- en: Implementing Design Patterns - Basics Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设计模式 - 基础部分 1
- en: In the previous two chapters, we introduced and defined a wide range of modern
    patterns and practices pertaining to the **software development life cycle** (**SDLC**),
    from lower-level development patterns to high-level solution architectural patterns.
    This chapter applies some of those patterns in a sample scenario in order to provide
    context and further understanding of the definitions. The scenario is the creation
    of a solution to manage the inventory of an e-commerce bookseller.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个章节中，我们介绍了并定义了一系列与现代软件开发生命周期（**SDLC**）相关的现代模式和最佳实践，从低级开发模式到高级解决方案架构模式。本章将这些模式应用于一个示例场景，以便提供上下文和进一步理解定义。该场景是创建一个解决方案来管理电子商务书店的库存。
- en: The scenario was chosen as it provides enough complexity to illustrate the patterns
    while the concept is relatively simple. The company needs a way of managing their
    inventory, including allowing users to order their products. The organization
    needs to get an application in place, as soon as possible, to allow them to track
    their inventory, but there are many additional features, including allowing customers
    to order products and provide reviews. As the scenario plays out, the number of
    features requested grows to the point where the development team does not know
    where to start. Fortunately, by applying some good practices to help manage the
    expectations and requirements, the development team is able to simplify their
    initial delivery and get back on track. Also, by using patterns, they are able
    to build a solid foundation in order to help the expansion of the solution as
    new features are added.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个场景是因为它提供了足够的复杂性来展示模式，而概念相对简单。公司需要一种管理其库存的方法，包括允许用户订购他们的产品。组织需要尽快部署一个应用程序，以便跟踪他们的库存，但还有许多其他功能，包括允许客户订购产品和提供评论。随着场景的发展，所需的功能数量增长到开发团队不知道从哪里开始的地步。幸运的是，通过应用一些良好的实践来帮助管理期望和要求，开发团队能够简化他们的初始交付并回到正轨。此外，通过使用模式，他们能够建立一个坚实的基础，以便在添加新功能时帮助扩展解决方案。
- en: 'This chapter will cover the kickoff of a new project and the creation of the
    first release of the application. The following patterns are illustrated in this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖新项目的启动和应用程序第一个版本的创建。本章展示了以下模式：
- en: '**Minimal Viable Product** (**MVP**)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小可行产品**（**MVP**）'
- en: '**Test-driven development** (**TDD**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）'
- en: Abstract Factory pattern (Gang of Four)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式（Gang of Four）
- en: SOLID principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID 原则
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释概念。代码保持简单，仅用于演示目的。大多数示例涉及用 C# 编写的 .NET Core 控制台应用程序。
- en: 'To run and execute the code, you need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，你需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    version 3 or later)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（你也可以使用 Visual Studio 2017 版本 3 或更高版本来运行应用程序）
- en: .NET Core
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: SQL Server (Express Edition is used in this chapter)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章使用的是 Express 版本）
- en: Installing Visual Studio
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual Studio
- en: 'To run these code examples, you need to install Visual Studio or you can use
    your preferred IDE. To do this, follow these instructions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，你需要安装 Visual Studio 或可以使用你喜欢的 IDE。为此，请遵循以下说明：
- en: 'Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循包含的安装说明。Visual Studio 安装有多种版本可用。在本章中，我们使用 Windows 版本的 Visual Studio。
- en: Setting up .NET Core
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 .NET Core
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装 .NET Core，你需要遵循以下说明：
- en: 'Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 .NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: 'Follow the installation instructions and related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装说明和相关库：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: 'The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete, so it is advisable to retrieve the source in order
    to run the examples: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub上获取。章节中展示的源代码可能并不完整，因此建议获取源代码以便运行示例：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3)。
- en: Minimum Viable Product
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小可行产品
- en: This section covers the initial phase of starting a new project to build a software
    application. This is sometimes referred to as a project kickoff or project launch,
    where the initial features and capabilities of the application are collected (in
    other words, requirement gathering).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了启动新项目以构建软件应用的初始阶段。这有时被称为项目启动或项目发布，其中收集了应用的基本功能和能力（换句话说，需求收集）。
- en: Many approaches, which can be viewed as patterns, exist for the determining
    the features of a software application. Best practices around how to effectively
    model, conduct interviews and workshops, brainstorm and other techniques are outside
    the scope of this book. Instead, one approach, Minimum Viable Product, is described
    to provide an example of what these patterns might contain.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多方法，可以被视为模式，用于确定软件应用的功能。关于如何有效地建模、进行访谈和研讨会、头脑风暴以及其他技术的最佳实践超出了本书的范围。相反，本书描述了一种方法，即最小可行产品（Minimum
    Viable Product），以提供一个这些模式可能包含的示例。
- en: The project is for a hypothetical situation where a company, FlixOne, wants
    to use an inventory management application to manage its growing collection of
    books. This new application will be used both by the staff to manage the inventory,
    and by customers to browse and create new orders. The application will need to
    be scalable, and, as an essential system to the business, it is planned to be
    used for a foreseeable future.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是一个假设情景，其中一家名为FlixOne的公司希望使用库存管理应用来管理其不断增长的书籍收藏。这个新应用将由员工用于管理库存，以及由客户用于浏览和创建新订单。该应用需要具备可扩展性，并且作为业务的关键系统，计划在未来可预见的时期内使用。
- en: The company is broadly broken down into *business users* and the *development
    team,* where business users are primarily concerned with the functionality of
    the system and the development team is concerned about satisfying the requirements,
    as well as keeping a tab on the maintainability of the system. This is a simplification;
    however, organizations are not necessarily so tidily organized, and individuals
    might not fit correctly into one classification or another. For example, a **Business
    Analyst** (**BA**) or **Subject Matter Expert** (**SME**) often represent both
    a business user and a member of the development team.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 公司大致分为*业务用户*和*开发团队*，其中业务用户主要关注系统的功能，而开发团队则关注满足需求，以及监控系统维护性。这是一个简化；然而，组织并不一定如此整洁地组织，个人可能不适合某一分类或另一分类。例如，**业务分析师**（**BA**）或**领域专家**（**SME**）通常既代表业务用户也是开发团队的一员。
- en: As this is a technical book, we will mostly view the scenario from the development
    team's perspective and discuss the patterns and practices used to implement the
    inventory management application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本技术书籍，我们将主要从开发团队的角度看待场景，并讨论用于实现库存管理应用的模式和最佳实践。
- en: Requirements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: Over the course of several meetings, the business and the development teams
    discussed the requirements of the new inventory management system. Progress toward
    defining a clear set of requirements was slow and the vision of the final product
    was not clear. The development team decided to pare down the enormous list of
    requirements to enough functionality that a key individual could start to record
    some inventory information. This would allow for simple inventory management and
    provide a basis that the business could extend upon. Each new set of requirements
    could then be added to the initial release.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在几次会议的过程中，业务和开发团队讨论了新库存管理系统的需求。定义清晰需求集的进展缓慢，最终产品的愿景并不明确。开发团队决定将庞大的需求列表缩减到足够的功能，以便关键个人可以开始记录一些库存信息。这将允许简单的库存管理，并为业务扩展提供一个基础。然后，可以将每个新的需求集添加到初始版本中。
- en: Minimum Viable Product (MVP)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最小可行产品（MVP）
- en: A Minimum Viable Product is the smallest set of features of an application that
    can still be released and have enough value for a user base.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最小可行产品（Minimum Viable Product，简称MVP）是指一个应用可以发布的最小功能集，它仍然具有足够的用户价值。
- en: An advantage of the MVP approach is it gives the business and development teams
    a simplified vision of what needs to be delivered by narrowing the scope of an
    application. By reducing the features that will be delivered, the effort in determining
    what needs to be done becomes more focused. In the FlixOne scenario, a meeting's
    value would often degrade into discussing the particulars of a feature that, although
    important for the final version of the product, would require several features
    to be released before it. For example, the design around a customer-facing website
    was distracting the team from focusing on the data to be stored in the inventory
    management system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: MVP方法的一个优点是它通过缩小应用的范围，为业务和开发团队提供了一个简化的交付视图。通过减少将要交付的功能，确定需要做什么的工作变得更加专注。在FlixOne场景中，会议的价值通常会降低到讨论一个特性的具体细节，尽管这对于产品的最终版本很重要，但需要在此特性之前发布几个功能。例如，围绕面向客户的网站的设计分散了团队对存储在库存管理系统中的数据的关注。
- en: MVP is very useful in situations where the complexity of requirements is not
    fully understood and/or the final vision is not well defined. It is important
    though to still maintain a product vision to avoid the risk of developing functionality
    that may not be required in the final version of the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MVP在需求复杂度不完全理解或最终愿景定义不明确的情况下非常有用。然而，仍然需要保持产品愿景，以避免开发最终版本可能不需要的功能的风险。
- en: 'The business and development teams were able to define the following functional
    requirements for the initial inventory management application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 业务和开发团队能够为初始库存管理应用定义以下功能需求：
- en: 'The application should be a console application:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用应该是一个控制台应用：
- en: It should print a welcome message that includes the version of the assembly.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该打印一个包含汇编版本的欢迎信息。
- en: It should loop until a quit command is given.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该循环直到接收到退出命令。
- en: If a given command is not successful or not understood, then it should print
    a helpful message.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定的命令不成功或未被理解，则应打印一条有用的信息。
- en: The application should respond to simple case-insensitive text commands.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用应该响应对简单的不区分大小写的文本命令。
- en: Each command should have a short form, of a single character, and a long form.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个命令都应该有一个简短形式，即单个字符，以及一个长形式。
- en: 'If a command has additional parameters:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果命令有附加参数：
- en: Each one should be entered in sequence and submitted with the return key.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个命令都应该按顺序输入，并通过回车键提交。
- en: Each one should have a prompt `Enter {parameter}:` where `{parameter}` is the
    name of the parameter.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个命令都应该有一个提示 `Enter {parameter}:`，其中 `{parameter}` 是参数的名称。
- en: 'A help command (`?`) should be available:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个帮助命令（`?`）可用：
- en: Prints a summary of the commands available.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印可用命令的摘要。
- en: Prints example usage of each command.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印每个命令的示例用法。
- en: 'A quit command (`q`, `quit`) should be available:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个退出命令（`q`，`quit`）可用：
- en: Prints a farewell message
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一条告别信息
- en: Ends the application
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束应用
- en: 'An add inventory command (`"a"`, `"addinventory"`) should be available:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个添加库存命令（`"a"`，`"addinventory"`）可用：
- en: The `name` parameter of type string.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`参数的类型为字符串。'
- en: It should add an entry into the database with the given name and a 0 quantity.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在数据库中添加一个具有给定名称和0数量的条目。
- en: 'An update quantity command (`"u"`, `"updatequantity"`) should be available
    :'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个更新数量命令（`"u"`，`"updatequantity"`）可用：
- en: The `name` parameter of type string.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串类型的`name`参数。
- en: The `quantity` parameter of a positive or negative integer.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`参数为正整数或负整数。'
- en: It should update the quantity value of the book with the given name by adding
    the given quantity.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该通过添加给定的数量来更新给定名称的书的数量值。
- en: 'A get inventory command (`"g"`, `"getinventory"`) should be available:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个获取库存命令（`"g"`，`"getinventory"`）可用：
- en: Returns all the books and their quantities in the database.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回数据库中所有书籍及其数量。
- en: 'And the following non-functional requirements were defined:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是非功能性需求定义：
- en: No security is required other than what was supplied by the operating system.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了操作系统提供的之外，不需要其他安全措施。
- en: The short form of a command is for usability while the long form of a command
    is for readability.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的简短形式是为了可用性，而命令的完整形式是为了可读性。
- en: The FlixOne example is an illustration of how MVP could be used to help focus
    and streamline the SDLC. It is worth emphasizing that the difference between a
    **Proof of Concept** (**PoC**) and an MVP will differ with each organization.
    In this book, a PoC is different from MVP in that the resulting application is
    not viewed as disposable or incomplete. For a commercial product, this would mean
    the end product could be sold, and for an internal enterprise solution, the application
    could add value to the organization.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne示例说明了如何使用MVP来帮助聚焦和简化软件开发生命周期（SDLC）。需要强调的是，**概念验证**（**PoC**）和MVP之间的区别会因每个组织而异。在这本书中，PoC与MVP的不同之处在于，生成的应用程序不被视为一次性或未完成的。对于一个商业产品，这意味着最终产品可以出售，而对于一个内部企业解决方案，应用程序可以为组织增加价值。
- en: How does MVP fit with future development?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVP如何与未来开发相匹配？
- en: Another benefit to using MVP to focus and contain requirements is its synergy
    with Agile software development. Breaking development cycles into smaller cycles
    of development is a software development technique that has gained popularity
    over traditional Waterfall development. The driving concept is that requirements
    and solutions evolve during the life cycle of an application and involve a collaboration
    between the development team and the end users. Typically, the agile software
    development framework has a short release cycle where new functionality is designed,
    developed, tested, and released. Release cycles are then repeated as the application
    includes additional functionality. MVP fits well within agile development when
    the scope of work fits within a release cycle.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVP来聚焦和限制需求的好处之一是其与敏捷软件开发的协同作用。将开发周期分解成更小的开发周期是一种在传统瀑布开发中越来越受欢迎的软件开发技术。其驱动概念是，需求和解决方案在应用程序的生命周期中演变，并涉及开发团队和最终用户之间的协作。通常，敏捷软件开发框架具有较短的发布周期，其中新功能被设计、开发、测试和发布。然后，随着应用程序包含更多功能，发布周期被重复。当工作范围适合发布周期时，MVP非常适合敏捷开发。
- en: Scrum and Kanban are popular software development frameworks based on agile
    software development.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum和Kanban是基于敏捷软件开发流行软件开发框架。
- en: The scope of the initial MVP requirements was kept to a size that could be designed,
    developed, tested, and released with an agile cycle. In the next cycle, additional
    requirements will be added to the application. The challenge is to limit the scope
    of new functionality to what can be accomplished within a cycle. Each new release
    of functionality is limited to essential requirements or to its MVP. The principle
    here is that, by using an iterative approach to software development, the final
    version of the application will have a greater benefit to the end user than by
    using a single release that requires all requirements to be defined up front.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 初始MVP需求范围被保持在可以设计、开发、测试和发布的大小，使用敏捷周期。在下一个周期中，将向应用程序添加更多需求。挑战是限制新功能的范围，使其在周期内可以完成。每个新功能发布都限于基本需求或其MVP。这里的原理是，通过使用迭代软件开发方法，应用程序的最终版本将比使用需要提前定义所有需求的单个发布版本对最终用户具有更大的好处。
- en: 'The following diagram sums up the difference between Agile and Waterfall software
    development methods:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了敏捷和瀑布软件开发方法之间的区别：
- en: '![](img/e56ad7fa-bc0c-4584-83f4-976b9a32daf3.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e56ad7fa-bc0c-4584-83f4-976b9a32daf3.png)'
- en: Test-driven development
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Different approaches to **test-driven development** (**TDD**) exist, and a *test*
    can vary from a unit test that is run on demand during development, to a unit
    test that is run during the build of a project, to a test script that will be
    run as a part of **user acceptance testing** (**UAT**). Similarly, a *test* can
    be code or a document describing the steps to be performed by a user in order
    to verify a requirement. A reason for this is that there are different views as
    to what TDD is trying to achieve. TDD for some teams is a technique to refine
    requirements before writing code, while others view TDD as a way of measuring
    or validating the code that is delivered.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着不同的**测试驱动开发**（**TDD**）方法，一个*测试*可以从在开发过程中按需运行的单元测试，到在项目构建期间运行的单元测试，再到作为**用户验收测试**（**UAT**）一部分运行的测试脚本。同样，一个*测试*可以是代码或描述用户为验证需求而要执行的步骤的文档。之所以如此，是因为人们对TDD试图实现的目标有不同的看法。对于某些团队来说，TDD是一种在编写代码之前细化需求的技术，而另一些团队则认为TDD是一种衡量或验证交付的代码的方式。
- en: UAT
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: UAT
- en: UAT is a term used for the activity during the SDLC where the product or project
    is verified to fulfill specified requirements. This is typically performed by
    members of the business or a selection of customers. Depending on the circumstances,
    this phase can be broken further into alpha and beta stages where alpha testing
    is performed by the development team and beta by the end users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: UAT是在SDLC（软件开发生命周期）期间用于验证产品或项目是否满足特定要求的活动术语。这通常由业务部门的成员或一部分客户执行。根据情况，这个阶段可以进一步细分为alpha和beta阶段，其中alpha测试由开发团队执行，beta测试由最终用户执行。
- en: Why did the team choose TDD?
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么团队选择了TDD？
- en: The development team decided to use TDD for several reasons. First, the team
    wanted a way to clearly measure progress during the development process. Second,
    they wanted to be able to reuse the tests in subsequent development cycles in
    order to continue to validate existing functionality while new functionality is
    added. For these reasons, the team will use unit tests to verify that the functionality
    written satisfies the given requirements of the team.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队决定使用TDD有几个原因。首先，团队希望有一种方法来清楚地衡量开发过程中的进度。其次，他们希望能够在后续的开发周期中重用测试，以便在添加新功能的同时继续验证现有功能。出于这些原因，团队将使用单元测试来验证编写的功能是否满足团队给出的要求。
- en: 'The following diagram illustrates the basics of TDD:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了TDD的基本原理：
- en: '![](img/4bfd18c6-4755-4bbf-8cf1-e0caff120847.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bfd18c6-4755-4bbf-8cf1-e0caff120847.png)'
- en: Tests are added and the code base is updated until all the defined tests pass.
    It is important to note that this is repeated. In each iteration, new tests are
    added and the tests are not considered passed until all tests, new and existing,
    pass.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加测试并更新代码库，直到所有定义的测试通过。重要的是要注意，这是一个重复的过程。在每次迭代中，都会添加新的测试，并且只有当所有测试（新的和现有的）都通过时，才认为测试通过。
- en: The FlixOne development team decided to incorporate both unit tests and UAT
    into a single agile cycle. At the beginning of each cycle, new acceptance criteria
    would be determined. This would include the functionality to be delivered, as
    well as how it would be verified or accepted at the end of the development cycle.
    These acceptance criteria would then be used to add tests to the project. The
    development team would then build the solution until the new and existing tests
    passed, and then prepare a build for acceptance testing. Then, the acceptance
    testing would be run, and if any issues were detected, the development team would
    define new tests or amend existing tests based on the failures. The application
    would be developed again until all tests passed and a new build would be prepared.
    This would be repeated until acceptance testing passed. Then, the application
    would be deployed and a new development cycle would begin.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne开发团队决定将单元测试和UAT整合到单个敏捷周期中。在每个周期的开始，都会确定新的验收标准。这包括要交付的功能以及如何在开发周期结束时验证或接受这些功能。然后，这些验收标准将被用来向项目添加测试。开发团队将构建解决方案，直到新的和现有的测试都通过，然后准备一个用于验收测试的构建。然后，将运行验收测试，如果发现任何问题，开发团队将根据失败情况定义新的测试或修改现有的测试。应用程序将再次开发，直到所有测试通过并准备新的构建。这将重复进行，直到验收测试通过。然后，应用程序将被部署，并开始新的开发周期。
- en: 'The following diagram illustrates this approach:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这种方法：
- en: '![](img/9798b545-4ea5-418d-91d5-5963745c9089.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9798b545-4ea5-418d-91d5-5963745c9089.png)'
- en: The team now has a plan, so let's start coding!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 团队现在有了计划，让我们开始编码吧！
- en: Setting up the projects
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: In this scenario, we will use the **Microsoft Unit Test** (**MSTest**) framework.
    This section provides some instructions to create the initial project using the
    .NET Core **command-line interface** (**CLI**) tools. These steps could have been
    completed using an **integrated development environment** (**IDE**) such as Visual
    Studio or Visual Studio Code. The instructions are supplied here to illustrate
    how the CLI can be used to complement the IDE.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，我们将使用**微软单元测试**（**MSTest**）框架。本节提供了一些使用 .NET Core **命令行界面**（**CLI**）工具创建初始项目的说明。这些步骤也可以使用
    Visual Studio 或 Visual Studio Code 等集成开发环境（**IDE**）完成。这里提供说明是为了说明如何使用 CLI 来补充
    IDE。
- en: CLI
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CLI
- en: '.NET Core CLI tools are cross-platform utilities for developing .NET applications
    and are the basis for more sophisticated tooling, such as IDEs. Please see the
    documentation for more information: [https://docs.microsoft.com/en-us/dotnet/core/tools](https://docs.microsoft.com/en-us/dotnet/core/tools).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core CLI 工具是用于开发 .NET 应用程序的跨平台实用工具，是更复杂工具（如 IDE）的基础。请参阅文档以获取更多信息：[https://docs.microsoft.com/en-us/dotnet/core/tools](https://docs.microsoft.com/en-us/dotnet/core/tools)。
- en: 'The solution for this chapter will consist of three projects: a console application,
    a class library, and a test project. Let''s create the solution directory, FlixOne,
    to contain the solution and sub-directories for the three projects. Within the
    created directory, the following command will create a new solution file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的解决方案将包括三个项目：一个控制台应用程序、一个类库和一个测试项目。让我们创建一个名为 FlixOne 的解决方案目录，以包含解决方案和三个项目的子目录。在创建的目录中，以下命令将创建一个新的解决方案文件：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot illustrates creating the directory and solution (note:
    only an empty solution file has been created so far):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了创建目录和解决方案（注意：到目前为止，只创建了一个空解决方案文件）：
- en: '![](img/c5472945-a2fe-4251-8d8a-7a9c1dd8b2c9.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5472945-a2fe-4251-8d8a-7a9c1dd8b2c9.png)'
- en: 'The class library, `FlixOne.InventoryManagement`, will contain our business
    entities and logic. In later chapters, we will split these into separate libraries
    but, as our application is still small, they are contained in a single assembly.
    The `dotnet` core CLI command to create the project is shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类库 `FlixOne.InventoryManagement` 将包含我们的业务实体和逻辑。在后面的章节中，我们将将这些内容拆分为单独的库，但由于我们的应用程序仍然很小，它们被包含在一个单独的程序集中。创建项目的
    `dotnet` 核心CLI命令如下所示：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note, in the following screenshot, that a new directory is created containing
    the new class library project file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在以下截图中，创建了一个包含新的类库项目文件的新目录：
- en: '![](img/7206ccd0-c6be-432b-bd5c-799896c79687.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7206ccd0-c6be-432b-bd5c-799896c79687.png)'
- en: 'References should be made from the solution to the new class library with the
    following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用以下命令从解决方案引用新的类库：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create a new console application project, the following command should be
    used:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的控制台应用程序项目，应使用以下命令：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the `console` template being restored:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了正在恢复的`控制台`模板：
- en: '![](img/d4670643-d4de-4934-b042-0772541e3e0d.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4670643-d4de-4934-b042-0772541e3e0d.png)'
- en: 'The console application requires a reference to the class library (note: the
    command needs to be run in the directory with the project file that will have
    the reference added to it):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序需要引用类库（注意：需要在包含要添加引用的项目文件所在的目录中运行此命令）：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A new `MSTest` project will be created using the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用以下命令创建一个新的 `MSTest` 项目：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the creation of the MSTest project and should
    be run in the same folder as the solution, FlixOne (note the packages restored
    as part of the command containing the required MSTest NuGet packages):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 MSTest 项目的创建，应在解决方案 FlixOne 的同一文件夹中运行（注意命令中恢复的包包含所需的 MSTest NuGet 包）：
- en: '![](img/f0e033e2-5bda-4b22-9b5e-5fa2600001ff.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0e033e2-5bda-4b22-9b5e-5fa2600001ff.png)'
- en: 'The test project also requires a reference to the class library (note: this
    command needs to be run in the same folder as the MSTest project file):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目也需要对类库的引用（注意：此命令需要在 MSTest 项目文件所在的同一文件夹中运行）：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, both the console application and the MSTest project should be added
    to the solution by running the following commands in the same directory as the
    solution file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在解决方案文件所在的同一目录中运行以下命令，将控制台应用程序和 MSTest 项目添加到解决方案中：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Visually, the solution is shown as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，解决方案如下所示：
- en: '![](img/7e47db76-ac52-4e8b-8866-1db9a03d4ebf.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e47db76-ac52-4e8b-8866-1db9a03d4ebf.png)'
- en: Now that the initial structure of our solution is ready, let's first start by
    adding to our unit test definitions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们解决方案的初始结构已经准备好了，让我们首先从添加单元测试定义开始。
- en: Initial unit test definitions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始单元测试定义
- en: 'The development team first transcribed the requirements into some basic unit
    tests. As nothing had been designed or written yet, these mostly take the form
    of noting what functionality should be validated. As the design and development
    progress, these tests will also evolve toward completion; for example, there is
    a requirement for adding inventory:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队首先将需求转录成一些基本的单元测试。由于还没有设计或编写任何内容，这些测试大多只是记录应该验证的功能。随着设计和开发的进展，这些测试也将向完成进化；例如，有一个添加库存的需求：
- en: 'An add inventory command ("a", "addinventory") is available:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的添加库存命令（"a"，"addinventory"）：
- en: The `name` parameter of type string.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串类型的`name`参数。
- en: Add an entry into the database with the given name and a `0` quantity.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定的名称和`0`数量将条目添加到数据库中。
- en: 'To capture this requirement, the development team created the following unit
    test to serve as a placeholder:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕捉这一需求，开发团队创建了以下单元测试作为占位符：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the application design becomes known and development starts, the existing
    tests will expand and new tests will be created, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序设计变得明确并且开发开始，现有的测试将扩展，新的测试将被创建，如下所示：
- en: '![](img/b2f6bef0-f8e8-481c-bc9c-83761e6bb255.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2f6bef0-f8e8-481c-bc9c-83761e6bb255.png)'
- en: The importance of the inconclusive tests is that they communicate what needs
    to be accomplished to the team and provide a measure as the development proceeds.
    As the development progresses, inconclusive and failing tests will indicate work
    to be undertaken and successful tests will indicate progress toward completing
    the current set of tasks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定测试的重要性在于它们向团队传达了需要完成的工作，并在开发过程中提供了一个衡量标准。随着开发的进展，不确定和失败的测试将表明需要开展的工作，而成功的测试将表明完成当前任务集的进展。
- en: Abstract Factory design pattern
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式
- en: 'To illustrate our first pattern, let''s walk through the development of the
    help command and the initial console application. The initial version of the console
    application is shown as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们的第一个模式，让我们回顾帮助命令和初始控制台应用程序的开发过程。初始控制台应用程序的版本如下所示：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the application starts, both a greeting and the result of a help command
    are shown. The application will then process entered commands until the quit command
    is entered.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，会显示问候语和帮助命令的结果。然后应用程序将处理输入的命令，直到输入退出命令。
- en: 'The following shows the detail of handling commands:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了处理命令的详细情况：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Until the application solution quits, the application will continue to prompt
    the user for command and, if a command was not successfully handled, then help
    text is shown.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 直到应用程序解决方案退出，应用程序将继续提示用户输入命令，如果命令未成功处理，则显示帮助文本。
- en: RunCommand(out bool shouldQuit)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: RunCommand(out bool shouldQuit)
- en: C# 7.0 introduces a more fluid syntax for creating `out` parameters. This will
    declare the variables in the scope of the command block. This is illustrated with
    the following, where the `shouldQuit` Boolean is not declared ahead of time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0 引入了一种更流畅的语法来创建`out`参数。这将声明命令块的变量作用域。以下示例说明了这一点，其中`shouldQuit`布尔值不是提前声明的。
- en: InventoryCommand abstract class
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommand 抽象类
- en: 'The first thing to point out about the initial console application is that
    the team is using **object-oriented programming** (**OOP**) to create a standard
    way of handling commands. What the team learned from this initial design is that
    all commands will contain a `RunCommand()` method that will return two Booleans
    indicating whether the command was successful and whether the program should terminate.
    For example, the `HelpCommand()` will simply display a help message to the console
    and should not cause the program to end. The two return Booleans would then be
    *true*, to indicate that the command ran successfully and *false,* to indicate
    that the application should not terminate. The following shows the initial version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要指出的是，初始控制台应用程序团队正在使用**面向对象编程**（**OOP**）来创建处理命令的标准方式。从这个初始设计中，团队学到的经验是所有命令都将包含一个`RunCommand()`方法，该方法将返回两个布尔值，指示命令是否成功以及程序是否应该终止。例如，`HelpCommand()`将简单地向控制台显示帮助信息，不应导致程序结束。这两个返回布尔值将是*true*，表示命令运行成功，*false*，表示应用程序不应终止。以下显示了初始版本：
- en: The ... indicates additional statements and, in this particular example, additional
    `Console.WriteLine()` statements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '... 表示额外的声明，在这个特定例子中，是额外的 `Console.WriteLine()` 声明。'
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `QuitCommand` will display a message and then cause the program to end.
    The initial `QuitCommand` was as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuitCommand` 将显示一条消息然后导致程序结束。最初的 `QuitCommand` 如下所示：'
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The team decided to either create an interface that both classes implement,
    or an abstract class that both classes inherit from. Both could have achieved
    the desired dynamic polymorphism but the team chose to use an abstract class as
    all commands will have shared functionality.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 团队决定创建一个两个类都实现的接口，或者一个两个类都继承的抽象类。两者都可以实现所需的动态多态，但团队选择使用抽象类，因为所有命令都将具有共享的功能。
- en: 'In OOP and in particular C#, polymorphism is supported in three main ways:
    function overloading, generics, and subtyping or dynamic polymorphism.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程，特别是在 C# 中，多态通过三种主要方式得到支持：函数重载、泛型和子类型或动态多态。
- en: 'Using the Abstract Factory Design pattern, the team created an abstract class
    that commands would inherit from, `InventoryCommand`. The `InventoryCommand` class
    has a single method, `RunCommand`, that will perform the command and return whether
    the command was successfully executed and whether the application should quit.
    The class is abstract, meaning the class contains one or more abstract methods.
    In this case, the `InternalCommand()` method is abstract and the intent is that
    classes deriving from the `InventoryCommand` class will implement the `InternalCommand`
    method with the specific command functionality. For example, `QuitCommand` will
    extend `InventoryCommand` and provide a concrete implementation for the `InternalCommand()`
    method. The following snippet shows the `InventoryCommand` abstract class with
    the abstract `InternalCommand()` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象工厂设计模式，团队创建了一个命令将继承的抽象类，`InventoryCommand`。`InventoryCommand` 类有一个单一的方法
    `RunCommand`，它将执行命令并返回命令是否成功执行以及应用程序是否应该退出。该类是抽象的，这意味着该类包含一个或多个抽象方法。在这种情况下，`InternalCommand()`
    方法是抽象的，意图是派生自 `InventoryCommand` 类的类将使用特定的命令功能实现 `InternalCommand` 方法。例如，`QuitCommand`
    将扩展 `InventoryCommand` 并为 `InternalCommand()` 方法提供具体实现。以下代码片段显示了具有抽象 `InternalCommand()`
    方法的 `InventoryCommand` 抽象类：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The abstract method would then be implemented in each derived class, as illustrated
    with the `HelpCommand`. The `HelpCommand` simply prints some information to the
    console and then returns `true`, indicating that the command was executed successfully:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法将在每个派生类中实现，如 `HelpCommand` 所示。`HelpCommand` 简单地打印一些信息到控制台，然后返回 `true`，表示命令已成功执行：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The development team then decided on making two additional changes to the `InventoryCommand`.
    The first thing they did not like was how the `shouldQuit` Boolean was being returned
    as an *out* variable. Thus, they decided to use the new tuples feature of C# 7
    to instead return a single `Tuple<bool,bool>` object as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队随后决定对 `InventoryCommand` 进行两项额外更改。他们不喜欢的是 `shouldQuit` 布尔值作为 *out* 变量返回的方式。因此，他们决定使用
    C# 7 的新元组功能，而是返回一个单一的 `Tuple<bool,bool>` 对象，如下所示：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tuple
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 元组
- en: The tuple is a C# type that provides a lightweight syntax for packaging multiple
    values into a single object easily. The disadvantage over defining a class is
    you lose inheritance and other object-oriented functionality. For more information,
    please see [https://docs.microsoft.com/en-us/dotnet/csharp/tuples](https://docs.microsoft.com/en-us/dotnet/csharp/tuples).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是 C# 类型，它提供了一种轻量级的语法，可以轻松地将多个值打包成一个单一的对象。与定义类相比的缺点是，你失去了继承和其他面向对象的功能。更多信息，请参阅
    [https://docs.microsoft.com/en-us/dotnet/csharp/tuples](https://docs.microsoft.com/en-us/dotnet/csharp/tuples)。
- en: The other change was to introduce another abstract class to indicate whether
    the command was a non-terminating command; in other words, a command that does
    not cause the solution to quit or end.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项更改是引入另一个抽象类来指示命令是否是非终止命令；换句话说，是一个不会导致解决方案退出或结束的命令。
- en: 'As shown in the following code, this command is still abstract as it does not
    implement the `InternalCommand` method of `InventoryCommand`, but it passes a
    false value to the base class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，此命令仍然是抽象的，因为它没有实现 `InventoryCommand` 的 `InternalCommand` 方法，但它向基类传递了一个
    false 值：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The advantage here is now commands that do not cause the application to end
    – in other words, are non-terminating – now have a simpler definition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势是现在不会导致应用程序结束的命令——换句话说，是非终止的——现在有了一个更简单的定义：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following class diagram shows the inheritance of the `InventoryCommand`
    abstract class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类图显示了`InventoryCommand`抽象类的继承关系：
- en: '![](img/bc1bd371-98d9-4fec-8acc-1f26d74eb3ac.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc1bd371-98d9-4fec-8acc-1f26d74eb3ac.png)'
- en: There is only one terminating command, `QuitCommand`, while the other commands
    extend the `NonTerminatingCommand` abstract class. It is also worth noting that
    only the `AddInventoryCommand` and `UpdateQuantityCommand` require parameters
    and the use of the `IParameterisedCommand` is explained later in the *Liskov Substitution
    Principle* section. Another subtle point in the diagram is that all the types,
    other than the base `InventoryCommand`, are not public (visible to external assemblies).
    This will become relevant in the *Access modifiers* section later in the chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个终止命令，即`QuitCommand`，而其他命令扩展了`NonTerminatingCommand`抽象类。还值得注意的是，除了基类`InventoryCommand`之外的所有类型都不是公开的（对外部程序集可见）。这一点将在本章后面的*访问修饰符*部分变得相关。图中另一个微妙之处在于，所有类型，除了基类`InventoryCommand`，都不是公开的（对外部程序集可见）。这一点将在本章后面的*访问修饰符*部分变得相关。
- en: SOLID principles
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: As the team simplifies the code by using patterns, they also use SOLID principles
    to help identify problems. By simplifying the code, the team aims to make the
    code more maintainable and easier for new team members to understand. This approach
    of reviewing the code with a set of principles is very useful in writing concise
    classes that only do what they need to achieve, and putting in a layer of abstraction
    that helps to write code that is easier to modify and understand.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模式简化代码，团队还使用SOLID原则来帮助识别问题。通过简化代码，团队旨在使代码更易于维护，并使新团队成员更容易理解。使用一组原则审查代码的方法在编写只做所需事情且具有抽象层的简洁类时非常有用，这有助于编写更容易修改和理解的代码。
- en: Single responsibility principle (SRP)
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: The first principle that the team applies is the **single responsibility principle**
    (**SRP**). The team identified that the actual mechanism of writing to the console
    is not the responsibility of the `InventoryCommand` classes. Because of this,
    a `ConsoleUserInterface` class is introduced that is responsible for the interaction
    with the user. SRP will help keep the `InventoryCommand` classes smaller and avoid
    situations where the same code is duplicated. For example, the application should
    have a uniform way of prompting the user for information and displaying messages
    and warnings. Instead of repeating this in the `InventoryCommand` classes, this
    logic is encapsulated in the `ConsoleUserInterface` class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 团队应用的第一条原则是**单一职责原则**（**SRP**）。团队确定将信息写入控制台的实际机制不是`InventoryCommand`类的责任。因此，引入了一个`ConsoleUserInterface`类，该类负责与用户的交互。SRP将帮助保持`InventoryCommand`类的大小，并避免代码重复的情况。例如，应用程序应该有一种统一的方式提示用户信息并显示消息和警告。而不是在`InventoryCommand`类中重复这些逻辑，这种逻辑被封装在`ConsoleUserInterface`类中。
- en: 'The `ConsoleUserInteraface` will consist of three methods, as indicated in
    the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleUserInteraface`将包含三个方法，如下所示：'
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first method will be used to read input from the console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法将用于从控制台读取输入：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second method will print a message to the console using the color green:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法将使用绿色在控制台打印一条消息：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final method will print a message to the console using a dark yellow color
    indicating a warning message:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的方法将以深黄色在控制台打印一条消息，表示警告信息：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the `ConsoleUserInterface` class, we can reduce the impact of changes to
    how we interact with the user. As our solution develops, we might find that the
    interface changes from a console to a web application. In theory, we would replace
    the `ConsoleUserInterface` with a `WebUserInterface`. If we had not reduced the
    user interface to a single class, the impact of such a change would most likely
    be more disruptive.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ConsoleUserInterface`类，我们可以减少我们与用户交互方式变化的影响。随着我们的解决方案的发展，我们可能会发现界面从控制台变为网络应用程序。理论上，我们将用`WebUserInterface`替换`ConsoleUserInterface`。如果我们没有将用户界面简化为单个类，这种变化的影响可能会更加破坏性。
- en: Open/closed principle (OCP)
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放/封闭原则（OCP）
- en: 'The **open/closed principle**, the O in SOLID, is represented by the different
    `InventoryCommand` classes. Instead of having an implementation of the `InventoryCommand`
    class per command, the team could have defined a single class containing multiple
    `if` statements. Each `if` statement would determine what functionality to execute.
    For example, the following illustrates how the team could have broken this principle:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**开闭原则**，SOLID中的O，由不同的`InventoryCommand`类表示。团队本可以定义一个包含多个`if`语句的单个类来替代每个命令的`InventoryCommand`类实现。每个`if`语句将确定要执行的功能。例如，以下说明了团队如何违反这一原则：'
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The above method breaks this principle because adding a new command would alter
    the behavior of the code. The idea of the principle is that it is **closed** to
    modification that would *alter* its behavior and instead is **open** to extend
    the class to support additional behavior. This is what is accomplished by having
    the abstract `InventoryCommand` and derived classes (for example, `QuitCommand`,
    `HelpCommand`, and `AddInventoryCommand`). A compelling reason for this, especially
    when combined with the other principles, is that it leads to succinct code that
    is easier to maintain and understand.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法违反了这一原则，因为添加新的命令会改变代码的行为。原则的想法是，它对会改变其行为的修改是**封闭**的，而相反，它是**开放**的，以扩展类以支持额外的行为。这是通过拥有抽象的`InventoryCommand`和派生类（例如，`QuitCommand`、`HelpCommand`和`AddInventoryCommand`）来实现的。特别是当与其他原则结合使用时，一个令人信服的原因是，它导致代码简洁，更容易维护和理解。
- en: Liskov substitution principle (LSP)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里氏替换原则（LSP）
- en: 'The commands for quit, help, and get inventory do not require parameters, while
    the `AddInventory` and `UpdateQuantityCommand` do. There are several ways to handle
    this and the team decided to introduce an interface to identify those commands
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 退出、帮助和获取库存的命令不需要参数，而`AddInventory`和`UpdateQuantityCommand`则需要。有几种处理方法，团队决定引入一个接口来识别这些命令，如下所示：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By applying the **Liskov substitution principle** (**LSP**), only those commands
    that require parameters should implement the `GetParameters()` method. For example,
    on the `AddInventory` command, the `IParameterisedCommand` is implemented using
    a method defined on the base `InventoryCommand`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用**里氏替换原则**（**LSP**），只有需要参数的命令应该实现`GetParameters()`方法。例如，在`AddInventory`命令中，`IParameterisedCommand`是通过在基类`InventoryCommand`上定义的方法实现的：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `GetParameter` method on the `InventoryCommand` class simply uses the `ConsoleUserInterface`
    to read a value from the console. The method will be shown later in this chapter.
    In C#, there is handy syntax that shows well how LSP can be used to apply functionality
    to only objects of a specific interface. On the first line of the `RunCommand`
    method, the `is` keyword is used to both test whether the current object implements
    the `IParameterisedCommand` interface as well as cast the object as a new object:
    `parameterisedCommand`. This is shown in bold in the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommand`类上的`GetParameter`方法简单地使用`ConsoleUserInterface`从控制台读取一个值。该方法将在本章后面展示。在C#中，有一种方便的语法可以很好地展示如何使用LSP将功能应用于特定接口的对象。在`RunCommand`方法的第
    一行，使用`is`关键字来测试当前对象是否实现了`IParameterisedCommand`接口，并将对象转换为新的对象：`parameterisedCommand`。这在以下代码片段中被加粗显示：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Interface segregation principle (ISP)
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则（ISP）
- en: 'One approach to handling commands with and without parameters would have been
    to define another method, `GetParameters`, on the `InventoryCommand` abstract
    class, and for those that do not require parameters to just return true to indicate
    that all, in this case no, parameters have been received. For example, the `QuitCommand`,
    `**HelpCommand**`, and `GetInventoryCommand` would all have an implementation
    similar to the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 处理带参数和不带参数的命令的一种方法是在`InventoryCommand`抽象类上定义另一个方法`GetParameters`，对于那些不需要参数的命令，只需返回true来表示已经接收到了所有（在这种情况下是没有）参数。例如，`QuitCommand`、`**HelpCommand**`和`GetInventoryCommand`都将有一个类似于以下实现的实现：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This would work but it does break the **interface segregation principle** (**ISP**),
    which states that an interface should only contain methods and properties that
    are required. Similar to SRP, which applies to classes, ISP applies to interfaces
    and is effective in keeping interfaces small and focused. In our example, only
    the `AddInventoryCommand` and `UpdateQuantityCommand` classes will implement the
    `InventoryCommand` interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，但它确实违反了**接口隔离原则**（**ISP**），该原则指出，一个接口应该只包含所需的方法和属性。类似于SRP，它适用于类，ISP适用于接口，并且有助于保持接口小而专注。在我们的例子中，只有`AddInventoryCommand`和`UpdateQuantityCommand`类将实现`InventoryCommand`接口。
- en: Dependency inversion principle
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The **dependency inversion principle** (**DIP**), also referred to as the **dependency
    injection** **principle** (**DIP**), modules should not depend on details but,
    instead, on abstractions. This principle encourages writing loosely coupled code
    to enhance both readability as well as maintenance, especially in a large complex
    code base.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**），也称为**依赖注入****原则**（**DIP**），模块不应该依赖于细节，而应该依赖于抽象。这个原则鼓励编写松耦合的代码，以提高可读性和维护性，尤其是在大型复杂代码库中。'
- en: 'If we revisit the `ConsoleUserInterface` class that was introduced earlier
    (in the *Single responsibility principle* section), we could use the class without
    the `QuitCommand` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下之前引入的`ConsoleUserInterface`类（在*单一职责原则*部分），我们可以使用该类而不使用`QuitCommand`，如下所示：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This breaks several SOLID principles, but in regards to DIP, it makes a tight
    coupling between the `QuitCommand` and the `ConsoleUserInterface`. Imagine the
    scenario where the console is no longer the means to display information to the
    user, or what if the constructor of the `ConsoleUserInterface` requires additional
    parameters?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这违反了几个SOLID原则，但在DIP方面，它使得`QuitCommand`和`ConsoleUserInterface`之间产生了紧密耦合。想象一下，如果控制台不再是向用户显示信息的方式，或者如果`ConsoleUserInterface`的构造函数需要额外的参数会怎样？
- en: By applying the DIP principle, the following refactor was performed. First a
    new interface, `IUserInterface`, was introduced that contained the definitions
    of the methods implemented in the `ConsoleUserInterface`. Next, the interface,
    and not the concrete class, is used in the `InventoryCommand` classes. Finally,
    a reference to an object implementing the `IUserInterface` is passed into the
    constructor of the `InventoryCommand` classes. This approach protects the `InventoryCommand`
    classes from changes to the implementation details of `IUserInterface` classes,
    as well as providing a mechanism for more easily replacing different implementations
    of `IUserInterface` as the code base evolves.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用DIP原则，进行了以下重构。首先引入了一个新的接口`IUserInterface`，其中包含了`ConsoleUserInterface`中实现的方法的定义。接下来，在`InventoryCommand`类中使用接口而不是具体类。最后，将实现`IUserInterface`的对象的引用传递到`InventoryCommand`类的构造函数中。这种方法保护了`InventoryCommand`类免受`IUserInterface`类实现细节变化的影响，同时也提供了一个机制，以便在代码库演变过程中更容易地替换不同的`IUserInterface`实现。
- en: 'The DIP is illustrated as follows with the `QuitCommand` and is our final version
    of the class for this chapter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用`QuitCommand`说明的DIP，这是本章的最终类版本：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the class extends the `InventoryCommand` abstract class, providing
    both a common way of handling commands, as well as providing shared functionality.
    The constructor requires the `IUserInterface` dependency to be injected when the
    object is instantiated. Also note the `QuitCommand` implements a single method,
    `InternalCommand()`, keeping the `QuitCommand` lean and easy to read and understand.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该类扩展了`InventoryCommand`抽象类，提供了处理命令的通用方式，同时也提供了共享功能。构造函数要求在对象实例化时注入`IUserInterface`依赖。另外，请注意`QuitCommand`实现了一个单独的方法`InternalCommand()`，这使得`QuitCommand`简洁且易于阅读和理解。
- en: 'To complete the picture, let''s view the final `InventoryCommand` base class.
    The following shows the constructor and properties:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整地展示，让我们查看最终的`InventoryCommand`基类。以下显示了构造函数和属性：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the `IUserInterface` is passed into the constructor as well as a Boolean
    indicating whether the command is terminating or not. The `IUserInterface` is
    then made available to all implementation of `InventoryCommand` as the `Interface`
    property.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IUserInterface`也被传递到构造函数中，以及一个布尔值，表示命令是否终止。然后，`IUserInterface`作为`Interface`属性对所有`InventoryCommand`的实现可用。
- en: 'The `RunCommand` is the only public method on the class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`RunCommand`是该类上的唯一公共方法：'
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Furthermore, the `GetParameter` method is a method common to all implementations
    of `InventoryCommand`, so it is made internal:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`GetParameter` 方法是 `InventoryCommand` 所有实现中通用的方法，因此它被设置为内部访问级别：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: DIP and IoC
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: DIP 和 IoC
- en: The DIP and **Inversion of Control** (**IoC**) are closely related and all address
    the same issues but in slightly different ways. IoC and its specialized form,
    the **Service Locator Pattern** (**SLP**), use a mechanism to supply an implementation
    of an abstraction on demand. So, instead of injecting the implementation, IoC
    acts as a proxy to supply the details that are required. In the next chapter,
    .NET Core support for these patterns will be explored.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: DIP（依赖倒置原则）和**控制反转**（IoC）密切相关，并且都解决了相同的问题，但以略微不同的方式。IoC 及其专用形式，**服务定位器模式**（SLP），使用一种机制按需提供抽象的实现。因此，而不是注入实现，IoC
    作为代理提供所需的详细信息。在下一章中，我们将探讨 .NET Core 对这些模式的支持。
- en: InventoryCommand unit tests
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommand 单元测试
- en: 'With the `InventoryCommand` classes taking shape, let''s revisit the unit tests
    so we can start to validate what has been written so far and identify any missing
    requirements. The SOLID principles will show their value here. Because we kept
    our classes (SRP) and interfaces (ISP) small, and focused on just the minimum
    amount of functionality required (LSP), our tests should also be simpler to write
    and validate. For example, a test regarding one of the commands will not need
    to validate the display of the messages on the console (for example, color or
    text size) as that is not the responsibility of the `InventoryCommand` classes
    but of the implementation of the `IUserInterface`. Also, with dependency injection,
    we will be able to isolate the test to just the inventory command. The following
    diagram illustrates this, as the unit test will only validate what is contained
    in the green box:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `InventoryCommand` 类的成形，让我们重新审视单元测试，以便我们可以开始验证到目前为止所写的内容，并识别任何缺失的需求。SOLID
    原则在这里将显示出其价值。因为我们保持了我们的类（SRP）和接口（ISP）的小型化，并专注于所需的最小功能（LSP），因此我们的测试也应该更容易编写和验证。例如，关于某个命令的测试不需要验证控制台消息的显示（例如，颜色或文本大小），因为这不是
    `InventoryCommand` 类的责任，而是 `IUserInterface` 实现的责任。此外，通过依赖注入，我们能够将测试隔离到仅针对库存命令。以下图表说明了这一点，因为单元测试将仅验证绿色框内的内容：
- en: '![](img/4cfda6fb-5968-451a-af94-5bee807667a1.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cfda6fb-5968-451a-af94-5bee807667a1.png)'
- en: By keeping the unit test's scope limited, it will be easier to handle change
    as the application changes. In some situations where it is more difficult to separate
    the functionality due to interdependencies within classes (in other words, when
    SOLID is not followed), a test can span a larger section of the application including
    repositories. These tests are usually referred to as integration tests instead
    of unit tests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制单元测试的范围，将更容易处理应用程序变化时的变更。在某些情况下，由于类之间的相互依赖性，分离功能可能更困难（换句话说，当不遵循 SOLID 原则时），测试可以跨越应用程序的更大部分，包括存储库。这些测试通常被称为集成测试而不是单元测试。
- en: Access modifiers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: Access modifiers are an important way of handling the visibility of types and
    type members by encapsulating code. By using a clear access strategy, the intent
    of how an assembly and its types should be used can be communicated and enforced.
    For example, in the FlixOne application, only types that should be accessed directly
    by the console are marked as public. This means that the console application should
    have visibility of a limited number of types and methods. These types and methods
    have been marked as public while types and methods that the console should not
    have access to, have been marked as internal, private, or protected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符是通过封装代码来处理类型和类型成员可见性的重要方式。通过使用清晰的访问策略，可以传达并强制执行程序集及其类型的使用意图。例如，在 FlixOne
    应用程序中，只有那些应该直接由控制台访问的类型被标记为公共。这意味着控制台应用程序应该只能看到有限数量的类型和方法。这些类型和方法被标记为公共，而那些控制台不应访问的类型和方法则被标记为内部、私有或受保护的。
- en: 'Please see the Microsoft docs programming guide for more information on access
    modifiers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 Microsoft 文档编程指南以获取有关访问修饰符的更多信息：
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)'
- en: The `InventoryCommand` abstract class is made public as the console application
    will use the `RunCommand` method to handle the command.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommand` 抽象类被公开，因为控制台应用程序将使用 `RunCommand` 方法来处理命令。'
- en: 'In the following snippet, note how the constructor and interface are made protected
    to give access to the sub-classes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，请注意构造函数和接口被设置为受保护的，以便子类可以访问：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the following snippet, note that the `RunCommand` method is made public
    while the `InternalCommand` is made internal:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，请注意 `RunCommand` 方法被公开，而 `InternalCommand` 被设置为内部使用：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similarly, the implementations of `InventoryCommand` are marked as internal
    to prevent them from being directly referenced outside of the assembly. This is
    illustrated as follows with the `QuitCommand`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`InventoryCommand` 的实现被标记为内部，以防止它们在程序集外部被直接引用。以下 `QuitCommand` 说明了这一点：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Because the access of the different implementations will not be visible directly
    to the unit test project, an additional step is required to make the internal
    types visible. The `assembly` directive could be placed in any compiled file and,
    for the FlixOne application, an `assembly.cs` was added containing the assembly
    attribute:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同实现方式的访问不会直接对单元测试项目可见，因此需要额外的步骤来使内部类型可见。`assembly` 指令可以放置在任何编译文件中，对于 FlixOne
    应用程序，添加了一个包含程序集属性的 `assembly.cs` 文件：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In situations where the assembly is signed, the `InternalsVisibleTo()` requires
    a public key. Please see the Microsoft Docs C# Guide for more information: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件签名的情况下，`InternalsVisibleTo()` 需要一个公钥。请参阅 Microsoft Docs C# 指南以获取更多信息：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies)。
- en: Helper TestUserInterface
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助测试用户界面
- en: 'As part of a unit test of one of the `InventoryCommand` implementations, we
    do not want to test the referenced dependencies. Fortunately, because the commands
    adhere to the DIP, we can create a `helper`class to validate the implementation
    interactions with the dependencies. One of the dependencies is the `IUserInterface`,
    which is passed into the implementation in the constructor. The following is a
    reminder of the methods of the interface:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对 `InventoryCommand` 实现之一单元测试的一部分，我们不想测试引用的依赖项。幸运的是，因为命令遵循 DIP，我们可以创建一个 `helper`
    类来验证实现与依赖项的交互。其中一个依赖项是 `IUserInterface`，它在构造函数中传递给实现。以下是对接口方法的提醒：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By implementing a `helper` class, we can supply the information required by
    the `ReadValue` method as well as verify that the appropriate messages are received
    in the `WriteMessage` and `WriteWarning` methods. In the test project, a new class
    called `TestUserInterface` was created that implements the `IUserInterface` interface.
    The class contains three lists containing the expected `WriteMessage`, `WriteWarning`,
    and `ReadValue` calls, and keeps track of the number of times it has been called.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个辅助类，我们可以提供 `ReadValue` 方法所需的信息，并验证在 `WriteMessage` 和 `WriteWarning` 方法中是否接收到了适当的消息。在测试项目中，创建了一个名为
    `TestUserInterface` 的新类，该类实现了 `IUserInterface` 接口。该类包含三个列表，包含预期的 `WriteMessage`、`WriteWarning`
    和 `ReadValue` 调用，并跟踪被调用的次数。
- en: 'For example, the `WriteWarning` method is shown as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`WriteWarning` 方法如下所示：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `WriteWarning` method performs two asserts. The first verifies that the
    method is not called more times than expected and the second verifies that the
    message received matches the expected message.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteWarning` 方法执行两个断言。第一个验证方法没有被调用超过预期次数，第二个验证接收到的消息与预期消息匹配。'
- en: 'The `ReadValue` method is similar but it additionally returns a value back
    to the calling `InventoryCommand` implementation. This will simulate the user
    entering information into the console:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadValue` 方法与之前的方法类似，但它还会将一个值返回给调用 `InventoryCommand` 实现的代码。这将模拟用户在控制台输入信息：'
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As an extra validation step, at the end of a test method, the `TestUserInterface`
    is called to verify that the expected number of `ReadValue`, `WriteMessage`, and
    `WriteWarning` requests were received:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的验证步骤，在测试方法结束时，调用 `TestUserInterface` 以验证是否接收到了预期的 `ReadValue`、`WriteMessage`
    和 `WriteWarning` 请求次数。
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `TestUserInterface` class illustrates how a dependency can be mocked to
    provide stubbed functionality as well as provide assertions to help verify the
    expected behavior. In later chapters, we will use a third-party package to provide
    a more sophisticated framework for mocking the dependencies.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestUserInterface` 类说明了如何模拟依赖关系以提供模拟功能，并提供断言以帮助验证预期的行为。在后面的章节中，我们将使用第三方包来提供一个更复杂的框架来模拟依赖关系。'
- en: Example unit test – QuitCommand
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例单元测试 – QuitCommand
- en: 'Starting with the `QuitCommand`, the requirements are pretty straightforward:
    the command should print a farewell message and then cause the application to
    end. We have designed the `InventoryCommand` to return two Booleans to indicate
    whether the application should quit and whether the command ended successfully:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `QuitCommand` 开始，需求相当直接：命令应该打印一条告别信息，然后导致应用程序结束。我们设计了 `InventoryCommand` 来返回两个布尔值，以指示应用程序是否应该退出以及命令是否成功结束：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The test uses the `TestUserInterface` to verify that the text `"Thank you for
    using FlixOne Inventory Management System"`is sent to the `WriteMessage` method
    and no `ReadValue` or `WriteWarning` requests are received. These last two criteria
    are verified by the `expectedInterface.Validate()` call. The result of the `QuitCommand`
    is verified by checking that the `shouldQuit` and `wasSuccessful` Booleans are
    true.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用 `TestUserInterface` 来验证文本 `"感谢您使用 FlixOne 库存管理系统"` 被发送到 `WriteMessage`
    方法，并且没有收到 `ReadValue` 或 `WriteWarning` 请求。后两个标准是通过 `expectedInterface.Validate()`
    调用来验证的。`QuitCommand` 的结果是通过检查 `shouldQuit` 和 `wasSuccessful` 布尔值是否为真来验证的。
- en: In the FlixOne scenario, the text to be shown is *hardcoded* in the solution
    for simplicity. A better approach would be to use resource files. Resource files
    provide a way of maintaining the text separate from the functionality as well
    as supporting localizing the data for different cultures.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FlixOne 场景中，为了简化，要显示的文本在解决方案中是*硬编码*的。更好的方法是将使用资源文件。资源文件提供了一种将文本与功能分离的维护方式，同时也支持对不同文化的数据进行本地化。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the scenario of an online bookseller, FlixOne, wanting
    to build an application for managing their inventory. The chapter covered a range
    of patterns and practices that the development team can use while developing the
    application. The team used MVP to help keep the scope of the initial delivery
    to a manageable level and to help focus the business onto determining the requirements
    that had the maximum benefit to the organization. The team decided to use TDD
    to validate that the delivery matches the requirements and to help the team measure
    progress. The basic project, as well as the unit testing framework, MSTest, was
    created. The team also used SOLID principles to help structure the code in a way
    that will both help readability as well as the maintenance of the code base, as
    new enhancements to the application are added. The first Gang of Four pattern,
    the Abstract Factory design pattern, was used to provide a base for all inventory
    commands.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在线书店 FlixOne 想要构建一个用于管理其库存的应用程序的场景。本章涵盖了开发团队在开发应用程序时可以使用的一系列模式和最佳实践。团队使用
    MVP 来帮助将初始交付的范围控制在可管理的水平，并帮助业务专注于确定对组织最有益的需求。团队决定使用 TDD 来验证交付是否符合需求，并帮助团队衡量进度。创建了基本项目和单元测试框架
    MSTest。团队还使用了 SOLID 原则来帮助以有助于可读性和代码库维护的方式结构化代码，因为应用程序的新增强功能被添加。第一个四人帮模式，即抽象工厂设计模式，被用来为所有库存命令提供一个基础。
- en: In the next chapter, the team will continue to build the initial inventory management
    project to fit the requirements defined in the MVP. The Gang of Four's Singleton
    pattern and the Factory Method pattern will be used by the team. These will be
    shown both with and without the mechanisms supported in .NET Core for these features.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，团队将继续构建初始库存管理项目，以满足 MVP 中定义的需求。团队将使用四人帮的 Singleton 模式和 Factory Method
    模式。这些模式将展示有和无 .NET Core 支持的这些功能的机制。
- en: Questions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: In developing software for an organization, why is it sometimes difficult to
    determine requirements?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为组织开发软件时，为什么有时难以确定需求？
- en: What are two advantages and disadvantages of Waterfall software development
    versus Agile software development?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水晶球软件开发与敏捷软件开发相比，有哪些优点和缺点？
- en: How does dependency injection help when writing unit tests?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖注入在编写单元测试时是如何帮助的？
- en: Why is the following statement false? With TDD, you no longer need people to
    test a new software deployment.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下陈述是错误的？在使用TDD（测试驱动开发）时，你不再需要人们来测试新的软件部署。
