<html><head></head><body>
		<div id="_idContainer043">
			<h1 id="_idParaDest-54"><em class="italic"><a id="_idTextAnchor053"/>Chapter 3</em>: Predefined Data Types and Memory Allocations</h1>
			<p>In this chapter, you will learn about <strong class="bold">C#</strong> predefined (that is, <em class="italic">built-in</em>) data types and C# object types, along with the different types of <strong class="bold">memory allocations</strong>.</p>
			<p>The most basic requirement for improving the performance of your application is to understand the predefined data types and their sizes. There may be times when the memory usage of your applications is critical. Knowing the size of data types and the values they hold can help you make accurate memory usage estimates, as do memory profiling tools such as <strong class="bold">dotTrace</strong> and <strong class="bold">dotMemory</strong>, which are developed by <strong class="bold">JetBrains</strong>. We will be discussing the use of dotTrace and dotMemory in the next chapter. It also makes sense to know the different types of memory allocations and how they affect your code performance. Here, we will be benchmarking the performance of various operations using <strong class="bold">BenchmarkDotNet</strong>.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li><strong class="bold">Understanding the predefined .NET data types</strong>: In this section, we will perform a review of the C# value and object types that are built into the C# programming language. Understanding these types and their size in bytes is useful when you need to provide memory usage estimates.</li>
				<li><strong class="bold">Understanding the various types of memory used in C#</strong>: In this section, we delve into the different types of memory used in C#, including the <em class="italic">stack</em>, <em class="italic">heap</em>, <em class="italic">small object heap</em>, and <em class="italic">large object heap</em>. It is useful to know what data gets stored in memory and how it gets stored. This can have a big effect on the performance of your applications. For instance, did you know that value types do not always get stored on the stack?</li>
				<li><strong class="bold">Passing by value and passing by reference</strong>: In this section, we will cover the differences between passing values by value and by reference, and the effects this has on the original variables. You will also understand how passing by value and by reference work in memory.</li>
				<li><strong class="bold">Boxing and unboxing:</strong> In this section, we will discuss what happens in memory when we <em class="italic">box</em> and <em class="italic">unbox</em> a variable, and we will explore how boxing and unboxing negatively impact the performance of programs. You will use the disassembler to view the intermediate language commands that perform the boxing and unboxing.</li>
			</ul>
			<p>By the end of this chapter, you will have the skills to do the following:</p>
			<ul>
				<li>You will understand the different value type sizes.</li>
				<li>You will understand the different reference types.</li>
				<li>You will understand the different types of memory and how they are allocated.</li>
				<li>You will understand the difference between passing by values and passing by references.</li>
				<li>You will understand how boxing and unboxing negatively impact performance and why.</li>
			</ul>
			<p>We will first look at the technical requirements for following along with this chapter, then, we will move on to look at the various predefined C# data types.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Technical requirements</h1>
			<ul>
				<li>Required: <strong class="bold">Microsoft</strong> <strong class="bold">Visual Studio</strong> <strong class="bold">2022</strong>, latest version – preview</li>
				<li>Required: BenchmarkDotNet</li>
			</ul>
			<p>The code files for this chapter can be found in this book's GitHub repository: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH03">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH03</a></p>
			<p>You will need to clone the git repository and do a release build. The compiled executable will be found under C:\Development\perfview\src\PerfView\bin\Release\net45.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Understanding the predefined .NET data types</h1>
			<p>There<a id="_idIndexMarker182"/> are two<a id="_idIndexMarker183"/> types of predefined data types: </p>
			<ul>
				<li><strong class="bold">Reference types</strong> </li>
				<li><strong class="bold">Value types</strong></li>
			</ul>
			<p>The reference types are objects and strings. The value types consist of enumeration and struct types. Struct types are aggregated of simple types. Simple types consist of Boolean, char, and numeric types.</p>
			<p>There are three main numeric types: decimal types, floating-point types, and integer types. Floating-point types consist of decimals, doubles, and floats. The integer types consist of bytes shorts, integers, longs, value tuples, and characters.</p>
			<p>We are going to mention the stack and the heap in more detail later in the chapter. But for now, we should understand that the stack is <em class="italic">unmanaged</em> memory, and the heap is <em class="italic">managed</em> memory.</p>
			<p>Value types live on the stack. Value types in arrays live on the heap. And reference types live on the heap, with their pointers living on the stack. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Even if arrays are not ideal for some scenarios, in most cases, arrays will often perform faster than lists and other data structures. Array contents are placed contiguously on the heap. The variable for the array will be placed on the stack, and its contents on the stack will be a pointer to the memory address of the array on the heap.</p>
			<p>The stack and the heap are the two main types of memory in <strong class="bold">.NET</strong>, and as mentioned, we will be covering them later in this chapter.</p>
			<p>Now, let's look at the predefined value types in C#.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Understanding the predefined value types in C#</h2>
			<p>In this <a id="_idIndexMarker184"/>section, we <a id="_idIndexMarker185"/>will describe each predefined value type and its size in bytes. This is important for being able to choose the right data type to improve the memory performance of your applications. For those who are new to C#, you should know that <em class="italic">signed</em> data types are those data types that can have <em class="italic">positive</em> and <em class="italic">negative</em> values, whereas <em class="italic">unsigned</em> data types are those that can have only <em class="italic">positive</em> values.</p>
			<p><em class="italic">Table 3.1</em> describes the different value types, their memory size, whether they are nullable, and<a id="_idIndexMarker186"/> their <a id="_idIndexMarker187"/>default, minimum, and maximum values, as well as providing notes where applicable:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Table_3.1_B16617.jpg" alt="Table 3.1 – The predefined value data types in C#&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 3.1 – The predefined value data types in C#</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">enum</strong> data type is 4 bytes (that is, 32 bits) in size, nullable, and has a minimum value of <strong class="source-inline">0</strong>. You can measure the size of a value type using <strong class="source-inline">sizeof(Type type)</strong>. Custom structs can be measured using <strong class="source-inline">Marshal.SizeOf(typeof(NameOfCustomStruct))</strong>. The <strong class="source-inline">ValueTuple</strong> data type is 1 byte (8 bits) in size and grows with each type parameter. For example, <strong class="source-inline">ValueTuple&lt;double, double, double&gt;</strong> is 24 bytes (192 bytes) in size. </p>
			<p>We <a id="_idIndexMarker188"/>will <a id="_idIndexMarker189"/>now look at understanding the predefined reference types in C#.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Understanding the predefined reference types in C#</h2>
			<p>A <strong class="bold">reference type</strong> is a <a id="_idIndexMarker190"/>type that is placed in managed <a id="_idIndexMarker191"/>memory <a id="_idIndexMarker192"/>called the <strong class="bold">managed heap</strong>. The four predefined reference types in C# are the object type, string type, delegate type, and dynamic type. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Unfortunately, with reference types, you cannot use <strong class="source-inline">sizeof</strong> (which is of the object type) to get the size of a reference type, and the <strong class="source-inline">BinaryFormatter</strong> class has been made obsolete. That means that you cannot serialize an object into binary, save it into a memory stream, and get its size from the memory stream's position.</p>
			<p class="callout">We are, however, recommended to serialize and deserialize <a id="_idIndexMarker193"/>objects using <strong class="bold">JSON</strong>. We can then assign the JSON to a memory stream, and in doing so, the length of the memory stream will give us the size of our object in memory.</p>
			<p>Let's look at each of these in turn in terms of memory usage.</p>
			<h3>Describing the object reference type</h3>
			<p>The .NET <strong class="source-inline">System.Object</strong> type<a id="_idIndexMarker194"/> is aliased as object in C#. All types in C# either directly or indirectly inherit from <strong class="source-inline">System.Object</strong>. This includes predefined and user types (such as classes, enums, and structs), reference types, and value types. Objects can be nullable.</p>
			<p>To obtain the memory size of your objects programmatically, serialize them to <strong class="bold">XML</strong> or JSON and load them into a memory stream, and the length of the memory stream will give you your object size in bytes. Alternatively, you can profile the memory of your application using a tool such as dotMemory to profile your application's memory usage.</p>
			<h3>Describing the string reference type</h3>
			<p>A <strong class="source-inline">string</strong> type uses 2 bytes (16 bits) for<a id="_idIndexMarker195"/> each character. So, our famous little <strong class="source-inline">string</strong>, <em class="italic">Hello, World!</em>, which uses 13 characters, is 13 x 2 bytes long, which equates to 26 bytes (208 bits) of memory. Strings can be nullable, and they can be empty.</p>
			<p>Strings are immutable in .NET. But what do we mean by this?</p>
			<p>When you create a <strong class="source-inline">string</strong> type, it is added to the heap. A variable is added to the stack that has an address pointer to the string's location on the heap. If you add the <strong class="source-inline">string</strong> type to another variable, that variable will be placed on the stack, and it will hold a copy of the address of the same string on the heap. But if you append an existing <strong class="source-inline">string</strong> type with another <strong class="source-inline">string</strong> type, a new <strong class="source-inline">string</strong> type is created in memory to hold the existing <strong class="source-inline">string</strong> type, plus the <strong class="source-inline">string</strong> type to be appended. The address pointer for the <strong class="source-inline">string</strong> type is updated on the stack to point to this new location.</p>
			<h4>Building an immutable string example program</h4>
			<p>We are going <a id="_idIndexMarker196"/>to write a simple <strong class="bold">.NET</strong> <strong class="bold">6</strong> console application that demonstrates the immutability of strings. Start by creating a new .NET 6 console application called <strong class="source-inline">CH03_StringsAreImmutable</strong>. Then, update the <strong class="source-inline">Main(string[] _)</strong> method as follows:</p>
			<pre class="source-code">static void Main(string[] _)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">Console.WriteLine("Chapter 3: Strings are immutable");</pre>
			<pre class="source-code">var greeting1 = "Hello, world!";</pre>
			<pre class="source-code">var greeting2 = greeting1;</pre>
			<pre class="source-code">Console.WriteLine($"greeting1={greeting1}");</pre>
			<pre class="source-code">Console.WriteLine($"greeting2={greeting2}");</pre>
			<pre class="source-code">greeting1 += " Isn't life grand!";</pre>
			<pre class="source-code">Console.WriteLine($"greeting1={greeting1}");</pre>
			<pre class="source-code">Console.WriteLine($"greeting1={greeting2}");</pre>
			<pre class="source-code">}</pre>
			<p>We output a header to the console, and then we set the <strong class="source-inline">greeting1</strong> <strong class="source-inline">string</strong> type to <strong class="source-inline">"Hello, world!"</strong>. Then, we assign <strong class="source-inline">greeting1</strong> to the <strong class="source-inline">string</strong> <strong class="source-inline">greeting2</strong> type. The contents of both <strong class="source-inline">string</strong> variables are output to the console window. We then amend <strong class="source-inline">greeting1</strong> by appending <strong class="source-inline">" Isn't life grand!"</strong> to the end of it. Next, we output the contents of both <strong class="source-inline">greeting1</strong> and <strong class="source-inline">greeting2</strong>. Run the program, and you should see the following:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_3.1_B16617.jpg" alt="Figure 3.1 – The immutable strings example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The immutable strings example</p>
			<p>As you can see, although we assigned <strong class="source-inline">greeting1</strong> to <strong class="source-inline">greeting2</strong> and then updated <strong class="source-inline">greeting1</strong>, <strong class="source-inline">greeting2</strong> remains unchanged. So, we now have two strings on the heap. We have <strong class="source-inline">"Hello, world!"</strong>, and we have <strong class="source-inline">"Hello, world! Isn't life grand!"</strong>. And so, from our little example, we can see that strings are indeed immutable. And<a id="_idIndexMarker197"/> now, we will describe the <strong class="source-inline">delegate</strong> reference type.</p>
			<h3>Describing the delegate reference type</h3>
			<p>A <strong class="bold">delegate</strong> reference <a id="_idIndexMarker198"/>type points to methods with specific parameters and returns types. Methods referred to by the <strong class="source-inline">delegate</strong> type must have the same signature and return type. When you compile code that uses delegates, a private sealed class is created for the delegate that inherits from <strong class="source-inline">System.MulticastDelegate</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please check <em class="italic">section I.8.9.3</em> in the<a id="_idIndexMarker199"/> following link for more information on delegates: <a href="https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf">https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf</a>.</p>
			<p>We will now<a id="_idIndexMarker200"/> describe the <strong class="source-inline">dynamic</strong> reference type.</p>
			<h3>Describing the dynamic reference type</h3>
			<p>Type checking is<a id="_idIndexMarker201"/> performed at compile time. This ensures type safety when your applications are executed at runtime. Type safety aims to prevent erroneous or undesirable program behavior that is caused by discrepancies between types.</p>
			<p>Types that are defined as <strong class="source-inline">dynamic</strong> bypass type checking at compile time, as they and the members are resolved at runtime. The advantage of the <strong class="source-inline">dynamic</strong> type is that it simplifies our access to COM APIs (such <a id="_idIndexMarker202"/>as the <strong class="bold">Office Automation</strong> API) to dynamic APIs (such <a id="_idIndexMarker203"/>as the <strong class="bold">IronPython</strong> libraries) and to<a id="_idIndexMarker204"/> the HTML <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>).</p>
			<p>Dynamic types are compiled as objects and exist as objects at runtime. A <strong class="source-inline">dynamic</strong> type only exists at compile time and not at runtime. When a <strong class="source-inline">dynamic</strong> type is compiled, it becomes an <strong class="source-inline">object</strong> type. Later in this section, and after we have written and built our console application, we will use ILDASM to show the IL type of a compiled dynamic variable.</p>
			<p>When the object runs for the first time, it is correctly resolved by the runtime. This resolution incurs a performance penalty that can be considerable depending upon the type being resolved. Since <strong class="source-inline">dynamic</strong> is compiled into an object, boxing and unboxing take place. And as you know, boxing costs processor cycles. </p>
			<p>Let's demonstrate the performance difference when using different variations of <strong class="source-inline">var</strong> and <strong class="source-inline">dynamic</strong> when we are declaring variables and assigning values to them, compared to using the correct types and assigning them without having to use casting.</p>
			<p>Start a new .NET 6 console application called <strong class="source-inline">CH03_DynamicPerformance</strong>.  You will need the following references:</p>
			<pre class="source-code">using System;</pre>
			<pre class="source-code">using System.Diagnostics;</pre>
			<pre class="source-code">using System.Security.Cryptography;</pre>
			<pre class="source-code">using BenchmarkDotNet.Attributes;</pre>
			<pre class="source-code">using BenchmarkDotNet.Running;</pre>
			<p>Add a new member variable at the top of the <strong class="source-inline">Program</strong> class:</p>
			<pre class="source-code">dynamic _dynamicType;</pre>
			<p>This variable declaration will be investigated by using ILDASM after we have run our benchmarks. Next, update the <strong class="source-inline">Main(string[] _)</strong> method as follows:</p>
			<pre class="source-code">static void Main(string[] _)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      BenchmarkRunner.Run&lt;BenchmarkTests&gt;();</pre>
			<pre class="source-code">}</pre>
			<p>We are running<a id="_idIndexMarker205"/> the benchmarking tests in a class called <strong class="source-inline">BenchmarkTests</strong>. Add a new class called <strong class="source-inline">BenchmarkTests</strong> by using the same statements as the preceding example. Then, add the <strong class="source-inline">MeasureVarUsage()</strong> method:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void MeasureVarUsage()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      var x = 3.14159;</pre>
			<pre class="source-code">}</pre>
			<p>This method assigns a <strong class="source-inline">double</strong> object to the <strong class="source-inline">x</strong> variable of a type that will be resolved at runtime. Next, add the <strong class="source-inline">MeasureVarDynamicUsage()</strong> method:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void MeasureVarDynamicUsage()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      var x = (dynamic)3.14159;</pre>
			<pre class="source-code">}</pre>
			<p>Here, we are still assigning a number to the <strong class="source-inline">x</strong> variable of a type that will be resolved at runtime. But this time, we prefix the number with the <strong class="source-inline">(dynamic)</strong> cast. Remember that the <strong class="source-inline">dynamic</strong> keyword only exists at compile time. When compiled, <strong class="source-inline">dynamic</strong> types become the <strong class="source-inline">object</strong> type. Now, add the <strong class="source-inline">MeasureTypeDynamicUsage()</strong> method:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void MeasureTypeDynamicUsage()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      double x = (dynamic)3.14159;</pre>
			<pre class="source-code">}</pre>
			<p>This time, we<a id="_idIndexMarker206"/> declare the variable as <strong class="source-inline">double</strong> and cast the assigned number as <strong class="source-inline">(dynamic)</strong>. At runtime, this number will be boxed in an <strong class="source-inline">object</strong> type, and so it will need to be unboxed. And for our final method, add the <strong class="source-inline">MeasureTypeTypeUsage()</strong> method:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void MeasureTypeTypeUsage()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      double x = 3.14159;</pre>
			<pre class="source-code">}</pre>
			<p>In this method, we declare a <strong class="source-inline">double</strong> type and assign a <strong class="source-inline">double</strong> type. Compile the project in Release mode. Then, open a command line and navigate to your release folder. Type the name of the executable and press <em class="italic">Enter</em>. This will cause BenchmarkDotNet to detect the benchmarks within the project and sequentially run through them. You should see a summary similar to the following, albeit with different mean times:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_3.2_B16617.jpg" alt="Figure 3.2 – The variable type declaration and the assignment's benchmarked mean timings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – The variable type declaration and the assignment's benchmarked mean timings</p>
			<p><em class="italic">Figure 3.2</em> shows us that there are differences in performance when we declare variables and assign values depending on the methods we use. The fastest combination of declaration and assignment is <strong class="source-inline">var variableName = (dynamic)value</strong>. </p>
			<p>Well, we have run our benchmark tests. So, let's view the IL code for the dynamic variable. Open<a id="_idIndexMarker207"/> the developer command prompt, then type <strong class="source-inline">ildasm.exe</strong> and press <em class="italic">Enter</em>. This will start the ILDASM application. </p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">.NET Core</strong> and <strong class="bold">.NET 6</strong> applications <a id="_idIndexMarker208"/>are <a id="_idIndexMarker209"/>compiled differently from previous <a id="_idIndexMarker210"/>versions of the <strong class="bold">.NET Framework</strong>. Previously, ILDASM would open the compiled executable. But .NET Core and .NET 6 applications get<a id="_idIndexMarker211"/> compiled into a <strong class="bold">dynamic-link library</strong> (<strong class="bold">DLL</strong>), and a native executable is produced to run the code in the resulting DLL.</p>
			<p>Open your compiled DLL. Expand the <strong class="source-inline">CH03_DynamicPerformance</strong> node and then expand the <strong class="source-inline">CH03_DynamicPerformance.Program</strong> node. Then, locate the <strong class="source-inline">_dynamicType : private object</strong> line call, as shown in <em class="italic">Figure 3.3</em>:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_3.3_.jpg" alt="Figure 3.3 – ILDASM showing us that the compiler converts a dynamic type into an object type at compile time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – ILDASM showing us that the compiler converts a dynamic type into an object type at compile time</p>
			<p>As you can see, our <strong class="source-inline">dynamic</strong> type gets compiled into an <strong class="source-inline">object</strong> type. As a little exercise, play <a id="_idIndexMarker212"/>about with the ILDASM settings and view the code for the <strong class="source-inline">BenchmarkTests</strong> class for yourself. Now, let's look at static types.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Understanding static types</h2>
			<p>In .NET versions <a id="_idIndexMarker213"/>earlier than .NET Core and <strong class="bold">.NET</strong> <strong class="bold">5.0</strong>, when you compile and run your applications, they run in their own application domains. If you run your applications multiple times, each running instance of your application will have its own app domain. In <strong class="bold">ASP.NET</strong>, you use<a id="_idIndexMarker214"/> multiple app domains for a single application. This becomes important when using static types in ASP.NET applications. In a single app domain, there will only be one instance of a static type. The runtime must create an instance of the static type before it can be used.</p>
			<p>The <strong class="source-inline">AppDomain</strong> object has its own static heap. Static value and reference types will be placed on the static heap and managed by the app domain. Static types are considered by the garbage collector, but they are never collected. The reason the garbage collector considers them is that they may have references to objects on other heaps. Static types and variables in other app domains are isolated from each other.</p>
			<p>In <strong class="bold">.NET</strong> <strong class="bold">Native</strong> and .NET 5.0, application<a id="_idIndexMarker215"/> domains have been discontinued as they require expensive runtime support. Developers use application domains for various purposes, including code isolation. It is recommended by Microsoft to replace the use of application domains with processes and/or containers. Microsoft also recommends the new <strong class="source-inline">AssemblyLoadContext</strong> class for the dynamic loading of assemblies. By <em class="italic">processes and/or containers</em>, Microsoft means that you should split your single applications/modules into separate, interacting applications/modules/processes/containers. So, you are encouraged by Microsoft to refactor code <a id="_idIndexMarker216"/>using microservices so that you no longer need to use application domains.</p>
			<p>The <strong class="source-inline">System.Runtime.Loader.AssemblyLoadContext</strong> object represents a load context. A <em class="italic">load context</em> creates<a id="_idIndexMarker217"/> a scope for loading, resolving, and unloading assemblies. For more information on the <strong class="source-inline">AssemblyLoadContext</strong> class, see the official Microsoft documentation at <a href="https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-5.0">https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-5.0</a>.</p>
			<p>Static classes are instantiated only once by the runtime. You cannot instantiate a static class yourself. Static constructors are executed at the time the class is loaded into memory. If a non-static class has a static constructor and an instance constructor, the static constructor will be called before the instance constructor. Static constructors are parameterless, and there can only be one static constructor per class. Static constructors do not have access modifiers. Memory is allocated for static variables when a class loads and deallocated when a class is unloaded. Variables, constructors, and methods belong to the class and not to instantiated objects. So, modifying variables will modify the variable across all instances of a class.</p>
			<p>On the call stack, static methods tend to be faster to call than instance methods. The compiler emits a nonvirtual call sites static members. Nonvirtual call sites prevent runtime checks that ensure the current object pointer is non-null. Although you may not see any visual performance improvements, performance gains can be measured for performance-sensitive <a id="_idIndexMarker218"/>code.</p>
			<p>Now that we have covered the various predefined C# data types, it is time to look at C# memory and how it works.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Understanding the various types of memory used in C#</h1>
			<p>There are two <a id="_idIndexMarker219"/>main types of memory in C#: the stack and the heap. The heap is further broken down into the <em class="italic">small object heap</em> and the <em class="italic">large object heap</em>. In terms of physical memory, there is no difference between the stack or heap, as they are both stored in physical memory. Their differences are in their implementations.</p>
			<p>When your application starts up, it is allocated a portion of memory. A pointer will be assigned to your application that will be your application's memory starting point. Above the pointer will be the stack, and below the pointer will be the heap. The heap will grow downwards, and the stack will grow upwards, as shown in <em class="italic">Figure 3.4</em>:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_3.4_B16617.jpg" alt="Figure 3.4 – The stack, heap, and application starting point memory address&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – The stack, heap, and application starting point memory address</p>
			<p>The following diagram <a id="_idIndexMarker220"/>visually represents the stack and heap for a simple program:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_3.5_B16617.jpg" alt="Figure 3.5 – The stack and heap at work&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – The stack and heap at work</p>
			<p>To understand the different types of memory in C#, first, we'll look at the stack and how it operates.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>The stack</h2>
			<p>The <em class="italic">stack</em> is used<a id="_idIndexMarker221"/> to <a id="_idIndexMarker222"/>store value types and pointers to memory locations on the heap. When you call a method, it is added to a stack frame on the stack. Then, within that frame, the value types are added to the stack. If there are any reference types in the method, these are placed on the heap, and a variable is placed on the stack and assigned a pointer to a memory address for the reference type on the heap.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Even though we can state that value types are added to the stack, this is not always true. For example, if you have an array of integers, the array – by virtue of being a reference type – will be added to the heap, and each of the integers that belong to the array will be added contiguously to the heap.</p>
			<p>If a <strong class="source-inline">struct</strong> object has a reference type, the struct is placed on the stack, the reference type is placed on the heap, and a pointer to the address of the reference type on the heap is stored in the variable on the heap.</p>
			<p>The stack is faster than the heap. It is arranged like a stack data structure. When you execute a method, the method is added to the stack in a stack frame. The local variables are then added to the stack frame on top of each other. When the method has completed execution, the memory is reclaimed immediately. The heap, however, must keep track of memory allocations, pointers, and reference counters, whereas the stack does not have to manage itself in this way.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">With the stack, you can simply pop things on and off the stack. To increase the performance of your applications, look for heap usage in your applications. Measure the performance when using the stack and using the heap. If the stack is faster, then replace heap usage with stack usage.</p>
			<p>Keep in mind that the cost of using memory is not at the time of allocation but at the point of deallocation. The deallocation of items on the stack is more predictable than the deallocation of items on the heap. In some cases, the garbage collector is doing similar pointer arithmetic when <em class="italic">freeing</em> memory in generation 0 or generation 1.</p>
			<p>Memory calls are also expensive because they are placed on the stack but may also reference the heap. Method performance is affected by code that does not execute. Therefore, you should refactor your methods to be as small as possible and remove any code that will not be executed, such as dead code that is no longer used. This will reduce the number of local variables in use and thereby reduce the stack size. And so, you will <a id="_idIndexMarker223"/>eliminate <a id="_idIndexMarker224"/>performance loss.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>The heap</h2>
			<p>The <em class="italic">heap</em> is used<a id="_idIndexMarker225"/> to store<a id="_idIndexMarker226"/> reference types. They are called reference types because they are reference-counted. To be reference-counted means that a count of variables referencing the allocated reference type is being kept by the runtime. When the reference count diminishes to zero, the reference type is deallocated by the garbage collector. For example, if I have a product object in memory and two variables on the stack pointing to that object, the product object has a reference count of two.</p>
			<p>You may be surprised to learn that the allocation of objects in C# can sometimes be faster than <a id="_idIndexMarker227"/>in <strong class="bold">C++</strong>. The price is paid in C# when it comes to garbage collection. So, instantiating many objects does not cost us much at all, but the cleanup of those objects does. This means that the more objects you create, the harder the garbage collector must work, which negatively impacts your application's performance. Therefore, avoid using reference types if alternative value types can be used. Do not create objects if you do not need to.</p>
			<p>When a new object is instantiated, it is placed on the heap. The variable is placed on the stack and is assigned a pointer to the address of the object on the heap.</p>
			<p>Arrays of reference types are placed on the heap. The variable that references the array will be placed on the stack and it will be assigned to the memory address of the array on the heap. The array itself will contain a contiguous list of memory addresses, as shown in <em class="italic">Figure 3.5</em>:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_3.6_B16617.jpg" alt="Figure 3.6 – The heap displaying objects on the heap and their memory addresses within an array&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – The heap displaying objects on the heap and their memory addresses within an array</p>
			<p>These memory <a id="_idIndexMarker228"/>addresses are pointers to the memory addresses of <a id="_idIndexMarker229"/>reference type address locations on the heap. This is because when an array is placed on the heap that contains reference types, each of the reference types in the array is assigned to its own area of memory. The memory addresses of the reference types are then placed inside the array.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Array performance has been prioritized, followed by string performance. Arrays are often faster than lists and other data structures. But it is best to use benchmarks to decide which is better for your situation and choose the data structure that performs best for you.</p>
			<p>When it comes to maximizing the performance of memory usage, you need to ensure that objects on the heap are placed as close to their reference pointers as possible. The reason for this is to reduce the required CPU cycles when locating the memory that is being referenced by the pointer. The rule of thumb for memory performance is that the further memory is from its pointer, the more it costs you in CPU performance. Although, it must be said that predictive memory access reduces this greatly, and memory usage can be dependent on the system page file setup.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The order in which you instantiate arrays, instantiate objects, assign values to objects, and assign values and objects to arrays affects the performance of your applications. This will be down to the placement of those items within memory. Remember that items on the heap should be close to their memory pointers, which may be stored either on the heap or on the stack.</p>
			<p>As already stated, object deallocation on the heap is slower than deallocation on the stack. The more objects you add to the heap, the slower your performance will be. The reason for this is that you give the garbage collector more work to do due to the frequent allocation and deallocation. It is this cycle of allocation and deallocation that causes the<a id="_idIndexMarker230"/> performance<a id="_idIndexMarker231"/> issues.</p>
			<p>There are two heaps within the main heap:</p>
			<ul>
				<li><strong class="bold">Small object heap</strong>: When <a id="_idIndexMarker232"/>a new object is instantiated, it is placed on the small object heap as generation 0 if it is less than 80,000 bytes in size.</li>
				<li><strong class="bold">Large object heap</strong>: When a new object is instantiated that is 80,000 bytes or larger in size, it is added to the large object heap. Large objects are always allocated in generation 2 because they are only garbage collected during a generation 2 collection.</li>
			</ul>
			<p>We will be looking at the heap in more detail when we look at garbage collection in <a href="B16617_04_Final_SB_Epub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, <em class="italic">Memory Management</em>. </p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Building a stack versus building a heap (example project)</h2>
			<p>Now, we will<a id="_idIndexMarker233"/> write a simple <a id="_idIndexMarker234"/>project that<a id="_idIndexMarker235"/> will get the number of ticks for object and struct instantiation with and without reference type properties. Start by adding a new .NET 6 console application called <strong class="source-inline">CH03_StackAndHeap</strong>. Then, add the <strong class="source-inline">BenchmarkDotNet nuget</strong> package. You will need to use the following <strong class="source-inline">using</strong> statements:</p>
			<pre class="source-code">using System;</pre>
			<pre class="source-code">using System.Diagnostics;</pre>
			<pre class="source-code">using System.Security.Cryptography;</pre>
			<pre class="source-code">using BenchmarkDotNet.Attributes;</pre>
			<pre class="source-code">using BenchmarkDotNet.Running;</pre>
			<p>Then, update the <strong class="source-inline">Main(string[] _)</strong> method as shown:</p>
			<pre class="source-code">static void Main(string[] _)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      BenchmarkRunner.Run&lt;BenchmarkTests&gt;();</pre>
			<pre class="source-code">}</pre>
			<p>In the method, we<a id="_idIndexMarker236"/> are calling the <strong class="source-inline">BenchmarkTests</strong> class that contains our <a id="_idIndexMarker237"/>benchmarks. Now, add<a id="_idIndexMarker238"/> the <strong class="source-inline">ClassNoReference</strong> class:</p>
			<pre class="source-code">internal class ClassNoReferences</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      public ClassNoReferences(</pre>
			<pre class="source-code">          int id,</pre>
			<pre class="source-code">          decimal price,</pre>
			<pre class="source-code">          DateTime purchaseDate</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          Id = id;</pre>
			<pre class="source-code">          Price = price;</pre>
			<pre class="source-code">          PurchaseDate = purchaseDate;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      public int Id { get; private set; }</pre>
			<pre class="source-code">      public decimal Price { get; private set; }</pre>
			<pre class="source-code">      public DateTime PurchaseDate { get; private set; }</pre>
			<pre class="source-code">}</pre>
			<p>This class has three value type properties and no reference type properties. Add the <strong class="source-inline">ProcessClassNoReferences()</strong> method in the <strong class="source-inline">BenchmarkTests</strong> class:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void ProcessClassNoReferences()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      var _ = new ClassNoReferences()</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          1,</pre>
			<pre class="source-code">          1.50M</pre>
			<pre class="source-code">          DateTime.Now</pre>
			<pre class="source-code">      };</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">ProcessClassNoReferences()</strong> method declares a new instance of the <strong class="source-inline">ClassNoReferences</strong> class. It<a id="_idIndexMarker239"/> will <a id="_idIndexMarker240"/>be used <a id="_idIndexMarker241"/>as a benchmarking method. Add the <strong class="source-inline">StructNoReferences</strong> class:</p>
			<pre class="source-code">internal class StructNoReferences</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      public StructNoReferences(</pre>
			<pre class="source-code">          int id,</pre>
			<pre class="source-code">          decimal price,</pre>
			<pre class="source-code">          DateTime purchaseDate</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          Id = id;</pre>
			<pre class="source-code">          Price = price;</pre>
			<pre class="source-code">          PurchaseDate = purchaseDate;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      public int Id { get; private set; }     </pre>
			<pre class="source-code">      public decimal Price { get; private set; }</pre>
			<pre class="source-code">      public DateTime PurchaseDate { get; private set; }</pre>
			<pre class="source-code">}</pre>
			<p>This struct has three value<a id="_idIndexMarker242"/> type <a id="_idIndexMarker243"/>properties and no reference types. Let's add the <strong class="source-inline">ProcessStructNoReferences()</strong> method <a id="_idIndexMarker244"/>to the <strong class="source-inline">BenchmarkTests</strong> class:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void ProcessStructNoReferences()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      var _ = new StructNoReferences()</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         1,</pre>
			<pre class="source-code">         1.50M,</pre>
			<pre class="source-code">         DateTime.Now</pre>
			<pre class="source-code">      };</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">ProcessStructNoReferences()</strong> method will be used as a benchmark, and it creates a new <strong class="source-inline">StructNoReferences</strong> struct. Next, add the <strong class="source-inline">ClassWithReferences</strong> class:</p>
			<pre class="source-code">class ClassWithReferences</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public ClassWithReferences(</pre>
			<pre class="source-code">        int id,</pre>
			<pre class="source-code">        string name,</pre>
			<pre class="source-code">        decimal price,</pre>
			<pre class="source-code">        DateTime purchaseDate,</pre>
			<pre class="source-code">        Dictionary&lt;string, string&gt; keyValueData</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        Id = id;</pre>
			<pre class="source-code">        Name = name;</pre>
			<pre class="source-code">        Price = price;</pre>
			<pre class="source-code">        PurchaseDate = purchaseDate;</pre>
			<pre class="source-code">        KeyValueData = keyValueData;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int Id { get; private set; }</pre>
			<pre class="source-code">    public string Name { get; private set; }</pre>
			<pre class="source-code">    public decimal Price { get; private set; }</pre>
			<pre class="source-code">    public DateTime PurchaseDate { get; private set; }</pre>
			<pre class="source-code">    public Dictionary&lt;string, string&gt; KeyValueData </pre>
			<pre class="source-code">        { get; private set; }</pre>
			<pre class="source-code">}</pre>
			<p>This class has <a id="_idIndexMarker245"/>value and reference type properties. Now, we will add the <strong class="source-inline">ProcessClassWithReferences()</strong> method:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void ProcessClassWithReferences()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      var _ = new ClassWithReferences(</pre>
			<pre class="source-code">         Id = 1,</pre>
			<pre class="source-code">         "The quick brown fox jumped over the lazy dog.",</pre>
			<pre class="source-code">         1.50M,</pre>
			<pre class="source-code">         DateTime.Now,</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">ProcessClassWithReferences()</strong> method will be used as a benchmark, and it creates <a id="_idIndexMarker246"/>an instance of <strong class="source-inline">ClassWithReferences</strong>. Next, we <a id="_idIndexMarker247"/>will<a id="_idIndexMarker248"/> add the <strong class="source-inline">StructWithReferences</strong> struct:</p>
			<pre class="source-code">internal struct StructWithReferences</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      public StructWithReferences(</pre>
			<pre class="source-code">          int id,</pre>
			<pre class="source-code">          string name,</pre>
			<pre class="source-code">          decimal price,</pre>
			<pre class="source-code">          DateTime purchaseDate,</pre>
			<pre class="source-code">          Dictionary&lt;string, string&gt; keyValueData</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          Id = id;</pre>
			<pre class="source-code">          Name = name;</pre>
			<pre class="source-code">          Price = price;</pre>
			<pre class="source-code">          PurchaseDate = purchaseDate;</pre>
			<pre class="source-code">          KeyValueData = keyValueData;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      public int Id { get; private set; }</pre>
			<pre class="source-code">      public string Name { get; private set; }</pre>
			<pre class="source-code">      public decimal Price { get; private set; }</pre>
			<pre class="source-code">      public DateTime PurchaseDate { get; private set; }</pre>
			<pre class="source-code">      public Dictionary&lt;string, string&gt; KeyValueData </pre>
			<pre class="source-code">          { get; private set; }</pre>
			<pre class="source-code">}</pre>
			<p>This struct has<a id="_idIndexMarker249"/> value and reference<a id="_idIndexMarker250"/> types. And <a id="_idIndexMarker251"/>now, we will add our final method, <strong class="source-inline">ProcessStructWithReferences()</strong>:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void ProcessStructWithReferences()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      var _ = new StructWithReferences()</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         Id = 1,</pre>
			<pre class="source-code">         Name = "Discard",</pre>
			<pre class="source-code">         Price = 1.50M</pre>
			<pre class="source-code">      };</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">ProcessStructWithReferences()</strong> method will be used as a benchmark, and it creates a new <strong class="source-inline">StructureWithReferences</strong> struct.</p>
			<p>Compile the code in release mode. Then, run the executable. Your code will then be benchmarked, and you will see the following benchmark report:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_3.7.jpg" alt="Figure 3.7 – The benchmark report comparing structs and classes with and without references&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – The benchmark report comparing structs and classes with and without references</p>
			<p>The benchmark <a id="_idIndexMarker252"/>results reveal the<a id="_idIndexMarker253"/> following<a id="_idIndexMarker254"/> insights:</p>
			<ul>
				<li>Processing a class with no references is faster than processing a struct with no references</li>
				<li>Processing a class with references is slower than processing a struct with references</li>
			</ul>
			<p>As the benchmark results show, depending on the scenario, a struct can be faster than a class and vice versa. This is a good reason for benchmarking code, as you could be thinking your code is optimal when in fact it is slow.</p>
			<p>So, how do you choose whether to use a struct or a class?</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Choosing between a struct and a class</h2>
			<p>As a rule <a id="_idIndexMarker255"/>of thumb, Microsoft <a id="_idIndexMarker256"/>recommends that we define our types as classes. If a type is embedded in other objects or if it is short-lived, then consider using a struct. When defining a struct, it should have the following characteristics:</p>
			<ul>
				<li>Logically, the struct represents a single value.</li>
				<li>The struct instance size is under 16 bytes.</li>
				<li>The struct is immutable.</li>
				<li>The struct is not frequently boxed and unboxed.</li>
			</ul>
			<p>A <em class="italic">struct</em> is a <em class="italic">value type</em>. Value <a id="_idIndexMarker257"/>types are allocated on the stack or inline inside containing types. A value type will be deallocated when the stack is unwound or during the deallocation of the containing type. Value types are not garbage collected. The allocation and deallocation of value types on the stack are considered cheap. However, when a value type is boxed, it is wrapped in a reference type or cast to an interface, and this causes a performance slowdown. A performance slowdown is also experienced when a value type is unwrapped from inside a reference type, which is known as <em class="italic">unboxing</em>. You<a id="_idIndexMarker258"/> should do your best to avoid boxing and unboxing value types for performance reasons. When you assign value types, a complete copy of the value is passed into the assignment. The assignment of large value types can be more expensive than the assignment of large reference types.</p>
			<p>A <em class="italic">class</em> is a <em class="italic">reference type</em>. Reference <a id="_idIndexMarker259"/>types are objects allocated on the heap with a pointer to the memory location placed on the stack. When a reference type comes to the end of its life, it is garbage-collected. The allocation and deallocation of reference types on the heap are considered expensive when compared with the allocation and deallocation of value types on the stack. Unlike value types, no boxing occurs when casting reference types. When you assign a reference type, a copy of the reference is passed to the assigned variable. The assignment of large reference types can be cheaper than the assignment of large value types.</p>
			<p>An array of reference types contains pointers to the actual types on the heap. An array of value types contains the actual values of those reference types. The allocation and deallocation of value type arrays are cheap, and they have better locality when compared to arrays of reference types, as the value type values are inline.</p>
			<p>Let's<a id="_idIndexMarker260"/> move<a id="_idIndexMarker261"/> on to look at <em class="italic">passing by value</em> and <em class="italic">passing by reference</em>. </p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Passing by value and passing by reference</h1>
			<p>When passing values into a method or constructor, there are two ways to do this. They are <em class="italic">passing by value</em> and <em class="italic">passing by reference</em>:</p>
			<ul>
				<li><strong class="bold">Passing by value</strong>: By <a id="_idIndexMarker262"/>default, all value types are passed by value into constructors and methods using <em class="italic">copy semantics</em>. This means that a copy is made of the value being passed in. The original value remains unchanged, and it is the copy that is used with the constructor or method.</li>
				<li><strong class="bold">Passing by reference</strong>: When<a id="_idIndexMarker263"/> a reference type is passed into a constructor or method, a variable is made on the stack that points to the same object on the heap. So, both the variable that is passed in and the copied variable used inside the constructor or method operate on the same object in memory. </li>
			</ul>
			<p>Now that we know what passing by value and passing by reference are, let's write a simple program that demonstrates what we have learned.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Building a pass-by-reference example program</h2>
			<p>We are going to<a id="_idIndexMarker264"/> write a very simple program that demonstrates the effects of passing by value and passing by reference. Add a new .NET 6 console application called <strong class="source-inline">CH03_PassByValueAndReference</strong>. Then, modify the <strong class="source-inline">Main(string[] _)</strong> method as follows:</p>
			<pre class="source-code">static void Main(string[] args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">int x = 0;</pre>
			<pre class="source-code">Console.WriteLine("Chapter 3: Pass by value and reference");     </pre>
			<pre class="source-code">Console.WriteLine($"=====================================");</pre>
			<pre class="source-code">Console.WriteLine($"int x = 0;");</pre>
			<pre class="source-code">AddByValue(x);</pre>
			<pre class="source-code">Console.WriteLine($"    AddByValue(x): {x}");</pre>
			<pre class="source-code">AddByReference(ref x);</pre>
			<pre class="source-code">Console.WriteLine($"AddByReference(x): {x}");</pre>
			<pre class="source-code">}</pre>
			<p>Here, we have declared an integer called <strong class="source-inline">x</strong> and assigned it a value of <strong class="source-inline">0</strong>. Some text is output to the console window, and we call two methods and output the value of <strong class="source-inline">x</strong> after they have been <a id="_idIndexMarker265"/>called. Let's add the first method that is called – the <strong class="source-inline">AddByValue(int x)</strong> method:</p>
			<pre class="source-code">static void AddByValue(int x)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      x++;</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, it is a very simple method that increments the value for the variable passed in. Now, let's repeat the same process, but this time, we will pass the value by reference:</p>
			<pre class="source-code">static void AddByReference(ref int x)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      x++;</pre>
			<pre class="source-code">}</pre>
			<p>Run the program, and you should see the following output:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_3.8_B16617.jpg" alt="Figure 3.8 – The value of x after incrementing using pass by value and pass by reference&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – The value of x after incrementing using pass by value and pass by reference</p>
			<p>We can see that the original value is not updated when we pass by value. But it is updated when we pass by reference. We will now extend the application to cover the <strong class="source-inline">in</strong> parameter modifier.</p>
			<p>Arguments passed with the <strong class="source-inline">in</strong> keyword are passed by reference. However, <strong class="source-inline">in</strong> arguments cannot be modified. Let's demonstrate this – add a new method called <strong class="source-inline">InParameterModifier()</strong>:</p>
			<pre class="source-code">static void InParameterModifier()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      int argument = 13;</pre>
			<pre class="source-code">      InParameterModifier(argument);</pre>
			<pre class="source-code">      Console.WriteLine(argument);</pre>
			<pre class="source-code">}</pre>
			<p>In <a id="_idIndexMarker266"/>the <strong class="source-inline">InParameterModifier()</strong> method, we create an integer and assign to it a value of <strong class="source-inline">13</strong>. We then call a method of the same name and pass in the variable as an argument. Then, we print out the value to the console window. Now, we will write the <strong class="source-inline">InParameterModifier(in int argument)</strong> method:</p>
			<pre class="source-code">static void InParameterModifier(in int argument)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      // Error CS8331: Cannot assign to variable 'in int'</pre>
			<pre class="source-code">      // because it is a readonly variable.</pre>
			<pre class="source-code">      // argument = 47; </pre>
			<pre class="source-code">}</pre>
			<p>The code is commented out because if we assign a value to the argument, we will get the compiler warning you see in the comment. Call the method from the <strong class="source-inline">Main(string[] _)</strong> object and run the program. You will see that the variable remains at <strong class="source-inline">13</strong>, as the compiler prevented us from being able to change it in the called method. Finally, in the next part of our program, we will look at the <strong class="source-inline">out</strong> keyword.</p>
			<p>An <strong class="source-inline">out</strong> argument does not have to be initialized before being passed in. This is different from a ref value that must be initialized before it is passed in. All <strong class="source-inline">out</strong> parameters are passed by reference. Any operation carried out on the argument inside the method becomes available to the external code that can see the argument. An example will make this easier to understand.</p>
			<p>We will be adding two methods to demonstrate how the <strong class="source-inline">out</strong> parameter works. Add a new method <a id="_idIndexMarker267"/>called <strong class="source-inline">OutParameterModifier()</strong> to the <strong class="source-inline">Program</strong> class:</p>
			<pre class="source-code">static void OutParameterModifier()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      int x;</pre>
			<pre class="source-code">      OutParameterModifier(out x);</pre>
			<pre class="source-code">      Console.WriteLine($"The value of x is: {x}.");</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, we declare an integer variable. Then, we call a method that has an <strong class="source-inline">out</strong> parameter and we pass in our integer with its default value of <strong class="source-inline">0</strong>. Next, we print out the value of the integer once the method has returned. Now, add the <strong class="source-inline">outParameter(out x)</strong> method:</p>
			<pre class="source-code">static void OutParameterModifier(out int argument)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      argument = 123;</pre>
			<pre class="source-code">}</pre>
			<p>Here, we are simply setting the argument to <strong class="source-inline">123</strong> and exiting. Call the <strong class="source-inline">OutParameterModifier()</strong> method from <strong class="source-inline">Main(string[] _)</strong>. If you run the code, you will see that our integer was updated to the value of <strong class="source-inline">123</strong> inside the method that we called. This is shown in <em class="italic">Figure 3.9</em>:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_3.9_B16617.jpg" alt="Figure 3.9 – Our integer has been updated inside the method we passed it into&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Our integer has been updated inside the method we passed it into</p>
			<p>In the<a id="_idIndexMarker268"/> following section, we will look at <em class="italic">boxing</em> and <em class="italic">unboxing</em>.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Boxing and unboxing</h1>
			<p><em class="italic">Boxing</em> and <em class="italic">unboxing</em> variables <a id="_idIndexMarker269"/>negatively <a id="_idIndexMarker270"/>impact the performance of your applications. To improve your application's code, you should do your best to avoid boxing and unboxing – especially when your code is mission-critical. In this section, we will look at what happens when you package (that is, box) a type.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Performing boxing</h2>
			<p>When a variable is <a id="_idIndexMarker271"/>boxed, you are wrapping it in an object that gets stored on the heap. As you know, objects on the heap incur costs, as they must be managed by the runtime. On top of this, you also increase the memory used by the variable, as well as the number of CPU cycles needed to process the variable.</p>
			<p>An empty <strong class="source-inline">class</strong> definition is 12 bytes on a 32-bit operating system and 24 bytes on a 64-bit operating system. This may not sound like a lot. But if a value type is boxed that does not need to be boxed, you will be wasting 12 or 24 bytes of memory unnecessarily.</p>
			<p>Now, we will look at what happens when you unbox a variable</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Performing unboxing</h2>
			<p>A variable is <a id="_idIndexMarker272"/>copied to the evaluation stack that references an object on the heap. The variable is then unboxed (that is, unpacked) and the variable is placed on the evaluation stack. Then, whatever needs to be done with the unboxed variable can be done. Once all the work has been done with the variable, it then must be boxed up again and placed on the heap. This will create a new object on the heap, and the variable on the stack will be updated with its memory location.</p>
			<h3>Building a boxing-and-unboxing example program</h3>
			<p>Now, we <a id="_idIndexMarker273"/>will <a id="_idIndexMarker274"/>write a simple .NET 6 console application that shows the time difference between not boxing and boxing/unboxing on performance using <strong class="source-inline">BenchmarkDotNet</strong>. First, start a new .NET 6 console application and call it <strong class="source-inline">CH03_BoxingAndUnboxing</strong>. You will need to add the <strong class="source-inline">BenchmarkDotNet</strong> package and the following two namespaces:</p>
			<pre class="source-code">using System;</pre>
			<pre class="source-code">using System.Diagnostics;</pre>
			<pre class="source-code">using System.Security.Cryptography;</pre>
			<pre class="source-code">using BenchmarkDotNet.Attributes;</pre>
			<pre class="source-code">using BenchmarkDotNet.Running;</pre>
			<p>We need these namespaces to perform benchmarking. In the <strong class="source-inline">Main(string[] _)</strong> method, add the following line:</p>
			<pre class="source-code">BenchmarkRunner.Run&lt;BoxingAndUnboxingBenchmarkTests&gt;();</pre>
			<p>This line of code starts the benchmarks running. Next, add a new class called <strong class="source-inline">BoxingAndUnboxingBenchmarkTests</strong>:</p>
			<pre class="source-code">public class BoxingAndUnboxingBenchmarkTests { }</pre>
			<p>This class will hold two benchmarking methods called <strong class="source-inline">NonBoxingUnboxingTest()</strong> and <strong class="source-inline">BoxingUnboxingTest()</strong>. Add the <strong class="source-inline">NonBoxingUnboxingTest()</strong> method:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void NonBoxingUnboxingTest()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      int z = 0, a = 4, b = 4;</pre>
			<pre class="source-code">      z = a + b;</pre>
			<pre class="source-code">}</pre>
			<p>In this method, we declare and assign three integers: <strong class="source-inline">z = 0</strong>, <strong class="source-inline">a = 1</strong>, and <strong class="source-inline">b = 6</strong>. We then add <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> together and assign the resulting value to <strong class="source-inline">z</strong>. Now, add the <strong class="source-inline">BoxingUnboxingTest()</strong> method:</p>
			<pre class="source-code">[Benchmark]</pre>
			<pre class="source-code">public void BoxingUnboxingTest()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      object a = 4, b = 4;</pre>
			<pre class="source-code">      int z;</pre>
			<pre class="source-code">      z = (int)a + (int)b;</pre>
			<pre class="source-code">} </pre>
			<p>This<a id="_idIndexMarker275"/> time, we<a id="_idIndexMarker276"/> declare and assign two objects: <strong class="source-inline">a = 4</strong> and <strong class="source-inline">b = 4</strong>. We also declare an integer: <strong class="source-inline">z</strong>. Then, we cast <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> to integers, add them together, and assign the result to the <strong class="source-inline">z</strong> integer variable.</p>
			<p>Perform a release build of your code. Then, open a command line and navigate to your executable. Run your executable from the command line, and you should see the following summary:</p>
			<p> </p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_3.10.jpg" alt="Figure 3.10 – The boxing-and-unboxing example project addition output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – The boxing-and-unboxing example project addition output</p>
			<p>As you can see <a id="_idIndexMarker277"/>from <a id="_idIndexMarker278"/>the screenshot in <em class="italic">Figure 3.10</em>, unboxing does add overhead to the performance of your applications. </p>
			<p>If you open <a id="_idIndexMarker279"/>the <strong class="bold">Developer Command Prompt</strong> for <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>) <strong class="bold">2019</strong> and<a id="_idIndexMarker280"/> type <strong class="source-inline">ILDASM</strong>, this will load the intermediate language disassembler. Open the DLL file in your build folder, and expand the tree until you see the <strong class="source-inline">Main : void(string[])</strong> line, as shown in <em class="italic">Figure 3.11</em>:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_3.11_B16617.jpg" alt="Figure 3.11 – The Intermediate Language Disassembler (ILDASM)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – The Intermediate Language Disassembler (ILDASM)</p>
			<p>Double-click<a id="_idIndexMarker281"/> the <strong class="source-inline">Main</strong> method. This will bring up the <a id="_idIndexMarker282"/>window that shows the disassembled intermediate language for our <strong class="source-inline">Main(string[] _)</strong> method, as shown in <em class="italic">Figure 3.12</em>:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_3.12_B16617.jpg" alt="Figure 3.12 – The disassembled intermediate language for our Main(string[] _) method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – The disassembled intermediate language for our Main(string[] _) method</p>
			<p>Study <a id="_idIndexMarker283"/>the<a id="_idIndexMarker284"/> disassembled code. When you see the <strong class="source-inline">box</strong> command, the value type is being wrapped inside of an object, which is a reference type that gets placed on the heap. And when you see the <strong class="source-inline">unbox.any</strong> command, the value type is being unwrapped from the object and assigned to an int value type that belongs on the stack.</p>
			<p>You now understand why boxing and unboxing affect the performance of your applications, and now we have come to the end of the chapter. In the next chapter, we will be focusing on how the garbage collector works and what we can do to improve its performance. But first, let's summarize what we have learned. You are then encouraged to answer the questions that follow and further your reading on this subject.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Summary</h1>
			<p>We started the chapter by looking at the various predefined .NET data types. First, we described the various value types, and then we moved on to the predefined reference types. Then, we concluded our discussion of predefined .NET data types by exploring static types.</p>
			<p>You learned that value types live on the stack. But if they are part of an array, they are placed on the heap with the array that happens to be a reference type. You also learned that reference types live on the heap and that they have pointers to them in the form of variables that live on the stack.</p>
			<p>Next, we looked at the different types of memory used in C#. First, we looked at the stack. Then, we looked at the heap, which consists of the small object heap and the large object heap. After looking at the differences between the stack and the heap, we saw that the stack performs much faster than the heap. The reason for this is that the stack memory does not have to be managed by the runtime. It is simply popped onto the stack when it is needed and popped off the stack when it is not needed. In contrast, the heap must be managed by the runtime that allocates the objects – it keeps a reference count of all the variables that reference those objects, and then it deallocates the objects when they are no longer needed.</p>
			<p>We then looked at passing by value and passing by reference. Values passed by value have a copy taken of them that is passed into the constructor or method. This copy is utilized, and the original value remains untouched. When passed by reference, a copy of a value is made and placed on the stack, and it is assigned the memory location of the object on the heap.</p>
			<p>Finally, we looked at the boxing and unboxing of variables and why this negatively impacts your application's performance.</p>
			<p>With all that you have learned in this chapter, you can reduce the amount of memory your applications use by using the right types, and you can reduce the number of ticks per operation by avoiding boxing and unboxing. And now that you know how memory allocations work, you can improve performance by keeping methods small and using the stack instead of the heap when it is practical to do so.</p>
			<p>In the next chapter, we will be learning more about garbage collection.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Questions</h1>
			<ol>
				<li>List the predefined .NET value types.</li>
				<li>List the predefined reference types.</li>
				<li>What does the runtime have to do before a static type can be accessed and utilized?</li>
				<li>Is there a physical difference in the memory that is used that makes the stack run faster than the heap?</li>
				<li>Why is the stack faster than the heap?</li>
				<li>Explain why strings are immutable.</li>
				<li>What is the approximate size of objects placed on the small object heap?</li>
				<li>What is the approximate size of objects placed on the large object heap?</li>
			</ol>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Further reading</h1>
			<ul>
				<li><em class="italic">The C# type system</em></li>
				<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/</a></li>
				<li><em class="italic">C# Different Types of Heap Memory</em></li>
				<li><a href="https://vivekcek.wordpress.com/tag/stub-heap/">https://vivekcek.wordpress.com/tag/stub-heap/</a></li>
				<li><em class="italic">Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects</em></li>
				<li><a href="https://web.archive.org/web/20140724084944/http://msdn.microsoft.com/en-us/magazine/cc163791.aspx">https://web.archive.org/web/20140724084944/http://msdn.microsoft.com/en-us/magazine/cc163791.aspx</a></li>
				<li><em class="italic">Passing Parameters (C# Programming Guide)</em></li>
				<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters</a></li>
				<li><em class="italic">Boxing and Unboxing (C# Programming Guide)</em></li>
				<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing</a></li>
				<li><em class="italic">The large object heap on Windows systems</em></li>
				<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap</a></li>
				<li><em class="italic">.NET Memory Allocations and Performance</em></li>
				<li><a href="https://www.youtube.com/watch?v=aylUPfOVM90">https://www.youtube.com/watch?v=aylUPfOVM90</a></li>
				<li><em class="italic">Replacing AppDomain in .NET Core</em></li>
				<li><a href="https://www.michael-whelan.net/replacing-appdomain-in-dotnet-core/">https://www.michael-whelan.net/replacing-appdomain-in-dotnet-core/</a></li>
			</ul>
		</div>
	</body></html>