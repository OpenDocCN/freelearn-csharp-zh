<html><head></head><body>
		<div><h1 id="_idParaDest-78"><em class="italic"><a id="_idTextAnchor078"/>Chapter 5</em>: Exploring Architecture Design Patterns</h1>
			<p>In the previous chapter, we learned about the key principles of solution architecture. We also explored the most frequently used UML diagrams and when we should use each one to create a view of the solution architecture.</p>
			<p>In this chapter, you will learn about the top architecture patterns that you must know to build a solid software architecture.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introducing the architectural patterns</li>
				<li>Exploring key architecture patterns</li>
				<li>Learning how to choose the right pattern for your product</li>
			</ul>
			<p>By the end of this chapter, you will understand architectural patterns. We will enrich our knowledge by exploring the top architecture patterns with example use cases. Additionally, we will explain the criteria that we should focus on when choosing the right architecture pattern for our software product.</p>
			<p>Before we begin learning about these patterns, first, let's understand what an architectural pattern actually is.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/>Introducing the architectural patterns</h1>
			<p>An architectural pattern<a id="_idIndexMarker327"/> is a reusable solution architecture to a common problem that we might face in different business industries and on various occasions. It offers predefined guidelines along with a set of rules to establish the underlying structure of the solution.</p>
			<p>It is important not to mix up the <strong class="bold">.NET</strong> design patterns and the architectural patterns. The first one represents a way in which to organize classes to make your source code more reliable, scalable, and easy to maintain, which will solve various problems that are internal to a specific component or module in our system. In comparison, the second one has a broader scope within the entire solution as it defines the high-level abstract structure of the solution. As a solution architect, you must possess knowledge of both types of patterns:</p>
			<ul>
				<li><strong class="bold">Design Patterns</strong> develop<a id="_idIndexMarker328"/> classes with object-oriented principles.</li>
				<li><strong class="bold">Architectural Patterns</strong> help <a id="_idIndexMarker329"/>to define and maintain the overall structure of the entire system.</li>
			</ul>
			<p>The following diagram shows the different levels of <a id="_idIndexMarker330"/>architectural decisions that you might need to make as a solution architect:</p>
			<div><div><img src="img/Figure_5.01_B17366.jpg" alt="Figure 5.1: The various levels of architectural decisions"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: The various levels of architectural decisions</p>
			<p>In the preceding diagram, you can see that choosing the architectural pattern is one of the earliest decisions that you must take. Following this, you should choose the right technology stack that you will use to build the product. After that, you need to decide upon the type of application and the design patterns that will help you to organize the code and make it both reusable and extensible.</p>
			<p>Now, let's begin by getting to know the most popular architecture patterns.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>Popular architecture patterns</h1>
			<p>In this section, we will explore <a id="_idIndexMarker331"/>five popular architectural patterns. We will explain the core concept of each pattern, and then we will outline the key components of each architecture pattern. This should help you learn about the usefulness of architecture patterns and support you in choosing the right pattern for a proposed solution. Let's begin with a layered architecture.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Layered architecture</h2>
			<p>This type <a id="_idIndexMarker332"/>of architecture is<a id="_idIndexMarker333"/> widely known by most architects and developers as <strong class="bold">n-tier architecture</strong>. It is used to structure the system into different layers, where each layer consists of a set of classes grouped in one assembly based on a specific context. The layers are structured horizontally so that each layer can consume services from one layer or the many layers that are beneath it.</p>
			<p>In most cases, this architecture consists of three main layers, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_5.02_B17366.jpg" alt="Figure 5.2: A typical 3-tier layered architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: A typical 3-tier layered architecture</p>
			<p>As you can see<a id="_idIndexMarker334"/> from the preceding diagram, these are the three main layers:</p>
			<ul>
				<li><strong class="bold">Presentation Layer</strong>: This <a id="_idIndexMarker335"/>layer represents the component that is responsible for handling all user interactions through pages, menus, buttons, links, reports, forms, and more. It contains all the graphical designs and defines what the application looks like. It is the only layer that is visible to end users.</li>
				<li><strong class="bold">Business Layer</strong>: This contains <a id="_idIndexMarker336"/>the business logic, business rules, and entities that define the behavior of the entire solution.</li>
				<li><strong class="bold">Data Access Layer</strong>: This <a id="_idIndexMarker337"/>contains the code responsible for manipulating the database layer, which is where all the data is stored (for example, <strong class="bold">SQL Server</strong>, <strong class="bold">Oracle</strong>, and <strong class="bold">MongoDB</strong>).</li>
			</ul>
			<p>The following screenshot shows the 3-tier architecture<a id="_idIndexMarker338"/> in <strong class="bold">Visual Studio</strong> using the <strong class="bold">Razor Web App</strong> and <strong class="bold">.NET 5</strong> class libraries:</p>
			<div><div><img src="img/Figure_5.03_B17366.jpg" alt="Figure 5.3: 3-tier architecture in Visual Studio"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3: 3-tier architecture in Visual Studio</p>
			<p>In the preceding example architecture, the <strong class="bold">data access layer</strong> is the lowest layer and does not reference any of the other layers. It should contain the <strong class="bold">ADO.NET</strong> call or the <strong class="bold">EntityFramework</strong> call to manipulate the database tables.</p>
			<p>The <strong class="bold">business layer</strong> references the <strong class="bold">data access layer</strong>. It should contain all the business logic and entities; here, the entities represent the business objects mapped to the database tables. As for the <strong class="bold">presentation layer</strong>, this is the <strong class="bold">web app</strong> that contains the user interface. It references the <strong class="bold">business layer</strong> and doesn't allow direct calls to the <strong class="bold">data access layer</strong>. The <strong class="bold">web app</strong> can be an MVC app or Razer app, as it is possible to mix these two patterns in order to build a solution. </p>
			<p>In the next section, let's get to know the presentation architecture in more detail.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Presentation architecture</h2>
			<p>One of the major <a id="_idIndexMarker339"/>issues we could face in a solution's <strong class="bold">User</strong> <strong class="bold">Interface</strong> (<strong class="bold">UI</strong>) is the presence of messy code that's difficult to maintain and scale. We have seen this<a id="_idIndexMarker340"/> in many web form solutions. This makes the architectural presentation pattern of the utmost importance, as it organizes the source code with a clear separation of responsibilities along with low coupling, which removes any complications and makes the UI code well organized and manageable.</p>
			<p>This architecture pattern helps to solve primary UI issues, such as logic that is coupled with the UI, state management, and the synchronization between the UI elements and the business entities.</p>
			<p>There are three types of presentation patterns, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_5.04_B17366.jpg" alt="Figure 5.4: The various types of presentation patterns"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4: The various types of presentation patterns</p>
			<p>All of these patterns focus on decoupling the UI from the logic, which allows for clean <strong class="bold">HTML</strong> markup. Let's explore these three types in the following sections.</p>
			<h3>MVC (Model, View, Controller)</h3>
			<p>The MVC pattern gives<a id="_idIndexMarker341"/> you full control over the markup. It is very popular, and<a id="_idIndexMarker342"/> Visual Studio has adopted it as the default template for when we want to create a new <strong class="bold">ASP.NET</strong> project. It splits the application into three main components:</p>
			<ul>
				<li><strong class="bold">Model</strong>: This encapsulates the business logic and contains the data to display in the view.</li>
				<li><strong class="bold">View</strong>: This displays the content through the UI.</li>
				<li><strong class="bold">Controller</strong>: This handles the user interaction, works with the model for data updates, and, finally, selects a view to render the content.</li>
			</ul>
			<p>The following diagram shows the three main components and illustrates which ones reference the others:</p>
			<div><div><img src="img/Figure_5.05_B17366.jpg" alt="Figure 5.5: The MVC pattern"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5: The MVC pattern</p>
			<p>Here is an example MVC project template using <strong class="bold">Visual Studio 2019</strong> and <strong class="bold">.NET 5</strong>:</p>
			<div><div><img src="img/Figure_5.06_B17366.jpg" alt="Figure 5.6: A typical MVC project template in Visual Studio"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6: A typical MVC project template in Visual Studio</p>
			<p>In the preceding <a id="_idIndexMarker343"/>example architecture, you can see that the three <a id="_idIndexMarker344"/>components are encapsulated within the same project but exist in different folders. You can also create a separate project for each layer and then configure the references.</p>
			<h3>MVP (Model, View, Presenter)</h3>
			<p>The MVP pattern is a UI <a id="_idIndexMarker345"/>presentation architecture and is considered to<a id="_idIndexMarker346"/> be a derivation of the MVC pattern. It separates the architecture into three main components:</p>
			<ul>
				<li><strong class="bold">Model</strong>: This contains the business logic of the solution.</li>
				<li><strong class="bold">View</strong>: This contains the interfaces that enclose the data properties, which we will either send to or receive from the UI. In comparison to the MVC pattern, it doesn't include the UI.</li>
				<li><strong class="bold">Presenter</strong>: This retrieves data from the <strong class="bold">Model</strong> and binds it back to the view. It works as an intermediate layer between the <strong class="bold">Model</strong> layer and the <strong class="bold">View</strong> layer. </li>
			</ul>
			<p>The following diagram <a id="_idIndexMarker347"/>illustrates the three main components of the <a id="_idIndexMarker348"/>MVP pattern:</p>
			<div><div><img src="img/Figure_5.07_B17366.jpg" alt="Figure 5.7: The MVP pattern"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7: The MVP pattern</p>
			<p>Here is an MVP project template in Visual Studio using the <strong class="bold">Razor Web App</strong> and <strong class="bold">.NET 5</strong> class libraries. Check the references between the projects in order to gain an understanding of the relationships between the three components:</p>
			<div><div><img src="img/Figure_5.08_B17366.jpg" alt="Figure 5.8: A typical MVP project template in Visual Studio"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8: A typical MVP project template in Visual Studio</p>
			<p>In the preceding example architecture, you can see that the UI is located in the web app, which references the <strong class="bold">Model</strong>, the <strong class="bold">View</strong>, and the <strong class="bold">Presenter</strong> layers. The View layer doesn't reference any other project. It contains the interfaces that are implemented in the Presenter layer. The <a id="_idIndexMarker349"/>Model layer contains the business <a id="_idIndexMarker350"/>entities and the business logic; it doesn't reference any other project. As for the Presenter layer, this contains the actual implementation of the interfaces defined in the View layer. It references the Model and the View layers because it plays an intermediate role between them.</p>
			<p>Let's explore the third type of presentation architecture next.</p>
			<h3>MVVM (Model, View, ViewModel)</h3>
			<p>This architecture is also<a id="_idIndexMarker351"/> considered an extension of the MVC pattern. It<a id="_idIndexMarker352"/> contains three main components, too. It combines the best strengths of MVC and MVP by offering a high level of reusability and scalability. The key concept of this architecture is that it moves the logic out of the controller and into <strong class="bold">ViewModel</strong>:</p>
			<ul>
				<li><strong class="bold">Model</strong>: This contains the business rules and the model classes.</li>
				<li><strong class="bold">View</strong>: This contains the UI.</li>
				<li><strong class="bold">ViewModel</strong>: This is an intermediate layer between <strong class="bold">View</strong> and <strong class="bold">Model</strong>.</li>
			</ul>
			<p>The following diagram shows the three components and how they interact with each other:</p>
			<div><div><img src="img/Figure_5.09_B17366.jpg" alt="Figure 5.9: The MVVM pattern"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9: The MVVM pattern</p>
			<p>Note that the <code>Session</code>, <code>ViewBag</code>, or <code>TempData</code>.</p>
			<p>Here is an example project template of the MVVM pattern using <strong class="bold">Visual Studio</strong>, <strong class="bold">MVC</strong>, and <strong class="bold">.NET 5</strong>:</p>
			<p class="figure-caption"><img src="img/Figure_5.10_B17366.png" alt="Figure 5.10: A typical MVVM project template in Visual Studio"/></p>
			<p class="figure-caption">Figure 5.10: A typical MVVM project template in Visual Studio</p>
			<p>We can also use the Razor Pages project template as it follows the MVVM pattern. This enables two-way data binding since the code of the model and the controller are attached to the Razor page, which allows for a simple development experience with a separation of concerns.</p>
			<p>It is important to understand the difference between these three types of presentation architectures so that you know which pattern you should use for your solution.</p>
			<p>Now, let's get to know clean architecture.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>Clean architecture</h2>
			<p>In the n-tier layered architecture, we<a id="_idIndexMarker355"/> learned that everything depends on the database layer, which is considered to be a transitive dependency. Clean architecture is considered domain-centric architecture. The business logic and application layers are at the center of the design. Instead of having the business logic depend on the data access layer, as is the case in the n-tier architecture, clean architecture inverts this dependency by forcing the infrastructure and other layers to depend on the application core.</p>
			<p>The following diagram shows a typical technique that can be used to visualize this architecture. It uses a series of concentric circles, which are similar to the rings of an onion:</p>
			<div><div><img src="img/Figure_5.11_B17366.jpg" alt="Figure 5.11: Clean architecture onion view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11: Clean architecture onion view</p>
			<p>In the preceding diagram, the<a id="_idIndexMarker356"/> circles represent the different components of the system, and the application core consists of the entities and the use cases. The key factor influencing this architecture is the dependency rule. It forces the dependency of the components to flow toward the center. The components in the inner circle should never depend on anything in the outer circle.</p>
			<p>As a result, if we declare a function or a class in the outer circle, it should not be visible in the inner circle. In the diagram, you can see how the dependencies flow toward the center from the most outer circle to where the use cases and the entities are located.</p>
			<p>Let's explore the key components of this architecture:</p>
			<ul>
				<li>The entities represent the business rules, such as objects and related methods.</li>
				<li>The use cases represent the application core, where all the use cases of the system are implemented. It manages the flow of data from and to the entities. This layer is not affected by the changes that might occur in the external layers, such as the database or the UI.</li>
				<li>The interface adapters are the layers that will contain the MVC components, such as the controllers, the views, and the presenters. This layer plays an intermediate role in converting the data coming from the use cases and entities into a suitable format for the external components, such as the database and the controllers. The models in this layer are used as data structures to exchange data between the use cases and the presenters or the views.</li>
				<li>The frameworks and drivers represent the outermost layer of this architecture. This layer contains the database and all of the UI code.</li>
			</ul>
			<p>The following diagram shows a<a id="_idIndexMarker357"/> horizontal view of this architecture:</p>
			<div><div><img src="img/Figure_5.12_B17366.jpg" alt="Figure 5.12: Clean architecture horizontal layer view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12: Clean architecture horizontal layer view</p>
			<p>In this diagram, there are two types of dependencies, which are represented by the style of the arrow. The solid arrow refers to compile-time dependencies, while the dashed arrow represents a runtime-only dependency. The <strong class="bold">User Interface</strong> layer deals with the interfaces defined in the application core with no direct access to the implementation in the <strong class="bold">Infrastructure</strong> layer. These interfaces are bound to the concrete implementation at runtime through <strong class="bold">dependency injection</strong>.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">Dependency injection<a id="_idIndexMarker358"/> is a software design pattern. The main purpose of this pattern is that it allows you to have loosely coupled code that supports architecture patterns, such as clean architecture, to reduce the tight coupling between the layers. It replaces the hardcoded dependencies between the classes by using a builder object to initialize objects and then inject those dependencies at runtime.</p>
			<p>The following screenshot shows<a id="_idIndexMarker359"/> a clean architecture solution template in <strong class="bold">Visual Studio</strong> with <strong class="bold">.NET 5</strong> and <strong class="bold">Angular 10</strong>:</p>
			<div><div><img src="img/Figure_5.13_B17366.jpg" alt="Figure 5.13: A typical project template using clean architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: A typical project template using clean architecture</p>
			<p>Let's explore each <a id="_idIndexMarker360"/>project in <a id="_idIndexMarker361"/>this .NET solution:</p>
			<ul>
				<li>The most inner layer is the <code>Domain</code> project. It doesn't reference any other layer, as shown in the following screenshot. On the right-hand side, you can see one of the entity's classes:</li>
			</ul>
			<div><div><img src="img/Figure_5.14_B17366.jpg" alt="Figure 5.14: The entities project in clean architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: The entities project in clean architecture</p>
			<ul>
				<li>Next, we have<a id="_idIndexMarker362"/> the <code>Application</code> project. As you can see, it references the <code>Domain</code> project. It contains all of the application logic by defining the interfaces that will be implemented in the infrastructure layer:</li>
			</ul>
			<div><div><img src="img/Figure_5.15_B17366.jpg" alt="Figure 5.15: The Application project in clean architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: The Application project in clean architecture</p>
			<ul>
				<li>Next, we <a id="_idIndexMarker363"/>have the <code>Infrastructure</code> layer, which contains the concrete implementation of the interfaces defined in the <code>Application</code> layer. As per the following screenshot, you can see that it references the <code>Application</code> layer: </li>
			</ul>
			<div><div><img src="img/Figure_5.16_B17366.jpg" alt="Figure 5.16: The Infrastructure project in clean architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16: The Infrastructure project in clean architecture</p>
			<ul>
				<li>The last <a id="_idIndexMarker364"/>layer is <code>WebUI</code> (please refer to <em class="italic">Figure 5.13</em>). This is a single-page application that uses <code>Application</code> layer and the <code>Infrastructure</code> layer.</li>
			</ul>
			<p>Many .NET solution templates support this architecture, which can be<a id="_idIndexMarker365"/> found on <strong class="bold">GitHub</strong> or <strong class="bold">NuGet</strong>. You can <a id="_idIndexMarker366"/>download one of the templates from NuGet to get started using the clean architecture. The following screenshot shows the NuGet command line required to install the same template that we used to explore this architecture: </p>
			<div><div><img src="img/Figure_5.17_B17366.jpg" alt="Figure 5.17: The command line required to install the clean architecture solution template"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17: The command line required to install the clean architecture solution template</p>
			<p>In this section, we learned about clean architecture along with its main components. In the next section, we will explore microservices architecture, which is considered to be one of the modern architectures.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>Microservices architecture</h2>
			<p>The microservices architecture<a id="_idIndexMarker367"/> allows you to divide the solution into various components. Each component is completely independent of the other components, and it provides a particular service. The following diagram shows the microservices architecture:</p>
			<div><div><img src="img/Figure_5.18_B17366.jpg" alt="Figure 5.18: The Microservices architecture style"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18: The Microservices architecture style</p>
			<p>As per the preceding diagram, you can see that the microservices architecture consists of a collection of independent services. Each service is self-contained and should provide a single business capability within a business domain.</p>
			<p>Let's examine the<a id="_idIndexMarker368"/> characteristics of this architecture pattern:</p>
			<ul>
				<li><strong class="bold">Microservices</strong> are small, autonomous, and loosely coupled services. Each service has its own code base, and it can be developed and maintained by a small team of developers.</li>
				<li>Each <strong class="bold">service</strong> should be self-contained and deployed separately. Updating one service won't require you to redeploy the entire solution.</li>
				<li>The services are responsible for having their own data access layer, as each service has a private database. </li>
				<li>The internal implementation of each service is not visible nor accessible by any other service. The communication between the services is achieved through proper APIs.</li>
				<li>The <strong class="bold">Client</strong> app has no direct access to the services. Consuming these services is achieved through the API gateway, which forwards the call to the appropriate services.</li>
			</ul>
			<p>The following screenshot shows a basic <a id="_idIndexMarker369"/>microservice project:</p>
			<div><div><img src="img/Figure_5.19_B17366.jpg" alt="Figure 5.19: An example microservice project"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19: An example microservice project</p>
			<p>In the preceding screenshot, you can see an order microservice that is consumed by an e-commerce solution. The main components<a id="_idIndexMarker370"/> of this microservice project are as follows:</p>
			<ul>
				<li><code>Models</code>: These are the data entities that hold the properties mapped to database fields.</li>
				<li><code>OrderContext</code>: This derives the entity framework, <code>DBContexts</code>. It is a bridge between the entity order and the database. </li>
				<li><code>OrderRepository</code>: This holds the CRUD functions, such as <code>GetOrder</code>, <code>CreateOrder</code>, and <code>UpdateOrder</code>. This class should implement the <code>IOrderRepository</code> interface.</li>
				<li><code>OrderController</code>: This is a class that is derived from <code>ControllerBase</code>. It contains all of the API RESTful actions.</li>
				<li><code>Docker</code>: This is the<a id="_idIndexMarker371"/> container that should simplify the deployment and testing of the microservice by bundling it along with all its dependencies into a single unit. It allows you to run the microservice in an isolated environment.</li>
			</ul>
			<p>The web API requests are handled by the <code>OrderController</code> class. The controller will call a function inside the repository that will use <code>DBContexts</code> along with the model to communicate with the database in order to return, add, or edit the requested data. </p>
			<p>In the next section, we will explore service-oriented architecture.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Service-oriented architecture</h2>
			<p><strong class="bold">Service-Oriented Architecture</strong> (<strong class="bold">SOA</strong>) allows <a id="_idIndexMarker372"/>you to consume services that are available in the network. Its structure is similar to n-tier architecture; the difference is that the presentation layer can't call the business layer directly, that is, it can only do so through the services. The following diagram shows the SOA in a layered structure:</p>
			<div><div><img src="img/Figure_5.20_B17366.jpg" alt="Figure 5.20: SOA"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20: SOA</p>
			<p>As you can see, the <strong class="bold">Service Layer</strong> is an abstraction layer located between the <strong class="bold">Presentation Layer</strong> and the <strong class="bold">Business Layer</strong>. With the existence of this layer, the <strong class="bold">Presentation Layer</strong> doesn't need to communicate directly with the <strong class="bold">Business Layer</strong>. In this scenario, you could change the <strong class="bold">Business Layer</strong> without affecting the <strong class="bold">Presentation Layer</strong>.</p>
			<p><em class="italic">What is the difference between microservices architecture and SOA?</em> Well, the answer is the scope. Microservices<a id="_idIndexMarker373"/> architecture is a cloud-based architecture; it promotes autonomous services that are self-contained, which target the application scope. While the SOA has an enterprise scope, each service does not need to have an independent database. It can handle multiple business capabilities; this is not the case for microservices, which only handle one single business capability at a time.</p>
			<p>Here is a list of .NET technologies that support you in the implementation of services (SOA):</p>
			<ul>
				<li><strong class="bold">.NET Web service</strong>: This is <a id="_idIndexMarker374"/>based <a id="_idIndexMarker375"/>on the <strong class="bold">Web Services Description Language</strong> (<strong class="bold">WSDL</strong>) (which is also known<a id="_idIndexMarker376"/> as <strong class="bold">XML Web Service</strong>). It is a service layer that contains a set of functions that uses a standardized XML messaging system.</li>
				<li><strong class="bold">Windows Communication Foundation</strong> (<strong class="bold">WCF</strong>): This is part of the .NET Framework and is used to build<a id="_idIndexMarker377"/> service-oriented solutions. By using WCF, you can send any type of data, such as asynchronous messages, from one endpoint to another.</li>
				<li><strong class="bold">ASP.NET RESTful Web API</strong>: This is <a id="_idIndexMarker378"/>also part of the .NET Framework. It is used to build HTTP services that can be consumed by any type of application including web and mobile applications.</li>
			</ul>
			<p>In this section, we explored some popular architecture patterns that can help us to create a solid foundation for our proposed solution. Adopting an architecture pattern is vital because it makes our platform more scalable and enhances the overall performance of the product. Additionally, it will prevent code redundancy.</p>
			<p>In the next section, we will explore another set of architecture patterns that you should know about.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Exploring additional architecture patterns</h1>
			<p>In this section, we will <a id="_idIndexMarker379"/>dive into a set of additional architecture patterns that will allow you to perform high-level scalability and system decoupling. We will examine each pattern to understand how it functions. This will help us to build more optimized systems with reusable modules and an organized structure that allows for extensibility. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>The serverless pattern</h2>
			<p><strong class="bold">Serverless architecture</strong> promotes cloud <a id="_idIndexMarker380"/>platforms and cloud-native code. It is a pattern that<a id="_idIndexMarker381"/> allows us to host our solution in a third-party infrastructure. Using this approach, the developers will no longer have to worry about managing the server software and hardware. This pattern allows us to break up our application into small and autonomous functions that can be triggered and scaled individually.</p>
			<p>The following diagram<a id="_idIndexMarker382"/> illustrates the serverless architecture of a<a id="_idIndexMarker383"/> single-page web application:</p>
			<div><div><img src="img/Figure_5.21_B17366.jpg" alt="Figure 5.21: The serverless architecture of a web app"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21: The serverless architecture of a web app</p>
			<p>We can use the <strong class="bold">Azure</strong> serverless infrastructure to implement this pattern. Azure functions include the following:</p>
			<ul>
				<li><strong class="bold">CDN</strong>: This stands<a id="_idIndexMarker384"/> for <strong class="bold">Content Delivery Network</strong>. It caches the content for a better response time.</li>
				<li><strong class="bold">Azure Blob Storage</strong>: This allows<a id="_idIndexMarker385"/> you to store large, unstructured data on <strong class="bold">Microsoft</strong>'s data storage platform.</li>
				<li><strong class="bold">Function App</strong>: This is an <a id="_idIndexMarker386"/>event-driven model that provides the capabilities to create autonomous functions that are triggered by the client through HTTP requests. The routing of the requests is managed by the API gateway, which is described next.</li>
				<li><strong class="bold">API Management</strong>: This is an <a id="_idIndexMarker387"/>API gateway that is located in front of the functions. It allows you to decouple the frontend app from the functions located in the backend. With this API management, we can rewrite the HTTP URLs and manage requests before they reach the concrete functions in the backend. Azure API management is also used to overcome cross-cutting concerns such as the following:<p>a. Caching HTTP responses</p><p>b. Monitoring and audit logging HTTP requests</p><p>c. Enabling <strong class="bold">Cross-Origin Requests Sharing</strong> (<strong class="bold">CORS</strong>), which enables access across domains</p><p>d. Enforcing policies such as checking HTTP requests and applying call rates</p><p>e. Protecting your API by enforcing an authentication mechanism by using <strong class="bold">Auth2.0 authorization</strong> with <strong class="bold">Azure Active Directory (Azure AD)</strong></p></li>
				<li><strong class="bold">Azure Cosmos DB</strong>: This is a <strong class="bold">NoSQL</strong> database service provided by Azure to build modern <a id="_idIndexMarker388"/>applications.</li>
				<li><strong class="bold">Azure AD</strong>: This is the cloud version of the regular active directory. It is used to authenticate <a id="_idIndexMarker389"/>users. </li>
				<li><strong class="bold">Azure Monitor</strong>: This<a id="_idIndexMarker390"/> collects performance metrics about the solution and the usage of resources.</li>
				<li><strong class="bold">Azure Pipelines</strong>: This is <a id="_idIndexMarker391"/>another service provided by Microsoft Azure. It provides <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">Continuous Delivery</strong> (<strong class="bold">CD</strong>) services to automatically build, test, and deploy your code to any accessible target.</li>
			</ul>
			<p>This pattern is perfect if you wish to implement the microservices architecture or if you want to scale your solution and benefit from pay-as-you-go services.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>The client-server pattern</h2>
			<p>A <strong class="bold">client-server pattern</strong> is a <a id="_idIndexMarker392"/>network architecture that involves two types of entities: the clients<a id="_idIndexMarker393"/> and the server. It is used in scenarios where you have a server playing the role of a service provider and multiple clients playing the role of service consumers. The following diagram describes the logic behind this architecture:</p>
			<div><div><img src="img/Figure_5.22_B17366.jpg" alt="Figure 5.22: Client-server architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22: Client-server architecture</p>
			<p>As you see in the preceding diagram, the <strong class="bold">Client</strong> components send an HTTP request over the <strong class="bold">TCP/IP</strong> protocol to the server. The request is processed, and the server connects to the database <strong class="bold">Server</strong> and then responds back to the <strong class="bold">Client</strong>.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/>The event-driven pattern</h2>
			<p><strong class="bold">Event-driven architecture</strong> is another <a id="_idIndexMarker394"/>pattern that allows us to highly decouple our <a id="_idIndexMarker395"/>applications. It is a pattern that consists of a set of services. Each service works asynchronously and publishes an event when its data is updated. The client components subscribe to the events to receive or send updates. </p>
			<p>Let's assume that we are building an e-commerce solution where customers are using coupon codes while submitting an order. The system must ensure that the coupon code is only used once by the same customer. Since the customer information, the number of orders, and the coupon code details are located in different databases, the system cannot simply verify the usage of the coupon code. The solution is to use the event-driven pattern to maintain data consistency across the different services.</p>
			<p>The following <a id="_idIndexMarker396"/>diagram shows <a id="_idIndexMarker397"/>the Azure event-driven architecture:</p>
			<div><div><img src="img/Figure_5.23_B17366.jpg" alt="Figure 5.23: Event-driven architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23: Event-driven architecture</p>
			<p>In the preceding diagram, pay attention to how the <strong class="bold">HR Application</strong> is subscribing to the <strong class="bold">Employee Events</strong> and each event has its own logic and database.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>The pipe-filter pattern</h2>
			<p>The <strong class="bold">pipe-filter pattern</strong> consists<a id="_idIndexMarker398"/> of splitting a complex process into a group of smaller <a id="_idIndexMarker399"/>tasks. This approach is expected to improve the performance of our application as well as the reusability and maintainability of each task. A single event triggers a sequence of multiple steps, with each performing a specific task. The following diagram shows an example process that has been implemented using the pipe-filter architecture:</p>
			<div><div><img src="img/Figure_5.24_B17366.jpg" alt="Figure 5.24: The pipe-filter pattern"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24: The pipe-filter pattern</p>
			<p>A good example of this pattern is <a id="_idIndexMarker400"/><strong class="bold">Azure Data Factory</strong>, which allows you to create data-driven automated<a id="_idIndexMarker401"/> workflows in the cloud for data extraction, analysis and <a id="_idIndexMarker402"/>transformation, and loading.</p>
			<p>In this section, we explored a set of architectural patterns that you should know about. Each one offers a unique methodology of implementation and delivers key advantages to your solution. In the next section, we will learn how to choose the right architecture pattern when designing a solution.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Choosing the right patterns</h1>
			<p>In the previous <a id="_idIndexMarker403"/>sections, we learned about major architectural patterns. However, you must have noticed that there are a few patterns that we didn't discuss in this chapter. In fact, some patterns will be introduced in the future. So, you will need a way in which to analyze a pattern and decide whether you want to choose it or not. One question that you could be asked is <em class="italic">how do we choose the right pattern for our solution?</em> Let's dig deep into this matter.</p>
			<p>Architecture design is the cornerstone of a solid and successful system. However, there is no one-size-fits-all solution when it comes to choosing the right architecture for your solution. Various perspectives should be taken into account when you want to decide which architecture pattern to use.</p>
			<p>Put simply, the main selection criterion for choosing an architecture pattern is based on three factors:</p>
			<ul>
				<li><strong class="bold">Software engineers</strong> (who will work on the project): Software engineers should be familiar with the architecture you are proposing. This is so that they can easily navigate through the solution structure and start implementing new features as per the requirements. Then, at a later stage, when the product is delivered, it should be clear and straightforward to them how to fix any defects and which layers need to be modified. This is a very important factor to consider in order for the team to work efficiently and deliver a successful and stable product.</li>
				<li><strong class="bold">Client</strong>: From the clients' perspective, they are looking for a good quality product while maintaining efficiency. Additionally, they want to make sure that the implemented architecture can support additional features and modifications even after releasing the product. They want their product to be well-architected, scalable, and easy to maintain.</li>
				<li><strong class="bold">Product type</strong>: Note that it is not a good practice to select an architecture pattern just because it is widely popular or because it is trendy. Don't assume that this will deliver a better product. However, an architecture pattern should be selected based on your requirements and the type of solution we want to build. This will allow you to<a id="_idIndexMarker404"/> deliver a successful product.</li>
			</ul>
			<p>We have explored the three main factors that should affect your selection of the architecture. Furthermore, here is a criterion list with key characteristics that you should consider when selecting an architecture pattern:</p>
			<ul>
				<li><strong class="bold">Agility</strong>: We should consider choosing the architecture that allows for high agility, which helps us to embrace and implement additional features and changes easily.</li>
				<li><strong class="bold">Ease of deployment</strong>: The architecture we choose should allow us to easily deploy the product.</li>
				<li><strong class="bold">Testability</strong>: The architecture should allow for a high testability rate.</li>
				<li><strong class="bold">Performance</strong>: This is an important factor. The architecture should allow for a high-performance rate.</li>
				<li><strong class="bold">Scalability</strong>: The architecture must allow us to scale our system, which means increasing its capacity. </li>
				<li><strong class="bold">Ease of development</strong>: The architecture should be well known by developers to ensure the easy development and implementation of the product. It should allow developers to troubleshoot <a id="_idIndexMarker405"/>the system and fix defects when needed.</li>
			</ul>
			<p>One of the primary reasons that might cause complete system failure is choosing the wrong architecture pattern. That's why it is important to choose the right architecture pattern for your system, as it will solve various problems that you might face during the several phases of the project life cycle.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Summary</h1>
			<p>In this chapter, we explored key architecture patterns that are widely used in many solutions along with some modern patterns, such as clean architecture and microservices architecture. We also learned about a set of important architectural patterns that allow you to perform system decoupling and scalability. Finally, in this chapter, we explored the key factors that you need to consider when choosing the right architecture pattern.</p>
			<p>In the next chapter, we will dig deep into core architecture considerations, such as the design quality attributes and how to properly plan for system caching, exception handling, and deployment.</p>
		</div>
	</body></html>