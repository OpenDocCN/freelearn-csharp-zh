- en: Chapter 14. A Road Ahead
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。前方的路
- en: 'It has been a whirlwind journey on various topics through our book. If you
    have reached this point, you might have come across some new concepts, or might
    have had a fresh look at some things that you already knew. Broadly speaking,
    the theme of this book can be divided into the following four sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的书中，我们经历了一场关于各种主题的风暴之旅。如果你已经到达这个阶段，你可能已经遇到了一些新概念，或者可能对你已经知道的一些事情有了新的看法。总的来说，本书的主题可以分为以下四个部分：
- en: Putting patterns into perspective (Chapter 1 and 2)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模式置于正确的视角（第1章和第2章）
- en: GoF in action (Chapter 3 through 7)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoF实践（第3章至第7章）
- en: Object/functional programming (Chapter 8 to 10)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象/函数式编程（第8章至第10章）
- en: (Functional) reactive programming (Chapter 11, 12, and 13)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （功能）响应式编程（第11章、第12章和第13章）
- en: 'Patterns are an interesting topic, and they have helped software developers
    to address complex business problems by providing proven and time-tested solutions.
    It has also improved communication between developers and their stakeholders.
    By learning patterns, as a developer, you get distilled knowledge and experience
    of those master programmers who cataloged these patterns. But there are some more
    topics that you should know in your journey as a developer or an architect. The
    authors of this book consider the following four topics of great interest to a
    professional (as a continuation of the topics covered in this book):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是一个有趣的话题，它们通过提供经过验证和经得起时间考验的解决方案，帮助软件开发者解决复杂的业务问题。它也改善了开发者和他们的利益相关者之间的沟通。通过学习模式，作为一名开发者，你可以获得那些编目这些模式的资深程序员的知识和经验。但在你作为开发者或架构师的旅程中，还有一些其他主题是你应该知道的。本书的作者认为以下四个主题对专业人士来说非常有兴趣（作为本书所涵盖主题的延续）：
- en: Polyglot programming and design (multi paradigm programming)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言编程和设计（多范式编程）
- en: Domain-specific languages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: Ontology
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本体论
- en: AntiPatterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反模式
- en: Polyglot programming and design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言编程和设计
- en: 'Modern applications are complex to develop as they might have the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序的开发可能很复杂，因为它们可能具有以下特点：
- en: Service layer with a database for persistence ( SQL or NoSQL)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有数据库持久化（SQL或NoSQL）的服务层
- en: The UI code has to be responsive and calibrated for different form factor devices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI代码必须对不同的设备形态做出响应并进行校准
- en: The frontend code is mostly based on some kind of **Single Page Architecture**
    (**SPA**) architecture
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端代码主要基于某种**单页应用架构**（SPA）架构
- en: In some cases, there can be desktop and mobile native frontends
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会有桌面和移动原生前端
- en: 'A developer who has been hired for such a project should have the following
    skills:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 被雇佣参与此类项目的开发者应该具备以下技能：
- en: Java, C#, PHP, Ruby, or Grails for writing service layers (skills in one or
    more)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java、C#、PHP、Ruby或Grails用于编写服务层（掌握一种或多种技能）
- en: For writing UI code, they should be familiar with CSS libraries and JavaScript
    (e.JQuery)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于编写UI代码，他们应该熟悉CSS库和JavaScript（例如JQuery）
- en: For web-based responsive frontend, TypeScript/JavaScript using Angular, ReactJs,
    or any other JavaScript-based framework
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于Web的响应式前端，使用TypeScript/JavaScript结合Angular、ReactJs或其他基于JavaScript的框架
- en: For writing desktop applications, the choices are C#, C++, Objective C/C++,
    Python, or Java
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于编写桌面应用程序，选择有C#、C++、Objective C/C++、Python或Java
- en: For mobile application development (native), choices are C#, Java, or Objective
    C/Swift
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于移动应用程序开发（原生），选择有C#、Java或Objective C/Swift
- en: The bottom line here is that one should be comfortable with at least more than
    half a dozen programming languages to be in a position to work with modern projects.
    If you add skills in PowerShell, Bash shell, JSP/HTML/template engines, XML, JSON,
    and so on, we are indeed living in a world where a person has to be really conversant
    in as many languages as possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里底线是，一个人应该至少熟悉超过半打编程语言，才能在现代项目中工作。如果你还掌握了PowerShell、Bash shell、JSP/HTML模板引擎、XML、JSON等技能，我们确实生活在一个一个人必须尽可能精通多种语言的世界。
- en: Let us trace the evolution of this state of affairs by quickly chronicling the
    history of development under the PC platform. The programming landscape has changed
    quite a lot in the last decade. When the GoF pattern book was written, programming
    languages such as Java and C# had not been born. The dominant object-oriented
    programming language in those days, for all practical purpose was C++. Even for
    C++, the ANSI standards were not ratified (it happened only in 1998). Other than
    C++, languages such as Delphi (Object Pascal),Visual Basic, PowerBuilder, and
    various xBase dialects (Clipper, FoxPro, and the like) were widely used by programmers
    of that era. Platforms such as Microsoft Windows were just evolving. Various flavors
    of UNIX and MS-DOS were the primary platforms (even GNU Linux had not reached
    a critical mass in those times!).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾 PC 平台下的开发历史，以追踪这一状况的演变。在过去十年中，编程环境发生了很大的变化。当 GoF 模式手册被编写时，像 Java 和 C#
    这样的编程语言还没有出现。当时占主导地位的对象导向编程语言，从所有实际目的来看是 C++。即使是 C++，ANSI 标准（直到 1998 年才得到批准）。除了
    C++，像 Delphi（Object Pascal）、Visual Basic、PowerBuilder 以及各种 xBase 方言（如 Clipper、FoxPro
    等）在那个时代的程序员中被广泛使用。像 Microsoft Windows 这样的平台正在发展。各种版本的 UNIX 和 MS-DOS 是主要平台（甚至当时
    GNU Linux 还没有达到临界质量！）
- en: Even in the early years of programming, it was realized that one cannot build
    solutions using a single programing language. We need to mix and match programming
    languages that are apt for the context. At one point in time, most numerical libraries
    were written in Fortran, and those libraries were interfaced with the C language
    for writing systems, which are numerically intensive. In the early years of programming,
    people used to write code in a high-level language, and interface their code with
    routines written in C and assembler. Thus, a programmer needs to know a high-level
    language, C programing language, and the syntax of the assembly language of the
    environment in which the program was developed and deployed. The process of developing
    a large system using different programming languages for writing different subsystems
    and composing them to create a larger system is called polyglot programming. Designing
    such systems, where there is a multitude of programming languages and technology
    stacks, is called polyglot design. To design such a system, developers should
    be able to think in a language-and-platform-agnostic manner.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在编程的早期阶段，人们就已经意识到不能仅使用一种编程语言来构建解决方案。我们需要根据上下文混合使用适合的编程语言。在某个时期，大多数数值库都是用 Fortran
    编写的，而这些库通过与 C 语言接口来编写系统，这些系统对数值计算有很高的要求。在编程的早期，人们通常使用高级语言编写代码，并将代码与用 C 和汇编语言编写的例程接口。因此，程序员需要了解高级语言、C
    编程语言以及程序开发和部署环境中汇编语言的语法。使用不同的编程语言编写不同的子系统，并将它们组合起来创建更大系统的开发过程被称为多语言编程。设计这样的系统，其中存在多种编程语言和技术堆栈，被称为多语言设计。为了设计这样的系统，开发者应该能够以语言和平台无关的方式进行思考。
- en: The movement towards polyglot programming started in the early years of programming
    on the IBM PC platform. Polyglot programming was mostly an affair of interfacing
    routines written in the C programming language to a high-level language chosen
    for writing the system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言编程的潮流始于 IBM PC 平台的早期编程阶段。多语言编程主要涉及将用 C 编程语言编写的例程与用于编写系统的所选高级语言进行接口。
- en: Polyglot programming with C/C++
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 C/C++ 进行多语言编程
- en: When people programmed in various languages other than C/C++, there were options
    available for interfacing with C/C++, code packaged as DLLs or `.so` in Windows
    and Unix/Linux, respectively. In MS-DOS, all xBase languages offered an interface
    mechanism to interact with the native code written in C/C++ and Assembler/. In
    the Microsoft Windows platform, Visual Basic offered a mechanism to call routines
    written in C/C++/. Using this mechanism, people consumed a vast amount of Windows
    API functions provided by Microsoft. People began to program Windows using Visual
    Basic and Visual C++. The visual development environments such as Delphi and PowerBuilder
    also provided similar mechanisms to consume code written in C/C++. This can be
    considered as the beginning of programming systems using multiple languages, and
    is nowadays called Polyglot programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们使用除C/C++以外的各种语言进行编程时，有选项可以用于与C/C++接口，代码在Windows中以DLL打包，在Unix/Linux中以`.so`打包。在MS-DOS中，所有xBase语言都提供了一个与用C/C++和汇编器编写的本地代码交互的接口机制。在Microsoft
    Windows平台上，Visual Basic提供了一个调用用C/C++编写的例程的机制。使用这个机制，人们消耗了大量的由Microsoft提供的Windows
    API函数。人们开始用Visual Basic和Visual C++编写Windows程序。像Delphi和PowerBuilder这样的可视化开发环境也提供了类似的机制来消耗用C/C++编写的代码。这可以被认为是使用多种语言编程系统的开始，现在被称为多语言编程。
- en: With the advent of the Java programming language, the promise of platform-neutral
    programming became a buzzword in the Industry. The **write once, run everywhere**
    (**WORE**) mantra came to the fore, and it did not prevent the implementers of
    Java to give a mechanism to interact with native code written in C/C++. The interface
    was called **Java Native Interface** (**JNI**). Using this mechanism, people wrote
    wrappers around technologies such as Direct3D and OpenGL to create libraries like
    Java 3D. The popular computer vision system, OpenCV, is interfaced with Java software
    using JNI.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java编程语言的问世，平台无关编程的承诺在业界成为了一个热门词汇。**一次编写，到处运行**（**WORE**）的口号浮出水面，这并没有阻止Java的实现者提供一个与用C/C++编写的本地代码交互的机制。这个接口被称为**Java本地接口**（**JNI**）。通过这个机制，人们围绕Direct3D和OpenGL等技术编写了包装器，创建了如Java
    3D这样的库。流行的计算机视觉系统OpenCV就是通过JNI与Java软件进行接口的。
- en: 'The .NET platform was unveiled in the year 2001, and it gave two interfaces
    to interface with the native code. The first one was PInvoke, a mechanism to interface
    with Win2/Win64 calls exported out of DLLs. Microsoft also gave a mechanism to
    call C++-based COM components called COM interoperability. They named it COM callable
    wrapper. To demonstrate the use of P/Invoke, here is a small C/C++ code snippet
    (compiled into a DLL) interfaced with C# code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: .NET平台在2001年公布，它提供了两个与本地代码接口的接口。第一个是PInvoke，这是一个与从DLL中导出的Win2/Win64调用进行接口的机制。Microsoft还提供了一个调用基于C++的COM组件的机制，称为COM互操作性。他们将其命名为COM调用包装器。为了演示P/Invoke的使用，这里有一个小的C/C++代码片段（编译成DLL）与C#代码接口：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can compile the preceding code using the Visual C++ compiler or MinGW compiler
    (GCC under Windows ) to create a DLL. We have used the MinGW 32-bit compiler to
    generate the Win32 DLL. The DLL can be interfaced with C# code written using Visual
    Studio or Mono compiler under Windows. If you know how to build a shared library
    (`.so`) under Mac OS X or GNU Linux, we can run the code on those platforms as
    well. The C# code can be used to invoke the DLL written previously:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Visual C++编译器或MinGW编译器（Windows下的GCC）来编译前面的代码，创建一个DLL。我们使用了MinGW 32位编译器来生成Win32
    DLL。该DLL可以与使用Visual Studio或Mono编译器在Windows下编写的C#代码接口。如果你知道如何在Mac OS X或GNU Linux下构建共享库（`.so`），我们也可以在这些平台上运行代码。C#代码可以用来调用之前编写的DLL：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The polyglot web programming
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多语言网络编程
- en: The **World Wide Web** (**WWW**) reached critical mass roughly in the year 1995,
    and the programming landscape changed all of a sudden. People who learned to program
    desktop systems using Windows API and X/Windows API found themselves in a position
    of great difficulty, forced to grapple with the complexities of the **Common Gateway
    Interface** (**CGI**), NSAPI, and ISAPI programming model to generate dynamic
    web pages. The languages of choice were Perl and TCL for CGI, and C/C++ for NSAPI/ISAPI.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网**（**WWW**）在1995年左右达到了临界质量，编程景观突然发生了变化。那些学习使用Windows API和X/Windows API编写桌面系统程序的人发现自己处于极大的困难之中，被迫处理**通用网关接口**（**CGI**）、NSAPI和ISAPI编程模型的复杂性，以生成动态网页。选择的语言是用于CGI的Perl和TCL，以及用于NSAPI/ISAPI的C/C++。'
- en: The situation continued for some time, and it all changed all of a sudden when
    Microsoft brought out **Active Server Pages** (**ASP**) for creating dynamic web
    pages. Soon, Sun Microsystems came up with Java Servlet API. The Servlet API was
    a low-level API like C++-based ISAPI, and Sun soon brought out **JavaServer Pages**
    (**JSP**), a technology that embedded Java code inside markups. The JSPs were
    converted to Servlet code on the fly using the Java Compiler system available
    on the executing machine. There were technologies such as ColdFusion, which leveraged
    custom markups to write extensible applications, and had the capacity to interact
    with code written in Java. The Web programming model mandated people to learn
    C++, Java, Visual Basic, and ASP to write dynamic web pages. On the Microsoft
    platform, people began to write VBScript code interspersed with calls to COM/ActiveX
    objects written in C++ and Visual Basic. In fact, the emergence of web-based application
    delivery forced programmers to become a true polyglot.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况持续了一段时间，直到微软推出了用于创建动态网页的 **Active Server Pages** (**ASP**)，一切突然发生了变化。不久之后，Sun
    Microsystems 推出了 Java Servlet API。Servlet API 是一个类似于基于 C++ 的 ISAPI 的低级 API，Sun
    很快又推出了 **JavaServer Pages** (**JSP**)，这是一种将 Java 代码嵌入到标记中的技术。JSP 在执行机器上可用的 Java
    编译器系统的动态转换成 Servlet 代码。还有像 ColdFusion 这样的技术，它利用自定义标记来编写可扩展的应用程序，并且能够与用 Java 编写的代码进行交互。网络编程模型要求人们学习
    C++、Java、Visual Basic 和 ASP 来编写动态网页。在微软平台上，人们开始编写 VBScript 代码，并在其中穿插调用用 C++ 和
    Visual Basic 编写的 COM/ActiveX 对象。实际上，基于网络的 Web 应用程序交付迫使程序员成为真正的多语言者。
- en: The JavaScript evolution
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 的发展历程
- en: The emergence of JavaScript was another thing that forced developers to learn
    yet another language to add a bit of interactivity to their web pages. In those
    times, people were mostly comfortable with statically typed languages, and found
    JavaScript to be a weird language. JavaScript remained in relative obscurity for
    a long time, until someone found out a clever way to mix JavaScript with IE ActiveX
    plugin. In the early years of the twenty-first century, people began to write
    user interfaces by embedding browser controls inside a desktop container, and
    used JavaScript as a glue language to interact with the ActiveX controls embedded
    in those pages. JavaScript picked up momentum, and people began to consider it
    as a first class programming language after the advent of Google's V8 engine and
    the Node.js platform. Another shot in the arm was the support for functional style
    programming using the JavaScript language, and the emergence of libraries such
    as JQuery, Angular, ReactJS, and the like. In the last decade, knowledge of the
    JavaScript programming language became essential for all programmers, whether
    they wrote server code or client code. JavaScript is another language that programmers
    were forced to learn.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的出现又迫使开发者学习另一种语言，以便在网页中添加一些交互性。在当时，人们大多对静态类型语言感到舒适，并认为 JavaScript
    是一种奇怪的语言。JavaScript 在一段时间内相对默默无闻，直到有人发现了一种巧妙的方法将 JavaScript 与 IE ActiveX 插件混合。在21世纪初的早期，人们开始通过在桌面容器中嵌入浏览器控件来编写用户界面，并使用
    JavaScript 作为粘合语言与嵌入在这些页面中的 ActiveX 控件进行交互。随着 Google 的 V8 引擎和 Node.js 平台的推出，JavaScript
    开始获得动力，并在那时人们开始将其视为一等编程语言。另一个推动力是支持使用 JavaScript 语言进行函数式编程风格，以及诸如 JQuery、Angular、ReactJS
    等库的出现。在过去的十年中，对 JavaScript 编程语言的知识对所有程序员来说都变得至关重要，无论他们编写的是服务器端代码还是客户端代码。JavaScript
    是程序员被迫学习的另一种语言。
- en: Dynamic/scripting languages
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态/脚本语言
- en: The emergence of Perl, Python, PHP, Ruby, TCL, and Groovy for writing command
    line, GUI, and web applications forced developers to master some of them in their
    day-to-day job. PERL is still widely used for writing CGI applications, automation
    scripts, and even GUI applications (Perl/TK) all across the world. The Python
    programming language is the de-facto programming language for writing (or at least
    learning) machine learning programs because of the libraries available in that
    language, and they are widely used for writing web applications with some MVC
    frameworks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Perl、Python、PHP、Ruby、TCL 和 Groovy 等语言的兴起，用于编写命令行、GUI 和网络应用程序，迫使开发者必须在日常工作中掌握其中的一些。PERL
    仍然被广泛用于编写 CGI 应用程序、自动化脚本，甚至全球范围内的 GUI 应用程序（Perl/TK）。由于 Python 编程语言中提供了丰富的库，因此它成为了编写（或至少学习）机器学习程序的默认编程语言，并且这些库被广泛用于使用一些
    MVC 框架编写网络应用程序。
- en: Both Ruby on Rails and Groovy and Grails ushered in a rapid development lifecycle
    era to make their penetration in the start-up ecosystem. PHP is the most popular
    web development system in the world, and it is especially suited for writing front-facing
    applications. The sheer number of content management systems available with the
    platform is another attraction. Architecting solutions with PHP for front-facing
    pages, Java for Service logic, and Silverlight for frontend (for interactive parts)
    became popular in some circles! The popularity of the REST paradigm has made writing
    the server-side logic to be in whatever language one chooses to. As long as the
    URI is consistent, the routing system makes sure that it resolves the correct
    handler logic to get executed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby on Rails和Groovy与Grails都引领了快速开发周期时代，使它们在创业生态系统中迅速渗透。PHP是世界上最受欢迎的Web开发系统，特别适合编写前端应用程序。该平台提供的众多内容管理系统数量也是一个吸引力。在一些人圈子中，使用PHP构建前端页面、Java构建服务逻辑、Silverlight构建前端（用于交互部分）变得流行！REST范式的流行使得服务器端逻辑的编写可以任选任何一种语言。只要URI保持一致，路由系统就会确保它解析并执行正确的处理逻辑。
- en: Emergence of functional programming
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程的兴起
- en: As mentioned in the first chapter, Herb Sutter's seminal article titled, *The
    Free Lunch Is Over*, rekindled interest in functional programming, which was mostly
    relegated to academic circles. The FP model was well suited for exploiting the
    many-core processing world. The stateless computation model of the FP helps to
    scale an application from a single core to dozens of cores without any additional
    programming effort. The emergence of Scala, F#, Clojure, Haskell (in some niche
    areas), and so on, and the availability of them in the JVM and CLR world made
    them a viable choice for writing some applications. In the Microsoft world, people
    began to write code in C# and F#, to bundle the code inside the same system. Learning
    a functional language (one or more) became absolutely essential for modern-day
    programmers. Another excuse to become a polyglot!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一章所述，Herb Sutter的标志性文章《The Free Lunch Is Over》重新点燃了对函数式编程的兴趣，这种编程主要被限制在学术圈。FP模型非常适合利用多核处理世界。FP的状态无状态计算模型有助于将应用程序从单核扩展到数十核，而无需任何额外的编程工作。Scala、F#、Clojure、Haskell（在某些细分领域）等语言的兴起，以及它们在JVM和CLR世界中的可用性，使它们成为编写某些应用程序的可行选择。在微软的世界里，人们开始用C#和F#编写代码，将代码打包在同一系统中。学习一种（或多种）函数式语言对于现代程序员来说变得绝对必要。成为多语言者的另一个借口！
- en: Mobile revolution
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动革命
- en: Some competence in mobile application development is necessary for every software
    developer in the world. Apple's iOS, Google's Android, and Microsoft's Windows
    Phone are the leading platforms in this arena. Unfortunately, native application
    development languages in these platforms are Objective C/Swift (iOS), Java (Android),
    and C# (Windows Phone). A .NET developer has to learn Java, Objective C, or Swift
    to write native applications for these platforms. If you want to avoid this, you
    might have to use hybrid application development with JavaScript as a programming
    language. Anyway, you need to be a Polyglot!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于世界上的每一位软件开发者来说，具备移动应用程序开发的能力是必要的。苹果的iOS、谷歌的Android和微软的Windows Phone是这一领域的领先平台。不幸的是，这些平台的原生应用程序开发语言分别是Objective
    C/Swift（iOS）、Java（Android）和C#（Windows Phone）。.NET开发者必须学习Java、Objective C或Swift才能为这些平台编写原生应用程序。如果你想避免这种情况，你可能不得不使用JavaScript作为编程语言的混合应用程序开发。无论如何，你需要成为一个多语言者！
- en: A quick note on polyglot persistence
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于多语言持久性的简要说明
- en: 'For a long time, the **Relational database management systems** (**RDBMSs**)
    became the backbone of every business application ever developed. The Oracle Server,
    Microsoft SQL Server, MYSQL, and Postgres systems were the de-facto choice for
    persisting data. The emergence of the NoSQL movement gave us different types of
    databases suitable for distributed programs, which should scale well. They are
    listed as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，**关系数据库管理系统**（**RDBMSs**）成为了每个已开发业务应用程序的骨架。Oracle Server、Microsoft
    SQL Server、MYSQL和Postgres系统是数据持久化的默认选择。NoSQL运动的兴起为我们提供了适合分布式程序的不同类型的数据库，这些数据库应该具有良好的可扩展性。它们如下列出：
- en: Columnar databases
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列存储数据库
- en: Key/value databases
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值数据库
- en: Document databases
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数据库
- en: Graph databases
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: 'NoSQL is a vast and varied topic, and the reader is expected to search Google
    to understand it, as a fair treatment of it warrants many books. So, a modern
    web-based application might store data in various persistence technologies available,
    based on the application context. A typical use case could be any one of the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL是一个庞大且多样化的主题，读者应搜索Google来了解它，因为对其公平的对待需要许多书籍。因此，一个现代的基于Web的应用程序可能会根据应用程序上下文存储在可用的各种持久化技术中的数据。一个典型的用例可能是以下任何一个：
- en: An RDBMS for storing transactional data
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储事务数据的RDBMS
- en: A key/value database for storing master data (for faster lookup)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储主数据（以实现更快查找）的键/值数据库
- en: A graph database for storing relationship between entities
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储实体之间关系的图数据库
- en: A columnar database for data that is part of analytical queries
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储分析查询数据的列式数据库
- en: By choosing the appropriate backend technologies, the application can ensure
    throughput and scalability for large-scale applications development. The process
    of using different persistence technologies in an application is called **polyglot
    persistence**. A developer should be really familiar with this paradigm along
    with polyglot programming.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择适当的后端技术，应用程序可以确保大规模应用程序开发的吞吐量和可伸缩性。在应用程序中使用不同持久化技术的过程称为**多语言持久性**。开发者应该真正熟悉这种范式以及多语言编程。
- en: How to become a polyglot programmer?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何成为一名多语言程序员？
- en: 'From a programming paradigm perspective, there are only three types of programming
    languages in this world, which are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程范式角度来看，世界上只有三种类型的编程语言，如下所示：
- en: Functional languages (based on lambda calculus)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式语言（基于λ演算）
- en: Logic languages (based on predicate logic)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑语言（基于谓词逻辑）
- en: Imperative languages (based on Turing machines)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式语言（基于图灵机）
- en: To be a contemporary developer, one needs to master a couple of languages from
    each family. To be competent in FP, the language options available are F#, Clojure,
    and Scala. The logic programming languages are Prolog and Datalog. Learning them
    will help on improving design skills, especially in building hierarchical data
    structures. The type inference algorithm available with F#, Scala, and C# uses
    the unification algorithm, which forms the backbone of the Prolog language. Thus,
    understanding the Prolog machine model helps you to appreciate and exploit the
    rich type systems available with the modern programming languages. Most of the
    popular languages are imperative in nature, and mastering a couple of object/functional
    languages (such as C#, Java 8, and Scala) really helps. Once you learn a representative
    language from each of the aforementioned families, you have made the cognitive
    leap to understanding every programming language ever created or going to be created
    in the near future!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一名当代开发者，需要掌握每个家族中的几种语言。要精通函数式编程（FP），可用的语言选项有F#、Clojure和Scala。逻辑编程语言有Prolog和Datalog。学习它们将有助于提高设计技能，尤其是在构建层次数据结构方面。F#、Scala和C#中可用的类型推断算法使用统一算法，这是Prolog语言的基础。因此，理解Prolog机器模型有助于你欣赏并利用现代编程语言中丰富的类型系统。大多数流行的语言在本质上都是命令式的，掌握几种面向对象/函数式语言（如C#、Java
    8和Scala）确实很有帮助。一旦你学习了上述每个家族中的一个代表性语言，你就已经实现了对今后可能创建的或即将创建的任何编程语言的认知飞跃！
- en: Domain-specific languages
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: A language developed for expressing solutions to problems that are specific
    to a domain such as finance, payroll, electronic circuit design, parser generators,
    input validations, and so on is called a **domain-specific language** (**DSL**).
    Two common examples that are familiar to most programmers are **Structured Query
    Language** (**SQL**) and **regular expression** (**RE**). If we were to write
    imperative code for retrieving data from a database, it would have been a difficult
    task and error prone. SQL gives you a declarative language to achieve the same
    objective, and it has solid mathematical foundations. While searching strings,
    RE helps us to give complicated patterns to match against a string. It helps to
    avoid writing tedious logic for searching complicated string matches.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一种用于表达特定领域（如金融、工资单、电子电路设计、解析器生成器、输入验证等）问题的解决方案的语言被称为**领域特定语言**（**DSL**）。两个大多数程序员都熟悉的常见例子是**结构化查询语言**（**SQL**）和**正则表达式**（**RE**）。如果我们编写
    imperative 代码从数据库中检索数据，这将是一项困难的任务，并且容易出错。SQL为你提供了一个声明性语言来实现相同的目标，并且它有坚实的数学基础。在搜索字符串时，RE帮助我们给出复杂的模式以匹配字符串。它有助于避免编写繁琐的逻辑来搜索复杂的字符串匹配。
- en: 'As a concrete example of a DSL, which is quite popular in the .NET and Java
    world, we are pasting here a specification given to the **ANTLR** tool to write
    a very simple arithmetic evaluator. The tool generates a lexical analyzer and
    parser automatically from this specification. Please consult the ANTLR documentation
    to understand the semantics of the following script:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为.NET和Java世界中相当流行的DSL的具体例子，我们在此粘贴了一个提供给**ANTLR**工具的规范，用于编写一个非常简单的算术评估器。该工具自动从这个规范生成词法分析器和解析器。请查阅ANTLR文档以了解以下脚本的语义：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The ANTLR tool will generate a lexical analyzer, a parser module, and even a
    tree walker to process the expression. We can write parsers for C#, Java, and
    even C/C++ using this tool. In the Unix and the Windows native programming world,
    the tool Lex (GNU Flex) and Yacc (GNU Bison) is used for the same purpose.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ANTLR工具将生成一个词法分析器、一个解析模块，甚至一个树遍历器来处理表达式。我们可以使用这个工具为C#、Java，甚至C/C++编写解析器。在Unix和Windows原生编程世界中，用于相同目的的工具是Lex（GNU
    Flex）和Yacc（GNU Bison）。
- en: 'As another case in point, authors worked in a DSL project, which evaluated
    a spreadsheet for consistency. A code snippet from the turing complete DSL generated
    for the project is given here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个案例，作者在一个领域特定语言（DSL）项目中工作，该项目评估了一个电子表格的一致性。以下是该项目为图灵完备的DSL生成的代码片段：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code snippet was parsed using a hand-coded recursive descent parser,
    and an **abstract syntax tree** (**AST**) was generated. The tree was traversed
    in a depth-first manner to generate a .NET IL code to generate a .NET assembly
    (DLL). The resulting assembly was consumed as if the logic were written in C#!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段使用手动编写的递归下降解析器进行解析，并生成了一个**抽象语法树**（**AST**）。该树以深度优先的方式遍历，以生成.NET IL代码，进而生成.NET程序集（DLL）。生成的程序集就像是用C#编写的逻辑一样被消费！
- en: 'The **Extensible Stylesheet Language** (**XSL**) is another domain-specific
    language, which is very much familiar to most programmers. A small XSL snippet
    is given here for the sake of completeness, and readers are expected to master
    this language for generating sites with variant layouts:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展样式表语言**（**XSL**）是另一种领域特定语言，对大多数程序员来说非常熟悉。为了完整性，这里提供了一个小的XSL片段，并期望读者能够掌握这门语言以生成具有不同布局的网站：'
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The other popular DSLs are VHDL and Verilog (Digital Hardware Description Language),
    CSS, and template languages available with different technology stacks, JBoss
    Drools, and so on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的DSL包括VHDL和Verilog（数字硬件描述语言），CSS，以及不同技术堆栈中可用的模板语言，JBoss Drools等等。
- en: 'Writing and designing one''s own DSL is a very vast topic, which cannot be
    covered in a short chapter. Some things that one needs to take care of are as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和设计自己的DSL是一个非常广泛的话题，无法在短短的一章中涵盖。以下是一些需要注意的事项：
- en: Designing an object model, which mimics domain concerns
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个模仿领域关注点的对象模型
- en: Designing a linguistic abstraction and associated key words for arriving at
    language elements and rules for composing elements to form compound elements
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个语言抽象及其相关关键词，以到达语言元素和组成复合元素的规则
- en: Mapping language elements to the object model created
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将语言元素映射到创建的对象模型
- en: Deciding whether the DSL should be internal or external?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定DSL应该是内部还是外部？
- en: Deciding whether the DSL should be turing complete or not
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定DSL是否应该是图灵完备的
- en: 'The topic is well covered by Debasish Ghosh and Martin Fowler/Rebecca Parsons
    in their wonderful books. Please consult the following books for a thorough understanding
    of the same:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题在Debasish Ghosh和Martin Fowler/Rebecca Parsons的精彩书籍中得到了很好的覆盖。请参考以下书籍以深入了解相同的内容：
- en: '*DSLs in Action* by Debashish Ghosh ( Manning)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《在行动中的领域特定语言》（DSLs in Action*）由Debashish Ghosh（Manning）著'
- en: '*Domain-Specific Languages* by Martin Fowler and Rebecca Parsons (Addison Wesley
    Martin Fowler signature series)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《领域特定语言》（Domain-Specific Languages*）由Martin Fowler和Rebecca Parsons（Addison
    Wesley Martin Fowler签名系列）著'
- en: Ontology
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本体
- en: In software engineering parlance, Ontology is the art, craft, and science of
    describing entities (types), attributes (properties), and relationships that exist
    in a particular domain of discourse. It can also be considered as a model for
    describing entities, attributes, their relationship, and even standard behavior.
    An ontology really helps to come up with a ubiquitous language (as in **Domain-Driven
    Design** (**DDD**)), where all stakeholders agree, and which eases communication.
    It avoids confusion while developing multi-domain software systems. An ontology
    defines and represents the basic terms and relations that exist in a software
    engineering context.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程的术语中，本体是描述特定领域话语中存在的实体（类型）、属性（属性）和关系的艺术、工艺和科学。它也可以被视为描述实体、属性、它们的关系甚至标准行为的模型。本体真正有助于提出一个普遍的语言（如在**领域驱动设计**（**DDD**）中），所有利益相关者都同意，这有助于沟通。它避免了在开发多领域软件系统时的混淆。本体定义并代表了软件工程环境中存在的基本术语和关系。
- en: 'From an information processing perspective, the following points are to be
    noted:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从信息处理的角度来看，以下几点需要注意：
- en: The propositional and predicate logic gives the rules of inference and formal
    structures to encode facts
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命题逻辑和谓词逻辑提供了推理规则和形式结构来编码事实
- en: The ontology defines and helps to represent entities, their attributes, and
    the relationship between the entities in an unambiguous manner
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本体以明确的方式定义并帮助表示实体、它们的属性以及实体之间的关系
- en: The computation helps to implement ontologies on a computer-it helps us go beyond
    the philosophical ontology (first two steps)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算有助于在计算机上实现本体——它帮助我们超越哲学本体（前两个步骤）
- en: 'To write non-trivial knowledge processing systems, a software engineer should
    acquire skills in defining and interpreting ontologies. He should also be able
    to encode the ontology and its associated rules on a computer to create working
    computation models of the ontology in question. In software engineering, a well-defined
    ontology helps in the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写非平凡的推理系统，软件工程师应该掌握定义和解释本体的技能。他还应该能够将本体及其相关规则编码到计算机上，以创建所讨论本体的有效计算模型。在软件工程中，一个明确定义的本体有助于以下方面：
- en: Sharing knowledge between stakeholders about problem/solutions domain using
    a common terminology
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用术语在利益相关者之间共享关于问题/解决方案领域的知识
- en: Filtering the ontology to create models and meta models for application development
    (projections of an ontology)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过过滤本体来创建用于应用开发的模型和元模型（本体的投影）
- en: Computation using the elements defined in the ontology
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本体中定义的元素进行计算
- en: 'There are different ways by which we can encode an ontology. All of them share
    common elements, which are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不同的方式来编码本体。所有这些方式都共享以下共同元素：
- en: Classes, types, or concepts
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类、类型或概念
- en: Relations, roles, or properties
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系、角色或属性
- en: Formal rules or axioms
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式规则或公理
- en: Instances
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例
- en: 'The W3C Semantic Web has created an XML-based language called **Web Ontology
    Language** (**OWL**) for describing ontologies in a structured manner. The OWL
    embeds **Resource Description Format** (**RDF**) tags to define standard ontologies.
    A transportation ontology from an IBM site goes as follows. These OWL markups
    specify that there are three classes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: W3C语义网创建了一种基于XML的语言，称为**Web本体语言**（**OWL**），用于以结构化的方式描述本体。OWL嵌入**资源描述格式**（**RDF**）标签来定义标准本体。来自IBM网站的一个运输本体如下所示。这些OWL标记指定有三个类：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This section was written to kindle interest in ontology for readers of this
    book. The DDD is a topic very closely related to ontology, and people who have
    written object-oriented systems can relate to them very fast. To get into the
    ontology-based software development method, we would like to recommend a wonderful
    book written by John Sowa, titled, *Knowledge Representation: Logical, Philosophical
    and Computational Foundations*. Chapter 2 of that book deals with ontology as
    applied to software engineering. Also learn about the semantic web initiative
    by the W3C, by visiting their site.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在激发本书读者的本体论兴趣。领域驱动设计（DDD）与本体论密切相关，编写面向对象系统的人可以很快地理解它们。为了进入基于本体的软件开发方法，我们推荐一本由John
    Sowa撰写的精彩书籍，书名为《知识表示：逻辑、哲学和计算基础》。该书的第二章讨论了本体在软件工程中的应用。还可以通过访问他们的网站了解W3C的语义网倡议。
- en: AntiPatterns
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反模式
- en: 'An AntiPattern is a solution to a problem that seems to produce gain initially,
    but turns out to be counterproductive eventually. As patterns are named solutions,
    it might not be fit for certain kind of scenarios, and end up being an AntiPattern.
    The context in which we apply patterns is very important. AntiPatterns occur in
    various scenarios of a software development life cycle. They are broadly classified
    into these three categories:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式是一种看似最初能带来收益的解决方案，但最终却证明是反效果的。由于模式是以解决方案命名的，它可能不适合某些场景，最终变成反模式。我们应用模式时的上下文非常重要。反模式出现在软件开发生命周期的各种场景中。它们被广泛地分为以下三个类别：
- en: Software development AntiPatterns
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发反模式
- en: Architectural AntiPatterns
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构反模式
- en: Management (process) AntiPatterns
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理反模式
- en: '*AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis*
    by William J. Brown, Raphael C. Malveau, Hays W. McCormick III, and Thomas J.
    Mowbray is a seminal work on the AntiPattern.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 《反模式：危机中的软件、架构和项目的重构》由William J. Brown、Raphael C. Malveau、Hays W. McCormick
    III和Thomas J. Mowbray所著，是关于反模式的开创性作品。
- en: 'For the sake of kick-starting the discussion, we would like to cover some of
    the AntiPatterns that are ubiquitous and to which the readers of this book might
    be able to relate in their context:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动讨论，我们想介绍一些普遍存在的反模式，这些反模式可能是本书读者在其环境中能够相关联的：
- en: '**The Blob AntiPattern**: This often happens when people from a procedural
    programming language background design object-oriented systems. They create a
    big class, which contains most of the logic, and the associated classes are just
    containers of data. This AntiPattern results in making a class take a lion''s
    share of the responsibility, while the other classes execute trivial logic. The
    solution is to refactor the class and distribute responsibilities.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粘液反模式**：这种情况通常发生在来自过程式编程语言背景的人设计面向对象系统时。他们创建一个包含大部分逻辑的大类，而相关的类只是数据容器。这种反模式导致一个类承担大部分责任，而其他类执行的是微不足道的逻辑。解决方案是对该类进行重构并分配责任。'
- en: '**The Lave Flow AntiPattern**: This is also called dead code, and is often
    found in systems that started out as POC, and incrementally morphed into a production
    system. In this transformation, a lot of code is not used or never reached.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉夫流程反模式**：这也被称为死代码，通常出现在最初作为POC（原型）系统开始，逐渐演变成生产系统的系统中。在这个转变过程中，大量代码未被使用或从未被触及。'
- en: '**Functional Decomposition AntiPattern**: An AntiPattern that emerges in scenarios
    where primary designers of systems come from procedural languages such as C or
    Fortran, and try to fit their time-tested techniques to an OOP paradigm. Even
    after twenty years of OOP becoming mainstream, this is a recurring pattern.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能分解反模式**：这种反模式出现在系统的主要设计者来自过程式语言（如C或Fortran）的场景中，他们试图将经过时间考验的技术适应面向对象范式。即使面向对象在二十年后成为主流，这种模式仍然反复出现。'
- en: '**The Poltergeist (aka Gypsy)**: In the OOP context, sometimes, developers
    create classes that have a short life cycle to kick-start the processing by core
    classes, which have long duration. This can be eliminated by refactoring the code
    to include the logic of these ghost classes to the hierarchy of classes created
    for the solution of the problem.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鬼魂（又称吉普赛人）**：在面向对象编程的上下文中，有时开发者会创建生命周期短的类，以启动核心类（生命周期长）的处理。这可以通过重构代码，将这些鬼魂类的逻辑包含到为解决问题而创建的类层次结构中来实现。'
- en: '**The Golden Hammer**: This AntiPattern emerges in the context where the primary
    designers of the system might have a favorite technology, technique, or methodology
    while solving problems. The old adage, *For a person with hammer, everything appears
    to be a nail* clearly summarizes this mindset. The favorite tool is unleashed
    in a context where it might fit remotely. As anecdotal evidence, one of the author
    knows a person who will try to solve every problem through SNMP, where an ordinary
    TCP/IP program would have done the job.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黄金锤**：这种反模式出现在系统的主要设计者在解决问题时可能有一个偏爱的技术、技术或方法论的背景下。古老的谚语“对于有锤子的人来说，一切看起来都像是钉子”清楚地总结了这种心态。偏爱的工具在可能勉强适用的情况下被释放。作为轶事证据，作者认识一个人，他会试图通过SNMP解决每一个问题，而一个普通的TCP/IP程序就能完成这项工作。'
- en: '**The Dead End**: This often happens where a team might have leveraged a custom
    control written by an ISV to speed up the development process. While in production,
    the vendor might go bankrupt, or the product might not be supported by the company
    that acquired the vendor. By this time, the code base could get coupled with the
    custom control in question. Writing an isolation layer with interfaces meant for
    the same could avert this problem. The authors have come across dozens of such
    systems.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死胡同**：这种情况通常发生在团队可能利用ISV编写的自定义控件来加快开发过程的地方。在生产过程中，供应商可能会破产，或者收购供应商的公司可能不再支持该产品。到那时，代码库可能会与相关的自定义控件耦合。为这些接口编写隔离层可以避免这个问题。作者遇到过几十个这样的系统。'
- en: '**Resume-Driven Design**: The majority of developers, especially in the software
    services industry across the world, put their resume in front of the problem they
    are trying to solve. The presence or absence of certain buzzword technologies
    determines their compensation, and they use the latest technologies for situations
    where it is not warranted. This is so common that it is very easy to detect, as
    some simple scenarios will contain all the technologies currently in the hype
    cycle. One of the authors found himself in a situation where the code base happened
    to have an m framework, NoSQL database (a text file would have done the trick),
    a plugin architecture based on Microsoft **Managed Extensibility Framework** (**MEF**),
    a messaging system, and a cache manager for a system that would have taken thirty
    lines of a transaction-script like code. The current trend of converting projects
    that are running in production well to Angular 2/Typescript is another case of
    resume-driven design.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简历驱动设计**：世界上大多数开发者，尤其是在软件服务行业中，将他们的简历放在他们试图解决的问题之前。某些热门技术的存在与否决定了他们的薪酬，他们会在不需要最新技术的情况下使用它们。这种情况很常见，很容易检测到，因为一些简单的场景将包含当前炒作周期中的所有技术。一位作者发现自己处于一个代码库恰好有一个m框架、NoSQL数据库（一个文本文件就能解决问题）、基于Microsoft
    **托管扩展性框架**（**MEF**）的插件架构、一个消息系统和一个用于系统的缓存管理器，而这个系统只需要三十行类似事务脚本的代码。将运行良好的生产项目转换为Angular
    2/TypeScript的当前趋势是简历驱动设计的另一个案例。'
- en: '**Spaghetti Code**: This is an emergent phenomena in most systems, even in
    systems that were well defined initially. There was a mistaken notion that Spaghetti
    code was found only in procedural programming code base and COBOL. In OOP systems,
    as the system evolves and initial developers move away, the new developers who
    might not have much clue about the whole system, might end up writing code in
    a spaghetti style. Recently, authors found a Silverlight application, which used
    the MVVM pattern, and that had more spaghetti style code than a mainframe COBOL
    program!'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意大利面代码**：这是大多数系统中的一种涌现现象，即使在最初定义良好的系统中也是如此。曾经有一种错误的观念，认为意大利面代码只存在于过程式编程代码库和COBOL中。在面向对象系统中，随着系统的演变和初始开发者的离开，可能对整个系统不太了解的新开发者可能会以意大利面风格编写代码。最近，作者发现了一个使用MVVM模式的Silverlight应用程序，其意大利面风格代码比主机的COBOL程序还要多！'
- en: '**Cut and Paste Programming**: This often happens in large systems where a
    new developer who is given a tight deadline tries to leverage code written elsewhere
    to speed up his development time. The developer cuts and pastes a large block
    of code that implements similar functionality, and makes the necessary changes.
    In the process, some residual code gets executed unnecessarily in the new content.
    One of the authors, who worked with a large electronic CAD software, found performance
    issues in the code as the developers resorted to the *Cut and Paste* model development,
    leading to some nested loops running unnecessarily. Because of the Spaghetti code
    acquired over a period of time, it happened at multiple places.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剪切和粘贴编程**：这通常发生在大型系统中，新开发者由于时间紧迫，试图利用其他地方编写的代码来加快他的开发时间。开发者剪切并粘贴一大块实现类似功能的代码，并进行必要的修改。在这个过程中，一些残留代码在新内容中不必要地被执行。一位作者在与大型电子CAD软件合作时发现，由于开发者转向了**剪切和粘贴**模型开发，代码中出现了性能问题，导致一些嵌套循环不必要地运行。由于一段时间内积累的意大利面代码，这种情况在多个地方发生。'
- en: '**The StovePipe System**: In most enterprises, because of the evolutionary
    nature of application development, software systems are integrated in an ad hoc
    manner. Some software might use resource tier integration (using relational databases),
    some might use transaction scripts (using a batch job engine) , point-to-point
    integration using REST/SOAP services, and applications run on multiple technology
    stacks through multiple messaging systems based on JMS and MSMQ protocol. Due
    to mergers and acquisitions, and lack of unified enterprise strategy, the whole
    scenario becomes a maintenance nightmare. By having an enterprise integration
    strategy and internal standards, we can reduce the complexity of integration.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烟囱系统**：在大多数企业中，由于应用开发的演进性，软件系统以临时方式集成。一些软件可能使用资源层集成（使用关系数据库），一些可能使用事务脚本（使用批量作业引擎），通过REST/SOAP服务进行点对点集成，以及基于JMS和MSMQ协议的多个消息系统上运行的多技术栈的应用程序。由于合并和收购，以及缺乏统一的企业战略，整个场景变成了维护噩梦。通过拥有企业集成战略和内部标准，我们可以减少集成的复杂性。'
- en: The other popular AntiPatterns are Vendor Lock-in, Design by Committee, Warm
    Bodies, Architecture by Implication, Intellectual Violence, Analysis Paralysis,
    Smoke and Mirrors, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的反模式包括供应商锁定、委员会设计、暖体、隐含架构、智力暴力、分析瘫痪、烟雾和镜子等。
- en: AntiPatterns are a topic that is as important as the patterns. While patterns
    give you time-trusted named solutions to common problems, AntiPatterns and their
    solutions avoid pitfalls in your software engineering life cycle. This topic warrants
    a book of its own. We have just given some brief descriptions here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式是一个与模式一样重要的主题。虽然模式为你提供了时间验证的命名解决方案来解决常见问题，但反模式和它们的解决方案避免了你在软件工程生命周期中的陷阱。这个主题值得有一本自己的书。我们在这里只是给出了简要的描述。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The chapter dealt with some pointers for the readers to further their study
    of software engineering techniques. The topics covered include polyglot programming,
    DSL, ontology, and AntiPatterns. We could only mention these topics briefly, as
    these topics require multiple books to do justice to them. There is indeed good
    material available on these topics in the form of YouTube videos, white papers,
    and books. Also try to understand more about various pattern catalogs mentioned
    in the first chapter of this book to have a solid foundation for architecting
    future systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为读者提供了一些指针，以进一步研究软件工程技术。涵盖的主题包括多语言编程、领域特定语言（DSL）、本体和反模式。我们只能简要提及这些主题，因为这些主题需要多本书才能公正地对待它们。确实，关于这些主题的YouTube视频、白皮书和书籍中有很多好的材料。还请尝试了解本书第一章中提到的各种模式目录，以构建未来系统架构的坚实基础。
