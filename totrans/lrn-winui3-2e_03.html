<html><head></head><body>
		<div><h1 id="_idParaDest-73" class="chapter-number"><a id="_idTextAnchor073"/>3</h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>MVVM for Maintainability and Testability</h1>
			<p>When building XAML-based applications, one of the most important design patterns to learn is the MVVM pattern. MVVM<a id="_idIndexMarker211"/> provides a clear separation of concerns between the XAML markup in the view and the C# code in the View Model using data binding. With this separation comes ease of maintenance and testability. The View Model classes can be tested without taking a dependency on the underlying <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) platform. For large teams, another benefit of this separation is that changing the XAML enables UI designers to work on the UI independently of developers who specialize in writing the business logic and the backend of the application.</p>
			<p>In this chapter, you will learn about the following concepts:</p>
			<ul>
				<li>Fundamentals of the MVVM design pattern</li>
				<li>Popular MVVM frameworks</li>
				<li>Implementing MVVM in WinUI applications</li>
				<li>Handling View Model changes in the view</li>
				<li>Event handling in MVVM</li>
				<li>Streamline View Model implementations with the MVVM Toolkit</li>
			</ul>
			<p>By the end of the chapter, you will understand the basics of the MVVM design pattern, have some familiarity with some popular MVVM frameworks available to developers, and know how to implement MVVM in a WinUI application. We will wrap up by getting hands-on with the open <a id="_idIndexMarker212"/>source <strong class="bold">MVVM Toolkit</strong>.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, please refer to the <em class="italic">Technical requirements</em> section of <a href="B20908_02.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Configuring the Development Environment and Creating </em><em class="italic">the Project</em>.</p>
			<p>You will find the code files of this chapter here: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03</a></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor076"/>Understanding MVVM</h1>
			<p>MVVM<a id="_idIndexMarker213"/> was introduced by Microsoft in 2005 and gained popularity with <a id="_idIndexMarker214"/>developers following the launch of <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>) and <strong class="bold">Silverlight</strong> because<a id="_idIndexMarker215"/> it lends itself so well to building applications with XAML. It is like<a id="_idIndexMarker216"/> the <strong class="bold">Presentation Model</strong> pattern, which was created by Martin Fowler – one of the most influential proponents of design patterns.</p>
			<p>The MVVM pattern consists of the following three layers:</p>
			<ul>
				<li><strong class="bold">Model</strong>: The <a id="_idIndexMarker217"/>Model layer contains the application’s business logic and should perform all the data access operations. The View Model communicates with the Model to retrieve and save the application’s data.</li>
				<li><strong class="bold">View</strong>: The <a id="_idIndexMarker218"/>View layer is only responsible for the presentation of data in the application. The layout or structure is defined here, along with style definitions. This is the layer responsible for interacting with the user and receiving input events and data. The View is aware of the View Model only through data-binding expressions.</li>
				<li><strong class="bold">ViewModel</strong>: The<a id="_idIndexMarker219"/> View Model (or ViewModel) layer is responsible for maintaining the state of data for the View. It has a set of properties that provide data to the View through data binding and a set of commands invoked by the View in response to user input events. View Model classes have no knowledge of their corresponding Views.</li>
			</ul>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>MVVM – the big picture</h2>
			<p>Let’s look at how <a id="_idIndexMarker220"/>the components of MVVM fit into the overall architecture of an application implementing the pattern, depicted in the following diagram:</p>
			<div><div><img src="img/B20908_03_01.jpg" alt="Figure 3.1 – The MVVM pattern in use"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The MVVM pattern in use</p>
			<p>In <em class="italic">Figure 3</em><em class="italic">.1</em>, you can see a representation of the MVVM pattern along with other parts of the application: services, data, and unit tests. The arrows in the diagram represent dependencies, not the data flow. You can imagine that data would need to move both ways along most of these pathways to create a functional application.</p>
			<p>As with many design patterns, the MVVM pattern is meant to be a guide for developers to create reliable, maintainable applications. However, not all developers implement the pattern in the same way. The differences usually lie in the implementation of the model. Some developers will create a domain model <a id="_idIndexMarker221"/>in the <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) style. This makes sense for large applications with complex business logic. For simpler applications, the model may only be a simple data access layer, residing either on the client or behind a service layer. In some of these cases, the <strong class="bold">Services</strong> cloud <a id="_idIndexMarker222"/>in the preceding diagram would move between the View Model and Model layers.</p>
			<p>The point of <a id="_idIndexMarker223"/>MVVM is to help guide you in building the best app for your users. As you gain experience with MVVM and WinUI, you will find the right implementation for your applications. A good way to get started is to find some frameworks that make it easier to work with MVVM.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>MVVM libraries for WinUI</h1>
			<p>When working with MVVM in WinUI <a id="_idIndexMarker224"/>applications, you must create a little infrastructure code to facilitate data binding between Views and View Models. You can either write this yourself or choose a framework that abstracts this plumbing code away from your application. Although we will start by writing our own plumbing code for the application in the next section, let’s review some popular MVVM frameworks for WinUI.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>The MVVM Toolkit</h2>
			<p>We<a id="_idIndexMarker225"/> will <a id="_idIndexMarker226"/>discuss the <code>CommunityToolkit.Mvvm</code> <strong class="bold">NuGet package</strong> through the <strong class="bold">NuGet Package Manager</strong> in <a id="_idIndexMarker230"/>Visual Studio or view its details on the NuGet website, at <a href="https://www.nuget.org/packages/CommunityToolkit.Mvvm/">https://www.nuget.org/packages/CommunityToolkit.Mvvm/</a>.</p>
			<p>The library includes base classes to support <code>INotifyPropertyChanged</code>, <code>IMessenger</code>, and <code>ICommand</code>. It<a id="_idIndexMarker231"/> also includes other messaging and <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) helper classes. In addition, the latest versions of the MVVM Toolkit <a id="_idIndexMarker232"/>use <strong class="bold">Roslyn source generators</strong> to reduce the amount of boilerplate code developers need to write.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are unfamiliar with Roslyn, it is the code name<a id="_idIndexMarker233"/> of the <strong class="bold">.NET Compiler Platform</strong>. It was first <strong class="bold">released to manufacturing</strong> (<strong class="bold">RTM</strong>) with Visual Studio 2015, and it is the current compiler for the C# and VB.NET languages. Roslyn’s extensibility, via the .NET Compiler Platform SDK, allows developers to create things such as custom source generators and source code analyzers for Visual Studio. For more information about the platform, you can check out the documentation on Microsoft Learn: <a href="https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/">https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/</a>.</p>
			<p>Later in the chapter, after you have learned how to implement your own MVVM base class, we will leverage the MVVM Toolkit in our sample application.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>The Prism Library</h2>
			<p><strong class="bold">Prism</strong> started <a id="_idIndexMarker234"/>out as a<a id="_idIndexMarker235"/> library created and maintained by Microsoft. It was part of the <strong class="bold">Patterns &amp; Practices</strong> guidance, reference <a id="_idIndexMarker236"/>architectures, and libraries that Microsoft’s developer division used to maintain.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The remaining <a id="_idIndexMarker237"/><em class="italic">Patterns &amp; Practices</em> projects still maintained by Microsoft are available on GitHub here: <a href="https://github.com/mspnp">https://github.com/mspnp</a>.</p>
			<p>Microsoft decided to open source the Prism Library and transferred ownership to the community. The project is<a id="_idIndexMarker238"/> hosted on GitHub and can be found on the web at <a href="https://prismlibrary.com/">https://prismlibrary.com/</a>. Prism has packages available for WPF, Xamarin, UWP, and WinUI projects.</p>
			<p>Prism is much more than an MVVM framework. It also includes <code>EventAggregator</code> for loosely coupled application messaging. Prism can be added to a project through NuGet. There is also an installer available on the Prism site to add a Visual Studio project and item templates.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>MVVMCross</h2>
			<p><strong class="bold">MVVMCross</strong> is an <a id="_idIndexMarker241"/>MVVM framework that was first created <a id="_idIndexMarker242"/>for Xamarin developers. It now has NuGet packages available for Xamarin, .NET MAUI, WPF, UWP, and WinUI. As with Prism, MVVMCross does much more than facilitate data binding in WinUI applications. It has helpers for the following:</p>
			<ul>
				<li>Data binding</li>
				<li>Navigation</li>
				<li>Logging and tracing</li>
				<li>DI and IoC</li>
				<li>Unit testing</li>
			</ul>
			<p>There are some additional libraries, but most are specific to .NET MAUI applications. The MVVMCross package can also be added to your project via NuGet. For more information about MVVMCross <a id="_idIndexMarker243"/>use with WinUI, check out their site: <a href="https://www.mvvmcross.com/">https://www.mvvmcross.com/</a>.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Choosing a framework for WinUI applications</h2>
			<p>Using a third-party framework <a id="_idIndexMarker244"/>for building production XAML applications is a great choice. These provide built-in support for things such as logging and DI. For the WinUI application in this book, we will use the MVVM Toolkit for data binding at the end of this chapter. However, first, we will implement the MVVM pattern from scratch. This will help you understand the underlying mechanisms of data binding, DI, and other core concepts relating to MVVM.</p>
			<p>Before jumping into the code, you should have some background on exactly how data binding works in WinUI.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Understanding data binding in WinUI</h1>
			<p>In the previous chapter, you saw some simple examples of <a id="_idIndexMarker245"/>data binding, using both the <code>Binding</code> and <code>x:Bind</code> markup extensions. Let’s dissect some of the components that allow the View to receive updates when the View Model data changes.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>What are markup extensions?</h2>
			<p>An in-depth discussion of<a id="_idIndexMarker246"/> markup extensions is beyond the scope of this introductory book. In brief, they are a class that executes some logic to return a value to the XAML parser. You can identify their use in XAML by looking for some markup inside curly braces. Take this example of <code>Binding</code> in the <code>Text</code> property of a <code>TextBlock</code>:</p>
			<pre class="source-code">
&lt;TextBlock Text="{Binding Path=Name, Mode=TwoWay}"/&gt;</pre>			<p>From this, you can derive that there is a markup extension class named <code>Binding</code> and that two of its properties are <code>Path</code> and <code>Mode</code>. This markup extension takes these properties, resolves a value, and returns it to the XAML parser for display in the application’s View.</p>
			<p>Some XAML markup languages allow developers to write their own custom markup extensions. WPF and .NET MAUI have custom markup extensions, but WinUI does not. If you’re curious about the implementation of a markup extension, Microsoft Learn has documentation on how to create one for .NET MAUI: <a href="https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create">https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create</a>.</p>
			<p>Now, let’s learn more about the <code>Binding</code> markup extension in WinUI.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Binding markup extension</h2>
			<p>As you briefly<a id="_idIndexMarker247"/> saw, the <code>Binding</code> markup extension maps <a id="_idIndexMarker248"/>data from the binding source, the View Model in MVVM, and provides it to a binding target in the View. These are all the properties of the <code>Binding</code> markup extension:</p>
			<ul>
				<li><code>Path</code>: The path to the value in the data-binding source. For our application, this will be the property name on the View Model.</li>
				<li><code>Converter</code>: If the data type of the source property does not match the data type of the control’s property in the View, a <code>Converter</code> property is used to define the mapping between the two data types.</li>
				<li><code>ConverterLanguage</code>: If a <code>Converter</code> property is specified, a <code>ConverterLanguage</code> property can optionally be set to support internationalization.</li>
				<li><code>ConverterParameter</code>: If a <code>Converter</code> property takes a parameter, use the <code>ConverterParameter</code> property to provide it. It’s not common to use a <code>Converter</code><code> Parameter</code> property, and it is typically a <code>string</code> value. If you need to provide multiple values to a <code>Converter</code>, you can concatenate them and then parse them inside the method.</li>
				<li><code>ElementName</code>: This parameter is used when binding to an attribute of another element in the View.</li>
				<li><code>FallBackValue</code>: If the data binding fails for any reason, you can specify a <code>FallBackValue</code> property to display in the View.</li>
				<li><code>Mode</code>: This defines whether the data binding is <code>OneTime</code> (sets the value only when the XAML is first parsed), <code>OneWay</code> (fetches the value from the View Model when changes are detected), or <code>TwoWay</code> (the value flows both ways between the View and View Model). The default <code>Mode</code> setting for <code>Binding</code> varies depending on the control and property being bound. It is important to check the documentation if you are unsure of the default <code>Mode</code>.</li>
				<li><code>RelativeSource</code>: This is used to define a data-binding source that is relative to the current control. This is usually used with control templates that get their data through a parent element.</li>
				<li><code>Source</code>: Specifies <a id="_idIndexMarker249"/>the data-binding source. This is<a id="_idIndexMarker250"/> usually defined at a top-level control level in WinUI as the View Model. However, it is possible for child controls to set a different <code>Source</code>, overriding the <code>Source</code> inherited from their ancestor. The <code>Source</code> value defined at any level in the View will be inherited by all child elements unless a new <code>Source</code> is set.</li>
				<li><code>TargetNullValue</code>: Specifies a default value to display if the data-binding source is resolved but has a <code>null</code> value.</li>
				<li><code>UpdateSourceTrigger</code>: Specifies the frequency with which to update <code>TwoWay</code> binding sources. The options are <code>PropertyChanged</code>, <code>Explicit</code>, and <code>LostFocus</code>. The default frequency for most properties is <code>PropertyChanged</code>.</li>
			</ul>
			<p><code>Path</code> is the default property and is assumed when no property name is given for a parameter. For example, the earlier <code>TextBlock</code> example could also be written as follows:</p>
			<pre class="source-code">
&lt;TextBlock Text="{Binding Name, Mode=TwoWay}"/&gt;</pre>			<p>Here, <code>Name</code> is assumed to be the value provided for the <code>Path</code> parameter. Providing two parameters without specifying parameter names will result in a XAML parser error.</p>
			<p>The <code>Binding</code> markup <a id="_idIndexMarker251"/>extension is found in every XAML<a id="_idIndexMarker252"/> language. The other option for data binding, <code>x:Bind</code>, is not. It is only an option with UWP and WinUI.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>x:Bind markup extension</h2>
			<p><code>x:Bind</code> is an alternative <a id="_idIndexMarker253"/>markup extension for WinUI. It is faster and uses less <a id="_idIndexMarker254"/>memory than <code>Binding</code> and has better debugging support. It achieves this performance gain by generating code at compile time to be used during binding at runtime. By contrast, the <code>Binding</code> markup extension is executed by the XAML parser at runtime, which incurs additional overhead. Compile-time bindings also result in incorrect data binding expressions being caught when compiling, rather than generating data binding failures at runtime.</p>
			<p>Another important distinction between <code>Binding</code> and <code>x:Bind</code> is that <code>Binding</code> requires a <code>Data</code><code> Context</code> to be set. Data is bound to properties of objects within the <code>DataContext</code>. When using <code>x:Bind</code>, you are binding directly to properties on the current <code>Window</code> or <code>UserControl</code>. You can also bind events directly to event handlers in the code-behind for the Window with <code>x:Bind</code>.</p>
			<p>While most of the properties of <code>x:Bind</code> are the same as those in <code>Binding</code>, let’s highlight those that differ, as follows:</p>
			<ul>
				<li><code>ElementName</code>: Not available in <code>x:Bind</code>. You must use <code>Binding</code> to data-bind to other XAML element attributes. If your application must bind to other elements, <code>x:Bind</code> and <code>Binding</code> can be used in the same View.</li>
				<li><code>Mode</code>: The only difference here is that the default <code>Mode</code> for <code>x:Bind</code> is usually <code>OneTime</code>, not <code>OneWay</code>.</li>
				<li><code>RelativeSource</code>: Not available in <code>x:Bind</code>.</li>
				<li><code>Source</code>: Not available in <code>x:Bind</code>. Instead, you will typically define a <code>ViewModel</code> property in the code-behind file of each View with a data type of the corresponding View Model class. You could also create a domain-specific name for the property, such as <code>MediaItems</code> for our application.</li>
				<li><code>BindBack</code>: This property is unique to <code>x:Bind</code>. It allows a custom function to be called in <code>TwoWay</code> binding when reverse data binding is invoked. This is not commonly used, and we <a id="_idIndexMarker255"/>will not use it in our application.</li>
			</ul>
			<p><code>x:Bind</code> is a<a id="_idIndexMarker256"/> powerful and complex markup extension. For more information about it, you can read this page on Microsoft Learn: <a href="https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension">https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension</a>.</p>
			<p>Next, let’s discuss <code>INotifyPropertyChanged</code>, the interface that enables changes in data-bound properties in the ViewModel to be reflected in the view.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Updating View data with INotifyPropertyChanged</h2>
			<p>So, how does the<a id="_idIndexMarker257"/> View get notified when data <a id="_idIndexMarker258"/>changes in the ViewModel? That magic lies within the <code>Microsoft.UI.Xaml.Data.INotifyPropertyChanged</code> interface. This interface consists of a single member, as shown here:</p>
			<pre class="source-code">
public interface INotifyPropertyChanged
{
    event PropertyChangedEventHandler PropertyChanged;
}</pre>			<p>Every ViewModel class must implement this interface and raise the <code>PropertyChanged</code> event to update the View. Indicate which property is changed by passing its name in the <code>PropertyChangedEventArgs</code> parameter. To refresh all properties, pass <code>null</code> or <code>string.Empty</code> as the property name, but be aware of the potential <a id="_idIndexMarker259"/>performance implications this<a id="_idIndexMarker260"/> can have on large views.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>Updating collection data with INotifyCollectionChanged</h2>
			<p><code>INotifyPropertyChanged</code> works<a id="_idIndexMarker261"/> great for <a id="_idIndexMarker262"/>most properties, but it will not update the View if items from a collection have been added or removed. This is where the <code>Microsoft.UI.Xaml.Interop.INotifyCollectionChanged</code> interface is used. Again, this interface only has a single member, as shown here:</p>
			<pre class="source-code">
public interface INotifyCollectionChanged
{
    event NotifyCollectionChangedEventHandler
      CollectionChanged;
}</pre>			<p>None of the collections or collection interfaces commonly used in .NET (<code>List&lt;T&gt;</code>, <code>IEnumerable&lt;T&gt;</code>, and so on) implement this interface. You can create your own collection derived from an existing list type and implement <code>INotifiedCollectionChanged</code> yourself, but it’s much easier to use the <code>ObservableCollection&lt;T&gt;</code> list type that is already available to WinUI developers. This is a collection that will update the View when items are added or removed, or when the contents are completely refreshed.</p>
			<p>The <code>Items</code> property of an <code>ObservableCollection&lt;T&gt;</code> is read-only, thus it cannot be directly set. You can add items by passing a <code>List&lt;T&gt;</code> or <code>IEnumerable&lt;T&gt;</code> to the constructor when creating <code>ObservableCollection&lt;T&gt;</code> or by using its <code>Add</code> or <code>Insert</code> methods (there is no <code>AddRange</code> method to add multiple items). You can update individual values in the collection by assigning a new item to the current index. You can remove<a id="_idIndexMarker263"/> items with <a id="_idIndexMarker264"/>the <code>Remove</code>, <code>RemoveAt</code>, <code>ClearItems</code>, or <code>Clear</code> methods.</p>
			<p>In the next section, when we implement the MVVM pattern for ourselves, you will see these concepts in practice.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Implementing MVVM in WinUI applications</h1>
			<p>It’s time <a id="_idIndexMarker265"/>to start converting <a id="_idIndexMarker266"/>our project to use MVVM. To gain a thorough understanding of the MVVM pattern, we will start by building our own MVVM infrastructure. For simple applications, it doesn’t require more than a single base class:</p>
			<ol>
				<li>Start by adding a <strong class="bold">ViewModels</strong> folder to the project. If you are using the code from GitHub, you can either continue with your project from the previous chapter or use the <strong class="bold">Start</strong> project in the folder for this chapter.</li>
				<li>Next, add a new class to the <code>BindableBase</code>. This will be the base class for all our View Model classes in the project. It will be responsible for notifying the corresponding views of any property changes. This is accomplished by implementing the <code>INotifyPropertyChanged</code> interface. Let’s review the <code>BindableBase</code> class code, as follows:<pre class="source-code">
public class BindableBase : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler
      PropertyChanged;
    protected void OnPropertyChanged(
      [CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new Property
          ChangedEventArgs(propertyName));
    }
    protected bool SetProperty&lt;T&gt;(ref T originalValue,
      T newValue, [CallerMemberName] string
        propertyName = null)
    {
        if (Equals(originalValue, newValue))
        {
            return false;
        }
        originalValue = newValue;
        OnPropertyChanged(propertyName);
        return true;
    }
}</pre></li>			</ol>
			<p>By using this<a id="_idIndexMarker267"/> as the base<a id="_idIndexMarker268"/> class of our View Models, they will have two new methods available to use, as follows:</p>
			<ul>
				<li><code>OnPropertyChanged</code>: Use this to trigger a <code>PropertyChanged</code> event to notify the View of changes in the data</li>
				<li><code>SetProperty</code>: This method is used to set the value of a property if the value has been changed and will then call <code>OnPropertyChanged</code></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Be sure you have these two using directives at the top of the <code>BindableBase</code> class file:</p>
			<p class="callout"><code>using System.ComponentModel;</code></p>
			<p class="callout"><code>using System.Runtime.CompilerServices;</code></p>
			<p>Now that we have a base <a id="_idIndexMarker269"/>class, let’s<a id="_idIndexMarker270"/> add our first View Model to the project. Right-click the <code>MainViewModel</code>. This View Model is going to replace most of the code in the <code>MainWindow</code>. The following code is part of the revised class. Please refer to <code>MainViewModel.txt</code> in the GitHub repository for the chapter (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels</a>) for the current version of the complete class:</p>
			<pre class="source-code">
public class MainViewModel : BindableBase
{
    private string selectedMedium;
    private ObservableCollection&lt;MediaItem&gt; items;
    private ObservableCollection&lt;MediaItem&gt; allItems;
    private IList&lt;string&gt; mediums;
    public MainViewModel()
    {
        PopulateData();
    }
    ...
    public IList&lt;string&gt; Mediums
    {
        get
        {
            return mediums;
        }
        set
        {
            SetProperty(ref mediums, value);
        }
    }
    ...
}</pre>			<p>You may have <a id="_idIndexMarker271"/>noticed that <a id="_idIndexMarker272"/>the code has been updated, using the new <code>BindableBase.SetProperty</code> method inside each property’s <code>Set</code> block. This ensures that the UI will be notified when the property value has been changed:</p>
			<ol>
				<li>Now, we’ll need to make the <code>MainViewModel</code> class available to the <code>MainWindow</code> view. Because there will be a single instance of this View Model used throughout the lifetime of the app, we will add a static read-only property to the <code>App.xaml.cs</code> file to make it available to the application, as follows:<pre class="source-code">
public static MainViewModel ViewModel { get; } = new
MainViewModel();</pre></li>				<li>We can now strip out all the code from <code>MainViewModel</code> class. In addition, add a property to make <code>App.ViewModel</code> available to <code>MainWindow</code> for data binding, as follows:<pre class="source-code">
public sealed partial class MainWindow : Window
{
    public MainWindow()
    {
        this.InitializeComponent();
        Loaded += MainPage_Loaded;
    }
    public MainViewModel ViewModel =&gt; App.ViewModel;
    private async void AddButton_Click(object sender,
      Microsoft.UI.Xaml.RoutedEventArgs e)
    {
        var dialog = new MessageDialog("Adding items
          to the collection is not yet available.",
            "My Media Collection");
        await dialog.ShowAsync();
    }
}</pre><p class="list-inset">The only <a id="_idIndexMarker273"/>other code we <a id="_idIndexMarker274"/>need to keep in the code-behind file right now is for the <code>MainViewModel</code>. There are only two changes required to handle the new data source, detailed next.</p></li>				<li>First, update <code>ComboBox</code> to remove the <code>x:Name</code> property and add <code>x:Bind</code> data binding for the <code>ItemsSource</code> and <code>SelectedItem</code> properties. The <code>SelectedItem</code> binding needs to be set to <code>TwoWay</code>. This will ensure that the data in <code>MainViewModel</code> is updated when the user changes <code>SelectedMedium</code> in the UI. The code can be seen in the following snippet:<pre class="source-code">
&lt;ComboBox <strong class="bold">ItemsSource="{x:Bind ViewModel.Mediums}"</strong>
<strong class="bold">  SelectedItem="{x:Bind ViewModel.SelectedMedium,</strong>
<strong class="bold">    Mode=TwoWay}"</strong> HorizontalAlignment="Right"
      MinWidth="120" Margin="0,2,6,4"/&gt;</pre></li>				<li>Now, update <code>ListView</code> to remove the <code>x:Name</code> property and add an <code>ItemsSource</code> <code>x:Bind</code> data binding, as follows:<pre class="source-code">
&lt;ListView Grid.Row="1" <strong class="bold">ItemsSource="{x:Bind</strong>
<strong class="bold">  ViewModel.Items}"</strong>&gt;</pre><p class="list-inset">The assigned <a id="_idIndexMarker275"/>names for <a id="_idIndexMarker276"/>these controls are no longer needed because we are not referencing them anywhere in the code.</p></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">Assigning names to XAML elements allocates additional resources. It is recommended to only name elements when the elements must be referenced directly from code-behind files or by other View elements’ data binding via <code>ElementName</code>.</p>
			<ol>
				<li value="5">Now, run the application and try changing the <code>Medium</code> filter with the <code>ComboBox</code>. It should behave exactly as it did before, but now we have decoupled the View <a id="_idIndexMarker277"/>Model data from the UI, making it easier to test or <a id="_idIndexMarker278"/>potentially reuse.</li>
			</ol>
			<p>Next, we will address the button <code>Click</code> event that we still have in the <strong class="bold">MainWindow.xaml.cs</strong> file.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Working with events and commands</h1>
			<p>It’s time to<a id="_idIndexMarker279"/> update the<a id="_idIndexMarker280"/> project to move the event handling code to <code>MainViewModel</code>. By the end of this section, you will have removed all the code that was added to the <code>ViewModel</code> property. This will be great for the separation of concerns, as well as for the maintainability and testability of the project.</p>
			<p>We could use the same process of wiring up events with the <code>Click</code> event and connect it to a method on the <code>MainViewModel</code> class. There are two problems with this approach:</p>
			<ul>
				<li>The View and View Model layers become more tightly coupled, reducing maintainability</li>
				<li>UI concerns are injected into the view model, reducing the testability of the class</li>
			</ul>
			<p>Let’s take <a id="_idIndexMarker281"/>another route. The MVVM pattern has the concept of <code>Command</code> properties all expect a type of <code>System.Windows.Input.ICommand</code>.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>Implementing ICommand</h2>
			<p>To use commands in the project, we’ll <a id="_idIndexMarker283"/>start by creating an implementation of <code>ICommand</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Another advantage of using an MVVM framework such as Prism or the MVVM Toolkit is that they provide implementations of <code>ICommand</code>.</p>
			<p>Add a new class to the <code>ViewModel</code> folder in the project and name it <code>RelayCommand</code>. This class will implement the <code>ICommand</code> interface. The <code>RelayCommand</code> class will look like this:</p>
			<pre class="source-code">
public class RelayCommand : ICommand
{
    private readonly Action action;
    private readonly Func&lt;bool&gt; canExecute;
    public RelayCommand(Action action)
        : this(action, null)
    {
    }
    public RelayCommand(Action action, Func&lt;bool&gt;
      canExecute)
    {
        if (action == null)
            throw new ArgumentNullException
              (nameof(action));
        this.action = action;
        this.canExecute = canExecute;
    }
    public bool CanExecute(object parameter) =&gt; canExecute
      == null || canExecute();
    public void Execute(object parameter) =&gt; action();
    public event EventHandler CanExecuteChanged;
    public void RaiseCanExecuteChanged() =&gt;
      CanExecuteChanged?.Invoke(this, EventArgs.Empty);
}</pre>			<p><code>RelayCommand</code> has two<a id="_idIndexMarker284"/> constructors that both take an <code>Action</code> that will be invoked when the command is executed. One of the constructors also takes a <code>Func&lt;bool&gt;</code>. This will allow us to enable or disable UI actions based on the return value of <code>CanExecute</code>. We will use this to enable a <code>ListView</code>.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Using commands in the View Model</h2>
			<p>Now, it’s time to update <code>MainViewModel</code> to handle commands from the <strong class="bold">Add</strong> and <strong class="bold">Delete</strong> buttons. In the<a id="_idIndexMarker285"/> next <a id="_idIndexMarker286"/>chapter, we will enhance the add operation so it can add or edit items. So, let’s name the command and method accordingly:</p>
			<ol>
				<li>First, add <a id="_idIndexMarker287"/>two new<a id="_idIndexMarker288"/> private variables to the <code>MainViewModel</code> class:<pre class="source-code">
private MediaItem selectedMediaItem;
private int additionalItemCount = 1;</pre><p class="list-inset">The <code>additionalItemCount</code> variable is a temporary variable that we will use to track how many new items we have added to the list. The counter will help to generate unique IDs and names for each new media item. <code>selectedMediaItem</code> is a backing variable for the new <code>SelectedMediaItem</code> property.</p></li>				<li>Add the <code>SelectedMediaItem</code> property next:<pre class="source-code">
public MediaItem SelectedMediaItem
{
    get =&gt; selectedMediaItem;
    set
    {
        SetProperty(ref selectedMediaItem, value);
        ((RelayCommand)DeleteCommand)
          .RaiseCanExecuteChanged();
    }
}</pre><p class="list-inset">In addition to calling <code>SetProperty</code> to notify the UI that <code>SelectedMediaItem</code> has changed, we also need to call <code>RaiseCanExecuteChanged</code> on a new <code>DeleteCommand</code>.</p></li>				<li>Next, let’s<a id="_idIndexMarker289"/> add <code>DeleteCommand</code> and <code>AddEditCommand</code> along <a id="_idIndexMarker290"/>with their corresponding actions:<pre class="source-code">
public ICommand AddEditCommand { get; set; }
public void AddOrEditItem()
{
    // Note this is temporary until
    // we use a real data source for items.
    const int startingItemCount = 3;
    var newItem = new MediaItem
    {
        Id = startingItemCount + additionalItemCount,
        Location = LocationType.InCollection,
        MediaType = ItemType.Music,
        MediumInfo = new Medium { Id = 1, MediaType =
          ItemType.Music, Name = "CD" },
        Name = $"CD {additionalItemCount}"
    };
    allItems.Add(newItem);
    Items.Add(newItem);
    additionalItemCount++;
}
public ICommand DeleteCommand { get; set; }
private void DeleteItem()
{
    allItems.Remove(SelectedMediaItem);
    Items.Remove(SelectedMediaItem);
}
private bool CanDeleteItem() =&gt; selectedMediaItem !=
  null;</pre><p class="list-inset">There is an <code>ICommand</code> property for each UI operation (<code>AddEditCommand</code> and <code>Delete</code><code> Command</code>) and new methods for each command to execute (<code>AddOrEditItem</code> and <code>DeleteItem</code>). There is also a <code>CanDeleteItem</code> method that returns a <code>bool</code> value to indicate whether a media item has been selected by the user.</p></li>				<li>At the <a id="_idIndexMarker291"/>end of the <code>MainViewModel</code> constructor, add <a id="_idIndexMarker292"/>two lines of code to initialize the commands, connecting them to the corresponding methods:<pre class="source-code">
DeleteCommand = new RelayCommand(DeleteItem,
  CanDeleteItem);
// No CanExecute param is needed for this command
// because you can always add or edit items.
AddEditCommand = new RelayCommand(AddOrEditItem);</pre></li>			</ol>
			<p>The preceding code is part of the revised <code>MainViewModel</code> class. Please refer to <code>MainViewModel2.txt</code> in the GitHub repository for the chapter (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels</a>) for the current version of the complete class.</p>
			<p>Our View Model has<a id="_idIndexMarker293"/> been updated to use commands. Next, we <a id="_idIndexMarker294"/>will update the view to bind to them.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Updating the View</h2>
			<p>Our view model is<a id="_idIndexMarker295"/> ready to go. It’s now safe to remove all the event handling code from the <code>MainWindow</code> code. It should look like this when you’re finished:</p>
			<pre class="source-code">
public sealed partial class MainWindow : Window
{
    public MainWindow()
    {
        this.InitializeComponent();
    }
    public MainViewModel ViewModel =&gt; App.ViewModel;
}</pre>			<p>The <strong class="bold">MainWindow.xaml</strong> file will need a few updates to get the <strong class="bold">Add Item</strong> and <strong class="bold">Delete Item</strong> buttons fully functional with the temporary test data. Perform the following steps to accomplish this:</p>
			<ol>
				<li>Update the <code>ListView</code> to bind the <code>SelectedItem</code> property to <code>SelectedMediaItem</code> in the view model:<pre class="source-code">
&lt;ListView Grid.Row="1" ItemsSource="{x:Bind
  ViewModel.Items}" <strong class="bold">SelectedItem="{x:Bind</strong>
<code>TwoWay</code> data binding is required to allow the UI to update the view model.</p></li>				<li>Next, move the <code>Grid</code>. Then, create a <code>Click</code> event handler and set the properties of the grid and two buttons to match the following snippet:<pre class="source-code">
&lt;StackPanel Grid.Row="2"
            HorizontalAlignment="Right"
            Orientation="Horizontal"&gt;
    &lt;Button Command="{x:Bind
      ViewModel.AddEditCommand}"
            Content="Add Item"
            Margin="8,8,0,8"/&gt;
    &lt;Button Command="{x:Bind ViewModel.DeleteCommand}"
            Content="Delete Item"
            Margin="8"/&gt;
&lt;/StackPanel&gt;</pre><p class="list-inset">Each button’s <code>Command</code> property will be bound to the new <code>ICommand</code> properties in the view model. The <code>Command</code> property of a button is invoked when it’s clicked by the user.</p></li>				<li>We’re now done<a id="_idIndexMarker296"/> updating the project to use MVVM. Run the application to see how it works.</li>
				<li>When it first loads, the <strong class="bold">Delete Item</strong> button will be disabled. Select an item in the list and notice that the button is automatically enabled. If you click <strong class="bold">Delete Item</strong>, the selected item is removed from the list and the button is disabled again.</li>
				<li>Finally, click <strong class="bold">Add Item</strong> a few times to see how new items are created and added to the list. Each new item has a unique name using the counter we created in the view model, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B20908_03_02.jpg" alt="Figure 3.2 – My Media Collection after adding and removing a few items"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – My Media Collection after adding and removing a few items</p>
			<p><code>MainWindow</code> now has a<a id="_idIndexMarker297"/> view model that is completely decoupled from any UI concerns. This will allow you to maximize the unit test coverage on the project.</p>
			<p>Before we wrap up, let’s see how we can reduce the amount of code in our project by using an MVVM framework such as the MVVM Toolkit.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Leveraging the MVVM Toolkit</h1>
			<p>We briefly introduced the MVVM<a id="_idIndexMarker298"/> Toolkit earlier in the chapter. In this section, we will update the <code>MainViewModel</code> to see how we can remove the need for a <code>BindableBase</code> class and reduce the amount of code in the view model itself:</p>
			<ol>
				<li>Start by right-clicking on the solution file in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Manage NuGet Packages </strong><strong class="bold">for Solution</strong>.</li>
				<li>In the NuGet window, select the <code>CommunityToolkit.Mvvm</code>.</li>
				<li>Select the <strong class="bold">CommunityToolkit.Mvvm</strong> package in the results and install the latest stable version (8.2.0 or later).</li>
				<li>Close the NuGet window and open the <code>MainViewModel</code> class. The first thing we need to do to use the MVVM Toolkit’s source generators is update <code>MainViewModel</code> to be a partial class and have it inherit from <code>CommunityToolkit.Mvvm.ComponentModel.ObservableObject</code> instead of our <a id="_idIndexMarker299"/>own <code>BindableBase</code> class:<pre class="source-code">
public partial class MainViewModel : ObservableObject</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn more about how the MVVM Toolkit uses <strong class="bold">.NET source generators</strong> to generate public properties and commands, check <a id="_idIndexMarker300"/>out the documentation on Microsoft Learn: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview</a>. If you are unfamiliar with .NET source generators, you can also read about them on Microsoft Learn in the .NET documentation: <a href="https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview">https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview</a>.</p>
			<ol>
				<li value="5">Next, each simple property that only calls <code>SetProperty</code> in its setter will be removed, and the backing variable will be updated to have an <code>ObservableProperty</code> attribute. Remove the <code>Mediums</code> and <code>Items</code> properties and the private <code>mediums</code> and <code>items</code> fields should now look like this:<pre class="source-code">
[ObservableProperty]
private IList&lt;string&gt; mediums;
[ObservableProperty]
private ObservableCollection&lt;MediaItem&gt; items;</pre><p class="list-inset">We have two public properties remaining in the class. Let’s start with <code>SelectedMedium</code>. We will remove <code>SelectedMediaItem</code> after updating the commands.</p></li>				<li>The setter for <code>SelectedMedium</code> has some custom logic after the call to <code>SetProperty</code>. Create a new partial method named <code>OnSelectedMediumChanged</code> to<a id="_idIndexMarker301"/> contain that code:<pre class="source-code">
partial void OnSelectedMediumChanged(string value)
{
    Items.Clear();
    foreach (var item in allItems)
    {
        if (string.IsNullOrWhiteSpace(value) ||
            value == "All" ||
            value == item.MediaType.ToString())
        {
            Items.Add(item);
        }
    }
}</pre><p class="list-inset">Notice that we also updated the uses of <code>selectedMedium</code> to <code>value</code>. The <code>value</code> parameter contains the new <code>selectedMedium</code> value. You may have also noticed some green squiggles in Visual Studio inside the <code>PopulateData</code> method, indicating that you should be using the generated properties instead of using the private <code>ObservableProperty</code> members directly. You can update all of these uses by capitalizing the first letter of each variable.</p></li>				<li>Next, we will update the two commands. Add the <code>RelayCommand</code> attribute to the <code>AddOr</code><code> EditItem</code> and <code>DeleteItem</code> methods and rename them to <code>AddEdit</code> and <code>Delete</code> to ensure that the generated commands have the same names that our old commands had.</li>
				<li>Remove the<a id="_idIndexMarker302"/> two commands and the code to initialize them in the <code>MainViewModel</code> constructor. The code for the constructor and the signatures for the two command methods should now look like this:<pre class="source-code">
public MainViewModel()
{
    PopulateData();
}
[RelayCommand]
public void AddEdit()
{
...
}
[RelayCommand(CanExecute = nameof(CanDeleteItem))]
public void Delete()
{
...
}
private bool CanDeleteItem() =&gt; SelectedMediaItem !=
  null;</pre><p class="list-inset">The attribute for <code>DeleteItem</code> also indicates that <code>CanDeleteItem</code> should be used for checking whether the command can be invoked.</p></li>				<li>Finally, let’s replace the <code>SelectedMediaItem</code> property with a source-generated property from the MVVM Toolkit. The existing public property tells the <code>DeleteCommand</code> that <code>CanExecute</code> should be checked. Remove that property and update the private <code>selectedMediaItem</code> variable to add two attributes:<pre class="source-code">
[ObservableProperty]
[NotifyCanExecuteChangedFor(nameof(DeleteCommand))]
private MediaItem selectedMediaItem;</pre><p class="list-inset">In addition to<a id="_idIndexMarker303"/> the <code>ObservableProperty</code> attribute, we’ve added a <code>NotifyCan</code><code> ExecuteChangedFor</code> attribute, providing the name of the <code>DeleteCommand</code> generated <code>ICommand</code> property. The generated property, which is invisible to us, would be equivalent to this:</p><pre class="source-code">public MediaItem SelectedMediaItem
{
    get =&gt; selectedMediaItem;
    set
    {
        if (SetProperty(ref selectedMediaItem, value))
        {
            DeleteCommand.NotifyCanExecuteChanged();
        }
    }
}</pre></li>			</ol>
			<p>That’s all you need to do. There are no changes needed in the view, and the application works exactly as it did before. All we’ve done is remove quite a bit of code from <code>MainViewModel</code>.</p>
			<p>We will continue to use the MVVM Toolkit throughout the remaining chapters. Now, let’s review what we’ve learned in this chapter.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Summary</h1>
			<p>We’ve made quite a bit of progress with the application in this chapter. While it’s not yet connected to a live data source, we have methods in place to add and remove items from the media collection in memory. In addition, the project has been refactored to use the <code>MainWindow</code> code-behind file to a new <code>MainViewModel</code> class. The new <code>MainViewModel</code> class has no dependencies on the UI. Finally, we saw how integrating the MVVM Toolkit into the project can reduce the boilerplate code in our view models. These good software design habits will serve us well in the chapters ahead as we build more functionality onto the project.</p>
			<p>In the next chapter, we will continue learning how to use the MVVM pattern to write robust, maintainable WinUI applications. We will cover some more advanced MVVM topics and learn some techniques for window management in a WinUI project.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Questions</h1>
			<ol>
				<li>What does MVVM stand for?</li>
				<li>Which layer typically defines the business entities in the MVVM pattern?</li>
				<li>Name one of the popular MVVM frameworks discussed in the chapter.</li>
				<li>Which interface must every View Model class implement in an MVVM application?</li>
				<li>Which special collection type in .NET notifies the UI of changes to the collection, via data binding?</li>
				<li>Which control property of <code>ComboBox</code> and <code>ListView</code> is used to get or set the currently selected item in the control?</li>
				<li>Which interface is implemented to create commands for event binding?</li>
			</ol>
		</div>
	</body></html>