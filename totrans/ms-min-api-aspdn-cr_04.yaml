- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Injection in a Minimal API Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter of the book, we will discuss some basic topics of minimal APIs
    in .NET 6.0\. We will learn how they differ from the controller-based Web APIs
    that we were used to using in the previous version of .NET. We will also try to
    underline the pros and the cons of this new approach of writing APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is dependency injection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing dependency injection in a minimal API project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the explanations in this chapter, you will need to create an ASP.NET
    Core 6.0 Web API application. You can refer the Technical requirements section
    of [*Chapter 2*](B17902_02.xhtml#_idTextAnchor023)*, Exploring Minimal APIs and
    Their Advantages* to know how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter04](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: What is dependency injection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a while, .NET has natively supported the **dependency injection** (often
    referred to as **DI**) software design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is a way to implement in .NET the **Inversion of Control**
    (**IoC**) pattern between service classes and their dependencies. By the way,
    in .NET, many fundamental services are built with dependency injection, such as
    logging, configuration, and other services.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a practical example to get a good understanding of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, a dependency is an object that depends on another object.
    In the following example, we have a `LogWriter` class with only one method inside,
    called `Log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Other classes in the project, or in another project, can create an instance
    of the `LogWriter` class and use the `Log` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This class depends directly on the `LogWriter` class, and it’s hardcoded in
    each class of your projects.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you will have some issues if you want to change the `Log` method;
    for instance, you will have to replace the implementation in each class of your
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding implementation has some issues if you want to implement unit tests
    in your solution. It’s not easy to create a mock of the `LogWriter` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency injection can solve these problems with some changes in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Use an interface to abstract the dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the dependency injection in the built-in service connecte to .NET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the service into the constructor of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding things might seem like they require big change in your code, but
    they are very easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can achieve this goal with our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create an `ILogWriter` interface with the abstraction of our
    logger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, implement this `ILogWriter` interface in a real class called `ConsoleLogWriter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, change the `Worker` class and replace the explicit `LogWriter` class with
    the new `ILogWriter` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, it’s very easy to work in this new way, and the advantages
    are substantial. Here are a few advantages of dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we need to perform the last step, that is, register the dependency when
    the application starts up.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `Program.cs` file, add this line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next section, we will discuss the difference between dependency injection
    lifetimes, another concept that you need to understand before using dependency
    injection in your minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dependency injection lifetimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned the benefits of using dependency injection
    in our project and how to transform our code to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In one of the last paragraphs, we added our class as a service to `ServiceCollection`
    of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will try to understand the difference between each dependency
    injection’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: The service lifetime defines how long an object will be alive after it has been
    created by the container.
  prefs: []
  type: TYPE_NORMAL
- en: When they are registered, dependencies require a lifetime definition. This defines
    the conditions when a new service instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following list, you can find the lifetimes defined in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transient**: A new instance of the class is created every time it is requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped**: A new instance of the class is created once per scope, for instance,
    for the same HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: A new instance of the class is created only on the first request.
    The next request will use the same instance of the same class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very often, in web applications, you only find the first two lifetimes, that
    is, transient and scoped.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a particular use case that requires a singleton, it’s not prohibited,
    but for best practice, it is recommended to avoid them in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the first two cases, transient and scoped, the services are disposed of at
    the end of the request.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to implement all the concepts that we have
    mentioned in the last two sections (the definition of dependency injection and
    its lifetime) in a short demo that you can use as a starting point for your next
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing dependency injection in a minimal API project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After understanding how to use dependency injection in an ASP.NET Core project,
    let’s try to understand how to use dependency injection in our minimal API project,
    starting with the default project using the `WeatherForecast` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the actual code of the `WeatherForecast` GET endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, this code works but it’s not easy to test it, especially
    the creation of the new values of the weather.
  prefs: []
  type: TYPE_NORMAL
- en: The best choice is to use a service to create fake values and use it with dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can better implement our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, in the `Program.cs` file, add a new interface called `IWeatherForecastService`
    and define a method that returns an array of the `WeatherForecast` entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to create the real implementation of the class inherited from
    the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now cut and paste the code from the project template inside our new implementation
    of the service. The final code looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to add our implementation of `WeatherForecastService` as a
    dependency injection in our project. To do that, insert the following line below
    the first line of code in the `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the application starts, insert our service into the services collection.
    Our work is not finished yet.
  prefs: []
  type: TYPE_NORMAL
- en: We need to use our service in the default `MapGet` implementation of the `WeatherForecast`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The minimal API has his own parameter binding implementation and it’s very easy
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, to implement our service with dependency injection, we need to
    remove all the old code from the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the endpoint, after removing the code, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can improve our code and use the dependency injection very easily by simply
    replacing the old code with the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the minimal API project, the real implementations of the services in the
    service collection are passed as parameters to the functions and you can use them
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'From time to time, you may have to use a service from the dependency injection
    directly in the main function during the startup phase. In this case, you must
    retrieve the instance of the implementation directly from the services collection,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have implemented dependency injection in a minimal API project,
    starting from the default template.
  prefs: []
  type: TYPE_NORMAL
- en: We reused the existing code but implemented it with logic that’s more geared
    toward an architecture that’s better suited to being maintained and tested in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is a very important approach to implement in modern applications.
    In this chapter, we learned what dependency injection is and discussed its fundamentals.
    Then, we saw how to use dependency injection in a minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on another important layer of modern applications
    and discuss how to implement a logging strategy in a minimal API project.
  prefs: []
  type: TYPE_NORMAL
