- en: Debugging and Threading
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和线程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Enabling the UI debugging tool for XAML
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 XAML 的 UI 调试工具
- en: Navigating through XAML elements using Live Visual Tree
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实时视觉树遍历 XAML 元素
- en: Inspecting XAML properties using Live Property Explorer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实时属性浏览器检查 XAML 属性
- en: Updating the UI from a non-UI thread
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从非 UI 线程更新 UI
- en: Adding cancelation support to long running threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为长时间运行的线程添加取消支持
- en: Using the background worker component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用后台工作组件
- en: Using a timer to periodically update the UI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计时器定期更新 UI
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When it comes to application development, debugging plays a vital role. It is
    a process that helps you to quickly look at the current state of your program
    by walking through the code line by line. While writing the code, developers start
    debugging their applications. Sometimes, developers start debugging even before
    writing the first line of code to know the existing logic.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到应用程序开发时，调试起着至关重要的作用。这是一个通过逐行遍历代码来快速查看程序当前状态的过程。在编写代码时，开发者开始调试他们的应用程序。有时，开发者甚至在编写第一行代码之前就开始调试，以便了解现有的逻辑。
- en: Visual Studio provides us with details about running programs as much as possible
    and helps you to change some values while the application is running. As a developer,
    you must already know this. As the focus of this book is on **Windows Presentation
    Foundation** (**WPF**), we will be discussing XAML UI debugging using **Live Visual
    Tree** and **Live Property Explorer**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 尽可能提供有关运行程序的详细信息，并帮助您在应用程序运行时更改一些值。作为一名开发者，您必须已经知道这一点。由于本书的重点是
    **Windows 表现基金会**（**WPF**），我们将讨论使用 **实时视觉树** 和 **实时属性浏览器**进行 XAML UI 调试。
- en: Later in this chapter, we will discuss **threading** and learn how to update
    a UI thread from a non-UI thread, a background worker process, and a timer that
    is used to periodically update the UI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将讨论 **线程**，并学习如何从非 UI 线程、后台工作进程和用于定期更新 UI 的计时器更新 UI 线程。
- en: Enabling the UI debugging tool for XAML
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 XAML 的 UI 调试工具
- en: To begin debugging your XAML application UI, you will first need to enable a
    few settings in Visual Studio. If the settings are disabled, you won't be able
    to view the **Live Visual Tree** and the **Live Properties** window, which we
    will be discussing in the next few recipes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试您的 XAML 应用程序 UI，您首先需要在 Visual Studio 中启用一些设置。如果设置被禁用，您将无法查看 **实时视觉树** 和
    **实时属性**窗口，我们将在接下来的几个食谱中讨论。
- en: These settings are by default enabled in Visual Studio 2017, but in case are
    disabled; this recipe will help you to get started with that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置在 Visual Studio 2017 中默认启用，但如果已禁用，此食谱将帮助您开始使用它。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have Visual Studio 2017\. Open it to get started with the
    settings changes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装 Visual Studio 2017。打开它以开始设置更改。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps mentioned here to verify and enable the UI Debugging Tools
    for XAML in Visual Studio 2017:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤验证并启用 Visual Studio 2017 中 XAML 的 UI 调试工具：
- en: 'Inside the Visual Studio IDE, navigate to the Tools | Options... menu, as shown
    in the following screenshot:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio IDE 中，导航到工具 | 选项...菜单，如图所示：
- en: '![](img/48a669c8-31c8-490c-8c7f-05b27b019075.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48a669c8-31c8-490c-8c7f-05b27b019075.png)'
- en: This will open the Visual Studio Options window. From this page, navigate to
    the Debugging | General section.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开 Visual Studio 选项窗口。从该页面，导航到调试 | 通用部分。
- en: 'Select the checkbox labeled Enable UI Debugging Tools for XAML, and switch
    it ON if it is not already:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择标记为启用 XAML UI 调试工具的复选框，如果尚未启用，请将其打开：
- en: '![](img/31212628-0a71-4961-a105-1c99e420412a.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31212628-0a71-4961-a105-1c99e420412a.png)'
- en: Once you switch ON the functionality to debug the XAML application UI, you will
    enable a few more settings to use the **Live Visual Tree** and modifications of
    XAML properties when the debugger is already attached.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您打开调试 XAML 应用程序 UI 的功能，您将启用更多设置以使用 **实时视觉树** 和在调试器已附加时修改 XAML 属性。
- en: From the same page, select the other checkboxes labeled Preview selected elements
    in Live Visual Tree and Show runtime tools in application.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从同一页面，选择其他标记为在实时视觉树中预览所选元素和显示应用程序中的运行时工具的复选框。
- en: To be able to change the XAML elements and their properties when the application
    is already running in debug mode, check Enable XAML Edit and Continue, as shown
    in the preceding screenshot.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要能够在应用程序以调试模式运行时更改 XAML 元素及其属性，请检查“启用 XAML 编辑和继续”，如图所示。
- en: Click OK to save the changes and restart the debugging process for the changes
    to take effect. You will now be able to debug your XAML UI.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以保存更改并重新启动调试过程以使更改生效。现在您将能够调试您的 XAML UI。
- en: Navigating through XAML elements using Live Visual Tree
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实时视觉树导航 XAML 元素
- en: '**Live Visual Tree** is a debugger tool that helps you to perform XAML debugging
    more easily. Using this, you can inspect the XAML at runtime and visualize the
    layout to show alignments and space for UI elements.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时视觉树**是一个调试工具，可以帮助您更轻松地执行 XAML 调试。使用它，您可以在运行时检查 XAML 并可视化布局以显示 UI 元素的对齐和空间。'
- en: Basically, Live Visual Tree provides you a tree view of the UI elements of your
    running XAML application, and provides information about the number of XAML elements
    inside each container. If the interface changes from one state to another, Live
    Visual Tree also changes in runtime.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，实时视觉树为您提供了正在运行的 XAML 应用程序 UI 元素的树视图，并提供了每个容器内 XAML 元素数量的信息。如果界面从一个状态变为另一个状态，实时视觉树也会在运行时发生变化。
- en: In this recipe, we will learn more about Live Visual Tree and how to use it
    to visualize the actual control rendering on the UI.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习更多关于实时视觉树以及如何使用它来可视化 UI 上的实际控件渲染。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open Visual Studio 2017 IDE and create a new WPF project named
    `CH10.XamlDebuggingDemo`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开 Visual Studio 2017 IDE 并创建一个名为 `CH10.XamlDebuggingDemo` 的新 WPF 项目。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps mentioned here to create our sample demo application and then
    learn how to use **Live Visual Tree** to navigate through the XAML elements while
    debugging the application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按照此处提到的步骤创建我们的示例演示应用程序，然后学习如何在调试应用程序时使用**实时视觉树**导航 XAML 元素：
- en: Let's first design our application UI. Open the `MainWindow.xaml` file from
    Solution Explorer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先设计应用程序 UI。从解决方案资源管理器打开 `MainWindow.xaml` 文件。
- en: 'Divide the default `Grid` panel to have five rows in the following manner:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 `Grid` 面板分成以下方式具有五行：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `Grid`, add the following XAML code block to create a login screen
    with a few textblocks, textboxes, and button controls. Place them in appropriate
    rows as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Grid` 内部，添加以下 XAML 代码块以创建一个包含几个文本块、文本框和按钮控件的登录屏幕。将它们放置在适当的行中，如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, inside the `<Window>` tag, add `<Window.Resources>` and add the following
    styles for the `TextBox` and `Button` controls to give them a proper look:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `<Window>` 标签内，添加 `<Window.Resources>` 并为 `TextBox` 和 `Button` 控件添加以下样式，以使它们看起来更合适：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the UI is ready, let''s run the application. You will see the following
    output on the screen:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 UI 准备就绪，让我们运行应用程序。你将在屏幕上看到以下输出：
- en: '![](img/506b3fa6-288b-46a3-a28c-b9ac7cb2c22f.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/506b3fa6-288b-46a3-a28c-b9ac7cb2c22f.png)'
- en: Now, close the application and run it in debug mode. To do this, either click
    on the Start button (![](img/56df5ce0-a8b4-4745-8b84-26d258ecfc9c.png)) on the
    **Visual Studio Toolbar** or navigate to the Visual Studio Debug menu and click
    Start Debugging.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭应用程序并以调试模式运行。为此，可以点击**Visual Studio 工具栏**上的开始按钮 (![](img/56df5ce0-a8b4-4745-8b84-26d258ecfc9c.png))，或者导航到
    Visual Studio 调试菜单并点击开始调试。
- en: Alternatively, you can press the keyboard shortcut *F5* to run the application
    in debug mode.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以按键盘快捷键 *F5* 以调试模式运行应用程序。
- en: 'Once the application launches, you will see the following output with a toolbar
    on the screen:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序启动，您将在屏幕上看到以下输出，其中包含一个工具栏：
- en: '![](img/7dff8c22-8b81-4214-af63-436438d3ff62.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dff8c22-8b81-4214-af63-436438d3ff62.png)'
- en: 'In case the toolbar is not present in the UI, navigate to Visual Studio''s
    Debugging options and enable Show runtime tools in application, as shown in the
    following screenshot. Also make sure that the other checkboxes (marked here) are
    already checked:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果工具栏在 UI 中不存在，请导航到 Visual Studio 的调试选项，并启用“在应用程序中显示运行时工具”，如图所示。同时确保其他复选框（此处标记）已经勾选：
- en: '![](img/3a277773-7867-425b-a4e2-5480e54599eb.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a277773-7867-425b-a4e2-5480e54599eb.png)'
- en: 'When the application is running in debug mode, click on the second button on
    the runtime toolbar to enable the control selection:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序以调试模式运行时，点击运行时工具栏上的第二个按钮以启用控件选择：
- en: '![](img/86f44a73-7714-42fd-9148-0c83e2e33c03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86f44a73-7714-42fd-9148-0c83e2e33c03.png)'
- en: 'Now, hover over on any control on the application UI, and you will see a red
    dotted border on the hovered control (just like the **IE Developer Tools**), as
    shown in the following screenshot:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将鼠标悬停在应用程序UI上的任何控件上，你将看到悬停控件上有一个红色虚线边框（就像**IE开发者工具**一样），如图所示：
- en: '![](img/d163a9cd-69ad-41bb-b44e-265f61620ebb.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d163a9cd-69ad-41bb-b44e-265f61620ebb.png)'
- en: 'Click on any control to open Live Visual Tree inside the Visual Studio editor.
    In case it is not visible, navigate back to the application UI, and as shown in
    the following screenshot, click the first button on the runtime toolbar to launch
    the Live Visual Tree dialog panel:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击任何控件以在Visual Studio编辑器中打开实时视觉树。如果它不可见，导航回应用程序UI，如图所示，点击运行时工具栏上的第一个按钮以启动实时视觉树对话框面板：
- en: '![](img/abcdcdcf-6f33-4ccb-9a19-0877d78ff662.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abcdcdcf-6f33-4ccb-9a19-0877d78ff662.png)'
- en: Alternatively, you can navigate to the Visual Studio 2017 menu Debug | Windows
    | Live Visual Tree to launch this dialog window.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你可以导航到Visual Studio 2017菜单调试 | 窗口 | 实时视觉树以打开此对话框窗口。
- en: 'Click on the input box, labeled Password. Live Visual Tree will show you the
    currently selected visual element within the visual tree. Check out the following
    screenshot:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标记为密码的输入框。实时视觉树将显示视觉树中当前选中的视觉元素。查看以下截图：
- en: '![](img/3b7450a6-0aac-4d90-b645-c941565aeba6.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b7450a6-0aac-4d90-b645-c941565aeba6.png)'
- en: 'Let''s click on the button control (labeled Login) and, as shown in the following
    screenshot, the appropriate Button control will be automatically selected in the
    Visual Tree:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们点击按钮控制（标记为登录），如图所示，在视觉树中会自动选择相应的按钮控制：
- en: '![](img/d01fa2b3-4c5f-441a-affd-5fb208e69ea8.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d01fa2b3-4c5f-441a-affd-5fb208e69ea8.png)'
- en: 'Now, click on the Login label inside the button. You will see that the `Button`
    control contains a `TextBlock` element, which is present inside a `ContentPresenter`,
    wrapped inside a `Border` control:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击按钮内的登录标签。你会看到`Button`控制包含一个`TextBlock`元素，该元素位于`ContentPresenter`内部，被`Border`控制包裹：
- en: '![](img/696637c5-9aa8-4e54-a362-ea1b14cb02bf.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/696637c5-9aa8-4e54-a362-ea1b14cb02bf.png)'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you launch a WPF application in debug mode, the floating toolbar also gets
    loaded on the screen, which allows you to easily select the element in the running
    instance of the application and inspect its **Visual Element** in **Live Visual
    Tree**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在调试模式下启动WPF应用程序时，浮动工具栏也会在屏幕上加载，这允许你轻松选择应用程序运行实例中的元素，并检查其在**实时视觉树**中的**视觉元素**。
- en: 'The floating toolbar contains four buttons—Go to Live Visual Tree, Enable Selection,
    Display layout adorners, and Track focused element, as shown in the following
    screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动工具栏包含四个按钮——转到实时视觉树、启用选择、显示布局装饰器和跟踪焦点元素，如图所示：
- en: '![](img/757ffdbe-5586-46ef-b8f5-9979650a9cd9.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/757ffdbe-5586-46ef-b8f5-9979650a9cd9.png)'
- en: 'In `MainWindow.xaml`, we have added just the `Button` control inside `StackPanel`,
    but when you see it on **Live Visual Tree**, you will notice that the `Button`
    control consists of other UI elements to represent the control. It contains a
    `Border`, a `ContentPresenter`, and a `TextBlock` to visualize the `Button` content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml`中，我们只在`StackPanel`内添加了`Button`控件，但当你看到它在**实时视觉树**中时，你会注意到`Button`控件由其他UI元素组成以表示控件。它包含一个`Border`、一个`ContentPresenter`和一个`TextBlock`来可视化`Button`内容：
- en: '![](img/c19150fb-9b41-470b-ba1f-b7dc94dd5e83.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c19150fb-9b41-470b-ba1f-b7dc94dd5e83.png)'
- en: Like this, each UI control consists of one or more UI elements that are only
    visible in a Visual Tree and can be inspected via Live Visual Tree when the debugger
    is attached to the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，每个UI控件都由一个或多个UI元素组成，这些元素仅在视觉树中可见，并且当调试器附加到应用程序时可以通过实时视觉树进行检查。
- en: Please note that this is how the XAML controls actually render in the UI. The
    more levels of elements you have in a **Visual Tree**, the more performance issues
    it may hit. Detecting and eliminating unnecessary elements in the Visual Tree
    is one of the major advantages of a **Live Visual Tree** debugger window.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这就是XAML控件在UI中实际渲染的方式。元素在视觉树中的层级越多，可能遇到的性能问题就越多。检测和消除视觉树中不必要的元素是**实时视觉树**调试窗口的主要优势之一。
- en: Visual Studio 2017 also supports modification of the selected element in the
    Live Visual Tree window, which we will be demonstrating in the next recipe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017还支持在实时视觉树窗口中修改所选元素，我们将在下一个菜谱中演示。
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can also ask the XAML debugger to display the layout adorners. While the
    runtime debugger tool is visible on the application window, click on the third
    button (as shown in the following screenshot), titled Display layout adorners.
    It will cause the application window to show horizontal and vertical lines along
    the bounds of the selected object, so you can see what it aligns to. It also displays
    rectangles showing the margins:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以要求 XAML 调试器显示布局装饰器。当运行时调试工具在应用程序窗口中可见时，点击第三个按钮（如下面的截图所示），标题为显示布局装饰器。这将导致应用程序窗口在所选对象的边界上显示水平和垂直线，以便你可以看到它对齐的位置。它还显示显示边距的矩形：
- en: '![](img/561a81b9-1d04-4ea4-b88c-8bc4b5a946aa.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/561a81b9-1d04-4ea4-b88c-8bc4b5a946aa.png)'
- en: 'When enabled, hover over or click any UI element on the application window.
    You will see the layout adorner for that control, as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用时，将鼠标悬停在应用程序窗口上的任何 UI 元素上或点击它。你会看到该控件的布局装饰器，如下面的截图所示：
- en: '![](img/9f4dc5f3-ce5b-4a75-9cca-b28b3a6b7271.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f4dc5f3-ce5b-4a75-9cca-b28b3a6b7271.png)'
- en: Inspecting XAML properties using Live Property Explorer
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Live Property Explorer 检查 XAML 属性
- en: In the previous recipe, we learnt about **Live Visual Tree**, which is used
    to get a real-time view of your running XAML code by inspecting the visual elements.
    Visual Studio 2015 and above also provide a **Live Property Explorer** window,
    which allows you to temporarily modify the XAML properties at runtime to see the
    visual effect.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们学习了 **Live Visual Tree**，它通过检查视觉元素来获取运行中的 XAML 代码的实时视图。Visual Studio
    2015 及以上版本还提供了一个 **Live Property Explorer** 窗口，允许你在运行时临时修改 XAML 属性以查看视觉效果。
- en: In this recipe, we will learn about Live Property Explorer. We will use Visual
    Studio 2017 to demonstrate it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习关于 Live Property Explorer 的内容。我们将使用 Visual Studio 2017 来演示它。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin with a demo project creation. Open your Visual Studio 2017 instance
    and create a new project named `CH10.LivePropertyExplorerDemo`. Make sure to select
    the WPF application template during project creation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个演示项目开始。打开你的 Visual Studio 2017 实例，创建一个名为 `CH10.LivePropertyExplorerDemo`
    的新项目。确保在创建项目时选择 WPF 应用程序模板。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to design our application UI with a simple button and then
    utilize **Live Property Explorer** to view and modify the XAML properties at runtime:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用简单的按钮设计我们的应用程序 UI，然后利用 **Live Property Explorer** 在运行时查看和修改 XAML 属性：
- en: From Solution Explorer, open the `MainWindow.xaml` file.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中打开 `MainWindow.xaml` 文件。
- en: 'Replace the content of the XAML with the following code to have a basic `Button`
    with default style:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 XAML 的内容替换为以下代码，以获得具有默认样式的基本 `Button`：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s run the application. You will see that the button automatically arranges
    itself to cover the entire application. This is because we have placed the button
    inside a `Grid` and haven''t specified its dimensions and margins, as shown in
    the following screenshot:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用程序。你会看到按钮自动排列以覆盖整个应用程序。这是因为我们将按钮放置在一个 `Grid` 中，并且没有指定其尺寸和边距，如下面的截图所示：
- en: '![](img/1fa1a4a0-fd85-4ba4-8143-6c19f5c3ace5.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fa1a4a0-fd85-4ba4-8143-6c19f5c3ace5.png)'
- en: Now, close the application and run it in debug mode.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭应用程序并以调试模式运行。
- en: Once the application launches in debug mode, navigate to the Visual Studio menu—Debug
    | Windows | Live Property Explorer to open said explorer window.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序以调试模式启动，导航到 Visual Studio 菜单—调试 | 窗口 | Live Property Explorer 以打开该探索器窗口。
- en: 'The Live Property Explorer window will look as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Live Property Explorer 窗口将如下所示：
- en: '![](img/9961fcd4-f963-4cd8-b227-cbb48a327975.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9961fcd4-f963-4cd8-b227-cbb48a327975.png)'
- en: As you can see in the preceding screenshot, Live Property Explorer is showing
    the properties of the selected `Button` control, named `myButton`. You will find
    that most of the properties are disabled. This is because they are either inherited
    from implicit/explicit styles or have default values.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前一个截图所示，Live Property Explorer 正在显示所选 `Button` 控件的属性，命名为 `myButton`。你会发现大多数属性都是禁用的。这是因为它们要么是从隐式/显式样式继承的，要么具有默认值。
- en: To experiment with the UI element properties, you should modify the properties
    inside the Local panel.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实验 UI 元素属性，你应该修改 Local 面板内的属性。
- en: 'To override an existing property value of the selected element (in our case,
    it is `myButton`) from Live Visual Tree, click on the New button, as shown in
    the following screenshot:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从 Live Visual Tree 中覆盖所选元素（在我们的例子中是 `myButton`）的现有属性值，点击如下截图所示的“新建”按钮：
- en: '![](img/fa9bb085-0f10-482f-8c7b-bea94c9638d0.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa9bb085-0f10-482f-8c7b-bea94c9638d0.png)'
- en: 'This will add a drop-down list in the panel, where you will be able to select
    the property that you would like to modify. Let''s select Width from the property
    list:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在面板中添加一个下拉列表，你可以从中选择要修改的属性。让我们从属性列表中选择“宽度”：
- en: '![](img/b20e3581-8413-4bb1-b086-dd6401cb91a1.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b20e3581-8413-4bb1-b086-dd6401cb91a1.png)'
- en: When you select the property, the panel will get populated with the appropriate
    property boxes to fill it. Enter `120` as the value against the Width property.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你选择属性时，面板将填充适当的属性框以填充它。将宽度属性的值输入为 `120`。
- en: Notice the running application window. The `Button` control in the window will
    be automatically resized to a width of 120 pixels.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意运行中的应用程序窗口。窗口中的 `Button` 控件将自动调整到 120 像素的宽度。
- en: 'Observe the actual element in the XAML designer window. The change was not
    performed in the XAML code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察 XAML 设计器窗口中的实际元素。更改并未在 XAML 代码中执行：
- en: '![](img/7a71d29e-bcd4-4a27-8f85-0627aabd7a6c.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a71d29e-bcd4-4a27-8f85-0627aabd7a6c.png)'
- en: Let's modify a few more properties of the `Button` control. Click on the New
    button and select `Height` from the property list. Set its value to `30`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改 `Button` 控制的几个属性。单击“新建”按钮，并从属性列表中选择“高度”。将其值设置为 `30`。
- en: Click on the New button once again and select `Background` from the property
    list. Now enter `Red` as its value. You can alternatively enter `#FFFF0000` to
    apply a red color as the button background.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击“新建”按钮，并从属性列表中选择“背景”。现在将其值输入为“Red”。你也可以输入 `#FFFF0000` 以将红色应用到按钮背景。
- en: 'Once you perform these changes, look at the running application window. The
    new height and the background color have already been applied to the button:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你进行了这些更改，查看运行中的应用程序窗口。新的高度和背景颜色已经应用到按钮上：
- en: '![](img/31e040d8-a933-4e68-a14e-c70ccdbca665.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31e040d8-a933-4e68-a14e-c70ccdbca665.png)'
- en: Let's change a few more properties. Add the `FontSize` and `Foreground` properties
    in your local property list. Set their values to `16` and `White`, respectively.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再更改一些属性。在你的本地属性列表中添加 `FontSize` 和 `Foreground` 属性。分别将它们的值设置为 `16` 和 `White`。
- en: 'Check the application window for the changes. It will now look as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查应用程序窗口中的更改。现在它将看起来如下：
- en: '![](img/65878958-94b4-47d9-a8a0-bd8ba688afa3.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65878958-94b4-47d9-a8a0-bd8ba688afa3.png)'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**Live Property Explorer** only gives you a preview of what you want to modify
    in runtime. Based on that, you can change the original UI in the XAML view or
    designer view for permanent changes.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时属性浏览器**只为你提供了在运行时想要修改的预览。基于此，你可以更改 XAML 视图或设计视图中的原始 UI 以进行永久更改。'
- en: If you end the debugging session, the changes that you performed in the Live
    Property Explorer window won't be saved and you will lose those changes. When
    you restart the application, you will see fresh values as per the default.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你结束调试会话，你在 Live Property Explorer 窗口中进行的更改将不会保存，并且你会丢失这些更改。当你重新启动应用程序时，你会看到默认的新值。
- en: This is often useful when you want to see the changes live at runtime for any
    element inside the Visual Tree.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在你想要在运行时实时查看 Visual Tree 中任何元素的更改时很有用。
- en: There's more...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To permanently set the properties of any UI element while the application is
    running in debug mode, use either the XAML code view or the XAML designer view.
    The running application will automatically get the update of the style changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试模式下运行应用程序时，要永久设置任何 UI 元素的属性，请使用 XAML 代码视图或 XAML 设计器视图。运行中的应用程序将自动获取样式更改的更新。
- en: To modify the XAML code while the application is running in debug mode, make
    sure that the Enable UI Debugging Tools for XAML and the Enable XAML Edit and
    Continue settings are enabled (checked) in the Visual Studio Options window, under
    the Debugging | General section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试模式下运行应用程序时修改 XAML 代码，请确保在 Visual Studio 选项窗口的调试 | 通用部分中启用了“启用 XAML UI 调试工具”和“启用
    XAML 编辑和继续”设置（已勾选）。
- en: 'Let''s run the application once again in debug mode and start modifying the
    control properties directly in the XAML view. Once you have made some changes,
    check the running application and you will see that it already has been updated
    with the modified data:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在调试模式下再次运行应用程序，并直接在 XAML 视图中修改控件属性。一旦你进行了更改，检查运行中的应用程序，你会看到它已经根据修改后的数据进行了更新：
- en: '![](img/47153405-e910-4b93-921c-3a2e2e324dd5.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47153405-e910-4b93-921c-3a2e2e324dd5.png)'
- en: 'Here''s the modified XAML code of the button, which we used in the preceding
    screenshot. When applied, it will result in the addition of a nice linear gradient
    color to the button background:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是按钮修改后的XAML代码，我们在前面的屏幕截图中使用了它。应用后，它将为按钮背景添加一个漂亮的线性渐变颜色：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Updating the UI from a non-UI thread
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从非UI线程更新UI
- en: In WPF, the UI is managed by a single thread, called a **UI thread**, which
    that creates an instance of a window and processes the UI messages for that window.
    This is known as **message pumping**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，UI由一个称为**UI线程**的单个线程管理，该线程创建一个窗口实例并处理该窗口的UI消息。这被称为**消息泵**。
- en: When the UI thread is performing a lot of operations, it enters in to a wait
    state and stops processing further UI messages. This causes the application to
    enter *Not Responding* mode, which is commonly known as **UI freezing**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当UI线程执行大量操作时，它会进入等待状态并停止处理进一步的UI消息。这会导致应用程序进入*无响应*模式，这通常被称为**UI冻结**。
- en: To resolve this issue, you need to offload that long running operation into
    another thread. This keeps the UI thread free and allows it to perform the UI
    updates and stay responsive.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，你需要将这个长时间运行的操作卸载到另一个线程。这会使UI线程保持空闲，并允许它执行UI更新并保持响应。
- en: In this recipe, we will learn how to offload a long running process into a separate
    thread in a thread pool and perform the UI updates once it completes the execution.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何将长时间运行的过程卸载到线程池中的单独线程，并在执行完成后执行UI更新。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin by creating a WPF project. Name it `CH10.ThreadingDemo1`. Make sure
    to select the right WPF App template during project creation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个WPF项目开始。命名为`CH10.ThreadingDemo1`。确保在创建项目时选择正确的WPF App模板。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create a simple application that will count odd and even numbers in
    a numeric range. This will be done on a non-UI thread and once the result is available
    we will update the UI. Follow these steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，该应用程序将计算一个数字范围内的奇数和偶数。这将在非UI线程上完成，一旦结果可用，我们将更新UI。按照以下步骤操作：
- en: From Solution Explorer, open the `MainWindow.xaml` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中打开`MainWindow.xaml`文件。
- en: 'Replace the existing `Grid` with the following simple user interface to provide
    the numeric range, and a button to calculate and display the result:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的`Grid`替换为以下简单的用户界面，以提供数字范围，并一个按钮来计算和显示结果：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Navigate to the `MainWindow.xaml.cs` file and add the following two member-variables
    to store the total count of odd and even numbers:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`MainWindow.xaml.cs`文件，并添加以下两个成员变量以存储奇数和偶数的总数：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will now create a method to calculate the odd and even numbers. Inside the
    `MainWindow` class, create a method named `CalculateOddEven`, and implement the
    code block as shown in this following code snippet:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个方法来计算奇数和偶数。在`MainWindow`类中，创建一个名为`CalculateOddEven`的方法，并实现如下代码片段所示的代码块：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we need to invoke the call. Let''s implement the button click event `OnCalculateClicked`
    to call the `CalculateOddEven` method and display the result:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要调用这个方法。让我们实现按钮点击事件`OnCalculateClicked`来调用`CalculateOddEven`方法并显示结果：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the application and click on the Calculate button. The UI will freeze for
    some time while the long running operation is in-progress, as it finds out the
    odd and even numbers between the `100 - 1000000000` range. Once the calculation
    completes, it will unfreeze the UI and display the result:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并点击计算按钮。在长时间运行的操作进行时，UI会冻结一段时间，因为它正在找出`100 - 1000000000`范围内的奇数和偶数。一旦计算完成，它将解冻UI并显示结果：
- en: '![](img/c0636500-0d8d-47e8-acb0-b7bb41ad2afd.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0636500-0d8d-47e8-acb0-b7bb41ad2afd.png)'
- en: To resolve this issue, we should move the long running process to a different
    thread so that the UI thread keeps responding. We will be using a thread pool
    to move the process to a different thread. You can also perform this by creating
    a new `Thread` instance or by using `Task`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们应该将长时间运行的过程移动到不同的线程，以便UI线程保持响应。我们将使用线程池将过程移动到不同的线程。您也可以通过创建一个新的`Thread`实例或使用`Task`来完成此操作。
- en: 'In this example, we will be using thread pool. This can be done by calling
    `ThreadPool.QueueUserWorkItem`, as shown in the following code snippet:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用线程池。这可以通过调用`ThreadPool.QueueUserWorkItem`来实现，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to update the UI once the operation gets completed. This can''t
    be done outside the `ThreadPool.QueueUserWorkItem` block, as the operation will
    run in a different thread. The same can''t be done directly inside the `ThreadPool.QueueUserWorkItem`
    block too, as the update should be performed in the UI thread. For this to work,
    the `Dispatcher.BeginInvoke` block can be used within the `ThreadPool.QueueUserWorkItem`
    block, as shown in the following code snippet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在操作完成后更新UI。这不能在`ThreadPool.QueueUserWorkItem`块外部完成，因为操作将在不同的线程上运行。同样，也不能直接在`ThreadPool.QueueUserWorkItem`块内部完成，因为更新应该在UI线程上执行。为了使这可行，可以在`ThreadPool.QueueUserWorkItem`块内部使用`Dispatcher.BeginInvoke`块，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's run the application once again. Click on the Calculate button. You will
    observe that the UI is responsive while the long running operation is in progress.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行应用程序。点击Calculate按钮。您将观察到，在长时间运行的操作进行时，UI仍然是响应的。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each and every element in WPF inherits from `DispatcherObject`, and thus, the
    UI thread is always associated with `System.Windows.Threading.Dispatcher`. This
    is the reason why the `Dispatcher` object can be accessed any time by using the
    `DispatcherObject.Dispatcher` property.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: WPF中的每个元素都继承自`DispatcherObject`，因此UI线程始终与`System.Windows.Threading.Dispatcher`相关联。这就是为什么可以通过使用`DispatcherObject.Dispatcher`属性在任何时候访问`Dispatcher`对象的原因。
- en: '`ThreadPool.QueueUserWorkItem` causes a delegate to execute on the CLRs thread
    pool. Thus, the operation performed within that delegate never executes on the
    UI thread.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool.QueueUserWorkItem`会导致委托在CLR线程池上执行。因此，在该委托内部执行的操作永远不会在UI线程上执行。'
- en: Once the operation completes, and you need to update the UI, you must update
    this from the UI thread. The call to `Dispatcher.BeginInvoke` causes the delegate
    to run on the UI thread and make the necessary changes to the UI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作完成，并且您需要更新UI，您必须从UI线程更新。对`Dispatcher.BeginInvoke`的调用会导致委托在UI线程上运行并做出必要的UI更改。
- en: A point to note is that the dispatcher is also accessible from the UI thread,
    using the static property `Dispatcher.CurrentDispatcher`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，调度器也可以从UI线程通过静态属性`Dispatcher.CurrentDispatcher`访问。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are two kinds of invocations by `Dispatcher`—`BeginInvoke` and `Invoke`.
    We have already seen the uses of `BeginInvoke`, which basically invokes `delegate`
    and returns to perform other operations while `delegate` is still running on the
    UI thread.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher`有两种调用方式——`BeginInvoke`和`Invoke`。我们已经看到了`BeginInvoke`的使用，它基本上会调用`delegate`并在`delegate`仍在UI线程上运行时返回以执行其他操作。'
- en: On the other side, the `Invoke` operation does not return until `delegate` completes
    its execution on the UI thread.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Invoke`操作不会返回，直到`delegate`在UI线程上完成其执行。
- en: '`BeginInvoke` is always preferable unless there is a specific reason to wait
    for the UI operation to complete.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定的原因需要等待UI操作完成，否则`BeginInvoke`始终是首选。
- en: '`Dispatcher` maintains a queue of requests that need to be processed on the
    UI thread. This is basically handled by setting `DispatcherPriority`. The default
    priority is `DispatcherPriority.Normal`, but you can set a lower or a higher priority
    based on the importance of the operation.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher`维护一个需要在UI线程上处理的请求队列。这基本上是通过设置`DispatcherPriority`来处理的。默认优先级是`DispatcherPriority.Normal`，但您可以根据操作的重要性设置一个较低的或较高的优先级。'
- en: Adding cancelation support to long running threads
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为长时间运行的线程添加取消支持
- en: When you execute a long running process on a different thread, to keep the UI
    responsive during the operation, you may want to provide a functionality to cancel
    the operation. This can be done on an on-demand basis.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在另一个线程上执行长时间运行的过程时，为了在操作期间保持UI的响应性，您可能希望提供一个取消操作的功能。这可以按需完成。
- en: In this recipe, we will learn how to add cancellation support to the existing
    long running operation that we have built in the previous recipe.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何将取消支持添加到之前菜谱中构建的现有长时间运行操作。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the same example that we used in the previous recipe. You can
    copy the entire `CH10.ThreadingDemo1` project folder and give it a new name, `CH10.ThreadingDemo2`.
    Launch Visual Studio and open the new (`CH10.ThreadingDemo2`) project inside it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前菜谱中使用的相同示例。您可以复制整个`CH10.ThreadingDemo1`项目文件夹，并给它一个新的名字，`CH10.ThreadingDemo2`。启动Visual
    Studio，并在其中打开新的（`CH10.ThreadingDemo2`）项目。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to update the existing project and to have cancellation
    support during the long running process:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤更新现有项目，并在长时间运行过程中支持取消操作：
- en: 'Navigate to the `MainWindow.xaml` file and modify the UI to have a `Cancel`
    button in it. Add the following button control inside `StackPanel`, and label
    it as `Cancel`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`MainWindow.xaml`文件，并修改UI以在其中包含一个`Cancel`按钮。在`StackPanel`内部添加以下按钮控件，并将其标签设置为`Cancel`：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make sure to set its `IsEnabled` property to `False`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将其`IsEnabled`属性设置为`False`。
- en: 'Now, navigate to the `MainWindow.xaml.cs` file and add the following member
    variable inside the class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到`MainWindow.xaml.cs`文件，并在类内部添加以下成员变量：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the `Cancel` button click, we need to cancel the running operation. Let''s
    modify the `OnCancelClicked` event to perform the same as the following code snippet:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cancel`按钮点击时，我们需要取消正在运行的操作。让我们修改`OnCancelClicked`事件，使其与以下代码片段执行相同的操作：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s navigate to the `CalculateOddEven` method and modify it to accept a
    third parameter of type `CancellationToken`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导航到`CalculateOddEven`方法并修改它以接受一个类型为`CancellationToken`的第三个参数：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the `for` loop of the `CalculateOddEven` method, check whether the `CancellationToken.IsCancellationRequested`
    is `true`, and if so, return immediately after setting the `totalOdd` and `totalEven`
    values to `-1`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CalculateOddEven`方法的`for`循环内部，检查`CancellationToken.IsCancellationRequested`是否为`true`，如果是，则立即返回，并在将`totalOdd`和`totalEven`值设置为`-1`后立即返回。
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For reference, here''s the modified code of the `CalculateOddEven` method implementation:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅供参考，以下是`CalculateOddEven`方法实现修改后的代码：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: On `OnCalculateClicked` event implementation, we need to perform some changes.
    First create the instance of `CancellationTokenSource` and assign it to the `tokenSource`
    variable.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCalculateClicked`事件实现中，我们需要进行一些更改。首先创建`CancellationTokenSource`的实例并将其分配给`tokenSource`变量。
- en: Then, pass the instance to the `CalculateOddEven` method as the third parameter
    value.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将实例传递给`CalculateOddEven`方法作为第三个参数值。
- en: 'Then, inside the `Dispatcher.BeginInvoke` call, modify the code to display
    Operation canceled! based on the value of `totalOdd` and `totalEven` variables.
    Display the message only if either of them is `-1`. Here''s the complete implementation:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Dispatcher.BeginInvoke`调用内部，修改代码以根据`totalOdd`和`totalEven`变量的值显示“操作已取消！”。只有当其中任何一个为`-1`时才显示消息。以下是完整的实现：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once done, let''s run the application. Click the Calculate button to start
    the process in a separate thread in the thread pool:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，让我们运行应用程序。点击计算按钮以在线程池中的单独线程中启动进程：
- en: '![](img/c47ebde2-9a39-4ce8-85bb-0d27be0ae523.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c47ebde2-9a39-4ce8-85bb-0d27be0ae523.png)'
- en: 'While the operation is in progress, click the Cancel button. You will see that
    the process immediately stops and the Operation canceled! message gets displayed
    in the UI:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当操作正在进行时，点击取消按钮。您会看到进程立即停止，并且在UI中显示“操作已取消！”消息：
- en: '![](img/05979e0a-608b-4706-a2dc-ddf3ff9ce364.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05979e0a-608b-4706-a2dc-ddf3ff9ce364.png)'
- en: Let's click on the `Calculate` button once again and wait until the process
    ends. What can you see now? It displays the total count of odd and even numbers
    on the UI.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次点击`Calculate`按钮并等待进程结束。现在您能看到什么？它会在UI上显示奇数和偶数的总数。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`CancellationTokenSource` represents a logical operation that can be canceled.
    The `Token` property of `CancellationTokenSource` provides the token object that
    provides the part of the logical operation.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource`表示一个可以取消的逻辑操作。`CancellationTokenSource`的`Token`属性提供了提供逻辑操作一部分的令牌对象。'
- en: Whenever the `Cancel()` method gets called on the `CancellationTokenSource`
    object, all distributed tokens from that source get their `IsCancellationRequested`
    property set as `true`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`CancellationTokenSource`对象上调用`Cancel()`方法时，该源的所有分布式令牌的`IsCancellationRequested`属性都会设置为`true`。
- en: In our example, the `for` loop inside our `CalculateOddEven` method polls the
    `IsCancellationRequested` property and fills the `totalOdd` and `totalEven` member
    variables with `-1`, which can be used to understand that a cancellation call
    was performed. Based on that value, the Operation canceled! message gets displayed
    on the screen.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`CalculateOddEven`方法内部的`for`循环轮询`IsCancellationRequested`属性，并将`totalOdd`和`totalEven`成员变量填充为`-1`，这可以用来理解已执行取消调用。基于该值，屏幕上会显示“操作已取消！”消息。
- en: Using the background worker component
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后台工作组件
- en: In the previous recipes, we used thread pool to perform long running operations
    in a different thread. From there, we had to update the UI by marshalling the
    code to the UI thread, which required additional work.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们使用了线程池在不同的线程中执行长时间运行的操作。从那里，我们必须通过将代码打包到UI线程来更新UI，这需要额外的工作。
- en: To overcome this explicit thread pooling and the marshalling of the UI updation
    on the UI thread, we can use the `System.ComponentModel.BackgroundWorker` class.
    It provides automatic management of long running operations on a background thread.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服显式线程池和UI更新在UI线程上的打包，我们可以使用`System.ComponentModel.BackgroundWorker`类。它提供在后台线程上自动管理长时间运行操作。
- en: In this recipe, we will use that `BackgroundWorker` to do the asynchronous operations
    without blocking the UI thread.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`BackgroundWorker`来执行异步操作，而不会阻塞UI线程。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: We will be using the same example that we have used in previous recipes. You
    can copy the entire `CH10.ThreadingDemo1` project folder and create a new one
    with the name `CH10.ThreadingDemo3`. Launch Visual Studio and open the new project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前菜谱中使用的相同示例。您可以复制整个`CH10.ThreadingDemo1`项目文件夹，并创建一个名为`CH10.ThreadingDemo3`的新文件夹。启动Visual
    Studio并打开新项目。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to use a background worker, to perform the long running
    process, and to count the odd and even numbers within a range:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用后台工作线程，执行长时间运行的过程，并计算范围内的奇数和偶数：
- en: From Solution Explorer, navigate to the `MainWindow.xaml.cs` file.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器，导航到`MainWindow.xaml.cs`文件。
- en: Add the following `using` namespace—`System.ComponentModel`, so that we can
    use the `BackgroundWorker` class.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`using`命名空间—`System.ComponentModel`，这样我们就可以使用`BackgroundWorker`类。
- en: Inside the `OnCalculateClicked` event, instead of calling `ThreadPool` to execute
    the operation, create an instance of the `BackgroundWorker` class.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCalculateClicked`事件内部，而不是调用`ThreadPool`来执行操作，创建`BackgroundWorker`类的实例。
- en: Register the worker events `DoWork` and `RunWorkerCompleted`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册工作线程事件`DoWork`和`RunWorkerCompleted`。
- en: 'Call the `RunWorkerAsync` method of the background worker by passing the numeric
    range as an argument. The argument accepts objects, hence, we will use `Tuple<int,
    int>` as the data type for simplicity. The complete code looks as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递数值范围作为参数调用后台工作线程的`RunWorkerAsync`方法。参数接受对象，因此我们将使用`Tuple<int, int>`作为数据类型以简化。完整的代码如下：
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s modify the `OnWorker_DoWork` event implementation to extract the argument
    first. Then, call the long running method (`CalculateOddEven`) by passing the
    values extracted from the argument:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`OnWorker_DoWork`事件实现，首先提取参数。然后，通过传递从参数中提取的值调用长时间运行的方法（`CalculateOddEven`）：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `OnWorker_WorkCompleted` event implementation, release the `BackgroundWorker`
    instance and then update the UI based on the values. Here''s the code for your
    reference:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnWorker_WorkCompleted`事件实现中，释放`BackgroundWorker`实例，然后根据值更新UI。以下是供您参考的代码：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once this is done, let''s run the application. You will see the same application
    UI as we saw in the first example:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这些操作，让我们运行应用程序。您将看到与我们在第一个示例中看到相同的应用程序UI：
- en: '![](img/6141192f-8e70-4c3a-8849-212faeb6e121.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6141192f-8e70-4c3a-8849-212faeb6e121.png)'
- en: Click on the `Calculate` button. You will observe that the application is responding
    while the execution is happening in the background worker process.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Calculate`按钮。您将观察到，在后台工作进程执行的同时，应用程序正在响应。
- en: Once the execution completes, it displays the result in the UI.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行完成，它将在UI中显示结果。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`BackgroundWorker` exposes events to coordinate the work. When you call the
    `RunWorkerAsync` method, the `DoWork` event is raised on the thread pool thread.
    You can pass an optional `Argument` to the `RunWorkerAsync` method, which can
    be retrieved from the `DoWorkEventArgs.Argument` property inside the `DoWork`
    event handler.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundWorker`公开事件以协调工作。当您调用`RunWorkerAsync`方法时，`DoWork`事件在线程池线程上触发。您可以将一个可选的`Argument`传递给`RunWorkerAsync`方法，该`Argument`可以在`DoWork`事件处理程序中的`DoWorkEventArgs.Argument`属性中检索。'
- en: As the `DoWork` event handler executes on a thread pool thread, accessing UI
    controls inside the `DoWork` handler will throw `Exception`. For this reason,
    pass the value from the UI as an argument to the `RunWorkerAsync` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`DoWork`事件处理程序在线程池线程上执行，因此在`DoWork`处理程序中访问UI控件将抛出`Exception`。因此，将UI的值作为参数传递给`RunWorkerAsync`方法。
- en: When the `DoWork` event handler completes its execution, `BackgroundWorker`
    raises the `RunWorkerCompleted` event. This runs on the UI thread, and thus, you
    can perform UI operations from this event handler. If you have passed any value
    from the `DoWork` handler, you can retrieve it here from the `RunWorkerCompletedEventArgs.Result`
    property.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `DoWork` 事件处理程序完成其执行时，`BackgroundWorker` 会引发 `RunWorkerCompleted` 事件。这个事件在
    UI 线程上运行，因此你可以从这个事件处理程序中执行 UI 操作。如果你从 `DoWork` 处理程序中传递了任何值，你可以从这里从 `RunWorkerCompletedEventArgs.Result`
    属性中检索它。
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To show the current progress indication of the long running background operation,
    you can raise the `ProgressChanged` event on the worker process and update the
    UI directly from here. The `ProgressChanged` handler runs in the UI thread and
    occurs when `BackgroundWorker.ReportProgress(System.Int32)` is called from the
    `DoWork` handler. For this to work, make sure that you have set the `WorkerReportsProgress`
    property of the worker to `true`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示长时间运行的后台操作的当前进度指示，你可以在工作进程中引发 `ProgressChanged` 事件，并直接从这里更新 UI。`ProgressChanged`
    处理程序在 UI 线程上运行，并且当从 `DoWork` 处理程序中调用 `BackgroundWorker.ReportProgress(System.Int32)`
    时发生。为了使其工作，请确保已将工作线程的 `WorkerReportsProgress` 属性设置为 `true`。
- en: You can also check whether `BackgroundWorker` is running an asynchronous operation.
    The `IsBusy` property will return `true` if it is running the background operation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查 `BackgroundWorker` 是否正在运行异步操作。如果它正在运行后台操作，`IsBusy` 属性将返回 `true`。
- en: In case you want to cancel a running background worker, you can call the `CancelAsync()`
    method of the worker to request cancellation of a pending background operation.
    If `BackgroundWorker.WorkerSupportsCancellation` is set as `false`, it will throw
    `InvalidOperationException`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想取消正在运行的后台工作线程，可以调用工作线程的 `CancelAsync()` 方法来请求取消挂起的后台操作。如果 `BackgroundWorker.WorkerSupportsCancellation`
    设置为 `false`，它将抛出 `InvalidOperationException`。
- en: Using a timer to periodically update the UI
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定时器定期更新 UI
- en: It is often require to update a portion of the user interface periodically.
    In that case, a timer object is beneficial to keep the UI refreshed. For example,
    in your application, you may want to show the current time at some part of the
    UI. For this, you can use a timer to periodically update the UI without the need
    to create a different thread.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要定期更新用户界面的一部分。在这种情况下，定时器对象有助于保持 UI 的刷新。例如，在你的应用程序中，你可能想在 UI 的某个部分显示当前时间。为此，你可以使用定时器定期更新
    UI，而无需创建不同的线程。
- en: The `System.Windows.Threading.DispatcherTimer` class can be used to integrate
    into the `Dispatcher` queue, and can process at a specified interval of time and
    at a specified priority.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `System.Windows.Threading.DispatcherTimer` 类将其集成到 `Dispatcher` 队列中，并可以在指定的时间间隔和优先级下进行处理。
- en: In this recipe, we will use the `DispatcherTimer` class to implement a timer,
    which will execute its subscribed `Tick` event each time the specified `Interval`
    is met.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `DispatcherTimer` 类来实现一个定时器，每次指定的 `Interval` 达到时，它将执行其订阅的 `Tick`
    事件。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Open Visual Studio and create a new WPF application project. Name it `CH10.DispatcherTimerDemo`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并创建一个新的 WPF 应用程序项目。将其命名为 `CH10.DispatcherTimerDemo`。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to create a digital clock experience with a timer:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用定时器创建数字时钟体验：
- en: From Solution Explorer, navigate to the `MainWindow.xaml` page.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器导航到 `MainWindow.xaml` 页面。
- en: 'Divide the default `Grid` into three rows, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 `Grid` 分为三行，如下所示：
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a `TextBlock` control at the `Grid.Row="0"` position and align it to the
    center:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Grid.Row="0"` 位置添加一个 `TextBlock` 控件并将其对齐到中心：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a `StackPanel` at `Grid.Row="2"` and insert two buttons inside it. Name
    the buttons `startButton` and `stopButton`. Also, register the `Click` events
    for both the buttons as `OnStartTimer` and `OnStopTimer`, respectively:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Grid.Row="2"` 位置添加一个 `StackPanel`，并在其中插入两个按钮。将按钮命名为 `startButton` 和 `stopButton`。同时，为两个按钮分别注册
    `Click` 事件为 `OnStartTimer` 和 `OnStopTimer`：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, navigate to `MainWindow.xaml.cs` to add the code behind the logic.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到 `MainWindow.xaml.cs` 以添加逻辑背后的代码。
- en: 'First, add the following namespaces in the class file:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在类文件中添加以下命名空间：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the class, declare a private member variable (`dispatcherTimer`) of
    type `DispatcherTimer`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部，声明一个私有的成员变量（`dispatcherTimer`）的类型为 `DispatcherTimer`：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside the constructor of the class, let''s create the instance of `DispatcherTimer`
    and raise its `Tick` event to trigger after every `1` second of interval. Here''s
    the code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的构造函数内部，让我们创建`DispatcherTimer`的实例，并在每`1`秒间隔后触发其`Tick`事件。以下是代码：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, inside the `Tick` event implementation, set the `Text` property of the
    `TextBlock` control (`clock`) to the current time in `hh:mm:ss` format:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Tick`事件实现内部，将`TextBlock`控件（`clock`）的`Text`属性设置为当前时间，格式为`hh:mm:ss`：
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When a user clicks on the Start button, the `OnStartTimer` event handler will
    fire. Inside it, let''s start the timer by calling the `Start()` method on the
    `dispatcherTimer` instance. Alternatively, you can also set the `dispatcherTimer.IsEnabled`
    property to `true` to start the timer:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击开始按钮时，`OnStartTimer`事件处理程序将被触发。在其内部，让我们通过在`dispatcherTimer`实例上调用`Start()`方法来启动计时器。或者，你也可以将`dispatcherTimer.IsEnabled`属性设置为`true`来启动计时器：
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When the handler `OnStopTimer` raises, on a click of the Stop button we will
    call the `Stop()` method of the `dispatcherTimer` instance. Here, also, you can
    set the `dispatcherTimer.IsEnabled` property as an alternate method to stop the
    timer, but in this case, you will have to set it as `false`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当处理程序`OnStopTimer`被触发时，在点击停止按钮时，我们将调用`dispatcherTimer`实例的`Stop()`方法。在这里，你也可以将`dispatcherTimer.IsEnabled`属性作为停止计时器的另一种方法，但在这个情况下，你必须将其设置为`false`：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now run the application. You will see the following output on the screen:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序。你将在屏幕上看到以下输出：
- en: '![](img/d7bd357d-0de7-4267-9242-6315d91c6609.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7bd357d-0de7-4267-9242-6315d91c6609.png)'
- en: 'Observe the text in the UI, where it is being displayed as `00:00:00`. Now
    click on the Start button. This will now change the text to the current time of
    your system, and it will refresh after every second:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察UI中的文本，它被显示为`00:00:00`。现在点击开始按钮。这将现在将文本更改为你的系统当前时间，并且每秒刷新一次：
- en: '![](img/b1363bc2-a4ec-4d61-a0d7-5af1c06c449b.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1363bc2-a4ec-4d61-a0d7-5af1c06c449b.png)'
- en: As the time is ticking on the UI, after every second of interval, click on the
    Stop button. This will cause the running timer on the screen to stop.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当时间在UI上流逝时，在每秒间隔之后，点击停止按钮。这将导致屏幕上运行的计时器停止。
- en: Clicking on the Start button again will start the timer and show the current
    time on the screen. The time displayed on the UI will refresh after every second.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击开始按钮将启动计时器并在屏幕上显示当前时间。UI上显示的时间将每秒刷新一次。
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you use a `DispatcherTimer` object, it represents a timer that is bound
    to the UI thread. The `Interval` property of the `DispatcherTimer` class indicates
    the period of the timer for the `Tick` event to raise, and continues ticking until
    explicitly stopped.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`DispatcherTimer`对象时，它代表一个绑定到UI线程的计时器。`DispatcherTimer`类的`Interval`属性表示计时器的周期，`Tick`事件将在该周期内触发，并持续计时，直到明确停止。
- en: To start the timer, you can call its `Start()` method, or set the `IsEnabled`
    property to `true`. Similarly, to stop a timer, you can call the `Stop()` method,
    or set the `IsEnabled` property to `false`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动计时器，你可以调用其`Start()`方法，或者将`IsEnabled`属性设置为`true`。同样，要停止一个计时器，你可以调用`Stop()`方法，或者将`IsEnabled`属性设置为`false`。
- en: Never perform any lengthy operations in the `Tick` event, as it runs on the
    UI thread. Long running operations may block the UI from responding.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在`Tick`事件中执行任何长时间的操作，因为它在UI线程上运行。长时间运行的操作可能会阻止UI响应用户操作。
