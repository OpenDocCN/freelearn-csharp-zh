- en: '*Chapter 6*: Integrating Audio and Video in a Unity Project'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：在Unity项目中集成音频和视频'
- en: In the previous chapters, we have discussed how to use C# scripts to develop
    game logic in Unity, how to efficiently implement UI, how to implement animation,
    and how to integrate physics simulation into your game. However, one feature that
    is often overlooked in game development is sound. The proper use of sound effects
    can enhance the immersion of a game, and the background music that matches the
    background of the game can trigger the emotional resonance of the players. Sometimes,
    playing video in a game is also a way to increase the fun of a game. There is
    no doubt that adding video and audio to your game can make your game more lively
    and interesting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经讨论了如何使用C#脚本在Unity中开发游戏逻辑，如何高效实现UI，如何实现动画，以及如何将物理模拟集成到您的游戏中。然而，在游戏开发中，声音这一特性常常被忽视。正确使用音效可以增强游戏的沉浸感，与游戏背景相匹配的背景音乐可以触发玩家的情感共鸣。有时，在游戏中播放视频也是增加游戏乐趣的一种方式。毫无疑问，将视频和音频添加到您的游戏中可以使您的游戏更加生动有趣。
- en: 'In this chapter, we will introduce the following key topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下关键主题：
- en: Concepts in Unity's audio system and video system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity音频系统和视频系统中的概念
- en: Scripting with audio and video
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用音频和视频进行脚本编写
- en: Things to note when using Unity to develop web applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity开发Web应用程序时需要注意的事项
- en: Increasing the performance of the audio system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高音频系统的性能
- en: By the end of this chapter, you will be able to implement audio and video correctly
    and efficiently in Unity to add more realism and fun to your game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够正确且高效地在Unity中实现音频和视频，为您的游戏增添更多真实感和乐趣。
- en: Now, let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find complete code examples on GitHub in the following repository:
    [https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub仓库中找到完整的代码示例：[https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers)。
- en: Concepts in Unity's audio system and video system
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity音频系统和视频系统中的概念
- en: Unity provides video and audio features, allowing your game to play videos on
    different platforms, and supports real-time mixing and full 3D spatial sound effects.
    In this section, we will introduce important concepts of the Unity audio system
    and video system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了视频和音频功能，允许您的游戏在不同的平台上播放视频，并支持实时混合和全3D空间音效。在本节中，我们将介绍Unity音频系统和视频系统的重要概念。
- en: Audio clips
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频剪辑
- en: 'In order to be able to play audio in Unity, we need to import an audio file
    into the Unity editor first. The audio data will be saved in an **audio clip**
    object in Unity. We can download and import the **Ultra Sci-Fi Game Audio Weapons
    Pack Vol. 1** from **Unity Asset Store** at the following link: [https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047](https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047).
    You can see this in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在Unity中播放音频，我们首先需要将音频文件导入Unity编辑器。音频数据将被保存在Unity中的一个**音频剪辑**对象中。您可以从以下链接下载并导入**超科幻游戏音频武器包Vol.
    1**：[https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047](https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047)。您可以在以下屏幕截图中看到这一点：
- en: '![Figure 6.1 – Ultra Sci-Fi Game Audio Weapons Pack Vol. 1'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 超科幻游戏音频武器包Vol. 1'
- en: '](img/Figure_6.01_B17146.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B17146.jpg)'
- en: Figure 6.1 – Ultra Sci-Fi Game Audio Weapons Pack Vol. 1
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 超科幻游戏音频武器包Vol. 1
- en: 'The format of the audio files contained in this pack is `.wav`. In addition
    to `.wav` files that can be imported into Unity, Unity also supports importing
    files in the following formats:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本包中包含的音频文件格式为`.wav`。除了可以导入Unity的`.wav`文件外，Unity还支持导入以下格式的文件：
- en: '`.aif`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.aif`'
- en: '`.mp3`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.mp3`'
- en: '`.ogg`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.ogg`'
- en: '`.xm`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.xm`'
- en: '`.mod`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.mod`'
- en: '`.it`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.it`'
- en: '`.s3m`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.s3m`'
- en: 'After importing these audio files, we can choose one of them to open the **Import**
    settings as shown in *Figure 6.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入这些音频文件后，我们可以选择其中一个打开**导入**设置，如图*图6.2*所示：
- en: '![Figure 6.2 – Import settings of audio'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 音频导入设置'
- en: '](img/Figure_6.02_B17146.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B17146.jpg)'
- en: Figure 6.2 – Import settings of audio
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 音频导入设置
- en: As you can see in the **Import** settings, Unity supports mono and multichannel
    audio assets, up to eight channels. Unity also provides a lot of import options.
    Let's introduce some important options.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在**导入**设置中看到的，Unity支持单声道和多声道音频资源，最多可达八个声道。Unity还提供了许多导入选项。让我们介绍一些重要的选项。
- en: Load Type
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载类型
- en: Unity provides game developers with three different ways to load audio assets
    at runtime. We can determine how Unity loads this audio file by modifying the
    **Load Type** property in the **Import** settings window.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为游戏开发者提供了三种不同的方式在运行时加载音频资源。我们可以通过修改**导入**设置窗口中的**加载类型**属性来决定Unity如何加载这个音频文件。
- en: '![Figure 6.3 – Load Type'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 加载类型]'
- en: '](img/Figure_6.03_B17146.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.03_B17146.jpg]'
- en: Figure 6.3 – Load Type
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 加载类型
- en: 'The three methods are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 三种方法如下：
- en: '**Decompress On Load**: This is the default value for **Load Type**. If the
    audio file is small, such as UI sounds or footstep sounds, we should choose this
    option. This is because, in this way, the audio file will be decompressed and
    decoded into the memory at its original size. The advantage is that it will be
    ready for on-demand playing with minimal CPU usage.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载时解压缩**：这是**加载类型**的默认值。如果音频文件较小，例如UI声音或脚步声，我们应该选择此选项。这是因为，在这种情况下，音频文件将以原始大小解压缩并解码到内存中。优点是它将以最小的CPU使用率准备好按需播放。'
- en: '**Compressed In Memory**: As a contrast with **Decompress On Load**, by choosing
    this method, Unity will store the compressed audio data in memory and require
    the CPU to decompress and decode it when playing the audio.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存中压缩**：与**加载时解压缩**形成对比，通过选择此方法，Unity将压缩的音频数据存储在内存中，并在播放音频时需要CPU进行解压缩和解码。'
- en: '**Streaming**: This is completely different from the previous two. If we choose
    this method, Unity will not load the audio data into the memory, but instead will
    stream it from disk. This method uses the least memory, but at the cost of the
    highest CPU usage and disk usage.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流式传输**：这与前两种方法完全不同。如果我们选择这种方法，Unity不会将音频数据加载到内存中，而是从磁盘流式传输。这种方法使用的内存最少，但代价是CPU和磁盘使用率最高。'
- en: Compression Format
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩格式
- en: 'In addition to the **Load Type** property just introduced, the **Compression
    Format** property is also very important for audio assets. Unity supports a variety
    of audio compression formats, and there are different formats available according
    to the different target platforms. For example, if the target platform is **Windows**,
    the following formats are available:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了刚刚介绍的**加载类型**属性外，**压缩格式**属性对于音频资源也非常重要。Unity支持多种音频压缩格式，根据不同的目标平台有不同的格式可供选择。例如，如果目标平台是**Windows**，以下格式可用：
- en: '![Figure 6.4 – Compression Format on Windows'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – Windows上的压缩格式]'
- en: '](img/Figure_6.04_B17146.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.04_B17146.jpg]'
- en: Figure 6.4 – Compression Format on Windows
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – Windows上的压缩格式
- en: On the other hand, if the target platform is **Android**, in addition to the
    previous formats, it also supports the MP3 format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果目标平台是**Android**，除了之前的格式外，它还支持MP3格式。
- en: '![Figure 6.5 – Compression Format on Android'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – Android上的压缩格式]'
- en: '](img/Figure_6.05_B17146.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.05_B17146.jpg]'
- en: Figure 6.5 – Compression Format on Android
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – Android上的压缩格式
- en: 'We will explore the different compression formats here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里探讨不同的压缩格式：
- en: '**PCM**: **Pulse-code modulation** (**PCM**) is a lossless, uncompressed format
    and is the standard form of digital audio in computers. It offers high quality
    and has a very large file size. As you can see in *Figure 6.6*, when the **PCM**
    format is selected, the imported size of this audio file is equal to its original
    size.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PCM**：**脉冲编码调制**（**PCM**）是一种无损、未压缩的格式，是计算机中数字音频的标准形式。它提供高质量，但文件大小非常大。如*图6.6*所示，当选择**PCM**格式时，此音频文件的导入大小等于其原始大小。'
- en: '![Figure 6.6 – The PCM format'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 – PCM格式]'
- en: '](img/Figure_6.06_B17146.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.06_B17146.jpg]'
- en: Figure 6.6 – The PCM format
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – PCM格式
- en: '**Vorbis**: This is the default value for **Compression Format**. **Vorbis**
    is a very effective audio compression format. Compared with **PCM** audio, this
    compression produces smaller files, but the quality is lower. If we choose the
    **Vorbis** option, the imported size of this audio file will be much smaller than
    its original size. There is a **Quality** slider that allows us to adjust the
    compression quality.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vorbis**: 这是**压缩格式**的默认值。**Vorbis**是一种非常有效的音频压缩格式。与**PCM**音频相比，这种压缩产生的文件更小，但质量较低。如果我们选择**Vorbis**选项，导入的音频文件大小将远小于其原始大小。有一个**质量**滑块，允许我们调整压缩质量。'
- en: '![Figure 6.7 – The Vorbis format'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 – Vorbis格式'
- en: '](img/Figure_6.07_B17146.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.07_B17146.jpg)'
- en: Figure 6.7 – The Vorbis format
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – Vorbis格式
- en: '**ADPCM**: **ADPCM** is short for **adaptive differential pulse-code modulation**.
    Although the name is similar to PCM, it is a lossy compression format. But unlike
    Vorbis, its compression ratio cannot be adjusted in Unity. The compressed file
    size will always be 3.5 times smaller than PCM.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADPCM**：**ADPCM**代表**自适应差分脉冲编码调制**。虽然名称与PCM相似，但它是一种有损压缩格式。但与Vorbis不同，在Unity中无法调整其压缩比。压缩文件大小将始终比PCM小3.5倍。'
- en: '![Figure 6.8 – The ADPCM format'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 – ADPCM格式'
- en: '](img/Figure_6.08_B17146.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.08_B17146.jpg)'
- en: Figure 6.8 – The ADPCM format
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – ADPCM格式
- en: '**MP3**: This is available on mobile platforms, such as Android. The MP3 format
    is similar to Vorbis, which is a very effective audio compression format. There
    is also a **Quality** slider that allows us to adjust the compression quality.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MP3**：这在移动平台上可用，例如Android。MP3格式与Vorbis类似，是一种非常有效的音频压缩格式。还有一个**质量**滑块，允许我们调整压缩质量。'
- en: '![Figure 6.9 – The MP3 format'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 – MP3格式'
- en: '](img/Figure_6.09_B17146.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.09_B17146.jpg)'
- en: Figure 6.9 – The MP3 format
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – MP3格式
- en: After we set the import settings for these audio files, they can be imported
    into the Unity editor as audio clips.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置这些音频文件的导入设置后，它们可以作为音频剪辑导入到Unity编辑器中。
- en: '![Figure 6.10 – Audio clips'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10 – 音频剪辑'
- en: '](img/Figure_6.10_B17146.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.10_B17146.jpg)'
- en: Figure 6.10 – Audio clips
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 音频剪辑
- en: As shown in *Figure 6.10*, we can find these audio clips in the **Project**
    window, and the icon of the audio clip will show its waveform.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6.10*所示，我们可以在**项目**窗口中找到这些音频剪辑，音频剪辑的图标将显示其波形。
- en: Audio Sources
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频源
- en: In order to play the audio clip we just created in the game scene, we also need
    to set an **Audio Source**. Then this audio clip can be dragged to the Audio Source
    or used from a C# script.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在游戏场景中播放我们刚刚创建的音频剪辑，我们还需要设置一个**音频源**。然后这个音频剪辑可以被拖到音频源或从C#脚本中使用。
- en: 'Let''s follow these steps to create an Audio Source first:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤首先创建一个音频源：
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键单击以打开菜单。
- en: Choose **Create Empty** to create a new GameObject in the scene. As a reminder,
    the GameObject that is the Audio Source is not necessarily a static object. In
    many cases, the Audio Source needs to be moved, such as simulating the effect
    of firing a cannonball in a game. But for the sake of simplicity, we will not
    add movement logic to this GameObject here.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建空对象**以在场景中创建一个新的GameObject。提醒一下，作为音频源的GameObject不一定是静态对象。在许多情况下，音频源需要移动，例如模拟游戏中发射炮弹的效果。但为了简单起见，我们不会在此为该GameObject添加移动逻辑。
- en: '![Figure 6.11 – Create an Audio Source object'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11 – 创建音频源对象'
- en: '](img/Figure_6.11_B17146.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.11_B17146.jpg)'
- en: Figure 6.11 – Create an Audio Source object
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 创建音频源对象
- en: Select this newly created GameObject and click the **Add Component** button
    to open the components list.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新创建的GameObject，并单击**添加组件**按钮以打开组件列表。
- en: Choose **Audio** | **Audio Source** to add an **Audio Source** component to
    this GameObject.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**音频** | **音频源**以向此GameObject添加**音频源**组件。
- en: '![Figure 6.12 – Add an Audio Source component'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 – 添加音频源组件'
- en: '](img/Figure_6.12_B17146.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.12_B17146.jpg)'
- en: Figure 6.12 – Add an Audio Source component
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 添加音频源组件
- en: Now we have created a new **Audio Source** component in our game scene. The
    properties of this **Audio Source** component are shown in *Figure 6.13*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在游戏场景中创建了一个新的**音频源**组件。这个**音频源**组件的属性如*图6.13*所示。
- en: '![Figure 6.13 – Properties of Audio Source'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13 – 音频源的属性'
- en: '](img/Figure_6.13_B17146.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.13_B17146.jpg)'
- en: Figure 6.13 – Properties of Audio Source
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – 音频源的属性
- en: 'We will explore some of them here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里探讨其中的一些：
- en: '**AudioClip**: Here, we find the first property of **Audio Source** is a reference
    to **Audio Clip**. We can drag an **Audio Clip** asset to this field directly
    in the editor.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AudioClip**: 在这里，我们发现**音频源**的第一个属性是对**音频剪辑**的引用。我们可以在编辑器中直接将**音频剪辑**资产拖拽到这个字段。'
- en: '**Output**: We don''t have to set this property, because the output of this
    Audio Source will then be picked up by an Audio Listener in the scene by default.
    Set this property only when you want to output the sound to an Audio Mixer Group.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Output**: 我们不需要设置这个属性，因为默认情况下，这个音频源的输出会被场景中的音频监听器拾取。只有当你想要将声音输出到音频混音器组时，才需要设置这个属性。'
- en: '`Play` method in a C# script.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#脚本中的`Play`方法。
- en: In addition to the Audio Source, to emit the sound in the scene, an Audio Listener
    is also needed to receive the sound from the source. Next, we will discuss **Audio
    Listener**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了音频源之外，为了在场景中发出声音，还需要一个音频监听器来接收来自源的声音。接下来，我们将讨论**音频监听器**。
- en: Audio Listener
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频监听器
- en: Generally speaking, you don't need to worry about the absence of **Audio Listener**
    in the scene, because an Audio Listener will be attached to the main camera in
    the scene by default when a scene is created, as shown here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，你不需要担心场景中缺少**音频监听器**，因为当创建场景时，默认情况下，音频监听器会附加到场景中的主相机上，如图所示。
- en: '![Figure 6.14 – An Audio Listener'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14 – 音频监听器'
- en: '](img/Figure_6.14_B17146.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.14_B17146.jpg)'
- en: Figure 6.14 – An Audio Listener
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 音频监听器
- en: In real life, sounds are heard by listeners, and **Audio Listener** is the representation
    of a listener in Unity. If you set **Audio Source** correctly in the game scene
    and the audio clip is available but you can't hear the sound when you run the
    game, then you can first check whether there is an Audio Listener in the scene.
    Usually, the listener is attached to the camera.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，声音是由听者听到的，**音频监听器**是Unity中听者的表示。如果你在游戏场景中正确设置了**音频源**，音频剪辑可用，但在运行游戏时你听不到声音，那么你可以首先检查场景中是否有音频监听器。通常，监听器是附加到相机上的。
- en: To hear the sound, we need to make sure that an Audio Listener is available,
    but at the same time, it should be noted that there cannot be more than one Audio
    Listener in the scene, otherwise you will see the following warning message in
    the **Console** window. So, please ensure there is always exactly one Audio Listener
    in the scene.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要听到声音，我们需要确保有一个音频监听器可用，但同时也应注意的是，场景中不能有超过一个音频监听器，否则你将在**控制台**窗口中看到以下警告信息。所以，请确保场景中始终只有一个音频监听器。
- en: '![Figure 6.15 – Please ensure there is always exactly one audio listener in
    the scene'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15 – 请确保场景中始终只有一个音频监听器'
- en: '](img/Figure_6.15_B17146.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.15_B17146.jpg)'
- en: Figure 6.15 – Please ensure there is always exactly one audio listener in the
    scene
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 请确保场景中始终只有一个音频监听器
- en: After introducing a few important concepts about audio in Unity, let's discuss
    the concepts related to video in Unity next.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了Unity中关于音频的一些重要概念之后，接下来让我们讨论与Unity中视频相关的概念。
- en: Video clips
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频剪辑
- en: 'Similar to audio clips, we also need to import external video files into the
    Unity editor to generate video clips. Unity supports typical file extensions for
    video files, such as the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与音频剪辑类似，我们还需要将外部视频文件导入到Unity编辑器中，以生成视频剪辑。Unity支持视频文件的典型文件扩展名，例如以下这些：
- en: '`.mp4`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.mp4`'
- en: '`.mov`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.mov`'
- en: '`.webm`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.webm`'
- en: '`.wmv`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.wmv`'
- en: 'After importing a video file, we can choose to open **Import settings**, as
    shown in *Figure 6.16*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 导入视频文件后，我们可以选择打开**导入设置**，如图6.16所示：
- en: '![Figure 6.16 – Import settings of a video clip'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16 – 视频剪辑的导入设置'
- en: '](img/Figure_6.16_B17146.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.16_B17146.jpg)'
- en: Figure 6.16 – Import settings of a video clip
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 视频剪辑的导入设置
- en: By default, the **Transcode** option is disabled, which means that Unity will
    use the default settings to import this video file. If we enable this option,
    Unity will allow us to modify these settings, as shown in *Figure 6.17*, and we
    will introduce a few of them. At the bottom of the **Import settings** window,
    we can also directly preview the video by clicking the play button.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**转码**选项是禁用的，这意味着Unity将使用默认设置导入这个视频文件。如果我们启用这个选项，Unity将允许我们修改这些设置，如图6.17所示，我们将会介绍其中的一些。在**导入设置**窗口的底部，我们还可以通过点击播放按钮直接预览视频。
- en: Now, let's check and enable the **Transcode** option and explore some of these
    import settings.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查并启用**转码**选项，并探索一些这些导入设置。
- en: '![Figure 6.17 – Video import settings'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17 – 视频导入设置'
- en: '](img/Figure_6.17_B17146.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.17_B17146.jpg)'
- en: Figure 6.17 – Video import settings
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 视频导入设置
- en: '**Dimensions**: By default, Unity will not resize the original video, but if
    you want to resize the video file in Unity, you can change the **Dimensions**
    option. You will find a list of presets, such as **Half Res**, and you can also
    customize new sizes.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸**：默认情况下，Unity 不会调整原始视频的大小，但如果你想在 Unity 中调整视频文件的大小，你可以更改**尺寸**选项。你将找到一个预设列表，例如**半分辨率**，你也可以自定义新的大小。'
- en: '![Figure 6.18 – Dimensions option'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.18 – 尺寸选项'
- en: '](img/Figure_6.18_B17146.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.18_B17146.jpg)'
- en: Figure 6.18 – Dimensions option
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 尺寸选项
- en: '**Codec**: Unity provides the option to transcode video clip assets into one
    of the following video codecs: **H264**, **H265**, and **VP8**, as shown in the
    following figure. **Auto** is the default value for **Codec**. Of course, you
    can also choose the video codec by yourself. **H264** is the best natively supported
    hardware-accelerated video codec.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编解码器**：Unity 提供了将视频剪辑资产转码为以下视频编解码器之一的选项：**H264**、**H265**和**VP8**，如以下图所示。**自动**是**编解码器**的默认值。当然，你也可以自己选择视频编解码器。**H264**是最佳的本机支持的硬件加速视频编解码器。'
- en: '![Figure 6.19 – Codec option'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19 – 编解码器选项'
- en: '](img/Figure_6.19_B17146.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.19_B17146.jpg)'
- en: Figure 6.19 – Codec option
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 编解码器选项
- en: '**Keep Alpha**: As you can see in *Figure 6.19*, **Keep Alpha** is not an option
    in this case. This is because this option can only be checked when the video file
    contains an alpha channel. If your video file contains an alpha channel and you
    want to keep the alpha channel when the video is played in the game, then check
    this option.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持透明度**：如你在*图 6.19*中看到的，在这种情况下**保持透明度**不是一个选项。这是因为此选项只能在视频文件包含透明通道时勾选。如果你的视频文件包含透明通道，并且你希望在游戏中播放视频时保持透明通道，则勾选此选项。'
- en: '**Flip Horizontally**: As the name suggests, if this option is enabled, Unity
    will flip the video horizontally, switching the left side to the right side.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平翻转**：正如其名所示，如果此选项被启用，Unity 将水平翻转视频，将左侧切换到右侧。'
- en: '**Flip Vertically**: Similar to **Flip Horizontally**, if this option is enabled,
    Unity will flip the video vertically to make it upside down.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直翻转**：与**水平翻转**类似，如果此选项被启用，Unity 将垂直翻转视频，使其上下颠倒。'
- en: '**Import Audio**: If your original video file contains audio tracks, then you
    can decide whether to import the audio tracks of the video by checking this option.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入音频**：如果你的原始视频文件包含音频轨道，那么你可以通过勾选此选项来决定是否导入视频的音频轨道。'
- en: After setting the import settings, we can click **Apply** to transcode the video.
    It may take some time to complete the transcoding process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 设置导入设置后，我们可以点击**应用**来转码视频。转码过程可能需要一些时间。
- en: '![Figure 6.20 – Transcoding the video'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.20 – 转码视频'
- en: '](img/Figure_6.20_B17146.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.20_B17146.jpg)'
- en: Figure 6.20 – Transcoding the video
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 转码视频
- en: Now we have imported the video file into the Unity editor, next we need to set
    up a video player to play the video clip.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将视频文件导入到 Unity 编辑器中，接下来我们需要设置一个视频播放器来播放视频剪辑。
- en: Video Player
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频播放器
- en: 'Let''s create a Video Player by following these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个视频播放器：
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中右键单击以打开菜单。
- en: Choose `VideoPlayer`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `VideoPlayer`。
- en: Select this newly created GameObject and click the **Add Component** button
    to open the components list.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新创建的 GameObject，并点击**添加组件**按钮以打开组件列表。
- en: Choose **Video** | **Video Player** to add a **VideoPlayer** component to this
    GameObject.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**视频** | **视频播放器**以向此 GameObject 添加**视频播放器**组件。
- en: '![Figure 6.21 – Add a Video Player component'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.21 – 添加视频播放器组件'
- en: '](img/Figure_6.21_B17146.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.21_B17146.jpg)'
- en: Figure 6.21 – Add a Video Player component
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 添加视频播放器组件
- en: 'Now we have created a new **Video Player** in our game scene. The properties
    of this **Video Player** are shown in *Figure 6.22*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在游戏场景中创建了一个新的**视频播放器**。此**视频播放器**的属性如*图 6.22*所示：
- en: '![Figure 6.22 – Properties of Video Player component'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.22 – 视频播放器组件属性'
- en: '](img/Figure_6.22_B17146.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.22_B17146.jpg)'
- en: Figure 6.22 – Properties of Video Player component
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – 视频播放器组件属性
- en: 'Next, we will explore some of these properties:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索一些这些属性：
- en: '**Source**: In Unity, a **Video Player** can play videos from video clip assets
    or from a URL. By default, the **Video Player** needs a video clip asset as the
    video source, but we can also choose a URL as the source for video here.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**：在 Unity 中，**视频播放器**可以从视频剪辑资产或从 URL 播放视频。默认情况下，**视频播放器**需要一个视频剪辑资产作为视频源，但在这里我们也可以选择将
    URL 作为视频源。'
- en: '![Figure 6.23 – Choose the type of video source'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.23_B17146.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – Choose the type of video source
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '`Play` method in a C# script to trigger the video playback at another point
    during the runtime.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playback Speed**: We can increase or decrease the playback speed by adjusting
    this slider. The default value is 1.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render Mode
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a very important setting, so we will explain it in detail. If you just
    set up the Video Player, drag a video clip asset to the **Source** property, and
    play the game, you will find that nothing will happen. This is because the default
    value for **Render Mode** in a Video Player is **Render Texture**, which means
    you should create and assign a render texture to the **Target Texture** property
    of the Video Player first. Then the Video Player will output the video to this
    render texture, as you can see in *Figure 6.24*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Set the Target Texture property'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.24_B17146.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.24 – Set the Target Texture property
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: However, at this stage, we only render the video to the render texture, and
    the video is not played in the game scene. In order to play this video in the
    game scene, we can create a new **Raw Image** UI element in the scene and assign
    this render texture to the **Raw Image** UI element.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – The Raw Image UI element'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.25_B17146.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.25 – The Raw Image UI element
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's play the game again and the video plays as expected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – Play the video'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.26_B17146.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.26 – Play the video
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change **Render Mode**. As you can see in *Figure 6.27*, the other
    options include the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Camera Far Plane**, which renders video content behind the camera''s scene,
    allows developers to change the value of the alpha channel to make video content
    transparent, and can be used as a background video player.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera Near Plane**, which renders video content in front of the camera''s
    scene, allows developers to change the value of the alpha channel to make video
    content transparent, and can be used as a foreground video player.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material Override**: In Unity, a material is used to describe the appearance
    of the surface of a model. If this mode is selected, the video content will be
    passed into a user-specified property of the target material instead of being
    drawn on the screen or in a render texture. This mode is often used when making
    360-degree panoramic videos in Unity.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Only**, which does not render the video content, but allows developers
    to access the video content via an API.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.27 – Render Mode List'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.27_B17146.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.27 – Render Mode List
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will choose **Camera Far Plane** for **Render Mode**. Instead
    of a render texture, we need to provide a camera here and, as you can see in the
    following figure, it allows us to modify the **Alpha** value as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Camera Far Plane'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.28_B17146.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.28 – Camera Far Plane
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: If we play the game, the video plays again this time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们玩游戏，这次视频会再次播放。
- en: '![Figure 6.29 – Play the video'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.29 – 播放视频]'
- en: '](img/Figure_6.29_B17146.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.29_B17146.jpg]'
- en: Figure 6.29 – Play the video
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.29 – 播放视频]'
- en: In this section, we learned about some concepts of Unity's audio and video systems.
    Now, let's explore how to write C# code in Unity to control audio and video.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 Unity 音频和视频系统的一些概念。现在，让我们探索如何在 Unity 中编写 C# 代码来控制音频和视频。
- en: Scripting with audio and video
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频和视频脚本化
- en: In this section, we will explore how to interact with the audio and video systems
    via C# scripts. Similar to the previous section, we will also introduce the C#
    methods for **Audio Source** and **Video Player** respectively. We first start
    with the C# methods for **Audio Source**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何通过 C# 脚本与音频和视频系统进行交互。与上一节类似，我们也将分别介绍 **Audio Source** 和 **Video
    Player** 的 C# 方法。我们首先从 **Audio Source** 的 C# 方法开始。
- en: AudioSource.Play
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AudioSource.Play
- en: 'The first function we will introduce is the `Play` function of `AudioSource`.
    The function signature of `Play` is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的第一个函数是 `AudioSource` 的 `Play` 函数。`Play` 函数的签名如下：
- en: '[PRE0]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is very simple and straightforward to call this function to play an audio
    clip. However, if you need to deal with more complex scenarios, such as delaying
    the playback of an audio clip, you can call the `PlayDelayed` function, which
    will play the clip with a delay specified in seconds.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数播放音频剪辑非常简单直接。然而，如果您需要处理更复杂的场景，例如延迟播放音频剪辑，您可以调用 `PlayDelayed` 函数，该函数将以指定的秒数延迟播放剪辑。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There was an overloaded version of the `Play` function, which requires a `delay`
    parameter. However, it's deprecated now. Developers are advised to use the `PlayDelayed`
    function instead of the old `Play` (`delay`) function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Play` 函数有一个重载版本，它需要一个 `delay` 参数。然而，现在它已被弃用。建议开发者使用 `PlayDelayed` 函数而不是旧的
    `Play` (`delay`) 函数。'
- en: 'The following is the function signature of `PlayDelayed`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `PlayDelayed` 函数的函数签名：
- en: '[PRE1]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It requires a parameter, `delay`, which is specified in samples relative to
    the 44.1 kHz reference rate.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要一个参数，`delay`，该参数以相对于 44.1 kHz 参考速率的样本数指定。
- en: 'Now let''s create a new C# script to first obtain a reference to the Audio
    Source in the scene and play the audio clip assigned to it by calling the `Play`
    function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的 C# 脚本，首先获取场景中音频源的引用，并通过调用 `Play` 函数播放分配给它的音频剪辑：
- en: '[PRE2]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then we drag this newly created script onto the Audio Source GameObject in the
    scene to attach this script to the GameObject as a new component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这个新创建的脚本拖放到场景中的 Audio Source GameObject 上，将其附加到 GameObject 作为新的组件。
- en: '![Figure 6.30 – Attaching the script to the GameObject'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.30 – 将脚本附加到 GameObject]'
- en: '](img/Figure_6.30_B17146.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.30_B17146.jpg]'
- en: Figure 6.30 – Attaching the script to the GameObject
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.30 – 将脚本附加到 GameObject]'
- en: Here, we can manually drag the `GetComponent<AudioSource>()` function to get
    the **AudioSource** component in the code as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以手动拖动 `GetComponent<AudioSource>()` 函数来在代码中获取 **AudioSource** 组件。
- en: Next, we will create a UI button in the scene and bind the button with the `OnClickPlayAudioButton`
    function so that when the button is clicked, the **Audio Source** will play the
    audio clip.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在场景中创建一个 UI 按钮，并将按钮绑定到 `OnClickPlayAudioButton` 函数，以便当按钮被点击时，**Audio
    Source** 将播放音频剪辑。
- en: '![Figure 6.31 – Create a button'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.31 – 创建一个按钮]'
- en: '](img/Figure_6.31_B17146.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.31_B17146.jpg]'
- en: Figure 6.31 – Create a button
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.31 – 创建一个按钮]'
- en: Now we can run the game and click the button to play the sound effect in the
    scene. This function is very useful when implementing audio effects; for example,
    when the player fires a gun, the sound of the bullet can be played, and so on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行游戏并点击按钮来播放场景中的音效。此功能在实现音频效果时非常有用；例如，当玩家开枪时，可以播放子弹的声音，等等。
- en: AudioSource.Pause
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AudioSource.Pause
- en: An Audio Source can be used to play background music. In some cases, we would
    like the background music to be paused, such as when the player enters a different
    scene or triggers a new plot. At this point, we can consider using the `Pause`
    function to pause playing the background music clip.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 音频源可以用来播放背景音乐。在某些情况下，我们可能希望背景音乐暂停，例如当玩家进入不同的场景或触发新的剧情时。在这种情况下，我们可以考虑使用 `Pause`
    函数来暂停播放背景音乐剪辑。
- en: 'The function signature of `Pause` is very simple, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pause` 函数的函数签名非常简单，如下所示：'
- en: '[PRE3]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can create another function for the `AudioPlayer` class we created earlier:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为之前创建的 `AudioPlayer` 类创建另一个函数：
- en: '[PRE4]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since the assets pack we downloaded earlier only contains sound effects with
    a short duration, in order to demonstrate the function of pausing background music,
    we can download and import **Free Music Tracks For Games** from the Unity Asset
    Store at the following link: [https://assetstore.unity.com/packages/audio/music/free-music-tracks-for-games-156413](https://assetstore.unity.com/packages/audio/music/free-music-tracks-for-games-156413).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前下载的资产包只包含短时长的声音效果，为了演示暂停背景音乐的功能，我们可以从Unity Asset Store下载并导入**Free Music
    Tracks For Games**，链接如下：[https://assetstore.unity.com/packages/audio/music/free-music-tracks-for-games-156413](https://assetstore.unity.com/packages/audio/music/free-music-tracks-for-games-156413)。
- en: '![Figure 6.32 – Free Music Tracks For Games'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.32 – 游戏免费音乐轨道'
- en: '](img/Figure_6.32_B17146.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.32_B17146.jpg)'
- en: Figure 6.32 – Free Music Tracks For Games
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 6.32 – 游戏免费音乐轨道
- en: Then replace the sound effect clip referenced by `AudioSource` with a new background
    music clip. Next, we will create another UI button and bind the button with the
    newly created `OnClickPauseAudioButton` function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后替换由`AudioSource`引用的声音效果剪辑为新背景音乐剪辑。接下来，我们将创建另一个UI按钮并将按钮绑定到新创建的`OnClickPauseAudioButton`函数。
- en: Now, we can run the game. If you click the first button, the background music
    will play; if you click the second button, we can pause the music.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行游戏。如果你点击第一个按钮，背景音乐将播放；如果你点击第二个按钮，我们可以暂停音乐。
- en: '`AudioSource` also provides an `UnPause` function to unpause the paused playback
    and an `isPlaying` property to check whether the current audio clip is playing.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioSource`还提供了一个`UnPause`函数来取消暂停已暂停的播放，以及一个`isPlaying`属性来检查当前音频剪辑是否正在播放。'
- en: 'The following is the function signature of `UnPause`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`UnPause`函数的签名：
- en: '[PRE5]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use them to implement a more flexible function of pausing and continuing
    music playback as in the following code snippet:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它们来实现更灵活的暂停和继续音乐播放功能，如下代码片段所示：
- en: '[PRE6]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this way, we can click the second button to pause the music playback, and
    click again to continue playing the music.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以点击第二个按钮来暂停音乐播放，再次点击以继续播放音乐。
- en: AudioSource.Stop
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AudioSource.Stop
- en: In some cases, you may want the background music of the game to stop and then
    start from the beginning, instead of pausing and continuing to play. The `Stop`
    function of `AudioSource` is a suitable solution here.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望游戏中的背景音乐停止并从头开始播放，而不是暂停并继续播放。`AudioSource`的`Stop`函数在这里是一个合适的解决方案。
- en: 'The function signature of `Stop` is also very simple, as shown in the following
    code snippet:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop`函数的签名也非常简单，如下代码片段所示：'
- en: '[PRE7]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s create another function in the C# script to stop the background music
    and start playing from the beginning:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在C#脚本中创建另一个函数来停止背景音乐并从头开始播放：
- en: '[PRE8]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And we will also create a third UI button and bind the button with the `OnClickStopAndPlayAudioButton`
    function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建第三个UI按钮并将按钮绑定到`OnClickStopAndPlayAudioButton`函数。
- en: Run the game and click this button and the background music starts to play.
    Click again to stop the background music, and if you click for a third time, the
    background music will start to play from the beginning.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并点击此按钮，背景音乐开始播放。再次点击停止背景音乐，如果第三次点击，背景音乐将从开头重新播放。
- en: VideoPlayer.clip
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VideoPlayer.clip
- en: 'By default, a `VideoPlayer` component will play the video clip it refers to.
    However, it''s a common requirement that we should be able to change the video
    when the game is running instead of creating many different Video Player instances.
    So, we can just modify the clip property of `VideoPlayer` via C# code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`VideoPlayer`组件将播放它所引用的视频剪辑。然而，我们通常需要能够在游戏运行时更改视频，而不是创建许多不同的Video Player实例。因此，我们可以通过C#代码直接修改`VideoPlayer`的剪辑属性：
- en: '[PRE9]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, we create a new C# script called `VideoManager`, which will get
    a reference to the target `VideoPlayer` component and a reference to the video
    clip asset. There is also a function called `OnClickChangeVideoClip`, which will
    later be bound to a UI button to change the video clip being played.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们创建一个新的C#脚本名为`VideoManager`，该脚本将获取目标`VideoPlayer`组件的引用以及视频剪辑资产的引用。还有一个名为`OnClickChangeVideoClip`的函数，该函数将被绑定到UI按钮上以更改正在播放的视频剪辑。
- en: Compared to setting an Audio Source, setting a Video Player is slightly more
    complicated, because we also need to select a **Render Mode** option for **Video
    Player**. For simplicity, here we select the **Camera Near Plane** option and
    use **Main Camera** in the scene to render each frame of the video clip, as shown
    in *Figure 6.33*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33 – Video Player'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.33_B17146.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.33 – Video Player
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Then, we also need to assign the newly created script **VideoManager** to the
    same GameObject.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.34 – Video Manager'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.34_B17146.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.34 – Video Manager
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 6.34*, we not only assigned a reference to **Video
    Player** to the **VideoManager** script but also assigned a reference to a video
    clip asset to it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The third thing is to create a new UI button and bind the button with the `OnClickChangeVideoClip`
    function we mentioned earlier.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.35 – UI button'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.35_B17146.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.35 – UI button
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Let's play the game in the editor and click the button to change the video clip.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.36 – Change the video clip'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.36_B17146.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.36 – Change the video clip
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 6.36*, the video clip of the **Video Player** component
    is changed to the video clip asset we want it to play.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: VideoPlayer.url
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, playing videos from video clip assets is not a good idea. For example,
    we do not want to increase the size of the game due to the inclusion of video
    files, or we want to develop WebGL-based games, and WebGL does not support video
    clip assets. Then, the use of a URL to provide video resources becomes an obvious
    solution. So, let''s add another function called `OnClickSetVideoURL` to let the
    Video Player in the game scene play the video pointed to by the URL:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And we also need to create a new UI button and bind the button with the `OnClickSetVideoURL`
    function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.37 – Set Video URL'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.37_B17146.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.37 – Set Video URL
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and click the **Set Video URL** button to play the video from the
    URL, as shown in the preceding figure.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Unity does not support playing videos from YouTube, so you can host your video
    resources on other platforms, such as the Azure cloud.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: VideoPlayer.Play
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous two examples, whether we set the video clip asset or the video
    URL, the Video Player will automatically play the video. This is because we have
    enabled the **Play On Awake** option by default, as shown in *Figure 6.38*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.38 – Play On Awake'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.38_B17146.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.38 – Play On Awake
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, we prefer to be able to control when to play the video ourselves.
    Therefore, it is a good idea to disable this option and use C# code in a script
    to control playback, as shown in the following code block:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we will create the third UI button and bind the button with the `OnClickPlay`function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.39 – Play Video'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.39_B17146.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.39 – Play Video
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: This time, if we run the game and click the `Play` function of **Video Player**
    to play the video, as shown in *Figure 6.39*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，如果我们运行游戏并点击**视频播放器**的**播放**功能来播放视频，如图*图 6.39*所示。
- en: VideoPlayer.frame and VideoPlayer.frameCount
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VideoPlayer.frame 和 VideoPlayer.frameCount
- en: Speaking of controlling video playback, the video progress bar is a useful feature.
    We can also implement a video progress bar in Unity. Next, let's discuss how to
    use the `frame` and `frameCount` properties of **Video Player** to implement a
    video progress bar.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到控制视频播放，视频进度条是一个有用的功能。我们也可以在 Unity 中实现视频进度条。接下来，让我们讨论如何使用**视频播放器**的`frame`和`frameCount`属性来实现视频进度条。
- en: The `frameCount` property is read-only and provides the number of frames in
    the current video content. On the other hand, the `frame` property can be modified
    and provides the frame index of the current frame. Therefore, we should first
    create a UI slider and then modify the value of the slider according to the value
    of `frame` and `frameCount` for a **VideoPlayer** component, as shown in *Figure
    6.40*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`frameCount`属性是只读的，它提供了当前视频内容中的帧数。另一方面，`frame`属性可以修改，并提供了当前帧的帧索引。因此，我们首先创建一个
    UI 滑块，然后根据`frame`和`frameCount`的值修改**视频播放器**组件的滑块值，如图*图 6.40*所示。'
- en: '![Figure 6.40 – Create a slider'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.40 – 创建滑块'
- en: '](img/Figure_6.40_B17146.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.40_B17146.jpg)'
- en: Figure 6.40 – Create a slider
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.40 – 创建滑块
- en: 'We also need to modify the C# script to obtain a reference to the slider and
    update the value of the slider based on the value of `frame` and the value of
    `frameCount`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改 C# 脚本来获取滑块的引用并根据`frame`和`frameCount`的值更新滑块的值：
- en: '[PRE12]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, we are using the `UnityEngine.UI` namespace because we need to
    access the UI slider from our code. And we implemented the `Update` function to
    update the value of the slider.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`UnityEngine.UI`命名空间，因为我们需要从我们的代码中访问 UI 滑块。并且我们实现了`Update`函数来更新滑块的值。
- en: Let's run the game and play the video as before.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行游戏并播放视频。
- en: '![Figure 6.41 – The progress bar'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.41 – 进度条'
- en: '](img/Figure_6.41_B17146.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.41_B17146.jpg)'
- en: Figure 6.41 – The progress bar
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.41 – 进度条
- en: We can see that as the video plays, the progress bar is also updated.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，随着视频的播放，进度条也会更新。
- en: In this section, we explored and demonstrated the use of C# code to control
    audio and video, such as how to play audio and video, pause audio and video, and
    implement a progress bar via C# code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了并演示了如何使用 C# 代码来控制音频和视频，例如如何播放音频和视频，暂停音频和视频，以及通过 C# 代码实现进度条。
- en: However, if you are using Unity to develop a web application, then you may encounter
    other problems. Let's continue to explore.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用 Unity 开发 Web 应用程序，那么你可能会遇到其他问题。让我们继续探索。
- en: Things to note when using Unity to develop web applications
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity 开发 Web 应用时需要注意的事项
- en: Unity is a cross-platform game engine, which means that we can deploy games
    that use the same code base and resources on different platforms, including WebGL.
    However, if you are using Unity to develop games for the web platform, here are
    some notes about implementing a video player.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 是一个跨平台的游戏引擎，这意味着我们可以将使用相同代码库和资源的游戏部署到不同的平台，包括 WebGL。然而，如果你使用 Unity 为 Web
    平台开发游戏，这里有一些关于实现视频播放器的注意事项。
- en: URL
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL
- en: First of all, the `VideoPlayer.clip` property is not supported on WebGL, which
    means that you can implement your video player solution by playing the video content
    in the video clip assets in the editor. However, once you build and deploy your
    web application to the server and run it, the video will not be played, even if
    the required video assets are packaged and deployed together.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`VideoPlayer.clip`属性在 WebGL 上不受支持，这意味着你可以通过在编辑器中播放视频剪辑资产中的视频内容来实现你的视频播放器解决方案。然而，一旦你构建并部署你的
    Web 应用程序到服务器并运行它，即使所需的视频资产已打包并部署在一起，视频也不会播放。
- en: '![Figure 6.42 – WebGL'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.42 – WebGL'
- en: '](img/Figure_6.42_B17146.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.42_B17146.jpg)'
- en: Figure 6.42 – WebGL
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.42 – WebGL
- en: As shown in *Figure 6.42*, when we run the web app and click the **Play Video**
    button, nothing will happen.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 6.42*所示，当我们运行 Web 应用程序并点击**播放视频**按钮时，什么也不会发生。
- en: In this case, we have to provide a video source via the `VideoPlayer.url` property
    instead. If the video file has been hosted on another cloud platform, then we
    can directly use the method introduced in the previous section to play the video
    pointed to by the URL. In addition, `VideoPlayer.url` also supports local absolute
    or relative paths. Therefore, we can also build and deploy video files and other
    content of the game together. It should be noted that in this case, we no longer
    use Unity's video clip assets, but directly use the original video files, and
    put these video files in a folder called `StreamingAssets`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须通过`VideoPlayer.url`属性提供视频源。如果视频文件已托管在另一个云平台上，则可以直接使用上一节中介绍的方法播放URL指向的视频。此外，`VideoPlayer.url`还支持本地绝对或相对路径。因此，我们也可以构建和部署视频文件和其他游戏内容。需要注意的是，在这种情况下，我们不再使用Unity的视频剪辑资产，而是直接使用原始视频文件，并将这些视频文件放在名为`StreamingAssets`的文件夹中。
- en: Note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**StreamingAssets** is a special folder name of a Unity project. Files in this
    folder are available in their original format.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**StreamingAssets**是Unity项目的一个特殊文件夹名称。此文件夹中的文件以原始格式可用。'
- en: Here, we can create a new folder in the root of the project, rename it **StreamingAssets**,
    then put the original video file in this folder.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以在项目的根目录下创建一个新的文件夹，将其重命名为**StreamingAssets**，然后将原始视频文件放入此文件夹。
- en: '![Figure 6.43 – StreamingAssets folder'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.43 – StreamingAssets文件夹'
- en: '](img/Figure_6.43_B17146.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.43 – B17146.jpg](img/Figure_6.43_B17146.jpg)'
- en: Figure 6.43 – StreamingAssets folder
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.43 – StreamingAssets文件夹
- en: As you can see in *Figure 6.43*, the video file is in its original format and
    has not been converted into a Unity video clip asset.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6.43*所示，视频文件保持其原始格式，并未转换为Unity视频剪辑资产。
- en: 'Next, let''s create another C# script to demonstrate how to make **Video Player**
    load this video file and play it in the browser:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建另一个C#脚本，以演示如何使**视频播放器**加载此视频文件并在浏览器中播放：
- en: '[PRE13]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this script, we access the `Application.streamingAssetsPath` property to
    get the path to the folder at runtime and assign the path to the `url` property
    of `VideoPlayer`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们通过`Application.streamingAssetsPath`属性在运行时获取文件夹的路径，并将该路径分配给`VideoPlayer`的`url`属性。
- en: Now, instead of running the game in the editor, we build and deploy it as a
    web application, and then run it in the browser.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不是在编辑器中运行游戏，而是构建并部署它作为一个网络应用程序，然后在浏览器中运行。
- en: '![Figure 6.44 – Play the video in the broswer'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.44 – 在浏览器中播放视频'
- en: '](img/Figure_6.44_B17146.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.44 – B17146.jpg](img/Figure_6.44_B17146.jpg)'
- en: Figure 6.44 – Play the video in the broswer
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.44 – 在浏览器中播放视频
- en: This time the video played as expected in the browser.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这次视频在浏览器中按预期播放。
- en: Frame rate
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧率
- en: When developing WebGL applications with Unity, another thing you should pay
    attention to is the **frame rate** of the video. In Unity, the frame rate is expressed
    as frames per second.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Unity开发WebGL应用程序时，您还应注意视频的**帧率**。在Unity中，帧率以每秒帧数的形式表示。
- en: Let's print the video length, video frame count, and video frame rate information
    of the sample video we are using in the editor.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出我们在编辑器中使用的示例视频的长度、帧数和帧率信息。
- en: '![Figure 6.45 – Frame rate'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.45 – 帧率'
- en: '](img/Figure_6.45_B17146.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.45 – B17146.jpg](img/Figure_6.45_B17146.jpg)'
- en: Figure 6.45 – Frame rate
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.45 – 帧率
- en: As you can see here, the frame count of this video is 213, the video length
    is 7.1 seconds, and the frame rate is 30 FPS.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，本视频的帧数为213帧，视频长度为7.1秒，帧率为30 FPS。
- en: However, since the underlying implementation on the WebGL platform, that is,
    the JavaScript API for `HTML5 <video>`, does not disclose frame rate information,
    the frame rate is always assumed to be 24 FPS, even if the real frame rate of
    the video is 30 FPS. Therefore, frames/second of a video is always 24, which should
    be paid attention to when implementing the video progress bar for WebGL.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于WebGL平台底层的实现，即`HTML5 <video>`的JavaScript API没有公开帧率信息，帧率始终假设为24 FPS，即使视频的实际帧率为30
    FPS。因此，视频的帧/秒始终为24，这在实现WebGL的视频进度条时应该注意。
- en: In this section, we discussed the things that need to be paid attention to when
    using Unity to develop video functions due to some limitations of the web platform.
    Next, we will explore how to use the profiler tool provided by Unity to locate
    the performance problems caused by audio and how to solve them.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了由于Web平台的一些限制，使用Unity开发视频功能时需要注意的事项。接下来，我们将探讨如何使用Unity提供的性能分析工具定位由音频引起的性能问题以及如何解决这些问题。
- en: Increasing the performance of the audio system
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高音频系统的性能
- en: In game development, the importance of audio is often overlooked. Sometimes
    this is also reflected in performance optimization. Game developers usually invest
    more effort in other performance areas, such as performance optimization for graphics
    rendering. But as games become more and more complex, audio can also cause performance
    problems, such as greater memory usage and so on. In this section, we will explore
    how to optimize audio performance in Unity.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，音频的重要性往往被忽视。有时这也反映在性能优化上。游戏开发者通常在其他性能领域投入更多精力，例如图形渲染的性能优化。但随着游戏变得越来越复杂，音频也可能导致性能问题，例如更大的内存使用等。在本节中，我们将探讨如何在Unity中优化音频性能。
- en: The Unity Profiler
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity分析器
- en: 'First, we should learn how to use the Unity Profiler tool to view and locate
    performance bottlenecks caused by the audio system in Unity:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该学习如何使用Unity分析器工具来查看和定位由Unity中的音频系统引起的性能瓶颈：
- en: Click **Window** | **Analysis** | **Profiler** or use the keyboard shortcut
    *Ctrl* + *7* (*command + 7* on macOS) to open the **Profiler** window.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**窗口** | **分析** | **分析器**或使用键盘快捷键*Ctrl* + *7*（在macOS上为*command* + *7*）打开**分析器**窗口。
- en: 'Click the **Audio** module area in the **Profiler** window to view the performance
    data of the audio system. You can find out how many Audio Sources are playing,
    the number of audio clips being used, and the amount of memory being used for
    audio, and so on, as shown in *Figure 6.46*:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**音频**模块区域在**分析器**窗口中查看音频系统的性能数据。您可以了解正在播放的音频源数量、正在使用的音频剪辑数量以及音频使用的内存量等信息，如图*图6.46*所示：
- en: '![Figure 6.46 – Audio Profiler'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.46 – 音频分析器'
- en: '](img/Figure_6.46_B17146.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.46_B17146.jpg)'
- en: Figure 6.46 – Audio Profiler
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.46 – 音频分析器
- en: As shown in *Figure 6.46*, the value of **Total Audio Memory** is 38.9 MB, which
    is very bad because, currently, only one Audio Source is playing sound. Therefore,
    we can click on the drop-down menu labeled **Simple** and switch to the **Detailed**
    view.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6.46*所示，**总音频内存**的值为38.9 MB，这非常糟糕，因为目前只有一个是音频源正在播放声音。因此，我们可以点击标记为**简单**的下拉菜单并切换到**详细**视图。
- en: '![Figure 6.47 – Switch to the Detailed view'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.47 – 切换到详细视图'
- en: '](img/Figure_6.47_B17146.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.47_B17146.jpg)'
- en: Figure 6.47 – Switch to the Detailed view
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.47 – 切换到详细视图
- en: We can get more information about the audio system and identify the specific
    audio asset that occupies 38.9 MB of memory.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以获取有关音频系统的更多信息，并识别占用38.9 MB内存的具体音频资产。
- en: '![Figure 6.48 – Detailed view'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.48 – 详细视图'
- en: '](img/Figure_6.48_B17146.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.48_B17146.jpg)'
- en: Figure 6.48 – Detailed view
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.48 – 详细视图
- en: Next, we will introduce how to reduce the memory occupied by this audio resource.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何减少此音频资源占用的内存。
- en: Using Force To Mono to save memory
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用强制单声道来节省内存
- en: If we inspect this audio asset, we will find the audio asset is stereo, as shown
    in *Figure 6.49*.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查这个音频资产，我们会发现音频资产是立体声的，如图*图6.49*所示。
- en: '![Figure 6.49 – The audio clip'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.49 – 音频剪辑'
- en: '](img/Figure_6.49_B17146.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.49_B17146.jpg)'
- en: Figure 6.49 – The audio clip
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.49 – 音频剪辑
- en: However, since there is only one Audio Source in the game scene, which means
    that the sound is emitted from one point, the effect of using stereo is lost here,
    but the memory consumption is twice that of mono. Therefore, if the game does
    not require stereo and needs to reduce memory overhead, we can just enable the
    **Force To Mono** option in the audio clip's import settings to convert the stereo
    audio clip to a mono audio clip.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于游戏场景中只有一个音频源，这意味着声音从一个点发出，因此在这里使用立体声的效果会丢失，但内存消耗是单声道的两倍。因此，如果游戏不需要立体声且需要减少内存开销，我们只需在音频剪辑的导入设置中启用**强制单声道**选项，将立体声音频剪辑转换为单声道音频剪辑即可。
- en: '![Figure 6.50 – Enable Force To Mono'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.50 – 启用强制单声道'
- en: '](img/Figure_6.50_B17146.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.50_B17146.jpg)'
- en: Figure 6.50 – Enable Force To Mono
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.50 – 启用强制单声道
- en: Then let's play the audio again. This time we find that the memory consumption
    of this audio clip has dropped from 38.9 MB to 20.2 MB, which is almost halved.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们再次播放音频。这次我们发现这个音频剪辑的内存消耗已从38.9 MB降至20.2 MB，几乎减半。
- en: '![Figure 6.51 – Memory consumption has dropped'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.51 – 内存消耗已降低'
- en: '](img/Figure_6.51_B17146.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.51_B17146.jpg)'
- en: Figure 6.51 – Memory consumption has dropped
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.51 – 内存消耗已降低
- en: In this section, we introduced how to use Unity's Profiler tool to view the
    performance data of the audio system and explored how to optimize the performance
    of the audio system.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用Unity的Profiler工具查看音频系统的性能数据，并探讨了如何优化音频系统的性能。
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by introducing the audio and video features provided
    by Unity, then we explored some of the most important concepts in the Unity audio
    system and video system, such as **audio clip** assets, **Audio Source** components,
    **Audio Listener** components, **Video Player** components, and so on. We also
    discussed how to create a new script in Unity to interact with Unity's audio system
    and video system.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了Unity提供的音频和视频功能，然后探讨了Unity音频系统和视频系统中最重要的一些概念，例如**音频剪辑**资源、**音频源**组件、**音频监听器**组件、**视频播放器**组件等等。我们还讨论了如何在Unity中创建一个新的脚本以与Unity的音频系统和视频系统交互。
- en: Then we demonstrated how to implement a video for the web platform because WebGL
    does not support Unity's **video clip** assets and due to underlying implementation
    reasons, the video frame rate is always assumed to be 24 FPS. These need to be
    paid attention to.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们演示了如何为Web平台实现视频，因为WebGL不支持Unity的**视频剪辑**资源，并且由于底层实现原因，视频帧率始终假设为24 FPS。这些需要注意。
- en: Finally, we explored how to view and locate performance bottlenecks caused by
    the audio system in Unity.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何查看和定位由Unity音频系统引起的性能瓶颈。
- en: In the next chapter, we will introduce the mathematics of computer graphics
    in Unity.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Unity中计算机图形学的数学原理。
