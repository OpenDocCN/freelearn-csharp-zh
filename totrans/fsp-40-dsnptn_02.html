<html><head></head><body>
<div><div><div><div><h1 class="title"><a id="ch02"/>
 Chapter 2. Dissecting F# Origins and Design</h1>
</div>
</div>
</div>
<p>This chapter reviews F# features from the historical perspective tracking them back to origins where possible. The review covers:</p>
<div><ul class="itemizedlist">
<li class="listitem">F# evolvement timeline</li>
<li class="listitem">Predecessor inherited language features</li>
<li class="listitem">.NET imposed language features</li>
<li class="listitem">Intrinsic F# language features</li>
</ul>
</div>
<p>Although F# is a functional-first programming language, at the same time, you should not forget that it is a multi-paradigm tool that allows paradigms to be combined if required. Another important aspect you should keep in mind is that F# is designed for a .NET platform, so certain language facilities are shaped by underlying implementation mechanisms and interoperability requirements. The goal of this chapter is to dissect the language into components in a way that allows you to grasp the origins and the logic behind a contemporary F# design.</p>
<div><div><div><div><h1 class="title" id="toc_1"><a id="ch02lvl1sec17"/>
 The evolvement of F#</h1>
</div>
</div>
</div>
<p>Press began mentioning (<a class="ulink" href="http://developers.slashdot.org/story/02/06/08/0324233/f---a-new-net-language">http://developers.slashdot.org/story/02/06/08/0324233/f---a-new-net-language</a>
 ) the F# programming language in the Summer of 2002 as a research project at Microsoft Research Cambridge (<a class="ulink" href="http://research.microsoft.com/en-us/labs/cambridge/">http://research.microsoft.com/en-us/labs/cambridge/</a>
 ) aiming to create a dialect of 
<strong>OCaml</strong>

 language (<a class="ulink" href="https://ocaml.org/">https://ocaml.org/</a>
 ) running on top of the .NET platform. Computer scientist Don Syme (<a class="ulink" href="http://research.microsoft.com/en-us/people/dsyme/">http://research.microsoft.com/en-us/people/dsyme/</a>
 ) was in charge of design and the first implementation.</p>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch02lvl2sec8"/>
 Predecessors</h2>
</div>
</div>
</div>
<p>The F# project of Microsoft Research Cambridge didn't come from scratch. F# belongs to ML (<a class="ulink" href="https://en.wikipedia.org/wiki/ML_(programming%20language)">https://en.wikipedia.org/wiki/ML_(programming language)</a>
 ) programming language family. It predecessors are Standard ML (<a class="ulink" href="https://en.wikipedia.org/wiki/Standard_ML">https://en.wikipedia.org/wiki/Standard_ML</a>
 ) and 
<strong>OCaml</strong>

 . Moreover, F# initially had a twin project at Microsoft Research Cambridge named SML.NET, which aimed at bringing 
<strong>Standard </strong>

 
<strong>ML</strong>

 (
<strong>SML</strong>

 ) to the .NET platform.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch02lvl2sec9"/>
 F# Version 1</h2>
</div>
</div>
</div>
<p>The first release took place in December of 2004, labelled as a Microsoft Research project. This means that at that time, it didn't have the status of a Microsoft product, although it was providing integration with Visual Studio 2003 and Visual Studio 2005 Beta.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_4"><a id="ch02lvl2sec10"/>
 F# Version 1.1</h2>
</div>
</div>
</div>
<p>Released in October 2005, this version is signified by bringing its object-oriented features to the language. It represents the milestone where F# had turned into a genuinely multi-paradigm language.</p>
<div><blockquote class="blockquote">
<p>

<em>"The major addition to the F# language itself in this release is what we're calling the "F# Object and Encapsulation Extensions". This combines what I've found to be the best features of the .NET object oriented paradigm with the functional programming model that lies at the core of F#. This means that F# has become a mixed functional/imperative/object-oriented programming language."
<em>Don Syme (</em>

 <a class="ulink" href="http://blogs.msdn.com/b/dsyme/archive/2005/08/24/455403.aspx">http://blogs.msdn.com/b/dsyme/archive/2005/08/24/455403.aspx</a>
 
<em>) in his blog on August 23, 2005.</em>

</em>

</p>
</blockquote>
</div>
<p>Another feature that makes version 1.1 ponderous is introducing of F# Interactive, also known as FSI, the tool providing F# scripting capabilities and the manner of code development by frequenting REPL along the course. This release was suitable for use within the final version of Visual Studio 2005.</p>
<p>After the version 1.1 milestone, the language continued to have frequent releases and introduce new major features. On October 17, 2007, Microsoft Corp officially declared a transition of F# from research to product development organization, aiming to productize F# into another first class programming language on the .NET platform fully integrated into Visual Studio. Following another year of intensive work, in December 2008 came the announcement of F# to be shipped as the integral part of Visual Studio 2010.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_5"><a id="ch02lvl2sec11"/>
 F# Version 2</h2>
</div>
</div>
</div>
<p>In February 2010, it was announced that the version of F# to be included into Visual Studio 2010 will be incremented to 2.0. Shortly afterwards, in April 2010, F# 2.0 was released, indeed, as part of Visual Studio 2010 and also as the matching installation for Visual Studio 2008 and standalone compiler for other platforms. The F# version 2.0 milestone reflects almost 5 years of F# 1.x evolvement, which has added to object-oriented facilities on top of its functional programming base such major language features as active patterns, sequence expressions, asynchronous and parallel computations, and significant library refinements. Also, it worth noting that integration with Visual Studio provided developers using F# on Microsoft platform with world class tooling such as, debugging, IntelliSense, and the project system. At this point, F# 2.0 is completely ready for enterprise software development.</p>
<p>Also, F# version 2.0 delineates the stage of language evolvement that is usually recognized as 
<em>full-fledged</em>

 F# in comparison with primordial versions that lack some core features.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_6"><a id="ch02lvl2sec12"/>
 F# Version 3</h2>
</div>
</div>
</div>
<p>Another intensive year and a half of F# evolvement brought to life a preview version of F# 3.0 in the September of 2011. This version proclaimed targeting information-rich programming.</p>
<div><blockquote class="blockquote">
<p>

<em>"A growing trend in both the theory and practice of programming is the interaction between programming and rich information spaces. From databases to web services to the semantic web to cloud-based data, the need to integrate programming with heterogeneous, connected, richly structured, streaming and evolving information sources is ever-increasing. Most modern applications incorporate one or more external information sources as integral components. Providing strongly typed access to these sources is a key consideration for strongly-typed programming languages, to insure low impedance mismatch in information access."
<em>Technical Report MSR-TR-2012-101 of Microsoft Research</em>

 (<a class="ulink" href="http://research.microsoft.com/apps/pubs/?id=173076">http://research.microsoft.com/apps/pubs/?id=173076</a>
 ).</em>

</p>
</blockquote>
</div>
<p>With this goal, the language acquires query expressions, an incredibly powerful mechanism of type providers along with numerous reference implementations of type providers for major enterprise information exchange technologies. It took another year for F# 3.0 to get released as part of Visual Studio 2012 in September 2012.</p>
<p>The following year, 2013, signified an explosive burst of activity around F#, indicating that the language reached some critical mass. Xamarin (<a class="ulink" href="https://xamarin.com">https://xamarin.com</a>
 ) announced support for F#, reaching multiplatform mobile development, and multiple break-through developments took place in the fields of machine learning, cloud programming, finance time series, numeric libraries, and type providers.</p>
<p>This period also signifies strong cross-platform open engineering community effort, factually turning F# into an open source cross-platform shared implementation not fundamentally dependent on Microsoft anymore. The Microsoft affiliation with F# got limited to Visual F#, also known as 
<em>The F# Tools for Visual Studio</em>

 , and even in this space, Microsoft turned to enabling community contributions and open engineering.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_7"><a id="ch02lvl2sec13"/>
 F# Version 4</h2>
</div>
</div>
</div>
<p>Announced in late 2014, F# 4.0 provided some new capabilities: type constructors were turned into first-class functions, mutable values could be captured by closures, and there were high-dimensional arrays, slicing syntax for lists, normalized collections in core run-time libraries, among others.</p>
<p>Getting you equipped with the vision of more than a dozen years of the language's exciting historical evolution, I now turn to the dissection of language features. In this chapter, these features are to be outlined only briefly, postponing the complete details of idiomatic usage to later chapters.</p>
</div>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>
 Predecessor inherited language features</h1>
</div>
</div>
</div>
<p>F# inherits the core of the features associated with its functional-first nature from ML and OCaml. This means that its chief fashion of expressing computations is via the definition and application of functions.</p>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch02lvl2sec14"/>
 F# functions are first-class entities</h2>
</div>
</div>
</div>
<p>The ability to define and apply functions is a common feature of many programming languages. However, F# follows ML and other functional programming languages in treating functions similarly to, say, numeric values. The ways of treating functions in F# go well beyond the limits usually associated with stored-program computer concept:</p>
<div><ul class="itemizedlist">
<li class="listitem">Functions can be used as arguments to other functions; the latter are higher-order functions in this case</li>
<li class="listitem">Functions can be returned from other functions</li>
<li class="listitem">Functions can be computed from other functions, for example, with the help of function composition operators</li>
<li class="listitem">Functions can be elements of structures usually associated with data</li>
</ul>
</div>
</div>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch02lvl2sec15"/>
 Functions are free of side effects</h2>
</div>
</div>
</div>
<p>Computations with functions have the main form of 
<em>evaluating expressions</em>

  as opposed to 
<em>making assignments to variables</em>

 . Expressions do not carry the stigma of ever-changing values stored in rewritable memory. When the function <code class="literal">triple x</code>
 is applied to argument value <code class="literal">3</code>
 , it evaluates some inner expression and returns <code class="literal">9.</code>
 We are sure that this result is consistent, may be repeatedly reproduced, and may change from <code class="literal">9</code>
 only if the argument value changes from <code class="literal">3</code>
 to something else.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch02lvl2sec16"/>
 Functions can be curried and partially evaluated</h2>
</div>
</div>
</div>
<p>Currying is a method of converting a function of many arguments evaluation into an equivalent evaluation of a sequence of functions of a single argument each. Partial evaluation binds one or more first arguments of a curried function, effectively producing a new function of fewer (non-bound) arguments.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_4"><a id="ch02lvl2sec17"/>
 Functions may be anonymous</h2>
</div>
</div>
</div>
<p>Why bother giving a name to a function that is passed to a higher-order function or is returned from it? For the sake of succinctness F# allows using generic <code class="literal">fun</code>
 and <code class="literal">function</code>
 forms of function definitions that will not be invoked from elsewhere, hence the name is omitted.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_5"><a id="ch02lvl2sec18"/>
 Functions may be recursive</h2>
</div>
</div>
</div>
<p>A frequently used example of recursive function (<a class="ulink" href="https://en.wikipedia.org/wiki/Recursive_function">https://en.wikipedia.org/wiki/Recursive_function</a>
 ) implementation is a divide and conquer algorithm (<a class="ulink" href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms</a>
 ) when a problem gets broken into a few of the same problems with less dimensions, so the same solving function can be applied. This breaking down continues until solutions get simple, and then smaller solutions are combined back to in the solution of the original size.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_6"><a id="ch02lvl2sec19"/>
 Functions may raise exceptions</h2>
</div>
</div>
</div>
<p>Not every expression may always bring back a result value; the most beaten up example of such a situation is a number divided by zero. Another typical example would be invalid argument value that does not allow to return result. In such cases instead of returning the result an exception is to be thrown.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_7"><a id="ch02lvl2sec20"/>
 Functions may reference external values</h2>
</div>
</div>
</div>
<p>The use of an external value freezes it in the function definition, creating a so called 
<strong>closure</strong>

 .</p>
</div>
<div><div><div><div><h2 class="title" id="toc_8"><a id="ch02lvl2sec21"/>
 F# is a statically typed language</h2>
</div>
</div>
</div>
<p>Expressions and their constituents carry unique types that can be inferred by the F# compiler. As a rule, no implicit type conversions have place ever. F# compiler type checks programs and catches errors that may otherwise occur at run-time for dynamically typed languages.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_9"><a id="ch02lvl2sec22"/>
 F# type inference provides type generalization</h2>
</div>
</div>
</div>
<p>Type assignment algorithm performed by the compiler often allows the programmer to omit type declarations if the context unambiguously determines them. It finds most general type possible for value binding and expression evaluation.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_10"><a id="ch02lvl2sec23"/>
 F# supports parametric polymorphism</h2>
</div>
</div>
</div>
<p>A function may allow a generic type of argument(s); for example, the implementation of a function calculating the sum of the list elements of <code class="literal">int</code>
 , or <code class="literal">int64</code>
 , or <code class="literal">bigint</code>
 may be the same.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_11"><a id="ch02lvl2sec24"/>
 F# inherits the variety of aggregate data structures from ML</h2>
</div>
</div>
</div>
<p>Inherited data structures include the following:</p>
<div><ul class="itemizedlist">
<li class="listitem">A tuple or values of the algebraic product type, allowing you to represent values of heterogeneous types</li>
<li class="listitem">A list or a finite sequence of zero or more values of the same type</li>
<li class="listitem">Discriminated union or a custom algebraic sum type defined via a mechanism similar to the ML data type, in particular, allows recursive type definition (for example, binary tree)</li>
<li class="listitem">The option to represent the absence or the presence of a value of a certain type</li>
<li class="listitem">A record that is like a tuple with components named rather than ordered</li>
<li class="listitem">An array, of course</li>
<li class="listitem">A sequence, which is implemented as extension of the data type with lazily evaluated value constructors in ML</li>
</ul>
</div>
</div>
<div><div><div><div><h2 class="title" id="toc_12"><a id="ch02lvl2sec25"/>
 F# supports pattern matching</h2>
</div>
</div>
</div>
<p>Pattern matching is a powerful mechanism of data structure decomposition, allowing you to disassemble the data aggregate into components or define the processing depending on a particular structure/attributes of the data aggregate.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_13"><a id="ch02lvl2sec26"/>
 F# supports data references</h2>
</div>
</div>
</div>
<p>Data references were introduced in ML in order to support mutable storage and, more broadly, imperative programming. F# inherits this feature for backward compatibility with ML without reservations. Values of the <code class="literal">ref</code>
 type allow you to achieve mutability, changing states and representing global variables.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_14"><a id="ch02lvl2sec27"/>
 Functions are non-recursive by default</h2>
</div>
</div>
</div>
<p>F# follows OCaml in this respect, so recursive function binding should be labeled with the <code class="literal">rec</code>
 attribute. <code class="literal">let rec</code>
 immediately puts the name of the function into the scope shadowing the potential duplicate from the outer scope. In absence of <code class="literal">rec</code>
 attribute <code class="literal">let</code>
 puts the name of the function into the scope only after the body is fully defined, making the reference either unavailable within the function body, or in the worst case using an unintentionally shadowed outer one in place of the intended.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_15"><a id="ch02lvl2sec28"/>
 Modules</h2>
</div>
</div>
</div>
<p>Following ML and OCaml, F# offers modules as a way of grouping together related values, functions, and types. Effectively modules resemble static classes of C# and provide developers with means of grouping together, maintaining, and extending related entities.</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>
 .NET-imposed language features</h1>
</div>
</div>
</div>
<p>Along with the features inherited from the language predecessors, the multitude of F# features was brought into the language for the sake of interoperability with the .NET platform.</p>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch02lvl2sec29"/>
 F# adheres to .NET Common Language Infrastructure</h2>
</div>
</div>
</div>
<p>Run-time arrangement for the F# code has been defined by .NET 
<strong>Common </strong>

 
<strong>Language </strong>

 
<strong>Infrastructure</strong>

 (
<strong>CLI</strong>

 ) and does not anyhow differ from the same of C# or VB.NET. F# compiler ingests F# source code file(s) and produces the intermediate code in assembly language named MSIL packaged as binary .NET assembly(ies). During code execution stage MSIL is converted into machine code as needed, or 
<strong>Just-in-time</strong>

 (
<strong>JIT</strong>

 ). Interoperability with other .NET languages is achieved as F#-produced assemblies do not anyhow differ from assemblies produced by C# or VB.NET. Similarly, the JIT compiler takes care of the target hardware platform providing portability. CLI also takes the burden of memory management on itself, making F# programs subject to .NET garbage collection.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch02lvl2sec30"/>
 F# has nominal type system</h2>
</div>
</div>
</div>
<p>This is a significant deviation off OCaml and ML having a structural object system. Apparently, this design decision was dictated by the necessity to exist within and interact with the .NET object system, which is nominal.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch02lvl2sec31"/>
 F# fully embraces .NET object orientation</h2>
</div>
</div>
</div>
<p>F# allows you to follow the object-oriented paradigm of .NET from both the direction of using the existing .NET frameworks and object-oriented libraries as well as the direction of contributing F# code in the form of .NET libraries, frameworks, and tools.</p>
<p>All F# entities are inherited from a single root type of <code class="literal">System.Object</code>
 , or <code class="literal">obj</code>
 . As such, they come with some common methods that are overridable and customizable. For custom F# entities such as discriminated unions, the compiler generates the implementation of these common <code class="literal">obj</code>
 methods.</p>
<p>In addition to the use of .NET classes, F# allows you to create your own custom classes consisting of 
<em>data</em>

 in the form of 
<strong>fields</strong>

 and 
<em>functions</em>

 manipulating these fields in the form of 
<strong>methods</strong>

 and 
<strong>properties</strong>

 . Special methods named 
<strong>constructors</strong>

 initialize instances of each class assigning certain values to fields. Classes may be further parameterized by type parameters getting generic this way. A class may inherit from the single 
<strong>base class</strong>

 and implement many 
<strong>interfaces</strong>

 . The subclass may modify the behavior of the base class by 
<em>overriding</em>

 its properties and methods. The custom classes are consumable from other tenants of .NET ecosystem.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_4"><a id="ch02lvl2sec32"/>
 F# requires calling the method of an explicit interface</h2>
</div>
</div>
</div>
<p>F# differs from other .NET languages in this matter, so let me explain this with a short coding example as following (<code class="literal">Ch2_2.fsx</code>
 ):</p>
<pre class="programlisting">type IMyInterface = 
    abstract member DoIt: unit -&gt; unit 
     
type MyImpl() = 
    interface IMyInterface with 
        member __.DoIt() = printfn "Did it!" 
         
MyImpl().DoIt() // Error: member 'DoIt' is not defined 
 
(MyImpl() :&gt; IMyInterface).DoIt() 
 
// ... but 
let doit (doer: IMyInterface) = 
    doer.DoIt() 
 
doit (MyImpl()) 
</pre>
<p>The preceding <code class="literal">MyImpl</code>
 class implements the <code class="literal">MyInterface</code>
 interface. However, an attempt to use the implementation fails implicitly as if <code class="literal">MyImpl</code>
 does not have the method at all. Only after the explicit upcast of the <code class="literal">MyImpl</code>
 instance into <code class="literal">MyInterface</code>
 does the implementation get accessible.</p>
<p>The justification of this design decision that comes to my mind is this: it would disambiguate situations when there is a need for implementing more than one interface that has similarly named methods. Also, this matter gets less annoying if we consider typical interface use as in the preceding <code class="literal">doit</code>
 function that has the <code class="literal">doer</code>
 parameter of type <code class="literal">IMyInterface</code>
 . In this case, the compiler does the cast for using <code class="literal">MyImpl</code>
 in place of <code class="literal">IMyInterface</code>
 implicitly. The execution of the preceding script illustrates this subtlety in the following screenshot:</p>
<div><img src="img/Image00005.jpg" alt="F# requires calling the method of an explicit interface"/>
</div>
<p style="clear: both; height: 1em;"/>
</div>
<div><div><div><div><h2 class="title" id="toc_5"><a id="ch02lvl2sec33"/>
 Object expressions</h2>
</div>
</div>
</div>
<p>F# offers the way to implement an interface without bothering to create a custom type just for that purpose. The following code illustrates the implementation of <code class="literal">IMyInterface</code>
 from the preceding code with an object expression (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233237.aspx">https://msdn.microsoft.com/en-us/library/dd233237.aspx</a>
 ), followed by the implementation usage (<code class="literal">Ch2_3.fsx</code>
 ):</p>
<pre class="programlisting">// Define interface 
type IMyInterface = 
    abstract member DoIt: unit -&gt; unit 
 
// Implement interface... 
let makeMyInterface() = 
    { 
        new IMyInterface with 
            member __.DoIt() = printfn "Did it!" 
    } 
 
//... and use it 
makeMyInterface().DoIt() 
makeMyInterface().DoIt() 
</pre>
</div>
<div><div><div><div><h2 class="title" id="toc_6"><a id="ch02lvl2sec34"/>
 Reflection</h2>
</div>
</div>
</div>
<p>F# completely embraces .NET Reflection, allowing access to the metadata information of the program code at run-time. It is possible from F# as well as from other .NET languages to introspect the running application and get to type metadata and to attributes decorating the source code. The final goal of such exercises is usually to modify the run-time behavior of the already executing code. For example, the goal might be dynamically adding new components, or resolving dependencies.</p>
<p>F# core library contains the comprehensive tools for run-time analyzing and constructing F#-specific types and values within <code class="literal">Microsoft.FSharp.Reflection</code>
 namespace (<a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/microsoft.fsharp.reflection-namespace-%5Bfsharp%5D">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/microsoft.fsharp.reflection-namespace-%5Bfsharp%5D</a>
 )</p>
</div>
<div><div><div><div><h2 class="title" id="toc_7"><a id="ch02lvl2sec35"/>
 Extending classes and modules</h2>
</div>
</div>
</div>
<p>F# allows a very unobtrusive way to extend classes and modules (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-extensions">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-extensions</a>
 ). The first form usually referred as 
<strong>intrinsic extension</strong>

 is similar to 
<em>partial classes</em>

 of C#. Unfortunately, in F#, this form of class augmentation cannot cross boundaries of the source file, namespace, or assembly.</p>
<p>The other form of extension, referred to as 
<strong>optional extension</strong>

 , goes through source files with ease. Its purpose clearly is augmenting any modules. Although much more widely applicable, this type of augmentation is not visible for reflection and cannot be utilized outside of F# from C# or VB.NET. We will take a close look at these augmentation methods later in the book.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_8"><a id="ch02lvl2sec36"/>
 Enumerations</h2>
</div>
</div>
</div>
<p>Enumerations in F# (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233216.aspx">https://msdn.microsoft.com/en-us/library/dd233216.aspx</a>
 ) mimic C# enumerations, allowing you to create named numeric constants. As these are not discriminated unions, their use with pattern matching is limited. Also, they may be of use when manipulating combinations of binary flags.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_9"><a id="ch02lvl2sec37"/>
 Structures</h2>
</div>
</div>
</div>
<p>Structures in F# (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233233.aspx">https://msdn.microsoft.com/en-us/library/dd233233.aspx</a>
 ) are lightweight classes represented with value types. As such, their instances can be put on the stack, they take less memory than reference types, and they may not be required to participate in garbage collection.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_10"><a id="ch02lvl2sec38"/>
 Events</h2>
</div>
</div>
</div>
<p>F# events (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233189.aspx">https://msdn.microsoft.com/en-us/library/dd233189.aspx</a>
 ) allow interoperation with .NET events of CLI. However, F# goes further than CLI, providing powerful aggregation, filtering, and partitioning in observer-observable and publish-subscribe scenarios.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_11"><a id="ch02lvl2sec39"/>
 Nullable types</h2>
</div>
</div>
</div>
<p>Nullable types (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233233.aspx">https://msdn.microsoft.com/en-us/library/dd233233.aspx</a>
 ) address <code class="literal">null</code>
 value related problems that normally do not exist in F# due to idiomatic <code class="literal">option</code>
 types usage. As a rule, in any internal scenario F# allows to cover absence of value with <code class="literal">None</code>
 case of correspondent <code class="literal">option</code>
 type. However, F# code interoperation with C# and VB.NET code as well as low-level database manipulations from F# when <code class="literal">option</code>
 types cannot be used may require using nullable types instead for expressing the absence of values.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_12"><a id="ch02lvl2sec40"/>
 Interoperation with the managed code</h2>
</div>
</div>
</div>
<p>C# and VB.NET using F# code only can access public methods implemented in F#, leaving F#-specific data types or functions out of scope. Fortunately, the access in the opposite direction is easier as F# supersets C# and VB.NET features.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_13"><a id="ch02lvl2sec41"/>
 Interoperation with unmanaged code</h2>
</div>
</div>
</div>
<p>When it comes to these infrequent cases of interoperation with legacy code or the use of libraries written in C/C++, F# follows C# using 
<strong>P/Invoke</strong>

 or 
<strong>COM Interop</strong>

 .</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>
 Intrinsic F# language features</h1>
</div>
</div>
</div>
<p>Along with features inherited from F# predecessors, the F# language carries its own set of notable novel facilities. The outline of these facilities is discussed in the upcoming sections.</p>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch02lvl2sec42"/>
 Indentation-aware syntax</h2>
</div>
</div>
</div>
<p>Yes, this is correct; the F# compiler is sensitive to indentation in the source code (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233191.aspx">https://msdn.microsoft.com/en-us/library/dd233191.aspx</a>
 ), so correct code formatting is not just a matter of aesthetics. Why? Firstly, the improved code readability is enforced by the compiler, and secondly, this design choice dramatically decreases the amount of noise in the F# source code as block markers (such as curly brackets in C#) do not present, overall making the F# source code significantly shorter than the equivalent C# one.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch02lvl2sec43"/>
 Units of measure</h2>
</div>
</div>
</div>
<p>This feature (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233243.aspx">https://msdn.microsoft.com/en-us/library/dd233243.aspx</a>
 ) allows you to decorate values with associated units and statically validate unit usage correctness by the compiler as well as infer units associated with the expression value based on units of operands. Let us look at the following example.</p>
<p>Here, I have defined two measures: <code class="literal">&lt;m&gt;</code>
 meters for distance and <code class="literal">&lt;s&gt;</code>
 seconds for time. Knowing how to find speed from acceleration and distance from physics, I defined a <code class="literal">fallSpeed</code>
 function to find the speed of objects falling from the given argument <code class="literal">height</code>
 at the time of hitting the ground as shown in the following code (<code class="literal">Ch2_1.fsx</code>
 ):</p>
<pre class="programlisting">[&lt;Measure&gt;] type &lt;m&gt; // meters 
[&lt;Measure&gt;] type &lt;s&gt; // seconds 
let fallSpeed (height: float&lt;m&gt;) = 
  2.0 * height * 9.81&lt;m/s^2&gt; |&gt; sqrt 
</pre>
<p>Now using this function, it is easy to find that a water bottle that accidentally dropped from the top of the Empire State Building hit the pavement of 5th Avenue in New York City with a speed of 86.46 meters per second (<code class="literal">&lt;m/s&gt;</code>
 ), hopefully not hurting a random bystander from the tourist crowd hanging out near the entrance.The following code represents the preceding example:</p>
<pre class="programlisting">let empireStateBuilding = 381.0&lt;m&gt; 
fallSpeed empireStateBuilding 
</pre>
<p>Note that the compiler will not allow anything but float decorated with <code class="literal">&lt;m&gt;</code>
 as the argument for <code class="literal">fallSpeed</code>
 . Also, the function correctly infers that units of measure for the resulting speed are meters per second. Neat, right? But seriously, consider this CNN article back from 1999 titled 
<em>Metric mishap caused loss of NASA orbiter</em>

 (<a class="ulink" href="http://www.cnn.com/TECH/space/9909/30/mars.metric.02/">http://www.cnn.com/TECH/space/9909/30/mars.metric.02/</a>
 ). The $125 million loss of satellite would not occur if units of measure checks were in place. Unfortunately, NASA and Lockheed Martin software systems used for the satellite flight control were operating each in its own system of measures and integration tests failed to discover this defect prior to the actual flight beginning.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch02lvl2sec44"/>
 Overloaded operators</h2>
</div>
</div>
</div>
<p>F# allows the overloading (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233204.aspx">https://msdn.microsoft.com/en-us/library/dd233204.aspx</a>
 ) of the existing operators as well as creating new unary and infix operators. It allows providing multiplicity of implementations for unary (prefix) and infix operations based on concrete types of operands. For example, an implementation of rational fractions arithmetic may use three versions of addition operation represented by infix operator <code class="literal">+</code>
 applicable to adding fraction to integer, integer to fraction, and fraction to fraction. Overloading has a positive side allowing to express semantic of manipulating objects of some domain tersely. But this feature is good in moderation as excessive overloading may be detrimental to code readability.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_4"><a id="ch02lvl2sec45"/>
 Inline Functions</h2>
</div>
</div>
</div>
<p>Inline functions (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd548047.aspx">https://msdn.microsoft.com/en-us/library/dd548047.aspx</a>
 ) represent a specific compilation technique. Normally a compiled function with non-generic type of arguments is associated with a single piece of MSIL and each function reference is compiled into invocation of this code and receiving back the evaluated result. However, it is impossible to have compiled MSIL for generic arguments within .NET type system. F# offers a smart workaround by statically evaluating arguments of each specific function invocation and creating MSIL adjusted for non-generic argument types of this particular function invocation. By following the outlined technique F# achieves function argument generalization under very limited support from .NET type system.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_5"><a id="ch02lvl2sec46"/>
 Type constraints and statically resolved type parameters</h2>
</div>
</div>
</div>
<p>It is sufficient to have genuinely generic function type arguments in only very limited number of design and implementation situations . Usually, the addition of a custom combination of distinctive additional properties of the argument type is required in order to give the F# compiler a way of statically checking whether the type generalization is specific enough for the task. In most such cases, type inference is smart enough to derive such constraining from the static context, but sometimes, it may be desired that the developer provide some extra constraining. The process and further details of supplying the additional static constraints is described by the link: <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233203.aspx">https://msdn.microsoft.com/en-us/library/dd233203.aspx</a>
 . The book puts this matter under scrutiny in <a class="link" title="Chapter 10. Type Augmentation and Generic Computations" href="text00071.html#ch10">Chapter 10</a>
 , 
<em>Type Augmentation and Generic Computations</em>

 .</p>
</div>
<div><div><div><div><h2 class="title" id="toc_6"><a id="ch02lvl2sec47"/>
 Active Patterns</h2>
</div>
</div>
</div>
<p>Active patterns (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233248.aspx">https://msdn.microsoft.com/en-us/library/dd233248.aspx</a>
 ) tremendously amplify the power of pattern matching by allowing the usage of custom functions within pattern matching rules. In other words, pattern matching can be specialized for any desired level of sophistication. Active patterns are absolutely essential for mastery over F#, and I will devote a lot of attention to them in the following chapters.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_7"><a id="ch02lvl2sec48"/>
 Computation Expressions</h2>
</div>
</div>
</div>
<p>Computation expressions (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233182.aspx">https://msdn.microsoft.com/en-us/library/dd233182.aspx</a>
 ) represent quite an advanced topic. They provide tools for representation of complex nested computations sequenced and bound with simple looking syntax sugar. Some of F# language's very own features are implemented with the help of computation expressions, namely sequence expressions, query expressions, and asynchronous computations. F# also allows you to write custom computation expressions, providing tremendous extensibility power.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_8"><a id="ch02lvl2sec49"/>
 Query Expressions</h2>
</div>
</div>
</div>
<p>Query expressions (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh225374.aspx">https://msdn.microsoft.com/en-us/library/hh225374.aspx</a>
 ) represent the language-provided form of computation expressions addressing language integrated queries, also known as LINQ in F#. They are a part of mechanics addressing the information rich programming I've mentioned earlier, allowing data consumed from the multiplicity of sources and in the multiplicity of forms to be manipulated uniformly. For example, data obtained off OData service, web service defined with WSDL, or SQL server can be transformed to a certain extent without taking into consideration the specifics of their origin.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_9"><a id="ch02lvl2sec50"/>
 Asynchronous workflows</h2>
</div>
</div>
</div>
<p>Asynchronous workflows (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233250.aspx">https://msdn.microsoft.com/en-us/library/dd233250.aspx</a>
 ) in F# are presented, in a manner similar to query expressions, by a language-provided form of computation expressions, and they demonstrate the mechanism's power and universal nature. They allow you to execute asynchronous code against implicitly provided thread pool at a high level of abstraction from asynchronous computations' arrangement details. As a corollary, writing F# asynchronous code is almost as simple as synchronous code.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_10"><a id="ch02lvl2sec51"/>
 Meta-programming</h2>
</div>
</div>
</div>
<p>Meta-programming (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233212.aspx">https://msdn.microsoft.com/en-us/library/dd233212.aspx</a>
 ) is an extremely powerful and exciting technique that allows programs to write other programs. It may take different forms and occur at different levels: at native machine-level code, at MSIL level, or even at the source code level of F# or another programming language. A few years ago, I was quite excited about this feature and blogged a short series on this matter: 
<strong>F# Metaprogramming part 1: JIT Some Native Code on the Fly</strong>

 (<a class="ulink" href="https://infsharpmajor.wordpress.com/2012/03/04/how-hard-is-to-jit-some-native-code-from-f/">https://infsharpmajor.wordpress.com/2012/03/04/how-hard-is-to-jit-some-native-code-from-f/</a>
 ), 
<strong>F# Metaprogramming part 2: Dynamic synthesis of executable F# code</strong>

 (<a class="ulink" href="https://infsharpmajor.wordpress.com/2012/04/01/how-to-dynamically-synthesize-executable-f-code-from-text/">https://infsharpmajor.wordpress.com/2012/04/01/how-to-dynamically-synthesize-executable-f-code-from-text/</a>
 ), and 
<strong>F# Metaprogramming part 3: Creating MSIL on the Fly</strong>

 (<a class="ulink" href="https://infsharpmajor.wordpress.com/2012/04/12/creating-msil-from-f-on-the-fly/">https://infsharpmajor.wordpress.com/2012/04/12/creating-msil-from-f-on-the-fly/</a>
 ).</p>
<p>However, usually, when developers consider F# meta-programming, a different program level is involved, namely F#, but in a partially compiled form associated with the language feature known as 
<strong>quoted expressions</strong>

 . When the F# compiler comes across specifically delimited F# code, then instead of making this code part of the program, it compiles it into a special object representing the F# expression. The great power of this feature is that when compiled in this manner, F# expressions can be further transformed into the form that's good for execution in a completely different environment, for example, inside a web browser in the form of JavaScript or in some 
<strong>Graphic</strong>

 
<strong>Processing </strong>

 
<strong>Unit</strong>

 (
<strong>GPU</strong>

 ), reaching, in principle, a vast amount of diverse computational platforms.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_11"><a id="ch02lvl2sec52"/>
 Type providers</h2>
</div>
</div>
</div>
<p>Type providers (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh156509.aspx">https://msdn.microsoft.com/en-us/library/hh156509.aspx</a>
 ) represent the meta-programming feature as well. However, instead of transforming some form of source code into executable form type providers does something completely different. A typical type provider represents a data source of certain kind as an assortment of types with their methods and properties ready to be seamlessly used exactly the same way as human-written types or libraries. It's worth noting that the provided types carry the same qualities as the hand-written ones. They can be statically checked, introspected by Intellisense, inferred by F# compiler.</p>
<p>For example, the SqlClient type provider (<a class="ulink" href="http://fsprojects.github.io/FSharp.Data.SqlClient/">http://fsprojects.github.io/FSharp.Data.SqlClient/</a>
 ) allows F# developers to get type-safe access to the complete set of features of the Microsoft SQL server.</p>
<p>Another fantastically powerful use case for type providers is the interoperability between F# and other programming languages. One of the big successes in this field is F# R Type Provider (<a class="ulink" href="http://bluemountaincapital.github.io/FSharpRProvider/">http://bluemountaincapital.github.io/FSharpRProvider/</a>
 ), allowing access from F# to a vast amount of R programming language libraries for statistical computing. Using F# in tandem with 
<strong>R Type Provider</strong>

 gave a big boost to using F# in the fields of machine learning and data science.</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>
 Summary</h1>
</div>
</div>
</div>
<p>This chapter familiarized you with F# features dissected according to origins and design motives. You now better understand where the each language feature comes from, what features come from the ML breed, what language design decisions are dictated by the hosting .NET platform, what features of F# are unique, and what the causes for their inclusion into the language were.</p>
<p>Equipped with this knowledge, you are now ready to absorb the main contents. In the next chapter, I'll turn to the feature at the core of F#: functions and their uses.</p>
</div>
</body></html>