<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-69"><em class="italic"><a id="_idTextAnchor124"/>Chapter 8</em>: Writing Custom Middleware</h1>
			<p>Wow, we are already onto the eighth chapter of this book! In this chapter, we will learn about <strong class="bold">middleware</strong> and how you can use it to customize your app a little more. We will quickly go over the basics of middleware and then we'll explore some special things you can do with it.</p>
			<p>In this chapter, we'll cover the following topics:</p>
			<ul>
				<li>Introducing middleware</li>
				<li>Writing custom middleware</li>
				<li>Exploring the potential of middleware</li>
				<li>Using middleware on ASP.NET Core 3.0 and later</li>
			</ul>
			<p>The topics covered in this chapter relate to the middleware layer of the ASP.NET Core architecture:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_8.1_B17996.jpg" alt="Figure 8.1 – The ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor125"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. To do this, open your console, shell, or Bash terminal, and change to your working directory. Then, use the following command to create a new MVC application:</p>
			<p class="source-code">dotnet new web -n MiddlewaresSample -o MiddlewaresSample</p>
			<p>Now, open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code by typing the following command in the already-open console:</p>
			<p class="source-code">cd MiddlewaresSample</p>
			<p class="source-code">code .</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The simple <strong class="source-inline">web</strong> project template changed in .NET 6.0. In version 6.0, Microsoft introduced <strong class="bold">minimal APIs</strong> and changed the project template to use the minimal API approach. This is a simpler way to bootstrap and to get started with a web application.</p>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08</a>.</p>
			<h1 id="_idParaDest-71">I<a id="_idTextAnchor126"/><a id="_idTextAnchor127"/>ntroducing middleware</h1>
			<p>The majority of you probably already know what middleware is, but some of you might not. Even if you <a id="_idIndexMarker103"/>have already been using ASP.NET Core for a while, you don't really need to know about middleware instances in detail, as they are mostly hidden behind nicely named extension methods such as <strong class="source-inline">UseMvc()</strong>, <strong class="source-inline">UseAuthentication()</strong>, <strong class="source-inline">UseDeveloperExceptionPage()</strong>, and so on. Every time you call a <strong class="source-inline">Use</strong> method in the <strong class="source-inline">Startup.cs</strong> file, in the <strong class="source-inline">Configure</strong> method, you'll implicitly use at least one – or maybe more – middleware components.</p>
			<p>A middleware component is a piece of code that handles the request pipeline. Imagine the request pipeline as a huge tube where you can call something and then an echo comes back. The middleware is responsible for the creation of this echo – it manipulates the sound to enrich the information, handling the source sound, or handling the echo.</p>
			<p>Middleware components are executed in the order in which they are configured. The first middleware component configured is the first that gets executed.</p>
			<p>In an ASP.NET Core web application, if the client requests an image or any other static file, <strong class="source-inline">StaticFileMiddleware</strong> searches for that resource and returns that resource if it finds it. If not, this middleware component does nothing except call the next one. If there is no final <a id="_idIndexMarker104"/>piece of middleware that handles the request pipeline, the request returns nothing. The <strong class="source-inline">MvcMiddleware</strong> component also checks the requested resource, tries to map it to a configured route, executes the controller, creates a view, and returns an HTML or web API result. If <strong class="source-inline">MvcMiddleware</strong> does not find a matching controller, it will return a result anyway – in this case, it is a <strong class="source-inline">404</strong> status result. So, in any case, it returns an echo. This is why <strong class="source-inline">MvcMiddleware</strong> is the last piece of middleware configured.</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_8.2_B17996.jpg" alt="Figure 8.2 – A middleware workflow diagram"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – A middleware workflow diagram</p>
			<p><strong class="bold">Exception-handling</strong> middleware is usually one of the first pieces of middleware configured, not <a id="_idIndexMarker105"/>because it is the first to be executed, but because it is the last. The first middleware component configured is also the last one to be executed if the echo comes back from the tube. Exception-handling middleware validates the result and displays a possible exception in a browser in a client-friendly way. The following process describes where a runtime error gets a <strong class="source-inline">500</strong> status:</p>
			<ol>
				<li>You are <a id="_idIndexMarker106"/>able to see how the pipeline is executed if you create an empty ASP.NET Core application, as described in the <em class="italic">Technical requirements</em> section.</li>
				<li>Open <strong class="source-inline">Program.cs</strong> with your favorite editor. This should be pretty small compared to a regular ASP.NET Core application. In ASP.NET Core 6.0, Microsoft introduced the minimal API approach, which simplifies the application configuration and hides a lot of default configuration from the developers. Microsoft is also implementing default <strong class="source-inline">using</strong> statements in ASP.NET Core. Because of this, you don't see any <strong class="source-inline">using</strong> statements initially. This is how <strong class="source-inline">Program.cs</strong> looks in ASP.NET Core 6.0:<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">var app = builder.Build();</p><p class="source-code">app.MapGet("/", () =&gt; "Hello World!");</p><p class="source-code">app.Run()<a id="_idTextAnchor128"/>;</p><p>Here, special lambda middleware is bound to the default route and only writes <strong class="source-inline">"Hello World!"</strong> to the response stream. The response stream is the echo we learned about previously. This special middleware stops the pipeline and returns something like an echo. So, it is the last middleware to run.</p></li>
				<li>Replace the line with the call of <strong class="source-inline">app.MapGet()</strong> with the following lines of code, right before the <strong class="source-inline">app.Run()</strong> function:<p class="source-code">app.Use(async (context, next) =&gt;{</p><p class="source-code">    await context.Response.WriteAsync("===");</p><p class="source-code">    await next();</p><p class="source-code">    await context.Response.WriteAsync("===");</p><p class="source-code">});</p><p class="source-code">app.Use(async (context, next) =&gt;</p><p class="source-code">{</p><p class="source-code">    await context.Response.WriteAsync("&gt;&gt;&gt;&gt;&gt;&gt; ");</p><p class="source-code">    await next();</p><p class="source-code">    await context.Response.WriteAsync(" &lt;&lt;&lt;&lt;&lt;&lt;");</p><p class="source-code">});</p><p class="source-code">app.Run(async context =&gt;</p><p class="source-code">{</p><p class="source-code">    await context.Response.WriteAsync("Hello World!");</p><p class="source-code">});</p><p>These two <a id="_idIndexMarker107"/>calls of <strong class="source-inline">app.Use()</strong> also create two lambda middlewares, but this time, in addition to dealing with specific requests, the middleware components are calling their successors: each middleware component knows which middleware component should follow it, and so calls it. The call of <strong class="source-inline">app.Run()</strong> replaces the call of <strong class="source-inline">app.MapGet()</strong>, but it does basically the same thing, except that <strong class="source-inline">app.Run()</strong> directly writes to the response stream. The lambda middlewares created with <strong class="source-inline">app.Use()</strong> write to the response stream before and after the next middleware is called. Before the next middleware is called, the actual request is handled, and after the next middleware is called, the response (echo) is handled. This should demonstrate how the pipeline works.</p></li>
				<li>If you now run the application (using <strong class="source-inline">dotnet run</strong>) and open the displayed URL in the browser, you should see a plain text result like this:<p class="source-code">===&gt;&gt;&gt;&gt;&gt;&gt; Hello World! &lt;&lt;&lt;&lt;&lt;&lt;===</p></li>
			</ol>
			<p>Does this <a id="_idIndexMarker108"/>make sense to you? If yes, let's move on and see how to use this concept to add some additional functionality to the request pipeli<a id="_idTextAnchor129"/><a id="_idTextAnchor130"/>ne.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor131"/>Writing custom middleware</h1>
			<p>ASP.NET Core is based on middleware. All the logic that gets executed during a request is based <a id="_idIndexMarker109"/>on middleware. So, we can use this to add custom functionality to the web. In the following process, we want to find out the execution time of every request that goes through the request pipeline:</p>
			<ol>
				<li value="1">We can do this by creating and starting a stopwatch before the next middleware is called, and stop measuring the execution time after the next middleware is called, like so:<p class="source-code">app.Use(async (context, next) =&gt;</p><p class="source-code">{</p><p class="source-code">    var s = new Stopwatch();</p><p class="source-code">    s.Start();</p><p class="source-code">    // execute the rest of the pipeline</p><p class="source-code">    await next();</p><p class="source-code">    s.Stop(); //stop measuring</p><p class="source-code">    var result = s.ElapsedMilliseconds;</p><p class="source-code">    // write out the milliseconds needed</p><p class="source-code">    await context.Response.WriteAsync($" Time needed: </p><p class="source-code">      {result} milliseconds");</p><p class="source-code">});</p><p>You might need to add a <strong class="source-inline">using</strong> statement for <strong class="source-inline">System.Diagnostics</strong>.</p><p>After that, we return the elapsed milliseconds to the response stream.</p></li>
				<li>If you <a id="_idIndexMarker110"/>write some more middleware components, the configuration in <strong class="source-inline">Program.cs</strong> gets pretty messy. This is why most middleware components are written as separate classes. This could look like this:<p class="source-code">using System.Diagnostics;</p><p class="source-code">public class StopwatchMiddleware</p><p class="source-code">{</p><p class="source-code">    private readonly RequestDelegate _next;</p><p class="source-code">    public StopwatchMiddleware(RequestDelegate next)</p><p class="source-code">    {</p><p class="source-code">        _next = next;</p><p class="source-code">    }</p><p class="source-code">    public async Task Invoke(HttpContext context)</p><p class="source-code">    {</p><p class="source-code">        var s = new Stopwatch();</p><p class="source-code">        s.Start();</p><p class="source-code">        // execute the rest of the pipeline</p><p class="source-code">        await _next(context);</p><p class="source-code">        s.Stop(); //stop measuring</p><p class="source-code">        var result = s.ElapsedMilliseconds;</p><p class="source-code">        // write out the milliseconds needed</p><p class="source-code">        await context.Response.WriteAsync($" Time </p><p class="source-code">          needed: {result} milliseconds");</p><p class="source-code">    }</p><p class="source-code">}</p><p>This way, we <a id="_idIndexMarker111"/>get the next middleware component to execute via the constructor and the current context in the <strong class="source-inline">Invoke()</strong> method.</p><p class="callout-heading">Note</p><p class="callout">The middleware is initialized at the start of the application and the constructor runs only once during the application lifetime. On the other hand, the <strong class="source-inline">Invoke()</strong> method is called once per request.</p></li>
				<li>To use this middleware, there is a generic <strong class="source-inline">UseMiddleware()</strong> method available that you can use:<p class="source-code">app.UseMiddleware&lt;StopwatchMiddleware&gt;();</p></li>
				<li>However, the more elegant way is to create an <strong class="source-inline">extension</strong> method that encapsulates this call:<p class="source-code">public static class StopwatchMiddlewareExtension</p><p class="source-code">{</p><p class="source-code">    public static IApplicationBuilder </p><p class="source-code">      UseStopwatch(this IApplicationBuilder app)</p><p class="source-code">    {</p><p class="source-code">        app.UseMiddleware&lt;StopwatchMiddleware&gt;();</p><p class="source-code">        return app;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, you can simply call it like this:<p class="source-code">app.UseStopwatch();</p></li>
			</ol>
			<p>This way, you can provide additional functionality to an ASP.NET Core application through the <a id="_idIndexMarker112"/>request pipeline. You have the entire <strong class="source-inline">HttpContext</strong> available in your middleware. With this, you can manipulate the request or even the response using middleware.</p>
			<p>For example, <strong class="source-inline">AuthenticationMiddleware</strong> tries to collect user information from the request. If it doesn't find any, it will ask for the information by sending a specific response back to the client. If it finds some information, it will add it to the request context and make it available to the entire application th<a id="_idTextAnchor132"/><a id="_idTextAnchor133"/>is way.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor134"/>Exploring the potential of middleware</h1>
			<p>There are <a id="_idIndexMarker113"/>many other things you can do with middleware. For example, did you know that you can split the request pipeline into two or more pipelines? We'll look at how to do that and several other things in this section.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor135"/>Branching the pipeline with /map</h2>
			<p>The next <a id="_idIndexMarker114"/>code snippet shows how to create branches of the request pipeline based on specific paths:</p>
			<p class="source-code">app.Map("/map1", app1 =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    // some more Middleware</p>
			<p class="source-code">    app1.Run(async context =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        await context.Response.WriteAsync("Map Test 1");</p>
			<p class="source-code">    });</p>
			<p class="source-code">});</p>
			<p class="source-code">app.Map("/map2", app2 =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    // some more Middleware</p>
			<p class="source-code">    app2.Run(async context =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        await context.Response.WriteAsync("Map Test 2");</p>
			<p class="source-code">    });</p>
			<p class="source-code">});</p>
			<p class="source-code">// some more Middleware</p>
			<p>The <strong class="source-inline">/map1</strong> path is <a id="_idIndexMarker115"/>a specific branch that continues the request pipeline inside – this is the same with the <strong class="source-inline">/map2</strong> path. Both maps have their own middleware configurations inside. All other unspecified paths will follow the main branch.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor136"/>Branching the pipeline with MapWhen()</h2>
			<p>There is <a id="_idIndexMarker116"/>also a <strong class="source-inline">MapWhen()</strong> method to branch the pipeline based on a condition, instead of a branch based on a path:</p>
			<p class="source-code">public void Configure(IApplicationBuilder app)</p>
			<p class="source-code">{</p>
			<p class="source-code">    app.MapWhen(</p>
			<p class="source-code">        context =&gt; </p>
			<p class="source-code">          context.Request.Query.ContainsKey("branch"),</p>
			<p class="source-code">        app1 =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // some more Middleware</p>
			<p class="source-code">            app1.Run(async context =&gt;</p>
			<p class="source-code">            {</p>
			<p class="source-code">                await context.Response.WriteAsync(</p>
			<p class="source-code">                    "MapBranch Test");</p>
			<p class="source-code">            });</p>
			<p class="source-code">    });</p>
			<p class="source-code">    // some more Middleware</p>
			<p class="source-code">    app.Run(async context =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        await context.Response.WriteAsync(</p>
			<p class="source-code">            "Hello from non-Map delegate.");</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p>Next, we'll <a id="_idIndexMarker117"/>look at using middleware to create conditions.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor137"/>Creating conditions with middleware</h2>
			<p>You can create conditions based on configuration values or, as shown here, based on properties <a id="_idIndexMarker118"/>of the request context. In the previous example, a query string property was used. You can use HTTP headers, form properties, or any other property of the request context.</p>
			<p>You are also able to nest the maps to create child and grandchild branches if needed.</p>
			<p>We can use <strong class="source-inline">Map()</strong> or <strong class="source-inline">MapWhen()</strong> to provide a special API or resource based on a specific path or a specific condition, respectively. The ASP.NET Core <strong class="source-inline">HealthCheck</strong> API works like this: first, it uses <strong class="source-inline">MapWhen()</strong> to specify the port to use, and then, it uses <strong class="source-inline">Map()</strong> to set the path for the <strong class="source-inline">HealthCheck</strong> API (or, it uses <strong class="source-inline">Map()</strong> if no port is specified). In the end, <strong class="source-inline">HealthCheckMiddleware</strong> is used. The following code is just an example to show what this looks like:</p>
			<p class="source-code">private static void UseHealthChecksCore(IApplicationBuilder </p>
			<p class="source-code">  app, PathString path, int? port, object[] args)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (port == null)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        app.Map(path, </p>
			<p class="source-code">            b =&gt; </p>
			<p class="source-code">             b.UseMiddleware&lt;HealthCheckMiddleware&gt;(args));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        app.MapWhen(</p>
			<p class="source-code">            c =&gt; c.Connection.LocalPort == port,</p>
			<p class="source-code">            b0 =&gt; b0.Map(path, </p>
			<p class="source-code">            b1 =&gt; </p>
			<p class="source-code">              b1.UseMiddleware&lt;HealthCheckMiddleware&gt;(args)</p>
			<p class="source-code">            )</p>
			<p class="source-code">        );</p>
			<p class="source-code">    };</p>
			<p class="source-code">}</p>
			<p>Next, let's <a id="_idIndexMarker119"/>see how you should use terminating middleware components in newer versions of ASP.NET Core.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor138"/>Using middleware in ASP.NET Core 3.0 and later</h1>
			<p>In ASP.NET <a id="_idIndexMarker120"/>Core 3.0 and later, there are two <a id="_idIndexMarker121"/>new kinds <a id="_idIndexMarker122"/>of middleware element, and they are called <strong class="source-inline">UseRouting</strong> and <strong class="source-inline">UseEndpoints</strong>:</p>
			<p class="source-code">public void Configure(IApplicationBuilder app, </p>
			<p class="source-code">  IWebHostEnvironment env)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (env.IsDevelopment())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        app.UseDeveloperExceptionPage();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    app.UseRouting();</p>
			<p class="source-code">    app.UseEndpoints(endpoints =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        endpoints.MapGet("/", async context =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">           await context.Response.WriteAsync("Hello </p>
			<p class="source-code">                                              World!");</p>
			<p class="source-code">  <a id="_idTextAnchor139"/>      });</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p>The first <a id="_idIndexMarker123"/>one is a middleware component that uses routing and the other one uses endpoints. So, what exactly are we looking at?</p>
			<p>This is <a id="_idIndexMarker124"/>the new <strong class="bold">endpoint routing</strong>. Previously, routing was part of MVC, and it only worked with MVC, web APIs, and frameworks that are based on the MVC framework. In ASP.NET Core 3.0 and later, however, routing is no longer in the MVC framework. Now, MVC and the other frameworks are mapped to a specific route or endpoint. There are different kinds of endpoint definitions available.</p>
			<p>In the preceding code snippet, a <strong class="source-inline">GET</strong> request is mapped to the page root URL. In the next code snippet, MVC is <a id="_idIndexMarker125"/>mapped to a route pattern, and <strong class="bold">Razor Pages</strong> are mapped to the Razor Pages-specific file structure-based routes:</p>
			<p class="source-code">app.UseEndpoints(endpoints =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    endpoints.MapControllerRoute(</p>
			<p class="source-code">        name: "default",</p>
			<p class="source-code">        pattern: "{controller=Home}/{action=Index}/{id?}");</p>
			<p class="source-code">    endpoints.MapRazorPages();</p>
			<p class="source-code">});</p>
			<p>There is no <strong class="source-inline">UseMvc()</strong> method anymore, even if it still exists and works on the <strong class="source-inline">IApplicationBuilder</strong> object level, to prevent the existing code from breaking. Now, there are new methods to activate ASP.NET Core features more granularly.</p>
			<p>These are <a id="_idIndexMarker126"/>the most commonly used new <strong class="source-inline">Map</strong> methods for ASP.NET Core 5.0 or later:</p>
			<ul>
				<li><strong class="bold">Areas for MVC and web API</strong>: <strong class="source-inline">endpoints.MapAreaControllerRoute(...);</strong></li>
				<li><strong class="bold">MVC and web API</strong>: <strong class="source-inline">endpoints.MapControllerRoute(...);</strong></li>
				<li><strong class="bold">Blazor server-side</strong>: <strong class="source-inline">endpoints.MapBlazorHub(...);</strong></li>
				<li><strong class="bold">SignalR</strong>: <strong class="source-inline">endpoints.MapHub(...);</strong></li>
				<li><strong class="bold">Razor Pages</strong>: <strong class="source-inline">endpoints.MapRazorPages(...);</strong></li>
				<li><strong class="bold">Health checks</strong>: <strong class="source-inline">endpoints.MapHealthChecks(...);</strong></li>
			</ul>
			<p>There are many more methods to define fallback endpoints, to map routes and HTTP methods to delegates, and for middleware components.</p>
			<p>If you <a id="_idIndexMarker127"/>want to create middleware that works on all requests, such as <strong class="source-inline">StopWatchMiddleware</strong>, this will work as before on <strong class="source-inline">IApplicationBuilder</strong>. If you would like to write middleware to work on a specific path or route, you will need to create a <strong class="source-inline">Map</strong> method for it to map it to that route.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It is no longer recommended to handle the route inside the middleware. Instead, you should use the new endpoint routing. With this approach, the middleware is a lot more generic, and it will work on multiple routes with a single configuration.</p>
			<p>I recently wrote middleware to provide a <strong class="bold">GraphQL</strong> endpoint in an ASP.NET Core application. However, I had to rewrite it to follow the new ASP.NET Core routing. The old way would still have worked, but it would have handled the paths and routes separately from the new ASP.NET Core routing. Let's look at how to deal with those situations.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor140"/>Rewriting terminating middleware to meet the current standards</h2>
			<p>If you <a id="_idIndexMarker128"/>have existing middleware that provides a different endpoint, you should change it to use the new endpoint routing:</p>
			<ol>
				<li value="1">As an example, let's create small, dummy middleware that writes an application status to a specific route. In this example, there is no custom route handling:<p class="source-code">namespace MiddlewaresSample;</p><p class="source-code">public class AppStatusMiddleware</p><p class="source-code">{</p><p class="source-code">    private readonly RequestDelegate _next;</p><p class="source-code">    private readonly string _status;</p><p class="source-code">    public AppStatusMiddleware(</p><p class="source-code">        RequestDelegate next, string status)</p><p class="source-code">    {</p><p class="source-code">        _next = next;</p><p class="source-code">        _status = status;</p><p class="source-code">    }</p><p class="source-code">    public async Task Invoke(HttpContext context)</p><p class="source-code">    {</p><p class="source-code">        await context.Response.WriteAsync(</p><p class="source-code">            $"Hello {_status}!");</p><p class="source-code">    }</p><p class="source-code">}</p><p>The first thing we need to do is write an <strong class="source-inline">extension</strong> method on the <strong class="source-inline">IEndpointRouteBuilder</strong> object. This method has a route pattern as an optional argument <a id="_idIndexMarker129"/>and returns an <strong class="source-inline">IEndpointConventionBuilder</strong> object to enable <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>), authentication, or other conditions to the route.</p></li>
				<li>Now, we <a id="_idIndexMarker130"/>should add an extension method to make it easier to use the middleware:<p class="source-code">public static class MapAppStatusMiddlewareExtension</p><p class="source-code">{</p><p class="source-code">    public static IEndpointConventionBuilder </p><p class="source-code">      MapAppStatus(</p><p class="source-code">        this IEndpointRouteBuilder routes,</p><p class="source-code">        string pattern = "/", </p><p class="source-code">        string name = "World")</p><p class="source-code">    {</p><p class="source-code">        var pipeline = routes</p><p class="source-code">            .CreateApplicationBuilder()</p><p class="source-code">            .UseMiddleware&lt;AppStatusMiddleware&gt;(name)</p><p class="source-code">            .Build();</p><p class="source-code">        return routes.Map(pattern, pipeline)</p><p class="source-code">            .WithDisplayName("AppStatusMiddleware");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Once that is complete, we can use the <strong class="source-inline">MapAppStatus</strong> method to map it to a specific route:<p class="source-code">app.UseRouting();</p><p class="source-code">app.UseEndpoints(endpoints =&gt;</p><p class="source-code">{</p><p class="source-code">    endpoints.MapGet("/", () =&gt; "Hello World!");</p><p class="source-code">    endpoints.MapAppStatus("/status", "Status");</p><p class="source-code">});</p></li>
				<li>We can <a id="_idIndexMarker131"/>now call the route in the browser by entering the following address: <strong class="source-inline">http://localhost:5000/status</strong>.</li>
			</ol>
			<p>We will learn more about endpoint routing and how to customize it in <a href="B17996_09_ePub.xhtml#_idTextAnchor143"><em class="italic">Chapter 9</em></a>, <em class="italic">Working with Endpoint Routing</em>. For now, let's recap what we've<a id="_idTextAnchor141"/> learned about middleware.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor142"/>Summary</h1>
			<p>Most of the ASP.NET Core features are based on middleware and in this chapter, you learned how middleware works and how to create your own middleware components to extend the ASP.NET framework. You also learned how to use the new routing to add routes to your own custom terminating middleware components.</p>
			<p>In the next chapter, we will have a look at the new endpoint routing in ASP.NET Core, which allows you to create your own hosted endpoints in an easy and flexible way.</p>
		</div>
	</body></html>