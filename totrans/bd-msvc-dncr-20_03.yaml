- en: Integration Techniques and Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we developed microservices using a .NET monolithic
    application. These services are independent of each other and are located on different
    servers. What would be a better way to have inter-service communication, where
    one service interacts/communicates with the other? In this chapter, we will discuss
    the various patterns and methods that will help us foster this communication.
    We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Communication between services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles of collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event-driven pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of a .NET monolithic application, if there is a need to access third-party
    components or external services, we use the HTTP client or another client framework
    to access the resources. In[Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml),
    *Implementing Microservices*, we developed the **Product service** in such a way
    that it would work independently. But this was not the case; we mandatorily required
    a few services to interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: So this is a challenge—having services communicate with each other. Both the **Product
    service** and **Order service** are hosted on separate servers. Both these servers
    are independent of each other, are based on **REST**, and have their own endpoints
    via which they communicate with each other (when a service interacts with another
    service and vice versa, we refer to it as an inter-service communication as well).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are ways in which services communicate with each other; let''s discuss
    them briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Synchronous: In this case, the client makes a request to the remote service
    (called a **service**) for a specific functionality and waits until it gets the
    response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/296fffe7-bfbc-4fc5-9f22-def20a1251a3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram (pictorial view, not complete), you can see our different
    microservices communicate with each other. All our services are RESTful. They
    are based on the ASP.NET Core Web API. In the upcoming section, we will discuss
    in detail how exactly a service is called. This is known as the synchronous method,
    where clients have to wait for a response from the service. In this case, the
    client had to wait until it got a complete response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous: In this,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles of collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we discussed two different modes of how services
    intercommunicate. These modes are nothing but styles of collaborations, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Request/response: In this case, the client sends a request and waits for the
    response from the server. This is an implementation of synchronous communication.
    But it is not true that request/response is only an implementation of synchronous
    communication; we can use it for asynchronous communication as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider an example to understand the concept. In [Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml)*,* *Implementing
    Microservices*, we developed `ProductService`. This service has the `GetProduct` method,
    which is synchronous. The client has to wait for a response whenever it calls
    this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the preceding code snippet, whenever this method is called by the client
    (who is requesting this), they will have to wait for the response. In other words,
    they will have to wait until the `ToViewModel()` extension method is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we can see that our method is implemented in
    such a way that whenever a client makes a request, they will have to wait until
    the `async` method is executed. Here, we call `async` in the `sync` way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our code short, we added extension methods to the already existing
    code written in [Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml), *Implementing
    Microservices*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To sum up, we can say that the collaboration style request/response does not
    mean that it can be implemented only synchronously; we can use asynchronous calls
    for this as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event-based: The implementation of this collaborative style is purely asynchronous.
    This is a method of implementation in which clients that emit an event do not
    know exactly how to react.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding section, we discussed `ProductService` in a synchronous manner.
    Let''s look at an example of how users/customers can place an order; here is a pictorial
    overview of the functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/333b8129-c5f2-4f51-b29f-2a5b4119fac0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows that the process of purchasing a book has a few
    main functions:'
  prefs: []
  type: TYPE_NORMAL
- en: With the help of the search functionality, customers can find a specific book.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: After getting the results for the searched book, customers can view the details
    of the book.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as they proceed to **Checkout**, our system will make sure that the
    display (available books to purchase) shows the right quantity. For example, the available
    quantity is 10 copies of *Microservices for .NET* and the customer checks out
    with one book. In this case, the available quantity should now show nine copies.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The system will generate an invoice for the purchased book and send it to the customer,
    to their registered email.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conceptually, this looks easy; however, when we talk about implementing microservices,
    we are talking about services that are hosted separately and have their own REST
    API, database, and so on. This is now sounding more complex. There are many aspects
    involved, for example, how a service will call or invoke another service upon
    a successful response from one or more services. This is where the event-driven
    architecture comes into the picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1af219a-eae1-4041-8674-bbdc855c2f58.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see that **Invoice service** and **Product
    service** are triggered when **Order service** is executed. These services further
    call internal asynchronous methods to complete their functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: We are using Azure API management as our API gateway. In the upcoming sections,
    we will discuss this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Integration patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have discussed inter-service communication and have gone through
    the practical implementation of `ProductService` with the use of synchronous and
    asynchronous communication. We've also implemented microservices using different
    styles of collaboration. Our *FlixOne bookstore* (developed as per the microservice
    architectural style) required more interaction, therefore it required more patterns.
    In this section, we will discuss the implementation of various integration patterns
    required for our application.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application of the *FlixOne bookstore* is available in [Chapter
    10](bcd6e14a-bd2b-4964-94f4-dcf93cc9d756.xhtml)*, Creating a Complete Microservice
    Solution.*
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Styles of collaboration* section, we discussed two styles we can use
    to foster intercommunication between microservices. Our application is split into
    various microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Product service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoice service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our *FlixOne bookstore* (user interface), we need to show a few details:'
  prefs: []
  type: TYPE_NORMAL
- en: Book title, author name, price, discount, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book reviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book ratings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publisher ranking and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we check out the implementation, let's discuss the API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway is nothing but an implementation of **Backend For Frontend**
    (**BFF**). Sam Newman introduced this pattern. It acts as a proxy between client
    applications and services. In our example, we are using **Azure API management**
    as our API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is responsible for the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting API calls and routing them to your backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying API keys, JWT tokens, and certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting Auth through Azure AD and the OAuth 2.0 access token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing usage quotas and rate limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming your API on the fly without code modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching backend responses wherever they are set up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging call metadata for analytics purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to *Azure API management* ([https://social.technet.microsoft.com/wiki/contents/articles/31923.azure-create-and-deploy-asp-net-webapi-to-azure-and-manage-using-azure-api-management.aspx](https://social.technet.microsoft.com/wiki/contents/articles/31923.azure-create-and-deploy-asp-net-webapi-to-azure-and-manage-using-azure-api-management.aspx))
    to learn more about the process of setting up the API Azure portal and working
    with REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7725c9c9-fe57-4d71-922c-f772ab138148.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we have different clients, such as a mobile and desktop
    application and a web application, that are using microservices. Here, Azure API
    management is working as an API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Our client does not know the actual server in which our services are located.
    The API gateway provides them with the address of its own server, and internally,
    it authenticates the request from clients with the use of a valid `Ocp-Apim-Subscription-Key`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `ProductService` has a REST API. Refer to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API resource** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /api/product` | Gets a list of products |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /api/product{id}` | Gets a product |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT /api/product{id}` | Updates an existing product |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE /api/product{id}` | Deletes an existing product |'
  prefs: []
  type: TYPE_TB
- en: '| `POST /api/product` | Adds a new product |'
  prefs: []
  type: TYPE_TB
- en: 'We have already created `ProductClient`, a .NET console application. It makes
    a request to Azure API management bypassing the subscription key. Here is the
    code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, our client is requesting a REST API to get all the products.
    Here a brief description of the terms that appear in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `BaseUrl` | This is the address of the proxy server. |'
  prefs: []
  type: TYPE_TB
- en: '| `Ocp-Apim-Subscription-Key` | This is a key assigned by API management to
    a specific product the client has opted for. |'
  prefs: []
  type: TYPE_TB
- en: '| `Resource` | This is our API resource, which is configured over Azure API
    management. It will be different from our actual REST API resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `Response` | This refers to the response to a specific request, in our case
    the default JSON format. |'
  prefs: []
  type: TYPE_TB
- en: 'Since we''re using Azure API management as an API gateway, there are certain
    benefits we''ll enjoy:'
  prefs: []
  type: TYPE_NORMAL
- en: We can manage our various APIs from a single platform, for example, `ProductService`,
    `OrderService`, and other services can be easily managed and called by many clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we're using API management, it does not only provide us with a proxy
    server, but also provides the facility to create and maintain documentation for
    our APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a built-in facility to define various policies for quota, output
    formats, and format conversions, such as XML to JSON or vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, with the help of the API gateway, we can have access to some great features.
  prefs: []
  type: TYPE_NORMAL
- en: The event-driven pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The microservice architecture has the database per service pattern, which means
    it has an independent database for every dependent or independent service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependent service: Our application would require a few external services (third-
    party services or components, and so on) and/or internal services (these are our
    own services) to work or function as expected. For instance, **CHECKOUT-SERVICE** requires **CUSTOMER-SERVICE**;
    also, **CHECKOUT-SERVICE** requires an external (third-party) service to verify
    a customer''s identity (such as Aadhaar card ID in the case of Indian customers).
    Here, our **CHECKOUT-SERVICE** is a dependent service, as it requires two services (an
    internal service and external service) to function as expected. Dependent services
    do not work if any or all the services on which the service is dependent on do
    not work properly (there are a lot of reasons a service would not work, including
    network failure, unhandled exception, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Independent service: In our application, we have services that do not require
    any other service to work properly. Services that do not need any other service
    to work in order to function are called independent services; these services can
    be self-hosted. Our **CUSTOMER-SERVICE** does not require any other service to
    function properly, but other services may or may not require this service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main challenge is to maintain business transactions to ensure data consistency
    across these services. For instance, when and how **CUSTOMER-SERVICE** would know
    that **CHECKOUT-SERVICE** has functioned; now it requires the functionality of
    **CUSTOMER-SERVICE**. There may be several services in an application (services
    may be self-hosted). In our case, when **CHECKOUT-SERVICE** is triggered and **CUSTOMER-SERVICE** is
    not invoked, then how will our application identify the customer’s details?
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET WebHooks can also be used for providing event notifications; refer to
    the WebHooks documentation for more information.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the related problems/challenges we've discussed (for **CHECKOUT-SERVICE**
    and **CUSTOMER-SERVICE**), we can use an event-driven pattern (or the eventual
    consistency approach) and use distributed transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A document on MSDN ([https://msdn.microsoft.com/en-us/library/windows/desktop/ms681205(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681205(v=vs.85).aspx))
    says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A distributed transaction is a transaction that updates data on two or more
    networked computer systems. Distributed transactions extend the benefits of transactions
    to applications that must update distributed data. Implementing robust distributed
    applications is difficult because these applications are subject to multiple failures,
    including failure of the client, the server, and the network connection between
    the client and server. In the absence of distributed transactions, the application
    program itself must detect and recover from these failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes an actual implementation of the event-driven
    pattern in our application, where **PRODUCT-SERVICE** subscribes to the events
    and **Event-Manager** manages all the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa3994cc-83d1-4f0e-a417-5d72d06fe3f0.png)'
  prefs: []
  type: TYPE_IMG
- en: In an event-driven pattern, we implement a service in such a way that it publishes
    an event whenever a service updates its data, and another service (dependent service)
    subscribes to this event. Now, whenever a dependent service receives an event,
    it updates its data. This way, our dependent services can get and update their
    data if required. The preceding diagram shows an overview of how services subscribe
    to and publish events. In the diagram, **Event-Manager** could be a program running
    on a service or a mediator helping you manage all the events of the subscribers
    and publishers.
  prefs: []
  type: TYPE_NORMAL
- en: It registers an event of the **Publisher** and notifies a **Subscriber** whenever
    a specific event occurs/is triggered. It also helps you to form a queue and wait
    for events. In our implementation, we will use Azure Service Bus queues for this
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example. In our application, this is how our services will publish
    and receive an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CUSTOMER-SERVICE** performs a few checks for the users, namely login check,
    customer details check, and so on; after these necessary checks are conducted,
    the service publishes an event called `CustomerVerified`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CHECKOUT-SERVICE** receives this event and, after performing the necessary
    operations, it publishes an event called `ReadyToCheckout`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ORDER-SERVICE** receives this event and updates the quantity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as the checkout is performed, **CHECKOUT-SERVICE** publishes an event.
    Whatever result is received from the external service, either `CheckedoutSuccess`
    or `CheckedoutFailed`, it is used by **CHECKOUT-SERVICE**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `InventoryService` receives these events, it updates the data to make sure
    the exact item is added or removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the use of event-driven patterns, services can automatically update the
    database and publish an event.
  prefs: []
  type: TYPE_NORMAL
- en: Event sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern helps us ensure that the service will publish an event whenever
    the state changes. In this pattern, we take a business entity (product, customer,
    and so on) as a sequence of state-changing events. The **Event Store** persists
    the events and these events are available for subscription or as other services.
    This pattern simplifies our tasks by avoiding the requirement to synchronize the
    data model and the business domain. It improves performance, scalability, and
    responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: This simply defines an approach indicating how we can handle the various operations
    on our data by a sequence of events; these events are recorded in a store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event represents a set of changes made to the data, for example, `InvoiceCreated`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/83ac2541-af63-4f39-8f0b-498d655c9028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram describes how an event would work for **ORDERSERVICE**:'
  prefs: []
  type: TYPE_NORMAL
- en: The commands issue a book from the **User Interface** to be ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ORDERSERVICE** queries (from the **Event Store**) and populates the results
    with the `CreateOrder` event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the command handler raises an event to order the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our service performs the related operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the system appends the event to the event store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eventual consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eventual consistency is nothing but an implementation of the data consistency
    approach. This suggests implementation, so the system would be a scalable system
    with high availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'A document on MSDN ([https://msdn.microsoft.com/en-us/library/dn589800.aspx](https://msdn.microsoft.com/en-us/library/dn589800.aspx))
    says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Eventual consistency is unlikely to be specified as an explicit requirement
    of a distributed system. Instead it is often a result of implementing a system
    that must exhibit scalability and high availability, which precludes most common
    strategies for providing strong consistency."'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to this distributed data, stores are subject to the CAP theorem.
    The CAP theorem is also known as Brewer''s theorem. **Consistency**, **Availability**,
    **(network) Partition tolerance** (**CAP**). According to this theorem, in a distributed
    system, we can only choose two out of these three:'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compensating transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compensating transactions provides a way to roll back or undo all the tasks
    performed in a series of steps. Suppose one or more services have implemented
    operations in a series and one or more of them have failed. What would be your
    next step then? Would you reverse all the steps or commit to a half-completed
    functionality?
  prefs: []
  type: TYPE_NORMAL
- en: In our case, in which a customer orders a book and `ProductService` marks the
    ordered book as sold temporarily, after the confirmation of the order, `OrderService`
    calls an external service for completing the payment process. If the payment fails,
    we would need to undo our previous tasks, which means we will have to check `ProductService`
    so it will mark the specific book as unsold.
  prefs: []
  type: TYPE_NORMAL
- en: Competing consumers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Competing consumers provides a way to process messages for multiple concurrent
    consumers, so they receive these messages on the same channel. This application
    is meant for handling a large number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be implemented by passing a messaging system to another service (a consumer
    service), and it can be handled asynchronously, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22642a53-34b3-4d54-8c41-cf4a622ce690.png)'
  prefs: []
  type: TYPE_IMG
- en: This scenario can be implemented with the use of Azure Service Bus queues.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the event-driven pattern, we discussed services publishing and subscribing
    events. We used an **Event-Manager** to manage all the events. In this section,
    we will see how Azure Service Bus manages events and provides the facility to
    work with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Service Bus is an information delivery service. It is used to make communication
    easier between two or more components/services. In our case, whenever services
    need to exchange information, they will communicate using this service. Azure
    Service Bus plays an important role here. There are two main types of service
    provided by Azure Service Bus:'
  prefs: []
  type: TYPE_NORMAL
- en: Brokered communication: This service can also be called **hired service**. It
    works similarly to the postal service in the real world. Whenever a person wants
    to send messages/information, he/she can send a letter to another person. In this
    way, one can send various types of messages in the form of letters, packages,
    gifts, and so on. This type of messaging service ensures delivery of a message
    even when both the sender and receiver are not online at the same time. This is
    a messaging platform with components such as queues, topics, subscriptions, and
    so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-brokered communication: This is similar to making a phone call. In this
    case, the caller (sender) calls a person (receiver) without any confirmation indicating
    whether he/she will answer the call or not. In this way, the sender sends information,
    and it purely depends on the receiver to receive the communication and pass the
    message back to the sender.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccf94a49-9fc8-4062-bae3-e9ddf4a8a767.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The documentation on Microsoft Azure ([https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-fundamentals-hybrid-solutions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-fundamentals-hybrid-solutions))
    says:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Service Bus is a multi-tenant cloud service, which means that the service
    is shared by multiple users. Each user, such as an application developer, creates
    a namespace, then defines the communication mechanisms she needs within that namespace."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram is a pictorial view of Azure Service Bus and it depicts
    four different communication mechanisms. Everyone has their own taste in terms
    of which it connects application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Queues: These allow one-directional communication, and act as brokers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Topics: These provide one-directional communication where a single topic can
    have multiple subscriptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relays: These provide bi-directional communication. They do not store messages
    (as queues and topics do). Relays pass messages to the destination application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure queues are nothing but cloud storage accounts that use Azure Table. They
    provide a way to queue a message between applications. In the upcoming sections,
    we will implement message queues, which is part of Azure Service Bus.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Azure Service Bus queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at the actual implementation of an Azure Service
    Bus queue by creating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Service Bus namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Service Bus messaging queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A console application to send a message to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A console application to receive a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need the following to implement this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 update 3 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A valid Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not have an Azure subscription, you can get it for free by signing
    in here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have everything mentioned, you can start by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log on to the Azure portal ([https://portal.azure.com/](https://portal.azure.com/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left navigation bar, click on Service Bus. If unavailable, you can find
    it by clicking on More Services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71213eda-bd77-4603-9eb7-431638542d09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Create namespace dialog, enter a namespace, say, `flixone`. Select the
    pricing tier next: `Basic`, `Standard`, or `Premium`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your Subscription.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an existing resource or create a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the location where you want to host the namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a newly created namespace (we just created `flixone`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on Shared access policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on RootManageSharedAccessKey. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f73bc19a-6d5c-400c-b757-89ba34977789.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Queues in the main dialog of the `flixone` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Policy: RootManageSharedAccessKey window, note the primary key connection
    string for further use. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/10cf14b5-942d-4621-ae5b-d3f4fec8e090.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Name to add a queue (say, `flixonequeue`), and click on Create (we''re
    using REST values as default values). Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/011610d4-9e56-4b85-80b9-7990d89dc4cd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is of Create Queue dialog. In the Create Queue dialog we
    can create a queue for example in above image we are creating a queue with the
    name of floxonequeue. Queues can be verified by visiting the Queues dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to create our sender and receiver applications for messages.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to the queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a console application that will actually send
    messages to the queue. To create this application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new console application and name it `FlixOne.BookStore.MessageSender` using
    Visual Studio''s new project (C#) template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e272b2c4-8ecb-42f6-9eca-95c30afc5974.png)'
  prefs: []
  type: TYPE_IMG
- en: Add the NuGet package Microsoft Azure Service Bus by right-clicking on the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code to send the message to the queue, and your `Program.cs` file
    will contain the following `MainAsync()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are creating our queue client by providing `ConnectionString`
    and `QueueName` that we have already set in our Azure portal. It calls the `SendMessagesAsync()`
    method that accepts a parameter containing the count of the number of messages
    needed to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `SendMessagesAsync()` method and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program and wait for a while. You will get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/82510dd4-ecba-4221-adfb-32e32a171306.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to the Azure portal and then go to the created queue to check whether it
    displays a message. The below image is showing overview of flixonequeue where
    we can see Active Message Count etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5dc0366b-bb78-4c9c-abec-09dcaeb2c909.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding configuration settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we used constant values for both `ConnectionString`
    and `QueueName`. If we need to change these settings, we have to make changes
    to the code. But why should we make code changes for this small change? To overcome
    this situation, we have configuration settings. You can learn more about configuration
    at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration).
    In this section, we will add configurations with the help of the `IConfigurationRoot`
    of the `Microsoft.Extensions.Configuration` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, right-click on the project and click on Manage NuGet packages.
    Search for the `Microsoft.Extensions.Configuration` NuGet package. Refer to the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15c3fa44-c91d-4eae-806b-7c0dd52655b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, locate and search for the `Microsoft.Extensions.Configuration.Json` NuGet
    package. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a9e843d-06bf-4de0-b9d6-507243a81bac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following `ConfigureBuilder()` method to the `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `appsettings.json` file to the project, and the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After adding the preceding code, we added a way to get the `connectionstring`
    and `queuename` from the `.json` file. Now, if we need to change any of these
    fields, we do not need to make changes to the code files.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages from the queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a console application that will receive messages
    from the queue. To create this application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new console application (C#) and name it `FlixOne.BookStore.MessageReceiver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the NuGet package for Azure Service Bus (as added in the previous application).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code to receive messages from the Azure Bus Service queue, so your
    `program.cs` file contains the method `ProcessMessagesAsync()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and look at the result. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3f1c2b74-34a0-425f-a02f-83af7f56e1f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The console window will display the message and its ID. Now, go to the Azure
    portal and verify the message. It should be zero. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75afb60c-ebb1-45e2-9e9e-5d376a0966b0.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example demonstrates how we can use the Azure Bus Service to send/receive
    messages for our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inter-service communication is possible with synchronous or asynchronous communication,
    which are styles of collaboration. Microservices should have asynchronous APIs.
    The API gateway is a proxy server that provides a way to allow various clients
    to interact with APIs. API management, as an API gateway, provides plenty of features
    to manage/host various RESTful APIs. There are various patterns that help us communicate
    with microservices. With the use of Azure Bus Service, we can easily manage and
    play with inter-service communication using the Azure Bus Service message queue;
    services can easily send or receive messages between themselves through this.
    Eventual consistency talks about scalable systems with high scalability, and it
    is proven by the CAP theorem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss various testing strategies to test an application
    and build on the microservice architectural style.
  prefs: []
  type: TYPE_NORMAL
