<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Authentication and Authorization on Networks</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we gave serious consideration to the transport layer solutions for ensuring secure connections. With that knowledge, we'll be spending this chapter exploring the kinds of host-to-host interactions that demand that transport-level security. We'll be taking a step back up the tiers of the network stack, into the application layer, to look at how authentication and authorization is handled in .NET Core. We'll look at the various standards supported by the authorization header of HTTP. Then, we'll look at some widely used and widely supported open source tools for authentication. Finally, we'll look at how to manage access control within a C# application.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The various authentication schemes supported by valid authorization header values in HTTP requests</li>
<li>Understanding OAuth tokens and how they can be leveraged for user authentication and authorization</li>
<li>Strategies and settings for implementing authorization schemes in a .NET Core application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>In this chapter, as in the previous chapters, you'll need your IDE or source code editor of choice, as well as the sample code for this chapter <a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2014"><span>https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter 14</span></a><span>.</span></p>
<p><span>Check out the following video to see the code in action: <a href="http://bit.ly/2HY64XC">http://bit.ly/2HY64XC</a></span></p>
<p>We'll also be relying heavily on a REST client to initiate requests against our demo API, so make sure you've installed one. My two recommendations stand with either Postman, which can be found at: <a href="https://www.getpostman.com/downloads/">https://www.getpostman.com/downloads/</a>, or the Insomnia REST client, which can be found at: <a href="https://insomnia.rest/">https://insomnia.rest/.</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The authorization header</h1>
                </header>
            
            <article>
                
<p>If you've ever used your browser tools to inspect an outbound request to a website you've logged on to, you will likely have noticed, in the request header segment of your network inspector, a header titled <kbd>Authorization</kbd>. This standard header in the HTTP protocol can be used to specify a variety of schemes used to authenticate and authorize a user to access content at the requested URL. If you're not familiar with it, though, you might be surprised at the sheer variety of options at your disposal for providing those basic functions in your software. So, let's look at what those authorization schemes are and how we can use them in our own projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization versus authentication</h1>
                </header>
            
            <article>
                
<p>The first thing we'll want to consider as we explore the <kbd>Authorization</kbd> header is the two<em> </em>functions of web security that it can enable. While it is explicitly titled an <kbd>Authorization</kbd> header, often times, in practice, it's actually a misnomer. In reality, it can be both an <kbd>Authorization</kbd> header and<em> </em>an <kbd>Authentication</kbd> header, and frequently it functions as both.</p>
<p>Now, if you're not quite clear on the distinction between these two operations, this may all sound like I'm just splitting hairs. However, they each provide fundamentally different, and fundamentally necessary, features for a robust system of access control. And when we're talking about the <kbd>Authorization</kbd> header, we are explicitly talking about controlling access to the resources of our software. So, what exactly are these operations, and how can they facilitate an access controlled architecture?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication</h1>
                </header>
            
            <article>
                
<p>Put simply, authentication is the process of verifying a user's claim about who they are. Your user is making a claim about their identity, and you want to make sure that the identity is authentic<em>.</em> This is typically done by having the user provide some information that only they could be reasonably expected to have. In access-controlled software, that information is typically a set of credentials, such as a username and password combination, but it could be any number of things, such as knowledge of previous addresses or familial ties.</p>
<p>Authentication credentials could be anything that the user in question should reasonably be expected to know, and which no one else could reasonably be expected to know. Once these credentials are provided, the authenticity of the user's claim can be verified. So, authentication is about verifying a user's<strong> </strong>identity<strong><em>.</em></strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization</h1>
                </header>
            
            <article>
                
<p>On the other side of the access-control coin is authorization. This is about determining what a user should be allowed to do within a system, from modifying or adding information stored by a system to even accessing it in the first place. Just as the name suggests, authorization is a precaution of not allowing a user to perform an action until the system knows that the user is authorized to do so.</p>
<p>In almost all access-controlled systems, authorization is dependent on authentication. You can't determine if a user is authorized to perform an action until you can first authenticate that the user is who they claim to be. Authorization has the potential to be a substantially more complex step in the access-control process, though. The authentication step is fairly straightforward, with only two possible results. Either the user is who they claimed to be, in which case authentication succeeds, or they are not, in which case authentication fails. With authorization, though, the permissions that are returned for a given user could be determined by any number of underlying rules, procedures, or conditions. So, while authentication is about verifying a user's identity, authorization is about determining the actions a user is permitted to perform.</p>
<p>So, now that we understand the roles authentication and authorization play in access control, let's look at the HTTP mechanisms that enable those roles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization header values</h1>
                </header>
            
            <article>
                
<p>When a user attempts to access a site that is access-controlled, they might be prompted to provide an <kbd>Authorization</kbd> header from the server. For a client to authorize themselves with the server, they must do so using an authorization mechanism the server is prepared to handle. If the server is only set up for basic authentication, but the client tries to pass a bearer token, the server won't be able to parse the <kbd>Authorization</kbd> header, and will return a <span class="packt_screen">401-Unauthorized</span> status code, regardless of the validity of the token sent by the client.</p>
<p>The client (who, in this case, doesn't have prior knowledge of the valid authorization schemes supported by the server) must first be told exactly which authorization mechanism it should use to authenticate with the server. This is done with a <kbd>WWW-Authenticate</kbd> response header, which is applied to the initial response from the server. This header is used to indicate to the client exactly which <kbd>Authorization</kbd> protocol the server expects. So what exactly are the <kbd>Authorization</kbd> protocols defined by HTTP, and how do they work?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic authentication</h1>
                </header>
            
            <article>
                
<p>This specific schema is our first example of the <kbd>Authorization</kbd> header being used for an authentication task. In an HTTP interaction, the <strong>basic authentication</strong> (<strong>BA</strong>) schema is used for simple transmission of a username and password from the client to the server for authentication and authorization. It's known as the Basic, because when it is requested by a server, the client simply passes along credentials with no additional session keys or cookies and no additional handshaking between services to set the header appropriately.</p>
<p>With BA, the server indicates the authentication scheme by passing back a <kbd>WWW-Authenticate</kbd> header with the following structure:</p>
<pre>WWW-Authenticate: Basic realm="{description of the access-controlled area}", charset="UTF-8"</pre>
<p>Here, the <kbd>realm</kbd> and <kbd>charset</kbd> parameters are technically optional, but can provide useful guidance for the client with respect to how or why they must pass their credentials. Upon receiving this header, the client is responsible for delivering their credentials via the Authorization header in subsequent requests.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The user information URL segment</h1>
                </header>
            
            <article>
                
<p>We've actually seen the first method before, back in <a href="ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml">Chapter 2</a><em>, DNS and Resource Location</em>, in the <em>URLs, domain names, and device addresses </em>section<em>.</em> If a server supports the Basic authentication mechanism, clients can bypass the <kbd>Authorization</kbd> header altogether and simply transmit their credentials in the URL itself.</p>
<p>As you may remember, the first segment of a URL, after the schema specification, is actually an optional segment used for access credentials. So, let's imagine we have a user that has valid access to a remote resource. For this example, let's say their username is <kbd>aesop_rock</kbd>, and their password <kbd>A3h4s9f0cjeC</kbd><span>. Upon receiving the <kbd>WWW-Authenticate</kbd> method specifying Basic authentication, the client could simply redirect themselves to the access-controlled URL with the following credentials prefixed:</span></p>
<pre><span> https://aesop_rock:A3hw4s9f0cjeC@test-domain.com/test/url</span></pre>
<p>While this format meets the standards for a valid URL, and will allow for basic authentication mechanisms without passing the authentication header, it should be avoided at all costs. Transmitting passwords in plain text as part of your destination URL poses a substantial security risk. For that reason, the use of this <kbd>username:password</kbd> format is considered deprecated, and often unsupported by modern web browsers. However, the high volume of services that continue to support this URI-based authentication technique makes it worth your effort to understand and consider. As a rule, though, you should never support access with this credential mechanism. Whenever possible, you should scrub URLs of any content in the user information segment that comes after the first colon before transmitting requests over the wire to prevent accidentally persisting plain-text records of user passwords.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic authentication with header values</h1>
                </header>
            
            <article>
                
<p>When transmitting the credentials in the request header, however, a client would transmit all subsequent requests with the <kbd>Authorization</kbd> header, configured as follows:</p>
<pre>Authorization: Basic &lt;base64-encoded-credentials&gt;</pre>
<p>Here, the credentials are first formatted with a username and password separated by a single colon, just as in the URL format, then the <kbd>base64</kbd> character encoded.</p>
<div class="packt_tip">For credentials that are passed using this Basic authentication format, the first colon is always parsed as the delimiter between the username and password fields. Because of this, the username in a Basic authenticated system can never contain a colon.</div>
<p>So, if we have our user from the previous example, with the username of <kbd>aesop_rock</kbd> and a password of <kbd><span>A3</span><span>h</span><span>4s9f0cjeC</span></kbd>, then we would first format the credentials as follows:</p>
<pre>j_public:<span>A3r9f0cjeC</span></pre>
<p>And then we would <kbd>base-64</kbd> encode the characters. Applying this to our <kbd>Authorization</kbd> header, we would have a header value that's as follows:</p>
<pre>Authorization: Basic al9wdWJsaWM6QTNyOWYwY2plQw==</pre>
<p>Now, we have a Basic authentication <kbd>Authorization</kbd> header that, when transmitted to the server, the server will be able to validate by decoding the value of the <kbd>base-64</kbd> encoded access credentials.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encryption versus encoding</h1>
                </header>
            
            <article>
                
<p>It's important to note that when we modify our credentials, we are merely encoding them, and not actually encrypting them. The difference here is that a user can go from the <kbd>base-64</kbd> encoding to plain text and then back to the <kbd>base-64</kbd> encoding, all without access to any sort of cryptographic key to transition from one format to another. Encoding is simply a matter of character representation. It's almost like translating a basic noun from English to Spanish, and then back from Spanish to English. The meaning isn't obscured; it's just how the words are represented. Meanwhile, encryption is about deriving a new, secret value for an input string based on an additional, secret input, to obscure the meaning of the original message entirely.</p>
<p>At this point, I'll just go ahead and point out the obvious—any interaction that involves an <kbd>Authorization</kbd> header must take place over a secured connection using HTTPS. Though it might not always be feasible, the simplest best practice for enforcing this more secure behavior is to simply not configure your application to listen for HTTP requests. We'll see in just a bit what other options we have for preventing privileged information from being transmitted, unencrypted, and unsecured over a network. For now, though, if you can avoid supporting HTTP altogether, I'd strongly recommend doing so.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bearer token authorization</h1>
                </header>
            
            <article>
                
<p>While Basic authentication simply provided a raw username and password credentials, the bearer authentication deals in what is known as <strong>bearer </strong><strong>tokens</strong>. A bearer token is simply a security token that notifies the server that the user presenting the token (the bearer) has the credentials and permissions granted by the token.</p>
<p class="mce-root"/>
<p>Since, from the server's perspective, this token is used to authenticate a specific user, a bearer token can be thought of as simply a different kind of access credential. For this to be the case, though, the server must operate on the assumption that the bearer of a given security token wouldn't have it unless they were authorized to have it. For that reason, protecting the value of a given bearer token from eavesdropping or unauthorized access is just as important as protecting the value of a user password. Extra care should be taken to ensure that a token is never persisted on your server in an unsecured format.</p>
<p>Within the context of the <kbd>Authorization</kbd> header, the bearer authentication scheme is used specifically to support what are known as <strong>OAuth tokens</strong>. <strong>Open Authentication</strong> (<strong><span>OAuth</span></strong>) is a standard that was designed explicitly to support token-based authentication mechanisms for access-control of web-based resources. It's incredibly common across the internet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth basics</h1>
                </header>
            
            <article>
                
<p>If you've ever logged on to a website with your Google account, Facebook, or Twitter, you've used OAuth before. It's an access control mechanism that's designed to allow a delegate service to authenticate and authorize a user for the access-controlled resource. So, when you enter a new website for the first time, and it allows you to access it with your Google account, that new website is delegating the responsibility of authenticating you to Google. Google requests your credentials and authenticates you, and you are implicitly notifying Google to provide the new website with a token which the new website will consider sufficient for <em>authorization</em>.</p>
<p>It's not entirely dissimilar to the <strong>trusted certificate authority</strong> (<strong>CA</strong>) system we learned about in <a href="2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml">Chapter 13</a>,<em> Transport Layer Security</em>. In this context, Google would be analogous to a CA, and the users, or bearers of the token, are essentially the holders of the security certificate. So systems which support OAuth access are trusting the OAuth providers (Google, Facebook, and so on) as reliable sources for authentication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorizing with bearer tokens</h1>
                </header>
            
            <article>
                
<p>When a bearer token is supported, the syntax for delivering the token in your <kbd>Authorization</kbd> header is almost identical to that of Basic authentication. The format for doing so is as follows:</p>
<pre>Authorization: Bearer &lt;token&gt;</pre>
<p>The main difference here is that while the Basic authentication credentials were merely <kbd>base64</kbd> encoded, the token in a bearer authentication scheme can be cryptographically secured, providing some measure of protection if a client attempts to deliver the token over an unsecured transport mechanism. Moreover, Basic authentication credentials will only ever contain the user's access credentials, whereas bearer tokens can be far more robust in the information or context they contain.</p>
<p>While merely passing access credentials in a Basic authentication scheme is sufficient for authenticating a user, it leaves the task of determining any permissions that user might have up to the server. With a bearer token, though, the token might contain information for both, authentication of a user's identity as well as an assertion of the permissions granted to the user. In this way, the bearer authentication mechanism can be substantially more versatile, when implemented properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Digest authentication</h1>
                </header>
            
            <article>
                
<p>With the Digest authentication scheme, the designers explicitly sought to provide a more secure authentication implementation than is provided by the unencrypted Basic authentication scheme. In actuality, though, it only ends up providing a set of security trade-offs, and is reliant on an outdated hashing algorithm for its encryption. It still has a number of advantages, though, and is worth considering for implementation in certain circumstances. To understand the advantages and disadvantages it introduces, and when you might want to use it, let's look at how it works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Digest authentication WWW-Authenticate header</h1>
                </header>
            
            <article>
                
<p>When a user attempts to access a system <span><span>that </span></span>leverages Digest authentication, they are still prompted to use an <kbd>Authorization</kbd> header with the <kbd>WWW-Authenticate</kbd> response header. However, unlike the simple scheme specification returned with Basic and Bearer authentication schemes, the <kbd>WWW-Authenticate</kbd> header in a Digest authentication scheme contains a series of values the client will use to generate its authentication request.</p>
<p>These header values include the <kbd>realm</kbd> parameter that we saw as an optional parameter in Basic authentication schemes, and serves the same purpose, describing the authenticated space. There is also a required <kbd>nonce</kbd> value (nonce just means something that is only meant to be used once; in this case, for one authenticated session), which is used by the client to generate their digested credentials. This essentially serves as a shared secret or session key. In addition to these two required header parameters, there are several additional optional parameters.</p>
<p class="mce-root"/>
<p>The first of these optional parameters is <kbd>qop</kbd>, or quality of protection—a specification which, if included, dictates an additional set of steps the user must take in building their authenticated response. The values specified by this optional field can ensure a higher degree of security for the credentials being transmitted by the client. When left unspecified by the server, the default operations used by the client are the least secure for transit. Interestingly, the <span><strong>Remote Function Call</strong> (</span><strong>RFC</strong>), which standardized Digest authentication (RFC 7616), specifies the <kbd>qop</kbd> field as being required, but its support and implementation vary for different application servers.</p>
<p>The server can also specify a <kbd>domain</kbd> field, which can include a space-separated list of URIs that define the protection space. When this field is provided, the client can use the value to determine all of the URIs for which the same authentication information will be considered valid. This is useful in a distributed system wherein one resource is responsible for authenticating, but the user must forward authentication information to a separate server to access its restricted content.</p>
<p>The server can specify the specific hashing algorithm the client must use for its digested response with the <kbd>algorithm</kbd> parameter. When not specified, the algorithm is expected to default to MD5, which is known to be insecure in many contexts. Because of this, if you ever find yourself implementing the Digest authentication scheme, I would strongly encourage you to enforce a secure hashing algorithm using the <kbd>algorithm</kbd> parameter of your response header.</p>
<p>Additionally, the server can provide an <kbd>opaque</kbd> value, which is meant to be echoed exactly by the client. This is a useful mechanism by which a server can transmit state information from one resource to another through the authenticated client. So, for example, if server A is responsible for authenticating the client for access to resources on server B, then server A could transmit access details to server B, through the opaque field. When implemented properly, the client would simply echo whatever values are sent by server A in its subsequent requests to server B.</p>
<p>Finally, there are entirely optional parameters for minor details of the authentication interaction, such as <kbd>charset</kbd>, which is used to specify the supported encoding schemes that the client may use. There is also a <kbd>userhash</kbd> parameter, which notifies the client that the server supports hashing the username in addition to the password component of their credentials.</p>
<p>Taken together, each of these required and optional parameters will produce a <kbd>WWW-Authenticate</kbd> header that looks like the following sample, as presented in the original RFC for Digest authentication:</p>
<pre class="newpage">WWW-Authenticate: Digest
    realm="http-auth@example.org",
    qop="auth, auth-int",
    algorithm=SHA-256,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"</pre>
<p>Now, to understand how these header values are used to create a digested credential, let's look at the client's role in this process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Digest authentication's authorization header</h1>
                </header>
            
            <article>
                
<p>Once the client has received the <kbd>WWW-Authenticate</kbd> header from the server, they are responsible for building out their Digest response using the hashing algorithm that's specified (or the default MD5, if unspecified) by the server. To do so, they follow a series of procedures for one-way hashing their passwords using the hashing algorithm, and then hashing a combination of their username, the nonce value returned by the server, and their password.</p>
<p>The user creates a hash value with their username, the realm, and their password, with each separated by a colon. Assuming the server specified <kbd>SHA-256</kbd>, this creates a value designated as <kbd>HA1</kbd>, as shown here:</p>
<pre>HA1 = SHA256(username:realm:password)</pre>
<p>Then they generate a secondary hash value, dubbed <kbd>HA2</kbd>, which is composed of the HTTP method, to access the restricted resource, and the designated URI, separated by a colon and hashed with the specified algorithm:</p>
<pre>HA2 = SHA256(method:resourceURI)</pre>
<p>Finally, both of these values are hashed again in combination with the <kbd>nonce</kbd> value sent over by the server to produce the <kbd>response</kbd> parameter of the <kbd>Authorization</kbd> header:</p>
<pre>response = SHA256(HA1:nonce:HA2)</pre>
<p>There are variations of the specific inputs for each of these three values, depending on the <kbd>qop</kbd> value specified by the server, but overall the interactions are the same. Once all of this is done, the client returns an <kbd>Authorization</kbd> header <span>to the server</span> that includes the response value as well as its own array of optional parameters (and the echoed opaque parameter, if the server sent one in the first place) back to the server, as shown here:</p>
<pre><span class="na">Authorization</span><span class="o">:</span> <span class="l">Digest username="Mufasa",</span>
<span class="l">   realm="testrealm@host.com",<br/>   uri="/dir/secured.html",<br/></span>   response="6<span class="l">629fae49393a05397450978507c4ef1",<br/></span><span class="l">   nonce="</span>7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v<span class="l">",</span><span class="l"><br/></span><span class="l">   opaque="</span>FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS<span class="l">"</span></pre>
<p>The advantage to this is that the user never sends their password in plain text. The reason for this is that, since the server should<em> </em>know the user password, it can reproduce the same hashing algorithms, using the same inputs, and confirm the result against the <kbd>response</kbd> parameter of the <kbd>Authorization</kbd> header.</p>
<p>Of course, you can probably already see the risk inherent with such an implementation. For the server to reproduce the same <kbd>response</kbd> parameter, it must have access to the user password stored somewhere in plain text. Since this is universally a bad idea, more modern implementations will typically store the entirety of the HA1 value in a secured database the first time a user creates a new set of credentials. This technique still allows the server to produce the response calculation of <kbd>SHA256(HA1:nonce:HA2)</kbd> while eliminating the need for the plain-text inputs of HA1. However, that also means that any time the realm value is changed, HA1 needs to be recalculated for each user on the system.</p>
<p>Furthermore, even storing the <kbd>HA1</kbd> value should be considered relatively insecure, since it's used to create a new response by the client and access to the database still compromises the underlying system. A malicious actor would still be able to generate a fraudulent request, even without the plain-text password of the victim. The biggest benefit to using the <kbd>HA1</kbd> is that, in the event of the server being compromised, it at least protects the user's raw password from exposure, minimizing risk to users in the event of a security breach.</p>
<p>Although the Digest authentication scheme is intended to provide higher levels of security for the authentication step of system access, it introduces its own complications and security concerns. For this reason, it's much less used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP origin-bound access</h1>
                </header>
            
            <article>
                
<p>While not a fully-realized standard, the <strong>HTTP origin-bound access</strong> (<strong>HOBA</strong>) authentication scheme represents an exciting paradigm shift in the design of access-control mechanisms. Each of the previous forms of authentication we've discussed all revolved around users providing credentials (usually in the form of a username and password) to gain access to a system. With HOBA, no credentials are ever transmitted. Instead, a client (usually a specific web browser) persists a digital signature, which is given to the server in a challenge-response scheme.</p>
<p>Under the HOBA mechanism, the first time a client attempts to access a system, that specific client must register with the server. During this registration, once the client has been authenticated through traditional means, the client creates a <strong>client public key</strong> (<strong>CPK</strong>) and a private key registered to the specific origin/realm for the restricted resource. The CPK is then provided to the server, which assigns the CPK as the digital signature of the client. It's this CPK that is used to authenticate and authorize subsequent requests by the user to access restricted resources within the specified realm.</p>
<p>This provides the major security benefit of not having to store a record of the user credentials on the server, even in a securely hashed format. The downside to this practice, though, is that the CPK is typically stored in local storage by the browser on the client's machine. This means that any time a user accesses the server from a different machine (or indeed even a different web browser on the same machine) the client will have to register the new user-agent with the server again. Though, thankfully, the RFC draft, which defines the HOBA specification, explicitly allows for servers to register multiple CPKs to a single client account. As support for this authentication scheme grows and the specification is formally standardized, I would expect to see the other modes of authentication become very quickly deprecated in favor of HOBA.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization tokens</h1>
                </header>
            
            <article>
                
<p>One of the most commonly leveraged mechanisms for authorization is a bearer token. The most common mechanism for issuing these tokens is by using OAuth. However, while bearer tokens are typically referred to as OAuth tokens, in reality, they are merely provisioned by OAuth. The token itself can be defined by any standard, or no standard at all. Let's see how this relationship between token and token issuer can play out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth token provisioning</h1>
                </header>
            
            <article>
                
<p>As I mentioned before, OAuth is a standard for providing clients with valid authentication tokens. The formal standard for how this is done is actually relatively brief and high level, and allows for a lot of flexibility in specific implementations. It was originally designed as a way to allow third-party applications to access a target application on a user's behalf.</p>
<p>In the OAuth interaction scheme, a client must first register as a consumer of a resource server. In this context, a resource server is simply any server that contains access-restricted resources and relies on a delegate server to handle access control for it. During this registration process, the resource server grants the relevant permissions to the client to access the restricted resources in the future.</p>
<p>Once a client has been registered, whenever that client attempts to access the resource server in the future, it is prompted to acquire an <strong>access token</strong>. The client must then request an access token from an <strong>authorization server</strong>. An authorization server is a server that the resource server has registered as its delegate, and which implements the OAuth interaction standard. The client provides the authorization server any access credentials it was given by the resource server during the registration step.</p>
<p>Upon validating the access credentials, the authorization server returns an access token. The access token response of OAuth 2.0 forms the backbone of most users' day-to-day interactions with the standard. Whenever a valid user successfully requests a token, they will get a response body with the following properties:</p>
<ul>
<li><strong>access_token</strong>: This property is required, for obvious reasons. It's the value of the token string that will be returned to the resource server.</li>
<li><strong>token_type</strong>: This indicates the specific token authorization mechanism the resource server will expect. In almost all cases, this will simply have a value of bearer.</li>
<li><strong>expires_in</strong>:  This property, while not required, is strongly recommended. Access tokens should be short-lived, with the OAuth specification recommending a maximum lifespan of only 10 minutes for most tokens. This is a security precaution to reduce the risk of an exposed access token being used by a malicious actor.</li>
<li><strong>refresh_token</strong>: This property is only used if the access token has an expiration, and even then it's optional. It specifies a refresh token that can be used by the client to request a new access token from the authorization server.</li>
<li><strong>scope</strong>: This field is used to notify a user if their set of granted permissions are less permissive than the set of permissions they initially requested. For example, if I request an access token with read, write, and update permissions, but the server restricts my access to only read permissions, this field would be used to specify the read permissions.</li>
</ul>
<p>Finally, the client sends a request to the resource server with the access token as its <kbd>Authorization</kbd> bearer token.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Token generation</h1>
                </header>
            
            <article>
                
<p>While OAuth specifies the interactions between a client and the corresponding resource and authorization servers, it says nothing about how<em> </em>the <kbd>access_token</kbd> field is actually generated. Instead, that detail is left up to each server that implements or relies on OAuth. So, how are tokens generated and validated?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Persisted tokens</h1>
                </header>
            
            <article>
                
<p>It's not uncommon for a token to be nothing more than a randomly generated string. In this token generation mechanism, there is a database shared by both the authorization server and the resource server, which contains all of the relevant user access credentials and permissions. On some predetermined schedule, <span>tokens are</span><span> </span><span>randomly generated and then associated with each user in the database. Then, upon successful authentication, the authorization server looks up the current token for a given user and returns it as the access token. Upon authorization, the resource server then looks up the user in the database with that same token value and validates their access, and can look up any permissions they may have.</span></p>
<p>The obvious downside to this approach is the need for a shared database and concurrency within that database across both the authentication and resource server. This approach doesn't lend itself especially well to cloud-deployed systems that might have dozens of concurrently running instances of the resource or authorization server, with multiple database instances. It's also not particularly well-suited to extremely high-volume applications, since the multiple database lookups can be extremely costly in terms of an application's responsiveness. If your system is relatively centralized and handles a reasonably small volume, though, it's certainly not a terrible choice for implementing your access token system. So, what's the alternative?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Self-encoded tokens</h1>
                </header>
            
            <article>
                
<p>Perhaps one of the most robust and useful token generation mechanisms is the self-encoded <span>token.</span><span> </span><span>Self-encoded tokens</span><span> </span><span>are tokens whose bodies contain all of the information that's necessary for the resource server to authorize the bearer. So, when a user is authenticated to a system and granted a token by an authorization server, the resource server can simply inspect the body of the token to determine the success of the authorization request and any permissions or claims the user has. With the context contained entirely in the token, the resource server never has to access a shared database to validate the user or their permissions, thus saving on the orchestration of resources in a distributed environment.</span></p>
<p>Perhaps the most widely used, and widely supported, self-encoded token scheme is the <span><strong>JSON Web Token</strong> (<strong>JWT</strong>). A JWT implements the self-encoded token mechanism by providing a set of claims the bearer has as properties in an encoded JSON object. The structure of a JWT token consists of three separate components, which are concatenated together and separated by a period.</span></p>
<p><span>The first of these components is a header, which is a <kbd>base-64</kbd> encoded string with well-known header parameters represented as a JSON object. This specifies the algorithm that's used for the signature (which we'll look at in just a moment) and the token type, which is typically just JWT.</span></p>
<p><span>Next is the body, which is a <kbd>base-64</kbd> encoded JSON object containing the complete list of claims the bearer of the token has. There are a few required parameters in this object, such as sub (subject, or the name of the bearer) and iat (issued at). However, since the specification of the token body is done entirely at the discretion of the resource server, any number of claims can be added with any given values.</span></p>
<p>The final piece of a JWT is the verification signature. This is how your resource server will know the token came from its associated authorization server. The verify signature is an encrypted <strong>hashed message authentication code</strong> (<strong>HMAC</strong>), which is derived from the <kbd>base-64</kbd> encoded strings of the previous two sections combined with a secret key. If any part of the body of the token or the header of the token was modified, then the verification step of token authorization won't produce the same HMAC, and the resource server can find out whether the token was tampered with and is invalid. For this to work though, the resource server and authorization server must share the secret key between the two of them and use it to sign and subsequently verify any tokens passed between the two.</p>
<p>Whether the token has been determined to be valid or not, the first two components of the token are simply <kbd>base-64</kbd> encoded. As such, they can easily be decoded and read by any interested party. For this reason, it's important to never send private information in the body of a JWT in plain text. If confidential information or access credentials must be sent, they should be sent in a securely encrypted format, with a one-way hash when possible and secure reversible encryption otherwise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization in .NET Core</h1>
                </header>
            
            <article>
                
<p>Now that we've explored the ins and outs of authorization on the application layer of the OSI stack, it's time to look at how we can leverage these features in our own applications. Thankfully, as was the case with enforcing SSL, enabling an authorization scheme on our web APIs is mostly a matter of configuration more than anything. For the purposes of this demo, we'll be creating an application which will serve as both our resource server and our authentication server. And as always, we'll be taking some shortcuts with respect to error-handling and robust application design, for simplicity's sake.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The AuthorizeAttribute</h1>
                </header>
            
            <article>
                
<p>The first thing we'll want to do is designate which resources we will need the authorization to access. We'll deal with the actual process of authorizing a user later. To designate restricted resources, we apply <kbd>AuthorizeAttribute</kbd>. This attribute is designated as suitable for methods or classes. This means we can apply it directly to our application's restricted endpoint or to the entire controller. So, let's look at the impact of each approach. First, let's create our application with the CLI command:</p>
<pre><strong>dotnet new webapi -n AuthSample</strong></pre>
<p>Then, we'll navigate to the <kbd>ValuesController.cs</kbd> file, rename it <kbd>AuthController.cs</kbd>, and then modify it to the following:</p>
<pre>[Route("api/[controller]")]<br/>[ApiController]<br/>public class AuthController : ControllerBase {<br/><br/>  [HttpGet("secret")]<br/>  public ActionResult&lt;string&gt; GetRestrictedResource() {<br/>    return "This message is top secret!";<br/>  }<br/><br/>  [HttpPost("authenticate")]<br/>  public void AuthenticateUser([FromBody] Credentials creds) {<br/>  }<br/>}</pre>
<p>We want to allow users to <kbd>POST</kbd> their credentials when they authenticate, but they'll simply <kbd>GET</kbd> our top secret message. Here, I've created a simple <kbd>Credentials</kbd> class to serve as the message body of our <kbd>POST</kbd> request. This is just for the convenience of encapsulating both the <kbd>username</kbd> and <kbd>password</kbd> strings in a single container class. Now, let's look at different approaches for applying the <kbd>Authorize</kbd> attribute. One approach would be to explicitly flag a given endpoint as needing authorization. In this case, this would be the <kbd>GetRestrictedResource()</kbd> method. So, we can apply the attribute above or below the <kbd>[HttpGet]</kbd> attribute and then that's that! Lets, have a look at the following code:</p>
<pre>[Authorize]<br/>[HttpGet("secret")]<br/>public ActionResult&lt;string&gt; GetRestrictedResource() {<br/>    return "This message is top secret!";<br/>}</pre>
<p>However, I'm sure you could imagine a scenario where a controller has dozens of endpoints, each of which requiring authorization. In that scenario, you could simply apply the <kbd>Authorize</kbd> attribute to the controller class itself, like so:</p>
<pre>[Route("api/[controller]")]<br/>[ApiController]<br/>[Authorize]<br/>public class AuthController : ControllerBase {</pre>
<p>By applying the attribute to the controller, it is automatically applied to every endpoint defined in that controller. Of course, in our current controller, we'll need some way of designating our <kbd>AuthenticateUser()</kbd> method as not needing authorization (after all, how would a user become authorized if they must first be authorized?). To do this, we can override the <kbd>Authorize</kbd> attribute that's applied at the controller level with the <kbd>AllowAnonymous</kbd> attribute applied at the method level:</p>
<pre>[HttpPost]<br/>[AllowAnonymous]<br/>public void AuthenticateUser([FromBody] Credentials creds) {<br/>}</pre>
<p>This attribute will always override any <kbd>Authorize</kbd> attributes that would otherwise apply to the current method. For that reason, it's always important to make sure you are only ever applying the <kbd>AllowAnonymous</kbd> attribute where it is absolutely necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization middleware</h1>
                </header>
            
            <article>
                
<p>Now that we've designated which of our resources require to use authorization to be accessed, it's time to see what that authorization step looks like in our code. For this application, we'll be taking advantage of JWT bearer token authentication. To leverage this, we will be going to our <kbd>Startup.cs</kbd> file and modifying the services we've configured to use the appropriate authentication scheme.</p>
<p>Thanks to its open source distribution and wide support, the <kbd>Microsoft.AspNetCore</kbd> and <kbd>Microsoft.IdentityModel</kbd> namespaces support JWT token libraries right out of the box. This will make defining our authentication behavior much easier. We'll invoke the <kbd>AddAuthentication()</kbd> method on <kbd>IServicesCollection</kbd> and apply the default JWT bearer authentication scheme using the <kbd>JwtBeareDefaults</kbd> library class. Let's have a look at the following code:</p>
<pre>services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</pre>
<p>This <kbd>AddAuthentication()</kbd> method is where you can define any custom access policies you want to apply to a given <kbd>Authorize</kbd> endpoint. For example, if you wanted to define a policy for a role-based authentication scheme, you could define a policy as requiring the <kbd>Manager</kbd> privileges by adding it as an option to your <kbd>AddAuthentication()</kbd> middleware:</p>
<pre><span>services.AddAuthorization(options =&gt; {<br/>  options.AddPolicy(</span><span class="hljs-string">"RequireManagerRole"</span><span>, <br/>    policy =&gt; policy.RequireRole(</span><span class="hljs-string">"Manager"</span><span>));<br/>});</span></pre>
<p>Then, for any endpoints for which you wanted to restrict access to managers, simply define that access policy in the <kbd>Authorize</kbd> attribute, like so:</p>
<pre>[Authorize(Policy = "RequireManagerRole")]</pre>
<p>This can be cumbersome when you have a wide variety of access policies and need many to be applied at once. In that case, you'll often find yourself writing your own extension methods to the <kbd>IServicesCollection</kbd> class, and invoking them directly. For this example, though, we've already got an extension method to customize our authorization, provided by the <kbd>Microsoft.AspNetCore.Authentication.JwtBearer</kbd> namespace.</p>
<p>Simply defining our authentication scheme to the JWT default means that any endpoint with an <kbd>Authorize</kbd> directive will invoke .NET's JWT validation code. We don't have to write anything else for our application to pull the token value out of the <kbd>Authorization</kbd> header, validate its signature against our own record of the private key, and then either approve the request and continue to the method, or reject it with a <span class="packt_screen">401</span> response. This is all done by defining <kbd>JwtBearerDefaults.AuthenticationScheme</kbd> in our <kbd>AddAuthentication()</kbd> method.</p>
<p>The only remaining step we have to take to enable our authentication is to define what should be considered a valid token. We'll do that by using the <kbd>AddJwtBearer()</kbd> extension method. This method allows us to define an action delegate to configure the options we want our <kbd>Authentication</kbd> code to use when validating tokens. For this sample code, I've moved the definition of a signing key, token issuer, and token audience to a static utility class called <kbd>SecurityService</kbd>. This is just to make it easier to get the same values for our token validation options and our token generation code, which we'll look at in just a moment. But if you're curious, all that class is doing is returning consistent values for some key components of our token:</p>
<pre>public static class SecurityService {<br/>  public static SymmetricSecurityKey GetSecurityKey() {<br/>      string key = "0125eb1b-0251-4a86-8d43-8ebeeeb39d9a";<br/>      return new SymmetricSecurityKey(Encoding.ASCII.GetBytes(key));<br/>  }<br/><br/>  public static string GetIssuer() {<br/>      return "https://our-issuer.com/oauth";<br/>  }<br/><br/>  public static string GetAudience() {<br/>      return "we_the_audience";<br/>  }<br/>}</pre>
<p>So, by using this class for our shared symmetric key, issuer, and audience generation, we can configure those aspects of our token as being necessary for authorizing a valid user. Simply apply them to the <kbd>TokenValidationParameters</kbd> class of <kbd>JwtBearerOptions</kbd>, as follows:</p>
<pre>services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)<br/>  .AddJwtBearer(options =&gt; {<br/>    options.TokenValidationParameters = new TokenValidationParameters {<br/>      IssuerSigningKey = SecurityService.GetSecurityKey(),<br/>      RequireSignedTokens = true,<br/>      ValidateActor = false,<br/>      ValidateAudience = true,<br/>      ValidAudience = SecurityService.GetAudience(),<br/>      ValidateIssuer = true,<br/>      ValidIssuer = SecurityService.GetIssuer()<br/>    };<br/>  });</pre>
<p>With this configuration, you can see that our application is responsible for determining the validity of a bearer token based on the claims it contains. But thanks to the extensions available in the JWT utility libraries, defining those parameters becomes very easy!</p>
<p>Finally, as with any middleware configured in the <kbd>ConfigureServices</kbd> method, we'll need to tell our application to leverage it by adding the following line to our <kbd>Configure</kbd> method:</p>
<pre>app.UseAuthentication();</pre>
<p>And now, if you run the application and attempt to access the <kbd>/auth/secret</kbd> endpoint, you'll be given a <span class="packt_screen">401</span> response, with the <kbd>WWW-Authenticate</kbd> message indicating the expected authentication scheme:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-934 image-border" src="assets/b565513a-6916-49b9-b58b-86b798ddb0cb.png" style="width:80.00em;height:38.75em;"/></p>
<p>Now, all that's left is giving our users a token. Let's look at how to do that in our <kbd>AuthController</kbd> class using the JWT libraries for .NET.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a token</h1>
                </header>
            
            <article>
                
<p>With our <kbd>/auth/secret</kbd> endpoint safely locked away behind the authorize attribute, we need some way of authenticating and authorizing a user. For that, we'll use the <kbd>AuthenticateUser()</kbd> method, which is configured with the <kbd>AllowAnonymous</kbd> attribute to enable anyone to attempt to log in. The first thing we'll need is a list of users. For this, I've created a simple dictionary of <kbd>username:password</kbd> combinations in a <kbd>user_vault.json</kbd> file, which we can access with a static <kbd>UserVault</kbd> class. The <kbd>UserVault</kbd> class then exposes a simple method for checking whether a <kbd>username:password</kbd> combination exists in our user database. So, let's let <kbd>user_vault.json</kbd> be defined as follows:</p>
<pre>{<br/>    "aladdin": "open_sesame",<br/>    "dr_suess": "green_eggs_and_ham",<br/>    "jack_skellington": "halloween"<br/>}</pre>
<p>This gives us three valid users that we can test with. Our corresponding <kbd>UserVault</kbd> class allows us to check that by first being initialized with a static constructor:</p>
<pre>private static Dictionary&lt;string, string&gt; _users { get; set; }<br/>static UserVault() {<br/>  try {<br/>    using (var sr = new StreamReader("user_vault.json")) {<br/>      var json = sr.ReadToEnd();<br/>      _users = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, string&gt;&gt;(json);<br/>    }<br/>  } catch (Exception e) {<br/>    throw e;<br/>  }<br/>}</pre>
<p>Then, with an in-memory representation of our <kbd>user_vault.json</kbd> file, we can check against our private dictionary for any <kbd>username:password</kbd> pair with a <kbd>ContainsCredentials()</kbd> method:</p>
<pre>public static bool ContainsCredentials(string userName, string password) {<br/>  if (_users.ContainsKey(userName)) {<br/>    string storedPassword;<br/>    if(_users.TryGetValue(userName, out storedPassword)){<br/>      return storedPassword.Equals(password);<br/>    }<br/>  }<br/>  return false;<br/>}</pre>
<p>So, now that we can check for a user's presence in our user database, let's go ahead and define the authentication for our application. The first thing we'll need to do is build the key details that our authorization code will be expecting from any tokens we've issued. So, we'll need to use the same security key that we've configured our authentication middleware to expect. We'll also give the user a basic <kbd>Identity</kbd> using the <kbd>ClaimsIdentity</kbd> class:</p>
<pre>[HttpPost]<br/>[AllowAnonymous]<br/>public ActionResult&lt;string&gt; AuthenticateUser([FromBody] Credentials creds) {<br/>  if (UserVault.ContainsCredentials(creds.UserName, creds.Password)) {<br/>    var key = SecurityService.GetSecurityKey();<br/>    var signingCredentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);<br/>    var identity = new ClaimsIdentity(new GenericIdentity(creds.UserName, "username"));</pre>
<p>The <kbd>SigningCredentials</kbd> class in this code is a simple wrapper class that handles the details of hashing a given security key using the designated hash algorithm (in this case, HMAC SHA-256). This class is then used to generate the signature key component of the resulting JWT token. Once we've got that, we're ready to build our JWT token. To do that, we'll be using an instance of the <kbd>JwtSecurityTokenHandler</kbd> class. This is essentially a factory class that is used to produce well-formed JWT tokens with the configuration details passed to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying user claims</h1>
                </header>
            
            <article>
                
<p>For the sake of demonstration, we'll be applying a few arbitrary claims to our token, just so we can inspect the result and see how those claims are applied and displayed in a well-formed token. We've got a simple helper class for that which returns a list of basic <kbd>Claim</kbd> instances:</p>
<pre>private IEnumerable&lt;Claim&gt; GetClaims() {<br/>  return new List&lt;Claim&gt;() {<br/>    new Claim("secret_access", "true"),<br/>    new Claim("excellent_code", "true")<br/>  };<br/>}</pre>
<p>So, now that we've got all of our claims defined, we can apply them to the <kbd>ClaimsIdentity</kbd> that we create for the user with the following line of code:</p>
<pre>identity.AddClaims(GetClaims());</pre>
<p class="mce-root"/>
<p>This will give us the flexibility of restricting access to individual resources based on the permissions a user has on a case-by-case basis. The <kbd>User</kbd> property of <kbd>HttpContext</kbd> for any given request is an instance of a <kbd>ClaimsPrinciple</kbd>. Thus, we can inspect a user's claims through the <kbd>HttpContext.User.Claims</kbd> property.</p>
<p>When we secure an endpoint behind an authorize filter, any user claims specified by the authentication mechanism (in this case, JWT) will be applied to the <kbd>HttpContext.User.Claims</kbd> property. With that in mind, we can restrict access to our secret endpoint by inspecting our user's <kbd>Claims</kbd> property and confirming that they contain the claims we're looking for. Simply modify your  <kbd>GetRestrictedResource</kbd> method to examine the <kbd>Type</kbd> parameter of your user claims, and confirm that the user has at least one claim of the valid claim types returned by <kbd>GetClaims</kbd>, as shown here:</p>
<pre>[HttpGet("secret")]<br/>public ActionResult&lt;string&gt; GetRestrictedResource() {<br/>    var validClaims = GetClaims().Select(x =&gt; x.Type);<br/>    var userClaims = HttpContext.User.Claims.Select(x =&gt; x.Type);<br/>    if (validClaims.Intersect(userClaims).Count() &lt; 1) {<br/>        return StatusCode(403);<br/>    }<br/>    return "This message is top secret!";<br/>}</pre>
<p class="mce-root">With that, our user is defined, their claims are specified, and our resource is restricted to users who have those claims. And since <span>our signing credentials are configured to use the same symmetric key as the resource server, we're ready to build out our token. This is easily done with the</span> <kbd>JwtSecurityTokenHandler</kbd><span>, and</span> <kbd>SecurityTokenDescriptor</kbd> <span>classes:</span></p>
<pre>var handler = new JwtSecurityTokenHandler();<br/>var token = handler.CreateToken(new SecurityTokenDescriptor() {<br/>  Issuer = SecurityService.GetIssuer(),<br/>  Audience = SecurityService.GetAudience(),<br/>  SigningCredentials = signingCredentials,<br/>  Subject = identity,<br/>  Expires = DateTime.Now.AddMinutes(10),<br/>  NotBefore = DateTime.Now<br/>});</pre>
<p>Now, all that's left to do is write the token to our output for our users to apply to their subsequent requests. If you want to implement a fully compliant OAuth server, your response body and exception handling would need to adhere to the standard defined by OAuth 2.0, with your token returned as a part of a larger response body. Since we're just demonstrating the high-level workflow though, I'll leave that additional research to you. Instead, our output will just be the raw JWT token. So, with everything we've just done to fill in the blanks, the shell of our authentication method should look like this:</p>
<pre>[HttpPost]<br/>[AllowAnonymous]<br/>public ActionResult&lt;string&gt; AuthenticateUser([FromBody] Credentials creds) {<br/>  if (UserVault.ContainsCredentials(creds.UserName, creds.Password)) {<br/>    ... // Build and generate JWT token<br/>    return handler.WriteToken(token);<br/>  } else {<br/>    return StatusCode(401);<br/>}</pre>
<p>Now, we're ready to put it all together. Run the application, post a request to the auth endpoint with any of the credentials in <kbd>user_vault.json</kbd> , and you should be greeted with a token:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-935 image-border" src="assets/e5ee7a7b-ee40-46af-8656-75a4fc31d624.png" style="width:80.33em;height:46.50em;"/></p>
<p>Next, make a request to the secret endpoint, supplying your newly retrieved token. To do this, go to the <span class="packt_screen">Authorization</span> tab of Postman (or Insomnia) and set the <span class="packt_screen">Authorization Type</span> in the drop-down list to the <span class="packt_screen">Bearer Token</span> option. Then, paste in your newly acquired token into the input box, and send your request. If you followed all the steps here, you should get our secret message returned with a <span class="packt_screen">200</span> status code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-936 image-border" src="assets/e54e94ad-ed86-4c89-bf03-f8ef20c82954.png" style="width:79.92em;height:45.58em;"/></p>
<p>And just like that, you've implemented and applied a complete authentication and authorization scheme within .NET core, which it required a minimum amount of custom code on your part.</p>
<p>Before we move on, however, I would like to firmly establish that the coding practices used here are for demonstration purposes only<em>. </em>My goal was simply to illustrate the conceptual flow and basic patterns for an authentication/authorization framework in .NET Core. If you find yourself implementing user access in any of your applications, you have a strong responsibility to ensure the security of their private access credentials, and that should never be taken lightly.</p>
<p>With that said, we're now in a position to look at other ways we can improve the performance and versatility of our application layer network code. In the next chapter, we'll be taking a close look at caching strategies and patterns in .NET Core.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered every aspect of authentication and authorization at the application layer. First, we learned about the key but subtle distinction between authentication and authorization. We looked at the HTTP standard header that allows applications to perform both of those tasks to control access to restricted resources. Then, we learned about each of the valid authentication schemes supported by the standard <kbd>Authorization</kbd> header.</p>
<p>We saw the security risks and ease of implementation that come along with basic authentication. We looked at how a bearer token authentication could alleviate some of the security risks associated with basic authentication without necessarily adding much more in the way of complexity. Finally, we learned about the complexities and nuances of the Digest authentication mechanism. Before moving on, we also took the time to consider how authorization might be handled in the future with something like the HOBA scheme.</p>
<p>Next, we took a deep dive into bearer tokens. We saw how the OAuth standard defines an interaction mechanism for accessing and provisioning tokens. Then, we looked at how those tokens can be generated and leveraged by a resource server. Finally, we tied this all together by learning how to implement these features in .NET Core. Now, we're ready to look at performance improvements and resiliency strategies through caching, which we'll be exploring in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the difference between authentication and authorization? How do they apply to access control for web-based resources?</li>
<li>What are the valid authentication mechanisms for the authorize HTTP header?</li>
<li>What is HOBA? What is the primary advantage it has over other authentication schemes?</li>
<li>What is a bearer token? How is it used for authentication or authorization?</li>
<li>What is OAuth? How does it relate to standard authorization techniques?</li>
<li>What is a self-encoded token?</li>
<li>What is a JWT? How is it used?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>For more information about modern authentication techniques, I would strongly recommend reading <em>Mastering OAuth 2.0</em> by <em>Charles Bihis</em>. It's a relatively short read, but provides an extensive exploration of the standard. You can find it through Packt, here: </span><a href="https://www.packtpub.com/application-development/mastering-oauth-2">https://www.packtpub.com/application-development/mastering-oauth-2.</a></p>
<p>Alternatively, if you have designs to leverage an OAuth system within your own software and want a more hands-on approach to the subject, I would recommend the <em>OAuth 2.0 Cookbook</em> by <em>Adolfo Eloy Nascimento</em>. It's also available through Packt, here: <a href="https://www.packtpub.com/virtualization-and-cloud/oauth-20-cookbook">https://www.packtpub.com/virtualization-and-cloud/oauth-20-cookbook.</a></p>


            </article>

            
        </section>
    </body></html>