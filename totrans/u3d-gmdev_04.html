<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer075">
<h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-79">Characters</h1>
<p class="normal">In <em class="chapterRef">Chapter 2</em>, <em class="italic">Design and Prototype</em>, we discussed that this book will be utilizing a vertical slice method for our model. Being a vertical slice, the project is a simplification of the game. It is similar to a demo, but it has all of the main mechanics the game would contain, just in a simpler form. It is meant to give investors a strong example of what could be an entire game experience. We will be showing the character’s behavior to draw the player in and then lead into a small portion of the story with mechanics driven by environment puzzles while learning about the main character’s past.</p>
<p class="normal">We will start with the concepts related to the main character; we will then model the character out and make changes as we see fit by working through their mechanics and movement. We will make a rig for them so they can be animated. After this, we will put them in Unity and test out how it feels moving them around in the engine. This chapter will be packed with a lot of information, and we will be going over many different production concepts to create our character and get them properly moving:</p>
<ul>
<li class="bulletList">Design and concept</li>
<li class="bulletList">Rigging</li>
<li class="bulletList">Character controllers</li>
<li class="bulletList">Scripting your character’s movement</li>
</ul>
<p class="normal">Let’s start with the conception phase for Myvari, the main character of our small story.</p>
<h1 class="heading-1" id="_idParaDest-80">Design and concept</h1>
<p class="normal">To make a character, there can be many<a id="_idIndexMarker194"/> dimensions. We want to make sure that the hero character of this vertical slice, Myvari, is as fleshed out as possible. One of the best tools for this is asking “why” for aspects of the character. </p>
<h2 class="heading-2" id="_idParaDest-81">Asking why</h2>
<p class="normal">We are building an adventure-based puzzle game. The first question that comes to mind is: why is the character<a id="_idIndexMarker195"/> on this adventure? In this case, we answered that question with: “She is seeking to find answers about her race’s past that aren’t in the stories being told or the books she’s read.” Now we’ve defined a few things, but there are still more questions. </p>
<p class="normal">To give an idea of the questions that came up from this initial answer, look at this list:</p>
<ul>
<li class="bulletList">What race is she and why does this matter to the story?</li>
<li class="bulletList">Why female?</li>
<li class="bulletList">Why is her history hidden?</li>
<li class="bulletList">What is her clothing like?</li>
<li class="bulletList">What does the race look like?</li>
<li class="bulletList">Is she humanoid?</li>
</ul>
<p class="normal">As you can see, this can go on for a while, and it should. All of these answers should bring more questions. Take them down to their lowest possible components. This may seem tedious, but when you are done, you will know how this character acts when they are confronted, their facial expressions, behaviors, inside jokes, family backstory, and everything in between.</p>
<h2 class="heading-2" id="_idParaDest-82">Concept time!</h2>
<p class="normal">Now that we have a strong<a id="_idIndexMarker196"/> idea of Myvari and who she is, we can draw up concept art. We first start out with some proportion work and sketch work to find her basic appearance.</p>
<p class="normal">On the left in <em class="italic">Figure 4.1</em>, we also drew up a behavioral take. This gives us a visual idea of how she may act in an <strong class="keyWord">idle break</strong> animation. An idle break is an animation<a id="_idIndexMarker197"/> that occurs when your character remains still for some time. We felt that her character would be studious and inquisitive, so she would pull out a book and just start studying on the spot.</p>
<figure class="mediaobject"><img alt="" height="534" src="../Images/B17304_04_01.png" width="824"/></figure>
<p class="packt_figref">Figure 4.1: Initial Myvari sketches</p>
<p class="normal">After we have drawn up the sketches<a id="_idIndexMarker198"/> of what she may look like, including giving a sense of her personality, we need to get a feel for the colors to finalize the design. The color scheme shown in <em class="italic">Figure 4.2</em> was chosen after answering all the previous questions. </p>
<p class="normal">Myvari’s overall color themes give the sense of royalty, curiosity, and safety. These are depicted through regal clothing with gold lines denoting royalty. Blue evokes a sense of safety—a psychological and physical effect, as seeing this color lowers our blood pressure. Using blue draws the player slightly more into her character, curious about this bright blue amongst the rest of her neutrally colored outfit.</p>
<p class="normal">Her most unique accessory is her necklace, which has a mechanical purpose. It will be the key for the puzzles that she will have to interact with. For this reason, the necklace has a color that stands out from the rest of Myvari. This color<a id="_idIndexMarker199"/> will also be unique in the environment utilizing a concept known as <strong class="keyWord">user guidance</strong>, which we will talk about in <em class="chapterRef">Chapter 5</em>, <em class="italic">Environment</em>, <em class="chapterRef">Chapter 6</em>, <em class="italic">Interactions and Mechanics</em>, <em class="chapterRef">Chapter 7</em>, <em class="italic">Rigid Bodies and Physics Interaction</em>, and <em class="chapterRef">Chapter 12</em>, <em class="italic">Final Touches</em>. We will need to use this color continuously in the environment, the mechanics, as well as the polishing of the entire vertical slice.</p>
<figure class="mediaobject"><img alt="" height="596" src="../Images/B17304_04_02.png" width="270"/></figure>
<p class="packt_figref">Figure 4.2: Myvari’s color scheme</p>
<p class="normal">Once we have a strong<a id="_idIndexMarker200"/> idea about the character’s personality and colors, we need to move into the 3D versions of concepting. This is less creating and more defining a character. The following image depicts the character’s facial features using a <strong class="keyWord">sculpting</strong> tool. Our team has a strong<a id="_idIndexMarker201"/> background in the use of Pixologic’s ZBrush, which allowed us to create the sculpt you see in <em class="italic">Figure 4.3</em>. 3DCoat and Blender also offer sculpting tools.</p>
<p class="normal">After we’ve worked through enough iterations with the sculpts, we will use this as a beginning high-resolution model. </p>
<p class="normal">Now that we’ve defined<a id="_idIndexMarker202"/> our primary high-res sculpt, we can move on to getting a low-res model out of ZBrush.</p>
<figure class="mediaobject"><img alt="" height="463" src="../Images/B17304_04_03.png" width="824"/></figure>
<p class="packt_figref">Figure 4.3: Myvari’s high-resolution head sculpt</p>
<p class="normal">The low-res model will be our scale bias for everything in the game, as seen below in <em class="italic">Figure 4.4</em>. When you are creating buildings, flora, fauna, or characters, this model will act as the universal <strong class="keyWord">scale</strong> for them. There are multiple ways<a id="_idIndexMarker203"/> to work through scale, however, I know that this character is the main creature in this game; all of the items will be environmental or props, which will all be scaled off her size as the base scale.</p>
<figure class="mediaobject"><img alt="" height="290" src="../Images/B17304_04_04.png" width="825"/></figure>
<p class="packt_figref">Figure 4.4: Myvari’s low-resolution head sculpt</p>
<p class="normal">Some other ways scaling can be done<a id="_idIndexMarker204"/> is by building to scale. Unity’s units are centimeters. If you build to a meter and then export from your Digital Content Creation (<strong class="keyWord">DCC</strong>) as a centimeter, everything will follow a single unit scale. This is a great way to build if you are building a large game with many teams working around the world. You could also build the game around the environment itself. An example of this could be a top-down game using squares for environment creation, so it all clicks together. The squares may be a 10<sup class="superscript">th</sup> of the screen. From this information, you would take a screenshot at the resolution expected, then draw the character concepts on that picture to fit the scale. Look at your project and look through what the single point of scale that you can build off is. This will ultimately save you time down the road.</p>
<p class="normal">You could potentially just build whatever you can and scale the item in-game after it’s imported. However, what will happen with that is the mechanics may not work properly. Think about games like Tomb Raider or Assassin’s Creed, where the main character must climb onto walls. This requires the character to have a very specific height and a large amount of conditioning to ensure they are in the right spot at the right time for the animation.</p>
<h1 class="heading-1" id="_idParaDest-83">Rigging</h1>
<p class="normal">After working through<a id="_idIndexMarker205"/> this whole concepting phase, we need to work on getting some bones into the character so we can animate her. We will be using Autodesk’s Maya 2022 to rig our character. The points we will go over will be principles, not technical details. Depending on your DCC tool, you may encounter slightly<a id="_idIndexMarker206"/> different terminology, however, the following terms will generally apply to any of the major DCCs in use for game development.</p>
<h2 class="heading-2" id="_idParaDest-84">Animation-first thinking</h2>
<p class="normal">When beginning the rigging<a id="_idIndexMarker207"/> task, the most efficient way to work is by having a detailed conversation about the animations themselves with the artists who will be responsible for them. Even if you’re doing the animations yourself, successful rigs are ones that ensure the animator doesn’t need an explanation of what each control does. There may be some technical attributes, but overall if a control doesn’t need something, it should be locked and hidden. </p>
<p class="normal">When the animator moves<a id="_idIndexMarker208"/> a control that oversees the hand, they may expect all the finger controls to be on that control. This is intuitive but it shouldn’t be assumed that the animator needs this. They may want all individual controls to be placed on their own control.</p>
<h2 class="heading-2" id="_idParaDest-85">Deformation</h2>
<p class="normal">This is the ability for a mesh<a id="_idIndexMarker209"/> to be able to bend in a predetermined way, such as the elbows or knees. Since you know how they will be bending, you can plan your mesh for that deformation<a id="_idIndexMarker210"/> to be possible with a proper <strong class="keyWord">edge flow</strong> in your model. Edge flow is an art form all on its own, ensuring that there is enough geometry to keep the shape when deforming. An example edge flow can be seen in <em class="italic">Figure 4.5</em>. Take your time working through other AAA model examples and learn how each body structure may bend.</p>
<figure class="mediaobject"><img alt="" height="513" src="../Images/B17304_04_05.png" width="824"/></figure>
<p class="packt_figref">Figure 4.5: Example of edge flow on a humanoid</p>
<p class="normal">Facial deformation<a id="_idIndexMarker211"/> is by far the most specific deformation. If you are planning on having any facial deformation when you start rigging, look for some videos explaining how to set up the character for this. Facial expressions<a id="_idIndexMarker212"/> are intricate and hard to do correctly. </p>
<p class="normal">A small example of edge flow and separation can be seen in <em class="italic">Figure 4.6</em>.</p>
<figure class="mediaobject"><img alt="" height="461" src="../Images/B17304_04_06.png" width="823"/></figure>
<p class="packt_figref">Figure 4.6: Example of facial edge flow</p>
<p class="normal">Facial deformation done correctly will result in your character producing relatable expressions. This can accentuate the experience by bolstering the immersion through emotion. If you plan on having close-ups of your character, it’s a good idea to take the time to work through facial deformation.</p>
<h2 class="heading-2" id="_idParaDest-86">Hierarchy</h2>
<p class="normal">Hierarchy and parenting<a id="_idIndexMarker213"/> are an integral part of rigging knowledge. When Unity imports a skeletal mesh, there may be transforms that your DCC had in place. This can sometimes be a grouping or hierarchical change that has its own transform. Unity would see these items as GameObjects and place them in the same spot in the Hierarchy of the skeleton. Every application may be slightly different. An example of this is with Maya: if your hierarchy has a group node as a parent of your rig, Unity will think this is a transform of its own and import it as such. This may not cause an issue in the beginning with no logic on the GameObject, but it’s always best to be as clean as possible. If you are using Maya, we recommend that you don’t have any parent nodes on the skeleton you will be binding.</p>
<p class="normal">This brings up a topic<a id="_idIndexMarker214"/> that is interesting to work with: the <strong class="keyWord">control rig</strong>. The most customizable rig that we’ve worked<a id="_idIndexMarker215"/> with was a binding rig, which was bound to all the vertices on the character. This was then driven directly by a duplicate rig, which we called a control rig. This allowed for the bind rig to only worry about the inputs of a single entity. This is important as sometimes you may want to have multiple deforming tools moving around the rig. You might want a separate squash control and twist control. All this logic on the control rig will drive the bind rig without worrying about breaking the binding on the character.</p>
<h2 class="heading-2" id="_idParaDest-87">Bones or joints</h2>
<p class="normal">Bones and joints are terms used<a id="_idIndexMarker216"/> interchangeably in rigging. The bind skeleton consists only of bones or joints in its own Hierarchy from the root, through the spine, arms, legs, neck, and head. These bones can be seen in <em class="italic">Figure 4.7</em> below. </p>
<figure class="mediaobject"><img alt="" height="482" src="../Images/B17304_04_07.png" width="824"/></figure>
<p class="packt_figref">Figure 4.7: Examples of joints of character inside DCC</p>
<p class="normal">After you’ve laid out your bones, you then need to plan out the next level by constraining systems<a id="_idIndexMarker217"/> that will drive the bones’ structure. If you are using a control rig on top, these constraints would instead drive the control rig bones.</p>
<h2 class="heading-2" id="_idParaDest-88">Forward Kinematics/Inverse Kinematics</h2>
<p class="normal"><strong class="keyWord">Forward Kinematics</strong> (<strong class="keyWord">FK</strong>) and <strong class="keyWord">Inverse Kinematics</strong> (<strong class="keyWord">IK</strong>) are two major forms of animation for arms and legs. FK is a technique where the animator will manually rotate every joint individually. If you are animating<a id="_idIndexMarker218"/> an arm, you would start<a id="_idIndexMarker219"/> from the shoulder, then the elbow, then the wrist, etc. It’s called “forward”<a id="_idIndexMarker220"/> as you are going forward down the Hierarchy<a id="_idIndexMarker221"/> for animation. On the contrary, IK is where you would animate the hand, and the shoulder and elbow would follow from the guidance of a rotate plane. There is a debate on whether to use one or the other, however, they are tools. If you work with one and it makes your job easier, then use that style. It is very common to see FK/IK switches on character rigs as both have their places in certain animation workflows.</p>
<p class="normal">Further, the primary concern about IK is that you can keep the hand in the same position or to the space where it was last placed. Imagine standing up and putting a hand in the air, then moving your hips up and down while keeping your hand in the air in the same place. This would be extremely tedious to animate with an FK-only setup as you would have to key the shoulder, elbow, and wrist separately to all the hip motions. With IK, you would be able to key the wrist in the spot where it would be and then just animate the hips. IK would handle the shoulder and elbow for you. However, a walk cycle where gravity is working on the hand and it’s mostly just making an arc with the momentum of the movement is better suited for FK.</p>
<p class="normal">As previously mentioned, these are tools that can potentially produce the same result. As you build experience with your tools, it will provide you with insight into your animation style.</p>
<h2 class="heading-2" id="_idParaDest-89">Constraints</h2>
<p class="normal">Constraining is a simple action. Using visual<a id="_idIndexMarker222"/> objects, we want the animators<a id="_idIndexMarker223"/> to understand the control’s purpose straight away. A concise example would be a <strong class="keyWord">NURBS</strong> (<strong class="keyWord">non-uniform rational basis spline</strong>—a point in space that creates something visual) curve that will point to each finger in a rigged hand to help with making a fist. <em class="italic">Figure 4.8</em> below shows how we did this with Myvari’s rig. </p>
<figure class="mediaobject"><img alt="A picture containing text, indoor  Description automatically generated" height="458" src="../Images/B17304_04_08.png" width="824"/></figure>
<p class="packt_figref">Figure 4.8: Myvari’s hand controls</p>
<p class="normal">These are called controls<a id="_idIndexMarker224"/> simply because they allow the animators to control certain<a id="_idIndexMarker225"/> aspects of the character. Reading this may sound similar to another term we introduced in <em class="chapterRef">Chapter 1</em>, <em class="italic">A Primer to the Third Dimension</em>: <strong class="keyWord">parenting</strong>. It is true that there is a similarity between constraining<a id="_idIndexMarker226"/> and parenting, however, we are allowed to be specific in what we want to constrain with constraints. In Maya, this is separated into translation, rotation, and scale constraining. You can also constrain individual components of each of these, such as “rotate <em class="italic">x</em>” only. This allows the rigger to be able to restrict the animator a bit. The above example with the head control may only need a rotational constraint. This makes it so the translation of the box would not affect the bones. With parenting, you wouldn’t be able to separate these. Parents affect all transforms of the child object.</p>
<h2 class="heading-2" id="_idParaDest-90">Deformers</h2>
<p class="normal">The deforming tools will be unique<a id="_idIndexMarker227"/> to each DCC. The primary function of a deformer is to control<a id="_idIndexMarker228"/> the top-level hierarchy in certain ways. An example of this may be a twist deformer, which could allow a nice twist of the controls to make it easier for the animator to build a twist animation.</p>
<p class="normal">Some advanced animations <a id="_idIndexMarker229"/>use the deformers on another mesh that is controlling<a id="_idIndexMarker230"/> the bones, which is sometimes called a ribbon rig, which is seen below in <em class="italic">Figure 4.9</em>. This image shows the ribbon on the left and the deformers that control the underlying joints of the necklace. The right side shows what the animator sees by hiding the underlying ribbon control.</p>
<figure class="mediaobject"><img alt="" height="133" src="../Images/B17304_04_09.png" width="825"/></figure>
<p class="packt_figref">Figure 4.9: Examples of a ribbon rig for Myvari’s necklace</p>
<h2 class="heading-2" id="_idParaDest-91">Controls</h2>
<p class="normal">Animators have the unique job<a id="_idIndexMarker231"/> in the 3D world of working with representations <a id="_idIndexMarker232"/>of the items they need to move in real time. Whether this is a box surrounding the hand or head, each shape gives the animator control. Each character will have controls unique to their needs. Myvari will have standard controls for a biped and extra controls for her clothing and trinkets. </p>
<p class="normal">Below in <em class="italic">Figure 4.10</em> is our character’s controls for her whole body.</p>
<figure class="mediaobject"><img alt="" height="754" src="../Images/B17304_04_10.png" width="728"/></figure>
<p class="packt_figref">Figure 4.10: Myvari’s whole-body controls</p>
<h2 class="heading-2" id="_idParaDest-92">Physics-based animation</h2>
<p class="normal">Some animation<a id="_idIndexMarker233"/> can be done through a simulation. There should be a bone<a id="_idIndexMarker234"/> attached to the mesh, but the DCC will perform physics movements that would be slightly constrained. These are very good to work with for chains, necklaces, and basically anything springy or dangly. These things are notoriously difficult to animate by hand, so it’s best to let the application handle it for you. In some cases, the game engine<a id="_idIndexMarker235"/> can handle all the physics-based animation and doesn’t need to be keyed<a id="_idIndexMarker236"/> by the animators. This means that the physics animation would be independent of the animation file itself, which would allow for a much smoother blending of animations.</p>
<h2 class="heading-2" id="_idParaDest-93">Human Inverse Kinematics (HIK) system</h2>
<p class="normal">Autodesk has created a biped rigging system<a id="_idIndexMarker237"/> to integrate multiple software easily. This is needed<a id="_idIndexMarker238"/> primarily for motion capture work where the animations are created through separate technologies. Motion capture is done through suits, facial capture devices, as well as specialized gloves.</p>
<p class="normal">The primary purpose of a <strong class="keyWord">Human Inverse Kinematics</strong> (<strong class="keyWord">HIK</strong>) rig is to gather animation data for the biped’s head, spine, arms, and legs. There is an advanced version that allows for fingers as well as more features on the arms and legs, such as twists. To gather more information about HIK skeletons, Autodesk has published documentation about how best to use it. For our demonstrations, we will not be using the HIK system. With Myvari, we will be doing all hand-keyed animations and no mocap work. In knowing this, we decided to stick to just keeping a custom rig and control system.</p>
<h2 class="heading-2" id="_idParaDest-94">Animation</h2>
<p class="normal">We have now designed, modeled, and rigged<a id="_idIndexMarker239"/> a character with controls. Now we can use our animation skills in our DCC to give some life to the character. When you are deciding what animations to make, be sure to give good thought to what personality the character has. Since we spent a good amount of time asking all the hard questions about our character’s motivations and desires, we should honor that with the correct movements expected of someone with that personality.</p>
<p class="normal">A strong way to work through animations is the same way that you would work through any art form. First, we will work with a blocking phase to get the timing right by working with just key poses. While you are doing this, get the key posing as strong as possible. Every keyframe should have a personality in it. If you look at the keyframe and cannot get a sense of the character, then it would not be considered “key” to the character. After you have blocked in some keyframes and moved them to get a sense of timing, this is when you would then add in-betweens. </p>
<p class="normal">These are keyframes in between the key poses in timing. These keys will help sell the movement within each key pose. </p>
<p class="normal">Once you get to this point, it can be a good idea<a id="_idIndexMarker240"/> to add it into the game engine to get a sense of actual movement with the character controller to see if what you see in the DCC translates into the game’s movement. Doing this at this stage is smart as you will have a good amount of time near the end of the project to polish all your animations after you learn how to move your character.</p>
<h1 class="heading-1" id="_idParaDest-95">Character controllers</h1>
<p class="normal">Now that we have put together<a id="_idIndexMarker241"/> a character design, model, and rig, we need to set up a <strong class="keyWord">controller</strong> to have them react to inputs. There are two general methods for character controllers. The built-in character controller that Unity provides will allow you to have a character walk around, up stairs, and easily build in further functions of interaction, but it has its limits. The largest limitation is that it is not used as a physics object. If you need your character to get pushed around by physics, there is a second option available. The second option is using a Rigidbody and collision capsule with a character script using these as restrictions to the physics engine. Just as you may have come to expect by now, to choose the correct option here we need to ask questions! The following are some examples:</p>
<ul>
<li class="bulletList">What are the primary mechanics?</li>
<li class="bulletList">Do I need physics for movements?</li>
<li class="bulletList">How many other limitations will there be for my character?</li>
</ul>
<p class="normal">After some time, you may learn to ask these questions very early when you start seeing what architecture may be needed to pull off the gameplay you want within Unity. This will only happen after leaving these questions unanswered and missing the mark slightly. Do not get discouraged by this. This is the best way of learning: failing fast and failing often. The options available to you are not always obvious.</p>
<p class="normal">An example of this is asking yourself what the primary mechanics are. Looking at your game, you may try to push crafting weapons in the game, but the combat mechanics are more fun during production. After finding this out, you may cut most of the crafting and put more effort into polishing the combat mechanics. What this does is place more emphasis on the character controller over UI or interactive crafting work.</p>
<p class="normal">In our game, we decided to take a simple approach to the character movement. We only need movement, and all other interactions will mostly be through mouse position and camera work. With that in mind, we will investigate the character controller foundation to build upon.</p>
<h2 class="heading-2" id="_idParaDest-96">Built-in character controller</h2>
<p class="normal">Unity has a built-in character controller<a id="_idIndexMarker242"/> component that can be added to your character. This will give you solid foundations to work with. It is simply a capsule collider that allows simple movement for a first-person or third-person game. The interesting portion of this is that it does not use physics or Rigidbodies for physics. Unity documentation explains this the best as a “Doom-style” controller: moving very fast<a id="_idIndexMarker243"/> and when you let go of the thumbstick, it stops immediately. This is sometimes desirable, but not often. An example of when this could be desirable is when you’re making a game where extremely tight controls are needed. Metroid uses this to flip the character left and right immediately. If you had to slow to a stop before turning, the game wouldn’t feel as good as it does.</p>
<p class="normal">The best part of this is that it is fast and easy to throw it on your character to get moving if you want to just test something simple. If you want to add jumping, floating, swimming, flying, or anything dealing with physics, this application will not work without a good amount of work.</p>
<p class="normal">We will be using the built-in character controller for this tutorial, as Myvari only needs to explore on the ground without jumping or sliding and none of her interactions use any focused physics.</p>
<h2 class="heading-2" id="_idParaDest-97">Rigidbody character controller</h2>
<p class="normal">This option for a component<a id="_idIndexMarker244"/> starts with coding in mind but offers a large amount of flexibility that the built-in character controller can’t provide for many purposes. The initial reasoning for using a Rigidbody is if you are looking to have different physics materials in your game. If your game is planning on utilizing physics in multiple ways, then it would be better to plan on working with the Rigidbody and collision components as your choice for physics on your character controller.</p>
<h1 class="heading-1" id="_idParaDest-98">Scripting your character’s movement</h1>
<p class="normal">When you’re scripting your character, it’s a good idea to have as many movement-related design conversations<a id="_idIndexMarker245"/> as you can to know what to architect out. For Myvari, we wanted to have a few movement-related specifics in the environment because this game is an environmental puzzle game. We should<a id="_idIndexMarker246"/> have the environment interact with her as she traverses it. Here is a list of what we went over:</p>
<ul>
<li class="bulletList">Idling</li>
<li class="bulletList">Walking:<ul>
<li class="bulletList">On the ground</li>
<li class="bulletList">In water</li>
<li class="bulletList">On ledges </li>
</ul>
</li>
<li class="bulletList">Rotation</li>
</ul>
<div class="note">
<p class="normal">There are two movement-related scripts<a id="_idIndexMarker247"/> that we, at this time, haven’t fully decided on implementing. These are running and jumping. The reason we aren’t going to implement these currently is that we do not know for certain that we need them. As we move through the level currently, it feels good walking through it, and we want the player to pay attention to the environment as well. We will set up the character controller to accept a running movement if we think it’s needed later. Jumping is similar, but we have no mechanics that require jumping up or over. You would only implement this to satisfy the need for jumping around in an environment. We may find that this is needed after some QA passes are done and player feedback states that they need to jump around. If this is a strong enough case, we can add it in.</p>
</div>
<h2 class="heading-2" id="_idParaDest-99">Initial setup in Unity</h2>
<p class="normal">To begin with, to get Myvari set up<a id="_idIndexMarker248"/> to even accept scripts<a id="_idIndexMarker249"/> for movement, we should set it up in Unity. We should already have Myvari imported into the Unity project. Just so you are aware, the way to go about this is just a simple drag and drop onto the project’s folder you want her to be in. If you select <code class="inlineCode">SM_Myvari</code> in the <code class="inlineCode">Character</code> folder, the Inspector will show the imported settings on the model, as shown in <em class="italic">Figure 4.11</em>. The default settings that are in use here are good for our needs.</p>
<figure class="mediaobject"><img alt="" height="301" src="../Images/B17304_04_11.png" width="774"/></figure>
<p class="packt_figref">Figure 4.11: Import settings Model tab</p>
<p class="normal">We need to move over to the <strong class="screenText">Rig</strong> tab and set up our rig. In <em class="italic">Figure 4.12</em>, we have a couple of options to go over. We want<a id="_idIndexMarker250"/> to make sure that <strong class="screenText">Animation Type</strong> is set to <strong class="screenText">Humanoid</strong>. We also want to create an avatar<a id="_idIndexMarker251"/> from this model and then configure it. This will open another window to set up the bones in the humanoid structure.</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="235" src="../Images/B17304_04_12.png" width="633"/></figure>
<p class="packt_figref">Figure 4.12: Import settings Rig tab</p>
<p class="normal">This window will default to the body portion, though we’re showing the head section in <em class="italic">Figure 4.13</em>. It’s best to go through every portion of the body as the avatar system will do its best to align the joints to the right location, but sometimes it doesn’t work out. If it isn’t set up properly, just select the correct joint to fill the slot properly.</p>
<figure class="mediaobject"><img alt="Graphical user interface  Description automatically generated with medium confidence" height="498" src="../Images/B17304_04_13.png" width="535"/></figure>
<p class="packt_figref">Figure 4.13: Import settings Rig, configure head portion</p>
<p class="normal">Before we set up the controller, we should have a chat about our decisions on how the game will be played. We have a third-person, over-the-shoulder<a id="_idIndexMarker252"/> play style. This means<a id="_idIndexMarker253"/> we must add a camera to the character. As such, we should make a <strong class="keyWord">Prefab</strong> with our character<a id="_idIndexMarker254"/> and our camera. To set this up, we make a Hierarchy that will allow for independent camera movement but keep the camera and character together. In <em class="italic">Figure 4.14 </em>you can see the way we set up the Prefab.</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="187" src="../Images/B17304_04_14.png" width="385"/></figure>
<p class="packt_figref">Figure 4.14: Character prefab hierarchy</p>
<p class="normal">The reason we set it up this way was that we wanted a container to hold both the camera and the character. The character GameObject<a id="_idIndexMarker255"/> holds all the scripts needed for the character. The mesh will hold the animator<a id="_idIndexMarker256"/> and avatar. The camera rig will house the camera as well as the scripts needed to maintain the camera in the position we want. Later in the book, when we get into the mechanics in <em class="chapterRef">Chapter 6</em>, <em class="italic">Interactions and Mechanics</em>, we will be going over <strong class="screenText">Cinemachine</strong> quite heavily as there are parts of the game where we will need to put the camera in a location for a cinematic.</p>
<p class="normal">For the rest of this chapter, we will go over just the basics of setting the character up for movement. On the character GameObject, let’s set up the components to get her moving around. As shown in <em class="italic">Figure 4.15</em>, we will add four more components. These are the character controller, our movement script, a Rigidbody component, and a player input system.</p>
<figure class="mediaobject"><img alt="" height="317" src="../Images/B17304_04_15.png" width="588"/></figure>
<p class="packt_figref">Figure 4.15: Character GameObject components</p>
<p class="normal">As stated previously, we will be using the base character<a id="_idIndexMarker257"/> controller. These settings are subjective, and we haven’t finalized<a id="_idIndexMarker258"/> them, but this is what we have so far. One note we should add here regards the <strong class="keyWord">center attribute</strong>. This is where the character controller<a id="_idIndexMarker259"/> thinks the center of the character is. It defaults to being on the ground, but you need to move it up so the capsule is closer to the center and slightly off the ground. We try to put it near the pelvis and then use the radius and height to encompass the general body of the character. We do this because the pelvis controls the overall height as the human structure has its center of mass in the belly button.</p>
<p class="normal">We’re going to skip over the movement script for now. The Rigidbody here is to help with future mechanics needs and physics-based work. We will cover this in <em class="chapterRef">Chapter 5</em>, <em class="italic">Environment</em>, and <em class="chapterRef">Chapter 6</em>, <em class="italic">Interactions and Mechanics</em>.</p>
<p class="normal"><strong class="keyWord">PlayerInput</strong> is a Unity system that sets up<a id="_idIndexMarker260"/> modular inputs to easily add different input systems without needing to change the code. Firstly, open your <strong class="screenText">Package Manager</strong> and see if the <strong class="screenText">Input System</strong> is installed. It would be part of the <strong class="screenText">Unity Registry</strong>. If it’s not installed, install it! If it is, then we need to make an input system for us to work with. </p>
<p class="normal">This can be done by adding a new asset called <strong class="screenText">Input Actions</strong>, as shown in <em class="italic">Figure 4.16</em>.</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" height="855" src="../Images/B17304_04_16.png" width="590"/></figure>
<p class="packt_figref">Figure 4.16: Adding an Input Actions asset</p>
<p class="normal">After you create the input action, name it according<a id="_idIndexMarker261"/> to your needs. We are naming<a id="_idIndexMarker262"/> ours <code class="inlineCode">Player Actions</code>. We are going to use this grouping of input actions specifically for any player actions needed. You may need other actions besides characters in your future projects. At this point, you will need to double-click the asset to open the <strong class="screenText">Input Actions</strong> window. Here, we will design the input options for use as currently needed for Myvari.</p>
<p class="normal"><em class="italic">Figure 4.17</em> shows a completed input system as we need it currently. We may add more inputs as the vertical slice continues to develop. </p>
<figure class="mediaobject"><img alt="Graphical user interface  Description automatically generated" height="313" src="../Images/B17304_04_17.png" width="825"/></figure>
<p class="packt_figref">Figure 4.17: Input Actions</p>
<p class="normal"><strong class="keyWord">Action Maps</strong> are groupings that have their own set<a id="_idIndexMarker263"/> of actions that can be called upon. Properties are details and options<a id="_idIndexMarker264"/> for the selected action. For this<a id="_idIndexMarker265"/> case, we only need inputs for Myvari, so we created a Myvari Action Mapping. Notice the capitalization of the <strong class="screenText">Action Mapping</strong> name, as it will be used in scripting once we get into the movement script. </p>
<p class="normal">In <strong class="screenText">Actions</strong>, the green sections are the actions themselves, the blue are the bindings, and the light red are the binding parts. For <strong class="screenText">Locomotion</strong> we only need to worry about a composite of vectors. When adding a new binding, if you press the plus (<strong class="screenText">+</strong>) symbol on the right of the action, you have two options. These are <strong class="screenText">Binding</strong> or <strong class="screenText">2D Vector Composite</strong>. When you click <strong class="screenText">2D Vector Composite</strong>, it automatically adds the <strong class="screenText">Up</strong>, <strong class="screenText">Down</strong>, <strong class="screenText">Left</strong>, and <strong class="screenText">Right</strong> composite parts. We are defining them as keyboard inputs currently to stick with a certain input system. There is a very interesting and useful tool when setting an action, called the <strong class="screenText">Listen</strong> button. Looking at <em class="italic">Figure 4.18</em>, you can see that it’s pressed and is listening for input. For us, being able to press the assumed button that may be pressed gives us a sense of immediate player feedback. If it feels odd at this point to assign a keystroke to an action, then it won’t feel much better during gameplay.</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" height="143" src="../Images/B17304_04_18.png" width="546"/></figure>
<p class="packt_figref">Figure 4.18: Listening for input</p>
<p class="normal">The <strong class="screenText">Look</strong> input is for camera <a id="_idIndexMarker266"/>movement, and we are using <strong class="screenText">Delta</strong> for mouse<a id="_idIndexMarker267"/> movement. Our <strong class="screenText">Aim</strong> action is meant for when you’re holding down the right mouse button for precision. This is choosing the <strong class="screenText">Action Type</strong> as a <strong class="screenText">button</strong> and expecting a right mouse button input. Finally, we have an <strong class="screenText">Interact</strong> button. This is the same as <strong class="screenText">Aim</strong> but designed for the <em class="keystroke">E</em> key to be hit at certain times. Those times will be defined in<em class="chapterRef">, Environment,</em> and <em class="chapterRef">, Interactions and Mechanics</em>.</p>
<p class="normal">We now have a setup for the inputs we as players put into the game. Even if we wrote scripts to work with this input system, it wouldn’t affect anything. So, before we start scripting, we need to put together the basics of the animation setup for Myvari. Let’s look at the animations we will need. For now, we only need <strong class="screenText">Idle</strong> and <strong class="screenText">Walk</strong> for animation transitioning. We do not need to set up <strong class="screenText">Interact</strong> just yet here as we do not currently have a use for it. In <em class="chapterRef">Chapter 5</em>, <em class="italic">Environment</em>, we will be looking at the use of <strong class="screenText">Interact</strong>.</p>
<h2 class="heading-2" id="_idParaDest-100">Idling</h2>
<p class="normal">Myvari may have to stand<a id="_idIndexMarker268"/> still for a time as the player looks around. Most of the time, there is no scripting involved when idling as this should be the standard state in your animation controller. When you bring the character into your Scene, you will need to add an <strong class="screenText">Animator</strong> component. See <em class="italic">Figure 4.19</em> for a correct configuration.</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="173" src="../Images/B17304_04_19.png" width="825"/></figure>
<p class="packt_figref">Figure 4.19: Animator component</p>
<p class="normal"><strong class="screenText">Controller</strong> and <strong class="screenText">Avatar</strong> will be empty. We need to create the controller by creating a new asset and going to <strong class="screenText">Create</strong> &gt; <strong class="screenText">Animator Controller</strong>. The controller is an interface between the code and visuals to move the skeletal mesh we want to animate. </p>
<p class="normal">With <strong class="screenText">Idle</strong>, we will make a default state and name it <code class="inlineCode">Idle</code>. You can see this in <em class="italic">Figure 4.20</em>. In the <strong class="screenText">Characters</strong> &gt; <strong class="screenText">Animations</strong> folder within the project, there are animations we’ve set up with Myvari. Select the <strong class="screenText">Idle</strong> state and drag the idle <a id="_idIndexMarker269"/>animation from that folder onto the <strong class="screenText">Motion</strong> parameter in the inspector, as shown in <em class="italic">Figure 4.21</em> below.</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" height="270" src="../Images/B17304_04_20.png" width="779"/></figure>
<p class="packt_figref">Figure 4.20: Controller state machine</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="383" src="../Images/B17304_04_21.png" width="734"/></figure>
<p class="packt_figref">Figure 4.21: Idle animation state inspector</p>
<p class="normal">When you have the idle animation in place, when you press <strong class="screenText">Play</strong>, the character will enter idle mode and loop that animation forever!</p>
<p class="normal">We also want to have a walk animation<a id="_idIndexMarker270"/> though. To add this, in an empty space, right-click and choose <strong class="screenText">Create State</strong> and then choose <strong class="screenText">Empty</strong>.</p>
<p class="normal">Name it <code class="inlineCode">Walk</code>. Select it and add the walking animation. After that, right-click on <strong class="screenText">Idle</strong> and choose <strong class="screenText">Make Transition</strong>, then left-click on the <strong class="screenText">Walk</strong> state. </p>
<p class="normal">This will make a transition from <strong class="screenText">Idle</strong> to <strong class="screenText">Walk</strong>. Do the same thing from the <strong class="screenText">Walk</strong> state back to <strong class="screenText">Idle</strong>. This allows us to set up parameters to transition to and from <strong class="screenText">Idle</strong> and <strong class="screenText">Walk</strong>. We will now add a parameter of <code class="inlineCode">isWalking</code> to the controller, as seen in <em class="italic">Figure 4.22</em>.</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" height="226" src="../Images/B17304_04_22.png" width="409"/></figure>
<p class="packt_figref">Figure 4.22 Controller parameters</p>
<p class="normal">The <strong class="screenText">Parameters</strong> section is found on the upper left of the controller. We want to make a bool and name it <code class="inlineCode">isWalking</code>. We will be using this parameter in the transition points. If you select the transition from the <strong class="screenText">Idle</strong> to <strong class="screenText">Walk</strong> states, you will see the transition from one animation to the other in the inspector. At the bottom of the inspector are conditions. Let’s add a condition and set it to <strong class="screenText">isWalking is True</strong>. The animation state of <strong class="screenText">Idle</strong> will change to <strong class="screenText">Walk</strong> when <code class="inlineCode">isWalking</code> is <code class="inlineCode">true</code>. You can then do the opposite to revert to <strong class="screenText">Idle</strong>.</p>
<p class="normal">We now have inputs and animations in place with a transition ready to listen to the character logic. We now need to get in there and get the movement script working. Let’s dive into the code!</p>
<h2 class="heading-2" id="_idParaDest-101">Code entry point</h2>
<p class="normal">We wanted to add a small section here explaining<a id="_idIndexMarker271"/> how we will go over the code. In <em class="chapterRef">Chapter 3</em>, <em class="italic">Programming</em>, we went step by step through every line to go over the basics of code. What we plan on doing here is having the script in its entirety available to you, with full comments so you can read it if you’re more comfortable with code. In the rest of this chapter, we will be going over small parts we haven’t been over previously and explaining them as tools. We encourage you to build your own scripts and work with the tools we go over to build your own character movement scripts.</p>
<p class="normal">We are going to be working through the <code class="inlineCode">MyvariThirdPersonMovement.cs</code> file. We have some simple work here as well as a complicated function. While we are going through this, know that it is OK not to fully grasp everything that is discussed. By noticing the hard parts and working through them, you are solidifying that knowledge and understanding how to work as a developer in Unity.</p>
<h2 class="heading-2" id="_idParaDest-102">RequireComponent</h2>
<p class="normal">When you see a <code class="inlineCode">RequireComponent</code> above the class definition, this is saying that the GameObject <a id="_idIndexMarker272"/>that this script is attached to is required to have something. In our case, we want <code class="inlineCode">MyvariThirdPersonMovement.cs</code> on the character, and we need to ensure it has a character controller. Something that is very helpful is that if Unity sees that the GameObject you attach this to doesn’t have the required component, it will just attach it to the GameObject for you! Isn’t that nice? We think so.</p>
<pre class="programlisting code"><code class="hljs-code">[<span class="hljs-meta">RequireComponent(typeof(CharacterController))</span>]
</code></pre>
<h2 class="heading-2" id="_idParaDest-103">Update code</h2>
<p class="normal">We’re going to go through this part in a bit of detail as each line<a id="_idIndexMarker273"/> goes in-depth about the previous information and it’s difficult to explain a single line at the end without showing the context. For the first part, we want to ensure that if the character is grounded and their velocity isn’t above <em class="italic">0</em>, it is set to <em class="italic">0</em>. Sometimes GameObjects will move in small increments in the <em class="italic">y</em> direction. This isn’t a common occurrence, however sometimes in 3D applications, rotations and movement causing rounding to happen for values and velocity can increment when it shouldn’t. This can be prevented by using these few lines of code.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (controller.isGrounded &amp;&amp; playerVelocity.y &lt; <span class="hljs-number">0</span>)
        {
            playerVelocity.y = <span class="hljs-number">0f</span>;
        }
</code></pre>
<p class="normal">In the next section<a id="_idIndexMarker274"/> we are breaking down the code we’ve written to ensure a thorough explanation leading up to the character movement script assignment in the Editor. </p>
<p class="normal">If you recall at the start of the <em class="italic">Scripting your character movement </em>section of this chapter, walking through water was one of the movements we wanted to have set up. We need to check if the character is in water to know how to set up that logic. We will be using a method from the <strong class="screenText">Physics</strong> library called <strong class="screenText">Raycast</strong>, which takes arguments, as seen in the helper tooltip in <em class="italic">Figure 4.23</em> below.</p>
<p class="packt_figref"><img alt="Graphical user interface, text  Description automatically generated" height="129" src="../Images/B17304_04_23.png" width="616"/></p>
<p class="packt_figref">Figure 4.23: Physics.Raycast arguments</p>
<p class="normal">When a Raycast is used, its arguments are as follows: <strong class="screenText">origin</strong>, <strong class="screenText">direction</strong>, <strong class="screenText">hitInfo</strong>, <strong class="screenText">maxDistance</strong>, and <strong class="screenText">layerMask</strong>:</p>
<ul>
<li class="bulletList">We define <strong class="screenText">origin</strong> as this GameObject’s position plus one unit in the up direction</li>
<li class="bulletList"><strong class="screenText">direction</strong> is the down direction</li>
<li class="bulletList"><strong class="screenText">hitInfo</strong> is being saved as a <code class="inlineCode">RayCastHit</code> named <code class="inlineCode">hit</code></li>
<li class="bulletList"><strong class="screenText">maxDistance</strong> is set to 2 units </li>
<li class="bulletList"><strong class="screenText">layerMask</strong> is set to <code class="inlineCode">waterLayer</code></li>
</ul>
<p class="normal">To test this, make a cube and select <strong class="screenText">Water</strong> for its layer value in the inspector. We will call for this <code class="inlineCode">waterLayer</code> check during the <code class="inlineCode">controller.Move</code> portion at the bottom.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// Check for water</span>
standingInWater = Physics.Raycast(transform.position + Vector3.up, Vector3.down, <span class="hljs-keyword">out</span> RaycastHit hit, <span class="hljs-number">2f</span>, waterLayer);
</code></pre>
<p class="normal">This next part is where the <strong class="screenText">Input System</strong> is reading the value<a id="_idIndexMarker275"/> of the locomotion we put together. The <strong class="screenText">movement</strong> variable is a <code class="inlineCode">Vector2,</code> or <em class="italic">x </em>and <em class="italic">y</em> only. So, we will need to manipulate this to make sure it makes sense for a 3D movement.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// read in the values of the input action assigned to this script</span>
Vector2 movement = movementControl.action.ReadValue&lt;Vector2&gt;();
</code></pre>
<p class="normal">We make a <code class="inlineCode">Vector3</code> and place the <em class="italic">x</em> and <em class="italic">y</em> from the read value while keeping the <em class="italic">y</em> of the <code class="inlineCode">Vector3</code> as <em class="italic">0</em>.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// Use the values from the inputs and put them into a vector3, leaving up blank</span>
Vector3 move = <span class="hljs-keyword">new</span> Vector3(movement.x, <span class="hljs-number">0</span>, movement.y);
</code></pre>
<p class="normal">We now need to think about the character and camera coordination. We have a <code class="inlineCode">move</code> variable that has the <code class="inlineCode">movement</code> we need to move toward, but the camera may be looking in another direction other than straight forward relative to your character. So, let’s take that into account before moving.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// take into account the camera's forward as this needs to be relative to the view of the camera</span>
move = cameraMainTransform.forward * move.z + cameraMainTransform.right * move.x;
</code></pre>
<p class="normal">Then we again just zero out that <em class="italic">y</em> value. If we were to implement jumping sometime later, we would need to change this from <em class="italic">0</em> to different values depending on the jump.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// zero out that y value just in case ;)</span>
move.y = <span class="hljs-number">0.0f</span>;
</code></pre>
<p class="normal">Here we go. Now it’s time to move the character. We’ve thought about all the possible problems we could have with the camera, character, and type of terrain. The standard Unity character controller has a method named <strong class="screenText">Move</strong>. This method takes a single argument, a <code class="inlineCode">Vector3</code>. This tells the character which way to go. We need to take advantage of a few things. How fast are they moving? Are they in water? Something new we are using<a id="_idIndexMarker276"/> here is something called a <strong class="keyWord">ternary</strong>. </p>
<p class="normal">Let’s give a slight explanation before we get into the next line of code. This is the ternary function. What is being said here is this:</p>
<pre class="programlisting code"><code class="hljs-code">If standingInWater <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> whatever the <span class="hljs-keyword">value</span> of waterSlowFactor <span class="hljs-keyword">is</span>. Otherwise, <span class="hljs-keyword">this</span> will be <span class="hljs-number">1f</span>.
(standingInWater ? waterSlowFactor : <span class="hljs-number">1f</span>)
</code></pre>
<p class="normal">This is handy! We can slow<a id="_idIndexMarker277"/> the character down by a tunable value easily and if we aren’t in water, she moves at the regular rate we have already designed.</p>
<pre class="programlisting code"><code class="hljs-code">controller.Move(move * Time.deltaTime * playerSpeed * (standingInWater ? waterSlowFactor : <span class="hljs-number">1f</span>));
</code></pre>
<p class="normal">We have gravity defined at the top of this class, and we set the velocity to that gravity value multiplied by the change in time to account for framerate. This will not be accounted for unless Myvari is not grounded due to the <code class="inlineCode">if</code> statement on top of the update function, which sets the <code class="inlineCode">velocity.y</code> to <em class="italic">0</em> if it’s less than <em class="italic">0</em> and <code class="inlineCode">isGrounded</code>.</p>
<pre class="programlisting code"><code class="hljs-code">playerVelocity.y += gravityValue * Time.deltaTime;
controller.Move(playerVelocity * Time.deltaTime);
</code></pre>
<p class="normal">Here we are calling two methods to handle rotation and animation states.</p>
<pre class="programlisting code"><code class="hljs-code">HandleRotation(movement);
HandleAnimation(movement);
</code></pre>
<h2 class="heading-2" id="_idParaDest-104">Methods</h2>
<p class="normal">In an effort to keep the update loop<a id="_idIndexMarker278"/> as clean as possible, we refactored out handling the rotation and animation from the <code class="inlineCode">Update</code> function. </p>
<p class="normal">Refactoring is the process of restructuring existing code to make it more readable. It’s running in the update, but it’s only called one line per method. The initial method we’d like to go over is the <code class="inlineCode">HandleAnimation</code> method. This takes a <code class="inlineCode">Vector2</code> as an input, which is the direct input to the <code class="inlineCode">Vector2</code> reading from the input system. We are only worried about the single animation parameter <code class="inlineCode">isWalking</code>.</p>
<p class="normal">We first get the value of the bool at its current state and store it in a local variable. Then we check if either of the vectors in the input movement is nonzero as well as if <code class="inlineCode">isWalking</code> is currently <code class="inlineCode">false</code>. If so, we set the animator bool to <code class="inlineCode">true</code>. Otherwise, we set it to <code class="inlineCode">false</code>. When this bool changes, it will update in the controller and set the animations to the appropriate state.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">HandleAnimation</span><span class="hljs-function">(</span><span class="hljs-params">Vector2 movement</span><span class="hljs-function">)</span>
    {
        <span class="hljs-built_in">bool</span> isWalking = animator.GetBool(<span class="hljs-string">"isWalking"</span>);
        <span class="hljs-keyword">if</span> (movement != Vector2.zero &amp;&amp; !isWalking)
        {
            animator.SetBool(<span class="hljs-string">"isWalking"</span>, <span class="hljs-literal">true</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(movement != Vector2.zero) &amp;&amp; isWalking)
        {
            animator.SetBool(<span class="hljs-string">"isWalking"</span>, <span class="hljs-literal">false</span>);
        }
    }
</code></pre>
<p class="normal">This is the most advanced method<a id="_idIndexMarker279"/> we have going on here. We think it’s a smart idea to get out of our comfort zones as often as possible to continue growth. We will walk through this and if it’s not making sense right now, let it sink in and your brain will work through it. There are three actions taking place here. We need to find the angle we want to rotate to, get a rotation value, and then rotate!</p>
<p class="normal">Firstly, <code class="inlineCode">targetAngle</code> is doing a <code class="inlineCode">Mathf</code> method called <code class="inlineCode">Atan2</code>. <code class="inlineCode">Atan2</code> is an arctangent method that allows you to find the angle given the target position of where you want to rotate to. It’s an interesting method that is very useful in games for character rotations in 3D applications. The problem is that we need to also account for the camera again. <code class="inlineCode">Atan2</code> returns radians, so we need to multiply it by the radians-to-degrees constant and then add the camera’s <em class="italic">y</em> angle. This is the offset from the character’s angle.</p>
<p class="normal">Next, we then take that target angle and create a quaternion from it in the current camera angle on the <em class="italic">y</em> axis. This will allow us to get an angle<a id="_idIndexMarker280"/> we will need to go to without worrying about <strong class="keyWord">gimbal locking</strong> occurring. Gimbal locking is when two axes get stuck in rotation due to one axis being 90 degrees off center. Quaternions are not susceptible to gimbal locking, which is why we transfer to quaternions in the end from the Euler angles.</p>
<p class="normal">By definition, Euler angles are oriented with respect to a fixed coordinate system. This is how we represent the angle we are at in the game where the reference is from <em class="italic">0</em>, <em class="italic">0</em>, <em class="italic">0</em> in rotation on import. If you rotate the character 90 degrees on the <em class="italic">y</em> axis, it is represented as <em class="italic">0</em>, <em class="italic">90</em>, <em class="italic">0</em> in the rotational fields of the transform of that GameObject. These values are Euler angles.</p>
<p class="normal">Finally, we need to transition <a id="_idIndexMarker281"/>to that rotation value. We do this through a <strong class="keyWord">Slerp</strong>. This stands for a <strong class="keyWord">spherical lerp</strong>. When working with rotations, it’s best to use the Slerp method. The arguments are our current rotation, the new rotation we just made, and then how long it should take to rotate to that new position. We made this rotation speed publicly available so we could change it on the fly to get the variable that feels best.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function">Void </span><span class="hljs-title">HandleRotation</span><span class="hljs-function">(</span><span class="hljs-params">Vector2 movement</span><span class="hljs-function">)</span>
    {
        <span class="hljs-keyword">if</span> (movement != Vector2.zero)
        {
            <span class="hljs-built_in">float</span> targetAngle = Mathf.Atan2(movement.x, movement.y) *    Mathf.Rad2Deg + cameraMainTransform.eulerAngles.y;
            Quaternion rotation = Quaternion.Euler(<span class="hljs-number">0.0f</span>, targetAngle, <span class="hljs-number">0.0f</span>);
            transform.rotation = Quaternion.Slerp(transform.rotation, rotation, rotFactorPerFrame * Time.deltaTime);
        }
    }
</code></pre>
<p class="normal">After this is done, your character now has movement and rotation. This is a great first step to building out an environmental, narrative-driven exploration game. Let’s finish up with a summary of what the whole chapter covered.</p>
<h1 class="heading-1" id="_idParaDest-105">Summary</h1>
<p class="normal">In this chapter, we covered a large amount of character information. We went through design, modeling and rigging, character controllers, rigid bodies, working in Unity, and scripting a movement controller.</p>
<p class="normal">Design will always be boiled down to the question of “why?” You should’ve taken away from this chapter that the why of your character and their motivations will help secure a unique character that can be relatable. Modeling and rigging are heavily dependent on the type of modeling you will need to do. We went over some key methods to help guide your modeling to think of animation first. This also applies to rigging. Animation will be the final stage, and the easier it is to properly animate, the easier you and your players will find a better overall experience. Animations tend to be continually worked on until very close to release. Take the design of the rig seriously, as making changes after animations start could end up requiring a remake of animations.</p>
<p class="normal">We realized that Unity built-in character controller makes the most sense to us as we don’t need Myvari to be tossed around by physics, such as ragdolling. We then went into Unity and imported Myvari and went over the components needed to get input as well as animations for her. Finally, we finished going over a character script for movement and rotations. </p>
<p class="normal">In the next chapter, we will look at the environment, the terrain, and a tool called ProBuilder.</p>
<h1 class="heading-1" id="_idParaDest-106">Join us on Discord!</h1>
<p class="normal">At the time of writing this book, we had over 200 Unity professionals on the Unity server and we are constantly adapting to add new channels to facilitate conversations on key topics such as C# programming, game mechanics, game UI, animations, 3D games, sound and effects, and a dedicated channel for Packt authors to connect with the book’s readers.</p>
<p class="normal">Tell us about your progress made so far and the game idea you have in mind to build alongside this book. You never know—you might end up collaborating with someone on the server to build your mini-team today.</p>
<p class="normal"><a href="https://packt.link/unity3dgamedev"><span class="url">https://packt.link/unity3dgamedev</span></a></p>
<p class="normal"><span class="url"><img alt="" height="177" src="../Images/QR_Code89002272-1876859406.png" width="177"/></span></p>
</div>
</div></body></html>