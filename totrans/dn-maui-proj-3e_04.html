<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor274"/>4</h1>
<h1 id="_idParaDest-90"><a id="_idTextAnchor275"/>Building a News App Using .NET MAUI Shell</h1>
<p>In this chapter, we will create a news app that leverages the <strong class="bold">Shell</strong> navigation functionality provided to us by the .NET MAUI team at Microsoft. The old way of doing this, which involved using <strong class="bold">ContentPage</strong>, <strong class="bold">FlyoutPage</strong>, <strong class="bold">TabbedPage</strong>, or <strong class="bold">NavigationPage</strong> as the main page, as we did in <em class="italic">Chapter 2</em>, still works, but we are sure that you will enjoy the new way of defining the structure of your app. Also, you can mix and match the old and new.</p>
<p>By the end of this chapter, you will have learned how to define an app structure using Shell, consume data from a REST API, configure navigation, and pass data between views using query-style routes.</p>
<p>So, what is Shell, then? In Shell, you define the structure of your app using <strong class="bold">Extensible Application Markup Language</strong> (<strong class="bold">XAML</strong>) instead of hiding it in spread-out pieces of code in your app. You can also navigate using routes, just like those fancy web developers are doing.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Defining a Shell navigation page</li>
<li>Creating a flyout</li>
<li>Creating a navigation bar</li>
<li>Navigating using routes and passing data in query strings</li>
<li>Consuming data from a public <strong class="bold">representational state transfer</strong> (<strong class="bold">REST</strong>) <strong class="bold">application programming </strong><strong class="bold">interface</strong> (<strong class="bold">API</strong>)</li>
<li>Adding content in the form of a <code>CollectionView</code> control</li>
</ul>
<h1 id="_idParaDest-91"><a id="_idTextAnchor276"/><a id="_idTextAnchor277"/>Technical requirements</h1>
<p>To be able to complete this project, you will need to have Visual Studio for Mac or Windows installed, as well as the necessary .NET MAUI workload components. See <em class="italic">Chapter 1</em>, <em class="italic">Introduction to .NET MAUI</em>, for more details on how to set up your environment.</p>
<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition">https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition</a>.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor278"/>Project overview</h1>
<p>We will create a .NET MAUI project using the <strong class="bold">single-project</strong> feature as the code-sharing strategy. It will contain two parts, detailed as <a id="_idIndexMarker438"/><a id="_idIndexMarker439"/>follows:</p>
<ul>
<li>In the first part, we will create views and make them navigable using Shell</li>
<li>In the second part, we will add some content by consuming a <strong class="bold">REST API</strong> for news</li>
</ul>
<p>The second part is not needed to learn about Shell, but it will take you a bit further down the road to a complete app.</p>
<p>The build time for this project is about 1.5 hours.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor279"/><a id="_idTextAnchor280"/>Building the news app</h1>
<p>This chapter will be all about building <a id="_idIndexMarker440"/><a id="_idIndexMarker441"/>a news app from the beginning. It will guide you through every step, but it will not go into every detail. For that, we recommend <em class="italic">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>, which goes into more detail.</p>
<p>Happy coding!</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor281"/>Setting up the project</h2>
<p>This project, like all the rest, is a <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project...</strong>-style project. This means that we will not be importing any code at all. So, this first section<a id="_idIndexMarker442"/><a id="_idIndexMarker443"/> is all about creating the project and setting up the basic project structure.</p>
<h3><a id="_idTextAnchor282"/><a id="_idTextAnchor283"/>Creating the new project</h3>
<p><a id="_idTextAnchor284"/>The first step is to <a id="_idIndexMarker444"/><a id="_idIndexMarker445"/>create a new .NET MAUI project:</p>
<ol>
<li>Open Visual Studio 2022 and select <strong class="bold">Create a </strong><strong class="bold">new project</strong>:</li>
</ol>
<div><div><img alt="Figure 4.1 – Visual Studio 2022" src="img/Figure_4.1_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Visual Studio 2022</p>
<p class="list-inset"><a id="_idTextAnchor285"/>This will open the <strong class="bold">Create a new </strong><strong class="bold">project</strong> wizard.</p>
<ol>
<li value="2">In the search field, type<a id="_idIndexMarker446"/><a id="_idIndexMarker447"/> in <code>maui</code> and select the <strong class="bold">.NET MAUI App</strong> item from the list:</li>
</ol>
<div><div><img alt="Figure 4.2 – Create a new project" src="img/Figure_4.2_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Create a new project</p>
<ol>
<li value="3">Cl<a id="_idTextAnchor286"/>ick <strong class="bold">Next</strong>.</li>
<li>Enter <code>News</code> as the <a id="_idIndexMarker448"/><a id="_idIndexMarker449"/>name of the app, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 4.3 – Configure your new project" src="img/Figure_4.3_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Configure your new project</p>
<ol>
<li value="5">Click <strong class="bold">Next</strong>.</li>
<li>The last step will prompt you for the version of .NET Core to support. At the time of writing, .NET 6 is available as <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>), and .NET 7 is available as <strong class="bold">Standard Term Support</strong>. For this book, we will assume that you will be using .NET 7:</li>
</ol>
<div><div><img alt="Figure 4.4 – Additional information" src="img/Figure_4.4_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Additional information</p>
<ol>
<li value="7">Finalize the setup by clicking <strong class="bold">Create</strong> and wait for Visual Studio to create the project.</li>
</ol>
<p>That’s it for project creation.</p>
<p>Let<a id="_idTextAnchor287"/><a id="_idTextAnchor288"/><a id="_idTextAnchor289"/>’s continue by setting up the <a id="_idIndexMarker450"/><a id="_idIndexMarker451"/>structure of the app.</p>
<h2 id="_idParaDest-95">Crea<a id="_idTextAnchor290"/><a id="_idTextAnchor291"/><a id="_idTextAnchor292"/>ting the structure of the app</h2>
<p>In this section, we will start to build the <a id="_idIndexMarker452"/><a id="_idIndexMarker453"/><strong class="bold">Views</strong> and <strong class="bold">ViewModels</strong> of the app. The <em class="italic">Using MVVM – creating views and ViewModels</em> section in <em class="italic">Chapter 2</em> contains more details on <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) as a design pattern. It’s recommended that you read that first if you don’t know what MVVM is.</p>
<h3>Crea<a id="_idTextAnchor293"/><a id="_idTextAnchor294"/><a id="_idTextAnchor295"/><a id="_idTextAnchor296"/><a id="_idTextAnchor297"/>ting the ViewModel base class</h3>
<p><code>ViewModel</code> is the mediator between <code>View</code> and <code>Model</code>. Let’s create a base class for <code>ViewModels</code> with common functionality that we can reuse. In<a id="_idIndexMarker454"/><a id="_idIndexMarker455"/> practice, <code>ViewModel</code> must implement an interface called <code>INotifyPropertyChanged</code> for MVVM to function. We will do so in the base class and will also add a little handy helper tool called <strong class="bold">CommunityToolkit.Mvvm</strong> that will save us a lot of time. Again, please check out <em class="italic">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>, if you are feeling unsure about MVVM.</p>
<p>The first step is to create a base<a id="_idIndexMarker456"/><a id="_idIndexMarker457"/> class. Proceed as follows:</p>
<ol>
<li>In the <code>News</code> project, create a folder called <code>ViewModels</code>.</li>
<li>In the <code>ViewModels</code> folder, create a class called <code>ViewModel</code>.</li>
<li>Change the existing class so that it looks as follows:<pre class="source-code">
namespace News.ViewModels;
public abstract class ViewModel
{
}</pre></li> </ol>
<p>Excellent! Let’s implement <code>INotifyPropertyChanged</code> in the base <code>ViewModel</code> class.</p>
<h4>A quick recap of CommunityToolkit.Mvvm</h4>
<p>CommunityToolkit.Mvvm is a NuGet package that <a id="_idIndexMarker458"/><a id="_idIndexMarker459"/>contains a few source generators that can automatically generate the necessary implementation details for <code>INotifyPropertyChanged</code>. More specifically, it will inject a call that will raise the <code>PropertyChanged</code> event whenever a setter is called. It also takes care of property dependencies; if I change the <code>FirstName</code> property, the <code>FullName</code> read-only property will also get a <code>PropertyChanged</code> event. Before CommunityToolkit.Mvvm, you would have had to write this code manually.</p>
<p>It’s all explained in more detail in <em class="italic">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>. Have you <a id="_idTextAnchor298"/>read it yet?</p>
<h4>Adding a reference to CommunityToolkit.Mvvm</h4>
<p>CommunityToolkit.Mvvm and its <a id="_idIndexMarker460"/><a id="_idIndexMarker461"/>dependencies are installed using NuGet. So, let’s install the NuGet package:</p>
<ol>
<li>In the <code>News</code> project, install the CommunityToolkit.Mvvm NuGet package, version 8.0.0.</li>
<li>Accept any license dialog boxes.</li>
</ol>
<p>This will install the relevant NuGet packages.</p>
<h4>Implementing INotifyPropertyChanged</h4>
<p><code>ViewModel</code> sits between <code>View</code> and <code>Model</code>. When a change in <code>ViewModel</code> occurs, <code>View</code> must be notified. The mechanism for this is the <code>INotifyPropertyChanged</code> interface, which defines an event that the <a id="_idIndexMarker462"/><a id="_idIndexMarker463"/>controls in <code>View</code> subscribe to. The <code>ObservableObject</code> attribute is the magic that will generate the <code>INotifyPropertyChanged</code> implementation for us. Follow these steps:</p>
<ol>
<li>In the <code>News</code> project, open up <code>ViewModels.cs</code>.</li>
<li>Add the following code in bold:<pre class="source-code">
<strong class="bold">using CommunityToolkit.Mvvm.ComponentModel;</strong>
<strong class="bold">[ObservableObject]</strong>
public abstract <strong class="bold">partial</strong> class ViewModel
{
}</pre></li> </ol>
<p>This instructs CommunityToolkit.Mvvm to implement the <code>INotifyPropertyChanged</code> interface. The next step is all about reducing the number of lines of code that we will have to write. Normally, you would have to manually raise the <code>PropertyChanged</code> event from your code, but thanks to source generators, which write code at <a id="_idIndexMarker464"/><a id="_idIndexMarker465"/>build time, we simply have to create normal properties and let CommunityToolkit.Mvvm do the magic.</p>
<p>Let’<a id="_idTextAnchor299"/>s move on and create our first <code>ViewModel</code>.</p>
<h4>Crea<a id="_idTextAnchor300"/><a id="_idTextAnchor301"/><a id="_idTextAnchor302"/>ting the HeadlinesViewModel class</h4>
<p>We will now start to create some <code>View</code> and <code>ViewModel</code> placeholders that we will expand on during this chapter. We will not directly <a id="_idIndexMarker466"/><a id="_idIndexMarker467"/>implement all graphical features; instead, we’ll keep it simple and think of all these pages as placeholders for what’s to come next.</p>
<p>The first one is the <code>HeadlinesViewModel</code> class, which will serve as the <code>ViewModel</code> for <code>HeadlinesView</code>. Proceed as follows:</p>
<ol>
<li>In the <code>News</code> project, under the <code>ViewModels</code> folder, create a new class called <code>Head</code><strong class="source-inline">
</strong><code>linesViewModel</code>.</li>
<li>Edit the class so that it inherits from the <code>ViewModel</code> base class, as shown in bold in the following code snippet:<pre class="source-code">
namespace News.ViewModels;
public class HeadlinesViewModel : <strong class="bold">ViewModel</strong>
{
    public HeadlinesViewModel()
    {
    }
}</pre></li> </ol>
<p>OK – not bad. It doesn’t do much yet, but we’ll just leave it for now. Let’s create the matc<a id="_idTextAnchor303"/>hing view.</p>
<h4>Crea<a id="_idTextAnchor304"/>ting HeadlinesView</h4>
<p>This view will eventually show <a id="_idIndexMarker468"/><a id="_idIndexMarker469"/>a list of news, but for now, it will be kept simple. Follow these steps to create the page:</p>
<ol>
<li>In the <code>News</code> project, create a folder named <code>Views</code>.</li>
<li>Right-click on the <code>Views</code> folder, select <strong class="bold">Add</strong>, and then click <strong class="bold">New Item...</strong>.<p class="list-inset">If you are using Visual Studio 17.7 or later, click the <strong class="bold">Show all Templates</strong> button in the dialog that pops up. Otherwise, move on to the next step.</p></li>
<li>Under the <strong class="bold">C# Items</strong> node on the left, select <strong class="bold">.</strong><strong class="bold">NET MAUI</strong>.</li>
<li>Select <code>HeadlinesView</code>.</li>
<li>Click <strong class="bold">Add</strong> to create the page.<p class="list-inset">Refe<a id="_idTextAnchor305"/>r to the following screenshot to view the preceding information:</p></li>
</ol>
<div><div><img alt="Figure 4.5 – Add New Item" src="img/Figure_4.5_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Add New Item</p>
<p>Let’s add some placeholder code to <code>HeadlinesView</code>, just to have something to navigate to and from. We will replace it with something hotter later on in this <a id="_idIndexMarker470"/><a id="_idIndexMarker471"/>chapter, but to keep things simple, let’s add a label. To do so, proceed as<a id="_idIndexMarker472"/><a id="_idIndexMarker473"/> follows:</p>
<ol>
<li>In the <code>News</code> project, under the <code>Views</code> folder, open <code>HeadlinesView.xaml</code>.</li>
<li>Edit the XAML code by adding the following code marked in bold:<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
             
    x:Class="News.Views.HeadlinesView"
    Title="<strong class="bold">Home</strong>"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Label
            Text="<strong class="bold">HeadLinesView!</strong>"
            VerticalOptions="Center"
            HorizontalOptions="Center" /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre></li> </ol>
<p>This <a id="_idTextAnchor306"/>will set the title of the page and add a label with the text <code>HeadlinesView</code> centered in the m<a id="_idTextAnchor307"/>iddle of the page. Let’s move on and create <a id="_idIndexMarker474"/><a id="_idIndexMarker475"/>some additional view placeholders.</p>
<h4>Creat<a id="_idTextAnchor308"/>ing ArticleItem</h4>
<p>The app will eventually display a list of articles where each article will be rendered using a reusable component. We will call this reusable component <code>ArticleItem</code>. In .NET MAUI, a reusable component is called a <strong class="bold">ContentView</strong>. Please don’t confuse this with an<a id="_idIndexMarker476"/><a id="_idIndexMarker477"/> MVVM View, which is represented by a page in .NET MAUI. We know that this is confusing, but the rule is that a .NET MAUI page is an MVVM View and a .NET MAUI ContentView is essentially a reusable control.</p>
<p>That said, let’s create the <code>ArticleItem</code> class, as follows:</p>
<ol>
<li>In the <code>News</code> project, right-click the <code>Views</code> folder, select <strong class="bold">Add</strong>, and then click <strong class="bold">New Item...</strong>.<p class="list-inset">If you are using Visual Studio 17.7 or later, click the <strong class="bold">Show all Templates</strong> button in the dialog that pops up. Otherwise, move on to the next step.</p></li>
<li>Under the <strong class="bold">C# Items</strong> node on the left, select <strong class="bold">.</strong><strong class="bold">NET MAUI</strong>.<p class="list-inset"><em class="italic">Important</em>: Make sure that you select the <strong class="bold">ContentView</strong> template in the next step and <em class="italic">not</em> the <strong class="bold">ContentPage</strong> template.</p></li>
<li>Select <code>ArticleItem</code>.</li>
<li>Click <strong class="bold">Add</strong> to create the view.</li>
</ol>
<p>Refer<a id="_idTextAnchor309"/> to the following screenshot to view the preceding information:</p>
<div><div><img alt="Figure 4.6 – Add New Item – ArticleItem.xaml" src="img/Figure_4.6_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Add New Item – ArticleItem.xaml</p>
<p>We don<a id="_idTextAnchor310"/>’t need to alter the XAML code that’s been generated at this point, so we’ll simply leave it as is.</p>
<h4>Creati<a id="_idTextAnchor311"/>ng ArticleView</h4>
<p>In the previous section, we created the <code>ArticleItem</code> content view. This view (<code>ArticleView</code>) will contain <code>WebView</code> to display each article. But<a id="_idIndexMarker478"/><a id="_idIndexMarker479"/> for the moment, let’s just add <code>ArticleView</code> as a placeholder. Follow these steps to do so:</p>
<ol>
<li>In the <code>News</code> project, right-click the <code>Views</code> folder, select <strong class="bold">Add</strong>, and then click <strong class="bold">New Item...</strong>.<p class="list-inset">If you are using Visual Studio 17.7 or later, click the <strong class="bold">Show all Templates</strong> button in the dialog that pops up. Otherwise, move on to the next step.</p></li>
<li>Select <strong class="bold">.NET MAUI</strong> under the <strong class="bold">C# Items</strong> node on the left.</li>
<li>Select <code>ArticleView</code>.</li>
<li>Click <strong class="bold">Add</strong> to create the page.</li>
</ol>
<p>Since <a id="_idTextAnchor312"/>this view is also a placeholder view at the moment, we’ll just add a label to indicate the type of page. Edit the content by following these steps:</p>
<ol>
<li>In the <code>News</code> project, open <code>ArticleView.xaml</code>.</li>
<li>Edit the XAML code by adding the following code marked in bold:<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
             
    x:Class="News.Views.ArticleView"
    Title="ArticleView"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Label
            Text="<strong class="bold">ArticleView!</strong>"
            VerticalOptions="Center"
            HorizontalOptions="Center" /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre></li> </ol>
<p>Alright – just one more view to mock <a id="_idIndexMarker480"/><a id="_idIndexMarker481"/>before we can start to wire things up.</p>
<h4>Creati<a id="_idTextAnchor313"/><a id="_idTextAnchor314"/>ng AboutView</h4>
<p>The last view will be created in the same way as<a id="_idIndexMarker482"/><a id="_idIndexMarker483"/> all the others. Proceed as follows:</p>
<ol>
<li>In the <code>News</code> project, right-click the <code>Views</code> folder, select <strong class="bold">Add</strong>, and then click <strong class="bold">New Item...</strong>.</li>
<li>Under the <strong class="bold">C# Items</strong> node on the left, select <strong class="bold">.</strong><strong class="bold">NET MAUI</strong>.</li>
<li>Select <code>AboutView</code>.</li>
<li>Click <strong class="bold">Add</strong> to create the page.</li>
</ol>
<p>This view is the only view that will stay a placeholder view. It’s up to you to do something with it if you choose to build something cool out of this project later. So, we will only add a label that states that this is <code>AboutView</code>:</p>
<ol>
<li>In the <code>News</code> project, open <code>AboutView.xaml</code>.</li>
<li>Edit the XAML code by adding the following code marked in bold:<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
             
    x:Class="News.Views.AboutView"
    Title="AboutView"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Label
            Text="<strong class="bold">AboutView!</strong>"
            VerticalOptions="Center"
            HorizontalOptions="Center" /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre></li> </ol>
<p>With that, we have all the views we need to start wiring the app up. The first step is to configure depend<a id="_idTextAnchor315"/>ency injection.</p>
<h3>Wiring<a id="_idTextAnchor316"/> up dependency injection</h3>
<p>By using dependency injection as a <a id="_idIndexMarker484"/><a id="_idIndexMarker485"/>pattern, we can keep our code cleaner and more testable. This app will use constructor injection, which means that all dependencies that a class has must be passed through its constructor. The container then constructs objects for you, so you don’t have to care too much about the dependency chain. Since .NET MAUI already includes a dependency injection framework, called Microsoft.Extensions.DependencyInjection, there is nothing extra to install.</p>
<p class="callout-heading">Confused about dependency injection?</p>
<p class="callout">Check out the <em class="italic">Wiring up a dependency injection</em> section in <em class="italic">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>, for more details on depend<a id="_idTextAnchor317"/>ency injection.</p>
<h4>Regist<a id="_idTextAnchor318"/><a id="_idTextAnchor319"/>ering Views and ViewModels with dependency injection</h4>
<p>When registering classes with the container, it is<a id="_idIndexMarker486"/><a id="_idIndexMarker487"/> recommended to use extension methods to group the types. The extension methods will take a single parameter and return a single value, the <code>MauiAppBuilder</code> instance. This is how the <code>CreateMauiApp</code> method. For this app, we have <code>Views</code> and <code>ViewModels</code> to register for now. Let’s create the method:</p>
<ol>
<li>In the <code>News</code> project, open the <code>MauiProgram.cs</code> fil<a id="_idTextAnchor320"/>e.</li>
<li>Make the following changes to the <code>MauiProgram</code> class; the changes are highlighted in the code:<pre class="source-code">
public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        builder
            .UseMauiApp&lt;App&gt;()
            .ConfigureFonts(fonts =&gt;
            {
                fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
                fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
<strong class="bold">            })</strong>
<strong class="bold">        .RegisterAppTypes();</strong>
        return builder.Build();
    }
    <strong class="bold">public static MauiAppBuilder RegisterAppTypes(this MauiAppBuilder mauiAppBuilder)</strong>
    <strong class="bold">{</strong>
        <strong class="bold">// ViewModels</strong>
        <strong class="bold">mauiAppBuilder.Services.AddTransient&lt;ViewModels.</strong>
        <strong class="bold">HeadlinesViewModel&gt;();</strong>
        <strong class="bold">// Views</strong>
        <strong class="bold">mauiAppBuilder.Services.AddTransient&lt;Views.AboutView&gt;();</strong>
        <strong class="bold">mauiAppBuilder.Services.AddTransient&lt;Views.</strong>
<strong class="bold">ArticleView&gt;();</strong>
        <strong class="bold">mauiAppBuilder.Services.AddTransient&lt;Views.</strong>
<strong class="bold">HeadlinesView&gt;();</strong>
        <strong class="bold">return mauiAppBuilder;</strong>
    <strong class="bold">}</strong>
}</pre></li> </ol>
<p>The .N<a id="_idTextAnchor321"/>ET MAUI <code>MauiAppBuilder</code> class exposes the <code>Services</code> property, which is the dependency injection container. We simply need to add the types we want dependency injection to know about; the container will do the rest for us. Think of a builder as something that collects a lot of information on what needs to be done, and then finally builds the object we need. It’s a very useful pattern on its own, by the way.</p>
<p>We're only using the builder for one thing at the <a id="_idIndexMarker488"/><a id="_idIndexMarker489"/>moment. Later on, we will use it to register any class in the assembly that inherits from our abstract <code>ViewModel</code> class. The container is now prepared for us to ask for these types.</p>
<p>Now, we need to make some graphical touches to our app. We will rely on <strong class="bold">Font Awesome</strong> to do the magic.</p>
<h3>Downl<a id="_idTextAnchor322"/><a id="_idTextAnchor323"/><a id="_idTextAnchor324"/>oading and configuring Font Awesome</h3>
<p>Font Awesome is a free collection of images <a id="_idIndexMarker490"/><a id="_idIndexMarker491"/>packaged into a font. .NET MAUI has excellent support for using Font Awesome in toolbars, navigation bars, and all over <a id="_idIndexMarker492"/><a id="_idIndexMarker493"/>the place. It’s not strictly needed to make this app, but we think that it’s worth the extra round trip since you are most likely going to need something like this in your new killer app.</p>
<p>The fi<a id="_idTextAnchor325"/>rst step is to download the font.</p>
<h4>Downlo<a id="_idTextAnchor326"/>ading Font Awesome</h4>
<p>Downloading the font is straightforward. Please<a id="_idIndexMarker494"/><a id="_idIndexMarker495"/> note the renaming of the file – it’s not needed but it’s easier to edit configuration files and such if they have simpler names. Follow these steps to acquire and copy the font to each project:</p>
<ol>
<li>Browse to <a href="https://fontawesome.com/download">https://fontawesome.com/download</a>.</li>
<li>Click the <strong class="bold">Free for Desktop</strong> button to download Font Awesome.</li>
<li>Unzip the downloaded file, then locate the <code>otfs</code> folder.</li>
<li>Rename the <code>Font Awesome 5 Free-Solid-900.otf</code> file to <code>FontAwesome.otf</code> (you can keep the original name, but it’s just less to type if you rename it). Your filename may be different since Font Awesome is continually updating but it should be similar.</li>
<li>Copy <code>FontAwesome.otf</code> to the <code>Resources/Fonts</code> folder in the <code>News</code> project.</li>
</ol>
<p>Alright – now, we need to register Font Awesome with .NET MAUI.</p>
<h4>Configuring .NET MAUI to use Font Awesome</h4>
<p>It would be nice if all we needed to do <a id="_idIndexMarker496"/><a id="_idIndexMarker497"/><a id="_idIndexMarker498"/>was to copy the font file into the project folders. A lot does happen with just that action. The default .NET MAUI template includes all the fonts in the <code>Resources/Fonts</code> folder with the following item definition in the <code>News.csproj</code> file:</p>
<pre class="source-code">
&lt;!-- Custom Fonts --&gt;
&lt;MauiFont Include="Resources\Fonts\*" /&gt;</pre> <p>This ensures that the font files are processed and included in the app package automatically. What is left is to register the font with the .NET MAUI runtime so that it is available to our XAML resources. To do that, add the following highlighted line to the <code>MauiProgram.cs</code> file:</p>
<pre class="source-code">
.ConfigureFonts(fonts =&gt;
{
    <strong class="bold">fonts.AddFont("FontAwesome.otf", "FontAwesome");</strong>
    fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
    fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
})</pre> <p>This line adds an alias that we can use in the next section to create static resources. The first parameter is the filename for the font file, while the second is the alias for the font that we can use in the <code>FontFamily</code> attribute.</p>
<p>All that is left is to define some icons in a resource dictionary.</p>
<h4>Deﬁnin<a id="_idTextAnchor327"/><a id="_idTextAnchor328"/>g some icons in the resource dictionary</h4>
<p>Now that we have defined the font, we <a id="_idIndexMarker499"/><a id="_idIndexMarker500"/>will put that to use and define five icons to use in our app. We’ll add the XAML first; then, we’ll examine one of the <code>FontImage</code> tags.</p>
<p>Proceed as follows:</p>
<ol>
<li>In the <code>News</code> project, open <code>App.xaml</code>.</li>
<li>Add the following code marked in bold under the existing <code>ResourceDictionary.MergedDictionaries</code> tag:<pre class="source-code">
&lt;ResourceDictionary&gt;
  &lt;ResourceDictionary.MergedDictionaries&gt;
    &lt;ResourceDictionary Source="Resources/Styles/Colors.xaml" /&gt;
    &lt;ResourceDictionary Source="Resources/Styles/Styles.xaml" /&gt;
  &lt;/ResourceDictionary.MergedDictionaries&gt;
<strong class="bold">  &lt;FontImage x:Key="HomeIcon" FontFamily="FontAwesome" Glyph<a id="_idTextAnchor329"/>="&amp;#xf015;" Size="22" Color="Black" /&gt;</strong>
<strong class="bold">  &lt;FontImage x:Key="HeadlinesIcon" FontFamily="FontAwesome" Glyph="&amp;#xf70e;" Size="22" /&gt;</strong>
<strong class="bold">  &lt;FontImage x:Key="NewsIcon" FontFamily=" FontAwesome" Glyph="&amp;#xf1ea;" Size="22" /&gt;</strong>
<strong class="bold">  &lt;FontImage x:Key="SettingsIcon" FontFamily="FontAwesome" Glyph="&amp;#xf013;" Size="22" Color="Black" /&gt;</strong>
<strong class="bold">  &lt;FontImage x:Key="AboutIcon" FontFamily="FontAwesome" Glyph="&amp;#xf05a;" Size="22" Color="Black" /&gt;</strong>
&lt;/ResourceDictionary&gt;</pre></li> </ol>
<p><code>FontImage</code> is a class that can be used anywhere in .NET MAUI that expects an <code>ImageSource</code> object. It’s designed to render one character (or glyph) into an image. The <code>FontImage</code> class needs a few attributes to work, detailed as follows:</p>
<ul>
<li>A key for reference that will be used by other views in the application.</li>
<li>A <code>FontFamily</code> resource that uses the alias reference back to the <code>Font</code> resource that we defined in the preceding section.</li>
<li>The <code>Glyph</code> object, which represents the image to be shown. To find which image these cryptic values refer to, check out <a href="http://fontawesome.com">fontawesome.com</a>, click on <strong class="bold">Icons</strong>, select <strong class="bold">free and open-source icons</strong>, and start browsing.</li>
<li><code>Size</code> and <code>Color</code>. These are not strictly needed but they’re nice to define. They are used for a few of the icons in this app so that they render properly for light themes.</li>
</ul>
<p>Font Awesome is now installed and configured. We’ve done a lot of work to get to the actual<a id="_idTextAnchor330"/> topic of this chapter. It’s time to define the shell!</p>
<h3>Defini<a id="_idTextAnchor331"/>ng the shell</h3>
<p>As stated earlier, .NET MAUI Shell is the<a id="_idIndexMarker501"/><a id="_idIndexMarker502"/> newest way of defining the structure of your app. The different projects in this book use alternate ways of defining the overall structure of the app, but .NET MAUI Shell is, in our opinion, the best way of defining the UI structure. We hope you find it as exciting as we do!</p>
<h4>Deﬁnin<a id="_idTextAnchor332"/><a id="_idTextAnchor333"/><a id="_idTextAnchor334"/>g the basic structure</h4>
<p>We’re going to start by defining a basic structure <a id="_idIndexMarker503"/><a id="_idIndexMarker504"/>for the app without really adding any of our defined views to it. After that, we’ll add the actual views one by one. But let’s start by adding some content and creating <code>ContentPage</code> objects using XAML directly. Follow these two steps to do so:</p>
<ol>
<li>In the <code>News</code> project, open the <code>AppShell.xaml</code> file.</li>
<li>Alter the file so that it looks like the following code:<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Shell 
       
    
<strong class="bold">    x:Class="News.AppShell"&gt;</strong>
<strong class="bold">    &lt;FlyoutItem Title="Home" Icon="{StaticResource HomeIcon}"&gt;</strong>
<strong class="bold">      &lt;ShellContent Title="Headlines" Icon="{StaticResource HeadlinesIcon}" &gt;</strong>
<strong class="bold">      &lt;ContentPage Title="Headlines" /&gt;</strong>
<strong class="bold">      &lt;/ShellContent&gt;</strong>
<strong class="bold">      &lt;Tab Title="News" Icon="{StaticResource NewsIcon}"&gt;</strong>
<strong class="bold">        &lt;ContentPage Title="Local" /&gt;</strong>
<strong class="bold">        &lt;ContentPage Title="Global" /&gt;</strong>
<strong class="bold">      &lt;/Tab&gt;</strong>
<strong class="bold">    &lt;/FlyoutItem&gt;</strong>
<strong class="bold">    &lt;FlyoutItem Title="Settings" Icon="{StaticResource SettingsIcon}"&gt;</strong>
<strong class="bold">      &lt;ContentPage Title="Settings" /&gt;</strong>
<strong class="bold">    &lt;/FlyoutItem&gt;</strong>
<strong class="bold">    &lt;ShellContent Title="About" Icon="{StaticResource AboutIcon}"&gt;</strong>
<strong class="bold">      &lt;ContentPage Title="About"/&gt;</strong>
<strong class="bold">    &lt;/ShellContent&gt;</strong>
&lt;/Shell&gt;</pre></li> </ol>
<p>Let’s <a id="_idTextAnchor335"/>break this down. First, by default, the .NET MAUI Shell template disables the flyout menu. Since we want to use it in this app, you must remove the line that disables it. The direct children of Shell itself are two <code>FlyoutItem</code> objects and one <code>ShellContent</code> object. All three of these have <code>Title</code> and <code>Icon</code> properties defined, as shown in the following screenshot. The icons are referenced to the Font Awesome resources we created earlier. This will render a flyout, as shown in the following screenshot:</p>
<div><div><img alt="Figure 4.7 – The app flyout" src="img/Figure_4.7_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The app flyout</p>
<p>The flyout is accessible by swiping in from the left. <code>Flyout</code> objects can have multiple children, while the <code>ShellContent</code> element can only have a single child.</p>
<p>The <code>ShellContent</code> with a page with the title <strong class="bold">Headlines</strong> and a tab that defines two child pages on its own. The first level of children will render the tab bar at the bottom of the app, as shown in the following screenshot. The second level of children, under the <strong class="bold">Tab</strong> element with the <strong class="bold">News</strong> title, will be rendered as a tab bar directly under the title of the navigation bar at the top:</p>
<div><div><img alt="Figure 4.8 – The Shell tabs and pages" src="img/Figure_4.8_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The Shell tabs and pages</p>
<p>The <strong class="bold">Sett<a id="_idTextAnchor336"/><a id="_idTextAnchor337"/>ings</strong> and <strong class="bold">About</strong> flyouts will simply render the pages that they define.</p>
<h3>Making t<a id="_idTextAnchor338"/><a id="_idTextAnchor339"/>he app run</h3>
<p>It’s time to try the app out and see whether it looks<a id="_idIndexMarker507"/><a id="_idIndexMarker508"/> like the screenshots shown throughout this chapter. The app should now run. If not, stay calm and simply go through the code again. Once you are done navigating around the app, we can create a news service to fetch news from, an<a id="_idTextAnchor340"/>d extend all those views that we’ve created.</p>
<h2 id="_idParaDest-96">Creating<a id="_idTextAnchor341"/> the news service</h2>
<p>To find cool content, we’ll<a id="_idIndexMarker509"/><a id="_idIndexMarker510"/> consume an already existing <code>News</code> API provided by <a href="http://newsapi.org">newsapi.org</a>. To do so, we must register for an API key that we can use to request the news. If you aren’t comfortable with doing so, you can mock the news service if you would like, instead of using the API.</p>
<p>The first thing we must do is obtain an API key.</p>
<h3>Obtainin<a id="_idTextAnchor342"/><a id="_idTextAnchor343"/><a id="_idTextAnchor344"/>g an API key</h3>
<p>The process<a id="_idIndexMarker511"/><a id="_idIndexMarker512"/> of registering is pretty <a id="_idIndexMarker513"/><a id="_idIndexMarker514"/>straightforward. Be aware, however, that the UI of <a href="http://newsapi.org">newsapi.org</a> might have changed by the time you read this.</p>
<p>OK – let’s get that key:</p>
<ol>
<li>Browse to <a href="https://newsapi.org/">https://newsapi.org/</a>.</li>
<li>Click <strong class="bold">Get </strong><strong class="bold">API key</strong>.</li>
<li>Fill out the form, as illustrated in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 4.9 – Register for API ﻿key" src="img/Figure_4.9_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Register for API key</p>
<ol>
<li value="4">Copy the <a id="_idTextAnchor345"/>API key provided on the next page, as illustrated in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 4.10 – Registration complete" src="img/Figure_4.10_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Registration complete</p>
<p>Now, we need a place to store the key for easy access. We’ll create a static class that will hold the key for us. Proceed as follows:<a id="_idIndexMarker515"/><a id="_idIndexMarker516"/></p>
<ol>
<li>In the <code>News</code> project, create a new class called <code>Settings</code> in the root folder.</li>
<li>Add the code shown in the following snippet, replacing the placeholder text with the API key you obtained in the preceding steps:<pre class="source-code">
namespace News;
internal static class Settings
{
    public static string NewsApiKey =&gt; "<strong class="bold">&lt;Your APIKEY Here&gt;</strong>";
}</pre></li> </ol>
<p>The important thing here is that you copy and paste the key into the file. Now, we need models.</p>
<p class="callout-heading">A note on tokens and other secrets</p>
<p class="callout">This is not a recommended way to store an API key or any other token that should be secured in your app. To securely store tokens and other data, you should use <strong class="bold">secure storage</strong> (see <a href="https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage">https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage</a>) and obtain the data from a secure server, preferably gated by some form of user authentication. You could also require the user to provide the API key through a settings page – hint, hint.</p>
<h3>Creating t<a id="_idTextAnchor346"/><a id="_idTextAnchor347"/><a id="_idTextAnchor348"/>he models</h3>
<p>The data returned from the API needs to go somewhere, and the most convenient way of accessing it would be to deserialize<a id="_idIndexMarker517"/><a id="_idIndexMarker518"/> the data into <code>Models</code>. Let’s create our models:</p>
<ol>
<li>In the <code>News</code> project, create a new folder called <code>Models</code>.</li>
<li>In the <code>Models</code> folder, add a new class called <code>NewsApiModels</code>.</li>
<li>Add the following code to the class:<pre class="source-code">
namespace News.Models;
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;
public class Source
{
    [JsonPropertyName("id")]
    public string Id { get; set; }
    [JsonPropertyName("name")]
    public string Name { get; set; }
}
public class Article
{
    [JsonPropertyName("source")]
    public Source Source { get; set; }
    [JsonPropertyName("author")]
    public string Author { get; set; }
    [JsonPropertyName("title")]
    public string Title { get; set; }
    [JsonPropertyName("description")]
    public string Description { get; set; }
    [JsonPropertyName("url")]
    public string Url { get; set; }
    [JsonPropertyName("urlToImage")]
    public string UrlToImage { get; set; }
    [JsonPropertyName("publishedAt")]
    public DateTime PublishedAt { get; set; }
    [JsonPropertyName("content")]
    public string Content { get; set; }
}
public class NewsResult
{
    [JsonPropertyName("status")]
    public string Status { get; set; }
    [JsonPropertyName("totalResults")]
    public int TotalResults { get; set; }
    [JsonPropertyName("articles")]
    public List&lt;Article&gt; Articles { get; set; }
}</pre></li> </ol>
<p>The <code>JsonPropertyName</code> attributes on each property allow the <code>System.Text.Json</code> deserializer to map the name from the JSON received from the web API into the C# object. When we call the API, the API will return a <code>NewsResult</code> object that <a id="_idIndexMarker521"/><a id="_idIndexMarker522"/>will, in turn, contain a list of articles. The next step is to create a service that will wrap the API and allow us to access the latest news.</p>
<p class="callout-heading">Tip for creating POCO classes</p>
<p class="callout">If you ever need to create a class model <a id="_idIndexMarker523"/><a id="_idIndexMarker524"/>out of a bunch of <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>), you can use the <strong class="bold">Paste JSON as Classes</strong> tool in Visual Studio for Windows (<strong class="bold">Edit</strong> | <strong class="bold">Paste Special</strong> | <strong class="bold">Paste JSON </strong><strong class="bold">as Classes</strong>).</p>
<h3><a id="_idTextAnchor349"/>Creating a<a id="_idTextAnchor350"/> service class</h3>
<p>The service class will wrap the API so that we can<a id="_idIndexMarker525"/><a id="_idIndexMarker526"/> access it in a nice .NET-ish kind of way.</p>
<p>But we’ll <a id="_idTextAnchor351"/>start by defining an enum that will define the scope of the news that we request.</p>
<h4>Creating t<a id="_idTextAnchor352"/>he NewsScope enum</h4>
<p>The <code>NewsScope</code> enum defines the <a id="_idIndexMarker527"/><a id="_idIndexMarker528"/>different kinds of news that our service supports. Let’s add it by following these few steps:</p>
<ol>
<li>In the <code>News</code> project, create a new folder called <code>Services</code>.</li>
<li>In the <code>Services</code> folder, add a new file called <code>NewsScope.cs</code>.</li>
<li>Add the following code to that file:<pre class="source-code">
namespace News.Services;
public enum NewsScope
{
    Headlines,
    Local,
    Global
}</pre></li> </ol>
<p>The next step is to create the <code>NewsService</code> class that will wrap <a id="_idTextAnchor353"/>the call to the <code>News</code> API.</p>
<h4>Creating the NewsService class</h4>
<p>The purpose of the <code>NewsService</code> class is to <a id="_idIndexMarker529"/><a id="_idIndexMarker530"/>wrap the HTTP calls to the news REST API and make them easily accessible to our code in the form of regular .NET method calls. To make it easier to replace the source of the news – for example, to use a mock in tests – we will use an interface.</p>
<p>To create the <code>INewsService</code> interface, follow these steps:</p>
<ol>
<li>In the <code>Services</code> folder, create a new interface called <code>INewsService</code>.</li>
<li>Edit the interface so that it looks like this:<pre class="source-code">
namespace News.Services;
using News.Models;
public interface INewsService
{
    public Task&lt;NewsResult&gt; GetNews(NewsScope scope);
}</pre></li> </ol>
<p>Creating the <code>NewsService</code> class is now quite straightforward. Follow these steps:</p>
<ol>
<li>In the <code>Services</code> folder, create a new class called <code>NewsService</code>.</li>
<li>Edit the class so that it looks like this:<pre class="source-code">
namespace News.Services;
using News.Models;
using System.Net.Http.Json;
public class NewsService : INewsService, IDisposable
{
    private bool disposedValue;
    const string UriBase = "https://newsapi.org/v2";
    readonly HttpClient httpClient = new() {
        BaseAddress = new(UriBase),
        DefaultRequestHeaders = { { "user-agent", "maui-projects-news/1.0" } }
    };
    public async Task&lt;NewsResult&gt; GetNews(NewsScope scope)
    {
        NewsResult result;
        string url = GetUrl(scope);
        try
        {
            result = await httpClient.GetFromJsonAsync&lt;NewsResult&gt;(url);
        }
        catch (Exception ex) {
            result = new() { Articles = new() { new() { Title = $"HTTP Get failed: {ex.Message}", PublishedAt = DateTime.Now} } };
        }
        return result;
    }
    private string GetUrl(NewsScope scope) =&gt; scope switch
    {
        NewsScope.Headlines =&gt; Headlines,
        NewsScope.Global =&gt; Global,
        NewsScope.Local =&gt; Local,
        _ =&gt; throw new Exception("Undefined scope")
    };
    private static string Headlines =&gt; $"{UriBase}/top-headlines?country=us&amp;apiKey={Settings.NewsApiKey}";
    private static string Local =&gt; $"{UriBase}/everything?q=local&amp;apiKey={Settings.NewsApiKey}";
    private static string Global =&gt; $"{UriBase}/everything?q=global&amp;apiKey={Settings.NewsApiKey}";
    protected virtual void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                httpClient.Dispose();
            }
            disposedValue = true;
        }
    }
    public void Dispose()
    {
        // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }
}</pre></li> </ol>
<p>The <code>NewsService</code> class is composed of five methods; I know there are technically eight, but we will get to that in a moment.</p>
<p>The first method, <code>GetNews</code>, is the method that we will eventually call from our app. It takes one parameter, <code>scope</code>, which is the enum that we created earlier. Depending on the value of this parameter, we will get different types of news. The first thing this method does is resolve the URL to call, and it does so by calling the <code>GetUrl</code> method with the scope.</p>
<p>The <code>GetUrl</code> method uses a switch expression to resolve the URL and, depending on the value of the scope parameter passed, returns one of three URLs. The URL points to the REST API of the <code>News</code> API with some predefined query parameters and the API key that we registered for.</p>
<p>When we’ve resolved the correct URL, we are ready to make the HTTP request and download the news in the form of JSON. The built-in <code>HttpClient</code> class in .NET does a fine job of fetching the JSON for us. All that is left after acquiring the data <a id="_idIndexMarker531"/><a id="_idIndexMarker532"/>is to deserialize it into the news models that we defined earlier.</p>
<p>Let’s say a word or two about the remainder of the methods and the <code>HttpClient</code> class. <code>HttpClient</code> is now the recommended class to use when requesting data from the web. It is a much safer implementation than was previously available. It has been shipping with .NET 5+ and is available as a separate NuGet package for previous versions. With that, there are a few peculiarities when using <code>HttpClient</code>.</p>
<p>First, <code>HttpClient</code> can hold onto native resources, so it must be properly disposed of. To properly dispose of <code>HttpClient</code>, we need to derive from and implement <code>IDisposable</code>. This is the reason for the extra methods that are in the class, <code>Dispose(bool)</code> and <code>Dispose()</code>. All they do is make sure that the instance of <code>HttpClient</code> is disposed of properly.</p>
<p>Second, <code>HttpClient</code> will pool those native resources, so it is recommended that you reuse an instance of <code>HttpClient</code> as much as possible. This is the reason for creating the <code>HttpClient</code> instance in the <code>NewsService</code> constructor.</p>
<p>Final word – since the <code>GetFromJsonAsync</code> call can throw an exception and it is called from an <code>async</code> method, you must handle the exception; otherwise, it will be lost on the executing thread and your only indication that something is wrong will be<a id="_idIndexMarker533"/><a id="_idIndexMarker534"/> the fact that you have no items. For this app, we are just going to create a <code>NewsResult</code> object that contains one <code>Article</code> that has the exception in it so that something is displayed. There are much better ways of handling errors, but this will do for this app.</p>
<p>The next step is to wire up the <code>NewsService</code> class.</p>
<h2 id="_idParaDest-97">Wiring up<a id="_idTextAnchor354"/><a id="_idTextAnchor355"/><a id="_idTextAnchor356"/> the NewsService class</h2>
<p>We are now ready to wire up<a id="_idIndexMarker535"/><a id="_idIndexMarker536"/> the <code>NewsService</code> class in our app and integrate it with a real news source. We will extend all the existing <code>ViewModels</code> that we have and define the UI element<a id="_idTextAnchor357"/>s to be able to render the news in the <code>Views</code>.</p>
<h3>Extending <a id="_idTextAnchor358"/>the HeadlinesViewModel class</h3>
<p>In MVVM, <code>ViewModel</code> is the place to handle the logic of the app. The model is the news data that we will get from our <code>NewsService</code> class. We will now <a id="_idIndexMarker537"/><a id="_idIndexMarker538"/>extend the <code>HeadlinesViewModel</code> class so that it uses <code>NewsService</code> to fetch news:</p>
<ol>
<li>In the <code>News</code> project, expand the <code>ViewModels</code> folder and open the <code>HeadlinesViewModel.cs</code> file.</li>
<li>Add the following code marked in bold and resolve the references:<pre class="source-code">
namespace News.ViewModels;
<strong class="bold">using System.Threading.Tasks;</strong>
<strong class="bold">using System.Web;</strong>
<strong class="bold">using CommunityToolkit.Mvvm.ComponentModel;</strong>
<strong class="bold">using CommunityToolkit.Mvvm.Input;</strong>
<strong class="bold">using News.Models;</strong>
<strong class="bold">using News.Services;</strong>
public <strong class="bold">partial</strong> class HeadlinesViewModel : ViewModel
{
<strong class="bold">    private readonly INewsService newsService;</strong>
<strong class="bold">    [ObservableProperty]</strong>
<strong class="bold">    private NewsResult currentNews;</strong>
    public HeadlinesViewModel(<strong class="bold">INewsService newsService</strong>)
    {
        <strong class="bold">this.newsService = newsService;</strong>
    }
<strong class="bold">    public async Task Initialize(string scope) =&gt;</strong>
<strong class="bold">        await Initialize(scope.ToLower() switch</strong>
<strong class="bold">        {</strong>
<strong class="bold">            "local" =&gt; NewsScope.Local,</strong>
<strong class="bold">            "global" =&gt; NewsScope.Global,</strong>
<strong class="bold">            "headlines" =&gt; NewsScope.Headlines,</strong>
<strong class="bold">            _ =&gt; NewsScope.Headlines</strong>
<strong class="bold">        });</strong>
<strong class="bold">    public async Task Initialize(NewsScope scope)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        CurrentNews = await newsService.GetNews(scope);</strong>
<strong class="bold">    }</strong>
<strong class="bold">    [RelayCommand]</strong>
<strong class="bold">    public void ItemSelected(object selectedItem)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        var selectedArticle = selectedItem as Article;</strong>
<strong class="bold">        var url = HttpUtility.UrlEncode(selectedArticle.Url);</strong>
<strong class="bold">        // Placeholder for more code later on</strong>
<strong class="bold">    }</strong>
}</pre></li> </ol>
<p>Since we are using (constructor) dependency injection, we need to inject our dependencies into the constructor. The only dependency this <code>ViewModel</code> has is <code>NewsService</code>, and we store it internally in the class as a field.</p>
<p>The <code>CurrentNews</code> property is defined to get <a id="_idIndexMarker539"/><a id="_idIndexMarker540"/>something to bind the UI to.</p>
<p>Then, we have two <code>Initialize</code> methods – one that takes <code>scope</code> as an enum and one that takes <code>scope</code> as a string. The string overload of the <code>Initialize</code> method will be used in XAML. It simply translates the string into the enum representation of <code>scope</code> and then calls the other <code>Initialize</code> method, which, in turn, calls the <code>GetNews(...)</code> method on the news service.</p>
<p>The property at the end, <code>ItemSelected</code>, returns a .NET MAUI command that we will wire up to respond to when the user of the app selects an item. Half of the method is implemented from the start. The selected item will be passed into the method. Then, we encode the URL to the article since we will be passing it as a query parameter when we navigate within the app. We will get back to the navigation part in a while.</p>
<p>If you are curious about the <code>ObservableProperty</code> and <code>RelayCommand</code> attributes, refresh your memory by reviewing <em class="italic">Chapter 2</em>, <em class="italic">Building Our First .NET </em><em class="italic">MAUI App</em>.</p>
<p>Now that we have the code to fetch the data, we’ll move on to defining the UI to display it.</p>
<h3>Extending <a id="_idTextAnchor359"/><a id="_idTextAnchor360"/><a id="_idTextAnchor361"/>HeadlinesView</h3>
<p><code>HeadlinesView</code> is a shared view that will be used in several places in the app. The purpose of this view is to display a list of articles and to allow for <a id="_idIndexMarker541"/><a id="_idIndexMarker542"/>navigation from one article into a web browser that will display the entire article.</p>
<p>To extend <code>HeadlinesView</code> we must do two things – first, must we edit the XAML and define the UI; then, we need to add some code to initialize it. Proceed as follows:</p>
<ol>
<li>In the <code>News</code> project, expand the <code>Views</code> folder and open the <code>HeadlinesView.xaml</code> file.</li>
<li>Edit the XAML, as shown in the following code block:<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ContentPage 
             
<strong class="bold">    </strong>
<strong class="bold">    </strong>
<strong class="bold">    </strong>
<strong class="bold">    x:Name="headlinesview"</strong>
    x:Class="News.Views.HeadlinesView"
<strong class="bold">              x:DataType="viewModels:HeadlinesViewModel"</strong>
<strong class="bold">    Title="Home" Padding="14"&gt;</strong>
<strong class="bold">  &lt;CollectionView ItemsSource="{Binding CurrentNews.Articles}"&gt;</strong>
<strong class="bold">    &lt;CollectionView.EmptyView&gt;</strong>
<strong class="bold">      &lt;Label Text="Loading" /&gt;</strong>
<strong class="bold">    &lt;/CollectionView.EmptyView&gt;</strong>
<strong class="bold">    &lt;CollectionView.ItemTemplate&gt;</strong>
<strong class="bold">      &lt;DataTemplate x:DataType="models:Article"&gt;</strong>
<strong class="bold">        &lt;ContentView&gt;</strong>
<strong class="bold">          &lt;ContentView.GestureRecognizers&gt;</strong>
<strong class="bold">            &lt;TapGestureRecognizer Command="{Binding BindingContext.ItemSelectedCommand, Source={x:Reference headlinesview}}" CommandParameter="{Binding .}" /&gt;</strong>
<strong class="bold">          &lt;/ContentView.GestureRecognizers&gt;</strong>
<strong class="bold">          &lt;views:ArticleItem /&gt;</strong>
<strong class="bold">        &lt;/ContentView&gt;</strong>
<strong class="bold">      &lt;/DataTemplate&gt;</strong>
<strong class="bold">    &lt;/CollectionView.ItemTemplate&gt;</strong>
<strong class="bold">  &lt;/CollectionView&gt;</strong>
&lt;/ContentPage&gt;</pre></li> </ol>
<p><code>HeadlinesV<a id="_idTextAnchor362"/>iew</code> uses <code>CollectionView</code> to display the list of articles. The <code>ItemsSource</code> property is set to the <code>CurrentNews.Articles</code> property of <code>ViewModel</code>, which, after loading news, should contain a list of news. While the list is empty or loading, we display a loading label, defined within the <code>CollectionView.EmptyView</code> element. You could, of course, create any valid UI inside of that tag to create a cooler loading screen.</p>
<p>Each article in the <code>CurrentNews.Articles</code> list will be rendered using whatever is inside the <code>CollectionView.ItemTemplate</code> element, and it’s what’s inside of the <code>ContentView</code> element that will represent the actual item. The article will be rendered using an <code>ArticleItem</code> view, which is a custom control that we defined earlier. We will define this view after we are done with this view.</p>
<p>To enable navigation from the view, we need to <a id="_idIndexMarker543"/><a id="_idIndexMarker544"/>detect when a user clicks on a specific article. We can do so by adding <code>TapGestureRecognizer</code> and binding it to the <code>ItemSelectedCommand</code> property of the root <code>ViewModel</code>. The <code>Source={x:Reference headlinesview}}</code> snippet is what references the current context back to the root of the page, not the current article in the list that we are iterating. If we didn’t specify the source, the binding engine would try to bind the <code>ItemSelectedCommand</code> property to a property defined in the current article of the <code>CurrentNews.Articles</code> property.</p>
<p>That’s all for the GUI part. Now, we need to alter the code-behind to enable initialization based on data that we will pass from the XAML itself. Follow these steps to make it happen:</p>
<ol>
<li>In the <code>News</code> project, open the <code>HeadlinesView.xaml.cs</code> code-behind file.</li>
<li>Add the following code marked in bold to the file:<pre class="source-code">
namespace News.Views
using System.Threading.Tasks;
using News.Services;
<strong class="bold">using News.ViewModels;</strong>
public partial class HeadlinesView : ContentPage
{
    <strong class="bold">readonly HeadlinesViewModel viewModel;</strong>
<strong class="bold">    public HeadlinesView(HeadlinesViewModel viewModel)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        this.viewModel = viewModel;</strong>
<strong class="bold">        InitializeComponent();</strong>
<strong class="bold">        Task.Run(async () =&gt; await Initialize(GetScopeFromRoute()));</strong>
<strong class="bold">    }</strong>
<strong class="bold">    private async Task Initialize(string scope)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        BindingContext = viewModel;</strong>
<strong class="bold">        await viewModel.Initialize(scope);</strong>
<strong class="bold">    }</strong>
<strong class="bold">    private string GetScopeFromRoute()</strong>
<strong class="bold">    {</strong>
<strong class="bold">        var route = Shell.Current.CurrentState.Location</strong>
<strong class="bold">        .OriginalString.Split("/").LastOrDefault();</strong>
<strong class="bold">        return route;</strong>
<strong class="bold">    }</strong>
}</pre></li> </ol>
<p>Usually, we don’t want to add code to the code-behind of a view directly, but we need to make an exception so that arguments can be passed from XAML to our <code>ViewModel</code>.</p>
<p>Based on the routing information that was used to create the view, we will initialize <code>ViewModel</code> differently. The <code>GetScopeFromRoute</code> method will parse the location information from <code>Shell</code> to determine which scope is used to query the news<a id="_idIndexMarker545"/><a id="_idIndexMarker546"/> service. Then, we can call a private method that creates an instance of <code>HeadlinesViewModel</code> for us, sets it as the binding context of the view, and calls the <code>Initialize()</code> method on <code>ViewModel</code>, which makes the REST call to the <code>News</code> API. We will define the routes when we edit the shell file.</p>
<p>But first, we need to extend <code>ContentView</code> of <code>ArticleItem</code> so that it displays a single-row item in th<a id="_idTextAnchor363"/>e news lists.</p>
<h3>Extending <a id="_idTextAnchor364"/>ContentView of ArticleItem</h3>
<p><code>ContentView</code> of <code>ArticleItem</code> represents one item<a id="_idIndexMarker547"/> in a list of news, as shown in the following screenshot:</p>
<div><div><img alt="Figure 4.11 – A sample news item" src="img/Figure_4.11_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – A sample news item</p>
<p>To create the layout shown in <em class="italic">Figure 4</em><em class="italic">.11</em>, we will use a <code>Grid</code> control. Follow these steps to create the layout:</p>
<ol>
<li>In the <code>News</code> project, expand the <code>Views</code> folder and open the <code>ArticleItem.xaml</code> file.</li>
<li>Edit the XAML code, as shown in the following code block:<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ContentView 
    
             
    x:Class="News.Views.ArticleItem"
    x:DataType="models:Article"&gt;
  &lt;Grid Margin="0"&gt;
    &lt;Grid.RowDefinitions&gt;
      &lt;RowDefinition Height="10" /&gt;
      &lt;RowDefinition Height="40" /&gt;
      &lt;RowDefinition Height="15" /&gt;
      &lt;RowDefinition Height="10" /&gt;
      &lt;RowDefinition Height="1" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
      &lt;ColumnDefinition Width="65" /&gt;
      &lt;ColumnDefinition Width="*" /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Label Grid.Row="1" Grid.Column="1" Text="{Binding Title}" Padding="10,0" FontSize="Small" FontAttributes="Bold" /&gt;
    &lt;Label Grid.Row="2" Grid.Column="1" Text="{Binding PublishedAt, StringFormat='{0:MMMM d, yyyy}'}" Padding="10,0,0,0" FontSize="Micro" /&gt;
    &lt;Border Grid.Row="1" Grid.RowSpan="2" StrokeShape="RoundRectangle 15,15,15,15" Padding="0" Margin="0,0,0,0" BackgroundColor="#667788" &gt;
      &lt;Image Source="{Binding UrlToImage}" Aspect="AspectFill" HeightRequest="55" HorizontalOptions="Center" VerticalOptions="Center" /&gt;
    &lt;/Border&gt;
    &lt;BoxView Grid.Row="4" Grid.ColumnSpan="2" BackgroundColor="LightGray" /&gt;
  &lt;/Grid&gt;
&lt;/ContentView&gt;</pre></li> </ol>
<p>The preceding XAML code defines a grid layout with two columns and five rows. The <code>Grid.Row</code> and <code>Grid.Column</code> attributes <a id="_idIndexMarker548"/>position child elements into the grid, while the <code>Grid.ColumnSpan</code> attribute allows for a control to span multiple columns.</p>
<p>A rounded image can be achieved using a <code>Border</code> element with <code>StrokeShape="RoundRectangle 15,15,15,15"</code> specified in conjunction with the <code>Image</code> <code>Aspect</code> attribute set to <code>AspectFill</code>.</p>
<p>Strings in labels can be formatted directly in the binding statement. Check out the <code>Text="{Binding PublishedAt, StringFormat='{0:MMMM d, yyyy}'}"</code> line of code, which formats a date into a specific string format.</p>
<p>Lastly, the gray divider line is <code>BoxView</code> at the end of the XAML code.</p>
<p>Now that we have created <code>NewsService</code> and fixed all its related views, it’s time to make<a id="_idTextAnchor365"/> use of them.<a id="_idTextAnchor366"/></p>
<h3>Adding to dependency injection</h3>
<p>Since <code>HeadlinesViewModel</code> depends on <code>INewsService</code>, we need to register it in our dependency injection container (please see the <em class="italic">Wiring up dependency injection</em> section in <em class="italic">Chapter 2</em> for more details <a id="_idIndexMarker549"/>on dependency injection in .NET MAUI). Follow these steps to do so:</p>
<ol>
<li>In the <code>News</code> project, open the <code>MauiProgram.cs</code> file.</li>
<li>Locate the <code>RegisterAppTypes()</code> method and add the following line marked in bold:<pre class="source-code">
public static MauiAppBuilder RegisterAppTypes(this MauiAppBuilder mauiAppBuilder)
{
<strong class="bold">    // Services</strong>
<strong class="bold">     mauiAppBuilder.Services.AddSingleton&lt;Services.INewsService&gt;((serviceProvider) =&gt; new Services.NewsService());</strong>
    // ViewModels
    mauiAppBuilder.Services.AddTransient&lt;ViewModels.HeadlinesViewModel&gt;();
    //Views
    mauiAppBuilder.Services.AddTransient&lt;Views.AboutView&gt;();
    mauiAppBuilder.Services.AddTransient&lt;Views.ArticleView&gt;();
    mauiAppBuilder.Services.AddTransient&lt;Views.HeadlinesView&gt;();
    return mauiAppBuilder;
<a id="_idTextAnchor367"/>}</pre></li> </ol>
<p>This will allow for the dependency <a id="_idIndexMarker550"/>injection of <code>NewsServic<a id="_idTextAnchor368"/><a id="_idTextAnchor369"/>e</code>.</p>
<h3>Adding a ContentTemplate attribute</h3>
<p>So far, we only have placeholder <a id="_idIndexMarker551"/>code in our <code>AppShell</code> file. Let’s replace this with actual content, as follows:</p>
<ol>
<li>In the <code>News</code> project, open <code>AppShell.xaml</code>.</li>
<li>Locate the <code>FlyoutItem</code> element with the title set to <code>Home</code>.</li>
<li>Edit the XAML so that the <code>ShellContent</code> element becomes self-closing, add the following <code>ContentTemplate</code> attribute marked in bold, and replace the contents of the <code>Tab</code> element:<pre class="source-code">
&lt;Shell
    x:Class="News.AppShell"
    
    
    <strong class="bold"></strong>
    &gt;
<strong class="bold">    &lt;FlyoutItem Title="Home" Icon="{StaticResource HomeIcon}"&gt;</strong>
<strong class="bold">        &lt;ShellContent Title="Headlines" Route="headlines" Icon="{StaticResource HeadlinesIcon}" ContentTemplate="{DataTemplate views:HeadlinesView}" /&gt;</strong>
<strong class="bold">        &lt;Tab Title="News" Route="news" Icon="{StaticResource NewsIcon}"&gt;</strong>
<strong class="bold">            &lt;ShellContent Title="Local" Route="local" ContentTemplate="{DataTemplate views:HeadlinesView}" /&gt;</strong>
<strong class="bold">            &lt;ShellContent Title="Global" Route="global" ContentTemplate="{DataTemplate views:HeadlinesView}" /&gt;</strong>
<strong class="bold">        &lt;/Tab&gt;</strong>
<strong class="bold">    &lt;/FlyoutItem&gt;</strong>
    &lt;FlyoutItem Title="Settings" Icon="{StaticResource SettingsIcon}"&gt;
        &lt;ContentPage Title="Settings" /&gt;
    &lt;/FlyoutItem&gt;
    &lt;ShellContent Title="About" Icon="{StaticResource AboutIcon}"&gt;
        &lt;ContentPage Title="About"/&gt;
    &lt;/ShellContent&gt;
&lt;/She<a id="_idTextAnchor370"/>ll&gt;</pre></li> </ol>
<p>Two things are going on <a id="_idIndexMarker552"/>here. The first is that we specify the content of <code>ShellContent</code> using the <code>ContentTemplate</code> attribute. This means that we point to the type of view that we want to have created when the shell becomes visible. Usually, you want to defer the creation of a view until right before it is going to be displayed, and the <code>ContentTemplate</code> attribute gives you that. Notice that the <code>Route</code> attribute for that <code>FlyoutItem</code> is set to <code>headlines</code>.</p>
<p>The second thing is that we have the same thing going on below for the <code>Local</code> and <code>Global</code> news but instead <a id="_idIndexMarker553"/>using the <code>local</code> and <code>global</code> routes.</p>
<p>If you run the app at this point, you should end up with something that looks like the following screensh<a id="_idTextAnchor371"/>ot:</p>
<div><div><img alt="Figure 4.12 – The main list view" src="img/Figure_4.12_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – The main list view</p>
<p>The last thing we need to implement is how we can view the articles when we tap on the item in<a id="_idTextAnchor372"/> the l<a id="_idTextAnchor373"/>ist.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor374"/>Handling navigation</h2>
<p>We are on the home stretch now for this app. The only thing we need to do is implement navigation to <a id="_idIndexMarker554"/>the article view, which will display the entire article in a web view. Since we are using Shell, we will be navigating using routes. Routes can be registered directly in the Shell markup – for example, in the <code>AppShell.xaml</code> file. We can do this by using <code>Route</code> attributes on the <code>ShellContent</code> elements, as we did in the previous section.</p>
<p>In the following code, we will add a route programmatically and register a view to handle it for us. We will also create a navigation service to abstract the concept of navigation a<a id="_idTextAnchor375"/> bit.</p>
<p>So, buckle up, and let’s finish this<a id="_idTextAnchor376"/> app!</p>
<h3>Creating the navigation service</h3>
<p>The first step is to define an interface that will wrap .NET MAUI navigation. Why do we do this? Well, it’s a good practice<a id="_idIndexMarker555"/> to separate the interfaces from the implementati<a id="_idTextAnchor377"/>on; it makes unit testing easier, and <a id="_idTextAnchor378"/>so on.</p>
<h4>Creating the INavigation interface</h4>
<p>The <code>INavigation</code> interface is simple, and we will <a id="_idIndexMarker556"/>overshoot the target a little bit. We are only interested in the <code>NavigateTo</code> method, but we will add the <code>PushModal()</code> and <code>PopModal()</code> methods since it is likely that you will use them if you continue extending the app.</p>
<p>Adding the navigation interface is simple, as the following steps illustrate:</p>
<ol>
<li>In the <code>News</code> project, expand the <code>ViewModels</code> folder and add a new file called <code>INavigate.cs</code>.</li>
<li>Add the following code to the file:<pre class="source-code">
namespace News.ViewModels;
public interface INavigate
{
    Task NavigateTo(string route);
    Task PushModal(Page page);
    Task PopModal();
}</pre></li> </ol>
<p>The <code>NavigateTo()</code> method declaration takes the route we want to navigate to. This is the method that we will be calling. The <code>PushModal()</code> method adds a new page on top of the navigation stack as a modal page, forcing the user only to interact with this specific page. The <code>PopModal()</code> method <a id="_idIndexMarker557"/>removes it from the navigation stack. So, if you use the <code>PushModal()</code> method, make sure that you give the user a way to pop it off the stack.</p>
<p>Otherwise, you will be stuck viewing the modal page <a id="_idTextAnchor379"/>forever.</p>
<p>That’s all for the interface. Let’s create an implementation using .NET MAU<a id="_idTextAnchor380"/>I Shell.</p>
<h4>Implementing the INavigate interface using .NET MAUI Shell</h4>
<p>The implementation is very straightforward <a id="_idIndexMarker558"/>since each method is only calling .NET MAUI static methods provided by the Shell API.</p>
<p>Create the <code>Navigator</code> class, as shown in the following steps:</p>
<ol>
<li>In the <code>News</code> project, add a new class called <code>Navigator</code>.</li>
<li>Add the following code to the class:<pre class="source-code">
namespace News;
using News.ViewModels;
public class Navigator : INavigate
{
    public async Task NavigateTo(string route) =&gt; await Shell.Current.GoToAsync(route);
    public async Task PushModal(Page page) =&gt; await Shell.Current.Navigation.PushModalAsync(page);
    public async Task PopModal() =&gt; await Shell.Current.Navigation.PopModal<a id="_idTextAnchor381"/>A<a id="_idTextAnchor382"/>sync();
}</pre></li> </ol>
<p>This is simply pass-through code that calls already existing methods. Now, we need to register the type with our<a id="_idIndexMarker559"/> dependency injection container so that it can be consumed by the <code>ViewMo<a id="_idTextAnchor383"/>del</code> class.</p>
<h4>Registering the Navigator class with dependency injection</h4>
<p>For the <code>ViewModel</code> class and its descendants to have access to the <code>Navigator</code> instance, we will have to register it with the<a id="_idIndexMarker560"/> container, just like we did with <code>NewService</code>; just follow these steps:</p>
<ol>
<li>In the <code>News</code> project, open the <code>MauiProgram.cs</code> file.</li>
<li>Find the <code>RegisterAppTypes</code> method and add the following highlighted code:<pre class="source-code">
public static MauiAppBuilder RegisterAppTypes(this MauiAppBuilder mauiAppBuilder)
{
    // Services
    mauiAppBuilder.Services.AddSingleton&lt;Services.INewsService&gt;((serviceProvider) =&gt; new Services.NewsService());
<strong class="bold">    mauiAppBuilder.Services.AddSingleton&lt;ViewModels.INavigate&gt;((serviceProvider) =&gt; new Navigator());</strong>
    // ViewModels
…
}</pre></li> </ol>
<p>Now, we can add the <code>INavigate</code> interface <a id="_idIndexMarker561"/>to the <code>ViewModel</code> class and its descendants.</p>
<h4>Adding the INavigate interface to the ViewModel class</h4>
<p>To be able to access <code>Navigator</code>, we<a id="_idIndexMarker562"/> must extend the <code>ViewModel</code> base class, making it available to all <code>ViewModels</code>. Proceed as follows:</p>
<ol>
<li>In the <code>News</code> project, open the <code>ViewModels</code> folder, and then open the <code>ViewModel.cs</code> file.</li>
<li>Add the following highlighted code to the class:<pre class="source-code">
public abstract class ViewModel
{
    <strong class="bold">public INavigate Navigation { get; init; }</strong>
<strong class="bold">    internal ViewModel(INavigate navigation) =&gt; Navigation = navigation;</strong>
}</pre></li> <li>Open the <code>HeadlinesViewModel.cs</code> file and make the highlighted changes to the constructor:<pre class="source-code">
public HeadlinesViewModel(INewsService newsService<strong class="bold">, INavigate navigation) : base (navigation)</strong></pre></li> </ol>
<p>The base <code>ViewModel</code> now exposes the <code>Navigator</code> property through the <code>INavigate</code> interface. At this <a id="_idIndexMarker563"/>point, we are ready to wire up the navigation to our<a id="_idTextAnchor384"/><a id="_idTextAnchor385"/> <code>Article</code> view.</p>
<h3>Navigating using routes</h3>
<p>Routes are a very handy way to navigate since they abstract the creation of the page away. All we need to know is the route to the view we want to navigate to – .NET MAUI Shell takes care of the rest for us. If you are familiar with how web navigation works, you might recognize the <a id="_idIndexMarker564"/>way that we pass arguments in routes. They are passed as qu<a id="_idTextAnchor386"/><a id="_idTextAnchor387"/><a id="_idTextAnchor388"/>ery parameters.</p>
<h4>Finalizing the ItemSelected command</h4>
<p>Previously, we <a id="_idIndexMarker565"/>defined the <code>ItemSelected</code> method in the <code>HeadlinesViewModel</code> class. Now, it’s time to add code that will perform the navigation to <code>ArticleView</code>:</p>
<ol>
<li>In the <code>News</code> project, expand the <code>ViewModels</code> folder and open <code>HeadlinesViewModel.cs</code>.</li>
<li>Locate the <code>ItemSelected</code> method and add the following line marked in bold:<pre class="source-code">
[RelayCommand]
public <strong class="bold">async Task</strong> ItemSelected(object selectedItem)
{
    var selectedArticle = selectedItem as Article;
    var url = HttpUtility.UrlEncode(selectedArticle.Url);
    <strong class="bold">await Navigation.NavigateTo($"articleview?url={url}");</strong>
}</pre></li> </ol>
<p>Here, we define a route called <code>articleview</code> that takes a query-line parameter called <code>url</code> that points to the URL of the article itself. It will look something like this: <code>articleview?url=www.mypage.com</code>. Only the data passed after the <code>url=</code> argument must be <code>HttpUtility.UrlEncode()</code> method, which is defined in <code>System.Web</code> for us.</p>
<p>The preceding <code>NavigateTo()</code> method call uses this encoded data in the query parameter. On the recipient side of the <a id="_idIndexMarker566"/>navigation call, we need to handle the incomi<a id="_idTextAnchor389"/><a id="_idTextAnchor390"/>ng <code>url</code> parameter.</p>
<h4>Extending ArticleView so that it receives query data</h4>
<p><code>ArticleView</code> is responsible <a id="_idIndexMarker567"/>for rendering the article for us. To keep things simple (and also illustrate that you don’t always need <code>ViewModel</code>), we will not define <code>ViewModel</code> for this class; instead, we will define <code>BindingContext</code> as an instance of the <code>UrlWe<a id="_idTextAnchor391"/>bViewSource</code> class.</p>
<p>Add the following code to the <code>ArticleView.xaml.cs</code> file:</p>
<ol>
<li>In the <code>News</code> project, expand the <code>Views</code> folder and open the <code>ArticleView.xaml.cs</code> file.</li>
<li>Add the following code marked in bold to the file:<pre class="source-code">
namespace News.Views;
<strong class="bold">using System.Web;</strong>
<strong class="bold">[QueryProperty("Url", "url")]</strong>
public partial class ArticleView : ContentPage
{
<strong class="bold">    public string Url</strong>
<strong class="bold">    {</strong>
<strong class="bold">        set</strong>
<strong class="bold">        {</strong>
<strong class="bold">            BindingContext = new UrlWebViewSource</strong>
<strong class="bold">            {</strong>
<strong class="bold">                Url = HttpUtility.UrlDecode(value)</strong>
<strong class="bold">            };</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
    public ArticleView()
    {
        InitializeComponent();
    }
}</pre></li> </ol>
<p><code>ArticleView</code> is dependent on a URL being set, and we do so by defining a set-only property called <code>Url</code>. When this property is set, it creates a new instance of <code>UrlWebViewSource</code> with the <a id="_idIndexMarker568"/>value of the property and assigns it to the page’s <code>BindingContext</code>. This setter is called by the Shell framework since we added an attribute called <code>QueryProperty</code> to the class itself. It takes two arguments – the first is which property to set, while the second is the name of the <code>url</code> query parameter.</p>
<p>Since the data comes URL encoded, we need to decode it using the <code>HttpUtility.UrlDecode()</code> method.</p>
<p>With that, we have a binding context that points to the web page we want to display. Now, we just need to<a id="_idIndexMarker569"/> define <a id="_idTextAnchor392"/><a id="_idTextAnchor393"/><a id="_idTextAnchor394"/><code>WebView</code> in the XAML.</p>
<h4>Extending ArticleView with WebView</h4>
<p>This page only has one purpose, and that is to <a id="_idIndexMarker570"/>display the web page from the URL that we passed to it. Let’s add a <code>WebView</code> control to the page, as follows:</p>
<ol>
<li>In the <code>News</code> project, expand the <code>Views</code> folder and open <code>ArticleView.xaml</code>.</li>
<li>Add the following highlighted XAML:<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
             
    x:Class="News.Views.ArticleView"
    Title="ArticleView"&gt;
    <strong class="bold">&lt;WebView Source="{Binding .}" /&gt;</strong>
&lt;/ContentPage&gt;</pre></li> </ol>
<p>The <code>WebView</code> control will take up all available space in the view. The source will be set to <code>.</code>, meaning that it will be the same as the <code>BindingContext</code> property of <code>ViewModel</code>. In this case, the <code>BindingContext</code> property is a <code>UrlWebViewSource</code> instance, which is exactly what <code>WebView</code> needs to navigate and display the content.</p>
<p>We’ve only got one step left – our app needs to know about the <code>ArticleView</code> route an<a id="_idTextAnchor395"/><a id="_idTextAnchor396"/>d what to do with it.</p>
<h4>Registering the route</h4>
<p>As mentioned previously, routes <a id="_idIndexMarker571"/>can be added declaratively in the XAML (<code>Route="MyDucks"</code>) or code, as shown here:</p>
<ol>
<li>In the <code>News</code> project, open the <code>AppShell.xaml.cs</code> file.</li>
<li>Add the following lines of code marked in bold:<pre class="source-code">
namespace News;
public partial class AppShell : Shell
{
    public AppShell()
    {
        InitializeComponent();
        Routing.RegisterRoute("articleview", typeof(Views.ArticleView));
    }
}</pre></li> </ol>
<p>The <code>RegisterRoute()</code> method takes two arguments – the first is the route we want to use, and it’s the one that we specify in the <code>NavigateTo()</code> calls. The second is the type of page (view) that we want to create – in our case, we want to create <code>ArticleView</code>.</p>
<p>Cool! That wraps it up. The app should now run, and you should be able to navigate to the article from any of your <code>Colle<a id="_idTextAnchor397"/>ctionViews</code>. Good work!</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor398"/>Summary</h1>
<p>In this chapter, we learned how to define a navigation structure using .NET MAUI Shell, how to navigate to views using routes, and how to pass arguments between views in the form of a query string. There is a lot more to Shell, but this should get you started and confident enough to start exploring the Shell APIs. Also, keep in mind that the Shell APIs are constantly evolving, so make sure you check out the latest features available.</p>
<p>We also learned how to create an API client for an arbitrary REST API, which always comes in handy since most of the apps you will write need to communicate with a server at some point. There is a very good chance that the server will expose its data and functionality through a REST API.</p>
<p>If you are interested in extending the app even further, try designing your own <code>News</code> API key to be set through the settings.</p>
<p>The next project will be about creating a match-making app, and how to create a swiping-enabled yes/no image selector app using nothing but .NET MAUI to render and animate cross-platform UI controls.</p>
</div>
</body></html>