- en: Chapter 7. Deploying and Testing on Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。在设备上部署和测试
- en: Deploying to devices is both important and a bit of a hassle when you try it
    the first time. Testing on a device will commonly display performance issues that
    aren't present in the simulator/emulator of your application. You can also test
    things that are only possible on real devices such as GPS, camera, memory limitations,
    or cellular network connectivity. There are also common pitfalls that exist when
    developing for Xamarin, which will only surface when testing on a real device.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首次尝试部署到设备时，这既重要又有些麻烦。在设备上测试通常会显示在应用程序的模拟器/仿真器中不存在的性能问题。您还可以测试只能在真实设备上完成的事情，例如
    GPS、摄像头、内存限制或蜂窝网络连接。在为 Xamarin 开发时，也存在一些常见的陷阱，这些陷阱只有在真实设备上测试时才会显现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: iOS provisioning
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 配置
- en: Android device settings for debugging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 设备调试设置
- en: The linker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接器
- en: Ahead-of-time (AOT) compilation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译（AOT）
- en: Common memory pitfalls with Xamarin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Xamarin 相关的常见内存陷阱
- en: Before we begin this chapter, it is important to note that an iOS Developer
    Program membership is required to deploy to iOS devices. Feel free to go back
    to [Chapter 1](part0014_split_000.html#page "Chapter 1. Setting Up Xamarin"),
    *Setting Up Xamarin*, to walk through this process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始本章之前，重要的是要注意，部署到 iOS 设备需要 iOS 开发者计划会员资格。您可以随时返回到[第 1 章](part0014_split_000.html#page
    "第 1 章。设置 Xamarin")，*设置 Xamarin*，以了解此过程。
- en: iOS provisioning
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS 配置
- en: Apple has a strict process for deploying applications to iOS devices. While
    being quite convoluted and sometimes painful for developers, Apple can enable
    a certain level of security by preventing the average user from side loading potentially
    malicious applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司对部署应用程序到 iOS 设备有一套严格的过程。虽然这对开发者来说可能相当复杂，有时甚至痛苦，但苹果可以通过阻止普通用户侧载可能有害的应用程序来提高一定级别的安全性。
- en: Prerequisites for deploying to iOS
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到 iOS 的先决条件
- en: Before we can deploy our application to an iOS device, there are a few things
    we will need to set up in the **iOS Dev Center**. We will begin by creating an
    App ID or a bundle ID for your account. This is the primary identifier for any
    iOS application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将我们的应用程序部署到 iOS 设备之前，我们需要在**iOS 开发中心**设置一些事情。我们将首先为您创建 App ID 或包 ID。这是任何
    iOS 应用程序的主要标识符。
- en: 'We will begin by navigating to [http://developer.apple.com](http://developer.apple.com)
    and performing the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导航到 [http://developer.apple.com](http://developer.apple.com) 并执行以下步骤：
- en: Click on the **iOS Apps** icon.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**iOS 应用**图标。
- en: Sign in with your developer account.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的开发者账户登录。
- en: Click on **Certificates, Identifiers, & Profiles** on the right-hand side navigation.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧导航中的**证书、标识符和配置文件**。
- en: Click on **Identifiers**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**标识符**。
- en: Click on the plus button to add a new iOS App ID.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击加号按钮添加新的 iOS App ID。
- en: In the **Name** field, enter something meaningful such as `YourCompanyNameWildcard`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**字段中，输入一些有意义的名称，例如 `YourCompanyNameWildcard`。
- en: Select the **Wildcard App ID** radio button.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**通配符 App ID**单选按钮。
- en: In the **Bundle ID** field, select a reverse domain styled name for your company
    such as `com.yourcompanyname.*`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**包 ID**字段中，选择一个反向域名风格的名称，例如 `com.yourcompanyname.*`。
- en: Click on **Continue**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**继续**。
- en: Review the final setting and hit **Submit**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查最终设置并点击**提交**。
- en: Leave this web page open, as we will be using it throughout the chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 保持此网页打开，因为我们将在本章中一直使用它。
- en: We just registered a wildcard bundle ID for your account; use this as a prefix
    for all future applications you wish to identify with this account. Later, when
    you are preparing to deploy an app to the Apple App Store, you will create an
    **Explicit App ID** such as `com.yourcompanyname.yourapp`. This allows you to
    deploy the specific app to the store, while the wildcard ID is best used for deploying
    to devices for testing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为您注册了一个通配符包 ID；请将此用作所有未来希望与该账户关联的应用程序的名称前缀。稍后，当您准备将应用程序部署到苹果应用商店时，您将创建一个**显式
    App ID**，例如 `com.yourcompanyname.yourapp`。这允许您将特定应用程序部署到商店，而通配符 ID 最好用于部署到设备进行测试。
- en: Next, we need to locate the unique identifier on each device you plan on debugging
    your application on. Apple requires each device to be registered under your account
    with a limit of 200 devices per developer. The only way to circumvent this requirement
    is to register for the iOS Developer Enterprise program with a $299 yearly fee
    that is separate from the standard $99 developer fee.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找到您计划在调试应用程序的每个设备上的唯一标识符。苹果要求每个设备都必须在您的账户下注册，每个开发者的设备数量限制为200台。绕过这一要求的唯一方法是注册iOS开发者企业计划，该计划每年费用为299美元，与标准99美元的开发者费用分开。
- en: 'We will begin by launching Xcode and performing the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始启动Xcode并执行以下步骤：
- en: Navigate to **Window** | **Devices** in the top menu.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部菜单中导航到**窗口** | **设备**。
- en: Plug in your target device with a USB cable.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用USB线将您的目标设备连接上。
- en: On the left-hand side navigation, you should see your device's name. Click on
    it to select it.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航栏中，您应该看到您的设备名称。点击它以选择它。
- en: Notice the **Identifier** value for your device. Copy it to your clipboard.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意您的设备的**标识符**值。将其复制到您的剪贴板。
- en: 'The following screenshot shows what your screen should look like with your
    device selected in Xcode:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Xcode中选择您的设备时您的屏幕应该看起来像什么：
- en: '![Prerequisites for deploying to iOS](img/00053.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![部署到iOS的先决条件](img/00053.jpeg)'
- en: 'Return to [http://developer.apple.com](http://developer.apple.com) (hopefully,
    it is still open from earlier in the chapter) and perform the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到[http://developer.apple.com](http://developer.apple.com)（希望它仍然在章节的早期打开）并执行以下步骤：
- en: Navigate to **Devices** | **All** on the left-hand side navigation.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航栏中导航到**设备** | **所有**。
- en: Click on the plus button in the top-right corner of the page.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面右上角的加号按钮。
- en: Enter a meaningful name for your device and paste the **Identifier** value from
    your clipboard into the **UDID** field.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的设备输入一个有意义的名称，并将剪贴板中的**标识符**值粘贴到**UDID**字段中。
- en: Click on **Continue**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**继续**。
- en: Review the information you entered and hit **Register**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看您输入的信息并点击**注册**。
- en: Down the road, when your account is fully set up, you can just click on the
    **Use for Development** button in Xcode and skip the second set of steps.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在将来，当您的账户完全设置好时，您只需在Xcode中点击**用于开发**按钮即可跳过第二组步骤。
- en: 'The following screenshot shows you what your device list should look like when
    complete:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了完成时您的设备列表应该看起来像什么：
- en: '![Prerequisites for deploying to iOS](img/00054.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![部署到iOS的先决条件](img/00054.jpeg)'
- en: Next, we will need to generate a certificate to represent you as the developer
    for your account. Prior to Xcode 5, you had to create a certificate signing request
    using the **Keychain** app on your Mac. You can find this under `Applications`,
    or using the search spotlight on OS X via *Command* + *Space*. The newer versions
    of Xcode make things a lot easier by integrating a lot of this process into Xcode.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要生成一个代表您作为账户开发者的证书。在Xcode 5之前，您必须使用Mac上的**密钥链**应用程序创建一个证书签名请求。您可以在“应用程序”下找到它，或者使用OS
    X的搜索spotlight通过*Command* + *Space*。Xcode的新版本通过将许多此过程集成到Xcode中，使事情变得容易得多。
- en: 'Open Xcode and perform the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Xcode并执行以下步骤：
- en: Navigate to **Xcode** | **Preferences** in the menu at the top.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部菜单中导航到**Xcode** | **首选项**。
- en: Select the **Accounts** tab.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**账户**选项卡。
- en: Click on the plus button, on the bottom-left, and then click on **Add Apple
    ID**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左下角的加号按钮，然后点击**添加Apple ID**。
- en: Enter the e-mail and password for your developer account.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您的开发者账户的电子邮件和密码。
- en: On creating the account, click on **View Details** on the bottom-right.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建账户时，点击右下角的**查看详情**。
- en: Click on the **sync** button on the bottom-left.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左下角的**同步**按钮。
- en: If this is a new account, Xcode will display a warning that no certificates
    exist yet. Check each box and click on **Request** to generate the certificates.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是一个新账户，Xcode将显示一个警告，表示尚不存在任何证书。勾选每个框并点击**请求**以生成证书。
- en: Xcode will now automatically create a developer certificate for your account
    and install it into your Mac's keychain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode现在将自动为您创建一个开发者证书并将其安装到您的Mac的密钥链中。
- en: 'The following screenshot shows what your screen will look after setting up
    your account:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了设置账户后您的屏幕将看起来像什么：
- en: '![Prerequisites for deploying to iOS](img/00055.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![部署到iOS的先决条件](img/00055.jpeg)'
- en: Creating a provisioning profile
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建配置文件
- en: Next, we need to create a **provisioning profile**. This is the final file that
    allows applications to be installed on an iOS device. A provisioning profile contains
    an App ID, a list of device IDs, and finally, a certificate for the developer.
    You must also have the private key of the developer certificate in your Mac's
    keychain to use a provisioning profile.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个**配置文件**。这是允许应用程序安装在iOS设备上的最终文件。配置文件包含一个App ID、设备ID列表，最后是开发者的证书。您还必须在Mac的密钥链中拥有开发者证书的私钥才能使用配置文件。
- en: 'The following are a few types of provisioning profiles:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些配置文件类型：
- en: '**Development**: This is used for debug or release builds. You will actively
    use this type of profile when your applications are in development.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：这用于调试或发布构建。当您的应用程序处于开发阶段时，您将积极使用此类配置文件。'
- en: '**Ad Hoc**: This is used mainly for release builds. This type of certificate
    is great for beta testing or distribution to a small set of users. You can distribute
    to an unlimited number of users using this method with an enterprise developer
    account.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ad Hoc**：这主要用于发布构建。此类证书非常适合beta测试或向少量用户分发。使用企业开发者帐户，您可以使用此方法向无限数量的用户分发。'
- en: '**App Store**: This is used for release builds for submission to the App Store.
    You cannot deploy an app to your device using this certificate; it can only be
    used for store submission.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**App Store**：这用于提交到App Store的发布构建。您不能使用此证书将应用程序部署到您的设备；它只能用于商店提交。'
- en: 'Let''s return to [http://developer.apple.com](http://developer.apple.com) and
    create a new provisioning profile by performing the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[http://developer.apple.com](http://developer.apple.com)并按照以下步骤创建一个新的配置文件：
- en: Navigate to **Provisioning Profiles** | **All** on the left-hand side pane.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到左侧面板上的**配置文件** | **所有**。
- en: Click on the plus button at the top-right of the page.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面右上角的加号按钮。
- en: Select **iOS App Development** and click on **Continue**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**iOS应用开发**并点击**继续**。
- en: Select your wildcard App ID created earlier in the chapter and click on **Continue**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择本章中创建的通配符App ID并点击**继续**。
- en: Select the certificate we created earlier in the chapter and click on **Continue**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择本章中创建的证书并点击**继续**。
- en: Select the devices you want to deploy to and click on **Continue**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要部署到的设备并点击**继续**。
- en: Enter an appropriate **Profile Name** such as `YourCompanyDev`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个合适的**配置文件名称**，例如`YourCompanyDev`。
- en: Click on **Generate** and your provisioning profile will be created.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成**，您的配置文件将被创建。
- en: The following screenshot shows the new profile that you will end up with on
    creation. Don't worry about downloading the file; we'll use Xcode to import the
    final profile.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了创建过程中最终将得到的配置文件。不用担心下载文件；我们将使用Xcode导入最终配置文件。
- en: '![Creating a provisioning profile](img/00056.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![创建配置文件](img/00056.jpeg)'
- en: 'To import the provisioning profile, return to Xcode and perform the following
    steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入配置文件，请返回Xcode并执行以下步骤：
- en: Navigate to **Xcode** | **Preferences** in the menu at the top of the dialog.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到对话框顶部的菜单中的**Xcode** | **首选项**。
- en: Select the **Accounts** tab.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**帐户**选项卡。
- en: Select your account and click on **View Details**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的帐户并点击**查看详情**。
- en: Click on the **sync** button on the bottom-left.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左下角的**同步**按钮。
- en: After a few seconds, your provisioning profiles will appear.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，您的配置文件将出现。
- en: Xcode will automatically include any provisioning profiles you have created
    on the Apple developer site. Xcode will also create a few profiles on its own.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode将自动包括您在Apple开发者网站上创建的任何配置文件。Xcode还会创建一些自己的配置文件。
- en: In the latest version of Xamarin Studio, you can view these profiles but will
    not be able to sync them. Navigate to **Xamarin Studio** | **Preferences** | **Developer
    Accounts** to view the provisioning profiles from Xamarin Studio. You can also
    view Xamarin's documentation on iOS provisioning on their documentation website
    at [http://docs.xamarin.com/guides/ios/getting_started/device_provisioning/](http://docs.xamarin.com/guides/ios/getting_started/device_provisioning/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio的最新版本中，您可以查看这些配置文件，但无法同步它们。导航到**Xamarin Studio** | **首选项** |
    **开发者帐户**以查看Xamarin Studio中的配置文件。您还可以在Xamarin的文档网站上查看有关iOS配置的文档，网址为[http://docs.xamarin.com/guides/ios/getting_started/device_provisioning/](http://docs.xamarin.com/guides/ios/getting_started/device_provisioning/)。
- en: Android device settings
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓设备设置
- en: Compared to the hassle of deploying your application on iOS devices, Android
    is a breeze. To deploy an application to a device, you merely have to set a few
    settings on the device. This is due to Android's openness in comparison to iOS.
    Android device debugging is turned off for most users, but it can be easily turned
    on by any developer who might wish to have a go at writing Android applications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与在iOS设备上部署应用的麻烦相比，Android要容易得多。要将应用部署到设备上，你只需在设备上设置一些设置即可。这是由于Android相对于iOS的开放性。大多数用户的Android设备调试是关闭的，但任何可能想尝试编写Android应用的开发者都可以轻松将其打开。
- en: 'We will begin by opening the **Settings** application. You might have to locate
    this by looking through all the applications on the device as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先打开**设置**应用。你可能需要通过查看设备上的所有应用来找到它，如下所示：
- en: Scroll down and click on the section labeled **Developer options**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动并点击标记为**开发者选项**的部分。
- en: In the action bar at the top, you might have to toggle a switch to the **ON**
    position. This varies on each device.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的操作栏中，你可能需要将开关切换到**开启**位置。这因设备而异。
- en: Scroll down and check **USB Debugging**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动并勾选**USB调试**。
- en: A warning confirmation message will appear. Then, click on **OK**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个警告确认消息。然后，点击**确定**。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that some newer Android devices have made it a little more difficult for
    the average user to turn on USB debugging. You have to click on the **Developer
    options** item seven times to turn this option on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些较新的Android设备使得普通用户开启USB调试变得稍微困难一些。你必须点击**开发者选项**项目七次才能打开此选项。
- en: 'The following screenshot shows what your device will look like during the process:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在过程中你的设备将看起来像什么：
- en: '![Android device settings](img/00057.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Android设备设置](img/00057.jpeg)'
- en: After enabling this option, all you have to do is plug in your device via USB
    and debug an Android application in Xamarin Studio. You will see your device listed
    in the **Select Device** dialog. Note that if you are on Windows or have a nonstandard
    device, you might have to visit your device vendor's website to install drivers.
    Most Samsung and Nexus devices install their drivers automatically. On Android
    4.3 and higher, there is also a confirmation dialog on the device that appears
    before beginning a USB debugging session.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此选项后，你只需通过USB连接你的设备，并在Xamarin Studio中调试Android应用即可。你将在**选择设备**对话框中看到你的设备。请注意，如果你使用Windows或非标准设备，你可能需要访问设备制造商的网站来安装驱动程序。大多数三星和Nexus设备会自动安装它们的驱动程序。在Android
    4.3及以上版本中，在开始USB调试会话之前，设备上还会出现一个确认对话框。
- en: The following screenshot shows you what your device will look like for a Samsung
    Galaxy SII in the **Select Device** dialog. Xamarin Studio will display the model
    number, which is not always a name that you can recognize. You can view this model
    number in your device's settings.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在**选择设备**对话框中你的设备将看起来像三星Galaxy SII。Xamarin Studio将显示型号编号，这并不总是你可以识别的名字。你可以在设备的设置中查看此型号编号。
- en: '![Android device settings](img/00058.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Android设备设置](img/00058.jpeg)'
- en: Understanding the linker
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解链接器
- en: To keep Xamarin applications small and lightweight for mobile devices, Xamarin
    has created a feature for their compiler called the **linker**. Its main purpose
    is to strip unused code out of the core Mono assemblies (such as `System.dll`)
    and platform-specific assemblies (such as `Mono.Android.dll` and `monotouch.dll`).
    However, it can also give you the same benefits if it is set up to run on your
    own assemblies. Without running the linker, the entire Mono framework can be around
    30 megabytes. This is why linking is enabled by default in device builds, which
    enables you to keep your applications small.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Xamarin应用在移动设备上保持小巧和轻量，Xamarin为其编译器创建了一个名为**链接器**的功能。其主要目的是从核心Mono汇编（如`System.dll`）和平台特定汇编（如`Mono.Android.dll`和`monotouch.dll`）中删除未使用的代码。然而，如果它被设置为在你的自己的汇编上运行，它也可以给你带来同样的好处。不运行链接器，整个Mono框架大约有30兆字节。这就是为什么默认情况下在设备构建中启用链接的原因，这使你可以保持你的应用小巧。
- en: The linker uses static analysis to work through the various code paths in an
    assembly. If it determines a method or class that is never used, it removes the
    unused code from that assembly. This can be a time-consuming process, so builds
    running in the simulator skip this step by default.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器使用静态分析来处理汇编中的各种代码路径。如果它确定某个方法或类从未使用过，它将从该汇编中删除未使用的代码。这可能是一个耗时的过程，因此默认情况下，在模拟器中运行的构建会跳过此步骤。
- en: 'Xamarin applications have the following three main settings for the linker:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin应用程序有针对链接器的以下三个主要设置：
- en: '**Don''t Link**: In this setting, the linker compilation step is skipped. This
    is best used for builds running in the simulator or if you need to diagnose a
    potential issue with the linker.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不链接**：在此设置中，跳过链接器编译步骤。这最好用于在模拟器中运行的构建或如果您需要诊断链接器可能存在的问题。'
- en: '**Link SDK Assemblies Only**: In this setting, the linker will only be run
    on the core Mono assemblies such as `System.dll`, `System.Core.dll`, and `System.Xml.dll`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅链接SDK程序集**：在此设置中，链接器将仅在核心Mono程序集（如`System.dll`、`System.Core.dll`和`System.Xml.dll`）上运行。'
- en: '**Link All Assemblies**: In this setting, the linker is run against all the
    assemblies in your application, which include any class libraries or third-party
    assemblies you are using.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接所有程序集**：在此设置中，链接器将针对您的应用程序中的所有程序集运行，包括您使用的任何类库或第三方程序集。'
- en: These settings can be found in the **Project** options of any Xamarin.iOS or
    Xamarin.Android application. These settings are generally not present on class
    libraries, as it is generally associated with an iOS or Android application that
    will be deployed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置可以在任何Xamarin.iOS或Xamarin.Android应用程序的**项目**选项中找到。通常，这些设置不会出现在类库中，因为它通常与将要部署的iOS或Android应用程序相关联。
- en: The linker can also cause potential issues at runtime as there are cases in
    which its analysis determines incorrectly that a piece of code is unused. This
    can happen if you are using features in the `System.Reflection` namespace instead
    of accessing the method or property directly. This is one reason why it is important
    for you to test your application on physical devices, as linking is enabled for
    device builds.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器也可能在运行时引起潜在问题，因为在某些情况下，其分析错误地确定某些代码未使用。如果您使用的是`System.Reflection`命名空间中的功能而不是直接访问方法或属性，则可能会发生这种情况。这就是为什么您需要在物理设备上测试您的应用程序很重要的原因，因为设备构建启用了链接。
- en: 'To demonstrate this issue, let''s take a look at the following code example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个问题，让我们看一下以下代码示例：
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the preceding code will work fine using the options for **Don''t Link**
    or **Link SDK Assemblies Only**. However, if you try to run this, when using **Link
    All Assemblies**, you will get an exception similar to the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**不链接**或**仅链接SDK程序集**的选项运行前面的代码将正常工作。但是，如果您尝试使用**链接所有程序集**运行此代码，您将得到一个类似于以下异常：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the `Name` property's getter was never used directly from code, the linker
    stripped it from the assembly. This caused the reflection code to fail at runtime.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Name`属性的getter从未直接从代码中使用，链接器将其从汇编中移除。这导致反射代码在运行时失败。
- en: Even though potential issues can arise in your code, the option of **Link All
    Assemblies** is still quite useful. There are a few optimizations that can only
    be performed in this mode, and Xamarin can reduce your application to the smallest
    possible size. If performance or a tiny download size is the requirement for your
    application, you can try this option. However, thorough testing should be performed
    to verify that no problems are caused by linking your assemblies.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码中可能会出现潜在问题，但**链接所有程序集**的选项仍然非常有用。只有在这种模式下才能执行一些优化，Xamarin可以将您的应用程序减小到可能的最小大小。如果您的应用程序需要性能或极小的下载大小，您可以尝试此选项。但是，应该进行彻底的测试，以验证链接程序集不会引起任何问题。
- en: To resolve issues in your code, Xamarin has included a complete set of workarounds
    to prevent specific parts of your code from being stripped away.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决代码中的问题，Xamarin包含了一套完整的解决方案，以防止您的代码的特定部分被移除。
- en: 'Some of the options include the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些选项包括以下内容：
- en: Mark class members with `[Preserve]`. This will force the linker to include
    the attributed method, field, or property.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`[Preserve]`标记类成员。这将强制链接器包含具有该属性的函数、字段或属性。
- en: Mark an entire class with `[Preserve(AllMembers=true)]`. This will preserve
    all code within the class.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`[Preserve(AllMembers=true)]`标记整个类。这将保留类中的所有代码。
- en: 'Mark an entire assembly with `[assembly: Preserve]`. This is an assembly-level
    attribute that will preserve all code contained within it.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用`[assembly: Preserve]`标记整个程序集。这是一个程序集级别的属性，将保留其中包含的所有代码。'
- en: Skip an entire assembly by modifying **Additional mtouch arguments** in your
    project options. Use `--linkskip=System` to skip an entire assembly. This can
    be used on assemblies that you do not have the source code for.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改项目选项中的**附加mtouch参数**来跳过一个整个程序集。使用`--linkskip=System`来跳过一个整个程序集。这可以用于您没有源代码的程序集。
- en: Custom linking via an XML file. This is the best option to use when you need
    to skip linking on a specific class or method that you do not have the source
    code for. Use `–-xml=YourFile.xml` in **Additional mtouch arguments**.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 XML 文件进行自定义链接。当你需要跳过没有源代码的特定类或方法的链接时，这是最佳选择。在**附加 mtouch 参数**中使用 `–-xml=YourFile.xml`。
- en: 'The following is a sample XML file that demonstrates custom linking:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示自定义链接的示例 XML 文件：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Custom linking is the most complicated option and is usually the last resort.
    Luckily, most Xamarin applications will not have to work around many linker issues.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义链接是最复杂的选择，通常是最后的手段。幸运的是，大多数 Xamarin 应用程序不需要解决许多链接器问题。
- en: Understanding AOT compilation
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 AOT 编译
- en: The runtime behind Mono and .NET on Windows is based on a **just in time** (**JIT**)
    compiler. C# and other .NET languages are compiled into **Microsoft Intermediate
    Language** (**MSIL**). At runtime, MSIL is compiled into a native code to run
    on whatever type of architecture is running your application. Xamarin.Android
    follows this exact pattern. However, due to Apple's restrictions on dynamically
    generated code, a JIT compiler is not allowed on iOS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 上 Mono 和 .NET 的运行时基于一个**即时**（**JIT**）编译器。C# 和其他 .NET 语言被编译成**微软中间语言**（**MSIL**）。在运行时，MSIL
    被编译成原生代码以在运行应用程序的任何类型的架构上运行。Xamarin.Android 遵循这个模式。然而，由于苹果对动态生成代码的限制，iOS 上不允许使用
    JIT 编译器。
- en: To work around this restriction, Xamarin has developed a new option called **Ahead-of-time**
    (**AOT**) compilation. In addition to making .NET possible on iOS, AOT has other
    benefits such as a shorter startup time and potentially better performance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个限制，Xamarin 开发了一个新的选项，称为**预编译**（**AOT**）编译。除了使 .NET 在 iOS 上成为可能之外，AOT 还具有其他好处，如更短的启动时间和可能更好的性能。
- en: AOT also has some limitations that are generally related to C# generics. To
    compile an assembly ahead of time, the compiler will need to run some static analysis
    against your code to determine the type of information. Generics throw a wrench
    into this situation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: AOT 也有一些限制，通常与 C# 泛型相关。为了在编译前编译程序集，编译器需要对你的代码进行一些静态分析以确定信息类型。泛型给这种情况带来了麻烦。
- en: 'There are a few cases that are not supported by AOT, but they are completely
    valid in C#. The first is a generic interface, which is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况不支持 AOT，但在 C# 中它们是完全有效的。第一个是一个泛型接口，如下所示：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The compiler cannot determine the classes that can implement this interface
    ahead of time, especially when multiple assemblies are involved. The second limitation
    is related to the first. You cannot override virtual methods that contain generic
    parameters or return values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器无法在编译前确定可以实现此接口的类，尤其是在涉及多个程序集时。第二个限制与第一个相关。你不能重写包含泛型参数或返回值的虚拟方法。
- en: 'The following is a simple example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, the static analysis of the compiler cannot determine which classes can
    override this method at compile time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，编译器的静态分析无法在编译时确定哪些类可以重写此方法。
- en: 'Another limitation is that you cannot use `DllImport` in a generic class, as
    shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个限制是，你无法在泛型类中使用 `DllImport`，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you are not familiar with the language feature, `DllImport` is a way to call
    native C/C++ methods from C#. Using them inside generic classes is not supported.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉语言功能，`DllImport` 是从 C# 调用原生 C/C++ 方法的一种方式。在泛型类中使用它们是不支持的。
- en: These limitations are another good reason why testing on devices is important
    since the preceding code will work fine on other platforms that can run C# code
    but not Xamarin.iOS.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制是另一个很好的理由，说明为什么在设备上进行测试很重要，因为前面的代码在其他可以运行 C# 代码但不是 Xamarin.iOS 的平台上运行良好。
- en: Avoiding common memory pitfalls
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免常见的内存陷阱
- en: Memory on mobile devices is certainly not an unlimited commodity. Because of
    this, memory usage in your application can be much more important than on desktop
    applications. At times, you might find the need to use a memory profiler, or improve
    your code to use memory more efficiently.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备上的内存绝对不是无限的商品。因此，你的应用程序中的内存使用可能比桌面应用程序更重要。有时，你可能需要使用内存分析器，或者改进你的代码以更有效地使用内存。
- en: 'The following are the most common memory pitfalls:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见的内存陷阱：
- en: The **garbage collector** (**GC**) is unable to collect large objects fast enough
    to keep up with your application
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收器**（**GC**）无法快速收集大对象以跟上你的应用程序'
- en: Your code inadvertently causes a memory leak
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码无意中导致内存泄漏
- en: A C# object is garbage collected but is later attempted to be used by native
    code
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个C#对象被垃圾收集，但后来被原生代码尝试使用
- en: Garbage collector
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾收集器
- en: 'Let''s take a look at the first problem where the GC cannot keep up. Let''s
    say we have a Xamarin.iOS application with a button for sharing an image on Twitter
    as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个问题，即GC无法跟上。假设我们有一个Xamarin.iOS应用程序，其中有一个按钮用于在Twitter上分享图片，如下所示：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let's assume the image is a 10 MB image from the user's camera roll. If
    the user clicks on the button and cancels the Twitter post rapidly, there could
    be a possibility of your application running out of memory. iOS will commonly
    force close apps using too much memory, and you don't want users to experience
    this with your app.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设图片是从用户的相册中获取的10MB图片。如果用户快速点击按钮并取消Twitter帖子，应用程序可能会出现内存不足的情况。iOS通常会强制关闭使用过多内存的应用程序，您不希望用户在使用您的应用程序时遇到这种情况。
- en: 'The best solution is to call `Dispose` on the image when you are finished with
    it as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是在处理完图片后调用`Dispose`，如下所示：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An even better approach would be to take advantage of the C# `using` statement
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是将C#的`using`语句利用如下：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The C# `using` statement will automatically call `Dispose` in a `try-finally`
    block, so the object will get disposed even if an exception is thrown. I recommend
    that you take advantage of the `using` statement for any `IDisposable` class where
    possible. It is not always necessary for small objects such as `NSString`, but
    is always a good idea for larger, more heavyweight `UIKit` objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`using`语句会在`try-finally`块中自动调用`Dispose`，因此即使在抛出异常的情况下，对象也会被销毁。我建议您尽可能利用`using`语句来处理任何`IDisposable`类。对于像`NSString`这样的小对象，这并不总是必要的，但对于更大、更重的`UIKit`对象来说，这是一个好主意。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A similar situation can occur on Android with the `Bitmap` class. Although slightly
    different, it is best to call both the `Dispose` and `Recycle` methods on this
    class along with using the `BitmapFactory.Options` settings for `InPurgeable`
    and `InInputShareable`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况也可能在Android的`Bitmap`类中发生。尽管略有不同，但最好在这个类上调用`Dispose`和`Recycle`方法，并使用`BitmapFactory.Options`设置`InPurgeable`和`InInputShareable`。
- en: Memory leaks
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: Memory leaks are the next potential issues. C# being a managed, garbage-collected
    language prevents a lot of memory leaks, but not all of them. The most common
    leaks in C# are caused by events.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是下一个潜在的问题。C#作为一个受管理的、垃圾回收的语言，防止了许多内存泄漏，但并非全部。在C#中最常见的泄漏是由事件引起的。
- en: 'Let''s assume that we have a static class with an event as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个具有事件的静态类，如下所示：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s say we need to subscribe to the event from an iOS controller as
    follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要从iOS控制器中订阅事件，如下所示：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The problem here is that the static class will hold a reference to the controller
    until the event is unsubscribed. This is a situation that a lot of developers
    might miss. To fix this issue on iOS, I would subscribe to the event in `ViewWillAppear`
    and unsubscribe `ViewWillDisappear`. On Android, use `OnStart` and `OnStop`, or
    `OnPause` and `OnResume`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于静态类会保留对控制器的引用，直到事件取消订阅。这是很多开发者可能会忽略的情况。为了在iOS上解决这个问题，我会在`ViewWillAppear`中订阅事件，并在`ViewWillDisappear`中取消订阅。在Android上，使用`OnStart`和`OnStop`，或者`OnPause`和`OnResume`。
- en: 'You would correctly implement this event as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您将正确实现此事件如下：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, an event is not a surefire cause of a memory leak. Subscribing to the
    `TouchUpInside` event on a button inside the `ViewDidLoad` method, for example,
    is just fine. Since the button lives in memory just as long as the controller
    does, everything can get garbage collected without any problems.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个事件并不是内存泄漏的必然原因。例如，在`ViewDidLoad`方法中订阅按钮的`TouchUpInside`事件是完全可以的。因为按钮的生命周期与控制器一样长，所以所有内容都可以在没有问题的前提下进行垃圾回收。
- en: Accessing objects disposed by GC
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问GC已处理的对象
- en: For the final issue, the garbage collector can sometimes remove a C# object.
    Later, an Objective-C object attempts to access it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个问题，垃圾收集器有时会移除C#对象。后来，一个Objective-C对象尝试访问它。
- en: 'The following is an example to add a button to `UITableViewCell`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个将按钮添加到`UITableViewCell`的示例：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We add the built-in info button as an accessory view to the cell. The problem
    here is that the button will get garbage collected, but its Objective-C counterpart
    will remain in use as it is displayed on the screen. If you click on the button
    after some period of time, you will get a crash that looks something similar to
    the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将内置的信息按钮作为附件视图添加到单元格中。这里的问题是按钮将被垃圾回收，但它的 Objective-C 对应物将保持使用状态，因为它显示在屏幕上。如果你在一段时间后点击该按钮，你将得到一个类似以下崩溃：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is not the most descriptive error message, but in general, you know that
    something went wrong in the native Objective-C code. To resolve the issue, create
    a custom subclass of `UITableViewCell`, and create a dedicated member variable
    for the button as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最描述性的错误信息，但一般来说，你知道原生 Objective-C 代码中出了些问题。要解决这个问题，创建一个自定义的 `UITableViewCell`
    子类，并为按钮创建一个专门的成员变量，如下所示：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, your `GetCell` implementation will look something like the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的 `GetCell` 实现看起来可能像以下代码：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the button is not a local variable, it will no longer get garbage collected
    sooner than needed. A crash is avoided, and in some ways this code is a bit cleaner.
    Similar situations can happen on Android with the interaction between C# and Java;
    however, it is less likely since both are garbage collected languages.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于按钮不再是局部变量，它将不会在需要之前被垃圾回收。这样可以避免崩溃，并且从某种意义上说，这段代码更加简洁。类似的情况可能在 Android 上发生，由于
    C# 和 Java 之间的交互；然而，这种情况不太可能，因为两者都是垃圾回收语言。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started out learning the process of setting up iOS provision
    profiles to deploy to iOS devices. Next, we looked at the required device settings
    for deploying your application to an Android device. We discovered the Xamarin
    linker and how it can make your applications smaller and more performance-oriented.
    We went through the various settings to resolve problems caused by your code and
    the linker, and we explained AOT compilation on iOS and the limitations that occur.
    Finally, we covered the most common memory pitfalls that can occur with Xamarin
    applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习设置 iOS 配置文件的过程，以便部署到 iOS 设备。接下来，我们查看将应用程序部署到 Android 设备所需的设备设置。我们发现了
    Xamarin 链接器以及它如何使你的应用程序更小、更注重性能。我们通过了各种设置来解决由你的代码和链接器引起的问题，并解释了 iOS 上的 AOT 编译及其局限性。最后，我们涵盖了
    Xamarin 应用程序可能遇到的最常见的内存陷阱。
- en: Testing your Xamarin application on mobile devices is important for various
    reasons. Some bugs are only displayed on the device due to the platform limitations
    that Xamarin has to work around. Your PC is much more powerful, so you will see
    different performances using the simulator rather than on a physical device. In
    the next chapter, we'll create a real web service using Windows Azure to drive
    our XamChat application. We will use a feature called Azure Mobile Services and
    implement push notifications on iOS and Android.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上测试你的 Xamarin 应用程序对于各种原因来说都很重要。由于 Xamarin 必须解决的平台限制，一些错误只会在设备上显示。你的电脑更加强大，所以你会在模拟器上看到不同的性能，而不是在物理设备上。在下一章中，我们将使用
    Windows Azure 创建一个真实的 Web 服务来驱动我们的 XamChat 应用程序。我们将使用一个名为 Azure Mobile Services
    的功能，并在 iOS 和 Android 上实现推送通知。
