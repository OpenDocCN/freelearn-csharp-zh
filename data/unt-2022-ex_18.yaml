- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Implementing AI with Sensors, Behavior Trees, and ML-Agents
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用传感器、行为树和ML-Agents实现AI
- en: In [*Chapter 12*](B18347_12.xhtml#_idTextAnchor232), we dove into all the required
    details for approaching adding audio to our games. We did this by introducing
    an audio manager and individual reusable audio player components so that designers
    and developers can easily add different types of game audio to create a sound
    experience that encompasses our players. We enforced good coding practices to
    ensure we’re writing maintainable code, with an emphasis on reusability and extensibility,
    to simplify the challenges in our daily game developer lives.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B18347_12.xhtml#_idTextAnchor232)中，我们深入探讨了添加音频到游戏所需的所有细节。我们通过引入音频管理器和可重用的音频播放器组件来实现这一点，以便设计师和开发者可以轻松地添加不同类型的游戏音频，从而为玩家创造一个包含所有玩家的声音体验。我们强调了良好的编码实践，以确保我们编写的代码易于维护，并注重可重用性和可扩展性，以简化我们日常游戏开发者生活中的挑战。
- en: Now that we have addressed the sound design of our game, we can continue to
    finish out the enemy **non-player character** (**NPC**) mechanics for our FPS
    game’s level by implementing some basic **artificial intelligence** (**AI**).
    We’ll accomplish adding simple AI navigation by reusing and refactoring our previous
    2D components and code to 3D. We’ll continue to discuss the elevation and sophistication
    of NPC systems with **behavior trees** and **machine learning** (**ML**) tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了游戏的声音设计问题，我们可以继续完成FPS游戏关卡中敌人的**非玩家角色**（NPC）机制，通过实现一些基本的**人工智能**（AI）。我们将通过重用和重构先前的2D组件和代码到3D来实现简单的AI导航。我们将继续讨论NPC系统的提升和复杂化，使用**行为树**和**机器学习**（ML）工具。
- en: In this chapter, we’re going to cover the following main topics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题。
- en: Refactoring the 2D enemy systems to 3D with NavMesh
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NavMesh重构2D敌人系统到3D
- en: Dynamic enemies with sensors and behavior trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有传感器和行为树的动态敌人
- en: Introducing ML with ML-Agents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ML-Agents引入机器学习
- en: By the end of this chapter, you’ll be able to create a remarkable gameplay experience
    for your players by implementing AI-based interactions with NPCs, seamlessly navigating
    the level environment, and executing a set of behaviors on their own. You will
    better understand the differences between 2D and 3D implementation because we’ll
    revisit the 2D methods and refactor for 3D while making improvements in the process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将通过实现基于AI与NPC的交互、无缝导航关卡环境以及执行一系列自主行为，为您的玩家创造一个令人难忘的游戏体验。您将更好地理解2D和3D实现之间的差异，因为我们将在改进过程中重新审视2D方法并将其重构为3D。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载完整项目：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Refactoring the 2D enemy systems to 3D with NavMesh
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NavMesh重构2D敌人系统到3D
- en: In this chapter, the goal is to guide you through the comprehensive process
    of bringing this hovering adversary to life, turned against us by the evil plant
    entity invading our systems. Its mission is to patrol the corridors of the habitat
    station to prevent the player from eradicating the infestation and getting back
    to Kryk’zylx normalcy (whatever that is).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是指导您完成将这个悬浮对手激活的综合过程，它被邪恶的植物实体入侵我们的系统而对我们产生敌意。它的任务是巡逻栖息地站的走廊，以防止玩家根除感染并恢复Kryk’zylx的正常状态（无论那是什么）。
- en: '![Figure 13.1 – Enemy hover bot on patrol](img/B18347_13_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 巡逻的敌人悬浮机器人](img/B18347_13_01.jpg)'
- en: Figure 13.1 – Enemy hover bot on patrol
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 巡逻的敌人悬浮机器人
- en: Way back in [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151), for our 2D game,
    we solved the problem of enemy NPC navigation by using a simple patrol waypoint
    behavior where the enemy robot moves between two waypoints in 2D space – a left
    and a right.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18347_08.xhtml#_idTextAnchor151)中，为了我们的2D游戏，我们通过使用简单的巡逻航点行为来解决敌人NPC导航问题，其中敌人机器人在2D空间中的两个航点之间移动——一个向左和一个向右。
- en: Well, we’re going to do something similar here. However, because we’re now working
    in 3D space and have a more complex floor plan to navigate, we’ll still set up
    a patrol path using waypoints. Still, we’ll now use Unity’s **AI Navigation**
    package and its **NavMesh** components to accomplish the task of navigating between
    them. NPC navigation is crucial for creating immersive game environments, and
    Unity’s updated 3D NavMesh system, introduced in a Unity 2022.3 release, offers
    an efficient solution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们在这里要做的是类似的事情。然而，因为我们现在在3D空间中工作，并且有一个更复杂的楼层平面需要导航，我们仍然会使用航点设置巡逻路径。不过，我们现在将使用Unity的**AI导航**包及其**NavMesh**组件来完成在它们之间导航的任务。NPC导航对于创建沉浸式游戏环境至关重要，Unity在2022.3版本中引入的更新3D
    NavMesh系统提供了一个高效的解决方案。
- en: Additional reading | Unity documentation
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'Information about the AI Navigation package can be found here: [https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于AI导航包的信息可以在这里找到：[https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/)
- en: Revising and refactoring previously programmed components to save on development
    time is something we’ve discussed a few times already since the inception of the
    3D FPS project, and there will be no exception now. There is no sense starting
    from scratch every time; let’s rely on the assets we already have in our bag of
    tricks and revise where required (ultimately, adding to our bag).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 修订和重构先前编写的组件以节省开发时间是我们自从3D FPS项目开始以来已经讨论过几次的事情，这次也不会例外。每次从头开始都没有意义；让我们依靠我们工具箱中已有的资产，并在需要的地方进行修订（最终，这会丰富我们的工具箱）。
- en: 'We’ll need a bit of a refresher for the basic component structure to understand
    where 3D-related revisions, specifically for NavMesh refactoring, will be required.
    So, here we go. Let’s review the following **Unified Modeling Language** (**UML**)
    diagram representing the behavior responsible for moving the NPC in the 2D project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要复习一下基本组件结构，以便理解在3D相关修订中，特别是对于NavMesh重构，需要在哪里进行。所以，让我们开始吧。让我们回顾以下代表2D项目中NPC移动行为的**统一建模语言**（**UML**）图：
- en: '![Figure 13.2 – 2D patrol waypoints reference UML](img/B18347_13_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 2D巡逻航点参考UML](img/B18347_13_02.jpg)'
- en: Figure 13.2 – 2D patrol waypoints reference UML
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 2D巡逻航点参考UML
- en: Interestingly enough, we’re going to reuse about 96% of what we see in the preceding
    diagram (no, I didn’t do the math; don’t hold me to that percentage). It’s primarily
    the `PatrolWaypoints` class that is in need of revising because it’s the implementation
    of the `IBehaviorPatrolWaypoints` interface that actually moves the enemy NPCs
    between the waypoints. We simply need a behavior implementation for the NavMesh
    instead – because we did the work upfront, following good programming practices,
    to extend functionality without modifying the implementing class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 趣味的是，我们将重用前面图中大约96%的内容（不，我没有做数学计算；不要对我这个百分比太苛刻）。主要需要修订的是`PatrolWaypoints`类，因为它实现了`IBehaviorPatrolWaypoints`接口，实际上是在航点之间移动敌人NPC。我们只需要为NavMesh提供一个行为实现即可——因为我们事先按照良好的编程实践进行了工作，以扩展功能而不修改实现类。
- en: First things first, let’s gather the 2D scripts for reuse.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们收集2D脚本以供重用。
- en: Importing scripts from the 2D project
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从2D项目中导入脚本
- en: We currently require the scripts from the previous 2D adventure game project.
    We’ll need several files this time, unlike the previous time we reused and refactored
    the 2D components for 3D in [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187),
    in the *Refactoring environment interactions to 3D API methods* section, where
    we only needed a few files. So, for the scripts necessary for the 3D FPS project,
    let’s use the Unity package exporter to obtain the scripts along with their dependencies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前需要从之前的2D冒险游戏项目中获取脚本。这一次我们需要几个文件，而不同于我们在[*第10章*](B18347_10.xhtml#_idTextAnchor187)的“将环境交互重构为3D
    API方法”部分中重用和重构2D组件用于3D的情况，那时我们只需要几个文件。因此，对于3D FPS项目所需的脚本，让我们使用Unity包导出器来获取脚本及其依赖项。
- en: Download scripts
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下载脚本
- en: 'Alternatively, download **patrol-behavior-and-dependencies.zip**, with the
    already exported scripts and dependencies required, from the book’s GitHub repo
    here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Script-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Script-Assets).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从本书的GitHub仓库[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Script-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Script-Assets)下载**patrol-behavior-and-dependencies.zip**，其中包含已导出的脚本和所需的依赖项。
- en: For a review of the process, you can revisit [*Chapter 9*](B18347_09.xhtml#_idTextAnchor169),
    where we exported the sliding puzzle game assets. This process certainly isn’t
    one of the most fun parts of developing games, but you’ll find yourself doing
    these types of things from time to time. Let’s get to it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾这个过程，您可以重新访问[*第9章*](B18347_09.xhtml#_idTextAnchor169)，其中我们导出了滑动拼图游戏资源。这个过程当然不是开发游戏中最有趣的部分之一，但您会发现您时不时地会做这些类型的事情。让我们开始吧。
- en: 'Open the previous 2D adventure game project in Unity now and follow these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在Unity中打开之前的2D冒险游戏项目，并按照以下步骤操作：
- en: Go to the `Assets/Scripts/Behaviors` folder in the **Project** window.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中转到`Assets/Scripts/Behaviors`文件夹。
- en: Right-click on the `PatrolWaypoints.cs` file and select **Export Package…**,
    as seen in *Figure* *13**.3* (*A*).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`PatrolWaypoints.cs`文件，并选择**导出包…**，如图*图* *13**.3* (*A*)所示。
- en: The 2D patrolling waypoints behavior is what we want to leverage our reuse of
    for our enemy bot NPC in the 3D FPS game, so we’ll use it as the basis for our
    export and grab its dependencies and other related scripts in the process. Don’t
    worry – in the next step, I’ve already sorted out what scripts we’ll want here
    to save you the time and stress of figuring it out for yourself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 2D巡逻路径行为是我们希望在3D FPS游戏中重用敌对NPC的基础，因此我们将以此为基础进行导出，并在过程中获取其依赖项和其他相关脚本。不用担心——在下一步中，我已经整理好了我们需要的脚本，以节省您自己找出这些脚本的时间和压力。
- en: 'Ensure you’ve selected the following files in the `Assets/Scripts/`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`Assets/Scripts/`目录下已选择以下文件：
- en: '`Bullet.cs`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bullet.cs`'
- en: '`Enemy.cs`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enemy.cs`'
- en: '`EnemyController.cs`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnemyController.cs`'
- en: '`PlayerShootingPooled.cs`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerShootingPooled.cs`'
- en: '`ProjectileBase.cs`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProjectileBase.cs`'
- en: '`ProjectileDamage.cs`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProjectileDamage.cs`'
- en: '`WeaponRanged.cs`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeaponRanged.cs`'
- en: '`Assets/Scripts/Behaviors/`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assets/Scripts/Behaviors/`:'
- en: '`PatrolWaypoints.cs`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PatrolWaypoints.cs`'
- en: '`Assets/Scripts/Data/`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assets/Scripts/Data/`:'
- en: '`EnemyConfigData.cs`'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnemyConfigData.cs`'
- en: '`Assets/Scripts/ExtensionMethods/`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assets/Scripts/ExtensionMethods/`:'
- en: '`LayerMaskExtensions.cs`'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LayerMaskExtensions.cs`'
- en: '`Assets/Scripts/Interfaces/`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assets/Scripts/Interfaces/`:'
- en: '`IBehaviorAttack.cs`'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IBehaviorAttack.cs`'
- en: '`IBehaviorPatrolWaypoints.cs`'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IBehaviorPatrolWaypoints.cs`'
- en: '`IWeapon.cs`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IWeapon.cs`:'
- en: '`IWeaponLaser.cs`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IWeaponLaser.cs`'
- en: '`Assets/Scripts/Systems/`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assets/Scripts/Systems/`:'
- en: '`EventSystem Example/`:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventSystem Example/`:'
- en: '`ExampleListener.cs`'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExampleListener.cs`'
- en: '`ExampleTrigger.cs`'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExampleTrigger.cs`'
- en: '`EventSystem.cs`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventSystem.cs`'
- en: You can see from the list of dependencies selected that we’ll be using some
    of these later to fast-track the implementation of projectile shooting and events.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从选定的依赖项列表中看到，我们将使用其中一些来快速实现弹射射击和事件。
- en: Once you have the files selected, click the **Export…** button and save the
    exported package file (with any name you choose) to a location where we can easily
    find it to import into our current 3D FPS project.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了文件，点击**导出…**按钮，并将导出的包文件（您可以选择任何名称）保存到我们可以轻松找到的位置，以便导入到当前的3D FPS项目中。
- en: Now, open the 3D FPS project, if not already, so we can import the files.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果尚未打开，请打开3D FPS项目，以便我们可以导入文件。
- en: As shown in *Figure 13**.3* (*B*), we’ll be presented with the **Import Unity
    Package** dialog when we drag and drop the exported package from your system’s
    file manager to the 3D FPS game’s **Project** window.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图13**.3* (*B*)所示，当我们从系统文件管理器中将导出的包拖放到3D FPS游戏的**项目**窗口时，会弹出**导入Unity包**对话框。
- en: Click **Import**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**导入**。
- en: '![Figure 13.3 – 2D project export and 3D project import](img/B18347_13_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 2D项目导出和3D项目导入](img/B18347_13_03.jpg)'
- en: Figure 13.3 – 2D project export and 3D project import
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 2D项目导出和3D项目导入
- en: 'You’ll likely notice after the import finishes that we immediately have a console
    error:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 导入完成后，您可能会立即注意到控制台错误：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll first – quickly and easily – fix this compiler error while the remainder
    of the changes will be focused on the refactoring of the 2D to 3D functionality.
    So, to fix the error, we simply need to change `Collider2D` to `Collider` in the
    `ProjectileDamage` class’s `DoDamage()` method signature to properly implement
    the `IDamage` interface as defined in this 3D project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先——快速且容易地——修复这个编译器错误，而其余的更改将集中在2D到3D功能的重构上。所以，为了修复错误，我们只需要将`Collider2D`在`ProjectileDamage`类的`DoDamage()`方法签名中更改为`Collider`，以正确实现在此3D项目中定义的`IDamage`接口。
- en: 'Open `Assets/Scripts/ProjectileDamage.cs` in your IDE and change both the `UnityEvent`
    declaration and the `DoDamage()` method signature to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IDE中打开`Assets/Scripts/ProjectileDamage.cs`，并将`UnityEvent`声明和`DoDamage()`方法签名更改为以下内容：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Simple.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 简单。
- en: Moving on with the remaining refactoring will require an additional step to
    ensure we can reference the required 3D navigation types. This simply means we
    must first add the **AI Navigation** package to our project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行剩余的重构需要额外一步来确保我们可以引用所需的3D导航类型。这仅仅意味着我们必须首先将**AI导航**包添加到我们的项目中。
- en: Open `nav` in the search box to filter the available packages and select **AI
    Navigation** from the list view. Finish by clicking the **Install** button.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索框中输入`nav`以过滤可用的包，并从列表视图中选择**AI导航**。完成时，点击**安装**按钮。
- en: '![Figure 13.4 – Installing the AI Navigation package](img/B18347_13_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 安装AI导航包](img/B18347_13_04.jpg)'
- en: Figure 13.4 – Installing the AI Navigation package
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 安装AI导航包
- en: Okay, now we’re ready to move on updating our code reuse to use the NavMesh
    components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以继续更新我们的代码重用，以使用NavMesh组件。
- en: Refactoring the PatrolWaypoints class for NavMesh
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为NavMesh重构PatrolWaypoints类
- en: Unity’s NavMesh system greatly simplifies setting up complex 3D waypoint navigation
    where NPCs can move more naturally and interact in believable ways, which contributes
    to enhancing the game’s immersion for our players. The modular, adaptable code
    design (i.e., SOLID principles and composition) we adhere to also makes switching
    between 2D and 3D and adding or swapping components easy. That’s why we’ll be
    able to quickly make only a few updates to our existing 2D components to have
    the 3D FPS game up and running with patrolling enemy bot NPCs!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的NavMesh系统极大地简化了设置复杂的3D航点导航，其中NPC可以更自然地移动并以可信的方式进行交互，这有助于增强玩家对游戏的沉浸感。我们坚持的模块化、可适应的代码设计（即SOLID原则和组合）也使得在2D和3D之间切换以及添加或交换组件变得容易。这就是为什么我们能够快速地对现有的2D组件进行少量更新，从而使3D第一人称射击游戏能够运行起来，并配备巡逻的敌方机器人NPC！
- en: Primarily, as indicated earlier in the UML diagram, the most significant revision
    will be with the patrol waypoints behavior class. We’ll actually end up replacing
    most of it, so open the newly imported `Assets/Scripts/Behaviors/PatrolWaypoints`
    script in your IDE now so we can get started. And the first thing we’ll start
    with – beginning at the top of the script and working our way down – is the waypoint
    variables.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的，如之前在UML图中所示，最重要的修改将是巡逻航点行为类。实际上，我们将替换掉大部分内容，所以现在在你的IDE中打开新导入的`Assets/Scripts/Behaviors/PatrolWaypoints`脚本，这样我们就可以开始了。我们首先开始的工作——从脚本顶部开始，向下工作——是航点变量。
- en: Updating the waypoint variables
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新航点变量
- en: 'We’re simply going to replace the old transform `WaypointPatrolLeft` and `WaypointPatrolRight`
    variable declarations with the following single list of waypoint transforms declaration
    – serialized with the `[SerializeField]` attribute so they’re assignable in the
    Inspector:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地用以下单个航点变换声明替换旧的`WaypointPatrolLeft`和`WaypointPatrolRight`变量声明——使用`[SerializeField]`属性序列化，以便在检查器中可分配：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Okay, off to a good start; we’ll now be able to add any number of waypoints
    to the `_waypoints` list for the enemy bot NPC to navigate. We’ll tackle the remaining
    variables next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经有一个良好的开始；现在我们将能够为敌方机器人NPC导航添加任意数量的航点到`_waypoints`列表中。接下来，我们将处理剩余的变量。
- en: 'We’ll replace the movement-related private member variables with only the following
    two – `_waypointCurrentIndex` and `_navMeshAgent` – to hold the reference to `NavMeshAgent`
    and to keep track of the current waypoint the agent will head towards from the
    list of transforms we add to the preceding `_waypoints` list. Remove the 2D private
    member variables now and replace them with the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下两个私有成员变量替换与移动相关的私有成员变量 – `_waypointCurrentIndex` 和 `_navMeshAgent` – 以保持对
    `NavMeshAgent` 的引用，并跟踪代理将从我们添加到前面 `_waypoints` 列表中的变换列表中前往的当前航点。现在移除这两个 2D 私有成员变量，并用以下内容替换：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since the `_navMeshAgent` variable will hold the reference to `NavMeshAgent`
    that’s used to move our enemy NPC – its accessor is private and not serialized,
    we’ll have to ensure it’s assigned by using the Unity `Awake()` lifecycle message
    event. Do that now by adding the following method to the `PatrolWaypoints` class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `_navMeshAgent` 变量将持有用于移动我们的敌人 NPC 的 `NavMeshAgent` 的引用（其访问器是私有的且未序列化），我们必须确保它通过使用
    Unity 的 `Awake()` 生命周期消息事件来分配。现在通过向 `PatrolWaypoints` 类添加以下方法来完成此操作：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ll be adding the `NavMeshAgent` component to our enemy patrol bot when we
    set up its Prefab in the *Configuring the enemy NavMesh Agent (Prefab)* section.
    So, if we forget to add the component, `GetComponent()` will return a `null` assignment
    to the `_navMeshAgent` variable, and that just won’t do! To make ourselves aware
    of this potential forgetfulness, we’ll use a `Debug.Assert()` statement – if the
    condition is not met, an error message will be logged to the Unity console.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 *配置敌人 NavMesh Agent (Prefab)* 部分设置其 Prefab 时，我们将添加 `NavMeshAgent` 组件到我们的敌人巡逻机器人。所以，如果我们忘记添加组件，`GetComponent()`
    将返回一个 `null` 分配给 `_navMeshAgent` 变量，这绝对不行！为了让我们意识到这种潜在的疏忽，我们将使用 `Debug.Assert()`
    语句——如果条件不满足，错误信息将被记录到 Unity 控制台。
- en: Additional reading | Unity documentation
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'Information about **Debug.Assert** can be found here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Debug.Assert.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Debug.Assert.xhtml).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **Debug.Assert** 的信息可以在以下位置找到：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Debug.Assert.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Debug.Assert.xhtml)。
- en: That takes care of the variables! We can now move down to our first method to
    update, which involves getting things set up for the new patrolling behavior.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理好了变量！现在我们可以继续到我们的第一个更新方法，这个方法涉及到为新巡逻行为设置好一切。
- en: Initializing the patrolling behavior
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化巡逻行为
- en: Now, let’s look at the `Init()` method. First, we’ll change the method signature,
    specifically the parameters, because we no longer need the values for the rigid
    body nor the direction, as `NavMeshAgent` will now take care of these. We’re just
    going to leave the `acceleration` and `speed` parameters since they still apply.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Init()` 方法。首先，我们将更改方法签名，特别是参数，因为我们不再需要刚体值或方向，因为 `NavMeshAgent` 将现在负责这些。我们只是保留
    `acceleration` 和 `speed` 参数，因为它们仍然适用。
- en: 'Modify the `Init()` method signature to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Init()` 方法签名修改为以下内容：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the contents of the `Init()` method, we’re going to remove all the previous
    movement code and replace it with the following – for working with `NavMeshAgent`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Init()` 方法的具体内容，我们将移除所有之前的移动代码，并用以下内容替换——用于处理 `NavMeshAgent`：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A quick breakdown of the code looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的快速概述如下：
- en: '`_navMeshAgent.acceleration`: We assign the acceleration that will be passed
    in from our enemy configuration data to determine how quickly the agent will reach
    its maximum speed.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_navMeshAgent.acceleration`: 我们将敌人配置数据中传入的加速度赋值，以确定代理达到最大速度的快慢。'
- en: '`_navMeshAgent.speed`: We assign the speed passed in from our enemy configuration
    data to set the maximum speed the agent will travel along its path to the current
    waypoint.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_navMeshAgent.speed`: 我们将敌人配置数据中传入的速度赋值给设置代理在其路径上移动的最大速度。'
- en: '`_waypoints.Count > 0`: A quick insurance check that we indeed have a list
    of waypoints to work with before attempting to get the position of one.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_waypoints.Count > 0`: 在尝试获取一个航点的位置之前，进行一个快速的保险检查，以确保我们确实有一个航点列表可以工作。'
- en: '`_navMeshAgent.SetDestination`: When the behavior is initialized, what waypoint
    will the NavMesh Agent travel to? This one. The index value of `0` addresses the
    first waypoint that was added to the `_waypoints` list.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_navMeshAgent.SetDestination`: 当行为初始化时，NavMesh Agent 将前往哪个航点？就是这一个。索引值 `0`
    指的是添加到 `_waypoints` 列表中的第一个航点。'
- en: '`_waypointCurrentIndex`: Again, specifying the first waypoint in the `_waypoints`
    list by its index value of `0` as the current waypoint the agent will travel to.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_waypointCurrentIndex`：再次指定 `_waypoints` 列表中的第一个航点，通过其索引值 `0` 作为当前航点，代理将前往。'
- en: To quickly summarize what we did here, just as before in the 2D code, the `Init()`
    method is used to initialize the movement parameters for the NavMesh Agent. It
    is specifically designed to initiate navigation between waypoints as part of the
    implemented enemy NPC patrolling behavior.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速总结我们在这里所做的工作，就像在 2D 代码中一样，`Init()` 方法用于初始化 NavMesh Agent 的运动参数。它专门设计用于启动航点之间的导航，作为实现敌对
    NPC 巡逻行为的一部分。
- en: '`NavMeshAgent` parameters can be a vital part of game balancing. They allow
    developers to adjust NPC behavior and game difficulty to match the design – creating
    challenging areas or guiding gameplay experiences. Hint: you’ll be adjusting these
    values later as you playtest the game level.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavMeshAgent` 参数可以是游戏平衡的重要部分。它们允许开发者调整 NPC 行为和游戏难度以匹配设计——创建挑战区域或引导游戏体验。提示：在游戏关卡测试过程中，你将调整这些值。'
- en: With the initialization of the behavior completed, we can move down further
    in the class to revise the required methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成行为初始化后，我们可以进一步向下移动到类中，以修订所需的方法。
- en: Revising the update methods
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修订更新方法
- en: The `UpdateDirection()` method wasn’t technically responsible for moving the
    object in the previous 2D implementation (the `UpdateVelocity()` method was).
    Still, to keep within the same logical naming, I’ve decided to reuse it here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateDirection()` 方法在先前的 2D 实现中并非技术层面上负责移动对象（这个责任由 `UpdateVelocity()` 方法承担）。尽管如此，为了保持逻辑命名的统一性，我决定在这里重用它。'
- en: The previous `UpdateDirection()` code was simply responsible for facing (flipping)
    the patrolling sprite object in the direction of movement – since the 2D game
    is a side-view, we don’t really have a rotation. Well, in a 3D perspective game,
    we certainly do have object rotation to contend with. Thankfully, the `NavMeshAgent`
    component will automatically calculate and apply the object’s rotation while pathfinding
    its way between waypoints.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `UpdateDirection()` 代码仅负责将巡逻精灵对象朝向移动方向（翻转）——由于 2D 游戏是侧视图，我们实际上没有旋转。好吧，在一个
    3D 视角游戏中，我们当然有要处理的物体旋转。幸运的是，`NavMeshAgent` 组件将在路径查找过程中自动计算并应用物体旋转。
- en: Tip
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To have more control over the agent’s rotation, you’ll have to manage it manually.
    Keep in mind that if you choose to, you’ll need to disable the NavMesh Agent’s
    automatic rotation by setting **_navMeshAgent.updateRotation =** **false**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要对代理的旋转有更多控制，你必须手动管理它。记住，如果你选择这样做，你需要通过设置 **_navMeshAgent.updateRotation =**
    **false** 来禁用 NavMesh Agent 的自动旋转。
- en: 'Let’s see what the new `UpdateDirection()` method looks like now. Replace the
    code with the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看新的 `UpdateDirection()` 方法现在是什么样子。用以下代码替换原有代码：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see here, for the `UpdateDirection()` method, we’re now dealing directly
    with `NavMeshAgent`. We’re evaluating the current values for the progression using
    the `pathPending` and `remainingDistance` properties of the agent heading to the
    currently set destination waypoint. Precisely, we’ll execute a call to `MoveToNextWaypoint()`
    to set moving to the next waypoint when the agent’s current remaining distance
    is less than the stopping distance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，对于 `UpdateDirection()` 方法，我们现在直接处理 `NavMeshAgent`。我们正在使用代理当前航向的 `pathPending`
    和 `remainingDistance` 属性来评估进度值。确切地说，我们将执行对 `MoveToNextWaypoint()` 的调用，当代理的当前剩余距离小于停止距离时，设置移动到下一个航点。
- en: Important note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this example, we rely on the **NavMeshAgent** component’s default values
    for its stopping distance, obstacle avoidance, and path-finding values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们依赖于 **NavMeshAgent** 组件的默认值，包括其停止距离、障碍物避让和路径查找值。
- en: 'As you can see, we’ve added a new method to handle setting the next waypoint
    from the list of available waypoints for when the agent arrives at the currently
    assigned waypoint. If you’re following along with the code directly, you can automatically
    use your IDE’s refactoring tools to generate the new `MoveToNextWaypoint()` method.
    Either way, with the new method created, add the following code to it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们添加了一个新方法来处理从可用航点列表中设置下一个航点，当代理到达当前指定的航点时。如果你直接跟随代码，你可以自动使用你的 IDE 的重构工具来生成新的
    `MoveToNextWaypoint()` 方法。无论如何，在创建新方法后，向其中添加以下代码：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Nothing too tricky is happening here; it’s just a simple *null check* and looping
    through the waypoints. Even so, a simple breakdown of these lines looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有发生什么太复杂的事情；它只是一个简单的*空值检查*和遍历航点。即便如此，这些行的简单分解如下：
- en: '`if (_waypoints == null || _waypoints.Count == 0)`: Doing a double-check on
    the available waypoints in the list here, we’re ensuring it’s not `null`, and
    the count for the number of waypoints in the list is not `0` (zero) before continuing
    to execute statements to assign the next waypoint for the agent to travel to.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (_waypoints == null || _waypoints.Count == 0)`: 在这里对列表中可用的航点进行双重检查，我们确保在继续执行为代理分配下一个要前往的航点的语句之前，它不是`null`，并且列表中航点的数量不是`0`（零）。'
- en: '`_(_waypointCurrentIndex + 1) % _waypoints.Count`: The modulus operator (or
    remainder operator) ensures we loop back to the *beginning of the list* index
    when the `_waypointsCurrentIndex` value equals the list count.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_(_waypointCurrentIndex + 1) % _waypoints.Count`: 模数运算符（或余数运算符）确保当`_waypointsCurrentIndex`值等于列表计数时，我们回绕到*列表开头*的索引。'
- en: '`_navMeshAgent.SetDestination`: This is the `NavMeshAgent` method we call to
    tell the agent to start heading toward the passed-in position – the index assigned
    in the preceding line.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_navMeshAgent.SetDestination`: 这是`NavMeshAgent`方法，我们调用它来告诉代理开始向传入的位置移动——即前一行分配的索引。'
- en: Modulus or remainder operator % (C#)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模数或余数运算符 % (C#)
- en: A typical shorthand way of using the modulus operator is to guarantee a seamless
    infinite loop of a list of items by ensuring that the current item index progresses
    linearly through each list item and only wraps around to **0** upon reaching the
    end of the list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模数运算符的典型简写方式是确保通过确保当前项目索引线性地遍历每个列表项，并在达到列表末尾时仅回绕到**0**，以保证列表项的无缝无限循环。
- en: 'Additional reading can be found here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更多阅读资料请见此处：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators)。
- en: In this section, we’ve sorted out the update methods to work with the new NavMesh
    system. Next, we’ll still work with methods, but instead of revising, we’ll remove
    ones that are no longer needed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经整理了更新方法以与新的NavMesh系统一起工作。接下来，我们仍然会使用方法，但不是修订，而是移除不再需要的那些。
- en: Cleaning up unused methods
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理未使用的方法
- en: Still working within the `PatrolWaypoints` class, we have some no longer needed
    methods. Instead of just leaving them in the class, let’s clean them up – by removing
    them – so if we ever need to revisit the class later, we won’t be confused by
    methods with zero references.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`PatrolWaypoints`类中工作，我们有一些不再需要的方法。而不是仅仅将它们留在类中，让我们通过移除它们来清理它们——这样，如果我们以后需要重新访问该类，就不会被零引用的方法所困惑。
- en: 'Remove the following methods from the `PatrolWaypoints` class now:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从`PatrolWaypoints`类中删除以下方法：
- en: '`UpdateVelocity()`: The velocity is now calculated internally by `NavMeshAgent`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateVelocity()`: 速度现在由`NavMeshAgent`内部计算。'
- en: '`SetWaypoints(Transform left, Transform right)`: We won’t be spawning the patrolling
    enemy NPC NavMesh agents in this example. Consider this an opportunity to add
    a patrolling enemy spawner to your game later!'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetWaypoints(Transform left, Transform right)`: 在这个例子中，我们不会生成巡逻的敌人NPC NavMesh代理。请将此视为将来向您的游戏中添加巡逻敌人生成器的机会！'
- en: 'Oh, and give “update `TickPhysics()`“ a quick fix by removing the now invalid
    call to the removed `UpdateVelocity()` method, leaving simply this expression:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哦，并且通过移除现在已无效的`UpdateVelocity()`方法的调用，快速修复“更新`TickPhysics()`”：
- en: '[PRE9]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Methods removed; check! To compare your revisions to the completed `PatrolWaypoints`
    class, you can find it here: [https://github.com/PacktPublishing/Unity-2022-by-Example/blob/main/ch13/Unity-Project/Assets/Scripts/Behaviors/PatrolWaypoints.cs](https://github.com/PacktPublishing/Unity-2022-by-Example/blob/main/ch13/Unity-Project/Assets/Scripts/Behaviors/PatrolWaypoints.cs).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 已删除的方法；检查！要比较您的修订与完成的`PatrolWaypoints`类，您可以在以下位置找到它：[https://github.com/PacktPublishing/Unity-2022-by-Example/blob/main/ch13/Unity-Project/Assets/Scripts/Behaviors/PatrolWaypoints.cs](https://github.com/PacktPublishing/Unity-2022-by-Example/blob/main/ch13/Unity-Project/Assets/Scripts/Behaviors/PatrolWaypoints.cs)。
- en: Updated the behavior interface? Next refactoring item to check!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了行为接口？下一个重构项目检查！
- en: Updating the behavior interface
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新行为接口
- en: This will be another quick section (very quick). The only changes we need to
    make for the `IBehaviorPatrolWaypoints` interface – you’ve probably already noticed
    the errors from saving the previous changes to the `PatrolWaypoints` class – are
    directly related to the implementing class’s changes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个简短的部分（非常简短）。我们需要对`IBehaviorPatrolWaypoints`接口进行的唯一更改——你可能已经注意到了从`PatrolWaypoints`类保存前一个更改时出现的错误——与实现类的更改直接相关。
- en: 'Update the `IBehaviorPatrolWaypoints` code to the following to resolve the
    issues:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将`IBehaviorPatrolWaypoints`代码更新为以下内容以解决问题：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lastly, in addition to the error we just resolved, we have a few additional
    ones to clean up before we can call this process entirely done.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，除了我们刚刚解决的错误之外，我们还有一些额外的错误需要清理，才能完全完成这个过程。
- en: Resolving remaining console errors
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决剩余的控制台错误
- en: For the last bit of housekeeping on the 2D code refactoring, when we changed
    the behavior `PatrolWaypoints.Init()` method’s signature in the `PatrolWaypoints`
    class, we caused an error in the implementing classes. So, we’ll simply remove
    the unnecessary parameter variables to fix it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2D代码重构的最后一点家务事，当我们更改`PatrolWaypoints`类中`PatrolWaypoints.Init()`方法签名时，我们在实现类中引起了错误。因此，我们将简单地删除不必要的参数变量以修复它。
- en: 'Open the `EnemyController.cs` script and update the portion of the `if` block
    body shown to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`EnemyController.cs`脚本并更新以下`if`块主体的部分：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For the `_behaviorPatrol.Init()` call, the only `config` variables we must pass
    now are the acceleration and speed values. Easy-peasy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`_behaviorPatrol.Init()`调用，我们现在必须传递的唯一`config`变量是加速度和速度值。简单易懂。
- en: Completed 2D to 3D refactored code
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的2D到3D重构代码
- en: 'It wasn’t a ton of changes, but it certainly may have seemed that way as we
    stepped through each one at a time and touched multiple scripts. If it left you
    a bit fuzzy on the final state of the code, you can refer to the completed scripts
    in the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然变化并不多，但当我们逐个检查每个更改并触及多个脚本时，可能会给人一种很多变化的感觉。如果你对代码的最终状态感到有些模糊，可以参考GitHub仓库中的完成脚本：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts)。
- en: 'Also, since we’re no longer using a rigid body to move the enemy NPC between
    waypoints, we can remove all references to `Rigidbody2D` in the `EnemyController`
    class, which includes removing the following lines:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们不再使用刚体在航点之间移动敌人NPC，我们可以从`EnemyController`类中删除所有对`Rigidbody2D`的引用，包括删除以下行：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Whew, we are done! We didn’t even break a sweat with all the 2D to 3D refactoring
    we completed in this section, right!? We are nearly there to test out our game’s
    new NavMesh setup for the 3D FPS enemy patrols. Two steps remain, including configuring
    the patrolling enemy Prefab next, and they’re also no sweat for us to complete
    now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，我们完成了！在这个部分中，我们甚至没有在完成所有2D到3D重构时出汗，对吧？我们几乎可以测试游戏的新NavMesh设置，用于3D FPS敌人的巡逻。剩下两个步骤，包括配置巡逻敌人Prefab，这对我们来说也不是什么难事。
- en: Configuring the enemy NavMesh Agent (Prefab)
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置敌人NavMesh代理（Prefab）
- en: 'Setting up a NavMesh Agent for waypoint patrol requires technical and visual
    setup in the Unity Editor, as well as careful consideration of the bot’s behavior
    for optimal player experience – nothing we haven’t done before. But, because there
    are several steps involved in the process, let’s first break it down into high-level
    tasks:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity编辑器中设置用于航点巡逻的NavMesh代理需要技术和视觉设置，以及仔细考虑机器人的行为以获得最佳的玩家体验——这些都是我们以前做过的。但是，由于这个过程涉及多个步骤，让我们首先将其分解为高级任务：
- en: '**Designing the enemy bot**: We’ll select the 3D model to use for the NavMesh
    Agent and create the Prefab asset.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计敌人机器人**：我们将选择用于NavMesh代理的3D模型并创建Prefab资产。'
- en: '**Adding the enemy base type and controller components**: We’ll add the required
    components to give the enemy object properties and state.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加敌人基地类型和控制器组件**：我们将添加所需组件以赋予敌人对象属性和状态。'
- en: '**Configuring the patrolling behavior**: We’ll add the behavior component that
    implements patrolling waypoints.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置巡逻行为**：我们将添加实现巡逻航点的行为组件。'
- en: '**Adjusting NavMesh agent for the environment**: We’ll set the NavMesh Agent
    type and properties for the enemy bot.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调整环境中的NavMesh代理**：我们将设置敌人机器人的NavMesh代理类型和属性。'
- en: '**Testing and tweaking settings**: We’ll playtest and adjust values for the
    desired gameplay.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试和调整设置**：我们将进行游戏测试并调整所需的游戏值。'
- en: Not so bad, only five steps! Here we go; let’s knock out the first step.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错，只有五步！现在，让我们开始，先完成第一步。
- en: Designing the enemy bot
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计敌方机器人
- en: This will be super easy because we’ll leverage more Polypix Studios 3D models
    provided for our game’s use. We have a lovely hovering camera drone (armed with
    some type of weaponry) available in the assets we previously added to the 3D FPS
    project in [*Chapter 11*](B18347_11.xhtml#_idTextAnchor212), which will be perfect
    for a patrolling enemy!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将非常简单，因为我们将利用更多Polypix Studios提供的3D模型，这些模型可用于我们的游戏。我们有一个可爱的悬浮摄像头无人机（装备了一些类型的武器）可用，我们之前将其添加到3D
    FPS项目中，在[*第 11 章*](B18347_11.xhtml#_idTextAnchor212)，这将非常适合巡逻敌人！
- en: '![Figure 13.5 – Patrol hover bot reporting for duty!](img/B18347_13_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 巡逻悬浮机器人报到！](img/B18347_13_05.jpg)'
- en: Figure 13.5 – Patrol hover bot reporting for duty!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 巡逻悬浮机器人报到！
- en: 'Here are the steps we’ll follow to build out the enemy patrol bot. Use *Figure
    13**.6* as an object hierarchy reference while completing the following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循以下步骤来构建敌方巡逻机器人。在完成以下步骤时，请使用*图 13**.6*作为对象层次结构参考：
- en: Create an empty GameObject in the Hierarchy, reset its transform, and rename
    it `Enemy Hover` `Bot A`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个空的游戏对象，重置其变换，并将其重命名为`Enemy Hover Bot A`。
- en: In the `Assets/Polypix 3D Assets/Prefabs` folder, find the `SM_Camera_Drone
    Variant` Prefab and parent it to the new `Enemy Hover Bot A` object – seen in
    *Figure 13**.5*.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Polypix 3D Assets/Prefabs`文件夹中，找到`SM_Camera_Drone Variant`预制件，并将其设置为新的`Enemy
    Hover Bot A`对象的父对象 – 如*图 13**.5*所示。
- en: Remember that it’s always preferred to maintain the graphics as a child of the
    root object to make future changes easily, should you want or need to.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，始终建议将图形作为根对象的子对象，以便在需要时轻松进行更改。
- en: Set the following transform values for the `(0,` `0, 0)`
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下变换值设置为`(0,` `0, 0)`
- en: '`(1.5,` `1.5, 1.5)`'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(1.5,` `1.5, 1.5)`'
- en: Then, for the child `SM_Camera_Drone` object, set its Y-position value to `0.6`
    so that it’s a good height off the ground – this is a hovering patrol bot! We
    change the child mesh object because we want the parent object anchor to maintain
    its current position.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对于子`SM_Camera_Drone`对象，将其Y位置值设置为`0.6`，使其离地面有一定高度 – 这是一个悬浮巡逻机器人！我们更改子网格对象，因为我们希望父对象锚点保持其当前位置。
- en: 'Back to the `Enemy Hover Bot A` root object, add the following components to
    it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`Enemy Hover Bot A`根对象，向其中添加以下组件：
- en: '`Enemy`'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enemy`'
- en: '`EnemyController`'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnemyController`'
- en: '`PatrolWaypoints`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PatrolWaypoints`'
- en: '`NavMeshAgent`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavMeshAgent`'
- en: Additional reading | Unity documentation
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'More information about NavMesh Agent can be found here: [https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshAgent.xhtml](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshAgent.xhtml).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于NavMesh Agent的信息可以在这里找到：[https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshAgent.xhtml](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshAgent.xhtml)。
- en: Now, make a Prefab by dragging `Enemy Hover Bot A` from the Hierarchy to the
    `Assets/Prefabs` folder.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将`Enemy Hover Bot A`从层次结构拖动到`Assets/Prefabs`文件夹来创建一个预制件。
- en: The results of these setup steps can be seen in *Figure 13**.6*. Note that for
    assigning the waypoints to the `PatrolWaypoints` component, we’ll add the waypoints
    to the scene in the *Adding waypoints to the level and* *testing* section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置步骤的结果可以在*图 13**.6*中看到。注意，在将航点分配给`PatrolWaypoints`组件时，我们将在*添加航点到关卡和测试*部分中添加航点。
- en: '![Figure 13.6 – Enemy hover bot setup](img/B18347_13_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 敌方悬浮机器人设置](img/B18347_13_06.jpg)'
- en: Figure 13.6 – Enemy hover bot setup
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 敌方悬浮机器人设置
- en: That was just the first part. The second part of the setup requires the enemy
    configuration data that we’ll assign to the `EnemyController` component’s **Config**
    field, seen as (*A*) in *Figure 13**.6*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是第一步。设置的第二步需要我们分配给`EnemyController`组件的**Config**字段的敌方配置数据，如图 13**.6*中的(*A*)所示。
- en: Configuring the enemy bot properties
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置敌方机器人属性
- en: If you remember, in [*Chapter 7*](B18347_07.xhtml#_idTextAnchor130), we’re using
    a `ScriptableObject` asset to hold varying configurations to have different property
    values (for example, to change the enemy’s difficulty).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在[*第 7 章*](B18347_07.xhtml#_idTextAnchor130)中，我们使用一个`ScriptableObject`资产来保存不同的配置以拥有不同的属性值（例如，更改敌人的难度）。
- en: 'Following these steps, we’ll create a new enemy configuration asset to assign
    right now:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤，我们将创建一个新的敌方配置资产以立即分配：
- en: Create a new `Assets/Data` folder in the **Project** window.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 窗口中创建一个新的 `Assets/Data` 文件夹。
- en: While within the new folder, use the **Create** menu and select **ScriptableObjects**
    | **EnemyConfigData**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹内，使用 **创建** 菜单并选择 **ScriptableObjects** | **EnemyConfigData**。
- en: Rename the newly created file asset `Enemy Bot` `A Config`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的文件资产重命名为 `Enemy Bot` `A Config`。
- en: 'Set the following starting values:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置以下起始值：
- en: '`10`'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`'
- en: '`4`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`'
- en: '`0` (correct, we won’t have the patrol bot idle)'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`（正确，我们不会让巡逻机器人闲置）'
- en: '`Infinity` (yes, **infinity** is a valid float value!)'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Infinity`（是的，**infinity** 是一个有效的浮点值！）'
- en: Finally, assign the `Enemy Bot A Config` asset to the `Enemy Bot A` Prefab’s
    `Enemy` component’s **Config** field and save.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `Enemy Bot A Config` 资产分配给 `Enemy Bot A` 预制件的 `Enemy` 组件的 **Config** 字段并保存。
- en: Bonus activity
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励活动
- en: Add a blob shadow projector to the enemy bot and light probes to the scene in
    the area of the level where the bot will be patrolling. This will maintain the
    high-quality visual fidelity of the game. You can refer to [*Chapter 11*](B18347_11.xhtml#_idTextAnchor212)
    as a reminder of how we implemented these features.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个阴影投射器添加到敌方机器人上，并将光照探针添加到机器人巡逻的关卡区域的场景中。这将保持游戏的高质量视觉保真度。你可以参考 [*第 11 章*](B18347_11.xhtml#_idTextAnchor212)
    作为如何实现这些功能的提醒。
- en: 'And that’s all there is to creating the NavMesh Agent enemy patrol bot Prefab!
    Only two tasks remain to get the bot on patrol: defining the navigation surface
    and setting the waypoints.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了创建 NavMesh 代理敌方巡逻机器人预制件的所有工作！只剩下两个任务需要完成，才能让机器人开始巡逻：定义导航表面和设置航点。
- en: Baking the NavMesh Surface
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 烘焙 NavMesh 表面
- en: Now that our NavMesh Agent enemy bot Prefab is ready and equipped with all the
    necessary components, baking only the desired patrol areas is the next crucial
    step. We accomplish this with a NavMesh Surface component. By selectively defining
    the patrol areas in our game’s level, we can influence our level design for more
    strategic gameplay.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 NavMesh 代理敌方机器人预制件已经准备好并配备了所有必要的组件，下一步是仅烘焙所需的巡逻区域。我们通过 NavMesh Surface
    组件来完成这个任务。通过在游戏关卡中选择性定义巡逻区域，我们可以影响关卡设计，以实现更具有战略性的游戏玩法。
- en: Additional reading | Unity documentation
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity 文档
- en: 'More information about the NavMesh Surface can be found here: [https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshSurface.xhtml](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshSurface.xhtml).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 NavMesh Surface 的信息可以在这里找到：[https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshSurface.xhtml](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshSurface.xhtml)。
- en: Using *Figure 13**.7* as a reference, you can see I’ve decided to have the enemy
    hover bot patrol the main corridors, indicated by the blue surfaces, connecting
    the two major sections of the habitat station. We use layers to accomplish selectively
    baking NavMesh surfaces. Comparatively, we’ve previously utilized layers in a
    physics context to identify and limit interactions – so, layers have different
    purposes in Unity.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以 *图 13**.7* 为参考，你可以看到我决定让敌方悬浮机器人巡逻主要走廊，这些走廊由蓝色表面指示，连接了栖息站的两个主要区域。我们使用层来实现选择性烘焙
    NavMesh 表面。相比之下，我们之前在物理环境中使用层来识别和限制交互，所以，层在 Unity 中的用途不同。
- en: '![Figure 13.7 – NavMesh Surface baked and waypoints added](img/B18347_13_07.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 烘焙后的 NavMesh 表面和添加了航点](img/B18347_13_07.jpg)'
- en: Figure 13.7 – NavMesh Surface baked and waypoints added
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 烘焙后的 NavMesh 表面和添加了航点
- en: We’ll first have to add a new layer to select the specific surfaces for NavMesh
    baking. Using the `Floor` in the first available numbered **User** **Layer** fields.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要添加一个新层来选择特定的表面进行 NavMesh 烘焙。使用第一个可用的编号 **用户** **层** 字段中的 `Floor`。
- en: Next, select the contiguous corridor floor sections in the `Floor` layer by
    selecting it from the Inspector’s `NavMeshSurface` component.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在检查器的 `NavMeshSurface` 组件中选择它，选择 `Floor` 层中的连续走廊地板部分。
- en: Configuring the NavMesh Surface
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 NavMesh Surface
- en: After assigning floor sections to their designated layer, we’re ready to add
    the `NavMeshSurface` component and bake the surfaces – it’s like embedding invisible
    pathways that dictate the agent’s movements. This baking process will empower
    the agents we set up to navigate simple and complex paths with speed and accuracy,
    ensuring seamless AI navigation for our patrolling enemy hover bot!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在将地板部分分配到指定的层后，我们就可以添加 `NavMeshSurface` 组件并烘焙表面了——这就像嵌入无形路径，这些路径决定了代理的运动。这个烘焙过程将赋予我们设置的代理以速度和准确性导航简单和复杂路径的能力，确保我们的巡逻敌方悬浮机器人实现无缝的
    AI 导航！
- en: 'To bake the NavMesh floor surfaces now, follow these steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要现在烘焙NavMesh楼层表面，请按照以下步骤操作：
- en: Add a new empty GameObject to the `NavMesh Surface`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NavMesh Surface`中添加一个新的空游戏对象。
- en: You can place this just under an organizational object in the `"----` `ENVIRONMENT
    ----"`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将它放在组织对象“`----` `ENVIRONMENT ----`”下的任意位置。
- en: Tip
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Set the **EditorOnly** tag on organization-only GameObjects in the **Scene**
    Hierarchy so these objects aren’t included in builds, saving some resources.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在**场景**层次结构中组织对象上的**仅编辑器**标签，以便这些对象不包含在构建中，节省一些资源。
- en: 'Add a `NavMeshSurface` component to the `NavMesh` `Surface` GameObject:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NavMeshSurface`组件添加到`NavMesh` `Surface`游戏对象中：
- en: To ensure that only the floor sections we want the enemy bot to patrol get baked,
    in the **Object Collection** | **Include Layers** dropdown, first select **Nothing**,
    then select **Floor**.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保只有我们希望敌方机器人巡逻的楼层部分被烘焙，在**对象收集** | **包含图层**下拉菜单中，首先选择**无**，然后选择**楼层**。
- en: Click the **Bake** button. The selected floor sections should now show a blue
    mesh that represents the baked navigation surface, as shown in *Figure 13.7*.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**烘焙**按钮。现在选定的楼层部分应该显示一个蓝色网格，代表烘焙的导航表面，如图13.7所示。
- en: And that’s really all there is to setting up the navigation surfaces for our
    NavMesh agents. Make sure to revisit the `NavMeshSurface` component whenever you
    make changes and re-bake. We’ll now make one final adjustment to the navigation
    setup via **Agent Type** before adding waypoints and testing it all out.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是设置我们的NavMesh代理导航表面的全部内容了。确保在每次更改并重新烘焙时都重新访问`NavMeshSurface`组件。在添加航点并测试之前，我们将通过**代理类型**进行最后的调整。
- en: Configuring the agent type
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置代理类型
- en: An additional consideration we’ll make while baking the NavMesh Surface is to
    adjust the agent’s size to ensure its capabilities align with our needs. I’ve
    arbitrarily decided that we don’t want the bot to come too close to the sides
    of the corridor as it finds its way from waypoint to waypoint.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在烘焙NavMesh表面时，我们还将考虑的一个额外因素是调整代理的大小，以确保其能力与我们的需求相匹配。我随意决定我们不希望机器人在从航点找到航点的过程中太靠近走廊的侧面。
- en: 'While referring to *Figure 13**.8*, proceed to create a new navigation agent
    type by following these steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考*图13**.8*的同时，按照以下步骤创建一个新的导航代理类型：
- en: Open the **Navigation** window by going to **Window** | **AI** | **Navigation**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**窗口** | **AI** | **导航**来打开**导航**窗口。
- en: Click the plus (**+**) icon at the bottom-right of the **Agent Types** list
    to add a new type.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**代理类型**列表右下角的加号（**+**）图标以添加新类型。
- en: In the `Bot`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Bot`。
- en: In the `1` to give the bot more of a margin from the walls of the corridors.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`1`以给机器人更多的走廊墙壁边缘的余地。
- en: In the `0.75`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0.75`。
- en: '![Figure 13.8 – Specifying a Bot agent type](img/B18347_13_08.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8 – 指定机器人代理类型](img/B18347_13_08.jpg)'
- en: Figure 13.8 – Specifying a Bot agent type
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 指定机器人代理类型
- en: Tip
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also access the **Navigation** window from the **NavMeshSurface** component
    by selecting **Open Agent Settings…** in the **Agent** **Type** dropdown.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在**代理类型**下拉菜单中选择**打开代理设置…**从**NavMeshSurface**组件访问**导航**窗口。
- en: 'Now that we have a specific bot agent type to use with our navigation mesh
    surface, return to both the following components to set `Bot`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了与我们的导航网格表面一起使用的特定机器人代理类型，返回到以下两个组件以设置`Bot`：
- en: 'The `NavMeshSurface` component: On the `NavMesh Surface` object in the **Scene**
    Hierarchy.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavMeshSurface`组件：在**场景**层次结构中的`NavMesh Surface`对象上。'
- en: 'The `NavMeshAgent` component: On the `Enemy Hover Bot A` Prefab (which can
    be seen as (*B*) in *Figure 13**.6*).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavMeshAgent`组件：在`Enemy Hover Bot A`预设件上（如图13**.6**中的*（B*）所示）。'
- en: Having `NavMeshSurface` and `NavMeshAgent` use the same agent type is a requirement
    of the AI Navigation system – you’ll receive odd *set destination*-related issues
    in the console if they don’t, and baking just won’t work!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavMeshSurface`和`NavMeshAgent`使用相同的代理类型是AI导航系统的要求——如果它们不使用相同的代理类型，您将在控制台中收到奇特的*设置目的地*相关的问题，并且烘焙将无法工作！'
- en: With a different agent type selected, we’ll have to click the **Bake** button
    again to calculate the new navigation mesh surface – make sure you return to re-bake
    as needed when adjustments are made to the **Agent** **Type** values.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择不同的代理类型后，我们将必须再次点击**烘焙**按钮来计算新的导航网格表面——确保在调整**代理类型**值时需要时返回重新烘焙。
- en: We’ve only touched the surface
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了表面
- en: 'Sorry, I couldn’t help the pun! The Unity AI Navigation system is capable of
    a *lot* more than what we’ve touched on here. I encourage you to explore the documentation
    and try implementing additional features into your game to level up the player
    experience even more:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起，我忍不住要打趣一下！Unity AI 导航系统的能力远不止我们在这里提到的。我鼓励您探索文档，并尝试将更多功能集成到您的游戏中，以进一步提升玩家体验：
- en: '[https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/](https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/).'
- en: Now that we have the navigation surface baked, we can finally add waypoints
    to get the bot performing its patrol duties while walking the beat!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经烘焙了导航表面，我们最终可以添加航点，让机器人边走边巡逻！
- en: Adding waypoints to the level and testing
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加航点到关卡并测试
- en: NPC patrolling enhances gameplay by making environments feel alive, increasing
    player immersion and challenge. While having an NPC patrol a set of waypoints
    may not be considered an **emergent behavior** on its own, encounters can still
    appear unpredictable, keeping gameplay exciting and testing the player’s adaptability.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: NPC 巡逻增强了游戏体验，使环境感觉生动，增加了玩家的沉浸感和挑战性。虽然让 NPC 巡逻一组航点本身可能不被视为 **自发的行为**，但遭遇仍然可能显得不可预测，保持游戏乐趣并测试玩家的适应性。
- en: Emergent behavior
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 自发行为
- en: Emergent gameplay refers to complex situations that could arise from the implementation
    of simple game mechanics in both video and tabletop board games.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 自发游戏体验指的是由简单游戏机制在视频和桌面卡牌游戏中实施可能出现的复杂情况。
- en: 'We’ve already configured all the requirements for adding the ability for our
    enemy bot to patrol; we just need to define the specific patrol points now. So,
    follow these steps to add our waypoints to specific locations within the navigation
    mesh surface we made:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了添加敌人机器人巡逻能力的所有要求；现在我们只需要定义具体的巡逻点。因此，按照以下步骤将我们的航点添加到我们制作的导航网格表面内的特定位置：
- en: Add an empty GameObject named `Patrol Waypoints` to the **Scene** Hierarchy
    to parent (group) the waypoint objects under.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **场景** 层次结构中添加一个名为 `Patrol Waypoints` 的空 GameObject，以将航点对象分组。
- en: Don’t forget to reset the transform position to `(0, 0, 0)` after adding the
    object.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加对象后，别忘了将变换位置重置为 `(0, 0, 0)`。
- en: Add three GameObjects, one to each end of the corridors – whose transform position
    represents the actual waypoint location; see *Figure 13**.7* as a location reference.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个 GameObject，每个走廊的末端各一个——其变换位置代表实际的航点位置；参见 *图 13*.7* 作为位置参考。
- en: With a waypoint object selected, use the Inspector to assign an icon for quick
    identification in the **Scene** view – *Figure 13**.7* shows a green label icon
    having been selected.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择航点对象后，使用检查器分配一个图标以便在 **场景** 视图中快速识别——*图 13*.7* 显示了一个选中的绿色标签图标。
- en: Now that we have waypoints in our scene, we can assign them to the `PatrolWaypoints`
    behavior component’s `Enemy Bot A` object in the **Scene** Hierarchy, then lock
    the Inspector. Now, select all three waypoint objects we just made and drag them
    to the **Waypoints** field to add them all at once. If we didn’t lock the Inspector,
    it would have changed when we multi-selected the waypoint objects in the hierarchy,
    preventing the assignment. Alternatively, without locking the Inspector, you can
    drag each waypoint one at a time to assign them (yuck).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在场景中添加了航点，我们可以将它们分配给 **场景** 层次结构中的 `PatrolWaypoints` 行为组件的 `Enemy Bot
    A` 对象，然后锁定检查器。现在，选择我们刚刚创建的所有三个航点对象，并将它们拖到 **航点** 字段中，一次性添加它们。如果我们没有锁定检查器，它会在我们多选层次结构中的航点对象时改变，从而阻止分配。或者，如果没有锁定检查器，您可以一次拖动一个航点来分配它们（真麻烦）。
- en: Obligatory saving reminder
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 强制保存提醒
- en: You’ve been hitting *Ctrl/Cmd* + *S* to save your scene periodically, right?
    Consider this a reminder to do it now. The waypoints assignment to the **Enemy
    Bot A** Prefab is a scene-level save; they won’t be saved with the file-based
    Prefab asset.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您一直在定期按 *Ctrl/Cmd* + *S* 保存您的场景，对吧？现在就把它作为一个提醒去做这件事。航点分配到 **Enemy Bot A** 预制件是场景级别的保存；它们不会与基于文件的预制件资产一起保存。
- en: Test out navigating the waypoints. Enter **Play mode**, switch back to the **Scene**
    view, adjust the view, and watch the bot navigate a path to the waypoints in the
    order they appear in the list of waypoints – make any adjustments to the **Config**
    values for acceleration, speed, or the navigation agent type radius, and so on.
    Repeat playtesting as needed to get the initial enemy bot patrolling in a, well,
    good patrolling fashion.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 测试导航航点。进入**播放模式**，切换回**场景视图**，调整视图，并观察机器人按照航点列表中出现的顺序导航路径——对加速度、速度或导航代理类型半径等**配置**值进行任何调整。根据需要重复进行测试，以使初始敌人机器人以良好的巡逻方式巡逻。
- en: In this section, we learned how to refactor a 2D patrolling waypoint behavior
    to its 3D equivalent counterpart using Unity’s NavMesh system. Next, let’s make
    the enemy bot have the ability to detect – or sense – the player and respond with
    appropriate behavior.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Unity的NavMesh系统将2D巡逻航点行为重构为其3D等效版本。接下来，让我们让敌人机器人具有检测或感知玩家的能力，并做出适当的反应。
- en: Dynamic enemies with sensors and behavior trees
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有传感器和行为树的动态敌人
- en: In video games, sensors can play a crucial role in creating interactive and
    dynamic AI behaviors. They enable NPCs to *perceive* their surroundings, allowing
    them to react to not only the player but also other environmental things in a
    *more realistic* manner. For example, in stealth games such as **Metal Gear Solid**,
    enemies are often equipped with a **field of view** (**FOV**) sensor that detects
    the player when they enter their line of sight. Similarly, games such as **The
    Last of Us** incorporate audio sensors that enable enemies to detect the player
    based on noises they make. These types of sensors add depth to the gameplay by
    having players change the strategy of their movement and actions more carefully.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，传感器在创建交互性和动态AI行为中可以发挥关键作用。它们使NPC能够*感知*周围环境，使他们能够以*更真实*的方式对玩家以及其他环境因素做出反应。例如，在潜行游戏如**合金装备固体**中，敌人通常配备有**视野**（**FOV**）传感器，当玩家进入他们的视线时可以检测到玩家。同样，**最后一人**等游戏结合了音频传感器，使敌人能够根据玩家发出的噪音来检测玩家。这些类型的传感器通过使玩家更仔细地改变移动和行动策略，为游戏增加了深度。
- en: In short, sensors are abilities added to our objects that make them aware of
    their surroundings and other objects – especially true concerning an enemy NPC
    and the player!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，传感器是我们对象中添加的能力，使它们能够感知周围环境和其他对象——特别是对于敌人NPC和玩家来说更是如此！
- en: 'In this section, we’ll look at some code that can be used to implement the
    two types of sensors we just identified: detecting the player based on an FOV
    and the player based on audio – such as the player’s footsteps.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一些代码，这些代码可以用来实现我们刚刚识别出的两种传感器类型：基于FOV检测玩家和基于音频检测玩家——例如玩家的脚步声。
- en: Creating sensory behaviors
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建感官行为
- en: The first sensor code we’ll look at is for detecting the player within an FOV
    of the patrolling enemy NPC. We’ll make this an event-based class that does not
    inherit from `MonoBehaviour`. That way, we can use it directly in the implementing
    class, `EnemyController`, by simply creating a new instance. It will be very straightforward.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个传感器代码是用于检测巡逻的敌人NPC视野内的玩家。我们将使其成为一个基于事件类的类，不继承自`MonoBehaviour`。这样，我们就可以通过简单地创建一个新实例，直接在实现类`EnemyController`中使用它。这将非常直接。
- en: 'First, look at the code template for our sensor classes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看我们的传感器类的代码模板：
- en: '[PRE13]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s break it down:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解：
- en: '`class SensorTemplate`: Note that we’re not a derived class, and there is no
    inheritance from `MonoBehaviour` since we won’t be using this class as a component
    in the Inspector. We’ll create an instance of the sensor class in the implementing
    class using the `new` keyword (remember, too, that we can’t use `new` with `MonoBehaviour`).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class SensorTemplate`：请注意，我们不是一个派生类，并且由于我们不会将此类用作Inspector中的组件，因此没有从`MonoBehaviour`继承。我们将在实现类中使用`new`关键字创建传感器类的实例（记住，我们也不能用`new`与`MonoBehaviour`一起使用）。'
- en: '`MonoBehaviour _context`: Speaking of `MonoBehaviour`… we may still need access
    to it for running a coroutine or getting the `Transform` values or GameObject
    of the implementing class. We’ll use the class constructor to assign this variable.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonoBehaviour _context`：说到`MonoBehaviour`……我们可能仍然需要访问它来运行协程或获取实现类的`Transform`值或GameObject。我们将使用类构造函数来分配此变量。'
- en: Constructor (C#)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数（C#）
- en: 'Every time an instance of a class or struct is created, its constructor is
    called. More information can be found here: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个类或结构的实例时，都会调用其构造函数。更多信息可以在这里找到：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors)。
- en: '`event UnityAction OnSensorDetected`: I mentioned the sensor class will be
    event-based, so here it is. This is the event, `UnityAction`, that we’ll invoke
    when the sensor detects, well, what we design it to detect. The `event` keyword
    enforces that only the declaring class can invoke it.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event UnityAction OnSensorDetected`: 我提到传感器类将是基于事件的，所以这就是它。这是当传感器检测到我们设计它去检测的东西时我们将调用的`UnityAction`事件。`event`关键字强制只有声明类可以调用它。'
- en: '`SensorTemplate(MonoBehaviour context)`: We have our class’s constructor here.
    The method that shares the same name as the class is the constructor. We’ve added
    a parameter to set the `_context` member variable when creating the class instance.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SensorTemplate(MonoBehaviour context)`: 这里是我们的类的构造函数。与类名相同的方法是构造函数。我们在创建类实例时添加了一个参数来设置`_context`成员变量。'
- en: '`void Tick()`: This is where the magic happens. Typically, `Tick()` will be
    called from the implementing class’s `Update()` method to perform the detection
    work required for each sensor’s purpose. We’ll invoke the `OnSensorDetected` event
    only when the detection occurs.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Tick()`: 这里是魔法发生的地方。通常，`Tick()`将从实现类的`Update()`方法中调用，以执行每个传感器所需进行的检测工作。我们仅在检测发生时调用`OnSensorDetected`事件。'
- en: 'Now, before continuing onto the two sensor examples I’ve provided, let’s see
    how the sensor class is used in the implementing class. We’ll use `EnemyController`
    for this example, where we previously just used a simple member method, `IsPlayerInRange()`.
    You can see how we can instead use a sensor class as a way to construct an NPC’s
    abilities in the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在继续查看我提供的两个传感器示例之前，让我们看看传感器类在实现类中的使用方式。我们将使用`EnemyController`作为这个例子，其中我们之前只是使用了一个简单的成员方法，`IsPlayerInRange()`。你可以看到我们如何使用传感器类作为构建NPC能力的一种方式，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is another quick breakdown of the implementation:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对实现的一个快速概述：
- en: '`private SensorTemplate _sensor`: This variable will hold the instance of the
    sensor class we create to refer to throughout its implementation in this class.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private SensorTemplate _sensor`: 这个变量将持有我们创建的传感器类的实例，以便在整个类的实现中引用。'
- en: '`_sensor = new SensorTemplate(this)`: Using the `new` keyword, we create a
    new instance of the sensor class for its use, passing in the `this` keyword, which
    represents the `EnemyController` class (derived from the `MonoBehaviour` base
    class).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_sensor = new SensorTemplate(this)`: 使用`new`关键字，我们创建了一个新的传感器类实例以供使用，传递了`this`关键字，它代表`EnemyController`类（从`MonoBehaviour`基类派生）。'
- en: this (C#)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: this (C#)
- en: 'The **this** keyword refers to the current instance of a class. More information
    can be found here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字指的是类的当前实例。更多信息可以在这里找到：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this)。'
- en: '`_sensor.OnSensorDetected += HandleSensor_Detected`: Adding the handler method
    for listening when the sensor detects something.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_sensor.OnSensorDetected += HandleSensor_Detected`: 添加处理方法以监听传感器检测到某物时的情况。'
- en: In this template example, the `HandleSensor_Detected()` method simply changes
    to a different state where the controller will take action based on the sensor
    detection. Don’t forget that we can also pass parameters to the handler method
    via the event; simply change the event type declaration to something like `UnityAction<float>`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板示例中，`HandleSensor_Detected()`方法简单地改变到另一个状态，控制器将根据传感器的检测采取行动。别忘了我们也可以通过事件将参数传递给处理方法；只需将事件类型声明更改为类似`UnityAction<float>`的形式。
- en: '`void Update()`: We’ll run the `Update()` method every frame in the sensor
    class for it to perform its detecting workload.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Update()`: 我们将在传感器类中每帧运行`Update()`方法，以便执行其检测工作负载。'
- en: That’s all there is to implementing custom class instances for the purpose of
    adding sensing abilities to your NPCs. If you want to further solidify the sensor
    class’s architecture, you could use a base abstract class or an interface. Consider
    this your challenge to refactor the sensor template code with either of these
    patterns in mind!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为NPC添加感知能力而实现自定义类实例的全部内容。如果你想进一步巩固传感器类的架构，你可以使用一个基抽象类或一个接口。把这看作是你使用这些模式之一重构传感器模板代码的挑战！
- en: Abstract class or interface?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类或接口？
- en: An abstract class can provide a starting point with some predefined ways to
    do things, whereas an interface simply states requirements that must be followed.
    Imagine you have a box of crayons with some colors already defined – that’s the
    abstract class. And a coloring book with outlines of pictures where you have to
    stay within the lines – that’s the interface.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以提供一个起点，提供一些预定义的做事方式，而接口只是声明必须遵循的要求。想象一下，你有一个已经定义了一些颜色的蜡笔盒——那就是抽象类。而一本有轮廓图的彩色书，你必须在这个轮廓内涂色——那就是接口。
- en: In the following two subsections, I’ve provided two code examples for sensor
    classes that can be added to any controller class to detect a target within an
    FOV and detect any nearby player’s audio source that is playing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个小节中，我提供了两个传感器类的代码示例，可以将它们添加到任何控制器类中，以检测FOV内的目标以及检测任何附近正在播放的玩家的音频源。
- en: Detecting the player within an FOV sensor
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在FOV传感器内检测玩家
- en: Imagine having a pair of glasses that can assist you in finding your friends
    in a game of hide and seek. These glasses work similarly to the *player within
    the FOV sensor* in a video game, where you have a limited seeing distance and
    area of view and need to look in the correct direction to identify your friends.
    If the player is within the viewing angle and distance while not hidden behind
    anything, the sensor detects them and triggers an alert. By using this type of
    sensor in a video game, NPCs can detect, or sense, the player, similar to how
    the glasses help during the game of hide and seek.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有一副眼镜可以帮助你在捉迷藏游戏中找到你的朋友。这些眼镜在视频游戏中与FOV传感器中的玩家工作方式类似，你有一个有限的视距和视野范围，需要朝正确的方向看以识别你的朋友。如果玩家在视野角度和距离内且没有被遮挡，传感器就会检测到他们并触发警报。在视频游戏中使用这种类型的传感器，NPC可以检测或感知玩家，就像眼镜在捉迷藏游戏中帮助一样。
- en: 'I’ve provided the complete example `SensorTargetInFOV` class in the 3D FPS
    game project code available for download and its initial implementation in the
    `EnemyController` class. The script is located here: `Assets/Scripts/Sensors/SensorTargetInFOV.cs`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在可下载的3D FPS游戏项目代码中提供了完整的`SensorTargetInFOV`类，以及其在`EnemyController`类中的初始实现。脚本位于此处：`Assets/Scripts/Sensors/SensorTargetInFOV.cs`。
- en: Download the complete sensor code
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完整的传感器代码
- en: 'The code for all the example sensors can be found on the GitHub repository
    here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts/Sensors/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts/Sensors/).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例传感器代码可以在GitHub仓库中找到：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts/Sensors/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts/Sensors/)。
- en: 'The class constructor has additional parameters added for specifying the FOV
    angle and the visual range:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数增加了额外的参数，用于指定FOV角度和视觉范围：
- en: '[PRE15]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These additional values are then used for the sensor’s detection calculation
    within its `IsTargetInsideFOV()` method called every frame tick, which does the
    following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的值随后被用于传感器在其每帧调用`IsTargetInsideFOV()`方法时的检测计算，该方法执行以下操作：
- en: Calculates the direction of the specified target object.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算指定目标对象的方位。
- en: The target object is set with a call to `SetTarget()` just before calling `Tick()`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`Tick()`之前，通过调用`SetTarget()`设置目标对象。
- en: If the direction to the target angle is within the specified `fovAngle`, it
    then calculates the distance to the target.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标角度的方向在指定的`fovAngle`内，它就会计算到目标的位置。
- en: If the distance to the target is within `fovRange`, we finally do a physics
    **raycast** to detect the target object as the player.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果到目标的位置距离在`fovRange`内，我们最终会进行一次物理**射线投射**来检测玩家目标对象。
- en: Additional reading | Unity documentation
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: In game development, a *raycast* is a common way of detecting objects. It involves
    projecting an invisible laser beam in a specified direction to report on any objects
    that it intersects with.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，*射线投射*是一种常见的检测对象的方法。它涉及在指定方向上投射一个不可见的激光束，以报告它与任何相交的对象。
- en: 'More information about **Physics.Raycast** can be found here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.xhtml).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于**Physics.Raycast**的信息可以在以下链接找到：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.xhtml)。
- en: If the hit object of the raycast is the player – determined by comparing its
    tag – we invoke the *target* *detected* event.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果射线投射的击中对象是玩家——通过比较其标签确定——我们调用*目标* *检测*事件。
- en: Explore and discover the sensor code and its implementation to further solidify
    your understanding of the different ways in which we can create code architecture.
    We’ll now look at the second sensor example, the hearing sensor.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 探索并发现传感器代码及其实现，以进一步巩固你对我们可以创建代码架构的不同方式的了解。现在，我们将查看第二个传感器示例，即听觉传感器。
- en: Detecting the player’s audio sensor
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测玩家的音频传感器
- en: 'In a video game, a hearing sensor gives your NPCs the ability to identify sounds
    from the surrounding environment with super-sensitive ears. This type of sensor
    can help the NPC locate and identify objects based on the sounds they make, even
    if the object is not visible to the NPC. My favorite example of this is the horrifying
    game **Alien: Isolation**, in which the alien NPC uses a sophisticated hearing
    sensor to not only hear noises made by the player but also recognize their severity
    – sound plays a crucial role in the survival-horror experience.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '在视频游戏中，听觉传感器使你的NPC能够用超敏感的耳朵识别周围环境中的声音。这种类型的传感器可以帮助NPC根据它们发出的声音定位和识别对象，即使对象对NPC不可见。我最喜欢的例子是恐怖游戏**Alien:
    Isolation**，其中外星NPC使用复杂的听觉传感器不仅能够听到玩家发出的噪音，还能识别其严重性——声音在生存恐怖体验中扮演着至关重要的角色。'
- en: 'Using a hearing-type sensor in your game may or may not be so frightening,
    but it will elevate the gameplay experience nonetheless. I’ve provided the complete
    example `SensorHearing` class in the 3D FPS game project code available for download
    and its initial implementation in the `EnemyController` class. The script is located
    here: `Assets/Scripts/Sensors/SensorHearing.cs`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中使用听觉型传感器可能令人恐惧，也可能不会，但它无论如何都会提升游戏体验。我已经在可下载的3D FPS游戏项目代码中提供了完整的`SensorHearing`类示例，以及其在`EnemyController`类中的初始实现。脚本位于此处：`Assets/Scripts/Sensors/SensorHearing.cs`。
- en: 'The class constructor has additional parameters added for specifying the hearing
    range and update frequency (how often to check for audio sources):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数增加了额外的参数，用于指定听觉范围和更新频率（检查音频源的频率）：
- en: '[PRE16]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These additional values are then used for the sensor’s detection calculation
    within its `IsAudioDetected()` method called every frame tick. Additionally, we’re
    using the passed-in `MonoBehaviour` context to start a coroutine: coroutines require
    a `MonoBehaviour` object to run – to periodically update the list of audio sources
    in the scene (not particularly useful for our 3D FPS game but especially relevant
    for multiplayer games where players will drop in and out of gameplay).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的值随后被用于传感器在其每帧调用`IsAudioDetected()`方法中的检测计算。此外，我们使用传入的`MonoBehaviour`上下文来启动一个协程：协程需要`MonoBehaviour`对象来运行——定期更新场景中音频源列表（对于我们的3D
    FPS游戏来说并不特别有用，但对于玩家会进入和退出游戏的多玩家游戏来说尤其相关）。
- en: 'The audio detection method, `IsAudioDetected()`, does the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 音频检测方法`IsAudioDetected()`执行以下操作：
- en: We’ll simply start by iterating through a list of audio sources found in the
    scene.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将简单地通过遍历场景中找到的音频源列表开始。
- en: If an audio source is playing and we can hear the audio source, invoke the *target*
    *detected* event.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有音频源正在播放并且我们能听到音频源，则调用*目标* *检测*事件。
- en: '`CanHearAudioSource()` is used to determine whether the currently playing audio
    source is within `hearingRange`, adjusted for its playing volume.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanHearAudioSource()`用于确定当前播放的音频源是否在`hearingRange`内，并对其播放音量进行调整。'
- en: Player footsteps 3D audio source
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家脚步3D音频源
- en: Note that for our player footsteps audio, we implemented it as a 2D sound using
    the **AudioPlayerSFX** component. For the enemy NPC to sense the player’s footstep
    sounds, with the **SensorHearing** class, we’d need to use the **AudioPlayerSFX3D**
    component instead. Refer to [*Chapter 12*](B18347_12.xhtml#_idTextAnchor232) if
    you’d like to refactor the player footsteps to support audio-sensing behavior.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于我们的玩家脚步声音频，我们使用 **AudioPlayerSFX** 组件实现了二维声音。对于敌人 NPC 感知玩家的脚步声，我们需要使用 **SensorHearing**
    类，此时应使用 **AudioPlayerSFX3D** 组件。如果您想重构玩家脚步声以支持音频感知行为，请参阅 [*第 12 章*](B18347_12.xhtml#_idTextAnchor232)。
- en: Similarly, for this sensor, explore and discover the sensor code and its implementation
    to further solidify your understanding of the different ways in which we can create
    code architecture.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于这个传感器，探索并了解传感器代码及其实现，以进一步巩固您对我们能以何种不同方式创建代码架构的理解。
- en: In this section, we learned what a sensor is in game development terms and how
    to use a class that does not derive from `MonoBehaviour` to implement sensory
    abilities for our NPCs. Next, we’ll see how a behavior tree can help to manage
    the complexity of AI for NPCs.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了在游戏开发术语中什么是传感器，以及如何使用不继承自 `MonoBehaviour` 的类来实现 NPC 的感知能力。接下来，我们将看到行为树如何帮助管理
    NPC 的 AI 复杂性。
- en: Wrangling behaviors with a behavior tree
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用行为树管理行为
- en: A **behavior tree** (**BT**) is a powerful and flexible tool for implementing
    diverse AI-driven NPCs because it enables more complex hierarchical decision-making
    compared to a more traditional **finite state machine** (**FSM**) that would simply
    hold the current state. BTs work really well with predefined sensors, such as
    our *player within FOV sensor* and *hearing player audio* sensors we’ve discussed,
    since these sensors could be integrated into the BT as custom nodes in the graph.
    This sensor integration would allow NPCs to make decisions based on sensory input
    conditions, favorably enhancing enemy NPC behavior for the gameplay.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为树**（**BT**）是实现多种 AI 驱动的 NPC 的强大且灵活的工具，因为它能够实现比传统的 **有限状态机**（**FSM**）更复杂的分层决策，后者只是简单地保持当前状态。BT
    与预定义的传感器配合得非常好，例如我们讨论过的 *玩家视野内传感器* 和 *听到玩家音频* 传感器，因为这些传感器可以作为图中的自定义节点集成到 BT 中。这种传感器集成将允许
    NPC 根据感官输入条件做出决策，从而有利于增强敌对 NPC 的游戏行为。'
- en: Because BTs are graph-based, with sequences, actions, and other nodes, they
    offer a more manageable way to visualize the relationship of the AI behavior being
    implemented. However, BTs are not visual scripting (although some BT frameworks
    do provide functionality that crosses over into what might be considered visual
    scripting). Conditional nodes are what allow the BT-driven NPC to react dynamically
    to the player’s actions, such as changing the NPC’s behavior from patrolling to
    investigating a noise or spotting the player.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 BT 是基于图的，包含序列、动作和其他节点，它们提供了一种更易于管理的可视化方式来展示正在实现的 AI 行为之间的关系。然而，BT 不是可视化脚本（尽管一些
    BT 框架确实提供了跨入可能被视为可视化脚本的功能）。条件节点允许由 BT 驱动的 NPC 动态地响应玩家的动作，例如将 NPC 的行为从巡逻改为调查噪音或发现玩家。
- en: 'Here is a simple example UML diagram of a BT for a patrolling NPC that can
    sense the player’s position within its FOV or hear the player, with the child
    nodes representing the resulting state of the triggered sensors:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的 UML 图，展示了一个巡逻 NPC 的 BT，它可以感知玩家在其视野内或听到玩家，其中子节点代表触发传感器的结果状态：
- en: '![Figure 13.9 – A simple BT graph](img/B18347_13_09.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 一个简单的 BT 图](img/B18347_13_09.jpg)'
- en: Figure 13.9 – A simple BT graph
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 一个简单的 BT 图
- en: As you can see, the hierarchical structure of BTs offers a clear and manageable
    way to design AI behaviors. Tools such as **Behavior Designer**, **Node Canvas**,
    and **Schema** in the Unity Asset Store provide frameworks for creating BTs, mostly
    without the need to write any code. They offer intuitive editors, many pre-built
    nodes, plus their own custom actions and actions specific to the Unity Scripting
    API, too.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，BT 的分层结构提供了设计 AI 行为的清晰且易于管理的方式。Unity Asset Store 中的工具，如 **Behavior Designer**、**Node
    Canvas** 和 **Schema**，提供了创建 BT 的框架，大多数情况下无需编写任何代码。它们提供了直观的编辑器、许多预构建的节点，以及它们自己的自定义动作和针对
    Unity 脚本 API 的特定动作。
- en: BT tools are designed to make it easier for Unity developers to implement complex
    behaviors for their NPCs. They’re also more accessible for integrating custom
    conditional nodes (e.g., sensors), allowing for rapid iteration of configurations
    to attain the desired behaviors.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: BT工具旨在使Unity开发者更容易为他们的NPC实现复杂的行为。它们还更容易集成自定义条件节点（例如，传感器），允许快速迭代配置以获得所需的行为。
- en: Free behavior tree asset | Unity Asset Store
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 免费行为树资产 | Unity资产商店
- en: '**Schema** is described as “*A fast, easy platform to build artificial intelligence
    with Behavior Trees. Create complex and intelligent behaviors for your game without
    writing a single line of code. Behavior trees are used extensively by AAA studios
    to bring lifelike behaviors into* *their AI.*”'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式**被描述为“*一个快速、简单的平台，用于使用行为树构建人工智能。无需编写任何代码，即可为您的游戏创建复杂和智能的行为。AAA工作室广泛使用行为树将逼真的行为引入其人工智能中。*”'
- en: 'Here is its Asset Store link: [https://assetstore.unity.com/packages/tools/behavior-ai/schema-200876](https://assetstore.unity.com/packages/tools/behavior-ai/schema-200876).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的资产商店链接：[https://assetstore.unity.com/packages/tools/behavior-ai/schema-200876](https://assetstore.unity.com/packages/tools/behavior-ai/schema-200876)。
- en: I’ve already gone ahead and added the Schema BT asset to the 3D FPS project
    files in the book’s GitHub repo (link in the *Technical requirements* section)
    for you to explore and experiment with. You can use the Schema graph editor to
    create custom nodes for the sensors we made in the previous *Creating sensory
    behaviors* section and apply them to the enemy hover bot NPC.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提前将Schema行为树资产添加到书中GitHub仓库（*技术要求*部分中的链接）的3D第一人称射击（FPS）项目文件中，供您探索和实验。您可以使用Schema图形编辑器为上一节*创建感官行为*中创建的传感器创建自定义节点，并将它们应用于敌方悬浮机器人NPC。
- en: Unity Muse AI tools – Behavior
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Muse AI工具 – 行为
- en: '**Muse Behavior** is a new Unity built-in graph-based BT tool with an intuitive
    flow graph and action node stories for AI designers. It is currently in pre-release
    but looks to be an up-and-coming full-featured BT solution for AI NPC design –
    including the ability to use text-input generative AI to create node actions rapidly.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**Muse行为**是Unity内置的基于图形的行为树（BT）工具，具有直观的流程图和动作节点故事，适用于AI设计师。它目前处于预发布阶段，但看起来将成为AI
    NPC设计的全功能BT解决方案——包括使用文本输入生成式AI快速创建节点动作的能力。'
- en: 'Here is the link to a Muse Behavior tutorial project: [https://assetstore.unity.com/packages/templates/tutorials/muse-behavior-tutorial-project-269570](https://assetstore.unity.com/packages/templates/tutorials/muse-behavior-tutorial-project-269570).'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Muse行为教程项目的链接：[https://assetstore.unity.com/packages/templates/tutorials/muse-behavior-tutorial-project-269570](https://assetstore.unity.com/packages/templates/tutorials/muse-behavior-tutorial-project-269570)。
- en: As a game developer, you’ll gravitate toward certain technologies over others
    and favor either a code-only approach or adding some visual tools to your skill
    set over time. At the end of the day, remember, it’s about overcoming challenges
    effectively to implement all the features in the scope of your project, and especially
    to finish the game!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏开发者，你可能会倾向于某些技术而远离其他技术，并随着时间的推移，要么只采用代码方法，要么在技能集中添加一些可视化工具。最后，记住，关键在于有效地克服挑战，以实现项目范围内的所有功能，尤其是完成游戏！
- en: In this section, we learned the value of creating sensors for adding detecting
    abilities to our NPCs and using a BT as a visual tool for creating, managing,
    and setting up dynamic AI-driven NPC behaviors. Next, we’ll look at AI-driven
    behavior further by investigating Unity’s ML tools.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了创建传感器以增加NPC的检测能力，以及使用行为树作为可视化工具来创建、管理和设置动态AI驱动的NPC行为的价值。接下来，我们将通过调查Unity的机器学习工具来进一步探讨AI驱动的行为。
- en: Introducing ML with ML-Agents
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ML与ML-Agents
- en: Many parts of developing a video game touch on technologies that could fill
    entire books all on their own, and ML is definitely one of them! Unity has its
    own tooling for ML that is particularly suited for games, and it’s called **ML-Agents**.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 开发视频游戏的许多部分都涉及可能单独填满整本书的技术，机器学习（ML）无疑是其中之一！Unity拥有自己的机器学习工具，特别适合游戏开发，它被称为**ML-Agents**。
- en: ML-Agents is an **AI toolkit** for Unity developers that helps them create advanced
    and complex behaviors in their games and simulations using ML techniques. Unlike
    BTs, which rely on hand-crafted sets of rules, ML-Agents leverages ML to enable
    NPCs to *learn* and adapt their behavior by interacting with their surroundings.
    This is accomplished by training an agent using ML techniques such as **reinforcement
    learning**, **imitation learning**, or other custom methods. The process enables
    trained agent NPCs to determine the best course of action, all on their own, constantly
    changing and surprising you with dynamic and, hopefully, unpredictable gameplay.
    I briefly noted **emergent gameplay** before, and this is it!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ML-Agents 是一个为 Unity 开发者提供的 **AI 工具包**，帮助他们使用机器学习技术在其游戏和模拟中创建高级和复杂的行为。与依赖于手工编写的规则集的
    BT 不同，ML-Agents 利用机器学习使非玩家角色（NPC）能够通过与环境交互来 **学习** 和调整其行为。这是通过使用诸如 **强化学习**、**模仿学习**
    或其他自定义方法等机器学习技术训练智能体来实现的。这个过程使得经过训练的智能体 NPC 能够独立地确定最佳行动方案，不断变化并让你惊喜，希望是难以预测的游戏玩法。我之前简要提到了
    **涌现游戏玩法**，这就是它！
- en: 'Unity ML-Agents applies to various scenarios, from simple games to much more
    complex simulations. Here is a summarized list of what the ML-Agents toolkit offers:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Unity ML-Agents 适用于各种场景，从简单的游戏到更复杂的模拟。以下是 ML-Agents 工具包提供的总结列表：
- en: '**Different training environments**: You can create environments as simple
    or complex as the real world to train agents.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的训练环境**：你可以创建与现实世界一样简单或复杂的环境来训练智能体。'
- en: '**Variety of training algorithms**: Also relatable to the toolkit’s flexibility,
    it supports various cutting-edge ML algorithms customizable for the agent training
    task at hand.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多种训练算法**：这也与工具包的灵活性相关，它支持各种针对当前智能体训练任务可定制的先进机器学习算法。'
- en: '**Unity integration**: ML-Agents is designed to work specifically with Unity,
    which makes it very accessible to Unity game developers.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity 集成**：ML-Agents 设计为专门与 Unity 一起工作，这使得它对 Unity 游戏开发者来说非常易于访问。'
- en: 'Unity also provides a breadth of resources to learn ML-Agents, including the
    **ML-Agents: Hummingbirds** project, a comprehensive example project with approximately
    10 hours of content!'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'Unity 还提供了丰富的资源来学习 ML-Agents，包括 **ML-Agents: Hummingbirds** 项目，这是一个包含大约 10
    小时内容的综合示例项目！'
- en: Additional reading | Unity documentation
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的阅读材料 | Unity 文档
- en: 'More information about ML-Agents can be found here: [https://unity.com/products/machine-learning-agents](https://unity.com/products/machine-learning-agents).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 ML-Agents 的信息可以在这里找到：[https://unity.com/products/machine-learning-agents](https://unity.com/products/machine-learning-agents)。
- en: 'More information about the ML-Agents toolkit can be found here: [https://github.com/Unity-Technologies/ml-agents/tree/latest_release](https://github.com/Unity-Technologies/ml-agents/tree/latest_release).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 ML-Agents 工具包的信息可以在这里找到：[https://github.com/Unity-Technologies/ml-agents/tree/latest_release](https://github.com/Unity-Technologies/ml-agents/tree/latest_release)。
- en: 'More information about ML-Agents: Hummingbirds can be found here: [https://learn.unity.com/course/ml-agents-hummingbirds/?tab=overview](https://learn.unity.com/course/ml-agents-hummingbirds/?tab=overview).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '更多关于 ML-Agents: Hummingbirds 的信息可以在这里找到：[https://learn.unity.com/course/ml-agents-hummingbirds/?tab=overview](https://learn.unity.com/course/ml-agents-hummingbirds/?tab=overview)。'
- en: 'There are three basic steps to how ML-Agents can work for Unity games:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ML-Agents 如何为 Unity 游戏**工作**有三个基本步骤：
- en: '**Integrating**: This step involves integrating the Unity ML-Agents package
    into a Unity project designed for training.'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**集成**：这一步骤涉及将 Unity ML-Agents 包集成到为训练设计的 Unity 项目中。'
- en: '**Training agents**: This step involves connecting the Unity project to train
    the agents to learn the desired behavior.'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**训练智能体**：这一步骤涉及将 Unity 项目连接起来，以训练智能体学习所需的行为。'
- en: '**Embedding**: This final step involves embedding the trained agent model into
    your game project.'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**嵌入**：这一最终步骤涉及将训练好的智能体模型嵌入到你的游戏项目中。'
- en: Let’s keep this simplified, high-level, three-step process in mind and build
    on our previous work with the Unity AI Navigation package. In this way, we can
    use a NavMesh Agent to optimize the efficiency of the ML-Agents agent training
    by having it focus on behavior training and not navigation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住这个简化的、高级的三步流程，并在此基础上构建我们之前使用 Unity AI 导航包的工作。这样，我们可以使用 NavMesh 智能体来优化 ML-Agents
    智能体训练的效率，使其专注于行为训练而不是导航。
- en: Navigating training efficiency with NavMesh
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NavMesh 提高训练效率
- en: When developing a game using ML-Agents, we can use the `NavMeshAgent` component
    to handle the task of agent navigation while leaving the ML-Agents training to
    focus on the higher-level decision-making processes such as patrolling, investigating,
    and attacking the player character.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ML-Agents开发游戏时，我们可以使用 `NavMeshAgent` 组件来处理代理导航的任务，同时将ML-Agents训练集中在更高层次的决策过程，如巡逻、调查和攻击玩家角色。
- en: 'This approach of blending intelligent AI behavior with an established navigation
    setup results in a more streamlined and effective training result. The following
    figure shows a simple training scene with a NavMesh Surface setup:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将智能AI行为与既定的导航设置相结合的方法，导致训练结果更加流畅和有效。以下图显示了具有NavMesh Surface设置的简单训练场景：
- en: '![Figure 13.10 – Example ML-Agents training scene](img/B18347_13_10.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – 示例ML-Agents训练场景](img/B18347_13_10.jpg)'
- en: Figure 13.10 – Example ML-Agents training scene
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 示例ML-Agents训练场景
- en: Having noted this efficiency, let’s see what a general ML-Agents training setup
    looks like next.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到此效率后，让我们看看下一个通用ML-Agents训练设置的样子。
- en: Examining an ML-Agents setup
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查ML-Agents设置
- en: 'Here is a more detailed breakdown of the steps we’d typically see setting up
    ML-Agents training and implementation within Unity:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在Unity中设置ML-Agents训练和实现的典型步骤的更详细分解：
- en: The ML-Agents package and dependencies.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ML-Agents包及其依赖项。
- en: 'The latest installation instructions can be found in the ML-Agents GitHub repo
    at [https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Installation.md](https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Installation.md):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最新安装说明可在ML-Agents GitHub仓库中找到：[https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Installation.md](https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Installation.md)：
- en: 'I recommend installing the latest version using the GitHub URL via the Package
    Manager: git+[https://github.com/Unity-Technologies/ml-agents.git?path=com.unity.ml-agents#release_21](https://github.com/Unity-Technologies/ml-agents.git?path=com.unity.ml-agents#release_21).'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我建议通过GitHub URL使用包管理器安装最新版本：git+[https://github.com/Unity-Technologies/ml-agents.git?path=com.unity.ml-agents#release_21](https://github.com/Unity-Technologies/ml-agents.git?path=com.unity.ml-agents#release_21)。
- en: Dependencies include ML-Agents extensions, `mlagents` Python package, **PyTorch**
    (Windows), **Visual C++ Redistributable**, and **Unity Sentis**.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖项包括ML-Agents扩展、`mlagents` Python包、**PyTorch**（Windows）、**Visual C++ Redistributable**和**Unity
    Sentis**。
- en: 'Unity project setup:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity项目设置：
- en: Create a new Unity project, selecting a **3D** **Core** template.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity项目，选择一个**3D** **Core**模板。
- en: Design the environment with a baked NavMesh Surface and add objects to the scene
    representing the player character and the NPC that should observe the player.
    Refer to *Figure 13**.10* for a simple training scene representation.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用烘焙的NavMesh Surface设计环境，并在场景中添加代表玩家角色和应观察玩家的NPC对象。请参阅*图13.10*以获取简单的训练场景表示。
- en: 'Setting up the agents:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置代理：
- en: Attach both the `NavMeshAgent` and ML-Agents `Agent` components to the NPC object.
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `NavMeshAgent` 和 ML-Agents `Agent` 组件附加到NPC对象上。
- en: Configure the `NavMeshAgent` properties such as speed, angular speed, and acceleration.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `NavMeshAgent` 属性，如速度、角速度和加速度。
- en: 'Implement the agent methods:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现代理方法：
- en: Create a new class that inherits from `Unity.MLAgents.Agent`, named, for example,
    `AgentController`.
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，从 `Unity.MLAgents.Agent` 继承，例如命名为 `AgentController`。
- en: 'Override the `Agent.CollectObservations()` method to inform the agent with
    sensor information concerning the environment or player data:'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `Agent.CollectObservations()` 方法，向代理提供有关环境或玩家数据的传感器信息：
- en: '[PRE17]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Override the `Agent.OnActionReceived()` method to apply NPC actions such as
    setting the destination for the NavMesh Agent or turning to face the player:'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `Agent.OnActionReceived()` 方法以应用NPC动作，例如为NavMesh Agent设置目的地或转向面对玩家：
- en: '[PRE18]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the rewards and training:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义奖励和训练：
- en: 'Define rewards within the `OnActionReceived()` method:'
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnActionReceived()` 方法中定义奖励：
- en: '`SetReward()` method and pass in a positive float value for successfully reaching
    a patrol point or facing the player, for example. Note that this function replaces
    any rewards given to the agent during the current step. You can also use `AddReward()`
    to incrementally change rewards instead of overriding.'
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetReward()` 方法并传入一个正浮点值，例如成功到达巡逻点或面对玩家。请注意，此函数替换了在当前步骤期间给予代理的任何奖励。您也可以使用
    `AddReward()` 来逐步更改奖励而不是覆盖。'
- en: '`SetReward()` method and pass in a negative float value for undesirable behaviors
    such as running into walls or losing sight of the player:'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `SetReward()` 方法并传入一个负浮点值，以传递不希望的行为，例如撞墙或失去对玩家的视线：
- en: '[PRE19]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create a training configuration file (i.e., `trainer_config.yaml`) where the
    specified training algorithm will be defined (e.g., reinforcement learning algorithm)
    along with its configuration.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个训练配置文件（即 `trainer_config.yaml`），在其中定义指定的训练算法（例如，强化学习算法）及其配置。
- en: Configure both a `BehaviorParameters` and `DecisionRequestor` component on the
    player object agent for the observation and decision-making settings.
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家对象代理上配置一个 `BehaviorParameters` 和 `DecisionRequestor` 组件，用于观察和决策设置。
- en: 'Run the training process:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行训练过程：
- en: Using Command Prompt or Terminal, navigate to your Unity project folder, run
    the training command (e.g., `mlagents-learn trainer_config.yaml --run-id=firstNPCPatrol`
    – here, `run-id` is any unique name for the session), and use **TensorBoard**
    to monitor the training process of the agent.
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令提示符或终端导航到您的 Unity 项目文件夹，运行训练命令（例如，`mlagents-learn trainer_config.yaml --run-id=firstNPCPatrol`
    – 这里，`run-id` 是会话的任何唯一名称），并使用 **TensorBoard** 监控代理的训练过程。
- en: 'Integrate the training results:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成训练结果：
- en: After finishing training, the inference model is saved as a `.nn` file. Import
    it into a folder in your Unity project.
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练完成后，推理模型将保存为 `.nn` 文件。将其导入到您的 Unity 项目中的一个文件夹中。
- en: On the agent, assign the model to the `BehaviorParameters` component’s **Model**
    property and set **Behavior Type** to **Inference Only** to test the behavior
    in your scene.
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代理上，将模型分配给 `BehaviorParameters` 组件的 **Model** 属性，并将 **Behavior Type** 设置为 **Inference
    Only** 以在场景中测试行为。
- en: 'Playtest and iterate on the design:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行游戏测试和设计迭代：
- en: In Unity, play the scene and observe the NPC agent’s behavior (for example,
    as it patrols, senses, or detects the player).
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 中播放场景并观察 NPC 代理的行为（例如，在巡逻、感知或检测玩家时）。
- en: Adjust rewards and rerun the training as needed to refine the NPC behavior incrementally.
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要调整奖励并重新运行训练，以逐步细化 NPC 行为。
- en: By following these steps, you can set up a training environment that uses a
    NavMesh Agent for pathfinding. At the same time, ML-Agents is left to train only
    the complex NPC behavior, such as patrolling and player detection in our example.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，您可以设置一个使用 NavMesh Agent 进行路径查找的训练环境。同时，ML-Agents 只负责训练复杂的 NPC 行为，例如在我们的示例中的巡逻和玩家检测。
- en: ML-Agents sample environments
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ML-Agents 样例环境
- en: The **ML-Agents Toolkit** GitHub repository contains a set of example environments
    that demonstrate the various features of the toolkit. These environments can also
    be used as a starting basis for new environments or a predefined setup for testing
    new ML algorithms.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**ML-Agents 工具包**的 GitHub 仓库包含一系列示例环境，这些环境展示了工具包的各种功能。这些环境也可以用作新环境的起始基础或测试新机器学习算法的预定义设置。'
- en: 'Some example learning environments can be found here: [https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Learning-Environment-Examples.md](https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Learning-Environment-Examples.md).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例学习环境可以在以下位置找到：[https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Learning-Environment-Examples.md](https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Learning-Environment-Examples.md)。
- en: If you’re looking to create a truly exceptional gaming experience for your players,
    consider using ML with ML-Agents. It’s a powerful tool that can help you achieve
    remarkable results!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望为玩家创造真正卓越的游戏体验，请考虑使用 ML 和 ML-Agents。这是一个强大的工具，可以帮助您取得显著成果！
- en: Unity Muse | Additional reading
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Muse | 额外阅读
- en: During the course of the Unity 2022 tech stream releases, Unity has released
    new AI tools for developers under the moniker **Unity Muse**. The tools are currently
    offered as a subscription service, starting with a free trial period.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 2022 技术流发布过程中，Unity 在 **Unity Muse** 的名称下为开发者发布了新的 AI 工具。这些工具目前作为订阅服务提供，包括免费试用期。
- en: 'More information about Unity Muse AI tools for developers can be found here:
    [https://unity.com/products/muse](https://unity.com/products/muse).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Unity Muse AI 工具的更多信息，请参阅以下链接：[https://unity.com/products/muse](https://unity.com/products/muse)。
- en: In this section, we explored how Unity’s ML-Agents toolkit can be used to train
    NPCs with ML algorithms. The result is an NPC with adaptable behaviors that go
    beyond what we can pre-script for an AI (for example, with a BT). We further understood
    the required knowledge to use ML-Agents in a Unity project to elevate the player
    experience with adaptive NPC behavior.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用Unity的ML-Agents工具包通过机器学习算法训练NPC。结果是拥有可适应行为的NPC，这些行为超出了我们为AI预先编写的脚本（例如，使用BT）。我们还进一步了解了在Unity项目中使用ML-Agents所需的知识，以通过自适应NPC行为提升玩家体验。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we refactored our game’s enemy NPCs from 2D to 3D environments
    while still using waypoints but also leveraging Unity’s NavMesh system for AI
    navigation. We also improved our NPCs’ behavior complexity by enabling them to
    interact with the player and the environment more realistically by using sensors
    – the effect of which is to challenge players more engagingly.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在保持使用航点的同时，将我们的游戏敌人NPC从2D环境重构到3D环境，并利用Unity的NavMesh系统进行AI导航。我们还通过使NPC能够通过使用传感器更真实地与玩家和环境互动来提高NPC的行为复杂性——这种效果使得玩家在挑战中更加投入。
- en: We continued discussing dynamic enemy behavior by incorporating our sensors
    as conditions within BTs. We completed our advanced AI discussion with an introduction
    to ML by using Unity’s ML-Agents, enabling NPCs that can learn and evolve, allowing
    us to integrate advanced AI-based gameplay into our games for remarkable player
    experiences.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将传感器作为BT中的条件来整合，继续讨论动态敌人行为。我们通过介绍Unity的ML-Agents来结束高级AI讨论，使NPC能够学习和进化，使我们能够将基于高级AI的游戏玩法集成到我们的游戏中，为玩家带来非凡的体验。
- en: In the next chapter, we’ll finish things up with the 3D FPS game by creating
    a classic boss room battle in **mixed reality** (**MR**). Additionally, you will
    learn how to design a challenging boss room and its mechanics quickly by applying
    all the previous lessons learned for developing game systems.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过创建一个经典的混合现实（**MR**）中的**混合现实**老板房间战斗来结束3D FPS游戏。此外，你将学习如何通过应用之前学习到的所有开发游戏系统的课程，快速设计一个具有挑战性的老板房间及其机制。
