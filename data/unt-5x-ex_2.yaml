- en: Chapter 2. Project A – the Collection Game Continued
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 项目A – 收集游戏继续
- en: This chapter continues from the previous one by building a collection game with
    Unity. In this game, the player wanders an environment in first-person mode, searching
    for and collecting all coins in a scene before a global timer expires. If all
    coins are collected before timer expiry, the game is won. However, if the timer
    expires before all coins are collected, the game is lost. The project created
    so far features a complete environment, with a floor, props, and water, and it
    also features a first-person controller along with a basic coin object, which
    looks correct in shape and form but still cannot be collected.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从上一章继续，通过使用Unity构建一个收集游戏。在这个游戏中，玩家以第一人称模式在环境中漫步，在全局计时器耗尽之前寻找并收集场景中的所有硬币。如果所有硬币在计时器耗尽之前被收集，则游戏胜利。然而，如果计时器在所有硬币被收集之前耗尽，则游戏失败。到目前为止创建的项目包括一个完整的环境，有地板、道具和水，还包括一个第一人称控制器和一个基本的硬币对象，形状和形式看起来正确，但仍然不能被收集。
- en: 'This chapter completes the project by creating a coin object to collect and
    adding a timer system to determine whether the total game time has elapsed. In
    essence, this chapter is about defining a system of logic and rules governing
    the game. To achieve this, we''ll need to code in C# and so this chapter requires
    a basic understanding of programming. This book is about Unity and developing
    games with that engine. The basics of programming as a subject is, however, beyond
    the scope of this book. So I''ll assume that you already have a working knowledge
    of coding generally but have simply not coded in Unity before. Overall, this chapter
    will demonstrate the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过创建一个可收集的硬币对象并添加一个计时器系统来确定总游戏时间是否已过时来完成项目。本质上，本章是关于定义一个逻辑和规则系统来管理游戏。为了实现这一点，我们需要用C#进行编码，因此本章需要基本的编程知识。这本书是关于Unity和用该引擎开发游戏的。然而，作为主题的编程基础超出了本书的范围。所以我会假设你已经对编程有了一定的了解，但之前没有在Unity中编码过。总的来说，本章将演示以下主题：
- en: Material creation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质创建
- en: Prefabs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制体
- en: Coding with C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#进行编码
- en: Writing script files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写脚本文件
- en: Using particle systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用粒子系统
- en: Building and compiling games
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和编译游戏
- en: Creating a coin material
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建硬币材质
- en: The previous chapter closed by creating a basic coin object from a non-uniformly
    scaled cylinder primitive. This object was created by selecting **GameObject**
    | **3D Object** | **Cylinder** from the application menu. See *Figure 2.1*. The
    coin object, as a concept, represents a basic or fundamental unit in our game
    logic because the player character should be actively searching the level looking
    for coins to collect before a timer runs out. This means that the coin is more
    than mere *appearance*; its purpose in the game is not simply eye candy, but is
    functional. It makes an immense difference to the game outcome whether the coin
    is collected by the player or not. Therefore, the coin object, as it stands, is
    lacking in two important respects. Firstly, it looks dull and grey—it doesn't
    really stand out and grab the player's attention. Secondly, the coin cannot actually
    be collected yet. Certainly, the player can walk into the coin, but nothing appropriate
    happens in response.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章通过从非均匀缩放的圆柱原形创建一个基本的硬币对象来结束。这个对象是通过从应用程序菜单中选择**GameObject** | **3D Object**
    | **Cylinder**来创建的。见*图2.1*。作为一个概念，硬币对象代表了我们游戏逻辑中的一个基本或基本单位，因为玩家角色应该在计时器耗尽之前积极地在关卡中寻找可以收集的硬币。这意味着硬币不仅仅是*外观*；它在游戏中的目的不仅仅是视觉上的吸引力，而是具有功能性。硬币是否被玩家收集对游戏结果的影响极大。因此，目前的硬币对象在两个方面存在不足。首先，它看起来单调且灰色——它并没有真正突出并吸引玩家的注意力。其次，硬币实际上还不能被收集。当然，玩家可以走进硬币，但没有任何适当的反应发生。
- en: '![Creating a coin material](img/figure_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材质](img/figure_02_01.jpg)'
- en: 'Figure 2.1: The coin object so far'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：到目前为止的硬币对象
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The completed `CollectionGame` project, as discussed in this chapter and the
    next, can be found in the book companion files in the `Chapter02/CollectionGame`
    folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章和下一章所讨论的，完成的`CollectionGame`项目可以在本书配套文件中的`Chapter02/CollectionGame`文件夹中找到。
- en: In this section, we'll focus on improving the coin appearance using a **material**.
    A material defines an algorithm (or instruction set) specifying how the coin should
    be rendered. A material doesn't just say what the coin should look like in terms
    of color; it defines how shiny or smooth a surface is, as opposed to rough and
    diffuse. This is important to recognize and is why a texture and material refer
    to different things. A texture is simply an image file loaded in memory, which
    can be wrapped around a 3D object via its UV mapping. In contrast, a material
    defines how one or more textures can be combined together and applied to an object
    to shape its appearance. To create a new material asset in Unity, right-click
    on an empty area in the **Project** panel, and from the context menu, choose **Create**
    | **Material**. See *Figure 2.2*. You can also choose **Assets** | **Create**
    | **Material** from the application menu.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于使用**材质**来改进硬币的外观。材质定义了一个算法（或指令集），指定了硬币应该如何渲染。材质不仅说明硬币在颜色方面的外观，还定义了表面是光滑还是闪亮的，与粗糙和漫反射相对。这一点很重要，这也是为什么纹理和材质指的是不同的事物。纹理只是一个加载到内存中的图像文件，可以通过其UV映射将其包裹在3D对象上。相比之下，材质定义了如何将一个或多个纹理组合在一起并应用于对象以塑造其外观。要在Unity中创建新的材质资产，请在**项目**面板的空白区域右键单击，然后从上下文菜单中选择**创建**
    | **材质**。参见*图2.2*。您也可以从应用程序菜单中选择**资产** | **创建** | **材质**。
- en: '![Creating a coin material](img/figure_02_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材质](img/figure_02_02.jpg)'
- en: 'Figure 2.2: Creating a material'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：创建材质
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A material is sometimes called a **Shader**. If needed, you can create custom
    materials using a **Shader Language** or you can use a Unity add-on, such as **Shader
    Forge**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一种材料被称为**着色器**。如果需要，您可以使用**着色器语言**创建自定义材料，或者您可以使用Unity插件，例如**Shader Forge**。
- en: 'After creating a new material, assign it an appropriate name from the Project
    panel. As I''m aiming for a gold look, I''ll name the material `mat_GoldCoin`.
    Prefixing the asset name with `mat` helps me know, just from the asset name, that
    it''s a material asset. Simply type a new name in the text edit field to name
    the material. You can also click on the material name twice to edit the name at
    any time later. See *Figure 2.3*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的材质后，从项目面板中为其分配一个合适的名称。由于我目标是金色外观，我将材质命名为`mat_GoldCoin`。在资产名称前加上`mat`前缀有助于我仅从资产名称中知道它是一个材质资产。只需在文本编辑字段中键入新名称即可命名材质。您还可以双击材质名称，在任何时候稍后编辑名称。参见*图2.3*：
- en: '![Creating a coin material](img/figure_02_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材质](img/figure_02_03.jpg)'
- en: 'Figure 2.3: Naming a material asset'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：命名材质资产
- en: 'Next, select the material asset in the **Project** panel, if it''s not already
    selected, and its properties display immediately in the **Object Inspector**.
    There are lots of properties listed! In addition, a material preview displays
    at the bottom of the **Object Inspector**, showing you how the material would
    look, based on its current settings, if it were applied to a 3D object, such as
    a sphere. As you change material settings from the **Inspector**, the preview
    panel updates automatically to reflect your changes, offering instant feedback
    on how the material would look. See the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果尚未选择，请选择**项目**面板中的材质资产，其属性将立即在**对象检查器**中显示。列出了许多属性！此外，材质预览显示在**对象检查器**的底部，根据其当前设置显示材质的外观，如果将其应用于3D对象（如球体），则会显示。您从**检查器**更改材质设置时，预览面板会自动更新以反映您的更改，提供关于材质外观的即时反馈。参见以下截图：
- en: '![Creating a coin material](img/figure_02_04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材质](img/figure_02_04.jpg)'
- en: 'Figure 2.4: Material properties are changed from the Object Inspector'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：从对象检查器更改材质属性
- en: 'Let''s now create a gold material for the coin. When creating any material,
    the first setting to choose is the **Shader** type because this setting affects
    all other parameters available to you. The **Shader** type determines which algorithm
    will be used to shade your object. There are many different choices, but most
    material types can be approximated using either **Standard** or **Standard (Specular
    setup)**. For the gold coin, we can leave the **Shader** as **Standard**. See
    the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为硬币创建一个金色材质。在创建任何材质时，首先要选择的设置是**着色器**类型，因为此设置会影响您可用的所有其他参数。**着色器**类型确定将用于着色对象的算法。有众多不同的选择，但大多数材质类型可以使用**标准**或**标准（镜面设置）**来近似。对于金币，我们可以将**着色器**保留为**标准**。参见以下截图：
- en: '![Creating a coin material](img/figure_02_05.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材质](img/figure_02_05.jpg)'
- en: 'Figure 2.5: Setting the material Shader type'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：设置材质着色器类型
- en: 'Right now, the preview panel displays the material as a dull grey, which is
    far from what we need. To define a gold color, we must specify the **Albedo**.
    To do this, click on the **Albedo** color slot to display a **Color** picker,
    and from the **Color** picker dialog, select a gold color. The material preview
    updates in response to reflect the changes. Refer to the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，预览面板显示的材料为一种暗灰色，这远非我们所需要的。为了定义金色，我们必须指定**阿尔贝托**。为此，点击**阿尔贝托**颜色槽以显示**颜色**选择器，并从**颜色**选择器对话框中选择金色。材料预览会根据变化进行更新。参见图下所示截图：
- en: '![Creating a coin material](img/figure_02_06.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材料](img/figure_02_06.jpg)'
- en: 'Figure 2.6: Selecting a gold color for the Albedo channel'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：为阿尔贝托通道选择金色
- en: 'The coin material is looking better than it did, but it''s still supposed to
    represent a metallic surface, which tends to be shiny and reflective. To add this
    quality to our material, click and drag the **Metallic** slider in the **Object
    Inspector** to the right-hand side, setting its value to `1`. This indicates that
    the material represents a fully metal surface as opposed to a diffuse surface
    such as cloth or hair. Again, the preview panel will update to reflect the change.
    See *Figure 2.7*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币材料看起来比之前好，但它仍然应该代表一个金属表面，这种表面通常是闪亮的且具有反射性的。为了给我们的材料添加这种特性，在**对象检查器**中点击并拖动**金属**滑块到右侧，将其值设置为`1`。这表示该材料代表一个完全金属表面，而不是像布料或头发这样的漫反射表面。同样，预览面板将更新以反映变化。参见*图2.7*：
- en: '![Creating a coin material](img/figure_02_07.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材料](img/figure_02_07.jpg)'
- en: 'Figure 2.7: Creating a metallic material'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：创建金属材质
- en: 'We now have a gold material created, and it''s looking good in the preview
    panel. If needed, you can change the kind of object used for a preview. By default,
    Unity assigns the created material to a sphere, but other primitive objects are
    allowed, including cubes, cylinders, and torus. This helps you preview materials
    under different conditions. You can change objects by clicking on the geometry
    button directly above the preview panel to cycle through them. See *Figure 2.8*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个金色材料，并且在预览面板中看起来不错。如果需要，您可以更改用于预览的对象类型。默认情况下，Unity将创建的材料分配给球体，但允许使用其他原始对象，包括立方体、圆柱体和环面。这有助于您在不同条件下预览材料。您可以通过点击预览面板正上方的几何按钮来更改对象，以循环浏览它们。参见*图2.8*：
- en: '![Creating a coin material](img/figure_02_08.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材料](img/figure_02_08.jpg)'
- en: 'Figure 2.8: Previewing a material on an object'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：在对象上预览材料
- en: 'When your material is ready, you can assign it directly to meshes in your scene
    just by dragging and dropping. Let''s assign the coin material to the coin. Click
    and drag the material from the **Project** panel to the coin object in the scene.
    On dropping the material, the coin will change appearance. See *Figure 2.9*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的材料准备就绪时，您可以直接通过拖放将其分配到场景中的网格上。让我们将硬币材料分配给硬币。将材料从**项目**面板拖放到场景中的硬币对象上。放下材料后，硬币的外观将发生变化。参见*图2.9*：
- en: '![Creating a coin material](img/figure_02_09.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材料](img/figure_02_09.jpg)'
- en: 'Figure 2.9: Assigning the material to the coin'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：将材料分配给硬币
- en: 'You can confirm that material assignment occurred successfully and can even
    identify which material was assigned by selecting the `Coin` object in the **Scene**
    and viewing its **Mesh Renderer** component from the **Object Inspector**. The
    **Mesh Renderer** component is responsible for making sure that a mesh object
    is actually visible in the scene when the camera is looking. The **Mesh Renderer**
    component contains a **Materials** field. This lists all materials currently assigned
    to the object. By clicking on the material name from the **Materials** field,
    Unity automatically selects the material in the **Project** panel, making it quick
    and simple to locate materials. See *Figure 2.10*, The **Mesh Renderer** component
    lists all materials assigned to an object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过选择**场景**中的`Coin`对象并从**对象检查器**中查看其**网格渲染器**组件来确认材料分配是否成功，甚至可以识别出分配了哪种材料。**网格渲染器**组件负责确保当相机正在查看时，网格对象在场景中实际上是可见的。**网格渲染器**组件包含一个**材料**字段。该字段列出了当前分配给对象的全部材料。通过点击**材料**字段中的材料名称，Unity会自动在**项目**面板中选择该材料，这使得查找材料变得快速且简单。参见*图2.10*，**网格渲染器**组件列出了分配给对象的全部材料：
- en: '![Creating a coin material](img/figure_02_10.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬币材料](img/figure_02_10.jpg)'
- en: 'Figure 2.10: The Mesh Renderer component lists all materials assigned to an
    object'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：网格渲染器组件列出了分配给对象的全部材质
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mesh objects may have multiple materials with different materials assigned to
    different faces. For the best in-game performance, use as few unique materials
    on an object as necessary. Make the extra effort to share materials across multiple
    objects, if possible. Doing so can significantly enhance the performance of your
    game. For more information on optimizing rendering performance, see the online
    documentation at [http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html](http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 网格对象可能具有多个材质，不同材质分配给不同的面。为了获得最佳的游戏性能，尽量在对象上使用尽可能少的独特材质。如果可能的话，请努力在多个对象之间共享材质。这样做可以显著提高游戏性能。有关优化渲染性能的更多信息，请参阅在线文档[http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html](http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)。
- en: That's it! You now have a complete and functional gold material for the collectible
    coin. It's looking good. However, we're still not finished with the coin. The
    coin looks right, but it doesn't behave right. Specifically, it doesn't disappear
    when touched, and we don't yet keep track of how many coins the player has collected
    overall. To address this, then, we'll need to script.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在已经拥有了一个完整且功能齐全的金色材质，用于收藏硬币。看起来不错。然而，我们还没有完成硬币的制作。硬币的外观是正确的，但它的行为却不正确。具体来说，当被触摸时，它不会消失，而且我们还没有记录玩家总共收集了多少硬币。因此，我们需要编写脚本。
- en: C# scripting in Unity
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中的C#脚本编写
- en: 'Defining game logic, rules, and behavior often requires scripting. Specifically,
    to transform a static and lifeless scene with objects into an environment that
    does something, a developer needs to code behaviors. It requires someone to define
    how things should act and react under specific conditions. The coin collection
    game is no exception to this. In particular, it requires three main features:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义游戏逻辑、规则和行为通常需要脚本编写。具体来说，要将静态且无生命的场景中的对象转换成具有某种行为的环境，开发者需要编写行为代码。这需要有人定义在特定条件下事物应该如何行动和反应。收集硬币的游戏也不例外。特别是，它需要三个主要功能：
- en: To know when the player collects a coin
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要知道玩家何时收集到硬币
- en: To keep track of how many coins are collected during gameplay
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要跟踪游戏过程中收集了多少硬币
- en: To determine whether a timer has expired
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定计时器是否已过期
- en: 'There''s no default out-of-the-box functionality included with Unity to handle
    this scenario. So we must write some code to achieve it. Unity supports two languages,
    namely, UnityScript (sometimes called JavaScript) and C#. Both are capable and
    useful languages, but this book uses C# because, going forward, support for JavaScript
    will eventually be dropped. Let''s start coding these three features in sequence.
    To create a new script file, right-click on an empty area in the **Project** panel,
    and from the context menu, choose **Create** | **C# Script**. Alternatively, you
    can navigate to **Assets** | **Create** | **C# Script** from the application menu.
    See *Figure 2.11*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Unity没有包含处理此场景的默认功能。因此，我们必须编写一些代码来实现它。Unity支持两种语言，即UnityScript（有时称为JavaScript）和C#。这两种语言都是强大且有用的语言，但本书使用C#，因为从现在开始，对JavaScript的支持最终将被放弃。让我们按顺序开始编写这三个功能。要创建一个新的脚本文件，请在**项目**面板的空白区域右键单击，并在上下文菜单中选择**创建**
    | **C#脚本**。或者，您可以从应用程序菜单导航到**资产** | **创建** | **C#脚本**。参见*图2.11*：
- en: '![C# scripting in Unity](img/figure_02_11.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Unity中的C#脚本编写](img/figure_02_11.jpg)'
- en: 'Figure 2.11: Creating a new C# script'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：创建一个新的C#脚本
- en: 'After the file is created, you''ll need to assign a descriptive name to it.
    I''ll call it `Coin.cs`. In Unity, each script file represents a single, discrete
    class of matching names. Hence, the `Coin.cs` file encodes the `Coin` class. The
    `Coin` class will encapsulate the behavior of a `Coin` object and will, eventually,
    be attached to the `Coin` object in the scene. See *Figure 2.12*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文件创建后，您需要给它赋予一个描述性的名称。我会叫它`Coin.cs`。在Unity中，每个脚本文件代表一个具有匹配名称的单个、离散的类。因此，`Coin.cs`文件编码了`Coin`类。`Coin`类将封装`Coin`对象的行为，并最终被附加到场景中的`Coin`对象上。参见*图2.12*：
- en: '![C# scripting in Unity](img/figure_02_12.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Unity中的C#脚本编写](img/figure_02_12.jpg)'
- en: 'Figure 2.12: Naming a script file'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：命名脚本文件
- en: 'Double-click on the `Coin.cs` file from the **Object Inspector** to open it
    to edit in **MonoDevelop**, a third-party IDE application that ships with Unity.
    This program lets you edit and write code for your games. Once opened in MonoDevelop,
    the source file will appear, as shown in *Code Sample 2.1*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 双击**对象检查器**中的`Coin.cs`文件以打开它，在**MonoDevelop**中进行编辑，这是一个随Unity一起提供的第三方IDE应用程序。此程序允许您编辑和为您的游戏编写代码。一旦在MonoDevelop中打开，源文件将显示出来，如图*代码示例2.1*所示：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载本书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'You can download the code files by following these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册我们的网站。
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的**支持**选项卡上。
- en: Click on **Code Downloads & Errata**.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**代码下载与勘误表**。
- en: Enter the name of the book in the **Search** box.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入书籍名称。
- en: Select the book for which you're looking to download the code files.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您想要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您购买此书的来源。
- en: Click on **Code Download**.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**代码下载**。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载完成后，请确保使用最新版本的以下软件解压缩或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows上的WinRAR / 7-Zip
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac上的Zipeg / iZip / UnRarX
- en: 7-Zip / PeaZip for Linux
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux上的7-Zip / PeaZip
- en: 'By default, all newly created classes derive from `MonoBehavior`, which defines
    a common set of functionality shared by all components. The `Coin` class features
    two autogenerated functions, namely `Start` and `Update`. These functions are
    events invoked automatically by Unity. `Start` is called once as soon as the `GameObject`
    (to which the script is attached) is created in the **Scene**. `Update` is called
    once per frame on the object to which the script is attached. `Start` is useful
    for initialization code and `Update` is useful to create behaviors over time,
    such as motion and change. Now, before moving any further, let''s attach the newly
    created script file to the `Coin` object in the **Scene**. To do this, drag and
    drop the `Coin.cs` script file from the **Project** panel on the `Coin` object.
    When you do this, a new **Coin** component is added to the object. This means
    that the script is instantiated and lives on the object. See *Figure 2.13*, attaching
    a script file to an object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有新创建的类都从`MonoBehavior`派生，它定义了一组所有组件共享的通用功能。`Coin`类有两个自动生成的函数，即`Start`和`Update`。这些函数是由Unity自动调用的事件。`Start`在`GameObject`（脚本附加到的对象）在**场景**中创建时立即调用一次。`Update`在附加脚本的每个对象上每帧调用一次。`Start`对于初始化代码很有用，而`Update`对于创建随时间变化的行为很有用，例如运动和变化。现在，在继续之前，让我们将新创建的脚本文件附加到**场景**中的`Coin`对象。为此，从**项目**面板拖动并放下`Coin.cs`脚本文件到`Coin`对象上。当您这样做时，对象将添加一个新的**Coin**组件。这意味着脚本被实例化并存在于对象上。参见*图2.13*，将脚本文件附加到对象：
- en: '![C# scripting in Unity](img/figure_02_13.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Unity中的C#脚本](img/figure_02_13.jpg)'
- en: 'Figure 2.13: Attaching a script file to an object'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：将脚本文件附加到对象
- en: 'When a script is attached to an object, it exists on the object as a component.
    A script file can normally be added to multiple objects and even to the same object
    multiple times. Each component represents a separate and unique instantiation
    of the class. When a script is attached in this way, Unity automatically invokes
    its events, such as `Start` and `Update`. You can confirm that your script is
    working normally by including a `Debug.Log` statement in the `Start` function.
    This prints a debug message to the **Console** window when the `GameObject` is
    created in the **Scene**. Consider *Code Sample 2.2*, which achieves this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本附加到对象上时，它作为组件存在于对象上。脚本文件通常可以添加到多个对象上，甚至可以添加到同一个对象上多次。每个组件代表类的独立且唯一的实例化。当以这种方式附加脚本时，Unity会自动调用其事件，如`Start`和`Update`。你可以通过在`Start`函数中包含一个`Debug.Log`语句来确认你的脚本是否正常工作。这会在**场景**中创建**GameObject**时将调试消息打印到**控制台**窗口。请考虑*代码示例2.2*，它实现了这一点：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you press play (*Ctrl* + *P*) on the toolbar to run your game with the preceding
    script attached to an object, you will see the message, **Object Created**, printed
    to the **Console** window—once for each instantiation of the class. See *Figure
    2.14*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按工具栏上的播放按钮（*Ctrl* + *P*）运行你的游戏，并将前面的脚本附加到对象上，你将在**控制台**窗口中看到消息，**对象已创建**——每次创建类的实例时都会打印一次。请参见*图2.14*：
- en: '![C# scripting in Unity](img/figure_02_14.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Unity中的C#脚本](img/figure_02_14.jpg)'
- en: 'Figure 2.14: Printing messages to the Console window'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：向控制台窗口打印消息
- en: Good work! We've now created a basic script for the `Coin` class and attached
    it to the coin. Next, let's define its functionality to keep track of coins as
    they are collected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们现在已经为`Coin`类创建了一个基本的脚本并将其附加到硬币上。接下来，让我们定义其功能，以便在收集硬币时跟踪它们。
- en: Counting coins
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数硬币
- en: 'The coin collection game wouldn''t really be much of a game if there were only
    one coin. The central idea is that a level should feature many coins, all of which
    the player should collect before a timer expires. Now, to know whether all coins
    have been collected, we''ll need to know how many coins there are in total in
    the scene. After all, if we don''t know how many coins there are, then we can''t
    know if we''ve collected them all. So, our first task in scripting is to configure
    the `Coin` class so that we can know the total number of coins in the scene at
    any moment easily. Consider *Code Sample 2.3*, which adapts the `Coin` class to
    achieve this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏中只有一个硬币，那么收集硬币的游戏就不会是真正的游戏。核心思想是，一个关卡应该有多个硬币，玩家应该在计时器到期前收集所有硬币。现在，为了知道是否已经收集了所有硬币，我们需要知道场景中总共有多少个硬币。毕竟，如果我们不知道有多少硬币，那么我们就无法知道是否已经收集了所有硬币。因此，我们在脚本编写中的第一个任务是配置`Coin`类，以便我们可以在任何时刻轻松地知道场景中硬币的总数。请考虑*代码示例2.3*，它将`Coin`类适配以实现这一点：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Code Sample 2.3
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例2.3
- en: 'The following points summarize the code sample:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `Coin` class maintains a static member variable, `CoinCount`, which, being
    static, is shared across all instances of the class. This variable keeps count
    of the total number of coins in the scene and each instance has access to it.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Coin`类维护一个静态成员变量`CoinCount`，由于它是静态的，因此跨所有类的实例共享。这个变量统计场景中硬币的总数，每个实例都可以访问它。'
- en: The `Start` function is called once per `Coin` instance when the object is created
    in the **Scene**. For coins that are present when the scene begins, the `Start`
    event is called at scene startup. This function increments the `CoinCount` variable
    by one per instance, thus keeping count of all coins.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象在**场景**中创建时，`Start`函数会针对每个`Coin`实例调用一次。对于场景开始时存在的硬币，`Start`事件在场景启动时被调用。这个函数会将`CoinCount`变量增加一，从而统计所有硬币。
- en: The `OnDestroy` function is called once per instance when the object is destroyed.
    This decrements the `CoinCount` variable, reducing the count for each coin destroyed.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象被销毁时，`OnDestroy`函数会针对每个实例调用一次。这会减少`CoinCount`变量的值，减少每个被销毁的硬币的数量。
- en: Altogether, *Code Sample 2.3* maintains a `CoinCount` variable. In short, this
    variable allows us to always keep track of the total coin count. We can query
    it easily to determine how many coins remain. This is good, but is only the first
    step towards completing the coin collection functionality.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，*代码示例2.3*维护一个`CoinCount`变量。简而言之，这个变量允许我们始终跟踪硬币的总数。我们可以轻松查询它以确定剩余多少硬币。这是好的，但这只是完成收集硬币功能的第一步。
- en: Collecting coins
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集硬币
- en: Previously, we developed a coin counting variable telling us how many coins
    are in the scene. However, regardless of the count, the player still can't collect
    the coins during gameplay. Let's fix this now. To start, we need to think about
    collisions. Thinking carefully, we know that a coin is considered collected whenever
    the player walks into it, that is, a coin is collected when the player and the
    coin intersect or collide.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们开发了一个计数变量，告诉我们场景中有多少硬币。然而，无论计数如何，玩家在游戏过程中仍然无法收集硬币。现在让我们解决这个问题。首先，我们需要考虑碰撞。仔细思考后，我们知道只要玩家走进硬币，硬币就被认为是收集到了，也就是说，当玩家和硬币相交或碰撞时，硬币就被收集了。
- en: 'To determine when a collision happens like that, we must approximate the volume
    of both the player and coin in order to determine when the two volumes overlap
    in space. This is achieved in Unity through colliders. Colliders are special physics
    objects attached to meshes. They tell us when two meshes intersect. The `FPSController`
    object (First-person controller) already has a collider on it, through its **Character
    Controller** component. This approximates the physical body of a generic person.
    This can be confirmed by selecting `FPSController` in the **Scene** and examining
    the green wireframe cage surrounding the main camera. It is capsule-shaped. See
    *Figure 2.15*, the **Character Controller** features a Collider to approximate
    the player body:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定何时发生此类碰撞，我们必须近似玩家和硬币的体积，以确定两个体积在空间中何时重叠。在Unity中，这是通过碰撞器实现的。碰撞器是附加到网格的特殊物理对象。它们告诉我们两个网格何时相交。`FPSController`对象（第一人称控制器）已经通过其**角色控制器**组件附加了一个碰撞器。这近似了一个普通人的物理身体。这可以通过在**场景**中选择`FPSController`并检查围绕主相机的绿色线框笼来确认。它是胶囊形状的。参见*图2.15*，**角色控制器**具有一个碰撞器来近似玩家身体：
- en: '![Collecting coins](img/figure_02_15.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![收集硬币](img/figure_02_15.jpg)'
- en: 'Figure 2.15: The Character Controller features a collider to approximate the
    player body'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：角色控制器具有碰撞器来近似玩家身体
- en: '`FPSController` features a **Character Controller** component attached, which
    is configured by default with **Radius**, **Height**, and **Center** settings,
    defining the physical extents of the character in the scene. See *Figure 2.16*,
    `FPSController` features **Character Controller**. These settings can be left
    unchanged for our game:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`FPSController`组件包含一个**角色控制器**组件，默认配置了**半径**、**高度**和**中心**设置，这些设置定义了场景中角色的物理范围。参见*图2.16*，`FPSController`组件包含**角色控制器**。这些设置可以保持不变，适用于我们的游戏：'
- en: '![Collecting coins](img/figure_02_16.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![收集硬币](img/figure_02_16.jpg)'
- en: 'Figure 2.16: FPSController features a Character Controller'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：FPSController具有角色控制器
- en: 'The `Coin` object, in contrast, features only a **Capsule Collider** component,
    which was added automatically when we created the **Cylinder** primitive earlier
    to resemble a coin. This approximates the coin''s physical volume in the scene
    without adding any additional features specific to characters and motion as found
    in the **Character Controller** component. This is fine, because the coin is a
    **Static** object as opposed to a moving and dynamic object like the `FPSController`.
    See *Figure 2.17*, **Cylinder** primitives feature a **Capsule Collider** component:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Coin`对象仅具有一个**胶囊碰撞器**组件，这是在我们之前创建**圆柱**原语时自动添加的，以模拟硬币。这近似了场景中硬币的物理体积，而不添加任何特定于角色和运动的额外功能，如**角色控制器**组件中找到的。这是可以的，因为硬币是一个**静态**对象，而不是像`FPSController`那样的移动和动态对象。参见*图2.17*，**圆柱**原语具有**胶囊碰撞器**组件：
- en: '![Collecting coins](img/figure_02_17.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![收集硬币](img/figure_02_17.jpg)'
- en: 'Figure 2.17: Cylinder primitives feature a Capsule Collider component'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：圆柱原语具有胶囊碰撞器组件
- en: 'For this project, I''ll stick to using a **Capsule Collider** component for
    the `Coin` object. However, if you want to change the attached collider to a different
    shape instead, such as a box or sphere, you can do this by first removing any
    existing collider components on the coin—click on the cog icon of the component
    in the **Object Inspector** and then select **Remove Component** from the context
    menu. See *Figure 2.18*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我将坚持使用**胶囊碰撞器**组件为`Coin`对象。但是，如果您想将附加的碰撞器更改为不同的形状，例如盒子或球体，您可以通过首先删除硬币上的任何现有碰撞器组件来实现这一点——点击**对象检查器**中组件的齿轮图标，然后在上下文菜单中选择**移除组件**。参见*图2.18*：
- en: '![Collecting coins](img/figure_02_18.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![收集硬币](img/figure_02_18.jpg)'
- en: 'Figure 2.18: Removing a component from an object'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：从物体中移除组件
- en: 'You can then add a new collider component to the selected object by choosing
    **Component** | **Physics** from the application menu and then choosing a suitably
    shaped collider. See *Figure 2.19*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过从应用程序菜单中选择**组件** | **物理**，然后选择一个合适形状的碰撞体，将新的碰撞体组件添加到选定的对象中。参见*图 2.19*：
- en: '![Collecting coins](img/figure_02_19.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![收集金币](img/figure_02_19.jpg)'
- en: 'Figure 2.19: Adding a component to the selected object'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19：向选定的对象添加组件
- en: 'Regardless of the collider type used, there''s a minor problem. If you play
    the game now and try to run through the coin, it''ll block your path. The coin
    acts as a solid, physical object through which `FPSController` cannot pass. However,
    for our purposes, this isn''t how the coin should behave. It''s supposed to be
    a collectible object. The idea is that when we walk through it, the coin is collected
    and disappears. We can fix this easily by selecting the `Coin` object and enabling
    the **Is Trigger** checkbox in the **Capsule Collider** component, in the **Object
    Inspector**. The **Is Trigger** setting appears for almost all collider types.
    It lets us detect collisions and intersections with other colliders while allowing
    them to pass through. See *Figure 2.20*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不论使用哪种碰撞体类型，都存在一个小问题。如果你现在玩游戏并尝试穿过金币，它会阻挡你的路径。金币作为一个固体、物理对象，`FPSController`无法通过。然而，对于我们的目的来说，金币不应该这样表现。它应该是一个可收集的对象。我们的想法是，当我们穿过它时，金币被收集并消失。我们可以通过选择`Coin`对象，并在**对象检查器**中的**胶囊碰撞体**组件中启用**Is
    Trigger**复选框来轻松解决这个问题。**Is Trigger**设置几乎适用于所有碰撞体类型。它允许我们检测与其他碰撞体的碰撞和交点，同时允许它们通过。参见*图
    2.20*：
- en: '![Collecting coins](img/figure_02_20.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![收集金币](img/figure_02_20.jpg)'
- en: 'Figure 2.20: The Is Trigger setting allows objects to pass through colliders'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20：Is Trigger 设置允许对象通过碰撞体
- en: 'If you play the game now, `FPSController` will easily walk through all coin
    objects in the scene. This is a good start. However, the coins don''t actually
    disappear when touched; they still don''t get collected. To achieve this, we''ll
    need to add more script to the `Coin.cs` file. Specifically, we''ll add an `OnTriggerEnter`
    function. This function is called automatically when an object, like the player,
    enters a collider. For now, we''ll add a `Debug.Log` statement to print a debug
    message when the player enters the collider, just for test purposes. See *Code
    Sample 2.4*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，`FPSController`将轻松地穿过场景中的所有金币对象。这是一个好的开始。然而，金币在被触摸时并没有真正消失；它们仍然没有被收集。为了实现这一点，我们需要在`Coin.cs`文件中添加更多的脚本。具体来说，我们将添加一个`OnTriggerEnter`函数。当像玩家这样的对象进入碰撞体时，这个函数会自动被调用。目前，我们将添加一个`Debug.Log`语句，在玩家进入碰撞体时打印一个调试信息，仅用于测试目的。参见*代码示例
    2.4*：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information on the `OnTriggerEnter` function can be found at the online
    Unity documentation here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`OnTriggerEnter`函数的更多信息，可以在以下在线 Unity 文档中找到：
- en: '[http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html)'
- en: 'Test the *Code Sample 2.4* by pressing play on the toolbar. When you run into
    a coin, the `OnTriggerEnter` function will be executed and the message displayed.
    However, the question remains as to what object initiated this function in the
    first place. It''s true that something collided with the coin, but what exactly?
    Was it the player, an enemy, a falling brick, or something else? To check this,
    we''ll use **Tag**. The **Tag** feature lets you mark specific objects in the
    scene with specific tags or labels, allowing these objects to be easily identified
    in code so that we can check quickly that the player, rather than other objects,
    are colliding with the coins. After all, it should only be the player that can
    collect coins. So, firstly, we''ll tag the player object with a tag called **Player**.
    To do this, select the `FPSController` object in the scene and then click on the
    **Tag** drop-down box in the **Object Inspector**. From here, select the **Player**
    tag. This marks `FPSController` as the `Player` object. See *Figure 2.21*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过工具栏上的播放按钮测试*代码示例2.4*。当你遇到代币时，`OnTriggerEnter`函数将被执行并显示消息。然而，问题仍然存在，即最初是什么对象触发了这个函数。确实，有东西与代币发生了碰撞，但具体是什么？是玩家、敌人、下落的砖块，还是其他东西？为了检查这一点，我们将使用**标签**。**标签**功能允许你使用特定的标签或标签标记场景中的特定对象，使得这些对象在代码中容易被识别，以便我们可以快速检查是玩家而不是其他对象与代币发生了碰撞。毕竟，只有玩家才能收集代币。因此，首先，我们将玩家对象标记为名为**Player**的标签。为此，在场景中选择`FPSController`对象，然后点击**对象检查器**中的**标签**下拉框。从这里，选择**Player**标签。这标志着`FPSController`为`Player`对象。参见*图2.21*：
- en: '![Collecting coins](img/figure_02_21.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![收集代币](img/figure_02_21.jpg)'
- en: 'Figure 2.21: Tagging FPSController as Player'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：将FPSController标记为Player
- en: With `FPSController` now tagged as **Player**, we can refine the `Coin.cs` file,
    as shown in *Code Sample 2.5*. This handles coin collection, making the coin disappear
    on touch and decreasing the coin count.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FPSController`现在被标记为**Player**，我们可以细化`Coin.cs`文件，如*代码示例2.5*所示。这处理了代币收集，使得代币在触摸时消失并减少代币计数。
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Code Sample 2.5
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例2.5
- en: 'The following points summarize the code sample:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: '`OnTriggerEnter` is called once automatically by Unity each time `FPSController`
    intersects the `Coin` collider'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity每次`FPSController`与`Coin`碰撞器相交时都会自动调用一次`OnTriggerEnter`。
- en: When `OnTriggerEnter` is called, the `Col` argument contains information about
    the object that entered the collider on this occasion
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`OnTriggerEnter`时，`Col`参数包含有关此次进入碰撞器的对象的信息。
- en: The `CompareTag` function is used to determine if the colliding object is the
    `Player` as opposed to a different object
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CompareTag`函数来确定碰撞的对象是否是`Player`而不是其他对象。
- en: The `Destroy` function is called to destroy the `Coin` object itself, represented
    internally by the inherited member variable, `gameObject`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Destroy`函数是为了销毁`Coin`对象本身，该对象在内部通过继承的成员变量`gameObject`表示。
- en: When the `Destroy` function is called, the `OnDestroy` event is invoked automatically,
    which decrements the `Coin` count
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当调用`Destroy`函数时，会自动触发`OnDestroy`事件，该事件会减少`Coin`的数量。
- en: Excellent work! You've just created your first working coin. The player can
    now run into the coin, collect it, and remove it from the scene. This is a great
    beginning, but the scene should contain more than one coin. We could solve this
    by duplicating the existing coin many times and repositioning each duplicate to
    a different place. However, there's a better way, as we'll see next.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作！你刚刚创建了你第一个工作的代币。现在玩家可以跑向代币，收集它，并将其从场景中移除。这是一个很好的开始，但场景应该包含不止一个代币。我们可以通过多次复制现有的代币并将每个副本重新定位到不同的位置来解决这个问题。然而，还有更好的方法，我们将在下面看到。
- en: Coins and prefabs
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代币和预制体
- en: The basic coin functionality is now created, but the scene needs more than one
    coin. The problem with simply duplicating a coin and scattering the duplicates
    is that if we make a change later to one coin and need to propagate that change
    to all other coins, we'd need to delete the former duplicates and manually replace
    those with newer and amended duplicates. To avoid this tedious repetition, we
    can use prefabs. Prefabs let you convert an object in the scene to `Assets` in
    the **Project** panel. This can be instantiated in the scene as frequently as
    needed, as though it were a mesh asset. The advantage is that changes made to
    the asset are automatically applied to all instances automatically, even across
    multiple scenes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经创建了基本的硬币功能，但场景需要不止一个硬币。简单地复制一个硬币并将副本散布开来存在的问题是，如果我们稍后对其中一个硬币进行更改并需要将此更改传播到所有其他硬币，我们需要删除之前的副本并手动用较新和修正的副本替换它们。为了避免这种繁琐的重复，我们可以使用预制件。预制件允许您将场景中的对象转换为**项目**面板中的`Assets`。这可以在场景中按需实例化，就像它是一个网格资产一样。优点是，对资产所做的更改将自动应用于所有实例，即使在多个场景中也是如此。
- en: 'This makes it easier to work with custom assets, so let''s prefab the coin
    right now. To do this, select the `Coin` object in the scene and then drag and
    drop it in the **Project** panel. When this happens, a new `prefab` is created.
    The object in the scene is automatically updated to be an instance of `prefab`.
    This means that if the asset is deleted from the `Project` panel, the instance
    will become invalidated. See *Figure 2.22*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做使得与自定义资产的工作更加容易，所以现在就预制硬币吧。为此，在场景中选择`Coin`对象，然后将其拖放到**项目**面板中。当这样做时，将创建一个新的`prefab`。场景中的对象将自动更新为`prefab`的实例。这意味着如果从`项目`面板中删除了资产，实例将变得无效。参见*图2.22*：
- en: '![Coins and prefabs](img/figure_02_22.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![硬币和预制件](img/figure_02_22.jpg)'
- en: 'Figure 2.22: Creating a coin prefab'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：创建硬币预制件
- en: 'After `prefab` is created, you can add more instances of the coin easily to
    the level by dragging and dropping `prefab` from the **Project** panel to the
    **Scene**. Each instance is linked to the original `prefab` asset, which means
    that all changes made to the asset will immediately be made to all instances.
    With this in mind, go ahead now and add as many `Coin` prefabs to the level as
    suitable for your coin collection game. Refer to the following figure for my arrangement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`prefab`之后，您可以通过将`prefab`从**项目**面板拖放到**场景**中，轻松地将更多硬币实例添加到关卡中。每个实例都与原始`prefab`资产相关联，这意味着对资产所做的所有更改将立即应用于所有实例。考虑到这一点，现在请继续添加尽可能多的`Coin`预制件到关卡中，以适应您的硬币收集游戏。参考以下图示进行布局：
- en: '![Coins and prefabs](img/figure_02_23.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![硬币和预制件](img/figure_02_23.jpg)'
- en: 'Figure 2.23: Adding coin prefabs to the level'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：将硬币预制件添加到关卡中
- en: 'One question that naturally arises is how you can transform prefab back into
    an independent `GameObject` that is no longer connected to the `prefab` asset.
    This is useful to do if you want some objects to be based on `prefab` but deviate
    from it slightly. To achieve this, select a `prefab` instance in the **Scene**,
    and then navigate to **GameObject** | **Break Prefab Instance** from the application
    menu. See *Figure 2.24*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自然而然出现的问题是，您如何将预制件转换回不再与`prefab`资产连接的独立`GameObject`。如果您希望某些对象基于`prefab`但略有偏差，这样做是有用的。为了实现这一点，在**场景**中选择一个`prefab`实例，然后从应用程序菜单导航到**GameObject**
    | **分解预制件实例**。参见*图2.24*：
- en: '![Coins and prefabs](img/figure_02_24.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![硬币和预制件](img/figure_02_24.jpg)'
- en: 'Figure 2.24: Breaking the prefab instance'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24：分解预制件实例
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you add a `prefab` instance to **Scene** and make changes to it that you
    like and want to distribute upstream back to the `prefab` asset, then select the
    object and choose **GameObject** | **Apply Changes to Prefab**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`prefab`实例添加到**场景**中并对它进行了您喜欢的更改，并希望将这些更改向上游分发回`prefab`资产，那么请选择该对象并选择**GameObject**
    | **应用到预制件**。
- en: Timers and countdowns
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器和倒计时
- en: 'You should now have a level complete with geometry and coin objects. Thanks
    to our newly added `Coin.cs` script, the coins are both countable and collectible.
    Even so, the level still poses little or no challenge to the player because there''s
    no way the level can be won or lost. Specifically, there''s nothing for the player
    to achieve. This is why a time limit is important for the game: it defines a win
    and loss condition. Namely, collecting all coins before the timer expires results
    in a win condition and failing to achieve this results in a loss condition. Let''s
    get started at creating a timer countdown for the level. To do this, create a
    new and empty game object by selecting **GameObject** | **Create Empty** and rename
    this to `LevelTimer`. See *Figure 2.25*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有一个包含几何和硬币对象的游戏关卡。多亏了我们新添加的 `Coin.cs` 脚本，硬币现在既可计数也可收集。即便如此，关卡对玩家来说仍然几乎没有挑战，因为没有赢得或输掉关卡的方法。具体来说，玩家没有要实现的目标。这就是为什么游戏中的时间限制很重要：它定义了胜利和失败条件。也就是说，在计时器到期之前收集所有硬币会导致胜利条件，而未能实现这一点则会导致失败条件。让我们开始为关卡创建计时器倒计时。为此，通过选择
    **GameObject** | **Create Empty** 创建一个新的空游戏对象，并将其重命名为 `LevelTimer`。参见 *图 2.25*：
- en: '![Timers and countdowns](img/figure_02_25.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![计时器和倒计时](img/figure_02_25.jpg)'
- en: 'Figure 2.25: Renaming the timer object'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25：重命名计时器对象
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that empty game objects cannot be seen by the player because they have
    no mesh renderer component. They are especially useful to create functionality
    and behaviors that don't correspond directly to physical and visible entities,
    such as timers, managers, and game logic controllers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，空的游戏对象玩家是看不到的，因为它们没有网格渲染器组件。它们特别有用于创建不直接对应于物理和可见实体的功能和行为，例如计时器、管理器和游戏逻辑控制器。
- en: 'Next, create a new script file named `Timer.cs` and add it to the `LevelTimer`
    object in **Scene**. By doing this, the timer functionality will exist in the
    scene. Make sure, however, that the timer script is added to one object, and no
    more than one. Otherwise, there will effectively be multiple, competing timers
    in the same scene. You can always search a scene to find all components of a specified
    type by using the **Hierarchy** panel. To do this, click in the **Hierarchy**
    search box and type `t:Timer`. Then press *Enter* on the keyboard to confirm the
    search. This searches the scene for all objects with a component attached of the
    timer type, and the results are displayed in the **Hierarchy** panel. Specifically,
    the **Hierarchy** panel is filtered to show only the matching objects. The `t`
    prefix in the search string indicates a search by type operation. See *Figure
    2.26*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `Timer.cs` 的新脚本文件，并将其添加到 **场景** 中的 `LevelTimer` 对象中。通过这样做，计时器功能将存在于场景中。但是，请确保计时器脚本只添加到一个对象中，并且不超过一个。否则，场景中实际上会有多个相互竞争的计时器。您可以通过使用
    **层次结构** 面板来搜索场景以找到指定类型的所有组件。为此，点击 **层次结构** 搜索框并输入 `t:Timer`。然后按键盘上的 *Enter* 键确认搜索。这将搜索场景中所有附加了计时器类型组件的对象，并将结果显示在
    **层次结构** 面板中。具体来说，**层次结构** 面板被过滤以仅显示匹配的对象。搜索字符串中的 `t` 前缀表示按类型进行搜索操作。参见 *图 2.26*：
- en: '![Timers and countdowns](img/figure_02_26.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![计时器和倒计时](img/figure_02_26.jpg)'
- en: 'Figure 2.26: Searching for objects with a component of matching type'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26：搜索具有匹配类型组件的对象
- en: 'You can easily cancel a search and return the **Hierarchy** panel back to its
    original state by clicking on the small cross icon aligned to the right-hand side
    of the search field. This button can be tricky to spot. See *Figure 2.27*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击搜索字段右侧的小交叉图标轻松取消搜索，并将 **层次结构** 面板恢复到原始状态。这个按钮可能很难找到。参见 *图 2.27*：
- en: '![Timers and countdowns](img/figure_02_27.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![计时器和倒计时](img/figure_02_27.jpg)'
- en: 'Figure 2.27: Canceling a type search'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27：取消类型搜索
- en: The timer script itself must be coded if it's to be useful. The full source
    code for the `Timer.cs` file is given in the following *Code Sample 2.6*. This
    source code is highly important if you've never scripted in Unity before. It demonstrates
    so many critical features. See the comments for a fuller explanation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使计时器脚本有用，则必须编写计时器脚本。`Timer.cs` 文件的完整源代码在以下 *代码示例 2.6* 中给出。如果您以前从未在 Unity
    中编写过脚本，这段源代码非常重要。它展示了许多关键特性。请参阅注释以获得更全面的解释。
- en: '[PRE5]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Code Sample 2.6
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 2.6
- en: 'The following points summarize the code sample:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: In Unity, class variables declared as `public` (such as `public float MaxTime`)
    are displayed as editable fields in the **Object Inspector** of the editor. However,
    this applies to a range of supported data types only, but it's a highly useful
    feature. It means that developers can monitor and set `public` variables for classes
    directly from the **Inspector** as opposed to changing and recompiling code every
    time a change is needed. The `private` variables, in contrast, are hidden from
    the **Inspector** by default. However, you can force them to be visible, if needed,
    using the `SerializeField` attribute. The `private` variables prefixed with this
    attribute, such as the `CountDown` variable, will be displayed in the **Object
    Inspector** just like a `public` variable, even though the variable's scope still
    remains `private`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中，声明为`public`（例如`public float MaxTime`）的类变量在编辑器的**对象检查器**中显示为可编辑字段。然而，这仅适用于支持的多种数据类型，但这是一个非常有用的功能。这意味着开发者可以直接从**检查器**中监控和设置类的`public`变量，而不必每次需要更改时都修改和重新编译代码。相比之下，`private`变量默认情况下被隐藏在**检查器**中。但是，如果需要，可以使用`SerializeField`属性强制它们可见。带有此属性的前缀的`private`变量，例如`CountDown`变量，将在**对象检查器**中显示，就像一个`public`变量一样，尽管变量的作用域仍然是`private`。
- en: The `Update` function is a Unity native event supported for all classes derived
    from `MonoBehaviour`. `Update` is invoked automatically once per frame for all
    active `GameObjects` in the scene. This means that all active game objects are
    notified about frame change events. In short, `Update` is therefore called many
    times per second; the game FPS is a general indicator as to how many times each
    second. The actual number of calls will vary in practice from second to second.
    In any case, `Update` is especially useful to animate, update, and change objects
    over time. In the case of a `CountDown` class, it'll be useful to keep track of
    time as it passes, second by second. More information on the `Update` function
    can be found at the online Unity documentation at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`函数是Unity原生事件，支持所有从`MonoBehaviour`派生的类。`Update`函数会自动在每一帧调用一次场景中所有活动的`GameObjects`。这意味着所有活动的游戏对象都会收到帧更改事件的通知。简而言之，`Update`因此每秒被调用多次；游戏FPS是每秒调用次数的一般指标。实际上，每秒的调用次数会因实际情况而有所不同。无论如何，`Update`特别适用于在一段时间内动画化、更新和改变对象。对于`CountDown`类，跟踪时间流逝，每秒更新是有用的。关于`Update`函数的更多信息可以在Unity在线文档中找到，网址为[http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html)。'
- en: Note
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to the `Update` function called on each frame, Unity also supports
    two other related functions, namely, `FixedUpdate` and `LateUpdate`. `FixedUpdate`
    is used when coding with **Physics**, as we'll see later, and is called a fixed
    number of times per frame. `LateUpdate` is called once per frame for each active
    object, but the `LateUpdate` call will always happen after every object has received
    an `Update` event. Thus, it happens after the `Update` cycle, making it a late
    update. There are reasons for this late update and we'll see them later in the
    book.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了每帧调用的`Update`函数之外，Unity还支持两个其他相关函数，即`FixedUpdate`和`LateUpdate`。`FixedUpdate`在编写**物理**代码时使用，我们将在后面看到，并且每帧调用固定次数。`LateUpdate`每帧为每个活动对象调用一次，但`LateUpdate`调用总是在每个对象收到`Update`事件之后发生。因此，它发生在`Update`周期之后，使其成为延迟更新。这种延迟更新的原因将在本书后面的章节中看到。
- en: More information on `FixedUpdate` can be found in the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html).
    More information on the `LateUpdate` function can be found in the online Unity
    documentation at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html).
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于`FixedUpdate`的更多信息可以在Unity在线文档中找到，网址为[http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html)。关于`LateUpdate`函数的更多信息可以在Unity在线文档中找到，网址为[http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html)。
- en: When scripting, the static `Time.deltaTime` variable is constantly available
    and updated automatically by Unity. It always describes the amount of time (in
    seconds) that has passed since the previous frame ended. For example, if your
    game has a frame rate of 2 FPS (a very low frame rate!) then `deltaTime` will
    be `0.5`. This is because, in each second, there would be two frames, and thus
    each frame would be half a second. The `deltaTime` is useful because, if added
    over time, it tells you how much time in total has elapsed or passed since the
    game began. For this reason, `deltaTime` floating point variable is used heavily
    in the `Update` function for the timer to subtract the elapsed time from the countdown
    total. More information can be found on `deltaTime` at the online documentation
    at [http://docs.unity3d.com/ScriptReference/Time-deltaTime.html](http://docs.unity3d.com/ScriptReference/Time-deltaTime.html).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写脚本时，静态的`Time.deltaTime`变量始终可用，并由Unity自动更新。它始终描述了自上一帧结束以来经过的时间（以秒为单位）。例如，如果你的游戏帧率为2
    FPS（一个非常低的帧率！）那么`deltaTime`将是`0.5`。这是因为，在每一秒中，会有两个帧，因此每个帧将是半秒。`deltaTime`很有用，因为，如果随着时间的推移而累加，它就会告诉你自游戏开始以来总共经过了多少时间。因此，`deltaTime`浮点变量在`Update`函数中被大量使用，以便从倒计时总数中减去经过的时间。有关`deltaTime`的更多信息，可以在在线文档中找到，网址为[http://docs.unity3d.com/ScriptReference/Time-deltaTime.html](http://docs.unity3d.com/ScriptReference/Time-deltaTime.html)。
- en: The static `Application.LoadLevel` function can be called anywhere in code to
    change the active scene at runtime. Thus, this function is useful to move the
    gamer from one level to another. It causes Unity to terminate the active scene,
    destroying all its contents, and load a new scene. It can also be used to restart
    the active scene, simply by loading the active level again. `Application.LoadLevel`
    is most appropriate for games with clearly defined levels that are separate from
    each other and have clearly defined beginnings and endings. It is not, however,
    suitable for large open-world games in which large sprawling environments stretch
    on, seemingly without any breakage or disconnection. More information on `Application.LoadLevel`
    can be found in the online Unity documentation at [http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html](http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态的`Application.LoadLevel`函数可以在代码的任何地方调用，以在运行时更改活动场景。因此，这个函数对于将玩家从一个关卡移动到另一个关卡非常有用。它会导致Unity终止活动场景，销毁其所有内容，并加载一个新的场景。它也可以通过重新加载活动关卡来重新启动活动场景。`Application.LoadLevel`对于具有明确定义且彼此分离的关卡，并且有明确开始和结束的游戏最为合适。然而，它并不适合大型开放世界游戏，在这些游戏中，广阔的环境似乎没有中断或断开。有关`Application.LoadLevel`的更多信息，可以在Unity在线文档中找到，网址为[http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html](http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html)。
- en: After the timer script is created, select the `LevelTimer` object in the scene.
    From the **Object Inspector**, you can set the maximum time (in seconds) that
    the player is allowed in order to complete the level. See *Figure 2.28*. I've
    set the total time to `60` seconds. This means that all coins must be completed
    within `60` seconds from the level start. If the timer expires, the level is restarted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建计时器脚本后，选择场景中的`LevelTimer`对象。从**对象检查器**中，你可以设置玩家完成关卡允许的最大时间（以秒为单位）。参见*图2.28*。我已经将总时间设置为`60`秒。这意味着所有金币必须在关卡开始后的`60`秒内完成。如果计时器到期，关卡将重新启动。
- en: '![Code Sample 2.6](img/figure_02_28.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例2.6](img/figure_02_28.jpg)'
- en: 'Figure 2.28: Setting the level total time'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28：设置关卡总时间
- en: Great work! You should now have a completed level with a countdown that works.
    You can collect coins and the timer can expire. Overall, the game is taking shape.
    There is a further problem, however, which we'll address next.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的工作！你现在应该有一个带有工作倒计时的完成关卡。你可以收集金币，计时器可以到期。总的来说，游戏正在成形。然而，还有一个进一步的问题，我们将在下一部分解决。
- en: Celebrations and fireworks!
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 庆祝和烟花！
- en: The coin collection game is nearly finished. Coins can be collected and a timer
    expires, but the win condition itself is not truly handled. That is, when all
    coins are collected before time expiry, nothing actually happens to show the player
    that they've won. The countdown still proceeds and even restarts the level as
    though the win condition hadn't been satisfied at all. Let's fix this now. Specifically,
    when the win scenario happens, we should delete the timer object to prevent further
    countdown and show visual feedback to signify that the level has been completed.
    In this case, I'll add some fireworks! So, let's start by creating the fireworks.
    You can add these easily from the Unity 5 **Particle System** packages. Navigate
    to the `Standard Assets` | `ParticleSystems` | `Prefabs` folder. Then, drag and
    drop the `Fireworks` particle system in **Scene**. Add a second or even a third
    one if you want.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币收集游戏几乎完成了。可以收集硬币，计时器到期，但胜利条件本身并没有真正处理。也就是说，在时间到期前收集到所有硬币时，实际上并没有发生任何事情来向玩家显示他们已经获胜。倒计时仍在继续，甚至重新开始关卡，好像根本未满足胜利条件。现在让我们解决这个问题。具体来说，当发生胜利场景时，我们应该删除计时器对象以防止进一步的倒计时并显示视觉反馈以表明关卡已完成。在这种情况下，我将添加一些烟花！所以，让我们先创建烟花。您可以从
    Unity 5 的 **粒子系统** 包中轻松添加这些。导航到 `Standard Assets` | `ParticleSystems` | `Prefabs`
    文件夹。然后，将 `Fireworks` 粒子系统拖放到 **场景** 中。如果您想要的话，还可以添加第二个或第三个。
- en: '![Celebrations and fireworks!](img/figure_02_29.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![庆祝和烟花！](img/figure_02_29.jpg)'
- en: 'Figure 2.29: Adding two Fireworks prefabs'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29：添加两个烟花预制体
- en: 'By default, all firework particle systems will play when the level begins.
    You can test this by pressing play on the toolbar. This is not the behavior that
    we want. We only want the fireworks to play when the win condition has been satisfied.
    To disable playback on level startup, select the **Particle System** object in
    the **Scene** and, from the **Object Inspector**, disable the **Play On Awake**
    checkbox, which can be found in the **Particle System** component. See *Figure
    2.30*, Disabling **Play On Awake**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有烟花粒子系统将在关卡开始时播放。您可以通过在工具栏上按播放来测试这一点。这不是我们想要的行为。我们只想在满足胜利条件时播放烟花。要禁用在关卡启动时的播放，请在
    **场景** 中选择 **粒子系统** 对象，并在 **对象检查器** 中禁用 **播放唤醒** 复选框，该复选框位于 **粒子系统** 组件中。参见 *图
    2.30*，禁用 **播放唤醒**：
- en: '![Celebrations and fireworks!](img/figure_02_30.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![庆祝和烟花！](img/figure_02_30.jpg)'
- en: 'Figure 2.30: Disabling Play On Awake'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30：禁用播放唤醒
- en: 'Disabling **Play On Awake** prevents particle systems playing automatically
    at level startup. This is fine, but if they are ever to play at all, something
    must manually start them at the right time. We can achieve this through code.
    Before resorting to a coding solution, however, we''ll first mark all firework
    objects with an appropriate tag. The reason for this is that, in code, we''ll
    want to search for all firework objects in the scene and trigger them to play
    when needed. To isolate the firework objects from all other objects, we''ll use
    tags. So, let''s create a new **Fireworks** tag and assign them to the firework
    objects only in the **Scene**. Tags were created earlier in this chapter when
    configuring the player character for coin collisions. See *Figure 2.31*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用 **播放唤醒** 防止粒子系统在关卡启动时自动播放。这很好，但如果它们要播放，必须在正确的时间手动启动它们。我们可以通过代码来实现这一点。然而，在求助于编码解决方案之前，我们首先将所有烟花对象标记为适当的标签。这样做的原因是，在代码中，我们将想要在场景中搜索所有烟花对象并在需要时触发它们播放。为了将烟花对象与其他所有对象隔离开来，我们将使用标签。因此，让我们创建一个新的
    **Fireworks** 标签并将它们仅分配给 **场景** 中的烟花对象。标签是在本章早期配置玩家角色以进行硬币碰撞时创建的。参见 *图 2.31*：
- en: '![Celebrations and fireworks!](img/figure_02_31.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![庆祝和烟花！](img/figure_02_31.jpg)'
- en: 'Figure 2.31: Tagging firework objects'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31：标记烟花对象
- en: 'With the firework objects now tagged, we can refine the `Coin.cs` script class
    to handle a win condition for the scene, as shown in *Code Sample 2.7*. Comments
    follow:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标记烟花对象，我们现在可以细化 `Coin.cs` 脚本类以处理场景的胜利条件，如 *代码示例 2.7* 所示。注释如下：
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Code Sample 2.7
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 2.7
- en: 'The following points summarize the code sample:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `OnDestroy` function is critical. It occurs when a coin is collected and
    features an `if` statement to determine when all coins are collected (the win
    scenario).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy` 函数至关重要。它发生在收集到硬币时，并包含一个 `if` 语句以确定何时收集到所有硬币（即胜利场景）。'
- en: When a win scenario happens, the `GameObject.Find` function is called to search
    the complete scene hierarchy for any active object named `LevelTimer`. If found,
    the object is deleted. This happens to delete the timer and prevent any further
    countdown when the level is won. If the scene contains multiple objects of a matching
    name, then only the first object is returned. This is one reason why the scene
    should contain one and only one timer.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生胜利场景时，会调用`GameObject.Find`函数来在整个场景层次结构中搜索任何名为`LevelTimer`的活动对象。如果找到，该对象将被删除。这会导致删除计时器并防止在关卡胜利后进行进一步的倒计时。如果场景包含多个同名对象，则只返回第一个对象。这是场景应该只包含一个计时器的一个原因。
- en: Note
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Avoid using the `GameObject.Find` function wherever possible. It's slow for
    performance. Instead, use `FindGameObjectsWithTag`. It's been used here only to
    demonstrate its existence and purpose. Sometimes, you'll need to use it to find
    a single, miscellaneous object that has no specific tag.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽可能避免使用`GameObject.Find`函数。它在性能上很慢。相反，使用`FindGameObjectsWithTag`。这里只使用它来演示其存在和目的。有时，你需要使用它来找到单个、无特定标签的杂项对象。
- en: In addition to deleting the `LevelTimer` object, the `OnDestroy` function finds
    all firework objects in the scene and initiates them. It finds all objects of
    a matching tag using the `GameObject.FindGameObjectsWithTag` function. This function
    returns an array of all objects with the **Fireworks** tag and the `ParticleSystem`
    is initiated for each object by calling the `Play` function.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了删除`LevelTimer`对象外，`OnDestroy`函数还会在场景中找到所有烟花对象并启动它们。它使用`GameObject.FindGameObjectsWithTag`函数找到所有匹配标签的对象。此函数返回所有带有**Fireworks**标签的对象数组，并通过调用`Play`函数为每个对象启动`ParticleSystem`。
- en: Note
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned, each `GameObject` in Unity is really made from a collection of
    attached and related components. An object is the sum of its components. For example,
    a standard cube (created using **GameObject** | **3D Object** | **Cube**) is made
    from a **Transform** component, **Mesh Filter** component, **Mesh Renderer** component,
    and **Box Collider** component. These components together make the cube what it
    is and behave how it does.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，Unity中的每个`GameObject`实际上是由一组附加的相关组件组成的。一个对象是其组件的总和。例如，一个标准立方体（使用**GameObject**
    | **3D Object** | **Cube**）由**Transform**组件、**Mesh Filter**组件、**Mesh Renderer**组件和**Box
    Collider**组件组成。这些组件共同构成了立方体，并决定了它的行为。
- en: The `GetComponent` function can be called in script to retrieve a reference
    to any specified component, giving you direct access to its public properties.
    The `OnDestroy` function in the preceding code uses `GetComponent` to retrieve
    a reference to the `ParticleSystem` component attached to the object. `GetComponent`
    is a highly useful and important function. More information on `GetComponent`
    can be found at the online Unity documentation at [http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html](http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html).
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以在脚本中调用`GetComponent`函数来检索对任何指定组件的引用，从而直接访问其公共属性。前述代码中的`OnDestroy`函数使用`GetComponent`来检索附加到对象上的`ParticleSystem`组件的引用。`GetComponent`是一个高度有用且重要的函数。有关`GetComponent`的更多信息，可以在Unity在线文档中找到，链接为[http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html](http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)。
- en: Play testing
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试
- en: 'You''ve now completed your first game in Unity! It''s time to take it for a
    test run and then finally build it. Testing in Unity firstly consists of pressing
    play on the toolbar and simply playing your game to see that it works as intended
    from the perspective of a gamer. In addition to playing, you can also enable debugging
    mode from the **Object Inspector** to keep a watchful eye on all `public` and
    `private` variables during runtime, making sure that no variable is assigned an
    unexpected value. To activate the **Debug** mode, click on the menu icon at the
    top right corner of the **Object Inspector** and, from the context menu that appears,
    select the **Debug** option. See *Figure 2.32*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经在Unity中完成了你的第一个游戏！是时候对其进行测试运行，然后最终构建它了。在Unity中进行测试首先是通过工具栏上的播放按钮来播放游戏，以查看游戏是否按预期从玩家的角度工作。除了播放之外，你还可以从**对象检查器**中启用调试模式，在运行时密切关注所有`public`和`private`变量，确保没有变量被分配了意外的值。要激活**调试**模式，点击**对象检查器**右上角的菜单图标，然后从出现的上下文菜单中选择**调试**选项。参见*图2.32*：
- en: '![Play testing](img/figure_02_32.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![游戏测试](img/figure_02_32.jpg)'
- en: 'Figure 2.32: Activating Debug mode from the Object Inspector'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.32：从对象检查器激活调试模式
- en: 'After activating the **Debug** mode, the appearance of some variables and components
    in the **Object Inspector** may change. Typically, you''ll get a more detailed
    and accurate view of your variables, and you''ll also be able to see most `private`
    variables. See *Figure 2.33* for the **Transform** component in **Debug** mode:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活**Debug**模式后，**对象检查器**中一些变量和组件的外观可能会改变。通常，您将获得更详细和准确的变量视图，您还将能够看到大多数`private`变量。参见*图2.33*以查看**Debug**模式下的**Transform**组件：
- en: '![Play testing](img/figure_02_33.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Play测试](img/figure_02_33.jpg)'
- en: 'Figure 2.33: Viewing the Transform component in Debug mode'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.33：在调试模式下查看变换组件
- en: 'Another useful debugging tool at runtime is the **Stats** panel. This can be
    accessed from the **Game** tab by clicking on the **Stats** button from the toolbar.
    See *Figure 2.34*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在运行时非常有用的调试工具是**Stats**面板。您可以通过点击工具栏中的**Stats**按钮从**Game**标签页访问它。参见*图2.34*：
- en: '![Play testing](img/figure_02_34.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Play测试](img/figure_02_34.jpg)'
- en: 'Figure 2.34: Accessing the Stats panel from the Game tab'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.34：从Game标签页访问Stats面板
- en: The **Stats** panel is only useful during the play mode. In this mode, it details
    the critical performance statistics for your game, such as Frame Rate (FPS) and
    memory usage. This lets you diagnose or determine whether any problems may be
    affecting your game. The FPS represents the total number of frames (ticks or cycles)
    per second that your game can sustain on average. There is no right, wrong, or
    magical FPS, but higher values are better than lower ones. Higher values represent
    better performance because it means that your game can sustain more cycles in
    one second. If your FPS falls below 20 or 15, it's likely that your game will
    appear choppy or laggy as the performance weight of each cycle means it takes
    longer to process. Many variables can affect FPS, some internal and some external
    to your game. Internal factors include the number of lights in a scene, vertex
    density of meshes, number of instructions, and complexity of code. Some external
    factors include the quality of your computer's hardware, number of other applications
    and processes running at the same time, amount of hard drive space, among others.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**Stats**面板仅在游戏模式下有用。在此模式下，它详细说明了游戏的关键性能统计信息，例如帧率（FPS）和内存使用情况。这使您能够诊断或确定是否有任何问题可能影响您的游戏。FPS代表您的游戏每秒可以平均维持的总帧数（滴答或周期）。没有正确、错误或神奇的FPS，但较高的值比较低的值好。较高的值代表更好的性能，因为它意味着您的游戏可以在一秒内维持更多的周期。如果您的FPS低于20或15，那么您的游戏可能会出现卡顿或延迟，因为每个周期的性能权重意味着它需要更长的时间来处理。许多变量可以影响FPS，有些是游戏内部的，有些是游戏外部的。内部因素包括场景中的灯光数量、网格的顶点密度、指令数量和代码的复杂性。一些外部因素包括您计算机硬件的质量、同时运行的其他应用程序和进程的数量、硬盘空间的大小等。'
- en: In short, if your FPS is low, then it indicates a problem that needs attention.
    The solution to that problem varies depending on the context and you'll need to
    use judgement, for example, are your meshes too complex? Do they have too many
    vertices? Are your textures too large? Are there too many sounds playing? See
    *Figure 2.35* for the coin collection game up and running. The completed game
    can be found in the book companion files in the `Chapter02/End` folder.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果您的FPS（每秒帧数）低，那么这表明需要关注的问题。该问题的解决方案取决于上下文，您需要运用判断力，例如，您的网格是否过于复杂？它们是否有太多的顶点？您的纹理是否太大？是否有太多的声音在播放？参见*图2.35*以查看正在运行的收集硬币游戏。完成的游戏可以在书籍配套文件中的`Chapter02/End`文件夹中找到。
- en: '![Play testing](img/figure_02_35.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Play测试](img/figure_02_35.jpg)'
- en: 'Figure 2.35: Testing the coin collection game'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.35：测试收集硬币游戏
- en: Building
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: So now it's time to build the game! That is, to compile and package the game
    into a standalone and self-executing form, which the gamer can run and play without
    needing to use the Unity Editor. Typically, when developing games, you'll reach
    a decision about your target platform (such as Windows, iOS, Android, and others)
    during the design phase and not at the end of development. It's often said that
    Unity is a 'develop once, deploy everywhere tool. This slogan can conjure up the
    unfortunate image that, after a game is made, it'll work just as effortlessly
    on every platform supported by Unity as it does on the desktop.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候构建游戏了！也就是说，将游戏编译并打包成独立和可执行的形式，玩家可以在不使用Unity编辑器的情况下运行和播放。通常，在开发游戏时，您会在设计阶段而不是开发结束时决定您的目标平台（如Windows、iOS、Android等）。经常有人说Unity是一个“一次开发，到处部署”的工具。这个口号可能会让人联想到一个不幸的图像，即游戏制作完成后，它将在Unity支持的所有平台上像在桌面平台上一样轻松地工作。
- en: 'Unfortunately, things are not so simple; games that work well on desktop systems
    don''t necessarily perform equally well on mobiles and vice versa. This is largely
    due to the great differences in target hardware and industry standards that hold
    between them. Due to these differences, I''ll focus our attention here to the
    Windows and Mac desktop platforms, ignoring mobiles and consoles and other platforms.
    To create a Build for desktop platform, select **File** | **Build Settings** from
    the **File** menu:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，事情并不那么简单；在桌面系统上运行良好的游戏不一定在移动设备上表现同样出色，反之亦然。这主要归因于它们之间在目标硬件和行业标准方面的巨大差异。由于这些差异，我将在此处将我们的注意力集中在Windows和Mac桌面平台上，忽略移动设备、游戏机和其他平台。要为桌面平台创建构建，请从**文件**菜单中选择**文件**
    | **构建设置**：
- en: '![Building](img/figure_02_36.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/figure_02_36.jpg)'
- en: 'Figure 2.36: Accessing the Build Settings for the project'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.36：访问项目的构建设置
- en: 'The **Build Settings** dialog is displayed and its interface consists of three
    main areas. The **Scenes In Build** list is a complete list of all scenes to be
    included in the build, regardless of whether the gamer will actually visit them
    in the game. It represents the totality of all scenes that could ever be visited
    in the game. In short, if you want or need a scene in your game, then it needs
    to be in this list. Initially, the list is empty. See *Figure 2.37*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建设置**对话框显示，其界面由三个主要区域组成。**构建中的场景**列表是包含在构建中的所有场景的完整列表，无论玩家是否会在游戏中访问它们。它代表了游戏中可能访问到的所有场景的总体。简而言之，如果您需要在您的游戏中添加或需要场景，那么它需要在这个列表中。最初，列表是空的。请参阅*图2.37*：'
- en: '![Building](img/figure_02_37.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/figure_02_37.jpg)'
- en: 'Figure 2.37: The Build Settings dialog'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.37：构建设置对话框
- en: 'You can easily add scenes to the list by simply dragging and dropping the scene
    asset from the **Project** panel to the **Scenes In Build** list. For the coin
    collection game, I''ll drag and drop the `Level_01` scene to the list. As scenes
    are added, Unity automatically assigns them a number, depending on their order
    in the list. **0** represents the topmost item, 1 the next item, and so on. This
    number is important insofar as the **0** item is concerned. The topmost scene
    (scene 0) will always be the starting scene. That is, when the build runs, Unity
    automatically begins execution from scene 0\. Thus, scene 0 will typically be
    your splash or intro scene. See *Figure 2.38*, Adding a level to the **Build Settings**
    dialog:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单地从**项目**面板拖放场景资产到**构建中的场景**列表中轻松地将场景添加到列表中。对于金币收集游戏，我会将`Level_01`场景拖放到列表中。随着场景的增加，Unity会根据它们在列表中的顺序自动为它们分配一个数字。**0**代表列表中最顶部的项目，1代表下一个项目，以此类推。这个数字对于**0**项目来说很重要。最顶部的场景（场景0）始终是起始场景。也就是说，当构建运行时，Unity会自动从场景0开始执行。因此，场景0通常将是您的启动或介绍场景。请参阅*图2.38*，向**构建设置**对话框添加一个级别：
- en: '![Building](img/figure_02_38.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/figure_02_38.jpg)'
- en: 'Figure 2.38: Adding a level to the Build Settings dialog'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.38：向构建设置对话框添加一个级别
- en: 'Next, be sure to select your target platform from the **Platform** list at
    the bottom left-hand side of the **Build Settings** dialog. For desktop platforms,
    choose **PC, Mac & Linux Standalone**, which should be selected by default. Then,
    from the options, set the **Target Platform** drop-down list to either **Windows**,
    **Linux**, or **Mac OS X**, depending on your system. See *Figure 2.39*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请确保从**构建设置**对话框左下角的**平台**列表中选择您的目标平台。对于桌面平台，选择**PC、Mac & Linux 独立**，这应该是默认选中的。然后，从选项中设置**目标平台**下拉列表为**Windows**、**Linux**或**Mac
    OS X**，具体取决于您的系统。请参阅*图2.39*：
- en: '![Building](img/figure_02_39.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![构建](img/figure_02_39.jpg)'
- en: 'Figure 2.39: Choosing a target build platform'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.39：选择目标构建平台
- en: 'If you''ve previously been testing your game for multiple platforms or trying
    out other platforms such as **Android** and **iOS**, the **Switch Platform** button
    (at the bottom left of the **Build Settings** dialog) might become active when
    you select the **Standalone** option. If it does, click on the **Switch** **Platform**
    button to confirm to Unity that you intend building for the selected platform.
    On clicking this, Unity may spend a few minutes configuring your assets for the
    selected platform:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前已经为多个平台测试过您的游戏或尝试过其他平台，如**Android**和**iOS**，当您选择**独立**选项时，**切换平台**按钮（位于**构建设置**对话框的左下角）可能会变得可用。如果是这样，点击**切换**
    **平台**按钮以向Unity确认您打算为所选平台进行构建。点击此按钮后，Unity可能需要几分钟来配置您的资产以适应所选平台：
- en: '![Building](img/figure_02_40.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![构建](img/figure_02_40.jpg)'
- en: 'Figure 2.40: Switching platforms'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.40：切换平台
- en: 'Before building for the first time, you''ll probably want to view the **Player
    Settings** options to fine-tune important build parameters, such as game resolution,
    quality settings, executable icon, and information, among other settings. To access
    the **Player Settings**, you can simply click on the **Player Settings** button
    from the **Build** dialog. This displays the **Player Settings** in the **Object
    Inspector**. The same settings can also be accessed via the application menu by
    navigating to **Edit** | **Project Settings** | **Player**. See *Figure 2.4*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次构建之前，您可能希望查看**玩家设置**选项以微调重要的构建参数，例如游戏分辨率、质量设置、可执行图标和信息，以及其他设置。要访问**玩家设置**，您可以直接从**构建**对话框中点击**玩家设置**按钮。这将在**对象检查器**中显示**玩家设置**。相同的设置也可以通过应用程序菜单访问，方法是导航到**编辑**
    | **项目设置** | **玩家**。参见*图2.4*：
- en: '![Building](img/figure_02_41.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![构建](img/figure_02_41.jpg)'
- en: 'Figure 2.41: Accessing the Player Settings options'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.41：访问玩家设置选项
- en: 'From the **Player Settings** options, set **Company Name** and **Product Name**
    as this information is baked and stored within the built executable. You can also
    specify an icon image for the executable as well as a default mouse cursor, if
    one is required. For the collection game, however, these latter two settings will
    be left empty. See *Figure 2.42*:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从**玩家设置**选项中，设置**公司名称**和**产品名称**，因为这些信息将被嵌入并存储在构建的可执行文件中。您还可以指定可执行文件的图标图像以及默认鼠标光标（如果需要的话）。然而，对于集合游戏，后两个设置将被留空。参见*图2.42*：
- en: '![Building](img/figure_02_42.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![构建](img/figure_02_42.jpg)'
- en: 'Figure 2.42: Setting a publisher name and product name'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.42：设置出版商名称和产品名称
- en: The **Resolution and Presentation** tab is especially important as it specifies
    the game screen size and whether a default splash screen (**Resolution** dialog)
    should appear at the application startup. From this tab, ensure that the **Default
    Is Full Screen** option is enabled, meaning that the game will run at the complete
    size of the system's screen as opposed to a smaller and movable window. In addition,
    enable the **Display Resolution Dialog** drop-down list. See *Figure 2.43*. When
    this is enabled, your application will display an options screen at startup, allowing
    the user to select a target resolution and screen size and customize controls.
    For a final build, you'll probably want to disable this option, presenting the
    same settings through your own customized options screen in-game instead. However,
    for test builds, the **Resolution** dialog can be a great help. It lets you test
    your build easily at different sizes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**分辨率和显示**选项卡特别重要，因为它指定了游戏屏幕大小以及是否在应用程序启动时显示默认的启动画面（**分辨率**对话框）。从此选项卡，确保已启用**默认全屏**选项，这意味着游戏将以系统屏幕的完整尺寸运行，而不是一个较小且可移动的窗口。此外，启用**显示分辨率对话框**下拉列表。参见*图2.43*。当此选项启用时，您的应用程序将在启动时显示一个选项屏幕，允许用户选择目标分辨率和屏幕大小以及自定义控制。对于最终构建版本，您可能希望禁用此选项，而是在游戏中通过您自己的定制选项屏幕提供相同的设置。然而，对于测试构建，**分辨率**对话框可以非常有帮助。它让您能够轻松地在不同尺寸下测试您的构建。'
- en: '![Building](img/figure_02_43.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![构建](img/figure_02_43.jpg)'
- en: 'Figure 2.43: Enabling the Resolution dialog'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.43：启用分辨率对话框
- en: 'Now you''re ready to make your first compiled build. So, click on the **Build**
    button from the **Build Settings** dialog or else, choose **File** | **Build &
    Run** from the application menu. When you do this, Unity presents you with a **Save**
    dialog, asking you to specify a target location on your computer where the build
    should be made. Select a location and choose **Save**, and the build process will
    be completed. Occasionally, this process can generate errors, which are printed
    in red in the **Console** window. This can happen, for example, when you save
    to a read-only drive, have insufficient hard drive space, or don''t have the necessary
    administration privileges on your computer. However, generally, the build process
    succeeds if your game runs properly in the editor. See *Figure 2.44*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以准备进行第一次编译构建了。因此，从**构建设置**对话框中点击**构建**按钮，或者从应用程序菜单中选择**文件** | **构建 & 运行**。当你这样做时，Unity会弹出一个**保存**对话框，询问你指定计算机上构建的目标位置。选择一个位置并选择**保存**，构建过程将完成。偶尔，这个过程可能会生成错误，这些错误会在**控制台**窗口中以红色打印出来。例如，当你保存到只读驱动器、硬盘空间不足或没有在计算机上必要的管理员权限时，可能会发生这种情况。然而，一般来说，如果你的游戏在编辑器中运行正常，构建过程就会成功。参见*图2.44*：
- en: '![Building](img/figure_02_44.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/figure_02_44.jpg)'
- en: 'Figure 2.44: Building and running a game'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.44：构建和运行游戏
- en: After the **Build** is completed, Unity generates new files at your destination
    location. For Windows, it generates an executable file and data folder. See *Figure
    2.45*. Both are essential and interdependent. That is, if you want to distribute
    your game and have other people play it without needing to install Unity, then
    you'll need to send users both the executable file and associated data folder
    and all its contents.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，Unity会在你的目标位置生成新的文件。对于Windows，它生成一个可执行文件和数据文件夹。参见*图2.45*。这两个都是必需的，并且相互依赖。也就是说，如果你想分发你的游戏并让其他人玩而不需要安装Unity，那么你需要发送给用户可执行文件以及相关的数据文件夹及其所有内容。
- en: '![Building](img/figure_02_45.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/figure_02_45.jpg)'
- en: 'Figure 2.45: Unity builds several files'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.45：Unity构建了几个文件
- en: 'On running your game, the **Resolution** dialog will show, assuming that you
    **Enabled** the **Display Resolution** **Dialog** option from the **Player Settings**.
    From here, users can select the game resolution, quality, and output monitor and
    configure player controls:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的游戏时，如果从**玩家设置**中启用了**显示分辨率** **对话框**选项，将显示**分辨率**对话框。从这里，用户可以选择游戏分辨率、质量和输出监视器，并配置玩家控制：
- en: '![Building](img/figure_02_46.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/figure_02_46.jpg)'
- en: 'Figure 2.46: Preparing to run your game from the Resolution dialog'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.46：从分辨率对话框准备运行你的游戏
- en: 'On clicking the play button, your game will run by default in fullscreen mode.
    Congratulations! Your game is now completed and built and you can send it to your
    friends and family for play testing! See *Figure 2.47*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮后，你的游戏将默认在全屏模式下运行。恭喜！你的游戏现在已经完成并构建好了，你可以发送给你的朋友和家人进行游戏测试！参见*图2.47*：
- en: '![Building](img/figure_02_47.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/figure_02_47.jpg)'
- en: 'Figure 2.47: Running the coin collection game in fullscreen mode'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.47：全屏模式运行硬币收集游戏
- en: But wait! How do you exit your game when you're finished playing? There's no
    quit button or main menu option in the game. For Windows, you just need to press
    *Alt* + *F4* on the keyboard. For Mac, you press *cmd* + *Q* and for Ubuntu, it's
    *Ctrl* + *Q*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！当你玩完游戏后，如何退出游戏？游戏中没有退出按钮或主菜单选项。对于Windows，你只需按键盘上的*Alt* + *F4*。对于Mac，按*cmd*
    + *Q*，而对于Ubuntu，则是*Ctrl* + *Q*。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Excellent work! On reaching this point, you've completed the coin collection
    game as well as your first game in Unity. On achieving this, you've seen a wide
    range of Unity features including level editing and design, prefabs, particle
    systems, meshes, components, script files, and build settings. That's a lot! Of
    course, there's a lot more to be said and explored for all these areas, but nevertheless,
    we've pulled them together to make a game. Next, we'll get stuck in with a different
    game altogether and, in doing this, we'll see a creative reuse of the same features
    as well as the introduction of completely new features. In short, we're going
    to move from the world of beginner-level Unity development to intermediate.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的作品！到达这个阶段，你已经完成了收集硬币游戏以及你在Unity中的第一个游戏。在实现这一点后，你看到了Unity的广泛功能，包括关卡编辑和设计、预制体、粒子系统、网格、组件、脚本文件和构建设置。这已经很多了！当然，对于所有这些领域还有很多可以说的和探索的，但无论如何，我们已经将它们整合在一起制作了一个游戏。接下来，我们将着手制作一个完全不同的游戏，在这个过程中，我们将看到相同功能的创造性重用以及全新功能的引入。简而言之，我们将从入门级Unity开发的领域过渡到中级。
