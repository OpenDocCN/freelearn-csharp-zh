<html><head></head><body>
		<div><p><a id="_idTextAnchor120"/></p>
			<h1 id="_idParaDest-122"><em class="italic"><a id="_idTextAnchor121"/>Chapter 7</em>: Understanding the Mathematics of Computer Graphics in Unity</h1>
			<p>Mathematics is a topic that is often discussed in game development. Although Unity has provided game developers with many helper functions to reduce the complexity of using mathematics in Unity, it is still necessary to have some basic mathematical knowledge about computer graphics, such as coordinate systems, vectors, matrices, and quaternions.</p>
			<p>In this chapter, we will explore the following key topics:</p>
			<ul>
				<li>Getting started with coordinate systems</li>
				<li>Working with vectors</li>
				<li><a id="_idTextAnchor122"/>Working with the transformation matrix</li>
				<li>Working with quaternions</li>
			</ul>
			<p>By the end of this chapter, you will have mathematical knowledge of computer graphics and know how to use vectors, matrices, quaternions, and Euler angles in scripts correctly.</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/>Getting started with coordinate systems </h1>
			<p>Like many files, most model files are binary files. When a game engine, such as Unity, needs to render a model, the data of the model, such as the vertex array of the model and the index of the vertex array, will be extracted and processed through the render pipeline of the game engine. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find more information about the render pipeline<a id="_idIndexMarker622"/> in computer graphics at <a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a>.</p>
			<p>A graphics render pipeline <a id="_idIndexMarker623"/>mainly includes two functions: one to convert the 3D coordinates of an object into 2D coordinates in the screen space and the other to color each pixel of the screen. Finally, the 3D model is rendered on the 2D screen.</p>
			<p>In the process of the render pipeline, a lot of coordinate system conversion work will be involved, as you can see in <em class="italic">Figure 7.1</em>. So, it's an important topic and we will introduce information about coordinate systems in this section:</p>
			<div><div><img src="img/Figure_7.01_B17146.jpg" alt="Figure 7.1 – Coordinate transformation process (CC BY 4.0)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Coordinate transformation process (CC BY 4.0)</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor124"/>Understanding left-handed and right-handed coordinate systems</h2>
			<p>A <a id="_idIndexMarker624"/>coordinate system is a geometric system that typically uses numbers to determine the position of a point in space.</p>
			<p>In <a id="_idIndexMarker625"/>mathematics, there <a id="_idIndexMarker626"/>are many different<a id="_idIndexMarker627"/> types of coordinate systems, such as the <strong class="bold">number line coordinate system</strong>, <strong class="bold">Cartesian coordinate system</strong>, and <strong class="bold">polar coordinate system</strong>. In computer graphics, the <strong class="bold">Cartesian coordinate system</strong> is the most commonly used.</p>
			<div><div><img src="img/Figure_7.02_B17146.jpg" alt="Figure 7.2 – Cartesian coordinate system&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Cartesian coordinate system</p>
			<p>The<a id="_idIndexMarker628"/> Cartesian coordinate system is also very common in our daily lives, that is, the <em class="italic">x</em> axis, <em class="italic">y</em> axis, and <em class="italic">z</em> axis are used to describe the coordinate information of the object. When <a id="_idIndexMarker629"/>used to describe 3D space, the Cartesian coordinate system can be<a id="_idIndexMarker630"/> either a <strong class="bold">left-handed coordinate system</strong> or a <strong class="bold">right-handed coordinate system</strong>. As their names imply, we can actually distinguish between the two by using the left hand and the right hand. </p>
			<div><div><img src="img/Figure_7.03_B17146.jpg" alt="Figure 7.3 – Coordinate systems (CC BY-SA 3.0)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Coordinate systems (CC BY-SA 3.0)</p>
			<p>As shown in <em class="italic">Figure 7.3</em>, we can distinguish between the left-handed coordinate system and the right-handed coordinate system by visualizing the thumb pointing to the <em class="italic">x</em> axis, the index finger to the <em class="italic">y</em> axis, and the middle finger to the <em class="italic">z</em> axis.</p>
			<div><div><img src="img/Figure_7.04_B17146.jpg" alt="Figure 7.4 – Left-handed coordinate system in Unity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Left-handed coordinate system in Unity</p>
			<p>If we look in <a id="_idIndexMarker631"/>the Unity Editor, we can see that Unity uses the left-handed coordinate system, as shown in <em class="italic">Figure 7.4</em>.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/>Local space</h2>
			<p>Coordinate space is the space where 3D positions and transformations exist within the coordinate system, such as <strong class="bold">local space</strong> and <strong class="bold">world space</strong>. In Unity, we often work with local space or world space. Local space<a id="_idIndexMarker632"/> is related to the concept of the <strong class="bold">parent-child relationship</strong>, which<a id="_idIndexMarker633"/> means it uses the origin and axes of the GameObject's parent node in the hierarchy of <a id="_idIndexMarker634"/>GameObjects. The position, rotation, and scaling of the parent GameObject will affect the local space defined by it. Therefore, this is useful not when we are dealing with the transformation of a single GameObject but of a group of GameObjects.</p>
			<p>For example, in <em class="italic">Figure 7.5</em>, the five cube objects are all children of the GameObject named <strong class="bold">LocalSpace</strong>:</p>
			<div><div><img src="img/Figure_7.05_B17146.jpg" alt="Figure 7.5 – LocalSpace parent object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – LocalSpace parent object</p>
			<p>We can see that the <code>0</code>. Now, let's move this parent <a id="_idIndexMarker635"/>object down 2 units along the <em class="italic">y</em> axis and also rotate it 45 degrees around the <em class="italic">y</em> axis.</p>
			<div><div><img src="img/Figure_7.06_B17146.jpg" alt="Figure 7.6 – LocalSpace parent object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – LocalSpace parent object</p>
			<p>As shown in <em class="italic">Figure 7.6</em>, all these cubes have moved down 2 units along the <em class="italic">y</em> axis and rotated 45 degrees around the <em class="italic">y</em> axis. However, if we look at the position and rotation of individual cubes in the <strong class="bold">Inspector</strong> window, we can see that these values have not changed. This is because, currently, they are in local space defined by their parent object, and the position and rotation of a single cube relative to its parent object have not changed. </p>
			<div><div><img src="img/Figure_7.07_B17146.jpg" alt="Figure 7.7 – Local space child object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Local space child object</p>
			<p>We can change the <a id="_idIndexMarker636"/>local position, local rotation, and local scale of a child object through C# code at runtime, as shown:</p>
			<pre>public class LocalSpaceTest : MonoBehaviour
{
    private Vector3 _localPosition = new Vector3(-2, 0, 0);
    private Vector3 _localScale = new Vector3(1, 2, 1);
    private Transform _transform;
    private void Start()
    {
        _transform = gameObject.transform;
        _transform.localPosition = _localPosition;
        _transform.localScale = _localScale;
    }
}</pre>
			<p>Attach this script to the child object named <strong class="bold">Cube (1)</strong> and run the game. We can see in the following screenshot <a id="_idIndexMarker637"/>that the child object has moved 2 units along the <em class="italic">x</em> axis relative to the parent object and is magnified 2 times along the <em class="italic">y</em> axis relative to the parent object:</p>
			<div><div><img src="img/Figure_7.08_B17146.jpg" alt="Figure 7.8 – Changing the local postion and local scale&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Changing the local postion and local scale</p>
			<p>In this section, we discussed local space. Next, we will explore world space.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor126"/>World space</h2>
			<p>Unlike local space, which <a id="_idIndexMarker638"/>is defined by a parent GameObject, world space is the coordinate system for the entire Scene. The center of the Scene is the origin of world space.</p>
			<p>Let's create a new Cube object in the Scene and this time, this new cube is not a child of other GameObjects.</p>
			<div><div><img src="img/Figure_7.09_B17146.jpg" alt="Figure 7.9 – World space&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – World space</p>
			<p>As shown in <em class="italic">Figure 7.9</em>, when the<a id="_idIndexMarker639"/> position of the cube is <code>0</code>, the cube is located in the center of the Scene. If we change the <em class="italic">x</em> value of the cube position from <code>0</code> to <code>1</code>, then the cube will advance 1 unit along the <em class="italic">x</em> axis of world space.</p>
			<div><div><img src="img/Figure_7.10_B17146.jpg" alt="Figure 7.10 – Moving in world space&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – Moving in world space</p>
			<p>We can also modify the position, rotation, and scale of a GameObject in world space in a C# script. The following code snippet shows how to do this:</p>
			<pre>using UnityEngine;
public class WorldSpaceTest : MonoBehaviour
{
    void Start()
    {
        transform.<strong class="bold">position</strong> = new Vector3(0, 1, 0);
    }
}</pre>
			<p>The <code>position</code> property is the<a id="_idIndexMarker640"/> world space position of the transform. In addition to directly modifying the <code>position</code> or <code>rotation</code> properties, we can also call the following method to modify the <code>position</code> and <code>rotation</code> properties of the object at the same time:</p>
			<pre>public void SetPositionAndRotation(Vector3 position, Quaternion 
  rotation);</pre>
			<p>We can see that this method requires a <code>Vector3</code>-type parameter and a <code>Quaternion</code>-type parameter. We will introduce vectors and quaternions later in the <em class="italic">Working with vectors</em> and <em class="italic">Working with quaternions</em> sections, respectively.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>Screen space</h2>
			<p>As we mentioned at the <a id="_idIndexMarker641"/>beginning of this section, the coordinate system can be used to determine a point in space. This refers to not only 3D space but also 2D space. Screen space is the space defined by the viewer's screen. It means that the screen space projects the content onto the screen.</p>
			<p>In screen space, the coordinates are in 2D; (<strong class="bold">0,0</strong>) is the lower-left corner and (screen.width, screen.height) is the upper-right corner, as shown in the following screenshot: </p>
			<div><div><img src="img/Figure_7.11_B17146.jpg" alt="Figure 7.11 – Screen space&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – Screen space</p>
			<p>2D elements are <a id="_idIndexMarker642"/>often described in screen space, and the most common is the UI. Another common use of screen space is to get the position of the mouse input. The reason is obvious: the mouse moves on the screen. The following code snippet demonstrates how to get the position of the mouse in a C# script:</p>
			<pre>using UnityEngine;
public class ScreenSpaceTest : MonoBehaviour
{
    void Update()
    {
        Vector2 mousePosition = <code>Input.mousePosition</code>;
        Debug.Log($"Mouse Position: {mousePosition}");
    }
}</pre>
			<p>The <code>mousePosition</code> property of the <code>Input</code> class will return the current mouse position in screen space, and the preceding code will print the mouse position to the <strong class="bold">Console</strong> window, as shown in <em class="italic">Figure 7.12</em>:</p>
			<div><div><img src="img/Figure_7.12_B17146.jpg" alt="Figure 7.12 – Mouse position&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – Mouse position</p>
			<p>After obtaining the screen space position of the mouse, we can use the methods provided by Unity's <code>Camera</code> class to convert the screen space position to the world space position. In addition, Unity allows us to create a ray that goes from the camera through a screen point to the game world. This can help us deal with a common situation in games where we need to know what the player is clicking on in the 3D game world, even though the player can only actually click on a 2D screen.</p>
			<p>The method signatures <a id="_idIndexMarker643"/>of some methods are as follows:</p>
			<pre>public <strong class="bold">Ray</strong> ScreenPointToRay(Vector3 pos);
public <strong class="bold">Vector3</strong> ScreenToWorldPoint(Vector3 position);</pre>
			<p>As we just mentioned, the <code>ScreenPointToRay</code> method is very useful because it returns a <code>Ray</code> instance from the camera pointing to the mouse position in the world space. I hope you still remember the Collider component in the physics system we introduced in the previous chapter because we can use this method to cast a ray to the collider and get the details of the collider, and it can also be used to draw a line in the Scene view of the Unity Editor to help with debugging.  </p>
			<p>Next, we will modify the previous code to implement a function that can detect whether there is a collider at the mouse click position and draw a red line in the Scene view if there is a collider:</p>
			<pre>    <strong class="bold">Ray</strong> _ray;
    private void FixedUpdate()
    {
      _ray =
        Camera.main.<strong class="bold">ScreenPointToRay</strong>(Input.mousePosition);
      if (<strong class="bold">Physics.Raycast</strong>(_ray, out RaycastHit hit, 50))
      {
          <strong class="bold">Debug.DrawLine</strong>(_ray.origin, hit.point,
            Color.red);
        }
    }</pre>
			<p>As the code snippet shows, we are calling the <code>ScreenPointToRay</code> method to create a ray pointing in the direction of the mouse from the location of the main camera in the scene, and then using this ray to detect colliders in the Scene by calling <code>Physics.Raycast</code>, and finally calling <code>Debug.DrawLine</code> to draw a red line in the Scene view, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_7.13_B17146.jpg" alt="Figure 7.13 – Drawing a red line&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – Drawing a red line</p>
			<p>In <em class="italic">Figure 7.13</em>, the top is the<a id="_idIndexMarker644"/> game view, which is the window where the game is running, and the bottom is the Scene view, which is the window for debugging. </p>
			<p>We have introduced you to coordinate systems in this section. Next, we will discuss another very important topic: vectors.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>Working with vectors </h1>
			<p>In game<a id="_idIndexMarker645"/> development, we use vectors to define directions and positions. As shown in the following figure, we draw a line between two points to represent a vector. In this case, the vector starts from the origin, which is point <strong class="bold">B (0, 0)</strong> on the graph, to point <strong class="bold">A (6, 2)</strong>: </p>
			<div><div><img src="img/Figure_7.14_B17146.jpg" alt="Figure 7.14 – 2D position&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14 – 2D position</p>
			<p>We can see this <a id="_idIndexMarker646"/>vector is made up of two components, namely <em class="italic">x</em> and <em class="italic">y</em>. They represent the distance from the origin along the <em class="italic">x</em> axis and the <em class="italic">y</em> axis. Therefore, this vector can be used to define the position of point <code>(x*x+y*y)</code>. </p>
			<p>In Unity, we will use the Vector2 structure to represent 2D vectors and points. The magnitude property of Vector2 returns the value of the magnitude of this 2D vector.</p>
			<p>3D vectors are similar to 2D vectors, but we also need to consider the value of the <em class="italic">z</em> axis. The magnitude of a 3D vector is the square root of <code>(x*x+y*y+z*z)</code>. </p>
			<p>Unity also provides the <code>Vector3</code> structure to represent 3D vectors and points. If you look at the Inspector window of a GameObject in the Scene, you will find that the <strong class="bold">Position</strong>, <strong class="bold">Rotation</strong>, and <strong class="bold">Scale</strong> properties of the object are all Vector3 types, as shown in the following figure:</p>
			<div><div><img src="img/Figure_7.15_B17146.jpg" alt="Figure 7.15 – Transform of a GameObject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15 – Transform of a GameObject</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/>Vector addition</h2>
			<p>Since vectors can be used to<a id="_idIndexMarker648"/> describe positions, they can also be used to describe positions that change over time. A moving object has a velocity, which is the speed of the object in a given direction.  </p>
			<div><div><img src="img/Figure_7.16_B17146.jpg" alt="Figure 7.16 – Vector addition&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16 – Vector addition</p>
			<p>As shown in <em class="italic">Figure 7.16</em>, suppose an object is currently located at point <strong class="bold">A</strong> and its velocity is (1, 1) per minute, which means the object will move in a direction that is 1 unit further on the <em class="italic">x</em> axis and 1 unit further on the <em class="italic">y</em> axis. So, we will add its current position vector to its velocity vector to calculate where it will end up after 1 minute: </p>
			<p><code>(6, 2) + (1, 1) = (7, 3)</code></p>
			<p>The new position of this object after 1 minute is (7, 3).</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>How to subtract vectors</h2>
			<p>Vector subtraction<a id="_idIndexMarker649"/> and vector addition are very similar. We can reverse the direction of the second vector and use vector addition. Let's still use the previous example. Suppose a moving object is currently located at point A and its velocity is (-1, -1) per minute, which means the object will move in a direction that is -1 unit further on the <em class="italic">x</em> axis and -1 unit further on the <em class="italic">y</em> axis.  </p>
			<div><div><img src="img/Figure_7.17_B17146.jpg" alt="Figure 7.17 – Vector subtraction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.17 – Vector subtraction</p>
			<p>Let's add its<a id="_idIndexMarker650"/> current position vector to its velocity vector to calculate where it will end up after 1 minute again:</p>
			<p><code>(6, 2) - (1, 1) = (6, 2) + (-1, -1) = (5, 1)</code></p>
			<p>The new position of this object after 1 minute is (5, 1).</p>
			<p>In Unity, we can add vectors and subtract vectors in C# code, as follows:</p>
			<pre>    private void Start()
    {
        var vector1 = new Vector3(1, 1, 1);
        var vector2 = new Vector3(1, 2, 3);
        var addVector = vector1 + vector2;
        var subVector = vector1 - vector2;
        Debug.Log($"Addition: {addVector}");
        Debug.Log($"Subtraction: {subVector}");
    }</pre>
			<p>In the previous code<a id="_idIndexMarker651"/> snippet, we created two 3D vectors, <code>(1, 1, 1)</code> and <code>(1, 2, 3</code>). Then, we added and subtracted them respectively and printed the results to the <strong class="bold">Console</strong> window.</p>
			<div><div><img src="img/Figure_7.18_B17146.jpg" alt="Figure 7.18 – Adding vectors and subtracting vectors&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.18 – Adding vectors and subtracting vectors</p>
			<p>In order to move <a id="_idIndexMarker652"/>objects in Unity, knowledge of vectors is needed. But sometimes we don't have to directly calculate the result of vector addition or subtraction in the code. This is because Unity provides us with the <code>Transform.Translate</code> function to move objects. Of course, we still need to pass a vector parameter to provide velocity:</p>
			<pre>    private void Update()
    {
        transform.Translate(_speed * Time.deltaTime *
          Vector3.forward);
    }</pre>
			<p>The preceding code snippet demonstrates how to move an object by calling the<code> Transform.Translate</code> function.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor131"/>Dot product</h2>
			<p>In addition to vector addition and vector subtraction, 3D vector operations commonly used in game development also include <strong class="bold">dot product</strong> operations and <strong class="bold">cross product</strong> operations. We will introduce them <a id="_idIndexMarker653"/>separately in this section and the next section.</p>
			<p>First, we will explore the dot product in Unity. The dot product or scalar product takes two vectors and returns a single scalar value. </p>
			<p>Suppose there are two 3D vectors, named <em class="italic">vector1</em> and <em class="italic">vector2</em>;<em class="italic"> </em>the calculation process of the dot product is very simple, as shown:</p>
			<p><code>scalar value = (x1 * x2) + (y1 * y1) + (z1 * z2)</code></p>
			<p>In game development, vector dot product operations are often used to find out whether these two vectors are perpendicular to each other. If the result of their dot product operation is 0, the two vectors are perpendicular to each other. If the result is positive, the angle between the two vectors is less than 90 degrees. If the result is negative, the angle between the two vectors is greater than 90 degrees.</p>
			<p>Next, we can create two <a id="_idIndexMarker654"/>3D vectors in the Unity Editor to demonstrate how to use the vector dot product operation.</p>
			<div><div><img src="img/Figure_7.19_B17146.jpg" alt="Figure 7.19 – Two 3D vectors in the Editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.19 – Two 3D vectors in the Editor</p>
			<p>As shown in <em class="italic">Figure 7.19</em>, the green line represents the first vector, which is (0, 5, 0), and the yellow line represents the other vector, which is (5, 0, 5). The result of the dot product operation of these two vectors is as follows:</p>
			<p><code>0 = (0 * 5) + (5 * 0) + (0 * 5)</code></p>
			<p>At the same time, we can see in <em class="italic">Figure 7.19</em> that these two vectors are perpendicular.</p>
			<p>If the first vector is (0, 5, 5), the result of the dot product operation of these two vectors will be as follows:</p>
			<p><code>25 = (0 * 5) + (5 * 0) + (5 * 5)</code></p>
			<p>As shown in <em class="italic">Figure 7.20</em>, the<a id="_idIndexMarker655"/> two vectors are not perpendicular this time, and the included angle is less than 90 degrees:</p>
			<div><div><img src="img/Figure_7.20_B17146.jpg" alt="Figure 7.20 – Two 3D vectors in the Editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.20 – Two 3D vectors in the Editor</p>
			<p>If the first <a id="_idIndexMarker656"/>vector is (0, 1, -1), the result of the dot product operation of these two vectors will be as follows:</p>
			<p><code>-5 = (0 * 5) + (1 * 0) + (-1 * 5)</code></p>
			<p>As shown in <em class="italic">Figure 7.21</em>, the two vectors are not perpendicular this time, and the included angle is greater than 90 degrees:</p>
			<div><div><img src="img/Figure_7.21_B17146.jpg" alt="Figure 7.21 – Two 3D vectors in the Editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21 – Two 3D vectors in the Editor</p>
			<p>Unity provides <a id="_idIndexMarker657"/>us with a function to calculate the result of the dot product of two 3D vectors, as follows:</p>
			<pre>public static float Dot(Vector3 lhs, Vector3 rhs);</pre>
			<p>It is a static function and we can call it directly in our C# code:</p>
			<pre>public class VectorTest : MonoBehaviour
{
    private Vector3 _vectorA = new Vector3(0, 1, -1);
    private Vector3 _vectorB = new Vector3(5, 0, 5);
    private void Start()
    {
        var result = Vector3.<strong class="bold">Dot</strong>(_vectorA, _vectorB);
        Debug.Log(result);
    }
}</pre>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor132"/>Cross product</h2>
			<p>On the other hand, the cross product<a id="_idIndexMarker658"/> takes two vectors as well but returns another vector instead of a single scalar value. This vector is perpendicular to both of the original two vectors.</p>
			<div><div><img src="img/Figure_7.22_B17146.jpg" alt="Figure 7.22 – Cross product (CC BY-SA 4.0)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22 – Cross product (CC BY-SA 4.0)</p>
			<p>Compared with the dot product, the calculation process of the cross product is more complicated. The preceding figure demonstrates this process.</p>
			<p>Unity also offers another <a id="_idIndexMarker659"/>helpful function to calculate the result of the cross product of two 3D vectors, as follows:</p>
			<pre>public static Vector3 Cross(Vector3 lhs, Vector3 rhs);</pre>
			<p>It is a static function and we can call it directly in our C# code:</p>
			<pre>    void FixedUpdate()
    {
        var vector1 = new Vector3(0, 1, 0);
        var vector2 = new Vector3(1, 0, 1);
        Debug.DrawLine(Vector3.zero, vector1, Color.green);
        Debug.DrawLine(Vector3.zero, vector2,
          Color.yellow);
        var resultVector = Vector3.Cross(vector1, vector2);
        Debug.DrawLine(Vector3.zero, resultVector,
          Color.cyan);
    }</pre>
			<p>In this code snippet, we <a id="_idIndexMarker660"/>calculate the result of the cross product of vector1 and vector2 and at the same time, we also draw these three vectors in the Unity Editor, as shown in the following figure:</p>
			<div><div><img src="img/Figure_7.23_B17146.jpg" alt="Figure 7.23 – Cross product&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23 – Cross product</p>
			<p>In this section, we introduced vectors and explored how to use vectors correctly in Unity scripts. Next, let's continue to explore another important concept in computer graphics, namely matrices.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor133"/>Working with the transformation matrix </h1>
			<p>In game<a id="_idIndexMarker661"/> development, the <strong class="bold">transformation matrix</strong> is also a common term. Specifically, we use the transformation matrix to encode transformations, including translation, rotation, and scaling transforms.</p>
			<p>Unity provides us with the Matrix4x4 struct in C# to represent a standard 4x4 transformation matrix. </p>
			<div><div><img src="img/Figure_7.24_B17146.jpg" alt="Figure 7.24 – A 4x4 matrix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.24 – A 4x4 matrix</p>
			<p>As shown in <em class="italic">Figure 7.24</em>, a transformation matrix is a grid of numbers. Although it is a common term, we rarely use this matrix directly in scripts. This is because the calculation of the matrix is relatively cumbersome, and Unity, as an easy-to-use game engine, has encapsulated the complex calculations in the <code>Transform</code> class for us, and we only need to<a id="_idIndexMarker662"/> call some functions. Therefore, in this section, we only give a brief introduction to the transformation matrix. </p>
			<p>Before we start, you should know that transformations include translation, rotation, scaling, and these operations can be represented as matrices. We will discuss them one by one in the following subsections.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/>Translation matrix</h2>
			<p>We can move an object by <a id="_idIndexMarker663"/>using a translation matrix. The following diagram shows a translation matrix and how to move the original vector by multiplying the translation matrix:</p>
			<div><div><img src="img/Figure_7.25_B17146.jpg" alt="Figure 7.25 – Translation matrix (CC BY 4.0)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.25 – Translation matrix (CC BY 4.0)</p>
			<p>Let's create a C# script and demonstrate how to move an object by using a matrix directly in Unity:</p>
			<pre>using UnityEngine;
public class MatrixTest : MonoBehaviour
{
    void Start()
    {
        var translationMatrix = new <strong class="bold">Matrix4x4</strong>(
            new Vector4<strong class="bold">(1, 0, 0, 0)</strong>,
            new Vector4(0, 1, 0, 0),
            new Vector4(0, 0, 1, 0),
            new Vector4(3, 2, 1, 1)
        );
        var newPosition =
          translationMatrix.<strong class="bold">MultiplyPoint</strong>
<strong class="bold">          </strong>(transform.position);
        transform.position = newPosition;
    }
}</pre>
			<p>As you can see in this <a id="_idIndexMarker664"/>code snippet, we used four <code>Vector4</code> instances to create an instance of the <code>Matrix4x4</code> struct. It should be noted here that each <code>Vector4</code> we used to create the matrix represents a column of the matrix, not a row. Therefore, the code creates a matrix, as shown in the following figure:</p>
			<div><div><img src="img/Figure_7.26_B17146.jpg" alt="Figure 7.26 – Creating a matrix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.26 – Creating a matrix</p>
			<p>Then, we calculated <a id="_idIndexMarker665"/>the new position of the object by calling the <code>MultiplyPoint</code> function of <code>Matrix4x4</code>, where the parameter is the original position of the object. Finally, we set the position of the object to this new vector.</p>
			<div><div><img src="img/Figure_7.27_B17146.jpg" alt="Figure 7.27 – Changing the position of the object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.27 – Changing the position of the object</p>
			<p>If we create an object at the origin and run this script, the result will be that the object is moved to the point (3, 2, 1), as shown in <em class="italic">Figure 7.27</em>.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/>Rotation matrix</h2>
			<p>Similarly, a matrix can also be used to<a id="_idIndexMarker666"/> rotate an object, that is, a rotation matrix. This time, we also need to create an instance of <code>Matrix4x4</code> in the C# script, but instead of calling its constructor, we call this function:</p>
			<pre>public static Matrix4x4 Rotate(Quaternion q);</pre>
			<p>The <code>Rotate</code> function is a static function of <code>Matrix4x4</code>, and it creates and returns a rotation matrix. This function requires a quaternion-type parameter. We will introduce quaternions in the next section.</p>
			<p>Now, let's write some code to rotate the object by using <code>Matrix4x4</code>:</p>
			<pre>        var rotation = <strong class="bold">Quaternion.Euler</strong>(0, 90, 0);
        var rotationMatrix = Matrix4x4.<strong class="bold">Rotate</strong>(rotation);
        var newPosition =
          rotationMatrix.MultiplyPoint(transform.position);
        transform.position = newPosition;</pre>
			<p>This code will move the <a id="_idIndexMarker667"/>point from its original position to a place rotated 90 degrees around the <em class="italic">y</em> axis.</p>
			<div><div><img src="img/Figure_7.28_B17146.jpg" alt="Figure 7.28 – Rotation matrix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.28 – Rotation matrix</p>
			<p>Let's set the original position of this object to (1, 0, 0) and then run the code. The new position of this object should be (0, 0, -1), as shown in the preceding figure.</p>
			<div><div><img src="img/Figure_7.29_B17146.jpg" alt="Figure 7.29 – The real result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.29 – The real result</p>
			<p>After running the code, we can see that the real result is consistent with what we expected.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/>Scaling matrix</h2>
			<p>When we scale a <a id="_idIndexMarker668"/>vector, we will keep its direction unchanged and change the length by the amount we want to scale. We can also use a scaling matrix to scale a point away from the origin. You can imagine that a model is composed of many vertices. When we scale a model, we actually extend or shrink the positions of the vertices that make it up. </p>
			<p>Unity also provides us with the following function to directly create a scaling matrix in a C# script:</p>
			<pre>public static Matrix4x4 Scale(Vector3 vector);</pre>
			<p>The <code>Matrix4x4</code>, and it creates and returns a scaling matrix:</p>
			<pre>    private void ScalingMatrixTest()
    {
        var scale = new Vector3(3, 2, 1);
        var scalingMatrix = Matrix4x4.<strong class="bold">Scale</strong>(scale);
        var newPosition =
          scalingMatrix.<strong class="bold">MultiplyPoint</strong>(transform.position);
        transform.position = newPosition;
    }</pre>
			<p>In order to demonstrate how to apply a scaling matrix to a point, we created the preceding code snippet. As you can see in the code, we created a new <code>Vector3</code> to present the scaling factors. Then, we created a scaling matrix by calling the <code>Matrix4x4.Scale</code> function and finally, we applied this matrix to a point.</p>
			<p>Let's create a new GameObject in the Scene and locate this GameObject at the position (1, 1, 0). </p>
			<div><div><img src="img/Figure_7.30_B17146.jpg" alt="Figure 7.30 – GameObject at (1, 1, 0)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.30 – GameObject at (1, 1, 0)</p>
			<p>Then, attach<a id="_idIndexMarker669"/> this script to it and run the script.</p>
			<div><div><img src="img/Figure_7.31_B17146.jpg" alt="Figure 7.31 – Apply the scaling matrix to this object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.31 – Apply the scaling matrix to this object</p>
			<p>As shown in <em class="italic">Figure 7.31</em>, the new position of this object is (3, 2, 0). This is because this scaling matrix increases the point three times along the <em class="italic">x</em> axis from its original position and two times along the <em class="italic">y</em> axis.</p>
			<div><div><img src="img/Figure_7.32_B17146.jpg" alt="Figure 7.32 – Scaling a point&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.32 – Scaling a point</p>
			<p>As we mentioned<a id="_idIndexMarker670"/> at the beginning of this section, in Unity development, matrix operations are relatively low-level operations. Unity has provided us with many functions to cover up the complexity of matrices. Developers don't often use matrices directly, but as an important concept, we still need to understand some concepts around them. However, when it comes to object rotation, Unity often uses another type to save rotation data. If you are interested in this, let's continue to explore <strong class="bold">quaternions</strong>.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor137"/>Working with quaternions</h1>
			<p>In Unity, the rotation <a id="_idIndexMarker671"/>of a transform is stored internally as a <strong class="bold">quaternion</strong>, which has four componenets, namely <em class="italic">x</em>, <em class="italic">y</em>, <em class="italic">z</em>, and <em class="italic">w</em>. However, these four components do not represent angles or axes, and we developers usually do not need to access them directly. You may be confused because if you look at the Inspector window of a transform, you will find the rotation is displayed as a Vector3.</p>
			<div><div><img src="img/Figure_7.33_B17146.jpg" alt="Figure 7.33 – Rotation property in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.33 – Rotation property in the Inspector window</p>
			<p>This is because although Unity uses quaternions to store rotations internally, in addition to quaternions, rotations can<a id="_idIndexMarker672"/> also be represented by three angle values of <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em>, namely <strong class="bold">Euler angles</strong>.</p>
			<p>Therefore, for the convenience of developers to edit, Unity displays the value of the equivalent Euler angle in the Inspector. </p>
			<p>So, why doesn't Unity use Euler angles to store rotations directly? It is composed of three axes angles and is in a format that is easy for humans to read. This is because the Euler angle is affected by the <strong class="bold">gimbal lock</strong>, which <a id="_idIndexMarker673"/>means that the "degree of freedom" is lost.</p>
			<p>On the other hand, using quaternion rotation will not cause the gimbal lock issue. Therefore, Unity<a id="_idIndexMarker674"/> uses quaternions to store rotations internally. But what you have to remember is that the four components of a quaternion do not represent angles, so we will not modify the value of a component individually, and it is very complicated to modify a quaternion directly. Fortunately, Unity provides us with many built-in C# functions in the <code>Quaternion</code> struct to manage quaternion rotations easily. It is our best choice to use the <code>Quaternion</code> structure and its functions to manage the rotation values in Unity. </p>
			<p>We can divide these functions into three groups according to their purpose, namely creating rotations, manipulating rotations, and working with Euler angles. Let's explore them next.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor138"/>Creating rotations</h2>
			<p>The first function <a id="_idIndexMarker675"/>we will introduce is <code>LookRotation</code> and the function signature of this function is as follows:</p>
			<pre>public static <strong class="bold">Quaternion</strong> LookRotation(<strong class="bold">Vector3</strong> forward,
  [DefaultValue("Vector3.up")] Vector3 upwards);</pre>
			<p>This is a static function; you can pass in parameters to specify the forward and upward direction for it, and it will return the correct rotation value according to the passed-in parameters.</p>
			<p>In the following example, we set up a Scene in which there are two objects, named <code>target</code> and <code>player</code>, and created a new C# script called <code>LookAtScript.cs</code>. We then attached this script to the player object, as shown in <em class="italic">Figure 7.34</em>. The blue cube represents the player and the red sphere represents the target object:</p>
			<div><div><img src="img/Figure_7.34_B17146.jpg" alt="Figure 7.34 – Objects in the Scene &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.34 – Objects in the Scene </p>
			<p>In the following<a id="_idIndexMarker676"/> script, we demonstrate how to implement the function that the player always faces the target object no matter where the target moves:</p>
			<pre>using UnityEngine;
public class LookAtTest : MonoBehaviour
{
    [SerializeField] private Transform _targetTransform;
    private void Update()
    {
        if (_targetTransform == null) return;
        var dir = _ targetTransform.position –
          transform.position;
        transform.rotation = Quaternion.<strong class="bold">LookRotation</strong>(dir);
    }
}</pre>
			<p>First, we calculated the direction from the player to the target. Next, we called the <code>Quaternion.LookRotation</code> function to calculate the rotation value.</p>
			<div><div><img src="img/Figure_7.35_B17146.jpg" alt="Figure 7.35 – The player facing the target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.35 – The player facing the target</p>
			<p>Finally, we <a id="_idIndexMarker677"/>moved the target object and the player also moved to face the target, as shown in <em class="italic">Figure 7.35</em>.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor139"/>Manipulating rotations</h2>
			<p>There are some<a id="_idIndexMarker678"/> functions that are used to manipulate rotations and <code>Quaternion.Slerp</code> is one of them. The following is the function signature of it:</p>
			<pre>public static <strong class="bold">Quaternion</strong> Slerp(<strong class="bold">Quaternion</strong> a, <strong class="bold">Quaternion</strong> b, 
  <strong class="bold">float</strong> t);</pre>
			<p>This is a static function. The result of calling <code>Quaternion.Slerp</code> is that the object will start to rotate, slower, then faster in the middle.</p>
			<p>In the following example, we still use the Scene we set up earlier, this time creating a new C# script called <code>OrbitScript.cs</code>. Then, we will attach this script to the player object to implement a gravity orbit effect. </p>
			<div><div><img src="img/Figure_7.36_B17146.jpg" alt="Figure 7.36 – Attaching the script to the GameObject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.36 – Attaching the script to the GameObject</p>
			<p>The code<a id="_idIndexMarker679"/> of <code>OrbitScript.cs</code> is as follows:</p>
			<pre>using UnityEngine;
public class OrbitScript : MonoBehaviour
{
    [SerializeField] private Transform _target;
    void Update()
    {
        if (_target == null) return;
        var dir = _target.position - transform.position;
        var targetRotation = Quaternion.LookRotation(dir);
        var currentRotation = transform.localRotation;
        transform.localRotation =
          Quaternion.<strong class="bold">Slerp</strong>(currentRotation, targetRotation,
          Time.deltaTime);
        transform.<strong class="bold">Translate</strong>(0, 0, 5 * Time.deltaTime);
    }
}</pre>
			<p>In this script, we <a id="_idIndexMarker680"/>reused some code from <code>LookAtScript.cs</code>. We also first calculated the angle of the player toward the target. But unlike the previous script, we did not directly modify the player's rotation, but saved the target rotation and the player's current rotation with two temporary variables, namely <code>targetRotation</code> and <code>currentRotation</code>. Then, the <code>Quaternion.Slerp</code> function was called to make the player gradually turn to the target, which is also the key to achieving the effect of gravity orbit. Finally, we called the <code>transform.Translate</code> function to keep the player moving forward.</p>
			<div><div><img src="img/Figure_7.37_B17146.jpg" alt="Figure 7.37 – Running the game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.37 – Running the game</p>
			<p>If we run the game, we will find that the player will move around the target and turn to face the target, as shown in <em class="italic">Figure 7.37</em>.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/>Working with Euler angles</h2>
			<p>If in some cases you prefer <a id="_idIndexMarker681"/>to use Euler angles instead of quaternions, Unity allows you to convert Euler angles to a quaternion, but you should not retrieve Euler angles from a quaternion and apply it to the quaternion after modifying it, because this may cause problems. </p>
			<p><code>Quaternion.Euler</code> is one of these functions that we can use to convert Euler angles into quaternions. The following is its function signature:</p>
			<pre>public static <strong class="bold">Quaternion</strong> Euler(<strong class="bold">Vector3</strong> euler);</pre>
			<p>This function requires a <code>Vector3</code>-type parameter, which provides the angle around the <em class="italic">x</em> axis, the angle around the <em class="italic">y</em> axis, and the angle around the <em class="italic">z</em> axis. Based on this data, this function returns the corresponding quaternion rotation.</p>
			<p>The following code<a id="_idIndexMarker682"/> snippet demonstrates how to use Euler angles in the script correctly:</p>
			<pre>using UnityEngine;
public class EulerAnglesTest : MonoBehaviour
{
    private float _xValue;
    private void Update()
    {
        _xValue += Time.<strong class="bold">deltaTime</strong> * 5;
        var <strong class="bold">euler</strong>Angles = new Vector3(_xValue, 0, 0);
        transform.rotation = Quaternion.<strong class="bold">Euler</strong>(eulerAngles);
    }
}</pre>
			<p>In the code, we created Euler angles that rotate around the <em class="italic">x</em> axis, and then called the <code>Quaternion.Euler</code> function to convert Euler angles into quaternions. </p>
			<div><div><img src="img/Figure_7.38_B17146.jpg" alt="Figure 7.38 – Converting Euler angles into quaternions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.38 – Converting Euler angles into quaternions</p>
			<p>Attach this script to <a id="_idIndexMarker683"/>a cube and run the game. You will find the cube rotates around the <em class="italic">x</em> axis.</p>
			<p>In this section, we introduced you to quaternions and explored how to use quaternions correctly in Unity scripts. It should be noted that in Unity, rotation can not only be represented by quaternions, but also by Euler angles. When Euler angles are used to represent rotation, its format is easy for humans to read, but due to the influence of the gimbal lock, Unity still uses quaternions to save rotations internally.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor141"/>Summary</h1>
			<p>This chapter first introduced the concept of the coordinate system in computer graphics, and then discussed the coordinate system used by Unity. Then, we discussed the concept of vectors and how to perform vector operations such as vector addition, vector subtraction, dot product, and cross product in Unity. </p>
			<p>We also introduced the concept of a matrix and demonstrated how to use a matrix to translate, rotate, and scale in Unity.</p>
			<p>Finally, we explored how to create rotations and manipulate rotations in quaternions, and demonstrated how to use Euler angles in the script correctly.</p>
			<p>By reading this chapter, you should now have a bit more mathematical knowledge about computer graphics. In the next chapter, we will introduce the Scriptable Render Pipeline in Unity.</p>
		</div>
	</body></html>