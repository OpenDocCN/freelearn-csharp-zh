<html><head></head><body>
		<div id="_idContainer033">
			<h1 class="chapter-number" id="_idParaDest-180"><a id="_idTextAnchor181"/>8</h1>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>The One with the  Network Navigation</h1>
			<p><em class="italic">Building High-Performance </em><span class="No-Break"><em class="italic">Networking Applications</em></span></p>
			<p>Software seldom lives in isolation. The same can be said, to a greater extent for system programs. Since these programs do not directly interact with the user, they rely on other software to give them input, read their output, and be told what to do. That “other software” often lives on the same machine, but just as often, that software <span class="No-Break">runs elsewhere.</span></p>
			<p>We have so far discussed how to transfer data to and from our applications and briefly looked at networking. This chapter focuses on that specific topic: networking. Be prepared to go deeply into the world of <span class="No-Break">interconnected software!</span></p>
			<p>In this chapter, we will go through the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>The fundamentals and the <span class="No-Break">OSI layers</span></li>
				<li>Exploring the System.Net namespace (including the most <span class="No-Break">used protocols)</span></li>
				<li>Working with System.Net.Sockets to have <span class="No-Break">more control</span></li>
				<li>Asynchronous, <span class="No-Break">non-blocking networking</span></li>
				<li>How to improve <span class="No-Break">networking performance</span></li>
				<li>Networking errors and time-out, and how to deal <span class="No-Break">with those</span></li>
			</ul>
			<p>We are about to break out of the box and connect to the outside world. <span class="No-Break">Let’s go!</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor183"/>Technical requirements</h1>
			<p>All of the code samples for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>The fundamentals</h1>
			<p>We have already talked about the OSI model. But just as a quick refresher, the OSI model defines the layers that make up the system, allowing us to communicate with other systems. The layers span from the lowest layer, which describes the voltages a network adapter should be able to handle, up to the highest level, which describes the application that <span class="No-Break">uses networking.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>A walk down the OSI layers</h2>
			<p>I want to<a id="_idIndexMarker586"/> walk you through all the layers again, detailing what happens in each. To do this, I want to discuss a user using FTP to send <a id="_idIndexMarker587"/>data. <strong class="bold">FTP</strong>, which stands for <strong class="bold">File Transfer Protocol</strong>, is an older, hardly used technique to send data to remote machines or to get data from those <span class="No-Break">remote machines.</span></p>
			<p>FTP used to be the best way to achieve that, but the lack of security features made people move to other means. We will discuss some of those later, but we can still use FTP for our walk-down of the OSI model. It makes things a bit easier <span class="No-Break">to understand.</span></p>
			<p>An FTP client can be as simple as a console application. Actually, almost all FTP clients are just that. There are GUI-based clients, but they act as wrappers around the <span class="No-Break">FTP commands.</span></p>
			<p>To transfer a file, a user fires up the FTP client, specifies the server to connect to, and optionally passes in the credentials. Then, the user uses commands such as <strong class="source-inline">GET</strong> and <strong class="source-inline">PUT</strong> to transfer the file. Another command is <strong class="source-inline">LS</strong>, which is used to get the contents of a remote directory. We also have <strong class="source-inline">MKDIR</strong> to create a remote directory and other <span class="No-Break">such commands.</span></p>
			<p>So, let us assume that the user is sitting at their machine and wants to log in to the remote computer. To do that, the user types <strong class="source-inline">ftp username:password@127.0.0.1</strong> at the command prompt. This does a <span class="No-Break">few things:</span></p>
			<ol>
				<li>It starts up the command-line version <span class="No-Break">of FTP</span></li>
				<li>Then it tells it to connect to a computer found at address 127.0.0.1 (which is, as you probably <span class="No-Break">remember, localhost)</span></li>
				<li>It supplies a username and a password that the <span class="No-Break">server needs.</span></li>
			</ol>
			<p>After a few<a id="_idIndexMarker588"/> seconds, the client lists all files in the requested location. But what happens in the computer when the user presses the <span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break"> key?</span></p>
			<p>After starting the application, the FTP client <span class="No-Break">takes over.</span></p>
			<p>The commands and data flow through the OSI levels. Let me show you <span class="No-Break">what happens:</span></p>
			<ul>
				<li><strong class="bold">Layer 7</strong>: The application runs on OSI level 7, the application level. The FTP protocol in the application then sets up the connection. FTP creates two connections: one for control commands and one for <span class="No-Break">data transfer.</span></li>
				<li><strong class="bold">Layer 6</strong>: In the presentation layer, the system converts the commands into the appropriate format. In this case, it is simple: the <strong class="source-inline">open</strong> command is translated from whatever string format it was into an 8-bit ASCII format. If encryption is needed, that is also taken care of here. After all, layer 6 is all about how to present <span class="No-Break">the data.</span></li>
				<li><strong class="bold">Layer 5</strong>: The session layer then takes over. This layer is where the actual connection to the remote machine is made. This layer keeps an eye on the connection to make sure it is reliable and stable. It also closes the connection when it is no <span class="No-Break">longer needed.</span></li>
				<li><strong class="bold">Layer 4</strong>: After that, the transport layer makes sure the data containing the command is broken into smaller packets and sends them out in the correct order. FTP uses TCP, meaning layer 4 is responsible for rearranging data packets that are out of order when data is received. Error checking is also something that <span class="No-Break">happens here.</span></li>
				<li><strong class="bold">Layer 3</strong>: The network layer is where the <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) lives. This protocol in layer 3 is responsible for finding the best route to the remote machine. It also handles packet forwarding <span class="No-Break">and rerouting.</span></li>
				<li><strong class="bold">Layer 2</strong>: Then, we <a id="_idIndexMarker589"/>get to the data link layer. This layer adds data to the packets, such as the MAC address of the next machine the data needs to get to. It is responsible for node-to-node communication. If you use Wi-Fi, this layer prepares the data to be sent over the <span class="No-Break">radio waves.</span></li>
				<li><strong class="bold">Layer 1</strong>: Finally, we reach the physical layer. This last layer is where the data is actually transmitted. This layer translates the data into radio signals if you use Wi-Fi. It deals with all the hardware issues, such as the frequencies used and the strength of <span class="No-Break">the signal.</span></li>
			</ul>
			<p>Luckily, most of this is done at the OS or BIOS level. We do not have to worry about frequencies when setting up a network connection. We usually deal with <strong class="bold">layers 7</strong> and <strong class="bold">6</strong>, and sometimes <strong class="bold">5</strong>. We write the application (<strong class="bold">layer 7</strong>). We define the presentation (<strong class="bold">layer 6</strong>) if we have our own protocol. And we might sometimes have to worry about the actual connections, so we deal with <strong class="bold">layer </strong><span class="No-Break"><strong class="bold">5</strong></span><span class="No-Break"> occasionally.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The BCL and the CLR have many classes, tools, and helpers, allowing us to focus on the fun without worrying about the details. But sometimes, as system programmers, we must worry about those details. These details can be the difference between a great, fast, and stable system and a mediocre one. But do not worry: we cover it all here in <span class="No-Break">this chapter!</span></p>
			<p>Before we can do that, let us look at commonly used ways to transmit data over <span class="No-Break">a network.</span></p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>Exploring the System.Net namespace</h1>
			<p>Chances are, if you <a id="_idIndexMarker590"/>need a way to transmit data, someone else has already figured out the best way to <span class="No-Break">do this.</span></p>
			<p>For instance, you could write all the code to transfer a file to and from a machine or use FTP and rely on <span class="No-Break">existing software.</span></p>
			<p>In fact, there are<a id="_idIndexMarker591"/> many ways to transfer data. Many of those ways are so standardized that they are part of the BCL. You can use them without dealing with third-party NuGet packages. Let us discuss some of the offerings in the System.Net namespace and see what we can do <span class="No-Break">with them.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>Understanding HTTP/HTTPS</h2>
			<p>HTTP was <a id="_idIndexMarker592"/>the protocol that enabled millions of users to finally use the internet. Before HTTP, the only way to exchange data was through technically complicated protocols, most of which had to be controlled through the command line. When Sir Tim Berners-Lee published his ideas about the World Wide Web and the <a id="_idIndexMarker593"/>accompanying <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>), people with little or no technical background could also use the net. Web browsers made it easy to go around and find information. Of course, when I say easy, I mean easier than before. In the early 1990s, we had no Google or Bing, so finding interesting sites was a struggle compared <span class="No-Break">to today.</span></p>
			<p><em class="italic">HTTP democratized the internet</em>. Before that, it was the realm of scientists and the military, with a few nerds sprinkled in for good measure. Yes, I was one of those nerds: I first used the internet through SMTP, Gopher, FTP, and Usenet in 1987. HTTP and the WWW made it all so <span class="No-Break">much easier.</span></p>
			<p>Programming for it was not that easy. However, with the current frameworks, getting data from an arbitrary site anywhere on the globe only takes a couple of lines of code. Let me <span class="No-Break">show you:</span></p>
			<pre class="source-code">
using var client = new HttpClient();
try
{
    string url =
        "https://jsonplaceholder.typicode.com/posts";
    HttpResponseMessage response =
        await client.GetAsync(url);
    response.EnsureSuccessStatusCode();
    string responseBody =
        await response.Content.ReadAsStringAsync();
    responseBody.Dump(ConsoleColor.Cyan);
}
catch(HttpRequestException ex)
{
    ex.Message.Dump(ConsoleColor.Red);
}</pre>			<p>In the <a id="_idIndexMarker594"/>first line, we<a id="_idIndexMarker595"/> create an instance of the <strong class="source-inline">HttpClient</strong> class. This class is a helpful little helper: it takes away much of the complexity of the older <strong class="source-inline">HttpWebRequest</strong>. Although <strong class="source-inline">HttpWebRequest</strong> does offer some advantages over <strong class="source-inline">HttpClient</strong> (for instance, more control over the headers, the option to set time-outs, and the ability to use synchronous data transfers if needed), <strong class="source-inline">HttpClient</strong> is by far the <span class="No-Break">better choice.</span></p>
			<p class="callout-heading">Testing with dummy servers</p>
			<p class="callout">If you want to play around with HTTP and HTTPS, you need a reliable and easy-to-use website to connect to. The <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a> URL is a great site to use in those cases. It gives you several endpoints to connect to, read from, and send data to. It is simple to use, and it is free. Please have a look at that site to see what <span class="No-Break">it offers.</span></p>
			<p>After declaring the URL, we call the <strong class="source-inline">GetAsync</strong> method with that URL. This asynchronous operation returns an instance of the <strong class="source-inline">HttpResponseMessage</strong> class. That class contains all we need to read the data from the <span class="No-Break">remote server.</span></p>
			<p>The next call is just a shorthand for some straightforward error checking. Calling <strong class="source-inline">EnsureSuccessStatusCode</strong> does very little besides looking at the return code from the server, and it throws an error if it is not in the 200 range. As you probably know, HTTP requests return a numeric status code that tells you what the result of the call is. Everything between 200 and 299 means your call worked. Codes such as 404 mean the site is unreachable, and <span class="No-Break">so on.</span></p>
			<p>This single method makes your code much more readable than <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> statements.</span></p>
			<p>If all is okay, we continue by reading the actual data. The response has several properties, one of which is <strong class="source-inline">Content</strong>. Other properties are the status code, the headers, and <span class="No-Break">so on.</span></p>
			<p><strong class="source-inline">Content</strong>, of type <strong class="source-inline">HttpContent</strong>, is a wrapper around <strong class="source-inline">Stream</strong> that allows us to read data from the<a id="_idIndexMarker596"/> server. In our case, we call <strong class="source-inline">ReadAsStringAsync</strong>, which takes all data the server can give us and returns that to us as a string. Of course, this all <span class="No-Break">happens asynchronously.</span></p>
			<p>Finally, we display that string on <span class="No-Break">the console.</span></p>
			<p>This is the <a id="_idIndexMarker597"/>simplest example of using HTTP I can think of. All classes shown here have many more use cases, methods, and helpers that can benefit you. I suggest you look at the documentation of <strong class="source-inline">HttpClient</strong>, <strong class="source-inline">HttpResponseMessage</strong>, <strong class="source-inline">HttpContent</strong>, and the rest to see what else you can do with them. In the meantime, let’s look at some <span class="No-Break">other protocols.</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/>FTP</h2>
			<p>We saw <a id="_idIndexMarker598"/>FTP before. I used it to illustrate the flow of actions through the OSI model. But we never thoroughly explored what we can do <span class="No-Break">with it.</span></p>
			<p>FTP is an older <a id="_idIndexMarker599"/>technology. It is not in use that much anymore, but it is still beneficial. It is a quick, easy-to-understand technology to transfer files between machines and control remote file systems, regardless of the underlying operating system. It is fast and reliable. Most operating systems support FTP both as a client and as <span class="No-Break">a server.</span></p>
			<p>In Windows, you can enable the FTP server by going to the <strong class="bold">Program and Features</strong> section of the settings in the control panel, and there, under <strong class="bold">Internet Information Services</strong>, you can see the option to install the FTP server. Alternatively, you can click <em class="italic">Win</em> + <em class="italic">R</em> and then enter the optional features. See <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em> to see what it <span class="No-Break">looks like.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 8.1: Installing FTP Server on Windows" src="image/B20924_09_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Installing FTP Server on Windows</p>
			<p>However, make<a id="_idIndexMarker600"/> sure you know what you are doing. One of the<a id="_idIndexMarker601"/> reasons we do not use FTP that much anymore is that it is not secure by default. To transfer files, it would be better to use something such as SFTP, which is a <span class="No-Break">secure version.</span></p>
			<p>But good old FTP is still your friend if you want to communicate in a secure environment (such as in a Kubernetes cluster) and transfer files quickly <span class="No-Break">and easily.</span></p>
			<p>So, how do you read the contents of a remote directory? Simple: use this piece <span class="No-Break">of code!</span></p>
			<pre class="source-code">
public static void FetchDirectoryContents(string ftpUrl, string username, string password)
{
    var request = (FtpWebRequest) WebRequest.Create(ftpUrl);
    request.Method = WebRequestMethods.Ftp.ListDirectoryDetails;
    request.Credentials = new NetworkCredential(username, password);
    try
    {
        using (var response = (FtpWebResponse) request.GetResponse())
        {
            using (var streamReader = new StreamReader(response.GetResponseStream()))
            {
                var line = string.Empty;
                while ((line = streamReader.ReadLine()) != null)                   Console.WriteLine(line);
            }
            $"Directory List Complete, status {response.               StatusDescription}".Dump(ConsoleColor.Cyan);
        }
    }
    catch (WebException ex)
    {
        var status = ((FtpWebResponse) ex.Response).StatusDescription;
        $"Error: {status}".Dump(ConsoleColor.Red);
    }
}</pre>			<p>As you can see, the code here is pretty straightforward. We create an instance of <strong class="source-inline">WebRequest</strong> and cast it to a subclass: <strong class="source-inline">FtpWebRequest</strong>. We specify what we want to do by setting the method to <strong class="source-inline">ListDirectoryDetails</strong>. We add some credentials if needed and <a id="_idIndexMarker602"/>get a stream containing the data we need. Of course, we handle exceptions <span class="No-Break">as well.</span></p>
			<p>Great! But wait… this is actually not <span class="No-Break">so great.</span></p>
			<p>If you do this in your <a id="_idIndexMarker603"/>editor, you will see warnings: <strong class="source-inline">WebRequest</strong> (and thus <strong class="source-inline">FtpWebRequest</strong>) has been marked obsolete. They have been superseded by the much better <strong class="source-inline">HttpClient</strong>. Unfortunately, that one cannot be used with FTP sites: it is only meant for <span class="No-Break">HTTP traffic.</span></p>
			<p>I believe Microsoft made a mistake here. But it is their framework, so they can do what they want. The good news is that plenty of NuGet packages can do what we want them to do. One is <em class="italic">FluentFtp</em>, which you can find at the <a href="https://github.com/robinrodricks/FluentFTP">https://github.com/robinrodricks/FluentFTP</a> URL. Here, I would like to mention that I am not affiliated with this or any other NuGet package I mention in this book; these are just the packages I use. Of course, many different options are available, so just pick whatever works <span class="No-Break">for you.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/>Email protocols</h2>
			<p>HTTP is<a id="_idIndexMarker604"/> the most used protocol on the public-facing internet, both in the number of servers handling it and in the percentage of data dealt with. But second to <a id="_idIndexMarker605"/>that is SMTP. <strong class="bold">SMTP</strong>, which stands for <strong class="bold">Simple Mail Transfer Protocol</strong>, is used <a id="_idIndexMarker606"/>for email. SMTP is just one of the protocols related to emails. Let’s look into each one <span class="No-Break">of those:</span></p>
			<ul>
				<li><strong class="bold">SMTP</strong>: The Simple Mail Transfer Protocol is <a id="_idIndexMarker607"/>used to send mail over the Internet. It is connection-oriented, meaning its primary task is to ensure a connection between the client sending the mail and the server processing it. It is reliable (meaning it can be recovered if data is lost <span class="No-Break">in transit).</span></li>
				<li><strong class="bold">POP3</strong>: POP3 is<a id="_idIndexMarker608"/> the third iteration of the <strong class="bold">Post Operation Protocol</strong>. This<a id="_idIndexMarker609"/> protocol deals with the other side: SMTP ensures the mail gets delivered to the server, and POP3 allows the users to read their mail from the server. POP3 allows for offline access to email, but<a id="_idIndexMarker610"/> it can only access one mailbox at a time. If you want to read multiple mailboxes (or accounts, if you will), you need to set up more than one <span class="No-Break">POP3 connection.</span></li>
				<li><strong class="bold">IMAP</strong>: IMAP<a id="_idIndexMarker611"/> stands for <strong class="bold">Internet Message Access Protocol</strong>. This<a id="_idIndexMarker612"/> protocol is also meant to read mail from the server. But this protocol can read multiple mailboxes in one go. IMAP can access, search, manipulate, and delete your emails without downloading them. It can send these commands to the server in an RPC way (we discussed RPC extensively in <a href="B20924_08.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">).</span></li>
				<li><strong class="bold">MIME</strong>: Despite <a id="_idIndexMarker613"/>not having a P at the end of the acronym, <strong class="bold">MIME</strong> is also a protocol. It is<a id="_idIndexMarker614"/> the acronym for <strong class="bold">Multipurpose Internet Mail Extension</strong> protocol. As the name suggests, it is an extension, allowing us to have attachments, multimedia, and non-ASCII characters in our <span class="No-Break">mail messages.</span></li>
			</ul>
			<p>All these protocols enable us to have a functional, complete <span class="No-Break">mail experience.</span></p>
			<h3>Sending an email</h3>
			<p>That<a id="_idIndexMarker615"/> being said, most software sends mail messages; it hardly ever reads them. So, let’s look at a simple sample of how to send an email in code. The sample code I provide consists of three parts. Let’s look <span class="No-Break">at them:</span></p>
			<pre class="source-code">
using System.Net.Mail;
// Create the mail message
MailMessage mail = new MailMessage();
mail.From = new MailAddress("dennis@vroegop.org");
mail.To.Add("dearreader@thisbook.com");
mail.Subject = "Hi there System Programmer!";
mail.Body =
    "This is a test email from the System Programming
      book.";</pre>			<p>Obviously, we need a message. Otherwise, why would we connect to an <span class="No-Break">SMTP server?</span></p>
			<p>The message is of type <strong class="source-inline">MailMessage</strong>. It needs a sender, and it can have multiple recipients. Those recipients can be in the <strong class="source-inline">To</strong>, <strong class="source-inline">CC</strong>, or <strong class="source-inline">BCC</strong> fields. <strong class="source-inline">To</strong>, <strong class="source-inline">CC</strong>, and <strong class="source-inline">BCC</strong> are all lists, so you can add multiple recipients. Of course, you need to supply at least the <span class="No-Break"><strong class="source-inline">To</strong></span><span class="No-Break"> recipients.</span></p>
			<p>We can<a id="_idIndexMarker616"/> supply a <strong class="source-inline">Subject</strong> field. I would really encourage you to do that, of course. Then we have a <strong class="source-inline">Body</strong>, which contains the message we want <span class="No-Break">to send.</span></p>
			<p>Once we have the message, we can create an instance of the <span class="No-Break"><strong class="source-inline">SmtpClient</strong></span><span class="No-Break"> class.</span></p>
			<p>You need to have access to a real SMTP server, of course. Most internet service providers have them, so please look up how to connect to them in their documentation. You usually need a username and password to authenticate yourself. In the old days,  there were anonymous servers, but in these days of spam, those are very hard <span class="No-Break">to find.</span></p>
			<p>We have to specify the server’s address and port (port <strong class="source-inline">25</strong> is the old port; port <strong class="source-inline">587</strong> is the new, secure one, and the preferred port to use), and you can specify whether you want to use SSL. That code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
// Set up the connection to the SMTP server
// And no, this is NOT a valid SMTP server. Use your own :)
SmtpClient client =
    new SmtpClient("smtp.vroegop.org");
client.Port = 587;
client.EnableSsl = true;
client.Credentials =
    new System.Net.NetworkCredential(
        "dennis@vroegop.org",
        "MySuperSecretPassword");</pre>			<p>And finally, we can send <span class="No-Break">the message!</span></p>
			<pre class="source-code">
// Send the email!
client.Send(mail);</pre>			<p>Once you have <a id="_idIndexMarker617"/>set up the client, you can send multiple messages using that same client instance. You do not have to worry about setting up connections. You can just call <strong class="source-inline">Send</strong>, and it <span class="No-Break">all works.</span></p>
			<h3>Sending HTML messages</h3>
			<p>The <a id="_idIndexMarker618"/>previous example works fine, but the message is kind of bland. These days, messages are much more colorful and pleasant to look at. The way to do that is to send an HTML message. You can do that by just putting HTML in the <strong class="source-inline">Body</strong> field and setting the <strong class="source-inline">IsBodyHtml</strong> property of <strong class="source-inline">MailMessage</strong> to true. But that is not the best way to do that for the following <span class="No-Break">two reasons:</span></p>
			<ul>
				<li>Not all clients support HTML. The readers must decipher the HTML to find the body text if their client does not <span class="No-Break">support HTML.</span></li>
				<li>Messages only containing HTML are usually marked <span class="No-Break">as spam.</span></li>
			</ul>
			<p>The best way to do this is to combine your beautifully crafted HTML body and a more down-to-earth plain text body. You can do that by using the <strong class="source-inline">AlternateView</strong> class. The code to create the mail message looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var multipartMail = new MailMessage();
multipartMail.From = new MailAddress("dennis@vroegop.org");
multipartMail.To.Add("dearreader@thisbook.com");
multipartMail.Subject = "Hi there System Programmer!";
var htmlBody = "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hi there System Programmer!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;";
var htmlView =
    AlternateView.CreateAlternateViewFromString(
        htmlBody,
        null,
        "text/html");
var plainView =
    AlternateView.CreateAlternateViewFromString(
        "This is a test email from the System Programming book.",
        null,
        "text/plain");
multipartMail.AlternateViews.Add(plainView);
multipartMail.AlternateViews.Add(htmlView);</pre>			<p>We<a id="_idIndexMarker619"/> create an instance of the regular <strong class="source-inline">MailMessage</strong> class. Most of the fields are the same. But we do not specify a body. Instead, we create two instances of the <strong class="source-inline">AlternateView</strong> class by calling the <strong class="source-inline">CreateAlternateViewFromString</strong> static method. That method takes the content we want to send (either HTML or plain text) and the encoding we use (we set it to <strong class="source-inline">NULL</strong>, so it uses the default setting for your machine). We do have to specify the content type. The first contains <strong class="source-inline">"text/html"</strong>  and the second <span class="No-Break">contains </span><span class="No-Break"><strong class="source-inline">"text/plain"</strong></span><span class="No-Break">.</span></p>
			<p>We then add both parts to the <strong class="source-inline">MailMessage</strong> instance, and we can <span class="No-Break">send it.</span></p>
			<p>The rest of the code stays <span class="No-Break">the same.</span></p>
			<p>That covers some of the higher-level classes. It is now time to go deeper into the <span class="No-Break">rabbit hole.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor190"/>Working with the System.Net.Sockets namespace</h1>
			<p>The <a id="_idIndexMarker620"/>default protocols are fantastic. They take away a lot of manual work. We do not have to program the HTTP protocol ourselves; we can focus on the content instead. The same goes for SMTP, POP3, and all the other protocols out there. You can find a class or a NuGet package if the protocol you want to use is <span class="No-Break">popular enough.</span></p>
			<p>But of course, sometimes you cannot find that package. Sometimes, you want to write your own protocol. In that case, you have to do all the hard work yourself. But, I have to be honest, I immensely enjoy doing that. There is something nice about writing my protocol, deploying it in my apps, and seeing them work together. And even if you do not enjoy this, there are cases where you have <span class="No-Break">no choice.</span></p>
			<p>The good news<a id="_idIndexMarker621"/> is that the good people who wrote the BCL have already done much of the <span class="No-Break">underlying work.</span></p>
			<p>In <a href="B20924_07.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, we encountered the <strong class="source-inline">Socket</strong> class when we discussed how systems can communicate. Sockets were mentioned as one of the options. We wrote a simple chat application that uses TCP/IP to communicate. TCP/IP is one of the ways sockets <span class="No-Break">can connect.</span></p>
			<p>In the chat sample I mentioned, we created instances of the <strong class="source-inline">TcpListener</strong> and <strong class="source-inline">TcpClient</strong> classes. These classes are wrappers around the more generic <strong class="source-inline">Socket</strong> class. They are specifically used for TCP/IP connections and handle much of the plumping needed to get this <span class="No-Break">to work.</span></p>
			<p>You can use sockets yourself, of course. That means you must do much of the work yourself, giving you more control over <span class="No-Break">what happens.</span></p>
			<p>You can use sockets with TCP and UDP connections. We looked at the differences in <a href="B20924_07.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, so we won’t compare them again here. However, you should use the <strong class="source-inline">Socket</strong> class if you want to use UDP: obviously, <strong class="source-inline">TCPClient</strong> will not work. By the way, there is also a <strong class="source-inline">UdpClient</strong> class, with which you can achieve the same result. However, I want you to be aware of the inner workings. That is why I am going with <span class="No-Break"><strong class="source-inline">Sockets</strong></span><span class="No-Break"> here.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>Steps to take when using sockets</h2>
			<p>When <a id="_idIndexMarker622"/>working with sockets, you need to take a number <span class="No-Break">of steps:</span></p>
			<ol>
				<li>Choose the right socket. You can use stream sockets. Stream sockets are based on the TCP protocol. It is a reliable, connection-oriented protocol. But you can also choose datagram sockets. These are based on the UDP protocol. They are connectionless, fire-and-forget ways of communicating. It is quick, but you have no guarantee the data will reach the <span class="No-Break">intended recipient.</span></li>
				<li>Then, you create the socket. You specify the kind of address you want to use (IPV4 or IPV6), the type of socket (stream or datagram), and the protocol (TCP <span class="No-Break">or UDP).</span></li>
				<li>It’s time<a id="_idIndexMarker623"/> to connect. You either listen to incoming connections or connect to a server somewhere. When you connect to a remote server, you must specify the IP address and the port. If you are listening, you need the port at least, and if you have more network connections, you might want to specify the IP address you are <span class="No-Break">listening to.</span></li>
				<li>Sending and receiving data. After all, that’s what we are here <span class="No-Break">for, right?</span></li>
				<li>When you are done, you must be sure to close the connection. You do not want to hold on to a connection for too long: you might get in the way of <span class="No-Break">other applications.</span></li>
			</ol>
			<p>And that is all there is to it. If I put it like this, it seems straightforward, doesn’t it? Well, the devil is in <span class="No-Break">the details!</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>IPv4 and IPv6</h2>
			<p>We need to talk a <a id="_idIndexMarker624"/>bit about the IP address. The <strong class="bold">IP</strong> address, which stands for <strong class="bold">Internet Protocol</strong> address, is a unique number identifying a network device. It is unique within boundaries, but we will discuss that later. There are two kinds of addresses we can use: IPv4 and IPv6. As you might have guessed, these acronyms are Internet Protocol version 4 and version <span class="No-Break">6, respectively.</span></p>
			<p>The first publicly used version was IPv4. IPv5 never saw the light of day, leaving us with two versions. It has always been the idea to replace IPv4 with IPv6 completely, but it seems IPv4 will stay around for a <span class="No-Break">bit longer.</span></p>
			<p>An IPv4 address consists of 4 bytes, thus making it 32 bits long. This size means that there are about 4.3 billion unique addresses in theory. In practice, there are fewer since many ranges are reserved. We have already encountered one of them: the address is <strong class="source-inline">127.0.0.1</strong>. This is the address of the <span class="No-Break">device itself.</span></p>
			<p>Although different <a id="_idIndexMarker625"/>systems can reserve different port ranges, there is a common understanding of what ranges we should avoid using or what ranges we can use. These ranges are explained <span class="No-Break">like this:</span></p>
			<ul>
				<li><strong class="bold">Port 0 – 1023</strong>: Well-known ports. These ports are used everywhere and you should not use <span class="No-Break">them yourself.</span></li>
				<li><strong class="bold">Port 1024 – 49151</strong>: A lot of the ports in this range are registered and well-known, such as port <strong class="source-inline">1433</strong>, which is used by SQL Server. However, these are not as strictly assigned as the range <strong class="source-inline">0</strong> – <span class="No-Break"><strong class="source-inline">1023</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Port 49152 – 65535</strong>: This range is known as the dynamic or private range. They are usually used for ephemeral or short-lived communications. They are, most of the time, dynamically allocated by the <span class="No-Break">operating system.</span></li>
			</ul>
			<p>Just make sure the port you pick is not yet in use on your <span class="No-Break">intended system!</span></p>
			<p>An IPv6 address comprises 8 sets of 2-byte structures, making it 128 bits in length. You can fit substantially more addresses in that address space: there are about 340 undecillion <span class="No-Break">unique addresses.</span></p>
			<p class="callout-heading">Big numbers</p>
			<p class="callout">Working with computers means you sometimes run into big numbers. This is such a case: an undecillion is 10 to the power of 36. That means the number is 340, followed by 36 zeros. That’s a lot <span class="No-Break">of addresses.</span></p>
			<p>The IPv6 address is displayed as a sequence of 8 sets of 16-bit hexadecimal values. For instance, a valid address could look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">2001:0db8:85a3:0000:0000:8a2e:0370:7334</strong></span><span class="No-Break">.</span></p>
			<p>This is also an interesting address: <strong class="source-inline">0000:0000:0000:0000:0000:0000:0000:0001</strong>. This is the IPv6 version of 127.0.0.1. In other words, this is localhost. However, it is pretty long: there are 7 sets of <strong class="source-inline">0000</strong>. With IPv6 we can omit a range of <strong class="source-inline">0000</strong> values with two colons. So we can shorten the address for localhost <span class="No-Break">to ::1.</span></p>
			<p>Both in IPv4 and IPv6, we have reserved ranges. For instance, everything in the range <strong class="source-inline">192.168.0.0</strong> up to <strong class="source-inline">192.168.255.255</strong> is used for internal networks. You cannot, however, assign these addresses to devices facing the public network. The same goes for the addresses <strong class="source-inline">10.0.0.0 to 10.255.255.255</strong> and <strong class="source-inline">172.16.0.0 </strong><span class="No-Break"><strong class="source-inline">to 172.31.255.255</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/>Looking up time with sockets</h2>
			<p>It is time to look at how to do all this <span class="No-Break">for real.</span></p>
			<p>There <a id="_idIndexMarker626"/>are servers out there that work as time servers. These servers have one purpose: wait for your connection and then respond with the current date and time. The way they do this is pretty interesting: they calculate the time it takes to send a response and adjust the time accordingly, thus making sure the answer is as accurate <span class="No-Break">as possible.</span></p>
			<p>Let’s look at <span class="No-Break">some code:</span></p>
			<pre class="source-code">
public DateTime GetNetworkTime(string ntpServer = "pool.ntp.org")
{
    // NTP message size - 16 bytes (RFC 2030)
    var ntpData = new byte[48];
    // Setting the Leap Indicator, Version Number and Mode values
    ntpData[0] = 0x23; // LI, Version, Mode
    var addresses = Dns.GetHostEntry(ntpServer);
    var ipEndPoint = new IPEndPoint(addresses.AddressList[0], 123);       // NTP uses port 123
    using (var socket = new Socket(AddressFamily.InterNetwork,       SocketType.Dgram, ProtocolType.Udp))
    {
        socket.Connect(ipEndPoint);
        socket.Send(ntpData);
        socket.Receive(ntpData);
        socket.Close();
    }
    return ConvertNtpTimeToDateTime(ntpData);
}</pre>			<p>The <a id="_idIndexMarker627"/>method starts with a default value for the name of the server. We use <a href="http://pool.ntp.org">pool.ntp.org</a> as our server, but there are many more out there that would do the trick. They all use the NTP protocol (<strong class="bold">NTP</strong> means <strong class="bold">Network Time Protocol</strong>, in <a id="_idIndexMarker628"/>case you were wondering). NTP is one of the oldest protocols. Systems used this protocol to synchronize the clocks of computers over a network as far back as the <span class="No-Break">early 80s!</span></p>
			<p>The address we use, <strong class="source-inline">pool.ntp.org</strong>, is not a single computer but a pool of thousands of NTP servers, ensuring everybody can get their time. However, we can treat it as a single server. Oh, one word of warning: that URL is meant to be used by NTP clients. They use port <strong class="source-inline">123</strong>, as you can see in the code. If you use your browser to go to that address, you automatically use HTTP and thus port <strong class="source-inline">80</strong> (there is no HTTPS server at that address). This means you get to see whatever the maintainers of that pool want to put there. Do not use your browser to go to that URL; use port <strong class="source-inline">123</strong> as it <span class="No-Break">is intended!</span></p>
			<p>A request to the NTP server needs a buffer of 48 bytes to hold the answer. We need to add some data in that buffer when we connect to the server, telling it what we want. In our case, we give it the value 0x23. This byte consists of 3 groups of bits, each group telling the server something about what we want. Look at the following table to see what these <span class="No-Break">bits mean:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-8">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Bits</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">6– 7</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Leap Indicator</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates whether we want to take the leap seconds a month might have into account. 0 means no adjustment, 1 means the last minute of the month has 61 seconds, 2 means the last minute of the month has 59 seconds, and 3 means the clock <span class="No-Break">is unsynchronized.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">4-6</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Version</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The version of the protocol we want to use. The latest version <span class="No-Break">is 4.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">0-3</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Mode</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0: Reserved</span></p>
							<p>1: <span class="No-Break">Symmetric active</span></p>
							<p>2: <span class="No-Break">Symmetric passive</span></p>
							<p><span class="No-Break">3: Client</span></p>
							<p><span class="No-Break">4: Server</span></p>
							<p><span class="No-Break">5: Broadcast</span></p>
							<p>6: NTP <span class="No-Break">control message</span></p>
							<p><span class="No-Break">7: Reserved</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1: Settings for NTP servers</p>
			<p>We do not <a id="_idIndexMarker629"/>want to use leap adjustment. We are interested in using protocol version 4. And we are a client here. That means we have to do some bit-arithmetic. Working down from the most significant bits to the least significant bits, we get 00 for bits 6 and 7, 100 for bits 4, 5, and 6, and finally, 011 for bits 0 through 4. If we combine this, we get 0010 0011, or 23 <span class="No-Break">in decimal.</span></p>
			<p>We place that value in the first byte in the 48-byte long buffer we shall give to <span class="No-Break">the server.</span></p>
			<p>We have the name of the NTP server (<strong class="source-inline">pool.ntp.org</strong>), but we need the actual IP address of that machine. After all, sockets need an address and not a string of text. The <strong class="bold">DNS</strong>, or <strong class="bold">Domain Name System</strong>, can <a id="_idIndexMarker630"/>look up the current address belonging to a domain name. In my case, if I run the line <strong class="source-inline">var addresses = Dns.GetHostEntry(ntpServer);</strong>, I get 4 IP <span class="No-Break">addresses back.</span></p>
			<p>We take the first address we got back and construct an instance of an <strong class="source-inline">IPEndPoint</strong> class with that address and <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">123</strong></span><span class="No-Break">.</span></p>
			<p>Then, we can create an instance of the <strong class="source-inline">Socket</strong> class. We give it the <strong class="source-inline">AddressFamily</strong> <strong class="source-inline">InterNetwork</strong>, meaning we want to use IPv4 addresses. We also specify that we’ll use a datagram, and thus, we <span class="No-Break">use UDP.</span></p>
			<p class="callout-heading">Mixing streams, datagrams, TCP, and UDP</p>
			<p class="callout">You must specify what socket type and protocol type you want to use. However, if you use <strong class="source-inline">SocketType.Stream</strong>, you must also use <strong class="source-inline">ProtocolType.TCP</strong>. And if you want to use <strong class="source-inline">SocketType.DGram</strong>, you must also use <strong class="source-inline">ProtocolType.UDP</strong>. If you try to mix these (you want datagram over TCP, for instance), you get an exception during runtime. So, be careful what <span class="No-Break">you choose.</span></p>
			<p>We call <strong class="source-inline">connect</strong> on <a id="_idIndexMarker631"/>the socket, giving it the endpoint we created. After that, we send the server our 48-byte buffer containing information about <strong class="source-inline">leap</strong>, <strong class="source-inline">version</strong>, and <strong class="source-inline">mode</strong>. Next, we try to get an answer by calling <strong class="source-inline">Receive</strong>, using that <span class="No-Break">same buffer.</span></p>
			<p>Of course, when we get the answer, we close <span class="No-Break">the connection.</span></p>
			<p>Once the answer is received and safely stored in our buffer, we can do some calculations to transform the data into something we can use in a <strong class="source-inline">DateTime</strong> structure. That specific piece of code we call contains conversions between different formats, swapping bits, and more. They have nothing to do with getting data from a server, so I leave it out. The sample on GitHub has that code, so please check that out if you want to see what that <span class="No-Break">looks like.</span></p>
			<p>The code that deals with the socket was not that complicated. But there is a problem with this code. It is what we call <strong class="bold">blocking code</strong>. It <a id="_idIndexMarker632"/>blocks the entire thread for the duration of the call to the NTP server. Let’s <span class="No-Break">fix that.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor194"/>Async, non-blocking networking</h1>
			<p>It should be evident by now <a id="_idIndexMarker633"/>that you must ensure that all non-instantaneous operations in your code are a potential performance issue. Slow operations can <a id="_idIndexMarker634"/>block a process from continuing. File I/O is one of the areas where this is appropriate. Networking is even slower than that. So, everything that we can do asynchronously should be implemented <span class="No-Break">that way.</span></p>
			<p>The good news is that most classes dealing with networking have asynchronous versions of their methods. The bad news is that for <strong class="source-inline">Socket</strong>, it is not as straightforward as you might have hoped. But do not worry: we will tackle <span class="No-Break">this soon!</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor195"/>Making asynchronous calls</h2>
			<p>In the<a id="_idIndexMarker635"/> previous sample, we used the static <strong class="source-inline">Dns</strong> class to get information about the address of the NTP server. We called <strong class="source-inline">GetHostEntry()</strong>, which is a synchronous blocking call. We can fix that quite easily: <strong class="source-inline">Dns</strong> has asynchronous versions of those methods. We can rewrite the call to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var addresses = await Dns.GetHostEntryAsync(ntpServer);</pre>			<p>Of course, the signature of the method needs to change as well. Instead of having this method declaration: <strong class="source-inline">public DateTime GetNetworkTime(string ntpServer = "</strong><span class="No-Break"><strong class="source-inline">pool.ntp.org")</strong></span><span class="No-Break">.</span></p>
			<p>We change it <span class="No-Break">into this:</span></p>
			<p><strong class="source-inline">public async Task&lt;DateTime&gt; GetNetworkTimeAsync(string ntpServer = "</strong><span class="No-Break"><strong class="source-inline">pool.ntp.org")</strong></span></p>
			<p>We made it <strong class="source-inline">async</strong>, changed the return type to <strong class="source-inline">Task&lt;DateTime&gt;</strong> instead of <strong class="source-inline">DateTime</strong>, and renamed the method to have the <span class="No-Break"><strong class="source-inline">Async</strong></span><span class="No-Break"> postfix.</span></p>
			<p>That was simple enough. We can do the same for the code working with <strong class="source-inline">Socket</strong>. This is the <span class="No-Break">full method:</span></p>
			<pre class="source-code">
public async Task&lt;DateTime&gt; GetNetworkTimeAsync(string ntpServer = "pool.ntp.org")
{
    // NTP message size - 16 bytes (RFC 2030)
    var ntpData = new byte[48];
    // Setting the Leap Indicator, Version Number, and Mode values
    ntpData[0] = 0x23; // LI, Version, Mode
    var addresses = await Dns.GetHostEntryAsync(ntpServer);
    var ipEndPoint = new IPEndPoint(addresses.AddressList[0], 123);       // NTP uses port 123
    using (var socket = new Socket(
               AddressFamily.InterNetwork,
               SocketType.Dgram,
               ProtocolType.Udp))
    {
        await socket.ConnectAsync(ipEndPoint);
        await socket.SendAsync(
            new ArraySegment&lt;byte&gt;(ntpData),
            SocketFlags.None);
        await socket.ReceiveAsync(
            new ArraySegment&lt;byte&gt;(ntpData),
            SocketFlags.None);
    }
    return ConvertNtpTimeToDateTime(ntpData);
}</pre>			<p>This version<a id="_idIndexMarker636"/> takes advantage of the async/await pattern, so the calls to the server do not block <span class="No-Break">the threads.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Networking code should always use asynchronous methods instead of synchronous ones. Networking is slow compared to the raw speed of the CPU and the local machine, so why waste time waiting on that slow trickle of data from the <span class="No-Break">network adapter?</span></p>
			<p>However, there are ways to improve the performance of your system when you use networking. Let’s look at <span class="No-Break">those next.</span></p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor196"/>Networking performance</h1>
			<p>Since networking<a id="_idIndexMarker637"/> is comparatively slow, we have to be smart about ways to improve the throughput of the data. We can control local networks, ensuring we have optic fiber and super-fast routers everywhere, but that does not solve the issues. Even the fastest physical network is way slower than data handled in the CPU. Of course, having fast hardware helps. But it only helps on our own network: we cannot control the hardware on other networks. We must be wise in our code to get the most out of our networking. Once again, it all comes down to us, <span class="No-Break">the developers!</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>Connection pooling</h2>
			<p>A connection represents <a id="_idIndexMarker638"/>an open line between a client and a server. Let’s look at the following line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
var client = new TcpClient("my.server.com", 123);</pre>			<p>This single line of code is simple enough: this creates a connection to a server called <strong class="source-inline">my.server.com</strong> on port <strong class="source-inline">123</strong> and returns the open connection. Fine. We’ve seen that before. But let me show you what happens when you run that line <span class="No-Break">of code:</span></p>
			<ul>
				<li><strong class="bold">Name resolution</strong>: The framework uses DNS to look up the address of that connection, translating the <strong class="source-inline">my.server.com</strong> string into the correct IPv4 or IPv6 addresses we <span class="No-Break">can use.</span></li>
				<li><strong class="bold">Socket creation</strong>: The <strong class="source-inline">Socket</strong> class is instantiated, allocating the memory for it and ensuring it <span class="No-Break">is available.</span></li>
				<li><strong class="bold">Connection attempt</strong>: The socket tries to connect to the IP address it found for the address. This is a multi-step process, and it requires a couple of round trips to the server. These are <span class="No-Break">the steps:</span><ol><li class="upper-roman"><strong class="bold">The client sends SYN</strong>: A message with the payload <strong class="source-inline">SYN</strong> is sent to the server. Basically, the client is asking, “Hey, can <span class="No-Break">we talk?”</span></li><li class="upper-roman"><strong class="bold">The server sends SYN-ACK</strong>: The server is listening on the port, and if the <strong class="source-inline">SYN</strong> message comes in, it responds with <strong class="source-inline">SYN-ACK</strong>, acknowledging that it is ready <span class="No-Break">to talk.</span></li><li class="upper-roman"><strong class="bold">The client sends ACK</strong>: The client confirms that it received <strong class="source-inline">SYN-ACK</strong>, that apparently the network works fine, and that they <span class="No-Break">can talk.</span></li></ol></li>
			</ul>
			<p>When all this <a id="_idIndexMarker639"/>has happened, the communication line is open and ready for use. We can start sending and <span class="No-Break">receiving data.</span></p>
			<p>As you can see, a lot of work is involved in that simple line of code. You can imagine that the handshaking between the client and the server takes a lot of time. Network connections <span class="No-Break">are expensive!</span></p>
			<p>There is no getting around this. These steps need to be taken. But there is no reason to do them more than you need to. If you have a connection to a server, you might reuse it as well. We call that connection pooling. We create a pool of connections, and whenever something in our system needs to talk to the server, we return the <span class="No-Break">already-created connection.</span></p>
			<p>Unfortunately, the BCL does not have a class for this. But it is not too hard to write one yourself. You could do it <span class="No-Break">like this.</span></p>
			<p>We create a class called <strong class="source-inline">TcpClientConnectionPool</strong>. The signature looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
internal class TcpClientConnectionPool : IAsyncDisposable{}</pre>			<p>We have three methods in <span class="No-Break">that class:</span></p>
			<pre class="source-code">
public TcpClient? GetConnection(){}
public void ReturnConnection(TcpClient? client) {}
public async ValueTask DisposeAsync(){}</pre>			<p>Before we look at what those methods do, we need to create two private fields in <span class="No-Break">the class:</span></p>
			<pre class="source-code">
private readonly ConcurrentBag&lt;TcpClient?&gt; _availableConnections = new();
private readonly int _maxPoolSize = 10; // Example pool size</pre>			<p>When you create a pool to hold objects, you need a place to store them. We use <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> here. <strong class="source-inline">ConcurrentBag</strong> is a thread-safe collection that has the <span class="No-Break">following characteristics:</span></p>
			<ul>
				<li><strong class="bold">Thread safe</strong>: You can add, access, and remove objects without worrying about locks or other threads running amock. This class handles the details <span class="No-Break">for you.</span></li>
				<li><strong class="bold">Unordered</strong>: There is no specific order. In our case, this is just fine. However, if you want to use something like FIFO, you should use a class with an order <span class="No-Break">built in.</span></li>
				<li><strong class="bold">Duplicates are allowed</strong>: You can add the same object to the collection if <span class="No-Break">you want.</span></li>
				<li><strong class="bold">Performance</strong>: This class is optimized for scenarios where the same thread adds or removes items but performs pretty well in <span class="No-Break">mixed scenarios.</span></li>
			</ul>
			<p>The <strong class="source-inline">GetConnection()</strong> method<a id="_idIndexMarker640"/> pulls an object from the pool if one is available. If one is not, it creates one for you. Here <span class="No-Break">it is:</span></p>
			<pre class="source-code">
public TcpClient? GetConnection()
{
    if (_availableConnections.TryTake(out TcpClient? client))
        return client;
    if (_availableConnections.Count &lt; _maxPoolSize)
    {
        // Create a new connection if the pool is not full
        client = new TcpClient("my.server.com", 443);
    }
    else
    {
        // Pool is full; wait for an available connection or throw an         // exception
        // This strategy depends on your specific requirements
        throw new Exception("Connection pool limit reached.");
    }
    return client;
}</pre>			<p>In this<a id="_idIndexMarker641"/> example, I throw an exception when the pool has reached the maximum allowed objects. You want to limit the number of <strong class="source-inline">TcpClient</strong> instances in your code: they take up quite a lot of memory and underlying handles, so having an unlimited amount of them lying around might not be the <span class="No-Break">best idea.</span></p>
			<p>If there is room in the pool but no items are available, we create a new one and return it to the caller. The idea is that after using, the caller returns the object, and we store it in the collection, ready for another user to pick it up. We use lazy initialization here: we only create <strong class="source-inline">TcpClient</strong> <span class="No-Break">when needed.</span></p>
			<p>If you want, you can create all 10 instances in the constructor of this class. That makes the initialization of the class slower, and it uses more memory, but it is much faster during the <span class="No-Break">object’s lifetime.</span></p>
			<p>When the connection user calls this method, it gets an active and open connection. When the user no longer needs <strong class="source-inline">TcpClient</strong>, it needs to be returned so it can be stored in the pool and ready for the following user. That method looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public void ReturnConnection(TcpClient? client)
{
    // Check the state of the connection to ensure it's still valid
    if (client is { Connected: true })
    {
        _availableConnections.Add(client);
    }
    else
    {
        // Optionally, handle the case where the connection is no         // longer valid
        // e.g., reconnect or simply discard this connection
    }
}</pre>			<p>We can <a id="_idIndexMarker642"/>do some checking when we get <strong class="source-inline">TcpClient</strong> back. For instance, I usually check to see whether it is still connected here. It is a bit like a library: when you return your items, they expect them to be pristine. We do the same here. If there is something wrong, we can fix it or not even add it back to the pool. I’ll leave that up <span class="No-Break">to you.</span></p>
			<p>Finally, when the connection pool is disposed of, we do some <span class="No-Break">cleaning up:</span></p>
			<pre class="source-code">
public async ValueTask DisposeAsync()
{
    foreach (var client in _availableConnections)
    {
        if (client is { Connected: true })
        {
            await client.GetStream().DisposeAsync();
        }
        client?.Close();
        client?.Dispose();
    }
}</pre>			<p>We go through all the remaining instances of <strong class="source-inline">TcpClient</strong> in our collection, close them if needed, dispose of the underlying stream, and dispose of the instances themselves. This makes <a id="_idIndexMarker643"/>sure we leave no connection open. My mother taught me this at a very young age: always clean up <span class="No-Break">after yourself!</span></p>
			<p>To finalize this part, this is how you would use <span class="No-Break">this class:</span></p>
			<pre class="source-code">
await using var connectionPool = new TcpClientConnectionPool();
TcpClient? myConnection = connectionPool.GetConnection();
try
{
    var myBuffer = "Hello, World!"u8.ToArray();
    // Use the connection
    await myConnection.Client.SendAsync(myBuffer);
}
finally
{
    connectionPool.ReturnConnection(myConnection);
}</pre>			<p>I first create an instance of <strong class="source-inline">connectionPool</strong>. Obviously, you would not do that in each method call that needs a connection, but for this simple example, it is <span class="No-Break">all right.</span></p>
			<p>Then I try to get a connection by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">GetConnection()</strong></span><span class="No-Break">;</span></p>
			<p>Then I get some bytes by taking the <strong class="source-inline">Hello, World</strong> string, postfixing that with <strong class="source-inline">u8</strong> to ensure it is UTF-8 and then converting it to a <span class="No-Break">byte array.</span></p>
			<p>I can use my pooled connection to send that string to the server. Finally, I can put the connection back in <span class="No-Break">the pool.</span></p>
			<p>This sample is limited in functionality and lacks a lot of the code you would need before taking it into <a id="_idIndexMarker644"/>production. But I am sure it will help you get on <span class="No-Break">your way.</span></p>
			<p>What we are doing is caching our connections. But caching can help in a lot of other ways <span class="No-Break">as well.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/>Caching</h2>
			<p>Caching<a id="_idIndexMarker645"/> stores data nearby so you can reuse it instead of going to the server each time. That sounds simple enough: it can be a huge performance booster. Getting an object from a memory location on your machine instead of going to a remote server each time sounds like a no-brainer, right? But there are some potential pitfalls you need to take into account. Here are the most <span class="No-Break">important ones:</span></p>
			<ul>
				<li><strong class="bold">Stale data</strong>: Data might change. For instance, our NTP sample changes every millisecond. That being said, you might retrieve it from the server once and then add the local time that’s elapsed since you got it. It will eventually run out of sync (NTP servers are much more precise than your local machine), but I am sure it will not be that big of an issue soon. But data will get stale. You have to take that into account if you store data locally. How often will data change? How important is it that I have the <span class="No-Break">latest version?</span></li>
				<li><strong class="bold">Memory overhead</strong>: Storing items locally on your machine takes up local memory. Storing large amounts of (large) objects takes up a lot of data, which might slow down your total application. It might even lead to out-of-memory exceptions. You must decide what you use frequently and what can be left on <span class="No-Break">the server.</span></li>
				<li><strong class="bold">Complexity in cache invalidation</strong>: If data gets stale, you have to renew it. That requires code to monitor the data and refresh it when needed. That code can get quite complicated. You might have a separate thread that monitors your local cache, or you might decide when something pulls that data from the cache. Either way, you have to write a lot of monitoring code. That might overly complicate <span class="No-Break">your software.</span></li>
				<li><strong class="bold">Security concerns</strong>: Data on your machine is not always safe. If you store sensitive data on the local machine, it might be susceptible to snooping, especially if you store that cached data on a storage medium. Be sure to handle sensitive <span class="No-Break">data safely.</span></li>
				<li><strong class="bold">Costs of cache misses</strong>: When your application relies on getting data from the cache and <a id="_idIndexMarker646"/>only has it read from the remote server when you have a cache miss (thus, the item is not in the cache yet), you might have introduced a performance bottleneck. The logic of going through the cache, only to go out to the server if the data is not available, takes time. If the data you need is not needed that often, this is probably not the best case <span class="No-Break">for caching.</span></li>
				<li><strong class="bold">Inconsistent data</strong>: Suppose your app uses data from the cache, but another system or part of your system uses data from the server. In that case, there might be discrepancies between the data. This is not only stale data, but it means that two systems use different data – data they expect to be the same. If that might be an issue, caching might be a <span class="No-Break">bad idea.</span></li>
			</ul>
			<p>Caching can speed up your application, but be aware of the risks involved. Before implementing this, you should consider the potential risks <span class="No-Break">and benefits.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor199"/>Compression and serialization</h2>
			<p>If transferring<a id="_idIndexMarker647"/> data over the wire is slow, transmitting or requesting less data can help. So, compression and how you serialize data can help. In earlier chapters, we looked into compression and serialization, so I will not go into detail <a id="_idIndexMarker648"/>here. But please remember: if there is one place where it helps a lot when you use compression, this is the place. You can speed up network communications if you reduce the payload by compressing it first. And of course, choosing the correct serialization technique <span class="No-Break">also helps.</span></p>
			<p>Since we already looked at how to do compression, I will not show you it again here. You already know how to use the <strong class="source-inline">GZipStream</strong> class in the <strong class="source-inline">System.IO.Compression</strong> namespace (yes, that was <span class="No-Break">a hint).</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>Keep-alive connections</h2>
			<p>Creating a <strong class="source-inline">TcpClient</strong> is not <a id="_idIndexMarker649"/>that expensive per se. Opening a connection to a server is expensive, however. It can help to keep connections open as long as you can. The <strong class="source-inline">HTTPClient</strong> class is very good at that: it is built so that you can leave the connection open for a long time without getting in your way. If you use sockets, you can do something similar. However, keeping a connection open when you do not need it anymore is not a good idea. If you do not need it, please close the connection. Otherwise, by all means, keep it open. Of course, if you keep a connection open, you also affect the other party. A client that clings to a connection also limits the server. You have to think about this a lot and make the <span class="No-Break">right decisions.</span></p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor201"/>Networking errors and time-outs</h1>
			<p>When<a id="_idIndexMarker650"/> dealing with networks, there is one rule you have to keep in mind. That rule is: <em class="italic">assume that the other party is not answering </em><span class="No-Break"><em class="italic">your call</em></span><span class="No-Break">.</span></p>
			<p>Servers go down. Connections can drop. Networks are unreachable. There are a whole lot of issues that will (not <span class="No-Break">might!) happen.</span></p>
			<p>You must use defensive coding to ensure it doesn’t impact your code too much. Of course, if you rely on an external machine to get the data you need, and that machine is not available, you have a problem. But maybe you can get around it. Perhaps you can cache older data. Or, you can retry if something <span class="No-Break">goes wrong.</span></p>
			<p>Let me help you with some strategies you can use to deal with hiccups in <span class="No-Break">the network.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>Using the HTTPClient wisely</h2>
			<p>The <strong class="source-inline">HTTPClient</strong> class has <a id="_idIndexMarker651"/>some neat tricks<a id="_idIndexMarker652"/> to help you with making the use of it more stable. For instance, connection pooling comes free and out of the box in this handy class. And they built that connection pooling in a pretty <span class="No-Break">clever way.</span></p>
			<p>The general advice is to create one instance of <strong class="source-inline">HTTPClient</strong> and use that throughout your system. The class is smart enough to pool connections to a server. If you use the same <strong class="source-inline">HTTPClient</strong> to get data from another server, the class creates a new pool, so those connections also <span class="No-Break">get pooled.</span></p>
			<p>Of course, be<a id="_idIndexMarker653"/> careful what you do: do not generate connections to hundreds of servers if you do not need them. They still take up memory in <span class="No-Break">your system.</span></p>
			<p>Another<a id="_idIndexMarker654"/> way to make <strong class="source-inline">HTTPClient</strong> more resilient is to use a default configuration for your connections. I always ensure I set <strong class="source-inline">DefaultRequestHeaders</strong> so I know that I can handle the data <span class="No-Break">coming in.</span></p>
			<p>And I always make sure I have a <strong class="source-inline">TimeOut</strong> on my instance. That way, I know that the <strong class="source-inline">HTTPClient</strong> will not have to wait too long for data from <span class="No-Break">the server.</span></p>
			<p>I suggest you use something such as a <strong class="source-inline">Factory</strong> to create your instances. I use one that looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
internal static class HttpClientFactory
{
    private static HttpClient? _instance;
    public static HttpClient? Instance
    {
        get
        {
            if (_instance == null) CreateInstance();
            return _instance;
        }
    }
    private static void CreateInstance()
    {
        var handler = new HttpClientHandler()
        {
            UseCookies = true,
            CookieContainer = new CookieContainer(),
            UseProxy = false
        };
        _instance = new HttpClient(handler);
        _instance.DefaultRequestHeaders.Clear();
        _instance.DefaultRequestHeaders.Accept.Add(new           MediaTypeWithQualityHeaderValue("application/json"));
        _instance.DefaultRequestHeaders.Add("User-Agent",           "SystemProgrammersApp");
        _instance.Timeout = TimeSpan.FromSeconds(5);
    }
}</pre>			<p>This static<a id="_idIndexMarker655"/> class creates an instance of <strong class="source-inline">HTTPClient</strong> for me if needed. It tells the handler that it needs to use <strong class="source-inline">Cookies</strong> and that I do not want <a id="_idIndexMarker656"/>a proxy on my connection. I also set <strong class="source-inline">DefaultRequestHeaders</strong> and asked it to accept <strong class="source-inline">application/json</strong> data. I also added a nice user agent so the server knows who it is talking to. Finally, I set the <strong class="source-inline">timeout</strong> to <span class="No-Break">5 seconds.</span></p>
			<p>If I need an <strong class="source-inline">HTTPClient</strong> instance, I can get it <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var client = HttpClientFactory.Instance;
var response = await client.GetAsync(
       "https://jsonplaceholder.typicode.com/posts");
if (response.IsSuccessStatusCode)
{
    string content = await response.Content.ReadAsStringAsync();
    $"Received: {content}".Dump(ConsoleColor.Yellow);
}</pre>			<p>The first time I needed that client, it built it. But the second time and after that, it will pull it <a id="_idIndexMarker657"/>from the connection pool, making it a lot quicker and more resilient <span class="No-Break">to mistakes.</span></p>
			<p>I also ensure<a id="_idIndexMarker658"/> I do not use the <strong class="source-inline">GetStringAsync()</strong> method or <strong class="source-inline">GetStreamAsync()</strong> directly from <strong class="source-inline">HTTPClient</strong>. I first get the <strong class="source-inline">Response</strong> (of the type <strong class="source-inline">HttpResponseMessage</strong>) to check whether the result is valid. As we have seen, this is what the <strong class="source-inline">IsSuccessStatusCode</strong> property <span class="No-Break">tells us.</span></p>
			<p>This way, your communications with an HTTP server will become faster and much <span class="No-Break">more stable.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor203"/>Implementing retries with Polly</h2>
			<p>But <a id="_idIndexMarker659"/>of course, things will still go wrong. The server might be busy, or the network might be congested. The best way to get around that is to try again, and then again, until either it works or you <span class="No-Break">give up.</span></p>
			<p>You could write that logic yourself, but you would be better off using a standard library. The most used library that <a id="_idIndexMarker660"/>implements this is <span class="No-Break">called </span><span class="No-Break"><strong class="bold">Polly</strong></span><span class="No-Break">.</span></p>
			<p>So, let’s install<a id="_idIndexMarker661"/> that NuGet package in our application first. You can do so in the CLI by using <span class="No-Break">this command:</span></p>
			<pre class="console">
Install-Package Polly</pre>			<p>Once you have done that, we can change our <strong class="source-inline">HttpClientFactory</strong> class <span class="No-Break">a bit.</span></p>
			<p>First, add a new <strong class="source-inline">private static</strong> field to <span class="No-Break">that class:</span></p>
			<pre class="source-code">
private static AsyncRetryPolicy&lt;HttpResponseMessage&gt; _retryPolicy;</pre>			<p>This is our <strong class="source-inline">RetryPolicy</strong>, which we will apply to <span class="No-Break">the requests.</span></p>
			<p>At the end of the <strong class="source-inline">CreateInstance</strong> method in the <strong class="source-inline">HttpClientFactory</strong> class, add a call to a new method: <strong class="source-inline">SetupRetryPolicy</strong>. The method looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
private static void SetupRetryPolicy()
{
    _retryPolicy = Policy
        .Handle&lt;HttpRequestException&gt;()
        .OrResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
        .WaitAndRetryAsync(
            3,
            retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2,               retryAttempt)),
            (outcome, timeSpan, retryCount, context) =&gt;
            {
                $"Request failed with
                 {outcome.Result.StatusCode}.".Dump(ConsoleColor.Red);
                $"Waiting {timeSpan} before next
                 retry.".Dump(ConsoleColor.Red);
                $"Retry attempt
                 {retryCount}.".Dump(ConsoleColor.Red);
            });
}</pre>			<p>In the <a id="_idIndexMarker662"/>static <strong class="source-inline">Policy</strong> class, we call the <strong class="source-inline">Handle()</strong> method. We give it the <strong class="source-inline">HttpRequestException</strong> type<a id="_idIndexMarker663"/> parameter. This way, the framework knows the trigger to start retrying. We also tell it to retry if <strong class="source-inline">HttpResponseMessage.IsSuccesStatusCode</strong> is set <span class="No-Break">to false.</span></p>
			<p>If one of those conditions arises, we tell the policy to <strong class="source-inline">WaitAndRetryAsync</strong>. We ask it to give it three retries after the first failure. The following parameter tells the <strong class="source-inline">Policy</strong> to wait for 2, 4, or 8 seconds (2 to the power of the retry number). So, it waits twice as long each time to give the server time to get its stuff <span class="No-Break">in order.</span></p>
			<p>We also give it a delegate that the framework will execute as soon as it starts to retry. In this case, we print out some messages to the console, telling it what failed, how long it will wait before it tries again, and how many times it has <span class="No-Break">tried already.</span></p>
			<p>With that <a id="_idIndexMarker664"/>in place, we can rewrite how we ask the <strong class="source-inline">HTTPClient</strong> for data. In the previous example, I showed you how to get the <strong class="source-inline">Instance</strong> from the factory and then use that instance directly. I want to move that code to <strong class="source-inline">HttpClientFactory</strong> as well. But the call to the server must be wrapped up in our new <strong class="source-inline">Policy</strong>. The method looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public static async Task&lt;HttpResponseMessage&gt; GetAsync(string url)
{
    return await _retryPolicy.ExecuteAsync(
        () =&gt; _instance.GetAsync(url));
}</pre>			<p>Instead of the user of our class calling <strong class="source-inline">GetAsync(url)</strong>, we do it for them using this wrapper method. But we wrap up that call <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">_retryPolicy.ExecuteAsync()</strong></span><span class="No-Break">.</span></p>
			<p>Change the original code that uses this factory to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var client = HttpClientFactory.Instance;
var response = await HttpClientFactory.GetAsync(
       "https://jsonplaceholder.typicode.com/posts2");
if (response.IsSuccessStatusCode)
{
    string content = await response.Content.ReadAsStringAsync();
    $"Received: {content}".Dump(ConsoleColor.Yellow);
}</pre>			<p>Instead of calling <strong class="source-inline">client.GetAsync()</strong>, I now call <strong class="source-inline">HttpClientFactory.GetAsync()</strong>. The rest hasn’t changed. Well, that’s not entirely true. I also altered the URL a bit. I am not asking for <strong class="source-inline">posts2</strong> instead of <strong class="source-inline">posts</strong> in that URL. And that doesn’t exist. That should trigger our <span class="No-Break">retry mechanism.</span></p>
			<p>Run it and see what happens. There you go – retries done the <span class="No-Break">right way!</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor204"/>The circuit breaker pattern</h2>
			<p>A <a id="_idIndexMarker665"/>similar pattern is the circuit <a id="_idIndexMarker666"/>breaker pattern. This pattern detects when connections are in a fault state and prevents the system from making calls to the server for a predefined period. If the connection raises errors, the circuit breaker opens and stops all communications to that server for a while. After that cooldown period, it opens a bit to allow another quick peek at the server. If it seems to work, it allows full traffic. Otherwise, it will give up and let you know things have <span class="No-Break">gone wrong.</span></p>
			<p>The circuit breaker is also part of the Polly <span class="No-Break">NuGet package.</span></p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor205"/>Validating network availability</h2>
			<p>Trying to<a id="_idIndexMarker667"/> connect to a server that doesn’t exist will result in errors. But what happens if your own network has an issue? In that case, it would look like all servers worldwide <span class="No-Break">are down.</span></p>
			<p>That last scenario doesn’t seem so likely, so verifying that our network is healthy would be nice before we blame the <span class="No-Break">entire internet.</span></p>
			<p>It turns out that it is not too hard to do so. All you need is one line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
bool isHealthy =     System.Net.NetworkInformation.NetworkInterface.GetIsNetworkAvailable();</pre>			<p>That’s all there is <span class="No-Break">to it.</span></p>
			<p>You can also interrogate each network adaptor in your machine <span class="No-Break">like this:</span></p>
			<pre class="source-code">
foreach (NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
{
    $"Name: {ni.Name}".Dump(ConsoleColor.DarkYellow);
    $"Type:{ni.NetworkInterfaceType}".Dump(ConsoleColor.DarkYellow);
    $"Status: {ni.OperationalStatus}".Dump(ConsoleColor.DarkYellow);
}</pre>			<p>We can<a id="_idIndexMarker668"/> iterate through all network adapters and see what their status is. That can help us to select the suitable adapter and thus the right IP address if we want to be resilient against errors <span class="No-Break">and failures.</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor206"/>Monitoring and logging</h2>
			<p>This one goes <a id="_idIndexMarker669"/>without saying: <em class="italic">the best way to solve issues is to log and monitor what is happening</em>. If you have extensive logging, you are much more likely to find problems if they occur. But let’s not worry about that too much <span class="No-Break">for now.</span></p>
			<p>If you follow these tips and tricks, you will still face network issues. They are inevitable. But at least network failures will not bring your <span class="No-Break">system down.</span></p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor207"/>Next steps</h1>
			<p>In this chapter, we took a deep dive into networking. We broke out of the confines of the local machine and looked at all the good stuff that the BCL gives us when it comes to connecting to the <span class="No-Break">outside world.</span></p>
			<p>We looked at default protocols such as HTTP, FTP, and SMTP. We also looked at sockets in case the predefined protocols are not good enough, such as when you want to look up the current time from a time server. We dove into asynchronous networking and talked a lot about performance and making our networking error-proof and <span class="No-Break">more robust.</span></p>
			<p>Let’s be honest: almost no computer these days runs on its own. Most machines and thus the software running on them, are somehow connected to the outside world. Especially the things we as system programmers are interested in are not used by users, but instead by other software. Some of that software lives on other machines. This means it is imperative you know about networking. And now <span class="No-Break">you do!</span></p>
			<p>We did not talk about security and logging. Logging is something we touch on in <a href="B20924_11.xhtml#_idTextAnchor222"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>. Security is the topic of <a href="B20924_13.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>. Yes, these topics are so important they deserve their <span class="No-Break">own chapter.</span></p>
			<p>But before we go there, let’s take a little trip to other platforms. Since systems programming works closely with devices, I thought it would be fun to dive into another device and see if we could talk to some fancy hardware. So, let’s go <span class="No-Break">there next!</span></p>
		</div>
	</body></html>