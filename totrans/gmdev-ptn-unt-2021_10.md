使用对象池模式进行优化

在大多数视频游戏中，屏幕上发生了很多事情。子弹在四处飞行，敌人正在地图周围生成，粒子在玩家周围弹出，这些各种对象在瞬间被加载和渲染到屏幕上。因此，为了避免在保持一致帧率的同时对**中央处理器**（**CPU**）造成压力，为我们的频繁生成的实体预留一些内存是一个好习惯。所以，我们不是从内存中释放最近被摧毁的敌人，而是将它们添加到对象池中以便以后重用。使用这种技术，我们避免了加载实体新实例的初始初始化成本。此外，因为我们没有摧毁可重用实体，所以**垃圾收集器**（**GC**）不会浪费周期清理一组定期重新初始化的对象。

这就是我们将在本章中要做的，幸运的是，自从Unity版本2021以来，对象池已经原生集成到**应用程序编程接口**（**API**）中。因此，我们不需要像之前章节那样手动实现该模式；相反，我们将专注于学习如何使用它，并让引擎完成所有工作。

本章将涵盖以下主题：

+   理解对象池模式

+   实现对象池模式

+   检查替代解决方案

垃圾收集器（GC）作为一个自动的内存管理器，是大多数现代面向对象语言（如C#）的一个基本组件。为了继续本章的学习，不需要理解它是如何工作的，但如果您对此感兴趣，可以在此处获取更多相关信息：[https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/)。

# 技术要求

本章是实践性的，因此您需要对Unity和C#有一个基本的了解。

本章的代码文件可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter08](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter08)。

查看以下视频以查看代码的实际运行情况：

[https://bit.ly/3yTLcI7](https://bit.ly/3yTLcI7)

需要注意的是，下一节中的代码示例在低于2021.1版本的Unity中无法工作，因为我们使用了最近添加的API功能。

# 理解对象池模式

该模式的核心概念很简单——以容器形式存在的池在内存中保存了一组初始化后的对象。客户端可以请求对象池为其提供特定类型的对象实例；如果可用，它将从池中移除并分配给客户端。如果在某个时间点池中实例不足，新的实例将被动态创建。

离开池的对象将在不再被客户端使用后尝试返回池中。如果对象池没有更多空间，它将销毁尝试返回的对象实例。因此，池会不断被填充，只能暂时排空，但永远不会溢出。因此，其内存使用是稳定的。

以下图示了客户端与对象池之间的交互：

![](img/9355c03f-fadf-4748-af73-7b54075cd42c.png)

图8.1 – 对象池模式的统一建模语言（UML）图

在图中，我们可以看到对象池通过向客户端提供特定类型对象实例的池的访问来服务于客户端——例如，客户端可以是请求特定敌人类型实例的生成器。

## 对象池模式的好处和缺点

这些是对象池模式的一些好处：

+   **可预测的内存使用**：使用对象池，我们可以以可预测的方式分配一些内存来保存特定类型对象的一定数量的实例。

+   **性能提升**：由于对象已经在内存中初始化，因此避免了初始化新对象时的加载成本。

这些是对象池模式的一些潜在缺点：

+   **在已管理的内存上增加层级**：有些人批评对象池模式在大多数情况下是不必要的，因为现代托管编程语言如C#已经最优地控制了内存分配。然而，这个说法在某些情况下可能是正确的，但在其他情况下可能是错误的。

+   **不可预测的对象状态**：对象池模式的一个潜在陷阱是，如果处理不当，对象可能会以当前状态而不是初始状态返回池中。当池中的实体可受损或可破坏时，这种情况可能成为问题。例如，如果你有一个被玩家击败的敌人实体，如果你在恢复其健康之前将其返回池中，当对象池将其拉回给客户端时，它将以已损坏的状态重新生成到场景中。

## 何时使用对象池模式

为了更好地理解何时使用对象池模式，让我们回顾一下何时不应使用它。例如，如果你在地图上需要一次性生成实体，比如最终Boss，将其放入对象池就是浪费内存，这些内存本可以用于更有用的地方。

此外，我们还应该记住，对象池不是一个缓存。它有一个类似的目的——对象的复用。核心区别在于，对象池有一个机制，在实体使用后自动将其返回到池中，并且如果实现得当，对象池会根据池的可用大小来处理对象的创建和删除。

但假设我们在游戏过程中经常生成和销毁子弹、粒子以及敌人角色等实体。在这种情况下，对象池可以减轻我们对CPU施加的压力，通过减少重复的生命周期调用，例如创建和销毁，因此CPU将能够为更关键的任务保留处理能力。

在下一节中，我们将把刚刚学到的概念转化为代码。

# 实现对象池模式

在开始本节之前，阅读以下链接下`UnityEngine.Pool`命名空间中`IObjectPool<T0>`类的官方API文档是个好主意：

[https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Pool.ObjectPool_1.html](https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Pool.ObjectPool_1.html)

在实现以下代码示例时，我们将尽量避免陷入API规范中。相反，我们将专注于与对象池核心概念直接相关的关键元素。此外，原生对象池是Unity API的一个相对较新的功能，因此它可能会受到更改和更新的影响。因此，短期内关注文档是明智的。

## 实现对象池模式的步骤

本节的代码示例应该是相对直接的，我们应该能够分两步完成它，如下所示：

1.  让我们从实现我们的无人机开始，因为这是我们将要池化的实体。由于这个类非常长，我们将将其分为两个部分。您可以看到第一部分如下：

[PRE0]

在这个类段中，我们调用`ResetDrone()`方法是在`OnDisable()`事件函数中。我们这样做是因为我们想在将无人机返回池之前将其重置到初始状态。

并且正如我们将在实现对象池模式时看到的那样，当一个GameObject返回池中时，它会被禁用，包括所有其子组件。因此，如果我们有任何需要执行的重新初始化代码，我们可以在`OnDisable()`调用中执行。

在本章的上下文中，我们保持简单；我们只恢复无人机的健康。但在高级实现中，我们可能需要重置视觉标记，例如移除损坏的标记。

1.  在我们`Drone`类的最后一段中，我们将实现核心行为，如下所示：

[PRE1]

我们的无人机有两个关键行为，如下所述：

+   **自我销毁**: 我们的无人机的寿命很短；当它被启用时，会调用 `SelfDestruct()` 协程。几秒钟后，无人机通过耗尽其生命值并通过调用 `ReturnToPool()` 方法将自己返回池中而自我销毁。

+   **攻击**: 方法内的逻辑尚未实现，为了简洁起见。但想象一下，一旦无人机被生成，它会寻找并攻击玩家。

1.  接下来是我们的 `ObjectPool` 类，它负责管理无人机实例的池。由于它是一个较长的类，我们将分两部分来审查它，第一部分在此处提供：

[PRE2]

在脚本的第一部分，我们设置了一个名为 `maxPoolSize` 的关键变量；正如其名称所暗示的，这设置了我们将保留在池中的无人机实例的最大数量。`stackDefaultCapacity` 变量设置了默认的堆栈容量；这是我们用来存储无人机实例的堆栈数据结构的一个属性。我们可以暂时忽略它，因为它对我们实现不是关键的。

在以下代码片段中，我们正在初始化对象池，这是我们类中最关键的部分：

[PRE3]

重要的是要注意，我们在 `ObjectPool<T>` 类的构造函数中传递了回调方法，并且在这些回调中我们将实现驱动我们的对象池的逻辑。

1.  在 `DroneObjectPool` 类的最后一段，我们将实现我们在 `ObjectPool<T>` 构造函数中声明的回调，如下所示：

[PRE4]

下面是对 `ObjectPool` 类将在特定时间调用的每个回调的简要说明：

+   `CreatedPooledItem()`: 在这个回调中，我们正在初始化我们的无人机实例。在本章的上下文中，为了简单起见，我们从头开始创建一个 GameObject，但在更实际的情况下，我们可能会只是加载一个预制体。

+   `OnReturnedToPool()`: 方法的名称暗示了其用途。注意我们并没有销毁 GameObject；我们只是将其停用以从场景中移除。

+   `OnTakeFromPool()`: 当客户端请求无人机实例时，会调用此方法。实际上并没有返回实例——GameObject 被启用。

+   `OnDestroyPoolObject()`: 这是一个重要的方法，需要理解。当池中没有更多空间时，它会调用。在这种情况下，返回的实例会被销毁以释放内存。

我们的 `DroneObjectPool` 类承担了额外的责任，并充当生成器，正如我们在 `Spawn()` 方法中看到的。当请求时，它会从池中获取一个 `drone` 实例，并在场景中的特定范围内随机位置生成它。

## 测试对象池实现

要在您自己的 Unity 实例中测试我们的对象池实现，您需要执行以下步骤：

1.  创建一个新的空 Unity 场景。

1.  将我们刚刚审查的所有脚本复制并保存在您的项目中。

1.  在场景中添加一个空的 GameObject。

1.  将以下客户端脚本附加到您的空 GameObject 上：

[PRE5]

一旦你启动场景，你应该在左上角看到一个名为**Spawn Drones**的**图形用户界面**（**GUI**）按钮，如下截图所示：

![图片](img/4c618be6-fbe6-4ccb-aef1-ba042b8f4195.png)

图8.2 – 代码示例的实际截图

通过按下 **Spawn Drones** 按钮，你现在可以在场景中的随机位置生成无人机。如果你想看到对象池机制的实际应用，请关注场景层次结构——你将能够看到无人机实体在进入和退出池时被启用和禁用。

## 检查对象池实现

通过使用对象池模式，我们自动化了创建、销毁和池化无人机实例的过程。现在我们可以预留一定量的内存来生成无人机波次，同时避免给CPU带来负担。通过实现这个模式，我们在不牺牲可读性或增加复杂性的情况下，为我们的代码添加了优化和可扩展性。

在下一节中，我们将回顾一些可以考虑的替代方案；在决定特定的模式之前考虑其他选项总是一个好习惯。

# 检查替代方案

对象池模式的近亲是**原型**模式；这两个都被认为是创建型模式。使用原型模式，你可以通过使用克隆机制来避免创建新对象固有的成本。因此，而不是初始化新对象，你可以从称为原型的引用对象中克隆它们。但在本章所展示的使用案例的上下文中，对象池提供了更好的优化优势。

创建型模式关注对象创建的机制。**工厂**、**构建**、**单例**、**对象池**和**原型**都是创建型设计模式。

# 摘要

我们刚刚将对象池模式添加到我们的工具箱中——这是Unity开发者最有价值的模式之一。正如我们在代码示例中看到的，我们可以轻松地回收常用对象的实例。当处理需要快速且重复生成的大量实体时，这个模式可以帮助我们避免CPU峰值和延迟。这些好处只能帮助我们使游戏变得更好，因为玩家确实喜欢运行流畅的游戏。

在下一章中，我们将使用观察者模式将组件彼此解耦。
