- en: Chapter 8. Optimizing Computation Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章。优化计算表达式
- en: One of the most-used and unique features of F# is asynchronous workflow, and
    we have discussed this with the introduction to concurrency optimization in [Chapter
    4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction to Concurrency in
    F#"), *Introduction to Concurrency in F#*. The asynchronous workflow itself is
    actually an implementation of a computation expression, a feature that enables
    us to have a computation. This computation is, in fact, a sequence of workflows
    of functions that is composed sequentially and has bindings to bind or combine
    them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: F# 最常用且独特的特性之一是异步工作流程，我们在 [第四章](fsp-hiperf_cu04.html#aid-11C3M2 "第四章。F# 并发介绍")，*F#
    并发介绍*中讨论了这一点。异步工作流程本身实际上是一种计算表达式的实现，这是一种使我们能够进行计算的功能。实际上，这种计算是一系列按顺序组成的函数工作流程，并且有绑定来绑定或组合它们。
- en: The computation expression has many kinds of helper methods to implement, but
    using these helpers can be overkill, and it may have some overheads as well if
    it is not constructed properly. It is not as subtle and hard as the previous discussion
    on language constructs in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算表达式有许多种辅助方法来实现，但使用这些辅助方法可能是过度设计，如果构建不当，还可能有一些开销。它并不像第七章中关于语言构造的讨论那样微妙和困难，*语言特性和构造优化*。
- en: 'In this chapter, we will focus our optimization on the implementation of computation
    workflows with the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于以下主题的计算工作流程实现优化：
- en: Quick introduction to F# computation workflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 计算工作流程的快速介绍
- en: Walkthrough of an example implementation of simple computation workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单计算工作流程的示例实现概述
- en: Design consideration in planning the computation workflow implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划计算工作流程实现的设计考虑
- en: Considerations of computation expression optimization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算表达式优化的考虑
- en: Quick introduction to F# computation expression
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 计算表达式的快速介绍
- en: One of the quite subtle, but quite common, traits of a functional programming
    language is the availability of features to combine and compose functions into
    more sophisticated conceptual techniques that also encapsulate some side effects
    when combining functions. Some of these techniques are known as Monoids and Monads.
    These two come from the world of a subset of algebra, the category theory. This
    mathematical foundation gives the inspiration and also powerful concepts when
    composing and combining functions, including side effects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言的一个相当微妙但相当常见的特性是具有将函数组合和组合成更复杂的概念技术的能力，这些技术结合函数时也封装了一些副作用。其中一些技术被称为 Monoids
    和 Monads。这两个概念来自代数的一个子集，即范畴论。这个数学基础为组合和组合函数（包括副作用）提供了灵感和强大的概念。
- en: 'For a more gentle introduction and information to Monads in functional programming,
    you could watch this MSDN Channel 9 interview with Microsoft''s developer Brian
    Beckman:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更温和的介绍和关于函数式编程中 Monads 的信息，你可以观看微软开发者 Brian Beckman 在 MSDN Channel 9 的访谈：
- en: '[https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads](https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[Brian Beckman 不怕 Monads](https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads)'
- en: The best sample of F# computation expression is the asynchronous workflow. The
    term workflow in asynchronous workflow comes from the fact that it is implemented
    from the use of the computation expression feature to provide asynchronous computation.
    Asynchronous workflow is itself composed from functions with side effects such
    as switching the context execution of the current thread.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: F# 计算表达式最佳示例是异步工作流程。异步工作流程中的“工作流程”一词来源于它是由计算表达式功能的使用实现的，以提供异步计算。异步工作流程本身是由具有副作用（如切换当前线程的上下文执行）的函数组成的。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We already have discussed these F# concurrencies including asynchronous workflow
    cases in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#* that asynchronous
    computations do not always equate to the needs of multithreading.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 4 章](fsp-hiperf_cu04.html#aid-11C3M2 "第 4 章。F# 并发简介")，*F# 并发简介* 中讨论了这些
    F# 并发，包括异步工作流案例，指出异步计算并不总是等同于多线程的需求。
- en: In F#, the composition of functions is done using builders. These builders are
    actually methods that help us construct a composition of functions. From the perspective
    of design patterns in OOP, these methods can be seen as helper methods or builder
    methods because they focus on building computation expressions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，函数的组合是通过构建者完成的。这些构建者实际上是帮助我们构建函数组合的函数。从面向对象设计模式的角度来看，这些方法可以被视为辅助方法或构建方法，因为它们专注于构建计算表达式。
- en: Sometimes the composition of functions might contain conditional logic to handle
    side effects, such as threads, execution context (such as asynchronous workflow),
    I/O, and many more. The conditional logic is quite similar to workflow concepts
    whereas execution is always implemented as a sequence of steps. When conditional
    logic is needed, the execution always follows the branches of conditional logic
    based on the expression evaluated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时函数的组合可能包含条件逻辑来处理副作用，例如线程、执行上下文（如异步工作流）、I/O 等。条件逻辑与工作流概念相当相似，而执行始终以一系列步骤的形式实现。当需要条件逻辑时，执行总是根据评估的表达式遵循条件逻辑的分支。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Earlier, F# language specification and MSDN Library mentioned computation expression
    as getting mixed with computation workflow. Since F# 3.0, the language specification
    is consistent and stricter to focus on computation expressions, not workflow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，F# 语言规范和 MSDN 图书馆提到计算表达式与计算工作流混合。自 F# 3.0 以来，语言规范一直保持一致且更加严格，专注于计算表达式，而不是工作流。
- en: 'Based on the official F# 4.0 language specification, the computation workflow
    syntax is often used by starting to have a construct using `builder-name` and
    the enclosing curly brackets as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 F# 4.0 的官方语言规范，计算工作流语法通常从使用 `builder-name` 和括号开始，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The expression itself might be functions as defined (and also governed) by the
    builders of the computation expressions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式本身可能是函数，这些函数由计算表达式的构建者定义（并管理）。
- en: 'For an initial example of the computation expression syntax, let''s revisit
    our own sample code for `async` workflow:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示计算表达式语法的初始示例，让我们回顾一下我们自己的 `async` 工作流示例代码：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding sample code uses `Control.AsyncBuilder`, a builder of `async`.
    The F# compiler will translate `AsyncBuilder` to a computation expression of `async`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例代码使用了 `Control.AsyncBuilder`，这是一个 `async` 的构建者。F# 编译器会将 `AsyncBuilder` 转换为
    `async` 的计算表达式。
- en: 'We will now go deeper into the fabric of computation expressions: builders
    of computation expressions. We will also create a simpler computation expression
    than asynchronous workflow as a starting sample in the next section.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更深入地探讨计算表达式的结构：计算表达式的构建者。我们还将创建一个比异步工作流更简单的计算表达式，作为下一节的起始示例。
- en: Introduction to builders of computation expression
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算表达式构建者简介
- en: The notion, *builder*, also means that we construct a computation workflow by
    using the available builders when composing functions. These builders are actually
    methods that can be used when composing functions as a computation expression.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “构建者”这一概念还意味着我们在组合函数时，通过使用可用的构建者来构建计算工作流。这些构建者实际上是组合函数时可以使用的函数。
- en: 'The following table briefly explains the commonly used builders in F# 4.0:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下表简要介绍了 F# 4.0 中常用的构建者：
- en: '| **Method** | **Typical Signature** | **Remark** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **典型签名** | **备注** |'
- en: '| `Bind` | `M<''T> * (''T -> M<''U>) -> M<''U>` | Provide `let!` and `do!`
    in a computation expression. It is a basic method to compose functions. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `Bind` | `M<''T> * (''T -> M<''U>) -> M<''U>` | 在计算表达式中提供 `let!` 和 `do!`。这是组合函数的基本方法。|'
- en: '| `Delay` | `(unit -> M<''T>) -> M<''T>` | Wraps a computation expression as
    a function. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Delay` | `(unit -> M<''T>) -> M<''T>` | 将计算表达式包装为一个函数。|'
- en: '| `Return` | `''T -> M<''T>` | Equivalent to `return` in computation expression.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Return` | `''T -> M<''T>''` | 等同于计算表达式中的 `return`。|'
- en: '| `ReturnFrom` | `M<''T> -> M<''T>` | Equivalent to `return!` in computation
    expressions. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `ReturnFrom` | `M<''T> -> M<''T>` | 等同于计算表达式中的 `return!`。|'
- en: '| `Run` | `M<''T> -> M<''T> or M<''T> -> ''T` | Executes a computation expression.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `Run` | `M<''T> -> M<''T> or M<''T> -> ''T` | 执行计算表达式。|'
- en: '| `TryWith` | `M<''T> * (exn -> M<''T>) -> M<''T>` | Called for `try..with`
    to catch exception (`exn`) in a computation expression. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `TryWith` | `M<''T> * (exn -> M<''T>) -> M<''T>` | 在计算表达式中调用`try..with`以捕获异常（`exn`）。|'
- en: '| `TryFinally` | `M<''T> * (unit -> unit) -> M<''T>` | Called for `try..finally`
    in computation expression. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `TryFinally` | `M<''T> * (unit -> unit) -> M<''T>` | 在计算表达式中调用`try..finally`。|'
- en: '| `Using` | `''T * (''T -> M<''U>) -> M<''U> when ''U :> IDisposable` | Called
    from `use` binding in computation expression. It is equivalent to `using!` in
    computation expression. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Using` | `''T * (''T -> M<''U>) -> M<''U> when ''U :> IDisposable` | 从计算表达式中的`use`绑定调用。它在计算表达式中等同于`using!`。'
- en: '| `Yield` | `''T -> M<''T>` | Called for `yield` in computation expression.
    It is conceptually the same as `yield` in C#/VB, but the semantic is different.
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `Yield` | `''T -> M<''T>` | 在计算表达式中调用`yield`。在概念上与C#/VB中的`yield`相同，但语义不同。|'
- en: '| `YieldFrom` | `M<''T> -> M<''T>` | Called for `yield!` in computation expression.
    It is conceptually the same as `yield` in C#/VB, but the semantic is different.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `YieldFrom` | `M<''T> -> M<''T>` | 在计算表达式中调用`yield!`。在概念上与C#/VB中的`yield`相同，但语义不同。|'
- en: '| `Zero` | `unit -> M<''T>` | Called when there is an empty `else` in the `if`
    condition (if there is an `if` statement in the computation expression). It is
    also called when the computation expression has an empty expression. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Zero` | `unit -> M<''T>` | 当`if`条件中有空`else`时调用（如果计算表达式中有一个`if`语句）。当计算表达式有一个空表达式时也会调用。|'
- en: 'For more information about computation expression and the full list of builder
    methods, consult the official MSDN F# computation expression on the new Microsoft''s
    docs:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于计算表达式和完整构建器方法列表的信息，请参考新微软文档中的官方MSDN F#计算表达式：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions)'
- en: 'We do not have to implement all of the builder methods because there are no
    definitive minimum requirements of a computation expression. However, we should
    have the basic requirements of understanding in order to use a computation expression
    implementation to be used easily. The following are the common requirements in
    terms of usage requirement with builder methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要实现所有构建器方法，因为没有计算表达式的明确最小要求。然而，为了能够轻松使用计算表达式实现，我们应该有基本的理解要求。以下是与构建器方法使用要求相关的常见要求：
- en: A bind to compose functions. This `Bind` method will contain a composition of
    functions. An implementation of `Bind` is recommended because the expressions
    supported inside a computation expression are governed by the types defined in
    the `Bind` method. For example, composing functions that have the same generic
    type.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于组合函数的绑定。这个`Bind`方法将包含函数的组合。建议实现`Bind`，因为计算表达式内部支持的表达式受`Bind`方法中定义的类型所控制。例如，组合具有相同泛型类型的函数。
- en: A type to return. This requirement enforces us to implement `Return` or `ReturnFrom`.
    This is important because computation expressions must return a type, and it is
    recommended not to return `unit` (or `void` in .NET and C#).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要返回的类型。这个要求强制我们实现`Return`或`ReturnFrom`。这很重要，因为计算表达式必须返回一个类型，并且建议不要返回`unit`（或在.NET和C#中的`void`）。
- en: '`Delay`, to wrap a computation expression as a function. It is also quite common
    to call the `Delay` method as a wrapper method.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delay`，将计算表达式包装为函数。通常也将`Delay`方法作为包装方法调用。'
- en: '`Using`, to leverage the use of a type that implements `IDisposable`. This
    will be translated as `use` binding inside the computation workflow.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using`，用于利用实现`IDisposable`的类型。这将在计算工作流中翻译为`use`绑定。'
- en: '`TryWith`, to handle exceptions inside a composition of functions of `Bind`
    or explicitly handle exceptions outside `Bind`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryWith`，用于处理`Bind`函数组合内的异常或显式处理`Bind`之外的异常。'
- en: The `Bind` method is crucial because it governs the type of generic type in
    the functions we are going to compose, but it is also enforcing all the types
    of the `let!` and `do!` functions inside a computation expression. Omitting `Bind`
    will make the computation expressions to be less complete because the main goal
    of a computation expression is the ability to compose expressions, not just returning
    the underlying type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 方法至关重要，因为它决定了我们将要组合的函数中泛型类型的形式，但它也强制执行计算表达式内部 `let!` 和 `do!` 函数的所有类型。省略
    `Bind` 将使计算表达式变得不完整，因为计算表达式的主要目标是组合表达式的能力，而不仅仅是返回底层类型。'
- en: 'In the case of our previous sample code for asynchronous workflow, the following
    is the illustration of `Bind` as `let!` in an asynchronous workflow:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前关于异步工作流的示例代码中，以下是对异步工作流中 `Bind` 作为 `let!` 的说明：
- en: '![Introduction to builders of computation expression](img/image00327.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![计算表达式构建器的介绍](img/image00327.jpeg)'
- en: 'The default distribution of the F# core library already has samples of implementations
    of computation expressions with its own underlying type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: F# 核心库的默认分布已经包含了计算表达式实现的示例，其底层类型为：
- en: LINQ query expressions support that returns `System.Linq.Enumerable<'T>`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ 查询表达式支持返回 `System.Linq.Enumerable<'T>`
- en: Asynchronous workflow returns `Async<'T>`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步工作流返回 `Async<'T>`
- en: 'F# LINQ query expression is a little bit subtle, but actually it has implementation
    details similar to LINQ used in C#/VB. It is semantically the same; therefore,
    the performance characteristics are also similar to running LINQ in C#/VB. The
    difference between F# and C#/VB implementation is the type of delegates used:
    `FastFunc` in F#, `Func` in C#/VB.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: F# LINQ 查询表达式稍微有些微妙，但实际上它的实现细节与 C#/VB 中使用的 LINQ 类似。在语义上是相同的；因此，性能特征也与在 C#/VB
    中运行 LINQ 类似。F# 与 C#/VB 实现之间的区别在于使用的委托类型：F# 中的 `FastFunc`，C#/VB 中的 `Func`。
- en: This strong recommendation of F# function over `Func` is crucial and important
    because the method signature of all method builders use F# curried functions instead
    of the normal .NET method signature.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对 F# 函数相对于 `Func` 的强烈推荐至关重要且重要，因为所有方法构建器的签名都使用 F# 柔性函数而不是正常的 .NET 方法签名。
- en: Using F# function/delegate over .NET Func
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 F# 函数/委托而非 .NET Func
- en: Usage of F# delegate instead of a normal .NET `Func` is also more efficient
    and more functional because of the immediate feature to have F# delegate as a
    function that supports currying; this allows for a higher order function after
    the availability of a partial function application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 F# 委托而不是正常的 .NET `Func` 的用法也更为高效和功能化，因为 F# 委托作为支持柔性的函数的即时特性；这允许在部分函数应用可用后使用高阶函数。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we are developing applications that use our own implementation of computation
    expressions, of course, it is faster and highly recommended to use F# function/delegate
    instead of using .NET `Func`. It is highly compatible with the rest of F# constructs/features,
    and it is faster to compile in F#. It is highly recommended due to the availability
    of function currying.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发使用我们自己的计算表达式实现的应用程序时，当然，使用 F# 函数/委托而不是使用 .NET `Func` 会更快，并且强烈推荐这样做。它与 F#
    的其他构造/特性高度兼容，并且在 F# 中编译更快。由于函数柔性的可用性，这被高度推荐。
- en: Proof that F# functions are optimized for supporting currying functions is available
    in the way F# supports higher order functions. Microsoft has documented this,
    and it is wrapped in a very nice walkthrough guide for functional programming
    traits/characteristics, focusing on function as first class values. The concept
    of function as first class values is then compared to classes and method as first
    class values of OOP.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: F# 函数优化以支持柔性函数的证明在于 F# 支持高阶函数的方式。微软已经记录了这一点，并在一个非常好的功能编程特性/特征教程中进行了包装，重点关注函数作为一等值。函数作为一等值的理念随后与类和作为面向对象一等值的类方法进行了比较。
- en: 'The starting information about function as first class values and F# currying
    is available in this MSDN docs page of F# functional programming traits:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数作为一等值和 F# 柔性函数的起始信息可在 F# 功能编程特性 MSDN 文档页面中找到：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values)'
- en: 'On that page, we focus on the implied currying of F# in the section on curried
    function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一页上，我们在关于高阶函数的部分关注了 F# 的隐式高阶函数：
- en: '*Currying is a process that transforms a function that has more than one parameter
    into a series of embedded functions, each of which has a single parameter. In
    F#, functions that have more than one parameter are inherently curried.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*高阶函数是一个将具有多个参数的函数转换为一系列嵌套函数的过程，每个嵌套函数只有一个参数。在 F# 中，具有多个参数的函数天生就是高阶函数。*'
- en: The implications of currying highly influence the language design of F#; hence,
    a special or unique F# function/delegate is needed. In the general .NET BCL, this
    F# unique implementation of a curried function is becoming very important and
    critical from the perspective of functional programming language architecture
    because `Func` does not support currying.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数对 F# 的语言设计产生了深远的影响；因此，需要一个特殊的或独特的 F# 函数/委托。在一般的 .NET BCL 中，这种独特的 F# 高阶函数实现正变得越来越重要和关键，因为
    `Func` 不支持高阶函数。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are not going to dive deeper into the discussion of what is functional programming
    and the traits of functional programming language. Consult more of functional
    programming concepts in F# and the functional programming support in F# in the
    preceding MSDN docs page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论什么是函数式编程以及函数式编程语言的特性。有关 F# 中的更多函数式编程概念和 F# 中的函数式编程支持，请参阅前面的 MSDN 文档页面。
- en: 'For example, let''s examine the common (typical) signature of the `Bind` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们检查 `Bind` 方法的常见（典型）签名：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This signature means that the function returns `M<'U>` as its result, as indicated
    by the type signature after the last `->`. The `*` between two types before the
    last `->` means that the method takes two arguments-one is a normal type and the
    second parameter is a function that takes a generic `T` returns a type with a
    type of `M<'U>`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名意味着函数返回 `M<'U>` 作为其结果，如最后 `->` 之后的类型签名所示。最后 `->` 之前两个类型之间的 `*` 表示该方法接受两个参数——一个是普通类型，第二个参数是一个接受泛型
    `T` 并返回类型为 `M<'U>` 的函数。
- en: The use of `*` in the signature of a method member of a class means that the
    types (before the resulting type) are seen as the arguments of a method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的成员方法签名中使用 `*` 表示，类型（在结果类型之前）被视为方法的参数。
- en: 'The function of `(''T -> M<''U>)` means a function that takes one argument
    of `''T` and returns a result. This argument does not have to be one argument.
    We can also use more functions that have more than one argument, such as this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`(''T -> M<''U>)` 函数表示一个接受 `''T` 类型的单个参数并返回结果的函数。这个参数不一定是单个参数。我们也可以使用具有多个参数的更多函数，例如：'
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `M<'V'>` is the result.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`M<'V'>` 是结果。
- en: 'The signature of `''T -> ''U` before the last -> means that the function has
    two arguments, typed generic `T` and `U`. We can then change and adapt the signature
    of `Bind` to be like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后 `->` 之前的 `'T -> 'U'` 签名表示该函数有两个参数，类型为泛型 `T` 和 `U`。然后我们可以将 `Bind` 的签名更改和调整为如下所示：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can then start to implement our `Bind` method. However, be careful as the
    `let!` and `do!` constructs are altered quite large, and it's better for us to
    implement computation expressions as simply as possible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始实现我们的 `Bind` 方法。但是，请注意，`let!` 和 `do!` 构造被修改得相当大，因此最好尽可能简单地实现计算表达式。
- en: Relation of F# function computation expressions with arguments restriction
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F# 函数计算表达式与参数限制的关系
- en: We can also use many arguments, but it is quite common to only use a function
    with one argument as long as the type is lined up well. If we use more than one
    argument, our `Bind` method implementation will be more complex, and it will always
    be harder to construct semantically correct computation expressions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用许多参数，但只要类型对齐得当，通常只使用一个参数的函数就足够了。如果我们使用多个参数，我们的 `Bind` 方法实现将更加复杂，并且构建语义正确的计算表达式将始终更加困难。
- en: Not just the generic types have to be aligned carefully; it is also more complex
    to implement `Bind` with many parameters. The F# language specification also implies
    that the current F# 4.0 compiler (especially the lexer and parser) is preferred
    instead of using `Func`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅需要仔细对齐泛型类型；实现具有多个参数的 `Bind` 也更加复杂。F# 语言规范还暗示，当前 F# 4.0 编译器（特别是词法和语法分析器）更倾向于使用
    `Func`。
- en: This complexity of having an implementation of `Bind` method with parameters
    will become clearer by having samples of computation expressions with `Bind`.
    The next section is the starting point of a sample of computation expression.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过具有 `Bind` 参数的实现示例，这种具有 `Bind` 的计算表达式的复杂性将变得更加清晰。下一节是计算表达式示例的起点。
- en: Walkthrough of planning and writing a computation expression
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算表达式的规划和编写指南
- en: Let's start writing a very simple functional way of creating a **WPF** (**Windows
    Presentation Foundation**) window and composing WPF controls.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一个非常简单的创建 **WPF**（**Windows Presentation Foundation**）窗口和组合 WPF 控件的函数式方法。
- en: WPF is basically a UI framework implemented on top of DirectX 9.0c that starts
    from the release of .NET 3.0 as libraries of UI. It is still aggressively developed
    by Microsoft, and with the release of WPF comes the innovation of XAML as a declarative
    UI. It has been heavily supported since Visual Studio 2008, and now it is beginning
    to replace Windows Forms.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 基本上是在 DirectX 9.0c 上实现的 UI 框架，从 .NET 3.0 的发布开始作为 UI 库。它仍然由微软积极开发，随着 WPF
    的发布，XAML 作为声明性 UI 的创新也随之而来。自 Visual Studio 2008 以来，它一直得到大力支持，现在它开始取代 Windows Forms。
- en: This slightly unfortunate fate of Windows Forms becomes more apparent with the
    introduction of Visual Studio 2012 and .NET 4.5; Windows Forms are no longer developed
    (although they are still supported in terms of bug fixes), but they have not yet
    been deprecated or become obsolete. It is considered as replacing Windows Forms
    because WPF is still developed heavily, at least not just in Visual Studio 2015/.NET
    4.6.1, but it is also evident in the upcoming version of Visual Studio 2015, the
    Visual Studio 2017.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Forms 的这种略显不幸的命运在 Visual Studio 2012 和 .NET 4.5 的推出时变得更加明显；Windows Forms
    已不再开发（尽管它们在错误修复方面仍然得到支持），但它们尚未被弃用或过时。这被认为是替代 Windows Forms，因为 WPF 仍在积极开发中，至少在
    Visual Studio 2015/.NET 4.6.1 中是这样，在即将推出的 Visual Studio 2015 和 Visual Studio 2017
    中也是如此。
- en: For more information about WPF, visit the official home page of WPF on MSDN
    at [https://msdn.microsoft.com/en-us/library/ms754130(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms754130(v=vs.110).aspx).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 WPF 的信息，请访问 MSDN 上 WPF 的官方主页 [https://msdn.microsoft.com/en-us/library/ms754130(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms754130(v=vs.110).aspx)。
- en: 'Before starting to implement WPF composition using computation expressions,
    we need to have some basic idea to understand the following (as design consideration
    plans) before having code implementations of WPF:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用计算表达式实现 WPF 组合之前，我们需要有一些基本概念来理解以下内容（作为设计考虑计划），然后再有 WPF 的代码实现：
- en: All WPF control derives from `System.Windows.FrameworkElement`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 WPF 控件都派生自 `System.Windows.FrameworkElement`。
- en: The WPF window is called `System.Windows.Window`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 窗口被称为 `System.Windows.Window`。
- en: On the `Window`, all of the controls (typed as `UIElement`) to be put are usually
    laid on a container panel that is inherited from `System.Windows.Controls.Panel`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Window` 上，所有要放置的控件（类型为 `UIElement`）通常都放置在一个继承自 `System.Windows.Controls.Panel`
    的容器面板上。
- en: The adding of controls on `Panel` has to be carefully designed to exclude `Window`
    as it will not make sense if we add `Window` on to `Panel`, although `Window`
    inherits `System.Windows.Controls.Control` and `System.Windows.UIElement`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Panel` 上添加控件必须精心设计，以排除 `Window`，因为如果我们把 `Window` 添加到 `Panel` 上，那就没有意义了，尽管
    `Window` 继承自 `System.Windows.Controls.Control` 和 `System.Windows.UIElement`。
- en: 'There are special treatments of a `Panel` to be taken into account: the knowledge
    of what a `Panel` is and why it is not available to be used directly.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑对 `Panel` 的特殊处理：了解 `Panel` 是什么以及为什么它不能直接使用。
- en: This is the proof that we cannot use `Panel` directly because `Panel` is implemented
    as an abstract class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们无法直接使用 `Panel`，因为 `Panel` 被实现为一个抽象类。
- en: 'The following is the `System.Windows.Controls.Panel` declaration in F#:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 F# 中 `System.Windows.Controls.Panel` 的声明：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `AbstractClass` attribute is the same semantic as marking the class as
    abstract class. Abstract class in F# is treated using the `AbstractClass` attribute,
    not as a keyword as in C#/VB:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractClass` 属性与将类标记为抽象类的语义相同。在 F# 中，使用 `AbstractClass` 属性处理抽象类，而不是像在 C#/VB
    中那样使用关键字：'
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To avoid confusion, we should know the OOP concept and keywords in F#, while
    at the same time relating and interoperating with OOP in C#/VB. This conceptual
    knowledge is increasingly relevant because it's quite common that in developing
    WPF application, we rely on inheritances and componentizations of OOP controls.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，我们应该了解F#中的OOP概念和关键字，同时与C#/VB中的OOP进行关联和交互。这种概念知识越来越相关，因为在开发WPF应用程序时，我们通常依赖于OOP控件的继承和组件化。
- en: 'Before we start utilizing WPF, ensure that the following assemblies are referenced
    or registered (if you are in the scripting interactive mode):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用WPF之前，确保以下程序集被引用或注册（如果你处于脚本交互模式）：
- en: '`WindowsBase`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WindowsBase`'
- en: '`PresentationCore`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PresentationCore`'
- en: '`PresentationFramework`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PresentationFramework`'
- en: '`System.Xaml`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Xaml`'
- en: 'For scripting mode, these assemblies have to be registered first by directly
    registering the location of the DLL. In the following sample, we register the
    assemblies with 32-bit assemblies:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于脚本模式，这些程序集必须首先通过直接注册DLL的位置进行注册。在下面的示例中，我们使用32位程序集注册程序集：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After registering all the required DLL assemblies, we should tell the F# compiler
    to scope the namespace of WPF to be available in our script:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册所有必需的DLL程序集之后，我们应该告诉F#编译器将WPF的命名空间作用域设置为在脚本中可用：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The open namespace is also useful because it will shorten our naming of WPF
    type not to use full type name with the namespace. It is semantically similar
    to the `Using` keyword in C# and `Import` in VB.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 开放命名空间也很有用，因为它将缩短我们为WPF类型命名的长度，无需使用带有命名空间的完整类型名。它在语义上类似于C#中的`Using`关键字和VB中的`Import`。
- en: 'We can start from just creating `Window` with `Panel`, but we can also use
    an abstract class as a template for `Window` with `Panel` and `Panel` with controls
    because both `Window` and `Panel` extend `FrameworkElement`, as illustrated in
    this image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从仅创建带有`Panel`的`Window`开始，但也可以使用抽象类作为带有`Panel`的`Window`和带有控件的`Panel`的模板，因为`Window`和`Panel`都扩展了`FrameworkElement`，如图所示：
- en: '![Walkthrough of planning and writing a computation expression](img/image00328.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![计算表达式的规划和编写流程图](img/image00328.jpeg)'
- en: 'Next, we are going to implement our abstract class as a template for our builder:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现我们的抽象类作为构建器的模板：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Based on the knowledge that `Window` and `Panel` inherit from the same `FrameworkElement`,
    we can continue to have the implementation of our own `Window` builder as a computation
    expression:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于已知`Window`和`Panel`都继承自相同的`FrameworkElement`，我们可以继续实现我们自己的`Window`构建器作为一个计算表达式：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the implementation of `PanelBuilder`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`PanelBuilder`的实现：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `PanelBuilder` implementation, we add type checking for `c` (as highlighted).
    If it is typed as `Window`, we should raise `System.ArgumentException` to inform
    us further that we cannot use `Window` to be added onto `Panel`. We can also return
    `null` as an option instead of `Exception`, but returning `null` is not recommended
    in F#, and it also adds more confusion on what is being added. Also, the code
    is not composed well. Any bad composition in `Bind` will always increase the unpredictability
    of the computation expression. Further information on this consideration is described
    in the next section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PanelBuilder`实现中，我们为`c`添加了类型检查（如高亮所示）。如果它被类型化为`Window`，我们应该引发`System.ArgumentException`来进一步通知我们不能将`Window`添加到`Panel`上。我们也可以选择返回`null`而不是异常，但在F#中返回`null`是不推荐的，它也会增加对添加内容的混淆。此外，代码的组成也不够好。`Bind`中的任何不良组合都会增加计算表达式的不可预测性。关于这一考虑的更多信息将在下一节中描述。
- en: Because of the fact that we derive `WindowBuilder` and `PanelBuilder` from the
    `IComposableControl` abstract class, we must also implement all of the abstract
    methods of `IComposableControl`. The implemented method must have an override
    modifier to denote that the method is an implementation of abstract methods from
    `IComposableControl`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从`IComposableControl`抽象类派生了`WindowBuilder`和`PanelBuilder`，我们必须实现`IComposableControl`的所有抽象方法。实现的方法必须有一个`override`修饰符来表示该方法是对`IComposableControl`中抽象方法的实现。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are not going to have a full discussion on OOP features of F# because it
    is outside the scope of this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对F#的OOP特性进行全面的讨论，因为这不属于本书的范围。
- en: For more information on abstract method and overrides, consult MSDN docs at [https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/methods](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/methods).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解抽象方法和重写（overrides）的更多信息，请查阅MSDN文档，链接为[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/methods](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/methods)。
- en: 'Now that we have the builders implemented, we can set the builders in action:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了构建器，我们可以将构建器投入实际使用：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code will display the following window:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将显示以下窗口：
- en: '![Walkthrough of planning and writing a computation expression](img/image00329.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![规划与编写计算表达式的演练](img/image00329.jpeg)'
- en: To test for `Zero`, we can simply test it by having an empty expression in the
    computation expression.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`Zero`，我们可以在计算表达式中简单地使用一个空表达式进行测试。
- en: 'This is an example of `Zero` in our `WindowBuilder`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`WindowBuilder`中`Zero`的一个示例：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is a subtle feature, but we have used it and most of us are unaware:
    the builder object; when it is instantiated, the F# compiler will treat the instance
    as a keyword!'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的功能，但我们已经使用了它，而大多数人可能并未意识到：构建器对象；当它被实例化时，F# 编译器会将该实例视为一个关键字！
- en: This translation of a computation expression instance becoming a keyword is
    already demonstrated by asynchronous workflow by instantiating `AsyncBuilder`
    as `async`. Therefore, the usage of `async` instance will be treated as a keyword.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将计算表达式实例转换为关键字的翻译已经通过将`AsyncBuilder`实例化为`async`来由异步工作流演示。因此，`async`实例的使用将被视为一个关键字。
- en: 'In the case of `WindowBuilder`, the instance of `WindowBuilder` will be treated
    as a keyword too. For example, the following is a sample instance of `WindowBuilder`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WindowBuilder`的情况下，`WindowBuilder`的实例也将被视为一个关键字。例如，以下是一个`WindowBuilder`的示例实例：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In Visual Studio, the preceding treatment of `windowexp` as a keyword is shown
    in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，前面将`windowexp`视为关键字的处理方式在以下屏幕截图中有展示：
- en: '![Walkthrough of planning and writing a computation expression](img/image00330.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![规划与编写计算表达式的演练](img/image00330.jpeg)'
- en: Now we have `windowexp` as an instance of `WindowBuilder()`, and we can use
    it as a `windowexp` computation expression keyword. This is shown by having a
    blue color just like the other F# keywords.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`windowexp`作为`WindowBuilder()`的实例，我们可以将其用作`windowexp`计算表达式关键字。这通过蓝色显示，就像其他F#关键字一样。
- en: We have created a simple computation expression that has `Bind`, `Return`, and
    `Zero`. Let's peek into the implementation of a computation expression inside
    an asynchronous workflow.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的计算表达式，其中包含`Bind`、`Return`和`Zero`。让我们窥视异步工作流中计算表达式的实现。
- en: The implementation of `AsyncBuilder` for an asynchronous computation also follows
    the same pattern as the implementation of `WindowBuilder` and `PanelBuilder`;
    it defines the method builder first, although the implementation does not use
    an abstract class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步计算，`AsyncBuilder`的实现遵循与`WindowBuilder`和`PanelBuilder`相同的模式；它首先定义方法构建器，尽管实现中并未使用抽象类。
- en: 'It is quite easy to examine the implementation of F# asynchronous workflow
    because we can directly examine the source code. The following is the landing
    page of F# core libraries (`FSharp.Core`) source code, including the F# compiler
    implementation and F# tooling:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 检查F#异步工作流的实现相当容易，因为我们可以直接检查源代码。以下是F#核心库（`FSharp.Core`）源代码的着陆页，包括F#编译器实现和F#工具：
- en: '[https://github.com/Microsoft/visualfsharp/tree/master/src](https://github.com/Microsoft/visualfsharp/tree/master/src)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Microsoft/visualfsharp/tree/master/src](https://github.com/Microsoft/visualfsharp/tree/master/src)'
- en: 'Let''s look at the type declaration and the code of `AsyncBuilder` in the `control.fs`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看`control.fs`文件中`AsyncBuilder`的类型声明和代码：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the members are implicitly `public static` methods, so it is again very
    succinct to quickly implement.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有成员都是隐式声明的`public static`方法，因此快速实现起来非常简洁。
- en: 'Let''s visit the `Bind` method implementation, the `bindA`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看`Bind`方法实现中的`bindA`：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we want to check the signature of `AsyncBuilder.Bind`, the signature is
    in the `Controls.fsi` file. The following is the signature:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检查`AsyncBuilder.Bind`的签名，该签名位于`Controls.fsi`文件中。以下是其签名：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Bind` signature defines that the method takes two arguments: computation
    and binder. The computation argument is typed as `Async<''T>`, the binder is typed
    as `''T -> Async<''U>`, and the return type is `Async<''U>`, the generic parameter
    of `''U` is the underlying type. This `Bind` method is then called if we are using
    `let!` within the asynchronous workflow construct.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind`签名定义了该方法接受两个参数：计算和绑定器。计算参数的类型为`Async<''T>`，绑定器的类型为`''T -> Async<''U>`，返回类型为`Async<''U>`，`''U`的泛型参数是底层类型。如果我们使用异步工作流构造中的`let!`，则调用此`Bind`方法。'
- en: Understanding the use of type returned in computation expression
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解计算表达式中返回类型的用法
- en: 'There is an apparent pattern of `let!`, `return`, and `return!` expressions
    in the computation expression. The use of the bang sign `!` as a suffix means
    that these expressions return the underlying type directly without any wrapper
    type. For example, `return!` will call the `ReturnFrom` method and `return` will
    call the `Return` method. In the case of F# asynchronous workflow, we can just
    see the signature comparison of `Return` and `ReturnFrom`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算表达式中，存在一个明显的`let!`、`return`和`return!`表达式的模式。使用感叹号`!`作为后缀意味着这些表达式直接返回底层类型，而不需要任何包装类型。例如，`return!`将调用`ReturnFrom`方法，而`return`将调用`Return`方法。在F#异步工作流的情况下，我们可以看到`Return`和`ReturnFrom`的签名比较：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the explanation of the implication of the underlying type:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对底层类型含义的解释：
- en: The `ReturnFrom` will return the resulting type immediately without the wrapping
    type. In practice, it returns `'T` instead of `Async<'T>`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReturnFrom`将立即返回结果类型，而不包含包装类型。在实践中，它返回`''T`而不是`Async<''T>`。'
- en: The `Return` method will return a type that wraps the underlying type. In the
    case of asynchronous workflow, `Return` will return `Async<'T>`, whereas the `Async`
    type wraps the type of `` `T ``.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Return`方法将返回一个包装底层类型的类型。在异步工作流的情况下，`Return`将返回`Async<''T>`，而`Async`类型包装了`T`的类型。'
- en: The concept of `ReturnFrom` is similar in .NET TPL to having `T` as the result
    of an operation of `Task<'T>`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReturnFrom`的概念在.NET TPL中类似于`Task<''T>`操作的结果为`T`。'
- en: The F# way of composing a computation expression makes it easier to reason about
    returning the underlying type, but in .NET TPL, to get the `T` in `Task<T>`, we
    have to access the property as the result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: F#组合计算表达式的方式使得推理返回底层类型变得更容易，但在.NET TPL中，要获取`Task<T>`中的`T`，我们必须访问作为结果的属性。
- en: 'For example, this type wrap is shown when getting the result of `Task<T>` (in
    C#):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当获取`Task<T>`（在C#中）的结果时，会显示这种类型包装：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As highlighted in the preceding code, the underlying result is contained in
    `t.Result` instead of `t` because `t` is typed as `Task<int>`. Therefore, the
    underlying type is typed as `int`; it is matched with the property declaration
    of `Task<T>`. `Result` documentation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，底层结果包含在`t.Result`中而不是`t`中，因为`t`的类型为`Task<int>`。因此，底层类型被类型化为`int`；它与`Task<T>`的属性声明相匹配。`Result`文档：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Other expressions such as `yield` and `yield!` have the same intention and behavior
    as `return`/`return!` and `let`/`let!` in terms of the type they return.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其他如`yield`和`yield!`的表达式在返回类型方面与`return`/`return!`和`let`/`let!`具有相同的目的和行为。
- en: The asynchronous workflow and our own WPF computation expressions are samples
    of the common nature (also called *common behavior* in the realm of practical
    software engineering) of computation expressions. It is strongly recommended to
    follow this common nature of computation expression. Therefore, these traits of
    common nature of computation expression are not just best practices but also make
    more sense as predefined specifications for implementations. The predefined specifications
    for common code programming implementations are often called **design considerations**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作流和我们的WPF计算表达式是计算表达式的共同性质（在实用软件工程的领域中，也称为*共同行为*）的样本。强烈建议遵循计算表达式的这种共同性质。因此，这些共同性质的特性不仅是最佳实践，而且作为实现预定义规范也更有意义。预定义规范通常称为**设计考虑**。
- en: We will discuss the design considerations in the next section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论设计考虑。
- en: General computation expression design considerations
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用计算表达式设计考虑
- en: We have implemented a very simple computation expression using `Bind`, `Return`,
    and `Zero` as a starting sample.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`Bind`、`Return`和`Zero`作为起始样本实现了一个非常简单的计算表达式。
- en: We can conclude that the use of `Bind` will translate into `let!` as the result
    of `let!` expression will be composed nicely. The other translations are available
    on the official MSDN docs page of computation expression.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，使用`Bind`将翻译成`let!`，因为`let!`表达式的结果将很好地组合。其他翻译可以在计算表达式的官方MSDN文档页面上找到。
- en: The translation of builder methods into syntaxes of language constructs such
    as `let!`, `return`, `return!`, and  `do!` are samples of syntactic sugar. The
    **syntactic sugar** of a computation expression is the ability to translate the
    builder methods into very neat declarative expressions to combine expressions
    and functions nicely. It is quite easier to have computation expressions instead
    of directly calling the method builder after instantiating the builder object's
    constructor.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建器方法翻译成语言构造的语法，如`let!`、`return`、`return!`和`do!`是语法糖的示例。计算表达式的**语法糖**是将构建器方法翻译成非常整洁的声明性表达式以很好地组合表达式和函数的能力。与在实例化构建器对象的构造函数之后直接调用方法构建器相比，拥有计算表达式要容易得多。
- en: Based on the discussion in the previous sections, we have concluded that there
    are some aspects of best practices and some advice that must be taken into consideration.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前几节的讨论，我们得出结论，有一些最佳实践方面和一些建议必须加以考虑。
- en: The appropriate term for these aspects is *design considerations* because they
    serve as best practices and some initial actions to be avoided at the beginning
    of the implementation of a computation expression. The design considerations also
    include the related information on avoiding the pitfalls of computation expression
    because the design considerations include the related implementation patterns
    or background reasons behind each of the design considerations. Most of the reasons
    include pitfalls to avoid.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面的适当术语是*设计考虑因素*，因为它们作为最佳实践和一些在计算表达式实现初期应避免采取的初步行动。设计考虑因素还包括避免计算表达式陷阱的相关信息，因为设计考虑因素包括每个设计考虑因素背后的相关实现模式或背景原因。大多数原因都包括要避免的陷阱。
- en: 'The following are the design considerations of computation expression implementations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对计算表达式实现的设计考虑因素：
- en: Always begin with the planned results and general outcomes of what you want
    to achieve. Not all builder methods have to be implemented because while any builder
    method implementation provides more powerful syntactic sugar and also more declarative
    constructs, it also adds compilation overheads, and therefore the generated IL
    could be more complex.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是以你想要实现的结果和一般结果开始。并非所有构建器方法都必须实现，因为虽然任何构建器方法实现都提供了更强大的语法糖和更多的声明性结构，但它也增加了编译开销，因此生成的IL可能更复杂。
- en: The signature of the used builder method must follow the same pattern recommendation
    as described in MSDN docs for F# computation expressions. This is crucial because
    any computation expression must have a high degree of predictability in the beginning
    by obeying or complying with the same signature recommendation of the builder
    method. For example, `Bind` must follow the signature of `M<'T> * ('T -> M<'U>)
    -> M<'U>` in order to have a predictable result.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所使用的构建器方法的签名必须遵循MSDN文档中描述的F#计算表达式的相同模式推荐。这是至关重要的，因为任何计算表达式都必须通过遵守或遵守构建器方法的相同签名推荐，在开始时具有高度的预测性。例如，`Bind`必须遵循`M<'T>
    * ('T -> M<'U>) -> M<'U>`的签名，以便具有可预测的结果。
- en: '*The focus of the computation expression is usually differentiated into three
    main focuses: on the requirement to return underlying type, on only combining
    operations in expressions/functions that usually return nothing or return F# Unit
    (void in C#), and on combining side effects*. This condition especially applies
    to the case of `Zero` method. The nature of computation workflow does not require
    to implement `Zero` for all cases. For example, a query computation expression
    (the `query { ... }` expression) does not require `Zero`, because it does not
    make sense to implement the `Zero` method because the main focus of a query expression
    is on not the underlying type, but rather on combining query expressions/functions
    of LINQ and trying to avoid side effects as much as possible. It makes sense in
    the case of asynchronous workflows and for `WindowBuilder`/`PanelBuilder` as combining
    asynchronous computations and adding UI controls have side effects.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*计算表达式的焦点通常分为三个主要方面：对返回底层类型的要求、仅在表达式/函数中结合通常返回无值或返回 F# 单元（C# 中的 void）的操作，以及对结合副作用的要求*。这种条件特别适用于`Zero`方法的情况。计算工作流程的本质不需要为所有情况实现`Zero`。例如，查询计算表达式（`query
    { ... }`表达式）不需要`Zero`，因为实现`Zero`方法没有意义，因为查询表达式的重点不是底层类型，而是结合LINQ的查询表达式/函数，并尽可能避免副作用。在异步工作流程和`WindowBuilder`/`PanelBuilder`的情况下是有意义的，因为结合异步计算和添加UI控件会有副作用。'
- en: Adding support for `Zero` means that we should be aware that the computation
    of `Zero` support might contain side effects. Therefore, the `Zero` method support
    should be added for computation expressions that have the predefined goal to include
    any side effect instead of composing pure functions or composing objects with
    a strict hierarchy. Asynchronous workflow is intended to combine functions and
    operations in a manner so as to have side effects; therefore we can safely include
    `Zero` support as well. `WindowBuilder`/`PanelBuilder` might not have side effects,
    but *all of the leverage in GUI layer, such as Windows Forms and WPF, always has
    side effects*. Sequence computation workflow, the `seq { ... }`, might have side
    effects, but the main goal is to focus on returning the underlying type. Therefore,
    `seq` computation expression does not have the requirement or necessity to implement
    `Zero`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对`Zero`的支持意味着我们应该意识到`Zero`支持的计算可能包含副作用。因此，应该为具有预定义目标包括任何副作用而不是组合纯函数或组合具有严格层次结构的对象的计算表达式添加`Zero`方法支持。异步工作流程旨在以产生副作用的方式组合函数和操作；因此，我们可以安全地包括`Zero`支持。`WindowBuilder`/`PanelBuilder`可能没有副作用，但*所有GUI层（如Windows
    Forms和WPF）的利用都始终有副作用*。序列计算工作流程，`seq { ... }`，可能包含副作用，但主要目标是关注返回底层类型。因此，`seq`计算表达式没有实现`Zero`的要求或必要性。
- en: Adding support for `Combine` means that it is strongly recommended to add support
    for `Delay` because it is required based on the implementation body of the `Combine`
    method. But implementations of the `Delay` method builder will add more complexity
    because the result is not evaluated immediately. Such a behavior of not having
    evaluated immediately happens because the `Delay` method is always executed before
    the `Return`/`ReturnFrom` method. It can be optimized to be implemented with less
    complexity only if the method body of `Delay` contains simple expressions or if
    it simply contains a function because the nature of the `Delay` method is to wrap
    a function that contains our computation.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对`Combine`的支持意味着强烈建议添加对`Delay`的支持，因为根据`Combine`方法的实现体，这是必需的。但是，`Delay`方法构建器的实现将增加更多复杂性，因为结果不会立即评估。这种不立即评估的行为发生是因为`Delay`方法总是在`Return`/`ReturnFrom`方法之前执行。只有当`Delay`方法的方法体包含简单的表达式或仅包含一个函数时，才能将其优化以具有更少的复杂性，因为`Delay`方法的本性是包装包含我们计算的功能。
- en: To shorten the instantiation of the computation expression builder, we can instantiate
    it under a module using the normal `let` syntax. F# will treat the instance of
    the builder as a keyword. *It is therefore strongly recommended to have only one
    instance that will be used as a keyword because it is bad practice to have many
    instances of a builder to have many keywords with the same semantic*. For example,
    we use `windowexp` as our instance of `WindowBuilder`, which can then be used
    by other F# library (DLL) or executable applications.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了缩短计算表达式构建器的实例化，我们可以在模块下使用正常的 `let` 语法来实例化它。F# 将将构建器的实例视为关键字。因此，强烈建议只有一个实例将被用作关键字，因为拥有多个构建器实例以拥有多个具有相同语义的关键字是不良实践。例如，我们使用
    `windowexp` 作为我们的 `WindowBuilder` 实例，然后它可以被其他 F# 库（DLL）或可执行应用程序使用。
- en: The instantiation of a computation expression must not be the same keyword in
    the existing pool of F# keywords. Otherwise, we will have unpredictable results
    and compile errors. This is crucial because we should not add more keywords in
    form of the name of type builders freely without checking the existing F# keywords.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: F# 计算表达式的实例化不能与现有 F# 关键字池中的相同关键字。否则，我们可能会得到不可预测的结果和编译错误。这一点至关重要，因为我们不应该在未检查现有
    F# 关键字的情况下，自由地以类型构建器的名称形式添加更多关键字。
- en: 'Use an F# delegate/function (`FSharpFunc`) instead of .NET `Func` as much as
    possible, unless we are going to have an explicit use of .NET `Func` inside the
    implementation of the computation expression. For example: a query computation
    expression contains calls to LINQ''s static methods, such as `Enumerable.Where`
    and `Orderable.OrderBy`, which requires .NET `System.Func` delegates.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能使用 F# 委托/函数（`FSharpFunc`）而不是 .NET `Func`，除非我们打算在计算表达式的实现中显式使用 .NET `Func`。例如：查询计算表达式包含对
    LINQ 的静态方法的调用，如 `Enumerable.Where` 和 `Orderable.OrderBy`，这需要 .NET `System.Func`
    委托。
- en: The use of `Using` method builder is optional but we should use `Using` as much
    as possible if we are allowing the use of types (for the underlying type) that
    should be disposed immediately. The type that fits into this model is the type
    that implements `IDisposable`. But having this `Using` will add more complexity
    to our computation expression, and not all of the planning focuses (as described
    in point 3) require us to have implementations of `Using` method.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Using` 方法构建器是可选的，但如果我们允许使用应立即处置的类型（作为底层类型），则应尽可能使用 `Using`。符合此模式的类型是实现 `IDisposable`
    的类型。但是，拥有这个 `Using` 将会增加我们的计算表达式的复杂性，并且并非所有规划重点（如第 3 点所述）都需要我们有 `Using` 方法的实现。
- en: Do not use an implicit type as the underlying type of a computation expression
    for a type that has an implicit reference counting of events as part of event
    driven programming mode.. An example of this is the use of any `EventHandler`
    type (or a derived type) for the underlying type of a computation expression.
    Although there is no restriction on using event handler objects as the underlying
    type, there is no guarantee that we can always dereference the events from an
    event handler as the underlying type. Any event might have been added during the
    running of the computation expression, unless we also remember to dereference
    all of the referenced event objects, and this always adds more complexity to the
    implementation of the computation expression itself. Using the `IDisposable` pattern
    will not guarantee that any handled events are deregistered when the type is disposed.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要将隐式类型用作具有事件驱动编程模式中事件隐式引用计数的类型的计算表达式的底层类型。例如，将任何 `EventHandler` 类型（或其派生类型）用作计算表达式的底层类型。尽管没有限制使用事件处理对象作为底层类型，但我们无法保证总能从事件处理对象中解引用事件作为底层类型。在计算表达式运行期间，任何事件都可能被添加，除非我们也记得解引用所有引用的事件对象，这总是会增加计算表达式实现的复杂性。使用
    `IDisposable` 模式并不能保证在类型被处置时，任何处理的事件都会被注销。
- en: If we use an implicit type as underlying type that is derived from reference-counting
    type such as `EventHandler`, the event registration (reference) and dereference
    have to be handled explicitly. This explicit reference/dereference implementation
    will guarantee that the reference to outside events that are referenced outside
    as delegates are registered and deregistered correctly.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将隐式类型用作从 `EventHandler` 等引用计数类型派生的底层类型，事件注册（引用）和解引用必须显式处理。这种显式的引用/解引用实现将保证外部事件（作为委托引用）的注册和注销是正确的。
- en: Do not use inline functions on method builders. The context of inline functions
    does not fit into the context of a computation expression because inline functions
    will be inlined for every use of our method builder, and this is against the F#
    language specification. However, the nature of method builders prefers to have
    normal generic type parameters, which are then generalized instead of having an
    early optimization on the generic type inlined. Also, all of the method builders
    cannot be inlined easily because these methods only live within the type set by
    the computation expression builder type definition and can be used only within
    the scope of the computation expression when its instance is used. Fortunately,
    the F# compiler will catch this inline usage on builder methods early as a compile
    error.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要在方法构建器上使用内联函数。内联函数的上下文不适合计算表达式的上下文，因为内联函数将内联到我们方法构建器的每次使用中，这与F#语言规范相违背。然而，方法构建器的本质更倾向于有正常的泛型类型参数，这些参数随后被泛化，而不是在泛型类型上提前进行内联优化。此外，所有的方法构建器都不容易内联，因为这些方法仅存在于由计算表达式构建器类型定义设定的类型集中，并且只能在计算表达式实例被使用时在其作用域内使用。幸运的是，F#编译器会及早捕捉到构建器方法上的这种内联使用，并将其作为编译错误。
- en: It is good for us to have the preceding design guidelines when we are going
    to implement computation expressions, but they have their own implications and
    there are additional sub notes and more explanations on some points of the design
    consideration. The next section describes these implications with the additional
    explanations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备实现计算表达式时，有前面的设计指南是好的，但它们有自己的影响，并且有一些设计考虑点的子注释和更多解释。下一节将描述这些影响以及额外的解释。
- en: Implications of the design considerations of computation expression
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算表达式设计考虑的设计影响
- en: The points in the design consideration are quite self-explanatory, but some
    points have to be explored further because they have some implications not just
    on the correctness and the clarity of the intention of the computation expression
    when used outside the scope of the assembly but also on the performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 设计考虑中的点相当直观，但有些点需要进一步探讨，因为它们不仅对计算表达式在程序集作用域外使用时的正确性和意图的清晰性有影响，还对性能有影响。
- en: Let's discuss the points of the design considerations that have additional implications
    to be handled.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论设计考虑中具有额外处理影响的点。
- en: Point 2 defines that we must meet the specifications based on the signature
    of the commonly used method builder. This is important, especially on the crucial
    (required) methods that define the core intention and the requirement of the computation
    expression's focus as described in point 3 of computation expression focus. In
    the case of asynchronous workflow and `WindowBuilder`/`PanelBuilder`, all of them
    have to deal with the side effects, and therefore the implementation of `Bind`,
    `Return`, and `ReturnFrom` methods has to be implemented using the respective
    signature guidelines. Failing to comply with these signature guidelines will result
    as compile errors.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点规定我们必须根据常用方法构建器的签名来满足规范。这很重要，尤其是在定义计算表达式核心意图和要求的（必需的）方法上，正如计算表达式焦点第三点所述。在异步工作流和`WindowBuilder`/`PanelBuilder`的情况下，所有这些都必须处理副作用，因此`Bind`、`Return`和`ReturnFrom`方法的实现必须使用相应的签名指南。未能遵守这些签名指南将导致编译错误。
- en: For example, if we try to have `yield` in our use of `PanelBuilder`, we will
    get a compile error.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们尝试在`PanelBuilder`的使用中包含`yield`，我们将得到一个编译错误。
- en: 'Consider the following faulty code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下有误的代码：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Visual Studio editor will display squiggle on the line with the `yield`
    declaration and also will complain that `yield` method has not been implemented
    yet, as shown in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio编辑器将在带有`yield`声明的行上显示波浪线，并且还会抱怨`yield`方法尚未实现，如下面的截图所示：
- en: '![Implications of the design considerations of computation expression](img/image00331.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![计算表达式设计考虑的设计影响](img/image00331.jpeg)'
- en: This error information from the F# compiler is crucial as currently, we have
    not yet implemented yield for `PanelBuilder`, although `yield` itself is a valid
    keyword in F# when used in a `for` loop outside a computation expression.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 来自F#编译器的这个错误信息至关重要，因为目前我们尚未为`PanelBuilder`实现`yield`，尽管`yield`本身在计算表达式外的`for`循环中是F#中的一个有效关键字。
- en: This simple quick test is also useful to prove that consistency in the implementation
    of a computation expression is very important so that we can be sure that our
    implementation of computation expression is correct in the sense that we have
    done the implementations based on the initial intention and design considerations.
    This is also why it is called *correctness*, not just consistency of the implementation
    and the usage.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的快速测试也有助于证明计算表达式实现的一致性非常重要，这样我们就可以确信我们的计算表达式实现是正确的，因为我们已经根据初始意图和设计考虑进行了实现。这也是为什么它被称为*正确性*，而不仅仅是实现和使用的一致性。
- en: Point 3 in the aspect of computation expression focuses implies that there is
    a certain deciding plan before implementing a computation expression. This focus
    plan will also provide guidelines on what method builder we should strongly implement
    and what method should not be implemented mainly based on how we are going to
    handle the side effects first.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 计算表达式方面的第3点关注点意味着在实现计算表达式之前有一个确定的计划。这个关注计划还将提供指导，说明我们应该强烈实现哪些方法构建器，以及哪些方法不应该实现，这主要基于我们如何首先处理副作用。
- en: Currently, there are no officially defined guidelines for computation expression
    method builder implementation in F# language specification. The main goal of the
    focus guideline is to have a starting focus plan on the implementation of computation
    expressions, which is then easily translated to what method builders we should
    implement.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在F#语言规范中尚未正式定义计算表达式方法构建器实现的指南。重点指南的主要目标是制定一个关于计算表达式实现的起始计划，这样就可以轻松地将其转换为我们应该实现的方法构建器。
- en: Having the mindset to first focus on side effects is also critical and helpful.
    It also complies with the functional programming language common practices that
    we should treat side effects explicitly and identify them early in the beginning
    of the implementation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先关注副作用的心态也是关键和有帮助的。这也符合函数式编程语言的常见实践，我们应该明确处理副作用并在实现初期尽早识别它们。
- en: 'We can then simplify the narrative description of point 3 with this illustration
    as the deciding flow (using UML 2 diagram notation):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个示例作为决策流程（使用UML 2图符号）来简化第3点的叙述描述：
- en: '![Implications of the design considerations of computation expression](img/image00332.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![计算表达式设计考虑因素的影响](img/image00332.jpeg)'
- en: The preceding Unified Modeling Language (UML) activity diagram illustration
    is not meant to limit the creativity of the developer. In fact, there are no restrictions
    for the minimum method builders for many specific purposes beyond what we have
    in the illustration.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的统一建模语言（UML）活动图示例并不是为了限制开发者的创造力。事实上，对于许多具体目的，除了我们在示例中展示的内容之外，没有对最小方法构建器的限制。
- en: We leverage the UML activity diagram because we need to document or illustrate
    the flow of the deciding factor. UML itself is a software development standard diagram
    that focuses on documenting processes and system development (including application
    development), under the supervision of **Object Management Group** (**OMG**),
    a non-profit organization for standardizing documented processes and architecture.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用UML活动图，因为我们需要记录或说明决策因素的流程。UML本身是一个软件开发标准图，专注于在**对象管理组**（**OMG**）的监督下记录流程和系统开发（包括应用开发），**对象管理组**是一个非营利组织，用于标准化记录的流程和架构。
- en: 'For more information about UML 2 diagram, visit the official UML page at: [http://www.uml.org/](http://www.uml.org/).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于UML 2图的信息，请访问官方UML页面：[http://www.uml.org/](http://www.uml.org/)。
- en: 'This is the landing page of UML 2 standards with various version histories
    at OMG: [http://www.omg.org/spec/UML/](http://www.omg.org/spec/UML/).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是UML 2标准的着陆页，在OMG（[http://www.omg.org/spec/UML/](http://www.omg.org/spec/UML/)）有各种版本历史。
- en: The UML activity diagram is part of the UML 2.1 standard diagrams and notations.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: UML活动图是UML 2.1标准图和符号的一部分。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The UML activity diagram is easier to understand than a flowchart because it
    can accommodate more conditional concerns (not just yes/no or true/false) and
    provides more support for event-driven and message passing agents. The most frequently
    used UML diagram is the activity diagram. Activity diagram is one of the many
    diagrams under the UML 2.1 umbrella standards. Currently, the UML standard has
    version 2.5, but still the widely used version in 2016 is UML 2.1\. This book
    does not focus on how to create and use UML diagrams because it is beyond the
    scope of this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: UML活动图比流程图更容易理解，因为它可以容纳更多的条件关注点（不仅仅是是/否或真/假），并为事件驱动和消息传递代理提供更多支持。最常用的UML图是活动图。活动图是UML
    2.1标准下的许多图之一。目前，UML标准版本为2.5，但2016年广泛使用的版本仍然是UML 2.1。本书不专注于如何创建和使用UML图，因为这超出了本书的范围。
- en: When we discuss the side effects in point 3, we should be aware that side effects
    are not just I/O or any other kind of outside API calls, such as interoperability
    with Win32 API; side effects such as exceptions, event-driven model, and any GUI
    library have to be taken into account as well to be carefully handled. When an
    event handler is instantiated within a computation expression, it is recommended
    to clear all event handlers of any events that we want to handle by setting them
    to `None` (`null` in C# semantic, `Nothing` in VB semantic). Otherwise, we will
    have occurrences of memory leaks even after we are done executing computation
    expressions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论第3点中的副作用时，我们应该意识到副作用不仅仅是I/O或任何其他类型的对外部API调用，如与Win32 API的互操作性；像异常、事件驱动模型和任何GUI库这样的副作用也必须被考虑到，以便进行仔细处理。当在计算表达式中实例化事件处理器时，建议通过将它们设置为`None`（在C#语义中为`null`，在VB语义中为`Nothing`）来清除我们想要处理的任何事件的全部事件处理器。否则，即使我们完成了计算表达式的执行，也可能会发生内存泄漏。
- en: Point 5 about the instantiation of computation expression is also a simple but
    meaningful proof of how we can easily add keywords to the existing F# keywords.
    It can lead to confusion because more keywords means more semantic and more contexts
    to be understood.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计算表达式实例化的第5点也是一个简单但富有意义的证明，说明了我们如何轻松地向现有的F#关键字添加关键字。这可能会导致混淆，因为更多的关键字意味着更多的语义和更多的上下文需要理解。
- en: Point 8 about leveraging the `Using` method in a computation expression has
    to be implemented carefully. It is nice to have a use pattern for disposable objects,
    but many uses of disposable objects might lead to having additional overhead on
    garbage collector (GC) because of the overhead when disposing objects at the end
    of the computation expression lifetime. Also, having the `Using` method only can
    work for `IDisposable` objects, and this constraint will put a restriction on
    what kind of types to be used in the implementation of the `Using` method.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在计算表达式中利用`Using`方法的第8点必须谨慎实现。对于可处置对象来说，有一个使用模式是很好的，但许多可处置对象的使用可能会因为计算表达式生命周期结束时处置对象的开销而导致垃圾收集器（GC）有额外的开销。此外，只有`Using`方法可以用于`IDisposable`对象，这个限制将对`Using`方法的实现中可以使用的类型类型施加限制。
- en: Point 9 is also important, although it is the last point in our design considerations
    because any use of types that have implicit reference counting as the underlying
    type (such as event handler) might be dangerous. Not that we cannot have the guarantee
    of always dereferencing references to other objects, such as events, but any action
    of dereferencing itself is always synchronous and it may slow down the running
    performance a bit.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第9点也很重要，尽管它是我们设计考虑中的最后一个点，因为任何使用具有隐式引用计数作为底层类型的类型（例如事件处理器）都可能很危险。并不是我们不能保证总是解除对其他对象（如事件）的引用，但任何解除引用本身的行为总是同步的，这可能会稍微降低运行性能。
- en: Although dereferencing events of an event handler is as easy as setting it to
    `None`, but because of its sequential nature of synchronous executions, it cannot
    be used nicely in a parallel execution at all. This means that there is no option
    for parallelism when we have to do dereferencing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将事件处理器的引用设置为`None`与设置它一样简单，但由于其同步执行的顺序性质，它根本不能在并行执行中使用。这意味着当我们必须进行解除引用时，没有并行性的选项。
- en: Considerations of computation expression optimization
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑计算表达式优化
- en: Computation expressions can be further optimized if we carefully implement the
    design planning. We have discussed the design considerations of a computation
    workflow in the previous section of this chapter, and we shall carry the considerations
    as a quick foundation to perform optimization.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细实施设计规划，计算表达式可以进一步优化。我们在本章的前一节讨论了计算工作流的设计考虑，我们将把这些考虑作为快速基础来执行优化。
- en: 'The optimization of computation expression is quite hard because of the following
    factors as consequences of computation expression syntax translations:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算表达式语法的翻译后果，计算表达式的优化相当困难，以下是一些因素：
- en: Construction of computation expressions depends heavily on syntactic sugar that
    becomes language constructs. For example, `ReturnFrom` method is translated to
    a method that returns a result of the underlying type of a computation expression.
    Therefore, we must follow the strict guidelines of the asynchronous method builders
    to express translation; otherwise, we will get unpredictable results or even exceptions.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算表达式的构建在很大程度上依赖于语法糖，这些语法糖成为语言结构。例如，`ReturnFrom` 方法被翻译成一个返回计算表达式底层类型结果的方法。因此，我们必须遵循异步方法构建器的严格指南来表达翻译；否则，我们可能会得到不可预测的结果或甚至异常。
- en: Composing the sequence of `let!` requires some wirings of a chained `Bind` method
    builder in the form of chaining `Bind` methods. This chaining of `Bind` method
    might be error-prone and it cannot be optimized further. Fortunately, we have
    a method builder in a computation expression called `Combine` to sequence multiple
    expressions (also called *sequencing expression* in the MSDN documentation of
    F#). However, the `Combine` method has to be carefully rewritten to match the
    signature requirement specification for `Combine`, then all of the necessary requirements
    of the related builder methods such as `Bind`, `Return`, and `ReturnFrom` must
    be aligned to match the type signature as well.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `let!` 序列需要一些链式 `Bind` 方法构建器的连接，这些连接以链式 `Bind` 方法的形式出现。这种 `Bind` 方法的链式调用可能会出错，并且无法进一步优化。幸运的是，我们在计算表达式中有一个名为
    `Combine` 的方法构建器，用于序列化多个表达式（在 F# 的 MSDN 文档中也称为 *序列表达式*）。然而，`Combine` 方法必须仔细重写以匹配
    `Combine` 的签名要求规范，然后所有相关的构建器方法，如 `Bind`、`Return` 和 `ReturnFrom`，都必须对齐以匹配类型签名。
- en: By default, the expression returned by expressions within a computation expression
    is not returned immediately because the order of execution might change based
    on what the implementation body of `Combine` and `Delay` is.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，计算表达式内部的表达式返回的表达式不会立即返回，因为执行顺序可能会根据 `Combine` 和 `Delay` 的实现体而改变。
- en: Points 2 and 3 are closely related to the design considerations, particularly
    to point 5 of the design considerations of computation expression that we discussed
    previously in this chapter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 点 2 和 3 与设计考虑密切相关，尤其是与我们之前在本章中讨论的计算表达式设计考虑的第 5 点。
- en: 'To understand `Delay` and also to prove that it changes the execution order,
    we could compare two implementations of computation expressions: the first one
    without `Delay`, and the second one that has `Delay`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 `Delay` 并证明它改变了执行顺序，我们可以比较两种计算表达式的实现：第一个没有 `Delay`，第二个有 `Delay`。
- en: 'This following code is implemented without the `Delay` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是未使用 `Delay` 方法实现的：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s test this `ComputeExpression1Builder` builder, using the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这个 `ComputeExpression1Builder` 构建器，使用以下代码：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using **F# Interactive** mode, execute the preceding code. The **F# Interactive**
    window will display the following signature:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **F# Interactive** 模式执行前面的代码。**F# Interactive** 窗口将显示以下签名：
- en: '![Considerations of computation expression optimization](img/image00333.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![计算表达式优化的考虑因素](img/image00333.jpeg)'
- en: 'The following code is the same code as the previous one, but now it has the
    `Delay` method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码与上一个代码相同，但现在它有了 `Delay` 方法：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Delay` method in the preceding code is implemented with type annotations.
    This is important because without type annotation, F# will set the signature to
    be generalized; this generalization is caused by automatic generalization. We
    need to minimize automatic generalization because we want to prevent type checking
    at the runtime when the generic parameter is bound because we already know that
    the method body of `Combine` will infer that the type of the underlying result
    type is `Int32`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的`Delay`方法使用了类型注解。这很重要，因为没有类型注解，F#会将签名设置为泛型；这种泛化是由自动泛化引起的。我们需要最小化自动泛化，因为我们希望在泛型参数绑定时防止运行时类型检查，因为我们已经知道`Combine`的方法体将推断出底层结果类型的类型是`Int32`。
- en: 'Use the following code to test `ComputeExpression2Builder`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码测试`ComputeExpression2Builder`：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following display of **F# Interactive** window proves that the `Delay`
    method wraps a function in a computation expression and affects the evaluation
    (as shown by the display of **Test** from `Console.WriteLine`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下**F#交互式窗口**的显示证明了`Delay`方法将一个函数包裹在计算表达式中，并影响了评估（如`Console.WriteLine`的**Test**显示所示）：
- en: '![Considerations of computation expression optimization](img/image00334.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![计算表达式优化的考虑因素](img/image00334.jpeg)'
- en: The preceding code has proved that the `Delay` method should be used carefully,
    and it may contain side effects that not just change the order of execution of
    `Yield` (or other returning result methods, such as `Return`/`ReturnFrom`), but
    it also might terminate the execution before returning the result of `Yield` because
    of the possibility of catching an exception.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码证明了`Delay`方法应谨慎使用，它可能包含副作用，不仅会改变`Yield`（或其他返回结果方法，如`Return`/`ReturnFrom`）的执行顺序，还可能因为捕获异常而提前终止执行，从而在返回`Yield`的结果之前。
- en: This simple sample optimization case combined with the design considerations
    provides us careful and predictable behaviors. We now have increased awareness
    of what is going on inside a computation expression and how to minimize the overhead
    of having unnecessary or overkill usage of method builders.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的优化案例示例结合设计考虑因素，为我们提供了谨慎且可预测的行为。我们现在对计算表达式内部发生的事情有了更高的认识，以及如何最小化使用方法构建器时产生的不必要或过度使用带来的开销。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The knowledge of the computation expression correctness is also useful as we
    are not sacrificing performance as well, while at the same time keeping the functional
    programming's best practices in place. Although the nature of builder methods
    in a computation expression implementation is mostly implemented using the object
    oriented principle, using instantiated computation expression gives us more expressiveness
    to make our code cleaner and better composed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 计算表达式正确性的知识也非常有用，因为我们没有牺牲性能，同时保持了函数式编程的最佳实践。尽管计算表达式实现中构建器方法的本质大多使用面向对象原则实现，但使用实例化的计算表达式给我们提供了更多的表达性，使我们的代码更简洁、更易于组合。
- en: We have the knowledge of the optimization of F# code or applications, starting
    from identifying the performance aspects of the .NET runtime to the detail of
    F# performance characteristics, measurement with .NET tooling ecosystem, and optimization
    of all the aspects of the F# language ecosystem-from the compiler to the existing
    F# features.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们掌握了F#代码或应用的优化知识，从识别.NET运行时的性能方面开始，到F#性能特性的细节，使用.NET工具生态系统进行测量，以及优化F#语言生态系统的各个方面——从编译器到现有的F#功能。
- en: We not only have an understanding of the general language features but also
    the knowledge of aligning compilers with concurrency, data structures, language
    constructs, and other sophisticated and powerful features, such as computation
    expression.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅理解了通用语言特性，还了解了如何将编译器与并发、数据结构、语言构造和其他复杂且强大的功能（如计算表达式）对齐。
