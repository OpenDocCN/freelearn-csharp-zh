- en: '5\. Concurrency: Multithreading Parallel and Async Code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 并发：多线程、并行和异步代码
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: C# and .NET provide a highly effective way to run concurrent code, making it
    easy to perform complex and often time-consuming actions. In this chapter, you
    will explore the various patterns that are available, from creating tasks using
    the `Task` factory methods to continuations to link tasks together, before moving
    on to the `async`/`await` keywords, which vastly simplify such code. By the end
    of this chapter, you will see how C# can be used to execute code that runs concurrently
    and often produces results far quicker than a single-threaded application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C# 和 .NET 提供了一种高效的方式来运行并发代码，使得执行复杂且通常耗时的操作变得容易。在本章中，你将探索可用的各种模式，从使用 `Task` 工厂方法创建任务到使用延续将任务链接起来，然后转向
    `async`/`await` 关键字，这些关键字极大地简化了此类代码。在本章结束时，你将看到如何使用 C# 执行并发运行的代码，并且通常比单线程应用程序产生结果更快。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Concurrency is a generalized term that describes the ability of software to
    do more than one thing at the same time. By harnessing the power of concurrency,
    you can provide a more responsive user interface by offloading CPU-intensive activities
    from the main UI thread. On the server side, taking advantage of modern processing
    power through multi-processor and multi-core architectures, scalability can be
    achieved by processing operations in parallel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一个通用术语，描述了软件同时执行多项任务的能力。通过利用并发的力量，你可以通过将 CPU 密集型活动从主 UI 线程卸载来提供更响应的用户界面。在服务器端，通过利用多处理器和多核架构的现代处理能力，可以通过并行处理操作来实现可伸缩性。
- en: Multithreading is a form of concurrency whereby multiple threads are used to
    perform operations. This is typically achieved by creating many `Thread` instances
    and coordinating operations between them. It is regarded as a legacy implementation,
    having largely been replaced by parallel and async programming; you may well find
    it used in older projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是一种并发形式，其中使用多个线程来执行操作。这通常是通过创建许多 `Thread` 实例并在它们之间协调操作来实现的。它被认为是一种遗留实现，已被并行和异步编程所取代；你可能会在旧项目中找到它的使用。
- en: Parallel programming is a class of multithreading where similar operations are
    run independently of each other. Typically, the same operation is repeated using
    multiple loops, where the parameters or target of the operation themselves vary
    by iteration. .NET provides libraries that shield developers from the low-level
    complexities of thread creation. The phrase **embarrassingly parallel** is often
    used to describe an activity that requires little extra effort to be broken down
    into a set of tasks that can be run in parallel, often where there are few interactions
    between sub-tasks. One such example of parallel programming could be counting
    the number of words found in each text file within a folder. The job of opening
    a file and scanning through the words can be split into parallel tasks. Each task
    executes the same lines of code but is given a different text file to process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程是一种多线程类别，其中相似的操作彼此独立运行。通常，相同的操作会通过多个循环重复执行，其中操作的参数或目标本身会随着迭代而变化。.NET 提供了库，可以保护开发者免受线程创建的低级复杂性的影响。短语**令人尴尬的并行**常用来描述一种只需要额外努力就能分解成可以并行运行的任务集的活动，通常在这些子任务之间几乎没有交互。并行编程的一个例子可能是计算文件夹中每个文本文件中找到的单词数量。打开文件和扫描单词的工作可以分解成并行任务。每个任务执行相同的代码行，但被分配处理不同的文本文件。
- en: Asynchronous programming is a more recent form of concurrency where an operation,
    once started, will complete at some point in the future, and the calling code
    is able to continue with other operations. This completion is often known as a
    `Task<>` equivalent. In C# and .NET, async programming has become the preferred
    means to achieve concurrent operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是一种更近期的并发形式，其中一旦启动操作，将在未来的某个时刻完成，并且调用代码能够继续执行其他操作。这种完成通常被称为 `Task<>` 等价物。在
    C# 和 .NET 中，异步编程已成为实现并发操作的首选方法。
- en: A common application of asynchronous programming is where multiple slow-running
    or expensive dependencies need to be initialized and marshaled prior to calling
    a final step that should be called only when all or some of the dependencies are
    ready to be used. For example, a mobile hiking application may need to wait for
    a reliable GPS satellite signal, a planned navigation route, and a heart-rate
    monitoring service to be ready before the user can start hiking safely. Each of
    these distinct steps would be initialized using a dedicated task.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程的一个常见应用场景是，在调用最终步骤之前，需要初始化和整理多个慢速运行或昂贵的依赖项。例如，一个移动徒步旅行应用程序可能需要在用户安全开始徒步之前等待可靠的
    GPS 卫星信号、计划好的导航路线和心率监测服务准备就绪。每个这些独立的步骤都会使用一个专用的任务来初始化。
- en: Another very common use case for asynchronous programming occurs in UI applications
    where, for example, saving a customer's order to a database could take 5-10 seconds
    to complete. This may involve validating the order, opening a connection to a
    remote server or database, packaging and sending the order in a format that can
    be transmitted over the wire, and then finally waiting for confirmation that the
    customer's order has been successfully stored in a database. In a single-threaded
    application, this would take much longer, and this delay would soon be noticed
    by the user. The application would become unresponsive until the operation was
    completed. In this scenario, the user may rightly think the application has crashed
    and may try to close it. That is not an ideal user experience.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程的另一个非常常见的用例出现在 UI 应用程序中，例如，将客户的订单保存到数据库可能需要 5-10 秒才能完成。这可能涉及验证订单、打开与远程服务器或数据库的连接、打包并发送订单以供通过网络传输的格式，然后最终等待确认客户的订单已成功存储在数据库中。在一个单线程应用程序中，这会花费更长的时间，这种延迟很快就会被用户注意到。应用程序会在操作完成之前无响应。在这种情况下，用户可能会错误地认为应用程序已崩溃，并尝试关闭它。这不是一个理想的用户体验。
- en: Such issues can be mitigated by using async code that performs any of the slow
    operations using a dedicated task for each. These tasks may choose to provide
    feedback as they progress, which the UI's main thread can use to notify the user.
    Overall, the operation should complete sooner, thus freeing the user to continue
    interacting with the app. In modern applications, users have come to expect this
    method of operation. In fact, many UI guidelines suggest that if an operation
    may take more than a few seconds to complete, then it should be performed using
    async code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用执行任何慢速操作的专用任务的异步代码，可以减轻此类问题。这些任务可以选择在进度中提供反馈，UI 的主线程可以使用这些反馈来通知用户。总体而言，操作应该会更快完成，从而使用户能够继续与应用程序交互。在现代应用程序中，用户已经习惯了这种操作方式。事实上，许多
    UI 指南建议，如果某个操作可能需要几秒钟才能完成，那么它应该使用异步代码来执行。
- en: Note that when code is executing, whether it's synchronous or asynchronous code,
    it is run within the context of a `Thread` instance. In the case of asynchronous
    code, this `Thread` instance is chosen by the .NET scheduler from a pool of available
    threads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当代码正在执行时，无论是同步代码还是异步代码，它都是在 `Thread` 实例的上下文中运行的。在异步代码的情况下，这个 `Thread` 实例是由
    .NET 调度程序从可用的线程池中选择。
- en: The `Thread` class has various properties but one of the most useful is `ManagedThreadId`,
    which will be used extensively throughout this chapter. This integer value serves
    to uniquely identify a thread within your process. By examining `Thread.ManagedThreadId`,
    you can determine that multiple thread instances are being used. This can be done
    by accessing the `Thread` instance from within your code using the static `Thread.CurrentThread`
    method.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 类具有多种属性，但其中最有用的一项是 `ManagedThreadId`，它将在本章中广泛使用。这个整数值用于在您的进程中唯一标识一个线程。通过检查
    `Thread.ManagedThreadId`，您可以确定正在使用多个线程实例。这可以通过在代码中使用静态的 `Thread.CurrentThread`
    方法来访问 `Thread` 实例来完成。'
- en: For example, if you started five long-running tasks and examined the `Thread.ManagedThreadId`
    for each, you would observe five unique IDs, possibly numbered as two, three,
    four, five, and six. In most cases, the thread with ID number one is the process's
    main thread, created when the process first starts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您启动了五个长时间运行的任务，并检查每个任务的 `Thread.ManagedThreadId`，您会观察到五个唯一的 ID，可能编号为二、三、四、五和六。在大多数情况下，ID
    为一的线程是进程的主线程，它在进程首次启动时创建。
- en: Keeping track of thread IDs can be quite useful, especially when you have time-consuming
    operations to perform. As you have seen, using concurrent programming, multiple
    operations can be executed at the same time, rather than using a traditional single-threaded
    approach, where one operation must complete before a subsequent operation can
    start.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪线程 ID 可以非常有用，尤其是在你需要执行耗时操作时。正如你所见，使用并发编程，可以同时执行多个操作，而不是使用传统的单线程方法，在后续操作开始之前，必须完成一个操作。
- en: In the physical world, consider the case of building a train tunnel through
    a mountain. Starting at one side of a mountain and tunneling through to the other
    side could be made considerably faster if two teams started on opposite sides
    of the mountain, both tunneling toward each other. The two teams could be left
    to work independently; any issues experienced by a team on one side should not
    have an adverse effect on the other side's team. Once both sides have completed
    their tunneling, there should be one single tunnel, and the construction could
    then continue with the next task, such as laying the train line.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，考虑在山脉中建造火车隧道的案例。如果两个团队从山脉的两侧开始，同时向对方挖掘隧道，那么这个过程可以大大加快。两个团队可以独立工作；一个团队在一边遇到的问题不应对另一边的团队产生不利影响。一旦两边都完成了隧道挖掘，就应有一个单一的隧道，然后可以继续进行下一个任务，例如铺设火车线路。
- en: 'The next section will look at using the C# `Task` class, which allows you to
    execute blocks of code at the same time and independently of each other. Consider
    again the example of the UI app, where the customer''s order needs to be saved
    to a database. For this, you would have two options:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨使用 C# 的 `Task` 类，它允许你同时独立地执行代码块。再次考虑 UI 应用程序的例子，其中客户的订单需要保存到数据库。为此，你有两种选择：
- en: 'Option 1 is to create a C# `Task` that performs each step one after another:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是创建一个 C# `Task`，依次执行每个步骤：
- en: Validate the order.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证订单。
- en: Connect to the server.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到服务器。
- en: Send the request.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送请求。
- en: Wait for a response.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待响应。
- en: Option 2 is to create a C# `Task` for each of the steps, executing each in parallel
    where possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是为每个步骤创建一个 C# `Task`，尽可能并行执行每个步骤。
- en: Both options achieve the same end result, freeing the UI's main thread to respond
    to user interactions. Option one may well be slower to finish, but the upside
    is that this would require simpler code. However, Option two would be the preferred
    choice as you are offloading multiple steps, so it should complete sooner. Although,
    this could involve additional complexity as you may need to coordinate each of
    the individual tasks as they are complete.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选择都达到了相同的结果，即释放 UI 的主线程以响应用户交互。第一种选择可能完成得较慢，但优点是代码会更简单。然而，第二种选择将是首选，因为你正在卸载多个步骤，因此它应该完成得更快。尽管如此，这可能会涉及额外的复杂性，因为你可能需要协调每个单独的任务，一旦它们完成。
- en: In the upcoming sections, you will first get a look at how Option one could
    be approached, that is, using a single `Task` to run blocks of code, before moving
    on to the complexity of Option two where multiple tasks are used and coordinated.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将首先了解如何采用第一种选择，即使用单个 `Task` 来运行代码块，然后再继续探讨第二种选择，即使用多个任务并协调它们的复杂性。
- en: Running Asynchronous Code Using Tasks
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务运行异步代码
- en: The `Task` class is used to execute blocks of code asynchronously. Its usage
    has been somewhat superseded by the newer `async` and `await` keywords, but this
    section will cover the basics of creating tasks as they tend to be pervasive in
    larger or mature C# applications and form the backbone of the `async`/`await`
    keywords.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类用于异步执行代码块。它的使用已被较新的 `async` 和 `await` 关键字所取代，但本节将介绍创建任务的基础知识，因为它们在较大的或成熟的
    C# 应用程序中普遍存在，并构成了 `async`/`await` 关键字的基石。'
- en: In C#, there are three ways to schedule asynchronous code to run using the `Task`
    class and its generic equivalent `Task<T>`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，有三种方法可以使用 `Task` 类及其泛型等效 `Task<T>` 来安排异步代码的运行。
- en: Creating a New Task
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新任务
- en: You'll start off with the simplest form, one that performs an operation but
    does not return a result back to the caller. You can declare a `Task` instance
    by calling any of the `Task` constructors and passing in an `Action` based delegate.
    This delegate contains the actual code to be executed at some point in the future.
    Many of the constructor overloads allow cancellation tokens and `Task` runs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从最简单的形式开始，即执行操作但不向调用者返回结果的形式。你可以通过调用任何`Task`构造函数并传递基于`Action`的委托来声明一个`Task`实例。此委托包含在未来的某个时刻执行的实际代码。许多构造函数重载允许使用取消令牌和`Task`运行。
- en: 'Some of the commonly used constructors are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的构造函数如下：
- en: '`public Task(Action action)`: The `Action` delegate represents the body of
    code to be run.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task(Action action)`: `Action`委托代表要运行的代码主体。'
- en: '`public Task(Action action, CancellationToken cancellationToken)`: The `CancellationToken`
    parameter can be used as a way to interrupt the code that is running. Typically,
    this is used where the caller has been provided with a means to request that an
    operation be stopped, such as adding a `Cancel` button that a user can press.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task(Action action, CancellationToken cancellationToken)`: 可以使用`CancellationToken`参数作为中断正在运行代码的方式。通常，这用于调用者已提供一种请求停止操作的手段，例如添加一个用户可以按下的`Cancel`按钮。'
- en: '`public Task(Action action, TaskCreationOptions creationOptions)`: `TaskCreationOptions`
    offers a way to control how the `Task` is run, allowing you to provide hints to
    the scheduler that a certain `Task` might take extra time to complete. This can
    help when running related tasks together.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task(Action action, TaskCreationOptions creationOptions)`: `TaskCreationOptions`提供了一种控制`Task`如何运行的方式，允许你向调度器提供提示，表明某个`Task`可能需要额外的时间来完成。这有助于在运行相关任务时。'
- en: 'The following are the most often used `Task` properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用的`Task`属性：
- en: '`public bool IsCompleted { get; }`: Returns `true` if the `Task` completed
    (completion does not indicate success).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCompleted { get; }`: 如果`Task`已完成（完成并不表示成功），则返回`true`。'
- en: '`public bool IsCompletedSuccessfully { get; }`: Returns `true` if the `Task`
    completed successfully.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCompletedSuccessfully { get; }`: 如果`Task`成功完成，则返回`true`。'
- en: '`public bool IsCanceled { get; }`: Returns `true` if the `Task` was canceled
    prior to completion.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCanceled { get; }`: 如果在完成之前`Task`被取消，则返回`true`。'
- en: '`public bool IsFaulted { get; }`: Returns `true` if the `Task` has thrown an
    unhandled exception prior to completion.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsFaulted { get; }`: 如果在完成之前`Task`抛出了未处理的异常，则返回`true`。'
- en: '`public TaskStatus Status { get; }`: Returns an indicator of the task''s current
    status, such as `Canceled`, `Running`, or `WaitingToRun`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public TaskStatus Status { get; }`: 返回任务当前状态的指示器，例如`Canceled`、`Running`或`WaitingToRun`。'
- en: '`public AggregateException Exception { get; }`: Returns the exception, if any,
    that caused the `Task` to end prematurely.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public AggregateException Exception { get; }`: 如果有，返回导致`Task`提前结束的异常。'
- en: Note that the code within the `Action` delegate is not executed until sometime
    after the `Start()` method is called. This may well be some milliseconds after
    and is determined by the .NET scheduler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Action`委托中的代码只有在调用`Start()`方法之后才会执行。这可能是几毫秒之后，由.NET调度器决定。
- en: Start here by creating a new VS Code console app, adding a utility class named
    `Logger`, which you will use in the exercises and examples going forward. It will
    be used to log a message to the console along with the current time and current
    thread's `ManagedThreadId`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个新的VS Code控制台应用程序开始，添加一个名为`Logger`的实用工具类，你将在接下来的练习和示例中使用它。它将用于将消息记录到控制台，并附带当前时间和当前线程的`ManagedThreadId`。
- en: 'The steps for this are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤如下：
- en: Change to your source folder.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到你的源文件夹。
- en: 'Create a new console app project called `Chapter05` by running the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个名为`Chapter05`的新控制台应用程序项目：
- en: '[PRE0]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Rename the `Class1.cs` file to `Logger.cs` and remove all the template code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Class1.cs`文件重命名为`Logger.cs`并移除所有模板代码。
- en: 'Be sure to include the `System` and `System.Threading` namespaces. `System.Threading`
    contains the `Threading` based classes:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一定要包含`System`和`System.Threading`命名空间。`System.Threading`包含基于`Threading`的类：
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Mark the `Logger` class as static so that it can be used without having to
    create an instance to use:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Logger`类标记为静态，这样就可以在不创建实例的情况下使用它：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If you use the `Chapter05` namespace, then the `Logger` class will be accessible
    to code in examples and activities, provided they also use the `Chapter05` namespace.
    If you prefer to create a folder for each example and exercise, then you should
    copy the file `Logger.cs` into each folder that you create.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用 `Chapter05` 命名空间，那么 `Logger` 类将可供示例和活动中的代码访问，前提是它们也使用 `Chapter05` 命名空间。如果你更喜欢为每个示例和练习创建一个文件夹，那么你应该将文件
    `Logger.cs` 复制到你创建的每个文件夹中。
- en: 'Now declare a `static` method called `Log` that is passed a `string message`
    parameter:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在声明一个名为 `Log` 的 `static` 方法，它接受一个 `string message` 参数：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When invoked, this will log a message to the console window using the `WriteLine`
    method. In the preceding snippet, the string interpolation feature in C# is used
    to define a string using the `$` symbol; here, `:T` will format the current time
    (`DateTime.Now`) into a time-formatted string and `:00` is used to include `Thread.ManagedThreadId`
    with a leading 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，它将使用 `WriteLine` 方法将消息记录到控制台窗口。在上面的代码片段中，C# 中的字符串插值功能使用 `$` 符号定义一个字符串；这里，`:T`
    将当前时间 (`DateTime.Now`) 格式化为一个时间格式的字符串，`:00` 用于包含带前导 0 的 `Thread.ManagedThreadId`。
- en: Thus, you have created the static Logger class that will be used throughout
    the rest of this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经创建了一个静态的 `Logger` 类，它将在本章的其余部分中使用。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/cg6c5](https://packt.link/cg6c5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/cg6c5](https://packt.link/cg6c5) 找到用于此示例的代码。
- en: In the next example, you will use the `Logger` class to log details when a thread
    is about to start and finish.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，你将使用 `Logger` 类来记录线程即将开始和结束时的一些细节。
- en: 'Start by adding a new class file called `TaskExamples.cs`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个名为 `TaskExamples.cs` 的新类文件：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Main` entry point will log that `taskA` is being created:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Main` 入口点将记录 `taskA` 正在创建：'
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, add the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the simplest `Task` constructor is passed an `Action` lambda statement,
    which is the actual target code that you want to execute. The target code writes
    the message `Inside taskA` to the console. It pauses for five seconds using `Thread.Sleep`
    to block the current thread, thus simulating a long-running activity, before finally
    writing `Leaving taskA` to the console.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最简单的 `Task` 构造函数传递了一个 `Action` lambda 表达式，这是你想要实际执行的代码的目标。目标代码将消息 `Inside
    taskA` 写入控制台。它使用 `Thread.Sleep` 暂停五秒钟以阻塞当前线程，从而模拟一个长时间运行的活动，最后将 `Leaving taskA`
    写入控制台。
- en: 'Now that you have created `taskA`, confirm that it will only invoke its target
    code when the `Start()` method is called. You will do this by logging a message
    immediately before and after the method is called:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经创建了 `taskA`，确认它只有在调用 `Start()` 方法时才会调用其目标代码。你将通过在方法调用前后立即记录一条消息来完成此操作：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Copy the contents of `Logger.cs` file to same folder as the `TaskExamples.cs`
    example.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Logger.cs` 文件的全部内容复制到与 `TaskExamples.cs` 示例相同的文件夹中。
- en: 'Next run the console app to produce the following output:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来运行控制台应用程序，产生以下输出：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the task's status is `WaitingToRun` even after you've called `Start`.
    This is because you are asking the .NET scheduler to schedule the code to run—that
    is, to add it to its queue of pending actions. Depending on how busy your application
    is with other tasks, it may not run immediately after you've called `Start`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使你调用了 `Start`，任务的状态仍然是 `WaitingToRun`。这是因为你要求 .NET 调度器安排代码运行——也就是说，将其添加到其挂起操作队列中。根据你的应用程序中其他任务的繁忙程度，它可能在你调用
    `Start` 后不会立即运行。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/DHxt3](https://packt.link/DHxt3).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/DHxt3](https://packt.link/DHxt3) 找到用于此示例的代码。
- en: In earlier versions of C#, this was the main way to create and start `Task`
    objects directly. It is no longer recommended and is only included here as you
    may find it used in older code. Its usage has been replaced by the `Task.Run`
    or `Task.Factory.StartNew` static factory methods, which offer a simpler interface
    for the most common usage scenarios.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 的早期版本中，这是直接创建和启动 `Task` 对象的主要方式。现在不再推荐使用，这里仅包括它，因为你在旧代码中可能会遇到它的使用。它的使用已被
    `Task.Run` 或 `Task.Factory.StartNew` 静态工厂方法所取代，这些方法为最常见的使用场景提供了一个更简单的接口。
- en: Using Task.Factory.StartNew
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Task.Factory.StartNew
- en: The static method `Task.Factory.StartNew` contains various overloads that make
    it easier to create and configure a `Task`. Notice how the method is named `StartNew`.
    It creates a `Task` and automatically starts the method for you. The .NET team
    recognized that there is little value in creating a `Task` that is not immediately
    started after it is first created. Typically, you would want the `Task` to start
    performing its operation right away.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法 `Task.Factory.StartNew` 包含各种重载，使得创建和配置 `Task` 更加容易。注意方法被命名为 `StartNew`。它创建一个
    `Task` 并自动为您启动方法。.NET 团队认识到，创建一个在首次创建后不会立即启动的 `Task` 几乎没有价值。通常，您希望 `Task` 立即开始执行其操作。
- en: The first parameter is the familiar `Action` delegate to be executed, followed
    by optional cancelation tokens, creation options, and a `TaskScheduler` instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要执行的熟悉 `Action` 委托，后面跟着可选的取消令牌、创建选项和一个 `TaskScheduler` 实例。
- en: 'The following are some of the common overloads:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的重载：
- en: '`Task.Factory.StartNew(Action action)`: The `Action` delegate contains the
    code to execute, as you have seen previously.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew(Action action)`: `Action` 委托包含要执行的代码，正如您之前所看到的。'
- en: '`Task.Factory.StartNew(Action action, CancellationToken cancellationToken)`:
    Here, `CancellationToken` coordinates the cancellation of the task.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew(Action action, CancellationToken cancellationToken)`:
    在这里，`CancellationToken` 协调任务的取消。'
- en: '`Task.Factory.StartNew(Action<object> action, object state, CancellationToken
    cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)`:
    The `TaskScheduler` parameter allows you to specify a type of low-level scheduler
    responsible for queuing tasks. This option is rarely used.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew(Action<object> action, object state, CancellationToken
    cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)`:
    `TaskScheduler` 参数允许您指定一种低级调度程序类型，该调度程序负责排队任务。此选项很少使用。'
- en: 'Consider the following code, which uses the first and simplest overload:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它使用了第一个也是最简单的重载：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running this code produces the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the output, you can see that this code achieves the same result as creating
    a `Task` but is more concise. The main point to consider is that `Task.Factory.StartNew`
    was added to C# to make it easier to create tasks that are started for you. It
    was preferable to use `StartNew` rather than creating tasks directly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，您可以看到此代码实现了与创建 `Task` 相同的结果，但更加简洁。要考虑的主要点是，`Task.Factory.StartNew` 被添加到
    C# 中是为了使创建由您启动的任务更加容易。与直接创建任务相比，使用 `StartNew` 更为可取。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term **Factory** is often used in software development to represent methods
    that help create objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，术语 **Factory** 通常用于表示帮助创建对象的函数。
- en: '`Task.Factory.StartNew` provides a highly configurable way to start tasks,
    but in reality, many of the overloads are rarely used and need a lot of extra
    parameters to be passed to them. As such, `Task.Factory.StartNew` itself has also
    become somewhat obsolete in favor of the newer `Task.Run` static method. Still,
    the `Task.Factory.StartNew` is briefly covered as you may see it used in legacy
    C# applications.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew` 提供了一种高度可配置的方式来启动任务，但实际上，许多重载很少使用，并且需要传递很多额外的参数。因此，`Task.Factory.StartNew`
    本身也变得有些过时，转而使用更新的 `Task.Run` 静态方法。尽管如此，`Task.Factory.StartNew` 仍将简要介绍，因为您可能会在遗留的
    C# 应用程序中看到它的使用。'
- en: Using Task.Run
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Task.Run
- en: The alternative and preferred `static` factory method, `Task.Run`, has various
    overloads and was added later to .NET to simplify and shortcut the most common
    task scenarios. It is preferable for newer code to use `Task.Run` to create started
    tasks, as far fewer parameters are needed to achieve common threading operations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代和首选的 `static` 工厂方法，`Task.Run` 有各种重载，后来被添加到 .NET 中以简化并缩短最常见的任务场景。对于新代码来说，使用
    `Task.Run` 创建已启动的任务更为可取，因为需要的参数更少，可以完成常见的线程操作。
- en: 'Some of the common overloads are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的重载如下：
- en: '`public static Task Run(Action action)`: Contains the `Action` delegate code
    to execute.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Task Run(Action action)`: 包含要执行的 `Action` 委托代码。'
- en: '`public static Task Run(Action action, CancellationToken cancellationToken)`:
    Additionally contains a cancelation token used to coordinate the cancellation
    of a task.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Task Run(Action action, CancellationToken cancellationToken)`:
    此外还包含一个用于协调任务取消的取消令牌。'
- en: 'For example, consider the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this code will produce the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the output is pretty similar to the outputs of the previous
    two code snippets. Each wait for a shorter time than its predecessor before the
    associated `Action` delegate completes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出与前面两个代码片段的输出非常相似。在相关的 `Action` 委托完成之前，每个等待的时间都比前一个短。
- en: The main difference is that creating a `Task` instance directly is an obsolete
    practice but will allow you to add an extra logging call before you explicitly
    call the `Start` method. That is the only benefit in creating a `Task` directly,
    which is not a particularly compelling reason to do so.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别是直接创建 `Task` 实例是一种过时的做法，但它将允许你在显式调用 `Start` 方法之前添加一个额外的日志调用。这是直接创建 `Task`
    的唯一好处，但这并不是一个特别有说服力的理由去做这件事。
- en: 'Running all three examples together produces this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同时运行这三个示例会产生以下结果：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see various `ManagedThreadIds` being logged and that `taskC` completes
    before `taskB`, which completes before `taskA`, due to the decreasing number of
    seconds specified in the `Thread.Sleep` calls in each case.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到各种 `ManagedThreadIds` 被记录，并且由于在每个情况下 `Thread.Sleep` 调用中指定的秒数逐渐减少，`taskC`
    在 `taskB` 之前完成，而 `taskB` 在 `taskA` 之前完成。
- en: It is preferable to favor either of the two static methods, but which should
    you use when scheduling a new task? `Task.Run` should be used for the `Task.Run`
    defers down to `Task.Factory.StartNew`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更倾向于使用两种静态方法中的任何一种，但当你安排一个新的任务时应该使用哪一个？应该使用 `Task.Run`，因为 `Task.Run` 将会递归到 `Task.Factory.StartNew`。
- en: '`Task.Factory.StartNew` should be used where you have more advanced requirements,
    such as defining where tasks are queued, by using any of the overloads that accept
    a `TaskScheduler` instance, but in practice, this is seldom the requirement.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有更高级的要求时，例如使用接受 `TaskScheduler` 实例的重载之一来定义任务队列的位置时，应该使用 `Task.Factory.StartNew`，但在实践中，这很少是必需的。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on `Task.Run` and `Task.Factory.StartNew` at [https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/)
    and [https://blog.stephencleary.com/2013/08/startnew-is-dangerous.xhtml](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.xhtml).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/)
    和 [https://blog.stephencleary.com/2013/08/startnew-is-dangerous.xhtml](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.xhtml)
    找到关于 `Task.Run` 和 `Task.Factory.StartNew` 的更多信息。
- en: So far, you have seen how small tasks can be started, each with a small delay
    before completion. Such delays can simulate the effect caused by code accessing
    slow network connections or running complex calculations. In the following exercise,
    you'll extend your `Task.Run` knowledge by starting multiple tasks that run increasingly
    longer numeric calculations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何启动小任务，每个任务在完成前都有一个小延迟。这样的延迟可以模拟代码访问慢速网络连接或运行复杂计算时产生的效果。在接下来的练习中，你将通过启动运行时间越来越长的数值计算来扩展你的
    `Task.Run` 知识。
- en: This serves as an example to show how potentially complex tasks can be started
    and allowed to run to completion in isolation from one another. Note that in a
    traditional synchronous implementation, the throughput of such calculations would
    be severely restricted, owing to the need to wait for one operation to complete
    before the next one can commence. It is now time to practice what you have learned
    through an exercise.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这作为一个例子，展示了如何启动可能复杂的任务，并允许它们相互独立地运行到完成。请注意，在传统的同步实现中，这种计算的吞吐量会受到严重限制，因为需要在下一个操作开始之前等待一个操作完成。现在是时候通过练习来实践你所学的知识了。
- en: 'Exercise 5.01: Using Tasks to Perform Multiple Slow-Running Calculations'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.01：使用任务执行多个慢速运行的计算
- en: 'In this exercise, you will create a recursive function, Fibonacci, which calls
    itself twice to calculate a cumulative value. This is an example of potentially
    slow-running code rather than using `Thread.Sleep` to simulate a slow call. You
    will create a console app that repeatedly prompts for a number to be entered.
    The larger this number, the longer each task will take to calculate and output
    its result. The following steps will help you complete this exercise:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个递归函数 Fibonacci，该函数调用自身两次来计算累积值。这是一个使用 `Thread.Sleep` 来模拟慢速调用的潜在慢速运行代码的例子。你将创建一个控制台应用程序，该程序会反复提示输入一个数字。这个数字越大，每个任务计算并输出其结果所需的时间就越长。以下步骤将帮助你完成这个练习：
- en: In the `Chapter05` folder, add a new folder called `Exercises`. Inside that
    folder, add a new folder called `Exercise01`. You should have the folder structure
    as `Chapter05\Exercises\Exercise01`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter05` 文件夹中，添加一个名为 `Exercises` 的新文件夹。在该文件夹内，添加一个名为 `Exercise01` 的新文件夹。你应该有如下文件夹结构：`Chapter05\Exercises\Exercise01`。
- en: Create a new file called `Program.cs`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Program.cs` 的新文件。
- en: 'Add the recursive `Fibonacci` function as follows. You can save a little processing
    time by returning `1` if the requested iteration is less than or equal to `2`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式添加递归的 `Fibonacci` 函数。如果你请求的迭代小于或等于 `2`，可以返回 `1` 以节省一些处理时间：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add the `static Main` entry point to the console app and use a `do`-loop to
    prompt for a number to be entered.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `static Main` 入口点添加到控制台应用程序中，并使用 `do`-循环提示输入一个数字。
- en: 'Use `int.TryParse` to convert the string into an integer if the user enters
    a string:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入一个字符串，使用 `int.TryParse` 将其转换为整数：
- en: '[PRE15]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define a lambda statement that captures the current time using `DateTime.Now`,
    calls the slow-running `Fibonacci` function, and logs the time taken to run:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 lambda 表达式，使用 `DateTime.Now` 获取当前时间，调用慢速运行的 `Fibonacci` 函数，并记录运行时间：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The lambda is passed to `Task.Run` and will be started by `Task.Run` shortly,
    freeing the `do-while` loop to prompt for another number.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式被传递给 `Task.Run`，并将很快由 `Task.Run` 启动，从而释放 `do-while` 循环以提示输入另一个数字。
- en: 'The program shall exit the loop when an empty value is entered:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当输入空值时，程序应退出循环：
- en: '[PRE17]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For running the console app, start by entering the numbers `1` and then `2`.
    As these are very quick calculations, they both return in under one second.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于运行控制台应用程序，首先输入数字 `1` 和 `2`。由于这些计算非常快，它们都在一秒内返回。
- en: '[PRE18]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the `ThreadId` is `[04]` for both `1` and `2`. This shows that the
    same thread was used by `Task.Run` for both iterations. By the time `2` was entered,
    the previous calculation had already been completed. So .NET decided to reuse
    thread `04` again. The same occurs for the value `45`, which took `27` seconds
    to complete even though it was the third requested.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于 `1` 和 `2`，`ThreadId` 都是 `[04]`。这表明 `Task.Run` 在这两个迭代中都使用了相同的线程。当输入 `2`
    时，之前的计算已经完成。所以 .NET 决定再次重用线程 `04`。对于值 `45`，尽管它是第三次请求，但它仍然花费了 `27` 秒来完成。
- en: You can see that entering values above `40` causes the elapsed time to increase
    quite dramatically (for each increase by one, the time taken almost doubles).
    Starting with higher numbers and descending downward, you can see that the calculations
    for `41`, `40`, and `42` were all completed before `44` and `43`, even though
    they were started at similar times. In a few instances, the same thread appears
    twice. Again, this is .NET re-using idle threads to run the task's action.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，输入超过 `40` 的值会导致经过的时间显著增加（每次增加一个，所需时间几乎翻倍）。从更高的数字开始，向下递减，你可以看到 `41`、`40`
    和 `42` 的计算都在 `44` 和 `43` 之前完成，尽管它们是在类似的时间启动的。在少数情况下，同一个线程出现了两次。同样，这是 .NET 重新使用空闲线程来运行任务的操作。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/YLYd4](https://packt.link/YLYd4).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/YLYd4](https://packt.link/YLYd4) 找到用于此练习的代码。
- en: Coordinating Tasks
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协调任务
- en: In the previous *Exercise 5.01*, you saw how multiple tasks can be started and
    left to run to completion without any interaction between the individual tasks.
    One such scenario is a process that needs to search a folder looking for image
    files, adding a copyright watermark to each image file found. The process can
    use multiple tasks, each working on a distinct file. There would be no need to
    coordinate each task and its resulting image.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 *练习 5.01* 中，你看到了如何启动多个任务并在它们完成时无需任何交互地运行。一个这样的场景是需要一个过程来搜索文件夹以查找图像文件，并为每个找到的图像文件添加版权水印。这个过程可以使用多个任务，每个任务处理一个不同的文件。不需要协调每个任务及其生成的图像。
- en: Conversely, it is quite common to start various long-running tasks and only
    continue when some or all of the tasks have completed; maybe you have a collection
    of complex calculations that need to be started and can only perform a final calculation
    once the others have completed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，启动各种长时间运行的任务并在某些或所有任务完成后再继续的情况相当常见；也许你有一系列复杂的计算需要启动，并且只能在其他任务完成后执行最终计算。
- en: In the *Introduction* section, it was mentioned that a hiking application needed
    a GPS satellite signal, navigation route, and a heart rate monitor before it could
    be used safely. Each of these dependencies can be created using a `Task` and only
    when all of them have signaled that they are ready to be used should the application
    then allow the user to start with their route.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *简介* 部分中，提到一个徒步旅行应用程序在使用前需要 GPS 卫星信号、导航路线和心率监测器。这些依赖项都可以使用 `Task` 创建，并且只有当所有这些都表示它们已准备好使用时，应用程序才应允许用户开始他们的路线。
- en: Over the next sections, you will cover various ways offered by C# to coordinate
    tasks. For example, you may have a requirement to start many independent tasks
    running, each running a complex calculation, and need to calculate a final value
    once all the previous tasks have completed. You may either like to start downloading
    data from multiple websites but want to cancel the downloads that are taking too
    long to complete. The next section will cover this scenario.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，你将了解 C# 提供的各种任务协调方式。例如，你可能需要启动许多独立任务运行，每个任务运行一个复杂的计算，并在所有先前任务完成后计算一个最终值。你可能喜欢从多个网站下载数据，但希望取消耗时过长的下载。下一节将介绍这种情况。
- en: Waiting for Tasks to Complete
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待任务完成
- en: '`Task.Wait` can be used to wait for an individual task to complete. If you
    are working with multiple tasks, then the static `Task.WaitAll` method will wait
    for all tasks to complete. The `WaitAll` overloads allow cancellation and timeout
    options to be passed in, with most returning a Boolean value to indicate success
    or failure, as you can see in the following list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Task.Wait` 来等待单个任务完成。如果你正在处理多个任务，那么静态的 `Task.WaitAll` 方法将等待所有任务完成。`WaitAll`
    重载允许传递取消和超时选项，其中大多数返回一个布尔值以指示成功或失败，如以下列表所示：
- en: '`public static bool WaitAll(Task[] tasks, TimeSpan timeout)`: This is passed
    an array of `Task` items to wait for. It returns `true` if `TimeSpan` allows specific
    units such as hours, minutes, and seconds to be expressed).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static bool WaitAll(Task[] tasks, TimeSpan timeout)`: 这接受一个等待的 `Task`
    项目数组。如果 `TimeSpan` 允许表达特定单位，如小时、分钟和秒，则返回 `true`。'
- en: '`public static void WaitAll(Task[] tasks, CancellationToken cancellationToken)`:
    This is passed an array of `Task` items to wait for, and a cancellation token
    that can be used to coordinate the cancellation of the tasks.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void WaitAll(Task[] tasks, CancellationToken cancellationToken)`:
    这接受一个等待的 `Task` 项目数组和一个可以用来协调任务取消的取消令牌。'
- en: '`public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken
    cancellationToken)`: This is passed an array of `Task` items to wait for and a
    cancellation token that can be used to coordinate the cancellation of the tasks.
    `millisecondsTimeout` specifies the number of milliseconds to wait for all tasks
    to complete by.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken
    cancellationToken)`: 这接受一个等待的 `Task` 项目数组和一个可以用来协调任务取消的取消令牌。`millisecondsTimeout`
    指定了等待所有任务完成所需的毫秒数。'
- en: '`public static void WaitAll(params Task[] tasks)`: This allows an array of
    `Task` items to wait for.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void WaitAll(params Task[] tasks)`: 这允许等待一个 `Task` 项数组。'
- en: If you need to wait for any task to complete from a list of tasks, then you
    can use `Task.WaitAny`. All of the `WaitAny` overloads return either the index
    number of the first completed task or `-1` if a timeout occurred (the maximum
    amount of time to wait for).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要等待任务列表中的任何任务完成，则可以使用 `Task.WaitAny`。所有的 `WaitAny` 重载都返回第一个完成的任务的索引号，或者在超时发生时返回
    `-1`（等待的最大时间）。
- en: For example, if you pass an array of five Task items and the last Task in that
    array completes, then you will be returned the value four (array indexes always
    start counting at zero).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你传递一个包含五个 `Task` 项的数组，并且该数组中的最后一个 `Task` 完成，那么你将返回值四（数组索引始终从零开始计数）。
- en: '`public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken
    cancellationToken)`: This is passed an array of `Task` items to wait for, the
    number of milliseconds to wait for any `Task` to complete by, and a cancellation
    token that can be used to coordinate the cancellation of the tasks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken
    cancellationToken)`: 这接受一个等待的 `Task` 项目数组，等待任何 `Task` 完成的毫秒数，以及一个可以用来协调任务取消的取消令牌。'
- en: '`public static int WaitAny(params Task[] tasks)`: This is passed an array of
    `Task` items to wait for any `Task` to be completed.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(params Task[] tasks)`: 这个方法接收一个 `Task` 项的数组，等待任何
    `Task` 完成。'
- en: '`public static int WaitAny(Task[] tasks, int millisecondsTimeout)`: Here, you
    pass the number of milliseconds to wait for any tasks to complete.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(Task[] tasks, int millisecondsTimeout)`: 在这里，您传递等待任何任务完成的毫秒数。'
- en: '`public static int WaitAny(Task[] tasks, CancellationToken cancellationToken)
    CancellationToken`: This is passed a cancellation token that can be used to coordinate
    the cancellation of the tasks.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(Task[] tasks, CancellationToken cancellationToken)
    CancellationToken`: 这个方法接收一个可以用来协调任务取消的取消令牌。'
- en: '`public static int WaitAny(Task[] tasks, TimeSpan timeout)`: This is passed
    the maximum time period to wait for.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(Task[] tasks, TimeSpan timeout)`: 这个方法接收等待的最大时间周期。'
- en: Calling `Wait`, `WaitAll`, or `WaitAny` will block the current thread, which
    can negate the benefits of using a task in the first place. For this reason, it
    is preferable to call these from within an awaitable task, such as via `Task.Run`
    as the following example shows.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Wait`、`WaitAll` 或 `WaitAny` 将阻塞当前线程，这可能会抵消最初使用任务的好处。因此，最好在可等待的任务（如 `Task.Run`）内部调用这些方法，如下例所示。
- en: 'The code creates `outerTask` with a lambda statement, which itself then creates
    two inner tasks, `inner1`, and `inner2`. `WaitAny` is used to get the index of
    the `inner2` will complete first as it pauses for a shorter time, so the resulting
    index value will be `1`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 lambda 表达式创建 `outerTask`，然后它本身创建了两个内部任务 `inner1` 和 `inner2`。使用 `WaitAny`
    获取 `inner2` 将首先完成的索引，因为它暂停的时间较短，所以结果索引值将是 `1`：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the code runs, it produces the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行时，它会产生以下输出：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The application remains responsive because you called `WaitAny` from inside
    a `Task`. You have not blocked the application''s main thread. As you can see,
    thread ID `01` has logged this message: `15:47:43 [01] Press ENTER`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序保持响应，因为您在 `Task` 内部调用了 `WaitAny`。您没有阻塞应用程序的主线程。如您所见，线程 ID `01` 记录了以下消息：“15:47:43
    [01] 按下 ENTER”。
- en: This type of pattern can be used in cases where you need to fire and forget
    a task. For example, you may want to log an informational message to a database
    or a log file, but it is not essential that the flow of the program is altered
    if either task fails to complete.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以在需要一次性忘记任务的情况下使用。例如，您可能希望将信息性消息记录到数据库或日志文件中，但如果任一任务未能完成，程序流程不必要改变。
- en: A common progression from fire-and-forget tasks is those cases where you need
    to wait for several tasks to complete within a certain time limit. The next exercise
    will cover this scenario.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从“一次性”任务到常见进阶的例子是那些需要在一定时间限制内等待多个任务完成的场景。下一个练习将涵盖这个场景。
- en: 'Exercise 5.02: Waiting for Multiple Tasks to Complete Within a Time Period'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.02：在时间周期内等待多个任务完成
- en: In this exercise, you will start three long-running tasks and decide your next
    course of action if they all completed within a certain randomly selected time
    span.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将启动三个长时间运行的任务，并在它们在随机选择的时间跨度内全部完成时决定您的下一步行动。
- en: 'Here, you will see the generic `Task<T>` class being used. The `Task<T>` class
    includes a `Value` property that can be used to access the result of `Task` (in
    this exercise, it is a string-based generic, so `Value` will be a string type).
    You won''t use the `Value` property here as the purpose of this exercise is to
    show that void and generic tasks can be waited for together. Perform the following
    steps to complete this exercise:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将看到通用 `Task<T>` 类的使用。`Task<T>` 类包含一个 `Value` 属性，可以用来访问 `Task` 的结果（在这个练习中，它是一个基于字符串的泛型，因此
    `Value` 将是字符串类型）。在这里您不会使用 `Value` 属性，因为这个练习的目的是展示 void 和泛型任务可以一起等待。完成以下步骤以完成此练习：
- en: 'Add the main entry point to the console app:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主入口点添加到控制台应用程序中：
- en: '[PRE21]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Declare a variable named `taskA`, passing `Task.Run` a lambda that pauses the
    current thread for `5` seconds:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `taskA` 的变量，将 `Task.Run` 传递一个 lambda 表达式，该表达式暂停当前线程 `5` 秒：
- en: '[PRE22]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create two more tasks using the method group syntax:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用方法组语法创建两个更多任务：
- en: '[PRE23]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you may recall, this shorter syntax can be used if the compiler can determine
    the type of argument required for a zero- or single-parameter method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，如果编译器可以确定零参数或单参数方法所需的参数类型，则可以使用这种简短的语法。
- en: 'Now pick a random maximum timeout in seconds. This means that either of the
    two tasks may **not** complete before the timeout period has elapsed:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在随机选择一个以秒为单位的最大超时时间。这意味着两个任务中的任何一个在超时期间都可能**不会**完成：
- en: '[PRE24]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that each of the tasks will still run to completion as you have not added
    a mechanism to stop executing the code inside the body of the `Task.Run` `Action`
    lambda.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个任务仍然会运行到完成，因为您没有在`Task.Run` `Action` lambda的主体中添加停止执行代码的机制。
- en: 'Call `WaitAll`, passing in the three tasks and the `timeout` period:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`WaitAll`，传入三个任务和`timeout`超时时间：
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will return `true` if all tasks complete in time. You will then log the
    status of all tasks and wait for `Enter` to be pressed to exit the application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有任务都能及时完成，这将返回`true`。然后您将记录所有任务的状态，并等待按下`Enter`键以退出应用程序。
- en: 'Finish off by adding two slow-running `Action` methods:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后添加两个运行缓慢的`Action`方法：
- en: '[PRE26]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each will log a message when starting and leaving a task, after a few seconds.
    The useful `nameof` statement is used to include the name of the method for extra
    logging information. Often, it is useful to examine log files to see the name
    of a method that has been accessed rather than hardcoding its name as a literal string.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务在开始和离开任务时都会记录一条消息，几秒钟后。有用的`nameof`语句用于包含方法的名称以提供额外的日志信息。通常，检查日志文件以查看已访问的方法的名称比将名称硬编码为字面字符串更有用。
- en: 'Upon running the code, you will see the following output:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码后，您将看到以下输出：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While running the code, a seven-second timeout was randomly picked by the runtime.
    This allowed all tasks to complete in time, so `true` was returned by `WaitAll`
    and all tasks had a `RanToCompletion` status at that point. Notice that the thread
    ID, in square brackets, is different for all three tasks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码时，运行时随机选择了七秒的超时时间。这使得所有任务都能及时完成，因此`WaitAll`返回`true`，此时所有任务的状态都是`RanToCompletion`。请注意，三个任务中的线程ID，用方括号括起来，是不同的。
- en: 'Run the code again:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码：
- en: '[PRE28]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time the runtime picked a two-second maximum wait time, so the `WaitAll`
    call times out with `false` being returned.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这次运行时选择了两秒的最大等待时间，因此`WaitAll`调用超时，返回`false`。
- en: You may have noticed from the output that `Inside TaskBActivity` can sometimes
    appear before `Inside TaskCActivity`. This demonstrates the .NET scheduler's queuing
    mechanism. When you call `Task.Run`, you are asking the scheduler to add this
    to its queue. There may only be a matter of milliseconds between the time that
    you call `Task.Run` and when it invokes your lambda, but this can depend on how
    many other tasks you have recently added to the queue; a greater number of pending
    tasks could increase that time period.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到输出中`Inside TaskBActivity`有时会出现在`Inside TaskCActivity`之前。这展示了.NET调度器的排队机制。当您调用`Task.Run`时，您是在要求调度器将其添加到队列中。您调用`Task.Run`和它调用您的lambda之间可能只有几毫秒的差距，但这可能取决于您最近添加到队列中的其他任务数量；待处理任务的数量越多，这个时间间隔可能会更长。
- en: Interestingly, the output shows `Leaving TaskBActivity`, but the `taskB` status
    was still `Running` just after `WaitAll` finished waiting. This indicates that
    there can sometimes be a very slight delay when a timed-out task's status is changed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，输出显示了`Leaving TaskBActivity`，但`taskB`的状态在`WaitAll`等待结束后仍然是`Running`。这表明有时在超时任务的状态改变时可能会有一个非常小的延迟。
- en: Some three seconds after the `Enter` key is pressed, `Leaving TaskA` is logged.
    This shows that the `Action` within any timed-out tasks will continue to run,
    and .NET will not stop it for you.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下`Enter`键大约三秒后，记录了`Leaving TaskA`。这表明任何超时任务中的`Action`将继续运行，.NET不会为您停止它。
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/5lH0o](https://packt.link/5lH0o).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/5lH0o](https://packt.link/5lH0o)找到用于此练习的代码。
- en: Continuation Tasks
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延续任务
- en: So far, you have created tasks that are independent of one another, but what
    if you need to continue a task with the results of the previous task? Rather than
    blocking the current thread, by calling `Wait` or accessing the `Result` property,
    this can be achieved using the `Task` `ContinueWith` methods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了相互独立的任务，但假设您需要使用前一个任务的结果来继续一个任务怎么办？而不是通过调用`Wait`或访问`Result`属性来阻塞当前线程，您可以使用`Task`的`ContinueWith`方法来实现这一点。
- en: These methods return a new task, referred to as a **continuation** task, or
    more simply, a continuation, which can consume the previous task's or the antecedent's
    results.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回一个新的任务，称为**延续**任务，或者更简单地说，延续，它可以消费前一个任务或前驱的结果。
- en: 'As with standard tasks, they do not block the caller thread. There are several
    `ContinueWith` overloads available, many allowing extensive customization. A few of
    the more commonly used overloads are as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准任务一样，它们不会阻塞调用线程。有几个`ContinueWith`重载可用，许多允许广泛的定制。以下是一些更常用的重载：
- en: '`public Task ContinueWith(Action<Task<TResult>> continuationAction)`: This
    defines a generic `Action<T>` based `Task` to run when the previous task completes.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task ContinueWith(Action<Task<TResult>> continuationAction)`: 这定义了一个基于泛型`Action<T>`的`Task`，在先前的任务完成时运行。'
- en: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, CancellationToken
    cancellationToken)`: This has a task to run and a cancellation token that can
    be used to coordinate the cancellation of the task.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, CancellationToken
    cancellationToken)`: 这有一个要运行的任务和一个可以用来协调任务取消的取消令牌。'
- en: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskScheduler
    scheduler)`: This also has a task to run and a low-level `TaskScheduler` that
    be used to queue the task.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskScheduler
    scheduler)`: 这也有一个要运行的任务和一个低级别的`TaskScheduler`，可以用来排队任务。'
- en: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskContinuationOptions
    continuationOptions)`: A task to run, with the behavior for the task specified
    with `TaskContinuationOptions`. For example, specifying `NotOnCanceled` indicates
    that you do **not** want the continuation to be called if the previous task is
    canceled.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskContinuationOptions
    continuationOptions)`: 一个要运行的任务，其行为由`TaskContinuationOptions`指定。例如，指定`NotOnCanceled`表示如果先前的任务被取消，则不调用后续操作。'
- en: Continuations have an initial `WaitingForActivation` status. The .NET Framework
    will execute this task once the antecedent task or tasks have completed. It is
    important to note that you do not need to start a continuation and attempting
    to do so will result in an exception.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 后续操作有一个初始的`WaitingForActivation`状态。.NET Framework将在先前的任务或任务完成时执行此任务。需要注意的是，您不需要启动后续操作，尝试这样做将导致异常。
- en: 'The following example simulates calling a long-running function, `GetStockPrice`
    (this may be some sort of web service or database call that takes a few seconds
    to return):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例模拟调用一个长时间运行的功能，`GetStockPrice`（这可能是一种需要几秒钟才能返回的网页服务或数据库调用）：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The call to `GetStockPrice` returns a `double`, which results in the generic
    `Task<double>` being passed to as a continuation (see the highlighted part). The
    `prev` parameter is a generic `Action` of type `Task<double>`, allowing you to
    access the antecedent task and its `Result` to retrieve the value returned from `GetStockPrice`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`GetStockPrice`返回一个`double`，这导致将泛型`Task<double>`作为后续操作传递（请参阅突出显示的部分）。`prev`参数是一个类型为`Task<double>`的泛型`Action`，允许您访问先前的任务及其`Result`以检索从`GetStockPrice`返回的值。
- en: 'If you hover your mouse over the `ContinueWith` method, you will see the IntelliSense
    description for it as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将鼠标悬停在`ContinueWith`方法上，您将看到以下IntelliSense描述：
- en: '![Figure 5.1: ContinueWith method signature ](img/B16835_05_01.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：ContinueWith方法签名](img/B16835_05_01.jpg)'
- en: 'Figure 5.1: ContinueWith method signature'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：ContinueWith方法签名
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ContinueWith` method has various options that can be used to fine-tune
    behavior, and you can get more details about them from [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWith`方法有多种选项可以用来微调行为，您可以从[https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions)获取更多详细信息。'
- en: 'Running the example produces an output similar to the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生类似于以下输出的结果：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the output, thread `[01]` represents the console's main thread. The task
    that called `GetStockPrice` was executed by thread ID `[03]`, yet the continuation
    was executed using a different thread, thread (`[04]`).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，线程 `[01]` 代表控制台的主线程。调用`GetStockPrice`的任务是由线程ID `[03]` 执行的，但后续操作是使用不同的线程（线程
    `[04]`）执行的。
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/rpNcx](https://packt.link/rpNcx).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/rpNcx](https://packt.link/rpNcx)找到此示例使用的代码。
- en: The continuation running on a different thread may not be a problem, but it
    certainly will be an issue if you are working on UWP, WPF, or WinForms UI apps
    where it's essential that UI elements are updated using the main UI thread (unless
    you are using binding semantics).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同线程上运行的延续操作可能不会成问题，但如果你正在开发 UWP、WPF 或 WinForms UI 应用程序，并且必须使用主 UI 线程来更新 UI
    元素（除非你使用绑定语义），那么这肯定是一个问题。
- en: It is worth noting that the `TaskContinuationOptions.OnlyOnRanToCompletion`
    option can be used to ensure the continuation only runs if the antecedent task
    has run to completion first. For example, you may create a `Task` that fetches
    customers' orders from a database and then use a continuation task to calculate
    the average order value. If the previous task fails or is canceled by the user,
    then there is no point in wasting processing power to calculate the average if
    the user no longer cares about the result.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，可以使用 `TaskContinuationOptions.OnlyOnRanToCompletion` 选项来确保延续操作仅在先决任务首先完成时运行。例如，你可能创建一个
    `Task` 来从数据库中检索客户的订单，然后使用延续任务来计算平均订单价值。如果先前的任务失败或被用户取消，那么如果用户不再关心结果，就没有必要浪费处理能力来计算平均值。
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ContinueWith` method has various options that can be used to fine-tune
    behavior, and you can see [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions)
    for more details.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWith` 方法有多种选项可以用来微调行为，你可以查看 [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions)
    获取更多详细信息。'
- en: If you access the `Task<T> Result` property on a `AggregateException` being
    thrown. This will be covered in more detail later.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问正在抛出的 `AggregateException` 上的 `Task<T> Result` 属性。这将在稍后详细说明。
- en: Using Task.WhenAll and Task.WhenAny with Multiple Tasks
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Task.WhenAll 和 Task.WhenAny 与多个任务
- en: You have seen how a single task can be used to create a continuation task, but
    what if you have multiple tasks and need to continue with a final operation when
    any or all of the previous tasks have completed?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用单个任务来创建延续任务，但如果你有多个任务，需要在之前的任务完成时执行最终操作，该怎么办呢？
- en: Earlier, the `Task.WaitAny` and `Task.WaitAll` methods were used to wait for
    tasks to complete, but these block the current thread. This is where `Task.WhenAny`
    and `Task.WhenAll` can be used. They return a new `Task` whose `Action` delegate
    is called **when** any, or all, of the preceding tasks have completed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，使用 `Task.WaitAny` 和 `Task.WaitAll` 方法来等待任务完成，但这些会阻塞当前线程。这就是 `Task.WhenAny`
    和 `Task.WhenAll` 可以使用的地方。它们返回一个新的 `Task`，其 `Action` 委托在 **任何** 或 **所有** 先前的任务完成时被调用。
- en: 'There are four `WhenAll` overloads, two that return a `Task` and two that return
    a generic `Task<T>` allowing the task''s result to be accessed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个 `WhenAll` 重载，两个返回 `Task`，两个返回泛型 `Task<T>`，允许访问任务的结果：
- en: '`public static Task WhenAll(IEnumerable<Task> tasks)`: This continues when
    the collection of tasks completes.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static Task WhenAll(IEnumerable<Task> tasks)`: 当任务集合完成时，这个操作会继续执行。'
- en: '`public static Task WhenAll(params Task[] tasks)`: This continues when the
    array of tasks completes.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static Task WhenAll(params Task[] tasks)`: 当任务数组完成时，这个操作会继续执行。'
- en: '`public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks)`:
    This continues when the array of generic `Task<T>` items complete.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks)`:
    当泛型 `Task<T>` 项的数组完成时，这个操作会继续执行。'
- en: '`public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>>
    tasks)`: This continues when the collection of generic `Task<T>` items complete.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>>
    tasks)`: 当泛型 `Task<T>` 项的集合完成时，这个操作会继续执行。'
- en: '`WhenAny` has a similar set of overloads but returns the `Task` or `Task<T>`
    that is the `WhenAll` and `WhenAny` in practice.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`WhenAny` 具有一组类似的重载，但返回的是 `Task` 或 `Task<T>`，这在实践中相当于 `WhenAll` 和 `WhenAny`。'
- en: 'Exercise 5.03: Waiting for All Tasks to Complete'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.03：等待所有任务完成
- en: Say you have been asked by a car dealer to create a console application that
    calculates the average sales value for cars sold across different regions. A dealership
    is a busy place, but they know it may take a while to fetch and calculate the
    average. For this reason, they want to enter a maximum number of seconds that
    they are prepared to wait for the average calculation. Any longer and they will
    leave the app and ignore the result.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被一位汽车经销商要求创建一个控制台应用程序，用于计算不同地区销售的汽车的平均销售价值。经销商是一个繁忙的地方，但他们知道获取和计算平均值可能需要一段时间。因此，他们希望输入他们准备等待平均计算的最大秒数。如果时间更长，他们将离开应用程序并忽略结果。
- en: The dealership has 10 regional sales hubs. To calculate the average, you need
    to first invoke a method called `FetchSales`, which returns a list of `CarSale`
    items for each of these regions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 经销商有10个区域销售中心。为了计算平均值，首先需要调用一个名为`FetchSales`的方法，该方法为这些区域中的每一个返回一个`CarSale`项目的列表。
- en: Each call to `FetchSales` could be to a potentially slow-running service (you
    will implement random pauses to simulate such a delay) so you need to use a `Task`
    for each as you can't know for sure how long each call will take to complete.
    You also do not want slow-running tasks to affect other tasks, but to calculate
    a valid average, it's important to have **all** results returned before continuing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`FetchSales`可能是一个可能运行缓慢的服务（你将实现随机暂停来模拟这种延迟），因此你需要为每个调用使用一个`Task`，因为你不能确定每个调用需要多长时间才能完成。你也不希望运行缓慢的任务影响其他任务，但为了计算有效的平均值，在继续之前，重要的是要**所有**结果都返回。
- en: Create a `SalesLoader` class that implements `IEnumerable<CarSale> FetchSales()`
    to return the car sales details. Then, a `SalesAggregator` class should be passed
    a list of `SalesLoader` (in this exercise, there will be 10 loader instances,
    one for each region). The aggregator will wait for all loaders to finish using
    `Task.WhenAll` before continuing with a task that calculates the average across
    all regions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`SalesLoader`类，实现`IEnumerable<CarSale> FetchSales()`以返回汽车销售详情。然后，一个`SalesAggregator`类应该传递一个`SalesLoader`列表（在这个练习中，将有10个加载器实例，每个地区一个）。聚合器将等待所有加载器完成使用`Task.WhenAll`，然后再继续执行一个计算所有地区平均值的任务。
- en: 'Perform the following steps to do so:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, create a `CarSale` record. The constructor accepts two values, the name
    of the car and its sale price (`name` and `salePrice`):'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`CarSale`记录。构造函数接受两个值，汽车的名字和其销售价格（`name`和`salePrice`）：
- en: '[PRE31]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now create an interface, `ISalesLoader`, that represents the sales data loading service:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个接口，`ISalesLoader`，它表示销售数据加载服务：
- en: '[PRE32]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It has just one call, `FetchSales`, returning an enumerable of type `CarSale`.
    For now, it's not important to know how the loader works; just that it returns
    a list of car sales when called. Using an interface here allows using various
    types of loader as needed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有一个调用，`FetchSales`，返回一个类型为`CarSale`的可枚举。现在，了解加载器的工作原理并不重要；只需知道调用时会返回汽车销售列表。在这里使用接口允许根据需要使用各种类型的加载器。
- en: 'User the aggregator class to call an `ISalesLoader` implementation:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用聚合类调用`ISalesLoader`实现：
- en: '[PRE33]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is declared as `static` as there is no state between calls. Define an `Average`
    function that is passed an enumerable of `ISalesLoader` items and returns a generic
    `Task<Double>` for the final average calculation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它被声明为`static`，因为在调用之间没有状态。定义一个`Average`函数，该函数接受一个`ISalesLoader`项目的可枚举，并返回一个通用的`Task<Double>`用于最终的平均值计算。
- en: 'For each of the loader parameters, use a LINQ projection to pass a `loader.FetchSales`
    method to `Task.Run`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个加载器参数，使用LINQ投影将`loader.FetchSales`方法传递给`Task.Run`：
- en: '[PRE34]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Each of these will return a `Task<IEnumerable<CarSale>>` instance. `WhenAll`
    is used to create a single task that continues when `ContinueWith` call.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都会返回一个`Task<IEnumerable<CarSale>>`实例。`WhenAll`用于创建一个在`ContinueWith`调用时继续的单个任务。
- en: 'Use the LINQ `SelectMany` to grab all of the `CarSale` items from every loader
    call result, before calling the Linq `Average` on the `SalePrice` field of each
    `CarSale` item:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LINQ的`SelectMany`从每个加载器调用结果中获取所有的`CarSale`项目，在调用Linq的`Average`之前对每个`CarSale`项目的`SalePrice`字段进行操作：
- en: '[PRE35]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the `ISalesLoader` interface from a class called `SalesLoader`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个名为`SalesLoader`的类中实现`ISalesLoader`接口：
- en: '[PRE36]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The constructor will be passed an `int` variable used for logging and a `Random`
    instance to help create a random number of `CarSale` items.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将传递一个用于日志记录的`int`变量和一个`Random`实例，以帮助创建随机数量的`CarSale`项目。
- en: 'Your `ISalesLoader` implementation requires a `FetchSales` function. Include
    a random delay of between `1` and `3` seconds to simulate a less reliable service:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的`ISalesLoader`实现需要一个`FetchSales`函数。包括`1`到`3`秒之间的随机延迟来模拟不太可靠的服务：
- en: '[PRE37]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You are trying to test that your application behaves with various time delays.
    Hence, the random class use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在尝试测试你的应用程序在各种时间延迟下的行为。因此，使用了随机类。
- en: 'Use `Enumerable.Range` and `random.Next` to pick a random number from one to
    five:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Enumerable.Range`和`random.Next`来选择一个介于一和五之间的随机数：
- en: '[PRE38]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is the total number of `CarSale` items to return using your `GetRandomCar` function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用你的`GetRandomCar`函数返回的`CarSale`项目总数。
- en: Use the `GetRandomCar` to generate a `CarSale` item with a random manufacturer's
    name from a hardcoded list.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetRandomCar`生成一个具有随机制造商名称的`CarSale`项目，该名称来自硬编码的列表。
- en: 'Use the `carNames.length` property to pick a random index number between zero
    and four for the car''s name:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`carNames.length`属性来选择一个介于零和四之间的随机索引号用于汽车名称：
- en: '[PRE39]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, create your console app to test this out:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建你的控制台应用程序来测试这个功能：
- en: '[PRE40]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Your app will repeatedly ask for a maximum time that the user is prepared to
    wait while data is downloaded. Once all the data has been downloaded, the app
    will use this to calculate an average price. Pressing `Enter` alone will result
    in the program loop ending. `MaxSalesHubs` is the maximum number of sales hubs
    to request data for.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序将反复询问用户愿意等待的最大时间，以便在下载数据时使用。一旦所有数据都下载完毕，应用程序将使用此信息来计算平均价格。单独按下`Enter`键将导致程序循环结束。`MaxSalesHubs`是请求数据的最大销售中心数。
- en: 'Convert the entered value into an `int` type, then use `Enumerable.Range` again
    to create a random number of new `SalesLoader` instances (you have up to 10 different
    sales hubs):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入的值转换为`int`类型，然后再次使用`Enumerable.Range`来创建一个随机数量的新`SalesLoader`实例（你有最多10个不同的销售中心）：
- en: '[PRE41]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Pass loaders to the static `SalesAggregator.Average` method to receive a `Task<Double>`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将加载器传递给静态`SalesAggregator.Average`方法以接收一个`Task<Double>`。
- en: 'Call `Wait`, passing in the maximum wait time:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Wait`，传入最大等待时间：
- en: '[PRE42]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the `Wait` call does return in time, then you will see a `true` value for
    has completed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Wait`调用在规定时间内返回，那么你将看到`has completed`的值为`true`。
- en: 'Finish off by checking `hasCompleted` and log a message accordingly:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查`hasCompleted`并相应地记录消息：
- en: '[PRE43]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When running the console app and entering a short maximum wait of `1` second,
    you see three loader instances randomly created:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行控制台应用程序并输入短的最大等待时间`1`秒时，你会看到随机创建的三个加载器实例：
- en: '[PRE44]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each loader sleeps for `1` second (you can see various thread IDs are logged)
    before returning a random list of `CarSale` records. You soon reach the maximum
    timeout value, hence the message `Timeout!` with no average value displayed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载器在返回一个随机的`CarSale`记录列表之前会睡眠`1`秒（你可以看到各种线程ID被记录），然后达到最大超时值，因此显示没有平均值的`Timeout!`消息。
- en: 'Enter a larger timeout period of `10` seconds:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个更大的超时时间`10`秒：
- en: '[PRE45]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Entering a value of `10` seconds allow `7` random loaders to complete in time
    and to finally create the average value of `639`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`10`秒的值允许`7`个随机加载器及时完成并最终创建平均值为`639`的值。
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/kbToQ](https://packt.link/kbToQ).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/kbToQ](https://packt.link/kbToQ)找到用于此练习的代码。
- en: So far, this chapter has considered the various ways that individual tasks can
    be created and how static `Task` methods are used to create tasks that are started
    for us. You saw how `Task.Factory.StartNew` is used to create configured tasks,
    albeit with a longer set of configuration parameters. The `Task.Run` methods,
    which were more recently added to C#, are preferable by using their more concise
    signatures for most regular scenarios.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经考虑了创建单个任务的各种方法以及如何使用静态`Task`方法来创建为我们启动的任务。你看到了如何使用`Task.Factory.StartNew`来创建配置任务，尽管它有一组更长的配置参数。最近添加到C#中的`Task.Run`方法，在大多数常规场景下，由于其更简洁的签名而更受欢迎。
- en: Using continuations, single and multiple tasks can be left to run in isolation,
    only continuing with a final task when all or any of the preceding tasks have
    run to completion.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用延续，单个和多个任务可以独立运行，只有当所有或任何前面的任务都完成时，才会继续执行最终任务。
- en: Now it is time to look at the `async` and `wait` keywords to run asynchronous
    code. These keywords are a relatively new addition to the C# language. The `Task.Factory.StartNew`
    and `Task.Run` methods can be found in older C# applications, but hopefully, you
    will see that `async`/`await` provides a much clearer syntax.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看`async`和`await`关键字来运行异步代码了。这些关键字是C#语言中相对较新的添加。`Task.Factory.StartNew`和`Task.Run`方法可以在旧的C#应用程序中找到，但希望你会看到`async`/`await`提供了更清晰的语法。
- en: Asynchronous Programming
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: So far, you have created tasks and used the static `Task` factory methods to
    run and coordinate such tasks. In earlier versions of C#, these were the only
    ways to create tasks.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了任务，并使用静态`Task`工厂方法来运行和协调这些任务。在C#的早期版本中，这些是创建任务的唯一方式。
- en: The C# language now provides the `async` and `await` keywords to `async`/`await`
    style results in less code and the code that is created is generally easier to
    grasp and therefore easier to maintain.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言现在提供了`async`和`await`关键字，这使得`async`/`await`风格的代码更简洁，所创建的代码通常更容易理解，因此也更容易维护。
- en: Note
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may often find that legacy concurrent-enabled applications were originally
    created using `Task.Factory.StartNew` methods are subsequently updated to use
    the equivalent `Task.Run` methods or are updated directly to the `async`/`await`
    style.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会经常发现，遗留的并发启用应用程序最初是使用`Task.Factory.StartNew`方法创建的，随后更新为使用等效的`Task.Run`方法，或者直接更新为`async`/`await`风格。
- en: The `async` keyword indicates that the method will return to the caller before
    it has had a chance to complete its operations, therefore the caller should wait
    for it to complete at some point in time.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`关键字表示方法在完成其操作之前将返回给调用者，因此调用者应该在某个时间点等待其完成。'
- en: Adding the `async` keyword to a method instructs the compiler that it may need
    to generate additional code to create a state machine. In essence, a state machine
    extracts the logic from your original method into a series of delegates and local
    variables that allows code to continue onto the next statement following an `await` expression.
    The compiler generates delegates that can jump back to the same location in the
    method once they have completed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将`async`关键字添加到方法中指示编译器它可能需要生成额外的代码来创建状态机。本质上，状态机将你的原始方法中的逻辑提取到一系列委托和局部变量中，允许代码在`await`表达式之后继续执行到下一个语句。编译器生成可以跳回方法中相同位置的委托。
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You don't normally see this extra complied code, but if you are interested in
    learning more about state machines in C#, visit [https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c](https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不会看到额外的编译代码，但如果你对C#中的状态机感兴趣，可以访问[https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c](https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c)了解更多信息。
- en: Adding the `async` keyword does not mean that `async` method is executed, it
    starts off running synchronously until it comes to a section of code with the
    `await` keyword. At this point, the awaitable block of code (in the following
    example, the `BuildGreetings` call is awaitable due to the preceding `async` keyword)
    is checked to see if it has already been completed. If so, it continues executing
    synchronously. If not, the asynchronous method is paused and returns an incomplete
    `Task` to the caller. This will be complete once the `async` code has been completed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`async`关键字并不意味着`async`方法立即执行，它一开始是同步运行的，直到遇到带有`await`关键字的代码段。在此点，会检查可等待的代码块（在以下示例中，由于前面的`async`关键字，`BuildGreetings`调用是可等待的）是否已经完成。如果是，它将继续同步执行。如果不是，异步方法将被暂停，并返回一个不完整的`Task`给调用者。这将在`async`代码完成时完成。
- en: 'In the following console app, the entry point, `static Main`, has been marked
    as `async` and the `Task` return type added. You cannot mark a `Main` entry point,
    which returns either `int` or `void`, as `async` because the runtime must be able
    to return a `Task` result to the calling environment when the console app closes:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下控制台应用程序中，入口点`static Main`已被标记为`async`，并添加了`Task`返回类型。你不能将返回`int`或`void`的`Main`入口点标记为`async`，因为当控制台应用程序关闭时，运行时必须能够返回`Task`结果给调用环境：
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Running the example produces an output like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生如下输出：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As soon as `Main` runs, it logs `Starting`. Notice how the `ThreadId` is `[01]`.
    As you saw earlier, the console app's main thread is numbered as `1` (because
    the `Logger.Log` method uses the `00` format string, which adds a leading `0`
    to numbers in the range zero to nine).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Main` 运行时，它记录 `Starting`。注意 `ThreadId` 是 `[01]`。正如你之前看到的，控制台应用程序的主线程编号为 `1`（因为
    `Logger.Log` 方法使用 `00` 格式字符串，它为范围零到九的数字添加前导 `0`）。
- en: Then the asynchronous method `BuildGreetings` is called. It sets the string
    `message` variable to `"Morning"` and logs the message. The `ThreadId` is still
    `[01]`; this is currently running synchronously.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用异步方法 `BuildGreetings`。它将字符串变量 `message` 设置为 `"Morning"` 并记录消息。`ThreadId`
    仍然是 `[01]`；这目前是同步运行的。
- en: So far, you have been using `Thread.Sleep` to block the calling thread in order
    or simulate long-running operations, but `async`/`await` makes it easier to simulate
    slow actions using the static `Task.Delay` method and awaiting that call. `Task.Delay`
    returns a task so it can also be used in continuation tasks.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直使用 `Thread.Sleep` 来阻塞调用线程以模拟或模拟长时间运行的操作，但 `async`/`await` 使得使用静态 `Task.Delay`
    方法模拟慢动作并等待该调用变得更容易。`Task.Delay` 返回一个任务，因此它也可以用于后续任务。
- en: Using `Task.Delay`, you will make two distinct awaitable calls (one that waits
    for 10 seconds and the second for two seconds), before continuing and appending
    to your local `message` string. The two `Task.Delay` calls could have been any
    method in your code that returns a `Task`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Task.Delay`，你将进行两个不同的可等待调用（一个等待 10 秒，另一个等待两秒），然后继续并将它们附加到你的本地 `message`
    字符串。这两个 `Task.Delay` 调用可以是你的代码中返回 `Task` 的任何方法。
- en: The great thing here is that each awaited section gets its correct state in
    the order that it was declared in the code, irrespective of waiting 10 (or two)
    seconds prior. The thread IDs have all changed from `[01]` to `[04]`. This tells
    you that a different thread is running these statements. Even the very last `Press
    Enter` message has a different thread to the original thread.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里很棒的一点是，每个等待的部分都会按照它在代码中声明的顺序获得其正确的状态，无论之前等待了 10 秒（或两秒）。线程 ID 都已从 `[01]` 变为
    `[04]`。这告诉你不同的线程正在运行这些语句。甚至最后的 `Press Enter` 消息也有一个与原始线程不同的线程。
- en: '`Async/await` makes it easier to run a series of task-based codes using the
    familiar `WhenAll`, `WhenAny`, and `ContinueWith` methods interchangeably.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async/await` 使得使用熟悉的 `WhenAll`、`WhenAny` 和 `ContinueWith` 方法交替运行一系列基于任务的操作变得更容易。'
- en: The following example shows how multiple `async`/`await` calls can be applied
    at various stages in a program using a mixture of various awaitable calls. This
    simulates an application that makes a call to a database (`FetchPendingAccounts`)
    to fetch a list of user accounts. Each user in the pending accounts list is given
    a unique ID (using a task for each user).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在程序的不同阶段使用各种可等待调用混合应用多个 `async`/`await` 调用。这模拟了一个调用数据库（`FetchPendingAccounts`）以获取用户账户列表的应用程序。待处理账户列表中的每个用户都分配了一个唯一的
    ID（每个用户使用一个任务）。
- en: Based on the user's region, an account is then created in the `Task.WhenAll`
    call signals that everything has been completed.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的区域，`Task.WhenAll` 调用中的创建账户操作表示一切已完成。
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use an `enum` to define a `RegionName`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `enum` 定义一个 `RegionName`：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A `User` record constructor is passed a `userName` and the user''s `region`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 记录构造函数接收一个 `userName` 和用户的 `region`：'
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`AccountGenerator` is the main controlling class. It contains an `async` `CreateAccounts`
    method that can be awaited by a console app (this is implemented at the end of
    the example):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountGenerator` 是主要的控制类。它包含一个可以被控制台应用程序等待的 `async` `CreateAccounts` 方法（这在示例的末尾实现）：'
- en: '[PRE51]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using the `await` keyword, you define an awaitable call to `FetchPendingAccounts`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `await` 关键字，你定义了对 `FetchPendingAccounts` 的可等待调用：
- en: '[PRE52]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For each one of the users returned by `FetchPendingAccounts`, you make an awaitable
    call to `GenerateId`. This shows that a loop can contain multiple awaitable calls.
    The runtime will set the user ID for the correct user instance:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `FetchPendingAccounts` 返回的每个用户，你都会对 `GenerateId` 进行一个可等待调用。这表明循环可以包含多个可等待调用。运行时将为正确的用户实例设置用户
    ID：
- en: '[PRE53]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Using a Linq `Select` function, you create a list of tasks. For each user,
    a Northern or Other account is created based on the user''s region (each one of
    the calls is a `Task` per user):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linq 的 `Select` 函数，你创建了一个任务列表。根据用户的区域，为每个用户创建一个北方或其他账户（每个调用都是一个针对用户的 `Task`）：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The list of account creation tasks is awaited using the `static` `WhenAll`
    call. Once this completes, `UpdatePendindAccounts` will be called passing in the
    updated user list. This shows that you can pass lists of tasks between `async`
    statements:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`的`WhenAll`调用等待账户创建任务列表。一旦完成，`UpdatePendindAccounts`将被调用，并传递更新的用户列表。这表明你可以在`async`语句之间传递任务列表：
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `FetchPendingAccounts` method returns a `Task` containing a list of users
    (here you simulate a delay of `3` seconds using `Task.Delay`):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchPendingAccounts`方法返回一个包含用户列表的`Task`（在这里，你使用`Task.Delay`模拟了`3`秒的延迟）：'
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`GenerateId` uses `Task.FromResult` to generate a globally unique ID using
    the `Guid` class. `Task.FromResult` is used when you want to return a result but
    do not need to create a running task as you would with `Task.Run`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateId`使用`Task.FromResult`通过`Guid`类生成一个全局唯一ID。`Task.FromResult`用于当你想要返回一个结果但不需要创建一个运行的任务时，就像使用`Task.Run`一样：'
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The two `bool` task methods create either a northern account or other account.
    Here, you return `true` to indicate that each account creation call was successful, regardless:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`bool`任务方法创建一个北方账户或其他账户。在这里，你返回`true`以指示每个账户创建调用都成功，无论：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, `UpdatePendingAccounts` is passed a list of users. For each user, you
    create a task that simulates a slow-running call to update each user and returning
    a count of the number of users subsequently updated:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`UpdatePendingAccounts`传递一个用户列表。对于每个用户，你创建一个任务来模拟一个慢速运行的调用以更新每个用户，并返回随后更新的用户数量：
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, the console app creates an `AccountGenerator` instance and waits for
    `CreateAccounts` to finish before writing an `All done` message:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，控制台应用程序创建一个`AccountGenerator`实例，在写入`All done`消息之前等待`CreateAccounts`完成：
- en: '[PRE60]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Running the console app produces this output:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生以下输出：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, you can see that thread `[01]` writes the `Starting` message. This is
    the application's main thread. Note, too, that the main thread also writes `Fetching
    pending accounts...` from the `FetchPendingAccounts` method. This is still running
    synchronously as the awaitable block (`Task.Delay`) has not yet been reached.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到线程`[01]`写入`Starting`消息。这是应用程序的主线程。注意，主线程还从`FetchPendingAccounts`方法中写入`Fetching
    pending accounts...`。这仍然是以同步方式运行的，因为可等待的块（`Task.Delay`）尚未到达。
- en: 'Threads `[4]`, `[5]`, and `[7]` create each of the four user accounts. You
    used `Task.Run` to call the `CreateNorthernAccount` or `CreateOtherAccount` methods.
    Thread `[5]` runs the last statement in `CreateAccounts: Updated 4 pending accounts`.
    The thread numbers might differ in your system because .NET uses an internal pool
    of threads which vary based on how busy each thread is.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '线程`[4]`、`[5]`和`[7]`创建四个用户账户中的每一个。你使用`Task.Run`调用`CreateNorthernAccount`或`CreateOtherAccount`方法。线程`[5]`运行`CreateAccounts:
    Updated 4 pending accounts`中的最后一个语句。线程号可能因系统而异，因为.NET使用一个基于每个线程繁忙程度的内部线程池。'
- en: Note
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ZIK8k](https://packt.link/ZIK8k).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/ZIK8k](https://packt.link/ZIK8k)找到此示例使用的代码。
- en: Async Lambda Expressions
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步Lambda表达式
- en: '*Chapter 3*, *Delegates, Events, and Lambdas*, looked at lambda expressions
    and how they can be used to create succinct code. You can also use the `async`
    keyword with lambda expressions to create code for an event handler that contains
    various `async` code.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章*委托、事件和Lambda表达式*探讨了Lambda表达式及其如何用于创建简洁的代码。你还可以在Lambda表达式中使用`async`关键字来创建包含各种`async`代码的事件处理程序代码。
- en: The following example uses the `WebClient` class to show two different ways
    to download data from a website (this will be covered in great detail in *Chapter
    8*, *Creating and Using Web API Clients* and *Chapter 9*, *Creating API Services*).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`WebClient`类展示从网站下载数据的两种不同方式（这将在第8章*创建和使用Web API客户端*和第9章*创建API服务*中详细讨论）。
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, you add your own event handler to the `WebClient` class `DownloadDataCompleted`
    event using a lambda statement that is prefixed with the `async` keyword. The
    compiler will allow you to add awaitable calls inside the body of the lambda.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用带有`async`关键字的Lambda语句将你自己的事件处理程序添加到`WebClient`类的`DownloadDataCompleted`事件中。编译器将允许你在Lambda表达式的主体内部添加可等待的调用。
- en: 'This event will be fired after `DownloadData` is called and the data requested
    has been downloaded for us. The code uses an awaitable block `Task.Delay` to simulate
    some extra processing on a different thread:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`DownloadData`并为我们下载所需数据之后，此事件将被触发。代码使用可等待的块`Task.Delay`在另一个线程上模拟一些额外的处理：
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You invoke the `DownloadData` method, passing in your URL and then logging
    the length of the web data received. This particular call itself will block the
    main thread until data is downloaded. `WebClient` offers a task-based asynchronous
    version of the `DownloadData` method called `DownloadDataTaskAsync`. So it''s
    recommended to use the more modern `DownloadDataTaskAsync` method as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用`DownloadData`方法，传入你的URL，然后记录接收到的网络数据的长度。这个特定的调用本身会阻塞主线程，直到数据下载完成。`WebClient`提供了`DownloadData`方法的基于任务的异步版本，称为`DownloadDataTaskAsync`。因此，建议使用更现代的`DownloadDataTaskAsync`方法，如下所示：
- en: '[PRE64]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once again, you request the same URL but can simply use an `await` statement,
    which will be run once the data download has been completed. As you can see, this
    requires less code and has a cleaner syntax:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你请求相同的URL，但可以简单地使用`await`语句，该语句将在数据下载完成后执行。正如你所见，这需要更少的代码，并且语法更简洁：
- en: '[PRE65]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Running the code produces this output:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE66]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When running the program, you may see the following warning: `"Warning SYSLIB0014:
    ''WebClient.WebClient()'' is obsolete: ''WebRequest, HttpWebRequest, ServicePoint,
    and WebClient are obsolete. Use HttpClient instead.''"`. Here, Visual Studio has
    suggested that the `HttpClient` class be used, as `WebClient` has been marked
    as obsolete.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '在运行程序时，你可能会看到以下警告：“`Warning SYSLIB0014: ''WebClient.WebClient()'' is obsolete:
    ''WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient
    instead.''"`。在这里，Visual Studio建议使用`HttpClient`类，因为`WebClient`已被标记为过时。'
- en: '`DownloadData` is logged by thread `[01]`, the main thread, which is blocked
    for around one second until the download completes. The size of the downloaded
    file is then logged using the `downloadBytes.Length` property.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadData`由线程`[01]`（主线程）记录，该线程在下载完成前大约被阻塞一秒钟。然后使用`downloadBytes.Length`属性记录下载文件的长度。'
- en: The `DownloadDataTaskAsync` request is handled by thread `06`. Finally, the
    delayed code inside the `DownloadDataCompleted` event handler completes via thread
    `04`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadDataTaskAsync`请求由线程`06`处理。最后，`DownloadDataCompleted`事件处理器内部的延迟代码通过线程`04`完成。'
- en: Note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/IJEaU](https://packt.link/IJEaU).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/IJEaU](https://packt.link/IJEaU)找到这个示例使用的代码。
- en: Canceling Tasks
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消任务
- en: 'Task cancelation is a two-step approach:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 任务取消是一个两步过程：
- en: You need to add a way to request a cancelation.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要添加一种请求取消的方式。
- en: Any cancelable code needs to support this.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可取消的代码都需要支持这一点。
- en: You cannot provide cancelation without both mechanisms in place.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这两种机制，你无法提供取消功能。
- en: Typically, you will start a long-running task that supports cancelation and
    provide the user with the ability to cancel the operation by pressing a button
    on a UI. There are many real-world examples where such cancellation is needed,
    such as image processing where multiple images need to be altered allowing a user
    to cancel the remainder of the task if they run out of time. Another common scenario
    is sending multiple data requests to different web servers and allowing slow-running
    or pending requests to be canceled as soon as the first response is received.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会启动一个支持取消的长运行任务，并允许用户通过在UI上按按钮来取消操作。在许多实际场景中需要这样的取消，例如图像处理，需要修改多个图像，如果用户时间不够，允许他们取消剩余的任务。另一个常见场景是向不同的Web服务器发送多个数据请求，并在收到第一个响应后立即取消慢速运行或挂起的请求。
- en: In C#, `CancellationTokenSource` acts as a top-level object to initiate a cancelation
    request with its `Token` property, `CancellationToken`, being passed to concurrent/slow
    running code that can periodically check and act upon this cancellation status.
    Ideally, you would not want low-level methods to arbitrarily cancel high-level
    operations, hence the separation between the source and the token.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`CancellationTokenSource`作为一个顶级对象，通过其`Token`属性`CancellationToken`来发起取消请求，并将其传递给可以定期检查并对此取消状态做出响应的并发/慢速运行代码。理想情况下，你不会希望低级方法随意取消高级操作，因此源和令牌之间有明确的分离。
- en: 'There are various `CancellationTokenSource` constructors, including one that
    will initiate a cancel request after a specified time has elapsed. Here are a
    few of the `CancellationTokenSource` methods, offering various ways to initiate
    a cancellation request:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource`有各种构造函数，包括一个在指定时间过后会发起取消请求的构造函数。以下是`CancellationTokenSource`的一些方法，提供了多种发起取消请求的方式：'
- en: '`public bool IsCancellationRequested { get; }`: This returns `true` if a cancellation
    has been requested for this token source (a caller has called the `Cancel` method).
    This can be inspected at intervals in the target code.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCancellationRequested { get; }`: 如果已请求取消此令牌源（调用者已调用`Cancel`方法），则该属性返回`true`。这可以在目标代码的间隔中检查。'
- en: '`public CancellationToken Token { get; }`: The `CancellationToken` that is
    linked to this source object is often passed to `Task.Run` overloads, allowing
    .NET to check the status of pending tasks or for your own code to check while
    running.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CancellationToken Token { get; }`: 与此源对象关联的`CancellationToken`通常传递给`Task.Run`的重载版本，允许.NET检查挂起任务的状态，或者允许您的代码在运行时进行检查。'
- en: '`public void Cancel()`: Initiates a request for cancellation.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Cancel()`: 启动取消请求。'
- en: '`public void Cancel(bool throwOnFirstException)`: Initiates a request for cancellation
    and determines whether further operations are to be processed should an exception
    occur.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Cancel(bool throwOnFirstException)`: 启动取消请求并确定是否在发生异常时进一步处理操作。'
- en: '`public void CancelAfter(int millisecondsDelay)`: Schedules a cancel request
    after a specified number of milliseconds.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void CancelAfter(int millisecondsDelay)`: 在指定数量的毫秒后安排取消请求。'
- en: '`CancellationTokenSource` has a `Token` property. `CancellationToken` contains
    various methods and properties that can be used for code to detect a cancellation
    request:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource`具有`Token`属性。`CancellationToken`包含各种方法和属性，可用于代码检测取消请求：'
- en: '`public bool IsCancellationRequested { get; }`: This returns `true` if a cancellation
    has been requested for this token.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCancellationRequested { get; }`: 该属性返回`true`，如果已请求取消此令牌。'
- en: '`public CancellationTokenRegistration Register(Action callback)`: Allows code
    to register a delegate that will be executed by the system if this token is canceled.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CancellationTokenRegistration Register(Action callback)`: 允许代码注册一个在令牌被取消时由系统执行的委托。'
- en: '`public void ThrowIfCancellationRequested()`: Calling this method will result
    in `OperationCanceledException` being thrown if a cancellation has been requested.
    This is typically used to break out of loops.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void ThrowIfCancellationRequested()`: 调用此方法将在请求取消时抛出`OperationCanceledException`。这通常用于跳出循环。'
- en: Throughout the previous examples, you may have spotted that `CancellationToken`
    can be passed to many of the static `Task` methods. For example, `Task.Run`, `Task.Factory.StartNew`,
    and `Task.ContinueWith` all contain overrides that accept `CancellationToken`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您可能已经注意到`CancellationToken`可以传递给许多静态`Task`方法。例如，`Task.Run`、`Task.Factory.StartNew`和`Task.ContinueWith`都包含接受`CancellationToken`的重载版本。
- en: .NET will not try to interrupt or stop any of your code once it is running,
    no matter how many times you call `Cancel` on a `CancellationToken`. Essentially,
    you pass these tokens into target code, but it is up to that code to periodically
    check the cancellation status whenever it can, such as within a loop, and then
    decide how it should act upon it. This makes logical sense; how would .NET know
    at what point it was safe to interrupt a method, maybe one that has hundreds of
    lines of code?
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: .NET不会尝试中断或停止任何正在运行的代码，无论您在`CancellationToken`上调用`Cancel`多少次。本质上，您将这些令牌传递到目标代码中，但该代码必须在其能够时定期检查取消状态，例如在循环中，然后决定如何响应。这在逻辑上是合理的；.NET如何知道何时可以安全地中断一个方法，比如一个可能有数百行代码的方法？
- en: Passing `CancellationToken` to `Task.Run` only provides a hint to the queue
    scheduler that it may not need to start a task's action, but once started, .NET
    will not stop that running code for you. The running code itself must subsequently
    observe the cancelation status.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CancellationToken`传递给`Task.Run`仅向队列调度器提供提示，表明可能不需要启动任务的操作，但一旦启动，.NET不会为您停止正在运行的代码。运行中的代码本身必须随后观察取消状态。
- en: This is analogous to a pedestrian waiting to cross a road at a set of traffic
    lights. Motor vehicles can be thought of as tasks that have been started elsewhere.
    When the pedestrian arrives at the crossing and they press a button (calling `Cancel`
    on `CancellationTokenSource`), the traffic lights should eventually change to
    red so that the moving vehicles are requested to stop. It is up to each individual
    driver to observe that the red light has changed (`IsCancellationRequested`) and
    then decide to stop their vehicle. The traffic light does not forcibly stop each
    vehicle (.NET runtime). If a driver notices that the vehicle behind is too close
    and stopping soon may result in a collision, they may decide to not stop immediately.
    A driver that is not observing the traffic light status at all may fail to stop.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这与一个行人等待在交通灯处过马路的情况类似。机动车辆可以被视为在其他地方已启动的任务。当行人到达交叉路口并按下按钮（在`CancellationTokenSource`上调用`Cancel`）时，交通灯最终应该变为红色，以便请求移动的车辆停止。是否停止车辆取决于每个驾驶员是否注意到红灯已变亮（检查`IsCancellationRequested`），然后决定停止他们的车辆。交通灯不会强制停止每辆车（.NET
    运行时）。如果驾驶员注意到后面的车辆太近，并且很快停止可能会导致碰撞，他们可能会决定不立即停车。一个完全不观察交通灯状态的驾驶员可能会未能停车。
- en: The next sections will continue with exercises that show `async`/`await` in
    action, some of the commonly used options for canceling tasks, in which you will
    need to control whether pending tasks should be allowed to run to completion or
    interrupted, and when you should aim to catch exceptions.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节将继续通过练习展示`async`/`await`的实际应用，一些常用的取消任务选项，在这些选项中，你需要控制是否允许挂起的任务完成或中断，以及何时应该尝试捕获异常。
- en: 'Exercise 5.04: Canceling Long-Running Tasks'
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.04：取消长时间运行的任务
- en: 'You will create this exercise in two parts:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你将分两部分创建这个练习：
- en: One that uses a `Task` that returns a double-based result.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用返回基于双精度浮点数结果的`Task`。
- en: Second that provides a fine-grained level of control by inspecting the `Token.IsCancellationRequested`
    property.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个提供了通过检查`Token.IsCancellationRequested`属性提供精细级别控制的选项。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个练习：
- en: 'Create a class called `SlowRunningService`. As the name suggests, the methods
    inside the service have been designed to be slow to complete:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SlowRunningService`的类。正如其名所示，服务内部的方法已被设计为执行缓慢：
- en: '[PRE67]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add the first slow-running operation, `Fetch`, which is passed a delay time
    (implemented with a simple `Thread.Sleep` call), and the cancellation token, which
    you pass to `Task.Run`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一个慢速运行的操作`Fetch`，它接受一个延迟时间（通过简单的`Thread.Sleep`调用实现），以及取消令牌，你将其传递给`Task.Run`：
- en: '[PRE68]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When `Fetch` is called, the token may get canceled before the sleeping thread awakes.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Fetch`时，在休眠线程醒来之前，令牌可能会被取消。
- en: 'To test whether `Fetch` will just stop running or return a number, add a console
    app to test this. Here, use a default delay (`DelayTime`) of `3` seconds:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试`Fetch`是否会停止运行或返回一个数字，添加一个控制台应用程序来测试这个。在这里，使用默认延迟（`DelayTime`）为`3`秒：
- en: '[PRE69]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add a helper function to prompt for a maximum number of seconds that you are
    prepared to wait. If a valid number is entered, convert the value entered into
    a `TimeSpan`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个辅助函数来提示你准备等待的最大秒数。如果输入了有效的数字，将输入的值转换为`TimeSpan`：
- en: '[PRE70]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add a standard `Main` entry point for the console app. This is marked async
    and returns a `Task`:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为控制台应用程序添加一个标准的`Main`入口点。这个入口点标记为异步并返回一个`Task`：
- en: '[PRE71]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create an instance of the service. You will use the same instance in a loop, shortly:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务的一个实例。你将在循环中使用相同的实例，很快：
- en: '[PRE72]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now add a `do`-loop that repeatedly asks for a maximum delay time:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个`do`循环，反复请求最大延迟时间：
- en: '[PRE73]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This allows you to try various values to see how that affects the cancel token
    and the results you receive back. In the case of a `null` value, you will `break`
    out of the `do`-loop.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你尝试不同的值，以查看它如何影响取消令牌和返回的结果。在`null`值的情况下，你将退出`do`循环。
- en: 'Create `CancellationTokenSource`, passing in the maximum waiting time:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`CancellationTokenSource`，传入最大等待时间：
- en: '[PRE74]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This will trigger a cancellation without having to call the `Cancel` method yourself.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发取消，而无需你自己调用`Cancel`方法。
- en: 'Using the `CancellationToken.Register` method, pass an `Action` delegate to
    be invoked when the token gets signaled for cancellation. Here, simply log a message
    when that occurs:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CancellationToken.Register`方法，传递一个在令牌被信号取消时要调用的`Action`委托。在这里，简单地在发生这种情况时记录一条消息：
- en: '[PRE75]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now for the main activity, call the service''s `Fetch` method, passing in the
    default `DelayTime` and the token:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对于主要活动，调用服务的`Fetch`方法，传入默认的`DelayTime`和令牌：
- en: '[PRE76]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Before you await `resultTask`, add a `try-catch` block to catch any `TaskCanceledException`:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你等待`resultTask`之前，添加一个`try-catch`块来捕获任何`TaskCanceledException`：
- en: '[PRE77]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When using cancelable tasks, there is a possibility that they will throw `TaskCanceledException`.
    In this case, that is okay as you do expect that to happen. Notice that you only
    access the `resultTask.Result` if the task is marked as `IsCompletedSuccessfully`.
    If you attempt to access the `Result` property of a faulted task, then `AggregateException`
    instance is thrown. In some older projects, you may see non-async/await code that
    catches `AggregateException`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可取消的任务时，它们可能会抛出`TaskCanceledException`。在这种情况下，这是可以接受的，因为你确实期望这种情况发生。请注意，你只有在任务被标记为`IsCompletedSuccessfully`时才访问`resultTask.Result`。如果你尝试访问一个已故障任务的`Result`属性，则会抛出`AggregateException`实例。在一些较旧的项目中，你可能看到捕获`AggregateException`的非异步/await代码。
- en: 'Run the app and enter a waiting time greater than the ETA of three seconds,
    `5` in this case:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用并输入一个大于三秒预计到达时间的等待时间，在这个例子中是`5`：
- en: '[PRE78]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As expected, the token was not canceled prior to completion, so you see `Result=3`
    (the elapsed time in seconds).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在完成之前令牌没有被取消，所以你看到`Result=3`（已过时间，单位为秒）。
- en: 'Try this again. For the cancellation to be triggered and detected, enter `2`
    for the number of seconds:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再试一次。为了触发并检测取消，将秒数输入为`2`：
- en: '[PRE79]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Notice that the `Cancelled token` message is logged `Fetch` awakes, but you
    still end up receiving a result of `3` seconds with no `TaskCanceledException`
    message. This emphasizes the point that passing a cancellation token to `Start.Run`
    does not stop the task's action from starting, and more importantly, it did not
    interrupt it either.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当`Fetch`唤醒时，记录了`Cancelled token`消息，但你最终仍然收到了`3`秒的结果，没有`TaskCanceledException`消息。这强调了将取消令牌传递给`Start.Run`不会停止任务动作的启动，更重要的是，它也没有中断它。
- en: 'Finally, use `0` as the maximum waiting time, which will effectively trigger
    the cancellation immediately:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`0`作为最大等待时间，这将有效地立即触发取消：
- en: '[PRE80]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You will see the canceled token message and `TaskCanceledException` being caught,
    but there are no `Sleeping` or `Awake` messages logged at all. This shows that
    the `Action` passed to `Task.Run` was not actually started by the runtime. When
    you pass a `CancelationToken` to `Start.Run`, the task's `Action` gets queued
    but `TaskScheduler` will not run the action if it notices that the token has been
    canceled prior to starting; it just throws `TaskCanceledException`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到取消令牌消息和捕获到的`TaskCanceledException`，但没有任何`Sleeping`或`Awake`消息被记录。这表明传递给`Task.Run`的`Action`实际上并没有被运行时启动。当你将`CancelationToken`传递给`Start.Run`时，任务的动作会被排队，但如果`TaskScheduler`在启动之前注意到令牌已被取消，它将不会运行该动作；它只会抛出`TaskCanceledException`。
- en: Now for an alternative slow-running method, one that allows you to support cancellable
    actions via a loop that polls for a change in the cancellation status.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于一种替代的慢速运行方法，它允许你通过轮询取消状态的变化来支持可取消的动作。
- en: 'In the `SlowRunningService` class, add a `FetchLoop` function:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SlowRunningService`类中，添加一个`FetchLoop`函数：
- en: '[PRE81]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This produces a result similar to the earlier `Fetch` function but its purpose
    is to show how a function can be broken into a repeating loop that offers the
    ability to examine `CancellationToken` as each loop iteration runs.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生与之前`Fetch`函数类似的结果，但其目的是展示一个函数如何被分解成一个重复的循环，该循环在每次循环迭代运行时能够检查`CancellationToken`。
- en: 'Define the body of a `for...next` loop, which checks, for each iteration, if
    the `IsCancellationRequested` property is `true` and simply returns a nullable
    double if it detects that a cancellation has been requested:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`for...next`循环的主体，该循环在每次迭代中检查`IsCancellationRequested`属性是否为`true`，如果检测到请求取消，则简单地返回一个可空的`double`值：
- en: '[PRE82]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This is a rather firm way to exit a loop, but as far as this code is concerned,
    nothing else needs to be done.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当坚决的退出循环的方式，但就这段代码而言，不需要做其他任何事情。
- en: Note
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You could have also used a `continue` statement and cleaned up before returning.
    Another option is to call `token.ThrowIfCancellationRequested()` rather than checking
    `token.IsCancellationRequested`, which will force you to exit the `for` loop.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`continue`语句并在返回之前进行清理。另一种选择是调用`token.ThrowIfCancellationRequested()`而不是检查`token.IsCancellationRequested`，这将迫使你退出`for`循环。
- en: 'In the `Main` console app, add a similar `while` loop that calls the `FetchLoop`
    method this time. The code is similar to the previous looping code:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 控制台应用程序中，添加一个类似的 `while` 循环，这次调用 `FetchLoop` 方法。代码与之前的循环代码类似：
- en: '[PRE83]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now call the `FetchLoop` and await the result:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在调用 `FetchLoop` 并等待结果：
- en: '[PRE84]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Running the console app and using a `5`-second maximum allows all the iterations
    to run through with none detecting a cancellation request. The result is `3` as expected:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并使用 `5` 秒最大值允许所有迭代运行，没有任何检测到取消请求。结果是预期的 `3`：
- en: '[PRE85]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use `2` as the maximum. This time the token is auto-triggered during iteration
    `4` and spotted by iteration `5`, so you are returned a null result:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `2` 作为最大值。这次在迭代 `4` 时自动触发令牌，并在迭代 `5` 时被发现，因此返回了一个空结果：
- en: '[PRE86]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'By using `0`, you see the same output as the earlier `Fetch` example:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `0`，您将看到与之前的 `Fetch` 示例相同的输出：
- en: '[PRE87]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The action doesn't get a chance to run. You can see a `Cancelled token` message
    and `TaskCanceledException` being logged.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 动作没有机会运行。您可以看到一个 `Cancelled token` 消息和 `TaskCanceledException` 被记录。
- en: By running this exercise, you have seen how long-running tasks can be automatically
    marked for cancellation by the .NET runtime if they do not complete within a specified
    time. By using a `for` loop, a task was broken down into small iterative steps,
    which provided a frequent opportunity to detect if a cancellation was requested.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此练习，您已经看到长时间运行的任务如果未在指定时间内完成，.NET 运行时将自动将其标记为取消。通过使用 `for` 循环，任务被分解成小的迭代步骤，这提供了频繁检测是否请求取消的机会。
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/xa1Yf](https://packt.link/xa1Yf).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/xa1Yf](https://packt.link/xa1Yf) 找到用于此练习的代码。
- en: Exception Handling in Async/Await Code
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步/等待代码中的异常处理
- en: You have seen that canceling a task can result in `TaskCanceledException` being
    thrown. Exception handling for asynchronous code can be implemented in the same
    way you would for standard synchronous code, but there are a few things you need
    to be aware of.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到取消任务可能导致抛出 `TaskCanceledException`。异步代码的异常处理可以像标准同步代码一样实现，但您需要注意一些事项。
- en: When code in an `async` method causes an exception to be thrown, the task's
    status is set to **Faulted**. However, an exception will not be rethrown until
    the awaited expression gets rescheduled. What this mean is that if you do not
    await a call, then it's possible for exceptions to be thrown and to go completely
    unobserved in code.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `async` 方法中的代码抛出异常时，任务的状态被设置为 **Faulted**。然而，异常不会重新抛出，直到等待的表达式被重新安排。这意味着如果您不等待调用，则可能抛出异常，并且这些异常在代码中可能完全未被观察。
- en: Unless you absolutely cannot help it, you should not create `async void` methods.
    Doing so makes it difficult for the caller to await your code. This means they
    cannot catch any exceptions raised, which by default, will terminate a program.
    If the caller is not given a `Task` reference to await, then there is no way for
    them to tell if the called method ran to completion or not.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您绝对无法避免，否则不应创建 `async void` 方法。这样做会使调用者难以等待您的代码。这意味着他们无法捕获抛出的任何异常，默认情况下，这会导致程序终止。如果调用者没有
    `Task` 引用以等待，那么他们就没有办法知道被调用的方法是否运行完成。
- en: The general exception to this guideline is in the case of fire-and-forget methods
    as mentioned at the start of the chapter. A method that asynchronously logs the
    usage of the application may not be of such critical importance, so you may not
    care if such calls are successful or not.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此指南的一般例外是在本章开头提到的“一次性”方法。异步记录应用程序使用情况的方法可能不是那么关键，因此您可能不关心这些调用是否成功。
- en: 'It is possible to detect and handle unobserved task exceptions. If you attach
    an event delegate to the static `TaskScheduler.UnobservedTaskException` event,
    you can receive a notification that a task exception has gone unobserved. You
    can attach a delegate to this event as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检测和处理未观察到的任务异常。如果您将事件委托附加到静态 `TaskScheduler.UnobservedTaskException` 事件，您将收到通知，表示任务异常未被观察。您可以通过以下方式将委托附加到该事件：
- en: '[PRE88]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The runtime considers a task exception to be **unobserved** once the task object
    is finalized.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务对象被最终化后，运行时会将任务异常视为 **未观察到的**。
- en: Note
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/OkH7r](https://packt.link/OkH7r).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/OkH7r](https://packt.link/OkH7r) 找到用于此示例的代码。
- en: Continuing with some more exception handling examples, see how you can catch
    a specific type of exception as you would with synchronous code.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用一些异常处理示例，看看你如何可以像同步代码一样捕获特定类型的异常。
- en: In the following example, the `CustomerOperations` class provides the `AverageDiscount`
    function, which returns `Task<int>`. However, there is a chance that it may throw
    `DivideByZeroException`, so you will need to catch that; otherwise, the program
    will crash.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`CustomerOperations`类提供了`AverageDiscount`函数，它返回`Task<int>`。然而，它可能会抛出`DivideByZeroException`，所以你需要捕获它；否则，程序将崩溃。
- en: '[PRE89]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create a `CustomerOperations` instance and wait for the `AverageDiscount` method
    to return a value:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`CustomerOperations`实例并等待`AverageDiscount`方法返回一个值：
- en: '[PRE90]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Choose a random value for `ordercount` between `0` and `2`. An attempt to divide
    by zero will result in an exception being thrown by the .NET runtime:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0`和`2`之间选择一个随机的`ordercount`值。尝试除以零将导致.NET运行时抛出异常：
- en: '[PRE91]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The results show that when `orderCount` was zero, you did catch `DivideByZeroException`
    as expected:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，当`orderCount`为零时，你确实如预期那样捕获了`DivideByZeroException`：
- en: '[PRE92]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Running a second time, there was no error caught:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次运行时，没有捕获到错误：
- en: '[PRE93]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: On your system you may find that the program needs to be run multiple times
    before the `DivideByZeroException` is raised. This is due to the use of a random
    instance to assign a value to `orderCount`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的系统上，你可能需要多次运行程序，`DivideByZeroException`才会被引发。这是由于使用了随机实例来分配`orderCount`的值。
- en: Note
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/18kOK](https://packt.link/18kOK).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/18kOK](https://packt.link/18kOK)找到这个示例使用的代码。
- en: So far, you have created single tasks that may throw exceptions. The following
    exercise will look at a more complex variant.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 所以到目前为止，你已经创建了可能会抛出异常的单个任务。接下来的练习将查看一个更复杂的变体。
- en: 'Exercise 5.05: Handling Async Exceptions'
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.05：处理异步异常
- en: Imagine you have a `CustomerOperations` class that can be used to fetch a list
    of customers via a `Task`. For each customer, you need to run an extra `async`
    task, which goes off to a service to calculate the total value of that customer's
    orders.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`CustomerOperations`类，它可以用来通过`Task`获取客户列表。对于每个客户，你需要运行一个额外的`async`任务，该任务将去到一个服务中计算该客户订单的总价值。
- en: Once you have your customer list, the customers need to be sorted in descending
    order of sales, but due to some security restrictions, you are not allowed to
    read a customer's `TotalOrders` property if their region name is `West`. In this
    exercise you will create a copy of the `RegionName` enum that was used in the
    earlier example.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了客户列表，需要按销售额降序对客户进行排序，但由于一些安全限制，如果你读取的客户区域名称是`West`，则不允许读取客户的`TotalOrders`属性。在这个练习中，你将创建一个在早期示例中使用的`RegionName`枚举的副本。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个练习：
- en: 'Start by adding the `Customer` class:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加`Customer`类：
- en: '[PRE94]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The constructor is passed the customer `name` and their `region`, along with
    a second region that identifies the `protectedRegion` name. If the customer's
    `region` is the same as this `protectedRegion`, then throw an access violation
    exception on any attempt to read the `TotalOrders` property.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数传递客户的`name`和他们的`region`，以及一个标识`protectedRegion`名称的第二个区域。如果客户的`region`与这个`protectedRegion`相同，则在尝试读取`TotalOrders`属性时抛出访问违规异常。
- en: 'Then add a `CustomerOperations` class:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个`CustomerOperations`类：
- en: '[PRE95]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This knows how to load a customer's name and populate their total order value.
    The requirement here is that customers from the `West` region need to have a restriction
    hardcoded, so add a constant called `ProtectedRegion` that has `RegionName.West`
    as a value.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类知道如何加载一个客户的名字并填充他们的总订单价值。这里的要求是来自`West`区域的客户需要有一个硬编码的限制，所以添加一个名为`ProtectedRegion`的常量，其值为`RegionName.West`。
- en: 'Add a `FetchTopCustomers` function:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`FetchTopCustomers`函数：
- en: '[PRE96]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This returns a `Task` enumeration of `Customer` and is marked as `async` as
    you will make further `async` calls to populate each customer's order details
    inside the function. Await using `Task.Delay` to simulate a slow-running operation.
    Here, a sample list of customers is hardcoded. Create each `Customer` instance,
    passing their name, actual region, and the protected region constant, `ProtectedRegion`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个`Customer`的`Task`枚举，并且被标记为`async`，因为你在函数内部将进行进一步的`async`调用以填充每个客户的订单详情。使用`Task.Delay`来模拟一个慢速运行的操作。在这里，有一个硬编码的客户样本列表。创建每个`Customer`实例，传递他们的名字、实际区域和受保护的区域常量`ProtectedRegion`。
- en: 'Add an `await` call to `FetchOrders` (which will be declared shortly):'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FetchOrders` 中添加一个 `await` 调用（稍后将声明）：
- en: '[PRE97]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, iterate through the list of customers, but be sure to wrap each call to
    `TotalOrders` with a `try-catch` block that explicitly checks for the access violation
    exception that will be thrown if you attempt to view a protected customer:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，遍历客户列表，但请确保将每个对 `TotalOrders` 的调用用 `try-catch` 块包装起来，该块明确检查如果尝试查看受保护的客户将抛出的访问违规异常：
- en: '[PRE98]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now that the `filteredCustomers` list has been populated with a filtered list
    of customers, use the Linq `OrderByDescending` extension method to return the
    items sorted by each customer''s `TotalOrders` value:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`filteredCustomers` 列表已经填充了一个过滤后的客户列表，使用 Linq 的 `OrderByDescending` 扩展方法按每个客户的
    `TotalOrders` 值返回项目：
- en: '[PRE99]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Finish off `CustomerOperations` with the `FetchOrders` implementation.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成带有 `FetchOrders` 实现的 `CustomerOperations`。
- en: 'For each customer in the list, use an `async` lambda that pauses for `500`
    milliseconds before assigning a random value to `TotalOrders`:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于列表中的每个客户，使用一个暂停 `500` 毫秒的 `async` lambda，然后为 `TotalOrders` 分配一个随机值：
- en: '[PRE100]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The delay could represent another slow-running service.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟可能代表另一个运行缓慢的服务。
- en: 'Wait for `orderUpdateTasks` to complete using `Task.WhenAll`:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Task.WhenAll` 等待 `orderUpdateTasks` 完成：
- en: '[PRE101]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now create a console app to run the operation:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个控制台应用程序来运行操作：
- en: '[PRE102]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'On running the console, there are no errors as `Roy Batty` from the `West`
    region was skipped safely:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行控制台时，没有错误，因为来自 `West` 区域的 `Roy Batty` 被安全地跳过了：
- en: '[PRE103]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In this exercise, you saw how exceptions can be handled gracefully with asynchronous
    code. You placed a `try-catch` block at the required location, rather than over-complicating
    and adding too many unnecessary levels of nested `try-catch` blocks. When the
    code was run, an exception was caught that did not crash the application.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您看到了如何使用异步代码优雅地处理异常。您在所需位置放置了一个 `try-catch` 块，而不是过度复杂化并添加过多的不必要的嵌套 `try-catch`
    块。当代码运行时，捕获了一个异常而没有使应用程序崩溃。
- en: Note
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/4ozac](https://packt.link/4ozac).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/4ozac](https://packt.link/4ozac) 找到用于此练习的代码。
- en: The AggregateException Class
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AggregateException 类
- en: At the beginning of the chapter, you saw that the `Task` class has an `Exception`
    property of type `AggregateException`. This class contains details about one or
    more errors that occur during an asynchronous call.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，您看到 `Task` 类有一个 `Exception` 属性，其类型为 `AggregateException`。此类包含有关在异步调用期间发生的一个或多个错误的详细信息。
- en: '`AggregateException` has various properties, but the main ones are as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`AggregateException` 有各种属性，但主要如下：'
- en: '`public ReadOnlyCollection<Exception> InnerExceptions { get; }`: A collection
    of exceptions that caused the current exception. A single asynchronous call can
    result in multiple exceptions being raised and collected here.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public ReadOnlyCollection<Exception> InnerExceptions { get; }`: 由当前异常引起的异常集合。单个异步调用可能导致多个异常被引发并收集在此处。'
- en: '`public AggregateException Flatten()`: Flattens all of the `AggregateException`
    instances in the `InnerExeceptions` property into a single new instance. This
    saves you from having to iterate over `AggregateException` nested with the exceptions
    list.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public AggregateException Flatten()`: 将 `InnerExeceptions` 属性中的所有 `AggregateException`
    实例合并为一个单一的新实例。这可以避免您需要遍历嵌套在异常列表中的 `AggregateException`。'
- en: '`public void Handle(Func<Exception, bool> predicate)`: Invokes the specified
    Func handler on every exception in this aggregate exception. This allows the handler
    to return `true` or `false` to indicate whether each exception was handled. Any
    remaining unhandled exceptions will be thrown for the caller to catch as required.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Handle(Func<Exception, bool> predicate)`: 对此聚合异常中的每个异常调用指定的 Func
    处理程序。这允许处理程序返回 `true` 或 `false` 以指示每个异常是否被处理。任何剩余未处理的异常将抛出，由调用者按需捕获。'
- en: When something goes wrong and this exception is caught by a caller, `InnerExceptions`
    contains a list of the exceptions that caused the current exception. These can
    be from multiple tasks, so each individual exception is added to the resulting
    task's `InnerExceptions` collection.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时并且此异常被调用者捕获时，`InnerExceptions` 包含导致当前异常的异常列表。这些可能来自多个任务，因此每个单独的异常都被添加到结果任务的
    `InnerExceptions` 集合中。
- en: 'You may often find `async` code with a `try-catch` block that catches `AggregateException`
    and logs each of `InnerExceptions` details. In this example, `BadTask` returns
    an `int` based task, but it can be the cause of an exception when run. Perform
    the following steps to complete this example:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会经常遇到带有`try-catch`块来捕获`AggregateException`并记录每个`InnerExceptions`详细信息的`async`代码。在这个例子中，`BadTask`返回一个基于`int`的任务，但它运行时可能会引发异常。执行以下步骤来完成此示例：
- en: '[PRE104]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'It sleeps for `1,000` milliseconds before throwing the `InvalidOperationException`
    in case the number passed in is an even number (using the % operator to see if
    the number can be divided by `2` with no remainder):'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入的数字是偶数（使用`%`运算符来查看数字是否可以被`2`整除且没有余数），则它会在抛出`InvalidOperationException`之前睡眠`1,000`毫秒：
- en: '[PRE105]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Add a helper function, `CreateBadTasks`, that creates a collection of five
    bad tasks. When started, each of the tasks will eventually throw an exception
    of type `InvalidOperationException`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个辅助函数`CreateBadTasks`，该函数创建一个包含五个坏任务的集合。当启动时，每个任务最终都会抛出`InvalidOperationException`类型的异常：
- en: '[PRE106]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, create the console app''s `Main` entry point. You pass the results of
    `CreateBadTasks` to `WhenAll`, passing in the string `[WhenAll]` to make it easier
    to see what is happening in the output:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建控制台应用程序的`Main`入口点。你将`CreateBadTasks`的结果传递给`WhenAll`，传递字符串`[WhenAll]`以便更容易地在输出中看到正在发生的事情：
- en: '[PRE107]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Before you attempt to await the `whenAllCompletedTask` task, you need to wrap
    it in `try-catch`, which catches the base `Exception` type (or a more specific
    one if you are expecting that).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试等待`whenAllCompletedTask`任务之前，你需要将其包裹在`try-catch`中，以捕获基础`Exception`类型（如果你期望更具体的一个，则可以捕获更具体的一个）。
- en: 'You cannot catch `AggregateException` here as it''s the first exception inside
    the `Task` that you receive, but you can still use the `Exception` property of
    `whenAllCompletedTask` to get at the `AggregateException` itself:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在这里捕获`AggregateException`，因为它是你接收到的`Task`中的第一个异常，但你仍然可以使用`whenAllCompletedTask`的`Exception`属性来获取`AggregateException`本身：
- en: '[PRE108]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'You''ve caught an exception, so log its type (this will be `InvalidOperationException`
    instance that you threw) and the message:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经捕获了一个异常，因此记录其类型（这将是你抛出的`InvalidOperationException`实例）和消息：
- en: '[PRE109]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now you can examine `whenAllCompletedTask`, iterating though this task''s `AggregateException`
    to see its `InnerExceptions` list:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以检查`whenAllCompletedTask`，通过迭代此任务的`AggregateException`来查看其`InnerExceptions`列表：
- en: '[PRE110]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Running the code, you''ll see five tasks that sleep, and eventually, numbers
    `0`, `2`, and `4` each throw `InvalidOperationException`, which you will catch:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，你会看到五个任务在睡眠，最终数字`0`、`2`和`4`各自抛出`InvalidOperationException`，这将由你捕获：
- en: '[PRE111]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Notice how `number 0` appears to be the only error that was caught (`(Message=Oh`
    dear from `[WhenAll] number 0`). However, by logging each entry in the `InnerExceptions`
    list, you see all `number 0` appearing once again.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`数字 0`似乎是被捕获的唯一错误（`(Message=Oh dear from `[WhenAll] number 0)`）。然而，通过记录`InnerExceptions`列表中的每个条目，你会看到`数字
    0`再次出现。
- en: 'You can try the same code, but this time use `WhenAny`. Remember that `WhenAny`
    will complete when the first task in the list completes, so notice the complete
    lack of **error handling** in this case:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试相同的代码，但这次使用`WhenAny`。记住，`WhenAny`将在列表中的第一个任务完成时完成，所以请注意在这种情况下**错误处理**的完全缺失：
- en: '[PRE112]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Unless you wait for all tasks to complete, you may miss an exception raised
    by a task when using `WhenAny`. Running this code results in not a single error
    being caught and the app does `3` as that completed first:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你等待所有任务完成，否则在使用`WhenAny`时可能会错过任务引发的异常。运行此代码会导致没有捕获到任何错误，并且应用执行`3`，因为这是第一个完成的：
- en: '[PRE113]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: You will finish this look at `async`/`await` code by looking at some of the
    newer options in C# around handling streams of `async` results. This provides
    a way to efficiently iterate through the items of a collection without the calling
    code having to wait for the entire collection to be populated and returned before
    it can start processing the items in the list.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过查看C#中处理`async`结果流的一些较新选项来完成对`async`/`await`代码的审视。这提供了一种方法，可以在调用代码等待整个集合被填充并返回之前，高效地遍历集合中的项目。
- en: Note
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/SuCXK](https://packt.link/SuCXK).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/SuCXK](https://packt.link/SuCXK)找到此示例使用的代码。
- en: IAsyncEnumerable Streams
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IAsyncEnumerable 流
- en: If your application targets .NET 5, .NET6, .NET Core 3.0, .NET Standard 2.1,
    or any of the later versions, then you can use `IAsyncEnumerable` streams to create
    awaitable code that combines the `yield` keyword into an enumerator to iterate
    asynchronously through a collection of objects.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序针对.NET 5、.NET6、.NET Core 3.0、.NET Standard 2.1或任何后续版本，那么你可以使用`IAsyncEnumerable`流来创建可等待的代码，将`yield`关键字结合到枚举器中，以异步方式遍历对象集合。
- en: Note
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Microsoft''s documentation provides this definition of the `yield` keyword:
    When a `yield` return statement is reached in the iterator method, expression
    is returned, and the current location in code is retained. Execution is restarted
    from that location the next time that the iterator function is called.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的文档提供了`yield`关键字的以下定义：当在迭代方法中达到`yield`返回语句时，表达式返回，并保留代码中的当前位置。下一次迭代函数被调用时，从该位置重新启动执行。
- en: Using the `yield` statement, you can create methods that return an enumeration
    of items to the caller. Additionally, the caller does not need to wait for the
    **entire list** of items to be returned before they can start traversing each
    item in the list. Instead, the caller can access each item as soon as it becomes
    available.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`yield`语句，你可以创建返回项目枚举的方法。此外，调用者不需要等待返回**整个列表**的所有项目，就可以开始遍历列表中的每个项目。相反，调用者可以在项目可用时立即访问每个项目。
- en: In this example, you will create a console app that replicates an insurance
    quoting system. You will make five requests for an insurance quote, once again
    using `Task.Delay` to simulate a 1-second delay in receiving each delay.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，你将创建一个控制台应用程序，该程序复制了一个保险报价系统。你将发出五个保险报价请求，再次使用`Task.Delay`来模拟接收每个报价的1秒延迟。
- en: 'For the list-based approach, you can only log each quote once all five results
    have been received back to the `Main` method. Using `IAsyncEnumerable` and the
    `yield` keyword, the same one second exists between quotes being received, but
    as soon as each quote is received, the `yield` statement allows the calling `Main`
    method to receive and process the value quoted. This is ideal if you want to start
    processing items right away or potentially do not want the overhead of having
    thousands of items in a list for longer than is needed to process them individually:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于列表的方法，你只能在所有五个结果都返回到`Main`方法后才能记录每个引用一次。使用`IAsyncEnumerable`和`yield`关键字，引用接收之间存在相同的一秒间隔，但一旦接收到每个引用，`yield`语句就允许调用`Main`方法接收并处理引用的值。如果你希望立即开始处理项目或者可能不想在处理单个项目所需的时间之外在列表中保留数千个项目，这是理想的：
- en: '[PRE114]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Start by `GetInsuranceQuotesAsTask` to return a list of strings and iterate
    through each, logging the details of each quote. This code will wait for all quotes
    to be received before logging each item:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过`GetInsuranceQuotesAsTask`返回一个字符串列表并遍历每个，记录每个报价的详细信息。此代码将在接收到所有报价之前等待所有报价：
- en: '[PRE115]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now for the `async` stream version. If you compare the following code to the
    preceeding code block, you''ll see that there are fewer lines of code needed to
    iterate through the items returned. This code does not wait for all quote items
    to be received but instead writes out each quote as soon as it is received from
    `GetInsuranceQuotesAsync`:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`async`流版本。如果你将以下代码与前面的代码块进行比较，你会看到需要迭代的代码行更少。此代码不会等待接收到所有引用项，而是从`GetInsuranceQuotesAsync`接收到每个引用后立即将其写出：
- en: '[PRE116]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The `GetInsuranceQuotesAsTask` method returns a `Task` of strings. Between
    each of the five quotes, you wait for one second to simulate a delay, before adding
    the result to the list and finally returning the entire list back to the caller:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInsuranceQuotesAsTask`方法返回一个字符串的`Task`。在五个引用之间的每个引用之间，你等待一秒钟来模拟延迟，然后将结果添加到列表中，并最终将整个列表返回给调用者：'
- en: '[PRE117]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `GetInsuranceQuotesAsync` method contains the same delay between each quote,
    but rather than populating a list to return back to the caller, the `yield` statement
    is used to allow the `Main` method to process each quote item immediately:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInsuranceQuotesAsync`方法在每个引用之间有相同的延迟，但不是填充列表以返回给调用者，而是使用`yield`语句允许`Main`方法立即处理每个引用项：'
- en: '[PRE118]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Running the console app produces the following output:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生以下输出：
- en: '[PRE119]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Thread `[04]` logged all five task-based quote details five seconds after the
    app started. Here, it waited for all quotes to be returned before logging each
    quote. However, notice that each of the stream-based quotes was logged as soon
    as it was yielded by threads `4` and `5` with 1 second between them.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 线程 `[04]` 在应用程序启动后5秒内记录了所有五个基于任务的引用详情。在这里，它等待所有引用返回后才记录每个引用。然而，请注意，基于流的每个引用都在线程`4`和`5`之间产生了1秒的间隔后立即被记录。
- en: The overall time taken for both calls is the same (5 seconds in total), but
    `yield` is preferrable when you want to start processing each result as soon as
    it is ready. This is often useful in UI apps where you can provide early results
    to the user.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 两次调用所需的总时间相同（总共5秒），但当你想要一有结果就立即开始处理时，`yield`更可取。这在UI应用程序中非常有用，你可以向用户提供早期结果。
- en: Note
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/KarKW](https://packt.link/KarKW).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/KarKW](https://packt.link/KarKW)找到此示例使用的代码。
- en: Parallel Programming
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行编程
- en: So far, this chapter has covered async programming using the `Task` class and
    `async`/`await` keywords. You have seen how tasks and `async` blocks of code can
    be defined and the flow of a program can be finely controlled as these structures complete.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经介绍了使用`Task`类和`async`/`await`关键字进行异步编程。你已经看到了如何定义任务和`async`代码块，以及随着这些结构的完成，程序流程可以精细控制。
- en: The Parallel Framework (PFX) offers further ways to utilize multicore processors
    to efficiently run concurrent operations. The phrase TPL (Task Parallel Library)
    is generally used to refer to the `Parallel` class in C#.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 并行框架（PFX）提供了进一步利用多核处理器以高效运行并发操作的方法。术语TPL（任务并行库）通常用来指代C#中的`Parallel`类。
- en: Using the Parallel Framework, you do not need to worry about the complexity
    of creating and reusing threads or coordinating multiple tasks. The framework
    manages this for you, even adjusting the number of threads that are used, in order
    to maximize throughput.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并行框架，你不需要担心创建和重用线程或协调多个任务的复杂性。框架为你管理这些，甚至调整使用的线程数量，以最大化吞吐量。
- en: 'For parallel programming to be effective, the order in which each task executes
    must be irrelevant and all tasks should be independent of each other, as you cannot
    be certain when one task completes and the next one begins. Coordinating negates
    any benefits. Parallel programming can be broken down into two distinct concepts:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使并行编程有效，每个任务执行的顺序必须是无关紧要的，并且所有任务都应该相互独立，因为你不能确定何时一个任务完成，下一个任务开始。协调会抵消任何好处。并行编程可以分解为两个不同的概念：
- en: Data parallelism
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据并行
- en: Task parallelism
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务并行
- en: Data Parallelism
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据并行
- en: Data parallelism is used when you have multiple data values, and the same operation
    is to be applied concurrently to each of those values. In this scenario, processing
    each of the values is partitioned across different threads.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多个数据值，并且需要将这些值中的每个值都并发应用相同的操作时，就会使用数据并行。在这种情况下，对每个值的处理被分配到不同的线程中。
- en: A typical example might be calculating the prime numbers from one to 1,000,000\.
    For each number in the range, the same function needs to be applied to determine
    whether the value is a prime. Rather than iterating through each number one at
    a time, an asynchronous approach would be to split numbers across multiple threads.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子可能是计算从1到1,000,000之间的所有质数。对于范围内的每个数字，都需要应用相同的函数来确定该值是否为质数。与其逐个迭代每个数字，不如采用异步方法，将数字分配到多个线程中。
- en: Task Parallelism
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务并行
- en: 'Conversely, task parallelism is used where a collection of threads all performs
    a different action, such as calling different functions or sections of code, concurrently.
    One such example is a program that analyzes the words found in a book, by downloading
    the book''s text and defining separate tasks to do the following:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当一组线程同时执行不同的操作时，例如调用不同的函数或代码段，就会使用任务并行。一个这样的例子是分析一本书中找到的单词的程序，通过下载书的文本并定义以下单独的任务：
- en: Count the number of words.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算单词数量。
- en: Find the longest word.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到最长的单词。
- en: Calculate the average word length.
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算平均单词长度。
- en: Count the number of noise words (the, and, of, for example).
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算噪声词（例如，the、and、of）的数量。
- en: Each of these tasks can be run concurrently and they do not depend on each other.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些任务都可以并发运行，并且它们之间互不依赖。
- en: For the `Parallel` class, the Parallel Framework provides various layers that
    offer parallelism, including Parallel Language Integrated Query (PLINQ). PLINQ
    is a collection of extension methods that add the power of parallel programming
    to the LINQ syntax. The PLINQ won't be covered here in detail, but the `Parallel`
    class will be covered in more detail.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Parallel`类，Parallel Framework提供了各种层，提供了并行性，包括Parallel Language Integrated
    Query (PLINQ)。PLINQ是一组扩展方法，它将并行编程的力量添加到LINQ语法中。这里不会详细介绍PLINQ，但会对`Parallel`类进行更详细的介绍。
- en: Note
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: Note
- en: If you're interested in learning more about PLINQ, you can refer to the online
    documentation at [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于PLINQ的信息，可以参考在线文档[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq)。
- en: The Parallel Class
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The Parallel Class
- en: The `Parallel` class contains just three `static` methods but there are numerous
    overloads providing options to control and influence how actions are performed.
    Each of the methods `Parallel` class is often called from within an awaitable
    block such as `Task.Run`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel`类仅包含三个`static`方法，但提供了许多重载，以提供控制并影响操作执行方式的选择。`Parallel`类中的每个方法通常在`awaitable`块（如`Task.Run`）内部调用。'
- en: It is worth remembering that the runtime may run the required operations in
    parallel only if it thinks that is warranted. In the case of individual steps
    completing sooner than others, the runtime may decide that the overhead of running
    the remaining operations in parallel is not justified.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，运行时只有在认为有理由的情况下才会并行运行所需的操作。在单个步骤比其他步骤更快完成的情况下，运行时可能会决定并行运行剩余操作的开销是不合理的。
- en: 'Some of the commonly used `Parallel` method overloads are as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的`Parallel`方法重载如下：
- en: '`public static ParallelLoopResult For(int from, int to, Action<int> body)`:
    This data parallelism call executes a loop by invoking the body `Action` delegate,
    passing in an `int` value across the from and to numeric range. It returns `ParallelLoopResult`,
    which contains details of the loop once completed.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ParallelLoopResult For(int from, int to, Action<int> body)`:
    这是一个数据并行调用，通过调用`Action`委托体来执行循环，将一个`int`值传递给从到到数字范围的每个值。它返回`ParallelLoopResult`，其中包含循环完成后的详细信息。'
- en: '`public static ParallelLoopResult For(int from, int to, ParallelOptions options,
    Action<int, ParallelLoopState> body)`: A data parallelism call that executes a
    loop across the numeric range. `ParallelOptions` allows loop options to be configured
    and `ParallelLoopState` is used to monitor or manipulate the state of the loop
    as it runs. It returns `ParallelLoopResult`.'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ParallelLoopResult For(int from, int to, ParallelOptions options,
    Action<int, ParallelLoopState> body)`: 这是一个数据并行调用，在数字范围内执行循环。`ParallelOptions`允许配置循环选项，`ParallelLoopState`用于在运行时监控或操作循环的状态。它返回`ParallelLoopResult`。'
- en: '`public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source,
    Action<TSource, ParallelLoopState> body)`: A data parallelism call that invokes
    the `Action` body on each item in the `IEnumerable` source. It returns `ParallelLoopResult`.'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source,
    Action<TSource, ParallelLoopState> body)`: 一个数据并行调用，在`IEnumerable`源中的每个项目上调用`Action`委托体。它返回`ParallelLoopResult`。'
- en: '`public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source,
    Action<TSource> body)`: An advanced data parallelism call that invokes the `Action`
    body and allows you to specify `Partitioner` to provide partitioning strategies
    optimized for specific data structures to improve performance. It returns `ParallelLoopResult`.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source,
    Action<TSource> body)`: 一个高级数据并行调用，调用`Action`委托体，并允许你指定`Partitioner`来提供针对特定数据结构优化的分区策略，以提高性能。它返回`ParallelLoopResult`。'
- en: '`public static void Invoke(params Action[] actions)`: A task parallelism call
    that executes each of the actions passed.'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void Invoke(params Action[] actions)`: 一个任务并行调用，执行传递的每个操作。'
- en: '`public static void Invoke(ParallelOptions parallelOptions, params Action[]
    actions)`: A task parallelism call that executes each of the actions and allows
    `ParallelOptions` to be specified to configure method calls.'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void Invoke(ParallelOptions parallelOptions, params Action[]
    actions)`: 一个任务并行调用，执行每个操作，并允许指定`ParallelOptions`来配置方法调用。'
- en: 'The `ParallelOptions` class can be used to configure how the `Parallel` methods
    operate:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `ParallelOptions` class can be used to configure how the `Parallel` methods
    operate:'
- en: '`public CancellationToken CancellationToken { get; set; }`: The familiar cancelation
    token that can be used to detect within loops if cancellation has been requested
    by a caller.'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CancellationToken CancellationToken { get; set; }`：熟悉的取消令牌，可用于在循环中检测调用者是否请求取消。'
- en: '`public int MaxDegreeOfParallelism { get; set; }`: An advanced setting that
    determines the maximum number of concurrent tasks that can be enabled at a time.'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int MaxDegreeOfParallelism { get; set; }`：一个高级设置，确定一次可以启用多少个并发任务的最大数量。'
- en: '`public TaskScheduler? TaskScheduler { get; set; }`: An advanced setting that
    allows a certain type of task queue scheduler to be set.'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public TaskScheduler? TaskScheduler { get; set; }`：一个高级设置，允许设置某种类型的任务队列调度程序。'
- en: '`ParallelLoopState` can be passed into the body of an `Action` for that action
    to then determine or monitor flow through the loop. The most commonly used properties
    are as follows:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelLoopState`可以被传递到`Action`的主体中，以便该操作可以确定或监控通过循环的流程。最常用的属性如下：'
- en: '`public bool IsExceptional { get; }`: Returns `true` if an iteration has thrown
    an unhandled exception.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsExceptional { get; }`: 如果迭代抛出了未处理的异常，则返回`true`。'
- en: '`public bool IsStopped { get; }`: Returns `true` if an iteration has stopped
    the loop by calling the `Stop` method.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsStopped { get; }`: 如果迭代通过调用`Stop`方法停止了循环，则返回`true`。'
- en: '`public void Break()`: The `Action` loop can call this to indicate execution
    should cease beyond the current iteration.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Break()`: `Action`循环可以调用此方法来指示执行应在当前迭代之后停止。'
- en: '`public void Stop()`: Requests that the loop should cease execution at the
    current iteration.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Stop()`: 请求循环应在当前迭代处停止执行。'
- en: '`ParallelLoopResult`, as returned by the `For` and `ForEach` methods, contains
    a completion status for the `Parallel` loop.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParallelLoopResult`，由`For`和`ForEach`方法返回，包含`Parallel`循环的完成状态。'
- en: '`public bool IsCompleted { get; }`: Indicates that the loop ran to completion
    and did not receive a request to end before completion.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCompleted { get; }`: 表示循环运行完成，并且在完成之前没有收到结束请求。'
- en: '`public long? LowestBreakIteration { get; }`: If `Break` is called `while`
    the loop runs. This returns the index of the lowest iteration the loop arrived
    at.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public long? LowestBreakIteration { get; }`：如果`Break`在循环运行时被调用。这返回循环到达的最低迭代索引。'
- en: Using the `Parallel` class does not automatically mean that a particular bulk
    operation will complete any faster. There is an overhead in scheduling tasks,
    so care should be taken when running tasks that are too short or too long. Sadly,
    there is no simple metric that determines an optimal figure here. It is often
    a case of profiling to see if operations do indeed complete faster using the `Parallel`
    class.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Parallel`类并不意味着特定的批量操作会自动完成得更快。在任务调度中存在开销，因此在运行过短或过长的任务时应谨慎。遗憾的是，没有简单的指标可以确定这里的最佳数值。通常情况下，需要通过分析来查看是否使用`Parallel`类确实可以更快地完成操作。
- en: Note
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on data and task parallelism at [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism)找到有关数据和任务并行性的更多信息。
- en: Parallel.For and Parallel.ForEach
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Parallel.For和Parallel.ForEach
- en: These two methods offer data parallelism. The same operation is applied to a
    collection of data objects or numbers. To benefit from these, each operation should
    be CPU-bound, that is it should require CPU cycles to execute rather than being
    IO-bound (accessing a file, for example).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法提供数据并行性。相同的操作应用于数据对象或数字的集合。为了从中受益，每个操作应该是CPU密集型的，也就是说，它应该需要CPU周期来执行，而不是I/O密集型（例如访问文件）。
- en: With these two methods, you define an `Action` to be applied, which is passed
    an object instance or number to work with. In the case of `Parallel.ForEach`,
    the `Action` is passed an object reference parameter. A numeric parameter is passed
    to `Parallel.For`.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种方法，你定义一个要应用的操作，该操作传递一个对象实例或数字来处理。在`Parallel.ForEach`的情况下，`Action`传递一个对象引用参数。`Parallel.For`传递一个数字参数。
- en: 'As you saw in *Chapter 3*, *Delegates, Events, and Lambdas*, the `Action` delegate
    code can be as simple or complex as you need:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*第3章*，*委托、事件和Lambda表达式*中看到的，`Action`委托代码可以像你需要的那样简单或复杂：
- en: '[PRE120]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In this example, calling `Parallel.For`, you pass an inclusive `int` value
    to start from (`99`) and an exclusive end value (`105`). The third argument is
    a lambda statement, `Action`, that you want invoked over each iteration. This
    overload uses `Action<int>`, passing an integer via the `i` argument:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，调用 `Parallel.For` 时，你传递一个包含的 `int` 值作为起始点（`99`）和一个排他的结束值（`105`）。第三个参数是一个
    lambda 表达式，`Action`，你希望对每个迭代进行调用。这个重载使用 `Action<int>`，通过 `i` 参数传递一个整数：
- en: '[PRE121]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Examine the `ParallelLoopResult` `IsCompleted` property:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `ParallelLoopResult` 的 `IsCompleted` 属性：
- en: '[PRE122]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Running the code, you''ll see that it stops at `104`. Each iteration is executed
    by a set of different threads and the order appears somewhat random with certain
    iterations awaking before others. You have used a relatively short delay (using
    `Thread.Sleep`) so the parallel task scheduler may take a few additional milliseconds
    to activate each iteration. This is the reason why the orders in which iterations
    are executed should be independent of each other:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，你会看到它在 `104` 处停止。每个迭代由一组不同的线程执行，顺序似乎有些随机，某些迭代在另一些迭代之前唤醒。你使用了相对较短的时间延迟（使用
    `Thread.Sleep`），因此并行任务调度器可能需要额外几毫秒来激活每个迭代。这就是为什么迭代执行的顺序应该相互独立：
- en: '[PRE123]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Using the `ParallelLoopState` override, you can control the iterations from
    with the `Action` code. In the following example, the code checks to see if it
    is at iteration number `15`:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ParallelLoopState` 重载，你可以通过 `Action` 代码控制迭代。在下面的示例中，代码检查它是否在迭代编号 `15`：
- en: '[PRE124]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Calling `Break` on `loopState` communicates that the `Parallel` loop should
    cease further iterations as soon as it can:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loopState` 上调用 `Break` 传达了 `Parallel` 循环应尽快停止进一步迭代的意图：
- en: '[PRE125]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'From the results, you can see you got to item `17` before things actually stopped,
    despite asking to break at iteration `15`, as can be seen from the following snippet:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，你可以看到在实际上停止之前，你到达了项目 `17`，尽管在迭代 `15` 时请求中断，如下面的片段所示：
- en: '[PRE126]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The code used `ParallelLoopState.Break`; this indicates the loop `17` despite
    requesting a stop at iteration `15`. This generally occurs when the runtime has
    already started a subsequent iteration and then detects a `Break` request just
    after. These are requests to stop; the runtime may run extra iterations before
    it can stop.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了 `ParallelLoopState.Break`；这表明循环 `17` 尽管在迭代 `15` 时请求停止。这通常发生在运行时已经开始后续迭代，然后刚刚检测到一个
    `Break` 请求。这些是停止请求；运行时可能在停止之前运行额外的迭代。
- en: Alternatively, the `ParallelLoopState.Stop` method can be used for a more abrupt
    stop. An alternative `Parallel.For` overload allows state to be passed into each
    loop and return a single aggregate value.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用 `ParallelLoopState.Stop` 方法实现更突然的停止。一个替代的 `Parallel.For` 重载允许将状态传递到每个循环，并返回一个单个聚合值。
- en: To better learn about these overloads, you will calculate the value of `pi`
    in the next example. This is an ideal task for `Parallel.For` as it means repeatedly
    calculating a value, which is aggregated before being passed to the next iteration.
    The higher the number of iterations, the more accurate the final number.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解这些重载，你将在下一个示例中计算 `pi` 的值。这是一个非常适合 `Parallel.For` 的任务，因为它意味着重复计算一个值，该值在传递给下一个迭代之前被聚合。迭代次数越高，最终数值越精确。
- en: Note
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on the formula at [https://www.mathscareers.org.uk/article/calculating-pi/](https://www.mathscareers.org.uk/article/calculating-pi/).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.mathscareers.org.uk/article/calculating-pi/](https://www.mathscareers.org.uk/article/calculating-pi/)
    上找到有关公式的更多信息。
- en: 'You use a loop to prompt the user to enter the number of series (the number
    of decimal places to be shown) as a multiple of a million (to save typing many
    zeroes):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用循环提示用户输入系列数（要显示的小数位数）作为百万的倍数（以节省输入许多零）：
- en: '[PRE127]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Try to parse the input:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解析输入：
- en: '[PRE128]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Multiply the entered value by one million and pass it to the awaitable `CalcPi`
    function (which will be defined shortly):'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入的值乘以一百万，并将其传递给可等待的 `CalcPi` 函数（稍后将定义）：
- en: '[PRE129]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You eventually receive the value of `pi`, so use the string interpolation feature
    to write `pi` to `18` decimal places using the `:N18` numeric format style:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会收到 `pi` 的值，因此使用字符串插值功能将 `pi` 写入 `18` 位小数，使用 `:N18` 数值格式样式：
- en: '[PRE130]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Repeat the loop until `0` is entered:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 重复循环，直到输入 `0`：
- en: '[PRE131]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now for the `CalcPi` function. You know that the `Parallel` methods all block
    the calling thread, so you need to use `Task.Run` which will eventually return
    the final calculated value.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 `CalcPi` 函数。你知道 `Parallel` 方法都会阻塞调用线程，所以你需要使用 `Task.Run`，它最终将返回最终计算出的值。
- en: The concept of thread synchronization will be covered briefly. There is a danger
    when using multiple threads and shared variables that one thread may read a value
    from memory and attempt to write a new value at the same time a different thread
    is trying to do the same operation, with its own value and what it thinks is the
    correct current value, when it may have read an already out-of-date shared value.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 将简要介绍线程同步的概念。当使用多个线程和共享变量时，存在一种危险，即一个线程可能从内存中读取一个值，并在另一个线程尝试执行相同操作的同时尝试写入新值，该线程使用自己的值和它认为的正确当前值，而此时它可能已经读取了一个已经过时的共享值。
- en: To prevent such issues, a mutual-exclusion lock can be used so that a given
    thread can execute its statements while it holds a lock and then releases that
    lock when finished. All other threads are blocked from acquiring the lock and
    are forced to wait until the lock is released.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止此类问题，可以使用互斥锁，以便在给定线程持有锁时执行其语句，并在完成后释放该锁。所有其他线程都被阻止获取锁，并被迫等待直到锁被释放。
- en: 'This can be achieved using the `lock` statement. All of the complexities are
    handled by the runtime when the `lock` statement is used to achieve thread synchronization.
    The `lock` statement has the following form:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `lock` 语句来实现。当使用 `lock` 语句实现线程同步时，所有复杂性都由运行时处理。`lock` 语句具有以下形式：
- en: '[PRE132]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Conceptually, you can think of the `lock` statement as a narrow gate that has
    enough room to allow just one person to pass through at a time. No matter how
    long a person takes to pass through the gate and what they do while they are there,
    everyone else must wait to get through the gate until the person with the key
    has left (releasing the lock).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 概念上，你可以将 `lock` 语句想象成一个狭窄的通道，足够容纳一个人一次通过。无论一个人通过通道需要多长时间以及他们在那里做什么，其他人必须等待，直到持有钥匙的人离开（释放锁）才能通过通道。
- en: 'Returning to the `CalcPi` function:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `CalcPi` 函数：
- en: '[PRE133]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `gate` variable is of type `object` and used with the `lock` statement
    inside the lambda to protect the `sum` variable from unsafe access:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`gate` 变量是 `object` 类型，并在 lambda 表达式中与 `lock` 语句一起使用，以保护 `sum` 变量免受不安全访问：'
- en: '[PRE134]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This is where things get a little more complex, as you use the `Parallel.For`
    overload, which additionally allows you to pass in extra parameters and delegates:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情变得稍微复杂一些，因为你使用了 `Parallel.For` 重载，它还允许你传递额外的参数和委托：
- en: '`fromInclusive`: The start index (`0` in this case).'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromInclusive`：起始索引（在本例中为 `0`）。'
- en: '`toExclusive`: The end index (steps).'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toExclusive`：结束索引（步数）。'
- en: '`localInit`: A `Func` delegate that returns the **initial state** of data local
    to each iteration.'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localInit`：一个 `Func` 委托，返回每个迭代的局部数据的 **初始状态**。'
- en: '`body`: The actual `Func` delegate that calculates a value of Pi.'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：实际计算 Pi 值的 `Func` 委托。'
- en: '`localFinal`: A `Func` delegate that performs the final action on the local
    state of each iteration.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localFinal`：一个 `Func` 委托，用于对每个迭代的局部状态执行最终操作。'
- en: '[PRE135]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Here, you now use the `lock` statement to ensure that only one thread at a
    time can increment the value of `sum` with its own correct value:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你现在使用 `lock` 语句来确保一次只有一个线程可以递增 `sum` 的值，并使用其正确的值：
- en: '[PRE136]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'By using the `lock(obj)` statement, you have provided a minimum level of thread
    safety, and running the program produces the following output:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `lock(obj)` 语句，你已经提供了一种最低级别的线程安全性，运行程序会产生以下输出：
- en: '[PRE137]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '`Parallel.ForEach` follows similar semantics; rather than a range of numbers
    being passed to the `Action` delegate, you pass a collection of objects to work
    with.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach` 遵循类似的语义；而不是将数字范围传递给 `Action` 委托，你传递一个要处理的对象集合。'
- en: Note
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/1yZu2](https://packt.link/1yZu2).
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/1yZu2](https://packt.link/1yZu2) 找到用于此示例的代码。
- en: The following example shows `Parallel.ForEach` using `ParallelOptions` along
    with a cancelation token. In this example, you have a console app that creates
    10 customers. Each customer has a list containing the value of all orders placed.
    You want to simulate a slow-running service that fetches a customer's order on
    demand. Whenever any code accesses the `Customer.Orders` property, the list is
    populated only once though. Here, you will use another `lock` statement per customer
    instance to ensure the list is safely populated.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了使用 `ParallelOptions` 和取消令牌的 `Parallel.ForEach`。在这个例子中，你有一个控制台应用程序，它创建了
    10 个客户。每个客户都有一个包含所有已下订单值的列表。你想要模拟一个按需获取客户订单的慢速运行服务。每当任何代码访问 `Customer.Orders`
    属性时，列表只填充一次。在这里，你将为每个客户实例使用另一个 `lock` 语句来确保列表安全地填充。
- en: An `Aggregator` class will iterate through the list of customers and calculate
    the total and average order costs using a `Parallel.ForEach` call. Allow the user
    to enter a maximum time period that they are prepared to wait for all of the aggregations
    to complete and then show the top five customers.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregator` 类将遍历客户列表，并使用 `Parallel.ForEach` 调用来计算总订单成本和平均订单成本。允许用户输入他们愿意等待所有聚合操作完成的最大时间周期，然后显示前五名客户。'
- en: 'Start by creating a `Customer` class whose constructor is passed a `name` argument:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个 `Customer` 类，其构造函数接收一个 `name` 参数：
- en: '[PRE138]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You want to populate the `Orders` list on demand and once only per customer,
    so use another `lock` example that ensures the list of orders is safely populated
    once. You simply use the `Orders` `get` accessor to check for a null reference
    on the `_orders` variable, before creating a random number of order values using
    the `Enumerable.Range` LINQ method to generate a range of numbers.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望按需填充 `Orders` 列表，并且每个客户只填充一次，因此使用另一个 `lock` 示例来确保订单列表安全地只填充一次。你只需使用 `Orders`
    的 `get` 访问器来检查 `_orders` 变量的空引用，然后使用 `Enumerable.Range` LINQ 方法创建一个随机数量的订单值来生成一个数字范围。
- en: 'Note, you also simulate a slow request by adding `Thread.Sleep` to block the
    thread that is accessing this customer''s orders for the first time (as you''re
    using the `Parallel` class, this will be a background thread rather than the main
    thread):'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还可以通过添加 `Thread.Sleep` 来模拟慢速请求，这将阻塞第一次访问此客户订单的线程（由于你使用了 `Parallel` 类，这将是一个后台线程而不是主线程）：
- en: '[PRE139]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `Total` and `Average` properties that will be calculated by your `Aggregator`
    class are as follows:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `Aggregator` 类将计算以下 `Total` 和 `Average` 属性：
- en: '[PRE140]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Looking at the `Aggregator` class, note that its `Aggregate` method is passed
    a list of customers to work with and `CancellationToken`, which will automatically
    raise a cancellation request based on the console user''s preferred timespan.
    The method returns a bool-based `Task`. The result will indicate whether the operation
    was canceled partway through processing the customers:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下 `Aggregator` 类，注意它的 `Aggregate` 方法接收一个要处理的客户列表和 `CancellationToken`，该令牌将根据控制台用户的偏好时间周期自动发出取消请求。该方法返回一个基于
    `bool` 的 `Task`。结果将指示操作是否在处理客户过程中被取消：
- en: '[PRE141]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The main `Parallel.ForEach` method is configured by creating a `ParallelOptions`
    class, passing in the cancellation token. When invoked by the `Parallel` class,
    the `Action` delegate is passed a `Customer` instance (`customer =>`) that simply
    sums the order values and calculates the average which is assigned to the customer's
    properties.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 主 `Parallel.ForEach` 方法通过创建一个 `ParallelOptions` 类并传入取消令牌来配置。当由 `Parallel` 类调用时，`Action`
    委托传递一个 `Customer` 实例（`customer =>`），该实例仅简单地对订单值求和并计算平均值，然后将平均值分配给客户的属性。
- en: 'Notice how the `Parallel.ForEach` call is wrapped in a `try-catch` block that
    catches any exceptions of type `OperationCanceledException`. If the maximum time
    period is exceeded, then the runtime will throw an exception to stop processing.
    You must catch this; otherwise, the application will crash with an unhandled exception
    error:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Parallel.ForEach` 调用被包裹在一个 `try-catch` 块中，该块捕获任何类型的 `OperationCanceledException`
    异常。如果超过最大时间周期，则运行时会抛出异常以停止处理。你必须捕获此异常；否则，应用程序将因未处理的异常错误而崩溃：
- en: '[PRE142]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The main console app prompts for a maximum waiting time, `maxWait`:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 主控制台应用程序提示输入最大等待时间，`maxWait`：
- en: '[PRE143]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Create `100` customers that can be passed to the aggregator:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `100` 个客户，这些客户可以传递给聚合器：
- en: '[PRE144]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Create `CancellationTokenSource` instance, passing in the maximum wait time.
    As you saw earlier, any code that uses this token will be interrupted with a cancellation
    exception should the time limit be exceeded:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`CancellationTokenSource`实例，传入最大等待时间。如您之前所见，如果超过时间限制，使用此令牌的任何代码都将被取消异常中断：
- en: '[PRE145]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Once the task completes, you simply take the top five customers ordered by
    total. The `PadRight` method is used to align the customer''s name in the output:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成后，您只需取出按总订单排序的前五个客户。使用`PadRight`方法对输出中的客户姓名进行对齐：
- en: '[PRE146]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Running the console app with a short time of `1` second produces this output:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`1`秒的短时间运行控制台应用程序会产生以下输出：
- en: '[PRE147]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The operation of creating `10` customers ran using Thread `01` as this was intentionally synchronous.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程`01`创建`10`个客户的操作是同步进行的。
- en: Note
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visual Studio may show the following warning the first time you run the program:
    `Non-nullable field ''_orders'' must contain a non-null value when exiting constructor.
    Consider declaring the field as nullable.` This is a suggestion to check the code
    for the possibility of a null reference.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio在您第一次运行程序时可能会显示以下警告：“非空字段`_orders`在退出构造函数时必须包含一个非空值。考虑将字段声明为可空。”这是检查代码以检查空引用可能性的建议。
- en: '`Aggregator` then starts processing each of the customers. Notice how different
    threads are used and processing does not start with the first customer either.
    This is the task scheduler deciding which task is next in the queue. You only
    managed to process eight of the customers before the token raised the cancelation
    exception.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregator`随后开始处理每个客户。注意如何使用不同的线程，并且处理并不从第一个客户开始。这是任务调度器决定队列中下一个任务的过程。在令牌引发取消异常之前，您只成功处理了八个客户。'
- en: Note
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/1LDxI](https://packt.link/1LDxI).
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/1LDxI](https://packt.link/1LDxI)找到此示例使用的代码。
- en: You have looked at some of the features available in the `Parallel` class. You
    can see that it provides a simple yet effective way to run code across multiple
    tasks or pieces of data.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经查看了一些`Parallel`类中可用的功能。您可以看到它提供了一个简单而有效的方法来跨多个任务或数据片段运行代码。
- en: The phrase `Parallel` class is an example of this and can be a great utility.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 术语`Parallel`类是此类的一个例子，并且可以是一个非常有用的工具。
- en: The next section will bring these concurrency concepts into an activity that
    uses multiple tasks to generate a sequence of images. As each of the images can
    take a few seconds to create, you will need to offer the user a way to cancel
    any remaining tasks if the user so chooses.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将把这些并发概念引入到一个使用多个任务生成一系列图像的活动。由于每个图像的创建可能需要几秒钟，因此您需要提供一个让用户选择取消任何剩余任务的方法。
- en: 'Activity 5.01: Creating Images from a Fibonacci Sequence'
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：从斐波那契数列创建图像
- en: In *Exercise 5.01*, you looked at a recursive function to create a value called
    a Fibonacci number. These numbers can be joined into what is known as a Fibonacci
    sequence and used to create interesting spiral-shaped images.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习5.01*中，您查看了一个创建称为斐波那契数的值的递归函数。这些数字可以组合成所谓的斐波那契数列，并用于创建有趣的螺旋形状的图像。
- en: For this activity, you need to create a console application that allows various
    inputs to be passed to a sequence calculator. Once the user has entered their
    parameters, the app will start the time-consuming task of creating 1,000 images.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，您需要创建一个控制台应用程序，允许将各种输入传递给序列计算器。一旦用户输入了他们的参数，应用程序将开始创建1,000个图像的耗时任务。
- en: Each image in the sequence may take a few seconds to compute and create so you
    will need to provide a way to cancel the operation midway using `TaskCancellationSource`.
    If the user cancels the task, they should still be able to access the images that
    were created prior to the cancellation request. Essentially, you are allowing
    the user to try different parameters to see how this affects output images.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 序列中的每个图像可能需要几秒钟来计算和创建，因此您需要提供一个方法，使用`TaskCancellationSource`在操作中途取消操作。如果用户取消任务，他们仍然可以访问取消请求之前的图像。本质上，您允许用户尝试不同的参数，看看这对输出图像有什么影响。
- en: '![Figure 5.2: Fibonacci sequence image files ](img/B16835_05_02.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：斐波那契数列图像文件](img/B16835_05_02.jpg)'
- en: 'Figure 5.2: Fibonacci sequence image files'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：斐波那契数列图像文件
- en: 'This is an ideal example for the `Parallel` class or `async`/`await` tasks
    if you prefer. The following inputs will be needed from the user:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢`async`/`await`任务，这是一个理想的`Parallel`类示例。以下是需要从用户那里获取的输入：
- en: Input the value for `phi` (values between `1.0` and `6.0` provide ideal images).
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入`phi`的值（`1.0`到`6.0`之间的值提供理想的图像）。
- en: Input the number of images to create (the suggestion is `1,000` per cycle).
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入要创建的图像数量（建议每个周期`1,000`个）。
- en: Input the optional number of points per image (a default of `3,000` is recommended).
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入可选的每图像点数（建议默认为`3,000`）。
- en: Input the optional image size (defaults to `800` pixels).
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入可选的图像大小（默认为`800`像素）。
- en: Input the optional point size (defaults to `5`).
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入可选的点大小（默认为`5`）。
- en: Next input the optional file format (defaults to `.png` format).
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，输入可选的文件格式（默认为`.png`格式）。
- en: The console app should use a loop that prompts for the preceding parameters
    and allows the user to enter new criteria while images are created for previous criteria.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台应用程序应使用循环来提示用户输入前一个参数，并在为前一个参数创建图像的同时允许用户输入新的标准。
- en: If the user presses `Enter` whilst a previous set of images is still being created,
    then that task should be canceled.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在创建前一组图像时按下`Enter`键，则应取消该任务。
- en: Pressing `x` should close the application.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下`x`键应关闭应用程序。
- en: 'As this activity is aimed at testing your asynchronous skills, rather than
    math or image processing, you have the following classes to help with calculations
    and image creation:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此活动旨在测试您的异步技能，而不是数学或图像处理，您有以下类来帮助进行计算和图像创建：
- en: The `Fibonacci` class defined here calculates `X` and `Y` coordinates for successive
    sequence items. For each image loop, return a list of `Fibonacci` classes.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里定义的`Fibonacci`类计算连续序列项的`X`和`Y`坐标。对于每个图像循环，返回一个`Fibonacci`类的列表。
- en: 'Create the first element by calling `CreateSeed`. The remainder of the list
    should use `CreateNext`, passing in the previous item:'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`CreateSeed`创建第一个元素。列表的其余部分应使用`CreateNext`，传入前一个项：
- en: '[PRE148]'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Create a list of Fibonacci items using the following `FibonacciSequence`.`Calculate`
    method. This will be passed the number of points to be drawn and the value of
    `phi` (both as specified by the user):'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下`FibonacciSequence`.`Calculate`方法创建一个Fibonacci项的列表。这将传递要绘制的点的数量和`phi`的值（两者均由用户指定）：
- en: '[PRE150]'
  id: totrans-701
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Export the generated data to `.png` format image files using the `dotnet add
    package` command to add a reference to the `System.Drawing.Common` namespace.
    Within your project''s source folder, run this command:'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dotnet add package`命令导出生成的数据到`.png`格式图像文件，以添加对`System.Drawing.Common`命名空间的引用。在您的项目源文件夹中运行以下命令：
- en: '[PRE152]'
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'This image creation class `ImageGenerator` can be used to create each of the
    final image files:'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此图像创建类`ImageGenerator`可用于创建每个最终图像文件：
- en: '[PRE153]'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'To complete this activity, perform the following steps:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，请执行以下步骤：
- en: Create a new console app project.
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序项目。
- en: The generated images should be saved in a folder within the system's `Temp`
    folder, so use `Path.GetTempPath()` to get the `Temp` path and create a subfolder
    called `Fibonacci` using `Directory.CreateDirectory`.
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的图像应保存在系统`Temp`文件夹内的一个文件夹中，因此请使用`Path.GetTempPath()`获取`Temp`路径，并使用`Directory.CreateDirectory`创建一个名为`Fibonacci`的子文件夹。
- en: Declare a `do`-loop that repeats the following *Step 4* to *Step 7*.
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`do`循环，重复以下*步骤4*到*步骤7*。
- en: Prompt the user to enter a value for `phi` (this typically ranges from `1.0`
    to `6.00`). You will need to read the user's input as a string and use `double.TryParse`
    to attempt to convert their input into a valid double variable.
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入`phi`的值（这通常在`1.0`到`6.00`之间）。您需要将用户输入读取为字符串，并使用`double.TryParse`尝试将输入转换为有效的双精度浮点变量。
- en: Next, prompt the user to enter a value for the number of image files to create
    (`1,000` is an acceptable example value). Store the parsed input in an `int` variable
    called `imageCount`.
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，提示用户输入要创建的图像文件数量（`1,000`是一个可接受的示例值）。将解析后的输入存储在名为`imageCount`的`int`变量中。
- en: If either of the entered values is empty, this will indicate that the user pressed
    the `Enter` key alone, so break out of the `do`-loop. Ideally, `CancellationTokenSource`
    can also be defined and used to cancel any pending calculations.
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入的任一值是空的，这表明用户仅按下了`Enter`键，因此退出`do`循环。理想情况下，也可以定义并使用`CancellationTokenSource`来取消任何挂起的计算。
- en: The value of `phi` and `imageCount` should be passed to a new method called
    `GenerateImageSequences`, which returns a `Task`.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`phi`和`imageCount`的值应传递给名为`GenerateImageSequences`的新方法，该方法返回一个`Task`。'
- en: The `GenerateImageSequences` method needs to use a loop that iterates for each
    of the image counts requested. Each iteration should increment `phi`, and a constant
    value (a suggestion is `0.015`) before awaiting a `Task.Run` method that calls
    `FibonacciSequence.Calculate`, passing in `phi` and a constant for the number
    of points (`3,000` provides an acceptable example value). This will return a list
    of Fibonacci items.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GenerateImageSequences`方法需要使用一个循环，该循环为请求的每个图像计数迭代。每次迭代应增加`phi`，然后是一个常数值（建议为`0.015`），在等待调用`Task.Run`方法之前，该方法调用`FibonacciSequence.Calculate`，传入`phi`和用于点的常数值（例如`3,000`是一个可接受的示例值）。这将返回一个斐波那契项列表。'
- en: '`GenerateImageSequences` should then pass the generated Fibonacci list to the
    image creator `ImageGenerator.ExportSequence`, awaiting using a `Task.Run` call.
    An image size of `800` and a point size of `5` are recommended constants for the
    call to `ExportSequence`.'
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后`GenerateImageSequences`应将生成的斐波那契列表传递给图像创建者`ImageGenerator.ExportSequence`，使用`Task.Run`调用等待。对于`ExportSequence`的调用，建议的常数值为图像大小`800`和点大小`5`。
- en: 'Running the console app should produce the following console output:'
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序应该产生以下控制台输出：
- en: '[PRE155]'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'You will find that various image files have been generated in the Fibonacci
    folder in the system''s `Temp` folder:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现系统`Temp`文件夹中的斐波那契文件夹中生成了各种图像文件：
- en: '![Figure 5.3: Windows 10 Explorer image folder contents (a subset of images
    produced) ](img/B16835_05_03.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：Windows 10资源管理器图像文件夹内容（生成的图像子集）](img/B16835_05_03.jpg)'
- en: 'Figure 5.3: Windows 10 Explorer image folder contents (a subset of images produced)'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：Windows 10资源管理器图像文件夹内容（生成的图像子集）
- en: By completing this activity, you have seen how multiple long-running operations
    can be started and then coordinated to produce a single result, with each step
    running in isolation, allowing other operations to continue as necessary.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你看到了如何启动多个长时间运行的操作，然后协调它们以产生单个结果，每个步骤都在隔离中运行，允许其他操作按需继续。
- en: Note
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: Summary
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you considered some of the power and flexibility that concurrency
    provides. You started by passing target actions to tasks that you created and
    then looked at the static `Task` factory helper methods. By using continuation
    tasks, you saw that single tasks and collections of tasks can be coordinated to
    perform aggregate actions.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你考虑了并发提供的部分强大和灵活的功能。你首先通过将目标操作传递到你创建的任务来开始，然后查看静态的`Task`工厂辅助方法。通过使用延续任务，你看到单个任务和任务集合可以被协调以执行聚合操作。
- en: Next, you studied the `async`/`await` keywords that can help you write simpler
    and more concise code that is, hopefully, easier to maintain.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你研究了`async`/`await`关键字，这些关键字可以帮助你编写更简单、更简洁的代码，希望这样更容易维护。
- en: This chapter looked at how C# provides, with relative ease, concurrency patterns
    that make it possible to leverage the power of multicore processors. This is great
    for offloading time-consuming calculations, but it does come at a price. You saw
    how the `lock` statement can be used to safely prevent multiple threads from reading
    or writing to a value simultaneously.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了C#如何以相对简单的方式提供并发模式，这使得可以利用多核处理器的强大功能。这对于卸载耗时计算非常有用，但这也带来了一定的代价。你看到了如何使用`lock`语句来安全地防止多个线程同时读取或写入一个值。
- en: In the next chapter, you will look at how Entity Framework and SQL Server can
    be used to interact with relational data in C# applications. This chapter is about
    working with databases. If you are unfamiliar with database structure or would
    like a refresher on the basics of PostgreSQL, please refer to the bonus chapter
    available in the GitHub repository for this book.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解如何使用Entity Framework和SQL Server在C#应用程序中与关系型数据交互。本章是关于数据库操作的内容。如果你对数据库结构不熟悉或想复习PostgreSQL的基本知识，请参阅本书GitHub仓库中提供的附加章节。
