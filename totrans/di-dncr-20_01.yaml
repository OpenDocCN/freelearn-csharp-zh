- en: The SOLID Principles of Software Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计SOLID原则
- en: This book focuses on techniques related to Dependency Injection and the way
    those techniques are implemented by default and can be extended by the programmer
    in .NET Core--the first version of .NET that executes on every platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于与依赖注入相关的技术，以及这些技术在.NET Core中的默认实现方式，以及程序员如何扩展这些技术——这是.NET的第一个可以在每个平台上运行的版本。
- en: It works on Windows, macOS, and Linux distro on the desktop, and the idea can
    even be extended to the mobile world covering the Apple, Android, and Tizen (Samsung)
    operating systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它在桌面上的Windows、macOS和Linux发行版上运行，这个想法甚至可以扩展到移动世界，覆盖苹果、安卓和Tizen（三星）操作系统。
- en: This is, with no doubt, the most ambitious project from Microsoft in its search
    for a universal coverage of programming technologies and tools, and it can be
    considered a natural step after the initial **UWP** (**Universal Windows Platform**)
    project that allows building applications for any device supporting Windows, from
    IoT devices to the desktop, XBOX, or HoloLens.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是微软在寻求对编程技术和工具实现通用覆盖的最雄心勃勃的项目，并且可以被视为在最初的**UWP**（**通用Windows平台**）项目之后的自然一步，该项目允许为支持Windows的任何设备构建应用程序，从物联网设备到桌面、XBOX或HoloLens。
- en: 'So, in this chapter we''ll start with a quick review of the main architectural
    components of .NET Core and its derivative frameworks (such as ASP.NET Core),
    to be followed with the foundations on which Dependency Injection techniques are
    based, as part of the SOLID principles, stated by Robert C. Martin (*Uncle Bob*)
    in 2000\. (See Wikipedia: [https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将从.NET Core及其衍生框架（如ASP.NET Core）的主要架构组件的快速回顾开始，随后将介绍依赖注入技术的基础，这是SOLID原则的一部分，由Robert
    C. Martin（*Uncle Bob*）在2000年提出。（参见维基百科：[https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))).）
- en: 'Therefore, we''ll revise those five SOLID principles, explaining their purpose
    and advantages, together with some basic implementations of each one of them in
    the C# language using Console applications coded in .NET Core. In all we''ll see
    an explanation of each principle and its coverage:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将回顾这五个SOLID原则，解释它们的目的和优势，以及使用.NET Core编写的控制台应用程序中每个原则的基本实现。我们将看到每个原则及其覆盖范围的解释：
- en: Separation of concerns (clearly implemented in the core infrastructure of .NET
    Core and also from the initial configuration of pipelines and middleware in ASP.NET
    Core)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离（在.NET Core的核心基础设施中明确实现，并在ASP.NET Core的初始管道和中间件配置中实现）
- en: Open/Closed (already implemented in classic .NET Framework since version 3.0
    and also present here)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放/封闭原则（自.NET Framework 3.0版本以来已实现，此处也有体现）
- en: Liskov Substitution Principle (available in two ways--in a classic manner through
    the support of typecasting, and through the use of generics)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则（有两种实现方式——通过类型转换的经典方式，以及通过泛型使用）
- en: 'Interface segregation: Explanation of Interface segregation and its advantages'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口分离：解释接口分离及其优势
- en: 'Dependency Inversion: Explanation of the principle, its derivatives, and the
    concept of IoC containers'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置：解释原则、其衍生品以及IoC容器概念
- en: In the beginning
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开始时
- en: The evolution of programming techniques is, somehow, related to language evolution.
    Once the initial (and, in some ways, chaotic) times had passed, the universality
    of computing became clear, and the need for good patterns and languages capable
    of affording large projects turned out to be evident.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编程技术的演变，某种程度上，与语言演变有关。一旦最初的（在某些方面，是混乱的）时期过去，计算的通用性变得清晰，对良好的模式和能够承担大型项目的语言的需求变得明显。
- en: The 70s marked the start of the adoption of other paradigms, such as procedural
    programming, and later on, **object-oriented programming** (**OOP**), proposed
    by Ole-Johan Dahl and Kristen Nygaard with the Simula language, when they both
    worked at the Norwegian Computing Center. They were given the Turing Award for
    these achievements, among other recognitions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪70年代标志着采用其他范式的开始，例如过程式编程，后来，由Ole-Johan Dahl和Kristen Nygaard在挪威计算中心工作时提出的**面向对象编程**（**OOP**），通过Simula语言，他们两人都提出了这一概念。他们因这些成就获得了图灵奖以及其他认可。
- en: A few years later (around 1979), Bjarne Stroustrup created C with Classes, the
    prototype of what C++ is today because he found valuable aspects in the Simula
    language, but he thought that it was too slow for practical purposes, being the
    first OOP language that was universally adopted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后（大约在 1979 年），比约恩·斯特劳斯特鲁普在 Simula 语言中发现了一些有价值的方面，因此创建了具有类的 C 语言，这是今天 C++ 的原型，因为他认为它对于实际用途来说太慢了，这是第一个被普遍采用的面向对象语言。
- en: C++ originally had imperative features and object-oriented and generic ones,
    while also providing the ability to program for low-level memory manipulation.
    While it's true that it has become a de facto standard for building critical systems
    and applications, for many people it was not adequate for **LOB** (**Line of Business**)
    applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 最初具有命令式特性、面向对象和泛型特性，同时还能提供用于低级内存操作编程的能力。虽然它确实已经成为构建关键系统和应用的既定标准，但对于许多人来说，它并不足以满足
    **LOB** (**业务线**) 应用程序的需求。
- en: Years later, Java and the .NET platforms proposed a much easier and affordable
    solution for many programmers while still moving within the ordered space that
    object-oriented programming languages promote.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，Java 和 .NET 平台为许多程序员提供了一个更简单、更经济的解决方案，同时仍然在面向对象编程语言所倡导的有序空间内发展。
- en: So, OOP was adopted, and so far no other important programming paradigm has
    replaced these ideas. Certainly, there are other approaches, such as functional
    programming, but even the most significant representative of this tendency, JavaScript,
    is becoming more object-oriented in the latest versions (ECMAScript 2015).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，面向对象编程（OOP）被采纳，到目前为止，没有其他重要的编程范式取代这些思想。当然，还有其他方法，比如函数式编程，但即使是这一趋势的最显著代表 JavaScript，在最新版本（ECMAScript
    2015）中也变得更加面向对象。
- en: .NET and .NET Core
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 和 .NET Core
- en: .NET has been revamped lately in order to achieve the goal that Microsoft has
    pursued since Satya Nadella arrived in the company--"<q>*Any Developer, Any App,
    Any Platforms.*</q>".
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 最近经过重新设计，以实现自萨蒂亚·纳德拉加入公司以来微软一直追求的目标--"<q>*任何开发者，任何应用，任何平台。</q>"。
- en: 'According to Principal Manager Scott Hunter, the company now presents a set
    of unified application models that can be summarized in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据首席经理斯科特·亨特的说法，公司现在提供了一套统一的应用程序模型，以下截图可以概括：
- en: '![](img/93628383-00e3-490b-9444-694f2dc6f79d.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93628383-00e3-490b-9444-694f2dc6f79d.png)'
- en: 'Source: [http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx](http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx](http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx)
- en: As you see, the situation now is quite promising for a .NET Developer. The screenshot
    shows a **Common Infrastructure** (compilers, languages, and runtime components),
    powered by Roselyn services and other features. All those integrate with the IDEs
    that support these projects, now including Visual Studio for Mac.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，目前对于 .NET 开发者来说情况非常乐观。截图显示了一个 **通用基础设施**（编译器、语言和运行时组件），由 Roselyn 服务和其他功能提供支持。所有这些都与支持这些项目的
    IDE 集成，现在包括 Visual Studio for Mac。
- en: On top of that lies a **.NET Standard Library**, which has points in common
    that allow us to share code along the three different frameworks--the classic
    **.NET Framework** (in version 4.6.2, at the time of writing this), **.NET Core**
    (now in version 2.0), and **Xamarin**, which allows building applications for
    any type of mobile target--Android, iOS, Windows Phone, and Tizen (Samsung).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在其之上是 **.NET 标准库**，它具有共同点，使我们能够在三个不同的框架之间共享代码--经典的 **.NET Framework**（在撰写本文时为
    4.6.2 版），**.NET Core**（现在为 2.0 版），以及 **Xamarin**，它允许为任何类型的移动目标--Android、iOS、Windows
    Phone 和 Tizen（三星）--构建应用程序。
- en: About .NET Core
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 .NET Core
- en: .NET Core is the new version of .NET presented officially in the summer of 2016,
    and updated to version 1.1 in the November Connect() event the same year. It's
    defined as a *cross-platform, open source, cloud-ready and modular .NET platform
    for creating modern web apps, microservices, libraries, and console applications
    that run everywhere (Windows, Linux, and MacOS).*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 是 .NET 的新版本，于 2016 年夏季正式推出，并在同年 11 月的 Connect() 事件中更新到 1.1 版本。它被定义为
    *跨平台、开源、云就绪且模块化的 .NET 平台，用于创建可在任何地方运行（Windows、Linux 和 MacOS）的现代 Web 应用、微服务、库和控制台应用程序*。
- en: It can be deployed along with the application itself, minimizing installation
    issues.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以与应用程序本身一起部署，从而最小化安装问题。
- en: Prior to its publication, Microsoft decided to restart the numbering, reinforcing
    the idea that this is a totally new concept with respect to classical versions,
    as a better way to avoid ambiguities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布之前，微软决定重新开始编号，强化了这是一个与经典版本完全不同的新概念的想法，作为避免歧义的一种更好的方式。
- en: MSDN architect Cesar de la Torre defines in his blog very precisely the goals
    and structure of .NET Core--unlike the traditional .NET Framework, which is a
    single package installation, system-wide, and Windows-only runtime environment,
    .NET Core is about decoupling .NET from Windows, allowing it to run in non-Windows
    environments without having to install a giant 400 Mb set of binaries (versus
    just the footprint of the components you need from .NET Core) plus the ability
    to deploy applications accompanying the framework itself, supporting side-by-side
    execution of different versions of the framework.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN 架构师塞萨尔·德拉·托雷在他的博客中非常精确地定义了 .NET Core 的目标和结构——与传统的 .NET 框架不同，.NET 框架是一个全局安装的单个软件包，仅限于
    Windows 的运行时环境，.NET Core 是将 .NET 从 Windows 解耦，允许它在非 Windows 环境中运行，无需安装一个巨大的 400
    Mb 的二进制文件集（与仅从 .NET Core 需要的组件的足迹相比），以及能够部署与框架本身一起的应用程序，支持框架不同版本的并行执行。
- en: A very interesting part of its architecture and deployment infrastructure, as
    mentioned in the same source, is that instead of being part of the operating system,
    .NET Core is composed of NuGet packages and is either compiled directly into an
    application or put into a folder inside the application. This means applications
    can carry .NET Core within and thus are completely side by side on the machine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如同一来源中提到的，其架构和部署基础设施的一个非常有趣的部分是，.NET Core 不是操作系统的一部分，而是由 NuGet 软件包组成，可以直接编译到应用程序中，或者放入应用程序内部的文件夹中。这意味着应用程序可以携带
    .NET Core，因此可以在机器上完全并行运行。
- en: I, personally, think this is absolutely crucial for the project to be successful.
    No side-effects, no component installation in the target machine, and no dependencies.
    (As you'll see throughout this book this avoiding of dependencies is totally foundational
    when building software that follows good practices.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人认为这对项目的成功至关重要。没有副作用，目标机器上无需安装组件，也没有依赖。（正如你将在本书中看到的，避免依赖性在构建遵循良好实践的软件时是基础性的。）
- en: 'NET Core 2.0 - Supported OS Versions Proposal:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: NET Core 2.0 - 支持的操作系统版本建议：
- en: '| **OS** | **Version** | **Architectures** | **Notes** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **版本** | **架构** | **备注** |'
- en: '| Windows Client | 7 SP1+ | x64, x86 |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Windows 客户端 | 7 SP1+ | x64, x86 |  |'
- en: '| Windows Server | 2008 R2 SP1+ | x64, x86 | Configurations: Full, Server Core,
    Nano |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Windows Server | 2008 R2 SP1+ | x64, x86 | 配置：完整版、Server Core、Nano |'
- en: '| Windows IoT | 10+ | [C] arm32 | IoT Core - see [Raspberry Pi instructions](https://github.com/dotnet/core/blob/master/samples/RaspberryPiInstructions.md)
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Windows IoT | 10+ | [C] arm32 | IoT Core - 请参阅[Raspberry Pi 指令](https://github.com/dotnet/core/blob/master/samples/RaspberryPiInstructions.md)
    |'
- en: '| Red Hat Enterprise Linux | 7.3+ | x64 | This includes Centos and Oracle Linux
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 红帽企业 Linux | 7.3+ | x64 | 这包括 CentOS 和 Oracle Linux |'
- en: '| Fedora | 25+ | x64 |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Fedora | 25+ | x64 |  |'
- en: '| Debian | 8.7+ | x64 | [Debian 9 (Stretch) workaround](https://github.com/dotnet/corefx/issues/8951#issuecomment-299927277)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Debian | 8.7+ | x64 | [Debian 9 (Stretch) 工作区](https://github.com/dotnet/corefx/issues/8951#issuecomment-299927277)
    |'
- en: '| Ubuntu | 14.04+ | x64, [C] arm32 | This includes Linux Mint 17 for x64 For
    arm32, see [Raspberry Pi instructions](https://github.com/dotnet/core/blob/master/samples/RaspberryPiInstructions.md)
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu | 14.04+ | x64, [C] arm32 | 这包括 x64 的 Linux Mint 17。对于 arm32，请参阅[Raspberry
    Pi 指令](https://github.com/dotnet/core/blob/master/samples/RaspberryPiInstructions.md)
    |'
- en: '| openSUSE | 42.2+ | x64 |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| openSUSE | 42.2+ | x64 |  |'
- en: '| Tizen | 4+ | [S] arm32 | [Tizen .NET Developer Preview](https://developer.tizen.org/development/tizen-.net-preview/introduction)
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Tizen | 4+ | [S] arm32 | [Tizen .NET 开发者预览](https://developer.tizen.org/development/tizen-.net-preview/introduction)
    |'
- en: '| Mac OS X | 10.12+ | x64 |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Mac OS X | 10.12+ | x64 |  |'
- en: '| **In Progress OS''s** |  |  |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **进行中的操作系统** |  |  |  |'
- en: '| Arch Linux | [C] TBD | TBD | Blocked on [missing OpenSSL 1.0 package](https://github.com/dotnet/corefx/issues/9855#issuecomment-298982251)
    in distro. Arch Linux community efforts tracked [here](https://bbs.archlinux.org/viewtopic.php?pid=1708479).
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Arch Linux | [C] 待定 | 待定 | 由于在发行版中缺少[OpenSSL 1.0 软件包](https://github.com/dotnet/corefx/issues/9855#issuecomment-298982251)而受阻。Arch
    Linux 社区努力情况可追踪[此处](https://bbs.archlinux.org/viewtopic.php?pid=1708479)。|'
- en: '| FreeBSD & NetBSD | [C] TBD | TBD | Tracking [main issue](https://github.com/dotnet/coreclr/issues/6115)
    and [label](https://github.com/dotnet/coreclr/labels/os-freebsd). NetBSD packages
    for [.NET Core 1.0.0](https://github.com/dotnet/coreclr/issues/6115#issuecomment-233151220)
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| FreeBSD & NetBSD | [C] TBD | TBD | 跟踪 [主要问题](https://github.com/dotnet/coreclr/issues/6115)
    和 [标签](https://github.com/dotnet/coreclr/labels/os-freebsd). NetBSD 的 [.NET Core
    1.0.0](https://github.com/dotnet/coreclr/issues/6115#issuecomment-233151220) 软件包'
- en: 'As for the types of programmable project available from any of the above-mentioned
    IDE''s, .NET Core can support its own application model, and also the Universal
    Windows Platform Model, optionally compiled to .NET Native (see the following
    screenshot):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上述任何 IDE 可用的可编程项目类型，.NET Core 可以支持其自己的应用程序模型，也可以支持通用 Windows 平台模型，并且可以选择编译为
    .NET Native（见以下截图）：
- en: '![](img/ee337a92-791f-4607-8b0c-290aee531b55.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee337a92-791f-4607-8b0c-290aee531b55.png)'
- en: 'Source: [http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx](http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx](http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx)
- en: 'We end this introduction to .NET Core with the summary from the same page mentioned
    previously in relation to this framework:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以之前提到的同一页面上关于此框架的总结来结束对 .NET Core 的介绍：
- en: '**Cross-platform**: .NET Core currently supports three main operating systems--Linux,
    Windows and OS X. There are other OS ports in progress such as FreeBSD, NetBSD,
    and Arch Linux. .NET Core libraries can run unmodified across supported OSes.
    The apps must be re-compiled per environment, given that apps use a native host.
    Users select the .NET Core supported environment that works best for their situation.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：.NET Core 目前支持三个主要操作系统——Linux、Windows 和 OS X。还有其他操作系统移植正在进行中，例如 FreeBSD、NetBSD
    和 Arch Linux。.NET Core 库可以在支持的操作系统上无修改地运行。由于应用程序使用本地宿主，因此必须针对每个环境重新编译应用程序。用户选择最适合其情况的
    .NET Core 支持的环境。'
- en: '**Open Source**: .NET Core is available on GitHub at [https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.0-preview1.md](https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.0-preview1.md),
    licensed with the MIT and Apache 2 licenses (licensing is per component). It also
    makes use of a significant set of open source industry dependencies (see release
    notes). Being OSS is critical for having a thriving community plus a must for
    many organizations where OSS is part of their development strategy.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：.NET Core 可在 GitHub 上找到，地址为 [https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.0-preview1.md](https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.0-preview1.md)，采用
    MIT 和 Apache 2 许可证（许可按组件划分）。它还使用了一组重要的开源行业依赖项（见发布说明）。作为开源软件对于拥有繁荣的社区以及对于许多将开源软件作为其开发策略一部分的组织来说至关重要。'
- en: '**Natural acquisition**: .NET Core is distributed as a set of NuGet packages
    that developers can pick and choose from. The runtime and base framework can be
    acquired from NuGet and OS-specific package managers, such as APT, Homebrew, and
    Yum. Docker images are available on docker hub. The higher-level framework libraries
    and the larger .NET library ecosystem are available on NuGet.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自然获取**：.NET Core 以一系列 NuGet 软件包的形式分发，开发者可以从中选择所需的内容。运行时和基础框架可以从 NuGet 和特定于操作系统的软件包管理器（如
    APT、Homebrew 和 Yum）获取。Docker 镜像可在 Docker Hub 上找到。高级框架库和更大的 .NET 库生态系统可在 NuGet
    上找到。'
- en: '**Modular framework**: .NET Core is built with a modular design, enabling applications
    to include only the .NET Core libraries and dependencies that are needed. Each
    application makes its own .NET Core versioning choices, avoiding conflicts with
    shared components. This approach aligns with the trend of developing software
    using container technologies such as Docker.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化框架**：.NET Core 采用模块化设计，使应用程序仅包含所需的 .NET Core 库和依赖项。每个应用程序都做出自己的 .NET Core
    版本选择，避免与共享组件冲突。这种方法与使用 Docker 等容器技术开发软件的趋势相一致。'
- en: '**Smaller deployment footprint**: Even when in v1.0/1.1 the size of .NET Core
    is a lot smaller than .NET Framework; note that the overall size of .NET Core
    doesn''t set out to be smaller than the .NET Framework over time, but since it
    is pay-for-play, most applications that utilize only parts of CoreFX will have
    a smaller deployment footprint.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的部署占用空间**：即使在 v1.0/1.1 版本中，.NET Core 的大小也比 .NET Framework 小得多；请注意，.NET
    Core 的整体大小并不旨在随着时间的推移而小于 .NET Framework，但由于它是按需付费的，因此大多数仅利用 CoreFX 部分的应用程序将具有更小的部署占用空间。'
- en: '**Fast release cycles of .NET Core**: .NET Core''s modular architecture plus
    its OSS nature provide more modern and much faster release cycles (even per NuGet
    package) compared to slow release cycles from larger monolithic frameworks. This
    approach allows a much faster innovation pace from Microsoft and the OSS .NET
    community than what was traditionally possible with the .NET Framework.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core的快速发布周期**：.NET Core的模块化架构加上其开源特性提供了比大型单体框架慢速发布周期（甚至每个NuGet包）更现代、更快的发布周期。这种方法使得微软和开源.NET社区能够以比传统使用.NET
    Framework时更快的速度进行创新。'
- en: Thus, there are multiple application model stacks built on top of the .NET Core
    that allow developers to build applications ranging from console applications,
    across UWP Windows 10 apps (PC, tablet, and phones) to scalable web applications
    and microservices with ASP.NET Core.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在.NET Core之上构建了多个应用模型堆栈，允许开发者构建从控制台应用程序，跨越UWP Windows 10应用程序（PC、平板电脑和手机）到可扩展的Web应用程序和ASP.NET
    Core微服务的应用程序。
- en: ASP.NET Core
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core
- en: ASP.NET applications that use .NET Core promote a model based on the previous
    MVC model, although built from scratch, targeted at cross-platform execution,
    the elimination of some unnecessary features, and the unification of the previous
    MVC with the web API variant; so, they work with the same controller type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET Core的ASP.NET应用程序推广基于先前MVC模型的模式，尽管是从头开始构建的，旨在跨平台执行，消除了某些不必要的功能，并将先前的MVC与Web
    API变体统一；因此，它们使用相同的控制器类型。
- en: Besides this, the code doesn't need to be compiled prior to execution while
    you're developing. The BrowserSync technology allows you change the code on-the-fly
    and the Roselyn services take care of updating; so, you just have to refresh your
    page to see the changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在开发过程中，代码不需要在执行前进行编译。BrowserSync技术允许你即时更改代码，而Roselyn服务负责更新；因此，你只需刷新页面即可看到更改。
- en: ASP.NET Core also uses a new hosting model, completely decoupled from the web
    server environment that hosts the application. It supports IIS versions and also
    self-hosting contexts via Kestrel (cross-platform, extremely optimized, built
    on top of LibUv, the same component that Node.js uses) and WebListener HTTP (Windows-only)
    servers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core还使用了一种新的托管模型，完全与托管应用程序的Web服务器环境解耦。它支持IIS版本，也支持通过Kestrel（跨平台、极端优化、基于LibUv，这是Node.js使用的相同组件）和WebListener
    HTTP（仅限Windows）服务器进行自托管上下文。
- en: As part of its architecture, it proposes a new generation of middleware that
    is asynchronous, very modular, lightweight, and totally configurable, where we
    define things such as routing, authentication, static files, diagnostics, error
    handling, session, CORS, localization; and they can even be user-defined.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其架构的一部分，它提出了一代新的中间件，这些中间件是异步的、非常模块化的、轻量级的，并且完全可配置的，其中我们定义了诸如路由、认证、静态文件、诊断、错误处理、会话、CORS、本地化等；甚至可以由用户自定义。
- en: 'Notice also that ASP.NET Core can run as well in the classic .NET Framework
    with access to the functionality exposed by those libraries. The following screenshot
    shows the schema:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，ASP.NET Core同样可以在经典.NET Framework中运行，并访问那些库暴露的功能。以下截图显示了架构：
- en: '![](img/991fdcd2-0907-42ae-a698-432ddeae6b14.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/991fdcd2-0907-42ae-a698-432ddeae6b14.png)'
- en: ASP.NET Core joins many things that were separate in previous versions. Thus,
    there are no distinctions between MVC and Web API and, if you target .NET Core
    or if you prefer to target any of the other version of .NET, the architectural
    model can be MVC using this rebuilt architecture.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core将许多在先前版本中分离的事物结合在一起。因此，MVC和Web API之间没有区别，如果你针对.NET Core或者如果你更喜欢针对.NET的任何其他版本，可以使用这个重构的架构模型来构建MVC。
- en: In addition, a new built-in IoC container for dependency injection is responsible
    for bootstrapping the system, together with a new configuration protocol, which
    we'll see in practice in the following chapters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个新的内置IoC容器负责依赖注入的启动，以及一个新的配置协议，我们将在接下来的章节中实际看到。
- en: About the IDE used in this book
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于本书中使用的IDE
- en: Since this book deals with .NET Core and ASP.NET Core and their built-in capabilities
    covering SOLID principles in general and DI in particular, we're using the latest
    available version of Visual Studio (Visual Studio 2017 Enterprise), which includes
    full support for these platforms, together with a bunch of convenient extensions
    and templates.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书涉及 .NET Core 和 ASP.NET Core 以及它们内置的功能，涵盖了 SOLID 原则以及特定的依赖注入（DI），我们使用最新可用的
    Visual Studio 版本（Visual Studio 2017 Enterprise），它包括对这些平台的全支持，以及一系列方便的扩展和模板。
- en: You can also use Visual Studio 2017 Community Edition, which is free, or any
    higher version with practically no changes, as far as the codes samples are concerned.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用免费的 Visual Studio 2017 Community Edition，或者任何更高版本，只要代码示例没有实质性的变化。
- en: 'If you''re a Mac user, you can also use Visual Studio for Mac ([https://www.visualstudio.com/vs/visual-studio-mac/](https://www.visualstudio.com/vs/visual-studio-mac/)),
    available since November 2016, and, if you prefer a light, full-fledged, and free
    IDE for any platform (Linux, Mac or Windows), you can opt for Visual Studio Code
    ([https://code.visualstudio.com/download](https://code.visualstudio.com/download)),
    which also has excellent editing and debugging capabilities. All of them have
    full support for .NET Core/ASP.NET Core as well (see the following screenshot):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 Mac 用户，你也可以使用自 2016 年 11 月以来可用的 Visual Studio for Mac ([https://www.visualstudio.com/vs/visual-studio-mac/](https://www.visualstudio.com/vs/visual-studio-mac/))，如果你更喜欢任何平台（Linux、Mac
    或 Windows）上的轻量级、全功能的免费 IDE，可以选择 Visual Studio Code ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))，它也具有出色的编辑和调试功能。所有这些都对
    .NET Core/ASP.NET Core 提供了全面支持（见以下截图）：
- en: '![](img/4b6e0c2e-656d-4746-97c5-65f130e39d09.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b6e0c2e-656d-4746-97c5-65f130e39d09.png)'
- en: Throughout this and other chapters, I'll use indiscriminately .NET Core or ASP.NET
    Core for the demos, depending on whether we need a more complex user interface
    or not. Notice also that .NET Core (for the time being) does not offer any visual
    UI beyond Console applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节和其他章节中，我将根据是否需要更复杂的用户界面，无差别地使用 .NET Core 或 ASP.NET Core 进行演示。注意，目前 .NET
    Core 不提供任何超出控制台应用程序的视觉 UI。
- en: 'Actually, the currently available templates shown by default when we select
    *New Project* and click on .NET Core are the ones you can see in the following
    screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当我们选择 *新建项目* 并点击 .NET Core 时，默认显示的当前可用的模板就是你在以下截图中所看到的：
- en: '![](img/a6c16fe2-d1f2-4828-946f-372be1fca13d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6c16fe2-d1f2-4828-946f-372be1fca13d.png)'
- en: 'As you see, the choices are basically threefold (besides testing): Console
    apps, Class libraries, and ASP.NET Core Web apps, based on NET Core. In the three
    cases, the resulting apps run on any platform.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，选择基本上有三类（除了测试）：控制台应用程序、类库和基于 .NET Core 的 ASP.NET Core 网络应用程序。在这三种情况下，生成的应用程序可以在任何平台上运行。
- en: Other foundational changes in .NET Core
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 的其他基础变更
- en: It's important to keep in mind that, with NET Core, you no longer depend on
    .NET Framework libraries (the BCL libraries), either installed by the OS or manually
    and located in the GAC (Global Assembly Cache).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，在 .NET Core 中，你不再依赖于 .NET Framework 库（BCL 库），无论是操作系统安装的还是手动安装在 GAC（全局程序集缓存）中的。
- en: All libraries are available via NuGet and downloaded accordingly. But, if you
    have tried .NET Core prior to Visual Studio 2017, you might miss the file `project.json`
    in which all dependencies were referenced.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有库都可通过 NuGet 获取并相应下载。但是，如果你在 Visual Studio 2017 之前尝试过 .NET Core，你可能会错过包含所有依赖项的
    `project.json` 文件。
- en: 'The official documentation states that when using Visual Studio 2017:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档指出，当使用 Visual Studio 2017 时：
- en: MSBuild supports .NET Core projects, using a simplified `csproj` project format
    that makes it easier to be edited by hand, without the need for unloading the
    project
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSBuild 支持 .NET Core 项目，使用简化的 `csproj` 项目格式，这使得手动编辑更加容易，无需卸载项目
- en: There is support for file wildcards in the project file, enabling folder-based
    projects that don't require individual files to be included
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件支持文件通配符，使得基于文件夹的项目不需要包含单个文件
- en: NuGet package references are now part of the `csproj` format, consolidating
    all project references in one file
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuGet 包引用现在是 `csproj` 格式的一部分，将所有项目引用合并到一个文件中
- en: 'So, if you try a new .NET Core project with this tool, the project''s dependencies
    are now referenced in the `csproj` file (in XML format), as you can see when opening
    it in any text editor:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你尝试使用此工具创建新的 .NET Core 项目，项目的依赖现在已在 `csproj` 文件（XML 格式）中引用，正如你在任何文本编辑器中打开它时所见：
- en: '![](img/2ef002b8-cf59-47ae-8be3-ea6dcce235c9.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ef002b8-cf59-47ae-8be3-ea6dcce235c9.png)'
- en: In parallel, Visual Studio reads that file, creates a `Dependencies` entry in
    the Solution Explorer, and starts looking for that information (either in the
    PC's cache or in NuGet).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Visual Studio读取该文件，在解决方案资源管理器中创建一个`Dependencies`条目，并开始寻找该信息（在PC的缓存中或在NuGet中）。
- en: 'Note also that they''re not real, classic DLLs, but fragments of code that
    are assembled all together at compile time to minimize size and launch time. If
    you take a look at that entry you can see the Dependencies'' dependencies, and
    so on:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它们不是真正的、经典的DLL，而是在编译时组装在一起的代码片段，以最小化大小和启动时间。如果你查看那个条目，你可以看到依赖项的依赖项，等等：
- en: '![](img/551b8bc4-174e-43f4-900c-1288d9d309f5.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/551b8bc4-174e-43f4-900c-1288d9d309f5.png)'
- en: Another critical point to highlight relates to the deliverables produced after
    the compiling process. If you open the demo included as ConsoleApp1 (or create
    a basic one of your own), and just compile it, you'll see that the bin directory
    does not contain any executable file. You'll see a DLL with that name instead
    (ConsoleApp1.dll).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要强调的关键点与编译过程之后产生的可交付成果有关。如果你打开包含的ConsoleApp1（或创建你自己的基本版本），并仅编译它，你会看到bin目录中不包含任何可执行文件。你会看到一个名为该名称的DLL文件（ConsoleApp1.dll）。
- en: 'When you launch the application (after adding a `Console.Read()` sentence to
    stop execution), you''ll see that the executable is, indeed, `dotnet.exe`. And
    the same is true when you open the Diagnostics Tool and take a snapshot of the
    executable to see what is in place in that moment. The following screenshot shows
    the situation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动应用程序（在添加`Console.Read()`语句以停止执行之后），你会发现可执行文件确实是`dotnet.exe`。同样，当你打开诊断工具并捕获可执行文件的快照以查看那一刻的情况时也是如此。以下截图显示了这种情况：
- en: '![](img/419d5222-7299-47be-9774-fd60507cf1d4.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/419d5222-7299-47be-9774-fd60507cf1d4.png)'
- en: The reason for this is directly related to the complexity of this model. The
    application is thought to execute on distinct platforms. The default option allows
    the deployment architecture to determine the best way to configure the JIT compilers
    depending on the target. This is why the execution is undertaken by the dotnet
    runtime (named dotnet.exe).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接与该模型复杂性相关。该应用程序被认为将在不同的平台上执行。默认选项允许部署架构根据目标确定配置JIT编译器的最佳方式。这就是为什么执行由dotnet运行时（命名为dotnet.exe）承担。
- en: 'From the point of view of deployment, in .NET Core, two types of application
    are defined: portable and self-contained.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从部署的角度来看，在.NET Core中定义了两种应用程序类型：可移植和自包含。
- en: In .NET Core, portable applications are the default. Of course, that means that
    (as developers) we can be sure about their portability in distinct .NET core installations.
    However, a standalone app does not depend on any previous installation to run.
    That is to say, it holds within itself all the necessary components and dependencies,
    including the runtime packaged with the application. Certainly, that builds a
    larger app, but it also makes the application capable of executing on any .NET
    Core platform whether you have .NET Core installed in the target or not.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core中，可移植应用程序是默认的。当然，这意味着（作为开发者）我们可以确信它们在不同.NET Core安装中的可移植性。然而，独立应用程序不依赖于任何之前的安装来运行。也就是说，它包含所有必要的组件和依赖项，包括与应用程序打包的运行时。当然，这会构建一个更大的应用程序，但同时也使应用程序能够在任何.NET
    Core平台上执行，无论目标是否安装了.NET Core。
- en: For the main purposes of this book, it doesn't matter which runtime mode we
    choose. Anyhow, this brief introduction can give you an idea of how the new framework
    behaves and is managed inside Visual Studio 2017.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的主要目的来说，我们选择哪种运行时模式并不重要。无论如何，这个简短的介绍可以给你一个关于新框架如何在Visual Studio 2017内部行为和管理的想法。
- en: And, remember, anything I do using Visual Studio 2017, you can also do with
    Visual Studio Code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，记住，我使用Visual Studio 2017所做的任何事情，你都可以使用Visual Studio Code来做。
- en: The SOLID principles
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: Some programming guidelines have a comprehensive, general-purpose intention,
    while others are mainly designed to fix certain specific problems. Therefore,
    before we focus on specific problems, it's important to review those features
    that can be applied in different scenarios and solutions. I mean those principles
    that you should consider beyond the type of solution or specific platform to program
    for.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程指南具有全面、通用的目的，而另一些则主要是为了解决某些特定问题。因此，在我们专注于特定问题之前，回顾那些可以在不同场景和解决方案中应用的特征是很重要的。我的意思是那些你应考虑的原则，而不仅仅是针对解决方案类型或特定平台进行编程。
- en: This is where the SOLID principles (and other related problems) come into play.
    In 2001, Robert Martin published a foundational article on the subject ([http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)),
    in which he enumerated a set of principles and guidelines that, in his own words,
    focus very tightly on dependency management, its potential problems, and how to
    avoid them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是SOLID原则（以及其他相关问题）发挥作用的地方。在2001年，罗伯特·马丁发表了一篇关于该主题的基础性文章([http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod))，在其中他列举了一套原则和指南，用他自己的话说，这些原则非常紧密地关注依赖管理、其潜在问题以及如何避免这些问题。
- en: To explain this further, in his words, *poor dependency management leads to
    code that is hard to change, fragile, and non-reusable*. So, this principle is
    directly related with two of the OOP mantras--reusability, and maintainability
    (the capacity to change as the project grows, one of the main goals of inheritance).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释这一点，用他的话说，*糟糕的依赖管理会导致难以更改、脆弱且不可重用的代码*。因此，这个原则与两个面向对象的原则直接相关——可重用性和可维护性（随着项目的发展而改变的能力，继承的主要目标之一）。
- en: 'Overall, Martin stated his 11 commandments to consider, but they can be divided
    into three areas:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，马丁提出了11条应考虑的戒律，但它们可以分为三个领域：
- en: The five SOLID principles, which deal with class design
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理类设计的五个SOLID原则
- en: The other six principles, mainly focused on packages--three of them are about
    package cohesion, and the other three explain the dangers of package coupling
    and how to evaluate a package structure
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他六个原则主要关注包——其中三个是关于包的凝聚性，另外三个解释了包耦合的危险以及如何评估包结构
- en: We're going to start with the SOLID principles, which by extension not only
    affect the class design, but also other aspects of software architecture.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从SOLID原则开始，这些原则不仅影响类设计，还影响软件架构的其他方面。
- en: The application of these ideas has, for example, been decisive in important
    modifications made to the HTML5 standard. Concretely, the application of the **SRP**
    (**Single Responsibility principle**) only highlighted the need to totally separate
    presentation (CSS) from content (HTML) and the subsequent deprecation of some
    tags (`<cite>`, `<small>`, `<font>`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法的应用，例如，在HTML5标准的重大修改中起到了决定性作用。具体来说，**SRP**（单一职责原则）的应用仅强调了完全将表示（CSS）与内容（HTML）分离的需要，以及随后一些标签（`<cite>`、`<small>`、`<font>`）的弃用。
- en: This applies to other popular frameworks as well, such as AngularJS (and even
    more in Angular 2), both designed not only with the Single Responsibility principle
    in mind but also based on the **Dependency Inversion** principle (the **D** in
    SOLID).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于其他流行的框架，例如AngularJS（在Angular 2中更是如此），这两个框架不仅考虑了单一职责原则，而且基于**依赖倒置**原则（SOLID中的**D**）。
- en: 'The following diagram schematizes the five principles'' initials and correspondences:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概述了五个原则的首字母及其对应关系：
- en: '![](img/433e9b9f-6c4e-4c2c-9bd5-f5c088ae6f4d.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/433e9b9f-6c4e-4c2c-9bd5-f5c088ae6f4d.png)'
- en: 'The explanation of every letter in the acronym as expressed in Wikipedia is
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科中关于该缩写每个字母的解释如下：
- en: '**S - Single Responsibility Principle**: A class should have only a single
    responsibility (that is, only one potential change in the software''s specification
    should be able to affect the specification of the class). Martin states that this
    principle is based on the principle of cohesion, previously defined by Tom de
    Marco in a book named *Structured Analysis and Systems Specification* and by Meilir
    Page-Jones in his work *The Practical Guide to Structured Systems Design*.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S - 单一职责原则**：一个类应该只有一个职责（也就是说，只有软件规范的一个潜在变化应该能够影响类的规范）。马丁指出，这个原则基于凝聚性原则，该原则由汤姆·德马尔科在其名为《结构化分析和系统规范》的书中以及梅利尔·佩奇-琼斯在其著作《结构化系统设计实用指南》中定义。'
- en: '**O - Open/Closed Principle**: Software entities should be open for extension,
    but closed for modification. Bertrand Meyer was the first to propose this principle.
    Martin puts this in another way at [http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod),
    saying that **You should be able to extend a class''s behavior, without modifying
    it.**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O - 开放/封闭原则**：软件实体应该对扩展开放，但对修改封闭。伯特兰·迈耶是第一个提出这一原则的人。马丁在[http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)中以另一种方式表达了这个观点，说**你应该能够扩展类的行为，而不需要修改它**。'
- en: '**L - Liskov Substitution principle**: Objects in a program should be replaceable
    with instances of their subtypes without altering the correctness of that program.
    Barbara Liskov first stated this, and Martin rephrases the principle in this manner--*Derived
    classes must be substitutable for their base classes*.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L - Liskov 替换原则**：程序中的对象应该可以用其子类型实例替换，而不会改变该程序的正确性。芭芭拉·利斯科夫首先提出了这一观点，马丁以这种方式重新表述了原则--*派生类必须可替换为其基类*。'
- en: '**I - Interface Segregation principle**: *Many client-specific interfaces are
    better than one general-purpose interface*. Robert C. Martin was the first to
    use and formulate this principle, which he rewords in the aforementioned article
    as--*Make fine grained interfaces that are client specific.*'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I - 接口隔离原则**：*许多针对特定客户端的接口比一个通用接口更好*。罗伯特·C·马丁是第一个使用和制定这一原则的人，他在上述文章中将它重新表述为--*创建细粒度且针对特定客户端的接口*。'
- en: '**D - Dependency inversion principle**: *We should ''Depend on Abstractions''.
    Do not depend upon concretions*. This too is an idea developed by Robert C. Martin.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D - 依赖倒置原则**：*我们应该''依赖抽象''。不要依赖于具体实现*。这也是罗伯特·C·马丁提出的一个想法。'
- en: The Single Responsibility Principle (SRP)
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: The **Single Responsibility Principle** (**SRP**), focuses on the fact that
    there should never be more than one reason for a class to change. In this context,
    responsibility is defined as a reason for a change. If, under any circumstances,
    more than one reason comes up to change the class, then the class' responsibilities
    are multiple and should be redefined.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）关注的是，一个类不应该有超过一个改变的理由。在这种情况下，职责被定义为改变的理由。如果在任何情况下，出现多个理由来改变类，那么类的职责是多个的，应该被重新定义。'
- en: 'This is, indeed, one of the most difficult principles to apply properly because
    as Martin says, *conjoining responsibilities is something that we do naturally*.
    In his book, *Agile Principles, Patterns, and Practices in C#*, Martin proposes
    a canonical example to show the differences, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是最难正确应用的原则之一，因为正如马丁所说，*合并职责是我们自然而然做的事情*。在他的书《敏捷原则、模式和C#实践》中，马丁提出了一个典型的例子来展示差异，如下所示：
- en: '[PRE0]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Given the previous interface, any class implementing it has two responsibilities:
    connection management and the communication itself. Such responsibilities can
    be used from the different parts of an application, which, in turn, might change
    as well.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的接口，任何实现它的类都有两个职责：连接管理和通信本身。这些职责可以从应用程序的不同部分使用，而这些部分也可能随之改变。
- en: 'We''re going to use the Visual Studio 2017 Class Designer to express the way
    Martin proposes we express this class design instead:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Visual Studio 2017 类设计器来展示马丁提出的我们如何表达这种类设计的方式：
- en: '![](img/77024a2f-1d84-4232-ae00-e7317be4c6f5.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77024a2f-1d84-4232-ae00-e7317be4c6f5.png)'
- en: 'As we see, in Martin''s solution, the class depends on two interfaces, each
    one in charge of a responsibility--connection and channel transmission (two abstractions,
    really: remember that an interface is not compiled and it only serves as a contract
    for the compiler to check).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在马丁的解决方案中，类依赖于两个接口，每个接口负责一个职责--连接和通道传输（实际上两个抽象：记住接口不是编译的，它只作为编译器检查的合约）。
- en: However, one wonders, should these two responsibilities be separated? It only
    depends on application changes. To be precise, the key here is to know whether
    changes in the application affect the signature of connection functions. If they
    do, we should separate both; otherwise, there's no need for separation because
    we would then create needless complexity.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有人会想，这两个职责应该分开吗？这取决于应用程序的变化。更准确地说，关键在于知道应用程序的变化是否会影响连接函数的签名。如果会，我们应该将两者分开；否则，没有必要分开，因为那样会创建不必要的复杂性。
- en: So, overall, a reason to change is the key, but keep in mind that a reason to
    change is applicable only if changes occur.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，改变的原因是关键，但请记住，只有在发生变化时，改变的原因才是适用的。
- en: In other situations, there might be reasons to keep distinct responsibilities
    together as long as they are closely related to the business definitions or have
    to do with the hardware requirements of the operating system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，只要它们与业务定义紧密相关或与操作系统的硬件要求有关，就有理由将不同的职责保持在一起。
- en: The background of the Separation of Concerns (SoC)
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点分离（SoC）的背景
- en: As always happens, there were previous approaches to the problem of software
    separation. Dijkstra in "*On the role of scientific thought*" ([http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html))
    mentioned that *It is what I sometimes have called "the separation of concerns",
    which, even if not perfectly possible, is yet the only available technique for
    effective ordering of one's thoughts, that I know of.*
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如通常发生的那样，软件分离问题之前有先前的解决方案。迪杰斯特拉在“*关于科学思维的作用*”（[http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html)）中提到：“这就是我有时所说的‘关注点分离’，即使不是完美可行的，但据我所知，是唯一有效的思维排序技术。”
- en: Another advance was Information Hiding, defined by Wikipedia ([https://en.wikipedia.org/wiki/Information_hiding](https://en.wikipedia.org/wiki/Information_hiding))
    as *the principle of segregation of the design decisions in a computer program
    that* *are* *most likely to change, thus protecting other parts of the program
    from extensive modification if the design decision is changed.* This was the seed
    that later became a basic pillar of OOP--Data Encapsulation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项进步是信息隐藏，维基百科将其定义为*“在计算机程序中分离最可能改变的设计决策的原则，从而在设计决策改变时保护程序的其他部分免受大量修改。”*这是后来成为面向对象编程（OOP）基本支柱之一的封装的种子。
- en: Even Barbara Liskov, whom we mentioned in connection with the substitution principle,
    published at the same time *Programming With Abstract Data Types* ([http://dl.acm.org/citation.cfm?id=807045](http://dl.acm.org/citation.cfm?id=807045)),
    which she describes as an approach to the computer representation of abstraction.
    The definition of ADTs as a class of objects whose logical behavior is defined
    by a set of values and a set of operations links data and functionality.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是提到替换原则时我们提到的芭芭拉·利斯科夫，也同时发表了《**使用抽象数据类型编程**》([http://dl.acm.org/citation.cfm?id=807045](http://dl.acm.org/citation.cfm?id=807045))，她将其描述为一种计算机表示抽象的方法。ADT作为一类对象，其逻辑行为由一组值和一组操作定义，将数据和功能联系起来。
- en: Later approaches have improved these ideas. Proposals for Code Contracts, originally
    introduced by Bertrand Meyer in his Eiffel language, and implemented in C# via
    Code Contracts ([https://msdn.microsoft.com/es-es/library/dd264808(v=vs.110).aspx)](https://msdn.microsoft.com/es-es/library/dd264808(v=vs.110).aspx))
    foster the use of pre and post conditions that our software has to accomplish.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 后来的方法改进了这些想法。代码契约的提议，最初由伯特兰·梅耶在他的Eiffel语言中引入，并通过C#中的代码契约实现（[https://msdn.microsoft.com/es-es/library/dd264808(v=vs.110).aspx](https://msdn.microsoft.com/es-es/library/dd264808(v=vs.110).aspx)），鼓励使用软件必须完成的预条件和后条件。
- en: Finally, we can think of the separation of what Hayim Makabee ([https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/](https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/))
    reports as cross-cutting concerns--aspects that might affect distinct pieces of
    software in even distinct layers of the application and that should be managed
    in a similar fashion (authorization or instrumentation issues, and so on.). In
    .Net, we count on Attributes, applicable equally to classes and class members,
    to modify and tune such behavior.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将海姆·马卡比（[https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/](https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/））所报告的跨切面关注点的分离视为——可能影响软件的不同部分，甚至在应用的不同层中，应该以类似方式管理的方面（授权或仪表问题等）。在.NET中，我们依赖于属性，这些属性可以应用于类及其成员，以修改和调整此类行为。
- en: A bit later in the same article, Makabee clearly establishes the main purposes
    for these techniques. If we understand coupling as the degree of dependency between
    two modules, the goal is to obtain low coupling. Another term is cohesion or the
    measure of how strongly-related the set of functions performed by a module is.
    Obviously, high cohesion is better.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一篇文章的稍后部分，Makabee 明确提出了这些技术的主要目的。如果我们把耦合度理解为两个模块之间依赖的程度，那么目标是获得低耦合度。另一个术语是内聚度，即一个模块执行的功能集合的紧密程度。显然，高内聚度更好。
- en: 'He ends by summarizing the benefits obtained with these techniques:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 他最后总结了使用这些技术获得的好处：
- en: Patterns and methodologies are always intended to reduce coupling and at the
    same time increase congruity. By hiding information, we reduce coupling since
    we isolate implementation details. Thus, ADT's reduce coupling by using clear
    and abstract interfaces. We have an ADT specifying the set of function that can
    be executed on a type, that's more cohesive than a global data structure modified
    by external functions. The way that OOP reaches that cohesion is the implementation
    of two of its basic principles--encapsulation and polymorphism, together with
    dynamic binding. Furthermore, inheritance reinforces cohesion by means of hierarchies
    that are based on generalization and specialization, which permits a suitable
    separation from the functionality belonging to a superclass from its subclasses.
    AOP, in turn, supplies solutions for cross-cutting concerns in a way that both
    aspects and functionality may become more cohesive.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 模式和方法总是旨在减少耦合度，同时增加一致性。通过隐藏信息，我们减少了耦合度，因为我们隔离了实现细节。因此，ADT（抽象数据类型）通过使用清晰和抽象的接口来减少耦合度。我们有一个ADT，它指定了可以在类型上执行的一组函数，这比由外部函数修改的全局数据结构更具有内聚度。面向对象编程（OOP）达到这种内聚度的方法是实现其两个基本原则——封装和多态，以及动态绑定。此外，继承通过基于泛化和特殊化的层次结构来加强内聚度，这允许从超类所属的功能与其子类之间进行适当的分离。另一方面，AOP（面向切面编程）为跨切面关注点提供了解决方案，这样两个方面和功能都可能变得更加内聚。
- en: Maintainability, reusability, and extensibility are only three of the main advantages
    gained with its implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性、可重用性和可扩展性只是通过其实施获得的主要优势中的三个。
- en: Well-known examples of Separation of Concerns
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离关注点的知名例子
- en: All of us have gone through cases and scenarios where the separation of concerns
    lies at the heart of the system or technology that implements it. One such case
    is HTML (and, especially HTML5).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都经历过一些案例和场景，其中关注点的分离是实施该系统或技术的核心。其中之一就是HTML（尤其是HTML5）。
- en: Since its inception, the standard HTML5 was thought to clearly separate content
    from presentation. And the popularity of mobile devices only made that requirement
    more evident. The huge variety of form factors available today demanded a technology
    capable of adapting to these sizes, in such a way that content could be held by
    HTML tags and the final presentation in a given device decided at runtime depending
    on the device.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 自从其诞生以来，标准HTML5被认为可以清楚地分离内容和表现。移动设备的普及使得这一要求更加明显。今天可用的各种形式因素需要一种能够适应这些尺寸的技术，这样内容就可以由HTML标签持有，而最终的表现形式则由设备在运行时根据设备决定。
- en: Therefore, some tags were declared deprecated, such as `<font>`, `<big>`, `<center>`,
    and a list of others, and the same happened to some attributes, such as `background`,
    `align`, `bgcolor`, or `border` since they didn't make sense in this new system.
    Even some of them that still remain unchanged and that have a visual effect on
    the output (such as `<b>`, `<i>`, or `<small>`) are kept for their semantic meaning
    and not for their presentational effects, which is a role totally dependent on
    CSS3.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些标签被宣布为已弃用，例如 `<font>`、`<big>`、`<center>` 以及其他一些标签，同样，一些属性，如 `background`、`align`、`bgcolor`
    或 `border` 也发生了同样的情况，因为它们在这个新系统中没有意义。甚至一些仍然保持不变并且对输出有视觉效果的标签（如 `<b>`、`<i>` 或 `<small>`）也保留了下来，这是由于它们的语义意义，而不是它们的表现效果，这种角色完全依赖于CSS3。
- en: So, one of the main goals is to avoid functionality overlapping, although this
    is not the only benefit. If we understand concerns as the different aspects of
    software functionality, the business logic of software is a concern, and the interface
    through which a person uses this logic is another.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，主要目标之一是避免功能重叠，尽管这并非唯一的好处。如果我们把关注点理解为软件功能的不同方面，那么软件的业务逻辑是一个关注点，而一个人使用该逻辑的接口是另一个关注点。
- en: In practice, this translates into keeping the code for each of these concerns
    separate. That means, changing the interface should not require changing the business
    logic code, and vice versa. The underlying principle of encapsulation reinforces
    these ideas in the OOP paradigm, and the **Model-view-controller** (**MVC**) design
    pattern is a great example of separating these concerns for better software maintainability.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着将每个这些关注点的代码保持独立。这意味着，更改接口不需要更改业务逻辑代码，反之亦然。封装的底层原则在面向对象（OOP）范式中强化了这些想法，而**模型-视图-控制器**（**MVC**）设计模式是分离这些关注点以实现更好的软件可维护性的一个很好的例子。
- en: A basic sample of Separation of Concerns
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离关注点的一个基本示例
- en: Let's put this into code with a very basic sample and check for the differences
    between coupled and decoupled implementations. Imagine that a Console application
    in .NET Core has to show the user the initial configuration of Console colors,
    change a value, and present those changes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常基础的示例来编写这段代码，并检查耦合和去耦合实现之间的差异。想象一下，一个.NET Core控制台应用程序必须向用户显示控制台颜色的初始配置，更改一个值，并展示这些更改。
- en: 'If you make a basic project `ConsoleApp1`, the following code could be the
    first approach:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个基本的项目`ConsoleApp1`，以下代码可能是第一种方法：
- en: '[PRE1]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This produces the expected results (see the following screenshot showing the
    output):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生预期的结果（以下屏幕截图显示了输出）：
- en: '![](img/2b26742b-2bde-43dc-946c-74cbb2e91fd1.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b26742b-2bde-43dc-946c-74cbb2e91fd1.png)'
- en: 'Which problems can we find in this code? First, the main point is in charge
    of everything: resets the previous initial configuration of the console, changes
    the foreground, and prints the results.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中我们可以发现哪些问题？首先，主要职责是负责一切：重置控制台之前的初始配置，更改前景，并打印结果。
- en: The first attempt at separation would be to realize that further needs might
    require other fragments of code to use the same functionality. Even more, that
    functionality would be better located in another difference-- a piece of software
    such as a library, for example. So, we should enhance our solution with a new
    project containing a library project that would be referenced by any other projects
    along with the solution.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 分离的第一个尝试可能是意识到进一步的需求可能需要其他代码片段使用相同的功能。更进一步，这种功能最好位于另一个差异中——例如，一个库这样的软件。因此，我们应该通过一个新的项目来增强我们的解决方案，这个项目包含一个库项目，它将被任何其他项目以及解决方案引用。
- en: Besides, the manual change to Cyan color implicitly reminds us of the need for
    a function that allows changing to any valid color.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，手动更改到青色颜色隐含地提醒我们需要一个允许更改到任何有效颜色的函数。
- en: 'So, we might end up with another piece of code like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能会得到另一段像这样的代码：
- en: '[PRE2]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, in the main entry point, we could write:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在主入口点，我们可以编写：
- en: '[PRE3]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With exactly the same results (I omit the output since there are no changes).
    So, we made a physical separation together with a logical one, given that now
    any change to the `Console`, should be managed by the `Utilities` library, which
    increases their reusability and therefore maintainability and testing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结果完全相同（我省略了输出，因为没有变化）。因此，我们实现了物理分离和逻辑分离，因为现在对`Console`的任何更改都应该由`Utilities`库来管理，这增加了它们的可重用性，因此提高了可维护性和可测试性。
- en: Notice also that we could have opted for creating the library as static, to
    avoid instantiation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以选择创建一个静态库，以避免实例化。
- en: 'The only change over previous versions of .NET is that, as we showed in a previous
    screenshot, the reference to the library is now made slightly differently, as
    it appears in the Dependencies section on the Solution Explorer. Once the project
    is compiled, we can also see that reference in the `bin` directory resulting from
    compilation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与.NET的先前版本相比，唯一的改变是，正如我们在之前的屏幕截图中所展示的，现在对库的引用方式略有不同，它在解决方案资源管理器的依赖项部分中显示。一旦项目编译完成，我们也可以在编译产生的`bin`目录中看到这个引用：
- en: '![](img/c8c31586-699a-49c0-ae4f-e844ade412e2.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8c31586-699a-49c0-ae4f-e844ade412e2.png)'
- en: Another sample
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个示例
- en: 'Let''s take a more everyday approach with another sample: something simple,
    such as reading from a JSON file on a disk and presenting the results in the output.
    So, I''ve created a .NET Core Console app that includes a JSON file with five
    books from PACKT.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个更常见的示例来采取更实际的方法：简单的东西，比如从磁盘上的JSON文件中读取并展示结果。所以，我创建了一个包含来自PACKT的五本书的JSON文件的.NET
    Core控制台应用程序。
- en: 'A first approach could be the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的方法可能是以下代码：
- en: '[PRE4]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we can see, the code uses a `Book` class that implements the `IBook` interface,
    defined in a very simple manner:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码使用了一个实现 `IBook` 接口的 `Book` 类，该接口以非常简单的方式定义：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This works fine, and generates the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切正常，并生成以下输出：
- en: '![](img/055ba326-0689-4f4c-bbc1-2228223eb651.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/055ba326-0689-4f4c-bbc1-2228223eb651.png)'
- en: Notice that we're using the popular Newtonsoft JSON library, to easily convert
    the string into an array of `Book` objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用流行的 Newtonsoft JSON 库，以便轻松地将字符串转换为 `Book` 对象数组。
- en: 'If we analyze the code, we can identify several places where that SoC principle
    is present:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析代码，我们可以识别出几个存在 SoC 原理的地方：
- en: First, since the entity to manage is a `Book` (which has three properties),
    I created a `Model` folder to hold the definition of a `Book` interface (`IBook`),
    and also a `Book` class that implements that interface
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，由于要管理的实体是 `Book`（具有三个属性），我创建了一个 `Model` 文件夹来保存 `Book` 接口（`IBook`）的定义，以及实现该接口的
    `Book` 类
- en: Secondly, the use of the `Newtonsoft` library is another separation since it's
    the library that takes care of the conversion of the string into an array of `Books`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，使用 `Newtonsoft` 库是另一种分离，因为它是负责将字符串转换为 `Books` 数组的库。
- en: Finally, file reading takes place in the method `ReadFile()`, which receives
    the name of the file
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，文件读取发生在接收文件名的 `ReadFile()` 方法中。
- en: Is there any other separation required? As we mentioned, the reason to change
    would be key at the time to decide. For example, does the app read another type
    of information (apart from `Books`)? Or, does our UI really need to include the
    `ReadFile()`method? And what about having to reference directly the `Newtonsof`t
    library directly in the user interface?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 是否还需要其他分离？正如我们提到的，改变的原因在决定时是关键的。例如，应用程序是否读取另一种类型的信息（除了 `Books` 之外）？或者，我们的用户界面是否真的需要包含
    `ReadFile()` 方法？还有，直接在用户界面中引用 `Newtonsoft` 库呢？
- en: 'If this isn''t the case, perhaps a better approach would be to separate that
    method in a `Utilities` class, just like in the first sample, thus ensuring architecture
    has three separate folders to hold different aspects of the application: the data
    model, the utilities area, and the main user interface.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是这样，可能更好的方法是将该方法分离到一个 `Utilities` 类中，就像在第一个示例中一样，从而确保架构有三个单独的文件夹来保存应用程序的不同方面：数据模型、实用工具区域和主要用户界面。
- en: 'In this manner, we would end up with a `Utilities` class like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们最终会得到一个如下所示的 `Utilities` 类：
- en: '[PRE6]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And the resulting `Program` class gets reduced to the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 `Program` 类简化为以下内容：
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, we get the same output, but now we have an initial separation of
    concerns. There's no need to reference external libraries in the UI, which facilitates
    maintainability and extensibility.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们得到相同的结果，但现在我们有一个初始的关注点分离。在用户界面中不需要引用外部库，这有助于维护性和可扩展性。
- en: 'Let''s now explore the second principle: Open/Closed.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索第二个原则：开放/封闭。
- en: The Open/Closed principle
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**'
- en: We can detect the need to use this principle when a change in the module results
    in a cascade of changes that affect dependent modules. The design is said to be
    too inflexible.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块的变更导致一系列影响依赖模块的连锁反应时，我们可以检测到需要使用这个原则。我们说设计过于不灵活。
- en: The **Open/Closed principle** (**OCP**) principle advises us that we should
    refactor the application in such a manner that future changes don't provoke further
    modifications.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**（**OCP**）原则建议我们应以这种方式重构应用程序，以便未来的更改不会引发进一步的修改。'
- en: The form to apply this principle correctly would be by extending the functionality
    with new code (for instance, using polymorphism) and never changing the old code,
    which is working already. We can find several strategies to achieve this goal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正确应用此原则的形式是通过扩展新代码（例如，使用多态）来扩展功能，而不会更改已经工作的旧代码。我们可以找到几种实现这一目标的方法。
- en: Observe that closed for modification is especially meaningful when you have
    distinct, separate modules (DLLs, EXEs, and so on) that depend on the module that
    has to be changed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于修改封闭性特别有意义，当你有独立的、分开的模块（DLLs、EXEs 等）依赖于必须更改的模块时。
- en: On the other hand, using extension methods or polymorphic techniques allows
    us to perform changes in code without affecting the rest. Think, for example,
    about the extension methods available in the C# language since version 3.0.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用扩展方法或多态技术允许我们在不影响其余部分的情况下进行代码更改。例如，考虑自 C# 3.0 版本以来在 C# 语言中可用的扩展方法。
- en: You can consider extension methods as a special type of static methods with
    the difference being that they are called as if they were instance methods of
    the extended type. You find a typical example in the LINQ standard query operators
    because they add a query functionality to the existing types, such as `System.Collections.IEnumerable`
    or `System.Collections.Generic.IEnumerable<T>`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将扩展方法视为一种特殊的静态方法，区别在于它们被调用时就像它们是扩展类型的实例方法一样。你可以在LINQ标准查询操作符中找到一个典型的例子，因为它们为现有类型添加了查询功能，例如`System.Collections.IEnumerable`或`System.Collections.Generic.IEnumerable<T>`。
- en: The classical and simplest example of this pattern is the client/server cohesion
    that has been largely seen in development for many years. It is preferable that
    clients depend on server abstractions, not on their concretions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的经典和最简单的例子是客户端/服务器耦合，这在多年的开发中已经大量出现。最好是客户端依赖于服务器抽象，而不是它们的具体实现。
- en: 'This can be achieved with interfaces. Servers can implement a client interface
    that clients will use to connect to them. In this manner, servers can change without
    affecting the way clients use them (refer to the following diagram):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过接口来实现。服务器可以实现客户端接口，客户端将使用它来连接到服务器。以这种方式，服务器可以改变，而不会影响客户端使用它们的方式（参见图表）：
- en: '![](img/8ce953ba-b990-4382-9cca-78e872b36543.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ce953ba-b990-4382-9cca-78e872b36543.png)'
- en: Any subtype of the client interface will be free to implement the interface
    in the way it deems more appropriate, and as long as it doesn't break other clients'
    access.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端接口的子类型都可以自由地以它认为更合适的方式实现接口，只要它不影响其他客户端的访问。
- en: Back to our sample
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的示例
- en: Let's imagine a simple case in which the app has to cover a new aspect. For
    example, the app now has to allow the user to list an extra file of books to be
    added to the previous list.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个简单的案例，其中应用程序必须覆盖一个新的方面。例如，现在应用程序必须允许用户列出额外的书籍文件以添加到之前的列表中。
- en: For this new requirement, we can create a new and overloaded `ReadData()` method
    that receives an extra argument. Notice here that the argument doesn't even have
    to be used. It's enough if it declares another signature to be invoked for this
    extra situation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个新要求，我们可以创建一个新的重载`ReadData()`方法，它接收一个额外的参数。注意，这里甚至不需要使用参数。只要它声明了另一个签名来调用这种额外情况就足够了。
- en: 'If we have the extra data in another file (`BookStore2`.`json`, in our demo),
    we could create this extra version of the method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在另一个文件中（在我们的示例中是`BookStore2`.`json`）有额外的数据，我们可以创建这个额外版本的方法：
- en: '[PRE8]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we don't even use the method's argument in this implementation (of
    course, there are other ways to do this, but let's put it this way for the purpose
    of the demo).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们甚至没有在这个实现中使用方法参数（当然，还有其他方法可以做到这一点，但为了演示的目的，我们就这样做）。
- en: 'We have now two versions of `ReadData()` that should be called in the user
    interface depending on the user''s choice (I also changed the `Book[]` definition
    into a `List<Book>` for simplicity, but you can see the older version as well
    in the source code):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个版本的`ReadData()`方法，根据用户的选择在用户界面中调用（我也将`Book[]`定义改为`List<Book>`以简化，但您也可以在源代码中看到旧版本）：
- en: '[PRE9]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now if the user''s answer is *yes* you have an extra set of books added to
    the list, as you can see in the output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果用户的答案是*是*，你将有一组额外的书籍添加到列表中，正如你在输出中可以看到的：
- en: '![](img/e265aab9-543e-48d8-aa15-7a4f66f11b2f.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e265aab9-543e-48d8-aa15-7a4f66f11b2f.png)'
- en: Besides all these reasons, you can think of situations such as having the `Utilities`
    code separated in a distinct library that could also be used by other parts of
    the application. The implementation of the Open/Closed principle here allows a
    more stable and extensible approach.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些原因之外，你可以考虑像将`Utilities`代码分离到独立的库中这样的情况，这个库也可以被应用程序的其他部分使用。这里Open/Closed原则的实现允许更稳定和可扩展的方法。
- en: The Liskov Substitution principle
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: Let's remember this definition--subtypes must be substitutable for their base
    types. This means that this should happen without breaking the execution or losing
    any other kind of functionality.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住这个定义——子类型必须可替换为其基类型。这意味着这应该在不破坏执行或丢失任何其他类型的功能的情况下发生。
- en: You'll notice that this idea lies behind the basic principles of inheritance
    in the OOP programming paradigm.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个想法是面向对象编程范式继承的基本原则背后的。
- en: If you have a method that requires an argument of the `Person` type (let's put
    it that way), you can pass an instance of another class (`Employee`, `Provider`,
    and so on) as long as these instances inherit from `Person`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个需要`Person`类型参数的方法（让我们这样表达），你可以传递另一个类的实例（`Employee`、`Provider`等）作为参数，只要这些实例继承自`Person`。
- en: This is one of the main advantages of well-designed OOP languages, and most
    popular and accepted languages support this characteristic.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设计良好的面向对象语言的主要优势之一，并且大多数流行和接受的语言都支持这一特性。
- en: Back to the code again
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次回到代码
- en: Let's take a look at the support inside our sample, where a new requirement
    arises. Actually, our demo simply calls the `PrintBooks` method and expects to
    receive a `List<Book>` object as the argument.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的示例中的支持，其中出现了一个新的需求。实际上，我们的演示只是调用`PrintBooks`方法，并期望接收一个`List<Book>`对象作为参数。
- en: However, another reason for change might come up when new lists of books appear,
    and those lists include some new field, like the topic each book belongs to (.NET,
    Node, Angular, and so on).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当出现新的书籍列表，并且这些列表包含一些新字段，如每本书所属的主题（.NET、Node、Angular等）时，可能还会出现改变的原因。
- en: 'For example, a new list appears containing a fourth field, `Topic`, in this
    way:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，出现了一个包含第四个字段`Topic`的新列表：
- en: '[PRE10]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The class `Book` should not be changed since it''s being used already. Thus,
    we can inherit from `Book` and create a `TopicBook` class just adding the new
    field (I''m trying to keep things as simple as possible to focus on the architecture
    we''re dealing with):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Book`不应该被修改，因为它已经被使用。因此，我们可以从`Book`继承并创建一个`TopicBook`类，只需添加新的字段（我尽量保持事情尽可能简单，以便专注于我们正在处理的架构）：
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To cover this new aspect, we can change the user interface to allow the user
    to select a new option (`topic`) that includes the new type of book:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了涵盖这个新方面，我们可以更改用户界面，允许用户选择一个新选项（`topic`），该选项包括新的书籍类型：
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we're just including a new condition and calling the overloaded
    method in case the new condition is selected.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是在包括一个新条件，并在新条件被选中时调用重载方法。
- en: 'As for the `ReadData()` overloaded method, we can make some minimal changes
    (basically, adding an `if` condition to include the extra data), like you can
    see in the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`ReadData()`重载方法，我们可以进行一些最小程度的修改（基本上，添加一个`if`条件以包含额外的数据），就像你可以在以下代码中看到的那样：
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Observe that the method's changes are minimal, and especially that we're adding
    to the list of books the result of deserializing a different class (`TopicBook`),
    without any compilation or execution problems.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到方法的变化很小，特别是我们在添加到书籍列表中的是反序列化不同类（`TopicBook`）的结果，没有任何编译或执行问题。
- en: Therefore, the implementation of Generics in .NET (and .NET Core, in this case)
    correctly implements the Liskov Substitution Principle, and we don't have to make
    modifications in our logic.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，.NET（以及在这种情况下.NET Core）中泛型的实现正确地实现了Liskov替换原则，我们不需要对我们的逻辑进行修改。
- en: 'We can check the results in the Automatic Window using a breakpoint before
    the `return` sentence of `ReadData` and seeing how the `List<Book>` now includes
    five elements of type `TopicBook`, with no complaints:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`ReadData`函数的`return`语句之前使用断点在自动窗口中检查结果，看看`List<Book>`现在是否包含五个类型的`TopicBook`元素，没有任何错误：
- en: '![](img/93b4c95e-e217-47b0-917a-6c54857c62ca.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93b4c95e-e217-47b0-917a-6c54857c62ca.png)'
- en: What about the other side (the user interface logic) and, especially, our `PrintBooks`
    method, which expects a `List<Book>`? Well, there's no difference insofar as we
    don't try to print out a field that doesn't exist.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于另一边（用户界面逻辑）以及我们的`PrintBooks`方法，它期望一个`List<Book>`对象作为参数呢？好吧，只要我们不尝试打印一个不存在的字段，就没有区别。
- en: 'You can check the output in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下屏幕截图中检查输出：
- en: '![](img/d7689355-b322-49c0-a426-ec60a6c98b46.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7689355-b322-49c0-a426-ec60a6c98b46.png)'
- en: Thanks to the Liskov Substitution principle support, we were able to add behavior
    and information with minimum effort, and consequently, enforce the OOP principle
    of code reutilization.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Liskov替换原则的支持，我们能够以最小的努力添加行为和信息，从而强制执行面向对象编程的代码重用原则。
- en: Other implementations of LSP in .NET
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中LSP的其他实现
- en: What we've seen up to this point is not the only implementation of the LSP principle
    that we find inside .NET, since different areas of the framework, have grown using
    this conception.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的是.NET中LSP原则实现的唯一方法之一，因为框架的不同区域已经使用这种概念进行扩展。
- en: Events are flexible enough to be defined in a way that allows us to pass our
    own information via classic definitions, alternatively with the participation
    of generics, we can simply define a generic event handler that holds information
    of any kind. All these techniques foster the implementation of good practices,
    not just the SOLID principles.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 事件足够灵活，可以以允许我们通过经典定义传递我们自己的信息的方式定义，或者通过泛型的参与，我们可以简单地定义一个通用的事件处理器，它可以持有任何类型的信息。所有这些技术都促进了良好实践的实现，而不仅仅是SOLID原则。
- en: The Interface Segregation principle
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: As Martin states, this principle deals with the inconveniences of *fat* interfaces.
    And the problem arises when the interfaces of the class can be logically fragmented
    into distinct groups or methods.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如马丁所说，这个原则处理了*胖*接口的不便。问题出现在类的接口可以逻辑上分解成不同的组或方法时。
- en: In this case, if there is more than one client of our application, chances are
    that some clients are connected to a functionality they never use. As Martin states
    in his *Agile Principles Patterns and Practices in C#* book,
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们的应用程序有多个客户端，那么有些客户端可能连接到他们从未使用过的功能。正如马丁在他的《敏捷原则、模式与实践》一书中所说，
- en: When the clients are separate, the interfaces should remain separate, too. Why?
    Because clients exert forces on their server interfaces. When we think of forces
    that cause changes in software, we normally think about how changes to interfaces
    will affect their users.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端分离时，接口也应该保持分离。为什么？因为客户端对其服务器接口施加力量。当我们想到导致软件变化的力时，我们通常考虑接口的变化将如何影响其用户。
- en: And, as a conclusion, he remarks that
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，他总结说，
- en: When clients are forced to depend on methods they don't use, those clients are
    subject to changes to those methods. This results in an inadvertent coupling between
    all the clients. Said another way, when a client depends on a class that contains
    methods that the client does not use but that other clients do use, that client
    will be affected by the changes that those other clients force on the class. We
    would like to avoid such couplings where possible, and so we want to separate
    the interfaces.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端被迫依赖他们不使用的方法时，这些客户端会受到那些方法变化的影响。这导致所有客户端之间出现意外的耦合。换句话说，当一个客户端依赖于包含它不使用但其他客户端使用的方方法的类时，该客户端将受到那些其他客户端对类施加的变化的影响。我们希望尽可能避免这种耦合，因此我们想要分离接口。
- en: Another sample
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个示例
- en: Let's see this situation with another example that starts from a new scenario.
    Let's imagine another app in which we have to cover not only the two types of
    books available at the moment but also a new publication in video format, that
    holds another field named `Duration`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过另一个从新场景开始的例子来看这种情况。让我们想象另一个应用程序，其中我们不仅要覆盖目前可用的两种书籍类型，还要覆盖一种新的视频格式出版物，该出版物有一个名为`Duration`的字段。
- en: 'A single record of this file would look like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的单一记录看起来像这样：
- en: '[PRE14]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But the application maintains the other two previous formats, so we have the
    possibility to list files with three, four, or five fields, depending on the initial
    selection the user chooses.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但是应用程序仍然保留了其他两种之前的格式，因此我们有可能根据用户选择的初始选项列出具有三个、四个或五个字段的文件。
- en: 'A first approach could lead us to an interface like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法可能会引导我们到一个这样的接口：
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Based on this interface we could create the `Product` class (the new name is
    supposed to locate a step above the books or videos since both have four fields
    in common):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个界面，我们可以创建`Product`类（新的名字意味着它应该位于书籍或视频之上，因为两者都有四个共同的字段）：
- en: '[PRE16]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, the equivalent `Utilities` class could select a file depending on the user's
    entry, read it, deserialize it, and send the information back to a `PrintProducts`
    method in charge of the console output.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，等效的`Utilities`类可以根据用户的输入选择一个文件，读取它，反序列化它，并将信息发送回负责控制台输出的`PrintProducts`方法。
- en: 'Our new user interface would look like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的用户界面看起来像这样：
- en: '[PRE17]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Observe that we had to deal with the two cases in which some field could be
    null, so we use string interpolation, together with the null coalescence operator
    (`??`) and the Null-conditional operator (`?`), to prevent failure in these cases.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须处理两种情况，即某些字段可能为空，因此我们使用字符串插值，结合空合并运算符（`??`）和空条件运算符（`?`），以防止在这些情况下失败。
- en: 'The `Utilities` class gets reduced to a much simpler code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Utilities`类简化为更简单的代码：'
- en: '[PRE18]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output lets the user select a number and print the file''s content in a
    similar way to what we did in previous demos, only this time selecting each file
    individually:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 输出允许用户选择一个数字，并以与我们之前在演示中所做的方式打印文件内容，只是这次是单独选择每个文件：
- en: '![](img/4d0040db-0d58-4b08-b5e9-891917d4b7a0.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d0040db-0d58-4b08-b5e9-891917d4b7a0.png)'
- en: If our application now requires more changes, like the addition of statistics,
    for example, the use of a single class to hold them all (the `Product` class,
    here) denotes a violation of the Interface Segregation principle.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序现在需要更多的更改，比如添加统计信息，例如，使用单个类来持有所有这些（这里的`Product`类）表示违反了接口分离原则。
- en: This is because we should separate the interfaces and use a compound approach
    to prevent a class from dealing with unwanted or unneeded functionality.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们应该分离接口，并使用复合方法来防止一个类处理不想要的或不必要的功能。
- en: 'The alternative and proper separation could be to create the following (distinct)
    interfaces:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可行的和适当的分离可能是创建以下（不同的）接口：
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we should have three classes, since three entities can be distinguished,
    but could maintain three fields in common. The definitions of the three classes
    could be expressed in this way:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有三个类，因为可以区分出三个实体，但可以保持三个共同的字段。这三个类的定义可以表达如下：
- en: '[PRE20]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Thanks to this division every entity keeps its own personality, and we can later
    create methods that use generics, or apply the Liskov Substitution principle to
    deal with the distinct requirements that might arise during the lifecycle.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种划分，每个实体都保持了自己的个性，我们后来可以创建使用泛型的方法，或者应用Liskov替换原则来处理生命周期中可能出现的不同需求。
- en: The Dependency Inversion principle
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: 'The last of the SOLID principles is based on two statements, which Wikipedia
    ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle))
    defines in this form:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则中的最后一条基于两个声明，维基百科（[https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)）以这种形式定义了这两个声明：
- en: '*High-level modules should not depend on low-level modules. Both should depend
    on abstractions*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高层模块不应当依赖于低层模块。两者都应当依赖于抽象*'
- en: '*Abstractions should not depend upon details. Details should depend upon abstractions*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽象不应当依赖于细节。细节应当依赖于抽象*'
- en: As for the first statement, we should clarify what we understand by high-level
    and low-level modules. The terminology is related to the importance of the actions
    performed by the module with respect to the application as a whole.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第一个声明，我们应该明确我们理解的高层模块和低层模块是什么。这个术语与模块执行的动作相对于整个应用程序的重要性相关。
- en: 'Let''s put it simply: if a module holds the business logic of a `Customers`
    class, and another module `PrinterService` includes the format that a list of
    the `Customers` class uses in a report, the first one would be high-class and
    the second would be low-class (the reason for the existence of the second is to
    provide some functionality to the first).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单地说：如果一个模块持有`Customers`类的业务逻辑，而另一个模块`PrinterService`包含`Customers`类在报告中使用的格式，那么第一个模块将是高层模块，第二个模块将是低层模块（第二个模块存在的原因是为第一个模块提供一些功能）。
- en: The second statement speaks for itself. If an abstraction depends on details,
    the usage as a definition contract is compromised (a change in the details could
    force a redefinition).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个声明不言自明。如果一个抽象依赖于细节，那么作为定义合同的用法就会受到损害（细节的变化可能迫使重新定义）。
- en: The (more or less) canonical example
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （更多或更少的）典型示例
- en: Dependency Injection techniques are just a way of implementing this principle,
    and we will see them exemplified in many forms and scenarios along this book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入技术只是实现这一原则的一种方式，我们将在本书的许多形式和场景中看到它们的示例。
- en: 'So, I''ll use here the (almost) canonical code that you could find on the internet
    about this subject. I''m showing you here an adaptation made by Munir Hassan ([https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency](https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency))
    in CodeProject which uses a notification scenario to illustrate this situation,
    and I think it''s particularly interesting. He starts with an initial code such
    as this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将在这里使用（几乎）互联网上关于这个主题的规范代码。我在这里向您展示了一个由Munir Hassan（[https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency](https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency)）在CodeProject上制作的改编，他用一个通知场景来说明这种情况，我认为这特别有趣。他从一个初始代码开始，如下所示：
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notification depends on `Email`, creating an instance in its constructor. This
    kind of interaction is said to be tightly coupled. If we want to send other types
    of notification as well, we have to modify the way the `Notification` class is
    implemented.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通知依赖于 `Email`，在其构造函数中创建一个实例。这种交互被称为紧密耦合。如果我们还想发送其他类型的通知，我们必须修改 `Notification`
    类的实现方式。
- en: 'A way to achieve this could be the introduction of an interface (a new level
    of abstraction) to define the concept of sending messages and force the `Email`
    class to implement that interface:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的途径之一是引入一个接口（一个新的抽象级别）来定义发送消息的概念，并强制 `Email` 类实现该接口：
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, the class calls something named `_iMessageService`, whose implementation
    could vary. As Hamir mentions, there are three ways to implement this pattern:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类调用一个名为 `_iMessageService` 的东西，其实现可能会有所不同。正如Hamir提到的，有三种方法来实现这种模式：
- en: 'DI is the act of supplying all classes that a service needs rather than leaving
    the responsibility to the service to obtain dependent classes. DI typically comes
    in three flavors: Constructor Injection, Property Injection, Method Injection'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是指为服务提供所有所需类，而不是将获取依赖类的责任留给服务。依赖注入通常有三种形式：构造函数注入、属性注入、方法注入
- en: 'In the first form, (constructor injection) Hamir proposes the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种形式中（构造函数注入），Hamir提出了以下建议：
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This reminds us of what we will see in the implementation of Dependency Injection
    in ASP.NET Core in the following chapters. No mention of `Emails` here: only an
    `IMessageService` is implied.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们想起了在下一章中我们将要看到的ASP.NET Core中依赖注入的实现。这里没有提到 `Emails`：只隐含了一个 `IMessageService`。
- en: You can visit the aforementioned page for more details about the other ways
    to implement injection, but, as I mentioned, we'll cover all those in detail in
    the coming chapters.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问上述页面以获取有关其他实现注入方式的更多详细信息，但正如我提到的，我们将在接下来的章节中详细介绍所有这些。
- en: Other ways to implement Dependency Inversion
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现依赖倒置的其他方法
- en: 'Generally speaking, there are many ways in which the DIP principle can lead
    to a solution. Another way to implement this principle is by using the Dependency
    Injection techniques, derived from another way to see Dependency Inversion: the
    so-called **Inversion of Control** (**IoC**).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，有许多方式可以实现DIP原则，从而得到解决方案。实现这一原则的另一种方法是使用依赖注入技术，这是从另一种看待依赖倒置的方式中衍生出来的，即所谓的**控制反转**（**IoC**）。
- en: According to the paper written by Martin Fowler ([https://martinfowler.com/articles/injection.html](https://martinfowler.com/articles/injection.html)),
    Inversion of Control is the principle whereby the control flow of a program is
    inverted; instead of the programmer controlling the flow of a program, the external
    sources (framework, services, and other components) take control of it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Martin Fowler（[https://martinfowler.com/articles/injection.html](https://martinfowler.com/articles/injection.html)）撰写的论文，控制反转（Inversion
    of Control，IoC）是一种原则，其中程序的流程被反转；不是程序员控制程序的流程，而是外部来源（框架、服务和其他组件）控制它。
- en: One of them is a dependency container, which is a component and serves or provides
    you with some code, injecting it when required.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是一个依赖容器，它是一个组件，并在需要时为您提供服务或代码的注入。
- en: Some popular Dependency Containers for C# are Unity and Ninject, to name just
    a couple. In NET Core, there's an embedded container so there's no need to use
    an external one, except in cases where we might require some special functionality
    provided by them.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的C#依赖容器有Unity和Ninject，仅举两个例子。在.NET Core中，有一个内置的容器，因此不需要使用外部容器，除非我们可能需要它们提供的某些特殊功能。
- en: In the code, you instruct this component to register certain classes of your
    application; so, later on, when you need an instance of one of them, you just
    have to declare it (typically in the constructor), and it is served to your code
    automatically.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，你指导这个组件注册你的应用程序中的某些类；因此，稍后当你需要其中一个类的实例时，你只需声明它（通常在构造函数中），它就会自动提供给你的代码。
- en: Other frameworks implement this principle as well, even if they're not purely
    object-oriented. This is the case with AngularJS or Angular 2, in which, when
    you create a controller that requires access to a service, you ask for the service
    in the controller's function declaration, and the internal Angular's DI system
    serves a singleton instance of the service without the intervention of the client's
    code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其他框架也实现了这一原则，即使它们不是纯粹面向对象的。AngularJS或Angular 2就是这种情况，其中，当你创建一个需要访问服务的控制器时，你会在控制器函数声明中请求该服务，而Angular的内部DI系统会自动提供一个服务的单例实例，无需客户端代码的干预。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've reviewed the five SOLID Principles in the way they were
    formulated by Robert C. Martin in 2000.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了罗伯特·C·马丁在2000年提出的五个SOLID原则。
- en: We've explored each of these principles, discussing their advantages and checking
    their implementation with some simple code using .NET Core Console applications,
    to see how they can be coded.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了这些原则中的每一个，讨论了它们的优点，并使用.NET Core控制台应用程序的简单代码来检查它们的实现，以了解它们如何被编码。
- en: In the next chapter, we will talk about Dependency Injection and the most popular
    IoC containers, reviewing how they can be used and analyzing their pros and cons
    in everyday applications.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论依赖注入以及最流行的IoC容器，回顾它们如何被使用，并分析它们在日常应用中的优缺点。
