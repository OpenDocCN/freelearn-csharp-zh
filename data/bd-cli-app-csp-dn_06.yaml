- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Error Handling and Logging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和日志记录
- en: Logging and error handling are two important concepts to consider (and implement)
    when building any application, and CLI applications are no exceptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志和错误处理是在构建任何应用程序时需要考虑（并实现）的两个重要概念，CLI应用程序也不例外。
- en: While error handling ensures graceful behavior of the application in the face
    of unexpected events, logging provides crucial insights into the application’s
    runtime behavior and facilitates troubleshooting and debugging.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然错误处理确保了应用程序在面对意外事件时的优雅行为，但日志记录提供了对应用程序运行时行为的宝贵见解，并有助于故障排除和调试。
- en: That’s why, in this chapter, we will cover these two concepts, starting with
    error handling.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖这两个概念，从错误处理开始。
- en: 'Specifically, we’ll cover the following main topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将涵盖以下主要内容：
- en: Error handling in CLI applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLI应用程序中的错误处理
- en: Logging in CLI applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLI应用程序中的日志记录
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书附带的GitHub仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06)。
- en: Handling errors in CLI applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI应用程序中的错误处理
- en: 'Error handling may take two forms:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理可能有两种形式：
- en: An exception is raised, due to an unexpected event (such as an invalid input
    or an inaccessible dependency)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于意外事件（如无效输入或不可访问的依赖项）而引发异常
- en: The program is terminated, and we want to prevent it crashing by allowing it
    to gracefully shut down
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序终止，我们希望通过允许它优雅地关闭来防止它崩溃
- en: In this section, we will cover both topics. Let’s start with exception handling.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖这两个主题。让我们从异常处理开始。
- en: Handling exceptions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: There is nothing special about handling exceptions in a CLI application compared
    to other kinds of applications, as it follows the same guidelines and best practices.
    That’s why, in this section, you might find that you already know all the concepts
    that we are going to talk about, and that’s perfectly normal because you’d likely
    have implemented them in other applications, whether web, APIs, or desktop applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的应用程序相比，在CLI应用程序中处理异常并没有什么特别之处，因为它遵循相同的指南和最佳实践。这就是为什么在本节中，您可能会发现您已经知道我们将要讨论的所有概念，这是完全正常的，因为您很可能在其他应用程序中实现了它们，无论是Web、API还是桌面应用程序。
- en: However, it is important to note that a robust error-handling strategy will
    have a significant impact on the quality, reliability, and resilience of your
    application. This is why it is worth taking the time to design a good error-handling
    strategy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，一个健壮的错误处理策略将对应用程序的质量、可靠性和弹性产生重大影响。这就是为什么花时间设计一个好的错误处理策略是值得的。
- en: As you certainly know, every error-handling strategy relies on a `try-catch-finally`
    block. But not always! Not every method needs to implement a `try-catch-finally`
    block. In fact, best practices of error handling state that only the *caller*
    method (usually the top-level method) should handle exceptions, while the *callee*
    method should let the exceptions bubble up to be caught, and handled, by the *caller*
    method. This results in leaner, cleaner, and more focused methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，每个错误处理策略都依赖于一个`try-catch-finally`块。但并非总是如此！并非每个方法都需要实现`try-catch-finally`块。实际上，错误处理的最佳实践表明，只有*调用者*方法（通常是顶级方法）应该处理异常，而*被调用者*方法应该让异常冒泡到被*调用者*方法捕获和处理。这导致方法更加精简、干净和专注。
- en: Another best practice is to never swallow exceptions unless it is absolutely
    necessary. Why? Because swallowing exceptions hides errors, making code appear
    functional while it fails. This obscures valuable error information, allowing
    unpredictable behavior and data corruption. It complicates debugging and violates
    the principle of failing fast. In other words, it leads to silent failures that
    are hard to detect and fix, making it a poor practice.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是除非绝对必要，否则不要吞没异常。为什么？因为吞没异常隐藏了错误，使得代码看起来功能正常，而实际上却在失败。这掩盖了宝贵的错误信息，允许不可预测的行为和数据损坏。它使调试复杂化，并违反了快速失败的原则。换句话说，它导致难以检测和修复的静默失败，因此是一种不良实践。
- en: The `finally` block is important, although I see it often forgotten. It is important
    to remember that this block is used to ensure that resources are freed, even if
    an exception occurs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块很重要，尽管我经常看到它被遗忘。重要的是要记住，这个块用于确保即使在发生异常的情况下也能释放资源。'
- en: 'When catching exceptions, use multiple `catch` blocks, catching exceptions
    from the most specific to the most generic. This will ensure far better error
    handling than catching all exceptions as a generic exception and applying the
    same error-handling processing to all of them. An example of that is when working
    with files: we don’t want to handle the situation where the file is not found
    the same way as handling the situation where the file cannot be written to, because
    of a lack of permissions. By distinguishing each of these situations, we can apply
    a specific error-handling process and, ultimately, provide the user with appropriate
    details of what happened rather than having generic processing and telling the
    user that we couldn’t write to the file.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获异常时，使用多个 `catch` 块，从最具体到最通用的异常进行捕获。这将确保比将所有异常作为通用异常捕获并应用相同的错误处理过程有更好的错误处理。一个例子是在处理文件时：我们不希望以处理文件找不到的方式处理文件无法写入的情况，因为权限不足。通过区分这些情况，我们可以应用特定的错误处理过程，并最终向用户提供发生情况的适当细节，而不是进行通用的处理并告诉用户我们无法写入文件。
- en: We can also create our own exceptions. I do this often because it helps improve
    code readability. It is easy to understand what happens when the `CreateNewUser`
    method throws an instance of the `UserAlreadyExistsException` exception, isn’t
    it?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建自己的异常。我经常这样做，因为这有助于提高代码的可读性。当 `CreateNewUser` 方法抛出 `UserAlreadyExistsException`
    异常的实例时，很容易理解发生了什么，不是吗？
- en: 'Here’s how this custom exception would look:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个自定义异常的外观：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To catch or not to catch exceptions?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获还是不要捕获异常？
- en: There’s a movement nowadays that is going against throwing exceptions because
    of the performance cost this may have, and I totally understand this. One great
    video about this topic is the one by Nick Chapsas, titled *Don’t throw exceptions
    in C#. Do this instead*, which you can find on YouTube. I encourage you to go
    and watch it and make up your own mind.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一种反对抛出异常的运动，因为这样做可能会带来性能成本，我完全理解这一点。关于这个主题的一个很好的视频是由尼克·查帕斯（Nick Chapsas）制作的，标题为
    *Don’t throw exceptions in C#. Do this instead*，你可以在 YouTube 上找到它。我鼓励你去看看，并形成你自己的看法。
- en: However, whether you choose to throw the exception or handle it without throwing
    it, you will likely be dealing with exceptions. Also, keep in mind that both the
    .NET framework and some other libraries that you might be using are probably throwing
    exceptions, and you will need to catch these to handle them. Because of that,
    the principles described here are still valid and worth knowing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论你选择抛出异常还是不抛出异常而处理它，你很可能会处理异常。此外，请记住，.NET 框架以及你可能使用的某些其他库可能正在抛出异常，你需要捕获这些异常来处理它们。正因为如此，这里描述的原则仍然有效，并且值得了解。
- en: When catching exceptions, you can also filter them. This is because some exceptions
    may require a different handling mechanism depending on the reason they were thrown.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获异常时，你也可以过滤它们。这是因为某些异常可能需要根据它们被抛出的原因采取不同的处理机制。
- en: 'A good example of this is the `HttpResponseException` exception type, as illustrated
    here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个很好的例子是 `HttpResponseException` 异常类型，如这里所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see here, we are catching the same exception (`HttpResponseException`)
    twice, but in each `catch` block, we focus on a very specific situation: in the
    first one, we are handling the situation where the resource was not found, whereas,
    in the second one, we are handling the situation where the user accessing the
    resource was not authenticated.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在这里两次捕获了相同的异常（`HttpResponseException`），但在每个 `catch` 块中，我们关注的是一个非常具体的情况：在第一个中，我们处理资源未找到的情况，而在第二个中，我们处理访问资源的用户未认证的情况。
- en: One final best practice when handling exceptions is to avoid losing the stack
    trace of the exception when throwing it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常时的最后一个最佳实践是避免在抛出异常时丢失异常的堆栈跟踪。
- en: 'To illustrate this principle, let’s consider this example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个原则，让我们考虑这个例子：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we throw the exception using the `throw ex;` statement, we lose the stack
    trace containing the details of what happened up to this point. The proper way
    to do this is to simply use `throw` to ensure the stack trace is preserved.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `throw ex;` 语句抛出异常，我们将丢失包含到目前为止发生详情的堆栈跟踪。正确的方法是简单地使用 `throw` 来确保堆栈跟踪被保留。
- en: 'However, in some cases, we may need to catch the exception, handle it, and
    rethrow it by encapsulating it into another exception type, as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们可能需要捕获异常，处理它，并通过将其封装到另一个异常类型中重新抛出，如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the stack trace is preserved.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，堆栈跟踪被保留。
- en: Now, let’s apply these principles to *Bookmarkr*, and more specifically, to
    the ability to export bookmarks out of *Bookmarkr*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些原则应用到 *Bookmarkr* 中，更具体地说，是应用到从 *Bookmarkr* 导出书签的能力。
- en: 'If you recall from the previous chapter, the export handler method (`OnHandleExportCommand`)
    looked like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得上一章的内容，导出处理方法 (`OnHandleExportCommand`) 看起来是这样的：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, note that the `WriteAllText` method may throw many exceptions, such
    as the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，`WriteAllText` 方法可能会抛出许多异常，例如以下这些：
- en: '`UnauthorizedAccessException` will be thrown in the case of insufficient permissions
    to access the file'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有足够的权限访问文件，将抛出 `UnauthorizedAccessException`
- en: '`DirectoryNotFoundException` will be thrown if the path is invalid'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路径无效，将抛出 `DirectoryNotFoundException`
- en: '`PathTooLongException` will be thrown if the path exceeds the system-defined
    maximum length'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路径超过系统定义的最大长度，将抛出 `PathTooLongException`
- en: 'So, let’s handle these exceptions. The code would look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们处理这些异常。代码将如下所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, we are handling the most common exceptions, and we
    are also handling the general exception in case of an unexpected exception (yes,
    exceptions are exceptional situations but are nonetheless expected to happen,
    at least most of the time).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在处理最常见的异常，并且在出现意外异常的情况下，我们也在处理一般异常（是的，异常是例外情况，但仍然预期至少在大多数情况下会发生）。
- en: Note that we handled exceptions for both the serialization process and the file-writing
    process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经处理了序列化过程和文件写入过程中的异常。
- en: 'If you want to learn more about best practices for handling exceptions, I recommend
    that you visit this page: [https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于处理异常的最佳实践，我建议您访问这个页面：[https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions)。
- en: Handling errors doesn’t necessarily mean handling exceptions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误并不一定意味着处理异常
- en: As surprising as it may seem, this is true, and exceptions might be avoided
    (at least most of the time) by applying defensive programming techniques.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能令人惊讶，但这确实是事实，并且通过应用防御性编程技术，可以避免（至少在大多数情况下）异常的发生。
- en: By validating inputs, enforcing preconditions, and proactively identifying potential
    failure scenarios, we can significantly reduce error occurrences and enhance the
    overall resilience of our application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过验证输入、强制执行先决条件和积极识别潜在失败场景，我们可以显著减少错误发生，并增强我们应用程序的整体弹性。
- en: 'Let’s see what we can do here in terms of defensive programming:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在防御性编程方面我们能做些什么：
- en: '**Validate inputs**: We could ensure that the input file exists, hence avoiding
    an exception being raised if the file doesn’t exist.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证输入**：我们可以确保输入文件存在，从而避免在文件不存在时引发异常。'
- en: '`bookmarks` list is not null. Otherwise, `JsonSerializer` will throw a `NullReferenceException`.
    We can also ensure that the list is not empty because, if it is empty, although
    the serialization will return an empty JSON array, we may not want to write this
    to a file, especially if this means overwriting the existing file.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `bookmarks` 列表不为空。否则，`JsonSerializer` 将抛出 `NullReferenceException`。我们还可以确保列表不为空，因为如果列表为空，尽管序列化将返回一个空的
    JSON 数组，但我们可能不想将此写入文件，尤其是如果这意味着覆盖现有文件。
- en: '**Identify potential failure scenarios**: We have already done this by catching
    the most common exceptions and handling them.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别潜在失败场景**：我们已经通过捕获最常见的异常并处理它们来做到这一点。'
- en: Okay. So, at this point, we know how to handle exceptions in our CLI applications,
    and we implemented this in *Bookmarkr*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以，到目前为止，我们知道如何在我们的 CLI 应用程序中处理异常，并且我们在 *Bookmarkr* 中实现了这一点。
- en: However, there exists one other kind of unexpected event that represents, in
    fact, normal behavior. I’m talking about **program termination**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在另一种意外事件，实际上它代表了正常行为。我指的是**程序终止**。
- en: Handling program termination
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理程序终止
- en: A program might be terminated at any moment by pressing a specific keyboard
    combination (usually *Ctrl* + *C* or *Ctrl* + *Break*). When this happens, the
    operating system sends a signal to the program, instructing it to immediately
    stop its execution. This signal, often referred to as an interrupt or a termination
    signal, allows the program to perform any necessary cleanup operations, such as
    closing files, releasing resources, or saving state, before it exits. If the program
    has a signal handler for this specific signal, it can execute custom code to handle
    the termination gracefully. Otherwise, the program will terminate abruptly, and
    any unsaved data or incomplete operations may be lost.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可能在任何时候通过按特定的键盘组合（通常是*Ctrl* + *C*或*Ctrl* + *Break*）来终止。当这种情况发生时，操作系统会向程序发送一个信号，指示它立即停止执行。这个信号，通常被称为中断或终止信号，允许程序在退出之前执行任何必要的清理操作，例如关闭文件、释放资源或保存状态。如果程序有针对此特定信号的信号处理程序，它可以执行自定义代码以优雅地处理终止。否则，程序将突然终止，任何未保存的数据或不完整的操作可能会丢失。
- en: Program termination allows one to gracefully stop a program that is taking too
    long to execute or that has become unresponsive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 程序终止允许优雅地停止执行时间过长或已无响应的程序。
- en: '`System.CommandLine` provides a mechanism to handle program termination and
    execute custom code, allowing our CLI application to gracefully terminate.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.CommandLine`提供了一个处理程序终止并执行自定义代码的机制，允许我们的CLI应用程序优雅地终止。'
- en: Let’s implement it to handle the situation where the user terminates the program
    while the export operation is ongoing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现它来处理用户在导出操作进行中终止程序的情况。
- en: 'In order to handle program termination, we will need to modify the delegate
    of the `SetHandler` method to retrieve the cancellation token and pass it to the
    handler method itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理程序终止，我们需要修改`SetHandler`方法的委托以检索取消令牌并将其传递给处理方法本身：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can modify the handler method so it handles the program termination
    (i.e., catching the `OperationCanceledException` exception):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改处理方法，使其处理程序终止（即捕获`OperationCanceledException`异常）：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we run the program now and then terminate it by pressing the *Ctrl* + *C*
    keyboard combination, we get the following console output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序然后通过按*Ctrl* + *C*键盘组合来终止它，我们会得到以下控制台输出：
- en: '![Figure 6.1 – Handling program termination](img/B22400_06_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 处理程序终止](img/B22400_06_01.jpg)'
- en: Figure 6.1 – Handling program termination
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 处理程序终止
- en: One thing worth mentioning here is that we need to use the asynchronous version
    of the `WriteAllText` method (aka `WriteAllTextAsync`) in order to be able to
    pass the cancellation token we received as a parameter, and for that reason, we
    needed to declare the `OnExportCommand` method as `async`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们需要使用`WriteAllText`方法的异步版本（即`WriteAllTextAsync`），以便能够传递我们接收到的取消令牌，因此我们需要将`OnExportCommand`方法声明为`async`。
- en: Note that by handling program termination, we can gracefully handle the situation
    where the user abruptly stops the program. This results in a graceful shutdown
    of the program and release of the used resources, hence avoiding a crash and an
    error message.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过处理程序终止，我们可以优雅地处理用户突然停止程序的情况。这导致程序优雅地关闭并释放所使用的资源，从而避免崩溃和错误信息。
- en: Why are we passing the cancellation token as a parameter to the handler method
    and not using it?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要将取消令牌作为参数传递给处理方法而不使用它？
- en: This is an excellent question! As you have noticed, even though we receive the
    `CancellationToken` object as a parameter to the `OnExportCommand` method, we
    seem not to be using it. Then, why did we pass it in the first place?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的问题！正如你所注意到的，尽管我们在`OnExportCommand`方法中作为参数接收了`CancellationToken`对象，但我们似乎并没有使用它。那么，我们最初为什么要传递它呢？
- en: This is related to how cancellation tokens work in .NET. Let me explain!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这与.NET中取消令牌的工作方式有关。让我来解释一下！
- en: When `OperationCanceledException` is created in response to a cancellation request,
    it typically includes information about the `CancellationToken` object that triggered
    the cancellation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应取消请求创建`OperationCanceledException`时，它通常包含有关触发取消的`CancellationToken`对象的信息。
- en: For that matter, the `OperationCanceledException` exception class has a constructor
    that takes a `CancellationToken` object as a parameter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就此而言，`OperationCanceledException`异常类有一个构造函数，它接受一个`CancellationToken`对象作为参数。
- en: When .NET framework asynchronous methods create this exception, they usually
    use this constructor and pass the cancellation token that triggered the cancellation
    request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当.NET框架异步方法创建此异常时，它们通常使用此构造函数并传递触发取消请求的取消令牌。
- en: The `OperationCanceledException` class has a `CancellationToken` property that
    can be then accessed to get the token associated with the cancellation request.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationCanceledException`类有一个`CancellationToken`属性，可以用来获取与取消请求关联的令牌。'
- en: In our case, we are accessing it to check whether the cancellation was requested
    by the user or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们访问它是为了检查取消请求是否由用户发起。
- en: Having established a robust framework for error handling, it is equally important
    to ensure that these errors are recorded and monitored. That’s where logging comes
    into play!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了一个健壮的错误处理框架之后，同样重要的是确保这些错误被记录和监控。这正是日志记录发挥作用的地方！
- en: Effective logging not only helps in diagnosing and resolving issues but also
    provides valuable insights into the application’s behavior, performance, and usage.
    In the upcoming section, we will dive into the best practices and strategies for
    implementing comprehensive logging mechanisms that complement our error-handling
    strategy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的日志记录不仅有助于诊断和解决问题，还提供了关于应用程序的行为、性能和使用的宝贵见解。在接下来的部分中，我们将深入了解实施全面日志记录机制的最佳实践和策略，这些机制补充了我们的错误处理策略。
- en: At this point, we have covered a lot of information on error handling. However,
    error handling works together with logging to improve application reliability
    and maintainability. So, let’s shift our focus to logging, and explore how to
    capture and preserve valuable information not only about errors but also about
    other significant events that will happen during program execution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了关于错误处理的大量信息。然而，错误处理与日志记录一起工作，以提高应用程序的可靠性和可维护性。因此，让我们将重点转向日志记录，并探讨如何捕获和保存有关错误以及程序执行期间发生的其他重要事件的宝贵信息。
- en: Logging in CLI applications
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CLI应用程序中记录日志
- en: While error handling is more of a “just-in-time” compensation mechanism when
    an unexpected event or error occurs, we may want to keep track of what happened
    so we can reproduce the issue, analyze it, understand why it happened in the first
    place, and fix it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生意外事件或错误时，错误处理更像是“即时”的补偿机制，但我们可能希望记录发生了什么，以便我们可以重现问题、分析它、了解它最初发生的原因，并修复它。
- en: By “keeping track of what happened,” we either mean the sequence of events that
    led to that unexpected behavior or error and/or the call stack of the exception
    raised when the error occurred.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “记录发生了什么”的意思，要么是指导致意外行为或错误的事件的序列，要么是指错误发生时引发的异常的调用堆栈。
- en: Selecting a logging format is important. We want to find a balance between the
    amount of data we are logging (and storing) and the usage we intend to do with
    it. Logging unnecessary information will complexify log analysis, increase storage
    (and retention) costs, and may also slow down the logging process. We will also
    need to ensure that we are not logging sensitive information (such as credit card
    data), and if we do, that we are doing it in a safe manner. Some of the popular
    log formats include XML, JSON, CSV, and syslog.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 选择日志格式也很重要。我们希望在我们记录（并存储）的数据量和我们打算如何使用它的用途之间找到一个平衡。记录不必要的信息将使日志分析复杂化，增加存储（和保留）成本，也可能减慢日志记录过程。我们还需要确保我们没有记录敏感信息（如信用卡数据），如果确实记录了，那么我们必须以安全的方式进行。一些流行的日志格式包括XML、JSON、CSV和syslog。
- en: Choosing the logging destination is equally important. We need to understand
    that there are no good or bad options, only appropriate and inappropriate options
    depending on our context and needs. If our intent is to analyze the logs, we may
    want to store these logs in a solution that provides log analysis mechanisms out
    of the box, so we don’t need to write code for that. Examples of such solutions
    are Azure Log Analytics, Splunk, Datadog, Dynatrace, Serilog, and Elasticsearch.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择日志记录目的地同样重要。我们需要理解，没有好或坏的选择，只有根据我们的环境和需求是否合适的选择。如果我们打算分析日志，我们可能希望将这些日志存储在提供开箱即用日志分析机制的解决方案中，这样我们就不需要为它编写代码。这类解决方案的例子包括Azure
    Log Analytics、Splunk、Datadog、Dynatrace、Serilog和Elasticsearch。
- en: However, note that by relying on cloud solutions (such as Azure Log Analytics),
    our application needs either to be running in the cloud or to have a constant
    connection to the internet. Sure, we can also build our application to follow
    the **occasionally connected application** (**OCA**) pattern so it keeps logs
    locally when it is running offline and sends them to Azure Log Analytics when
    it goes back online, but the idea here is that we should select a logging solution
    that is coherent with the usage pattern of our application. So, for an application
    that is intended to run locally, we will favor a logging mechanism that runs locally
    as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，依赖于云解决方案（如Azure Log Analytics），我们的应用程序需要运行在云中或者保持对互联网的持续连接。当然，我们也可以构建我们的应用程序以遵循**偶尔连接的应用程序**（**OCA**）模式，这样当它离线运行时可以本地记录日志，当它重新上线时将它们发送到Azure
    Log Analytics，但这里的想法是我们应该选择与我们的应用程序使用模式一致的日志解决方案。因此，对于打算本地运行的应用程序，我们将优先考虑本地运行的日志机制。
- en: 'Finally, it is also important to define the log retention period. This can
    either be enforced by the organization’s compliance rules or by the relevance
    of the logged data: do you still need to analyze data from a bug or customer behavior
    that occurred three years ago? If not, you don’t need to keep this data.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义日志保留期也很重要。这可以由组织的合规性规则或记录数据的关联性来强制执行：你还需要分析三年前发生的错误或客户行为的数据吗？如果不，你不需要保留这些数据。
- en: Either way, it is important to separate the logging format from the solution
    you use to store and analyze these logs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，将日志格式与您用于存储和分析这些日志的解决方案分开是很重要的。
- en: Since our application is intended to run locally, we will select JSON as a logging
    format and Serilog as a logging mechanism.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序打算本地运行，我们将选择JSON作为日志格式，并使用Serilog作为日志机制。
- en: Why JSON?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择JSON？
- en: JSON-structured logs are easy to read and can easily be parsed by machines.
    Many modern log management solutions can ingest logs in JSON format, making it
    a good choice for structured logging.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JSON结构的日志易于阅读，并且可以很容易地被机器解析。许多现代日志管理解决方案可以接受JSON格式的日志，使其成为结构化日志的好选择。
- en: In addition, JSON is less verbose than XML, which results in files that are
    lightweight in size, which, in turn, reduces the amount of storage we need to
    store them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JSON比XML更简洁，这导致文件体积更小，反过来又减少了我们需要存储它们的存储空间。
- en: Why Serilog?
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择Serilog？
- en: Serilog is a diagnostic logging library for .NET. It is built with powerful
    structured event data in mind and supports various “sinks,” which are the destinations
    where log events can be written to. Examples of such sinks include files, the
    console, databases or log management tools (such as Elasticsearch, Application
    Insights, Datadog, and Splunk). It’s easy to set up, has a clean API, and is portable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog是一个.NET的诊断日志库。它是基于强大的结构化事件数据构建的，并支持各种“sink”，即日志事件可以写入的目的地。此类sink的例子包括文件、控制台、数据库或日志管理工具（如Elasticsearch、Application
    Insights、Datadog和Splunk）。它易于设置，具有干净的API，并且是可移植的。
- en: One of the key features of Serilog is its ability to log structured data, which
    allows for more meaningful and queryable logs. It uses message templates, a simple
    DSL extending .NET format strings, which can capture properties along with the
    log event.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog的一个关键特性是它能够记录结构化数据，这使得日志更有意义且可查询。它使用消息模板，这是一种简单的DSL，扩展了.NET格式字符串，可以捕获属性以及日志事件。
- en: I do like the way the NuGet packages for Serilog are structured. First, there
    is the base package, which provides Serilog’s functionalities in our code. Then,
    there are “sink” packages, one for each sink, and there are tons of them. We can
    even create our very own sink should we need it. I haven’t found a usage for that
    as there are already sinks for almost everything you can think of…
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实喜欢Serilog的NuGet包的结构。首先，有一个基础包，它为我们代码中的Serilog提供功能。然后，有“sink”包，每个sink都有一个，而且有很多。如果我们需要的话，甚至可以创建我们自己的sink。我还没有找到它的用途，因为几乎所有你能想到的东西都已经有了sink...
- en: Oh! And, by the way, the Serilog NuGet package has been downloaded (to this
    day) more than 1.24 billion times! That should mean something, right? 😉
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！顺便说一下，Serilog NuGet 包（截至今天）已经被下载了超过12.4亿次！这应该意味着什么，对吧？😉
- en: Before we add Serilog to our CLI application, we need to modify our code to
    expose the `IServiceCollection` property so we can configure our services.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将Serilog添加到我们的CLI应用程序之前，我们需要修改我们的代码以公开`IServiceCollection`属性，这样我们就可以配置我们的服务。
- en: Accessing IServiceCollection
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问IServiceCollection
- en: 'The first step we need to take is to add the `System.CommandLine.Hosting` NuGet
    package to our project. From the Visual Studio Code terminal, we can do so by
    typing this command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一个步骤是将`System.CommandLine.Hosting` NuGet包添加到我们的项目中。从Visual Studio Code终端，我们可以通过输入以下命令来完成：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we need to update our instantiation of the `CommandLineBuilder` class
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们的`CommandLineBuilder`类实例化方式如下：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have access to `IServiceCollection` and can thus add services to this
    collection and configure their behavior.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以访问`IServiceCollection`，因此可以向这个集合添加服务并配置它们的行为。
- en: Adding Serilog to IServiceCollection
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Serilog添加到IServiceCollection
- en: Adding Serilog to this collection will require the `Serilog.Extensions.Hosting`
    NuGet package. So, let’s add it!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将Serilog添加到这个集合需要`Serilog.Extensions.Hosting` NuGet包。所以，让我们添加它！
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This allows us to add Serilog to `IServiceCollection` by adding this line of
    code to the preceding code sample:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们通过在先前的代码示例中添加这一行代码来将Serilog添加到`IServiceCollection`：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding (and configuring) the required Serilog sinks
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加（并配置）所需的Serilog输出
- en: 'As mentioned earlier, there are tons of sinks available with Serilog. However,
    since we are building a CLI application, we will only use two sinks: `Console`
    and `File`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Serilog提供了大量的输出。然而，由于我们正在构建一个命令行应用程序，我们只会使用两个输出：`Console`和`File`。
- en: 'We also mentioned that Serilog is structured in such a way that each sink has
    its own NuGet package. We will then need to add the appropriate NuGet packages
    using these commands:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到，Serilog的结构是这样的，每个输出都有自己的NuGet包。然后，我们需要使用这些命令添加适当的NuGet包：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can start using Serilog at this point by configuring the sinks in the code.
    The updated code for the instantiation of the `CommandLineBuilder` class would
    then be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在代码中配置输出来开始使用Serilog。然后，用于实例化`CommandLineBuilder`类的更新代码如下：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s take a closer look at the part of the code where Serilog is configured
    (i.e., the delegate function within the `AddSerilog` method):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看配置Serilog的部分代码（即在`AddSerilog`方法内的委托函数）：
- en: This code acts on an instance of the `LoggerConfiguration` class that is used
    to configure the behavior of Serilog and its sinks.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码作用于一个`LoggerConfiguration`类的实例，用于配置Serilog及其输出的行为。
- en: We define the minimum log level as `Information`. This means that every event
    that is informational or above (such as warnings and errors) will be logged unless
    overridden by a specific sink.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将最小日志级别定义为`Information`。这意味着除非被特定的输出覆盖，否则所有信息性或更高级别的日志（如警告和错误）都会被记录。
- en: We notice that the `File` sink has overridden the log level in a way that only
    errors or higher severity events (such as `Fatal`) are logged.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们注意到`File`输出已经以这种方式覆盖了日志级别，即只有错误或更高严重性的事件（如`Fatal`）会被记录。
- en: We can also notice that the `File` sink has defined the location of the files
    (the `logs` folder) and the naming convention for the log files (`bookmark-.txt`).
    The dash symbol in the filename is not a misspelling but rather intentional! It
    is there because Serilog will append a unique identifier to that filename. Since
    we defined our rolling interval to be on a daily basis, Serilog will create a
    new log file every day. Hence, our log folder will contain files that will be
    named `bookmark-20240705.txt`, `bookmark-20240706.txt`, and so on.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以注意到，`File`输出已经定义了文件的位置（`logs`文件夹）和日志文件的命名约定（`bookmark-.txt`）。文件名中的破折号符号不是拼写错误，而是故意的！它在那里是因为Serilog会向该文件名追加一个唯一标识符。由于我们定义的滚动间隔是按日进行的，Serilog将每天创建一个新的日志文件。因此，我们的日志文件夹将包含名为`bookmark-20240705.txt`、`bookmark-20240706.txt`等文件。
- en: We notice that we are also explicitly telling Serilog to log to the console.
    This is because even though we added a reference to the `Serilog.Sinks.Console`
    NuGet package, we still need to tell Serilog to actually use this sink.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还注意到，我们明确告诉Serilog将日志记录到控制台。这是因为尽管我们添加了对`Serilog.Sinks.Console` NuGet包的引用，我们仍然需要告诉Serilog实际使用这个输出。
- en: Finally, we call the `CreateLogger` method so that all this configuration is
    taken into account.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`CreateLogger`方法，以便考虑所有这些配置。
- en: Configuring sinks in appsettings.json
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在appsettings.json中配置输出
- en: Although configuring the behavior of Serilog and its sinks directly in the code
    works perfectly fine, it is less flexible.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在代码中直接配置Serilog及其输出的行为是完全可以的，但这种方式不够灵活。
- en: What if we want to add a new sink or update the configuration of an existing
    one? Well, you guessed it, we need to update and redeploy the code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加一个新的输出或更新现有输出的配置呢？嗯，你已经猜到了，我们需要更新和重新部署代码。
- en: Moving this configuration into a configuration file (such as `appsettings.json`)
    brings more flexibility to our application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将此配置移动到配置文件（如`appsettings.json`）使我们的应用程序更加灵活。
- en: Let’s see how we can do this!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何做到这一点！
- en: 'We first need to add the `Serilog.Settings.Configuration` NuGet package to
    our application by typing this command into the Visual Studio Code terminal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要通过在Visual Studio Code终端中输入以下命令将`Serilog.Settings.Configuration` NuGet包添加到我们的应用程序中：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We then need to add an `appsettings.json` file to our application. This can
    easily be done by adding a new file to the project in Visual Studio Code or in
    your favorite code editor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在我们的应用程序中添加一个`appsettings.json`文件。这可以通过在Visual Studio Code或你喜欢的代码编辑器中向项目中添加新文件轻松完成。
- en: 'For the `appsettings.json` file to be deployed with our application, we need
    to ensure that its latest version is always copied to the output directory. This
    can be done in the `bookmarkr.csproj` file by adding this snippet just before
    the closing `</``Project>` element:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`appsettings.json`文件与我们的应用程序一起部署，我们需要确保其最新版本始终被复制到输出目录。这可以通过在`bookmarkr.csproj`文件中添加以下片段在`</Project>`元素之前完成：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s move the configuration of Serilog and its sinks from the code to
    the `appsettings.json` configuration file. The content of this file will then
    be the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将Serilog及其输出的配置从代码移动到`appsettings.json`配置文件。该文件的以下内容将是：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This file is easy to read and pretty self-explanatory. It describes the sinks
    to be used and their configuration and defines the minimum log level. There is
    one thing to pay attention to here, however! Notice that we have overridden the
    minimum log level for libraries of the `Microsoft` and `System` namespaces. This
    is because these libraries tend to be chatty, which may result in a large amount
    of log data that is not very useful. By setting their minimum log level to `Warning`,
    we can ensure to only capture relevant events such as warnings or errors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件很容易阅读，相当直观。它描述了要使用的输出及其配置，并定义了最小日志级别。然而，这里有一件事需要注意！请注意，我们已经覆盖了`Microsoft`和`System`命名空间库的最小日志级别。这是因为这些库往往很健谈，这可能会导致大量不太有用的日志数据。通过将它们的最低日志级别设置为`Warning`，我们可以确保只捕获相关事件，如警告或错误。
- en: The `Enrich` section is a new one, however. As the name suggests, it is there
    to enrich the log data with extra information such as the machine name and the
    thread ID. If your CLI application is intended to be executed on multiple computers
    within your organization, knowing on which machine you got the error helps you
    narrow the search area. If that application is intended to run in multiple instances
    on the same machine, the thread ID will let you know which instance logged that
    information. This can be helpful in a concurrent execution scenario.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enrich`部分是一个新的部分。正如其名所示，它在那里是为了通过添加额外的信息（如机器名和线程ID）来丰富日志数据。如果你的CLI应用程序打算在你的组织内的多台计算机上执行，知道错误发生在哪台机器上可以帮助你缩小搜索范围。如果该应用程序打算在同一台机器上的多个实例中运行，线程ID将告诉你哪个实例记录了该信息。这在并发执行场景中可能很有帮助。'
- en: Are we done?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了吗？
- en: Not exactly… We still need to update the code inside the `ConfigureServices`
    method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全是这样……我们仍然需要更新`ConfigureServices`方法内部的代码。
- en: 'Since all the configuration has been moved to the `appsettings.json` file,
    the code becomes simpler, as you can see here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有配置都已移动到`appsettings.json`文件中，代码变得更加简单，正如你在这里可以看到的：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Configuration in code or in a file?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的配置还是文件中的配置？
- en: You may be wondering whether to configure your logger in the code or in a configuration
    file. That is a great question!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道是否应该在代码中还是在配置文件中配置你的日志记录器。这是一个很好的问题！
- en: 'I personally rely on both: I configure my sinks in the code and the log level
    in the `appsettings.json` file. This way, I can ensure that my “base sinks” are
    always in use even though more may be added later.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人同时依赖两者：我在代码中配置我的输出，在`appsettings.json`文件中配置日志级别。这样，我可以确保即使以后可能添加更多，我的“基本输出”始终在使用中。
- en: This is a personal choice, however. You are, of course, welcome to use whatever
    works best for you.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个个人选择，当然，你当然可以使用对你来说最有效的方法。
- en: Keep in mind that configuration in the code takes precedence over configuration
    in the configuration file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，代码中的配置优先于配置文件中的配置。
- en: Let’s log something!
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们记录一些东西！
- en: Finally! Up to this point, all we did was configure our logger and its sinks.
    Let’s now see how this works!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后！到目前为止，我们只是配置了我们的日志记录器和其接收器。现在让我们看看它是如何工作的！
- en: Once everything is in place and well configured, logging information using Serilog
    is quite straightforward.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪并正确配置后，使用Serilog进行日志记录就相当简单了。
- en: To illustrate this, let’s take an example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们举一个例子。
- en: When we implemented the `import` command back in [*Chapter 5*](B22400_05.xhtml#_idTextAnchor068),
    if an existing bookmark was to be updated (because a bookmark with the same URL
    but a different name already existed in the list of bookmarks held by the application),
    we had no way to track the name of that conflicting bookmark before the update.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第5章*](B22400_05.xhtml#_idTextAnchor068)中实现`import`命令时，如果现有的书签需要更新（因为一个具有相同URL但不同名称的书签已经存在于应用程序持有的书签列表中），我们在更新之前无法追踪那个冲突书签的名称。
- en: If this was a piece of critical information (for compliance reasons, for example),
    logging would come in handy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一条关键信息（例如，出于合规性原因），日志记录将非常有用。
- en: We will revisit this functionality and implement logging to keep track of the
    name before and after the update, along with its URL and the date and time of
    the update.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新访问此功能并实现日志记录以跟踪更新前后的名称，以及其URL和更新的时间日期。
- en: 'The log format would then be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那么日志格式将是以下这样：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing we will do is to create a new version of the `import` method
    for the `BookmarkService` class. This new version will take a bookmark as a parameter
    and check whether a bookmark with the same URL but with a different name already
    exists in the list of bookmarks held by the application. If this is actually the
    case, it replaces the existing bookmark with the new name and then returns an
    instance of the `BookmarkConflictModel` type, which contains the original and
    updated name and the URL. If no conflict is detected, the method simply adds the
    bookmark and returns `null`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是为`BookmarkService`类创建`import`方法的新版本。这个新版本将接受一个书签作为参数，并检查是否已存在具有相同URL但名称不同的书签在应用程序持有的书签列表中。如果确实如此，它将用新名称替换现有的书签，然后返回一个包含原始和更新名称以及URL的`BookmarkConflictModel`类型的实例。如果没有检测到冲突，该方法简单地添加书签并返回`null`。
- en: 'Here is the code for this method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此方法的代码：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code of the `BookmarkConflictModel` class is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookmarkConflictModel` 类的代码如下：'
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, the code of the handler method of the `Import` command is updated to
    process each bookmark read from the file such that if a conflict is detected,
    Serilog is used to keep track of it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Import`命令的处理方法代码被更新，以处理从文件中读取的每个书签，以便在检测到冲突时使用Serilog来跟踪它。
- en: 'Here is the updated code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新的代码：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we run this program, we can see that was logged in case of a conflict:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这个程序，我们可以看到在发生冲突的情况下会记录日志：
- en: '![Figure 6.2 – Logging in case of a conflict](img/B22400_06_02.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 发生冲突时的日志记录](img/B22400_06_02.jpg)'
- en: Figure 6.2 – Logging in case of a conflict
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 发生冲突时的日志记录
- en: As we can see, this information was both logged to the console and to the file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，此信息既被记录到控制台，也被记录到文件中。
- en: We are now able to use Serilog to log important information. But what happens
    if the application is closed or is terminated? In such a situation, we can rely
    on the `CloseAndFlush` method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够使用Serilog来记录重要信息。但如果应用程序关闭或终止会发生什么？在这种情况下，我们可以依赖`CloseAndFlush`方法。
- en: Closing and gracefully disposing of Serilog
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭并优雅地处理Serilog
- en: When using Serilog, the `Log.CloseAndFlush` method is called to ensure that
    all pending log event messages are flushed out to the sinks and that the logging
    system is properly shut down. This is particularly important in applications that
    have a definite end to their life cycle, such as console applications or batch
    jobs, to make sure that no log entries are missed due to the application closing
    before the logs are fully written out.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Serilog时，会调用`Log.CloseAndFlush`方法以确保所有挂起的日志事件消息都被刷新到接收器中，并且日志系统被正确关闭。这对于有明确生命周期的应用程序尤为重要，例如控制台应用程序或批处理作业，以确保不会因为应用程序在日志完全写入之前关闭而错过任何日志条目。
- en: 'When calling this method, two things happen:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此方法时，会发生两件事：
- en: '**Close**: This sends a signal to the logging subsystem to stop accepting new
    log events. This is important to prevent any new logs from being generated after
    we have decided to shut down the logging system.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Close**：这向日志子系统发送一个信号，停止接受新的日志事件。这在我们决定关闭日志系统后，防止任何新的日志被生成非常重要。'
- en: '**Flush**: This ensures that all log events that have been captured and are
    currently buffered are written out to their respective sinks. Serilog may buffer
    events in memory for efficiency, and flushing ensures that these buffered events
    are not lost.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flush**：这确保了所有已捕获并当前缓存的日志事件都被写入它们各自的接收器。Serilog 可能为了效率而在内存中缓冲事件，而刷新操作确保这些缓冲的事件不会丢失。'
- en: I recommend calling this method when exiting the application, either by shutting
    it down or by terminating it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在退出应用程序时调用此方法，无论是通过关闭还是通过终止。
- en: 'For that matter, I always create a method (which I call `FreeSerilogLoggerOnShutdown`)
    that will subscribe to two events:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就此而言，我总是创建一个方法（我称之为 `FreeSerilogLoggerOnShutdown`），该方法将订阅两个事件：
- en: '`AppDomain.CurrentDomain.ProcessExit`: This event is raised when the process
    is about to exit, allowing us to perform cleanup tasks or save data.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDomain.CurrentDomain.ProcessExit`：当进程即将退出时，此事件被触发，允许我们执行清理任务或保存数据。'
- en: '`Console.CancelKeyPress`: This event is triggered when the user presses *Ctrl*
    + *C* or *Ctrl* + *Break*, terminating the currently running application.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Console.CancelKeyPress`：当用户按下 *Ctrl* + *C* 或 *Ctrl* + *Break* 时，此事件被触发，终止当前正在运行的应用程序。'
- en: In both cases, these subscription calls the same delegate method (which I call
    `ExecuteShutdownTasks`) that will call the `CloseAndFlush` method from Serilog.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，这些订阅调用相同的委托方法（我称之为 `ExecuteShutdownTasks`），该方法将调用 Serilog 的 `CloseAndFlush`
    方法。
- en: 'Here is the code for these two methods:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这两个方法的代码：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The call to the `FreeSerilogLoggerOnShutDown` method is the first instruction
    of the `Main` method of the `Program` class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `FreeSerilogLoggerOnShutDown` 方法的代码是 `Program` 类的 `Main` 方法的第一条指令。
- en: While this is not a book about Serilog (which, in my opinion, deserves a book
    on its own), in this section, we covered the basics, which is enough for the purpose
    of the book. If you want to find more information about Serilog, visit [https://serilog.net/](https://serilog.net/).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一本关于 Serilog 的书（在我看来，Serilog 值得一本单独的书），但在本节中，我们涵盖了基础知识，这对于本书的目的已经足够。如果你想了解更多关于
    Serilog 的信息，请访问 [https://serilog.net/](https://serilog.net/)。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we improved our CLI application, *Bookmarkr*, by adding error
    handling and logging into the application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过添加错误处理和日志记录到应用程序中，改进了我们的 CLI 应用程序 *Bookmarkr*。
- en: With error handling, we implemented graceful degradation into our CLI application.
    This means that our application is now more fault-tolerant and will not crash
    abruptly should an unexpected event occur.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过错误处理，我们在 CLI 应用程序中实现了优雅降级。这意味着我们的应用程序现在具有更高的容错性，在发生意外事件时不会突然崩溃。
- en: With logging, we can record application activities, errors, and exceptions so
    that they can be analyzed at a later point in time in order to understand the
    sequence of events that led up to that error or unexpected behavior. But logging
    also enables the monitoring of application health and performance over time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过日志记录，我们可以记录应用程序的活动、错误和异常，以便在稍后的时间点分析，以了解导致该错误或意外行为的事件的顺序。但日志记录也使得可以监控应用程序的健康状况和性能随时间的变化。
- en: In the upcoming chapter, we will see how to make our CLI application more interactive
    and user-friendly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的章节中，我们将看到如何使我们的 CLI 应用程序更加交互式和用户友好。
- en: Your turn!
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按照提供的代码进行操作是学习实践的好方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding the following features.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是挑战自己完成任务。因此，我挑战你通过添加以下功能来改进 *Bookmarkr* 应用程序。
- en: 'Task #1 – Handling errors for the Import command'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 处理导入命令的错误'
- en: If the input file cannot be accessed, or if its content cannot be deserialized,
    it is likely that the code will throw exceptions. Your mission is to identify
    what exceptions are likely to be thrown and handle them accordingly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法访问输入文件，或者其内容无法反序列化，代码可能会抛出异常。你的任务是识别可能抛出的异常，并相应地处理它们。
- en: 'Task #2 – Logging errors to a file'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #2 – 将错误记录到文件'
- en: In the previous task, the goal was to handle the exceptions. However, it might
    be useful to log the details of these exceptions to a file so we can review them
    later and use this information to improve the robustness of our application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个任务中，目标是处理异常。然而，将这些异常的详细信息记录到文件中可能很有用，这样我们可以在以后回顾它们，并利用这些信息来提高我们应用程序的健壮性。
- en: Your mission here is to use Serilog to log exception data on a daily rolling
    interval and store these log files in the `logs/errors` folder.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是使用Serilog按每日滚动间隔记录异常数据，并将这些日志文件存储在`logs/errors`文件夹中。
- en: 'You are also asked to customize the output template so that logs contain the
    following information:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你还被要求自定义输出模板，以便日志包含以下信息：
- en: Date and time of the event
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件的时间和日期
- en: The name of the machine on which the event happened
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生事件的机器名称
- en: The type of event (warning, error, and so on)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件类型（警告、错误等）
- en: The exception’s details, including its stack trace
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常的详细信息，包括其堆栈跟踪
- en: 'Part 3: Advanced Topics in CLI Application Development'
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：CLI应用程序开发的高级主题
- en: In this part, you will explore the world of interactive command-line applications,
    learning how to create engaging user experiences using libraries like `Spectre.Console`.
    You'll discover techniques for implementing rich prompts, colorful output, and
    interactive menus that enhance user interaction. Next, you'll delve into building
    modular and extensible CLI applications, focusing on architectural patterns that
    promote maintainability and scalability. This includes structuring your code and
    organizing your project into logical components. Finally, you'll learn about integrating
    external APIs and services into your CLI applications. By the end of this part,
    you'll have the skills to develop sophisticated CLI tools that can consume various
    external services and APIs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，你将探索交互式命令行应用程序的世界，学习如何使用`Spectre.Console`等库创建引人入胜的用户体验。你将发现实现丰富提示、彩色输出和增强用户交互的交互式菜单的技术。接下来，你将深入研究构建模块化和可扩展的CLI应用程序，重点关注促进可维护性和可扩展性的架构模式。这包括对你的代码进行结构化以及将你的项目组织成逻辑组件。最后，你将了解如何将外部API和服务集成到你的CLI应用程序中。到本部分结束时，你将具备开发复杂的CLI工具的技能，这些工具可以消费各种外部服务和API。
- en: 'This part has the following chapters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B22400_07.xhtml#_idTextAnchor105)*, Interactive CLI Applications*'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B22400_07.xhtml#_idTextAnchor105)*，交互式命令行应用程序*'
- en: '[*Chapter 8*](B22400_08.xhtml#_idTextAnchor120)*, Building Modular and Extensible
    CLI Applications*'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B22400_08.xhtml#_idTextAnchor120)*，构建模块化和可扩展的CLI应用程序*'
- en: '[*Chapter 9*](B22400_09.xhtml#_idTextAnchor136)*, Working with External APIs
    and Services*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B22400_09.xhtml#_idTextAnchor136)*，与外部API和服务协作*'
