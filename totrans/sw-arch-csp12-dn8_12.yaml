- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Choosing Your Data Storage in the Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中选择您的数据存储
- en: Azure, like other clouds, offers a wide range of storage services. The first
    approach that we may consider is defining a scalable set of virtual machines hosted
    in the cloud where we can implement our custom solutions. For instance, we can
    create a SQL Server cluster on our cloud-hosted virtual machines to increase reliability
    and computational power. However, usually, custom architectures are not the optimal
    solution and do not take full advantage of the opportunities offered by cloud
    infrastructure. Scalability, fast setup, focus on the business, and security are
    some of the criteria that you might consider while deciding on your data storage
    on Azure. To help you with this, many of the **platform-as-a-service** (**PaaS**)
    options for storing data can be a great solution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Azure，像其他云一样，提供了一系列的存储服务。我们可能考虑的第一种方法是在云中定义一组可扩展的虚拟机，我们可以在这些虚拟机上实现我们的自定义解决方案。例如，我们可以在云托管的虚拟机上创建一个SQL
    Server集群，以增加可靠性和计算能力。然而，通常，自定义架构不是最佳解决方案，也没有充分利用云基础设施的机会。可扩展性、快速设置、关注业务和安全性是在Azure上决定您的数据存储时可能考虑的一些标准。为了帮助您，许多**平台即服务**（**PaaS**）的数据存储选项可以是一个很好的解决方案。
- en: Therefore, this chapter will not discuss such custom architectures but will
    focus mainly on the various PaaS storage offerings that are available in the cloud
    and on Azure. These offerings include scalable solutions based on plain disk space,
    relational databases, NoSQL databases, and in-memory data stores such as Redis.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将不会讨论此类自定义架构，而将主要关注云和Azure中可用的各种PaaS存储服务。这些服务包括基于普通磁盘空间的可扩展解决方案、关系型数据库、NoSQL数据库以及如Redis这样的内存数据存储。
- en: Choosing a more adequate storage type is based not only on the application’s
    functional requirements but also on performance and scaling-out requirements.
    In fact, while scaling out when processing resources causes a linear increase
    in performance, scaling out storage resources does not necessarily imply an acceptable
    increase in performance. In short, no matter how much you duplicate your data
    storage devices, if several requests affect the same chunk of data, they will
    always queue for the same amount of time to access it!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 选择更合适的存储类型不仅基于应用程序的功能需求，还基于性能和扩展需求。实际上，在处理资源进行扩展时会导致性能线性增长，但扩展存储资源并不一定意味着性能的合理增长。简而言之，无论您复制多少数据存储设备，如果多个请求影响相同的数据块，它们将始终排队相同的时间来访问它！
- en: Scaling out data causes linear increases in read operation throughput since
    each copy can serve a different request, but it doesn’t imply the same increase
    in throughput for write operations since all copies of the same chunk of data
    must be updated! Accordingly, more sophisticated techniques are required to scale
    out storage devices, and not all storage engines scale equally well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展数据会导致读取操作吞吐量线性增长，因为每个副本可以服务不同的请求，但并不意味着写入操作吞吐量有相同的增长，因为同一数据块的所有副本都必须更新！因此，需要更复杂的技术来扩展存储设备，并且并非所有存储引擎的扩展性都相同。
- en: Relational databases do not scale well in all scenarios. Therefore, scaling
    needs and the need to distribute data geographically play a fundamental role in
    the choice of a storage engine, as well as in the choice of SaaS offering.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库在所有场景下扩展性都不好。因此，扩展需求和地理分布数据的需求在存储引擎的选择以及SaaS服务的选择中起着根本的作用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the different repositories for different purposes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同目的的不同存储库
- en: Choosing between SQL and NoSQL document-oriented databases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SQL和NoSQL文档型数据库之间进行选择
- en: Azure Cosmos DB – an opportunity to manage a multi-continental database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Cosmos DB – 管理跨大陆数据库的机会
- en: Let us get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires that you have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您具备以下条件：
- en: Visual Studio 2022 free Community edition or better, with all the database tool
    components installed.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022免费社区版或更高版本，并安装所有数据库工具组件。
- en: A free Azure account. The *Creating an Azure account* subsection in *Chapter
    1*, *Understanding the Importance of Software Architecture*, explains how to create
    one.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的Azure账户。*第一章*，“理解软件架构的重要性”中的*创建Azure账户*小节解释了如何创建一个。
- en: For a better development experience, we advise that you also install the local
    emulator of Cosmos DB, which can be found at [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获得更好的开发体验，我们建议您还安装 Cosmos DB 的本地模拟器，该模拟器可在[https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator)找到。
- en: You can find the sample code for the chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)找到该章节的示例代码。
- en: Understanding the different repositories for different purposes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同目的的不同存储库
- en: This section describes the functionalities that are offered by the most popular
    data storage techniques. We will mainly focus on the functional requirements they
    are able to satisfy. Performance and scaling-out features will be analyzed in
    the next section, which is dedicated to comparing relational and NoSQL databases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了最流行的数据存储技术提供的功能。我们将主要关注它们能够满足的功能需求。性能和扩展功能将在下一节中分析，该节专门用于比较关系型数据库和 NoSQL
    数据库。
- en: In Azure, the various offerings can be found by typing product names into the
    search bar at the top of all Azure portal pages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 中，您可以通过在所有 Azure 门户页面顶部的搜索栏中输入产品名称来找到各种产品。
- en: The following subsections describe the various kinds of databases that we can
    use in our C# projects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节描述了我们可以用于我们的 C# 项目的各种数据库类型。
- en: Relational databases
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: These databases are the most common and studied type of storage. They guarantee
    a high level of service and store an immeasurable amount of data. Dozens of applications
    have been designed to store data in this kind of database, and we can find them
    in banks, stores, industries, and so on. When you store data in a relational database,
    the basic principle is to define the entities and properties you will save in
    each of them, defining the correct relationship between these entities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据库是最常见和被研究的数据存储类型。它们保证高服务水平并存储了无法衡量的数据量。数十个应用程序被设计用于存储此类数据库中的数据，我们可以在银行、商店、工业等领域找到它们。当您在关系型数据库中存储数据时，基本原则是定义您将在其中保存的实体和属性，并定义这些实体之间正确的关联关系。
- en: For decades, relational databases were the only option imagined for designing
    great projects. Many big companies around the world have built their own database
    management system. Oracle, MySQL, and MS SQL Server would be listed by many as
    the ones you can trust to store your data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，关系型数据库是设计优秀项目的唯一想象选项。世界上许多大公司都建立了自己的数据库管理系统。Oracle、MySQL 和 MS SQL Server
    被许多人列为可以信赖来存储数据的数据库。
- en: Usually, clouds offer several database engines. Azure offers a variety of popular
    database engines, such as Oracle, MySQL, PostgreSQL, and SQL Server (Azure SQL).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，云提供多种数据库引擎。Azure 提供了各种流行的数据库引擎，例如 Oracle、MySQL、PostgreSQL 和 SQL Server（Azure
    SQL）。
- en: Regarding the Oracle database engine, Azure offers configurable virtual machines
    with various Oracle editions installed on them, which you can easily verify by
    the suggestions you get after typing `Oracle` into the Azure portal search bar.
    Azure fees do not include Oracle licenses; they just include computation time,
    so you must bring your own license to Azure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Oracle 数据库引擎，Azure 提供了预装了各种 Oracle 版本的配置虚拟机，您可以通过在 Azure 门户搜索栏中输入“Oracle”后得到的建议轻松验证。Azure
    费用不包括 Oracle 许可证；它们仅包括计算时间，因此您必须将许可证带到 Azure。
- en: With MySQL on Azure, you pay to use a private server instance. The fees you
    incur depend on the number of cores you have, how much memory must be allocated,
    and backup retention time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 上使用 MySQL，您需要为使用私有服务器实例付费。您产生的费用取决于您拥有的核心数量、必须分配多少内存以及备份保留时间。
- en: 'MySQL instances are redundant, and you can choose between local or geographically
    distributed redundancy:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 实例是冗余的，您可以选择本地或地理分布式的冗余：
- en: '![](img/B19820_12_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_12_01.png)'
- en: 'Figure 12.1: Creating a MySQL server on Azure'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：在 Azure 上创建 MySQL 服务器
- en: Azure SQL Database was one of the first PaaS options available on Azure, and
    for this reason, it has evolved a lot in recent years, which has made it one of
    the most flexible offers. Today, it also includes a serverless pricing model,
    where you are billed for the compute used per second. Here, you can configure
    resources that are used by every single database. When you create a database,
    you have the option to place it on an existing server instance or create a new
    instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Azure SQL 数据库是 Azure 上最早可用的 PaaS 选项之一，因此近年来它发展了很多，这使得它成为最灵活的提供之一。今天，它还包括一种无服务器定价模型，您将按每秒使用的计算量计费。在这里，您可以配置每个数据库使用的资源。当您创建数据库时，您可以选择将其放置在现有的服务器实例上或创建一个新的实例。
- en: There are several pricing options that you may choose while defining your solution,
    and Azure keeps incrementing them to make sure you will be able to handle your
    data in the cloud. Basically, they vary due to the computing capacity you need.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义解决方案时，您可以选择几种定价选项，Azure 会不断增加这些选项以确保您能够处理云中的数据。基本上，它们因您所需的计算能力而有所不同。
- en: For instance, in the **Database Transaction Units** (**DTUs**) model, fees are
    based on the database storage capacity that has been reserved and a linear combination
    of I/O operations, CPU usage, and memory usage that is determined by a reference
    workload. Considering the difficulty of understanding exactly how DTUs are calculated,
    Azure also offers **vCore-based** models, where you have flexibility, control,
    and transparency of individual resource consumption.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在**数据库事务单元（DTUs）**模型中，费用基于已预留的数据库存储容量以及由参考工作负载确定的线性组合的 I/O 操作、CPU 使用率和内存使用率。考虑到理解
    DTUs 精确计算方法的难度，Azure 还提供了基于**核心（vCore）**的模型，您在这里拥有灵活性、控制和透明度，可以单独监控资源消耗。
- en: Roughly, maximal database performance increases linearly when you increase the
    DTUs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，当您增加 DTUs（数据库事务单元）时，数据库的最大性能会线性增加。
- en: You can find detailed information about the options you have for purchasing
    Azure SQL Database at [https://learn.microsoft.com/en-us/azure/azure-sql/database/purchasing-models?view=azuresql](https://learn.microsoft.com/en-us/azure/azure-sql/database/purchasing-models?view=azuresql).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://learn.microsoft.com/en-us/azure/azure-sql/database/purchasing-models?view=azuresql](https://learn.microsoft.com/en-us/azure/azure-sql/database/purchasing-models?view=azuresql)找到有关您购买
    Azure SQL 数据库的选项的详细信息。
- en: '![](img/B19820_12_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_12_02.png)'
- en: 'Figure 12.2: Creating an Azure SQL Database'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：创建 Azure SQL 数据库
- en: You can also configure data replication by enabling read scale-out. This way,
    you can improve the performance of read operations. Backup retention is fixed
    for each offering level (basic, standard, and premium).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过启用读取扩展来配置数据复制。这样，您可以提高读取操作的性能。备份保留期对于每个提供级别（基本、标准和高级）是固定的。
- en: If you select **Yes** for **Want to use SQL elastic pool?**, the database will
    be added to an elastic pool. Databases that are added to the same elastic pool
    will share their resources, so resources that are not used by a database can be
    used during the usage CPU peaks of other databases. It is worth mentioning that
    elastic pools can only contain databases hosted on the same server instance. Elastic
    pools are an efficient way to optimize resource usage to reduce costs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择**是**以**是否要使用 SQL 弹性池？**，则数据库将被添加到弹性池中。添加到同一弹性池的数据库将共享其资源，因此未被数据库使用的资源可以在其他数据库使用
    CPU 峰值期间使用。值得一提的是，弹性池只能包含托管在同一服务器实例上的数据库。弹性池是优化资源使用以降低成本的有效方式。
- en: NoSQL databases
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL 数据库
- en: One of the biggest challenges that relational databases have caused software
    architects is related to how we deal with database structural schema changes.
    The agility of changes needed at the beginning of this century brought the opportunity
    to use a new database style called NoSQL. The next subtopics will present several
    types of NoSQL databases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库给软件架构师带来的最大挑战之一与我们如何处理数据库结构模式变化有关。本世纪初所需的变化敏捷性带来了使用一种名为 NoSQL 的新数据库风格的机会。接下来的子主题将介绍几种类型的
    NoSQL 数据库。
- en: Document-oriented database
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档型数据库
- en: The most common type of database, where you have the key and complex data, is
    called a document.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的数据库类型，其中包含键和复杂数据，被称为文档。
- en: For instance, in NoSQL document-oriented databases, relational tables are replaced
    with more general collections that can contain heterogeneous JSON objects. That
    is, collections have no predefined structure and no predefined fields with length
    constraints (in the case of strings) but can contain any type of object. The only
    structural constraint associated with each collection is the name of the property
    that acts as a primary key.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在NoSQL文档型数据库中，关系型表被更通用的集合所取代，这些集合可以包含异构的JSON对象。也就是说，集合没有预定义的结构，也没有预定义的字段长度限制（在字符串的情况下），但可以包含任何类型的对象。与每个集合相关联的唯一结构约束是作为主键的属性名称。
- en: More specifically, each collection entry can contain nested objects and object
    collections nested in object properties, that is, related entities that, in relational
    databases, are contained in different tables and connected through external keys.
    In NoSQL, databases can be nested in their parent entities. Since collection entries
    contain complex nested objects instead of simple property/value pairs, as is the
    case with relational databases, entries are not called tuples or rows but *documents*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，每个集合条目可以包含嵌套对象和嵌套在对象属性中的对象集合，即相关实体，在关系型数据库中，这些实体包含在不同的表中并通过外部键连接。在NoSQL中，数据库可以嵌套在其父实体中。由于集合条目包含复杂的嵌套对象，而不是像关系型数据库那样简单的属性/值对，因此条目不被称为元组或行，而是*文档*。
- en: No relations and/or external key constraints can be defined between documents
    that belong to the same collection or to different collections. If a document
    contains the primary key of another document in one of its properties, it does
    so at its own risk. The developer is responsible for maintaining and keeping these
    coherent references. This is a tradeoff that you, as a software architect, must
    analyze. If you design a system that is generally dependent on relational databases,
    the gain of NoSQL will not be achieved, and you are at the same time sacrificing
    data integrity and redundancy. However, if you have a scenario where flexibility
    is needed, you must consider NoSQL as an option.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一集合或不同集合的文档之间不能定义任何关系和/或外部键约束。如果一个文档在其属性中包含另一个文档的主键，那么它这样做是承担风险的。开发者负责维护和保持这些引用的一致性。这是你必须分析的一个权衡。如果你设计的是一个通常依赖于关系型数据库的系统，那么你将无法实现NoSQL的优势，同时你也在牺牲数据完整性和冗余。然而，如果你有一个需要灵活性的场景，你必须考虑将NoSQL作为一个选项。
- en: Finally, NoSQL storage is quite cheap. You can store a great amount of data
    as Base64 string properties. The developer can define rules to decide what properties
    to index in a collection. Since documents are nested objects, properties are tree
    paths. It is worth saying that you can specify which collection of paths and subpaths
    are indexed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，NoSQL存储相当便宜。你可以将大量数据作为Base64字符串属性存储。开发者可以定义规则来决定在集合中索引哪些属性。由于文档是嵌套对象，属性是树路径。值得一提的是，你可以指定哪些路径集合和子路径被索引。
- en: Almost all NoSQL databases are queried either with a subset of SQL or with a
    JSON-based language where queries are JSON objects whose paths represent the properties
    to query and whose values represent the query constraints that have been applied
    to them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的NoSQL数据库都使用SQL的子集或基于JSON的语言进行查询，其中查询是JSON对象，其路径表示要查询的属性，其值表示已应用于它们的查询约束。
- en: The possibility of nesting children objects inside documents can be simulated
    in relational databases with the help of one-to-many relationships. However, with
    relational databases, we are forced to redefine the exact structure of all the
    related tables, while NoSQL collections do not impose any predefined structure
    on the objects they contain. The only constraint is that each document must provide
    a unique value for the primary key property.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，可以通过一对多关系使用嵌套子对象的可能性。然而，在使用关系型数据库时，我们被迫重新定义所有相关表的确切结构，而NoSQL集合不对它们包含的对象施加任何预定义的结构。唯一的约束是每个文档必须为主键属性提供一个唯一的值。
- en: It is true that today, we have the possibility to define JSON columns in relational
    databases such as Azure SQL, so we can take a hybrid approach when defining our
    data model, having a schema for part of it but being flexible on other parts of
    it. However, NoSQL databases continue to be the best option when the structure
    of our objects is extremely variable, like social media and **Internet of Things**
    (**IoT**) solutions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，今天我们可以在像Azure SQL这样的关系数据库中定义JSON列，因此我们可以在定义我们的数据模型时采取混合方法，部分有模式，其他部分则灵活。然而，当我们的对象结构极其多变时，如社交媒体和**物联网**（**IoT**）解决方案，NoSQL数据库仍然是最佳选择。
- en: However, often, they are chosen for the way they scale out read and write operations
    and, more generally, for their performance advantages in distributed environments.
    Their performance features, which compare them to relational databases, will be
    discussed in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们通常是因为它们在扩展读写操作和更普遍地，在分布式环境中的性能优势而被选择的。它们与关系数据库相比的性能特性将在下一节中讨论。
- en: Graph database
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图数据库
- en: Social media sites tend to use this kind of database since the data is stored
    as graphs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 社交媒体网站倾向于使用这种类型的数据库，因为数据是以图的形式存储的。
- en: The graph data model is an extreme case of a completely unstructured document.
    The whole database is a graph where queries can add, change, and delete graph
    documents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据模型是完全非结构化文档的极端情况。整个数据库是一个图，查询可以在其中添加、更改和删除图文档。
- en: 'In this case, we have two kinds of documents: nodes and relationships. While
    relationships have a well-defined structure (the primary key of the nodes connected
    by the relationship, plus the relationship’s name), nodes have no structure at
    all since properties and their values are added together during node update operations.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两种类型的文档：节点和关系。虽然关系有一个定义良好的结构（通过关系连接的节点的主键，加上关系名称），但节点完全没有结构，因为属性及其值在节点更新操作中一起添加。
- en: It is important to you, as a software architect, to decide if this kind of structure
    presented in graph databases is the best one for the use case for which you are
    designing the system, always remembering that such a decision can make the system
    more complicated than needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你作为软件架构师来说，决定这种在图数据库中展示的结构是否最适合你正在设计的系统的用例是很重要的，始终记住这样的决定可能会使系统比所需的更复杂。
- en: Graph data models were conceived to represent the features of people and the
    objects they manipulate (media, posts, and so on), along with their relationships
    in *social applications*. The Gremlin language was conceived specifically to query
    graph data models. We will not discuss this in this chapter, but references are
    available in the *Further reading* section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据模型是为了表示人们及其操作的对象（媒体、帖子等）的特征以及他们在**社交应用**中的关系而设计的。Gremlin语言是为了查询图数据模型而专门设计的。我们将在本章中不讨论这一点，但在**进一步阅读**部分有相关参考。
- en: Key-value database
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键值数据库
- en: This is a useful database for implementing caches since you can store key-value
    pairs. Redis is a great example of it and it will be detailed soon in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的数据库，用于实现缓存，因为你可以存储键值对。Redis是它的一个很好的例子，将在本章中详细说明。
- en: Wide-column store database
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宽列存储数据库
- en: This is a type of database where the same column in each row can store different
    data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种数据库，其中每行的相同列可以存储不同的数据。
- en: NoSQL databases will be analyzed in detail in the remaining sections of this
    chapter, which are dedicated to describing Azure Cosmos DB and comparing it with
    relational databases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余的部分，我们将详细分析NoSQL数据库，这些部分专门用于描述Azure Cosmos DB并将其与关系数据库进行比较。
- en: Redis
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: Redis is a distributed in-memory storage based on key-value pairs and supports
    distributed queuing. It can be used as permanent in-memory storage and as a web
    application cache for database data. Alternatively, it can be used as a cache
    for pre-rendered content.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一种基于键值对的分布式内存存储，支持分布式队列。它可以作为永久性内存存储和数据库数据的Web应用程序缓存使用。或者，它可以用作预渲染内容的缓存。
- en: Redis can also be used to store a web application’s user session data. This
    was done originally with Microsoft SQL Server, but due to the performance provided
    by memory databases, Redis is the best alternative today.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Redis也可以用来存储Web应用程序的用户会话数据。这最初是用Microsoft SQL Server完成的，但由于内存数据库提供的性能，Redis现在是最佳替代品。
- en: In fact, ASP.NET Core supports session data to overcome the fact that the HTTP
    protocol is stateless. More specifically, user data that is kept between page
    changes is maintained in server-side stores such as Redis and indexed by a session
    key stored in cookies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，ASP.NET Core支持会话数据以克服HTTP协议无状态的事实。更具体地说，用户数据在页面变化之间保持，存储在Redis等服务器端存储中，并通过存储在cookie中的会话键进行索引。
- en: Interaction with the Redis server in the cloud is typically based on a client
    implementation that offers an easy-to-use interface. The client for .NET is available
    through the `StackExchange.Redis` NuGet package. The basic operations of the `StackExchange.Redis`
    clients have been documented in [https://stackexchange.github.io/StackExchange.Redis/Basics](https://stackexchange.github.io/StackExchange.Redis/Basics),
    while the full documentation can be found at [https://stackexchange.github.io/StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与云中的Redis服务器交互通常基于提供易于使用界面的客户端实现。.NET客户端通过`StackExchange.Redis` NuGet包提供。`StackExchange.Redis`客户端的基本操作已在[https://stackexchange.github.io/StackExchange.Redis/Basics](https://stackexchange.github.io/StackExchange.Redis/Basics)中记录，而完整文档可在[https://stackexchange.github.io/StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis)找到。
- en: 'The user interface for defining a Redis server on Azure is quite simple:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure上定义Redis服务器的用户界面相当简单：
- en: '![](img/B19820_12_03.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_12_03.png)'
- en: 'Figure 12.3: Creating a Redis cache'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：创建Redis缓存
- en: The **Pricing tier** dropdown allows us to select one of the available memory/replication
    options. A quick-start guide that explains how to use Azure Redis credentials
    and the URI with the `StackExchange.Redis` .NET client can be found at [https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**定价层**下拉菜单允许我们选择可用的内存/复制选项之一。有关如何使用Azure Redis凭据和`StackExchange.Redis` .NET客户端的快速入门指南，请参阅[https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart)。'
- en: Azure storage accounts
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure存储账户
- en: All clouds offer scalable and redundant general-purpose disk memory that you
    can use as virtual disks in virtual machines and/or as external file storage.
    Azure *storage account* disk space can also be structured in **tables** and **queues**.
    Consider using this option if you need cheap blob storage. However, there are
    more sophisticated options, as we have mentioned before. Depending on the scenario
    you have, Azure NoSQL databases are a better option than tables, and Azure Redis
    is a better option than Azure storage queues.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有云都提供可扩展和冗余的通用磁盘内存，你可以将其用作虚拟机中的虚拟磁盘或作为外部文件存储。Azure *存储账户*磁盘空间也可以在**表**和**队列**中进行结构化。如果你需要廉价的blob存储，请考虑使用此选项。然而，正如我们之前提到的，还有更复杂的选择。根据你的场景，Azure
    NoSQL数据库比表是一个更好的选择，而Azure Redis比Azure存储队列是一个更好的选择。
- en: '![](img/B19820_12_04.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_12_04.png)'
- en: 'Figure 12.4: Creating a storage account'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：创建存储账户
- en: In the rest of this chapter, we will focus on NoSQL databases and how they differ
    from relational databases. Next, we will look at how to choose one over the other.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将重点关注NoSQL数据库以及它们与关系数据库的不同之处。接下来，我们将探讨如何选择其中之一。
- en: Choosing between SQL and NoSQL document-oriented databases
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SQL和NoSQL面向文档的数据库之间进行选择
- en: As a software architect, you may consider some aspects of SQL and NoSQL databases
    to decide the best storage option for you. In many cases, both will be needed.
    The key point here will surely be how organized your data is and how big the database
    will become.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，你可能需要考虑SQL和NoSQL数据库的一些方面，以决定最适合你的存储选项。在许多情况下，两者都将被需要。这里的关键点无疑将是你的数据组织程度以及数据库将变得多大。
- en: In the previous section, we stated that NoSQL document-oriented databases should
    be preferred by you, as a software architect, when data has almost no predefined
    structure. They not only keep variable attributes close to their owners, but they
    also keep some related objects close since they allow related objects to be nested
    inside properties and collections.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到，作为软件架构师，当数据几乎没有任何预定义结构时，你应该优先考虑使用NoSQL面向文档的数据库。它们不仅将可变属性与其所有者保持紧密，而且由于允许相关对象嵌套在属性和集合中，它们还将一些相关对象保持在一起。
- en: Unstructured data can be represented in relational databases if variable properties
    of a tuple (`t`) can be placed in a connected table containing the property name,
    property value, and the external key of `t`. However, the problem in this scenario
    is performance. In fact, property values that belong to a single object would
    be spread all over the available memory space. In a small database, *all over
    the available memory space* means far away but on the same disk; in a bigger database,
    it means far away but in different disk units; in a distributed cloud environment,
    it means far away but in different – and possibly geographically distributed –
    servers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 非结构化数据可以通过将元组（`t`）的变量属性放置在一个包含属性名称、属性值和`t`的外部键的连接表中，在关系数据库中表示。然而，在这种场景下的问题是性能。实际上，属于单个对象的属性值会散布在可用的内存空间中。在一个小型数据库中，“散布在可用的内存空间中”意味着距离较远但位于同一磁盘上；在一个大型数据库中，意味着距离较远但位于不同的磁盘单元中；在分布式云环境中，意味着距离较远但位于不同——并且可能是地理上分布的——服务器上。
- en: On the other hand, in the NoSQL document-oriented database design, we always
    try to put all related objects that are likely to be processed together into a
    single entry. Related objects that are accessed less frequently are placed in
    different entries. Since external key constraints are not enforced automatically,
    and NoSQL transactions are very flexible, the developer can choose the best compromise
    between performance and coherence.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在NoSQL文档型数据库设计中，我们总是试图将所有可能一起处理的关联对象放入单个条目中。访问频率较低的相关对象被放置在不同的条目中。由于外部键约束不是自动执行的，并且NoSQL事务非常灵活，开发者可以在性能和一致性之间选择最佳折衷方案。
- en: It is important to mention that today, we can store unstructured data as columns
    with JSON (or XML) types in relational databases. This approach allows the use
    of patterns typically implemented in document databases to also be achievable
    in relational databases, such as avoiding joins by inserting complete objects
    in a JSON column. However, the adoption of the NoSQL document-oriented database
    can be considered the best option since it was designed for this purpose.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，今天，我们可以在关系数据库中将非结构化数据作为具有JSON（或XML）类型的列存储。这种方法允许在关系数据库中实现通常在文档数据库中实现的模式，例如通过在JSON列中插入完整对象来避免连接。然而，考虑到它是为此目的而设计的，采用NoSQL文档型数据库可以被认为是最佳选择。
- en: Therefore, we can conclude that relational databases perform well when tables
    that are usually accessed together can be stored close together. NoSQL document-oriented
    databases, on the other hand, automatically ensure that related data is kept close
    together since each entry keeps most of the data it is related to inside it as
    nested objects. Therefore, NoSQL document-oriented databases perform better when
    they are distributed to a different memory and to different geographically distributed
    servers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，当通常一起访问的表可以存储在一起时，关系数据库表现良好。另一方面，NoSQL文档型数据库自动确保相关数据保持在一起，因为每个条目都将其相关的大部分数据作为嵌套对象包含在内。因此，当NoSQL文档型数据库分布到不同的内存和地理上分布的服务器时，它们的表现更好。
- en: Unfortunately, the only way to scale out storage write operations is to split
    collection entries across several servers according to the values of *shard keys*.
    For instance, we can place all the records containing usernames that start with
    **A** on a server, the records containing usernames that start with **B** on another
    server, and so on. This way, write operations for usernames with different start
    letters may be executed in parallel, ensuring that the write throughput increases
    linearly with the number of servers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，扩展存储写操作的唯一方法是根据分片键的值将集合条目分散到几个服务器上。例如，我们可以将所有以**A**开头的用户名记录放在一个服务器上，以**B**开头的用户名记录放在另一个服务器上，依此类推。这样，不同起始字母的用户名的写操作可以并行执行，确保写吞吐量随着服务器数量的线性增长。
- en: However, if a *shard* collection is related to several other collections, there
    is no guarantee that related records will be placed on the same server. Also,
    putting different collections on different servers without using collection sharding
    increases write throughput linearly until we reach the limit of a single collection
    per server, but it doesn’t solve the issue of being forced to perform several
    operations on different servers to retrieve or update data that are usually processed
    together.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个**分片**集合与几个其他集合相关联，不能保证相关记录会被放置在同一个服务器上。此外，在不使用集合分片的情况下，将不同的集合放在不同的服务器上，可以线性地增加写入吞吐量，直到达到每个服务器单个集合的限制，但这并不能解决被迫在多个服务器上执行多个操作以检索或更新通常一起处理的数据的问题。
- en: This issue becomes catastrophic for performance in relational databases if access
    to related distributed objects must be transactional and/or must ensure structural
    constraints (such as external key constraints) are not violated. In this case,
    all related objects must be blocked during the transaction, preventing other requests
    from accessing them during the whole lifetime of a time-consuming distributed
    operation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须以事务方式访问相关分布式对象，并且/或者必须确保结构约束（如外键约束）不被违反，这个问题在关系数据库中会对性能造成灾难性的影响。在这种情况下，所有相关对象必须在事务期间被阻塞，防止其他请求在整个耗时的分布式操作期间访问它们。
- en: NoSQL document-oriented databases do not suffer from this problem and perform
    better with sharding and, consequently, with write-scaled output. This is because
    they do not distribute related data to different storage units and instead store
    them as nested objects of the same database entry. On the other hand, they suffer
    from different problems, like not supporting transactions by default.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 文档型数据库不会受到这个问题的影响，并且通过分片以及随之而来的写入扩展输出表现更好。这是因为它们不会将相关数据分布到不同的存储单元，而是将它们存储为同一数据库条目中的嵌套对象。另一方面，它们也面临着不同的问题，例如默认不支持事务。
- en: It is worth mentioning that there are situations where relational databases
    perform well with sharding. A typical instance is a multi-tenant application.
    In a multi-tenant application, all entry collections can be partitioned into non-overlapping
    sets called **tenants**. Only entries belonging to the same tenant can refer to
    each other, so if all the collections are sharded in the same way according to
    their object tenants, all related records end up in the same shard, that is, in
    the same server, and can be navigated efficiently.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在某些情况下，关系数据库通过分片表现良好。一个典型的例子是多租户应用程序。在多租户应用程序中，所有条目集合可以被划分为非重叠的集合，称为**租户**。只有属于同一租户的条目可以相互引用，因此如果所有集合都根据它们的对象租户以相同的方式分片，所有相关记录最终都会落在同一个分片中，即同一个服务器上，并且可以有效地进行导航。
- en: 'In this chapter, we did not talk about how to define sharding with Azure SQL.
    Here is the link to the official documentation if you want to find out more: [https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们没有讨论如何使用 Azure SQL 定义分片。如果您想了解更多信息，请参阅官方文档链接：[https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction).
- en: 'Multi-tenant applications are not rare in the cloud since all applications
    that offer the same services to several different users are often implemented
    as multi-tenant applications, where each tenant corresponds to a user subscription.
    Accordingly, relational databases, such as Azure SQL Server, are conceived to
    work in the cloud and usually offer sharding options for multi-tenant applications.
    Typically, sharding is not a cloud service and must be defined with database engine
    commands. Here, we will not describe how to define shards with Azure SQL Server,
    but the *Further reading* section contains a link to the official Microsoft documentation.
    The following table presents the pros and cons of each database approach:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中，多租户应用程序并不罕见，因为向多个不同用户提供相同服务的所有应用程序通常都作为多租户应用程序实现，其中每个租户对应一个用户订阅。因此，关系数据库，如
    Azure SQL Server，旨在在云中工作，通常为多租户应用程序提供分片选项。通常，分片不是一个云服务，必须使用数据库引擎命令来定义。在这里，我们不会描述如何使用
    Azure SQL Server 定义分片，但“进一步阅读”部分包含了一个指向官方微软文档的链接。以下表格展示了每种数据库方法的优缺点：
- en: '| **Subject** | **SQL** | **NoSQL document-oriented DB** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **主题** | **SQL** | **NoSQL 文档型数据库** |'
- en: '| Schema | Easy to deal with in well-structured schemas. Today, it is possible
    to design hybrid solutions with JSON/XML columns to store unstructured data. |
    Preferred when data has almost no predefined structure. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 架构 | 在结构良好的模式中易于处理。今天，可以通过设计具有 JSON/XML 列的混合解决方案来存储非结构化数据。 | 当数据几乎没有任何预定义结构时更受欢迎。
    |'
- en: '| Performance | In general, bad performance in distributed environments. |
    In general, good performance for reading and writing distributed data. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 通常在分布式环境中性能较差。 | 通常在读取和写入分布式数据时性能良好。 |'
- en: '| Language | Declarative to query and update data, standard. | Procedural to
    query and update operations. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | 使用声明性语言查询和更新数据，标准。 | 使用过程性语言查询和更新操作。 |'
- en: '| Consistency | Strong use of foreign keys. | Weak and left to the developer''s
    decision. All related objects that are likely to be processed together into a
    single entry. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 一致性 | 强制使用外键。 | 弱，留给开发者的决定。所有可能一起处理到单个条目中的相关对象。 |'
- en: '| Transactions | Supported. | By default, they are not supported. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 事务 | 支持。 | 默认情况下，不支持。 |'
- en: '| Scale | Vertically upgrading hardware. | Horizontally with data sharding.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 缩放 | 垂直升级硬件。 | 水平扩展数据分片。 |'
- en: 'Table 12.1: Pros and cons for each database approach'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1：每种数据库方法的优缺点
- en: In conclusion, relational databases offer a pure, logical view of data that
    is independent of the way they are stored and use declarative language to query
    and update them. This simplifies development and system maintenance, but it may
    cause performance issues in a distributed environment that requires write scale-out.
    It is also worth noting that tools like Entity Framework, presented in *Chapter
    13*, *Interacting with Data in C# – Entity Framework Core*, help in bridging the
    gap between objects and relational data, making development more intuitive for
    relational databases.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，关系数据库提供了独立于存储方式的数据的纯粹逻辑视图，并使用声明性语言查询和更新它们。这简化了开发和系统维护，但在需要写入扩展的分布式环境中可能会引起性能问题。值得注意的是，*第
    13 章*中介绍的 Entity Framework 等工具有助于在对象和关系数据之间架起桥梁，使关系数据库的开发更加直观。
- en: In NoSQL document-oriented databases, you must handle more details about how
    to store data, as well as some procedural details for all the update and query
    operations, manually, but this allows you to optimize performance in distributed
    environments that require both read and write scale-out. On the flip side, working
    with NoSQL data, especially when it involves deserializing formats like JSON or
    XML, can be tricky. It often requires careful mapping to ensure data integrity,
    which can be both challenging and error-prone. In the next section, we will look
    at Azure Cosmos DB, the main Azure NoSQL offering, which, fortunately, can be
    integrated with Entity Framework for a more streamlined development experience.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NoSQL 文档型数据库中，您必须手动处理有关如何存储数据的更多细节，以及所有更新和查询操作的一些过程性细节，但这允许您在需要读取和写入扩展的分布式环境中优化性能。另一方面，处理
    NoSQL 数据，尤其是涉及 JSON 或 XML 等反序列化格式时，可能会很棘手。这通常需要仔细映射以确保数据完整性，这可能既具有挑战性又容易出错。在下一节中，我们将探讨
    Azure Cosmos DB，这是 Azure 的主要 NoSQL 产品，幸运的是，它可以与 Entity Framework 集成，以获得更流畅的开发体验。
- en: Azure Cosmos DB – an opportunity to manage a multi-continental database
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Cosmos DB – 管理跨大陆数据库的机会
- en: Azure Cosmos DB is Azure’s main NoSQL offering. Azure Cosmos DB has its own
    interface that is a subset of SQL, but it can be configured with a MongoDB interface,
    a Table API, or a Cassandra API. It can also be configured as a graph data model
    that can be queried with Gremlin.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos DB 是 Azure 的主要 NoSQL 产品。Azure Cosmos DB 拥有自己独特的接口，它是 SQL 的子集，但可以配置为使用
    MongoDB 接口、Table API 或 Cassandra API。它还可以配置为图数据模型，可以使用 Gremlin 进行查询。
- en: 'You can find further details about Cosmos DB in the official documentation:
    [https://docs.microsoft.com/en-us/azure/cosmos-db/](https://docs.microsoft.com/en-us/azure/cosmos-db/).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到有关 Cosmos DB 的更多详细信息：[https://docs.microsoft.com/en-us/azure/cosmos-db/](https://docs.microsoft.com/en-us/azure/cosmos-db/).
- en: Cosmos DB allows replication for fault tolerance and read scale-out, and replicas
    can be distributed geographically to optimize communication performance. Moreover,
    you can specify which data center all the replicas are placed in. The user also
    has the option to write-enable all the replicas so that writes are immediately
    available in the geographical area where they are done. Write scale-up is achieved
    with sharding, which the user can configure by defining which properties to use
    as shard keys.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Cosmos DB 允许进行复制以实现容错和读取扩展，副本可以地理分布以优化通信性能。此外，您可以指定所有副本放置在哪个数据中心。用户还可以选择启用所有副本的写入功能，以便在数据写入的地理位置立即可用。通过分片实现写入扩展，用户可以通过定义哪些属性用作分片键来配置。
- en: Creating an Azure Cosmos DB account
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Azure Cosmos DB 帐户
- en: 'You can define a Cosmos DB account by typing `Cosmos DB` into the Azure portal
    search bar and clicking **+ Create**. The following page will appear:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 Azure 门户搜索栏中键入 `Cosmos DB` 并点击**创建**来定义 Cosmos DB 帐户。以下页面将出现：
- en: '![Interface gráfica do usuário, Aplicativo  Descrição gerada automaticamente](img/B19820_12_05.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，应用程序，自动生成的描述](img/B19820_12_05.png)'
- en: 'Figure 12.5: Creating an Azure Cosmos DB account'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：创建 Azure Cosmos DB 帐户
- en: For instance, if you select the **Core (SQL)** option, the account name you
    choose is used in the resource URI as `{account_name}.documents.azure.com`. Then,
    you can decide which location the main database will be placed in and the capacity
    mode. You can check more information about the capacity modes available at [https://docs.microsoft.com/en-us/azure/cosmos-db/throughput-serverless](https://docs.microsoft.com/en-us/azure/cosmos-db/throughput-serverless).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您选择**核心（SQL）**选项，您选择的帐户名称在资源 URI 中用作 `{account_name}.documents.azure.com`。然后，您可以决定主数据库将放置在哪个位置以及容量模式。您可以在[https://docs.microsoft.com/en-us/azure/cosmos-db/throughput-serverless](https://docs.microsoft.com/en-us/azure/cosmos-db/throughput-serverless)上查看有关可用容量模式的更多信息。
- en: Microsoft keeps improving many of its Azure services. The best way to keep updated
    about new features of any Azure component is by checking its documentation from
    time to time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 微软不断改进其许多 Azure 服务。了解任何 Azure 组件新功能的最佳方式是定期检查其文档。
- en: On the **Global Distribution** tab, the **Multi-region Writes** toggle lets
    you enable writes on geographically distributed replicas. If you do not do this,
    all write operations will be routed to the main location. Finally, you may also
    define network connectivity, backup policies, and encryption during the creation
    process.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在**全局分布**选项卡上，**多区域写入**切换按钮允许您在地理分布的副本上启用写入。如果您不这样做，所有写入操作都将路由到主位置。最后，您还可以在创建过程中定义网络连接性、备份策略和加密。
- en: Creating an Azure Cosmos DB container
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Azure Cosmos DB 容器
- en: Once you have created your Azure Cosmos DB – Core SQL account, select **Data
    Explorer** to create your databases and containers inside of them. A container
    is the unit of scalability both for provisioned throughput and storage, available
    when you decide by provisioned throughput capacity mode.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了您的 Azure Cosmos DB – Core SQL 帐户，选择**数据资源管理器**以在它们内部创建数据库和容器。容器是配置吞吐量和存储的可扩展性单元，当您通过配置吞吐量容量模式决定时可用。
- en: 'Since databases just have a name and no configuration, you can **Add a container**
    directly and then place the database where you wish:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库仅有一个名称而没有配置，您可以直接**添加容器**，然后将数据库放置在您希望的位置：
- en: '![Interface gráfica do usuário, Texto, Aplicativo, Email  Descrição gerada
    automaticamente](img/B19820_12_06.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，文本，应用程序，电子邮件，自动生成的描述](img/B19820_12_06.png)'
- en: 'Figure 12.6: Adding a container in Azure Cosmos DB'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：在 Azure Cosmos DB 中添加容器
- en: Here, you can decide on database and container names and the property to use
    for sharding (the partition key). Since NoSQL entries are object trees, property
    names are specified as paths. You can also add properties whose values are required
    to be unique.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以决定数据库和容器的名称以及用于分片的属性（分区键）。由于 NoSQL 条目是对象树，属性名称指定为路径。您还可以添加值必须唯一的属性。
- en: However, the uniqueness of IDs is checked inside each partition, so this option
    is only useful in certain situations, such as multi-tenant applications (where
    each tenant is included in a single shard). The fees depend on the collection
    throughput that you choose.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ID 的唯一性是在每个分区内部进行检查的，因此此选项仅在特定情况下有用，例如多租户应用程序（其中每个租户都包含在单个分片中）。费用取决于您选择的集合吞吐量。
- en: This is where you need to target all resource parameters to your needs. Throughput
    is expressed in request units per second, where request units per second are defined
    as the throughput we have when performing a read of 1 KB per second. Hence, if
    you check the **Provision database throughput** option, the chosen throughput
    is shared with the whole database instead of being reserved as a single collection.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要将所有资源参数针对您的需求进行定位的地方。吞吐量以每秒请求数量表示，其中每秒请求数量定义为每秒执行 1 KB 读取时的吞吐量。因此，如果您检查**配置数据库吞吐量**选项，所选的吞吐量是整个数据库共享的，而不是作为单个集合保留。
- en: Accessing Azure Cosmos DB
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 Azure Cosmos DB
- en: After creating the Azure Cosmos container, you will be able to access data.
    To get connection information, you can select the **Keys** menu. There, you will
    see all the information you need to connect with your Cosmos DB account from your
    application. The connection information page will provide you with the account
    URI and two connection keys, which can be used interchangeably to connect with
    the account.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Azure Cosmos 容器之后，您将能够访问数据。要获取连接信息，您可以选择**密钥**菜单。在那里，您将看到连接到您的 Cosmos DB
    账户所需的所有信息。连接信息页面将为您提供账户 URI 和两个连接密钥，这些密钥可以互换使用以连接到账户。
- en: '![Text  Description automatically generated with medium confidence](img/B19820_12_07.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成，置信度中等](img/B19820_12_07.png)'
- en: 'Figure 12.7: Connection information page'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：连接信息页面
- en: There are also keys with read-only privileges. Every key can be regenerated,
    and each account has two equivalent keys, like many other Azure components. This
    approach enables operations to be handled efficiently; that is, when a key is
    changed, the other one is kept. Therefore, existing applications can continue
    using the other key before upgrading to the new key.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些具有只读权限的密钥。每个密钥都可以重新生成，每个账户都有两个等效的密钥，就像许多其他 Azure 组件一样。这种方法使得操作可以高效地处理；也就是说，当一个密钥更改时，另一个密钥会被保留。因此，现有的应用程序可以在升级到新密钥之前继续使用另一个密钥。
- en: Defining database consistency
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据库一致性
- en: Considering that you are in the context of a distributed database, Azure Cosmos
    DB enables you to define the default read consistency level you will have. By
    selecting **Default consistency** in the main menu of your Cosmos DB account,
    you can choose the default replication consistency that you wish to apply to all
    your containers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到您处于分布式数据库的上下文中，Azure Cosmos DB 允许您定义默认的读取一致性级别。通过在您的 Cosmos DB 账户主菜单中选择**默认一致性**，您可以选择应用于所有容器的默认复制一致性。
- en: This default can be overridden in each container, either from Data Explorer
    or programmatically. Consistency problems in read/write operations are a consequence
    of data replication. More specifically, the results of various read operations
    may be incoherent if the read operations are executed on different replicas that
    have received different partial updates.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此默认设置可以在每个容器中覆盖，无论是通过数据资源管理器还是通过编程方式。读写操作中的不一致性问题是由数据复制引起的后果。更具体地说，如果读取操作在不同的副本上执行，而这些副本接收到了不同的部分更新，那么各种读取操作的结果可能是不连贯的。
- en: 'The following are the available consistency levels. These have been ordered
    from the weakest to the strongest:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用的一致性级别。这些已按从最弱到最强的顺序排列：
- en: '**Eventual**: After enough time has passed, if no further write operations
    are done, all the reads converge and apply all the writes. The order of writes
    is also not guaranteed, so while writes are being processed, you could also end
    up reading an earlier version than the one you have previously read.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：经过足够的时间后，如果没有进一步的写入操作，所有读取将收敛并应用所有写入。写入的顺序也不保证，所以在写入正在处理时，您也可能读取到之前读取的较早版本。'
- en: '**Consistent prefix**: All the writes are executed in the same order on all
    the replicas. So, if there are `n` write operations, each read is consistent with
    the result of applying the first `m` writes for some `m` less than or equal to
    `n`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性前缀**：所有写入都在所有副本上以相同的顺序执行。因此，如果有 `n` 个写入操作，每个读取都与应用前 `m` 个写入的结果一致，其中 `m`
    小于或等于 `n`。'
- en: '**Session**: This is the same as the consistency prefix but also guarantees
    that each writer sees the result of its own writes in all subsequent read operations
    and that subsequent reads of each reader are coherent (either the same database
    or a more updated version of it).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：这与一致性前缀相同，但还保证每个写者在其所有后续读取操作中看到其自己的写入结果，并且每个读者的后续读取是一致的（要么是相同的数据库，要么是其更新版本）。'
- en: '**Bounded staleness**: This is associated either with a delay time, `Delta`,
    or with several operations, `N`. Each read sees the results of all the write operations
    that were performed before a time `Delta` (or before the last `N` operations).
    That is, its reads converge with the result of all the writes with a maximum time
    delay of `Delta` (or a maximum operations delay of `N`).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有界陈旧性**：这与延迟时间`Delta`或多个操作`N`相关联。每次读取都会看到在时间`Delta`之前（或最后`N`个操作之前）执行的所有写操作的结果。也就是说，其读取与所有写操作的结果收敛，最大时间延迟为`Delta`（或最大操作延迟为`N`）。'
- en: '**Strong**: This is bounded staleness combined with `Delta = 0`. Here, each
    read reflects the result of all previous write operations.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强一致性**：这是有界陈旧性与`Delta = 0`的结合。在这里，每次读取都反映了所有之前的写操作的结果。'
- en: The strongest consistency can be obtained to the detriment of performance. By
    default, the consistency is set to **Session**, which is a good compromise between
    coherence and performance. A lower level of consistency is difficult to handle
    in applications and is only usually acceptable if sessions are either read-only
    or write-only.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以牺牲性能为代价获得最强的一致性。默认情况下，一致性设置为**会话**，这是在一致性和性能之间的一种良好折衷。在应用程序中处理较低级别的一致性很困难，并且通常只有在会话是只读或只写的情况下才可接受。
- en: 'If you select the **Settings** option in the **Data Explorer** menu of the
    container of your database, you can configure which paths to index and which kind
    of indexing to apply to each data type of each path. The configuration consists
    of a JSON object. Let us analyze its various properties:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择数据库容器中的**数据探索器**菜单中的**设置**选项，你可以配置要索引哪些路径以及将哪种索引应用于每个路径的数据类型。该配置由一个JSON对象组成。让我们分析其各种属性：
- en: '[PRE0]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you set `indexingMode` to `none` instead of `consistent`, no index is generated,
    and the collection can be used as a key-value dictionary that is indexed by the
    collection’s primary key. In this scenario, no secondary indexes are generated,
    so the primary key cannot efficiently be searched.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`indexingMode`设置为`none`而不是`consistent`，则不会生成索引，并且可以将集合用作由集合的主键索引的键值字典。在这种情况下，不会生成二级索引，因此无法有效地搜索主键。
- en: 'When `automatic` is set to `true`, all document properties are automatically
    indexed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当`automatic`设置为`true`时，所有文档属性都会自动索引：
- en: '[PRE1]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each entry in `includedPaths` specifies a path pattern such as `/subpath1/subpath2/?`
    (settings apply just to the `/subpath1/subpath2/property`) or `/subpath1/subpath2/*`
    (settings apply to all the paths starting with `/subpath1/subpath2/`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`includedPaths`中的每个条目指定了一个路径模式，例如`/subpath1/subpath2/?`（设置仅应用于`/subpath1/subpath2/property`）或`/subpath1/subpath2/*`（设置应用于所有以`/subpath1/subpath2/`开头的路径）。'
- en: Patterns contain the `[]` symbol when settings must be applied to child objects
    contained in collection properties; for example, `/subpath1/subpath2/[]/?`, `/subpath1/subpath2/[]/childpath1/?`,
    and so on. Settings specify the index type to apply to each data type (string,
    number, geographic point, and so on). Range indexes are needed for comparison
    operations, while hash indices are more efficient if we need equality comparisons.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置必须应用于集合属性中包含的子对象时，模式包含`[]`符号；例如，`/subpath1/subpath2/[]/?`，`/subpath1/subpath2/[]/childpath1/?`等等。设置指定要应用于每个数据类型（字符串、数字、地理点等）的索引类型。范围索引用于比较操作，而如果需要进行等价比较，散列索引则更有效。
- en: 'It is possible to specify a precision, that is, the maximum number of characters
    or digits to use in all the index keys. `-1` means the maximum precision and is
    always recommended:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定一个精度，即所有索引键中使用的最大字符数或数字数。`-1`表示最大精度，并且总是推荐使用：
- en: '[PRE2]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Paths contained in `excludedPaths` are not indexed at all. Index settings can
    also be specified programmatically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在`excludedPaths`中的路径根本不会被索引。索引设置也可以通过编程方式指定。
- en: 'Here, you have two options to connect to Cosmos DB: use a version of its official
    client for your preferred programming language or use Cosmos DB’s Entity Framework
    Core provider. In the following subsections, we will have a look at both options.
    Then, we will describe how to use Cosmos DB’s Entity Framework Core provider with
    a practical example.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有两种连接到Cosmos DB的选项：使用适用于你首选编程语言的官方客户端或使用Cosmos DB的Entity Framework Core提供程序。在接下来的小节中，我们将探讨这两种选项。然后，我们将通过一个实际示例描述如何使用Cosmos
    DB的Entity Framework Core提供程序。
- en: The Cosmos DB client
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cosmos DB客户端
- en: The Cosmos DB client for .NET 8 is available through the `Microsoft.Azure.Cosmos`
    NuGet package. It offers full control of all Cosmos DB features, while the Cosmos
    DB Entity Framework provider is easier to use but hides some Cosmos DB peculiarities.
    Follow these steps to interact with Cosmos DB through the official Cosmos DB client
    for .NET 8.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8的Cosmos DB客户端可通过`Microsoft.Azure.Cosmos` NuGet包获得。它提供了对所有Cosmos DB功能的完全控制，而Cosmos
    DB Entity Framework提供程序更容易使用，但隐藏了一些Cosmos DB的特性。按照以下步骤通过.NET 8的官方Cosmos DB客户端与Cosmos
    DB交互：
- en: 'The following code sample shows the creation of a database and a container
    using the client component. Any operation requires the creation of a client object.
    Do not forget that the client must be disposed of by calling its `Dispose` method
    (or by enclosing the code that references it in a `using` statement) when you
    do not need it anymore:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了使用客户端组件创建数据库和容器。任何操作都需要创建一个客户端对象。不要忘记，当不再需要客户端时，必须通过调用其`Dispose`方法（或通过将引用它的代码放在`using`语句中）来释放客户端：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: During collection creation, you can pass a `ContainerProperties` object, where
    you can specify the consistency level, how to index properties, and all the other
    collection features.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合创建期间，你可以传递一个`ContainerProperties`对象，其中你可以指定一致性级别、如何索引属性以及所有其他集合功能。
- en: 'Then, you must define the .NET classes that correspond to the structure of
    the JSON document you need to manipulate in your collections. You can also use
    the `JsonProperty` attribute to map class property names to JSON names if they
    are not equal:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须定义与你要在集合中操作的JSON文档结构相对应的.NET类。你也可以使用`JsonProperty`属性将类属性名称映射到JSON名称，如果它们不相等的话：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: NoSQL means Not Only SQL, so it is also possible to map properties. The great
    thing about NoSQL is that you must map these properties without causing damage
    to other properties or information you have in the document you are connecting
    to.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL意味着“不仅SQL”，因此也可以映射属性。NoSQL的伟大之处在于，你必须在不会损害你连接的文档中的其他属性或信息的情况下映射这些属性。
- en: Once you have all the necessary classes, you can use client methods to `ReadItemAsync`,
    `CreateItemAsync`, and `DeleteItemAsync`. You can also query data using a `QueryDefinition`
    object that accepts SQL commands. You can find a complete introduction to this
    library at [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有所有必要的类，你可以使用客户端方法`ReadItemAsync`、`CreateItemAsync`和`DeleteItemAsync`。你还可以使用接受SQL命令的`QueryDefinition`对象来查询数据。你可以在[https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started)找到这个库的完整介绍。
- en: The Cosmos DB Entity Framework Core provider
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cosmos DB Entity Framework Core提供程序
- en: 'The Cosmos DB provider for Entity Framework Core is contained in the `Microsoft.EntityFrameworkCore.Cosmos`
    NuGet package. Once you’ve added this to your project, you can proceed in a similar
    way to when you used the SQL Server provider in *Chapter 13*, *Interacting with
    Data in C# – Entity Framework Core*, but with a few differences. Let us take a
    look:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Cosmos DB的Entity Framework Core提供程序包含在`Microsoft.EntityFrameworkCore.Cosmos`
    NuGet包中。一旦将其添加到项目中，你可以按照与你在*第13章*，“使用C#与数据交互 – Entity Framework Core”中使用SQL Server提供程序类似的方式进行操作，但有一些不同之处。让我们看看：
- en: 'There are no migrations since Cosmos DB databases have no structure to update.
    Instead, they have a method that ensures that the database, along with all the
    necessary collections, is created:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Cosmos DB数据库没有结构需要更新，因此没有迁移。相反，它们有一个确保数据库以及所有必要的集合被创建的方法：
- en: '[PRE5]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, the `DbSet<T>` properties from `DBContext` are mapped to a unique
    container since this is the cheapest option. You can override this default by
    explicitly specifying which container you want to map some entities to by using
    the following configuration instruction:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`DBContext`中的`DbSet<T>`属性映射到一个唯一的容器，因为这是最经济的选项。你可以通过以下配置指令显式指定你想要将某些实体映射到哪个容器来覆盖此默认设置：
- en: '[PRE6]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only useful annotation on entity classes is the `Key` attribute, which becomes
    obligatory when the primary keys are not called `Id`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体类上唯一的实用注解是`Key`属性，当主键不命名为`Id`时，它成为强制性的。
- en: Primary keys must be strings and cannot be auto-incremented to avoid synchronization
    issues in a distributed environment. The uniqueness of primary keys can be ensured
    by generating GUIDs and transforming them into strings.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键必须是字符串，并且不能自动递增，以避免在分布式环境中的同步问题。可以通过生成GUID并将其转换为字符串来确保主键的唯一性。
- en: When defining relationships between entities, you can specify that an entity
    or a collection of entities is owned by another entity, in which case it is stored
    together with the parent entity.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义实体之间的关系时，你可以指定一个实体或一组实体属于另一个实体，在这种情况下，它将与父实体一起存储。
- en: We will look at the usage of Cosmos DB’s Entity Framework provider in the *How
    to choose your data storage in the cloud* section of *Chapter 21*, *Case Study*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第21章的“如何在云中选择你的数据存储”部分中查看Cosmos DB的Entity Framework提供者的使用情况，*案例研究*。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the main storage options available in Azure and
    learned when to use them. Then, we compared relational and NoSQL databases. We
    pointed out that relational databases offer automatic consistency checking and
    transaction isolation, but NoSQL databases are cheaper and offer better performance,
    especially when distributed writes form a high percentage of the average workload.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Azure中可用的主要存储选项，并学习了何时使用它们。然后，我们比较了关系型数据库和非关系型数据库。我们指出，关系型数据库提供自动一致性检查和事务隔离，但非关系型数据库更便宜，并且提供更好的性能，尤其是在分布式写入占平均工作负载很大比例的情况下。
- en: Then, we described Azure’s main NoSQL option, Cosmos DB, and explained how to
    configure it and how to connect with a client.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们描述了Azure的主要非关系型选项Cosmos DB，并解释了如何配置它以及如何与客户端连接。
- en: Finally, we learned how to interact with Cosmos DB with Entity Framework Core.
    Here, we learned how to decide whether to use relational or NoSQL databases for
    all families of data involved in an application. So, you can choose the kind of
    data storage that ensures the best compromise between data coherence, speed, and
    parallel access to data in each of your applications.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用Entity Framework Core与Cosmos DB交互。在这里，我们学习了如何决定在应用程序涉及的所有数据家族中，是使用关系型数据库还是非关系型数据库。因此，你可以选择确保在您的每个应用程序中数据一致性、速度和并行访问数据之间取得最佳折衷的数据存储类型。
- en: In the next chapter, we will learn all about how to interact with data in C#–Entity
    Framework Core.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用C#和Entity Framework Core与数据交互。
- en: Questions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is Redis a valid alternative to relational databases?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redis是关系型数据库的有效替代品吗？
- en: Are NoSQL databases a valid alternative to relational databases?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非关系型数据库是关系型数据库的有效替代品吗？
- en: What operation is more difficult to scale out in relational databases?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关系型数据库中，哪种操作更难进行扩展？
- en: What is the main weakness of NoSQL databases? What is their main advantage?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非关系型数据库的主要弱点是什么？它们的主要优势是什么？
- en: Can you list all Cosmos DB consistency levels?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能列出所有Cosmos DB的一致性级别吗？
- en: Can we use auto-increment integer keys with Cosmos DB?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用自动递增的整数键与Cosmos DB一起使用吗？
- en: Which Entity Framework configuration method is used to store an entity inside
    its related father document?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种Entity Framework配置方法用于在相关的父文档中存储实体？
- en: Can nested collections be searched efficiently with Cosmos DB?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cosmos DB能否有效地搜索嵌套集合？
- en: Further reading
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following is a reference to the Gremlin language, which is supported by
    Cosmos DB: [http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps](http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是对Gremlin语言的引用，该语言由Cosmos DB支持：[http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps](http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps)。
- en: 'The following is a general description of the Cosmos DB graph data model: [https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是对Cosmos DB图数据模型的简要描述：[https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction)。
- en: Details on how to use Cosmos DB’s official .NET client can be found at [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started).
    A good introduction to the `MvcControlsToolkit.Business.DocumentDB` NuGet package
    that we mentioned in this chapter is the *Fast Azure Cosmos DB Development with
    the DocumentDB Package* article contained in Issue 34 of *DNCMagazine*. This can
    be downloaded from [https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb](https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Cosmos DB 的官方 .NET 客户端的详细信息可以在 [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started)
    找到。关于我们在本章中提到的 `MvcControlsToolkit.Business.DocumentDB` NuGet 包的良好介绍是 *DNCMagazine*
    第 34 期中的 *Fast Azure Cosmos DB Development with the DocumentDB Package* 文章。这可以从
    [https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb](https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb)
    下载。
- en: Learn more on Discord
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
