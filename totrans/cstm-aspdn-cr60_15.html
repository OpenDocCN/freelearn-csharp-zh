<html><head></head><body>
		<div><h1 id="_idParaDest-121"><em class="italic"><a id="_idTextAnchor218"/>Chapter 15</em>: Working with Caches</h1>
			<p>In this chapter we will have a look into cache techniques. ASP.NET Core provides multiple ways to cache and we will learn to use and to customize them. </p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>The need for caching</li>
				<li>HTTP-based caching</li>
				<li>Caching using ResponseCachingMiddleware</li>
				<li>Predefining caching strategies using cache profiles</li>
				<li>Caching specific areas using CacheTagHelper</li>
				<li>Caching Manually</li>
			</ul>
			<p>The topics in this chapter refer to the MVC layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_15.1_B17996.jpg" alt="Figure 15.1 – ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – ASP.NET Core architecture</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor219"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. Open your console, shell, or Bash terminal, and change to your working directory. Use the following command to create a new MVC application:</p>
			<pre>dotnet new mvc -n CacheSample -o CacheSample</pre>
			<p>Now, open the project in Visual Studio by double-clicking the project file or, in VS Code, by typing the following command in the already open console:</p>
			<pre>cd CacheSample
code .</pre>
			<p>All of the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter15">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter15</a>.</p>
			<h1 id="_idParaDest-123">W<a id="_idTextAnchor220"/><a id="_idTextAnchor221"/><a id="_idTextAnchor222"/>hy do we need caching?</h1>
			<p>Caching <a id="_idIndexMarker218"/>speeds up performance, by storing the results in memory or in a distributed cache like a fast Redis database, you can also store cached data in files if it makes sense.</p>
			<p>A distributed cache<a id="_idIndexMarker219"/> is needed in case you run multiple instances of an application to scale for availability of your application. The instances will run on multiple Docker containers, in a Kubernetes cluster or just on more than one Azure App Services. In that case, the instances should share a cache.</p>
			<p>Most application caches are in-memory caches that store data for a short period of time. This is good for most scenarios.</p>
			<p>Also, browser do cache the websites or the web applications output. The browsers usually store the entire result in files. As an ASP.NET developer you can control the browsers cache by adding HTTP headers that specify whether the browser should cache or not and that specify how long the cached item should be valid. </p>
			<p>A browser cache reduces the number of requests to the server. A cache handling in your code might reduce the number of database access or reduce the access to another time-consuming action.</p>
			<p>Both client-side caches and server side caches are useful to increase the performance of your application. Let's have a detailed look at the client side cache.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor223"/>HTTP-based caching</h1>
			<p>To control the browsers<a id="_idIndexMarker220"/> cache you can set a <code>Cache-Control</code> HTTP header. Usually, the <code>StaticFileMiddleware</code> doesn't set a Cache-Control header. This means the clients are free to cache how they prefer. If you like to limit the cache time to just one day, you can do this by passing <code>StaticFileOptions</code> to the middleware: </p>
			<pre>const string cacheMaxAge = "86400";
app.UseStaticFiles(new StaticFileOptions()
{
    OnPrepareResponse = ctx =&gt;
    {
        ctx.Context.Response.Headers.TryAdd(
            "Cache-Control", 
            $"public, max-age={cacheMaxAge}");
    }
});</pre>
			<p>This sets the <code>Cache-Control</code> header to every static file that is requested before it gets sent to the client. The <code>Cache-Control</code> is set to public, which means it can be publicly cached on every client. The maximum age of the cache items should not be older than 86,400 seconds, which is one day.</p>
			<p>Setting the headers to the static file is just an example. You can set the header to every response that needs cache control. You can also disable the cache by setting the Cache-Control header to no-cache.</p>
			<p>To learn more about the <code>Cache-Control</code> header, see the following URL: https://datatracker.ietf.org/doc/html/rfc7234#section-5.2</p>
			<p>Also, the <code>Expires</code> header might be useful, to specify when the responded content get invalid and should get renewed from the server. See https://datatracker.ietf.org/doc/html/rfc7234#section-5.3</p>
			<p>The <code>Vary</code> header specifies a criteria that tells the clients about cache variations. It checks for specific headers to be available. See https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.4</p>
			<p>This controls the clients directly via the response object. </p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor224"/>Caching using ResponseCachingMiddleware</h1>
			<p>The <code>ResponseCachingMiddleware</code> caches the responses on the server side and creates responses based on the cached responses. The middleware respects the <code>Cache-Control</code> header in the same way as clients do. That means you are able to control the middleware by setting the specific headers as described in the previews section.</p>
			<p>To get it working you <a id="_idIndexMarker221"/>need to add the <code>ResponseCachingMiddleware</code> to the Dependency Injection container:</p>
			<pre>builder.Services.AddResponseCaching();</pre>
			<p>And you should use that middleware to the pipeline after the static files and routing got added:</p>
			<pre>app.UseResponseCaching();</pre>
			<p>If you added a CORS configuration, the <code>UseCors</code> method should be called before, as well.</p>
			<p>The <code>ResponseCachingMiddleware</code> gets affected by specific HTTP headers. For example, if the <code>Authentication</code> header is set the response doesn't get cached, same with the <code>Set-Cookie</code> header. It also only caches responses that result in a 200 OK result. Error pages and other status codes don't get cached.</p>
			<p>You can find the full list of criteria at this URL: https://docs.microsoft.com/en-us/aspnet/core/performance/caching/middleware?view=aspnetcore-6.0#http-headers-used-by-response-caching-middleware.</p>
			<p>Using the <code>ResponseCacheAttribute</code> on controller level, actions level or pages level you can set the right headers to control the <code>ResponseCachingMiddleware</code> by using <code>ResponseCacheAttribute</code>:</p>
			<pre>[ResponseCache(Duration = 86400)]
public IActionResult Index()
{
    return View();
}</pre>
			<p>This snippet sets the <code>Cache-Control</code> to public with max-age to one day, like the sample in the previews section. </p>
			<p>This attribute is pretty powerful, you can also set Vary headers in different ways, as well as the indicator to not cache the output at all. Even a <code>CacheProfileName</code> can be set. We are going <a id="_idIndexMarker222"/>to have a look at cache profiles in the next section.</p>
			<p>These are properties you can set:</p>
			<ul>
				<li><code>Duration</code>: Time range in seconds</li>
				<li><code>Location</code>: The location where to store the cache: Client, Any, or none</li>
				<li><code>NoStore</code>: Disables the cache if it is set to true</li>
				<li><code>VaryByHeader</code>: A header value that varies the cache</li>
				<li><code>VaryByQueryKeys</code>: An array of query key names that varies the cache</li>
			</ul>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor225"/>Predefining caching strategies using cache profiles</h2>
			<p>You can predefine caching strategies in a so-called cache profile<a id="_idIndexMarker223"/> to reuse them wherever you need. The <code>CacheProfile</code> type has the same properties as the <code>ResponseCache</code> attribute. To define cache profiles, you need to set options to the MVC services. </p>
			<p>In <code>Program.cs</code>, the <code>AddControllersWithViews method</code> has an overload to configure the <code>MvcOptions</code>. Here, you can also add cache profiles:</p>
			<pre>builder.Services.AddControllersWithViews(options =&gt;
{
    options.CacheProfiles.TryAdd("Duration30",
        new CacheProfile
        {
            Duration = 30, 
            VaryByHeader = "User-Agent", 
            Location = ResponseCacheLocation.Client
        });
    options.CacheProfiles.TryAdd("Duration60",
        new CacheProfile
        {
            Duration = 60, 
            VaryByHeader = "User-Agent", 
            Location = ResponseCacheLocation.Client
        });
});</pre>
			<p>You might need to add a <code>using</code> statement to <code>Microsoft.AspNetCore.Mvc</code>.</p>
			<p>This snippet adds<a id="_idIndexMarker224"/> two different cache profiles, the first one with a 30 second cache and the second one with a 60 second cache. Both profiles tell the cache to vary by the <code>"User-Agent"</code> header.</p>
			<p>To use a profile, you can use the profile name in the response caching attribute:</p>
			<pre>[ResponseCache(CacheProfileName = "Duration30")]
public IActionResult Index()
{</pre>
			<p>Instead of setting all the properties of <code>ResponseCacheAttribute</code>, you can just set <code>CacheProfileName</code>. Let's see how to use caches the declarative way.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor226"/>Caching specific areas using CacheTagHelper</h1>
			<p>You can also cache<a id="_idIndexMarker225"/> specific areas of the view. In a scenario where you are not able to cache an entire view, you would be able to just cache a specific area by surrounding it with the <code>CacheTagHelper</code>.</p>
			<p>To test that, add the following snippet to the <code>index.cshtml</code>, that you can find in the <code>/Views/Home/</code> folder:</p>
			<pre>&lt;div&gt;
    &lt;p&gt;
       The current time is: @DateTime.Now.ToLongTimeString()
   &lt;/p&gt;
&lt;/div&gt;
&lt;cache expires-sliding="@TimeSpan.FromSeconds(7)"&gt;
&lt;div&gt;
    &lt;p&gt;
       The current time is: @DateTime.Now.ToLongTimeString()
    &lt;/p&gt;
&lt;/div&gt;
&lt;/cache&gt;</pre>
			<p>This snippet contains two<a id="_idIndexMarker226"/> identical p-tags that write out the current time.</p>
			<p>The second one is wrapped in a <code>CacheTagHelper</code> that has a sliding expiration of 7 seconds defined.</p>
			<p>Start the application and see what happens. Navigate to the <code>Index</code> page and refresh the browser several times. You will see that only the first time will change while refreshing the page. The second one is cached and stays the same for 7 seconds.</p>
			<div><div><img src="img/Figure_15.2_B17996.jpg" alt="Figure 15.2 - Cached and uncached values "/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2 - Cached and uncached values </p>
			<p>Let's look at what we should do if we need to cache more specifically</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor227"/>Caching Manually</h1>
			<p>Sometimes it makes sense <a id="_idIndexMarker227"/>to cache specifically inside the C# code. For example, if you need to fetch data from an external source or database, it would save time and traffic if you cache the results and don't access the result every time. </p>
			<p>Let's try it out by using two different ways to use create and access cache items:</p>
			<ol>
				<li>To try it out we will extend the <code>HomeController</code> a little bit. Start by injecting an instance of the <code>IMemoryCache</code> to the controller and store it in a field:<pre>using Microsoft.Extensions.Caching.Memory;
public class HomeController : Controller
{
    private readonly ILogger&lt;HomeController&gt; _logger;
    private readonly IMemoryCache _cache;
    public HomeController(
        ILogger&lt;HomeController&gt; logger,
        IMemoryCache cache
        )
    {
        _logger = logger;
        _cache = cache;
    }</pre></li>
				<li>In the <code>Models</code> folder, create a<a id="_idIndexMarker228"/> file called <code>Person.cs</code> and place the following lines in it:<pre>namespace CacheSample.Models;
internal class Person
{
    public int Id { get; set; }
    public string? Firstname { get; set; }
    public string? Lastname { get; set; }
    public string? Address { get; set; }
    public string? City { get; set; }
}</pre></li>
				<li>Now we need to add two super complex methods that do some magic for us. Actually, these methods just create fake data and aren't really complex:<pre>private IEnumerable&lt;Person&gt;
  LoadDataFromExternalSource()
{
    return A.ListOf&lt;Person&gt;(10);
}
private IDictionary&lt;int, string&gt;
  LoadSuperComplexCalculatedData()
{
    return Enumerable.Range(0, 10)
        .ToDictionary(
            x =&gt; x, 
            x =&gt; $"Item{Random.Shared.Next()}");
}</pre><p>The first method uses <code>GenFu</code> that is also used in previous chapters to create a list of <code>Person</code> and fill them with random but valid data. The second method creates a <code>Dictionary</code> of 10 items that also contains random data. The random data make sense to show that the data are actually cached. If the data don't change on the user interface, the data came out of the cache.</p></li>
				<li>Type the following <a id="_idIndexMarker229"/>command in the project folder to install <code>GenFu</code>:<pre>dotnet add package GenFu</pre></li>
				<li>Add the following lines at the beginning of the index action to store the data of the first method in the cache or to load the data out of the cache:<pre>if (!_cache.TryGetValue&lt;IEnumerable&lt;Person&gt;&gt;(
    "ExternalSource", out var externalPersons))
{
    externalPersons = LoadDataFromExternalSource();
    _cache.Set(
        "ExternalSource",
        externalPersons,
        new MemoryCacheEntryOptions
        {
            AbsoluteExpiration = 
              DateTime.Now.AddSeconds(30)
        });
}</pre><p>This will at first try to load the data out of the cache by using the <code>ExternalSource</code> cache key. If the cached data doesn't exist, you need to load them from the original source and store them in the cache using the <code>Set</code> method.</p></li>
			</ol>
			<p>The other way to create and<a id="_idIndexMarker230"/> load cached data is to use the <code>GetOrCreate</code> method:</p>
			<pre>var calculatedValues = _cache.GetOrCreate(
    "ComplexCalculate", entry =&gt;
{
    entry.AbsoluteExpiration = DateTime.Now.AddSeconds(30);
    return LoadSuperComplexCalculatedData();
});</pre>
			<p>It works the same way but is pretty much simpler to use. The value that needs to be cached will be returned in the lambda expression directly while the lambda retrieves the cache entry that can be configured. </p>
			<p>Once the data are there you can return them to the view:</p>
			<pre>return View(new IndexViewModel
        {
            Persons = externalPersons,
            Data = calculatedValues
        });</pre>
			<p>The model that gets returned looks like this:</p>
			<pre>internal class IndexViewModel
{
    public IEnumerable&lt;Person&gt;? Persons { get; set; }
    public IDictionary&lt;int, string&gt;? Data { get; set; }
}</pre>
			<p>Add the next <a id="_idIndexMarker231"/>snippet to <code>Index.cshtml</code> right after <code>CacheTagHelper</code> to visualize the data:</p>
			<pre>&lt;div class="row"&gt;
    &lt;div class="col-md-6"&gt;
        &lt;ul&gt;
            @foreach (var person in Model.Persons)
            {
            &lt;li&gt;
            [@person.Id] @person.Firstname @person.Lastname
            &lt;/li&gt;
            }
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class="col-md-6"&gt;
        &lt;ul&gt;
            @foreach (var data in Model.Data)
            {
                &lt;li&gt;[@data.Key] @data.Value&lt;/li&gt;
            }
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
			<p>This creates two lists <a id="_idIndexMarker232"/>in two side-by-side columns. Now run the application, call it in the browser, and try to refresh the page. The displayed data shouldn't change even though the data are completely random. Without the cache, the data would change on every reload:</p>
			<div><div><img src="img/Figure_15.3_B17996.jpg" alt="Figure 5.3 - Changing data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 - Changing data</p>
			<p>That's it. The cache expires every 30 seconds as configured.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor228"/>Summary</h1>
			<p>Caches help us to create high performance applications by reducing the calls to resources that are less performant, such as databases, external APIs, or complex calculations. In this chapter, you learned to use the response cache using the <code>ResponseCachingMiddleware</code> and the <code>ResponseCacheAttribute</code>, and the in-memory cache by using the <code>CacheTagHelper</code> as well as by using the <code>IMemoryCache</code> manually in t<a id="_idTextAnchor229"/>he C# code.</p>
			<p>In the next chapter, you will learn how to create custom <code>TagHelper</code>.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor230"/>Further reading</h1>
			<p>More about caching in the ASP.NET Core docs: <a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-6.0</a>.</p>
		</div>
	</body></html>