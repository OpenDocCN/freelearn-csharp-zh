<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Completing that Great User Experience</h1>
                </header>
            
            <article>
                
<p>As we have seen, it is easy to add form fields to a View and produce visually appealing and functionally adequate applications. However, it can take a lot more work to provide the end user with an interface that truly ticks all of the boxes. For example, how many times have you clicked on a button in an application and had the whole application freeze while it does some work?</p>
<p>In this chapter, we'll look into solving this problem by using asynchronous programming, along with a number of other ways of improving the user experience for the end user. For example, we'll investigate enabling the users to customize their versions of the application using their own user preference settings.</p>
<p>We'll discuss keeping the users informed by providing user feedback, and update our application framework by adding a feedback system. We'll explore a few alternative methods of providing in-application help files and documentation and a number of other ways of making the application more user friendly and the life of the users that much easier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing user feedback</h1>
                </header>
            
            <article>
                
<p>One essential facet of a great application is keeping the end users up to date with what's going on in the application. If they click on a function button, they should be informed as to the progress or the status of the operation. Without adequate feedback, the user can be left wondering whether a particular operation worked and may attempt to run it several times, possibly causing errors.</p>
<p class="mce-root"/>
<p>It is, therefore, essential to implement a feedback system in our application framework. So far in this book, we've seen the name of the <kbd>FeedbackManager</kbd> class in a few places, although we've seen very little implementation. Let's now see how we can implement a working feedback system in our application framework, starting with the <kbd>Feedback</kbd> class that holds the individual feedback messages:</p>
<pre>using System; 
using System.ComponentModel; 
using CompanyName.ApplicationName.DataModels.Enums; 
using CompanyName.ApplicationName.DataModels.Interfaces;  
using CompanyName.ApplicationName.Extensions; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public class Feedback : IAnimatable, INotifyPropertyChanged 
  { 
    private string message = string.Empty; 
    private FeedbackType type = FeedbackType.None; 
    private TimeSpan duration = new TimeSpan(0, 0, 4); 
    private bool isPermanent = false; 
    private Animatable animatable; 
 
    public Feedback(string message, FeedbackType type, TimeSpan duration)
    { 
      Message = message; 
      Type = type; 
      Duration = duration == TimeSpan.Zero ? this.duration : duration; 
      IsPermanent = false; 
      Animatable = new Animatable(this); 
    } 
      
    public Feedback(string message, bool isSuccess, bool isPermanent) :  
      this(message, isSuccess ? FeedbackType.Success :  
      FeedbackType.Error, TimeSpan.Zero) 
    { 
      IsPermanent = isPermanent; 
    } 
 
    public Feedback(string message, FeedbackType type) : this(message,  
      type, TimeSpan.Zero) { } 
 
    public Feedback(string message, bool isSuccess) : this(message,  
      isSuccess ? FeedbackType.Success : FeedbackType.Error,  
      TimeSpan.Zero) { } 
 
    public Feedback() : this(string.Empty, FeedbackType.None) { } 
 
    public string Message 
    { 
      get { return message; } 
      set { message = value; NotifyPropertyChanged(); } 
    } 
 
    public TimeSpan Duration 
    { 
      get { return duration; } 
      set { duration = value; NotifyPropertyChanged(); } 
    } 
 
    public FeedbackType Type 
    { 
      get { return type; } 
      set { type = value; NotifyPropertyChanged(); } 
    } 
 
    public bool IsPermanent 
    { 
      get { return isPermanent; } 
      set { isPermanent = value; NotifyPropertyChanged(); } 
    } 
 
    #region IAnimatable Members 
 
    public Animatable Animatable 
    { 
      get { return animatable; } 
      set { animatable = value; } 
    } 
 
    #endregion 
 
    #region INotifyPropertyChanged Members 
 
    ... 
 
    #endregion 
  } 
} </pre>
<p>Note that our <kbd>Feedback</kbd> class implements the <kbd>IAnimatable</kbd> interface, which we saw earlier, along with the <kbd>INotifyPropertyChanged</kbd> interface. After declaring the private fields, we declare a number of useful constructor overloads.</p>
<p>In this example, we have hardcoded a default feedback display duration of four seconds for the <kbd>duration</kbd> field. In the main constructor, we set the <kbd>Duration</kbd> property dependent upon the value of the <kbd>duration</kbd> input parameter; if the input parameter is the <kbd>TimeSpan.Zero</kbd> field, then the default value is used, but if the input parameter is a non-zero value, it will be used.</p>
<p>The <kbd>Message</kbd> property will hold the feedback message; the <kbd>Duration</kbd> property specifies the length of time that the message will be displayed; the <kbd>Type</kbd> property uses the <kbd>FeedbackType</kbd> enumeration that we saw earlier to specify the type of the message, and the <kbd>IsPermanent</kbd> property dictates whether the message should be permanently displayed until the user manually closes it or not.</p>
<p>The implementation of our <kbd>IAnimatable</kbd> class is shown beneath the other properties, and simply consists of the <kbd>Animatable</kbd> property, but our implementation of the <kbd>INotifyPropertyChanged</kbd> interface has been omitted for brevity, as we are using the default implementation that we saw earlier.</p>
<p>Let's now see the <kbd>FeedbackCollection</kbd> class that will contain the individual <kbd>Feedback</kbd> instances:</p>
<pre>using System.Collections.Generic; 
using System.Linq; 
 
namespace CompanyName.ApplicationName.DataModels.Collections 
{ 
  public class FeedbackCollection : BaseAnimatableCollection&lt;Feedback&gt; 
  { 
    public FeedbackCollection(IEnumerable&lt;Feedback&gt; feedbackCollection) : 
      base(feedbackCollection) { } 
 
    public FeedbackCollection() : base() { } 
 
    public new void Add(Feedback feedback) 
    { 
      if (!string.IsNullOrEmpty(feedback.Message) &amp;&amp; (Count == 0 ||  
        !this.Any(f =&gt; f.Message == feedback.Message))) base.Add(feedback); 
    } 
 
    public void Add(string message, bool isSuccess) 
    { 
      Add(new Feedback(message, isSuccess)); 
    } 
  } 
} </pre>
<p>The <kbd>FeedbackCollection</kbd> class extends the <kbd>BaseAnimatableCollection</kbd> class, which we saw earlier, and sets its generic type parameter to the <kbd>Feedback</kbd> class. This is a very simple class and declares a couple of constructors, passing any input parameters straight through to the base class constructors.</p>
<p>In addition to this, it declares two <kbd>Add</kbd> methods, with the second simply creating a <kbd>Feedback</kbd> object from its input parameters and passing it to the first method. The first method first checks that the feedback message is not <kbd>null</kbd> or empty and that an identical message is not already contained in the feedback collection, before adding the new message to the collection.</p>
<p>Note that our current implementation uses the base class <kbd>Add</kbd> method to add the new items to the end of the feedback collection. We could alternatively use the <kbd>Insert</kbd> method from the base class here to add new items to the start of the collection instead.</p>
<p>Let's now look at the <kbd>FeedbackManager</kbd> class that uses these two classes internally:</p>
<pre>using System.ComponentModel;  
using System.Runtime.CompilerServices; 
using CompanyName.ApplicationName.DataModels; 
using CompanyName.ApplicationName.DataModels.Collections; 
 
namespace CompanyName.ApplicationName.Managers 
{ 
  public class FeedbackManager : INotifyPropertyChanged 
  { 
    private static FeedbackCollection feedback = new FeedbackCollection(); 
    private static FeedbackManager instance = null; 
 
    private FeedbackManager() { } 
 
    public static FeedbackManager Instance =&gt; 
      instance ?? (instance = new FeedbackManager()); 
 
    public FeedbackCollection Feedback 
    { 
      get { return feedback; } 
      set { feedback = value; NotifyPropertyChanged(); } 
    } 
 
    public void Add(Feedback feedback) 
    { 
      Feedback.Add(feedback); 
    } 
 
    public void Add(string message, bool isSuccess) 
    { 
      Add(new Feedback(message, isSuccess)); 
    } 
 
    #region INotifyPropertyChanged Members 
 
    ... 
 
    #endregion 
  } 
} </pre>
<p>The <kbd>FeedbackManager</kbd> class also implements the <kbd>INotifyPropertyChanged</kbd> interface, and in it we see the static <kbd>FeedbackCollection</kbd> field. Next, we see the static <kbd>instance</kbd> field, the private constructor, and the static <kbd>Instance</kbd> property of type <kbd>FeedbackManager</kbd>, which instantiates the <kbd>instance</kbd> field on the first use and tells us that this class follows the Singleton pattern.</p>
<p>The <kbd>Feedback</kbd> property follows and is the class access to the <kbd>FeedbackCollection</kbd> field. After that, we see a number of convenient overloads of the <kbd>Add</kbd> method that enables developers to add feedback using different parameters. Our implementation of the <kbd>INotifyPropertyChanged</kbd> interface here has again been omitted for brevity, but it uses our default implementation that we saw earlier.</p>
<p>Let's now focus on the XAML of the <kbd>FeedbackControl</kbd> object:</p>
<pre>&lt;UserControl  
  x:Class="CompanyName.ApplicationName.Views.Controls.FeedbackControl" 
   
   
   
  xmlns:Converters="clr-namespace:CompanyName.ApplicationName.Converters; 
    assembly=CompanyName.ApplicationName.Converters" 
  xmlns:DataModels="clr-namespace:CompanyName.ApplicationName.DataModels; 
    assembly=CompanyName.ApplicationName.DataModels" 
  &gt; 
  &lt;UserControl.Resources&gt; 
    &lt;Converters:FeedbackTypeToImageSourceConverter  
      x:Key="FeedbackTypeToImageSourceConverter" /&gt; 
    &lt;Converters:BoolToVisibilityConverter  
      x:Key="BoolToVisibilityConverter" /&gt; 
    &lt;ItemsPanelTemplate x:Key="AnimatedPanel"&gt; 
      &lt;Panels:AnimatedStackPanel /&gt; 
    &lt;/ItemsPanelTemplate&gt; 
    &lt;Style x:Key="SmallImageInButtonStyle" TargetType="{x:Type Image}"  
      BasedOn="{StaticResource ImageInButtonStyle}"&gt; 
      &lt;Setter Property="Width" Value="16" /&gt; 
      &lt;Setter Property="Height" Value="16" /&gt; 
    &lt;/Style&gt; 
    &lt;DataTemplate x:Key="FeedbackTemplate" DataType="{x:Type  
      DataModels:Feedback}"&gt; 
      &lt;Grid Margin="2,1,2,0" MouseEnter="Border_MouseEnter"  
        MouseLeave="Border_MouseLeave"&gt; 
        &lt;Grid.ColumnDefinitions&gt; 
          &lt;ColumnDefinition Width="16" /&gt; 
          &lt;ColumnDefinition /&gt; 
          &lt;ColumnDefinition Width="24" /&gt; 
        &lt;/Grid.ColumnDefinitions&gt; 
        &lt;Image Stretch="None" Source="{Binding Type, 
          Converter={StaticResource FeedbackTypeToImageSourceConverter}}"  
          VerticalAlignment="Top" Margin="0,4,0,0" /&gt; 
        &lt;TextBlock Grid.Column="1" Text="{Binding Message}"  
          MinHeight="22" TextWrapping="Wrap" Margin="5,2,5,0" 
          VerticalAlignment="Top" FontSize="14" /&gt; 
        &lt;Button Grid.Column="2" ToolTip="Removes this message from the
          list" VerticalAlignment="Top" PreviewMouseLeftButtonDown=
          "DeleteButton_PreviewMouseLeftButtonDown"&gt; 
          &lt;Image Source="pack://application:,,,/ 
            CompanyName.ApplicationName;component/Images/Delete_16.png"  
            Style="{StaticResource SmallImageInButtonStyle}" /&gt; 
        &lt;/Button&gt; 
      &lt;/Grid&gt; 
    &lt;/DataTemplate&gt; 
    &lt;DropShadowEffect x:Key="Shadow" Color="Black" ShadowDepth="6"  
      Direction="270" Opacity="0.4" /&gt; 
  &lt;/UserControl.Resources&gt; 
  &lt;Border BorderBrush="{StaticResource TransparentBlack}"  
    Background="White" Padding="3" BorderThickness="1,0,1,1"  
    CornerRadius="0,0,5,5" Visibility="{Binding HasFeedback,  
    Converter={StaticResource BoolToVisibilityConverter},  
    RelativeSource={RelativeSource Mode=FindAncestor,  
    AncestorType={x:Type Controls:FeedbackControl}}}"  
    Effect="{StaticResource Shadow}"&gt; 
    &lt;ListBox MaxHeight="89" ItemsSource="{Binding Feedback,  
      RelativeSource={RelativeSource Mode=FindAncestor,  
      AncestorType={x:Type Controls:FeedbackControl}}}"  
      ItemTemplate="{StaticResource FeedbackTemplate}"  
      ItemsPanel="{StaticResource AnimatedPanel}"  
      ScrollViewer.HorizontalScrollBarVisibility="Disabled"  
      ScrollViewer.VerticalScrollBarVisibility="Auto" BorderThickness="0"  
      HorizontalContentAlignment="Stretch" /&gt; 
  &lt;/Border&gt; 
&lt;/UserControl&gt; </pre>
<p>We start by adding a number of XAML namespace prefixes for some of our application projects. Using the <kbd>Converters</kbd> prefix, we add instances of the <kbd>FeedbackTypeToImageSourceConverter</kbd> and <kbd>BoolToVisibilityConverter</kbd> classes that we saw earlier into the <kbd>UserControl.Resources</kbd> section. We also reuse our <kbd>AnimatedStackPanel</kbd> class from <a href="83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Mastering Practical Animations</em>.</p>
<p>Next, we see the <kbd>SmallImageInButtonStyle</kbd> style, which is based on the <kbd>ImageInButtonStyle</kbd> style that we also saw earlier, and adds some sizing properties. After that, we see the <kbd>FeedbackStyle</kbd> style that defines what each feedback message will look like in our feedback control.</p>
<p>Each <kbd>Feedback</kbd> object will be rendered in three columns: the first contains an image that specifies the type of feedback, using the <kbd>FeedbackTypeToImageSourceConverter</kbd> class that we saw earlier; the second displays the message with a <kbd>TextWrapping</kbd> value of <kbd>Wrap</kbd>; the third holds a button with an image, using our <kbd>SmallImageInButtonStyle</kbd> style, which users can use to remove the message.</p>
<p>Note that, as this is purely a UI control with no business logic in, we are able to use the code behind the file, even when using MVVM. As such, we attach event handlers for the <kbd>MouseEnter</kbd> and <kbd>MouseLeave</kbd> events to the <kbd>Grid</kbd> panel containing each <kbd>Feedback</kbd> object, and another for the <kbd>PreviewMouseLeftButtonDown</kbd> event to the delete button. The final resource that we have here is a <kbd>DropShadowEffect</kbd> instance that defines a small shadow effect.</p>
<p>For the feedback control, we define a <kbd>Border</kbd> element that uses a semi-transparent border brush and has a <kbd>BorderThickness</kbd> value of <kbd>1,0,1,1</kbd> and a <kbd>CornerRadius</kbd> value of <kbd>0,0,5,5</kbd>. These four values work like the <kbd>Margin</kbd> property and enable us to set different values for each of the four sides, or corners in the case of the <kbd>CornerRadius</kbd> property. In this way, we can display a rectangle that is only bordered on three sides, with rounded corners on two.</p>
<p>Note that the <kbd>Visibility</kbd> property on this border is determined by the <kbd>HasFeedback</kbd> property of the <kbd>FeedbackControl</kbd> class via an instance of our <kbd>BoolToVisibilityConverter</kbd> class. Therefore, when there are no feedback objects to display, the border will be hidden. Also note that our <kbd>Shadow</kbd> resource is applied to the border <kbd>Effect</kbd> property.</p>
<p>Inside the border, we declare a <kbd>ListBox</kbd> control, with its <kbd>ItemsSource</kbd> property set to the <kbd>Feedback</kbd> property of the <kbd>FeedbackControl</kbd> class and its height restricted to a maximum of three feedback items, after which vertical scrollbars will be shown. Its <kbd>ItemTemplate</kbd> property is set to the <kbd>FeedbackTemplate</kbd> that we defined in the resources section.</p>
<p>Its <kbd>ItemsPanel</kbd> property is set to the <kbd>AnimatedPanel</kbd> resource that we declared to animate the entrance and exit of the feedback items. Next, we remove the default border of the <kbd>ListBox</kbd> by setting the <kbd>BorderThickness</kbd> property to <kbd>0</kbd> and stretch the autogenerated <kbd>ListBoxItem</kbd> objects to fit the width of the <kbd>ListBox</kbd> control by setting the <kbd>HorizontalContentAlignment</kbd> property to <kbd>Stretch</kbd>.</p>
<p>Let's now see the code behind our feedback control:</p>
<pre>using System; 
using System.Collections.Generic; 
using System.Collections.Specialized; 
using System.Linq; 
using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Input; 
using System.Windows.Threading; 
using CompanyName.ApplicationName.DataModels; 
using CompanyName.ApplicationName.DataModels.Collections; 
using CompanyName.ApplicationName.Extensions; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public partial class FeedbackControl : UserControl 
  { 
    private static List&lt;DispatcherTimer&gt; timers =  
      new List&lt;DispatcherTimer&gt;(); 
 
    public FeedbackControl() 
    { 
      InitializeComponent(); 
    } 
 
    public static readonly DependencyProperty FeedbackProperty =  
      DependencyProperty.Register(nameof(Feedback),  
      typeof(FeedbackCollection), typeof(FeedbackControl),  
      new UIPropertyMetadata(new FeedbackCollection(),  
      (d, e) =&gt; ((FeedbackCollection)e.NewValue).CollectionChanged +=  
      ((FeedbackControl)d).Feedback_CollectionChanged));
 
    public FeedbackCollection Feedback 
    { 
      get { return (FeedbackCollection)GetValue(FeedbackProperty); } 
      set { SetValue(FeedbackProperty, value); } 
    } 
 
    public static readonly DependencyProperty HasFeedbackProperty =  
      DependencyProperty.Register(nameof(HasFeedback), typeof(bool),  
      typeof(FeedbackControl), new PropertyMetadata(true)); 
 
    public bool HasFeedback 
    { 
      get { return (bool)GetValue(HasFeedbackProperty); } 
      set { SetValue(HasFeedbackProperty, value); } 
    } 
 
    private void Feedback_CollectionChanged(object sender,  
      NotifyCollectionChangedEventArgs e) 
    { 
      if ((e.OldItems == null || e.OldItems.Count == 0) &amp;&amp;  
        e.NewItems != null &amp;&amp; e.NewItems.Count &gt; 0) 
      { 
        e.NewItems.OfType&lt;Feedback&gt;().Where(f =&gt; !f.IsPermanent). 
          ForEach(f =&gt; InitializeTimer(f)); 
      } 
      HasFeedback = Feedback.Any(); 
    } 
 
    private void InitializeTimer(Feedback feedback) 
    { 
      DispatcherTimer timer = new DispatcherTimer(); 
      timer.Interval = feedback.Duration; 
      timer.Tick += Timer_Tick; 
      timer.Tag = new Tuple&lt;Feedback, DateTime&gt;(feedback, DateTime.Now); 
      timer.Start(); 
      timers.Add(timer); 
    } 
 
    private void Timer_Tick(object sender, EventArgs e) 
    { 
      DispatcherTimer timer = (DispatcherTimer)sender; 
      timer.Stop(); 
      timer.Tick -= Timer_Tick; 
      timers.Remove(timer); 
      Feedback feedback = ((Tuple&lt;Feedback, DateTime&gt;)timer.Tag).Item1; 
      Feedback.Remove(feedback); 
    } 
 
    private void DeleteButton_PreviewMouseLeftButtonDown(object sender,  
      MouseButtonEventArgs e) 
    { 
      Button deleteButton = (Button)sender; 
      Feedback feedback = (Feedback)deleteButton.DataContext; 
      Feedback.Remove(feedback); 
    } 
 
    private void Border_MouseEnter(object sender, MouseEventArgs e) 
    { 
      foreach (DispatcherTimer timer in timers) 
      { 
        timer.Stop(); 
        Tuple&lt;Feedback, DateTime&gt; tag = 
          (Tuple&lt;Feedback, DateTime&gt;)timer.Tag; 
        tag.Item1.Duration = timer.Interval = tag.Item1.Duration. 
          Subtract(DateTime.Now.Subtract(tag.Item2)); 
      } 
    } 
 
    private void Border_MouseLeave(object sender, MouseEventArgs e) 
    { 
      foreach (DispatcherTimer timer in timers) 
      { 
        Feedback feedback = ((Tuple&lt;Feedback, DateTime&gt;)timer.Tag).Item1; 
        timer.Tag = new Tuple&lt;Feedback, DateTime&gt;(feedback, DateTime.Now); 
        timer.Start(); 
      } 
    } 
  } 
} </pre>
<p>We start by declaring the collection of <kbd>DispatcherTimer</kbd> instances that will be responsible for timing when each feedback object should be removed from the collection, according to its <kbd>Duration</kbd> property. We then see the declaration of the <kbd>Feedback</kbd> and <kbd>HasFeedback</kbd> Dependency Properties, along with their CLR wrappers and the <kbd>Feedback</kbd> property's <kbd>CollectionChanged</kbd> handler.</p>
<p>In the attached <kbd>Feedback_CollectionChanged</kbd> handler method, we call the <kbd>InitializeTimer</kbd> method, passing in each new non-permanent feedback item. Note that we need to use the <kbd>OfType</kbd> LINQ Extension Method to cast each item in the <kbd>NewItems</kbd> property of the <kbd>NotifyCollectionChangedEventArgs</kbd> class from type <kbd>object</kbd> to <kbd>Feedback</kbd>. Before returning control to the caller, we set the <kbd>HasFeedback</kbd> property accordingly.</p>
<p>In the <kbd>InitializeTimer</kbd> method, we initialize a <kbd>DispatcherTimer</kbd> instance and set its interval to the value from the <kbd>Duration</kbd> property of the <kbd>feedback</kbd> input parameter. We then attach the <kbd>Timer_Tick</kbd> event handler, add the current time and the feedback object into the <kbd>Tag</kbd> property of the timer for later use, start the timer, and add it into the <kbd>timers</kbd> collection.</p>
<p> </p>
<p>In the <kbd>Timer_Tick</kbd> method, we access the timer from the <kbd>sender</kbd> input parameter, and the <kbd>Feedback</kbd> instance from its <kbd>Tag</kbd> property. The feedback item is then removed from the <kbd>Feedback</kbd> collection, the timer is stopped and removed from the <kbd>timers</kbd> collection, and the <kbd>Tick</kbd> event handler is detached.</p>
<p>In the <kbd>DeleteButton_PreviewMouseLeftButtonDown</kbd> method, we first cast the delete button from the <kbd>sender</kbd> input parameter. We then cast the <kbd>Feedback</kbd> object from the button's <kbd>DataContext</kbd> property and remove it from the <kbd>Feedback</kbd> collection.</p>
<p>In the <kbd>Border_MouseEnter</kbd> method, we iterate through the <kbd>timers</kbd> collection and stop each timer. The interval of each timer and duration of each associated <kbd>Feedback</kbd> object is then set to the remaining time that they should be displayed for, in effect, pausing their durations.</p>
<p>Finally, we see the <kbd>Border_MouseLeave</kbd> method, which re-initializes the <kbd>Tag</kbd> property of each timer in the timers collection, with the same feedback item and the current date and time, and restarts it when the user's mouse pointer leaves the feedback control.</p>
<p>This means that the length of time that temporary feedback messages are displayed can be extended if the user moves their mouse pointer over the feedback control. This feature will hold the feedback messages in the control for as long as the user keeps their mouse pointer over the control, giving them ample time to read the messages. Let's now see what this control looks like:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2130 image-border" src="assets/50b658f8-1c36-4560-9489-144e8d742180.png" style="width:52.33em;height:22.42em;"/></div>
<p> </p>
<p>If you have menu buttons at the top of your Views, then you could alternatively have the feedback appear at the bottom of the application, or even sliding in from one of the sides. Also note that the delete buttons have not been styled, so as to shorten this example, but they should be styled in line with the other controls in a real application.</p>
<p>If you remember from <a href="b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Writing Custom Application Frameworks</em>, all of our View Models will have access to our new <kbd>FeedbackManager</kbd> class through the <kbd>FeedbackManager</kbd> property in our <kbd>BaseViewModel</kbd> class, and so we can replicate the feedback in the preceding image from any View Model like this:</p>
<pre>FeedbackManager.Add(new Feedback("Here's some information for you",  
  FeedbackType.Information)); 
FeedbackManager.Add("Something was saved successfully", true); 
FeedbackManager.Add("Something else went wrong", false); 
FeedbackManager.Add("Something else went wrong too", false); </pre>
<p><span>Let's now move on to discover how we can make our applications more responsive by maximizing the utilization of the CPU.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing multiple threads</h1>
                </header>
            
            <article>
                
<p>Traditionally, all applications were developed as single threaded applications. However, when long running background processes were running, the application UI would freeze and become unresponsive, because the single thread was busy elsewhere. This problem and other performance bottlenecks led to the current era of asynchronous programming and multi threaded applications.</p>
<p>In days gone by, creating multi-threaded applications was a complicated matter. With each successive version of the .NET Framework, Microsoft has striven to make this task easier. Originally, we only had the <kbd>Thread</kbd> class and then the <kbd>BackgroundWorker</kbd> class in .NET 2.0, but in .NET 4.0 they introduced the <kbd>Task</kbd> class, and in .NET 4.5 they introduced the <kbd>async</kbd> and <kbd>await</kbd> keywords.</p>
<p>In this section, we will explore the latter methods of multithreading and add functionality to our application framework that will enable us to perform our data retrieval and update actions asynchronously. Let's start by looking at the <kbd>async</kbd> and <kbd>await</kbd> keywords first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovering the Async and Await keywords</h1>
                </header>
            
            <article>
                
<p>Along with these new keywords, Microsoft also added a plethora of methods across the .NET Framework that end with the suffix <kbd>Async</kbd>. As the suffix hints, these methods are all asynchronous and they are used in conjunction with the new keywords. Let's start with the basic rules.</p>
<p>First of all, in <span>order</span> to use the <kbd>await</kbd> keyword in a method, the method signature <span>must</span> be declared with the <kbd>async</kbd> keyword. The <kbd>async</kbd> keyword enables us to use the <kbd>await</kbd> keyword in the method without error and is responsible for returning just the <kbd>T</kbd> generic type parameter from asynchronous methods whose signatures declare a return type of <kbd>Task&lt;T&gt;</kbd>. A method that is modified with the <kbd>async</kbd> keyword is known as an async method.</p>
<p>Async methods actually execute in a synchronous manner, until they reach an <kbd>await</kbd> expression. If there is no <kbd>await</kbd> keyword in the method, then the whole method will run synchronously and the compiler will output a warning.</p>
<p>While a portion of async methods run asynchronously, they don't in fact run on their own threads. No additional threads are created using the <kbd>async</kbd> and <kbd>await</kbd> keywords. Instead, they give the appearance of multithreading by using the current synchronization context, but only when the method is active and not when it is paused, while running an <kbd>await</kbd> expression.</p>
<p>When execution reaches an <kbd>await</kbd> keyword, the method is suspended until the awaited task has completed asynchronously. During this time, execution returns to the method caller. When the asynchronous action is complete, program execution returns to the method and the remainder of the code in it is run synchronously.</p>
<p>Async methods are required to have a particular signature. They all need to use the <kbd>async</kbd> modifier keyword, and in addition to this the names of async methods should end with the <kbd>Async</kbd> suffix to clearly signify that they are asynchronous methods. Another requirement of declaring async methods is that they cannot contain any <kbd>ref</kbd> or <kbd>out</kbd> input parameters.</p>
<p>The final requirement is that async methods can only use one of three return types: <kbd>Task</kbd>, the generic <kbd>Task&lt;TResult&gt;</kbd>, or <kbd>void</kbd>. Note that the generic <span>type</span> <kbd>TResult</kbd> parameter is the same as and can be replaced with <kbd>T</kbd>, but Microsoft refers to it as <kbd>TResult</kbd> simply because it specifies a return type.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>All async methods that return some meaningful result will use <span>type </span><kbd>Task&lt;TResult&gt;</kbd>, where the actual type of the return value will be specified by the <kbd>TResult</kbd> generic type parameter. Therefore, if we want to return a <kbd>string</kbd> from our async method, we declare that our async method returns a parameter of <span>type </span><kbd>Task&lt;string&gt;</kbd>. Let's see an example of this in action:</p>
<pre>using System; 
using System.IO; 
using System.Threading.Tasks;

...

public async Task&lt;string&gt; GetTextFileContentsAsync(string filePath) 
{ 
  string fileContents = string.Empty; 
  try 
  { 
    using (StreamReader streamReader = File.OpenText(filePath)) 
    { 
      fileContents = await streamReader.ReadToEndAsync(); 
    } 
  } 
  catch { /*Log error*/ } 
  return fileContents; 
} </pre>
<p>Here we have a simple async method that returns a <kbd>string</kbd> that represents the contents of the text file specified by the <kbd>filePath</kbd> input parameter. Note that the actual return type of the method is in fact <kbd>Task&lt;string&gt;</kbd>. In it, we first initialize the <kbd>fileContents</kbd> variable and then attempt to create a <kbd>StreamReader</kbd> instance from the <kbd>File.OpenText</kbd> method within the <kbd>using</kbd> statement.</p>
<p>Inside the <kbd>using</kbd> statement, we attempt to populate the <kbd>fileContents</kbd> variable by awaiting the result of the <kbd>ReadToEndAsync</kbd> method of the <kbd>StreamReader</kbd> class. Up until this point, the method will run synchronously. The <kbd>ReadToEndAsync</kbd> method will be called, and then control will immediately return to the caller of our async method.</p>
<p>When the return value of the <kbd>ReadToEndAsync</kbd> method is ready, execution returns to our async method and continues where it left off. In our example, there is nothing else to do but return the result string, although async methods can contain any number of lines after the <kbd>await</kbd> keyword, or even multiple <kbd>await</kbd> keywords. Note that in a real-world application, we would log any exceptions that might be thrown from this method.</p>
<p class="mce-root"/>
<p>If our async method just performs some function asynchronously, but does not return anything, then we use a return type of <kbd>Task</kbd>. That is, the task-based async method will return a <kbd>Task</kbd> object that enables it to be used with the <kbd>await</kbd> keyword, but the actual method will not return anything to the caller of that method. Let's see an example of this:</p>
<pre>using System.Text;

...

public async Task SetTextFileContentsAsync(string filePath,  
  string contents) 
{ 
  try 
  { 
    byte[] encodedFileContents = Encoding.Unicode.GetBytes(contents); 
    using (FileStream fileStream = new FileStream(filePath,  
      FileMode.OpenOrCreate, FileAccess.Write, FileShare.None, 4096, true))
    { 
      await fileStream.WriteAsync(encodedFileContents, 0,  
        encodedFileContents.Length); 
    } 
  } 
  catch { /*Log error*/ } 
} </pre>
<p>In the <kbd>SetTextFileContentsAsync</kbd> method, we first need to convert our input string to a byte array. For this reason, we now need to add a <kbd>using</kbd> directive for the <kbd>System.Text</kbd> namespace in addition to the three originally specified. Note that in this particular example, we are using <kbd>Unicode</kbd> encoding, but you are free to use any other encoding value here.</p>
<p>After using the <kbd>GetBytes</kbd> method to obtain a byte array from the <kbd>contents</kbd> input parameter, we initialize a new <kbd>FileStream</kbd> object within another <kbd>using</kbd> statement. Apart from <span>the <kbd>bool</kbd> <kbd>useAsync</kbd></span> input parameter, the remaining parameters used in the <kbd>FileStream</kbd> constructor in this example are unimportant, and you are free to replace them with values that suit your requirements better.</p>
<p>Inside the <kbd>using</kbd> statement, we see the <kbd>await</kbd> keyword used with the <kbd>WriteAsync</kbd> method. Up until this point, this method will run synchronously, and on this line it will start execution of the <kbd>WriteAsync</kbd> method and then return control to the method caller.</p>
<p>As execution leaves the <kbd>using</kbd> statement, the <kbd>FileStream</kbd> instance will be closed and disposed of. As this method has nothing to return, the return type of the async method is <kbd>Task</kbd>, which enables it to be awaited by the calling code. Again, we would typically log any exceptions that might be thrown from this method, but this is omitted here for brevity.</p>
<p class="mce-root"/>
<p>Most of us will never use the third return type option of <kbd>void</kbd> when using MVVM, because it is primarily used in event handling methods. Note that async methods that return <kbd>void</kbd> cannot be awaited and that calling code cannot catch exceptions thrown from such async methods.</p>
<p>One of the most commonly asked questions regarding async methods is "How can I create an async method from a synchronous method?" Luckily, there is a very simple solution to this using the <kbd>Task.Run</kbd> method, so let's take a quick look at it now:</p>
<pre>await Task.Run(() =&gt; SynchronousMethod(parameter1, parameter2, etc)); </pre>
<p>Here we use a Lambda expression to specify the synchronous method to run in an asynchronous context. That's all that we have to do to run a synchronous method asynchronously. However, what about the opposite requirement? Let's now see how we can run an asynchronous method synchronously. Again, the <kbd>Task</kbd> class provides us with a solution:</p>
<pre>Task task = SetFileContentsAsync(filePath, contents); 
task.RunSynchronously(); </pre>
<p class="mce-root">As we saw at the end of <a href="b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>A Smarter Way of Working with WPF</em>, in order to run an asynchronous method synchronously, we first need to instantiate a <kbd>Task</kbd> instance from our asynchronous method. Then, all we have to do is call the <kbd>RunSynchronously</kbd> method on that instance, and it will run synchronously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building asynchrony into our framework</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>Task</kbd> class, we can add functionality into our application framework that will enable us to call any data access method asynchronously. Furthermore, it will also enable us to run our data operations asynchronously when the application is running, and synchronously while testing. In order to achieve this, we will need to implement several parts, that go together to provide this functionality.</p>
<p>Let's look at the first part that will wrap each data operation and hold the result value, if applicable, along with any feedback messages or error details:</p>
<pre>using System; 
using System.Data.SqlClient; 
using CompanyName.ApplicationName.DataModels.Enums; 
using CompanyName.ApplicationName.Extensions; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public abstract class DataOperationResult&lt;T&gt; 
  { 
    public DataOperationResult(string successText) 
    { 
      Description = string.IsNullOrEmpty(successText) ?  
        "The data operation was successful" : successText; 
    } 
 
    public DataOperationResult(Exception exception, string errorText) 
    { 
      Exception = exception; 
      if (Exception is SqlException) 
      { 
        if (exception.Message.Contains("The server was not found"))
          Error = DataOperationError.DatabaseConnectionError;
        else if (exception.Message.Contains("constraint"))
          Error = DataOperationError.DatabaseConstraintError; 
        // else Description = Exception.Message; 
      } 
      if (Error != DataOperationError.None)  
        Description = Error.GetDescription(); 
      else  
      { 
        Error = DataOperationError.UndeterminedDataOperationError; 
        Description = string.IsNullOrEmpty(errorText) ?  
          Error.GetDescription() : errorText; 
      } 
    } 
 
    public DataOperationResult(Exception exception) : 
      this(exception, string.Empty) { } 
 
    public string Description { get; set; } 
 
    public DataOperationError Error { get; set; } = 
      DataOperationError.None; 
 
    public Exception Exception { get; set; } = null; 
 
    public bool IsSuccess =&gt;  
      Error == DataOperationError.None &amp;&amp; Exception == null; 
  } 
} </pre>
<p class="mce-root"/>
<p>In our abstract <kbd>DataOperationResult</kbd> class, we have a number of properties and constructor overloads. The first constructor is used for a successful set data operation and merely takes the <kbd>successText</kbd> input parameter, which is used to populate the <kbd>Description</kbd> property, unless it is <kbd>null</kbd> or empty, in which case a default successful operation message is used instead.</p>
<p>The second constructor is to be used when an exception has been thrown during the data operation, and takes the exception and an error message as input parameters. In it, we first set the <kbd>Exception</kbd> property to the exception specified by the <kbd>exception</kbd> input parameter, and then we have a chance to catch common exceptions and replace the error messages with custom messages in plain English.</p>
<p>Although we are only checking for exceptions of <span>type </span><kbd>SqlException</kbd> in this example, we could easily extend this to capture other well-known or expected exceptions, and replace their messages with custom messages using laymen terms, by adding the further <kbd>else...if</kbd> conditions.</p>
<p>Note that the <kbd>Error</kbd> property of enumeration <span>type </span><kbd>DataOperationError</kbd> is used here to set and output the predefined error messages, and we'll see that in a moment. If the exception is not one that we were expecting, then we could choose to output the actual exception message, although that would mean little to the users and could be deemed confusing or even worrying.</p>
<p>Instead, we could log the exception in the database and output the message from the <kbd>errorText</kbd> input parameter. We check whether the <kbd>Error</kbd> property has been set, and if it has, we call our <kbd>GetDescription</kbd> Extension Method to retrieve the message that relates to the set enumeration member, and set it to the <kbd>Description</kbd> property.</p>
<p>Otherwise, we set the <kbd>Error</kbd> property to the <kbd>UndeterminedDataOperationError</kbd> member and the <kbd>Description</kbd> property to the value of the <kbd>errorText</kbd> input parameter if it is not <kbd>null</kbd> or empty, or the text associated with the selected enumeration member if it is. The third constructor is also used when an exception has been thrown, but when there is no predefined feedback message.</p>
<p>After the constructors, we see the properties of the <kbd>DataOperationResult</kbd> class, most of which are self-explanatory. Of particular note is the <kbd>IsSuccess</kbd> property, which can be used by the calling code to determine what to do with the result. Let's now take a look at the <kbd>DataOperationError</kbd> enumeration class that is used to hold the error descriptions:</p>
<pre>using System.ComponentModel; 
 
namespace CompanyName.ApplicationName.DataModels.Enums 
{ 
  public enum DataOperationError 
  { 
    [Description("")] 
    None = 0, 
    [Description("A database constraint has not been adhered to, so this
      operation cannot be completed")] 
    DatabaseConstraintError = 9995, 
    [Description("There was an undetermined data operation error")] 
    UndeterminedDataOperationError = 9997, 
    [Description("There was a problem connecting to the database")] 
    DatabaseConnectionError = 9998, 
  } 
} </pre>
<p>As you can see, we utilize the <kbd>DescriptionAttribute</kbd> class to relate a humanized error message with each enumeration member. We can use the <kbd>GetDescription</kbd> Extension Method that we saw earlier to access the text values from the attributes.</p>
<p>Each enumeration member is assigned a number, and this could work well with the SQL Server error numbers if you were using SQL stored procedures or queries directly. For example, we could cast the SQL error code to the particular enumeration member to get the custom message for each error. Let's now take a look at the two classes that extend the <kbd>DataOperationResult</kbd> class:</p>
<pre>using System; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public class GetDataOperationResult&lt;T&gt; : DataOperationResult&lt;T&gt; 
  { 
    public GetDataOperationResult(Exception exception, string errorText) :
      base(exception, errorText) 
    { 
      ReturnValue = default(T); 
    } 
 
    public GetDataOperationResult(Exception exception) :  
      this(exception, string.Empty) { } 
 
    public GetDataOperationResult(T returnValue, string successText) :  
      base(successText) 
    { 
      ReturnValue = returnValue; 
    } 
 
    public GetDataOperationResult(T returnValue) : 
      this(returnValue, string.Empty) { } 
     
    public T ReturnValue { get; private set; } 
  } 
} </pre>
<p>We start with the <kbd>GetDataOperationResult</kbd> class, which is used to return the result of get data operations, or the exception details if an error occurred. It adds a <kbd>ReturnValue</kbd> property of the generic <span>type </span><kbd>T</kbd> to hold the return value of the data operation. Apart from this single member, it simply adds a number of constructors that each call the base class constructors.</p>
<p>The first is used when an exception has been thrown and sets the <kbd>ReturnValue</kbd> property to its default value, rather than leaving it as <kbd>null</kbd>. The second constructor is also used when an exception has been thrown, but when there is no predefined error message.</p>
<p>The third constructor is used for a successful data operation and sets the <kbd>ReturnValue</kbd> property to the returned value. The fourth is also used for a successful data operation, but when there is no predefined success message. It calls the third constructor, passing the returned value and an empty string for the success message. Let's now see the other class that extends the <kbd>DataOperationResult</kbd> class:</p>
<pre>using System; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public class SetDataOperationResult : DataOperationResult&lt;bool&gt; 
  { 
    public SetDataOperationResult(Exception exception, string errorText) :
       base(exception, errorText) { } 
 
    public SetDataOperationResult(string successText) :  
      base(successText) { } 
  } 
} </pre>
<p>The <kbd>SetDataOperationResult</kbd> class is used for set operations and so has no return value. Like the <kbd>GetDataOperationResult</kbd> class, its two constructors call the relevant base class constructors. The first is used when an exception has been thrown, and the second is used for a successful data operation and accepts an input parameter for the operation's success message.</p>
<p class="mce-root"/>
<p>We'll need to add a new method into our <kbd>FeedbackManager</kbd> class to enable us to add the feedback messages from our <kbd>GetDataOperationResult</kbd> and <kbd>SetDataOperationResult</kbd> classes directly. We'll also include a parameter that allows us to override whether each message will be displayed for its set duration, or until the user closes it manually. Let's take a look at that now:</p>
<pre>public void Add&lt;T&gt;(DataOperationResult&lt;T&gt; result, bool isPermanent) 
{ 
  Add(new Feedback(result.Description, result.IsSuccess, isPermanent)); 
} </pre>
<p>Note that we use the <kbd>DataOperationResult</kbd> base class as the input parameter here, so that either of our derived classes can be used with it. This method simply initializes a <kbd>Feedback</kbd> object from the <kbd>Description</kbd> and <kbd>IsSuccess</kbd> properties of the <kbd>DataOperationResult</kbd> class and passes it to the <kbd>Add</kbd> method that actually adds it to the <kbd>Feedback</kbd> collection.</p>
<p>If we're going to be making asynchronous calls to the UI feedback control, then we'll also need to ensure that they are made on the UI thread, so as to avoid the common <kbd>calling thread cannot access this object because a different thread owns it</kbd> exception.</p>
<p>To enable this, we need to add a reference to the <kbd>UiThreadManager</kbd> class, which we discussed earlier, into our <kbd>FeedbackManager</kbd> class, although here we add a reference to the <kbd>IUiThreadManager</kbd> interface instead to enable us to use a different implementation while testing:</p>
<pre>using System; 
using CompanyName.ApplicationName.Managers.Interfaces;

...

private IUiThreadManager uiThreadManager = null;

...

public IUiThreadManager UiThreadManager 
{ 
  get { return uiThreadManager; } 
  set { uiThreadManager = value; } 
} 

...

public void Add(Feedback feedback) 
{ 
  UiThreadManager.RunOnUiThread((Action)delegate 
  { 
    Feedback.Add(feedback); 
  }); 
} </pre>
<p>Using the <kbd>IUiThreadManager</kbd> interface, we simply need to wrap our single call to add feedback to the <kbd>FeedbackManager.Feedback</kbd> collection property with the <kbd>RunOnUiThread</kbd> method to run it on the UI thread. However, our <kbd>uiThreadManager</kbd> field needs to be initialized before any feedback is displayed, and we can do that from the first use of the <kbd>BaseViewModel</kbd> class:</p>
<pre>public BaseViewModel() 
{ 
  if (FeedbackManager.UiThreadManager == null) 
    FeedbackManager.UiThreadManager = UiThreadManager; 
} 

...

public IUiThreadManager UiThreadManager 
{ 
  get { return DependencyManager.Instance.Resolve&lt;IUiThreadManager&gt;(); } 
} </pre>
<p>The first time that any View Model is instantiated, this base class constructor will be called and the instance of the <kbd>IUiThreadManager</kbd> interface in the <kbd>FeedbackManager</kbd> class will be initialized. Of course, in order to correctly resolve our instance of the <kbd>IUiThreadManager</kbd> interface at runtime, we'll first need to register it in the <kbd>App.xaml.cs</kbd> file, along with the other registrations.</p>
<pre>DependencyManager.Instance.Register&lt;IUiThreadManager, UiThreadManager&gt;();</pre>
<p>Let's take a look at this interface and the classes that implement it now:</p>
<pre>using System; 
using System.Threading.Tasks; 
using System.Windows.Threading; 
 
namespace CompanyName.ApplicationName.Managers.Interfaces 
{ 
  public interface IUiThreadManager 
  { 
    object RunOnUiThread(Delegate method); 
 
    Task RunAsynchronously(Action method); 
 
    Task&lt;TResult&gt; RunAsynchronously&lt;TResult&gt;(Func&lt;TResult&gt; method); 
  } 
} </pre>
<p>The <kbd>IUiThreadManager</kbd> interface is a very simple affair and declares just three methods. The <kbd>RunOnUiThread</kbd> method is used to run code on the UI thread; the first <kbd>RunAsynchronously</kbd> method is used to run code asynchronously, and the second <kbd>RunAsynchronously</kbd> method is used to run methods that return something asynchronously. Let's now see the classes that implement it:</p>
<pre>using System; 
using System.Threading.Tasks;  
using System.Windows; 
using System.Windows.Threading; 
using CompanyName.ApplicationName.Managers.Interfaces; 
 
namespace CompanyName.ApplicationName.Managers 
{ 
  public class UiThreadManager : IUiThreadManager 
  { 
    public object RunOnUiThread(Delegate method) 
    { 
      return Application.Current.Dispatcher.Invoke( 
        DispatcherPriority.Normal, method); 
    } 
 
    public Task RunAsynchronously(Action method) 
    { 
      return Task.Run(method); 
    } 
 
    public Task&lt;TResult&gt; RunAsynchronously&lt;TResult&gt;(Func&lt;TResult&gt; method) 
    { 
      return Task.Run(method); 
    } 
  } 
} </pre>
<p>In the <kbd>UiThreadManager</kbd> class, the <kbd>RunOnUiThread</kbd> method calls the <kbd>Invoke</kbd> method on the <kbd>Application.Current.Dispatcher</kbd> object to ensure that the method that is passed to it is queued to run on the UI thread.</p>
<p class="mce-root"/>
<p>Basically, a dispatcher is responsible for maintaining the queue of work items for a particular thread, and each thread will have its own dispatcher. The <kbd>Application.Current</kbd> property returns the <kbd>Application</kbd> object for the current <kbd>AppDomain</kbd> object, and its <kbd>Dispatcher</kbd> property returns the dispatcher of the thread that was running when the application started – the UI thread.</p>
<p>As was seen earlier, the <kbd>RunAsynchronously</kbd> methods simply pass the methods specified by the <kbd>method</kbd> input parameters to the <kbd>Task.Run</kbd> method. We also saw an example of mocking the <kbd>RunAsynchronously</kbd> method in <a href="b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>A Smarter Way of Working With WPF</em>, but now let's see the whole <kbd>MockUiThreadManager</kbd> class that we could use while testing our application:</p>
<pre>using System; 
using System.Threading.Tasks; 
using System.Windows.Threading; 
using CompanyName.ApplicationName.Managers.Interfaces; 
 
namespace Test.CompanyName.ApplicationName.Mocks.Managers 
{ 
  public class MockUiThreadManager : IUiThreadManager 
  { 
    public object RunOnUiThread(Delegate method) 
    { 
      return method.DynamicInvoke(); 
    } 
 
    public Task RunAsynchronously(Action method) 
    { 
      Task task = new Task(method); 
      task.RunSynchronously(); 
      return task; 
    } 
 
    public Task&lt;TResult&gt; RunAsynchronously&lt;TResult&gt;(Func&lt;TResult&gt; method) 
    { 
      Task&lt;TResult&gt; task = new Task&lt;TResult&gt;(method); 
      task.RunSynchronously(); 
      return task; 
    } 
  } 
} </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>In the <kbd>RunOnUiThread</kbd> method, we simply call the <kbd>DynamicInvoke</kbd> method of the <kbd>Delegate</kbd> class to run the method specified by the <kbd>method</kbd> input parameter. As we saw earlier, the <kbd>RunAsynchronously</kbd> methods use the <kbd>RunSynchronously</kbd> method of the <kbd>Task</kbd> class to run the methods specified by the <kbd>method</kbd> input parameters synchronously to avoid timing problems during testing.</p>
<p>In them, we first create a new <kbd>Task</kbd> object with the method specified by the <kbd>method</kbd> input parameter, then call the <kbd>RunSynchronously</kbd> method on it, and finally return the task. When called using the <kbd>await</kbd> keyword, this will actually return the result of the method instead.</p>
<p>Let's now see, perhaps the most important part of this functionality, where the <kbd>IUiThreadManager</kbd> interface is used, the <kbd>DataOperationManager</kbd> class:</p>
<pre>using System; 
using System.Diagnostics; 
using System.Threading.Tasks; 
using System.Windows.Threading; 
using CompanyName.ApplicationName.DataModels; 
using CompanyName.ApplicationName.Managers.Interfaces; 
 
namespace CompanyName.ApplicationName.Managers 
{ 
  public class DataOperationManager 
  { 
    private const int maximumRetryCount = 2; 
    private IUiThreadManager uiThreadManager; 
 
    public DataOperationManager(IUiThreadManager uiThreadManager) 
    { 
      UiThreadManager = uiThreadManager; 
    } 
      
    private IUiThreadManager UiThreadManager 
    { 
      get { return uiThreadManager.Instance; } 
      set { uiThreadManager = value; } 
    } 
      
    private FeedbackManager FeedbackManager 
    { 
      get { return FeedbackManager.Instance; } 
    } 
 
    public GetDataOperationResult&lt;TResult&gt; TryGet&lt;TResult&gt;( 
      Func&lt;TResult&gt; method, string successText, string errorText,  
      bool isMessageSupressed) 
    { 
      Debug.Assert(method != null, "The method input parameter of the
        DataOperationManager.TryGet&lt;TResult&gt;() method must not be null."); 
      for (int index = 0; index &lt; maximumRetryCount; index++) 
      { 
        try 
        { 
          TResult result = method(); 
          return WithFeedback(
            new GetDataOperationResult&lt;TResult&gt;(result, successText), 
            isMessageSupressed); 
        } 
        catch (Exception exception) 
        { 
          if (index == maximumRetryCount - 1) 
          { 
            return WithFeedback(
              new GetDataOperationResult&lt;TResult&gt;(exception, errorText),
              isMessageSupressed); 
          } 
          Task.Delay(TimeSpan.FromMilliseconds(300)); 
        } 
      }  
      return WithFeedback(
        new GetDataOperationResult&lt;TResult&gt;(default(TResult), successText),
        isMessageSupressed); 
    } 
 
    private GetDataOperationResult&lt;TResult&gt;WithFeedback&lt;TResult&gt;(      
      GetDataOperationResult&lt;TResult&gt; dataOperationResult, bool  
      isMessageSupressed) 
    { 
      if (isMessageSupressed &amp;&amp; dataOperationResult.IsSuccess)  
        return dataOperationResult; 
      FeedbackManager.Add(dataOperationResult, false); 
      return dataOperationResult; 
    } 
      
    public Task&lt;GetDataOperationResult&lt;TResult&gt;&gt; TryGetAsync&lt;TResult&gt;(
      Func&lt;TResult&gt; method, string successText, string errorText,  
      bool isMessageSupressed) 
    { 
      return UiThreadManager.RunAsynchronously(() =&gt; 
        TryGet(method, successText, errorText, isMessageSupressed)); 
    } 
 
    public SetDataOperationResult TrySet(Action method, 
      string successText, string errorText, bool isMessagePermanent, 
      bool isMessageSupressed) 
    { 
      Debug.Assert(method != null, "The method input parameter of the
        DataOperationManager.TrySet&lt;TResult&gt;() method must not be null."); 
      for (int index = 0; index &lt; maximumRetryCount; index++) 
      { 
        try 
        { 
          method(); 
          return WithFeedback(new SetDataOperationResult(successText),
            isMessagePermanent, isMessageSupressed); 
        } 
        catch (Exception exception) 
        { 
          if (index == maximumRetryCount - 1) 
          { 
            return WithFeedback(new SetDataOperationResult(exception,
              errorText), isMessagePermanent, isMessageSupressed); 
          } 
          Task.Delay(TimeSpan.FromMilliseconds(300)); 
        } 
      } 
      return WithFeedback(new SetDataOperationResult(successText),  
        isMessagePermanent, isMessageSupressed); 
    } 
 
    private SetDataOperationResult WithFeedback( 
      SetDataOperationResult dataOperationResult, 
      bool isMessagePermanent, bool isMessageSupressed) 
    { 
      if (isMessageSupressed &amp;&amp; dataOperationResult.IsSuccess)  
        return dataOperationResult; 
      FeedbackManager.Add(dataOperationResult, isMessagePermanent); 
      return dataOperationResult; 
    } 
 
    public Task&lt;SetDataOperationResult&gt; TrySetAsync(Action method) 
    { 
      return TrySetAsync(method, string.Empty, string.Empty); 
    } 
 
    public Task&lt;SetDataOperationResult&gt; TrySetAsync(Action method,  
      string successText, string errorText) 
    { 
      return TrySetAsync(method, successText, errorText, false, false); 
    } 
 
    public Task&lt;SetDataOperationResult&gt; TrySetAsync(Action method,
      string successText, string errorText, bool isMessagePermanent,  
      bool isMessageSupressed) 
    { 
      return UiThreadManager.RunAsynchronously(() =&gt; TrySet(method, 
        successText, errorText, isMessagePermanent, isMessageSupressed)); 
    } 
  } 
} </pre>
<p>The <kbd>DataOperationManager</kbd> class starts with a couple of private fields, which represent the maximum number of attempts to retry each data operation in case there is a problem, and the instance of the <kbd>IUiThreadManager</kbd> interface to use to run our functions asynchronously when running the application.</p>
<p>The constructor enables us to inject the <kbd>IUiThreadManager</kbd> dependency into the class and sets it to the private <kbd>UiThreadManager</kbd> property, which can only be accessed from within the class. Likewise, the <kbd>FeedbackManager</kbd> property is also private and enables us to pass feedback messages to the manager class to display them in the UI.</p>
<p>Next, we see the generic <kbd>TryGet&lt;TResult&gt;</kbd> method that returns an object of the <span>type</span> <kbd>GetDataOperationResult&lt;TResult&gt;</kbd>. More specifically, it returns a generic object of the <span>type</span> <kbd>TResult</kbd> wrapped in one of our <kbd>GetDataOperationResult</kbd> objects. It first asserts that the <kbd>method</kbd> input parameter is not <kbd>null</kbd>, as this class is based around the required parameter.</p>
<p>In this method, we create a loop, with the number of its iterations determined by the value of the <kbd>maximumRetryCount</kbd> field, and inside the loop we try to run the function specified by the <kbd>method</kbd> input parameter. If the data operation is successful, we initialize a <kbd>GetDataOperationResult</kbd> object, passing the return value and success feedback message, and return it via the <kbd>WithFeedback</kbd> method.</p>
<p>If an error occurs and the maximum number of attempts have not yet been reached, then we use the asynchronous <kbd>Task.Delay</kbd> method to wait before attempting to run the method again. If the maximum number of errors has been reached, then the exception and error feedback message are wrapped in a <kbd>GetDataOperationResult</kbd> object and returned via the <kbd>WithFeedback</kbd> method.</p>
<p>One improvement that we could implement here would be to increase this delay time each time we retry the data operation. We could implement a function that returns an exponentially increasing number, based on the <kbd>maximumRetryCount</kbd> field, representing the millisecond value that will be passed to the <kbd>Task.Delay</kbd> method. This would be more likely to handle short network drop outs better.</p>
<p class="mce-root"/>
<p>The <kbd>WithFeedback</kbd> method enables developers to suppress successful feedback messages, as they might not always need the users to receive feedback. For example, we may not need to inform them that their data objects were fetched from the database successfully, if they have been, or are soon to be, displayed on the screen.</p>
<p>Therefore, if the data operation was successful and the <kbd>isMessageSupressed</kbd> input parameter is <kbd>true</kbd>, the data operation result is returned directly, without feedback. Otherwise, the <kbd>dataOperationResult</kbd> input parameter object is passed to the <kbd>FeedbackManager</kbd> class to display the associated message, using the new methods that we added earlier.</p>
<p>Next, we see the asynchronous <kbd>TryGetAsync</kbd> method that simply calls the <kbd>TryGet</kbd> method via the <kbd>RunAsynchronously</kbd> method of the <kbd>UiThreadManager</kbd> class. After that, we have the <kbd>TrySet</kbd> method that is responsible for running all set data operations, and returns an object of the <span>type</span> <kbd>SetDataOperationResult</kbd>.</p>
<p>This method is very similar to the <kbd>TryGet</kbd> method, except that it works for set data operations. Similarly, it first asserts that the <kbd>method</kbd> input parameter is not <kbd>null</kbd> and then runs the remainder of the code within a for loop. This again enables our retry capability, and is limited by the value of the <kbd>maximumRetryCount</kbd> field.</p>
<p>In the method, we try to run the function specified by the <kbd>method</kbd> input parameter, and if the data operation is successful, we initialize a <kbd>SetDataOperationResult</kbd> object, passing just the success feedback message and return it via the <kbd>WithFeedback</kbd> method.</p>
<p>If an error occurs and the number of attempts specified by the <kbd>maximumRetryCount</kbd> field has not yet been reached, then we use the <kbd>Task.Delay</kbd> method to wait before attempting to run the method again. If the maximum number of errors has been reached, then the exception and error feedback message are wrapped in a <kbd>SetDataOperationResult</kbd> object and returned via the <kbd>WithFeedback</kbd> method.</p>
<p>The <kbd>WithFeedback</kbd> method used with the <kbd>SetDataOperationResult</kbd> objects works exactly the same as the earlier one that works with the generic <kbd>GetDataOperationResult</kbd> objects. Finally, we have some overloaded <kbd>TrySetAsync</kbd> methods that end up calling the <kbd>TrySet</kbd> method asynchronously via the <kbd>RunAsynchronously</kbd> method of the <kbd>UiThreadManager</kbd> class.</p>
<p>One point to note here is that, currently, this class is located in the <kbd>Managers</kbd> project. If we were at all likely to need to swap out our data access technology, then we might prefer to move this class to the data access project for ease of removal. As it stands, we don't have that requirement, and so it is fine where it is.</p>
<p class="mce-root"/>
<p>We can make use of this <kbd>DataOperationManager</kbd> class in the <kbd>DataController</kbd> class that we saw earlier, with just a few changes. We can also replace its previous <kbd>SetAuditCreateFields</kbd> and <kbd>SetAuditUpdateFields</kbd> methods with some new methods that also update our data models that implement the <kbd>ISynchronizableDataModel</kbd> interface. Let's take a look at the new code in there:</p>
<pre>using System; 
using System.Threading.Tasks; 
using CompanyName.ApplicationName.DataModels; 
using CompanyName.ApplicationName.DataModels.Collections; 
using CompanyName.ApplicationName.DataModels.Enums; 
using CompanyName.ApplicationName.DataModels.Interfaces; 
using CompanyName.ApplicationName.Managers; 
using CompanyName.ApplicationName.Models.Interfaces; 
 
namespace CompanyName.ApplicationName.Models.DataControllers 
{ 
  public class DataController 
  {
    ...

    private DataOperationManager dataOperationManager;
 
    public DataController(IDataProvider dataProvider,  
      DataOperationManager dataOperationManager, User currentUser) 
    { 
      ... 
      DataOperationManager = dataOperationManager;  
      CurrentUser = <span>c</span>urrentUser.Clone();
    } 
 
    protected DataOperationManager DataOperationManager 
    { 
      get { return dataOperationManager; } 
      private set { dataOperationManager = value; } 
    }
 
    ... 
 
    public Task&lt;SetDataOperationResult&gt; AddProductAsync(Product product) 
    { 
      return DataOperationManager.TrySetAsync(() =&gt;  
        DataProvider.AddProduct(InitializeDataModel(product)), 
        $"{product.Name} was added to the data source successfully", $"A 
        problem occurred and {product.Name} was not added to the data 
        source."); 
    } 
 
    public Task&lt;SetDataOperationResult&gt; DeleteProductAsync( 
      Product product) 
    { 
      return DataOperationManager.TrySetAsync(() =&gt;  
        DataProvider.DeleteProduct(DeleteDataModel(product)), 
        $"{product.Name} has been deleted from the data source 
        successfully.", $"A problem occurred and {product.Name} was not
        deleted from the data source.", true, false); 
    } 
 
    public Task&lt;GetDataOperationResult&lt;Products&gt;&gt; GetProductsAsync() 
    { 
      return DataOperationManager.TryGetAsync(() =&gt;  
        DataProvider.GetProducts(), string.Empty, "A problem occurred when
        trying to retrieve the products.", true); 
    } 
 
    public SetDataOperationResult UpdateProduct(Product product) 
    { 
      return DataOperationManager.TrySet(() =&gt;  
        DataProvider.UpdateProduct(UpdateDataModel(product)), 
        $"{product.Name} was saved in the data source successfully.", $"A
        problem occurred and {product.Name} was not updated in the data 
        source.", false, false); 
    } 
 
    private T InitializeDataModel&lt;T&gt;(T dataModel)  
      where T : class, IAuditable, new() 
    { 
      dataModel.Auditable = new Auditable(dataModel, <span>CurrentUser</span>); 
      if (dataModel is ISynchronizableDataModel&lt;T&gt;) 
      { 
        ISynchronizableDataModel&lt;T&gt; synchronisableDataModel =  
          (ISynchronizableDataModel&lt;T&gt;)dataModel; 
        synchronisableDataModel.ObjectState = ObjectState.Active; 
      } 
      return dataModel; 
    } 
 
    private T DeleteDataModel&lt;T&gt;(T dataModel)  
      where T : class, IAuditable, new() 
    { 
      dataModel.Auditable.UpdatedOn = DateTime.Now; 
      dataModel.Auditable.UpdatedBy = <span>CurrentUser</span>; 
      if (dataModel is ISynchronizableDataModel&lt;T&gt;) 
      { 
        ISynchronizableDataModel&lt;T&gt; synchronisableDataModel =  
          (ISynchronizableDataModel&lt;T&gt;)dataModel; 
        synchronisableDataModel.ObjectState = ObjectState.Deleted; 
      } 
      return dataModel; 
    } 
 
    private T UpdateDataModel&lt;T&gt;(T dataModel)  
      where T : class, IAuditable, new() 
    { 
      dataModel.Auditable.UpdatedOn = DateTime.Now; 
      dataModel.Auditable.UpdatedBy = <span>CurrentUser</span>; 
      return dataModel; 
    } 
  } 
} </pre>
<p>We start this class with the <kbd>dataOperationManager</kbd> field of the <span>type</span> <kbd>DataOperationManager</kbd>. We don't need to use an interface here, as this class is safe to be used during testing. However, it contains a member of the <span>type</span> <kbd>IUiThreadManager</kbd>, and we need to be able to use different implementations of this, depending on whether we're running or testing the application.</p>
<p>Therefore, we still need to inject the instance of the <kbd>dataOperationManager</kbd> field to use through the constructor, so that its instance of the <kbd>IUiThreadManager</kbd> interface can be resolved in the calling code. After the constructor, we see the private <kbd>DataOperationManager</kbd> property that can only be set from within the class.</p>
<p>The first of the new methods is the <kbd>AddProductAsync</kbd> method, and as a set operation it returns a <kbd>Task</kbd> of the <span>type</span> <kbd>SetDataOperationResult</kbd>. Internally, and like all async set operations here, it calls the <kbd>TrySetAsync</kbd> method of the <kbd>DataOperationManager</kbd> class. It passes the method to run asynchronously and the success and unspecified error text to be displayed as user feedback.</p>
<p>Note that we pass the <kbd>product</kbd> input parameter to the <kbd>InitializeDataModel</kbd> method, before passing it to the <kbd>AddProduct</kbd> method of the <kbd>IDataProvider</kbd> instance, to initialize the base class <kbd>Auditable</kbd> property before it is stored in the database.</p>
<p>If the current instance also extends the <kbd>ISynchronizableDataModel</kbd> interface, then its <kbd>ObjectState</kbd> property will be set to the <kbd>Active</kbd> member of the <kbd>ObjectState</kbd> enumeration. This idea could easily be extended; if we had an <kbd>IIdentifiable</kbd> interface with a single identification property, we could initialize that here as well.</p>
<p class="mce-root"/>
<p>The <kbd>DeleteProductAsync</kbd> method also returns a <kbd>Task</kbd> of the <span>type</span> <kbd>SetDataOperationResult</kbd> and calls the <kbd>TrySetAsync</kbd> method of the <kbd>DataOperationManager</kbd> class, but it uses a different overload, which enables the feedback message to be displayed permanently or until the user manually closes it. In this example, it is used to ensure that the user is aware that the product was deleted.</p>
<p>In this method, we pass the <kbd>product</kbd> input parameter to the <kbd>DeleteDataModel</kbd> method, before passing it to the <kbd>DeleteProduct</kbd> method of the <kbd>IDataProvider</kbd> instance. This sets the <kbd>UpdatedOn</kbd> property of the <kbd>Auditable</kbd> class to the current date and time and the <kbd>UpdatedBy</kbd> property to the currently logged-in user. If the current instance extends the <kbd>ISynchronizableDataModel</kbd> interface, then its <kbd>ObjectState</kbd> property will also be set to a state of <kbd>Deleted</kbd>.</p>
<p>The next new method is the <kbd>GetProductsAsync</kbd> method, which is a get operation and returns a <kbd>Task</kbd> of the <span>type</span> <kbd>GetDataOperationResult&lt;Products&gt;</kbd>. Internally, and like all async get operations, it calls the <kbd>TryGetAsync</kbd> method of the <kbd>DataOperationManager</kbd> class. It passes the method to run asynchronously and the unspecified error text to be displayed as user feedback.</p>
<p>Of particular note here is the <kbd>bool</kbd> parameter that it passes, which suppresses any successful feedback message from being displayed. If there is an error, either the provided error message or a more well-defined custom error message will be displayed, but as no successful message is displayed, we simply pass an empty string through for that parameter.</p>
<p>The final new data operation method is the <kbd>UpdateProduct</kbd> method, which is not asynchronous, and returns a <kbd>SetDataOperationResult</kbd> directly. Instead of the <kbd>TrySetAsync</kbd> method, it calls the <kbd>TrySet</kbd> method of the <kbd>DataOperationManager</kbd> class and passes the method to run the success and error messages and two <kbd>bool</kbd> parameters to signify that it should display the feedback normally.</p>
<p>Internally, it passes the <kbd>product</kbd> input parameter to the <kbd>UpdateDataModel</kbd> method, before passing it to the <kbd>UpdateProduct</kbd> method of the <kbd>IDataProvider</kbd> instance. This sets the <kbd>UpdatedOn</kbd> property of the <kbd>Auditable</kbd> class to the current date and time and the <kbd>UpdatedBy</kbd> property to the currently logged-in user.</p>
<p>This gives an example of how we might build up our data operation methods, predominantly using asynchronous access methods but not restricted to having to do so. Of course, there are many ways of accessing data in an application, and you should experiment with the way that suits you best. This way would suit larger scale applications best, as there is a fair amount of overhead in creating this system.</p>
<p class="mce-root"/>
<p>However, there's still one piece of the puzzle missing. Now that we've changed the constructor of the <kbd>DataController</kbd> class, we'll also need to update our <kbd>BaseViewModel</kbd> class, which exposes it, again:</p>
<pre>protected DataController Model 
{ 
  get { return new DataController(
    DependencyManager.Instance.Resolve&lt;IDataProvider&gt;(), 
    new DataOperationManager(UiThreadManager), 
    StateManager.CurrentUser); } 
}

...

public IUiThreadManager UiThreadManager 
{ 
  get { return DependencyManager.Instance.Resolve&lt;IUiThreadManager&gt;(); } 
} </pre>
<p>Now, the <kbd>IDataProvider</kbd> implementation is resolved by the <kbd>DependencyManager</kbd> instance, along with the <kbd>IUiThreadManager</kbd> implementation that gets injected into the <kbd>DataOperationManager</kbd> object. In addition to this, we pass the value of the <kbd>StateManager.CurrentUser</kbd> property to the <kbd>DataController</kbd> class constructor to instantiate it each time it is requested.</p>
<p>Now we have a system in place that can run our data operations either synchronously or asynchronously and retry our data operations a specified number of times if they fail, before finally reporting custom feedback messages to the user.</p>
<p>We can customize how long these messages remain visible before automatically disappearing, or whether they will automatically disappear or not, or even whether they are displayed in the first place or not. Even with these options, the system remains lightweight and can be easily added to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going the extra mile</h1>
                </header>
            
            <article>
                
<p>Most privately developed applications are primarily functional, with little time and effort spent on design concerns and even less on usability. How many times have we seen applications that throw out a stack trace to the end user when an error occurs, or validation messages that highlight errors with the camel case code names for fields, rather than the labels used in the UI?</p>
<p>In a good application, the end user should never be presented with any code-based terminology. If we were writing an English based application, we wouldn't output error messages in Spanish, so <em>why</em> output them in C#? This can confuse the user and even alarm them in some cases.</p>
<p>How many times have you used an application that has an awkward process flow to perform each task that involves far more mouse clicks than is necessary? This section is dedicated to avoiding these kinds of situations and suggests a number of ways of improving the usability of our applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Producing in-application help</h1>
                </header>
            
            <article>
                
<p>In an ideal world, we would all create applications that were so intuitive that we wouldn't need to provide in-application help. However, with the complexity of some of today's applications, this is not always possible. It is therefore often helpful to provide the end users of our applications with some form of help that they can refer to when necessary.</p>
<p>There are a number of ways of doing this, with the first simply being to provide a link to a separate help file from the application. If we have a PDF, or other type of file that contains help for the users, we can add it to our solution in Visual Studio as a resource.</p>
<p>To do this, we can add a <kbd>Resources</kbd> folder into our solution and then select the <span class="packt_screen">Add New Item</span> option in the new folder's context menu. After navigating to the help file in the <span class="packt_screen">Add New Item</span> dialog and successfully adding it, we can view its properties by selecting it in the <span class="packt_screen">Solution Explorer</span> and pressing <em><span class="KeyPACKT">F4</span></em>, or right clicking it and selecting <span class="packt_screen">Properties</span> from the context menu.</p>
<p>Once the properties are displayed, we can verify that the file has been added with a <span class="packt_screen">Build Action</span> of <span class="packt_screen">Content</span> and a <span class="packt_screen">Copy to Output Directory</span> value of <span class="packt_screen">Copy always</span> or <span class="packt_screen">Copy if newer</span>, which ensures that our help file and its <kbd>Resources</kbd> folder will be copied to the folder that contains the application executable file, and that the newest version will always be used.</p>
<p>We can then add a menu item or button to our application, which the users can select to open the document directly. In our View Model command that is data bound to this control, we can call the <kbd>Start</kbd> method of the <kbd>Process</kbd> class, passing the path of the help file, to open the file in the default application on the user's computer:</p>
<pre>System.Diagnostics.Process.Start(filePath); </pre>
<p>We can get the folder path of the application executable file, using the following code:</p>
<pre>string filePath = System.AppDomain.CurrentDomain.BaseDirectory; </pre>
<p>Therefore, if our <kbd>Resources</kbd> folder is in the startup project, we could attain its folder path like this:</p>
<pre>string filePath = Path.Combine(
  new DirectoryInfo(System.AppDomain.CurrentDomain.BaseDirectory).
  Parent.Parent.FullName, "Resources"); </pre>
<p>This utilizes the <kbd>DirectoryInfo</kbd> class to access the parent folder of the executable file, or the root directory of the project, and the <kbd>Combine</kbd> method of the <kbd>Path</kbd> class to create a file path that combines the new <kbd>Resources</kbd> folder with that path.</p>
<p>If we don't have a complete documentation file for our application, a quick and simple alternative would be to add an information icon to each View. This image control could display pertinent information to the users in a tooltip when they place their mouse pointer over it<span>:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2077 image-border" src="assets/8383fe40-40bb-48f9-b5c2-4b12b43f1548.png" style="width:18.00em;height:7.50em;"/></div>
<p>Using the information icon from the Visual Studio Image Library that was discussed in <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Creating Visually Appealing User Interfaces</em>, we can create these help points like this:</p>
<pre>&lt;Image Source="pack://application:,,,/CompanyName.ApplicationName; 
  component/Images/Information_16.png" Stretch="None" ToolTip="Here is  
  some relevant information" /&gt; </pre>
<p>Either way, the idea is to provide the users of the application with any help that they may need right from the application itself. This not only improves the usability of our applications but also reduces user errors and increases data quality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling user preferences</h1>
                </header>
            
            <article>
                
<p>The users of our applications are likely to be very different to each other, or at least have their individual preferences. One user may prefer to work in one way, while another may have different preferences. Providing the ability for them to customize the application to suit the way they work will increase the usability of the application for them.</p>
<p>This may relate to the View that they prefer to see when the application starts, or to which particular options in each View that they prefer to use, or even to the size and position of the application when it was last used. There are any number of preferences that we can offer each user.</p>
<p>Luckily, we can offer this customization functionality with minimal work, as the .NET Framework provides us with settings files for just this purpose. These settings can either have application or user scope and can be mixed and matched in each settings file.</p>
<p>Application settings are the same for each user and are suited to storing configuration settings, such as email server details or credentials. User settings can be different for each user and are suited to the kind of personal customizations just discussed.</p>
<p>Typically, the startup project will already have a settings file named <kbd>Settings.settings</kbd>. It can be found by opening the <kbd>Properties</kbd> folder in the <span class="packt_screen">Solution Explorer</span> in Visual Studio, and opened by double-clicking on it. Alternatively, you can right-click on the project in the <span class="packt_screen">Solution Explorer</span>, select the <span class="packt_screen">Properties</span> option, and then select the <span class="packt_screen">Settings</span> tab<span>:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2078 image-border" src="assets/1c19c851-ed84-4e7b-91d5-6289d9a0095c.png" style="width:36.58em;height:22.25em;"/></div>
<p class="mce-root"/>
<p>Settings files can also be added to other projects although they are not typically available by default. In order to add a settings file to another project, we first need to open the project properties by right clicking on the project in the <span class="packt_screen">Solution Explorer</span> and selecting the <span class="packt_screen">Properties</span> option.</p>
<p>In the project properties window, select the <span class="packt_screen">Settings</span> tab and click the link that says <span class="packt_screen">This project does not contain a default settings file. Click here to create one</span>. A settings file will be created within the project <kbd>Properties</kbd> folder in the <span class="packt_screen">Solution Explorer</span>. We are then free to start adding our user preferences<span>:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2136 image-border" src="assets/d80b38d1-0f81-44f9-85fe-cb1d23184363.png" style="width:45.00em;height:13.75em;"/></div>
<p>To add our custom settings, click a blank row in the settings file and enter the name, data type, scope, and default value of the setting. The name will be used in code, and so it cannot contain spaces. We can select our own custom data types, although whichever type we select must be serializable. The default value is the initial value that the setting will have before the user changes it.</p>
<p>Settings will usually be loaded upon application startup and saved just before application shutdown. As such, it is customary to attach event handlers to the <kbd>Loaded</kbd> and <kbd>Closed</kbd> events in the <kbd>MainWindow.xaml.cs</kbd> file, although we can also do it in the <kbd>App.xaml.cs</kbd> file if we have configured the application to use it. We can see a typical example here:</p>
<pre>using System; 
using System.Windows; 
using CompanyName.ApplicationName.ViewModels; 
 
namespace CompanyName.ApplicationName 
{ 
  public partial class MainWindow : Window 
  { 
    public MainWindow() 
    { 
      InitializeComponent(); 
      Loaded += MainWindow_Loaded; 
      Closed += MainWindow_Closed; 
    } 
 
    private void MainWindow_Loaded(object sender, RoutedEventArgs e) 
    { 
      MainWindowViewModel viewModel = new MainWindowViewModel(); 
      viewModel.LoadSettings(); 
      DataContext = viewModel; 
    } 
 
    private void MainWindow_Closed(object sender, EventArgs e) 
    { 
      MainWindowViewModel viewModel = (MainWindowViewModel)DataContext; 
      viewModel.SaveSettings(); 
    } 
  } 
} </pre>
<p>We attach the two event handlers in the constructor, right after the components are initialized. In the <kbd>MainWindow_Loaded</kbd> method, we instantiate an instance of the <kbd>MainWindowViewModel</kbd> class, call its <kbd>LoadSettings</kbd> method, and set it as the window's <kbd>DataContext</kbd> property value.</p>
<p>In the <kbd>MainWindow_Closed</kbd> method, we access the instance of the <kbd>MainWindowViewModel</kbd> class from the <kbd>DataContext</kbd> property, but, this time, call its <kbd>SaveSettings</kbd> method. Now, let's see these methods in the <kbd>MainWindowViewModel.cs</kbd> file:</p>
<pre>using CompanyName.ApplicationName.ViewModels.Properties;

...

public void LoadSettings() 
{ 
  Settings.Default.Reload(); 
  StateManager.AreAuditFieldsVisible =
    Settings.Default.AreAuditFieldsVisible; 
  StateManager.AreSearchTermsSaved = Settings.Default.AreSearchTermsSaved; 
} 
 
public void SaveSettings() 
{ 
  Settings.Default.AreAuditFieldsVisible = 
    StateManager.AreAuditFieldsVisible;
  Settings.Default.AreSearchTermsSaved = StateManager.AreSearchTermsSaved;
  Settings.Default.Save(); 
} </pre>
<p>The first thing that we need to do in the <kbd>L</kbd><kbd>oadSettings</kbd> method is to call the <kbd>Reload</kbd> method on the default instance of the settings file. This loads the settings from the settings file into the <kbd>Default</kbd> object. From there, we set each settings property to its corresponding property that we created in our <kbd>StateManager</kbd> class, for use in the application.</p>
<p>Note that the values of each user's personal settings are not stored in the <kbd>Settings.settings</kbd> file. Instead, they are stored in their <kbd>AppData</kbd> folder, which is hidden by default. The exact file path can be found using the <kbd>ConfigurationManager</kbd> class, but to find it we'll need to add a reference to the <kbd>System.Configuration</kbd> DLL and use the following code:</p>
<pre>using System.Configuration;

...

string filePath = ConfigurationManager.OpenExeConfiguration( 
  ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath; </pre>
<p>In my case, that resolves to the following file path:</p>
<pre>C:\Users\Sheridan\AppData\Local\CompanyName\  
  CompanyName.ApplicationNa_Url_0nu0qp14li5newll2223u0ytheisf2gh\
  1.0.0.0\user.config </pre>
<p>Note that the folder in the <kbd>CompanyName</kbd> folder is named using a particular identification number that relates to the current settings and application version. Over time and after making changes, new folders will appear here with new identification numbers, but this is all totally transparent to the users as their previous settings will be safely transferred.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending common courtesies</h1>
                </header>
            
            <article>
                
<p>One area of application development where we can easily make great improvements is usability. Many applications these days are created with little or no concern for the end users that will be using the application each day.</p>
<p>We've probably all seen applications that spew out exception stack traces when errors occur, and while we, as developers, may find that useful, it can be confusing or even alarming for the end users. Instead of worrying the end users unnecessarily, we can output stack traces and any other pertinent information about each error to an <kbd>Errors</kbd> table in our database.</p>
<p>Extending this idea further, it is good working practice to totally avoid using any development terms or phrases anywhere in the application that the users can see. That includes all UI labels along with any additional external help files and documentation. Using terms of this kind will make the application more difficult to use, especially for new users. All but the best known abbreviations should also be avoided.</p>
<p>We can further humanize our application by paying attention to the small details. How often have you come across an application that displays a label that says something like "1 passengers" or "2 item." While this is a very simple problem to fix, it is commonly found in many applications. Let's create a new Extension Method to encapsulate this useful functionality in an <kbd>IntegerExtensions</kbd> class:</p>
<pre>public static string Pluralize(this int input, string wordToAdjust) 
{ 
  return $"{wordToAdjust}{(input == 1 ? string.Empty : "s")}"; 
} </pre>
<p>In this example, we simply use String Interpolation to append an <kbd>s</kbd> to the end of the <kbd>wordToAdjust</kbd> input parameter when the value of the this <kbd>input</kbd> parameter is not <kbd>1</kbd>. While this will work for most words that we are likely to use, it is worth noting that there are some groups of words that this will not work with.</p>
<p>For example, some words, such as "Activity," ending with a "y" in their singular form, will end with "ies" when pluralized. However, this problem can be easily addressed by either adding a new overload of our <kbd>Pluralize</kbd> method or an additional input parameter that enables the users of our code to specify the transformation that they require.</p>
<p>With this method, we now have a really simple way to always ensure that our spelling is correct when dealing with quantities. Let's see how we might use this method to pluralize the word <kbd>Ticket</kbd>, but only when the amount of tickets in the <kbd>Tickets</kbd> collection is not <kbd>1</kbd><span>:</span></p>
<pre>public string TicketCountText =&gt; Tickets.Count.Pluralize("Ticket"); </pre>
<p>An extension to this method could combine this functionality with the actual number to output <kbd>6 Tickets</kbd> , for example. Let's take a look at this new method<span>:</span></p>
<pre>public static string Combine(this int input, string wordToAdjust) 
{ 
  return $"{input} {wordToAdjust}{(input == 1 ? string.Empty : "s")}"; 
} </pre>
<p>The <kbd>Combine</kbd> method is very similar to the <kbd>Pluralize</kbd> method, except that it also includes the value of the <kbd>input</kbd> input parameter in the text output. We could also extend this method in the same way that we could extend the <kbd>Pluralize</kbd> method to handle the pluralization of words other than those that just require an <kbd>s</kbd> to be appended. We can also use it in the same way:</p>
<pre>public string TicketCountText =&gt; Tickets.Count.Combine("Ticket"); </pre>
<p>Another way that we could humanize our textual output would be to provide a selection summary field that displays a comma-separated list of the selected items in a collection control. Clearly, this wouldn't be required for controls that only allow single selections to be made; however, it could be a useful confirmation for those using multiple selection collection controls. Let's see how we could declare a <kbd>ToCommaSeparatedString</kbd> method now:</p>
<pre>using System.Text;

...

public static string ToCommaSeparatedString&lt;T&gt;( 
  this IEnumerable&lt;T&gt; collection) 
{ 
  StringBuilder stringBuilder = new StringBuilder(); 
  int index = 0; 
  foreach (T item in collection) 
  { 
    if (index &gt; 0) 
    { 
      if (index &lt; collection.Count() - 1) stringBuilder.Append(", "); 
      else if (index == collection.Count() - 1)  
        stringBuilder.Append(" and "); 
    } 
    stringBuilder.Append(item.ToString()); 
    index++; 
  } 
  return stringBuilder.ToString(); 
} </pre>
<p>Here, we have a method that we can call on any collection that is either of the type of, or extends, the <kbd>IEnumerable&lt;T&gt;</kbd> interface and receives a string back that contains a comma-separated list of each contained element. We can either call it with a string collection or implement the <kbd>object.ToString</kbd> method in our classes, as that will be called on each element.</p>
<p>This method uses the <kbd>StringBuilder</kbd> class to build the comma-separated list. As the <kbd>StringBuilder</kbd> class has a slight overhead when being initialized and when exporting the constructed string, tests have shown that it only really offers an improvement in time over basic string concatenation when appending 10 or more strings.</p>
<p>You may therefore prefer to refactor this method to remove the <kbd>StringBuilder</kbd> object, although you may also find that the difference in milliseconds is negligible. Returning to the method, after declaring the <kbd>StringBuilder</kbd> object, we initialize the <kbd>index</kbd> variable, which is used to specify which separator to join each string with.</p>
<p>When the <kbd>index</kbd> variable equals zero and no strings have yet been added to the <kbd>StringBuilder</kbd> object, no separator will be appended. After that, we check whether the current string is the last in the collection, and if it is, we prepend <kbd>" and <span>"</span></kbd> to it; otherwise, we prepend a comma and a space to it.</p>
<p>After each iteration, we increment the <kbd>index</kbd> variable, and when finished, we return the output from the <kbd>StringBuilder</kbd> object. It could be used to display a comma-separated list of the products that a user has selected like this:</p>
<pre>SelectedProducts.Select(p =&gt; p.Name).ToCommaSeparatedString(); </pre>
<p>As you can see, there are many ways that we can humanize our output for the end users, to make them feel more at ease when using our applications. Let's now move on to see other ways that we can provide that great user experience for our users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unburdening the end user</h1>
                </header>
            
            <article>
                
<p>There are many things that we can do to make the life of the end users easier. One simple example would be to set the focus in a form to the first field, so that users can start typing as soon as they load a View, without first needing to focus it manually.</p>
<p>We saw one way to do this using an Attached Property in <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Becoming Proficient with Data Binding</em>, but we can also achieve this easily, by first adding a new <kbd>bool</kbd> property into our <kbd>BaseViewModel</kbd> class<span>:</span></p>
<pre>private bool isFocused = false;

...

public bool IsFocused 
{ 
  get { return isFocused; } 
  set { if (isFocused != value) { isFocused = value;
    NotifyPropertyChanged(); } } 
}</pre>
<p>Next we can add a style resource into the application resources in the <kbd>App.xaml</kbd> file:</p>
<pre>&lt;Style TargetType="{x:Type TextBox}"&gt; 
  &lt;!-- Define default TextBox style here --&gt; 
&lt;/Style&gt; 
&lt;Style x:Key="FocusableTextBoxStyle" TargetType="{x:Type TextBox}"  
  BasedOn="{StaticResource {x:Type TextBox}}"&gt; 
  &lt;Style.Triggers&gt; 
    &lt;DataTrigger Binding="{Binding IsFocused}" Value="True"&gt; 
      &lt;Setter Property="FocusManager.FocusedElement"  
        Value="{Binding RelativeSource={RelativeSource Self}}" /&gt; 
    &lt;/DataTrigger&gt; 
  &lt;/Style.Triggers&gt; 
&lt;/Style&gt; </pre>
<p>This assumes that we already have a default style that we want to use for our <span><kbd>TextBox</kbd> controls</span> and that our new style will be based on that, but add this additional focusable functionality. It simply consists of a single data trigger that uses the <kbd>FocusedElement</kbd> property of the <kbd>FocusManager</kbd> class to focus the <kbd>TextBox</kbd> element that has this style applied to it when the <kbd>IsFocused</kbd> property is set to <kbd>true</kbd>.</p>
<p>Therefore, all we need to do to focus a particular <kbd><span>TextBox</span></kbd> control in a View is to apply this style to it and set the <kbd>IsFocused</kbd> property from the <kbd>BaseViewModel</kbd> class to <kbd>true</kbd> in the appropriate place in the related View Model<span>:</span></p>
<pre>IsFocused = true; </pre>
<p>Note that the <kbd><span>TextBox</span></kbd><span> control</span> will become focused as the property becomes <kbd>true</kbd> , and so if the property is already <kbd>true</kbd>, we may need to first set it to <kbd>false</kbd> before again setting it to <kbd>true</kbd> to get this to work. For example, if the property was <kbd>true</kbd> before the View was loaded, then the <kbd><span>TextBox</span></kbd><span> control</span> would not become focused.</p>
<p>Another simple example of making our application users' lives easier would be to pre-populate any form fields that we may be able to. For example, if our application has a login screen that uses the users' Windows username, we could fill in the user name field in the form after accessing it from the <kbd>WindowsIdentity</kbd> class like this:</p>
<pre>UserName = WindowsIdentity.GetCurrent().Name; </pre>
<p>Another example of this might be to pre-populate form fields with the most commonly used values. We could perhaps fill in a date field with today's date or an Amount Paid field to the total amount, if that is what the users typically do.</p>
<p>We do, however, need to be careful when doing this because if we get the default value(s) wrong, it could backfire and actually take the users longer to delete the default value and replace it with the value that they want than to just input the value directly. Remember, the idea is to save the users time and make them more productive.</p>
<p>Quite often, we can save the users of our applications a great amount of time. If we have the chance to ask them exactly what they do and how they would use the application on a day-to-day basis, then we can usually program a lot of their operations into functions in the application.</p>
<p>For example, if any users have to repeatedly edit a number of files with the same data, perhaps to add, remove, or update a particular field, then we could build that functionality straight into the application.</p>
<p>Instead of making them edit a single record at a time, we could provide a View where they set the field, or fields to change, and the new value(s), along with the ability to select multiple records, and therefore save them a great deal of time and effort.</p>
<p>All menial, or repetitive tasks can be programmed into functions, and so writing a good application is not just restricted to making pretty and asynchronous UIs but also to making it highly usable. Furthermore, the more useful the application is, the more productive the users will become, and the more lavish the praise that will be bestowed on us and our development teams, if applicable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed further ways to improve our applications, making them as useful to the end users as possible. We investigated how we could implement a custom user feedback system to keep the users informed with the status of the operations that they perform.</p>
<p>We also examined how to make our applications asynchronous, so that our UI won't freeze when the application is performing long running operations. We then looked at one way of building this asynchronous behavior right into our application framework so that we can run any data access operation asynchronously with minimal code.</p>
<p>We ended with a short section dedicated to improving the way that our applications are perceived by the end users. In it, we detailed a number of ways of accomplishing this, from providing in-application help and user preferences to paying attention to the smaller details and implementing work-heavy functions to save the users from having to manually do the same.</p>
<p>In the next chapter, we'll be looking at a number of ways to improve the performance of our applications, from utilizing the power of installed graphics cards to writing more efficient code. We'll also look into how we can improve the efficiency of our data bindings and resources, and investigate other techniques, such as data virtualization.</p>


            </article>

            
        </section>
    </body></html>