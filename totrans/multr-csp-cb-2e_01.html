<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Threading Basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Threading Basics</h1></div></div></div><p>In this chapter, we will cover the basic tasks to work with threads in C#. You will learn the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a thread in C#</li><li class="listitem" style="list-style-type: disc">Pausing a thread</li><li class="listitem" style="list-style-type: disc">Making a thread wait</li><li class="listitem" style="list-style-type: disc">Aborting a thread</li><li class="listitem" style="list-style-type: disc">Determining a thread state</li><li class="listitem" style="list-style-type: disc">Thread priority</li><li class="listitem" style="list-style-type: disc">Foreground and background threads</li><li class="listitem" style="list-style-type: disc">Passing parameters to a thread</li><li class="listitem" style="list-style-type: disc">Locking with a C# lock keyword</li><li class="listitem" style="list-style-type: disc">Locking with a <code class="literal">Monitor</code> construct</li><li class="listitem" style="list-style-type: disc">Handling exceptions</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction</h1></div></div></div><p>At some point of time in the past, the common computer had only one computing unit and could not execute several computing tasks simultaneously. However, operating systems could already work with multiple programs simultaneously, implementing the concept of multitasking. To prevent the possibility of one program taking control of the CPU forever, causing other applications and the operating system itself to hang, the operating systems had to split a physical computing unit across a few virtualized processors in some way and give a certain amount of computing power to each executing program. Moreover, an operating system must always have priority access to the CPU and should be able to prioritize CPU access to different programs. A thread is an implementation of this concept. It could be considered as a  virtual processor that is given to the one specific program and runs it independently.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Remember that a thread consumes a significant amount of operating system resources. Trying to share one physical processor across many threads will lead to a situation where an operating system is busy just managing threads instead of running programs.</p></div></div><p>Therefore, while it was possible to enhance computer processors, making them execute more and more commands per second, working with threads was usually an operating system task. There was no sense in trying to compute some tasks in parallel on a single-core CPU because it would take more time than running those computations sequentially. However, when processors started to have more computing cores, older programs could not take advantage of this because they just used one processor core.</p><p>To use a modern processor's computing power effectively, it is very important to be able to compose a program in a way that it can use more than one computing core, which leads to organizing it as several threads that communicate and synchronize with each other.</p><p>The recipes in this chapter focus on performing some very basic operations with threads in the C# language. We will cover a thread's life cycle, which includes creating, suspending, making a thread wait, and aborting a thread, and then, we will go through the basic synchronization techniques.</p></div></div>
<div class="section" title="Creating a thread in C#"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Creating a thread in C#</h1></div></div></div><p>Throughout <a id="id0" class="indexterm"/>the following recipes, we will use Visual Studio 2015 as the <a id="id1" class="indexterm"/>main tool to write multithreaded programs in C#. This recipe will show you how to create a new C# program and use threads in it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>A free Visual Studio Community 2015 IDE can be downloaded from the Microsoft website and used to run the code samples.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found in the <code class="literal">BookSamples\Chapter1\Recipe1</code> directory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for this book from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>You can download the code files by following these steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Log in or register to our website using your e-mail address and password.</li><li class="listitem" style="list-style-type: disc">Hover the mouse pointer on the <span class="strong"><strong>SUPPORT</strong></span> tab at the top.</li><li class="listitem" style="list-style-type: disc">Click on <span class="strong"><strong>Code Downloads &amp; Errata</strong></span>.</li><li class="listitem" style="list-style-type: disc">Enter the name of the book in the <span class="strong"><strong>Search</strong></span> box.</li><li class="listitem" style="list-style-type: disc">Select the book for which you're looking to download the code files.</li><li class="listitem" style="list-style-type: disc">Choose from the drop-down menu where you purchased this book from.</li><li class="listitem" style="list-style-type: disc">Click on <span class="strong"><strong>Code Download</strong></span>.</li></ul></div><p>Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">WinRAR/7-Zip for Windows</li><li class="listitem" style="list-style-type: disc">Zipeg/iZip / UnRarX for Mac</li><li class="listitem" style="list-style-type: disc">7-Zip/PeaZip for Linux</li></ul></div></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>How to do it...</h2></div></div></div><p>To understand how to <a id="id2" class="indexterm"/>create a new C# program and use threads in it, perform the <a id="id3" class="indexterm"/>following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Make sure that the project uses .NET Framework 4.6 or higher; however, the code in this chapter will work with previous versions.<div class="mediaobject"><img src="graphics/B05292_01_01.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <a id="id4" class="indexterm"/><code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> <a id="id5" class="indexterm"/>directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void PrintNumbers()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    WriteLine(i);
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">Thread t = new Thread(PrintNumbers);
t.Start();
PrintNumbers();</pre></div></li><li class="listitem">Run the program. The output will be something like the following screenshot:<div class="mediaobject"><img src="graphics/B05292_01_02.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How it works...</h2></div></div></div><p>In step 1 and 2, we created a simple console application in C# using .Net Framework version 4.0. Then, in step 3, we included the <code class="literal">System.Threading</code> namespace, which contains all the types needed for the program. Then, we used the <code class="literal">using static</code> feature from C# 6.0, which allows us to use the <code class="literal">System.Console</code> type's static methods without specifying the type name.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>An instance of a program that is being executed can be referred to as a process. A process consists of one or more threads. This means that when we run a program, we always have one main thread that executes the program code.</p></div></div><p>In step 4, we defined the <code class="literal">PrintNumbers</code> method, which will be used in both the main and newly created <a id="id6" class="indexterm"/>threads. Then, in step 5, we created a thread that runs <a id="id7" class="indexterm"/>
<code class="literal">PrintNumbers</code>. When we construct a thread, an instance of the <code class="literal">ThreadStart</code> or <code class="literal">ParameterizedThreadStart</code> delegate is passed to the constructor. The C# compiler creates this object behind the scenes when we just type the name of the method we want to run in a different thread. Then, we start a thread and run <code class="literal">PrintNumbers</code> in the usual manner on the main thread.</p><p>As a result, there will be two ranges of numbers from 1 to 10 randomly crossing each other. This illustrates <a id="id8" class="indexterm"/>that the <code class="literal">PrintNumbers</code> method runs simultaneously on the main thread and on the other thread.</p></div></div>
<div class="section" title="Pausing a thread"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Pausing a thread</h1></div></div></div><p>This recipe <a id="id9" class="indexterm"/>will show you how to make a thread wait for some time without wasting operating system resources.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe2</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>How to do it...</h2></div></div></div><p>To understand how to make a thread wait without wasting operating system resources, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void PrintNumbers()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    WriteLine(i);
  }
}
static void PrintNumbersWithDelay()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(2));
    WriteLine(i);
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">Thread t = new Thread(PrintNumbersWithDelay);
t.Start();
PrintNumbers();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>How it works...</h2></div></div></div><p>When the program is run, it creates a thread that will execute a code in the <code class="literal">PrintNumbersWithDelay</code> method. Immediately after that, it runs the <code class="literal">PrintNumbers</code> method. The key feature <a id="id10" class="indexterm"/>here is adding the <code class="literal">Thread.Sleep</code> method call to a <code class="literal">PrintNumbersWithDelay</code> method. It causes the thread executing this code to wait a specified amount of time (2 seconds in our case) before printing each number. While a thread sleeps, it uses as little CPU time as possible. As a result, we will see that the code in the <code class="literal">PrintNumbers</code> method, which usually runs later, will be executed before the code in the <code class="literal">PrintNumbersWithDelay</code> method in a separate thread.</p></div></div>
<div class="section" title="Making a thread wait"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Making a thread wait</h1></div></div></div><p>This recipe will <a id="id11" class="indexterm"/>show you how a program can wait for some computation in another thread to complete to use its result later in the code. It is not enough to use the <code class="literal">Thread.Sleep</code> method because we don't know the exact time the computation will take.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe3</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How to do it...</h2></div></div></div><p>To understand how a program waits for some computation in another thread to complete in order to use its result later, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void PrintNumbersWithDelay()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(2));
    WriteLine(i);
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">WriteLine("Starting...");
Thread t = new Thread(PrintNumbersWithDelay);
t.Start();
t.Join();
WriteLine("Thread completed");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How it works...</h2></div></div></div><p>When the program is run, it runs a long-running thread that prints out numbers and waits two seconds before <a id="id12" class="indexterm"/>printing each number. But, in the main program, we called the <code class="literal">t.Join</code> method, which allows us to wait for the thread <code class="literal">t</code> to complete working. When it is complete, the main program continues to run. With the help of this technique, it is possible to synchronize execution steps between two threads. The first one waits until another one is complete and then continues to work. While the first thread waits, it is in a <code class="literal">blocked</code> state (as it is in the previous recipe when you call <code class="literal">Thread.Sleep</code>).</p></div></div>
<div class="section" title="Aborting a thread"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Aborting a thread</h1></div></div></div><p>In this recipe, we will <a id="id13" class="indexterm"/>describe how to abort another thread's execution.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe4</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How to do it...</h2></div></div></div><p>To understand how to abort another thread's execution, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;</pre></div></li><li class="listitem">Using the static <code class="literal">System.Threading.Thread</code>, add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void PrintNumbersWithDelay()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(2));
    WriteLine(i);
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">WriteLine("Starting program...");
Thread t = new Thread(PrintNumbersWithDelay);
t.Start();
Thread.Sleep(TimeSpan.FromSeconds(6));
t.Abort();
WriteLine("A thread has been aborted");
Thread t = new Thread(PrintNumbers);
t.Start();
PrintNumbers();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How it works...</h2></div></div></div><p>When the main program <a id="id14" class="indexterm"/>and a separate number-printing thread run, we wait for six seconds and then call a <code class="literal">t.Abort</code> method on a thread. This injects a <code class="literal">ThreadAbortException</code> method into a thread, causing it to terminate. It is very dangerous, generally because this exception can happen at any point and may totally destroy the application. In addition, it is not always possible to terminate a thread with this technique. The target thread may refuse to abort by handling this exception by calling the <code class="literal">Thread.ResetAbort</code> method. Thus, it is not recommended that you use the <code class="literal">Abort</code> method to close a thread. There are different methods that are preferred, such as providing a <code class="literal">CancellationToken</code> object to cancel a thread execution. This approach will be described in <a class="link" href="ch03.html" title="Chapter 3. Using a Thread Pool">Chapter 3</a>, <span class="emphasis"><em>Using a Thread Pool</em></span>.</p></div></div>
<div class="section" title="Determining a thread state"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Determining a thread state</h1></div></div></div><p>This recipe will <a id="id15" class="indexterm"/>describe the possible states a thread could have. It is useful to get information about whether a thread is started yet or whether it is in a blocked state. Note that because a thread runs independently, its state could be changed at any time.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe5</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How to do it...</h2></div></div></div><p>To understand how to determine a thread state and acquire useful information about it, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void DoNothing()
{
  Sleep(TimeSpan.FromSeconds(2));
}

static void PrintNumbersWithStatus()
{
  WriteLine("Starting...");
  WriteLine(CurrentThread.ThreadState.ToString());
  for (int i = 1; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(2));
    WriteLine(i);
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">WriteLine("Starting program...");
Thread t = new Thread(PrintNumbersWithStatus);
Thread t2 = new Thread(DoNothing);
WriteLine(t.ThreadState.ToString());
t2.Start();
t.Start();
for (int i = 1; i &lt; 30; i++)
{
  WriteLine(t.ThreadState.ToString());
}
Sleep(TimeSpan.FromSeconds(6));
t.Abort();
WriteLine("A thread has been aborted");
WriteLine(t.ThreadState.ToString());
WriteLine(t2.ThreadState.ToString());</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How it works...</h2></div></div></div><p>When the main program <a id="id16" class="indexterm"/>starts, it defines two different threads; one of them will be aborted and the other runs successfully. The thread state is located in the <code class="literal">ThreadState</code> property of a <code class="literal">Thread</code> object, which is a C# enumeration. At first, the thread has a <code class="literal">ThreadState.Unstarted</code> state. Then, we run it and assume that for the duration of 30 iterations of a cycle, the thread will change its state from <code class="literal">ThreadState.Running</code> to <code class="literal">ThreadState.WaitSleepJoin</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>Note that the current <code class="literal">Thread</code> object is always accessible through the <code class="literal">Thread.CurrentThread</code> static property.</p></div></div><p>If this does not happen, just increase the number of iterations. Then, we abort the first thread and see that now it has a <code class="literal">ThreadState.Aborted</code> state. It is also possible that the program will print out the <code class="literal">ThreadState.AbortRequested</code> state. This illustrates, very well, the complexity of synchronizing two threads. Keep in mind that you should not use thread abortion in your programs. I've covered it here only to show the corresponding thread state.</p><p>Finally, we can see that our second thread <code class="literal">t2</code> was completed successfully and now has a <code class="literal">ThreadState.Stopped</code> state. There are several other states, but they are partly deprecated and not as useful as those we examined.</p></div></div>
<div class="section" title="Thread priority"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Thread priority</h1></div></div></div><p>This recipe will <a id="id17" class="indexterm"/>describe the different options for thread priority. Setting a thread priority determines how much CPU time a thread will be given.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe6</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How to do it...</h2></div></div></div><p>To understand the <a id="id18" class="indexterm"/>workings of thread priority, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;
using static System.Diagnostics.Process;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void RunThreads()
{
  var sample = new ThreadSample();

  var threadOne = new Thread(sample.CountNumbers);
  threadOne.Name = "ThreadOne";
  var threadTwo = new Thread(sample.CountNumbers);
  threadTwo.Name = "ThreadTwo";

  threadOne.Priority = ThreadPriority.Highest;
  threadTwo.Priority = ThreadPriority.Lowest;
  threadOne.Start();
  threadTwo.Start();

  Sleep(TimeSpan.FromSeconds(2));
  sample.Stop();
}

class ThreadSample
{
  private bool _isStopped = false;

  public void Stop()
  {
    _isStopped = true;
  }

  public void CountNumbers()
  {
    long counter = 0;

    while (!_isStopped)
    {
      counter++;
    }

    WriteLine($"{CurrentThread.Name} with " +
      $"{CurrentThread.Priority,11} priority " +
      $"has a count = {counter,13:N0}");
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">WriteLine($"Current thread priority: {CurrentThread.Priority}");
WriteLine("Running on all cores available");
RunThreads();
Sleep(TimeSpan.FromSeconds(2));
WriteLine("Running on a single core");
GetCurrentProcess().ProcessorAffinity = new IntPtr(1);
RunThreads();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How it works...</h2></div></div></div><p>When the main program starts, it defines two different threads. The first one, <code class="literal">threadOne</code>, has the highest thread priority <code class="literal">ThreadPriority.Highest</code>, while the second one, that is <code class="literal">threadTwo</code>, has the lowest <code class="literal">ThreadPriority.Lowest</code> priority. We print out the main thread priority value and then start these two threads on all available cores. If we have more than one computing core, we should get an initial result within two seconds. The highest priority thread should calculate more iterations usually, but both values should be close. However, if there are any other programs running that load all the CPU cores, the situation could be quite different.</p><p>To simulate this situation, we <a id="id19" class="indexterm"/>set up the <code class="literal">ProcessorAffinity</code> option, instructing the operating system to run all our threads on a single CPU core (number 1). Now, the results should be very different, and the calculations will take more than two seconds. This happens because the CPU core runs mostly the high-priority thread, giving the rest of the threads very little time.</p><p>Note that this is an illustration of how an operating system works with thread prioritization. Usually, you <a id="id20" class="indexterm"/>should not write programs relying on this behavior.</p></div></div>
<div class="section" title="Foreground and background threads"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Foreground and background threads</h1></div></div></div><p>This recipe will <a id="id21" class="indexterm"/>describe what foreground and background threads are and how <a id="id22" class="indexterm"/>setting this option affects the program's behavior.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe7</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How to do it...</h2></div></div></div><p>To understand the effect of foreground and background threads on a program, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">class ThreadSample
{
  private readonly int _iterations;

  public ThreadSample(int iterations)
  {
    _iterations = iterations;
  }
  public void CountNumbers()
  {
    for (int i = 0; i &lt; _iterations; i++)
    {
      Sleep(TimeSpan.FromSeconds(0.5));
      WriteLine($"{CurrentThread.Name} prints {i}");
    }
  }
}</pre></div></li><li class="listitem">Add the <a id="id23" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var sampleForeground = new ThreadSample(10);
var sampleBackground = new ThreadSample(20);

var threadOne = new Thread(sampleForeground.CountNumbers);
threadOne.Name = "ForegroundThread";
var threadTwo = new Thread(sampleBackground.CountNumbers);
threadTwo.Name = "BackgroundThread";
threadTwo.IsBackground = true;

threadOne.Start();
threadTwo.Start();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How it works...</h2></div></div></div><p>When the main program starts, it defines two different threads. By default, a thread that we create explicitly is a foreground thread. To create a background thread, we manually set the <code class="literal">IsBackground</code> <a id="id24" class="indexterm"/>property of the <code class="literal">threadTwo</code> object to <code class="literal">true</code>. We configure these threads in a way that the first one will be completed faster, and then we run the program.</p><p>After the first thread is complete, the program shuts down and the background thread is terminated. This is the main difference between the two: a process waits for all the foreground threads to complete before finishing the work, but if it has background threads, they just shut down.</p><p>It is also important to mention that if a program defines a foreground thread that does not get completed; the main program does not end properly.</p></div></div>
<div class="section" title="Passing parameters to a thread"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Passing parameters to a thread</h1></div></div></div><p>This recipe will <a id="id25" class="indexterm"/>describe how to provide code that we run in another <a id="id26" class="indexterm"/>thread with the required data. We will go through the different ways to fulfill this task and review common mistakes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe8</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How to do it...</h2></div></div></div><p>To understand how to <a id="id27" class="indexterm"/>pass parameters to a thread, perform the <a id="id28" class="indexterm"/>following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void Count(object iterations)
{
  CountNumbers((int)iterations);
}

static void CountNumbers(int iterations)
{
  for (int i = 1; i &lt;= iterations; i++)
  {
    Sleep(TimeSpan.FromSeconds(0.5));
    WriteLine($"{CurrentThread.Name} prints {i}");
  }
}

static void PrintNumber(int number)
{
  WriteLine(number);
}

class ThreadSample
{
  private readonly int _iterations;

  public ThreadSample(int iterations)
  {
    _iterations = iterations;
  }
  public void CountNumbers()
  {
    for (int i = 1; i &lt;= _iterations; i++)
    {
      Sleep(TimeSpan.FromSeconds(0.5));
            WriteLine($"{CurrentThread.Name} prints {i}");
    }
  }
}</pre></div></li><li class="listitem">Add the <a id="id29" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> <a id="id30" class="indexterm"/>method:<div class="informalexample"><pre class="programlisting">var sample = new ThreadSample(10);

var threadOne = new Thread(sample.CountNumbers);
threadOne.Name = "ThreadOne";
threadOne.Start();
threadOne.Join();

WriteLine("--------------------------");

var threadTwo = new Thread(Count);
threadTwo.Name = "ThreadTwo";
threadTwo.Start(8);
threadTwo.Join();

WriteLine("--------------------------");

var threadThree = new Thread(() =&gt; CountNumbers(12));
threadThree.Name = "ThreadThree";
threadThree.Start();
threadThree.Join();
WriteLine("--------------------------");

int i = 10;
var threadFour = new Thread(() =&gt; PrintNumber(i));
i = 20;
var threadFive = new Thread(() =&gt; PrintNumber(i));
threadFour.Start(); 
threadFive.Start();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How it works...</h2></div></div></div><p>When the main program starts, it first creates an object of the <code class="literal">ThreadSample</code> class, providing it with a number of iterations. Then, we start a thread with the object's <code class="literal">CountNumbers</code> method. This method runs in another thread, but it uses the number <code class="literal">10</code>, which is the value that we passed to the object's constructor. Therefore, we just passed this number of iterations to another thread in the same indirect way.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>There's more…</h2></div></div></div><p>Another way to pass data is to use the <code class="literal">Thread.Start</code> method by accepting an object that can be passed to another thread. To work this way, a method that we started in another thread must accept one single parameter of the type <code class="literal">object</code>. This option is illustrated by creating a <code class="literal">threadTwo</code> thread. We pass <code class="literal">8</code> as an object to the <code class="literal">Count</code> method, where it is cast to an <code class="literal">integer</code> type.</p><p>The next option involves the use of lambda expressions. A lambda expression defines a method that does not belong to any class. We create such a method that invokes another method with the arguments needed and start it in another thread. When we start the <code class="literal">threadThree</code> thread, it <a id="id31" class="indexterm"/>prints out 12 numbers, which are exactly the numbers we passed to it via the lambda expression.</p><p>The use of lambda expressions involves another C# construct named <code class="literal">closure</code>. When we use any local variable in a <a id="id32" class="indexterm"/>lambda expression, C# generates a class and makes this variable a property of this class. So, actually, we do the same thing as in the <code class="literal">threadOne</code> thread, but we do not define the class ourselves; the C# compiler does this automatically.</p><p>This could lead to several problems; for example, if we use the same variable from several lambdas, they will actually share this variable value. This is illustrated by the previous example where, when we start <code class="literal">threadFour</code> and <code class="literal">threadFive</code>, they both print <code class="literal">20</code> because the variable was changed to hold the value <code class="literal">20</code> before both threads were started.</p></div></div>
<div class="section" title="Locking with a C# lock keyword"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Locking with a C# lock keyword</h1></div></div></div><p>This recipe will <a id="id33" class="indexterm"/>describe how to ensure that when one thread uses some resource, another does not simultaneously use it. We will see why this is needed and what the thread safety concept is all about.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe9</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>How to do it...</h2></div></div></div><p>To understand how to use the C# lock keyword, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;</pre></div></li><li class="listitem">Add the <a id="id34" class="indexterm"/>following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void TestCounter(CounterBase c)
{
  for (int i = 0; i &lt; 100000; i++)
  {
    c.Increment();
    c.Decrement();
  }
}

class Counter : CounterBase
{
  public int Count { get; private set; }

  public override void Increment()
  {
    Count++;
  }

  public override void Decrement()
  {
    Count--;
  }
}

class CounterWithLock : CounterBase
{
  private readonly object _syncRoot = new Object();

  public int Count { get; private set; }

  public override void Increment()
  {
    lock (_syncRoot)
    {
      Count++;
    }
  }

  public override void Decrement()
  {
    lock (_syncRoot)
    {
      Count--;
    }
  }
}

abstract class CounterBase
{
  public abstract void Increment();

  public abstract void Decrement();
}</pre></div></li><li class="listitem">Add the <a id="id35" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">WriteLine("Incorrect counter");

var c = new Counter();

var t1 = new Thread(() =&gt; TestCounter(c));
var t2 = new Thread(() =&gt; TestCounter(c));
var t3 = new Thread(() =&gt; TestCounter(c));
t1.Start();
t2.Start();
t3.Start();
t1.Join();
t2.Join();
t3.Join();

WriteLine($"Total count: {c.Count}");
WriteLine("--------------------------");

WriteLine("Correct counter");

var c1 = new CounterWithLock();

t1 = new Thread(() =&gt; TestCounter(c1));
t2 = new Thread(() =&gt; TestCounter(c1));
t3 = new Thread(() =&gt; TestCounter(c1));
t1.Start();
t2.Start();
t3.Start();
t1.Join();
t2.Join();
t3.Join();
WriteLine($"Total count: {c1.Count}");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How it works...</h2></div></div></div><p>When the main program starts, it first creates an object of the <code class="literal">Counter</code> class. This class defines a simple counter that can be incremented and decremented. Then, we start three threads that share the same counter instance and perform an increment and decrement in a cycle. This leads to nondeterministic results. If we run the program several times, it will print out several different counter values. It could be <code class="literal">0</code>, but mostly won't be.</p><p>This happens <a id="id36" class="indexterm"/>because the <code class="literal">Counter</code> class is not thread-safe. When several threads access the counter at the same time, the first thread gets the counter value <code class="literal">10</code> and increments it to <code class="literal">11</code>. Then, a second thread gets the value <code class="literal">11</code> and increments it to <code class="literal">12</code>. The first thread gets the counter value <code class="literal">12</code>, but before a decrement takes place, a second thread gets the counter value <code class="literal">12</code> as well. Then, the first thread decrements <code class="literal">12</code> to <code class="literal">11</code> and saves it into the counter, and the second thread simultaneously does the same. As a result, we have two increments and only one decrement, which is obviously not right. This kind of a situation is called a race condition and is a very common cause of errors in a multithreaded environment.</p><p>To make sure that this does not happen, we must ensure that while one thread works with the counter, all other threads wait until the first one finishes the work. We can use the <code class="literal">lock</code> keyword to achieve this kind of behavior. If we lock an object, all the other threads that require an access to this object will wait in a blocked state until it is unlocked. This could be a serious performance issue and later, in <a class="link" href="ch02.html" title="Chapter 2. Thread Synchronization">Chapter 2</a>, <span class="emphasis"><em>Thread Synchronization</em></span>, you will learn more about this.</p></div></div>
<div class="section" title="Locking with a Monitor construct"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Locking with a Monitor construct</h1></div></div></div><p>This recipe <a id="id37" class="indexterm"/>illustrates another common multithreaded error called a deadlock. Since a deadlock will cause a program to stop working, the first piece in this example is a new <code class="literal">Monitor</code> construct that allows us to avoid a deadlock. Then, the previously described <code class="literal">lock</code> keyword is used to get a deadlock.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe10</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>How to do it...</h2></div></div></div><p>To understand the <a id="id38" class="indexterm"/>multithreaded error deadlock, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void LockTooMuch(object lock1, object lock2)
{
  lock (lock1)
  {
    Sleep(1000);
    lock (lock2);
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">object lock1 = new object();
object lock2 = new object();

new Thread(() =&gt; LockTooMuch(lock1, lock2)).Start();

lock (lock2)
{
  Thread.Sleep(1000);
  WriteLine("Monitor.TryEnter allows not to get stuck, returning false after a specified timeout is elapsed");
  if (Monitor.TryEnter(lock1, TimeSpan.FromSeconds(5)))
  {
    WriteLine("Acquired a protected resource succesfully");
  }
  else
  {
    WriteLine("Timeout acquiring a resource!");
  }
}

new Thread(() =&gt; LockTooMuch(lock1, lock2)).Start();

WriteLine("----------------------------------");
lock (lock2)
{
  WriteLine("This will be a deadlock!");
  Sleep(1000);
  lock (lock1)
  {
    WriteLine("Acquired a protected resource succesfully");
  }
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>How it works...</h2></div></div></div><p>Let's start with the <code class="literal">LockTooMuch</code> method. In this method, we just lock the first object, wait for a second, and then lock the second object. Then, we start this method in another thread and try to lock the second object and then the first object from the main thread.</p><p>If we use the <code class="literal">lock</code> keyword like in the second part of this demo, there will be a deadlock. The first thread <a id="id39" class="indexterm"/>holds a <code class="literal">lock</code> on the <code class="literal">lock1</code> object and waits while the <code class="literal">lock2</code> object gets free; the main thread holds a <code class="literal">lock</code> on the <code class="literal">lock2</code> object and waits for the <code class="literal">lock1</code> object to become free, which will never happen in this situation.</p><p>Actually, the <code class="literal">lock</code> keyword is syntactic sugar for the <code class="literal">Monitor</code> class usage. If we were to disassemble code with <code class="literal">lock</code>, we would see that it turns into the following code snippet:</p><div class="informalexample"><pre class="programlisting">bool acquiredLock = false;
try
{
  Monitor.Enter(lockObject, ref acquiredLock);

// Code that accesses resources that are protected by the lock.

}
finally
{
  if (acquiredLock)
  {
    Monitor.Exit(lockObject);
  }
}</pre></div><p>Therefore, we can use the <code class="literal">Monitor</code> class directly; it has the <code class="literal">TryEnter</code> method, which accepts a timeout parameter <a id="id40" class="indexterm"/>and returns <code class="literal">false</code> if this timeout parameter expires before we can acquire the resource protected by <code class="literal">lock</code>.</p></div></div>
<div class="section" title="Handling exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Handling exceptions</h1></div></div></div><p>This recipe will describe how to handle exceptions in other threads properly. It is very important to always <a id="id41" class="indexterm"/>place a <code class="literal">try/catch</code> block inside the thread because it is not possible to catch an exception outside a thread's code.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe11</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How to do it...</h2></div></div></div><p>To understand the handling of exceptions in other threads, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void BadFaultyThread()
{
  WriteLine("Starting a faulty thread...");
  Sleep(TimeSpan.FromSeconds(2));
  throw new Exception("Boom!");
}

static void FaultyThread()
{
  try
  {
    WriteLine("Starting a faulty thread...");
    Sleep(TimeSpan.FromSeconds(1));
    throw new Exception("Boom!");
  }
  catch (Exception ex)
  {
    WriteLine($"Exception handled: {ex.Message}");
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var t = new Thread(FaultyThread);
t.Start();
t.Join();

try
{
  t = new Thread(BadFaultyThread);
  t.Start();
}
catch (Exception ex)
{
  WriteLine("We won't get here!");
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>How it works...</h2></div></div></div><p>When the main program starts, it defines two threads that will throw an exception. One of these threads handles an exception, while the other does not. You can see that the second exception is not caught by a <code class="literal">try/catch</code> block around the code that starts the thread. So, if you work with <a id="id42" class="indexterm"/>threads directly, the general rule is to not throw an exception from a thread, but to use a <code class="literal">try/catch</code> block inside a thread code instead.</p><p>In the older versions of .NET Framework (1.0 and 1.1), this behavior was different and uncaught exceptions did not force an application shutdown. It is possible to use this policy by adding an application configuration file (such as <code class="literal">app.config</code>) that contains the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;configuration&gt;
  &lt;runtime&gt;
    &lt;legacyUnhandledExceptionPolicy enabled="1" /&gt;
  &lt;/runtime&gt;
&lt;/configuration&gt;</pre></div></div></div></body></html>