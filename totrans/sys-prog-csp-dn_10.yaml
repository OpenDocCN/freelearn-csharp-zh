- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Systems Check-Ups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Logging, Monitoring,* *and Metrics*'
  prefs: []
  type: TYPE_NORMAL
- en: Now and then, software fails. Whether we like it or not, that is simply a fact
    of life. We make mistakes during development. Other people make mistakes. The
    environment changes. A network becomes unstable. These are all reasons the system
    might not behave as we intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing can help. A good and solid set of tests can show you the errors in
    your work and help make your system more robust. However, sometimes things still
    go wrong. Let’s face it: building software is a creative art form and thus subject
    to influences beyond our control. So, when things go wrong and our systems do
    not do what we thought they would be doing, we need a way to look into their workings.
    That can help us figure out what happened and what we can do to fix things.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where logging and monitoring comes into play. Logging helps us write
    important information and store it in a well-known place. Logging is part of our
    code base. Monitoring is watching the system from the outside to track what is
    happening. In this chapter, I will show you exactly how to do everything from
    a systems developer’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What logging frameworks are there?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I set up the correct levels of logging?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is structured logging?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I monitor my logs outside my system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is monitoring?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I set up monitoring?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What should I monitor or log?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you are as excited about this as I am!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we look into monitoring and logging tools. One of the tools
    I often use is **Seq**. I am not affiliated with them; it is just a tool I like
    to use. You can download a free-to-use personal version at [https://datalust.co/download](https://datalust.co/download).
    You can download the installer or run the tool as a Docker image. To use this,
    you have to install Docker on your environment. I suggest you go to [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)
    to learn more about Docker. If you want to play around, I suggest you choose the
    Docker version. You can run the image locally by invoking the following command
    from a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This Docker command downloads the image from `datalust/seq`. It listens to ports
    `80` for the `5341` to intercept logs. All settings are stored in the `C:\data`
    folder, so you must create that folder beforehand (or change the `-v` property
    in the Docker command).
  prefs: []
  type: TYPE_NORMAL
- en: 'I will also show you how to use Prometheus in this chapter. To get that up
    and running, you could do the same thing. Either download the software from their
    website at [https://prometheus.io/](https://prometheus.io/) or run it in a Docker
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You need to have a `prometheus.yml` file that contains information about what
    you want to monitor. I will show you what that file looks like later in this chapter,
    where I will also explain what each part does.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using a lot of NuGet packages as well; they are all mentioned in
    the paragraphs where I discuss each of them and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: You can download all code samples mentioned in this chapter from our GitHub
    repo at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10)
  prefs: []
  type: TYPE_NORMAL
- en: Available logging frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging has been around forever. In the early days of computing, operators would
    walk around the machines and note whatever they saw happening to them. If a light
    blinked when it should not have blinked or vice versa, they wrote it down a journal
    somewhere. Later, systems would log everything they could onto paper and punch
    cards. If systems did something unexpected, the operators could go to the paper
    trail and figure out what had caused the event. After that, people used serial
    monitors that logged everything onto a separate device.
  prefs: []
  type: TYPE_NORMAL
- en: These days, we hardly use punch cards anymore. However, we still log. There
    are many frameworks out there that help you get the job done. In this chapter,
    I will explain three of those frameworks. They all have pros and cons. I will
    highlight these as much as possible. That way, you can make your own decisions
    about what to use and when to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Default logger in .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft offers a **default logger**. We have seen it before: if you create
    an ASP.Net application or, as we have done, a worker process, you will get a logger
    framework for free. This framework is surprisingly full-featured. This framework
    offers enough features to satisfy the needs of most developers. So, let’s have
    a look at it!'
  prefs: []
  type: TYPE_NORMAL
- en: As I said, many of the templates in Visual Studio already include the standard
    `Logger` class. Some templates, however, do not have this. So, let’s have a look
    at how to add it. We’ll begin with a clean, empty Console application.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is add the correct NuGet package. In this case,
    you need to install `Microsoft.Extensions.Logging` in your project. Once you have
    done that, you will have access to the logging framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your main project, you can set up the logging like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code works. If you run it, you will not get any errors. However, you will
    also not get any output, so that is pretty useless, to be honest.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the framework is quite flexible. It can handle all sorts of
    outputs to various destinations. However, you have to specify what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s fix this. Install another NuGet package; this time, we need the `Microsoft.Extensions.Logging.Console`
    package. Once you have installed that, we need to change the code in the `LoggerFactory.Create()`
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the second line, we added the Console as a way to output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the program this time, you will get the desired information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Output from the log](img/B20924_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Output from the log'
  prefs: []
  type: TYPE_NORMAL
- en: OK. We got something on our screen. Let’s see what we have done so far since
    I deliberately skipped over some steps.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoggerFactory` is a factory class that can create instances of a class that
    implements `Ilogger<T>`. We set up `LoggerFactory` by hooking up the desired outputs
    (in our case, Console; we’ll add others later). We also gave it the minimum log
    level we wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into this. I want to discuss log levels and configuration, as well
    as the different tools we have.
  prefs: []
  type: TYPE_NORMAL
- en: Log levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all messages are equally important. If you are starting out on your project,
    you will probably want to log a lot. You can output anything you want and you
    will probably do so. You can write the contents of variables, loop controls, where
    you are in the flow, and so on. Anything that can help you understand the flow
    of your program as you run it is a candidate for logging.
  prefs: []
  type: TYPE_NORMAL
- en: However, once you have written and tested your software, you will probably not
    want all of that information anymore. You might want to log exceptional cases
    and errors, but that is about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, you must remove all the logging code that you do not need
    anymore. Alternatively, you could wrap up the code in `#IF / #ENDIF` statements
    and thus effectively remove the calls when you recompile using a different `#DEFINE`.
    However, that means changing your code. That could lead to side effects. If you
    later find a bug and decide that you need that code in again, you will need to
    rewrite or recompile the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Loglevels` eliminates that problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each log message we write has a level. In the preceding example, we used `Log.LogInformation()`.
    That means that we want to write something informational. There are other levels
    we can use as well. What you use them for is entirely up to you. However, in general,
    there is meaning to each level. These are the levels we can use with `ILogger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Log level** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Trace | This refers to the most detailed messages. These messages may contain
    sensitive application data and are therefore not recommended to be enabled in
    a production environment unless they are necessary for troubleshooting and only
    for short periods. |'
  prefs: []
  type: TYPE_TB
- en: '| Debug | This displays messages that are useful for debugging. It is less
    verbose than Trace, but more than Information. |'
  prefs: []
  type: TYPE_TB
- en: '| Information | This allows the system to show informational messages that
    highlight the general flow of the application. It is useful for general application
    insights. |'
  prefs: []
  type: TYPE_TB
- en: '| Warning | This is all about messages that highlight an abnormal or unexpected
    event in the application flow, but which do not otherwise cause the application
    execution to stop. |'
  prefs: []
  type: TYPE_TB
- en: '| Error | These are messages that highlight when the current flow of execution
    is stopped due to a failure. These should indicate a failure in the current activity,
    not an application-wide failure. |'
  prefs: []
  type: TYPE_TB
- en: '| Critical | This is about messages describing an unrecoverable application,
    system crash, or catastrophic failure requiring immediate attention. |'
  prefs: []
  type: TYPE_TB
- en: '| None | This results in no messages being logged. This level is used to turn
    off logging. |'
  prefs: []
  type: TYPE_TB
- en: Table 10.1 Log levels in Microsoft Logger
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which you can specify what level your message has to
    be. You can use one of the dedicated log methods (such as `LogInformation`, `LogTrace`,
    `LogDebug`, and so on) or the generic `Log()` method. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You just call `Log()` and then give it the `LogLevel`. Whatever method you choose,
    you can decide what level the log is supposed to be on.
  prefs: []
  type: TYPE_NORMAL
- en: However, that only solves a part of the issue. We want to be flexible in what
    we output to the screen. That’s where the `SetMinimumLevel()` method on the `ILoggingBuilder`
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The method determines what the log is writing to the chosen output channels.
    If you set it to `Information`, all calls to the log are processed if they are
    of the Information level or higher. In other words, all calls to `Log.LogTrace()`,
    `Log.Debug()`, `Log.Log(LogLevel.Trace)`, and `Log.Log(LogLevel.Debug)` are ignored.
    So you can, in one line, determine what you do and do not want to appear on the
    logs. You specify the level and all information on that level or above is outputted.
    The rest is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: During development, you might want to set the level to Trace. After extensive
    testing, you might want to set it to `Critical` or maybe `Error` during production.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Settings file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, we are not there yet. If you want to change the log level, you still
    need to change the code and recompile the system. Let’s change that so we can
    use something else.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file to your program called `appsettings.json`. Make sure you change
    the `Copy to output directory` property to `Copy if newer`; you need this file
    next to the binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to add a couple of NuGet packages. Install `Microsoft.Extensions.Configuration.JSon`
    and `Microsoft.Extensions.Logging.Configuration`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have done that, we will add the following code that actually reads
    the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a `ConfigurationBuilder` and then adds the JSON file we just
    added. We set the `optional` parameter to `true`; if people decide to remove the
    file, our app will still work. We also specify that the `reloadOnChange` parameter
    is `true`. As you have probably guessed, the configuration is reloaded when the
    file changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is relatively straightforward: we call `Build()` to get the `IConfiguration`,
    then call `GetSection` (Logging) to load that specific part of our JSON file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do some work on our `LoggerFactory` as well. Change it to look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Instead of hardcoding the log level, we will now give it the configuration section
    from the JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let’s change the code that does the actual logging a bit. I will wrap
    it in a continuous loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run your program and see all the different ways of displaying your message.
    Open another terminal window, navigate to the compiled application folder, and
    change the log setting in the `appsettings.json` file. As soon as you save the
    file, you will see a different behavior in the application. Depending on your
    desire, it will display more or fewer lines of logging.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can add all the logging you want to your application, use `Trace` during
    debugging and development, and then move to `Critical` or `Error` if your system
    is ready for production. You can quickly return to a more detailed debugging level
    as soon as something happens. All of that is done without recompiling!
  prefs: []
  type: TYPE_NORMAL
- en: Using EventId
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having different debugging levels is nice, but that is not enough to structure
    the information if you have a lot of messages. To help you create a bit of order
    in the logging chaos, you can use the `EventId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All log methods have an overload that allows you to add an `EventId`. An `EventId`
    is a class that contains an ID in the `integer` form and a name in the `string`
    form. What those are is entirely left up to you. The name is not even used in
    the logs, but it is there for your convenience during development. We can create
    an `EventId`, or multiple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I just made up a bunch of categories: `Initialization`, `Shutdown`, and `File
    Reading`. This is just an example; I am sure that you can come up with much better
    names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you log something, you can use an `EventId` to indicate that the message
    you log has to do with a certain part of the system. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output now looks a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FIgure 10.2: Output of logging with an EventId (or multiple)](img/B20924_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'FIgure 10.2: Output of logging with an EventId (or multiple)'
  prefs: []
  type: TYPE_NORMAL
- en: Next to the `Log` type and the `Program`, you can see the number between brackets.
    That is the number of the `EventId` type. In our case, `1` was initialization,
    `2` was shut down, and `3` was file reading. Again, these strings are never used
    and, unfortunately, are not shown on the screen. However, having these numbers
    in there can help you find the areas that you are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Using Type information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one last thing you can use to organize your logs. I didn’t explain
    it earlier, but you must have noticed that when we created the instance of our
    `logger`, we gave it a `Program` type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since we called `CreateLogger` with the `Program` type, we see the `Program`
    string on the screen in the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create several instances of the `ILogger` interface, each with its
    own type attached to it. That way, you can create different loggers for each application
    part. If you have a part of your system that handles printing and the main class
    is called `Printer`, you can create a logger of the `Printer` type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All logs written to the `printLogger` instance will now show `Printer` in their
    log lines instead of `Program`. Of course, it doesn’t really matter what you pass
    in that parameter. You can use the `Printer` logger in your main program if you
    want to. It is just decoration that helps you organize the output of the logs.
    That’s it. There is no logic behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Using categories wisely
  prefs: []
  type: TYPE_NORMAL
- en: I suggest you use these categories, but use them sparingly; too many will only
    clutter your logs. I usually create empty classes just for use in the logger creation.
    That way, I can get a nice set of logger instances without relying on internal
    code that nobody outside should see. However, I will leave that entirely up to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have basic logging out of the way, it is time to look at some popular
    alternatives that offer some other nifty tricks we can use. Let us begin with
    NLog!
  prefs: []
  type: TYPE_NORMAL
- en: NLog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft is not the only company that offers a logging framework. There are
    others out there, each with their own strengths and weaknesses. One of the more
    popular ones out there is **NLog**.
  prefs: []
  type: TYPE_NORMAL
- en: NLog was created by Jared Kowalski in 2006 as an alternative to the popular
    log4net solution, which is a port of the immensely popular log4j Java logging
    solution. Kowalski aimed to build a logging solution that was high in performance
    but also flexible in the configuration of the settings.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up NLog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use NLog, you need to install the corresponding NuGet package. The name of
    the package is simply `NLog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed that package, we must create a configuration file.
    To do that, add a new XML file to your project (do not forget to set the properties
    to `Copy if newer` so that the project can find the file when it runs). By convention,
    this file is called `NLog.config`, but you can choose any name. The file should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can control almost all of NLog through this configuration file. You can
    set up all parameters in code, but that kind of defeats the purpose of NLog. I
    suggest that you use the `configuration` file and avoid setting things in the
    code. That is unless you have a really good reason to do otherwise, of course.
    After all, it is still your code, not mine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to start logging. In your program, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we will load the configuration in the `LogManager`. You usually have
    one setup for all your logging needs in your entire application, so you might
    as well do this first.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will call `GetCurrentClassLogger()`. This call is the equivalent of
    the call to `CreateLogger<T>` in the Microsoft framework. It ties the current
    class name to the logger so you can categorize your logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want other loggers to be associated with different classes, you can
    do so by calling something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This call creates another logger with the same configuration but will show `"OtherLogger"`
    in the output this time.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is self-explanatory, except for the line that says `LogManager.Shutdown()`.
    This line is needed to flush out all logs in the code and ensure that no message
    is left behind.
  prefs: []
  type: TYPE_NORMAL
- en: Log levels in NLog logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with the Microsoft framework, you can specify which level you want to see
    in the log files. The levels for NLog are comparable, but there are minor differences.
    The following table shows the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **NLog level** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Trace | This provides the most detailed information. Use this for the most
    low-level debug information. |'
  prefs: []
  type: TYPE_TB
- en: '| Debug | This provides coarse-grained debugging information. It is less detailed
    than Trace. |'
  prefs: []
  type: TYPE_TB
- en: '| Info | Informational messages that highlight the general flow of the application
    come with this level. |'
  prefs: []
  type: TYPE_TB
- en: '| Warn | Potentially harmful situations of interest to end users or system
    managers that indicate potential problems are flagged at this level. |'
  prefs: []
  type: TYPE_TB
- en: '| Error | Error events of considerable importance that will prevent normal
    program execution but might still allow the application to continue running are
    flagged here. |'
  prefs: []
  type: TYPE_TB
- en: '| Fatal | This level focuses on very severe error events that will presumably
    lead the application to abort. |'
  prefs: []
  type: TYPE_TB
- en: '| Off | This involves no logging at all. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.2: Log levels in NLog'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the levels are almost the same; they are just named differently.
    That makes it harder to remember when you switch from one framework to another,
    but we can do nothing about that. We have to memorize the terms, I guess.
  prefs: []
  type: TYPE_NORMAL
- en: NLog targets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You control NLog through the configuration file. That is one of the two main
    principles that drove the development of NLog (the other being that NLog should
    be highly performant).
  prefs: []
  type: TYPE_NORMAL
- en: In the sample we have worked on, we wrote the logs in both the Console and a
    file. In the `settings` file, we have defined different targets where NLog writes
    the logs. Currently, more than 100 different targets are available, some of which
    are part of the core package and some of which require a NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at another target. We currently use `Console`, but we can
    replace that with `ColoredConsole`. That is part of the default package, so we
    do not have to add a NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the configuration, add a new target to the `targets` section. It looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This segment tells NLog that we want to use a new target of the `ColoredConsole`
    type. We can call it `logcolorconsole`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also specified a header that should display the `Logfile for run` text and
    then the current data. I also added a footer that consists of a simple line. The
    layout section is the same as the one we used with the file: we display the time
    (in the `HH:mm:ss` format), the name of the logger (which is `Program` or `OtherLogger`,
    depending on the line we are on), the level of the log in uppercase, and finally
    the message itself.'
  prefs: []
  type: TYPE_NORMAL
- en: You can vary this as much as you want and add or remove elements at will. You
    can also set up rules on what to display depending on various factors, such as
    the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also add it to the rules. Just for simplicity, I removed the file and
    console as a target and used the new `logcolorconsole` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you run the sample after making these changes, you will see a set of colorful
    lines. Yes, you can change or alter the colors based on the level. The options
    are almost endless.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said, there are over 100 targets available. Let me give you a shortened
    list of some of the more commonly used targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Target name** | **Description** | **NuGet package** |'
  prefs: []
  type: TYPE_TB
- en: '| File Target | Logs data to files on a disk with options for filenames, directories,
    rotations, and archiving | NLog |'
  prefs: []
  type: TYPE_TB
- en: '| Console Target | Sends log messages to the standard output or error streams;
    useful during development | NLog |'
  prefs: []
  type: TYPE_TB
- en: '| ColoredConsole Target | Sends log messages to the Console with color coding
    based on log level | NLog |'
  prefs: []
  type: TYPE_TB
- en: '| Database Target | Logs messages to a database using parameterized SQL commands
    | NLog |'
  prefs: []
  type: TYPE_TB
- en: '| EventLog Target | Writes log entries to the Windows Event Log; ideal for
    Windows apps | NLog.WindowsEventLog |'
  prefs: []
  type: TYPE_TB
- en: '| Mail Target | Sends log entries as email messages; suitable for alerts and
    monitoring | NLog.MailKit |'
  prefs: []
  type: TYPE_TB
- en: '| Network Targets | Includes WebService, TCP, and UDP targets for logging over
    networks | NLog |'
  prefs: []
  type: TYPE_TB
- en: '| Trace Target | Sends log messages to .NET trace listeners, integrating with
    other diagnostics tools | NLog |'
  prefs: []
  type: TYPE_TB
- en: '| Memory Target | Logs messages to an in-memory list of strings, mainly for
    debugging purposes | NLog |'
  prefs: []
  type: TYPE_TB
- en: '| Null Target | A target that does nothing; useful for disabling logging in
    certain scenarios | NLog |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.3: Targets in NLog'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you look at the documentation at [https://nlog-project.org/config/](https://nlog-project.org/config/)
    to see the different options and the settings per option. It is pretty extensive!
  prefs: []
  type: TYPE_NORMAL
- en: Rules in NLog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the targets, you can set rules in NLog. The rules define which
    target is used under which circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we used one rule: all logs should go to the Console and `file`
    targets or the `ColoredConsole` target, which we named `logcolorconsole`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change that a bit; I want to make it more intelligent. Change the rules
    section so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have three rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the catch-all. By writing `name="*"`, we tell the system to take
    all loggers. The minimum level we want is Trace, the lowest level, so we want
    all messages (yes, you can also define a maximum level). We define the target
    as a **logfile**. This target is the one that writes to a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second rule only applies to the logger that has the name `Program`. Thus,
    all loggers are created by calling `GetCurrentClassLogger()` using our `Main`
    method. We raise the minimum level to Warn; we are not interested in anything
    below that. The file catches this. We want to see them in nice colors, so we specify
    the `writeTo` parameter as `logcolorconsole`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All messages sent to the logger named `OtherLogger` are the subject of the third
    rule. We want all messages of the Info level or above, and we want to see them
    processed by our colorless, default Console logger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the sample. See how messages on different loggers get sent to the right
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember when I said that anything that takes longer than a few clock cycles
    should be done asynchronously? Well, NLog allows you to log to databases or network
    connections. They definitely have long-running operations. Unfortunately, there
    is no such method as `LogAsync()` in NLog. However, there is another solution
    to this.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a target called `AsyncWrapper`. As the name suggests, this is a wrapper
    around other targets that make them work asynchronously. All you have to do is
    add that to the configuration like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although the methods are still synchronous, NLog places all the log messages
    in a queue on a separate thread and writes them to the target on that thread instead
    of on the calling thread. You can set several variables to determine how long
    the delay must be, how long the queue can become, and so on. However, we have
    eliminated our delay when writing to a file, a database, or a network connection.
    I strongly suggest that you use that wrapper for anything besides Console!
  prefs: []
  type: TYPE_NORMAL
- en: Two useful but often neglected additional settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two more things I want to show you in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The root element, NLog, can have a property named `autoReload=true`. If you
    set that, you can have NLog pick up changes in the log file while the application
    runs. We saw a similar option with the Microsoft logger; it is good to know that
    NLog also supports this.
  prefs: []
  type: TYPE_NORMAL
- en: With all the available rules, targets, variables, and other things you can set
    in the configuration file, you might wonder what to do if things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The people behind NLog thought of that as well. You can turn on logging for
    NLog itself. All you have to do is change the root entry to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I have added the `internalLogFile` and `internalLogLevel` properties. Adding
    these properties results in NLog logging its internal logs to the given file.
    Doing this might help you find issues in your logging. It is all becoming a bit
    metaphysical, but you can log better by logging the workings of the log. Give
    it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Serilog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one more framework I want to share with you. Serilog is a popular logging
    framework that first saw the light of day in 2013.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind Serilog is that it allows for structured logging. So far, all
    the logs we have seen have all just been one-liners with some text. Serilog is
    built around the idea that structure can bring clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Let me show you what I mean by that. Let’s build a sample.
  prefs: []
  type: TYPE_NORMAL
- en: Although Serilog can (and should) be controlled by the settings in a configuration
    file, I will control this final example exclusively through code. I want to show
    you how to do that so you have at least seen it once.
  prefs: []
  type: TYPE_NORMAL
- en: However, again, since you want to change logging depending on the state of the
    system, you are better off having a configuration file that you can change without
    recompiling.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we will begin by creating a new Console application and adding some
    NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: Standard logging with Serilog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NLog has targets, and Serilog has **sinks**. You have to install all the sinks
    you need from different packages. I will only use Console and File in my sample,
    but there are others: SQL Server, HTTP, AWS, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: You need to install the `Serilog`, `Serilog.Sinks.Console` and `Serilog.Sinks.File`
    NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar. We create a configuration, this time all in
    code; we create a logger and log our messages. We end with a `CloseAndFlushAsync()`
    to ensure nothing is left in some buffer.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing special about this code. OK, the new thing here is the `RollingInterval`.
    This property determines when the system should create a new file. You can set
    that to anything from a minute to a year. If you do not want to create a new file
    at any point, you can also set it to `Infinite`. That way, the system creates
    the file once and never again (unless you delete it, of course).
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from that, there is nothing remarkable about Serilog. However, let’s
    change that. Change the parameters in the call to `WriteTo.File()` so that it
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code sample, I added a `JsonFormatter` to the output of both the console
    and the file. When you add a formatter, you tell Serilog to output the logs a
    certain way. The `JsonFormatter` formatter forces the output to be in (well, you
    guessed it) the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To truly use the structure log, we must change how we log the messages. Let’s
    add one line to the part where we write the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we log a line of text, but instead of building that string beforehand,
    we do it in the message. In this case, we give it named parameters, `userId,`
    and `loggedInTime`, and then pass in the values that we want to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run it now, that last line, after formatting, results in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a lot more information is suddenly available. The structure
    of the logline is such that if we store it in a system somewhere, we can easily
    query the lines. Later in this chapter, I will show you how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: So, Serilog is comparable to the other two frameworks until you use one of the
    many formatters. The ability to store the log information to easily query it makes
    it a very powerful tool to have in your toolbelt!
  prefs: []
  type: TYPE_NORMAL
- en: Log levels in Serilog logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you will probably expect by now, Serilog also has levels. Those levels should
    look very familiar to you. This table shows the levels that Serilog offers and
    what they are meant to do.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Serilog level** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Verbose | This contains the most detailed information. These messages may
    contain sensitive application data and are therefore not recommended for production
    unless hidden. |'
  prefs: []
  type: TYPE_TB
- en: '| Debug | This level contains information that is useful in development and
    debugging. |'
  prefs: []
  type: TYPE_TB
- en: '| Information | This level contains informational messages that highlight the
    general flow of the application. It is useful for general application insights.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Warning | Indications of possible issues or service and functionality degradation
    are included at this level. |'
  prefs: []
  type: TYPE_TB
- en: '| Error | Errors and exceptions that cannot be handled or are unexpected are
    included here. |'
  prefs: []
  type: TYPE_TB
- en: '| Fatal | This level focuses on critical errors causing complete failure of
    the application and requiring immediate attention. |'
  prefs: []
  type: TYPE_TB
- en: '| Silent | This is the level for no logging at all (Serilog does not explicitly
    define a Silent level, but logging can effectively be turned off). |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.4: Serilog log levels'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, there are no surprises here. As with the other frameworks, you can use
    this however you want: no one can stop you from adding lots of debug information
    to the Error level. It is just not a very good idea.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the logging frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After having seen all of these frameworks, you might wonder: which one should
    I pick? The answer is simple: choose whichever one you feel most comfortable with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All frameworks have pros and cons; none are bad or extremely good. They do
    have different use cases and areas of attention. The following table highlights
    some of those:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **.****NET Logger** | **NLog** | **Serilog** |'
  prefs: []
  type: TYPE_TB
- en: '| **Overview** | Reliable and integrates seamlessly with .NET | Rich in features,
    great for a wide range of applications | Excels in structured logging, making
    data meaningful and searchable |'
  prefs: []
  type: TYPE_TB
- en: '| **Integration** | Deeply integrated with .NET Core, supports dependency injection
    and configuration settings | Flexible, can be used in various .NET applications,
    supports multiple targets | Great with .NET applications, especially for structured
    data stores such as Seq or Elasticsearch |'
  prefs: []
  type: TYPE_TB
- en: '| **Pros** | Minimal setupSupports structured logging | Advanced log routing
    and filtering; logs to multiple targets simultaneously | Exceptional at structured
    logging; supports enrichers for additional context |'
  prefs: []
  type: TYPE_TB
- en: '| **Cons** | Less feature-rich without third-party providers | Configuration
    can get complex | Might be overkill for simple needs; best features require compatible
    logging targets |'
  prefs: []
  type: TYPE_TB
- en: '| **Best for** | Projects that need straightforward logging with minimal setup
    | Applications requiring detailed control over logging, or when logging into multiple
    places | Projects where structured logging and data querying are priorities |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.5: Comparison between the logging frameworks'
  prefs: []
  type: TYPE_NORMAL
- en: You just have to look at your own needs and determine your scenario and way
    of working best. Pick that tool. My advice is to give the others a go. You might
    find a new favorite logging framework!
  prefs: []
  type: TYPE_NORMAL
- en: So, we have now looked at logging. We have seen the most commonly used frameworks
    and how to use them. We have looked at default Microsoft logging; we have had
    an in-depth look at NLog and its robust collection of targets and rules. Finally,
    we have looked at Serilog’s structured logging approach.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to use logging from now on. However, logging is part of your
    application. What if you do not get all the information you need from logging?
    That is where monitoring comes into play. Let’s have a look at that next!
  prefs: []
  type: TYPE_NORMAL
- en: A word of caution
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging is very useful. In fact, I would suggest that you cannot do serious
    development on systems without a UI if you do not have extensive logging. However,
    you must be careful: it is too easy to leak sensitive information about your system.
    Consider things such as connection strings, credentials, and other sensitive information.
    Also, you might sometimes accidentally disclose information about the inner workings
    of your system or even about the organization that this system runs. Be careful.
    Do not assume that people will not try to move the log level to Trace to see what
    is happening. Log as much as possible, but be mindful of the dangers!'
  prefs: []
  type: TYPE_NORMAL
- en: Logging is one of the best things you can do to solve development and production
    issues. However, there is more that we can do. We need insights into these logs,
    but we must also monitor things such as memory usage, CPU usage, and much more.
    Let’s talk about monitoring next!
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring your applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to keep an eye on things as our software runs. During development, we
    can turn on extensive logging to the console or to a file, which helps us track
    errors and issues. However, once our code runs on the final machine, it needs
    to run, and it might be a bit harder to look at all those log files.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring with Seq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring the system’s state is essential to keep things healthy. One of the
    great tools we have available to do this is Seq. Seq and Serilog are a match made
    in heaven!
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons why Serilog is getting so much attention these days is because
    of its ability to write logs in a structured manner. We looked at this in the
    previous section but did not dive into what we could do. It is time to change
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Since the logs coming from Serilog are formatted in a particular way, we can
    also store them in a specific way. One of the tools that allow us to do so is
    Seq. Seq is a tool by the company Datalust. You can get a free personal license
    from them to play around with your logs. You can choose to install Seq on your
    machine, or you can choose to download a Docker image that contains everything
    you need. I prefer the latter, but it doesn’t matter which option you choose.
    The Datalust website clearly explains how to get the bits. You can find the documentation
    at [https://docs.datalust.co/docs/an-overview-of-seq](https://docs.datalust.co/docs/an-overview-of-seq).
    In the *Technical requirements* section of this chapter, I have shown you the
    Docker command that you will need to execute to get a local version of Seq running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have done that, you can actually start to use Seq. We need to change
    our code a little bit. In addition to the packages that we installed earlier to
    enable logging to `Console` and `File`, we will also need a new package: `Serilog.Sinks.Seq`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed that, we must change the setup of the log a bit. That
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we added a new `Sink` to our configuration, and this time, we
    are writing to Seq. I use the default port `5341`, since this is the port that
    Seq listens to.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I run the application and go to the Seq dashboard on my machine, I will
    also get to see the logs there. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Serilog captured by Seq](img/B20924_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Serilog captured by Seq'
  prefs: []
  type: TYPE_NORMAL
- en: You can clearly see all log messages. They are nicely colored. I have also opened
    the last message, in which we added some structural information. Seq captures
    this information and shows you exactly what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also query over the logs by entering a SQL-like statement in the top
    edit box. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.\uFEFF4: Seq dashboard with a filter for user Id.](img/B20924_11_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Seq dashboard with a filter for user Id.'
  prefs: []
  type: TYPE_NORMAL
- en: I added the `userId = 42` query in the edit box. This results in Seq only showing
    all messages about the user whose `userId` is `42`.
  prefs: []
  type: TYPE_NORMAL
- en: The query language is extensive and you can write complex queries. This means
    that you can always find what you need even if you log many messages.
  prefs: []
  type: TYPE_NORMAL
- en: Seq is extremely powerful and yet easy to set up. I highly recommend checking
    it out!
  prefs: []
  type: TYPE_NORMAL
- en: Performance counters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows gives us lots of tools to monitor our systems, such as `EventViewer`.
    We can use those tools in our own systems as well. For instance, there are a lot
    of performance counters available that you can access both inside and outside
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to get that in our code first.
  prefs: []
  type: TYPE_NORMAL
- en: 'I started a new Console application, added the `System.Diagnostic` NuGet package,
    and then wrote the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Near the top of the file, I have created an instance of the `PerformanceCounter`
    class. This class gives us access to all the performance counters that we have
    mentioned, so we can also use them in our code. We need to specify the category
    and the item in that category we want to monitor. In my case, I went for `Processor`
    and `% Processor Time`, which are indicators of the load on the CPUs
  prefs: []
  type: TYPE_NORMAL
- en: Then, I start a never-ending loop in which I increase a counter. As soon as
    that counter reaches `10`, I do some silly calculations on all the CPUs available
    on my machine. These calculations do not do anything useful besides keeping the
    CPUs busy. All this happens on a background thread, so the main loop keeps displaying
    how busy the system is.
  prefs: []
  type: TYPE_NORMAL
- en: For readability, I will also change the color of the output if the CPU percentage
    is over 10%. You might have to change this threshold if you have a slower or faster
    machine than I do.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this, you will be able to see how busy the system is. You should
    see a nice green output, but the system will get busier every few seconds, as
    shown by the red output.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can measure many items, tracking what the computer is doing. Suppose that
    you want to find out what you can monitor. In that case, you only need to open
    the Performance Monitor application on your Windows machine (search for `perfmon.exe`).
    You can add counters to the main screen; the dialog that shows them is a good
    source of information. Make sure that you check the **Show description** box at
    the bottom of the screen to see what all the counters do. To give you an idea,
    this is what that screen looks like when you search for the counter that we just
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Perfmon.exe example with % Processor Time](img/B20924_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Perfmon.exe example with % Processor Time'
  prefs: []
  type: TYPE_NORMAL
- en: I suggest that you browse through that list and see what you can find that might
    be useful. There are even categories specifically for the .NET CLR, so you can
    see how often the garbage collector runs or how frequently an exception has been
    raised per second!
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping an eye on your system’s vital metrics can help you pinpoint issues.
    If your system suddenly starts using a lot more memory, or if at certain times
    the CPU usage spikes, you might have a problem that needs fixing. Thus, it is
    important to track those metrics. As we just learned, we can use the `PerformanceCounter`
    class to get the necessary information and do something with it, such as writing
    it to Seq with Serilog.
  prefs: []
  type: TYPE_NORMAL
- en: However, that is not the only way. There is nothing wrong with the combination
    of Serilog and Seq. However, their primary goal is to log events. You can use
    a tool such as Prometheus to track trends, such as CPU usage or memory pressure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prometheus is similar to Serilog and Seq: they allow you to write something
    in your code to an external system that you can look at in your web browser. However,
    Prometheus is primarily used for ad monitoring and time series databases. It is
    designed to record real-time metrics in a scalable fashion. It excels at monitoring
    the state of your applications and infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at how all of that works.
  prefs: []
  type: TYPE_NORMAL
- en: The application that you want to monitor needs a NuGet package. So, let’s install
    that. It is called `prometheus-net`. However, that is only part of the equation.
    As I said, you can use your browser to see the events that you are interested
    in, so we will also need to install the server.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Prometheus from [https://prometheus.io](https://prometheus.io)
    and run it on your machine. However, if you are just trying to figure out how
    it works and see whether this is the tool for you, I recommend downloading the
    Docker image and running it.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus needs a configuration file. This is a simple YAML file telling it
    how to behave. We need to link to that configuration file when we start the Docker
    image, so let’s write that file first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your favorite code editor and create a file called `prometheus.yml` somewhere.
    I have placed mine in a folder called `c:\data`. The preceding Docker command
    will ensure that it gets read and used inside the running container. This is what
    the file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what is going on here.
  prefs: []
  type: TYPE_NORMAL
- en: The first line defines the `scrape_interval`. This is the interval that determines
    how often Prometheus looks at the metrics. Since metrics are usually interesting
    over a longer time, you do not need the system to measure them continuously. In
    our example, I have set it to do a scrape every five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The following line defines the `evaluation_interval`. Prometheus can have rules
    and alerts that fire when a particular metric goes over or under a specific metric.
    This interval determines how often it checks to see whether the alert needs to
    be fired. Again, I have set it to five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: These two settings are global; they apply to all the metrics for all the applications
    that we monitor. We can later change these for each specific metric or application
    if we want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section, called `scrape_configs`, defines the specific metrics
    that we want to collect. In my case, I have given it a name: `C# worker`. Then,
    we will tell it which server supplies the metrics. Again, in my case, it is `host.docker.internal:1234`.
    This means that the server runs on that URL with that specific port.'
  prefs: []
  type: TYPE_NORMAL
- en: “Wait a minute,” you might say, “I am not running a server; I am running a Console
    application!” Do not worry; Prometheus takes care of this.
  prefs: []
  type: TYPE_NORMAL
- en: The server application of Prometheus calls into the systems it needs to monitor
    over an HTTP connection. Thus, the clients it monitors need a web server that
    supplies that information. We do not have to take care of that; Prometheus does
    that for us.
  prefs: []
  type: TYPE_NORMAL
- en: IP addresses in Docker
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why I use the `host.docker.internal` hostname as the server
    address. After all, both Docker and our Console application run on the same system.
    They both are available on `localhost`, right? That is incorrect; Docker containers
    all run in their own network (I am simplifying things here, but the idea still
    works). That means that if the Prometheus server would listen to anything on `localhost:1234`,
    it would only listen to the virtual network in the image. We need to supply the
    actual IP address of the machine that runs our application. However, if you do
    not want to hardcode that, use the `host.docker.internal` DNS name. The DNS system
    in Docker knows this name. It resolves the actual IP address of the host machine
    so that the containers in Docker can find the correct machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at our code. I have started a new Console application and
    added the NuGet package. The code itself looks like this. I start by setting up
    our metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, I create a `Gauge`. This is like a thermometer that you use to measure
    metrics. In this case, I will make one that measures `app_memory_usage_bytes`,
    one of the many metrics that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will create an instance of a `MetricServer`. You must specify the host
    from which the app runs and the port from which it broadcasts the metrics. Remember
    when I said that Prometheus listens to servers to collect its metrics? Well, this
    is where we set up that server.
  prefs: []
  type: TYPE_NORMAL
- en: IP addresses and Docker, again
  prefs: []
  type: TYPE_NORMAL
- en: I have used the `127.0.0.1` hostname here. If I used `localhost`, I would get
    errors for some reason. If I used the machine’s actual hostname, I would get errors.
    Either the app does not start up, or the Prometheus server can’t find my app.
    However, if I specify the IP address here (my actual IP address also works), the
    system works just fine. So, if you have issues with getting things to work, just
    try to use `127.0.0.1` here.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I will start the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you are ready to send the metrics to the server. I have created a simple
    method that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That is basically all that you have to do.
  prefs: []
  type: TYPE_NORMAL
- en: However, let’s see what happens when we actually do something. In the main body
    of my code, I have a simple loop that adds a block of memory every five seconds
    and then clears them all after 20 seconds, after which the whole thing starts
    all over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I have defined some variables, such as `counter`, `buffer,` and `rnd`. In the
    loop, I will either add memory to the system, clear the memory, or do nothing.
    At the end, I will make sure to call the `UpdateMemoryGauge()` method. Then, the
    app sleeps for one second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AllocateMemoryBlock()` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is silly code; I hope you never write this in actual production
    code. However, it works here; we want to measure the memory usage of our app,
    so we might as well allocate lots of it. I have used a randomizer to make the
    system a bit less predictable because I like the look of the charts a bit better
    that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ClearMemory()` is even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We then clear the list and clean up the memory by calling `GC.Collect()`, and
    we will log that to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is it! If you run this for a while and open your browser to the default
    Prometheus URL of [http://localhost:9090](http://localhost:9090), you can search
    for the `app_memory_usage_bytes` metric. If you run the app for a while, you will
    get a nice chart like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Prometheus sampling our memory usage](img/B20924_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Prometheus sampling our memory usage'
  prefs: []
  type: TYPE_NORMAL
- en: The chart shows our app in action, depicting how much memory it uses. You can
    probably also see why I used a randomizer; the chart looks slightly more interesting.
    However, that is just my personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: You can search for metrics in the top part of the screen, or you can search
    for jobs. If you specify the `{job = "c# worker"}` search string, you will get
    over 30 metrics for your app. You can click on each of them to add them to the
    chart. There is a ton of information there!
  prefs: []
  type: TYPE_NORMAL
- en: Other platforms for monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at Seq to collect our logs. We looked at performance counters
    and we looked at Prometheus. These are all great tools and I believe they are
    the ones that fit us as system programmers the best. However, there are many more
    systems out there that might work better for you and your specific use case. I
    will not describe them all in detail; that would justify a book in itself. However,
    here is an overview of some of the most used ones. If you are interested in them,
    I suggest that you do research and find out how they can help you!
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Description** | **Use case** |'
  prefs: []
  type: TYPE_TB
- en: '| Application Insights | Part of Azure Monitor, it provides APM features and
    telemetry data | Cloud-based monitoring |'
  prefs: []
  type: TYPE_TB
- en: '| New Relic | Offers full-stack observability, including application monitoring
    | Performance insights |'
  prefs: []
  type: TYPE_TB
- en: '| Dynatrace | Utilizes AI for automatic monitoring and problem resolution |
    Full-stack monitoring |'
  prefs: []
  type: TYPE_TB
- en: '| Datadog | Provides monitoring, troubleshooting, and security for cloud applications
    | Cloud-native environments |'
  prefs: []
  type: TYPE_TB
- en: '| ELK Stack | Elasticsearch, Logstash for data processing, Kibana for visualization
    | Log Management |'
  prefs: []
  type: TYPE_TB
- en: '| Nagios | Offers monitoring and alerting services for servers, switches, applications,
    and services | Infrastructure monitoring |'
  prefs: []
  type: TYPE_TB
- en: '| AppDynamics | Application performance management and IT operations analytics
    | Business performance monitoring |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.6: Monitoring tools'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many options available, so there is definitely something
    that you can use that fits your specific needs!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to monitor using Seq, performance counters, and Prometheus,
    we should look at what we are logging and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: What you should be monitoring or logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen a lot of ways in which we can log and monitor our systems. However,
    the question remains: what should you be logging and monitoring? The answer is
    simple: whatever you need to keep your systems healthy.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, that answer is probably the easy way out. Let’s be a bit more specific.
  prefs: []
  type: TYPE_NORMAL
- en: Basic health monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should monitor the overall health of your system. Your application does
    not live in a vacuum, so you should be mindful of the state of the complete system
    and how you interact with it. These are some of the items you might want to keep
    an eye on:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU usage**: Track CPU usage to determine whether your application is causing
    a high CPU load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory usage**: Monitor memory consumption to detect memory leaks or excessive
    memory usage, which is critical in a managed environment such as .NET, where garbage
    collection occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disk I/O**: Monitor read/write operations and disk usage to ensure that disk
    I/O is not a bottleneck'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network I/O**: Keep an eye on inbound and outbound network traffic, especially
    if your system communicates with other services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there are many other metrics you might be interested in, but these
    are usually the ones that people care about the most.
  prefs: []
  type: TYPE_NORMAL
- en: Application-specific metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, your system itself is also something that you should look into.
    These are the metrics I would suggest you add to your monitoring tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread counts and thread pool health**: It is helpful to know whether your
    threads are getting starved or whether the pool is overworked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Garbage collection metrics**: Track the frequency and duration of garbage
    collection events to manage memory more effectively and optimize application performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue lengths**: If your application uses message queues or similar structures,
    monitoring their lengths can help you understand throughput and backlogs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These metrics are more geared toward your application than the whole system,
    so I really recommend that you use these.
  prefs: []
  type: TYPE_NORMAL
- en: Errors and exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Exceptions happen. That is just a fact of life. So, you might want to track
    those as well. Monitoring tools can capture these exceptions, but I would not
    solely rely on them. Always log what is happening in your exception-handling code
    blocks. You should be thinking about these items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unhandled exceptions**: Log all unhandled exceptions with complete stack
    traces for debugging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handled exceptions**: Sometimes, knowing about handled exceptions can provide
    insights into potential issues that are not critical yet but may become problematic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring errors and exceptions is, in my opinion, a given. You really want
    to know about these events!
  prefs: []
  type: TYPE_NORMAL
- en: Application logs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Several things are happening around your application that might be worthwhile
    to keep track of. These are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start/stop events**: Log when services or components start and stop to understand
    application life cycle events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Significant state changes**: Any change in the state that might affect the
    application’s behavior should be logged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security-related events**: These events include authentication attempts,
    access violations, and other security checks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency health
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Applications rarely work in isolation. There are usually other systems that
    they depend on. You should track those dependencies as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database connectivity**: Regular checks to ensure that your application can
    connect to databases or other storage systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External services**: Monitor the availability and response times of any APIs
    or external services that your application relies on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom business logic monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, the application does some specific things that only apply to your
    environment. These might also be targets to monitor. Think about things such as
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance of critical operations** such as algorithms or processes central
    to your application’s functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data processing rates**, especially in systems that handle large volumes
    of data or streaming data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the things you might add to your toolbelt.
  prefs: []
  type: TYPE_NORMAL
- en: Use the right level!
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: assigning the right level to each event is essential when logging.
    Not everything should be Information; you must distinguish between an error and
    debug information. Again, please make sure that you are not leaking sensitive
    information through your logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I hope that you took note of all of these items and kept a log of what we have
    been talking about! Logging and monitoring are extremely important, especially
    when you do not have a UI. We covered the logging frameworks available to you
    as a systems programmer in this chapter: the good and default Microsoft log, as
    well as NLog and structured logging in Serilog.'
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at monitoring the health of your system and your application.
    We looked at Seq to collect our logs, discussed how to use performance counters,
    and dove into monitoring with Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about what you should be logging and monitoring and why you should
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, from now on, you will no longer be in the dark when unexpected things
    happen. Since they *will* happen, you’d better make sure that you are prepared.
    A good logging and monitoring strategy can save your life. Well, maybe not your
    life, but it can help your system. That is what makes it all worth it. After all,
    a good log can set you on the right track when you want to start debugging your
    system. Incidentally, that is the topic of the next chapter!
  prefs: []
  type: TYPE_NORMAL
