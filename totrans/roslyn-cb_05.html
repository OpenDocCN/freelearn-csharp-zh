<html><head></head><body>
        

                            
                    <h1 class="header-title">Catch Security Vulnerabilities and Performance Issues in C# Code</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Identifying configuration-related security vulnerabilities in web applications</li>
<li>Identifying cross-site scripting vulnerabilities in view markup files (<kbd>.cshtml</kbd>, .<kbd>aspx</kbd> files) in web applications</li>
<li>Identifying insecure method calls that can lead to SQL and LDAP injection attacks</li>
<li>Identifying weak password protection and management in web applications</li>
<li>Identifying weak validation of data from external components to prevent attacks such as cross-site request forgery and path tampering</li>
<li>Identifying performance improvements to source code using FxCop analyzers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In this chapter, we will cover two very important and popular category of Roslyn analyzers: security and performance analyzers.</p>
<ul>
<li><strong>Security</strong>: Given the extremely large domain of .NET applications, each of them with very domain-specific security vulnerabilities, it is critical that we have a domain-specific tools/extensions to catch these vulnerabilities. Roslyn-based security analyzers, such as <strong>PUMA</strong> scan analyzers, catch these vulnerabilities at compile time and report diagnostics. PUMA scan analyzer rules are classified into the following broad categories:
<ul>
<li>Configuration (<a href="https://www.pumascan.com/rules.html#configuration">https://www.pumascan.com/rules.html#overview</a>): Rules to catch vulnerabilities in ASP.NET Web configuration files</li>
<li>Cross-site Scripting (<a href="https://www.pumascan.com/rules.html#cross-site-scripting">https://www.pumascan.com/rules.html#cross-site-scripting</a>): Rules to catch cross-site scripting (XSS) vulnerabilities</li>
<li>Injection (<a href="https://www.pumascan.com/rules.html#injection">https://www.pumascan.com/rules.html#injection</a>): Rules to catch calls to insecure method calls to external components that can cause SQL injection attacks</li>
<li><strong>Password Management</strong> (<a href="https://www.pumascan.com/rules.html#password-management">https://www.pumascan.com/rules.html#password-management</a>): Rules to catch vulnerabilities in password management components</li>
<li><strong>Validation</strong> (<a href="https://www.pumascan.com/rules.html#validation">https://www.pumascan.com/rules.html#validation</a>): Rules to catch weak validation and authentication of external requests, which can lead to malicious attacks to other users</li>
</ul>
</li>
<li><strong>Performance</strong>: Runtime performance is important for all applications, and there are many different aspects to it. One of the important performance criteria for .NET applications is the quality of MSIL or CIL (<a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language">https://en.wikipedia.org/wiki/Common_Intermediate_Language</a>) generated by the .NET compilers. The quality of MSIL is governed by both the quality of the user code and the compiler that produces MSIL. In this chapter, we will walk you through the performance rules in FxCop analyzers, which are the Microsoft code analysis rules (<em>CAXXXX</em>) written for identifying performance improvements in .NET applications to generate more efficient MSIL. These rules have been ported to the Roslyn analyzer framework and open sourced at <a href="https://github.com/dotnet/roslyn-analyzers">https://github.com/dotnet/roslyn-analyzers</a>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying configuration-related security vulnerabilities in web applications</h1>
                
            
            
                
<p>ASP.NET enables you to specify configuration settings that affect all Web applications on a server, that affect only a single application, that affect individual pages, or that affect individual folders in a Web application. You can make configuration settings for features, such as compiler options, debugging, user authentication, error-message display, connection strings, and more. Configuration data is stored in XML files that are named Web.config.</p>
<p>You can read more details about different kind of configuration settings in the Web.config files at <a href="https://msdn.microsoft.com/en-us/library/ff400235.aspx">https://msdn.microsoft.com/en-us/library/ff400235.aspx</a>.<br/> In this section, we will walk you through the rules in PUMA scan analyzers to catch security vulnerabilities in web configuration in an ASP.NET Web Forms project.</p>
<p>Note that Roslyn analyzers are fully supported on both .NET framework projects and .NET core projects, so the PUMA scan analyzers covered here work fine on both ASP.NET and ASP.Net core web projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start Visual Studio and click on File | New| Project... and create a new Visual C# | Web | ASP.NET Web Application with the Web Forms template, say <kbd>WebApplication</kbd>:</li>
</ol>
<div><img class="image-border" height="394" src="img/ad226c58-fa64-4869-b81d-39419887b541.png" width="604"/></div>
<ol start="2">
<li>Install the <kbd>Puma.Security.Rules</kbd> analyzers NuGet package (at the time of writing, the latest stable version is <em>1.0.4</em>). For guidance on how to search and install analyzer NuGet package to a project, refer to the recipe, <em>Searching and installing analyzers through the NuGet package manager</em>, in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
<li>Select Web.config in the solution explorer and change its build action from Content to AdditionalFiles using the Properties window and save the project:</li>
</ol>
<div><img class="image-border" height="467" src="img/9af8e7bd-1151-4fe8-9558-64f746c36a04.png" width="303"/></div>
<ol start="4">
<li>Open Web.config in the editor and replace existing <kbd>system.web</kbd> XML element with the following XML. You can read more about <kbd>system.web</kbd> XML element at <a href="https://msdn.microsoft.com/en-us/library/dayb112d(v=vs.100).aspx">https://msdn.microsoft.com/en-us/library/dayb112d(v=vs.100).aspx</a>.</li>
</ol>
<pre style="padding-left: 90px">
&lt;system.web&gt;<br/>  &lt;compilation debug="false" targetFramework="4.6.2" /&gt;<br/>  &lt;customErrors mode="Off" defaultRedirect="/home/error"/&gt;<br/>  &lt;httpRuntime enableHeaderChecking="false" enableVersionHeader="true" /&gt;<br/>  &lt;httpCookies requireSSL="false" httpOnlyCookies="false"/&gt;<br/>  &lt;pages enableEventValidation="false" enableViewStateMac="false" viewStateEncryptionMode="Never" validateRequest="false" /&gt;<br/>  &lt;authentication mode="Forms"&gt;<br/>    &lt;forms loginUrl="~/Account/Login.aspx" timeout="900" enableCrossAppRedirects="true" protection="None" /&gt;<br/>  &lt;/authentication&gt;<br/>&lt;/system.web&gt;
</pre>
<ol start="5">
<li>Build the project in Visual Studio or command line and verify that you get following <em>SECXXXX</em> warnings from the PUMA scan analyzer:</li>
</ol>
<pre style="padding-left: 90px">
1&gt;CSC : warning <strong>SEC0014</strong>: Insecure HTTP cookies C:WebApplicationWeb.config(11): &lt;httpCookies requireSSL="false" httpOnlyCookies="false" /&gt;<br/>1&gt;CSC : warning <strong>SEC0015</strong>: Cookies accessible via script. C:WebApplicationWeb.config(11): &lt;httpCookies requireSSL="false" httpOnlyCookies="false" /&gt;<br/>1&gt;CSC : warning <strong>SEC0003</strong>: Forms authentication does not set requireSSL to true. C:WebApplicationWeb.config(14): &lt;forms loginUrl="~/Account/Login.aspx" timeout="900" enableCrossAppRedirects="true" protection="None" /&gt;<br/>1&gt;CSC : warning <strong>SEC0004</strong>: Forms authentication does not set the cookieless attribute to UseCookies. C:WebApplicationWeb.config(14): &lt;forms loginUrl="~/Account/Login.aspx" timeout="900" enableCrossAppRedirects="true" protection="None" /&gt;<br/>1&gt;CSC : warning <strong>SEC0006</strong>: Forms authentication cookie protection attribute is not set to All. C:WebApplicationWeb.config(14): &lt;forms loginUrl="~/Account/Login.aspx" timeout="900" enableCrossAppRedirects="true" protection="None" /&gt;<br/>1&gt;CSC : warning <strong>SEC0007</strong>: Forms authentication timeout value exceeds the policy of 30 minutes. C:WebApplicationWeb.config(14): &lt;forms loginUrl="~/Account/Login.aspx" timeout="900" enableCrossAppRedirects="true" protection="None" /&gt;<br/>1&gt;CSC : warning <strong>SEC0005</strong>: Forms authentication does not set the enableCrossAppRedirects attribute to false. C:WebApplicationWeb.config(14): &lt;forms loginUrl="~/Account/Login.aspx" timeout="900" enableCrossAppRedirects="true" protection="None" /&gt;<br/>1&gt;CSC : warning <strong>SEC0002</strong>: Custom errors are disabled. C:WebApplicationWeb.config(9): &lt;customErrors mode="Off" defaultRedirect="/home/error" /&gt;<br/>1&gt;CSC : warning <strong>SEC0008</strong>: HTTP header checking is disabled. C:WebApplicationWeb.config(10): &lt;httpRuntime enableHeaderChecking="false" enableVersionHeader="true" /&gt;<br/>1&gt;CSC : warning <strong>SEC0009</strong>: The Version HTTP response header is enabled. C:WebApplicationWeb.config(10): &lt;httpRuntime enableHeaderChecking="false" enableVersionHeader="true" /&gt;<br/>1&gt;CSC : warning <strong>SEC0010</strong>: Event validation is disabled. C:WebApplicationWeb.config(12): &lt;pages enableEventValidation="false" enableViewStateMac="false" viewStateEncryptionMode="Never" validateRequest="false" /&gt;<br/>1&gt;CSC : warning <strong>SEC0012</strong>: Validate request is disabled. C:WebApplicationWeb.config(12): &lt;pages enableEventValidation="false" enableViewStateMac="false" viewStateEncryptionMode="Never" validateRequest="false" /&gt;<br/>1&gt;CSC : warning <strong>SEC0013</strong>: Pages ViewStateEncryptionMode disabled. C:WebApplicationWeb.config(12): &lt;pages enableEventValidation="false" enableViewStateMac="false" viewStateEncryptionMode="Never" validateRequest="false" /&gt;<br/>1&gt;CSC : warning <strong>SEC0011</strong>: ViewStateMac is disabled. C:WebApplicationWeb.config(12): &lt;pages enableEventValidation="false" enableViewStateMac="false" viewStateEncryptionMode="Never" validateRequest="false" /&gt;
</pre>
<ol start="6">
<li>Replace the <kbd>system.web</kbd> XML element in the <kbd>Web.config</kbd> file with the following contents (changes are highlighted in bold):</li>
</ol>
<pre style="padding-left: 90px">
&lt;system.web&gt;<br/>  &lt;compilation debug="false" targetFramework="4.6.2" /&gt;<br/>  &lt;customErrors mode="<strong>On</strong>" defaultRedirect="/home/error"/&gt;<br/>  &lt;httpRuntime enableHeaderChecking="<strong>true</strong>" enableVersionHeader="<strong>false</strong>" /&gt;<br/>  &lt;httpCookies requireSSL="<strong>true</strong>" httpOnlyCookies="<strong>true</strong>"/&gt;<br/>  &lt;pages enableEventValidation="<strong>true</strong>" enableViewStateMac="<strong>true</strong>" viewStateEncryptionMode="<strong>Always</strong>" validateRequest="<strong>true</strong>" /&gt;<br/>  &lt;authentication mode="Forms"&gt;<br/>    &lt;forms loginUrl="~/Account/Login.aspx" timeout="<strong>15</strong>" enableCrossAppRedirects="<strong>false</strong>" protection="<strong>All</strong>"<strong> requireSSL="true" cookieless="UseCookies"</strong> /&gt;<br/>  &lt;/authentication&gt;<br/>&lt;/system.web&gt;
</pre>
<ol start="7">
<li>Build the project again and verify it compiles without any security warnings.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>PUMA scan analyzers catch security vulnerabilities in the web configuration files in C# ASP.NET web projects. In the preceding recipe, we showed you different kinds of security vulnerabilities that are caught by the PUMA scan analyzers, such as insecure forms authentication, http cookies configuration, header settings, and so on. You can read detailed description of all web configuration-related security vulnerabilities identified by the PUMA scan analyzers at <a href="https://www.pumascan.com/rules.html#configuration">https://www.pumascan.com/rules.html#configuration</a>.</p>
<p>These security analyzers are written as additional file analyzers that analyze non-source files in the project that have been marked as <kbd>AdditionalFiles</kbd> item type. Users must mark the <kbd>web.config</kbd> file as an additional file in their project to trigger security analysis during build. You can read more about how to write and consume additional file analyzers at <a href="https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md">https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md</a>.<br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying cross-site scripting vulnerabilities in view markup files (.cshtml, .aspx files) in web applications</h1>
                
            
            
                
<p><strong>Cross-site scripting</strong> (<strong>XSS</strong>) is a type of computer security vulnerability typically found in web applications. XSS enables attackers to inject client-side scripts into web pages viewed by other users. A cross-site scripting vulnerability may be used by attackers to bypass access controls such as the same-origin policy. Cross-site scripting carried out on websites accounted for roughly 84% of all security vulnerabilities documented by Symantec as of 2007. Their effect may range from a petty nuisance to a significant security risk, depending on the sensitivity of the data handled by the vulnerable site and the nature of any security mitigation implemented by the site's owner.</p>
<p>You can read more details about cross-site scripting at <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">https://en.wikipedia.org/wiki/Cross-site_scripting</a>.<br/>
In this section, we will walk you through the rules in PUMA scan analyzers to catch security vulnerabilities that can lead to cross-site scripting attacks in an ASP.NET web project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start Visual Studio and click on File | New| Project... and create a new Visual C# | Web | ASP.NET Web Application with the MVC template, say <kbd>WebApplication</kbd>:</li>
</ol>
<div><img class="image-border" height="372" src="img/66e98811-4b2c-4298-9ca3-338328939f7a.png" width="572"/></div>
<ol start="2">
<li>Install the <kbd>Puma.Security.Rules</kbd> analyzers NuGet package (at the time of writing, the latest stable version is <em>1.0.4</em>). For guidance on how to search and install analyzer NuGet package to a project, refer to the recipe <em>Searching and installing analyzers through the NuGet package manager</em> in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
</ol>
<p> </p>
<ol start="3">
<li>Open Views | _ViewStart.cshtml file and add the following text at the end of the file:</li>
</ol>
<pre style="padding-left: 90px">
&lt;div&gt;<br/> @Html.Raw(string.Format("Welcome &lt;span class=\"bold\"&gt;{0}&lt;/span&gt;!", ViewContext.ViewBag.UserName))<br/><br/> @{<br/>   WriteLiteral(string.Format("Welcome &lt;span class=\"bold\"&gt;{0}&lt;/span&gt;!", ViewContext.ViewBag.UserName));<br/> }<br/>&lt;/div&gt;
</pre>
<ol start="4">
<li>Select <kbd>_ViewStart.cshtml</kbd> in the solution explorer and change its Build Action from Content to AdditionalFiles using the Properties window below and save the project.</li>
<li>Add a new Web Form to the project, say <kbd>WebForm.aspx</kbd>, and the following HTML heading with a raw inline expression to the form:</li>
</ol>
<pre style="padding-left: 90px">
&lt;div&gt;<br/> &lt;h2&gt;Welcome &lt;%= Request["UserName"].ToString() %&gt;&lt;/h2&gt;<br/>&lt;/div&gt;
</pre>
<ol start="6">
<li>Select <kbd>WebForm.aspx</kbd> in the solution explorer and change its Build Action from Content to AdditionalFiles using the Properties window below and save the project.</li>
<li>Build the project in Visual Studio or command line and verify you get following <em>SECXXXX</em> warnings from the PUMA scan analyzer:</li>
</ol>
<div><img class="image-border" height="251" src="img/607af216-65fc-49d7-8f54-48ace4b2e2d6.png" width="715"/></div>
<ol start="8">
<li>Replace the HTML division element added to <kbd>_ViewStart.cshtml</kbd> in step 3 with the following:</li>
</ol>
<pre style="padding-left: 90px">
&lt;div&gt;<br/> Welcome &lt;span class=\"bold\"&gt;@ViewContext.ViewBag.UserName&lt;/span&gt;!<br/>&lt;/div&gt;
</pre>
<ol start="9">
<li>Replace the HTML division element added to <kbd>WebForm.aspx</kbd> in step 5 with the following:</li>
</ol>
<pre style="padding-left: 90px">
&lt;div&gt;<br/> &lt;h2&gt;Welcome &lt;%: Request["UserName"].ToString() %&gt;&lt;/h2&gt;<br/>&lt;/div&gt;
</pre>
<ol start="10">
<li>Build the project again and verify it compiles without any security warnings.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>PUMA scan analyzers catch cross-site scripting security vulnerabilities in the view markup files (<kbd>.cshtml</kbd>, <kbd>.aspx</kbd>, <kbd>.ascx</kbd>) in C# ASP.NET web projects. In the preceding recipe, we showed you different kinds of security vulnerabilities that are caught by the PUMA scan analyzers, such as data from untrusted data source written to the body of an HTML document using raw inline and binding expressions, raw razor helper, and raw <kbd>WriteLiteral</kbd> method, and so on. It is recommended that such data is HTML encoded before being written to the browser. You can read detailed description of all cross-site scripting related security vulnerabilities identified by the PUMA scan analyzers at <a href="https://www.pumascan.com/rules.html#cross-site-scripting">https://www.pumascan.com/rules.html#cross-site-scripting</a>.<br/> These security analyzers are written as additional file analyzers that analyze non-source files in the project that have been marked as <kbd>AdditionalFiles</kbd> item type. Users must mark the view markup files as additional files in their project to trigger security analysis during build. You can read more about how to write and consume additional file analyzers at <a href="https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md">https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md</a>.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying insecure method calls that can lead to SQL and LDAP injection attacks</h1>
                
            
            
                
<div><p>SQL injection is a code injection technique, used to attack data-driven applications, in which nefarious SQL statements are inserted into an entry field for execution (for example, to dump the database contents to the attacker). SQL injection attacks allow attackers to spoof identity, tamper with existing data, cause repudiation issues such as voiding transactions or changing balances, allow the complete disclosure of all data on the system, destroy the data or make it otherwise unavailable, and become administrators of the database server.</p>
<p>LDAP injection is a code injection technique used to exploit web applications, which could reveal sensitive user information or modify information represented in the <strong>Lightweight Directory Access Protocol</strong> (<strong>LDAP</strong>) data stores. LDAP injection exploits a security vulnerability in an application by manipulating input parameters passed to internal search, add, or modify functions.</p>
</div>
<p>You can read more details about SQL injection at (<a href="https://en.wikipedia.org/wiki/SQL_injection">https://en.wikipedia.org/wiki/SQL_injection</a>) and LDAP injection at <a href="https://en.wikipedia.org/wiki/LDAP_injection">https://en.wikipedia.org/wiki/LDAP_injection</a>.<br/>
In this section, we will walk you through the rules in PUMA scan analyzers to catch security vulnerabilities that can lead to SQL injection and LDAP injection attacks in data driven .NET projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start Visual Studio and click File | New | Project... and create a new Visual C# | Class Library, say <kbd>ClassLibrary</kbd>.</li>
<li>Install the <kbd>Puma.Security.Rules</kbd> analyzers NuGet package (at the time of writing, the latest stable version is <em>1.0.4</em>). For guidance on how to search and install analyzer NuGet package to a project, refer to the recipe, <em>Searching and installing analyzers through the NuGet package manager</em> in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
<li>Add assembly references to the following framework assemblies: <q>System.Data.Linq.dll</q> and <kbd>System.DirectoryServices.dll</kbd>.</li>
<li>Replace the default <kbd>Class1</kbd> implementation in <kbd>Class1.cs</kbd> with the following code:</li>
</ol>
<pre style="padding-left: 90px">
using System.Data.Linq;<br/>using System.Data.SqlClient;<br/>using System.DirectoryServices;<br/><br/>public class Class1<br/>{<br/>  private void SQL_Injection(SqlConnection connection, string id)<br/>  {<br/>    using (DataContext context = new DataContext(connection))<br/>    {<br/>      context.ExecuteCommand("SELECT * FROM Items WHERE ID = " + id);<br/>    }<br/><br/>    SqlCommand cmd = new SqlCommand("SELECT * FROM Items WHERE ID = " + id, connection);<br/>    string result = cmd.ExecuteScalar().ToString();<br/>  }<br/><br/>  private void LDAP_Injection(string domain, string userName)<br/>  {<br/>    DirectoryEntry entry = new DirectoryEntry(string.Format("LDAP://DC={0}, DC=COM/", domain));<br/>    DirectorySearcher searcher = new DirectorySearcher(entry)<br/>    {<br/>      SearchScope = SearchScope.Subtree,<br/>      Filter = string.Format("(name={0})", userName)<br/>    };<br/>    SearchResultCollection resultCollection = searcher.FindAll();<br/>  }<br/>}
</pre>
<ol start="5">
<li>Verify you get following <em>SECXXX</em> diagnostics from PUMA scan analyzers in the error list and squiggles in the editor while editing code and also when invoking an explicit build.</li>
</ol>
<div><img class="image-border" height="146" src="img/48965768-bfdc-4d65-9262-24e9f988ba8a.png" width="705"/></div>
<ol start="6">
<li>Fix <em>SEC0106</em> reported on <kbd>context.ExecuteCommand</kbd> in method <kbd>SQL_Injection</kbd> by passing <em>id</em> as the second argument to the invocation: <kbd>context.ExecuteCommand("SELECT * FROM Items WHERE ID = {0}", id);</kbd></li>
<li>Fix <em>SEC0107</em> by parameterizing the query passed to <em>new</em> <kbd>SqlCommand(...)</kbd> with a <kbd><em>SqlParameter</em></kbd>:</li>
</ol>
<pre style="padding-left: 90px">
SqlCommand cmd = new SqlCommand("SELECT * FROM Items WHERE ID = <strong>@id</strong>", connection);<br/><strong>SqlParameter parm = new SqlParameter("@id", id);</strong><br/><strong>cmd.Parameters.Add(parm);</strong>
</pre>
<ol start="8">
<li>Fix <em>SEC0114</em> diagnostics by encoding the domain and <kbd>userName</kbd> arguments using the Web Protection Library (also known as AntiXSS) LDAP encoding methods.
<ol>
<li>Add NuGet package reference to AntiXSS library</li>
<li>Replace the domain argument passed to new <kbd>DirectoryEntry(...)</kbd> with <kbd>Microsoft.Security.Application.Encoder.LdapDistinguishedNameEncode(domain)</kbd></li>
<li>Replace the <kbd>userName</kbd> argument passed to <kbd>string.Format</kbd> invocation in the initializer for filter with <kbd>Microsoft.Security.Application.Encoder.LdapFilterEncode(userName)</kbd></li>
</ol>
</li>
<li>Verify there are no diagnostics in the error list and the project builds without any errors or warnings.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>PUMA scan analyzers catch SQL injection and LDAP injection security vulnerabilities in the source code of data-driven applications. In the preceding recipe, we showed you couple of different kinds of security vulnerabilities that are caught by these analyzers, such as concatenating untrusted data with SQL query strings, Sql command, LDAP directory entry path and filter format.<br/>
SQL injection attacks can be prevented by using parameterized queries where the untrusted data is passed as an explicit format argument.<br/>
LDAP injection attacks can be prevented by using LDAP encoding methods to encode the untrusted data. You can read detailed description of all SQL and LDAP injection security vulnerabilities identified by the PUMA scan analyzers at <a href="https://www.pumascan.com/rules.html#injection">https://www.pumascan.com/rules.html#injection</a>.<br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying weak password protection and management in web applications</h1>
                
            
            
                
<p class="mce-root">Applications responsible for password management inherit a tremendous amount of risk and responsibility. User passwords must be created with sufficient length/complexity, stored securely, and protected from brute force and cracking attempts.<br/></p>
<p>In this section, we will walk you through the rules in PUMA scan analyzers to catch vulnerabilities related to weak password management vulnerabilities in ASP.NET web projects. The following password management rules are currently supported in PUMA scan analyzers:</p>
<ul>
<li>ASP.NET Identity Weak Password Complexity</li>
<li>ASP.NET Identity Missing Password Lockout</li>
</ul>
<p>You can read more details about these rules at <a href="https://www.pumascan.com/rules.html#password-management">https://www.pumascan.com/rules.html#password-management</a>.<br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start Visual Studio and click on File | New | Project and create a new Visual C# | Web | ASP.NET Web Application with the Web Forms template, say <kbd>WebApplication</kbd>. Click on Change Authentication button and change the authentication to Individual User Accounts:</li>
</ol>
<div><img class="image-border" height="387" src="img/aa3dfea3-0f77-443c-a301-51dcd7a732b6.png" width="593"/></div>
<ol start="2">
<li>Install the <kbd>Puma.Security.Rules</kbd> analyzers NuGet package (at the time ofwriting, the latest stable version is <em>1.0.4</em>). For guidance on how to search and install analyzer NuGet package to a project, refer to the recipe, <em>Searching and installing analyzers through the NuGet package manager</em> in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
</ol>
<p> </p>
<ol start="3">
<li>Build the project and verify that you get a bunch of <em>SECXXXX</em> diagnostics from the PUMA scan analyzers, including a couple of password protection related diagnostics (<em>SEC0017</em> and <em>SEC0018</em>):</li>
</ol>
<pre style="padding-left: 90px">
WebApplicationApp_StartIdentityConfig.cs(50,41,57,14): warning <strong>SEC0017</strong>: Password validator settings do not meet the requirements - Minimum Length (12), Numeric Character (True), Lowercase Character (True), Uppercase Character (True), Special Character (True)<br/>...<br/>WebApplicationAccountLogin.aspx.cs(36,121,36,126): warning <strong>SEC0018</strong>: Password lockout is disabled. To protect accounts from brute force attacks, set the shouldLockout parameter to true.
</pre>
<ol start="4">
<li>Open <kbd>WebApplicationApp_StartIdentityConfig.cs</kbd> and change the required minimum password length to be <kbd>12</kbd>:</li>
</ol>
<pre style="padding-left: 90px">
// Configure validation logic for passwords<br/>manager.PasswordValidator = new PasswordValidator<br/>{<br/> <strong>RequiredLength = 12</strong>,<br/> RequireNonLetterOrDigit = true,<br/> RequireDigit = true,<br/> RequireLowercase = true,<br/> RequireUppercase = true,<br/>};
</pre>
<ol start="5">
<li>Open <kbd>WebApplicationAccountLogin.aspx.cs</kbd> and change the <kbd>shouldLockout</kbd> argument to <kbd>PasswordSignIn</kbd> invocation to be true:</li>
</ol>
<pre style="padding-left: 90px">
var result = signinManager.PasswordSignIn(Email.Text, Password.Text, RememberMe.Checked, <strong>shouldLockout: true</strong>);
</pre>
<ol start="6">
<li>Build the project and verify there are no <em>SEC0017</em> and <em>SEC0018</em> diagnostics.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying weak validation of data from external components to prevent attacks such as cross-site request forgery and path tampering</h1>
                
            
            
                
<p>In this section, we will walk you through the rules in PUMA scan analyzers to catch security vulnerabilities that can lead to following types of security attacks due to insufficient validation of input:</p>
<ul>
<li><strong>Cross-Site request forgery</strong> (<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">https://en.wikipedia.org/wiki/Cross-site_request_forgery</a>): Cross-site request forgery, also known as one-click attack or session riding and abbreviated as CSRF or XSRF, is a type of malicious exploit of a website where unauthorized commands are transmitted from a user that the web application trusts. Unlike cross-site scripting (XSS), which exploits the trust a user has for a particular site, CSRF exploits the trust that a site has in a user's browser</li>
</ul>
<ul>
<li><strong>Path tampering</strong> (<a href="https://en.wikipedia.org/wiki/Directory_traversal_attack">https://en.wikipedia.org/wiki/Directory_traversal_attack</a>): A directory traversal (or path traversal) consists in exploiting insufficient security validation/sanitization of user-supplied input filenames, so that characters representing traverse to parent directory are passed through to the file APIs. The goal of this attack is to use an affected application to gain unauthorized access to the filesystem</li>
</ul>
<ul>
<li class=""><strong>Unvalidated redirect</strong> (<a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet">https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet</a>): Unvalidated redirects and forwards are possible when a web application accepts untrusted input that could cause the web application to redirect the request to a URL contained within untrusted input. By modifying untrusted URL input to a malicious site, an attacker may successfully launch a phishing scam and steal user credentials</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a>.<a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start Visual Studio and click File | New | Project... and create a new Visual C# | Web | ASP.NET Web Application with the MVC template, say <kbd>WebApplication</kbd>.</li>
</ol>
<ol start="2">
<li>Install the <kbd>Puma.Security.Rules</kbd> analyzers NuGet package (at the time of writing, the latest stable version is <em>1.0.4</em>). For guidance on how to search and install analyzer NuGet package to a project, refer to the recipe, <em>Searching and installing analyzers through the NuGet package manager</em>, in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
<li>Add a new class <kbd>Class1</kbd> to the project and replace the file contents with the following code:</li>
</ol>
<p> </p>
<pre style="padding-left: 90px">
using System.Configuration;<br/>using System.Net.Http;<br/>using System.Web.Mvc;<br/><br/>namespace WebApplication<br/>{<br/>  public class Class1<br/>  {<br/>    [AllowHtml]<br/>    public string AllowHtmlProperty { get; set; }<br/><br/>    [HttpPost]<br/>    [ValidateInput(false)]<br/>    public ActionResult Missing_AntiForgeryToken()<br/>    {<br/>      return null;<br/>    }<br/><br/>    [HttpPost]<br/>    public FileResult Path_Tampering(string fileName)<br/>    {<br/>      string filePath = ConfigurationManager.AppSettings["DownloadDirectory"].ToString();<br/>      return new FilePathResult(filePath + fileName, "application/octet-stream");<br/>    }<br/><br/>    private void Certificate_Validation_Disabled()<br/>    {<br/>      using (var handler = new WebRequestHandler())<br/>      {<br/>        handler.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) =&gt; true;<br/>      }<br/>    }<br/>  }<br/>}
</pre>
<ol start="4">
<li>Verify you get following <em><strong>SECXXX</strong></em> diagnostics from PUMA scan analyzers in the error list and squiggles in the editor while editing code and also when invoking an explicit build:</li>
</ol>
<div><img class="image-border" height="188" src="img/f3b71eb8-5d9b-4ad0-a35e-4f530a1c744b.png" width="804"/></div>
<ol start="5">
<li>Fix the first two <em>SEC0019</em> diagnostics by applying the <kbd>[ValidateAntiForgeryToken]</kbd> attribute to methods <kbd>Missing_AntiForgeryToken</kbd> and <kbd>Path_Tampering</kbd>.</li>
<li>Fix <em>SEC0022</em> by deleting the <kbd>[AllowHtml]</kbd> attribute on <kbd>AllowHtmlProperty</kbd><em>.</em></li>
<li>Fix <em>SEC0023</em> by deleting the <kbd>[ValidateInput(false)]</kbd> attribute on <kbd>Missing_AntiForgeryToken</kbd><em>.</em></li>
<li>Fix <em>SEC01111</em> by adding the following <kbd>ValidatedFileResult</kbd> type and replacing <kbd>return new FilePathResult(...)</kbd> with <kbd>return new ValidatedFileResult(...)</kbd> in <kbd>Path_Tampering</kbd> method.</li>
</ol>
<p> </p>
<pre style="padding-left: 90px">
private class ValidatedFileResult : FileResult<br/>{<br/>  public ValidatedFileResult(string filePath, string fileName, string contentType)<br/>  : base(contentType)<br/>  {<br/>    // Add validation logic.<br/>  }<br/><br/>  protected override void WriteFile(HttpResponseBase response)<br/>  {<br/>    // Add write logic<br/>  }<br/>}
</pre>
<ol start="9">
<li>Fix <em>SEC0113</em> by deleting the line <kbd>handler.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) =&gt; true;</kbd>.</li>
<li>Build the project again and verify it compiles without any security warnings.</li>
</ol>
<p>You can read further details about PUMA scan validation rules at <a href="https://www.pumascan.com/rules.html#validation">https://www.pumascan.com/rules.html#validation</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying performance improvements to source code using FxCop analyzers</h1>
                
            
            
                
<p>In this section, we will introduce you to a popular third-party analyzer package for C# projects, FxCop analyzers.<br/>
We will walk through how to install the FxCop analyzers NuGet package and give examples violations for different performance rules and show you how to automatically fix some of these issues with the code fixes that come along with the analyzers in the NuGet package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start Visual Studio and click File | New | Project... and create a new C# class library project and replace the code in <kbd>Class1.cs</kbd> with code from the code sample at <kbd>ClassLibrary\Class1.cs</kbd>.</li>
<li>Install the <kbd>Microsoft.CodeAnalysis.FxCopAnalyzers</kbd> NuGet package (the latest prerelease version at the time of writing is <em>1.2.0-beta2)</em>. For guidance on how to search and install analyzer NuGet package to a project, refer to the recipe, <em>Searching and installing analyzers through the NuGet package manager</em>, in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
<li>Unload the project file by right-clicking on <kbd>ClassLibrary1</kbd> in the solution explorer and then open the project file for editing in Visual Studio by right clicking on the unloaded project in the solution explorer.</li>
<li>Add the following <kbd>PropertyGroup</kbd> to the project to enable the new Roslyn <kbd>IOperation</kbd> feature used by the FxCop analyzers:</li>
</ol>
<pre style="padding-left: 90px">
 &lt;PropertyGroup&gt;<br/>  &lt;Features&gt;IOperation&lt;/Features&gt;<br/> &lt;/PropertyGroup&gt;
</pre>
<ol start="5">
<li>Reload the project and verify the following FxCop diagnostics show up in the error list:</li>
</ol>
<div><img class="image-border" height="223" src="img/5da129c7-005b-4a2f-80b6-6727dc741eaf.png" width="738"/></div>
<ol start="6">
<li>Build the project from the command line or top level Build menu in Visual Studio and verify these diagnostics are also reported from build.</li>
<li>Double click on the warning <em>CA1815</em> (ValueType should override Equals) and verify lightbulb is offered in the editor to implement the overrides for equals, <kbd>GetHashCode</kbd> and <kbd>==</kbd> and <kbd>!=</kbd> operator methods:</li>
</ol>
<div><img class="image-border" height="319" src="img/f4f32f5a-4088-4a2d-97b4-a096ef87d070.png" width="560"/></div>
<ol start="8">
<li>Verify that applying the code fix by hitting the <em>Enter</em> key fixes <em>CA1815</em> diagnostics. Note that this introduces new <em>CAXXXX</em> diagnostics due to the default implementation of the overrides.</li>
<li>Replace the content of <kbd>Class1.cs</kbd> with following code and verify all <em>CAXXXX</em> diagnostics are fixed:</li>
</ol>
<pre style="padding-left: 90px">
using System;<br/><br/>namespace Namespace<br/>{<br/>  public class Class1: IDisposable<br/>  {<br/>    private static int staticField = 3;<br/>    private int[][] jaggedArray;<br/><br/>    public void Method1(int usedParam)<br/>    {<br/>      Console.WriteLine(usedParam);<br/>    }<br/><br/>    public void Dispose()<br/>    {<br/>      Dispose(true);<br/>      GC.SuppressFinalize(this);<br/>    }<br/><br/>    protected virtual void Dispose(bool disposing)<br/>    {<br/>      if (disposing)<br/>      {<br/>        // Dispose resources.<br/>      }<br/>    }<br/>  }<br/><br/>  public struct ValueType: IEquatable&lt;ValueType&gt;<br/>  {<br/>    public int Property { get; }<br/><br/>    public override bool Equals(object obj)<br/>    {<br/>      return Equals((ValueType)obj);<br/>    }<br/><br/>    public bool Equals(ValueType other)<br/>    {<br/>      return other.Property == Property;<br/>    }<br/><br/>    public override int GetHashCode()<br/>    {<br/>      return Property.GetHashCode();<br/>    }<br/><br/>    public static bool operator ==(ValueType left, ValueType right)<br/>    {<br/>      return left.Property == right.Property;<br/>    }<br/><br/>    public static bool operator !=(ValueType left, ValueType right)<br/>    {<br/>      return left.Property != right.Property;<br/>    }<br/>  }<br/>}
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>FxCop analyzers are a port of the most important Microsoft code analysis rules (CAXXXX), which were implemented as an MSIL-based binary analysis. Compared to the post-build binary analysis, the FxCop analyzers have added advantage of live analysis and diagnostics while editing code, as well as rich code fixes to fix these issues.<br/>
FxCop contains rules in various different categories such as performance, security, code style, API design, maintainability, and so on. In the example covered in this section, we focused on the following performance rules:</p>
<ul>
<li><em>CA1801</em> (Review unused parameters) (<a href="https://msdn.microsoft.com/en-us/library/ms182268.aspx">https://msdn.microsoft.com/en-us/library/ms182268.aspx</a>): A method signature includes a parameter that is not used in the method body.</li>
<li><em>CA1810</em> (Initialize reference type static fields inline) (<a href="https://msdn.microsoft.com/en-us/library/ms182275.aspx">https://msdn.microsoft.com/en-us/library/ms182275.aspx</a>): When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called. Static constructor checks can decrease performance.</li>
<li><em>CA1814</em> (Prefer jagged arrays over multidimensional) (<a href="https://msdn.microsoft.com/en-us/library/ms182277.aspx">https://msdn.microsoft.com/en-us/library/ms182277.aspx</a>): A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</li>
<li><em>CA1815</em> (Override equals and operator equals on value types) (<a href="https://msdn.microsoft.com/en-us/library/ms182276.aspx">https://msdn.microsoft.com/en-us/library/ms182276.aspx</a>): For value types, the inherited implementation of equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement equals.</li>
<li><em>CA1816</em> (Call <kbd>GC.SuppressFinalize</kbd> correctly) (<a href="https://msdn.microsoft.com/en-us/library/ms182269.aspx">https://msdn.microsoft.com/en-us/library/ms182269.aspx</a>): A method that is an implementation of <kbd>Dispose</kbd> does not call <kbd>GC.SuppressFinalize</kbd>, or a method that is not an implementation of <kbd>Dispose</kbd> calls <kbd>GC.SuppressFinalize</kbd>, or a method calls <kbd>GC.SuppressFinalize</kbd> and passes something other than this.</li>
<li><em>CA1821</em> (Remove empty finalizers) (<a href="https://msdn.microsoft.com/en-us/library/bb264476.aspx">https://msdn.microsoft.com/en-us/library/bb264476.aspx</a>): Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime. An empty finalizer incurs added overhead without any benefit.</li>
</ul>
<p>You can read detailed documentation about all the FxCop performance rules at <a href="https://msdn.microsoft.com/en-us/library/ms182260(v=vs.140).aspx">https://msdn.microsoft.com/en-us/library/ms182260(v=vs.140).aspx</a>.<br/>
Note that even though majority of Microsoft Code Analysis performance rules have been ported to FxCop analyzers package, not all rules are enabled by default in the NuGet package. You can view and configure the suppression state and severity of each FxCop rule by using the ruleset editor. For further guidance on using the ruleset editor, refer to recipe <em>Using ruleset file and ruleset editor to configure analyzers</em>, in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects.</em></p>


            

            
        
    </body></html>