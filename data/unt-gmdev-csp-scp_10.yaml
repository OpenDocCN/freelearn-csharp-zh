- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Implementing Artificial Intelligence in Unity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中实现人工智能
- en: In this chapter, we will explore the integration of **Artificial Intelligence**
    (**AI**) in Unity, starting with the basics of AI and progressing to complex applications
    such as pathfinding and Behavior Trees. You’ll learn how pathfinding algorithms
    enable intelligent character movement and navigation in varied environments. We
    will also cover AI decision-making processes that allow Non-Player Characters
    or NPCs to react and adapt to dynamic game scenarios. By the end of the chapter,
    you’ll have practical insights into crafting sophisticated NPC behaviors using
    advanced AI techniques, enhancing your game’s depth, realism, and player engagement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Unity中人工智能（**AI**）的集成，从AI的基础知识开始，逐步深入到复杂的路径查找和行为树应用。你将学习路径查找算法如何使智能角色在多变的环境中实现智能移动和导航。我们还将介绍AI决策过程，这些过程允许非玩家角色（NPC）对动态游戏场景做出反应和适应。到本章结束时，你将获得使用高级AI技术制作复杂NPC行为的实际见解，增强游戏深度、真实性和玩家参与度。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of the role of AI in gaming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中AI作用的概述
- en: Understanding the basics of AI in the Unity environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity环境中理解AI的基础知识
- en: Applying pathfinding algorithms for character movement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用路径查找算法进行角色移动
- en: Building AI logic for decision-making processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建决策过程的AI逻辑
- en: Creating sophisticated NPC behaviors using AI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AI创建复杂的NPC行为
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter10](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter10)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到与本章节相关的示例/文件：[https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter10](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter10)
- en: An overview of the role of AI in gaming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中AI作用的概述
- en: In this section, we will journey through AI’s evolution in gaming, from its
    rudimentary beginnings to its current sophistication, highlighting key milestones.
    From simple scripted behaviors to complex learning-driven agents, AI reshapes
    gameplay, character behavior, and narratives. Understanding these transformations
    provides insight into AI’s pivotal role in modern gaming, setting the context
    to explore its ongoing impact on interactive entertainment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾AI在游戏中的发展历程，从其原始的起点到现在的复杂程度，突出关键里程碑。从简单的脚本行为到复杂的学习驱动代理，AI重塑了游戏玩法、角色行为和叙事。理解这些转变有助于深入了解AI在现代游戏中的关键作用，为探索其对互动娱乐持续影响提供背景。
- en: Comparing large language models and Behavior Trees in game development
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较游戏开发中的大型语言模型和行为树
- en: In the rapidly evolving field of AI, **Large Language Models** (**LLMs**) such
    as **GPT-3** have garnered significant attention for their ability to generate
    coherent and contextually appropriate text, based on vast datasets. These models
    are characterized by their substantial size, often encompassing billions of parameters
    that require extensive storage space and considerable computational power to function
    effectively. As a result, LLMs demand robust hardware capabilities, often necessitating
    the use of specialized servers or cloud-based platforms to operate efficiently.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速发展的AI领域，**大型语言模型**（**LLMs**）如**GPT-3**因其基于大量数据集生成连贯且上下文适当的文本的能力而受到广泛关注。这些模型以其庞大的规模为特征，通常包含数十亿个参数，需要大量的存储空间和强大的计算能力才能有效运行。因此，LLMs需要强大的硬件能力，通常需要使用专用服务器或基于云的平台才能高效运行。
- en: In contrast, video game development typically requires more agile and less resource-intensive
    AI solutions, making **Behavior Trees** a preferred choice. Behavior Trees are
    modular, scalable, and notably faster in execution when compared to computationally
    heavy LLMs. They provide a clear structure for game AI, allowing developers to
    script complex behaviors made up of simple, reusable nodes. This architecture
    not only optimizes performance but also simplifies debugging and iterative design,
    crucial factors in game development cycles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，视频游戏开发通常需要更敏捷且资源消耗更少的AI解决方案，这使得**行为树**成为首选。行为树是模块化、可扩展的，与计算密集型LLMs相比，执行速度明显更快。它们为游戏AI提供了一个清晰的架构，允许开发者编写由简单、可重复使用的节点组成的复杂行为脚本。这种架构不仅优化了性能，还简化了调试和迭代设计，这些是游戏开发周期中的关键因素。
- en: While LLMs offer remarkable capabilities in natural language understanding and
    generation, their practical application in real-time gaming scenarios is currently
    limited by their resource demands. Conversely, Behavior Trees, by virtue of their
    efficiency and lower operational overhead, remain a staple in creating responsive
    and intelligent NPC behaviors without the overhead of extensive computational
    resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大型语言模型（LLMs）在自然语言理解和生成方面提供了非凡的能力，但它们在实时游戏场景中的实际应用目前受到资源需求的限制。相反，行为树（Behavior
    Trees）由于其效率和较低的操作开销，仍然是创建响应性和智能NPC行为的标准，无需大量计算资源。
- en: This distinction underlines why, despite the impressive capabilities of LLMs,
    Behavior Trees continue to be integral in game AI development, ensuring that games
    can run smoothly on a variety of hardware platforms, from high-end gaming rigs
    to mobile devices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别强调了为什么，尽管大型语言模型（LLMs）具有令人印象深刻的性能，但行为树（Behavior Trees）在游戏人工智能开发中仍然至关重要，确保游戏可以在各种硬件平台上平稳运行，从高端游戏机到移动设备。
- en: AI has profoundly transformed the landscape of video gaming, marking a significant
    evolution in how games are designed and experienced. Initially used in simple
    arcade games to direct basic enemy behavior, AI has grown in complexity to influence
    every facet of gaming – from enhancing gameplay mechanics to enriching narratives
    and character behaviors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能深刻地改变了电子游戏领域，标志着游戏设计和体验的重大演变。最初用于简单街机游戏来指导基本的敌人行为，人工智能的复杂性已经增长，影响了游戏的各个方面——从增强游戏机制到丰富叙事和角色行为。
- en: 'Key milestones in AI have transformed gameplay, enabling challenging interactions.
    Modern games showcase sophisticated AI characters with varied emotions, adding
    depth. AI has also reshaped narratives through adaptive storytelling, as seen
    in games such as *Detroit: Become Human*. This evolution increases immersion and
    replay value while paving the way for future innovations in gaming realism.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能的关键里程碑已经改变了游戏玩法，实现了具有挑战性的交互。现代游戏展示了具有多种情绪的复杂人工智能角色，增加了深度。人工智能还通过适应性叙事重塑了叙事，如在《底特律：成为人类》等游戏中所见。这种演变增加了沉浸感和重玩价值，并为游戏现实主义的未来创新铺平了道路。
- en: Enhancing gameplay with AI
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用人工智能增强游戏玩法
- en: After understanding the distinction between LLMs and Behavior Trees, we will
    now delve into the practical significance of AI in game design. AI isn’t just
    about automating tasks; it also transforms gameplay, making it dynamic and engaging.
    Through examples such as adaptive enemy behavior and AI-driven story progression,
    we’ll show how AI profoundly impacts games. Integrating AI in Unity projects elevates
    the gaming experience, offering players immersive worlds that evolve and react
    uniquely.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了LLMs和行为树之间的区别之后，我们现在将深入探讨人工智能在游戏设计中的实际意义。人工智能不仅仅是自动化任务；它还改变了游戏玩法，使其动态且引人入胜。通过适应性敌人行为和人工智能驱动的剧情进展等例子，我们将展示人工智能如何深刻影响游戏。将人工智能集成到Unity项目中提升了游戏体验，为玩家提供了不断发展和独特反应的沉浸式世界。
- en: AI transforms games, infusing them with intelligence and dynamism. Adaptive
    enemy behavior, powered by AI, adjusts difficulty based on player skill, ensuring
    engagement. Complex NPC interactions enrich narratives, with characters evolving
    based on player choices. AI-driven story progression offers personalized journeys,
    branching narratives based on actions. These AI features make games interactive
    and unique, enhancing Unity projects’ quality and appeal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能正在改变游戏，将智能和活力注入其中。由人工智能驱动的适应性敌人行为，根据玩家技能调整难度，确保玩家的参与度。复杂的NPC互动丰富了叙事，角色根据玩家的选择而发展。人工智能驱动的剧情进展提供了个性化的旅程，基于行动的分支叙事。这些人工智能特性使游戏更具互动性和独特性，提升了Unity项目的质量和吸引力。
- en: AI enhances gaming with dynamic elements, scaling difficulty and enriching narratives.
    AI-driven story progression ensures unique experiences. AI has dramatically transformed
    video gaming, evolving from simple patterns in early arcade games to complex systems
    that enhance gameplay, character interaction, and narrative depth. Key AI developments
    now allow characters to adapt to player actions and narratives and evolve, based
    on choices, greatly enriching the gaming experience.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能通过动态元素增强了游戏，调整难度并丰富叙事。人工智能驱动的剧情进展确保了独特的体验。人工智能极大地改变了电子游戏，从早期街机游戏中的简单模式发展到增强游戏玩法、角色互动和叙事深度的复杂系统。关键的AI发展现在允许角色根据玩家的行动和叙事进行适应和演变，基于选择，极大地丰富了游戏体验。
- en: This evolution has revolutionized game design and set the stage for advanced
    AI implementations in Unity. The next section will discuss Unity’s support for
    AI development with tools such as NavMesh for pathfinding, the Animator for state
    management, and the ML-Agents Toolkit, equipping developers to integrate sophisticated
    AI functionalities into their games.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种演变彻底改变了游戏设计，并为在Unity中实现高级人工智能应用奠定了基础。下一节将讨论Unity对人工智能开发的支撑，包括用于路径查找的NavMesh工具、用于状态管理的Animator以及ML-Agents
    Toolkit，使开发者能够将复杂的AI功能集成到他们的游戏中。
- en: An introduction to Unity’s AI support
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity人工智能支持的简介
- en: As AI reshapes the gaming industry, understanding its integration within Unity
    is essential for developers. Unity’s robust suite of AI tools and features empowers
    developers to elevate their games with sophisticated AI. This section provides
    an overview of AI’s evolution in gaming, highlighting pivotal developments that
    have influenced gameplay, character behavior, and narratives. We will explore
    Unity’s AI tools, such as NavMesh for pathfinding, the Animator for controlling
    character states, and the **Machine Learning Agents Toolkit**, each designed to
    enhance AI-driven game elements. These functionalities not only streamline the
    implementation of complex AI tasks but also enhance the interactive dynamics of
    games, allowing developers to craft engaging and intelligent gameplay experiences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着人工智能重塑游戏产业，了解其在Unity中的集成对于开发者来说至关重要。Unity强大的AI工具和功能集赋予开发者使用复杂AI提升游戏的能力。本节概述了人工智能在游戏中的演变，突出了影响游戏玩法、角色行为和叙事的关键发展。我们将探讨Unity的AI工具，如用于路径查找的NavMesh、用于控制角色状态的Animator以及**机器学习代理工具包**，每个工具都旨在增强由AI驱动的游戏元素。这些功能不仅简化了复杂AI任务的实现，还增强了游戏的交互动态，使开发者能够制作出引人入胜且智能的游戏体验。
- en: We will also discuss how AI integration enhances gameplay, making it more dynamic
    and challenging, and emphasize AI’s crucial role in Unity’s game design and development.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论AI集成如何增强游戏玩法，使其更加动态和具有挑战性，并强调AI在Unity游戏设计和开发中的关键作用。
- en: Unity provides a comprehensive toolkit for AI development that facilitates the
    creation of sophisticated, responsive game environments. Here, we will explore
    some of the essential tools and features that Unity offers to game developers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为AI开发提供了一个全面的工具包，便于创建复杂的、响应式的游戏环境。在这里，我们将探讨Unity为游戏开发者提供的某些基本工具和功能。
- en: '**NavMesh**: NavMesh in Unity simplifies pathfinding by defining walkable areas
    and calculating efficient paths for characters. It’s essential for NPCs to navigate
    complex terrains, avoid obstacles, and optimize routes in real time. Integrated
    with Unity’s physics engine, NavMesh ensures both intelligent and realistic character
    movements.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavMesh**：Unity中的NavMesh通过定义可通行区域和计算角色的有效路径来简化路径查找。对于NPC在复杂地形中导航、避开障碍物和在实时中优化路线来说至关重要。与Unity的物理引擎集成，NavMesh确保了智能和逼真的角色移动。'
- en: '**Animator**: Unity’s Animator is vital for lifelike game experiences, using
    state machines to manage character animations based on gameplay dynamics. For
    example, characters transition between walking and running or standing and jumping
    in response to the game’s logic. This tool enables developers to create detailed
    animation flows, enhancing characters’ reactivity and dynamism.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Animator**：Unity的Animator对于逼真的游戏体验至关重要，它使用状态机根据游戏动态管理角色动画。例如，角色根据游戏逻辑在行走和跑步或站立和跳跃之间转换。这个工具使开发者能够创建详细的动画流程，增强角色的反应性和动态性。'
- en: '**ML-Agents**: Unity’s ML-Agents Toolkit is a groundbreaking feature that enables
    machine learning to boost game AI. It offers a framework to train intelligent
    agents within a game environment, using deep reinforcement learning or other methods.
    These agents learn and adapt over time, perfect for developing complex behaviors
    that improve with experience. This capability is invaluable for games that need
    NPCs to handle tasks too complex for traditional AI coding, such as adapting strategies
    based on player behavior.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ML-Agents**：Unity的ML-Agents Toolkit是一个开创性的功能，它使机器学习能够提升游戏AI。它提供了一个框架，在游戏环境中使用深度强化学习或其他方法训练智能代理。这些代理随着时间的推移学习和适应，非常适合开发随着经验增长而改进的复杂行为。这种能力对于需要NPC处理传统AI编码过于复杂的任务的游戏来说非常宝贵，例如根据玩家行为调整策略。'
- en: Together, these tools form a robust framework to implement advanced AI in Unity.
    By utilizing NavMesh for navigation, the Animator for animation control, and ML-Agents
    for adaptive behaviors, developers can create rich, immersive, and intelligent
    game experiences that push the boundaries of traditional gameplay.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具共同构成了一个稳健的框架，以在Unity中实现高级人工智能。通过利用NavMesh进行导航、Animator进行动画控制以及ML-Agents进行自适应行为，开发者可以创建丰富、沉浸式和智能的游戏体验，推动传统游戏界限。
- en: Unity’s AI toolkit enhances developers’ capabilities in creating advanced game
    experiences. With NavMesh for pathfinding, Animator for animations, and ML-Agents
    for complex behaviors, Unity elevates games. These tools streamline development
    and enrich gameplay with intelligent behaviors. As we discuss AI’s significance,
    we’ll explore how these tools contribute to dynamic gameplay, enhancing Unity
    projects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的人工智能工具增强了开发者创建高级游戏体验的能力。通过NavMesh进行路径查找、Animator进行动画以及ML-Agents进行复杂行为，Unity提升了游戏水平。这些工具简化了开发流程，并通过智能行为丰富了游戏体验。在我们讨论人工智能的重要性时，我们将探讨这些工具如何有助于动态游戏，增强Unity项目。
- en: Next, we will explore pathfinding’s importance in game development, discussing
    algorithms such as **A*** and NavMesh and their Unity implementations for intelligent
    enemy navigation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨路径查找在游戏开发中的重要性，讨论如**A***和NavMesh等算法及其在Unity中实现智能敌人导航的应用。
- en: Implementing pathfinding
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现路径查找
- en: Effective *pathfinding* is essential for allowing characters to move through
    game environments with intelligence and efficiency. This section explores various
    algorithms such as A*(which is a popular pathfinding algorithm) and NavMesh (which
    simplifies pathfinding by defining walkable areas and calculating paths within
    those areas), highlighting their Unity implementations, impacts on performance,
    and practical examples, such as constructing obstacle-avoiding enemy AI. By breaking
    down content into focused subsections, from basic principles to real-world applications,
    you will gain a theoretical understanding and practical skills for effective navigation
    solutions in Unity projects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的*路径查找*对于使角色能够以智能和高效的方式在游戏环境中移动至关重要。本节探讨了各种算法，如A*（这是一种流行的路径查找算法）和NavMesh（通过定义可通行区域并在这些区域内计算路径来简化路径查找），强调了它们的Unity实现、对性能的影响以及实际示例，例如构建避障敌人人工智能。通过将内容分解为从基本原理到实际应用的专注子部分，你将获得对Unity项目中有效导航解决方案的理论理解和实践技能。
- en: The basics of pathfinding algorithms
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径查找算法的基本原理
- en: Navigating complex environments in games relies heavily on robust pathfinding
    algorithms. It utilizes graphs to abstract game maps into nodes and edges, with
    algorithms such as A* and Dijkstra’s determining the most efficient routes. Known
    for maximum accuracy, Dijkstra’s algorithm calculates the shortest path from a
    start node to all other nodes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中导航复杂环境高度依赖于稳健的路径查找算法。它利用图将游戏地图抽象为节点和边，通过A*和迪杰斯特拉算法等确定最有效的路线。以最大精确度著称，迪杰斯特拉算法计算从起始节点到所有其他节点的最短路径。
- en: These algorithms are crucial for developing responsive AI that enhances gameplay
    by dynamically adapting to obstacles and changing conditions. This section will
    delve into the basics of these pathfinding algorithms and their critical role
    in game development.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法对于开发能够动态适应障碍和变化条件的响应式人工智能至关重要。本节将深入探讨这些路径查找算法的基本原理及其在游戏开发中的关键作用。
- en: NPCs rely on efficient pathfinding techniques to move seamlessly within game
    worlds, with the A* algorithm being popular for its balance between efficiency
    and accuracy. It dynamically adjusts to changes in terrain. Meanwhile, Dijkstra’s
    algorithm offers maximum accuracy but is slower for larger maps. Both algorithms
    enhance game AI, enabling more dynamic and realistic gameplay experiences.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 非玩家角色（NPC）依赖于高效的路径查找技术，在游戏世界中无缝移动，A*算法因其效率和精确度的平衡而受到青睐。它能够动态调整地形变化。同时，迪杰斯特拉算法提供最大精确度，但在大地图上速度较慢。这两种算法都增强了游戏人工智能，使游戏体验更加动态和真实。
- en: Algorithms such as A* and Dijkstra’s play a vital role in guiding characters
    through intricate game environments. These algorithms not only ensure realistic
    NPC behavior but also enhance gameplay by enabling smooth navigation. Unity supports
    pathfinding with tools such as NavMesh, simplifying walkable area creation and
    obstacle avoidance. The upcoming section will explore Unity’s pathfinding tools
    and practical steps to set up NavMesh, enhancing efficient pathfinding in Unity
    projects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，A*和迪杰斯特拉算法在引导角色穿越复杂的游戏环境中发挥着至关重要的作用。这些算法不仅确保了NPC行为的真实性，而且通过实现平滑的导航来增强游戏体验。Unity支持使用NavMesh等工具进行路径查找，简化了可通行区域的创建和障碍物规避。下一节将探讨Unity的路径查找工具和设置NavMesh的实用步骤，以增强Unity项目中高效的路径查找。
- en: Unity’s pathfinding tools – NavMesh and Beyond
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity的路径查找工具 – NavMesh及其他
- en: Unity’s NavMesh system simplifies pathfinding by managing spatial complexities,
    streamlining walkable area creation, and obstacle avoidance. This section will
    explore NavMesh specifics and other vital tools within the Unity ecosystem and
    third-party providers that aid pathfinding. Let’s start with the NavMesh system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的NavMesh系统通过管理空间复杂性、简化可通行区域的创建和障碍物规避来简化路径查找。本节将探讨NavMesh的具体细节以及Unity生态系统和第三方提供商中的其他重要工具，这些工具有助于路径查找。让我们从NavMesh系统开始。
- en: The Unity NavMesh Agent is a component used for pathfinding and navigation in
    game environments, allowing **NPCs** to intelligently navigate around obstacles
    and across different terrains. To utilize it, a **navigation mesh** (**NavMesh**)
    must be created within your scene to define walkable areas. You can assign a NavMesh
    Agent to an NPC by selecting the NPC in the Unity Editor, adding the NavMesh Agent
    component by clicking the **Add Component** button, and configuring properties
    such as speed and stopping distance to fit the NPC’s behavior. The agent’s destination
    can then be set dynamically via scripts, enabling the NPC to autonomously move
    toward targets efficiently.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的NavMesh代理是一个用于游戏环境中路径查找和导航的组件，允许**NPC**智能地绕过障碍物并在不同地形上导航。要使用它，必须在场景中创建一个**导航网格**（**NavMesh**）来定义可通行区域。你可以在Unity编辑器中选择NPC，通过点击**添加组件**按钮添加NavMesh代理组件，并配置如速度和停止距离等属性以适应NPC的行为。然后，可以通过脚本动态设置代理的目的地，使NPC能够高效地向目标自主移动。
- en: The Unity **Navigation** window is a specialized interface within the Unity
    Editor, designed to configure and manage navigation meshes, essential for AI pathfinding
    in game environments. It consists of four main panels – **Agents**, where you
    define the characteristics of different navigators such as radius, height, and
    walking speed; **Areas**, which allows you to assign costs to different surface
    types, influencing pathfinding decisions; **Bake**, used to generate the navigation
    mesh based on the scene geometry and agent settings; and **Objects**, which lets
    you specify which objects should be included or excluded from the NavMesh baking
    process. This structured approach simplifies the creation and management of complex
    navigation systems, making it easier to develop sophisticated AI behaviors that
    interact with the game world effectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**导航**窗口是Unity编辑器中的一个专用界面，用于配置和管理导航网格，这对于游戏环境中的AI路径查找至关重要。它由四个主要面板组成——**代理**，在这里你可以定义不同导航器的特征，如半径、高度和行走速度；**区域**，允许你为不同表面类型分配成本，影响路径查找决策；**烘焙**，用于根据场景几何和代理设置生成导航网格；以及**对象**，允许你指定哪些对象应包含或排除在NavMesh烘焙过程中。这种结构化方法简化了复杂导航系统的创建和管理，使得开发与游戏世界有效交互的复杂AI行为变得更加容易。
- en: 'Here’s what the **Navigation** window looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是**导航**窗口的样貌：
- en: '![Figure 10.1 – The Navigation window (NavMesh) with four panels – Agents,
    Areas, Bake, and Objects](img/B22128_10_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 带有四个面板的导航窗口（NavMesh）– 代理、区域、烘焙和对象](img/B22128_10_01.jpg)'
- en: Figure 10.1 – The Navigation window (NavMesh) with four panels – Agents, Areas,
    Bake, and Objects
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 带有四个面板的导航窗口（NavMesh）– 代理、区域、烘焙和对象
- en: With the NavMesh Agent attached to an NPC, you can adjust an individual NPC’s
    speed, acceleration, stopping distance, and so on. The NPC also has `Animator`,
    `Collider`, and `Rigidbody` components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将NavMesh代理附加到NPC，你可以调整单个NPC的速度、加速度、停止距离等。NPC还具有`Animator`、`Collider`和`Rigidbody`组件。
- en: '![Figure 10.2 – The NavMesh Agent attached to an NPC](img/B22128_10_2.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 附属于NPC的NavMesh代理](img/B22128_10_2.jpg)'
- en: Figure 10.2 – The NavMesh Agent attached to an NPC
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 附属于NPC的NavMesh代理
- en: Next, let’s take a look at a step-by-step guide to setting up a basic NavMesh
    in a Unity scene, ensuring smooth and intelligent character navigation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们一步一步地了解如何在 Unity 场景中设置基本的 NavMesh，以确保角色导航的流畅和智能。
- en: Setting up a basic NavMesh in a Unity scene
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Unity 场景中设置基本的 NavMesh
- en: Setting up a basic NavMesh in a Unity scene is a straightforward process that
    greatly enhances the navigational capabilities of your game characters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 场景中设置基本的 NavMesh 是一个简单的过程，可以大大增强游戏角色的导航能力。
- en: 'Here’s a step-by-step guide to help you configure NavMesh in your Unity project:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个逐步指南，帮助你配置 Unity 项目中的 NavMesh：
- en: '**Prepare** **your scene**:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备** **你的场景**：'
- en: Ensure your scene has a terrain or environment where you want your characters
    to navigate. This environment should have various obstacles and walkable areas
    clearly defined.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你的场景有一个你希望角色在其中导航的地形或环境。这个环境应该有各种障碍物和可通行区域清晰定义。
- en: '**Mark the** **navigation areas**:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记导航区域**：'
- en: Select the GameObjects that will act as walkable areas or obstacles in your
    scene.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的场景中将作为可通行区域或障碍物的 GameObject。
- en: 'Adjust the **Navigation Static**:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 **导航静态**：
- en: Go to the **Inspector** window with your GameObject selected.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 GameObject 后，转到 **Inspector** 窗口。
- en: Under the **Navigation** tab, click on the **Object** subsection (see *Figure
    10**.1*).
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Navigation** 选项卡下，点击 **Object** 子选项（见 *图 10**.1*）。
- en: Check the **Navigation Static** box for all objects that should be considered
    in the NavMesh generation. This tells Unity that these objects should be baked
    into the NavMesh.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有应在 NavMesh 生成中考虑的对象勾选 **导航静态** 复选框。这告诉 Unity 这些对象应被烘焙到 NavMesh 中。
- en: '**Create** **the NavMesh**:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建** **NavMesh**：'
- en: Open the **Navigation** window by going to **Window** | **AI** | **Navigation**.
    This opens up the **Navigation** pane.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到 **Window** | **AI** | **Navigation** 打开 **Navigation** 窗口。这打开 **Navigation**
    面板。
- en: 'Set the **navigation areas**:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 **导航区域**：
- en: In the **Navigation** window, go to the **Bake** tab (see *Figure 10**.1*).
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **导航** 窗口中，转到 **Bake** 选项卡（见 *图 10**.1*）。
- en: Here, you can adjust settings such as **Agent Radius**, **Agent Height**, and
    **Max Slope** to fit the navigation needs of your characters. These settings determine
    where the agents can walk, climb, or jump.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以调整如 **Agent 半径**、**Agent 高度** 和 **最大坡度** 等设置，以适应角色的导航需求。这些设置决定了代理可以行走、攀爬或跳跃的位置。
- en: Bake the NavMesh.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 烘焙 NavMesh。
- en: To do so, click the **Bake** button at the bottom of the **Navigation** window.
    Unity will calculate the NavMesh based on the settings and marked objects and
    overlay it on the scene, with a blue-tinted mesh indicating walkable areas.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请点击 **导航** 窗口底部的 **Bake** 按钮。Unity 将根据设置和标记的对象计算 NavMesh，并将其叠加到场景上，蓝色调的网格表示可通行区域。
- en: '`NavMesh Agent` component to the character or object that needs to navigate
    using the NavMesh. You can do this by selecting the character in your hierarchy
    and then going to **Inspector** | **Add Component** | **NavMesh Agent** (see *Figure
    10**.2*).'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `NavMesh Agent` 组件添加到需要使用 NavMesh 导航的角色或对象。你可以通过在层次结构中选择角色，然后转到 **Inspector**
    | **Add Component** | **NavMesh Agent**（见 *图 10**.2*）来实现。
- en: Configure the NavMesh Agent settings, such as speed, angular speed, and stopping
    distance, to determine how the character moves through the NavMesh.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 NavMesh 代理设置，如速度、角速度和停止距离，以确定角色如何通过 NavMesh 移动。
- en: '**Implement** **navigation logic**:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现** **导航逻辑**：'
- en: 'Write or attach a script to the NavMesh Agent to control how it seeks destinations.
    Here’s a simple example in C#:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为 NavMesh 代理编写或附加脚本以控制其寻找目的地的方式。以下是一个简单的 C# 示例：
- en: '[PRE0]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding script utilizes the `UnityEngine.AI` namespace to attach `NavMeshAgent`
    to `GameObject`, enabling it to dynamically navigate toward a designated `Transform
    target`, set in the Unity Editor, while intelligently avoiding obstacles using
    pathfinding on each frame update.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述脚本使用 `UnityEngine.AI` 命名空间将 `NavMeshAgent` 附加到 `GameObject`，使其能够动态地导航到在 Unity
    编辑器中设置的指定 `Transform target`，同时在每一帧更新时使用路径查找智能避开障碍物。
- en: '**Finalizing**:'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终化**：'
- en: Once everything is set up, enter **Play** mode in Unity to see your character
    automatically navigate around obstacles toward the target, using the shortest
    possible route calculated by the NavMesh.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一切设置完成后，在 Unity 中进入 **Play** 模式，可以看到你的角色会自动沿着 NavMesh 计算出的最短路径绕过障碍物向目标移动。
- en: Adjust the **Navigation** settings as required to refine paths and behaviors,
    based on your game’s design requirements.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你的游戏设计需求，调整 **导航** 设置以细化路径和行为。
- en: Unity’s NavMesh system simplifies game navigation by managing walkable areas
    and obstacle avoidance. This section explored NavMesh specifics and additional
    tools such as third-party plugins. Next, let’s take a look at some practical pathfinding
    examples that demonstrate real game scenarios, including enemy behavior scripting
    and performance considerations for different game types and scales.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的NavMesh系统通过管理可通行区域和避障来简化游戏导航。本节探讨了NavMesh的具体细节和额外的工具，如第三方插件。接下来，让我们看看一些实际的路径查找示例，这些示例展示了真实游戏场景，包括敌人行为脚本和不同游戏类型和规模的性能考虑。
- en: Practical pathfinding examples and performance considerations
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际的路径查找示例和性能考虑
- en: This section delves into practical pathfinding examples and key performance
    considerations in game development. Real-world applications, such as scripting
    enemy characters to intelligently chase players, are explored. We’ll also discuss
    how pathfinding methods impact game performance and offer optimization strategies
    for different game types, from open-world environments to those with dynamic obstacles.
    This practical insight empowers developers to refine AI navigation effectively,
    ensuring responsive gameplay.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了游戏开发中的实际路径查找示例和关键性能考虑。探讨了现实世界的应用，例如通过脚本智能追逐玩家的敌人角色。我们还将讨论路径查找方法如何影响游戏性能，并提供不同游戏类型（从开放世界环境到具有动态障碍物的环境）的优化策略。这种实用见解使开发者能够有效地优化AI导航，确保响应迅速的游戏体验。
- en: The NavMesh will appear in the **Scene** window as a shade of blue outline,
    indicating where NPCs are allowed to travel. Since the **Scene** window provides
    a 3D view from the camera, items closer to the camera will appear above the NavMesh.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: NavMesh将以蓝色轮廓的形式出现在**场景**窗口中，表示NPC可以旅行的区域。由于**场景**窗口提供了从摄像机视角的3D视图，因此靠近摄像机的项目将出现在NavMesh之上。
- en: '![Figure 10.3 – A Scene window of a car racing game that shows a NavMesh](img/B22128_10_3.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 一款赛车游戏的场景窗口，显示了NavMesh](img/B22128_10_3.jpg)'
- en: Figure 10.3 – A Scene window of a car racing game that shows a NavMesh
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 一款赛车游戏的场景窗口，显示了NavMesh
- en: Pathfinding is a cornerstone of character navigation in game development, enhancing
    realism and engagement. For example, scripting enemy characters to chase players
    dynamically showcases how AI can adapt. However, such implementations require
    careful consideration of performance, especially in resource-intensive scenarios
    such as large open-world games. Optimizing pathfinding, particularly with Unity’s
    NavMesh, involves balancing mesh accuracy with performance, simplifying agent
    paths, and efficiently managing NavMesh updates. These optimizations ensure fluid
    and responsive gameplay, even in complex environments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找是游戏开发中角色导航的基石，增强了真实感和参与感。例如，通过脚本动态追逐玩家的敌人角色展示了人工智能如何适应。然而，这种实现需要仔细考虑性能，尤其是在资源密集型场景中，如大型开放世界游戏。优化路径查找，特别是使用Unity的NavMesh，涉及到平衡网格精度与性能，简化代理路径，以及高效管理NavMesh更新。这些优化确保了即使在复杂环境中也能实现流畅和响应迅速的游戏体验。
- en: When implementing pathfinding, it is essential to balance precision with performance.
    Favoring lower precision in less critical areas can significantly improve performance
    without affecting a player’s experience. For instance, an AI villager in a bustling
    town can use lower precision pathfinding with broader waypoints if not in the
    player’s line of sight, reducing the system’s computational load. Conversely,
    higher precision is necessary for AI characters directly interacting with the
    player, such as a companion guiding them through a busy market, to navigate accurately
    and ensure an immersive experience. By applying different levels of precision
    based on AI’s role and visibility, developers can optimize performance while maintaining
    an engaging and realistic game world, ensuring critical interactions are detailed
    and background activities are efficient.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现路径查找时，平衡精度与性能至关重要。在不太关键的区域内优先考虑较低的精度可以显著提高性能，而不会影响玩家的体验。例如，在繁忙的城镇中，如果AI村民不在玩家的视线范围内，可以使用较低的精度路径查找和更宽的航点，从而减少系统的计算负载。相反，对于直接与玩家交互的AI角色，如引导玩家穿越繁忙市场的同伴，需要较高的精度以确保准确导航并确保沉浸式体验。通过根据AI的角色和可见性应用不同级别的精度，开发者可以在保持引人入胜和真实游戏世界的同时优化性能，确保关键交互详细，背景活动高效。
- en: 'Here are some scenarios in video games where you might use NavMesh:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，以下是一些你可能使用NavMesh的场景：
- en: '**Crowd movement in urban settings**: Demonstrate how NavMesh can be used to
    simulate realistic crowd dynamics in an urban environment. NPCs can navigate busy
    streets, avoid static and dynamic obstacles such as vehicles and other pedestrians,
    and follow complex routes.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**城市环境中的群体移动**：展示如何使用NavMesh在都市环境中模拟真实的群体动态。NPC可以在繁忙的街道上导航，避开静态和动态障碍物，如车辆和其他行人，并遵循复杂的路线。'
- en: '**Stealth game enemy patrols**: Show how enemies in a stealth game use NavMesh
    to patrol predefined paths. Additionally, illustrate how they dynamically alter
    their paths to investigate noises or sightings of the player, using the NavMesh
    to navigate around barriers and through doorways.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜行游戏中的敌人巡逻**：展示潜行游戏中的敌人如何使用NavMesh巡逻预定义的路径。此外，说明它们如何动态改变路径以调查噪音或玩家的发现，使用NavMesh在障碍物周围和通过门道导航。'
- en: '**Wildlife behavior in natural landscapes**: Use NavMesh to simulate animal
    movements in naturalistic settings, such as a forest. Animals can traverse the
    terrain, avoid natural obstacles such as rocks and trees, and pursue or flee from
    other creatures based on their AI behaviors.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自然景观中的野生动物行为**：使用NavMesh在自然环境中模拟动物的运动，例如森林。动物可以在地形中穿行，避开自然障碍物，如岩石和树木，并根据它们的AI行为追逐或逃离其他生物。'
- en: '**Dynamic battlefield navigation**: Provide an example of how military NPCs
    in a combat simulator use NavMesh for strategic movements. They can find cover,
    flank enemies, and navigate complex terrains such as ruined cities or rugged landscapes,
    adapting their paths as the environment changes due to the destruction.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态战场导航**：提供一个例子，说明军事NPC在战斗模拟器中使用NavMesh进行战略移动。他们可以找到掩护，包抄敌人，并在环境因破坏而变化时导航复杂的地面，如废墟城市或崎岖景观，并调整他们的路径。'
- en: '**A rescue robot simulation**: NavMesh can be used in a rescue scenario where
    autonomous robots must navigate debris-filled environments to locate and reach
    victims. Highlight how NavMesh helps in planning the most efficient routes, considering
    various obstacles.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**救援机器人模拟**：NavMesh可用于救援场景，其中自主机器人必须穿越充满杂物的环境以定位和到达受害者。强调NavMesh如何帮助规划最有效的路线，同时考虑各种障碍。'
- en: Building on the practical scenarios of NavMesh usage in different game environments,
    it’s crucial to also consider performance optimization strategies tailored to
    each scenario. For expansive, open-world games, optimizing NavMesh involves segmenting
    a map into manageable zones and updating the NavMesh dynamically around the player’s
    vicinity, which conserves system resources. In games with densely packed interactive
    scenes and dynamic obstacles, a layered NavMesh approach or a simplified collision
    model for minor obstacles can significantly reduce computational demands. By adjusting
    pathfinding precision based on gameplay importance – favoring lower precision
    in less critical areas – you can optimize performance without compromising gameplay
    quality. These targeted strategies ensure that NavMesh operates efficiently, enhancing
    both the player experience and overall game performance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于不同游戏环境中NavMesh使用的实际场景，考虑针对每个场景定制的性能优化策略同样至关重要。对于广阔的开放世界游戏，优化NavMesh涉及将地图分割成可管理的区域，并在玩家周围动态更新NavMesh，从而节省系统资源。在密集交互场景和动态障碍物游戏中，采用分层NavMesh方法或为小障碍物简化碰撞模型可以显著降低计算需求。通过根据游戏重要性调整路径查找精度——在不太关键的区域优先使用较低的精度——可以在不牺牲游戏质量的情况下优化性能。这些有针对性的策略确保NavMesh高效运行，从而提升玩家体验和整体游戏性能。
- en: In this section, we’ve explored practical pathfinding techniques, showcasing
    examples such as enemy characters dynamically chasing players, and demonstrated
    AI’s ability to navigate complex environments while avoiding obstacles. We also
    discussed the performance implications of various pathfinding strategies and offered
    optimization tips for different game types, such as enhancing NavMesh efficiency
    in large, open-world settings or managing dynamic obstacles in densely interactive
    scenes. These insights are crucial for maintaining optimal game performance and
    realism.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了实用的路径查找技术，展示了例如敌人角色动态追逐玩家的例子，并展示了AI在避开障碍物的同时导航复杂环境的能力。我们还讨论了各种路径查找策略的性能影响，并为不同类型的游戏提供了优化建议，例如在大型开放世界设置中增强NavMesh效率或在密集交互场景中管理动态障碍。这些见解对于保持最佳游戏性能和真实感至关重要。
- en: Next, we’ll delve into AI decision-making processes, examining how techniques
    such as **finite state machines** (**FSMs**), Behavior Trees, and utility-based
    systems can be leveraged within Unity to empower NPCs with intelligent decision-making
    abilities, based on game states. This upcoming section will provide practical
    insights and example implementations to help craft sophisticated decision-making
    systems, bringing NPC interactions to life in games.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨AI决策过程，研究如何利用**有限状态机**（FSM）、行为树和基于效用系统等技术，在Unity中赋予NPC基于游戏状态智能决策的能力。本节将提供实用见解和示例实现，帮助构建复杂的决策系统，使NPC在游戏中的交互生动起来。
- en: AI decision making
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI决策
- en: As we venture deeper into AI in Unity, NPC decision-making becomes pivotal for
    crafting immersive gameplay. This section explores fundamental AI decision-making
    frameworks such as FSMs, Behavior Trees, and utility-based systems. These are
    advanced topics that can be challenging to grasp on the first read. We encourage
    you to take your time and read carefully to comprehend them. Each approach structures
    NPC behavior in response to game states, enhancing interaction dynamism and realism.
    With a practical focus on Unity implementation, we provide detailed insights and
    examples to develop robust NPC decision-making systems. This guidance empowers
    developers to create sophisticated AI that adapts intelligently to player actions,
    enriching game characters’ lifelike qualities and engagement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步探索Unity中的AI，NPC的决策对于制作沉浸式游戏玩法变得至关重要。本节探讨了基本的AI决策框架，如FSM、行为树和基于效用系统。这些是可能在一开始阅读时难以掌握的高级主题。我们鼓励您花时间仔细阅读，以理解它们。每种方法都根据游戏状态结构化NPC的行为，增强交互动态性和真实性。我们以Unity实现为重点，提供详细见解和示例，以开发健壮的NPC决策系统。此指导使开发者能够创建能够智能适应玩家行为的复杂AI，丰富游戏角色的逼真品质和参与度。
- en: An introduction to AI decision-making frameworks
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI决策框架简介
- en: In game development, NPC intelligence relies heavily on decision-making. This
    introduction to AI frameworks explores key models such as FSMs, **Behavior Trees**,
    and **utility-based systems**. Each model offers unique approaches to NPC behavior,
    from the structured simplicity of FSMs to the flexible hierarchies of Behavior
    Trees and dynamic prioritization of utility-based systems. Understanding these
    frameworks enables developers to manage complex AI behaviors effectively, enhancing
    realism and interactivity in Unity environments.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，NPC的智能很大程度上依赖于决策。本节介绍了AI框架，如FSM、**行为树**和**基于效用系统**等关键模型。每个模型都提供了独特的NPC行为方法，从FSM的结构化简单性到行为树的灵活层次结构和基于效用系统的动态优先级。理解这些框架使开发者能够有效地管理复杂的AI行为，增强Unity环境中的真实感和交互性。
- en: AI decision-making is pivotal for dynamic gameplay, with frameworks such as
    FSMs offering straightforward solutions. FSMs are ideal for managing simple scenarios,
    featuring limited states, transitions, and actions. For instance, an enemy character
    can use an FSM to cycle between patrolling, chasing, and attacking based on specific
    triggers or conditions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AI决策对于动态游戏玩法至关重要，FSM（有限状态机）等框架提供了直接的解决方案。FSM非常适合管理简单场景，具有有限的状态、转换和动作。例如，一个敌人角色可以使用FSM根据特定的触发器或条件在巡逻、追逐和攻击之间循环。
- en: '*Figure 10**.4* depicts a simple flowchart showing decision-making. The character
    stays on patrol most of the time. Periodically, the character will take a rest.
    If the character detects the player, it will chase them.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.4* 展示了一个简单的决策流程图。角色大部分时间都在巡逻。偶尔，角色会休息一下。如果角色检测到玩家，它将追逐他们。'
- en: '![Figure 10.4 – A simple flowchart showing decision-making](img/B22128_10_4.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 一个简单的决策流程图](img/B22128_10_4.jpg)'
- en: Figure 10.4 – A simple flowchart showing decision-making
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 一个简单的决策流程图
- en: Behavior Trees offer a modular and hierarchical approach to AI decision-making,
    featuring a root node branching into internal nodes (decisions) and leaf nodes
    (actions). This structure breaks down tasks into manageable subtasks, allowing
    for complex decision processes. Behavior Trees excel in games where NPCs must
    adapt to various game states, such as adjusting tactics in response to player
    movements. Their hierarchical design also facilitates maintenance and scalability,
    beneficial for games with complex AI needs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树为AI决策提供了一个模块化和层次化的方法，其根节点分支到内部节点（决策）和叶节点（动作）。这种结构将任务分解为可管理的子任务，允许复杂的决策过程。行为树在NPC必须适应各种游戏状态的游戏中表现出色，例如根据玩家动作调整策略。其层次化设计也便于维护和可扩展性，对具有复杂AI需求的游戏有益。
- en: '![Figure 10.5 – A complex Behavior Tree with multiple options, each with more
    options. Note that the same action, Attack, can be triggered in multiple ways.](img/B22128_10_5.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 一个具有多个选项的复杂行为树，每个选项都有更多选项。注意，相同的动作“攻击”可以通过多种方式触发。](img/B22128_10_5.jpg)'
- en: Figure 10.5 – A complex Behavior Tree with multiple options, each with more
    options. Note that the same action, Attack, can be triggered in multiple ways.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 一个具有多个选项的复杂行为树，每个选项都有更多选项。注意，相同的动作“攻击”可以通过多种方式触发。
- en: Utility-based systems evaluate decisions based on the utility, or value, associated
    with potential outcomes, enabling NPCs to select the most advantageous action
    dynamically. This approach is effective in unpredictable or competitive environments,
    allowing for nuanced and adaptable AI behaviors. For example, in strategy games,
    utility-based systems empower AI opponents to make strategic decisions that balance
    risk and reward, such as choosing to attack, defend, or retreat based on opposing
    forces’ strength and the probability of success.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 基于效用系统的AI会根据与潜在结果关联的效用或价值来评估决策，使非玩家角色（NPCs）能够动态选择最有利的行为。这种方法在不可预测或竞争环境中非常有效，允许AI行为具有细微和适应性。例如，在策略游戏中，基于效用系统的AI对手能够做出平衡风险和回报的战略决策，如根据敌方力量的强弱和成功的概率选择攻击、防御或撤退。
- en: Each framework – FSMs for simpler decision trees, Behavior Trees for granular
    control and scalability, and utility-based systems for adaptive decision-making
    – offers unique strengths and ideal use cases. Mastering their application within
    Unity can significantly enrich NPC behaviors in games, fostering a rich and immersive
    gaming experience that captivates players and immerses them in the game world.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框架——FSMs用于简单的决策树，行为树用于细粒度控制和可扩展性，基于效用系统用于适应性决策——都提供了独特的优势和使用案例。掌握它们在Unity中的应用可以显著丰富游戏中的NPC行为，培养一个丰富和沉浸式的游戏体验，吸引玩家并使他们沉浸在游戏世界中。
- en: The landscape of AI decision-making in video games is diverse, with frameworks
    such as FSMs, Behavior Trees, and utility-based systems offering structured approaches
    for AI. FSMs are straightforward and ideal for simpler decision paths, while Behavior
    Trees provide flexibility and scalability for more complex scenarios. Utility-based
    systems dynamically adapt AI actions based on their calculated benefit, suiting
    unpredictable game conditions. Understanding these frameworks sets the stage for
    practical application within Unity, where detailed guides and examples will be
    provided. This upcoming section will include code snippets and pseudocode, demonstrating
    AI’s dynamic decision-making to enhance game character interactivity and realism.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏中的AI决策领域丰富多彩，拥有诸如有限状态机（FSMs）、行为树和行为基于的系统等框架，为AI提供了结构化的方法。FSMs结构简单，非常适合简单的决策路径，而行为树则提供了灵活性和可扩展性，适用于更复杂的场景。基于效用系统的AI行为会根据其计算出的效益动态调整，以适应不可预测的游戏条件。理解这些框架为在Unity中实际应用奠定了基础，其中将提供详细的指南和示例。即将到来的部分将包括代码片段和伪代码，展示AI的动态决策，以增强游戏角色的交互性和真实性。
- en: Implementing decision-making models in Unity
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unity中实现决策模型
- en: This section delves into implementing AI decision-making frameworks within Unity.
    We’ll explore integrating FSMs, Behavior Trees, and utility systems into Unity
    projects, detailing available tools and assets. For FSMs, we’ll use Unity’s Animator
    for state management, while for Behavior Trees and utility systems, external assets
    will enhance functionality. Code snippets and pseudocode examples will illustrate
    scripting complex AI behaviors, such as enemies dynamically reacting to player
    actions. This hands-on guide enhances understanding of AI development in Unity.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了在Unity中实现AI决策框架。我们将探讨将有限状态机（FSMs）、行为树和效用系统集成到Unity项目中，详细说明可用的工具和资源。对于FSMs，我们将使用Unity的Animator进行状态管理，而对于行为树和效用系统，外部资源将增强功能。代码片段和伪代码示例将展示如何编写复杂的AI行为脚本，例如敌人根据玩家的动作动态反应。本实践指南增强了Unity中AI开发的了解。
- en: 'Implementing AI decision-making frameworks within Unity allows for more dynamic
    and responsive game characters. Each decision-making model has its strengths and
    is suited for particular types of gameplay challenges. Here’s how you can set
    up and utilize FSMs, Behavior Trees, and utility systems in Unity:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中实现AI决策框架允许创建更动态和响应的游戏角色。每种决策模型都有其优点，适用于特定类型的游戏挑战。以下是你在Unity中设置和使用FSMs、行为树和效用系统的步骤：
- en: '`Patrol`, `Chase`, `Attack`, and `Retreat`. You can set up each of these states
    in the Animator and use triggers or conditions to transition between them, based
    on gameplay variables such as the player’s proximity or the enemy’s health. The
    following script would be placed on an enemy NPC. When the enemy detects the player,
    it begins to behave differently:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`巡逻`、`追击`、`攻击`和`撤退`。你可以在Animator中设置每个状态，并使用触发器或条件根据游戏变量（如玩家的接近度或敌人的健康值）在它们之间进行转换。以下脚本将放置在敌人NPC上。当敌人探测到玩家时，它开始表现出不同的行为：'
- en: '[PRE1]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `EnemyController` script in Unity adjusts an NPC’s behavior based on the
    player’s proximity. It initializes by fetching the `Animator` component and locating
    the player’s `Transform`. During each frame, it calculates the distance to the
    player. If within 10 units, it triggers the `"Chase"` animation; otherwise, it
    activates the `"Patrol"` animation. This setup dynamically shifts the NPC between
    chasing and patrolling, enhancing gameplay interaction.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Unity中的`EnemyController`脚本根据玩家的接近度调整NPC的行为。它通过获取`Animator`组件和定位玩家的`Transform`来初始化。在每一帧中，它计算与玩家的距离。如果距离在10单位内，它触发`"Chase"`动画；否则，它激活`"Patrol"`动画。这种设置使NPC在追逐和巡逻之间动态转换，增强游戏互动。
- en: '`behavior trees` allow for creating more granular and hierarchical decision
    structures. While Unity does not have native support for Behavior Trees, several
    third-party tools and assets are available to integrate them. These Behavior Trees
    can be set up to check conditions and execute the appropriate actions, such as
    seeking cover when health is low or pursuing the player when detected. The following
    pseudocode outlines a simple behavior tree node, `AttackOrRetreatNode`, which
    decides whether an NPC should attack or retreat, based on its visibility of the
    player and their health status:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行为树`允许创建更细粒度和层次化的决策结构。虽然Unity没有原生支持行为树，但有一些第三方工具和资源可供集成。这些行为树可以设置来检查条件并执行适当的行为，例如在健康值低时寻找掩护或被探测到时追击玩家。以下伪代码概述了一个简单的行为树节点，`AttackOrRetreatNode`，它根据NPC对玩家的可见性和其健康状况来决定NPC是攻击还是撤退：'
- en: '[PRE2]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`AttackOrRetreatNode` in the pseudocode serves as a decision-making node within
    a Behavior Tree, evaluating whether an NPC can see the player and has enough health.
    If both conditions are met, the NPC attacks; otherwise, it retreats. This logic
    enables NPCs to dynamically respond to their environment, enhancing game realism.'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 伪代码中的`AttackOrRetreatNode`作为行为树中的决策节点，评估NPC是否可以看到玩家并且有足够的健康值。如果两个条件都满足，NPC就会攻击；否则，它就会撤退。这种逻辑使NPC能够动态地对其环境做出反应，增强游戏的真实感。
- en: '`UtilityDecider`, demonstrates a utility-based decision-making system where
    an NPC chooses between attacking, defending, or using a special ability, based
    on the highest utility value:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UtilityDecider`演示了一个基于效用的决策系统，其中NPC根据最高的效用值在攻击、防御或使用特殊能力之间进行选择：'
- en: '[PRE3]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `UtilityDecider` class in the provided code utilizes a utility-based AI
    decision-making framework to determine the best action for an NPC in a game. It
    maintains three utility values, representing the desirability of attacking, defending,
    and using a special ability. Within the `DecideAction` method, it calculates which
    of these actions has the highest utility at a given the moment by comparing the
    three utility values. The NPC then executes the action with the highest utility
    – if `attackUtility` is highest, it performs an attack; if `defendUtility` is
    highest, it defends; and if `specialAbilityUtility` is highest, it uses a special
    ability. This approach allows for dynamic and context-sensitive NPC behavior in
    response to varying game situations.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供的代码中的`UtilityDecider`类利用基于效用的AI决策框架来确定游戏中NPC的最佳行动。它维护三个效用值，分别代表攻击、防御和使用特殊能力的吸引力。在`DecideAction`方法中，它通过比较这三个效用值来计算在特定时刻哪个行动的效用最高。然后NPC执行效用最高的行动——如果`attackUtility`最高，它执行攻击；如果`defendUtility`最高，它进行防御；如果`specialAbilityUtility`最高，它使用特殊能力。这种方法允许NPC根据不同的游戏情况动态和情境敏感地做出反应。
- en: Each of these scripts provides a foundational approach to integrating complex
    AI behaviors in Unity, enabling your game characters to make decisions dynamically
    and intelligently. By leveraging FSMs, Behavior Trees, or utility systems, you
    can significantly enhance the interactivity and depth of your game’s NPCs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些脚本都提供了一个将复杂AI行为集成到Unity中的基础方法，使你的游戏角色能够动态和智能地做出决策。通过利用FSM、行为树或效用系统，你可以显著增强游戏NPC的交互性和深度。
- en: In this section, we explored implementing various AI decision-making frameworks
    in Unity, detailing the effective use of FSMs, Behavior Trees, and utility systems.
    FSMs, integrated via Unity’s Animator, offer straightforward state transitions,
    while Behavior Trees and utility systems provide nuanced control, utilizing external
    assets and complex logic for dynamic responses. Through code snippets, we demonstrated
    how an enemy character could decide actions based on player input, showcasing
    the systems’ flexibility.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了在Unity中实现各种AI决策框架，详细介绍了有限状态机（FSM）、行为树和行为系统的高效使用。通过Unity的Animator集成的FSM提供简单的状态转换，而行为树和行为系统则提供细致的控制，利用外部资源和复杂逻辑来实现动态响应。通过代码片段，我们展示了敌人角色如何根据玩家输入决定行动，展示了系统的灵活性。
- en: Next, we’ll discuss the best practices and optimization for designing and implementing
    these AI systems in Unity, ensuring scalability, performance, and efficient decision-making
    processes, while avoiding common pitfalls.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论在Unity中设计和实现这些AI系统的最佳实践和优化，确保可扩展性、性能和高效的决策过程，同时避免常见陷阱。
- en: The best practices and optimization strategies for designing and implementing
    AI in Unity
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计和实现Unity中AI的最佳实践和优化策略
- en: As we conclude our exploration of AI decision-making in Unity, it’s crucial
    to focus on the best practices and optimization strategies for efficient and effective
    AI systems. This section will delve into essential techniques to design maintainable,
    scalable, and high-performing AI systems across gaming platforms. We’ll discuss
    balancing decision-making complexity with game performance and provide practical
    tips to streamline AI behaviors. Additionally, we’ll identify common pitfalls
    in AI development and offer guidance to enhance gameplay. Adhering to these best
    practices equips developers to create robust, responsive AI systems that elevate
    the gaming experience.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束对Unity中AI决策的探索，关注高效和有效的AI系统的最佳实践和优化策略至关重要。本节将深入探讨设计可维护、可扩展和性能优异的AI系统所需的基本技术。我们将讨论平衡决策复杂性与游戏性能，并提供简化AI行为的实用技巧。此外，我们将识别AI开发中的常见陷阱，并提供提高游戏体验的指导。遵循这些最佳实践使开发者能够创建强大、响应迅速的AI系统，从而提升游戏体验。
- en: When designing AI decision-making systems in Unity, adhering to best practices
    is crucial for creating scalable and maintainable AI systems that enhance gameplay
    without sacrificing performance. Modular design – that is, structuring AI components
    for easy adjustment and expansion as game complexity grows – is fundamental. This
    approach simplifies updates and debugging and ensures that AI systems can scale
    as game environments become more intricate.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中设计人工智能决策系统时，遵循最佳实践对于创建可扩展和可维护的人工智能系统至关重要，这些系统能够增强游戏体验而不牺牲性能。模块化设计——即根据游戏复杂性的增长对AI组件进行结构化，以便于调整和扩展——是基础。这种方法简化了更新和调试，并确保人工智能系统可以随着游戏环境的变得更加复杂而扩展。
- en: 'For example, consider encapsulating decision-making logic within separate scripts
    that communicate via well-defined interfaces. This not only makes your AI easier
    to manage but also more adaptable to changes in game design. Here’s a snippet
    demonstrating this principle:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑将决策逻辑封装在独立的脚本中，并通过定义良好的接口进行通信。这不仅使你的AI更容易管理，而且更能适应游戏设计的变更。以下是一个展示这一原则的代码片段：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Balancing complexity with performance is another critical area. Utilizing Unity’s
    Profiler tool can help identify performance bottlenecks within AI routines. For
    instance, pathfinding calculations might be optimized by reducing the frequency
    of the path updates or simplifying the NavMesh:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂性和性能之间取得平衡是另一个关键领域。使用Unity的Profiler工具可以帮助识别人工智能例程中的性能瓶颈。例如，可以通过减少路径更新的频率或简化NavMesh来优化路径计算：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding snippet reduces the frequency of path recalculations, thus balancing
    the need for accurate, responsive AI navigation with the necessity of maintaining
    high game performance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段减少了路径重新计算的频率，从而在精确、响应性的人工智能导航需求与保持高游戏性能的必要性之间取得平衡。
- en: 'Lastly, a common pitfall in AI design is overloading AI with too many decisions
    or checks each frame, which can lead to performance issues. Implementing decision
    throttling or spreading decisions over multiple frames can mitigate this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，人工智能设计中一个常见的陷阱是每帧给AI加载过多的决策或检查，这可能导致性能问题。实施决策节流或将决策分散到多个帧中可以减轻这一问题：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Decision throttling in AI ensures that decisions are made at a manageable rate,
    balancing the need for timely responses with the conservation of computing resources.
    This strategy prevents performance degradation during complex decision-making
    processes. Such a technique can significantly enhance both the performance and
    quality of AI in Unity-based games, and they highlight the importance of thoughtful
    design and optimization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能中实施决策节流确保决策以可管理的速率进行，平衡及时响应的需求与计算资源的节约。这种策略可以防止在复杂的决策过程中性能下降。这种技术可以显著提高基于Unity的游戏中人工智能的性能和质量，并强调了深思熟虑的设计和优化的重要性。
- en: In this section, we’ve explored the best practices and strategies for designing
    and implementing AI decision-making systems in Unity, which are effective and
    efficient. Key to these processes is ensuring maintainable and scalable AI behaviors
    by structuring components modularly and using interfaces for manageability. We
    also emphasized the critical balance between complexity and performance, introducing
    techniques such as decision throttling to optimize AI responsiveness without compromising
    gameplay quality. Common pitfalls, such as overloading AI with excessive computations
    each frame, were discussed, with solutions provided to help developers avoid these
    traps and ensure smooth AI systems.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了在Unity中设计和实现人工智能决策系统的最佳实践和策略，这些策略既有效又高效。这些过程的关键是确保通过模块化结构组件和使用接口进行管理，以构建可维护和可扩展的人工智能行为。我们还强调了复杂性和性能之间的关键平衡，引入了如决策节流等技术来优化人工智能的响应性，同时不损害游戏质量。讨论了常见的陷阱，例如每帧给AI加载过多的计算，并提供了解决方案，以帮助开发者避免这些陷阱并确保人工智能系统的流畅运行。
- en: Moving forward, the next section will build upon these topics. We’ll explore
    creating complex behaviors using advanced AI techniques, such as Behavior Trees
    and machine learning, while maintaining the balance of complexity and performance
    to enhance the gaming experience with realistic NPCs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进的过程中，下一节将基于这些主题进行扩展。我们将探讨如何使用高级人工智能技术，如行为树和机器学习，来创建复杂的行为，同时保持复杂性和性能之间的平衡，以增强具有真实NPC的游戏体验。
- en: Behavioral AI for NPCs
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC的行为人工智能
- en: In this final section, we will explore advanced techniques to craft engaging
    NPC behaviors in Unity. Building on our earlier fundamental knowledge, we’ll delve
    into Behavior Trees and machine learning for dynamic NPC behaviors. We’ll also
    discuss balancing AI complexity with game performance, ensuring that these behaviors
    enhance the gaming experience. This section aims to provide insights into creating
    intelligent NPC behaviors that enrich the game environment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我们将探讨在 Unity 中制作引人入胜的 NPC 行为的高级技术。在之前的基本知识基础上，我们将深入研究行为树和机器学习以实现动态
    NPC 行为。我们还将讨论平衡 AI 复杂性与游戏性能，确保这些行为能够增强游戏体验。本节旨在提供创建智能 NPC 行为以丰富游戏环境的见解。
- en: Developing complex behaviors with Behavior Trees
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用行为树开发复杂行为
- en: In this section, we will explore Behavior Trees, a powerful tool for structuring
    NPC behaviors in Unity. Behavior Trees organize decision-making into a hierarchy
    of nodes, offering clarity and flexibility. We’ll demonstrate their practical
    application by designing a Behavior Tree for a patrol guard character, showcasing
    states such as patrolling and investigating noises. This illustrates how Behavior
    Trees enable sophisticated and adaptive NPC behavior in game development.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨行为树，这是在 Unity 中结构化 NPC 行为的强大工具。行为树将决策组织成一个节点的层次结构，提供清晰性和灵活性。我们将通过设计一个用于巡逻守卫角色的行为树来展示其实际应用，展示如巡逻和调查噪音等状态。这说明了行为树如何使游戏开发中的
    NPC 行为变得复杂和自适应。
- en: Behavior Trees are essential for creating nuanced AI behaviors in games. They’re
    structured such as flowcharts, with nodes representing decisions or actions. Components
    include nodes containing tasks or conditions, terminal leaves executing actions,
    and branches controlling flow based on criteria.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树对于在游戏中创建细微的 AI 行为至关重要。它们的结构类似于流程图，节点代表决策或行动。组件包括包含任务或条件的节点、执行行动的终端叶子和基于标准的分支来控制流程。
- en: An example Behavior Tree for a patrol guard could feature a root node branching
    into leaves, such as `Patrol`, `Chase`, and `Investigate`. The `Patrol` leave
    loops a route, `Chase` activates upon player detection, and `Investigate` triggers
    on hearing or seeing disturbances.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个巡逻守卫的示例行为树可能包括一个根节点分支到叶子节点，例如 `Patrol`（巡逻）、`Chase`（追击）和 `Investigate`（调查）。`Patrol`
    叶子节点循环一条路线，`Chase` 在检测到玩家时激活，而 `Investigate` 在听到或看到干扰时触发。
- en: 'Here’s a simple example in C#, using pseudocode to illustrate how a patrol
    guard might use a Behavior Tree to decide its actions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的 C# 示例，使用伪代码来说明一个巡逻守卫如何使用行为树来决定其行动：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, `SelectorNode` acts as a decision hub that selects which
    action to take based on the guard’s situation – whether to continue patrolling,
    chase a player, or investigate a noise. Each action is a sequence of tasks, such
    as checking whether the guard can see the player or whether there is a noise to
    investigate, followed by the corresponding response action.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`SelectorNode` 作为决策中心，根据守卫的情况选择采取哪种行动——是继续巡逻、追击玩家还是调查噪音。每个行动都是一个任务序列，例如检查守卫是否可以看到玩家或是否有噪音需要调查，然后是相应的响应行动。
- en: Behavior Trees offer a modular approach, simplifying complex decision-making
    and enabling flexibility for behavior additions or modifications. This structured
    framework facilitates the development of dynamic AI characters, enhancing gameplay
    engagement and unpredictability. Leveraging Behavior Trees ensures diverse and
    contextually appropriate NPC actions, enriching the gaming experience.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树提供了一种模块化方法，简化了复杂的决策，并使行为添加或修改具有灵活性。这种结构化框架促进了动态 AI 角色的开发，增强了游戏参与度和不可预测性。利用行为树确保了多样化和情境适当的
    NPC 行动，丰富了游戏体验。
- en: Behavior Trees provide a modular framework to construct dynamic NPC behaviors
    in games, organizing actions into nodes, leaves, and branches. This structure
    enables developers to define a range of behaviors, from basic patrolling to complex
    reactions such as chasing or investigating disturbances, in an organized and scalable
    system. For instance, a patrol guard’s Behavior Tree could manage states such
    as patrolling, chasing a player, and investigating noises efficiently.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树为在游戏中构建动态 NPC 行为提供了一个模块化框架，将行动组织成节点、叶子和分支。这种结构使开发者能够在有组织且可扩展的系统中定义一系列行为，从基本的巡逻到复杂的反应，如追击或调查干扰。例如，巡逻守卫的行为树可以有效地管理巡逻、追击玩家和调查噪音等状态。
- en: As we progress, we’ll explore advanced AI techniques such as machine learning
    and procedural content generation, leveraging tools such as Unity’s ML-Agents.
    These methods enable NPCs to learn and adapt behaviors, enhancing realism and
    responsiveness based on player interactions. We’ll discuss integrating these techniques
    into existing AI frameworks and managing added complexity within Unity for optimal
    performance and gameplay.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断前进，我们将探索高级人工智能技术，例如机器学习和程序化内容生成，利用Unity的ML-Agents等工具。这些方法使非玩家角色（NPC）能够学习和适应行为，根据玩家的互动增强真实感和响应性。我们将讨论将这些技术集成到现有的AI框架中，并在Unity中管理增加的复杂性，以实现最佳性能和游戏体验。
- en: Incorporating advanced AI techniques
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合高级人工智能技术
- en: As we delve into advanced game AI, integrating techniques such as machine learning
    and procedural content generation becomes crucial for dynamic NPC behaviors. This
    section explores Unity’s ML-Agents Toolkit, enabling NPCs to evolve based on player
    interactions. We’ll discuss integrating these techniques within Unity, enhancing
    gameplay while managing complexities for a seamless experience.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入研究高级游戏AI，集成机器学习和程序化内容生成等技术对于动态NPC行为变得至关重要。本节探讨了Unity的ML-Agents工具包，它使NPC能够根据玩家的互动进化。我们将讨论在Unity中集成这些技术，同时管理复杂性以实现无缝体验。
- en: The integration of advanced AI techniques, such as machine learning and procedural
    content generation, revolutionizes NPC behaviors. Unity’s ML-Agents toolkit enables
    NPCs to learn and adapt from player actions, enhancing realism and dynamism in
    interactions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 高级人工智能技术，如机器学习和程序化内容生成，的集成，彻底改变了NPC的行为。Unity的ML-Agents工具包使NPC能够根据玩家的动作学习和适应，增强交互的真实性和动态性。
- en: 'For example, by using Unity’s ML-Agents, developers can train an NPC to optimize
    its strategies in complex game environments. This is achieved by setting up an
    environment within Unity where an agent can perform actions, receive feedback
    in terms of rewards, and adjust its strategies accordingly. The following is a
    simplified example of setting up a training scenario using C# in Unity:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过使用Unity的ML-Agents，开发者可以训练一个NPC在复杂游戏环境中优化其策略。这是通过在Unity中设置一个环境来实现的，其中代理可以执行动作，根据奖励接收反馈，并相应地调整其策略。以下是在Unity中使用C#设置训练场景的简化示例：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code snippet outlines a basic agent setup where the NPC can learn
    from its actions within the game environment. `OnEpisodeBegin` is used to reset
    the NPC’s state at the beginning of each learning episode, `CollectObservations`
    to gather data from the environment, `OnActionReceived` to receive and execute
    actions, and `Heuristic` to provide manual overrides if necessary.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段概述了一个基本代理设置，其中NPC可以在游戏环境中从其动作中学习。`OnEpisodeBegin`用于在每个学习阶段开始时重置NPC的状态，`CollectObservations`用于从环境中收集数据，`OnActionReceived`用于接收和执行动作，以及`Heuristic`在必要时提供手动覆盖。
- en: Procedural content generation is another technique that complements machine
    learning, by dynamically creating game content based on a game’s state or player’s
    actions, which can further enhance the gaming experience. This approach can generate
    endless variations in game environments, ensuring that NPCs continually face new
    challenges and scenarios, promoting even more profound learning and adaptability.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化内容生成是另一种补充机器学习的技术，它根据游戏状态或玩家的动作动态创建游戏内容，这可以进一步增强游戏体验。这种方法可以在游戏环境中生成无限的变化，确保NPC不断面临新的挑战和场景，促进更深入的学习和适应性。
- en: While beneficial, these techniques add complexity to game development, necessitating
    a robust architecture and grasp of machine learning principles. Monitoring performance
    impacts, such as computational costs and training processes, is crucial, with
    optimizations such as adjusting learning rates or neural network complexity. Unity’s
    profiling tools help identify performance bottlenecks, ensuring smooth gameplay
    despite advanced AI integration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些技术有益，但它们增加了游戏开发的复杂性，需要强大的架构和对机器学习原理的掌握。监控性能影响，如计算成本和训练过程，至关重要，例如调整学习率或神经网络复杂性的优化。Unity的剖析工具有助于识别性能瓶颈，确保即使在高级AI集成的情况下也能实现流畅的游戏体验。
- en: Through thoughtful implementation and ongoing optimization, these advanced AI
    techniques can significantly elevate the capabilities of NPCs, making them more
    responsive and engaging for players, thereby deeply enriching the overall gameplay
    experience.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深思熟虑的实施和持续的优化，这些先进的AI技术可以显著提升NPC的能力，使他们更加响应和吸引玩家，从而极大地丰富整体游戏体验。
- en: In this section, we explored integrating advanced AI techniques such as machine
    learning and procedural content generation to enrich NPC behaviors in Unity. Using
    Unity’s ML-Agents toolkit, we discussed training NPCs to improve their responses
    to player interactions over time. While promising realism, these technologies
    add complexity to integration and performance management in Unity. Strategies
    such as planning learning phases and optimizing computational resources are crucial
    for an efficient workflow. Next, we’ll cover the best practices for performance
    and immersion, focusing on strategies to ensure that advanced AI systems enhance
    gaming experience richness while maintaining performance efficiency. This includes
    optimizing decision cycles, using efficient data structures, and rigorously testing
    AI behaviors for player engagement without compromising performance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了将先进的AI技术如机器学习和程序内容生成集成到Unity中，以丰富NPC的行为。我们讨论了使用Unity的ML-Agents工具包训练NPC，以改善他们随时间对玩家交互的响应。虽然这些技术承诺了更高的现实感，但它们增加了Unity中集成和性能管理的复杂性。规划学习阶段和优化计算资源等策略对于高效的工作流程至关重要。接下来，我们将介绍性能和沉浸感的最佳实践，重点关注确保高级AI系统增强游戏体验丰富性的策略，同时保持性能效率。这包括优化决策周期、使用高效的数据结构，以及严格测试AI行为以吸引玩家参与，而不影响性能。
- en: The best practices for performance and immersion
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能和沉浸感的最佳实践
- en: As we wrap up our look into AI in game development, it’s essential to cover
    the best practices to ensure that AI systems enrich gameplay while operating efficiently.
    This section will focus on balancing AI complexity with game performance by optimizing
    decision cycles, using efficient data structures, and implementing rigorous testing
    and refinement processes. Following these strategies enables developers to create
    smooth and sophisticated AI behaviors, ensuring high player immersion and engagement
    throughout the gaming experience.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束对游戏开发中人工智能的探讨，确保人工智能系统在高效运行的同时丰富游戏体验是至关重要的。本节将重点关注通过优化决策周期、使用高效的数据结构以及实施严格的测试和改进流程来平衡人工智能的复杂性与游戏性能。遵循这些策略使开发者能够创建平滑且复杂的人工智能行为，确保在整个游戏体验中玩家的高沉浸感和参与度。
- en: In game development, optimizing AI systems for performance and immersion is
    crucial. One strategy is refining AI decision cycles to enhance efficiency without
    sacrificing complexity or engagement. This prevents AI processes from overwhelming
    a game’s processing capabilities, ensuring a smooth player experience.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，优化AI系统以实现性能和沉浸感至关重要。一种策略是精炼AI决策周期，在不牺牲复杂性和参与度的同时提高效率。这防止AI过程超过游戏的处理能力，确保玩家体验的流畅性。
- en: Limiting the frequency of decision checks
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制决策检查的频率
- en: 'In Unity, you can optimize decision-making processes by limiting the frequency
    of decision checks within your game loop. Consider a scenario where an NPC needs
    to decide whether to hide or seek based on a player’s actions. Instead of processing
    this decision every frame, which is computationally expensive, you can reduce
    the frequency of checks:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，你可以通过限制游戏循环中决策检查的频率来优化决策过程。考虑一个场景，其中NPC需要根据玩家的行为决定是隐藏还是寻找。而不是每帧处理这个决策，这会消耗大量的计算资源，你可以减少检查的频率：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code snippet demonstrates how reducing the frequency of decision-making
    can significantly lower the computational load, enabling smoother gameplay without
    sacrificing AI’s effectiveness.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了通过减少决策频率可以显著降低计算负载，从而在不牺牲人工智能有效性的情况下实现更平滑的游戏体验。
- en: Continuous testing and refinement of AI behaviors
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续测试和改进AI行为
- en: Continuous testing and refinement of AI behaviors are essential for maintaining
    immersion and engagement in games. Rigorous testing identifies inconsistencies
    or performance issues, while iterative refinements enhance the believability and
    responsiveness of NPC behaviors. This cycle ensures that AI not only performs
    optimally but also enriches the gaming experience, keeping players immersed and
    engaged.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 持续测试和优化AI行为对于保持游戏中的沉浸感和参与度至关重要。严格的测试可以识别出不一致性或性能问题，而迭代优化则增强了NPC行为的可信度和响应性。这一循环确保AI不仅表现最优，而且丰富了游戏体验，使玩家保持沉浸和参与。
- en: This section emphasized the crucial best practices to improve AI systems’ performance
    and immersion in game development. Strategies such as balancing AI complexity
    with performance through optimized decision cycles and efficient data structures
    were highlighted. Additionally, we emphasized continuously testing and refining
    AI behaviors to maintain engagement and realism, enhancing player immersion. By
    adopting these practices, developers can implement an AI system that enriches
    the gaming experience while operating efficiently within the game environment,
    ensuring a seamless and immersive gameplay experience.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本节强调了在游戏开发中提高AI系统性能和沉浸感的关键最佳实践。例如，通过优化决策周期和高效的数据结构平衡AI复杂性与性能的策略被突出强调。此外，我们还强调了持续测试和优化AI行为以保持参与感和现实感，增强玩家的沉浸感。通过采用这些实践，开发者可以实施一个能够丰富游戏体验同时在游戏环境中高效运行的AI系统，确保无缝和沉浸式的游戏体验。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the essentials of AI in Unity, providing a solid
    understanding of its role in game development. We explored pathfinding algorithms
    for intelligent character navigation and delved into AI decision-making logic
    for dynamic NPC behaviors. Additionally, we discussed advanced AI techniques to
    enhance NPC realism.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Unity中AI的要点，提供了对其在游戏开发中作用的理解。我们探讨了智能角色导航的路径查找算法，深入探讨了AI决策逻辑以实现动态NPC行为。此外，我们还讨论了增强NPC现实感的先进AI技术。
- en: The next chapter will move on to multiplayer gaming and delve into core concepts
    such as networking and matchmaking in Unity. You’ll learn how to design and implement
    matchmaking systems, ensure consistent game states across clients, and address
    challenges such as network latency and security to offer players a smooth and
    secure multiplayer experience.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将进入多人游戏，深入探讨Unity中的核心概念，如网络和匹配。你将学习如何设计和实现匹配系统，确保客户端之间的游戏状态一致性，并解决网络延迟和安全等挑战，为玩家提供流畅和安全的多人游戏体验。
- en: Join our community on Discord
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: [https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)
- en: '![](img/Disclaimer_QR1.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Disclaimer_QR1.jpg)'
