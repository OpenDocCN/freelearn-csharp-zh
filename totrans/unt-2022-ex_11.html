<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-144"><a id="_idTextAnchor151" class="pcalibre1 pcalibre calibre6"/>8</h1>
<h1 id="_idParaDest-145" class="calibre5"><a id="_idTextAnchor152" class="pcalibre1 pcalibre calibre6"/>Extending the Adventure Game</h1>
<p class="calibre3">In <a href="B18347_07.xhtml#_idTextAnchor130" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 7</em></a>, we added polish to the game by applying some simple VFX using post-processing effects (mainly Bloom) with the Universal RP, Shader Graph for a custom 2D shader to make specific parts of a sprite glow, 2D lights to highlight the player, and the Trail Renderer component for a quick VFX win on our bullet sprite.</p>
<p class="calibre3">We then moved away from the player to give some much-needed attention to the enemy NPCs in the game by creating configurable enemies using a ScriptableObject architecture and introducing changing behaviors based on the state pattern as implemented via a simple FSM.</p>
<p class="calibre3">With the base functionality in place for the playable character and enemies with behaviors (mostly) set up, we can now move on to spawning enemies that attack the player and vice versa with a reusable health and damage system.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre17">
<li class="calibre15">Health and inflicting damage</li>
<li class="calibre15">Updating the player and enemy to use health</li>
<li class="calibre15">Enemy wave spawner</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to spawn enemies with simple health and damage systems – that will also be applicable for the player or any damageable objects in the game!</p>
<h1 id="_idParaDest-146" class="calibre5"><a id="_idTextAnchor153" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter with the same artwork created for the project in the book, download the assets from the following GitHub repository:<a id="_idTextAnchor154" class="pcalibre1 pcalibre calibre6"/></p>
<p class="calibre3"><a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a></p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop, or a graphics program that can export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).</p>
<h1 id="_idParaDest-147" class="calibre5"><a id="_idTextAnchor155" class="pcalibre1 pcalibre calibre6"/>Health and inflicting damage</h1>
<p class="calibre3">At this point in our project, we have implemented much of what we specified in our GDD (<a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Table 4.1</em>) for our player character and enemies, but an essential system is still missing – health and damage.</p>
<p class="calibre3">In the coming sections, we’ll not only tackle adding health to the player and enemies with a reusable component but also finish the enemy’s attack behavior for inflicting damage on the player. The player can already fire a weapon that shoots a projectile, so we’ll add to the <code>Bullet</code> object we previously made in <a href="B18347_06.xhtml#_idTextAnchor116" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, so that it can inflict damage, too.</p>
<h2 id="_idParaDest-148" class="calibre8"><a id="_idTextAnchor156" class="pcalibre1 pcalibre calibre6"/>Health system</h2>
<p class="calibre3">We’ll develop a <code>HealthSystem</code> component<a id="_idIndexMarker764" class="pcalibre1 pcalibre calibre6"/> to create a reusable component for <code>Player</code>, enemy, and other objects (e.g., in the environment – think a destructible crate). This health system will track health, take damage and/or heal, and can be added to any object. The remainder of the setup will include creating Interfaces that tie the system together and make the whole thing operate in an abstract way (i.e., reusable, extensible, maintainable).</p>
<p class="calibre3">Like before, to clearly understand how we’ll create the health system, we’ll utilize a UML diagram based on the concepts we just described in the preceding paragraph. We can always refer back to this diagram at any point if needed.</p>
<div><div><img alt="Figure 8.1 – Health system class diagram" src="img/B18347_08_1.jpg" class="calibre88"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Health system class diagram</p>
<p class="calibre3">Now, let’s dive into it! Create<a id="_idIndexMarker765" class="pcalibre1 pcalibre calibre6"/> a new script in the <code>Assets/Scripts</code> folder and name it <code>HealthSystem</code>. This, being central to the UML diagram, will be the largest class we’ll be creating for the health system because, well, it <em class="italic">is</em> the health system! Since it will consist of the most code we’ll be writing in this section, we’ll break it up by first just declaring the member variables and a Unity message event, then proceed to flesh it out as we build up the system’s functionality:</p>
<pre class="source-code">
using UnityEngine;
public class HealthSystem: MonoBehaviour
{
    [SerializeField] private int _healthMax;
    private int _healthCurrent;
    private void OnTriggerEnter2D(Collision collision)
    {
        // UNDONE: Test for a collision with a component
        // that can damage us.
        // UNDONE: HandleDamageCollision();
        // UNDONE: Test for a collision with a component
        // that can heal us.
        // UNDONE: HandleHealCollision();
    }
}</pre> <p class="callout-heading">Task list (IDE)</p>
<p class="callout">You’ve undoubtedly seen <strong class="source-inline1">// UNDONE:</strong> in the preceding code<a id="_idIndexMarker766" class="pcalibre1 pcalibre calibre6"/> and may have wondered what that’s all about. Well, we can use some tokens in our comments that our IDE will pick up, and it will generate a task list<a id="_idIndexMarker767" class="pcalibre1 pcalibre calibre6"/> based on them! This feature helps us locate incomplete tasks and highlight things that need attention. Additionally, you can create your own custom tokens, which can be super useful for your specific needs (but you’ll need to check your specific IDE for support).</p>
<p class="callout">Common tokens include the following:</p>
<p class="callout"><strong class="source-inline1">    // </strong><strong class="source-inline1">TODO:</strong></p>
<p class="callout"><strong class="source-inline1">    // </strong><strong class="source-inline1">UNDONE:</strong></p>
<p class="callout"><strong class="source-inline1">    // </strong><strong class="source-inline1">HACK:</strong></p>
<p class="calibre3">As you may be able to infer from the code we have so far – and if you’ve read the code comments – <code>HealthSystem</code> functions through collisions with other objects in the scene, such as projectiles from enemies or healing pickups. The other objects can either damage or heal the object with the <code>HealthSystem</code> component on it, and that will depend on the interface the object inherits from (from the UML diagram: <code>IDamage</code> and <code>IHeal</code>). Even the ground as an object can potentially damage the player if, let’s say, the player’s velocity is above a certain threshold when colliding.</p>
<p class="calibre3">Here’s the breakdown for the code added so far, plus the required additions:</p>
<ul class="calibre17">
<li class="calibre15">Variable declarations will enable<a id="_idIndexMarker768" class="pcalibre1 pcalibre calibre6"/> the core function of <code>HealthSystem</code>:<ul class="calibre22"><li class="calibre15"><code>_healthMax</code> will specify the maximum health value for the object (i.e., the object we’re giving health by adding the <code>HealthSystem</code> component).</li><li class="calibre15"><code>_healthCurrent</code> will specify the current health of the object. As the object is either damaged or healed, this value will decrease or increase respectively. When the object is created in the scene, we should set the current health to the <code>_healthMax</code> value, which we’ll do now by adding the <code>Awake()</code> Unity message event as follows:<pre class="source-code">
    private void Awake()
    {
        _healthCurrent = _healthMax;
    }</pre></li><li class="calibre15">Note here that the max health value (<code>_healthMax</code> is the serialized stored value) will be saved within the <code>Object with Health</code> Prefab, but imagine that you could also use a ScriptableObject, database, cloud-obtained (JSON) data, or even<a id="_idIndexMarker769" class="pcalibre1 pcalibre calibre6"/> Unity’s own <strong class="bold">Remote Config</strong> (as part of <strong class="bold">Unity Gaming Services</strong>) so that we can change the<a id="_idIndexMarker770" class="pcalibre1 pcalibre calibre6"/> max health value dynamically (and, with some of these methods, at any time without being dependent on distributing a new build of the game).</li></ul></li> </ul>
<p class="callout-heading">Additional reading | Unity Gaming Services</p>
<p class="callout">Remote<a id="_idIndexMarker771" class="pcalibre1 pcalibre calibre6"/> Config: <a href="https://unity.com/products/remote-config" class="pcalibre1 pcalibre calibre6">https://unity.com/products/remote-config</a></p>
<ul class="calibre17">
<li class="calibre15"><code>OnTriggerEnter2D()</code> is where the magic happens! Collisions with other objects drive the health system, so we’ll use this Unity message event to handle the interactions when triggered from the physics system.</li>
</ul>
<p class="calibre3">Let’s add both damage and healing methods first, and then we’ll add the evaluations that call these methods next:</p>
<p class="callout-heading">Note | Physical interactions</p>
<p class="callout">To have the objects physically respond to each other when colliding, use a <strong class="bold">Collider</strong> instance on the object that does not have <strong class="bold">IsTrigger</strong> enabled and respond to the collision using the <strong class="source-inline1">OnCollisionEnter2D()</strong> Unity message event. For an object to not have a physical response when colliding, use a <strong class="bold">Collider</strong> instance with the <strong class="bold">IsTrigger</strong> field enabled and respond to the collision using the <strong class="source-inline1">OnTriggerEnter2D()</strong> Unity message event.</p>
<ul class="calibre17">
<li class="calibre15"><code>HandleDamageCollision()</code>, as the name implies, handles<a id="_idIndexMarker772" class="pcalibre1 pcalibre calibre6"/> when we collide with another object that can damage us. We’ll pass in the collision parameter from when <code>OnTriggerEnter2D()</code> is called and, a future addition, the object that caused the damage (which is the object inheriting from the <code>IDamage</code> interface).</li>
<li class="calibre15">Add the following method to the <code>HealthSystem</code> class:<pre class="source-code">
internal void HandleDamageCollision
    (Collider2D collision, IDamage damage)
{
    // UNDONE: TakeDamage(amount);
}</pre></li> <li class="calibre15">Okay, yes, we’ve added another unfinished method to be called here that we’ll again add to later: <code>TakeDamage()</code>. We’re keeping the approach simple, taking one baby step at a time to build out the health system. The simple UML diagram may set an expectation that this will be easy. Well, it is – provided we tackle the implementation one step at a time.</li>
<li class="calibre15">Our future selves will again tackle implementing the <code>TakeDamage()</code> method in the coming <em class="italic">Taking damage – IDamage interface</em> section when we also add the required <code>IDamage</code> interface.</li>
<li class="calibre15"><code>HandleHealCollision()</code> is similar to the method for handling damage. We’ll add one for handling object healing. However, we’ll omit to pass in the <code>collision</code> object as a parameter this time; we’ll handle things a bit differently for healing compared to taking damage (as you’ll see in the coming <em class="italic">Healing – IHeal </em><em class="italic">interface</em> section).</li>
<li class="calibre15">Add the following method to the <code>HealthSystem</code> class:<pre class="source-code">
internal void HandleHealCollision(IHeal heal)
{
    // UNDONE: ApplyHealing(amount);
}</pre></li> <li class="calibre15">Okay, we’re piling on the <em class="italic">undone</em> methods to implement here, right?! Just like for <code>TakeDamage()</code>, we’ll have a method called for healing and changing the health value of the affected object.</li>
</ul>
<p class="calibre3">And that’s the core of the <code>HealthSystem</code> class laid out. Let’s go<a id="_idIndexMarker773" class="pcalibre1 pcalibre calibre6"/> ahead and add the required interfaces that our new health system classes inherit from and make things actually function!</p>
<h2 id="_idParaDest-149" class="calibre8"><a id="_idTextAnchor157" class="pcalibre1 pcalibre calibre6"/>Interfaces required!</h2>
<p class="calibre3">There’s still more work<a id="_idIndexMarker774" class="pcalibre1 pcalibre calibre6"/> to do before we add a <code>HealthSystem</code> component to any of our GameObjects, so let’s sort out and evaluate these damage and heal collisions.</p>
<p class="calibre3">The first part we’ll need interfaces for is the evaluation of the object that collides with the object that has health (e.g., a <code>Player</code> or enemy object with the <code>HealthSystem</code> component added). We’ll determine whether the colliding object can damage or heal – we’re replacing this first <code>UNDONE</code> token in our task list:</p>
<pre class="source-code">
    // UNDONE: Test for a collision with a component
    // that can damage us.</pre> <p class="calibre3">From the UML diagram, we can see the object we want to evaluate is either inherited from <code>IDamage</code> or <code>IHeal</code>. Using interfaces to inherit from ensures that the required members exist in our classes that provide the intended functionality (i.e., the class must satisfy the “contract” of the interface).</p>
<p class="calibre3">Standard naming conventions<a id="_idIndexMarker775" class="pcalibre1 pcalibre calibre6"/> dictate that when naming an interface, it should begin with the letter “<em class="italic">I</em>,” which offers us an opportunity to be a bit clever, or even memorable, in our naming and bring more readability to our codebase. So, for an object that can damage another object, we’ll name the interface <code>IDamage</code> – as in <em class="italic">I damage [an object]</em>. In the <em class="italic">Healing – IHeal interface</em> section, we’ll add additional interfaces for <code>IHaveHealth</code> and <code>IHeal</code> – see what we did there. Not that I’m being terribly clever here because <em class="italic">IDamage</em>, <em class="italic">IDamageable</em>, and <em class="italic">ITakeDamage</em> are pretty common interface names for game code for the same naming reasoning.</p>
<p class="calibre3">Now, let’s update the <code>OnTriggerEnter2D()</code> method with the following <code>if</code> statements that include the interfaces (that we’ll create just after this step):</p>
<pre class="source-code">
    private void OnTriggerEnter2D(Collision collision)
    {
        // Test for a collision with a component that can
        // damage us.
        if (collision.
            TryGetComponent&lt;IDamage&gt;(out var damage))
        {
            HandleDamageCollision(collision, damage);
        }
        // Test for a collision with a component that can
        // heal us.
        else if (collision.
            TryGetComponent&lt;IHeal&gt;(out var heal))
        {
            HandleHealCollision(heal);
        }
    }</pre> <p class="calibre3">Let’s have a look at the following two evaluations<a id="_idIndexMarker776" class="pcalibre1 pcalibre calibre6"/> and how they’ll provide the desired functionality for our health system:</p>
<ul class="calibre17">
<li class="calibre15"><code>collision.TryGetComponent&lt;IDamage&gt;()</code>: If you haven’t realized by now, I’m a fan of the <em class="italic">try get component pattern</em> – we can fail gracefully if the component doesn’t exist on the object we’re testing. And if it does exist, we conveniently have an <code>out</code> parameter that returns the component. Simples!</li>
</ul>
<p class="callout-heading">Optimization note</p>
<p class="callout">When using the <strong class="source-inline1">TryGetComponent</strong> method, the method does not allocate<a id="_idIndexMarker777" class="pcalibre1 pcalibre calibre6"/> memory on the heap when it doesn’t find a component. When it does find a component, it allocates memory only for the return value, not the component itself. This can be very beneficial for improving performance and reducing garbage collection, unlike the <strong class="source-inline1">GetComponent</strong> methods, which can generate garbage and allocate more memory – both negatively impacting performance. By utilizing <strong class="source-inline1">TryGetComponent</strong> instead, you can avoid unnecessary memory allocations and keep your game running smooth as butter.</p>
<p class="calibre3">So, what’s occurring here is, if the object we collided with has a component that inherits from <code>IDamage</code> on it, as in, <em class="italic">I damage this object</em>, then return the component and pass it into <code>HandleDamageCollision()</code> as a parameter along with the collision object itself. Peeking ahead a bit and referring back to the UML diagram, we can see that we’ll be implementing a <code>ProjectileDamage</code> component (e.g., on <code>Bullet</code>) that inherits from <code>IDamage</code>.</p>
<ul class="calibre17">
<li class="calibre15"><code>collision.TryGetComponent&lt;IHeal&gt;()</code>: Ditto here. If the component we collided with has a component that inherits from <code>IHeal</code> on it, as in, <em class="italic">I heal this object</em>, then return the component and pass it into <code>HandleHealCollision()</code>. Again, peeking back at the UML diagram, we can see that we’ll be implementing a <code>PickupHeal</code> component (e.g., on a Water Diamond) that inherits from <code>IHeal</code>.</li>
</ul>
<p class="calibre3">Currently, if the object collided does neither damage nor heal, then we simply ignore the collision (of course, when colliding with anything, the obvious choice here is to do a camera shake!).</p>
<p class="calibre3">Now that we have an implementation<a id="_idIndexMarker778" class="pcalibre1 pcalibre calibre6"/> of the interface, we need to actually create them. These interfaces aren’t going to write themselves, so let’s start with <code>IDamage</code>.</p>
<h2 id="_idParaDest-150" class="calibre8"><a id="_idTextAnchor158" class="pcalibre1 pcalibre calibre6"/>Taking damage – IDamage interface</h2>
<p class="calibre3">We’ve already seen<a id="_idIndexMarker779" class="pcalibre1 pcalibre calibre6"/> the UML <a id="_idIndexMarker780" class="pcalibre1 pcalibre calibre6"/>diagram (<em class="italic">Figure 8</em><em class="italic">.1</em>) and the <code>HandleDamageCollision()</code> code, where the <code>IDamage</code> interface is implemented but hasn’t been defined yet. I lied above, too: they can write themselves (at least partially) if we use the IDE’s refactoring tools – in <code>OnTriggerEnter2D()</code>, <code>IDamage</code> will have a red squiggly underline. Right-clicking on the word (or clicking anywhere on it and pressing <em class="italic">Alt + Enter</em> or <em class="italic">Ctrl + .</em> depending on your IDE) and selecting <strong class="bold">Generate interface ‘IDamage’ in a new file</strong> will generate the following:</p>
<pre class="source-code">
internal interface IDamage
{
}</pre> <p class="calibre3">If you decided not to use refactoring tools (why not?), create a new C# script in the <code>Assets/Scripts/Interfaces</code> folder and name it <code>IDamage</code>. Even if you did use the refactoring tools, you’ll likely still need to move the generated script into the <code>Assets/Scripts/Interfaces</code> folder to keep things tidy.</p>
<p class="calibre3">Now, we’ll need a field for specifying the value for how much the object inheriting from <code>IDamage</code> will damage the object with health, so add a <code>DamageAmount</code> variable declaration like so:</p>
<pre class="source-code">
    int DamageAmount { get; }</pre> <p class="calibre3">Remember, all members of an interface are public, so there is no need to add the accessor. We’ll set the property to be a getter only, though; we’ll only want the value to be read by other classes (no modification outside of the class inheriting the interface – all nice and hidden, how we like it).</p>
<p class="calibre3">Now that we have<a id="_idIndexMarker781" class="pcalibre1 pcalibre calibre6"/> our <code>IDamage</code> interface. We can use<a id="_idIndexMarker782" class="pcalibre1 pcalibre calibre6"/> it for making projectiles and, well, just about any other object that hurt the player, by subtracting health when a collision occurs between the object and <code>HealthSystem</code>.</p>
<p class="calibre3">Let’s fix up the <code>HandleDamageCollision()</code> method now back in our <code>HealthSystem</code> class by removing the <code>// UNDONE:</code> token comment and using <code>DamageAmount</code> for the parameter:</p>
<pre class="source-code">
    internal void HandleDamageCollision
        (Collider2D collision, IDamage damage)
    {
        TakeDamage(damage.DamageAmount);
    }</pre> <p class="calibre3">This sets us up nicely to have our IDE’s refactoring tools generate the <code>TakeDamage()</code> method for us, so let’s continue by doing just that. You know the drill: red squiggly line, etc., etc., then select <strong class="bold">Generate </strong><strong class="bold">method ‘TakeDamage.’</strong>.</p>
<p class="calibre3">And here we are:</p>
<pre class="source-code">
    private void TakeDamage(int amount)
    {
        // UNDONE: Subtract from current health.
        // UNDONE: HealthChanged();
    }</pre> <p class="calibre3">I’m so sorry, more <em class="italic">undone</em> comments! Please don’t fret; with this very temporary instruction, we’ll fix up the code straight away. Fill in the method with the following statements:</p>
<pre class="source-code">
    private void TakeDamage(int amount)
    {
        _healthCurrent = Mathf.Max(_healthCurrent - amount,
            0);
        HealthChanged();
    }</pre> <p class="calibre3">The first thing we do is update the current health value for the amount of damage received by subtracting <code>amount</code> from <code>_healthCurrent</code>. We’re getting some help from the <code>Mathf.Max()</code> function here so that the current health value will never dip below <a id="_idIndexMarker783" class="pcalibre1 pcalibre calibre6"/>zero (keeping things positive).</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">Mathf.Max()</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml</a></p>
<p class="calibre3">Let’s uncomment our placeholder<a id="_idIndexMarker784" class="pcalibre1 pcalibre calibre6"/> for the <code>HealthChanged()</code> method. Go ahead<a id="_idIndexMarker785" class="pcalibre1 pcalibre calibre6"/> and create an empty method block for it, but completing this method will be a job for our future selves when we actually have some objects set up to enact the health change:</p>
<pre class="source-code">
    private void HealthChanged()
    {
        // UNDONE: If current health is greater than zero,
        // notify the object with health.
        // UNDONE: If current health is zero, the object
        // with health dies/is destroyed.
    }</pre> <p class="calibre3">We’ll call this method anytime the health value has changed so we can evaluate the current health of the object and <em class="italic">do stuff</em> accordingly – such as notify other classes about the health value of the object<a id="_idIndexMarker786" class="pcalibre1 pcalibre calibre6"/> changing or die/destroy<a id="_idIndexMarker787" class="pcalibre1 pcalibre calibre6"/> if health reaches zero.</p>
<p class="calibre3">So, let’s get an object set up now that will inflict damage on the player.</p>
<h2 id="_idParaDest-151" class="calibre8"><a id="_idTextAnchor159" class="pcalibre1 pcalibre calibre6"/>ProjectileDamage component</h2>
<p class="calibre3">Create a new script<a id="_idIndexMarker788" class="pcalibre1 pcalibre calibre6"/> called <code>ProjectileDamage</code> in the <code>Assets/Scripts</code> folder – this<a id="_idIndexMarker789" class="pcalibre1 pcalibre calibre6"/> is a component we’ll add to our <code>Bullet</code> Prefab. To ensure this component will cause damage to our health system, it will implement the <code>IDamage</code> interface:</p>
<pre class="source-code">
using UnityEngine;
public class ProjectileDamage : MonoBehaviour, IDamage
{
    public int DamageAmount =&gt; _damageAmount;
    [SerializeField] private int _damageAmount = 5;
}</pre> <p class="calibre3">The public <code>DamageAmount int</code> variable is required to be declared to satisfy the <code>IDamage</code> interface contract – it’s also necessary for the health system to obtain the value for the amount of damage this projectile causes! <code>DamageAmount</code> is a public property because all interface members are public and cannot contain fields. Because C# properties are not serialized by Unity, to assign a value in the <code>Bullet</code> Prefab), we’ll encapsulate a private <code>_damageAmount</code> variable and decorate it with the <code>[SerializeField]</code> attribute. If you haven’t already guessed, this is the structure we’ll continue with throughout the remainder of the book.</p>
<p class="calibre3">When you’ve finished saving the script, open up the <code>Bullet</code> Prefab in <code>ProjectileDamage</code> to the root GameObject, as seen in the following figure:</p>
<div><div><img alt="Figure 8.2 – Bullet Prefab ProjectileDamage component" src="img/B18347_08_2.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Bullet Prefab ProjectileDamage component</p>
<p class="calibre3">When we declared <code>_damageAmount</code> in the preceding code, we set a default value of <code>5</code>, which you can already see as the assigned value in the <strong class="bold">Inspector</strong> window.</p>
<p class="calibre3">Okay, we can damage<a id="_idIndexMarker790" class="pcalibre1 pcalibre calibre6"/> stuff now; great! But that’s not really fair if objects such as our player<a id="_idIndexMarker791" class="pcalibre1 pcalibre calibre6"/> cannot also have a chance to heal.</p>
<h2 id="_idParaDest-152" class="calibre8"><a id="_idTextAnchor160" class="pcalibre1 pcalibre calibre6"/>Healing – IHeal interface</h2>
<p class="calibre3">We’ve taken care of the left<a id="_idIndexMarker792" class="pcalibre1 pcalibre calibre6"/> side of the UML diagram (<em class="italic">Figure 8</em><em class="italic">.1</em>) for our health system, so now, similar to <code>IDamage</code>, we need to define the <code>IHeal</code> interface to take care of the right side. We’ll also create a component to add to objects that can apply healing.</p>
<p class="calibre3">Back in the <code>OnTriggerEnter2D()</code> method now, let’s repeat the steps performed for creating the <code>IDamage</code> interface but for <code>IHeal</code>:</p>
<ol class="calibre14">
<li class="calibre15">Create the <code>IHeal</code> interface script (have your IDE generate it) in the <code>Assets/Scripts/Interfaces</code> folder and add the <code>HealAmount</code> variable for, you guessed it, specifying the amount of healing power:<pre class="source-code">
internal interface IHeal
{
    int HealAmount { get; }
}</pre></li> <li class="calibre15">Update the placeholder <code>HandlHealCollision()</code> method, specifying the <code>HealAmount</code> value from the interface<a id="_idIndexMarker793" class="pcalibre1 pcalibre calibre6"/> as the parameter when calling <code>ApplyHealing()</code>:<pre class="source-code">
    private void HandleHealCollision(IHeal heal)
    {
        ApplyHealing(heal.HealAmount);
    }</pre></li> <li class="calibre15">Lastly, create the <code>ApplyHealing()</code> method:<pre class="source-code">
    private void ApplyHealing(int amount)
    {
        _healthCurrent = Mathf.Min(_healthCurrent + amount,
            _healthMax);
        HealthChanged();
    }</pre></li> </ol>
<p class="calibre3">The first thing we do is update the current health value for the amount of healing received by adding <code>amount</code> to <code>_healthCurrent</code>. Just like when we took damage, we’re getting some help from a <code>Mathf</code> function here again, but it’s <code>Mathf.Min()</code> this time, so that the current health value will never exceed the object’s maximum health<a id="_idIndexMarker794" class="pcalibre1 pcalibre calibre6"/> value (no cheating).</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">Mathf.Min</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml</a></p>
<p class="calibre3">And, like with damage, we’ll create<a id="_idIndexMarker795" class="pcalibre1 pcalibre calibre6"/> a healing component that will add health when a collision occurs.</p>
<h3 class="calibre10">PickupHeal component</h3>
<p class="calibre3">Create a new script<a id="_idIndexMarker796" class="pcalibre1 pcalibre calibre6"/> called <code>PickupHeal</code> in the <code>Assets/Scripts</code> folder:</p>
<pre class="source-code">
using UnityEngine;
public class PickupHeal : MonoBehaviour, IHeal
{
    public int HealAmount =&gt; _healAmount;
    [SerializeField] private int _healAmount = 10;
}</pre> <p class="calibre3">Same as with the <code>ProjectileDamage</code> script, we can see that we’ve inherited from <code>IHeal</code> (to ensure healing with our health system) and implemented the <code>IHeal</code> interface by defining <code>HealAmount</code>. We’ve also encapsulated <code>HealAmount</code> by declaring a private <code>_healAmount</code> variable serialized so we can set the value in the <code>10</code> is also assigned here).</p>
<p class="callout-heading">Note on code architecture</p>
<p class="callout">If you find yourself needing many different types for damage or heal components, you can create a new base class for each that implements the interface, so you aren’t repeating yourself with the event and method to invoke. The current implementation suits our current needs, so you can also leave off here, or challenge yourself to create both a <strong class="source-inline1">DamageBase</strong> and <strong class="source-inline1">HealBase</strong> abstract class that <strong class="source-inline1">ProjectileDamage</strong> and <strong class="source-inline1">PickupHeal</strong> inherit from, respectively.</p>
<p class="calibre3"><code>PickupHeal</code> is a component we’ll add to… hmmm… what object will we add it to? Let’s consult our GDD (<a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Table 4.2</em>):</p>
<table class="no-table-style" id="table001-4">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is a buff mechanic for the player in the </strong><strong class="bold">adventure game?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">The player will be able to collect energy shards (water diamonds) scattered throughout the environment that, when a certain quantity has been collected, will give a power-up state to all of the weapons (increasing damage dealt).</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 8.1 – Adding a buff to the GDD</p>
<p class="calibre3">Sounds great. Well, actually, I think we can do better. Let’s revise; after all, the GDD is a living document:</p>
<table class="no-table-style" id="table002-2">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is a buff mechanic for the player in the </strong><strong class="bold">adventure game?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Players can gather energy shards (water diamonds) as they explore the game world. The player can later use the collected energy to power up weapons (increase damage dealt) or heal the player, offering more strategic options for the player while navigating the game’s challenges.</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 8.2 – Revising the buff in the GDD</p>
<p class="calibre3">Better! Allowing players to choose between using energy shards to power up weapons or to heal themselves creates a risk-versus-reward strategy in the game. To make the mechanic meaningful to the player, a game designer must consider the approach carefully, especially if the choice<a id="_idIndexMarker797" class="pcalibre1 pcalibre calibre6"/> is only sometimes clear!</p>
<p class="calibre3">For now, let’s just create an object that will heal the player when picked up.</p>
<h3 class="calibre10">Creating a water diamond pickup</h3>
<p class="calibre3">Let’s use the water diamond<a id="_idIndexMarker798" class="pcalibre1 pcalibre calibre6"/> from the artwork provided at the following link: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets</a>.</p>
<div><div><img alt="Figure 8.3 – Water diamond artwork" src="img/B18347_08_3.jpg" class="calibre83"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Water diamond artwork</p>
<p class="calibre3">To create our water diamond pickup<a id="_idIndexMarker799" class="pcalibre1 pcalibre calibre6"/> Prefab based on the water diamond artwork, and as a refresher, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Import the artwork to the <code>Assets/Sprites/Pickups</code> folder. (I love how this water diamond art came out, by the way; nice job, Nica!)</li>
<li class="calibre15">In the <strong class="bold">Project</strong> window, select the water diamond sprite and, in the <strong class="bold">Inspector</strong> window, use <strong class="bold">Sprite Editor</strong> to set the provided normal map as the secondary texture.</li>
<li class="calibre15">Drag the water diamond sprite into the <code>Water Diamond (Heal)</code> (remember, you can easily parent a GameObject in the <strong class="bold">Hierarchy</strong> window by right-clicking on it and selecting <strong class="bold">Create </strong><strong class="bold">Empty Parent</strong>).</li>
<li class="calibre15">Add a <code>CapsuleCollider2D</code> instance to the parent object to enable physics (precisely, collision detection).</li>
<li class="calibre15">Use the <strong class="bold">Edit Collider</strong> button to enable resizing of the collider around the diamond shape, as seen in the following figure.</li>
</ol>
<div><div><img alt="Figure 8.4 – Water diamond healing Prefab" src="img/B18347_08_4.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Water diamond healing Prefab</p>
<ol class="calibre14">
<li value="6" class="calibre15">Add the <code>PickupHeal</code> component to the Prefab root (also seen in <em class="italic">Figure 8</em><em class="italic">.4</em>).</li>
<li class="calibre15">Lastly, drag the parent object from the <code>Assets/Prefabs</code> folder.</li>
</ol>
<p class="calibre3">For a quick hack to bump up<a id="_idIndexMarker800" class="pcalibre1 pcalibre calibre6"/> the visuals, you can cheat a bit (as indie game devs, it’s all about cheating to save time anywhere we can) and reuse the material we created in <a href="B18347_07.xhtml#_idTextAnchor130" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 7</em></a>, for the bullet. Follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Assets/Materials</code> folder, duplicate the <code>Bullet 1</code> material and rename it <code>Water </code><code>Diamond 1</code>.</li>
<li class="calibre15">Assign the water diamond sprite to the <code>MainTex</code> channel but leave the <code>bullet1_emission</code> map.</li>
<li class="calibre15">Assign this new material to the <strong class="bold">Sprite Renderer Material</strong> field on the <strong class="bold">Water Diamond 1</strong> Prefab’s graphic.</li>
<li class="calibre15">Adjust the HDR color and intensity for desired visuals.</li>
</ol>
<p class="calibre3">Our pickup Prefab is looking good. Yay!</p>
<p class="calibre3">We need to add one last bit of functionality<a id="_idIndexMarker801" class="pcalibre1 pcalibre calibre6"/> for this Prefab to be a pickup for the player. It has to disappear once “collected,” and we can do that by revisiting an existing reusable component we previously made – along with a new one.</p>
<h3 class="calibre10">Composition for pickup behavior</h3>
<p class="calibre3">As previously introduced, being able to bring<a id="_idIndexMarker802" class="pcalibre1 pcalibre calibre6"/> multiple objects together to achieve<a id="_idIndexMarker803" class="pcalibre1 pcalibre calibre6"/> a desired behavior or functionality is a form of <strong class="bold">composition</strong>. To state another way, we’ll combine two or more reusable components, each responsible for a specific aspect of an object’s behavior or appearance. This will allow us to create a new behavior directly in the editor without introducing new code – this is especially valuable for designers on your team where experimentation can generate new ideas independently.</p>
<p class="calibre3">Let’s start by adding the <code>TriggeredEvent</code> component to the root <code>gameObject</code> of the <code>OnTriggered</code> event that fires when the player collides with the pickup object. We want to destroy the pickup, but there isn’t a built-in way to do that. However, it’s easily solved.</p>
<h3 class="calibre10">Destroyer component</h3>
<p class="calibre3">To destroy the pickup, all we need is an additional<a id="_idIndexMarker804" class="pcalibre1 pcalibre calibre6"/> component serving as a single-purpose but reusable component. This component will be added to the existing composition for the pickup behavior. To clarify, we need to destroy the pickup object by calling the <code>TriggeredEvent.OnTriggered</code> event. So, first,  make a new script named <code>Destroyer</code> in the <code>Assets/Scripts</code> folder:</p>
<pre class="source-code">
using UnityEngine;
public class Destroyer : MonoBehaviour
{
    public float Delay = 0f;
    public void DestroyMe()
    {
        if (Delay &gt; 0)
            Invoke(nameof(DestroyNow), Delay);
        else
            DestroyNow();
    }
    private void DestroyNow() =&gt; Destroy(gameObject);
}</pre> <p class="calibre3">Simple. A public method that can be called that destroys<a id="_idIndexMarker805" class="pcalibre1 pcalibre calibre6"/> the object – <code>DestroyMe()</code>. I’ve added the option for setting a delay before destroying the object – yes, I’m confident this is a typical enough use case, it literally only took seconds to add, and I’ll defend that I’m not violating the YAGNI principle!</p>
<p class="callout-heading">YAGNI | “You ain’t gonna need it”</p>
<p class="callout">This principle states that a programmer should only add functionality if necessary.</p>
<p class="callout">Another one I like is <strong class="bold">DRY</strong> (<strong class="bold">don’t repeat yourself</strong>), which is simply directed<a id="_idIndexMarker806" class="pcalibre1 pcalibre calibre6"/> at reducing repetition (a basic example would be if you find yourself writing the same code more than once, extract it to a method or abstraction).</p>
<p class="calibre3">Go ahead and add <code>Destroyer</code> to the root of the <code>Water Diamond (Heal)</code> Prefab so we can wire things up in the <strong class="bold">Inspector</strong> window:</p>
<ol class="calibre14">
<li class="calibre15">Set the execution state dropdown to <strong class="bold">Runtime Only</strong>.</li>
<li class="calibre15">Drag the <code>Destroyer</code> component to the object field (using its title area).</li>
<li class="calibre15">In the function selection dropdown, select <strong class="bold">Destroyer</strong> | <strong class="bold">DestroyMe( )</strong>.</li>
<li class="calibre15">I’d leave <code>0</code> for this pickup, but for other behavior, you may want to adjust (see, you have that option!). And, yes, although <code>Destroy()</code> has a second parameter to delay destroying the object, the <code>Destroyer</code> class serves as a general example for introducing an execution delay.</li>
</ol>
<div><div><img alt="Figure 8.5 – Assign DestroyMe to OnTriggered (UnityEvent)" src="img/B18347_08_5.jpg" class="calibre89"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Assign DestroyMe to OnTriggered (UnityEvent)</p>
<p class="calibre3">Okay, so let’s talk about what objects can affect the health of other objects – right now, it’s like the Wild West out there, with everything able to damage everything else. We can’t have any of that going on, so let’s put on a mask<a id="_idIndexMarker807" class="pcalibre1 pcalibre calibre6"/> to start getting everyone to behave properly – a LayerMask, that is.</p>
<h2 id="_idParaDest-153" class="calibre8"><a id="_idTextAnchor161" class="pcalibre1 pcalibre calibre6"/>Controlling what damages/heals what</h2>
<p class="calibre3">The problem we have to solve here is finding a simple way to specify what objects can damage other objects – this is essential for reinforcing<a id="_idIndexMarker808" class="pcalibre1 pcalibre calibre6"/> the game’s design. We’ve solved<a id="_idIndexMarker809" class="pcalibre1 pcalibre calibre6"/> this problem before by using a <strong class="bold">tag</strong> and also a <strong class="bold">LayerMask</strong>. My preference, generally, is to use tags only when comparing a single type of object in code and using a LayerMask for sorting out several different types of objects, with the added bonus of a LayerMask being designer friendly since the assignment is made in the <strong class="bold">Inspector</strong> window.</p>
<h3 class="calibre10">What damages</h3>
<p class="calibre3">The time to evaluate the objects <a id="_idIndexMarker810" class="pcalibre1 pcalibre calibre6"/>is at the time of the collision, so we will update the <em class="italic">handle collision</em> methods in <code>HealthSystem</code> accordingly. But first, we need to define the <code>LayerMask</code> variables in the right places, starting with damage.</p>
<p class="calibre3">Add a <code>DamageMask</code> declaration to the <code>IDamage</code> interface:</p>
<pre class="source-code">
internal interface IDamage
{
    int DamageAmount { get; }
    LayerMask DamageMask { get; }
}</pre> <p class="calibre3">Now, add the following variables so we can use <code>DamageMask</code> and satisfy the existing contract we have in <code>ProjectileDamage</code> for the interface implementation:</p>
<pre class="source-code">
public class ProjectileDamage : MonoBehaviour, IDamage
{
    public LayerMask DamageMask =&gt; _damageMask;
    [SerializeField] private LayerMask _damageMask;
    …</pre> <p class="calibre3">Here is the encapsulation pattern again (told you!) for the <code>_damageMask</code> variable.</p>
<p class="calibre3">We can now revise the <code>HandleDamageCollision()</code> method in <code>HealthSystem</code> to implement the mask check:</p>
<pre class="source-code">
    internal void HandleDamageCollision
        (Collider2D collision, IDamage damage)
    {
        if (damage.DamageMask
            &amp; (1 &lt;&lt; gameObject.layer)) != 0)
        {
            TakeDamage(damage.DamageAmount);
        }
    }</pre> <p class="calibre3">This <code>if</code> statement should look<a id="_idIndexMarker811" class="pcalibre1 pcalibre calibre6"/> a bit familiar; it’s the same <em class="italic">is this object’s layer in the LayerMask?</em> evaluation we used for our <code>Bullet</code> back in <a href="B18347_06.xhtml#_idTextAnchor116" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>. So, if the <code>ProjectileDamage.DamageMask</code> includes the object with health’s layer, only then will <code>TakeDamage()</code> be called.</p>
<p class="calibre3">Damage bad. Heal good. Let’s do the same for what can heal.</p>
<h3 class="calibre10">What heals</h3>
<p class="calibre3">We’re going to repeat what<a id="_idIndexMarker812" class="pcalibre1 pcalibre calibre6"/> we did for what damages, so add the <code>LayerMask</code> variable <code>HealMask</code> to the <code>IHeal</code> interface:</p>
<pre class="source-code">
internal interface IHeal
{
    int HealAmount { get; }
    LayerMask HealMask { get; }
}</pre> <p class="calibre3">Implement the updated <code>IHeal</code> interface contract in <code>PickupHeal</code> – encapsulating the <code>_healMask</code> variable:</p>
<pre class="source-code">
public class PickupHeal : MonoBehaviour, IHeal
{
    public LayerMask HealMask =&gt; _healMask;
    [SerializeField] private LayerMask _healMask;
    …</pre> <p class="calibre3">As an exception to repeating what we did in the <code>HandleDamageCollision()</code> method, let’s not repeat ourselves here by also adding the layer mask check code to <code>HealthSystem.HandleHealCollision()</code>; instead, let’s extract the layer mask evaluation to a method, and we’ll give it a nice, easy-to-understand name: <code>IsLayerInLayerMask()</code> (using <code>Is</code> to start the name with makes it obvious this will return a bool <code>true</code> or <code>false</code> value, no?):</p>
<pre class="source-code">
    private bool IsLayerInLayerMask(
        int layer,
        LayerMask mask)
            =&gt; (mask &amp; (1 &lt;&lt; layer)) != 0;</pre> <p class="callout-heading">Utility methods (C#)</p>
<p class="callout">You’ll likely need this <strong class="source-inline1">IsLayerInLayerMask()</strong> check in other classes, so consider creating a new static class for utility methods such as this one that can be used from anywhere in the code base.</p>
<p class="callout">Or, for action on specific<a id="_idIndexMarker813" class="pcalibre1 pcalibre calibre6"/> types, consider adding an <strong class="bold">extension </strong><strong class="bold">method</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods</a>.</p>
<p class="calibre3">Let’s update <code>HandleHealCollision()</code> and use our new utility LayerMask<a id="_idIndexMarker814" class="pcalibre1 pcalibre calibre6"/> check method:</p>
<pre class="source-code">
        private void HandleHealCollision(IHeal heal)
        {
            if (IsLayerInLayerMask(
                gameObject.layer, heal.HealMask))
            {
                ApplyHealing(heal.HealAmount);
            }
        }</pre> <p class="calibre3">Better readability for the win! Don’t forget to return to the <code>HandleDamageCollision()</code> method to refactor the LayerMask evaluation to use the new <code>IsLayerInLayerMask()</code> method too!</p>
<p class="callout-heading">Optimization note | Physics 2D</p>
<p class="callout">We can also control the physics interactions between objects by specifying what collisions are processed by their layer using the physics Layer Collision Matrix (<strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Physics 2D</strong>, select the <strong class="bold">Layer Collision </strong><strong class="bold">Matrix</strong> tab).</p>
<p class="calibre3">In this section, we created our health system that any object in the game can use for receiving damage and healing – it also provides<a id="_idIndexMarker815" class="pcalibre1 pcalibre calibre6"/> a method for handling the final death/destruction of the object. You learned how to use interfaces to tie everything together in an extensible way by not relying on concrete class references.</p>
<p class="calibre3">We haven’t added our new <code>HealthSystem</code> to any of our game’s objects yet. Let’s do that in the next section, starting with the player.</p>
<h1 id="_idParaDest-154" class="calibre5"><a id="_idTextAnchor162" class="pcalibre1 pcalibre calibre6"/>Updating the player and enemy to use health</h1>
<p class="calibre3">Not only <code>Player</code> and enemy objects<a id="_idIndexMarker816" class="pcalibre1 pcalibre calibre6"/> but any object can<a id="_idIndexMarker817" class="pcalibre1 pcalibre calibre6"/> be set up <a id="_idIndexMarker818" class="pcalibre1 pcalibre calibre6"/>to use <code>HealthSystem</code>. It’s barely<a id="_idIndexMarker819" class="pcalibre1 pcalibre calibre6"/> an inconvenience; in fact, the object simply needs to implement the <code>IHaveHealth</code> interface.</p>
<h2 id="_idParaDest-155" class="calibre8"><a id="_idTextAnchor163" class="pcalibre1 pcalibre calibre6"/>Assigning the object with health – IHaveHealth interface</h2>
<p class="calibre3">Back in the health system<a id="_idIndexMarker820" class="pcalibre1 pcalibre calibre6"/> UML diagram (<em class="italic">Figure 8</em><em class="italic">.1</em>), we see at the bottom<a id="_idIndexMarker821" class="pcalibre1 pcalibre calibre6"/> that the object having health will implement<a id="_idIndexMarker822" class="pcalibre1 pcalibre calibre6"/> the <code>IHaveHealth</code> interface (again, some meaningful naming here). Create a new file named <code>IHaveHealth</code> in the <code>Assets/Scripts/Interfaces</code> folder:</p>
<pre class="source-code">
internal interface IHaveHealth
{
    void HealthChanged(int amount);
    void Died();
}</pre> <p class="calibre3">We don’t yet have a class for the <code>Player</code> object, only <code>PlayerController</code>. We don’t want to add health<a id="_idIndexMarker823" class="pcalibre1 pcalibre calibre6"/> to something named <code>controller</code> because it wouldn’t make sense<a id="_idIndexMarker824" class="pcalibre1 pcalibre calibre6"/> considering the single-responsibility<a id="_idIndexMarker825" class="pcalibre1 pcalibre calibre6"/> principle – and the controller’s only concern is movement. Let’s fix that now by creating a script named <code>Player</code> in the <code>Assets/Scripts</code> folder:</p>
<pre class="source-code">
using UnityEngine;
public class Player : MonoBehaviour, IHaveHealth
{
}</pre> <p class="calibre3">Make sure it implements <code>IHaveHealth</code>. You can use the IDE’s refactoring tools again here. <code>IHaveHealth</code> should have the ever-so-helpful red squiggly underline – so, use the IDE refactoring to <em class="italic">implement interface</em> on it, and you will get the following:</p>
<pre class="source-code">
public class Player : MonoBehaviour, IHaveHealth
{
    public void HealthChanged(int amount)
    {
        throw new System.NotImplementedException();
    }
    public void Died()
    {
        throw new System.NotImplementedException();
    }
}</pre> <p class="calibre3">Until we decide what actions to perform for these methods, we’ll leave<a id="_idIndexMarker826" class="pcalibre1 pcalibre calibre6"/> it as is for now. You will get a reminder in the <code>throw</code> indicates an exception has occurred while the program is running – in this case, <code>NotImplementedException: The method or operation is </code><code>not implemented</code>.</p>
<p class="callout-heading">Caution when using throw</p>
<p class="callout">Be warned, however: throwing<a id="_idIndexMarker827" class="pcalibre1 pcalibre calibre6"/> these exceptions will cause program execution in the calling method to stop – meaning any statements that follow <strong class="source-inline1">HealthChanged()</strong> will not be executed! If unsure, replace the <strong class="source-inline1">throw</strong> statements with something such as <strong class="source-inline1">Debug.LogError("Player.HealthChanged() has not </strong><strong class="source-inline1">been implemented!");</strong>.</p>
<p class="calibre3">Do exactly the same for <code>Enemy</code>:</p>
<ol class="calibre14">
<li class="calibre15">Create a new <code>Enemy</code> script in the <code>Assets/Scripts</code> folder.</li>
<li class="calibre15">Add <code>IHaveHealth</code> to the class declaration.</li>
<li class="calibre15">Implement the <code>IHaveHealth</code> interface methods.</li>
</ol>
<p class="calibre3">The last step is to add<a id="_idIndexMarker828" class="pcalibre1 pcalibre calibre6"/> the components<a id="_idIndexMarker829" class="pcalibre1 pcalibre calibre6"/> to their respective <a id="_idIndexMarker830" class="pcalibre1 pcalibre calibre6"/>objects: adding <code>Player</code> to the <code>Player</code> Prefab and <code>Enemy</code> to both enemy Prefabs. Of course, they also both get <code>HealthSystem</code> added, as seen here:</p>
<div><div><img alt="Figure 8.6 – Player and Enemy Prefabs with health" src="img/B18347_08_6.jpg" class="calibre90"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Player and Enemy Prefabs with health</p>
<p class="calibre3">Initial values for max health are just initial values for testing. Playtesting will determine what values they’ll eventually<a id="_idIndexMarker831" class="pcalibre1 pcalibre calibre6"/> land on, depending<a id="_idIndexMarker832" class="pcalibre1 pcalibre calibre6"/> on difficulty and balanced<a id="_idIndexMarker833" class="pcalibre1 pcalibre calibre6"/> gameplay. You got this!</p>
<p class="calibre3">Now that we have objects with health, we have one final part of our <code>HealthSystem</code> in need of completion – processing.</p>
<h2 id="_idParaDest-156" class="calibre8"><a id="_idTextAnchor164" class="pcalibre1 pcalibre calibre6"/>Process changes to health</h2>
<p class="calibre3">To finish up our fully<a id="_idIndexMarker834" class="pcalibre1 pcalibre calibre6"/> functioning <code>HealthSystem</code>, we just need to process the changes to health for our objects that, yeah, have health. Back in our <code>HealthSystem</code> class, add the variable that will hold the reference to the object with health and get the object reference in <code>Awake()</code> using a <code>GetComponent()</code> call:</p>
<pre class="source-code">
public class HealthSystem : MonoBehaviour
{
    …
    private IHaveHealth _objectWithHealth;
    private void Awake()
    {
        …
        _objectWithHealth = GetComponent&lt;IHaveHealth&gt;();
    }</pre> <p class="calibre3">As our future selves now, we’ll revisit<a id="_idIndexMarker835" class="pcalibre1 pcalibre calibre6"/> the <code>HealthChanged()</code> method and squash those final lingering <code>UNDONE</code> token comments! We’ll use a null check (<code>if</code> statement) to ensure we have a sibling component on this GameObject that implements the <code>IHaveHealth</code> interface. We’ll give ourselves a warning in the console if we don’t (and use a <code>return</code> statement as a sort of cancellation not to execute any code that follows), and proceed to process the health change otherwise:</p>
<pre class="source-code">
    private void HealthChanged()
    {
        if (_objectWithHealth == null)
        {
            Debug.LogWarning($"HealthSystem on " +
                $"'{gameObject.name}' requires a " +
                $"sibling component that inherits from " +
                $"IHaveHealth!", gameObject);
            return;
        }
        if (_healthCurrent &gt; 0)
            _objectWithHealth.HealthChanged
                (_healthCurrent);
        else
            _objectWithHealth.Died();
    }</pre> <p class="calibre3">With that, our health system is complete! It allows the addition of health to any object and gives the ability for any object to cause damage or heal without any concrete class references! Interfaces for the win!</p>
<p class="calibre3">We covered much territory creating the health system and wrote lots of code back and forth in several classes, so don’t forget that you can always refer to the completed project code for this chapter on the book’s GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<p class="calibre3">Keeping with our composition pattern, let’s quickly look<a id="_idIndexMarker836" class="pcalibre1 pcalibre calibre6"/> at how we can set up the ability to easily add different behaviors (i.e., components) when interactions with <code>HealthSystem</code> occur.</p>
<h3 class="calibre10">Adding behavior with UnityEvent</h3>
<p class="calibre3">We’ve used <code>UnityEvent</code> before, for<a id="_idIndexMarker837" class="pcalibre1 pcalibre calibre6"/> the <code>TriggeredEvent</code> component<a id="_idIndexMarker838" class="pcalibre1 pcalibre calibre6"/> back in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>. It’s flexible, in that listeners can be registered by code or assigned in the <strong class="bold">Inspector</strong> window (you already know I’m a fan of this one), so it will be a perfect use case for our needs here.</p>
<p class="calibre3">Only a few additions are required to add a <code>UnityEvent</code> instance that will be invoked when we handle the collisions for <code>IDamage</code> and <code>IHeal</code>. Let’s start by adding a method declaration to the interfaces:</p>
<pre class="source-code">
internal interface IDamage
{
    …
    void DoDamage(Collider2D collision, bool isAffected);
}
internal interface IHeal
{
    …
    void DoHeal(GameObject healedObject);
}</pre> <p class="calibre3">As you can see in the differences<a id="_idIndexMarker839" class="pcalibre1 pcalibre calibre6"/> in the declarations, we’ll change things<a id="_idIndexMarker840" class="pcalibre1 pcalibre calibre6"/> up just a bit with each implementation. <code>DoDamage()</code> will pass two parameters for collision and whether the object is affected by the collision (as in, did it just collide or was it affected by the damage?). We can use this bool to alter things such as the visual effect (e.g., small versus a sizeable varying particle effect), where <code>DoHeal()</code> will just pass in the object that is being healed.</p>
<p class="calibre3">Now let’s implement the changes to the interfaces, starting with damage in the <code>ProjectileDamage</code> class. Add the <code>UnityEvent</code> and <code>DoDamage()</code> methods:</p>
<pre class="source-code">
public class ProjectileDamage : MonoBehaviour, IDamage
{
    …
    public UnityEvent&lt;Collider2D, bool&gt; OnDamageEvent;
    public void DoDamage(Collider2D collision,
        bool isAffected)
            =&gt; OnDamageEvent?.Invoke(collision,
                isAffected);
}</pre> <p class="calibre3">Here are the specifics of the implementation coded in the preceding snippet:</p>
<ul class="calibre17">
<li class="calibre15"><code>OnDamageEvent</code>: Declare as a <code>UnityEvent</code> instance with two parameters. <code>Collider2D</code> takes the collision object that can be used to get the intersection position between the objects. And the <code>isAffected</code> value indicates whether or not the damage was applied as a result of the collision - this is from the layer mask evaluation, as we’ll see in a minute.</li>
</ul>
<p class="calibre3">Take notice that we won’t use the <code>event</code> keyword here because it is a <code>UnityEvent</code> instance – it’s not a delegate type but a serializable class. Otherwise, always use the <code>event</code> keyword for your events to enforce the event pattern, where only the implementing class should invoke!</p>
<ul class="calibre17">
<li class="calibre15"><code>DoDamage()</code>: This is the public method called from <code>HandleDamageCollision()</code> when the interaction occurs, and its sole responsibility is to invoke the <code>UnityEvent</code> instance (passing the parameters).</li>
</ul>
<p class="calibre3">And now do the same<a id="_idIndexMarker841" class="pcalibre1 pcalibre calibre6"/> for <code>PickupHeal</code> – implement<a id="_idIndexMarker842" class="pcalibre1 pcalibre calibre6"/> the changes with the interface:</p>
<pre class="source-code">
public class PickupHeal : MonoBehaviour, IHeal
{
    …
    public UnityEvent&lt;GameObject&gt; OnHealEvent;
    public void DoHeal(GameObject healedObject)
        =&gt; OnHealEvent?.Invoke(healedObject);
}</pre> <p class="calibre3">Here is the explanation for these code changes:</p>
<ul class="calibre17">
<li class="calibre15"><code>OnHealEvent</code>: Declared as a <code>UnityEvent</code> instance with one parameter. The <code>GameObject</code> instance is just the object that is affected by the healing. The usage could simply be getting the object’s transform position for instantiating an object or particle effect.</li>
<li class="calibre15"><code>DoHeal()</code>: Just like the damage method, this is a public method called from <code>HandleHealCollision()</code> when the interaction occurs and is also solely responsible for invoking the <code>UnityEvent</code> instance (passing the parameter).</li>
</ul>
<p class="calibre3">The final step is to add<a id="_idIndexMarker843" class="pcalibre1 pcalibre calibre6"/> the public <code>Do</code> calls to<a id="_idIndexMarker844" class="pcalibre1 pcalibre calibre6"/> the <code>HealthSystem.OnTriggerEnter2D()</code> method. Update <code>HandleDamageCollision()</code> like so:</p>
<pre class="source-code">
    internal void HandleDamageCollision
        (Collider2D collision, IDamage damage)
    {
        var isAffected = IsLayerInLayerMask(
            gameObject.layer, damage.DamageMask);
        damage.DoDamage(collision, isAffected);
        if (isAffected)
            TakeDamage(damage.DamageAmount);
    }</pre> <p class="calibre3">We introduced a local bool variable, <code>isAffected</code>, to get the <code>IsLayerInLayerMask()</code> result – we can then use the variable in place of calling <code>IsLayerInLayerMask()</code> multiple times.</p>
<p class="calibre3">We can then just call <code>DoDamage()</code> and only call <code>TakeDamage()</code> if the object is affected by the damaging object.</p>
<p class="calibre3">Now, update <code>HandleHealCollision()</code> like so:</p>
<pre class="source-code">
    private void HandleHealCollision(IHeal heal)
    {
        if (IsLayerInLayerMask(gameObject.layer,
            heal.HealMask))
        {
            heal.DoHeal(gameObject);
            ApplyHealing(heal.HealAmount);
        }
    }</pre> <p class="calibre3">Unlike with damage, we don’t care about the impact of the damaging object having an effect or not. We’ll process healing if it’s in <code>HealMask</code>. We just need to call the public <code>DoHeal()</code> – passing in the object being healed – and we’re done!</p>
<p class="calibre3">Now that we have<a id="_idIndexMarker845" class="pcalibre1 pcalibre calibre6"/> an event <a id="_idIndexMarker846" class="pcalibre1 pcalibre calibre6"/>exposed on the <code>ProjectileDamage</code> and <code>PickupHeal</code> components, let’s refactor an earlier composition for destroying the water diamond pickup. Hence, we have an example of its usage.</p>
<h3 class="calibre10">Re-composition for Destroyer</h3>
<p class="calibre3">With <code>PickupHeal</code> now having a <code>UnityEvent</code> instance triggered<a id="_idIndexMarker847" class="pcalibre1 pcalibre calibre6"/> when the collision occurs, we can improve the composition for destroying the water diamond object when it’s collected. We previously used the <code>TriggeredEvent</code> component, but now we need to assign the <code>Destroyer.DestroyMe()</code> function to the <code>OnHealEvent</code> function selection drop-down menu.</p>
<div><div><img alt="Figure 8.7 – Revising Destroyer" src="img/B18347_08_7.jpg" class="calibre91"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Revising Destroyer</p>
<p class="calibre3">Referring to <em class="italic">Figure 8</em><em class="italic">.7</em>, let’s walk through this change:</p>
<ol class="calibre14">
<li class="calibre15">(<em class="italic">A</em>) – Click the little <code>OnHealEvent</code> tab to add a new listener to the list.</li>
<li class="calibre15">(<em class="italic">B</em>) – Drag the <code>Destroyer</code> component to the object field (using its title area).<ul class="calibre22"><li class="calibre15">In the function selection drop-down menu, select <strong class="bold">Destroyer | </strong><strong class="bold">DestroyMe( )</strong>.</li></ul></li>
<li class="calibre15">(<em class="italic">C</em>) – Right-click on the <code>TriggeredEvent</code> title area to bring up the context menu and select <strong class="bold">Remove Component</strong>.</li>
</ol>
<p class="calibre3">You end up with an <strong class="bold">Inspector</strong> window that looks like the right-most image – you are done. Easy-peasy.</p>
<p class="calibre3">Also, we don’t need to worry about <code>IsTriggeredByPlayer</code> from the <code>TriggeredEvent</code> component anymore since <code>DoHeal()</code> will only be called if the <code>HealMask</code> check is satisfied.</p>
<p class="calibre3">In this section, we have created a fully implemented health system, and that’s a game changer (yes, bad pun). Again, you learned the power of interfaces and how we can quickly add functionality to existing systems. We also practiced composition by refactoring some reusable components<a id="_idIndexMarker848" class="pcalibre1 pcalibre calibre6"/> to explore a different approach to destroying the heal pickup object.</p>
<p class="calibre3">In the next section, let’s put the health system through its paces by having a bunch of pesky enemies to contend with as we introduce a wave spawner.</p>
<h1 id="_idParaDest-157" class="calibre5"><a id="_idTextAnchor165" class="pcalibre1 pcalibre calibre6"/>Enemy wave spawner</h1>
<p class="calibre3">A <strong class="bold">wave spawner</strong> may sound scary, but it’s just a straightforward<a id="_idIndexMarker849" class="pcalibre1 pcalibre calibre6"/> script. We need to instantiate a new enemy<a id="_idIndexMarker850" class="pcalibre1 pcalibre calibre6"/> from a given position and on a fixed (or random) time interval. We’ll also ensure things don’t get out of hand by limiting the number of enemies spawned.</p>
<p class="calibre3">So, with that in mind, let’s have a look at our new <code>EnemySpawner</code> script – create it in the <code>Assets/Scripts</code> folder – and see whether you can point out where the few requirements I just stated have been implemented:</p>
<pre class="source-code">
using UnityEngine;
public class EnemySpawner : MonoBehaviour
{
    [SerializeField] private Enemy _enemyPrefab;
    [SerializeField] private float _spawnInterval = 5f;
    [SerializeField] private int _maxSpawned = 3;
    private int _objectCount = 0;
    private void Start()
        =&gt; InvokeRepeating(
            nameof(SpawnEnemy), 0f, _spawnInterval);
    private void SpawnEnemy()
    {
        if (_objectCount &lt; _maxSpawned)
        {
            var enemy = Instantiate(_enemyPrefab,
                transform.position, Quaternion.identity);
            enemy.Init(DestroyedCallback);
            _objectCount++;
        }
    }
    public void DestroyedCallback() =&gt; _objectCount--;
}</pre> <p class="calibre3">Let’s break this class down – a lot of this should<a id="_idIndexMarker851" class="pcalibre1 pcalibre calibre6"/> be looking very familiar by now:</p>
<ol class="calibre14">
<li class="calibre15">Declare a variable for the enemy Prefab that will be spawned – we use the <code>Enemy</code> type here instead of <code>GameObject</code> because when we reference <code>_enemyPrefab</code> later, we’ll be referencing the <code>Enemy</code> class directly and won’t need to do <code>GetComponent()</code>.</li>
<li class="calibre15">Declare a variable for <code>_spawnInterval</code>, which will be the delay before spawning the next enemy.</li>
<li class="calibre15">Declare a variable for <code>_maxSpawned</code>, which will be the total number of enemies onscreen – from this spawner – at the same time.</li>
<li class="calibre15">Declare a variable for <code>_objectCount</code>, which keeps track of how many enemies are currently spawned.</li>
<li class="calibre15">Create the <code>Start()</code> method – here we’ll simply use <code>InvokeRepeating()</code> to repeatedly call <code>SpawnEnemy()</code> at the specified spawn interval (<code>_spawnInterval</code>).</li>
<li class="calibre15">Create the <code>SpawnEnemy()</code> method – we first check to see whether we’ve already instantiated our <code>_maxSpawned</code> amount of enemies, and, if not, <code>Instantiate()</code> a new <code>Enemy</code>.<ol class="calibre42"><li class="calibre15">We create a new (implicit declaration using <code>var</code>) local <code>enemy</code> variable – returned from the <code>Instantiate()</code> call – so that we can call <code>Init()</code> and pass in a callback parameter (as a pseudo constructor). This is in place of what would usually be the C# constructor (objects created with the <code>new</code> keyword, which, if you remember, we cannot do with <code>MonoBehaviour</code>).</li><li class="calibre15">Increment the number of spawned objects with <code>_objectCount++</code>.</li></ol></li>
<li class="calibre15">Define the <code>DestroyedCallback()</code> method passed into the <code>Enemy.Init()</code> call so that, when the enemy object is destroyed, the currently spawned enemy count can be decreased – resulting in the spawner instantiating another enemy to maintain the <code>_maxSpawned</code> count.</li>
</ol>
<p class="callout-heading">Don’t forget about object pooling!</p>
<p class="callout">Note that if we have waves<a id="_idIndexMarker852" class="pcalibre1 pcalibre calibre6"/> and waves of many enemies, we do want to optimize this by introducing object pooling. Refer back to <a href="B18347_06.xhtml#_idTextAnchor116" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>.</p>
<p class="calibre3">We’ll have to tie <code>DestroyedCallback</code> to the <code>Enemy</code> class because<a id="_idIndexMarker853" class="pcalibre1 pcalibre calibre6"/> it’s passed to the instantiated enemy object via the <code>enemy.Init()</code> call. Let’s add everything to support that now; it’s not much, so open the <code>Enemy</code> script and add the following:</p>
<pre class="source-code">
public class Enemy : MonoBehaviour, IHaveHealth
{
    private event UnityAction _onDestroyed;
    internal void Init(UnityAction destroyedCallback)
        =&gt; _onDestroyed = destroyedCallback;
    private void OnDestroy()
        =&gt; _onDestroyed?.Invoke();
    …</pre> <p class="calibre3">Here we have a <code>UnityAction</code> instance that we’ll use to invoke the callback when the enemy object is destroyed – you’ve seen all this before.</p>
<p class="calibre3">We just need to actually destroy the enemy object, and we do that when the object dies, as dictated by the <code>IhaveHealth</code>-interface-implemented <code>Died()</code> method:</p>
<pre class="source-code">
    public void Died() =&gt; Destroy(gameObject);</pre> <p class="calibre3">A note about <code>DestroyedCallback</code> and why we don’t have to <em class="italic">unregister from the event</em> when enemy is destroyed: the responsibility is being flipped here since <code>EnemySpawner</code> is not holding a reference to the instantiated enemy object. You only need to unregister (or <code>RemoveListener</code>) from events<a id="_idIndexMarker854" class="pcalibre1 pcalibre calibre6"/> that can become invalid references.</p>
<p class="calibre3">Let’s set up a Prefab we can reuse as a preconfigured enemy spawner.</p>
<h2 id="_idParaDest-158" class="calibre8"><a id="_idTextAnchor166" class="pcalibre1 pcalibre calibre6"/>Creating the enemy spawner Prefab</h2>
<p class="calibre3">Go ahead and, in your current<a id="_idIndexMarker855" class="pcalibre1 pcalibre calibre6"/> open scene in Unity, create a new empty GameObject in the <code>EnemyB Spawner 1</code> – we can have different Prefabs for different enemy spawning behaviors. Make sure to place it right at ground level in your environment because the spawner’s transform position will be used as the enemy instantiation point. Add the <code>EnemySpawner</code> component to the <code>EnemyB</code><code>Spawner 1</code> object and drag in the <code>EnemyB</code> Prefab from the <code>Assets/Prefabs</code> folder to the <strong class="bold">Enemy Prefab</strong> field, as seen in <em class="italic">Figure 8</em><em class="italic">.8</em>.</p>
<div><div><img alt="Figure 8.8 – Enemy spawner setup" src="img/B18347_08_8.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Enemy spawner setup</p>
<p class="calibre3">Finish up by dragging the <code>EnemyB Spawner 1</code> object in the <code>Assets/Prefabs</code> folder. Yay!</p>
<p class="calibre3">If you playtest the enemy wave spawner now, they’ll just spawn on top of one another, be disorganized, and not go anywhere – in other words, not acting<a id="_idIndexMarker856" class="pcalibre1 pcalibre calibre6"/> like robots at all. Let’s integrate spawning with the patrolling behavior to keep things orderly.</p>
<h2 id="_idParaDest-159" class="calibre8"><a id="_idTextAnchor167" class="pcalibre1 pcalibre calibre6"/>Integrating spawning with patrol behavior</h2>
<p class="calibre3">If you haven’t picked up<a id="_idIndexMarker857" class="pcalibre1 pcalibre calibre6"/> on it already, because we’ve paid attention<a id="_idIndexMarker858" class="pcalibre1 pcalibre calibre6"/> to the project’s code structure and followed good programming practices from the beginning, maintaining and extending the code to add new functionality has been simple and straightforward. Integrating our new wave spawner to work with the existing patrol behavior will also be quick work. We’ll just need to add a few things to set it up.</p>
<p class="calibre3">First things first, let’s see if the instantiated <code>Enemy B</code> Prefab has a patrol behavior and, if so, <code>SetWaypoints()</code>. To do that, let’s modify the <code>SpawnEnemy()</code> method in the <code>EnemySpawner</code> class. Here you can see we’re again using <code>TryGetComponent()</code> to fail gracefully if the component doesn’t exist on the enemy:</p>
<pre class="source-code">
    private void SpawnEnemy()
    {
        if (_objectCount &lt; _maxSpawned)
        {
            …
            if (enemy.TryGetComponent
                &lt;IBehaviorPatrolWaypoints&gt;(out var patrol))
                    patrol.SetWaypoints(
                        _waypointPatrolLeft,
                        _waypointPatrolRight);
        }</pre> <p class="calibre3">In the <code>PatrolWaypoints</code> class, add the following <code>SetWaypoints()</code> method (or, again, use the IDE’s refactoring tools to generate it) to allow setting the left and right waypoint private variables externally (encapsulation at work):</p>
<pre class="source-code">
    public void SetWaypoints(
        Transform left,
        Transform right)
    {
        _waypointPatrolLeft = left;
        _waypointPatrolRight = right;
    }</pre> <p class="calibre3">And, don’t forget: we’ll need to add a <code>SetWaypoints()</code> method declaration to our <code>IBehaviorPatrolWaypoints</code> interface so that it’s accessible from the reference in the <code>EnemySpawner</code> class:</p>
<pre class="source-code">
public interface IBehaviorPatrolWaypoints
{
    …
    void SetWaypoints(Transform left, Transform right);
}</pre> <p class="calibre3">Seriously, that’s it – three simple additions<a id="_idIndexMarker859" class="pcalibre1 pcalibre calibre6"/> get the patrolling behavior<a id="_idIndexMarker860" class="pcalibre1 pcalibre calibre6"/> all wired up to our enemy spawner. You’ll just have to add two empty GameObjects to the scene for the patrolling path of this enemy spawner, one for left and one for right, and assign them in the <strong class="bold">Inspector</strong> window, as seen in the enemy spawner setup from <em class="italic">Figure 8</em><em class="italic">.8</em>.</p>
<p class="calibre3">However, you’ll notice we have a problem (you playtested, right?). Enemies won’t be able to pass each other as they patrol between the waypoints – a simple problem to solve by removing their physics interactions with each other. First, we’ll need a layer to set the enemy objects to… how about <code>Enemy</code>?</p>
<p class="calibre3">Using the <strong class="bold">Layers</strong> drop-down menu in the top-right corner of the <strong class="bold">Editor</strong> window, select <strong class="bold">Edit Layers…</strong>.</p>
<div><div><img alt="Figure 8.9 – Add an enemy layer" src="img/B18347_08_9.jpg" class="calibre92"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Add an enemy layer</p>
<p class="calibre3">Under the <code>Enemy</code> to add it.</p>
<p class="calibre3">Now we can control the physics<a id="_idIndexMarker861" class="pcalibre1 pcalibre calibre6"/> interactions between enemy<a id="_idIndexMarker862" class="pcalibre1 pcalibre calibre6"/> objects by specifying what collisions<a id="_idIndexMarker863" class="pcalibre1 pcalibre calibre6"/> are processed by their layer. Using the <code>Enemy</code> layer (uncheck <strong class="bold">Enemy/Enemy</strong>):</p>
<div><div><img alt="Figure 8.10 – Physics 2D layer collision matrix" src="img/B18347_08_10.jpg" class="calibre93"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Physics 2D layer collision matrix</p>
<p class="calibre3">When you playtest the enemy wave spawner in the scene now, the spawned enemies will patrol past one another. Awesome!</p>
<p class="calibre3">In this section, we created a wave spawner<a id="_idIndexMarker864" class="pcalibre1 pcalibre calibre6"/> to instantiate new enemies<a id="_idIndexMarker865" class="pcalibre1 pcalibre calibre6"/> on a fixed time interval and integrated it with the existing patrol behavior. We finished up by resolving physics interactions between enemy objects to allow them to pass each other while patrolling.</p>
<h1 id="_idParaDest-160" class="calibre5"><a id="_idTextAnchor168" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we covered the implementation of a health system that any object in the game can use to receive damage, heal, and handle the final death/destruction of the object. This system was designed using interfaces to tie everything together in an extensible way without relying on concrete class references – the flexibility of interfaces allowed for the quick addition of new functionality to our existing code.</p>
<p class="calibre3">We continued by creating a wave spawner that instantiates new enemies on a fixed time interval and integrates with the existing patrol behavior. This allows for adding in more complex enemy behavior, which adds new challenges to the game. Additionally, we discussed how to disable physics interactions between objects, which allowed patrolling enemies to pass each other in this case.</p>
<p class="calibre3">Finally, we further explored composition by refactoring some of our reusable components to explore a different approach to destroying the heal pickup object. Through examples such as this, the importance of good programming practices and the use of interfaces to build flexible and extensible systems was highlighted.</p>
<p class="calibre3">In the next chapter, we’ll complete the adventure game by creating a simple quest system for collecting key objects for solving the entryway puzzle. We will also introduce a new event system for keeping our code loosely coupled.</p>
</div>
</div></body></html>