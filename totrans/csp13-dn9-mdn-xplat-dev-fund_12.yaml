- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Modern Web Development Using .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third and final part of this book is about modern web development using
    .NET, which means ASP.NET Core, Blazor, and Minimal APIs. You will learn how to
    build cross-platform projects such as websites and web services.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft call platforms for building applications **app models** or **workloads**.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you work through this and subsequent chapters sequentially
    because later chapters will reference projects in earlier chapters, and you will
    build up sufficient knowledge and skills to tackle the trickier problems in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features in ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an entity model for use in the rest of the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this book is about C# and .NET, we will learn about app models that are
    used to build the practical applications that we will encounter in the remaining
    chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: Microsoft has extensive guidance for implementing app
    models in its *.NET Architecture Guides* documentation, which you can read at
    the following link: [https://dotnet.microsoft.com/en-us/learn/dotnet/architecture-guides](https://dotnet.microsoft.com/en-us/learn/dotnet/architecture-guides).'
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core is part of a history of evolving Microsoft technologies used to
    build websites and services that work with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ActiveX Data Objects (ADO)** was released in 1996 and was Microsoft’s attempt
    to provide a single set of **Component Object Model** (**COM**) components to
    work with data. With the release of .NET, an equivalent was created named **ADO.NET**,
    which is still the faster method to work with data in .NET, with its core classes,
    `DbConnection`, `DbCommand`, and `DbDataReader`. **ORMs (Object-Relational Mappers)**
    like EF Core use ADO.NET internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active Server Pages** (**ASP**) was released in 1996 and was Microsoft’s
    first attempt at a platform for dynamic server-side execution of website code.
    ASP files contain a mix of HTML and code that executes on the server, written
    in the VBScript language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET Web Forms** was released in 2002 with the .NET Framework and was
    designed to enable non-web developers, such as those familiar with Visual Basic,
    to quickly create websites by dragging and dropping visual components and writing
    event-driven code in Visual Basic or C#. Web Forms should be avoided in new .NET
    Framework web projects in favor of ASP.NET MVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Communication Foundation** (**WCF**) was released in 2006 and enables
    developers to build SOAP and REST services. SOAP is powerful but complex, so it
    should be avoided unless you need advanced features, such as distributed transactions
    and complex messaging topologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET MVC** was released in 2009 to cleanly separate the concerns of web
    developers between **models**, which temporarily store the data; **views**, which
    present data using various formats in the UI; and **controllers**, which fetch
    a model and pass it to a view. This separation enables improved reuse and unit
    testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET Web API** was released in 2012 and enables developers to create HTTP
    services (aka REST services) that are simpler and more scalable than SOAP services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET SignalR** was released in 2013 and enables real-time communication
    for websites by abstracting underlying technologies and techniques, such as WebSockets
    and long polling. This enables website features, such as live chat, and updates
    to time-sensitive data, such as stock prices, across a wide variety of web browsers,
    even when they do not support an underlying technology, such as WebSockets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET Core** was released in 2016 and combines modern implementations of
    .NET Framework technologies, such as MVC, Web API, and SignalR, with alternative
    technologies, such as Razor Pages, gRPC, and Blazor, all running on modern .NET.
    Therefore, ASP.NET Core can execute across platforms. ASP.NET Core has many project
    templates to get you started with its supported technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Choose ASP.NET Core to develop websites and web services
    because it includes web-related technologies that are modern and cross-platform.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Classic ASP.NET versus modern ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until modern .NET, ASP.NET was built on top of a large assembly in .NET Framework,
    named `System.Web.dll`, and it was tightly coupled to Microsoft’s Windows-only
    web server, named **Internet Information Services** (**IIS**). Over the years,
    this assembly has accumulated a lot of features, many of which are not suitable
    for modern cross-platform development.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core is a major redesign of ASP.NET. It removes the dependency on the
    `System.Web.dll` assembly and IIS and is composed of modular lightweight packages,
    just like the rest of modern .NET. Using IIS as the web server is still supported
    by ASP.NET Core, but there is a better option.
  prefs: []
  type: TYPE_NORMAL
- en: You can develop and run ASP.NET Core applications across platforms on Windows,
    macOS, and Linux. Microsoft has even created a cross-platform, super-performant
    web server, named **Kestrel**, and the entire stack is open source.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 2.2 or later projects default to the new in-process hosting model.
    This gives a 400% performance improvement when hosting in Microsoft IIS, but Microsoft
    still recommends using Kestrel for even better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Building websites using ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Websites are made up of multiple web pages, loaded statically from the filesystem
    or generated dynamically by a server-side technology, such as ASP.NET Core. A
    web browser makes `GET` requests using **Unique Resource Locators** (**URLs**)
    that identify each page and can manipulate data stored on the server, using `POST`,
    `PUT`, and `DELETE` requests.
  prefs: []
  type: TYPE_NORMAL
- en: With many websites, the web browser is treated as a presentation layer, with
    almost all the processing performed on the server side. Some JavaScript might
    be used on the client side to implement form validation warnings and some presentation
    features, such as carousels.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides multiple technologies to build the user interface for
    websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ASP.NET Core Razor Pages** is a simple way to dynamically generate HTML for
    simple websites. I recommend considering this as a legacy technology and using
    Blazor instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET Core MVC** is an implementation of the **Model-View-Controller**
    (**MVC**) design pattern that is popular for developing complex websites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blazor** lets you build user interface components using C# and .NET instead
    of a JavaScript-based UI framework, like Angular, React, and Vue. Early versions
    of Blazor required a developer to choose a **hosting model**. The **Blazor WebAssembly**
    hosting model runs your code in the browser like a JavaScript-based framework
    would. The **Blazor Server** hosting model runs your code on the server and updates
    the web page dynamically. .NET 8 introduced a unified, full-stack hosting model
    that allows individual components to execute either on the server or client side,
    or even adapt dynamically at runtime. You will learn about Blazor in detail in
    *Chapter 14*, *Building Interactive Web Components Using Blazor*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, which should you choose?
  prefs: []
  type: TYPE_NORMAL
- en: “Blazor is now our recommended approach for building web UI with ASP.NET Core,
    but neither MVC nor Razor Pages are now obsolete. Both MVC & Razor Pages are mature,
    fully supported, and widely used frameworks that we plan to support for the foreseeable
    future. There is also no requirement or guidance to migrate existing MVC or Razor
    Pages apps to Blazor. For existing, well-established MVC-based projects, continuing
    to develop with MVC is a perfectly valid and reasonable approach.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Dan Roth
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can see Dan’s original comment post at the following link: [https://github.com/dotnet/aspnetcore/issues/51834#issuecomment-1913282747](https://github.com/dotnet/aspnetcore/issues/51834#issuecomment-1913282747).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dan Roth is the principal product manager at ASP.NET, so he knows the future
    of ASP.NET Core better than anyone else: [https://devblogs.microsoft.com/dotnet/author/danroth27/](https://devblogs.microsoft.com/dotnet/author/danroth27/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I agree with the quote by Dan Roth. For me, there are two main choices for
    web development:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For websites or web services using modern web development: Choose Blazor for
    the web user interface and Minimal APIs for the web service. These technologies
    are covered in this book and its companion book, *Apps and Services with .NET
    8*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For websites or web services using mature and proven web development: Choose
    controller-based ASP.NET Core MVC for the web user interface and Web API for the
    web service. For even more productivity, you can add third-party platforms on
    top of those, for example, a .NET CMS like Umbraco. These technologies are covered
    in my new companion book, *Real-World Web Development with .NET 9*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Much of ASP.NET Core is shared across all these choices anyway, so you will
    only need to learn those shared components once, as shown in *Figure 12.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Modern or controller-based and shared ASP.NET Core components'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of file types used in ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is useful to summarize the file types used by these technologies because
    they are similar but different. If you do not understand some subtle but important
    differences, it can cause much confusion when trying to implement your own projects.
    Please note the differences in *Table 12.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Technology** | **Special filename** | **File extension** | **Directive**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Razor Component (Blazor) |  | `.razor` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Razor Component (Blazor with page routing) |  | `.razor` | `@page "<path>"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Razor Component Imports (Blazor) | `_Imports` | `.razor` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Razor Page |  | `.cshtml` | `@page` |'
  prefs: []
  type: TYPE_TB
- en: '| Razor View (MVC) |  | `.cshtml` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Razor Layout |  | `.cshtml` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Razor View Start | `_ViewStart` | `.cshtml` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Razor View Imports | `_ViewImports` | `.cshtml` |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.1: Comparison of file types used in ASP.NET Core'
  prefs: []
  type: TYPE_NORMAL
- en: Directives like `@page` are added to the top of a file’s contents.
  prefs: []
  type: TYPE_NORMAL
- en: If a file does not have a special filename, then it can be named anything. For
    example, you might create a Razor component for use in a Blazor project, named
    `Customer.razor`, or you might create a Razor layout for use in an MVC or Razor
    Pages project, named `_MobileLayout.cshtml`.
  prefs: []
  type: TYPE_NORMAL
- en: The naming convention for shared Razor files, like layouts and partial views,
    is to prefix with an underscore, `_`. For example, `_ViewStart.cshtml`, `_Layout.cshtml`,
    or `_Product.cshtml` (this might be a partial view for rendering a product).
  prefs: []
  type: TYPE_NORMAL
- en: 'A Razor layout file like `_MyCustomLayout.cshtml` is identical to a Razor view.
    What makes the file a layout is being set as the `Layout` property of another
    Razor file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning!** Be careful to use the correct file extension and directive at
    the top of the file; otherwise, you will get unexpected behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Building websites using a content management system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most websites have a lot of content, and if developers had to be involved every
    time some content needed to be changed, that would not scale well.
  prefs: []
  type: TYPE_NORMAL
- en: A **Content Management System** (**CMS**) enables developers to define content
    structure and templates to provide consistency and good design, while making it
    easy for a non-technical content owner to manage the actual content. They can
    create new pages or blocks of content and update existing content, knowing that
    it will look great for visitors with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: There are a multitude of CMSs available for all web platforms, like WordPress
    for PHP or Django for Python. CMSs that support modern .NET include Optimizely
    Content Cloud, Umbraco, Piranha, and Orchard Core.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit of using a CMS is that it provides a friendly content management
    user interface. Content owners log in to the website and manage the content themselves.
    The content is then rendered and returned to visitors using ASP.NET Core MVC controllers
    and views, or via web service endpoints, known as a **headless CMS**, to provide
    that content to “heads” implemented as mobile or desktop apps, in-store touchpoints,
    or clients built with JavaScript frameworks or Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book does not cover .NET CMSs, so I have included links where you can
    learn more about them in the GitHub repository: [https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#net-content-management-systems](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#net-content-management-systems).
    I also cover Umbraco CMS in my new book, *Real-World Web Development with .NET
    9*.'
  prefs: []
  type: TYPE_NORMAL
- en: Building web applications using SPA frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web applications are often built using technologies known as **Single-Page Application**
    (**SPA**) frameworks, such as Blazor, Angular, React, Vue, or a proprietary JavaScript
    library.
  prefs: []
  type: TYPE_NORMAL
- en: They can make requests to a backend web service to get more data when needed
    and post updated data using common serialization formats, such as XML and JSON.
    The canonical examples are Google web apps, like Gmail, Maps, and Docs.
  prefs: []
  type: TYPE_NORMAL
- en: With a web application, the client side uses JavaScript frameworks or Blazor
    to implement sophisticated user interactions, but most of the important processing
    and data access still happens on the server side, as the web browser has limited
    access to local system resources.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is loosely typed and not designed for complex projects, so most JavaScript
    libraries these days use TypeScript, which adds strong typing to JavaScript and
    is designed with many modern language features to handle complex implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET SDK has project templates for JavaScript and TypeScript-based SPAs,
    but we will not spend any time learning how to build JavaScript and TypeScript-based
    SPAs in this book. Even though these SPAs are commonly used with ASP.NET Core
    as the backend, the focus of this book is on C# and not on other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, C# and .NET can be used on both the server side and the client
    side to build websites, as shown in *Figure 12.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_12_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The use of C# and .NET to build websites on both the server side
    and client side'
  prefs: []
  type: TYPE_NORMAL
- en: Building web and other services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we will not learn about JavaScript and TypeScript-based SPAs, we will
    learn how to build a web service using **ASP.NET Core Minimal API**, and then
    we will call that web service from Blazor components.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no formal definitions, but services are sometimes described based
    on their complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service**: All functionality needed by a client app in one monolithic service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice**: Multiple services that each focus on a smaller set of functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nanoservice**: A single function provided as a service. Unlike services and
    microservices that are hosted 24/7/365, nanoservices are often inactive until
    called upon to reduce resources and costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the start of the first part of this book, we briefly reviewed C# language
    features and in which versions they were introduced. At the start of the second
    part of this book, we briefly reviewed .NET library features and in which versions
    they were introduced. Now, in the third and final part of this book, we will briefly
    review ASP.NET Core features and in which versions they were introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read this information in the GitHub repository at the following link:
    [https://github.com/markjprice/cs13net9/blob/main/docs/ch12-features.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch12-features.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize what’s new in ASP.NET Core 9, let’s end this section with another
    quote from Dan Roth:'
  prefs: []
  type: TYPE_NORMAL
- en: “We’re optimizing how the .NET runtime on WebAssembly initializes so that you
    start up faster and we’re making Blazor’s initialization logic more efficient
    by leveraging source generation for JSON serialization. We’re also optimizing
    how static web assets are handled for all ASP.NET Core apps so that your files
    are pre-compressed as part of publishing your app. For API developers we’re providing
    built-in support for OpenAPI document generation.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Dan Roth
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Building desktop and mobile apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this book is about modern cross-platform development using C# and .NET,
    it does not include coverage of building desktop apps using **Windows Forms**,
    **Windows Presentation Foundation (WPF)**, or **WinUI 3** apps because they are
    Windows-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to build apps for Windows, then the following links will be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Official documentation to get started building apps for Windows: [https://learn.microsoft.com/en-us/windows/apps/get-started/](https://learn.microsoft.com/en-us/windows/apps/get-started/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Is WPF Dead?: [https://avaloniaui.net/Blog/is-wpf-dead](https://avaloniaui.net/Blog/is-wpf-dead)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How popular is WPF compared to WinUI , MAUI in 2024?: [https://twitter.com/DrAndrewBT/status/1759557538805108860](https://twitter.com/DrAndrewBT/status/1759557538805108860)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WinForms in a 64-Bit world – our strategy going forward: [https://devblogs.microsoft.com/dotnet/winforms-designer-64-bit-path-forward/](https://devblogs.microsoft.com/dotnet/winforms-designer-64-bit-path-forward/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile app platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two major mobile platforms, Apple’s iOS and Google’s Android, each
    with its own programming languages and platform APIs. There are also two major
    desktop platforms, Apple’s macOS and Microsoft’s Windows, each with its own programming
    languages and platform APIs, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iOS**: Objective C or Swift and UIKit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android**: Java or Kotlin and Android API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**macOS**: Objective C or Swift and AppKit or Catalyst'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**: C, C++, or many other languages, and Win32 API or Windows App
    SDK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there are so many combinations to learn to do native mobile development,
    it would be useful if there were a single technology that could target all those
    mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cross-platform mobile and desktop apps can be built once for the **.NET Multi-platform
    App User Interfaces (MAUI)** platform, and then they can run on many mobile and
    desktop platforms.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI makes it easy to develop those apps by sharing user interface components
    as well as business logic. They can target the same .NET APIs as used by console
    apps, websites, and web services. The apps will be executed by the Mono runtime
    on mobile devices and the CoreCLR runtime on desktop devices. The Mono runtime
    is better optimized for mobile devices compared to the normal .NET CoreCLR runtime.
    Blazor WebAssembly also uses the Mono runtime because, like a mobile app, it is
    resource-constrained.
  prefs: []
  type: TYPE_NORMAL
- en: The apps can exist on their own, but they usually call services to provide an
    experience that spans all your computing devices, from servers and laptops to
    phones and gaming systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'I introduce .NET MAUI in my companion book, *Apps and Services with .NET 8*,
    and Packt has many other books that go much deeper into .NET MAUI, so if you’re
    serious about learning MAUI, please take a look at the following Packt books:'
  prefs: []
  type: TYPE_NORMAL
- en: '*.NET MAUI Cross-Platform Application Development*: [https://www.packtpub.com/en-us/product/net-maui-cross-platform-application-development-9781835080597](https://www.packtpub.com/en-us/product/net-maui-cross-platform-application-development-9781835080597)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The MVVM Pattern in .NET MAUI*: [https://www.packtpub.com/en-us/product/the-mvvm-pattern-in-net-maui-9781805125006](https://www.packtpub.com/en-us/product/the-mvvm-pattern-in-net-maui-9781805125006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET MAUI Projects*: [https://www.packtpub.com/en-us/product/net-maui-projects-9781837634910](https://www.packtpub.com/en-us/product/net-maui-projects-9781837634910)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before Microsoft created .NET MAUI, third parties created open source initiatives
    to enable .NET developers to build cross-platform apps using XAML, named **Uno**
    and **Avalonia**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** I have not tried Uno or Avalonia myself for any real-world projects,
    so I cannot give an evidence-based recommendation for either of them. I mention
    them in this book just to make you aware of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Uno platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Uno is an *“Open-source platform for building single codebase native mobile,
    web, desktop and embedded apps quickly”*, as stated on their website, found at
    the following link: [https://platform.uno/](https://platform.uno/).'
  prefs: []
  type: TYPE_NORMAL
- en: Developers can reuse 99% of the business logic and UI layer across native mobile,
    web, and desktop.
  prefs: []
  type: TYPE_NORMAL
- en: The Uno platform uses the Xamarin native platform but *not* Xamarin.Forms. For
    WebAssembly, Uno uses the Mono-WASM runtime. For Linux, Uno uses Skia to draw
    the user interface on canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Avalonia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Avalonia is an *“open source framework for building beautiful, cross-platform
    applications from a single .NET codebase”*, as stated on their website, found
    at the following link: [https://avaloniaui.net/](https://avaloniaui.net/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of Avalonia as a spiritual successor to WPF. WPF, Silverlight,
    and UWP developers familiar with WPF can continue to benefit from their years
    of pre-existing knowledge and skills.
  prefs: []
  type: TYPE_NORMAL
- en: It was used by JetBrains to modernize their WPF-based tools and make them cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: The Avalonia extension for Visual Studio and deep integration with Rider make
    development easier and more productive.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How should you structure your projects? So far, we have mostly built small individual
    console apps to illustrate language or library features, with the occasional class
    library and unit test project to support them. In the rest of this book, we will
    build multiple projects using different technologies that work together to provide
    a single solution.
  prefs: []
  type: TYPE_NORMAL
- en: With large, complex solutions, it can be difficult to navigate through all the
    code. So the primary reason to structure your projects is to make it easier to
    find components. It is good to have an overall name for your solution that reflects
    the application or solution.
  prefs: []
  type: TYPE_NORMAL
- en: We will build multiple projects for a fictional company named **Northwind**.
    We will name the solution `ModernWeb` and use the name `Northwind` as a prefix
    for all the project names.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to structure and name projects and solutions, for example,
    using a folder hierarchy as well as a naming convention. If you work in a team,
    make sure you know how your team does it.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring projects in a solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is good to have a naming convention for your projects in a solution so that
    any developer can tell what each one does instantly. A common choice is to use
    the type of project, for example, class library, console app, website, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Since you might want to run multiple web projects at the same time and they
    will be hosted on a local web server, we need to differentiate each project by
    assigning different port numbers for their endpoints, for both HTTP and HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly assigned local port numbers are `5000` for HTTP and `5001` for HTTPS.
    We will use a numbering convention of `5<chapter>0` for HTTP and `5<chapter>1`
    for HTTPS. For example, for a website project we will create in *Chapter 13*,
    we will assign `5130` to HTTP and `5131` to HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will, therefore, use the following project names and port numbers, as shown
    in *Table 12.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Ports** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Common` | N/A | A class library project for common types, like
    interfaces, enums, classes, records, and structs, used across multiple projects.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.EntityModels` | N/A | A class library project for common EF Core
    entity models. Entity models are often used on both the server side and client
    side, so it is best to separate dependencies on specific database providers. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.DataContext` | N/A | A class library project for the EF Core database
    context, with dependencies on specific database providers. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.UnitTests` | N/A | An xUnit test project for the solution. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Web` | `http` `5130` and`https` `5131` | An ASP.NET Core project
    for a simple website that uses a mixture of static HTML files and Blazor Static
    **Server-Side Rendering** (**SSR**). |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Blazor` | `http` `5140` and`https` `5141` | An ASP.NET Core Blazor
    project. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.WebApi` | `http` `5150` and`https` `5151` | An ASP.NET Core project
    for a web API, aka an HTTP service. A good choice for integrating with websites
    because it can use any JavaScript library or Blazor to interact with the service.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.2: Example project names for various project types'
  prefs: []
  type: TYPE_NORMAL
- en: Central package management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all previous projects in this book, if we needed to reference a NuGet package,
    we included the reference to the package name and version directly in the project
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Central Package Management (CPM)** is a feature that simplifies the management
    of NuGet package versions across multiple projects within a solution. This is
    particularly useful for large solutions with many projects, where managing package
    versions individually can become cumbersome and error-prone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key features and benefits of CPM include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized Control**: CPM allows you to define package versions in a single
    file, typically `Directory.Packages.props`, which is placed in the root directory
    of your solution. This file centralizes the version information for all NuGet
    packages used across the projects in your solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: It ensures consistent package versions across multiple projects.
    By having a single source of truth for package versions, CPM eliminates discrepancies
    that can occur when different projects specify different versions of the same
    package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified Updates**: Updating a package version in a large solution becomes
    straightforward. You update the version in the central file, and all projects
    referencing that package automatically use the updated version. This significantly
    reduces the maintenance overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced Redundancy**: It removes the need to specify package versions in
    individual project files (`.csproj`). This makes project files cleaner and easier
    to manage, as they no longer contain repetitive version information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s set up CPM for a solution that we will use throughout the rest of the
    chapters in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `cs13net9` folder, create a new folder named `ModernWeb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ModernWeb` folder, create a new file named `Directory.Packages.props`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Directory.Packages.props`, modify its contents, as shown in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** The `<ManagePackageVersionsCentrally>` element and its `true`
    value must go all on one line. Also, you cannot use floating wildcard version
    numbers, like `10.0-*`, as you can in an individual project, to always get the
    latest patch version of EF Core 10 during previews automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For any projects that we add underneath the folder containing this file, we
    can reference the packages without explicitly specifying the version, as shown
    in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should regularly review and update the package versions in the `Directory.Packages.props`
    file to ensure that you are using the latest stable releases, with important bug
    fixes and performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you set a monthly event in your calendar for the second Wednesday
    of each month. This will occur after the second Tuesday of each month, which is
    Patch Tuesday, when Microsoft releases bug fixes and patches for .NET and related
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in mid-December 2024, there are likely to be new versions, so
    you can go to the NuGet page for all your packages and then update the versions
    if necessary, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before updating package versions, check for any breaking changes in the release
    notes of the packages. Test your solution thoroughly after updating to ensure
    compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Educate your team, and document the purpose and usage of the `Directory.Packages.props`
    file to ensure that everyone understands how to manage package versions centrally.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can override an individual package version by using the `VersionOverride`
    attribute on a `<PackageReference />` element, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful if a newer version introduces a regression bug.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about CPM at the following link: [https://learn.microsoft.com/en-us/nuget/consume-packages/central-package-management](https://learn.microsoft.com/en-us/nuget/consume-packages/central-package-management).'
  prefs: []
  type: TYPE_NORMAL
- en: Building an entity model for use in the rest of the book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Websites and web services usually need to work with data in a relational database
    or another data store. In this section, we will define an entity data model for
    the Northwind database stored in SQL Server or SQLite. It will be used in most
    of the apps that we create in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Northwind database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script files to create the Northwind database for SQLite and SQL Server
    are different. The script for SQL Server creates 13 tables as well as related
    views and stored procedures. The script for SQLite is a simplified version that
    only creates 10 tables because SQLite does not support as many features. The main
    projects in this book only need those 10 tables, so you can complete every task
    in this book with either database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL scripts are found at the following link: [https://github.com/markjprice/cs13net9/tree/main/scripts/sql-scripts](https://github.com/markjprice/cs13net9/tree/main/scripts/sql-scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple SQL scripts to choose from, as described in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Northwind4Sqlite.sql` script: To use SQLite on a local Windows, macOS, or
    Linux computer. This script could probably also be used for other SQL systems,
    like PostgreSQL or MySQL, but has not been tested for use with those!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Northwind4SqlServer.sql` script: To use SQL Server on a local Windows computer.
    The script checks if the Northwind database already exists, and if the database
    does exists, then it drops (aka deletes) the database before recreating it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Northwind4AzureSqlDatabaseCloud.sql` script: To use SQL Server with an Azure
    SQL Database resource created in the Azure cloud. These resources cost money as
    long as they exist! The script does not drop or create the Northwind database
    because you should manually create the Northwind database using the Azure portal
    user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Northwind4AzureSqlEdgeDocker.sql` script: To use SQL Server on a local computer
    in Docker. The script creates the Northwind database. It does not drop it if it
    already exists because the Docker container should be empty anyway, as a fresh
    one will be spun up each time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions to install SQLite can be found in *Chapter 10*, *Working with Data
    Using Entity Framework Core*. In that chapter, you will also find instructions
    for installing the `dotnet-ef` tool, which you will use to scaffold an entity
    model from an existing database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions to install SQL Server Developer Edition (free) on your local Windows
    computer can be found in the GitHub repository for this book at the following
    link: [https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions to set up Azure SQL Edge in Docker for Windows, macOS, or Linux
    can be found in the GitHub repository for this book at the following link: [https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/sql-edge.md](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/sql-edge.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library for entity models using SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now define entity data models in a class library so that they can be
    reused in other types of projects, including client-side app models.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You should create a separate class library project for your
    entity data models from the class library for your data context. This allows easier
    sharing of the entity models between backend web servers and frontend desktop,
    mobile, and Blazor clients, and only the backend needs to reference the data context
    class library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will automatically generate some entity models using the EF Core command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project and solution, as defined
    in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.EntityModels.Sqlite`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `ModernWeb`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Northwind.EntityModels.Sqlite` project, add package references for
    the SQLite database provider and EF Core design-time support, as shown in the
    following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the `Class1.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `Northwind.EntityModels.Sqlite` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Northwind4Sqlite.sql` file into the `ModernWeb` solution folder (not
    the project folder!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal in the `ModernWeb` folder, enter a command
    to create the `Northwind.db` file for SQLite, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be patient because this command might take a while to create the database structure.
  prefs: []
  type: TYPE_NORMAL
- en: To exit SQLite command mode, press *Ctrl* + *C* twice on Windows or *Cmd* +
    *D* on macOS or Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal in the `ModernWeb` folder, enter a command
    to list the files in the current directory, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see that a new file named `Northwind.db` has been created, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change to the project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At a command prompt or terminal in the `Northwind.EntityModels.Sqlite` project
    folder (the folder that contains the `.csproj` project file), generate entity
    class models for all tables, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to perform: `dbcontext scaffold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The connection string refers to the database file in the solution folder, which
    is one folder up from the current project folder: `"Data Source=../Northwind.db"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The database provider: `Microsoft.EntityFrameworkCore.Sqlite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The namespace: `--namespace Northwind.EntityModels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use data annotations as well as the Fluent API: `--data-annotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** `dotnet-ef` commands must be entered all on one line and in a
    folder that contains a project; otherwise, you will see the following error: `No
    project was found. Change the current working directory or use the --project option.`
    Remember that all command lines can be found at and copied from the following
    link: [https://github.com/markjprice/cs13net9/blob/main/docs/command-lines.md](https://github.com/markjprice/cs13net9/blob/main/docs/command-lines.md).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you use SQLite, then you will see warnings about incompatible type mappings
    between the table columns and properties in the entity class models. For example,
    `The column 'BirthDate' on table 'Employees' should map to a property of type
    'DateOnly', but its values are in an incompatible format. Using a different type`.
    This is due to SQLite using dynamic types. We will fix those issues in the next
    section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a class library for a database context using SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will now define a database context class library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new project to the solution, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.DataContext.Sqlite`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `ModernWeb`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Northwind.DataContext.Sqlite` project, statically and globally import
    the `Console` class, add a package reference to the EF Core data provider for
    SQLite, and add a project reference to the `Northwind.EntityModels.Sqlite` project,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** The path to the project reference should not have a line break
    in your project file.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Northwind.DataContext.Sqlite` project, delete the `Class1.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `Northwind.DataContext.Sqlite` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Northwind.DataContext.Sqlite` project, add a class named `NorthwindContextLogger.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents to define a static method, named `WriteLine`, that appends
    a string to the end of a text file, named `northwindlog-<date_time>.txt`, in a
    folder named `book-logs` on the desktop, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Move the `NorthwindContext.cs` file from the `Northwind.EntityModels.Sqlite`
    project/folder to the `Northwind.DataContext.Sqlite` project/folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio **Solution Explorer**, if you drag and drop a file between
    projects, it will be copied. If you hold down *Shift* while dragging and dropping,
    it will be moved. In VS Code **EXPLORER**, if you drag and drop a file between
    projects, it will be moved. If you hold down *Ctrl* while dragging and dropping,
    it will be copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `NorthwindContext.cs`, note the second constructor can have `options` passed
    as a parameter, which allows us to override the default database connection string
    in any projects, such as websites that need to work with the Northwind database,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `NorthwindContext.cs`, in the `OnConfiguring` method, remove the compiler
    #warning about the connection string, and then add statements to check the end
    of the current directory to accommodate when running in Visual Studio compared
    to the command prompt with VS Code, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The throwing of the exception is important because if the database file is missing,
    then the SQLite database provider will create an empty database file, and so if
    you test connecting to it, it works. But if you query it, then you will see an
    exception related to missing tables because it does not have any tables! After
    converting the relative path to an absolute path, you can set a breakpoint while
    debugging to more easily see where the database file is expected to be, or add
    a statement to log that path.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the model and defining an extension method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will simplify the `OnModelCreating` method. I will briefly explain
    the individual steps and then show the complete final method. You can either try
    to perform the individual steps or just use the final method code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OnModelCreating` method, remove all Fluent API statements that call
    the `ValueGeneratedNever` method, like the one shown in the following code. This
    will configure primary key properties, like `CategoryId`, to never generate a
    value automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we do not remove the configuration like the statements above, then when
    we add new suppliers, the `CategoryId` value will always be `0`, and we will only
    be able to add one supplier with that value; all other attempts will throw an
    exception. You can compare your `NorthwindContext.cs` to the one in the GitHub
    repository at the following link: [https://github.com/markjprice/cs13net9/blob/main/code/ModernWeb/Northwind.DataContext.Sqlite/NorthwindContext.cs](https://github.com/markjprice/cs13net9/blob/main/code/ModernWeb/Northwind.DataContext.Sqlite/NorthwindContext.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OnModelCreating` method, for the `Product` entity, tell SQLite that
    the `UnitPrice` can be converted from `decimal` to `double`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `OnModelCreating` method, for the `Order` entity, pass a decimal value
    `0.0M` to the `HasDefaultValue` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `OnModelCreating` method, for the `Product` entity, pass a decimal value
    `0.0M` to the `HasDefaultValue` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `OnModelCreating` method should now be simpler, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Northwind.DataContext.Sqlite` project, add a class named `NorthwindContextExtensions.cs`.
    Modify its contents to define an extension method that adds the Northwind database
    context to a collection of dependency services, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the two class libraries and fix any compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HasDefaultValue and HasDefaultValueSql
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What’s the difference between these two methods?
  prefs: []
  type: TYPE_NORMAL
- en: You should use `HasDefaultValue()` when you need a constant, static value as
    a default for a column, and the value does not depend on any conditions or need
    to be dynamically calculated at the time of insertion. This constant value is
    set at the model level and is used by EF Core to insert into the database if no
    other value is provided.
  prefs: []
  type: TYPE_NORMAL
- en: For the equivalent to the preceding example, you would use `entity.Property(e
    => e.Freight).HasDefaultValue(0M);` because `0M` uses the decimal suffix `M`.
    Think of it as setting a default value on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use `HasDefaultValueSql()` when the default value should be calculated
    by the database at the time of insertion, especially if it involves SQL functions
    or dynamic data that the database should evaluate. The default is a string `"0"`
    because it will be concatenated to the SQL statement, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Think of this as configuring the database to set a default value on the server
    side.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core 8 and earlier database reverse-engineering for SQLite used `HasDefaultValueSql`.
    EF Core 9 database reverse-engineering uses `HasDefaultValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the scope of a dependency service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, a `DbContext` class is registered using the `Scope` lifetime, meaning
    that multiple threads can share the same instance. But `DbContext` does not support
    multiple threads. If more than one thread attempts to use the same `NorthwindContext`
    class instance at the same time, then you will see the following runtime exception
    thrown: `A second operation started on this context before a previous operation
    completed. This is usually caused by different threads using the same instance
    of a DbContext, however instance members are not guaranteed to be thread safe`.'
  prefs: []
  type: TYPE_NORMAL
- en: This happens in Blazor projects with components set to run on the server side
    because, whenever interactions on the client side happen, a SignalR call is made
    back to the server, where a single instance of the database context is shared
    between multiple clients. This issue does not occur if a component is set to run
    on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Creating class libraries for entity models using SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you would like to use SQL Server instead of SQLite, then there are instructions
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md#chapter-12---introducing-web-development-using-aspnet-core](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md#chapter-12---introducing-web-development-using-aspnet-core)'
  prefs: []
  type: TYPE_NORMAL
- en: Improving the class-to-table mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dotnet-ef` command-line tool generates different code for SQL Server and
    SQLite because they support different levels of functionality, and SQLite uses
    dynamic typing. For example, with EF Core 7, all integer columns in SQLite were
    mapped to nullable `long` properties for maximum flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: With EF Core 8 and later, the actual stored values are checked, and if they
    are all storable in an `int`, EF Core 8 and later will declare the mapped property
    as an `int`. If the stored values are all storable in a `short`, EF Core 8 and
    later will declare the mapped property as a `short`.
  prefs: []
  type: TYPE_NORMAL
- en: In this edition, we need to do less work to improve the mapping. Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, SQL Server text columns can have limits on the number of
    characters. SQLite does not support this. So `dotnet-ef` will generate validation
    attributes to ensure that `string` properties are limited to a specified number
    of characters for SQL Server but not for SQLite, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We will make some small changes to improve the entity model mapping and validation
    rules for SQLite. Similar ones for SQL Server are in the online-only instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that all code is available in the GitHub repository for the book.
    Although you will learn more by typing the code yourself, you never have to. Go
    to the following link and press *.* to get a live code editor in your browser:
    [https://github.com/markjprice/cs13net9](https://github.com/markjprice/cs13net9).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a regular expression to validate that a `CustomerId` value
    is exactly five uppercase letters. Second, we will add string length requirements
    to validate that multiple properties throughout the entity models know the maximum
    length allowed for their text values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate your code editor’s **Find and Replace** feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Edit** | **Find and Replace** | **Quick Replace**,
    and then toggle on **Use Regular Expressions**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type a regular expression in the **Find** box, as shown in *Figure 12.3* and
    the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Replace** box, type a replacement regular expression, as shown in
    the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the newline character, `\n`, I have included four space characters to
    indent correctly on my system, which uses two space characters per indentation
    level. You can insert as many as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Set **Find and Replace** to search files in the **Current project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute **Find and Replace** to replace all files, as shown in *Figure 12.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_12_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Find and replace all matches using regular expressions in Visual
    Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change any date/time columns, for example, in `Employee.cs`, to use a nullable
    `DateTime` instead of a string, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use your code editor’s **Find** feature to search for `"datetime"` to find all
    the properties that need changing. There should be two in `Employee.cs` and three
    in `Order.cs`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change any `money` columns, for example, in `Order.cs`, to use a nullable `decimal`
    instead of a `double`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use your code editor’s **Find** feature to search for `"money"` to find all
    the properties that need changing. There should be one in `Order.cs`, one in `Orderdetail.cs`,
    and one in `Product.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Category.cs`, make the `CategoryName` property required, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Customer.cs`, add a regular expression to validate its primary key `CustomerId`,
    only allowing uppercase Western characters and making the `CompanyName` property
    required, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Order.cs`, decorate the `CustomerId` property with a regular expression
    to enforce five uppercase characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Employee.cs`, make the `FirstName` and `LastName` properties required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Product.cs`, make the `ProductName` property required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Shipper.cs`, make the `CompanyName` property required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Supplier.cs`, make the `CompanyName` property required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the class libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s build some unit tests to ensure that the class libraries are working
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** If you are using the SQLite database provider, then when you call
    the `CanConnect` method with a wrong or missing database file, the provider creates
    a `Northwind.db` with 0 bytes! This is why it is so important that, in our `NorthwindContext`
    class, we explicitly check if the database file exists and throw an exception
    when it is instantiated if it does not exist, preventing this behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **xUnit Test Project [C#]** / `xunit`
    project, named `Northwind.UnitTests`, to the `ModernWeb` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Northwind.UnitTests` project, add a project reference to the `Northwind.DataContext`
    project for either SQLite or SQL Server, as shown highlighted in the following
    configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** The project reference must go all on one line with no line break.'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, delete the version numbers specified for the testing packages
    in the project file. (Visual Studio and other code editors will give errors if
    you have projects that should use CPM but specify their own package versions,
    without using the `VersionOverride` attribute.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `Northwind.UnitTests` project to build referenced projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `UnitTest1.cs` to `EntityModelTests.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the contents of the file to define two tests, the first to connect to
    the database and the second to confirm that there are eight categories in the
    database, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio, navigate to **Test** | **Run All Tests**, and
    then view the results in **Test Explorer**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using VS Code, in the `Northwind.UnitTests` project’s **TERMINAL**
    window, run the tests with the following command: `dotnet test`. Alternatively,
    use the **TESTING** window if you have installed C# Dev Kit.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the results should indicate that three tests ran and all passed,
    as shown in *Figure 12.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_12_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Three successful unit tests ran'
  prefs: []
  type: TYPE_NORMAL
- en: 'If any of the tests fail, then fix the issue. For example, if you use SQLite,
    then check that the `Northwind.db` file is in the solution directory (one up from
    the project directories). Check the database path in the `northwindlog-<date_time>.txt`
    file in the `book-logs` folder on your desktop, which should output the database
    path it used three times for the three tests, as shown in the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in this chapter, let’s review some key concepts about web development,
    enabling us to be better prepared to dive into ASP.NET Core Razor Pages in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding web development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing for the web means developing with the **Hypertext Transfer Protocol**
    (**HTTP**), so we will start by reviewing this important foundational technology.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Hypertext Transfer Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To communicate with a web server, the client, also known as the **user agent**,
    makes calls over the network using HTTP. As such, HTTP is the technical underpinning
    of the web. So when we talk about websites and web services, we mean that they
    use HTTP to communicate between a client (often a web browser) and a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client makes an HTTP request to a resource, such as a page, uniquely identified
    by a URL, and the server sends back an HTTP response, as shown in *Figure 12.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_12_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: An HTTP request and response'
  prefs: []
  type: TYPE_NORMAL
- en: You can use Google Chrome and other browsers to record requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Google Chrome is currently used by about two-thirds of website
    visitors worldwide, and it has powerful, built-in developer tools, so it is a
    good first choice for trying out your websites. Try out your websites with Chrome
    and at least two other browsers, for example, Firefox and Safari for macOS and
    iPhone, respectively. Microsoft Edge switched from using Microsoft’s own rendering
    engine to using Chromium in 2019, so it is less important to try out with it,
    although some say Edge has the best developer tools. If Microsoft’s Internet Explorer
    is used at all, it tends to mostly be inside organizations for intranets.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the components of a URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **URL** is made up of several components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scheme**: `http` (clear text) or `https` (encrypted).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain**: For a production website or service, the **top-level domain** (**TLD**)
    might be `example.com`. You might have subdomains such as `www`, `jobs`, or `extranet`.
    During development, you typically use `localhost` for all websites and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port number**: For a production website or service, use `80` for `http` and
    `443` for `https`. These port numbers are usually inferred from the scheme. During
    development, other port numbers are commonly used, such as `5000`, `5001`, and
    so on, to differentiate between websites and services that all use the shared
    domain `localhost`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: A relative path to a resource, for example, `/customers/germany`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query string**: A way to pass parameter values, for example, `?country=Germany&searchtext=shoes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment**: A reference to an element on a web page using its `id`, for example,
    `#toc`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A URL is a subset of a **Uniform Resource Identifier** (**URI**). A URL specifies
    where a resource is located and how to get it. A URI identifies a resource either
    by the URL or **URN** (**Uniform Resource Name**).
  prefs: []
  type: TYPE_NORMAL
- en: Using Google Chrome to make HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore how to use Google Chrome to make HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Google Chrome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **More tools** | **Developer tools**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Network** tab, and Chrome should immediately start recording the
    network traffic between your browser and any web servers (note the red circle),
    as shown in *Figure 12.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_12_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Chrome Developer tools recording network traffic'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chrome’s address box, enter the address of Microsoft’s website for learning
    ASP.NET, which is the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://dotnet.microsoft.com/en-us/learn/aspnet](https://dotnet.microsoft.com/en-us/learn/aspnet)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Developer Tools**, in the list of recorded requests, scroll to the top
    and click on the first entry, the row where the **Type** is **document**, as shown
    in *Figure 12.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_12_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Recorded requests in Developer Tools'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side, click on the **Headers** tab, and you will see details
    about **Request Headers** and **Response Headers**, as shown in *Figure 12.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_12_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Request and response headers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request Method** is `GET`. Other HTTP methods that you could see here include
    `POST`, `PUT`, `DELETE`, `HEAD`, and `PATCH`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status Code** is `200` OK. This means that the server found the resource
    that the browser requested and has returned it in the body of the response. Other
    status codes that you might see in response to a `GET` request include `301 Moved
    Permanently`, `400 Bad Request`, `401 Unauthorized`, and `404 Not Found`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request Headers** sent by the browser to the web server include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accept`, which lists what formats the browser accepts. In this case, the browser
    is saying it understands HTML, XHTML, XML, and some image formats, but it will
    accept all other files (`*/*`). Default weightings, also known as quality values,
    are `1.0`. XML is specified with a quality value of `0.9`, so it is less preferable
    than HTML or XHTML. All other file types are given a quality value of `0.8` so
    are least preferred.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accept-encoding`, which lists what compression algorithms the browser understands
    – in this case, GZIP, DEFLATE, and Brotli.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accept-language`, which lists the human languages it would prefer the content
    to use – in this case, US English, which has a default quality value of `1.0`;
    any dialect of English, which has an explicitly specified quality value of `0.9`;
    and then any dialect of Swedish, which has an explicitly specified quality value
    of `0.8`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response Headers** (`content-encoding)`, which tells me that the server has
    sent back the HTML web page response compressed using the `gzip` algorithm, as
    it knows that the client can decompress that format. (This is not visible in *Figure
    12.8* because there is not enough space to expand the **Response Headers** section.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close Chrome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding client-side web development technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building websites, a developer needs to know more than just C# and .NET.
    On the client (that is, in the web browser), you will use a combination of the
    following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML5**: This is used for the content and structure of a web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CSS3**: This is used for the styles applied to elements on the web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript**: This is used to code any business logic needed on the web page,
    for example, validating form input or making calls to a web service to fetch more
    data needed by the web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although HTML5, CSS3, and JavaScript are the fundamental components of frontend
    web development, there are many additional technologies that can make frontend
    web development more productive, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bootstrap**, the world’s most popular frontend open source toolkit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SASS** and **LESS**, CSS preprocessors for styling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft’s **TypeScript** language for writing more robust code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript libraries such as **Angular**, **jQuery**, **React**, and **Vue**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these higher-level technologies ultimately translate or compile to the underlying
    three core technologies, so they work across all modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the build and deploy process, you will likely use technologies such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js**, a framework for server-side development using JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node Package Manager** (**npm**) and **Yarn**, both client-side package managers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**webpack**, a popular module bundler and a tool for compiling, transforming,
    and bundling website source files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions and exploring
    this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.1 – Online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online materials can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the best sites for learning client-side web development is W3Schools,
    found at the following link: [https://www.w3schools.com/](https://www.w3schools.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A summary of what’s new with ASP.NET Core 9 can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-9.0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft’s official recommendation for how to choose an ASP.NET Core web UI
    can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/aspnet/core/tutorials/choose-web-ui](https://learn.microsoft.com/en-us/aspnet/core/tutorials/choose-web-ui)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft’s official recommendation for ASP.NET Core best practices can be
    found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/best-practices](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/best-practices)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.2 – Practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting web development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is common to have temporary issues with web development because there are
    so many moving parts. Sometimes, variations of the classic “turn it off and on
    again” can fix these!
  prefs: []
  type: TYPE_NORMAL
- en: Delete the project’s `bin` and `release` folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the web server to clear its caches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot the computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 12.3 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What was the name of Microsoft’s first dynamic server-side-executed web page
    technology, and why is it still useful to know this history today?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the names of two Microsoft web servers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some differences between a microservice and a nanoservice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Blazor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What was the first version of ASP.NET Core that could not be hosted on .NET
    Framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a user agent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What impact does the HTTP request-response communication model have on web developers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name and describe four components of a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What capabilities do developer tools give you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three main client-side web development technologies, and what do
    they do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Know your webbreviations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What do the following web abbreviations stand for, and what do they do?
  prefs: []
  type: TYPE_NORMAL
- en: URI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WCF
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TLD
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SPA
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CMS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wasm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SASS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 12.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-12---introducing-web-development-using-aspnet-core](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-12---introducing-web-development-using-aspnet-core)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have:'
  prefs: []
  type: TYPE_NORMAL
- en: Been introduced to some of the app models that you can use to build websites
    and web services using C# and .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created class libraries to define an entity data model for working with the
    Northwind database, using SQLite, SQL Server, or both
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following chapters, you will learn the details of how to build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple websites using static HTML pages and dynamically generated Blazor static
    SSR pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor user interface components that can be hosted on a web server, in the
    browser, or on hybrid web-native mobile and desktop apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services that can be called by any platform that can make an HTTP request,
    as well as client websites that call those web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code281224304227278796.png)'
  prefs: []
  type: TYPE_IMG
- en: Leave a Review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR or visit the link to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  Description automatically generated](img/review1.png)'
  prefs: []
  type: TYPE_IMG
