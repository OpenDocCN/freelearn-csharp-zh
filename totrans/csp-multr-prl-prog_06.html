<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Task-based Parallelism"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Task-based Parallelism</h1></div></div></div><p>In this chapter we will cover the <span class="strong"><strong>Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>) and the details of using the <code class="literal">Task</code> class to write concurrent code.</p><p>In <a class="link" href="ch05.html" title="Chapter 5. Lightweight Concurrency – Task Parallel Library (TPL)">Chapter 5</a>, <span class="emphasis"><em>Lightweight Concurrency – Task Parallel Library (TPL)</em></span>, we started our exploration of lightweight concurrency and .NET's new most preferred way to accomplish multithreaded programming—the TPL. In this chapter, we will explore task-based parallelism further and show how to wait on tasks or multiple tasks, custom scheduling of a task, error handling, and canceling a task.</p><p>The TPL<a id="id325" class="indexterm"/> gives us an easy way to schedule, run, and coordinate tasks at a higher level of abstraction than working directly with threads. As mentioned earlier, a task is a set of instructions to carry out an objective, a unit of work if you wish. We can define a task in a method called by a delegate or in a lambda expression defined directly in the task-creation command.</p><p>When running more than one task concurrently, there will be times when we need to wait on one or more tasks to complete before performing a function, or be able to cancel one or more tasks if a certain condition arises, or coordinate exception handling if one or more tasks throws an error when running in parallel. We will discuss all of these scenarios in this chapter and work through examples. By the end of this chapter, you will be very comfortable with all the aspects of using tasks in parallel in your applications.</p><p>In this chapter, you will learn how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Wait on a particular task when multiple tasks are running concurrently</li><li class="listitem" style="list-style-type: disc">Wait on all or many tasks that are running concurrently</li><li class="listitem" style="list-style-type: disc">Cancel one or more tasks when certain conditions occur</li><li class="listitem" style="list-style-type: disc">Handle exceptions thrown by one or more tasks</li><li class="listitem" style="list-style-type: disc">Fully coordinate the execution and completion of concurrently running tasks</li></ul></div><div class="section" title="Waiting for a task to complete"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Waiting for a task to complete</h1></div></div></div><p>The first thing we <a id="id326" class="indexterm"/>need to do when we execute a task is to know when it has completed, and if it returns results, what the results are. Let's see a simple example by creating a task, waiting for it to complete, and then checking the results.</p><p>We will do this using a task that doesn't return a result and one that does, and see the difference between <code class="literal">Task</code> and <code class="literal">Task&lt;TResult&gt;</code>. When a task returns a result value, the wait is implicit, and when it doesn't, we need to explicitly wait for it.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec63"/>How to do it</h2></div></div></div><p>First, let's open up Visual Studio and create a new console application called <code class="literal">WaitonTask</code>. Once we have the new project created, we will add the following code to the <code class="literal">Program.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
static Random ran = new Random();
static void Main(string[] args)
    {
        // Wait on a single task with no timeout.
        Task taskA = Task.Factory.StartNew(() =&gt; Worker(10000));
taskA.Wait();
Console.WriteLine("Task A Finished.");


        // Wait on a single task with a timeout.
        Task taskB = Task.Factory.StartNew(() =&gt; Worker(2000000));
taskB.Wait(2000); //Wait for 2 seconds. 

if (taskB.IsCompleted)
Console.WriteLine("Task B Finished.");
else
Console.WriteLine("Timed out without Task B finishing.");


Console.ReadLine();
    }

static void Worker(intwaitTime)
    {
Thread.Sleep(waitTime);
    }
}</pre></div><p>As you can see from this code, we are creating a task to run for 10 seconds and we will wait on the task to finish. This task calls a method named <code class="literal">Worker</code> and is instantiated using a <code class="literal">Task.Factory</code> and a lambda expression. The task does not return a value.</p><p>Now, let's compile and run<a id="id327" class="indexterm"/> our new application. The following is an example of the output you should see:</p><div class="mediaobject"><img src="graphics/8321EN_06_01.jpg" alt="How to do it"/></div><p>As you can see, we first start a task with the <code class="literal">Worker</code> method and wait on it to complete and then we start a task with the <code class="literal">Worker</code> method and perform a wait with a time-out value. Did you notice a difference between the two executions?</p><p>The first time we run the task, we will wait the full 10 seconds for the task to complete. The second time we run the task, we set a timeout and continue on before the task completes. Since the task runs for longer than 2 seconds, the wait command times out and the program moves on, while the task is still running.</p><p>In both of these examples, we have a task that does not return a value. Now, let's change our worker task to return a value and see what happens. Let's add a new method to our program called <code class="literal">Worker1</code>. Add the following code to the <code class="literal">Worker1</code> method:</p><div class="informalexample"><pre class="programlisting">static double Worker1()
    {
int i = ran.Next(1000000);
Thread.SpinWait(i);
return i;
    }</pre></div><p>Now, in the <code class="literal">Main</code> <a id="id328" class="indexterm"/>method of the <code class="literal">Program.cs</code> file, add the following two lines of code towards the end right before the <code class="literal">Console.ReadLine</code> command:</p><div class="informalexample"><pre class="programlisting">Task&lt;double&gt; taskC = Task&lt;double&gt;.Factory.StartNew(() =&gt; Worker1());

Console.WriteLine("TaskC finished = result is {0}.", taskC.Result);</pre></div><p>Now, let's compile and run our program again. The following is the output that you should see when you run the program:</p><div class="mediaobject"><img src="graphics/8321EN_06_02.jpg" alt="How to do it"/></div><p>Did you notice that the program ran and waited for <code class="literal">TaskC</code> to complete? Shortly, we will get to the <code class="literal">SpinWait</code> method of the <code class="literal">Thread</code> class, but for now, why did the program wait on <code class="literal">TaskC</code> to finish running when we did not put a wait command in the code for it?</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec64"/>How it works</h2></div></div></div><p>In the previous <a id="id329" class="indexterm"/>exercise, we saw three ways to wait for a task to complete. The first two examples used the <code class="literal">Task.Wait</code> method to tell our program to wait on the task. Since the task is running on a different thread, we have to wait for it to complete before we continue the execution of the program in our main thread. In these two examples, our task does not return a value. In this case, we need to explicitly wait on the task to complete if we do not want our main thread to continue after starting the task (or at least scheduling it in the threadpool). We do this using the <code class="literal">Task.Wait</code> method in the <code class="literal">Task</code> class.</p><p>The first time, we told our program to wait on the task to complete and then move on. The second time, we set a timeout value in the <code class="literal">Wait</code> method. This tells our main thread to wait for the amount of time in the timeout parameter and then move on. Then we checked the <code class="literal">Task.IsComplete</code> property to see whether our task has completed or not. </p><p>Since the task was set to run for longer than the timeout value, the task was still running when our main thread continued execution. That is why the <code class="literal">IsComplete</code> property is <code class="literal">false</code> and the <code class="literal">else</code> portion of our <code class="literal">if</code> statement gets executed:</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Timed out without Task B finishing.");</pre></div><p>You can play around with this code and make the task run for less time than the timeout value and see what happens.</p><p>Next, we ran a task using the <code class="literal">Worker1</code> method that returns a <code class="literal">double</code> value. What did we see here? We did not place a <code class="literal">Task.Wait</code> command but our main program still waited on the task to complete before continuing on with its execution. Why is that?</p><p>We know it waited until the task was completed because when we wrote the <code class="literal">Task.Result</code> value to the console, it had a value and was not <code class="literal">null</code>. In this case, we do not need to use the <code class="literal">Task.Wait</code> method explicitly because the main thread will wait on the task to complete; it needs to wait until the <code class="literal">Task.Result</code> property is set. By defining a task with a return value, we are telling our main thread implicitly to wait on the task to complete.</p><p>So, as we have seen, if we do not return a value in our task, then we need to explicitly tell our program to wait. However, if we return a value, we are implicitly telling our program to wait on the task to complete.</p><p>Next, we will see how to control the execution of our main thread when we start many concurrent tasks at once. In this case, if our tasks return values, we might not implicitly want to wait on every task to complete. Maybe we just want to wait on one task to complete.</p><p>In our current program, we used the <code class="literal">Thread.SpinWait</code> method. This method is different from the <code class="literal">Thread.Sleep</code> method. The <code class="literal">Thread.Sleep</code> method waits for a specified time whereas the <code class="literal">SpinWait</code> method starts a loop for the specified iterations passed to the method. So, in this case, the speed of the processor will dictate the duration because the clock speed will <a id="id330" class="indexterm"/>determine how fast it can complete the number of iterations. By using this instead of a <code class="literal">Sleep</code> method, it also allows the scheduler to perform context switching if thread priorities dictate.</p></div></div></div>
<div class="section" title="Waiting for multiple tasks to complete"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Waiting for multiple tasks to complete</h1></div></div></div><p>In the previous section, we <a id="id331" class="indexterm"/>examined how to explicitly and implicitly wait on a task to complete. Now, let's see how we can control execution and waiting when we start many tasks instead of just one.</p><p>Sometimes, we may want to wait on one task out of a group to finish. Sometimes, we might want to wait on all of the tasks to finish, and other times we might want to wait on a certain condition of tasks to finish before proceeding.</p><p>The following screenshot shows all of the <code class="literal">Wait</code> and <code class="literal">When</code> methods provided with the <code class="literal">Task</code> class. The <code class="literal">Wait</code> methods are as shown:</p><div class="mediaobject"><img src="graphics/8321EN_06_03.jpg" alt="Waiting for multiple tasks to complete"/></div><p>The <code class="literal">When</code> methods are as shown:</p><div class="mediaobject"><img src="graphics/8321EN_06_04.jpg" alt="Waiting for multiple tasks to complete"/></div><p>Both images are references from <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx">http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx</a>.</p><p>We will demonstrate how to<a id="id332" class="indexterm"/> perform different <code class="literal">Wait</code> and <code class="literal">When</code> techniques in this chapter, but this is to give you further ideas on what is possible.</p><p>Let's start by creating a simple program to demonstrate how the <code class="literal">WaitAll</code> method works by populating three circles with random numbers once three tasks complete.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec65"/>How to do it</h2></div></div></div><p>To get started, we need to create a WPF application using Visual Studio. Open Visual Studio and create a new WPF project called <code class="literal">RandomCircles</code>. Once we have created this project, proceed by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go into the design mode in Visual Studio and add the following controls to the <code class="literal">MainWindow.xaml</code> file:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add three Ellipse controls and name them <code class="literal">Circle1</code>, <code class="literal">Circle2</code>, and <code class="literal">Circle3</code>.</li><li class="listitem" style="list-style-type: disc">Set their height and width properties to <code class="literal">120</code> for all three circles. This is done in the <code class="literal">MainWindow.xaml</code> file using the <span class="strong"><strong>Design</strong></span> mode in Visual Studio.</li><li class="listitem" style="list-style-type: disc">Next, add three textboxes and place them inside the circles. Name them <code class="literal">text1</code>, <code class="literal">text2</code>, and <code class="literal">text3</code>. Set the <code class="literal">Text</code> property on all three to an empty string and make their <code class="literal">Background</code> property the same color as the <code class="literal">Fill</code> property on the Ellipse controls.</li><li class="listitem" style="list-style-type: disc">Next, add a button control and name it <code class="literal">btnRandomAll</code>. Set the <code class="literal">Content</code> property on this control to <code class="literal">Random All</code>.</li></ul></div><p>Now, your <code class="literal">MainWindow.xaml</code> file should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_06_05.jpg" alt="How to do it"/></div></li><li class="listitem">Next, let's go to the <code class="literal">MainWindow.xaml.cs</code> code behind this file. We need to add a <code class="literal">using</code> statement <a id="id333" class="indexterm"/>for the <code class="literal">Threading</code> namespace.<div class="informalexample"><pre class="programlisting">using System.Threading;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>The <code class="literal">System.Threading.Tasks</code> namespace should already be included when you created the WPF project, but check to make sure whether it is there.</p></div></div></li><li class="listitem">Now, let's add a worker method to provide work for the tasks to perform, which we are about to create. Create a <code class="literal">Worker1</code> method that is <code class="literal">private</code> and returns a string value. Add the following code to it:<div class="informalexample"><pre class="programlisting">private String Worker1()
        {
int result = ran.Next(10000000);
Thread.SpinWait(result);
return String.Format("Random Number is {0} and Time is {1}.",result, DateTime.Now.Millisecond);
        }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>
<code class="literal">SpinWait</code> is used here to demonstrate how processor speed can affect the speed of a function. <code class="literal">SpinWait</code> is very inefficient and does consume CPU resources more than <code class="literal">Sleep()</code>.</p></div></div></li><li class="listitem">Next, let's create<a id="id334" class="indexterm"/> an event handler for <code class="literal">btnRandomAll</code>—a click event called <code class="literal">btnRandomAll_Click</code>. Inside this method, add the following code:<div class="informalexample"><pre class="programlisting">private void btnRandomAll_Click(object sender, RoutedEventArgs e)
        {
// Wait for all tasks to finish.
Task&lt;String&gt;[] tasks = newTask&lt;String&gt;[3];
for (int i = 0; i&lt; 3; i++)
            {
tasks[i] = Task&lt;String&gt;.Factory.StartNew(() =&gt; Worker1());
            }
Task.WaitAll(tasks);

            text1.Text = tasks[0].Result.ToString();
            text2.Text = tasks[1].Result.ToString();
            text3.Text = tasks[2].Result.ToString();
        }</pre></div></li></ol></div><p>That should be all you need to have a program that runs three tasks in separate threads. Each of these tasks will spin for a random time. The main thread will wait on all of these tasks to complete and then return a string that has the random number used by the task and the current time in milliseconds.</p><p>Finally, let's compile and run our new program. The following is what random circles should look like when it is first started:</p><div class="mediaobject"><img src="graphics/8321EN_06_06.jpg" alt="How to do it"/></div><p>Now, click on the <span class="strong"><strong>Random All</strong></span> button<a id="id335" class="indexterm"/> once and see what the output looks like. The following is what we got when we ran it:</p><div class="mediaobject"><img src="graphics/8321EN_06_07.jpg" alt="How to do it"/></div><p>Now, click on the <span class="strong"><strong>Random All</strong></span> button<a id="id336" class="indexterm"/> a second time and see what the program looks like. The following screenshot is what we got:</p><div class="mediaobject"><img src="graphics/8321EN_06_08.jpg" alt="How to do it"/></div><p>Now, let's make some changes to<a id="id337" class="indexterm"/> our program and try running it again. Make the following changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new Ellipse control and name it <code class="literal">Circle4</code>.</li><li class="listitem">Add a new textbox control and name it <code class="literal">text4</code> and set the <code class="literal">Text</code> property to an empty string.</li><li class="listitem">Add another button control and name it <code class="literal">btnRandomFirst</code> and set the <code class="literal">Content</code> property to <code class="literal">RandomFirst</code>.</li><li class="listitem">Add an event handler to the button, <code class="literal">btnRandomFirst</code>, and name it <code class="literal">btnRandomFirst_Click</code>. Add the following code to the event handler:<div class="informalexample"><pre class="programlisting">private void btnRandomFirst_Click(object sender, RoutedEventArgs e)
        {
Task&lt;String&gt;[] tasks = newTask&lt;String&gt;[3];
for (int i = 0; i&lt; 3; i++)
            {
tasks[i] = Task&lt;String&gt;.Factory.StartNew(() =&gt; Worker1());
            }
//Task.WaitAll(tasks);
int index = Task.WaitAny(tasks);

            text4.Text = "Task " + index.ToString() + " finished first.";
        }</pre></div></li></ol></div><p>Now, let's compile and run our <a id="id338" class="indexterm"/>program. The following is the output before an action is taken:</p><div class="mediaobject"><img src="graphics/8321EN_06_09.jpg" alt="How to do it"/></div><p>Now, click on the <span class="strong"><strong>Random First</strong></span> button once and the output should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_06_10.jpg" alt="How to do it"/></div><p>Finally, let's click on the<a id="id339" class="indexterm"/> <span class="strong"><strong>Random First</strong></span> button a second time and look at the results. They should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_06_11.jpg" alt="How to do it"/></div></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>How it works</h2></div></div></div><p>Let's take a minute to<a id="id340" class="indexterm"/> go through what we just did with this program.</p><p>First, our <code class="literal">Worker1</code> method that performs our <span class="emphasis"><em>tasks</em></span> is a simple worker bee. It generates a random number and then does a <code class="literal">Thread.SpinWait</code> for that number of iterations. Then it returns the current time in milliseconds. So, every time this method is run as a task in a separate thread, it will run for a random amount of time. If multiple copies of this method are running in different threads, then they will each finish at a different time because <code class="literal">SpinWait</code> will run for a different randomly generated number of iterations.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When you click on the <span class="strong"><strong>Random All</strong></span> button, the event handler is fired. The event handler starts three separate tasks each running the <code class="literal">Worker1</code> method using the following command:<div class="informalexample"><pre class="programlisting">Task&lt;String&gt;.Factory.StartNew(() =&gt; Worker1());</pre></div></li><li class="listitem">We created a <code class="literal">Task</code> array with a string value <code class="literal">TResult</code> using this command:<div class="informalexample"><pre class="programlisting">Task&lt;String&gt;[] tasks = newTask&lt;String&gt;[3];</pre></div></li><li class="listitem">Then, we wait on all of the tasks in the tasks array using this command:<div class="informalexample"><pre class="programlisting">Task.WaitAll(tasks);</pre></div></li><li class="listitem">Then, we display the results of each task and see that they each have a different random number and finish at a different time even though each task is executing the same method.</li><li class="listitem">Next, we created a second button that does much of the same work except for this time instead of the <code class="literal">Task.WaitAll</code> command, we use this command:<div class="informalexample"><pre class="programlisting">int index = Task.WaitAny(tasks);</pre></div></li></ol></div><p>So, in this case, we <a id="id341" class="indexterm"/>only wait for any of the three tasks to complete before continuing execution in our main thread. You can verify this by clicking on the <span class="strong"><strong>Random First</strong></span> button many times. Each time it can be either task 0, 1, or 2 that finishes first.</p><p>Take some time to play with these two commands and make sure you have a full understanding of how each works.</p><p>We will not spend time on this book playing with the <code class="literal">Continue</code>, <code class="literal">ContinueAll</code>, <code class="literal">When</code>, and <code class="literal">WhenAll</code> methods of the <code class="literal">Task</code> class, but take some time to experiment with these functionalities. These methods allow you to execute a task when other tasks have completed. So, you can chain task executions together. The alternative to these is to wait on tasks to complete and then start new tasks. The <code class="literal">Continue</code> and <code class="literal">When</code> methods allow you to combine this into one statement.</p><p>In the next section, we will explore canceling tasks. Depending on your requirements, you might want to cancel a task that you have started, before it ends.</p></div></div>
<div class="section" title="Canceling a task"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Canceling a task</h1></div></div></div><p>Let's explore canceling a<a id="id342" class="indexterm"/> task. Now that we know how to start one or more tasks and how to coordinate waiting on one or more of these tasks, what if something happens after we have started a group of tasks and we need to stop them?</p><p>Task cancellation is accomplished in the .NET framework by using<a id="id343" class="indexterm"/> <span class="strong"><strong>cancellation tokens</strong></span>. The delegate used when running a task needs to have code to support cancelation and then any other code that needs to cancel a task can request cancelation of the task.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>The <code class="literal">CancellationToken</code> structure in .NET manages notification that an operation should be canceled. It has a property, <code class="literal">IsCancellationRequested</code>, that you can use to see if a cancellation request has been issued. This structure is a member of the <code class="literal">System.Threading</code> namespace and is used by threads and tasks to manage cancellation requests in a multithreaded environment.</p></div></div><p>Merely requesting to cancel a task will not cancel the task. The task delegate must support cancellation tokens. There are two ways that a delegate can choose to cancel. The delegate can simply return from execution, or it can throw an <code class="literal">OperationCanceledException</code> using the <code class="literal">ThrowIfCancellationRequested</code> method.</p><p>There are two main differences to these two methods of cancelation. If the delegate just returns from execution, then the following happens:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The task is put in a state of <code class="literal">TaskStatus.RanToCompletion</code> instead of <code class="literal">TaskStatus.Canceled</code>.</li><li class="listitem">The code requesting to cancel the task does not know if the task simply finished or was canceled before finishing.</li></ol></div><p>If the task delegate implements the latter method for canceling (throwing an <code class="literal">OperationCanceledException</code>), then the following happens:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The task is put in a state of <code class="literal">TaskStatus.Canceled</code>.</li><li class="listitem">The requesting code can check this status and determine if the task was canceled or just finished.</li></ol></div><p>So, now we will <a id="id344" class="indexterm"/>create a WPF application to allow the user to cancel tasks. We will demonstrate how to create cancellation tokens, monitor the task state to see if it is canceled, and then do some processing when it is canceled. This will also use the <code class="literal">Task.ContinueWith</code> method. This method allows us to execute a task when another task has completed.</p><p>In our application, we will start 10 tasks. Each task will take an integer parameter as input and will multiply it by the numbers from 1 to 10 million and take a sum of the results. It will then return a <code class="literal">double</code> value that is the result. While this may not be the world's most exciting computation, it will take a little time depending on your processor speed.</p><p>We will start each task with a task cancelation token pass to it and create <code class="literal">ContinueWith</code> tasks for it. One will <span class="emphasis"><em>continue with</em></span> if the task runs to completion, and the other will <span class="emphasis"><em>continue with</em></span> if the task is canceled. We will also have a <span class="strong"><strong>Cancel</strong></span> button that allows you to cancel at any time and stop the tasks in progress.</p><p>Let's get started.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>How to do it</h2></div></div></div><p>Open up Visual Studio and create a new WPF application called <code class="literal">TaskCancel</code>. In the designer window in the <code class="literal">MainWindow.xaml</code> file, let's add the following items.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add two button controls: one named <code class="literal">btnStart</code> and other named <code class="literal">btnCancel</code>.</li><li class="listitem">Next, add a click event handler for each button: <code class="literal">btnStart_Click</code> and <code class="literal">btnCancel_Click</code> respectively.</li><li class="listitem">Add a text block control named <code class="literal">textBlock1</code>.</li></ol></div><p>Your <code class="literal">MainWindow.xaml</code> file should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_06_12.jpg" alt="How to do it"/></div><p>Now, move to <a id="id345" class="indexterm"/>the <code class="literal">MainWindow.xaml.cs</code> code behind the file. Let's add the following items:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a <code class="literal">using</code> statement for the <code class="literal">System.Threading</code> namespace:<div class="informalexample"><pre class="programlisting">using System.Threading;</pre></div></li><li class="listitem">Then, inside the class definition at the top, let's add our cancelation token:<div class="informalexample"><pre class="programlisting">CancellationTokenSourcets;</pre></div></li><li class="listitem">Next, let's add a method that will execute inside our 10 tasks. We will call this method <code class="literal">AddMultiple</code>. It takes an integer parameter and returns a value that is the datatype <code class="literal">double</code>. Add the following code to it:<div class="informalexample"><pre class="programlisting">public double AddMultiple(int number)
        {
double result = 1;
for (int i = 1; i&lt; 100000000; i++)
            {
ts.Token.ThrowIfCancellationRequested();
result = result + (number * i);
            }
return result;
 }</pre></div></li><li class="listitem">Then, let's <a id="id346" class="indexterm"/>add the code to the click event handler of <code class="literal">btnStart</code> that will start the 10 tasks:<div class="informalexample"><pre class="programlisting">private void btnStart_Click(object sender, RoutedEventArgs e)
        {
ts = new CancellationTokenSource();

            textBlock1.Text = "";

List&lt;Task&gt; tasks = new List&lt;Task&gt;();

for (int i = 2; i&lt;= 10; i++)
            {
int tmp = i;

Task&lt;double&gt; adder = Task.Factory.StartNew(() =&gt;AddMultiple(tmp), ts.Token);

tasks.Add(adder);

var show = adder.ContinueWith(resultTask =&gt;
                                     textBlock1.Text += tmp.ToString() + " - " + adder.Result.ToString() + Environment.NewLine,
CancellationToken.None,
TaskContinuationOptions.OnlyOnRanToCompletion,
TaskScheduler.FromCurrentSynchronizationContext());

var showCancel = adder.ContinueWith(resultTask =&gt;
                                               textBlock1.Text += tmp.ToString() + " canceled" + Environment.NewLine,
CancellationToken.None,
TaskContinuationOptions.OnlyOnCanceled, TaskScheduler.FromCurrentSynchronizationContext());
            }
        }</pre></div></li><li class="listitem">Finally, let's add the code to the click event handler of <code class="literal">btnCancel</code>:<div class="informalexample"><pre class="programlisting">private void btnCancel_Click(object sender, RoutedEventArgs e)
        {
ts.Cancel();
        }</pre></div></li></ol></div><p>That is all we have to do. Now, let's compile and run our application. But this time, let's not run it through Visual Studio. We will run the application directly. Go to the <code class="literal">bin\Release</code> folder in our project directory and double-click on the <code class="literal">TaskCancel.exe</code> application. We will explain shortly why we are doing this and what happens when we run it in Visual Studio.</p><p>When you run the <a id="id347" class="indexterm"/>application, it should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_06_13.jpg" alt="How to do it"/></div><p>Now, click on the <span class="strong"><strong>Start</strong></span> button. Then click on the <span class="strong"><strong>Cancel</strong></span> button. You can decide how fast to click on the <span class="strong"><strong>Cancel</strong></span> button but you should see an output like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_06_14.jpg" alt="How to do it"/></div><p>If you try running it<a id="id348" class="indexterm"/> in Visual Studio directly, you will notice that when you click on the <span class="strong"><strong>Cancel</strong></span> button, an unhandled exception occurs. You can press <span class="emphasis"><em>F5</em></span> a couple of times and it will continue on. But why does this happen?</p><p>The <code class="literal">ThrowIfCancellationRequested</code> method has <span class="emphasis"><em>cooperative cancellation</em></span>. This throws an exception to indicate that it has <a id="id349" class="indexterm"/>accepted the cancellation requested and will stop. This exception is handled by .NET in the TPL and shouldn't be handled by your code. Since Visual Studio looks for all unhandled exceptions and shows them in debug mode, you will see it when running the application in debug mode through Visual Studio. There is a way to turn this off through the <span class="strong"><strong>Options-Debugging</strong></span> settings under <span class="strong"><strong>Tools</strong></span>, but we do not recommend it because it can mask other exceptions that you want to see. Nevertheless, the exception we encounter here is a nuisance when debugging.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>How it works</h2></div></div></div><p>Now that we've<a id="id350" class="indexterm"/> successfully canceled running tasks, let's see how we did it. First, we defined a cancellation token using <code class="literal">CancellationTokenSourcets</code>. Then we instantiated it using <code class="literal">ts = new CancellationTokenSource()</code>. This gives us a cancellation token that we can work with.</p><p>Let's skip, briefly, to the end. To cancel tasks, we just call the token's <code class="literal">Cancel</code> method, <code class="literal">ts.Cancel()</code>, in the <span class="strong"><strong>Cancel</strong></span> button's click event handler. This will indicate to any task, which is using this cancelation token, that they need to cancel. Now it is up to the tasks to monitor the token and perform the cancelation.</p><p>So, let's take a look at the <span class="strong"><strong>Start</strong></span> button's click method. Here, we create and start 10 tasks using the following code:</p><div class="informalexample"><pre class="programlisting">Task&lt;double&gt; adder = Task.Factory.StartNew(() =&gt;AddMultiple(tmp), ts.Token);</pre></div><p>Here, we call the <code class="literal">Task.Factory.StartNew</code> command and pass it the delegate for the task to execute and the cancellation token.</p><p>Then, we also call the <code class="literal">ContinueWith</code> command to tell the task what to do after it finishes. We set up two of these depending on how the task finishes:</p><div class="informalexample"><pre class="programlisting">var show = adder.ContinueWith(resultTask =&gt;
                                     textBlock1.Text += tmp.ToString() + " - " + adder.Result.ToString() + Environment.NewLine,
CancellationToken.None,
TaskContinuationOptions.OnlyOnRanToCompletion,
TaskScheduler.FromCurrentSynchronizationContext());

var showCancel = adder.ContinueWith(resultTask =&gt;
                                               textBlock1.Text += tmp.ToString() + " canceled" + Environment.NewLine,
CancellationToken.None,

TaskContinuationOptions.OnlyOnCanceled, TaskScheduler.FromCurrentSynchronizationContext());</pre></div><p>For the first one, we pass the parameter, <code class="literal">TaskContinuationOptions.OnlyOnCanceled</code>, and for the second one, we pass the parameter, <code class="literal">TaskContinuationOptions.OnlyOnRanToCompletion</code>.</p><p>So, if the task is canceled, the second <code class="literal">ContinueWith</code> command is executed and, if the task runs to completion, the first <code class="literal">ContinueWith</code> command is executed. In each of these <code class="literal">ContinueWith</code> commands, we pass a lambda expression to execute, which prints the results of the task. This is how we update the UI with the status of each task, once it has completed.</p><p>From the output you can see which tasks run to completion and which tasks are canceled. Also, note that the output is not in sequential order. Since the 10 tasks are scheduled with the threadpool and the different cores on the machine we run have different workloads, the tasks finish in different orders.</p><p>Next, we will take a look at error handling with tasks.</p></div></div>
<div class="section" title="Task exception handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Task exception handling</h1></div></div></div><p>Well, we have learned how<a id="id351" class="indexterm"/> to start, coordinate, and cancel tasks. Now, let's talk about error handling with tasks. In C#, when we discuss error handling, we are really talking about the <code class="literal">try..catch..finally</code> structure. In this book, we assume you are familiar with the operation of a <code class="literal">try..catch</code> block.</p><p>A task has a lifecycle of states that it can be in. A task can be idle (scheduled), running, pending, cancelled, faulted, or completed. Each task has a <code class="literal">status</code> property that defines the current state of the task. We saw this in the last section and used <code class="literal">OnlyOnCanceled</code> and <code class="literal">OnlyOnRanToCompletion</code> as the options for <code class="literal">TaskContinuationOptions</code> for our <code class="literal">ContinueWith</code> methods.</p><p>So, when we talk about exception handling with TPL, we are referring to faulted tasks. There are several ways a task can reach a faulted status, for example, when the task delegate fails and throws an exception. A <span class="strong"><strong>faulted task</strong></span><a id="id352" class="indexterm"/> is basically a task that resulted in an error and carries the exception with it.</p><p>Your code will incur an exception if you perform one of the following on a faulted task:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Waiting on a task</li><li class="listitem" style="list-style-type: disc">Using the task's result value</li><li class="listitem" style="list-style-type: disc">Performing an <code class="literal">Await</code> on the task</li></ul></div><p>So, when you use the <code class="literal">Wait</code>, <code class="literal">WaitAll</code>, <code class="literal">Await</code>, or <code class="literal">Result</code> methods of a task, you should surround these statements with a <code class="literal">try..catch</code> block. The first two will always throw an exception of the <code class="literal">AggregateException</code> type, which is a container for multiple exceptions. The <code class="literal">Await</code> will throw the actual exception occurred by the task's delegate.</p><p>These are the basics of task exception handling. We want to do a <code class="literal">try..catch</code> around the <code class="literal">Result</code>, <code class="literal">Wait</code>, or <code class="literal">Await</code> of a task.</p><p>But what if we start a task and do not care about waiting on it or its results, but we want to know if it incurs an exception? How do we know if a start-and-forget task has a problem? In this case, we can use a simple technique with the help of the <code class="literal">ContinueWith</code> command. Look at the following command:</p><div class="informalexample"><pre class="programlisting">task.ContinueWith(resultTask =&gt;DoSomething(), TaskContinuationOptions.OnlyOnFaulted);</pre></div><p>In this case, we create a task to execute on a <code class="literal">ContinueWith</code> command if the task is in an <code class="literal">OnlyOnFaulted</code> state.</p><p>So, you can perform exception handling with a <code class="literal">try..catch</code> on the result while waiting on a task or, if you are not <a id="id353" class="indexterm"/>waiting on the task or result, you can create a <code class="literal">ContinueWith</code> task to handle the exception.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, we have looked at ways to wait on a task, cancel, chain, and perform exception handling with tasks. We have now covered all of the aspects that need to work with tasks in the TPL and the techniques needed to handle all of the scenarios your design might encounter.</p><p>We encourage you to further explore the techniques presented in this chapter and explore the world of task-based parallelism. The days of working directly with threads and the <code class="literal">BackgroundWorker</code> component will soon become a distant memory.</p><p>These last two chapters have been an overview of TPL and task-based parallelism. In the next chapter, we will cover data-based parallelism and working with data collections in a concurrent manner.</p></div></body></html>