- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Variants of Lists
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表的变体
- en: In the previous chapter, you learned about arrays and their types. Of course,
    an array is not the only way of storing data. Another popular and even more powerful
    group of data structures contains various variants of **lists**. In this chapter,
    you will see such data structures in action, together with illustrations, explanations,
    and descriptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了数组和它们的类型。当然，数组并不是存储数据的唯一方式。另一组更受欢迎且更强大的数据结构包含各种**列表**的变体。在本章中，你将看到这些数据结构在实际中的应用，包括插图、解释和描述。
- en: First, you will see a **simple list** as an array list and a generic list, in
    which you can easily add and remove elements according to your needs. Then, you
    will get to know **sorted lists**, which keep an order of elements. Next, you
    will learn about four variants of the **linked list**, namely a singly linked
    list, a doubly linked list, a circular singly linked list, and a circular doubly
    linked list. Finally, you will familiarize yourself with three list-related interfaces
    that you can use while developing applications. Does this sound a bit complicated?
    If so, don’t worry. You will be guided throughout.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将看到一个**简单列表**，它作为一个数组列表和通用列表，你可以根据需要轻松地添加和删除元素。然后，你将了解**排序列表**，它保持元素的顺序。接下来，你将学习关于**链表**的四种变体，即单链表、双链表、循环单链表和循环双链表。最后，你将熟悉在开发应用程序时可以使用的一些与列表相关的接口。这听起来有点复杂吗？如果是这样，请不要担心。你将得到全程指导。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Simple lists
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单列表
- en: Sorted lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序列表
- en: Linked lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: List-related interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与列表相关的接口
- en: Simple lists
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单列表
- en: Arrays are really useful data structures and they are applied in many algorithms.
    However, in some cases, their application could be complicated due to their nature,
    which does not allow you to increase or decrease the length of the already-created
    array. What should you do if you do not know the total number of elements to store
    in the collection? Do you need to create a very big array and just not use unnecessary
    elements? Such a solution does not sound good, does it? A much better approach
    is to use a data structure that makes it possible to dynamically increase and
    decrease the size of the collection if necessary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是非常有用的数据结构，它们在许多算法中都有应用。然而，在某些情况下，由于它们的性质，它们的适用可能会变得复杂，因为它们不允许你增加或减少已创建数组的长度。如果你不知道要存储在集合中的元素总数，你应该怎么做？你是否需要创建一个非常大的数组，然后不使用不必要的元素？这样的解决方案听起来并不好，对吧？一个更好的方法是在必要时使用一种数据结构，它可以使集合的大小动态增加或减少。
- en: Imagine a simple list
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简单的列表
- en: If you want to better visualize a simple list and distinguish it from an array,
    close your eyes for a moment and try to think back to when you were just a few
    years old and Christmas was approaching. You and your family were preparing a
    chain to hang on the Christmas tree. You took another piece of paper, passed it
    through the last piece of the chain, and glued the new piece of the chain together.
    In this way, your chain grew by another element, and you could add more and more
    elements to the chain, basically endlessly. Well, maybe the limitation was the
    amount of paper and glue or your tiredness. A list works somewhat similarly, where
    you can easily add new elements. You can also remove them, just like you can remove
    a piece of chain and then glue it back together and you can still hang it on your
    beautiful Christmas tree!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更好地可视化一个简单列表，并区分它与数组的不同，请闭上眼睛片刻，试图回忆起当你只有几岁的时候，圣诞节即将到来。你和你的家人正在准备挂在圣诞树上的链。你拿了一张另一张纸，穿过链的最后一段，将新的一段链粘合在一起。这样，你的链就通过另一个元素增长，你可以不断地向链中添加更多元素。好吧，也许限制是纸张和胶水的数量，或者你的疲劳。列表的工作方式与此类似，你可以轻松地添加新元素。你也可以像移除链的一段并将其重新粘合在一起一样移除它们，你仍然可以将它挂在你的美丽圣诞树上！
- en: Array lists
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组列表
- en: 'The first data structure that allows you to `ArrayList` class from the `System.Collections`
    namespace. You can use this class to store big collections of data, to which you
    can easily add new elements when necessary. Of course, you can also remove them,
    count items, and find an index of a particular value stored within the array list.
    How can you do this? Let’s take a look at the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个允许您从 `System.Collections` 命名空间中的 `ArrayList` 类的数据结构。您可以使用此类存储大量数据，并在需要时轻松添加新元素。当然，您也可以删除它们，计算项目数量，并在数组列表中找到特定值的索引。您如何做到这一点？让我们看看以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'ArrayList arrayList = Add, AddRange, and Insert methods to add new elements
    to the array list. The difference between them is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList 类的 `Add`, `AddRange`, 和 `Insert` 方法用于向数组列表中添加新元素。它们之间的区别如下：
- en: '`Add` adds a new item at the end of the list'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add` 在列表末尾添加一个新项目'
- en: '`AddRange` adds a collection of elements at the end of the array list'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddRange` 在数组列表末尾添加一系列元素'
- en: '`Insert` places an element in a specified location within the collection'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Insert` 在集合的指定位置放置一个元素'
- en: 'When the preceding code is executed, the array list contains the following
    elements: `5`, `6`, `-7`, `8`, `"Marcin"`, `7.8`, and `"Kate"`. Please keep in
    mind that all the items stored within the array list are of the `object` type.
    Thus, you can place various types of data in the same collection at the same time.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码时，数组列表包含以下元素：`5`, `6`, `-7`, `8`, `"Marcin"`，`7.8`，和 `"Kate"`。请记住，数组列表中存储的所有项目都是
    `object` 类型。因此，您可以在同一集合中同时放置各种类型的数据。
- en: Do you need to specify a type?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要指定类型吗？
- en: Using `object` instead of a particular type is not always a good idea. So, if
    you want to specify a type of each element stored within the list, you can use
    the generic `List` class, which will be described just after `ArrayList`. I encourage
    you to use a strongly typed version of a collection whenever possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `object` 而不是特定类型并不总是好主意。所以，如果您想指定列表中每个元素的类型，您可以使用通用的 `List` 类，它将在 `ArrayList`
    之后描述。我鼓励您在可能的情况下始终使用强类型版本的集合。
- en: 'It is worth mentioning that you can easily access a particular element within
    the array list using an index, as shown in the following two lines of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您可以使用索引轻松访问数组列表中的特定元素，如下面的两行代码所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: foreach (object element in arrayList)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (object element in arrayList)
- en: '{'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine(element);
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console.WriteLine(element);`'
- en: '}'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: int count = arrayList.Count;
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: int count = arrayList.Count;
- en: 'int capacity = arrayList.Count) returns the number of elements stored currently
    in the array list, while the other property (Capacity) indicates how many elements
    can be stored within it. If you check the value of the Capacity property after
    adding new elements to the array list, you will see that this value is automatically
    increased to prepare a place for new items. This is shown in the following figure,
    which presents the difference between Count (marked as A) and Capacity (B):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: int capacity = arrayList.Count) 返回当前存储在数组列表中的元素数量，而另一个属性（容量）表示可以存储在其中的元素数量。如果您在向数组列表添加新元素后检查容量属性的值，您将看到此值会自动增加以为新项目腾出空间。这如图所示，展示了
    Count（标记为 A）和 Capacity（B）之间的区别：
- en: '![Figure 4.1 – The difference between Count and Capacity](img/B18069_04_1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Count 和 Capacity 的区别](img/B18069_04_1.jpg)'
- en: Figure 4.1 – The difference between Count and Capacity
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Count 和 Capacity 的区别
- en: 'The next common and important task is checking whether the array list contains
    an element with a particular value. You can perform this operation by calling
    the `Contains` method, as shown in the following line of code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个常见且重要的任务是检查数组列表是否包含具有特定值的元素。您可以通过调用 `Contains` 方法来执行此操作，如下面的代码行所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'int minusIndex = arrayList.IndexOf method returns an index of the first occurrence
    of the element in the array list, while LastIndexOf returns an index of the last
    occurrence. If a value is not found, -1 is returned by the methods. Thus, you
    can use IndexOf to check whether the array list contains a given element. If the
    result is smaller than zero, this means that the element is not available. On
    the other hand, if the result is greater than or equal to zero, it indicates that
    the item is found, as presented in the following line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: int minusIndex = arrayList.IndexOf 方法返回数组列表中元素首次出现的索引，而 LastIndexOf 返回最后一次出现的索引。如果没有找到值，方法返回
    -1。因此，你可以使用 IndexOf 检查数组列表是否包含指定的元素。如果结果是小于零的，这意味着元素不可用。另一方面，如果结果是大于或等于零的，则表示找到了项目，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: arrayList.Remove(5);
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: arrayList.Remove(5);
- en: arrayList.RemoveAt(1);
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: arrayList.RemoveAt(1);
- en: arrayList.RemoveRange(1, 2);
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: arrayList.RemoveRange(1, 2);
- en: arrayList.Clear();
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: arrayList.Clear();
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: List<int> list = [6, 90, -20, 0, 4, 1, 8, -20, 41];
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: List<int> list = [6, 90, -20, 0, 4, 1, 8, -20, 41];
- en: int min = list.Min();
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: int min = list.Min();
- en: int max = list.Max();
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: int max = list.Max();
- en: int sum = list.Sum();
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = list.Sum();
- en: double avg = list.min is equal to -20, max is equal to 90, sum is equal to 110,
    and avg is near 12.22.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: double avg = list.min 等于 -20，max 等于 90，sum 等于 110，且 avg 接近 12.22。
- en: 'Now, let’s check out some conditions on the list elements:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查列表元素的一些条件：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: int existingElement = list.ElementAtOrDefault(5);
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: int existingElement = list.ElementAtOrDefault(5);
- en: int nonExistingElement = list.ElementAtOrDefault method to get a value of the
    element with an index equal to 5 and 100. In the first case, 1 is returned and
    stored as a value of the existingElement variable. When you try to get an element
    with the index equal to 100, a default value for int is used instead and returned,
    namely 0.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: int nonExistingElement = list.ElementAtOrDefault 方法用于获取索引等于5和100的元素的值。在第一种情况下，返回1并存储为
    existingElement 变量的值。当你尝试获取索引等于100的元素时，使用 int 的默认值代替并返回，即0。
- en: 'The next extension method is named `Distinct` and can be used as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个扩展方法是名为 `Distinct` 的方法，可以使用如下方式：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: List<int> ordered = list.-20, -20, 0, 1, 4, 6, 8, 41, and 90.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: List<int> ordered = list.-20, -20, 0, 1, 4, 6, 8, 41, and 90.
- en: 'Another interesting group of methods consists of `Skip` and `Take`, as shown
    here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的组方法包括 `Skip` 和 `Take`，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: int page = 1;
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: int page = 1;
- en: int size = 10;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: int size = 10;
- en: List<int> items = list
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: List<int> items = list
- en: .Skip((page - 1) * size)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: .Skip((page - 1) * size)
- en: .Take(size)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: .Take(size)
- en: .ToList();
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: .ToList();
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: List<double> num = [];
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: List<double> num = [];
- en: do
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: do
- en: '{'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.Write("Enter the number: ");'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'Console.Write("Enter the number: ");'
- en: string numStr = Console.ReadLine() ?? string.Empty;
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: string numStr = Console.ReadLine() ?? string.Empty;
- en: if (!double.TryParse(numStr, out double n)) { break; }
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: if (!double.TryParse(numStr, out double n)) { break; }
- en: num.Add(n);
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: num.Add(n);
- en: 'Console.WriteLine($"Average value: {num.Average()}");'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'Console.WriteLine($"Average value: {num.Average()}");'
- en: '}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: while (true);
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: while (true);
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Enter the number: 10.5'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数字：10.5
- en: 'Average value: 10.5 (...)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值：10.5 (...)
- en: 'Enter the number: 15.5'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数字：15.5
- en: 'Average value: 9.375'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值：9.375
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'public record Name, Age, and Country, which stores a country code. In the main
    part of the code, you create a new instance of the List class and add the data
    of a few people with different names, ages, and countries, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: public record Name, Age, and Country，它存储国家代码。在代码的主要部分，你创建一个新的 List 类实例，并添加一些具有不同姓名、年龄和国家的数据，如下所示：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the next line, you sort the list by names of people in ascending order:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，你按人员的姓名按升序排序列表：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This line can be simplified using the collection expression, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行可以使用集合表达式简化，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: foreach (Person p in r)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (Person p in r)
- en: '{'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string line = $"{p.Name} ({p.Age}) from {p.Country}.";
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: string line = $"{p.Name} ({p.Age}) from {p.Country}.";
- en: Console.WriteLine(line);
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(line);
- en: '}'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Marcin (35) from PL.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Marcin (35) from PL.
- en: Mark (31) from PL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Mark (31) from PL.
- en: Sabine (25) from DE.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Sabine (25) from DE.
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: List<string> names = people
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: List<string> names = people
- en: .Where(p => p.Age <= 30)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: .Where(p => p.Age <= 30)
- en: .OrderBy(p => p.Name)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: .OrderBy(p => p.Name)
- en: .Select(p => p.Name)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: .Select(p => p.Name)
- en: .Select clause) of all people whose age is lower than or equal to 30 years (the
    Where clause), ordered by names (the OrderBy clause). The query is then executed
    and the results are returned as a list (ToList).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: .Select 子句（Where clause）中所有年龄低于或等于30岁（OrderBy clause）的人员。查询然后执行，并将结果作为列表返回（ToList）。
- en: 'The same task can be accomplished using the `ToList` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的任务可以使用 `ToList` 方法完成：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: public record Person(
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: public record Person(
- en: string Name,
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: string Name,
- en: string Street,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: string Street,
- en: string PostalCode,
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: string PostalCode,
- en: string City,
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: string City,
- en: string Country);
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: string Country);
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: SortedList<string, Person> people = new()
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: SortedList<string, Person> people = new()
- en: '{'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '{ "Marcin Jamro", new("Marcin Jamro",'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '{ "Marcin Jamro", new("Marcin Jamro",'
- en: '"Polish Street 1/23", "35-001", "Rzeszow", "PL") },'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '"Polish Street 1/23", "35-001", "Rzeszow", "PL") },'
- en: '{ "Martyna Kowalska", new("Martyna Kowalska",'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '{ "Martyna Kowalska", new("Martyna Kowalska",'
- en: '"World Street 5", "00-123", "Warsaw", "PL") }'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '"World Street 5", "00-123", "Warsaw", "PL") }'
- en: '};'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: people.Add("Mark Smith", new("Mark Smith",
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: people.Add("Mark Smith", new("Mark Smith",
- en: '"German Street 6", "10000", "Berlin", "DE"));'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '"German Street 6", "10000", "Berlin", "DE"));'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: foreach ((string k, Person p) in people)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: foreach ((string k, Person p) in people)
- en: '{'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine($"{k}: {p.Street}, {p.PostalCode}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'Console.WriteLine($"{k}: {p.Street}, {p.PostalCode}'
- en: '{p.City}, {p.Country}.");'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '{p.City}, {p.Country}.");'
- en: '}'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Marcin Jamro: Polish Street 1/23, 35-001 Rzeszow, PL.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'Marcin Jamro: Polish Street 1/23, 35-001 Rzeszow, PL.'
- en: 'Mark Smith: German Street 6, 10000 Berlin, DE.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mark Smith: German Street 6, 10000 Berlin, DE.'
- en: 'Martyna Kowalska: World Street 5, 00-123 Warsaw, PL.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'Martyna Kowalska: World Street 5, 00-123 Warsaw, PL.'
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'public record Content property. Then, you create a few instances of the Page
    class, representing six pages of the book:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: public record Content property. 然后，你创建了几个Page类的实例，代表书的六页：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the instances have been created, you can construct the doubly linked list
    using a few addition-related methods, as shown in the following lines of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例创建完成后，可以使用一些与添加相关的方法构建双向链表，如下面的代码行所示：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the first line, a new empty list is created. Then, the given operations
    are performed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，创建了一个新的空列表。然后，执行以下给定操作：
- en: Add the second page at the end (`[2]`).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在末尾添加第二页（`[2]`）。
- en: Add the fourth page at the end (`[``2, 4]`).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在末尾添加第四页（`[2, 4]`）。
- en: Add the sixth page at the end (`[2,` `4, 6]`).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在末尾添加第六页（`[2, 4, 6]`）。
- en: Add the first page at the beginning of the list (`[1, 2,` `4, 6]`).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表开头添加第一页（`[1, 2, 4, 6]`）。
- en: Add the third page before the fourth page (`[1, 2, 3,` `4, 6]`).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四页之前添加第三页（`[1, 2, 3, 4, 6]`）。
- en: Add the fifth page after the fourth page (`[1, 2, 3, 4,` `5, 6]`).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四页之后添加第五页（`[1, 2, 3, 4, 5, 6]`）。
- en: 'The next part of the code is responsible for presenting a page in the console,
    as well as for navigating between pages after pressing the appropriate keys. The
    code is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分负责在控制台显示一页，以及按下适当的键后在页面之间导航。代码如下：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the first line, the value of the `c` variable is set to the first node in
    the doubly linked list. Generally speaking, the `c` variable represents the page
    that is currently presented in the console. Then, the initial value for the page
    number is set to `1` (the `number` variable). However, the most interesting and
    complicated part of the code is shown in the `while` loop.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，将`c`变量的值设置为双向链表的第一个节点。一般来说，`c`变量代表当前在控制台显示的页面。然后，将页面编号的初始值设置为`1`（`number`变量）。然而，代码中最有趣和复杂的部分是`while`循环。
- en: Within the loop, the current content of the console is cleared and the string
    for presenting the page number is properly formatted to display. Before and after
    it, the `-` characters are added. Moreover, leading spaces are inserted (using
    the `PadLeft` method) to prepare the string that is centered horizontally.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，清除控制台当前内容，并正确格式化用于显示页码的字符串。在其前后添加`-`字符。此外，插入前导空格（使用`PadLeft`方法）以准备水平居中的字符串。
- en: Then, the content of the page is divided into lines of no more than `90` characters
    and written in the console. To divide a string, the `Length` property and the
    `content[i..]`. Similarly, additional information is presented in the console.
    Then, `PREV` and `NEXT` captions are shown, if a previous or a next page is available.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将页面内容分成不超过`90`个字符的行，并在控制台写入。为了分割字符串，使用`Length`属性和`content[i..]`。同样，在控制台显示其他信息。然后，如果存在上一页或下一页，显示`PREV`和`NEXT`标题。
- en: Can you improve this example?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你能改进这个示例吗？
- en: This example divides the text into a few lines while not taking spaces into
    account. I encourage you to modify the code so that it supports more user-friendly
    text wrapping. Good luck!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将文本分成几行，而不考虑空格。我鼓励您修改代码，以便它支持更友好的文本换行。祝你好运！
- en: In the following part of the code, the program waits until the user presses
    any key and does not present it in the console (by passing `true` as a parameter
    of `ReadKey`). When the user presses *N*, the `c` variable is set to the next
    node, using the `Next` property. Of course, the operation should not be performed
    when the next page is unavailable. The *P* key is handled similarly, which causes
    the user to be navigated to the previous page. It is worth mentioning that the
    number of the page (the `number` variable) is modified alongside changing the
    value of the `c` variable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的后续部分，程序会等待用户按下任意键，并且不会在控制台（通过将`true`作为`ReadKey`参数）中显示它。当用户按下*N*键时，使用`Next`属性将`c`变量设置为下一个节点。当然，当下一页不可用时不执行此操作。*P*键的处理方式类似，这会导致用户导航到上一页。值得一提的是，页面编号（`number`变量）在`c`变量值改变的同时也会被修改。
- en: 'Finally, the code of the auxiliary `GetSpaces` method is shown:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，展示辅助方法`GetSpaces`的代码：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This prepares and returns the `string` variable with the specified number of
    spaces. Of course, there are several ways to perform this task. However, in this
    book, I wanted to show you various approaches, even those that are not so typical.
    The aim is to show you various ways of achieving your goal and making your horizons
    as broad as possible.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将准备并返回具有指定空格数的`string`变量。当然，有几种方法可以完成这个任务。然而，在这本书中，我想向你展示各种方法，甚至那些不太典型的方法。目的是向你展示实现目标的各种方式，并尽可能拓宽你的视野。
- en: With this, you should be ready to continue your adventure regarding lists. In
    the next section, you’ll learn about circular lists and their two subtypes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你应该准备好继续你的列表冒险之旅。在下一节中，你将学习关于循环列表及其两种子类型的内容。
- en: Circular singly linked lists
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 循环单链表
- en: In the previous two sections, you learned about linked lists. As you should
    remember, in a singly linked list, you can navigate between the nodes using the
    `Next` property. However, the `Next` property of the last node is set to `null`.
    Do you know that you can easily expand this approach to create a **circular singly
    linked list**, where **the last node points to the first element, creating a list
    that can be** **iterated endlessly?**
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中，你已经学习了链表。你应该记得，在单链表中，你可以使用`Next`属性在节点之间导航。然而，最后一个节点的`Next`属性被设置为`null`。你知道你可以轻松地扩展这种方法来创建一个**循环单链表**，其中**最后一个节点指向第一个元素，创建一个可以无限迭代的列表**吗？
- en: Imagine a circular singly linked list
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个循环单链表
- en: If you want to better imagine a circular singly linked list, think for a moment
    about a screensaver showing photos from a specific folder. After a certain period
    of inactivity, your screen starts showing photos, one after the other. When the
    last photo is displayed, the first one from the catalog is shown automatically.
    Of course, you can’t control the photos yourself, because any interaction with
    the keyboard or mouse turns off the screensaver. A circular singly linked list
    works similarly. Here, only information about the next list element is saved,
    without the possibility of going back. The last element of the list takes you
    to the very beginning. It’s so easy once you can imagine a real-life case, right?
    Now, move your mouse to make the screensaver disappear, and get back to learning
    more about data structures and algorithms!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地想象一个循环单链表，那么请稍作思考，想象一下显示特定文件夹照片的屏保。在一段时间的不活动后，你的屏幕开始依次显示照片。当最后一张照片显示完毕后，目录中的第一张照片会自动显示。当然，你无法自己控制这些照片，因为任何与键盘或鼠标的交互都会关闭屏保。循环单链表的工作原理与此类似。在这里，只保存关于下一个列表元素的详细信息，而没有返回的可能性。列表的最后一个元素将你带到最开始的位置。一旦你能想象出一个现实生活中的案例，那就很容易理解了，对吧？现在，移动你的鼠标使屏保消失，然后继续学习更多关于数据结构和算法的知识！
- en: 'The following figure illustrates a circular singly linked list:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了循环单链表：
- en: '![Figure 4.5 – Illustration of a circular singly linked list](img/B18069_04_5.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 循环单链表的示意图](img/B18069_04_5.jpg)'
- en: Figure 4.5 – Illustration of a circular singly linked list
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 循环单链表的示意图
- en: 'After this short introduction to the topic of circular singly linked lists,
    it is time to take a look at the implementation code. As this data structure is
    not available by default while developing in C#, you will learn how to implement
    it on your own, based on a linked list. Let’s start with the following code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在对循环单链表主题的简要介绍之后，现在是时候看看实现代码了。由于在C#开发中默认情况下没有这种数据结构，你将学习如何基于链表自己实现它。让我们从以下代码片段开始：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementation can be created as a generic class that extends `LinkedList`,
    as shown in the preceding code. It is worth mentioning the implementation of the
    `GetEnumerator` method, which uses the `CircularEnumerator` class. By creating
    it, you will be able to endlessly iterate through all the elements of a circular
    linked list using a `foreach` loop. The code of `CircularEnumerator` is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以创建为一个泛型类，它扩展了`LinkedList`，如前所述代码所示。值得一提的是`GetEnumerator`方法的实现，它使用了`CircularEnumerator`类。通过创建它，你将能够使用`foreach`循环无限迭代循环链表的所有元素。`CircularEnumerator`的代码如下：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `CircularEnumerator` class implements the `IEnumerator` interface. This
    class declares the `private` field, which represents the current node (`_current`)
    in the iteration over the list. It also contains two properties, namely `Current`
    and `IEnumerator.Current`, which are required by the `IEnumerator` interface.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`CircularEnumerator`类实现了`IEnumerator`接口。这个类声明了一个`private`字段，它代表迭代列表时的当前节点（`_current`）。它还包含两个属性，即`Current`和`IEnumerator.Current`，这是`IEnumerator`接口所要求的。'
- en: One of the most important parts of the code is the `MoveNext` method. This checks
    whether the current element is equal to `null`. If so, it tries to get the first
    element from the list and starts iterating from it. If it does not exist, the
    method returns `false` since there are no items in the list. If the current element
    is not equal to `null`, it changes the current element to the next one or the
    first node in the list, if the next node is unavailable. In the `Reset` method,
    you just set a value of the `_current` field to `null`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最重要的部分之一是`MoveNext`方法。它检查当前元素是否等于`null`。如果是，它尝试从列表中获取第一个元素并从它开始迭代。如果不存在，由于列表中没有项目，该方法返回`false`。如果当前元素不等于`null`，它将当前元素更改为下一个元素或列表中的第一个节点，如果下一个节点不可用。在`Reset`方法中，你只需将`_current`字段的值设置为`null`。
- en: 'Finally, you create the `Next` extension method that navigates to the first
    element while trying to get the next element from the last item in the list. To
    simplify the implementation, such a feature will be available as a method, instead
    of the `Next` property. The code is shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你创建了`Next`扩展方法，在尝试从列表的最后一个元素获取下一个元素时导航到第一个元素。为了简化实现，这个功能将作为一个方法而不是`Next`属性提供。代码如下所示：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method checks whether the node exists and whether the list is available.
    In such a case, it returns a value of the `Next` property of the node (if such
    a value is not equal to `null`) or returns a reference to the first element in
    the list using the `First` property.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法检查节点是否存在以及列表是否可用。在这种情况下，它返回节点的`Next`属性值（如果该值不等于`null`）或使用`First`属性返回列表中的第一个元素的引用。
- en: That’s all! You’ve just completed the C#-based implementation of a circular
    singly linked list that you can use in various applications. But how? Let’s take
    a look at the following example, which uses this data structure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！你已经完成了基于C#的循环单链表的实现，你可以在各种应用中使用它。但如何使用呢？让我们看看以下示例，它使用了这种数据结构。
- en: Example – spin the wheel
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 旋转轮子
- en: 'This example simulates a game in which a user spins a wheel at a random speed.
    The wheel rotates slower and slower until it stops. Then, the user can spin it
    again, from the previous stop position, as shown in the following figure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子模拟了一个用户以随机速度旋转轮子的游戏。轮子旋转得越来越慢，直到停止。然后，用户可以从之前的停止位置再次旋转，如图所示：
- en: '![Figure 4.6 – Illustration of the spin the wheel example](img/B18069_04_6.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 旋转轮子示例的说明](img/B18069_04_6.jpg)'
- en: Figure 4.6 – Illustration of the spin the wheel example
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 旋转轮子示例的说明
- en: 'Let’s proceed to the first part of the code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续代码的第一部分：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: bool isStopped = true;
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: bool isStopped = true;
- en: Random random = new();
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Random random = new();
- en: DateTime targetTime = DateTime.Now;
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime targetTime = DateTime.Now;
- en: int ms = 0;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: int ms = 0;
- en: foreach (string category in categories)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (string category in categories)
- en: '{'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (isStopped)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: if (isStopped)
- en: '{'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Press [Enter] to start.");
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("按[Enter]键开始。");
- en: ConsoleKey key = Console.ReadKey().Key;
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleKey key = Console.ReadKey().Key;
- en: if (key == ConsoleKey.Enter)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: if (key == ConsoleKey.Enter)
- en: '{'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: ms = random.Next(1000, 5000);
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ms = random.Next(1000, 5000);
- en: targetTime = DateTime.Now.AddMilliseconds(ms);
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: targetTime = DateTime.Now.AddMilliseconds(ms);
- en: isStopped = false;
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: isStopped = false;
- en: Console.WriteLine(category);
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(category);
- en: '}'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else { return; }
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: else { return; }
- en: '}'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int remaining = (int)(targetTime
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: int remaining = (int)(targetTime
- en: '- DateTime.Now).TotalMilliseconds;'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '- DateTime.Now).TotalMilliseconds;'
- en: int waiting = Math.Max(100, (ms - remaining) / 5);
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: int waiting = Math.Max(100, (ms - remaining) / 5);
- en: await Task.Delay(waiting);
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: await Task.Delay(waiting);
- en: if (DateTime.Now >= targetTime)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: if (DateTime.Now >= targetTime)
- en: '{'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.ForegroundColor = ConsoleColor.Red;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ForegroundColor = ConsoleColor.Red;
- en: isStopped = true;
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: isStopped = true;
- en: '}'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Console.WriteLine(category);
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(category);
- en: Console.ResetColor();
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ResetColor();
- en: '}'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: public static class CircularLinkedListExtensions
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: public static class CircularLinkedListExtensions
- en: '{'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static LinkedListNode<T>? Next<T>(
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: public static LinkedListNode<T>? Next<T>(
- en: this LinkedListNode<T> n)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: this LinkedListNode<T> n)
- en: '{'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return n != null && n.List != null
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: return n != null && n.List != null
- en: '? n.Next ?? n.List.First'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '? n.Next ?? n.List.First'
- en: ': null;'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ': null;'
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static LinkedListNode<T>? Prev<T>(
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: public static LinkedListNode<T>? Prev<T>(
- en: this LinkedListNode<T> n)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: this LinkedListNode<T> n)
- en: '{'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return n != null && n.List != null
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: return n != null && n.List != null
- en: '? n.Previous ?? n.List.Last'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '? n.Previous ?? n.List.Last'
- en: ': null;'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ': null;'
- en: '}'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: string[][] arts = GetArts();
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: string[][] arts = GetArts();
- en: CircularLinkedList<string[]> images = new();
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CircularLinkedList<string[]> images = new();
- en: foreach (string[] art in arts) { images.AddLast(art); }
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (string[] art in arts) { images.AddLast(art); }
- en: LinkedListNode<string[]> node = images.First!;
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: LinkedListNode<string[]> node = images.First!;
- en: ConsoleKey key = ConsoleKey.Spacebar;
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleKey key = ConsoleKey.Spacebar;
- en: do
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: do
- en: '{'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (key == ConsoleKey.RightArrow)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: if (key == ConsoleKey.RightArrow)
- en: '{'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: node = node.Next()!;
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: node = node.Next()!;
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (key == ConsoleKey.LeftArrow)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: else if (key == ConsoleKey.LeftArrow)
- en: '{'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: node = node.Prev()!;
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: node = node.Prev()!;
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Console.Clear();
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Console.Clear();
- en: foreach (string line in node.Value)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (string line in node.Value)
- en: '{'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine(line);
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(line);
- en: '}'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: while ((key = Console.ReadKey().Key) != ConsoleKey.Escape);
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: while ((key = Console.ReadKey().Key) != ConsoleKey.Escape);
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: string[][] GetArts() => [
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: string[][] GetArts() => [
- en: '['
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '"  +-----+  ",'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '"  +-----+  ",'
- en: '"o-| o o |-o",'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '"o-| o o |-o",'
- en: '"|  -  |  ",'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '"|  -  |  ",'
- en: '"  +-----+  ",'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '"  +-----+  ",'
- en: '"    | |    "'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '"    | |    "'
- en: '],'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '['
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '"o +-----+  ",'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '"o +-----+  ",'
- en: '" \\| o o |\\ ",'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '" \\| o o |\\ ",'
- en: '"  |  -  | o",'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '"  |  -  | o",'
- en: '"  +-----+  ",'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '"  +-----+  ",'
- en: '"    / |    "'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '"    / |    "'
- en: '],'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '['
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '"+-----+ o",'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '"+-----+ o",'
- en: '" /| o o |/ ",'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '" /| o o |/ ",'
- en: '"o |  -  |  ",'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '"o |  -  |  ",'
- en: '"  +-----+  ",'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '"  +-----+  ",'
- en: '"    | \\    "'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '"    | \\    "'
- en: ']'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '];'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '];'
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
