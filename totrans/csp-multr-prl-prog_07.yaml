- en: Chapter 7. Data Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。数据并行
- en: Concurrently performing a task or a set of operations on a collection of data
    is referred to as data parallelism. For example, if we have a list of files in
    a folder and we want to rename them all, we can create a `For` loop that goes
    through the collection and, during each iteration, the loop performs a rename
    command. We can also iterate through a collection datatype such as a `List` or
    `DataView` using a `foreach` statement. These are specialized `For` and `ForEach`
    statements that are part of the **Task Parallel Library** (**TPL**) in the `System.Threading.Tasks.Parallel`
    namespace.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据集合或数据集合上并发执行任务或一系列操作被称为数据并行。例如，如果我们有一个文件夹中的文件列表，并且我们想要将它们全部重命名，我们可以创建一个 `For`
    循环遍历集合，并在每次迭代期间执行重命名命令。我们还可以使用 `foreach` 语句遍历集合数据类型，如 `List` 或 `DataView`。这些是
    **Task Parallel Library** (**TPL**) 中的专用 `For` 和 `ForEach` 语句，位于 `System.Threading.Tasks.Parallel`
    命名空间中。
- en: The TPL provides the `Parallel` library to make it easy to perform concurrent
    operations on a dataset or data collection using the different overloads of the
    `Parallel.For` and `Parallel.ForEach` methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 提供了 `Parallel` 库，使用 `Parallel.For` 和 `Parallel.ForEach` 方法的不同重载，可以轻松地在数据集或数据集合上执行并发操作。
- en: 'In this chapter, we will learn how to process items of a data source in parallel
    using the `Parallel.For` and `Parallel.ForEach` methods. We will also examine
    the `ParallelLoopState` class, which allows us to examine the results of a concurrent
    loop and perform actions with the results. Finally, we will learn how to cancel
    a concurrent loop before it has completed. In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 `Parallel.For` 和 `Parallel.ForEach` 方法并行处理数据源中的项。我们还将检查 `ParallelLoopState`
    类，它允许我们检查并发循环的结果并使用结果执行操作。最后，我们将学习如何在并发循环完成之前取消它。在本章中，我们将涵盖：
- en: Parallel data processing with `Parallel.For`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Parallel.For` 进行并行数据处理
- en: Parallel data processing of `IEnumerable` collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable` 集合的并行数据处理'
- en: Using the results of concurrent data loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发数据循环的结果
- en: Canceling a parallel loop operation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消并行循环操作
- en: Parallel loop processing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行循环处理
- en: 'In this first section, we will examine the `Parallel.For` method and several
    variations of it. The most basic overload to this method takes a starting index,
    an ending index, and an `Action` delegate. In the `Parallel` method, the `Action`
    delegate can be implemented with a named method, anonymous method, or a lambda
    expression. The following is the basic syntax for each method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，我们将检查 `Parallel.For` 方法及其几种变体。此方法最基本的重载接受一个起始索引、一个结束索引和一个 `Action`
    委托。在 `Parallel` 方法中，`Action` 委托可以用命名方法、匿名方法或 lambda 表达式实现。以下是为每个方法的基本语法：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In each example, the method or lambda expression takes a single parameter that
    is the iteration value. If you need more control over the execution of the concurrent
    loop, there are overload methods that take a `ParallelLoopState` parameter that
    is internally generated by .NET. We will talk about this later in the chapter,
    but it allows us to do things such as canceling a parallel loop or performing
    an action for each iteration of the loop once it is completed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个示例中，方法或 lambda 表达式接受一个单一参数，即迭代值。如果您需要更多控制并发循环的执行，有重载方法接受由 .NET 内部生成的 `ParallelLoopState`
    参数。我们将在本章后面讨论这一点，但它允许我们执行诸如取消并行循环或在每个循环迭代完成后执行操作等活动。
- en: 'Here is a list of all of the overloads of the `Parallel.For` method:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Parallel.For` 方法的所有重载列表：
- en: '![Parallel loop processing](img/8321EN_07_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![并行循环处理](img/8321EN_07_01.jpg)'
- en: MSDN reference—http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.for(v=vs.110).aspx
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN 参考—http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.for(v=vs.110).aspx
- en: Also, as well as a `ParallelLoopState` parameter, some overloads allow the method
    to return a thread-safe local variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，除了 `ParallelLoopState` 参数之外，一些重载允许方法返回线程安全的局部变量。
- en: Now, let's take a look at an example. We will build a simple **Windows Presentation
    Foundation** (**WPF**) application that takes an array of integer numbers, performs
    a calculation on them, and then updates the item in the array. This will be done
    concurrently instead of sequentially.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个例子。我们将构建一个简单的 **Windows Presentation Foundation** (**WPF**) 应用程序，它接受一个整数数组，对这些数字进行计算，然后更新数组中的项。这将并行执行而不是顺序执行。
- en: How to do it
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'For this example, we will create a WPF application that allows the user to
    enter numbers in 10 boxes and click on a button. Once the button is clicked, it
    will concurrently take each number and multiply it by the numbers 1 through 10
    and sum the results. The result of each calculation will be placed back in each
    box. Perform the following steps to do so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将创建一个WPF应用程序，允许用户在10个框中输入数字并点击一个按钮。一旦点击按钮，它将同时取每个数字并将其乘以1到10的数字，并求和结果。每个计算的结果将放回每个框中。执行以下步骤来完成：
- en: Open Visual Studio and create a WPF application named `ParallelMath1`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并创建一个名为`ParallelMath1`的WPF应用程序。
- en: 'In the `MainWindow.xaml` design view, change the page title to `ParallelMath`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml`设计视图中，将页面标题更改为`ParallelMath`：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, create 10 textbox controls and place them in the `MainWindow.xaml` file
    with the names, `tb1`, `tb2`, `tb3`, `tb4`, `tb5`, `tb6`, `tb7`, `tb8`, `tb9`,
    and `tb10` respectively. Also, set their `Text` properties to `0`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建10个文本框控件，并将它们分别命名为`tb1`、`tb2`、`tb3`、`tb4`、`tb5`、`tb6`、`tb7`、`tb8`、`tb9`和`tb10`，放置在`MainWindow.xaml`文件中。同时，将它们的`Text`属性设置为`0`。
- en: Now, place a button control on the `MainWindow.xaml` file and set the `Content`
    property to `Calculate` and the `Name` property to `btnCalculate`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`MainWindow.xaml`文件中放置一个按钮控件，并将`Content`属性设置为`Calculate`，将`Name`属性设置为`btnCalculate`。
- en: Next, create an event handler for the button's click event named `btnCalculate_Click`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为按钮的点击事件创建一个名为`btnCalculate_Click`的事件处理程序。
- en: 'Inside the class definition, place a line of code to create an array of 10
    integers:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类定义内部，放置一行代码来创建一个包含10个整数的数组：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, put the following code inside the `btnCalculate_Click` event handler:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码放入`btnCalculate_Click`事件处理程序中：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, create a method named `CalculateNumbers` and put the following code
    into it:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`CalculateNumbers`的方法，并将以下代码放入其中：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That should be all. Now, let's run our application and see what happens. Remember
    we have not put in any error handling. The application expects a number and only
    a number in each textbox when the **Calculate** button is clicked. If it is not
    there, the application will throw an argument out of range exception.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了。现在，让我们运行我们的应用程序并看看会发生什么。记住我们没有添加任何错误处理。应用程序在点击**计算**按钮时期望每个文本框中只有一个数字。如果没有，应用程序将抛出一个参数超出范围的异常。
- en: 'You should see results similar to this before you click on the button:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击按钮之前，你应该看到类似以下的结果：
- en: '![How to do it](img/8321EN_07_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_02.jpg)'
- en: 'Now, let''s enter 10 numbers into our textboxes so that the application looks
    something like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的文本框中输入10个数字，以便应用程序看起来像以下这样：
- en: '![How to do it](img/8321EN_07_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_03.jpg)'
- en: 'Now, click on the **Calculate** button and you should see the following results
    very quickly since we are doing these calculations concurrently:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击**计算**按钮，你应该会非常快地看到以下结果，因为我们正在并行进行这些计算：
- en: '![How to do it](img/8321EN_07_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_04.jpg)'
- en: How it works
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: In the preceding exercise, we entered 10 numbers into 10 textboxes and then
    clicked on **Calculate**. The program then took each number, multiplied it by
    the numbers 1 through 10, and summed them together. It then placed the result
    back in the textbox it came from.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我们在10个文本框中输入了10个数字，然后点击了**计算**。程序随后将每个数字乘以1到10的数字，并将它们相加。然后，它将结果放回原始的文本框中。
- en: This was all done concurrently. Each textbox was processed in parallel. This
    may have been on 10 separate threads or fewer, depending on the hardware we run
    the program on. Unlike using threads directly by using the `Parallel` class and
    TPL, .NET manages the threadpool and maximizes how many threads to perform the
    concurrent operation on, using the processing cores available on the machine.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在并行完成的。每个文本框都是并行处理的。这可能是10个单独的线程或更少，具体取决于我们在其上运行程序的硬件。与直接使用`Parallel`类和TPL使用线程不同，.NET管理线程池，并最大化在机器上可用的处理核心上执行并行操作时的线程数。
- en: Let's look at how the concurrent loop is executed. It is the single command
    `Parallel.For(0, 9, CalculateNumbers);`. This command queues 10 tasks to the threadpool
    and each task will execute the `CalculateNumbers` method with an integer parameter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看并发循环是如何执行的。它是单个命令`Parallel.For(0, 9, CalculateNumbers);`。此命令将10个任务排队到线程池中，每个任务将使用整数参数执行`CalculateNumbers`方法。
- en: Now, let's look at the `Parallel.ForEach` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Parallel.ForEach`命令。
- en: Data parallelism on collections using Parallel.ForEach
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel.ForEach在集合上实现数据并行
- en: The form of data parallelism that I find most helpful is performing concurrent
    operations on collections of data. This allows us to take data collections such
    as lists, dataviews, dictionaries, and so on and perform a task on each item in
    the collection in parallel with a single line of code! This makes using data parallelism
    simpler; you have to do nothing more than normal data processing. This is one
    of the reasons why the TPL is such a wonderful enhancement to .NET.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现最有用的数据并行形式是对数据集合执行并发操作。这允许我们对列表、数据视图、字典等数据集合执行任务，并在单行代码中并行地对集合中的每个项执行任务！这使得使用数据并行化更加简单；您无需做任何超出常规数据处理的事情。这也是为什么
    TPL 是 .NET 中如此美妙的功能增强之一的原因。
- en: 'Much like the `Parallel.For` method, the structure of `Parallel.ForEach` looks
    like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Parallel.For` 方法类似，`Parallel.ForEach` 的结构如下所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are two parameters in the most basic version of this method. There is
    a data collection and an `Action` delegate to perform a task on an item of the
    `dataCollection`. The `Action` delegate takes a single parameter that is an item
    in the collection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法的最基本版本中，有两个参数。有一个数据集合和一个用于在 `dataCollection` 的项上执行任务的 `Action` 委托。`Action`
    委托接受一个参数，该参数是集合中的一个项。
- en: 'The following are all of the different overloads of the `ForEach` method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下都是 `ForEach` 方法的不同重载：
- en: '![Data parallelism on collections using Parallel.ForEach](img/8321EN_07_05.jpg)![Data
    parallelism on collections using Parallel.ForEach](img/8321EN_07_06.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Parallel.ForEach 在集合上实现数据并行](img/8321EN_07_05.jpg)![使用 Parallel.ForEach
    在集合上实现数据并行](img/8321EN_07_06.jpg)'
- en: Reference—http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.foreach(v=vs.110).aspx
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 参考—http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.foreach(v=vs.110).aspx
- en: As you can see, there are many different overloads to this method. They allow
    us to use a `ParallelLoopState` object or a thread-safe local variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此方法有许多不同的重载。它们允许我们使用 `ParallelLoopState` 对象或线程安全的局部变量。
- en: We will focus on the simple form of just performing concurrent processing on
    a data collection. To further reiterate this point, let's revisit a project we
    worked on earlier in the book. In [Chapter 4](ch04.html "Chapter 4. Advanced Thread
    Processing"), *Advanced Thread Processing*, we wrote an application that took
    a JPG image, divided it into separate bitmaps, and then performed parallel functions
    on each bitmap to find old stars. It then reassembled the individual bitmaps back
    into a single image.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于仅对数据集合执行并发处理这种简单形式。为了进一步重申这一点，让我们回顾一下本书中早期工作的一个项目。在 [第 4 章](ch04.html
    "第 4 章。高级线程处理")，*高级线程处理*中，我们编写了一个应用程序，它接受 JPG 图像，将其分割成单独的位图，然后对每个位图执行并行函数以查找旧星。然后它将单个位图重新组装成单个图像。
- en: We will rewrite this application using data parallelism and the TPL instead
    of threads directly. This will demonstrate how TPL can simplify multithreaded
    code development
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用数据并行化和 TPL 而不是直接使用线程来重写此应用程序。这将展示 TPL 如何简化多线程代码开发。
- en: No longer do we have to manage threads (start them, wait on them to complete,
    or track them). We no longer have to manage the number of processing cores our
    machine has to maximize performance without starting too many individual threads.
    All we have to do is separate our large image into a collection of smaller bitmaps
    and use a `Parallel.ForEach` concurrent loop to process each bitmap. That's it.
    Let's get started.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要管理线程（启动它们、等待它们完成或跟踪它们）。我们不再需要管理机器上的处理核心数量，以在不启动太多单独线程的情况下最大化性能。我们只需要将大图像分割成一系列较小的位图，并使用
    `Parallel.ForEach` 并发循环来处理每个位图。就是这样。让我们开始吧。
- en: How to do it
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'We will take our original `OldStarsFinder` Windows Form application and change
    it. To do this let''s perform the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改原始的 `OldStarsFinder` Windows 表单应用程序。为此，让我们执行以下步骤：
- en: First, let's open our `OldStarsFinder` application in Visual Studio.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在 Visual Studio 中打开我们的 `OldStarsFinder` 应用程序。
- en: 'Let''s add a new `using` statement so we can access the `Parallel` library:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个新的 `using` 语句，以便我们可以访问 `Parallel` 库：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the beginning of the class definition, remove all of the old variable declarations
    and replace them with just these:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类定义的开始处，删除所有旧的变量声明，并用以下内容替换它们：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Replace the `CropBitmap` method with this method definition:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CropBitmap` 方法替换为以下方法定义：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can leave the `IsOldStar` method as is.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将 `IsOldStar` 方法保持原样。
- en: 'Change the `ThreadOldStarsFinder` method to look like this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ThreadOldStarsFinder` 方法修改如下：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then change the `ShowBitmapWithOldStars` method to look like this:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将`ShowBitmapWithOldStars`方法更改为如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, change the `butFindOldStars_Click` event handler to have the following
    code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`butFindOldStars_Click`事件处理程序更改为以下代码：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then add a label control with the text, `Number of bitmaps to divide into for
    processing:`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个带有文本`Number of bitmaps to divide into for processing:`的标签控件。
- en: Also, add a textbox control and set its `Name` property to `tbTasks`. This will
    be used to allow you to designate the number of sections you want the bitmap divided
    into.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加一个文本框控件，并将其`Name`属性设置为`tbTasks`。这将允许你指定你想要将位图分割成多少部分。
- en: Finally, we remove the `butFindOldStarsBatch` button because we do not need
    it in this application.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们移除了`butFindOldStarsBatch`按钮，因为在这个应用程序中我们不需要它。
- en: That should be all you need to do to run this application using data parallelism
    with the Task Parallel Library.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任务并行库进行数据并行运行此应用程序，你需要做的就这些。
- en: 'Let''s compile and run our application. You should get something like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行我们的应用程序。你应该会得到类似这样的结果：
- en: '![How to do it](img/8321EN_07_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_07.jpg)'
- en: 'Now, enter the number of bitmaps to divide the image into and click on the
    **Old Star Finder** button. The application will now look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入要将图像分割成多少个位图的数字，并点击**Old Star Finder**按钮。应用程序现在看起来是这样的：
- en: '![How to do it](img/8321EN_07_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_08.jpg)'
- en: What just happened? We entered `8` for the number of bitmaps to divide into.
    The application splits the JPG image into 8 equal-sized bitmaps and then into
    a list collection of bitmaps. Then it concurrently processes each bitmap looking
    for old stars. Finally, it reassembles the bitmaps into one image and redisplays
    it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才发生了什么？我们输入了`8`作为要分割的位图数量。应用程序将JPG图像分割成8个大小相等的位图，然后将其放入位图列表集合中。然后它并发处理每个位图以寻找旧星。最后，它将位图重新组装成一张图像并重新显示。
- en: Let's take a closer look at what just happened.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看刚才发生了什么。
- en: How it works
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'If you compare the two versions of the program, you will see that the second
    version is much simpler with less code. If we examine the `butOldStarsFinder_Click`
    event handler method, we will see most of the work. First, we divide our image
    up into a `List` collection of smaller bitmaps based on the number we entered.
    Here is the code that does this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较程序的两个版本，你会看到第二个版本代码更少，更简单。如果我们检查`butOldStarsFinder_Click`事件处理方法，我们会看到大部分的工作。首先，我们根据输入的数量将我们的图像分成一个包含较小位图的`List`集合。以下是完成此操作的代码：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we take our list collection, `BitmapList`, and use it in a parallel `ForEach`
    command in this line of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的列表集合`BitmapList`用于此行代码中的并行`ForEach`命令：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, when this loop has completed, we display the image with the old stars
    with this method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当这个循环完成后，我们使用这个方法显示带有旧星的图像：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That is it. We no longer have to find out how many cores the processor has and
    create that many threads. No matter how many items there are in our collection,
    .NET maximizes the threads in the threadpool to achieve optimal performance. It
    will create threads if needed or reuse existing threads if possible. This saves
    on the overhead of starting more threads than can be effectively used by the number
    of cores in the machine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们不再需要找出处理器有多少核心，并创建那么多线程。无论我们的集合中有多少项，.NET都会将线程池中的线程最大化以实现最佳性能。如果需要，它会创建线程，如果可能，它会重用现有的线程。这节省了比机器核心数能有效地使用的线程更多的开销。
- en: You can now see why writing multithreaded code using TPL is called lightweight
    concurrency. This version of the Old Stars Finder is definitely "lighter" on the
    code and logic than the previous version written directly with threads or heavyweight
    concurrency.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以明白为什么使用TPL编写的多线程代码被称为轻量级并发。这个版本的旧星查找器在代码和逻辑上肯定比直接使用线程或重量级并发编写的上一个版本“更轻”。
- en: Canceling a parallel loop
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消并行循环
- en: Now that we have learned how to execute a parallel loop using a `Parallel` class
    library, let's take a look at how we can stop or break a loop if needed. With
    a normal `For` or `ForEach` loop we can use a `Continue` command to break from
    a loop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何使用`Parallel`类库执行并行循环，让我们看看如果需要，我们如何停止或中断循环。使用正常的`For`或`ForEach`循环，我们可以使用`Continue`命令从循环中退出。
- en: If we break from a parallel loop, then we complete all iterations on the threads
    that are currently executing and then stop. If we `Stop` a parallel loop, then
    we stop all currently running iterations of the loop as soon as possible, but
    we do not run them to completion. In either case, we will not schedule tasks on
    the threadpool for the rest of the iterations of the parallel loop that we are
    yet to get started with.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从并行循环中跳出，那么我们将完成当前正在执行的线程上的所有迭代，然后停止。如果我们 `Stop` 一个并行循环，那么我们将尽可能快地停止循环的所有当前运行迭代，但我们不会将它们运行到完成。在两种情况下，我们都不会为尚未开始的并行循环的其余迭代在线程池上调度任务。
- en: To perform a break or a stop of a parallel loop, we need to use the `ParallelLoopState`
    object. This means that we have to use one of the overloads or the `Parallel.For`
    or `Parallel.ForEach` method that takes a `ParallelLoopState` parameter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行并行循环的跳出或停止，我们需要使用 `ParallelLoopState` 对象。这意味着我们必须使用 `Parallel.For` 或 `Parallel.ForEach`
    方法的一个重载，该方法接受 `ParallelLoopState` 参数。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: What is the `ParallelLoopState` class? This class cannot be instantiated in
    your user code. It is provided by the TPL and .NET and hence is a special class.
    This object provides your parallel loop with a mechanism to interact with other
    iterations in the loop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelLoopState` 类是什么？这个类不能在你的用户代码中实例化。它由 TPL 和 .NET 提供，因此是一个特殊类。此对象为你的并行循环提供了一个与其他循环迭代交互的机制。'
- en: The `break` and `stop` methods are the methods you will use most often, as well
    as the `IsStopped` and `IsExceptional` properties. These properties allow you
    to check whether any iteration of the loop has called `Stop` or thrown an exception.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 和 `stop` 方法是你将最常使用的，以及 `IsStopped` 和 `IsExceptional` 属性。这些属性允许你检查循环的任何迭代是否调用了
    `Stop` 或抛出了异常。'
- en: Now, we will take our `ParallelMath1` example and change it to stop the loop
    after seven iterations. This is arbitrary, for example purposes. But in a real
    example, there are many conditions where you will want to break or stop from a
    parallel loop.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的 `ParallelMath1` 示例更改为在七次迭代后停止循环。这是任意的，仅用于示例。但在实际示例中，有许多条件你将想要从并行循环中跳出或停止。
- en: How to do it
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'We just need to make a few adjustments to our previous program. Let''s start
    by opening the `ParallelMath1` WPF application in Visual Studio and making the
    following changes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要对我们的上一个程序做一些调整。让我们首先在 Visual Studio 中打开 `ParallelMath1` WPF 应用程序，并进行以下更改：
- en: 'Create a new method called `CalculateNumbers2` and place the following code
    into it:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CalculateNumbers2` 的新方法，并将以下代码放入其中：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then change our `Parallel.For` command to call this new method:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将我们的 `Parallel.For` 命令更改为调用此新方法：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s it. Now, let''s run our application and put numbers in each of the
    boxes so that it looks like the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，让我们运行我们的应用程序，并将数字放入每个框中，使其看起来像以下截图：
- en: '![How to do it](img/8321EN_07_09.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现](img/8321EN_07_09.jpg)'
- en: 'Now, click on the **Calculate** button and your results should look like the
    following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击 **Calculate** 按钮，你的结果应该看起来像以下截图：
- en: '![How to do it](img/8321EN_07_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现](img/8321EN_07_10.jpg)'
- en: What do you see? Yes, after seven iterations of the parallel loop, the loop
    is stopped and the last three iterations are not finished. Let's examine why.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了什么？是的，在并行循环的七次迭代后，循环停止，最后三次迭代没有完成。让我们看看原因。
- en: How it works
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'By adding the `ParallelLoopState` parameter to the method called by the parallel
    `For` method, we actually change the overload of the method that is called. We
    are now calling this overload:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `ParallelLoopState` 参数添加到由并行 `For` 方法调用的方法中，我们实际上改变了被调用方法的重载。我们现在调用这个重载：
- en: '![How it works](img/8321EN_07_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理](img/8321EN_07_11.jpg)'
- en: You will notice that we do not create this `ParallelLoopState` variable and
    pass it into the `CalculateNumbers2` method. It is done by .NET and we can just
    use it. Pretty handy!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们没有创建这个 `ParallelLoopState` 变量并将其传递给 `CalculateNumbers2` 方法。这是由 .NET 完成的，我们可以直接使用它。非常方便！
- en: 'Now, in our `Action` delegate, `CalculateNumbers2`, we call the `Stop` method
    of this object using the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `Action` 委托 `CalculateNumbers2` 中，我们使用以下命令调用此对象的 `Stop` 方法：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once this method is called, the rest of the iterations of the loop are not performed
    and the loop completes with the iterations it has already completed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用此方法，循环的其余迭代将不会执行，循环将使用已经完成的迭代完成。
- en: This is not a very practical example—why execute the loop for 10 iterations
    and just stop after seven? Why not execute the parallel for seven iterations in
    the first place? This is just an example for demonstration purposes. In your applications,
    you will find many conditions by which you will want to exit a parallel loop before
    completing all iterations, just like with a normal `For` loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个非常实用的例子——为什么执行10次循环然后只停止在第七次？为什么不一开始就执行7次并行循环呢？这只是一个用于演示的例子。在你的应用程序中，你会找到许多条件，在这些条件下你将想要在完成所有迭代之前退出并行循环，就像使用正常的`For`循环一样。
- en: Handling exceptions in parallel loops
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行循环中的异常处理
- en: Well, no matter how hard we try to write error-free code, the real world intervenes
    and inevitably there are exceptions that our code will encounter, for example,
    file not found, argument out or range, and so on. When we are processing a parallel
    loop command, since all of the iterations are running on potentially different
    threads, we need a way to gather all of the exceptions that any of the iterations
    of the loop may produce.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，无论我们多么努力地编写无错误的代码，现实世界总会介入，不可避免地会遇到我们的代码会遇到的异常，例如文件未找到、参数超出范围等。当我们处理并行循环命令时，由于所有迭代都在可能不同的线程上运行，我们需要一种方法来收集循环任何迭代可能产生的所有异常。
- en: .NET provides the `AggregateException` class for just this purpose. This allows
    us to collect all of the exceptions into the `AggregateException` object and then
    "catch" it once the loop has completed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了`AggregateException`类来专门实现这个目的。这允许我们将所有异常收集到`AggregateException`对象中，然后在循环完成后一次性“捕获”它。
- en: Think of this like you would a normal error-handling situation. Typically, you
    put a `try` block around a section of the code and then a `catch` block after
    it to process any exceptions that occurred in the `try` block of the code. This
    will behave the same way. We will put a `try` block around our parallel loop command
    and then catch the exceptions that occur in all of the iterations of the loop.
    Only in this case, our `catch` block will catch the `AggregateException`, which
    is just a collection of exceptions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理正常的错误处理情况一样来考虑这个问题。通常，你会在代码的一部分周围放置一个`try`块，然后在其后放置一个`catch`块来处理`try`块中发生的任何异常。这将以相同的方式工作。我们将把`try`块放在我们的并行循环命令周围，然后捕获循环所有迭代中发生的异常。只是在这次，我们的`catch`块将捕获`AggregateException`，它只是异常的集合。
- en: Also, in our `Action` delegate, we will catch any exceptions that occur and
    add them to the `AggregateException` object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们的`Action`委托中，我们将捕获发生的任何异常并将它们添加到`AggregateException`对象中。
- en: That is all there is to it! Let's try this for ourselves by modifying our `ParallelMath1`
    project to generate an exception if any of the iterations produce a sum of over
    5 million.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！让我们通过修改我们的`ParallelMath1`项目来尝试生成一个异常，如果任何迭代产生的总和超过500万，来亲自尝试一下。
- en: How to do it
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'To start, let''s open the `ParallelMath1` project in Visual Studio and make
    the following changes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在Visual Studio中打开`ParallelMath1`项目并做出以下更改：
- en: 'We will be using a `Concurrent` queue to collect the exceptions, so add this
    `using` statement:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个`Concurrent`队列来收集异常，所以添加以下`using`语句：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we need to declare our `ConcurrentQueue` instance where it is visible
    to the entire class. Add the following line right after the declaration on the
    number''s integer array:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要声明我们的`ConcurrentQueue`实例，使其对整个类可见。在数字整型数组的声明之后立即添加以下行：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will add a new method to be called by the `Action` delegate of our
    parallel loop command. We will call this method `CalculateNumbers3`. Add the following
    code to this method:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的并行循环命令的`Action`委托添加一个新方法。我们将把这个方法命名为`CalculateNumbers3`。将以下代码添加到这个方法中：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, let''s alter our `btnCalculate_Click` event handler. Change the code
    between the population of the numbers array and the population of the textboxes
    to include the following lines of code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们修改`btnCalculate_Click`事件处理器。更改在填充数字数组和在填充文本框之间的代码，包括以下行：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, in the `MainWindow.xaml` designer view, add a textblock control; set
    its `Name` property to `tbMessages` and its `Text` property to an empty string.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MainWindow.xaml`设计视图中，添加一个文本块控件；将其`Name`属性设置为`tbMessages`，并将其`Text`属性设置为空字符串。
- en: Now our changes are complete. When any of the iterations of the parallel loop
    reach above 5 million, we will throw an exception. All of the exceptions will
    be collected into a `ConcurrentQueue` and added to the `AggregateException` object.
    Once the parallel loop execution has completed, we will process the `AggregateException`,
    if there are any, and write their exception messages to the `Messages` textblock.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的更改已经完成。当并行循环的任何迭代达到超过500万时，我们将抛出异常。所有异常都将收集到`ConcurrentQueue`中，并添加到`AggregateException`对象中。一旦并行循环执行完成，我们将处理`AggregateException`，如果有任何异常，并将它们的异常消息写入`Messages`文本块。
- en: 'Build and run your application. Now, enter numbers in each of the boxes. You
    should have a screen that looks like the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行你的应用程序。现在，在每个框中输入数字。你应该有一个看起来像以下截图的屏幕：
- en: '![How to do it](img/8321EN_07_12.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_12.jpg)'
- en: 'Now, click on the **Calculate** button and you should see results that look
    like the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击**计算**按钮，你应该看到以下截图所示的结果：
- en: '![How to do it](img/8321EN_07_13.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_13.jpg)'
- en: As you can see from the output, every box that has a total that goes over 5
    million has a line printed in our **Messages** textblock. In this example, any
    number that goes over 5 million throws an exception. Once all of the iterations
    of the parallel loop have completed, we process these exceptions and print their
    messages to the `tbMessages` textblock.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，每个总数超过500万的框都会在我们的**消息**文本块中打印一行。在这个例子中，任何超过500万的数字都会抛出异常。一旦并行循环的所有迭代都完成，我们将处理这些异常并将它们的消息打印到`tbMessages`文本块中。
- en: How it works
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The first thing we changed was adding an object that is in a concurrent queue,
    to hold all of our exceptions. This is done with this command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是添加一个位于并发队列中的对象，用于存储所有异常。这是通过以下命令完成的：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, in our `Action` delegate of the parallel `for` command, which in this
    version executes `CalculateNumbers3`, we check for numbers greater than 5 million
    through an exception using the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的并行`for`命令的`Action`委托中，在这个版本中执行`CalculateNumbers3`，我们通过异常检查大于500万的数字，使用以下命令：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then catch this exception within the delegate and add it to our concurrent
    queue of exception objects using these statements:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在委托中捕获这个异常，并使用以下语句将其添加到我们的并发队列中的异常对象：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We do this because we do not want to interrupt other iterations of the parallel
    loop running on different threads. We want the loop to finish processing and then
    handle the exceptions. Since each iteration of the loop is running concurrently
    and is designed not to affect other iterations, we should not interrupt all of
    the iterations because one has an issue.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为我们不希望打断在不同线程上运行的并行循环的其他迭代。我们希望循环完成处理后再处理异常。由于循环的每次迭代都是并发运行的，并且设计上不会影响其他迭代，因此我们不应该因为一次迭代出现问题而中断所有迭代。
- en: 'Once the loop has completed, we want to check for any exceptions and process
    them. Here is the code that handles this functionality:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 循环完成后，我们想要检查是否有任何异常并处理它们。这是处理此功能的代码：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we see any exceptions in our `ConcurrentQueue` object, we throw an `AggregateException`
    and give it the whole queue of exceptions. Then we catch this `AggregateException`
    and process all of the exceptions it contains.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`ConcurrentQueue`对象中看到任何异常，我们抛出一个`AggregateException`，并给它整个异常队列。然后我们捕获这个`AggregateException`并处理它包含的所有异常。
- en: We could have also performed different actions based on the exception type of
    each exception. You can play with your code and try this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据每个异常的类型执行不同的操作。你可以玩一下你的代码并尝试这个。
- en: Using thread-local variables in parallel loops
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行循环中的线程局部变量
- en: Once you are comfortable using parallel loops, stopping them, and performing
    exception handling with them, let's talk about how we can use thread-local variables
    to better coordinate results. If we want to sum the results of all the iterations
    of a parallel loop, how would we do that?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了使用并行循环、停止它们以及使用它们进行异常处理，让我们谈谈如何使用线程局部变量更好地协调结果。如果我们想对所有并行循环迭代的结果求和，我们该如何做？
- en: From what we have learned so far, we would create a class variable before the
    loop and access it by each iteration of the loop using a `lock` statement so that
    it remains thread-safe. This takes overhead and coordination time. To improve
    performance, we can implement our parallel loop using a thread-local variable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们目前所学的知识来看，我们会在循环之前创建一个类变量，并通过 `lock` 语句在每个循环迭代中访问它，以确保它是线程安全的。这会带来开销和协调时间。为了提高性能，我们可以使用线程局部变量来实现我们的并行循环。
- en: The `Parallel.For` and `Parallel.ForEach` loops both have overloads that implement
    a thread-local variable. What do we mean by a thread-local variable? This is a
    variable whose scope lasts the duration of the parallel loop, from just before
    the first iteration starts to the completion of the last iteration. Each iteration
    of the loop gets its own copy of the thread-local variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.For` 和 `Parallel.ForEach` 循环都有实现线程局部变量的重载。我们所说的线程局部变量是什么意思？这是一个其作用域持续到并行循环期间的变量，从第一次迭代开始之前到最后一次迭代完成。循环的每个迭代都获得自己的线程局部变量副本。'
- en: In these overloads of the parallel loop methods, there are three functions that
    get passed to the loop as well as the iteration parameters. For a `For` loop,
    the iteration parameters are the starting and ending values of the loop index,
    and for the `ForEach` loop, it is the source collection.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行循环方法的这些重载中，有三个函数被传递给循环以及迭代参数。对于 `For` 循环，迭代参数是循环索引的起始和结束值，而对于 `ForEach` 循环，则是源集合。
- en: The first function will initialize the thread-local variable. The second function
    is the `Action` delegate that the loop performs. The third function is the `Action`
    delegate that gets executed when all iterations of the loop have completed, and
    it receives the thread-local variable for each loop iteration. It can then process
    the results, which usually means combining the results.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数将初始化线程局部变量。第二个函数是循环执行的 `Action` 委托。第三个函数是在循环的所有迭代完成后执行的 `Action` 委托，它接收每个循环迭代的线程局部变量。然后它可以处理结果，通常意味着合并结果。
- en: 'Let''s examine one of the `ForEach` overloads:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下 `ForEach` 的一个重载：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s dissect this for a minute. We will take each piece of the method definition
    and explain its role:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间来剖析一下。我们将逐个解释方法定义中的每一部分及其作用：
- en: '`ForEach<TSource, TLocal>`: `TSource` is the datatype of the source collection,
    and `TLocal` is the datatype of the thread-local variable.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForEach<TSource, TLocal>`：`TSource` 是源集合的数据类型，而 `TLocal` 是线程局部变量的数据类型。'
- en: '`IEnumerable<TSource>`: This is the source collection. Since we are using a
    `ForEach` example, the source collection has to be `IEnumerable`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`：这是源集合。由于我们正在使用 `ForEach` 示例，源集合必须是 `IEnumerable`。'
- en: '`Func<TLocal>`: This is the first function; it initializes the thread-local
    variable.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func<TLocal>`：这是第一个函数；它初始化线程局部变量。'
- en: '`Func<TSource, ParallelLoopState, TLocal, TLocal>`: This is the second function;
    it is the `Action` delegate that is performed by each iteration of the loop.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func<TSource, ParallelLoopState, TLocal, TLocal>`：这是第二个函数；它是由循环的每个迭代执行的 `Action`
    委托。'
- en: '`Action<TLocal>`: This is the third function; it is the `Action` delegate that
    is performed on the local state of each iteration.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action<TLocal>`：这是第三个函数；它是在每个迭代的局部状态上执行的 `Action` 委托。'
- en: Even though this is a fairly straightforward concept, it leads itself to a method
    overload that looks very complicated. To make sure we understand, let's go to
    our `ParallelMath1` project and see how it works in the sample application we
    have been building.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个相当直接的概念，但它本身会导致一个看起来非常复杂的方法重载。为了确保我们理解，让我们去我们的 `ParallelMath1` 项目，看看它在我们一直在构建的示例应用程序中是如何工作的。
- en: How to do it
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'To use a thread-local variable to sum up our textboxes once we have performed
    our parallel loop on them, let''s open our `ParallelMath1` project and make a
    few changes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在执行并行循环后使用线程局部变量来汇总我们的文本框，让我们打开我们的 `ParallelMath1` 项目并进行一些更改：
- en: In the `MainWindow.xaml` file in the designer view, let's add a label control
    and set the `Content` property to `Sum:`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计视图中 `MainWindow.xaml` 文件，让我们添加一个标签控件，并将 `Content` 属性设置为 `Sum:`。
- en: Now, let's add a textbox control beside it and set the `Name` property to `tbSum`
    and make the `Text` property empty.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在它旁边添加一个文本框控件，并将 `Name` 属性设置为 `tbSum`，并将 `Text` 属性设置为空。
- en: 'In the `MainWindow.xaml.cs` file, add the following `using` statement so that
    we can use the `Interlocked.Add` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml.cs` 文件中，添加以下 `using` 语句，以便我们可以使用 `Interlocked.Add` 方法：
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, add a class variable below our `ConcurrentQueue` declaration for a sum
    variable we will call `total`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在我们的 `ConcurrentQueue` 声明下方添加一个类变量，用于一个我们将称之为 `total` 的求和变量：
- en: '[PRE28]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, comment out our current `Parallel.For` command because we are going to
    use the new overloaded version needed for thread-local variables:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，注释掉我们当前的 `Parallel.For` 命令，因为我们将要使用需要线程局部变量的新重载版本：
- en: '[PRE29]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is easier for this version of a `Parallel.For` to use a lambda expression
    instead of the named methods for the `Action` delegates. So, use the following
    `Parallel.For` command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个版本的 `Parallel.For`，使用 lambda 表达式而不是命名方法来处理 `Action` 委托更容易。所以，使用以下 `Parallel.For`
    命令：
- en: '[PRE30]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, right after this statement, add the following statement so that we
    can see the total on the user interface:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在这条语句之后，添加以下语句，以便我们可以在用户界面上看到总数：
- en: '[PRE31]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That is all the changes we need to make so that we can use our thread-local
    variable with the `Parallel.For` loop to calculate the sum of our textbox.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们需要做的所有更改，以便我们可以使用 `Parallel.For` 循环和线程局部变量来计算文本框的求和。
- en: 'Once these changes have been made, build and run the application. Enter numbers
    in the textboxes and you should have a screen that looks like the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦做出这些更改，构建并运行应用程序。在文本框中输入数字，你应该有一个看起来像以下截图的屏幕：
- en: '![How to do it](img/8321EN_07_14.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_14.jpg)'
- en: 'Now, click on the **Calculate** button and see what happens. The results should
    look like the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击 **计算** 按钮，看看会发生什么。结果应该看起来像下面的截图：
- en: '![How to do it](img/8321EN_07_15.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_07_15.jpg)'
- en: As you can see from the example, we now have a sum of all of the boxes once
    the parallel loop has processed them. We are able to do this without having to
    continually lock the class variable in each iteration when it wants to update
    the loop. We can do the summing once at the end of the parallel loop using the
    thread-local value from each iteration of the loop.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，一旦并行循环处理完毕，我们现在有了所有文本框的总和。我们能够在每次迭代想要更新循环时不必不断锁定类变量的情况下做到这一点。我们可以在并行循环的末尾使用循环的每个迭代的线程局部值进行求和。
- en: Now, let's examine what just happened
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查刚才发生了什么
- en: How it works
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Just like in the previous versions of this project, we take the numbers in 10
    different textboxes and multiply them by the numbers 1 through 10 and sum them.
    The result is then put back in the textbox. But this time, we take the new results
    in the 10 text boxes and sum them, and the final total is displayed in the `tbSum`
    textbox.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在这个项目的先前版本中一样，我们取 10 个不同的文本框中的数字，并将它们乘以 1 到 10 的数字，然后求和。然后将结果放回文本框中。但这次，我们取
    10 个文本框中的新结果并求和，最终的总数显示在 `tbSum` 文本框中。
- en: 'The only real difference in this version is the `Parallel.For` command. Let''s
    take a deeper look at it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本中唯一的真正区别是 `Parallel.For` 命令。让我们更深入地看看它：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First, we now have a `TResult` parameter that is a long `Parallel.For<long>`.
    This tells us that the `Action` delegate that each iteration of the loop executes
    will return a value with the datatype `long`. This `Action` delegate is implemented
    as a lambda expression this time and is the fourth parameter of our `Parallel.For`
    method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们现在有一个 `TResult` 参数，它是一个 `Parallel.For<long>` 的长整型。这告诉我们循环的每个迭代执行的 `Action`
    委托将返回一个 `long` 类型的值。这次 `Action` 委托作为 lambda 表达式实现，并且是 `Parallel.For` 方法的第四个参数：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s create a back up; the first two parameters are the starting and ending
    indices of our iteration, 0 and 10\. The third parameter is our `Action` delegate
    that initializes the thread-local variable. It is implemented with a lambda expression:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个备份；前两个参数是迭代的起始和结束索引，0 和 10。第三个参数是我们的 `Action` 委托，它初始化线程局部变量。它使用 lambda
    表达式实现：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, our final parameter to the `Parallel.For` method is the `Action` delegate
    that is executed on each iteration''s thread-local variable:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们传递给 `Parallel.For` 方法的最后一个参数是执行在每个迭代线程局部变量的 `Action` 委托：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We chose to use lambda expression for the three `Action` delegates in this example
    instead of named or anonymous methods because it is easier for us to see what
    is going on and what is being passed to what. However, we can use named methods
    to achieve the same results.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们选择使用 lambda 表达式而不是命名或匿名方法来为三个 `Action` 委托，因为我们更容易看到正在发生什么以及传递给了什么。然而，我们可以使用命名方法达到相同的结果。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered all aspects of imperative data parallelism. In [Chapter
    10](ch10.html "Chapter 10. Parallel LINQ – PLINQ"), *Parallel LINQ – PLINQ*, we
    will cover declarative data parallelism with PLINQ discussion. Data parallelism
    using TPL in .NET really comes down to performing parallel loops using the `Parallel.For`
    and `Parallel.ForEach` methods. These parallel loops allow us to iterate through
    a set or collection of data and perform the same function on each member of the
    set concurrently.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了命令式数据并行化的所有方面。在[第10章](ch10.html "第10章。并行LINQ – PLINQ")中，我们将讨论使用PLINQ的声明式数据并行化。在.NET中使用TPL进行数据并行化实际上归结为使用`Parallel.For`和`Parallel.ForEach`方法执行并行循环。这些并行循环允许我们遍历一组或集合中的数据，并同时对集合中的每个成员执行相同的函数。
- en: We learned how to perform a parallel loop on a set of data using `Parallel.For`
    and a collection of data using `Parallel.ForEach`. We then saw how to stop or
    break from a loop when a particular condition was reached; for this we used the
    `ParallelLoopState` object that .NET can generate.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用`Parallel.For`在数据集上执行并行循环，以及使用`Parallel.ForEach`在数据集合上执行并行循环。然后我们看到了如何在达到特定条件时停止或跳出循环；为此，我们使用了.NET可以生成的`ParallelLoopState`对象。
- en: Next, we explored error handling with parallel loops and the `AggregateException`
    object. We learned how to process all of the exceptions that might occur during
    the different iterations of the loop without affecting the other iterations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了并行循环和`AggregateException`对象中的错误处理。我们学习了如何在循环的不同迭代过程中处理可能发生的所有异常，而不会影响其他迭代。
- en: In the last section, we saw how to use thread-local variables in our loops to
    have a thread-safe local copy of a variable and then use the results from all
    of these local copies at the end of the loop processing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们看到了如何使用线程局部变量在我们的循环中创建一个线程安全的局部变量副本，然后在循环处理结束时使用所有这些局部副本的结果。
- en: In the next chapter, we will take some time and explore the Visual Studio Debugger
    and the features it provides for debugging a parallel application that has multiple
    threads running at once.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将花一些时间来探索Visual Studio调试器和它为调试同时运行多个线程的并行应用程序提供的功能。
