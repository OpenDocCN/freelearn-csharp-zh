- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: 'Data Access in ASP.NET Core (Part 3: Tips)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的数据访问（第 3 部分：技巧）
- en: 'In [*Chapter 6*](B18971_06.xhtml#_idTextAnchor245), we learned how to manage
    relationships between entities using the EF Core Fluent API. We introduced three
    types of relationships: one-to-one, one-to-many, and many-to-many. We also learned
    how to perform **CRUD** operations on related entities. With the knowledge we
    gained from [*Chapter 6*](B18971_06.xhtml#_idTextAnchor245), we can now build
    a simple data access layer for most web API applications. However, there are still
    some scenarios that we need to handle properly. For example, how do we improve
    the performance of data access? And what should we do if there are concurrency
    conflicts?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B18971_06.xhtml#_idTextAnchor245) 中，我们学习了如何使用 EF Core Fluent API
    管理实体之间的关系。我们介绍了三种类型的关系：一对一、一对多和多对多。我们还学习了如何在相关实体上执行 **CRUD** 操作。凭借我们从 [*第 6 章*](B18971_06.xhtml#_idTextAnchor245)
    中获得的知识，我们现在可以为大多数 Web API 应用程序构建一个简单的数据访问层。然而，还有一些场景我们需要妥善处理。例如，我们如何提高数据访问的性能？如果存在并发冲突，我们应该怎么做？
- en: In this chapter, we will cover some advanced topics related to data access in
    ASP.NET Core, including `DbContext` pooling, performance optimization, raw SQL
    queries, and concurrency conflicts. We will also discuss some tips and tricks
    that can help you write better code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖与 ASP.NET Core 数据访问相关的一些高级主题，包括 `DbContext` 连接池、性能优化、原始 SQL 查询和并发冲突。我们还将讨论一些技巧和窍门，这些技巧和窍门可以帮助您编写更好的代码。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: '`DbContext` pooling'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DbContext` 连接池'
- en: Tracking versus no-tracking queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪与非跟踪查询
- en: IQueryable versus IEnumerable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IQueryable 与 IEnumerable 的区别
- en: Client versus server evaluation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端与服务器评估
- en: Raw SQL queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始 SQL 查询
- en: Bulk operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量操作
- en: Concurrency conflicts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发冲突
- en: Reverse engineering
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向工程
- en: Other ORM frameworks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 ORM 框架
- en: After reading this chapter, you will have gained a deeper understanding of EF
    Core and be able to use it more effectively in your applications. You will have
    learned how to use no-tracking queries to improve query performance, as well as
    how to use raw SQL queries to execute complex queries. Additionally, you will
    understand how to use bulk operations to improve the performance of bulk data
    operations. Furthermore, you will be able to handle concurrency conflicts for
    large-scale applications and use reverse engineering to generate the entity classes
    and the `DbContext` class from an existing database.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将更深入地了解 EF Core，并能够在您的应用程序中更有效地使用它。您将学习如何使用无跟踪查询来提高查询性能，以及如何使用原始 SQL
    查询来执行复杂查询。此外，您将了解如何使用批量操作来提高批量数据操作的性能。此外，您将能够处理大规模应用程序的并发冲突，并使用反向工程从现有数据库生成实体类和
    `DbContext` 类。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8).
    You can use VS 2022 or VS Code to open the solutions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在 [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8)
    找到。您可以使用 VS 2022 或 VS Code 打开解决方案。
- en: Understanding DbContext pooling
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DbContext 连接池
- en: In the previous chapter, we learned how to register the `DbContext` instance
    as a scoped service in the DI container using the `AddDbContext()` extension method.
    By default, a new `DbContext` instance is created for each request, which is generally
    not a problem since it is a lightweight object that does not consume many resources.
    However, in a high-throughput application, the cost of setting up various internal
    services and objects for each `DbContext` instance can add up. To address this,
    EF Core provides a feature called `DbContext` instance to be reused across multiple
    requests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 `AddDbContext()` 扩展方法将 `DbContext` 实例注册为 DI 容器中的作用域服务。默认情况下，为每个请求创建一个新的
    `DbContext` 实例，这通常不是问题，因为它是一个轻量级对象，不消耗许多资源。然而，在高吞吐量应用程序中，为每个 `DbContext` 实例设置各种内部服务和对象的成本可能会累积。为了解决这个问题，EF
    Core 提供了一个名为 `DbContext` 实例重用的功能。
- en: To enable `DbContext` pooling, you can replace the `AddDbContext()` method with
    the `AddDbContextPool()` method. This resets the state of the `DbContext` instance
    when it is disposed of, stores it in a pool, and reuses it when a new request
    comes in. By reducing the cost of setting up the `DbContext` instance, `DbContext`
    pooling can significantly improve the performance of your application for high-throughput
    scenarios.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`DbContext`池，您可以替换`AddDbContext()`方法为`AddDbContextPool()`方法。这将重置`DbContext`实例的当前状态，将其存储在池中，并在有新请求时重用。通过减少设置`DbContext`实例的成本，`DbContext`池可以显著提高您应用程序在高吞吐量场景下的性能。
- en: You can find the sample code for this section from the `/samples/chapter7/EfCoreDemo`
    folder in this chapter's GitHub repository.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本章GitHub仓库的`/samples/chapter7/EfCoreDemo`文件夹中找到本节的示例代码。
- en: 'Open the `Program.cs` file in the `EfCoreDemo` project. The following code
    shows how to enable `DbContext` pooling:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EfCoreDemo`项目中打开`Program.cs`文件。以下代码显示了如何启用`DbContext`池：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `AddDbContextPool()` method takes a `poolSize` parameter, which specifies
    the maximum number of `DbContext` instances that can be stored in the pool. The
    default value is `1024`, which is usually sufficient for most applications. If
    the pool is full, EF Core will start creating new `DbContext` instances as needed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDbContextPool()`方法接受一个`poolSize`参数，该参数指定可以存储在池中的最大`DbContext`实例数。默认值是`1024`，通常对大多数应用程序来说已经足够。如果池已满，EF
    Core将根据需要开始创建新的`DbContext`实例。'
- en: 'To validate whether `DbContext` pooling can improve the performance of the
    application, we can run a performance test. **Grafana k6** is an open-source load-testing
    tool that can be used to test the performance of web APIs. To use k6, you need
    to install NodeJS here: [https://nodejs.org/](https://nodejs.org/). Then you can
    download it from [https://k6.io/docs/get-started/installation/](https://k6.io/docs/get-started/installation/).
    k6 has packages for various platforms, including Windows, Linux, and macOS. Install
    k6 on your machine.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证`DbContext`池是否可以提高应用程序的性能，我们可以运行性能测试。**Grafana k6**是一个开源的负载测试工具，可以用来测试Web
    API的性能。要使用k6，您需要在此处安装NodeJS：[https://nodejs.org/](https://nodejs.org/)。然后您可以从[https://k6.io/docs/get-started/installation/](https://k6.io/docs/get-started/installation/)下载它。k6为各种平台提供包，包括Windows、Linux和macOS。在您的机器上安装k6。
- en: 'You can find a `script.js` file in the `k6` folder in the project. The `script.js`
    file is a k6 script that contains the test scenarios. The following code shows
    the content of the `script.js` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目的`k6`文件夹中找到一个`script.js`文件。`script.js`文件是一个包含测试场景的k6脚本。以下代码显示了`script.js`文件的内容：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a basic k6 test script that runs a 30-second, 500-VU load test. `GET`
    requests to the `/api/Invoices?page=1&pageSize=10` endpoint for 30 seconds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的k6测试脚本，运行一个30秒，500-VU负载测试。在30秒内向`/api/Invoices?page=1&pageSize=10`端点发送`GET`请求。
- en: 'First, use the `AddDbContext()` method to register the `DbContext`, and run
    the application using the `dotnet run` command. Then, open a new terminal and
    run the following command to start the k6 test:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`AddDbContext()`方法注册`DbContext`，然后使用`dotnet run`命令运行应用程序。然后，打开一个新的终端并运行以下命令以启动k6测试：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, use the `AddDbContextPool()` method to register the `DbContext`, and
    test the application again using the same k6 script. You can compare the results
    of the two tests to see whether `DbContext` pooling improves the performance of
    the application. For example, one test result of using the `AddDbContext()` method
    is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`AddDbContextPool()`方法注册`DbContext`，并使用相同的k6脚本再次测试应用程序。你可以比较两次测试的结果，以查看`DbContext`池是否提高了应用程序的性能。例如，使用`AddDbContext()`方法的测试结果如下：
- en: '![Figure 7.1 – The test result of using the AddDbContext() method](img/B18971_07_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 使用AddDbContext()方法的测试结果](img/B18971_07_1.jpg)'
- en: Figure 7.1 – The test result of using the AddDbContext() method
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 使用AddDbContext()方法的测试结果
- en: 'The following is the result of using the `AddDbContextPool` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用`AddDbContextPool`方法得到的结果：
- en: '![Figure 7.2 – The test result of using the AddDbContextPool() method](img/B18971_07_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 使用AddDbContextPool()方法的测试结果](img/B18971_07_2.jpg)'
- en: Figure 7.2 – The test result of using the AddDbContextPool() method
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 使用AddDbContextPool()方法的测试结果
- en: When using `AddDbContext()`, the average request duration is 1.07 s and 7,145
    requests are completed, while when using `AddDbContextPool()`, the average request
    duration is 782.36 ms and 8,530 requests are completed. The results show that
    `DbContext` pooling can improve the performance of the application. Note that
    your results may vary depending on your machine’s configuration. Also, the `dotnet
    run` command is used to run the application in development mode, which is not
    optimized for performance. So, this test is just for demonstration purposes and
    cannot reflect the real performance of the application. However, it can give you
    an idea of how `DbContext` pooling works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`AddDbContext()`时，平均请求时长为1.07秒，完成了7,145个请求，而使用`AddDbContextPool()`时，平均请求时长为782.36毫秒，完成了8,530个请求。结果显示，`DbContext`池化可以提高应用程序的性能。请注意，您的结果可能会根据您的机器配置而有所不同。此外，`dotnet
    run`命令用于以开发模式运行应用程序，这并不针对性能优化。因此，这个测试只是为了演示目的，并不能反映应用程序的真实性能。然而，它可以给您一个关于`DbContext`池化工作原理的直观理解。
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For most applications, `DbContext` pooling is not necessary. You should enable
    `DbContext` pooling only if you have a high-throughput application. Therefore,
    before enabling `DbContext` pooling, it is important to test your application’s
    performance with and without it to see whether there’s any noticeable improvement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序来说，`DbContext`池化不是必需的。您应该只在有高吞吐量应用程序的情况下启用`DbContext`池化。因此，在启用`DbContext`池化之前，重要的是测试您的应用程序在启用和未启用池化时的性能，以查看是否有任何明显的改进。
- en: In summary, while `DbContext` pooling can improve the performance of high-throughput
    applications, it’s not a one-size-fits-all solution. Be sure to evaluate your
    application’s specific needs before deciding whether to enable `DbContext` pooling
    or not.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，虽然`DbContext`池化可以提高高吞吐量应用程序的性能，但这并不是万能的解决方案。在决定是否启用`DbContext`池化之前，请务必评估您应用程序的具体需求。
- en: Understanding the difference between tracking versus no-tracking queries
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解跟踪查询与非跟踪查询的区别
- en: In this section, we will discuss the difference between tracking and no-tracking
    queries. What are tracking queries and no-tracking queries? Let us start from
    the beginning!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论跟踪查询与非跟踪查询的区别。什么是跟踪查询和非跟踪查询？让我们从基础开始了解！
- en: In the early days of .NET, the term **SqlHelper** was popular to refer to a
    static class that provided a set of methods to execute SQL queries. While SqlHelper
    simplified the process of executing SQL queries, developers still had to manage
    connection and transaction objects, write boilerplate code to map results to model
    objects, and work directly with the database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET的早期阶段，术语**SqlHelper**常用来指代一个提供一组方法来执行SQL查询的静态类。虽然SqlHelper简化了执行SQL查询的过程，但开发者仍然需要管理连接和事务对象，编写样板代码将结果映射到模型对象，并直接与数据库交互。
- en: '**ORM** frameworks such as EF Core were created to solve these problems. They
    not only simplify the process of executing SQL queries and mapping the results
    to model objects but also provide the ability to track changes made to the entities
    returned by queries. When changes are saved, EF Core generates the appropriate
    SQL queries to update the database. This is called tracking and is a significant
    benefit of using an ORM framework such as EF Core.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**ORM**框架，如EF Core，是为了解决这些问题而创建的。它们不仅简化了执行SQL查询并将结果映射到模型对象的过程，还提供了跟踪查询返回的实体所做更改的能力。当更改被保存时，EF
    Core会生成适当的SQL查询来更新数据库。这被称为跟踪，并且是使用EF Core等ORM框架的一个显著优势。'
- en: However, tracking comes at a cost. This can add overhead and memory usage, especially
    when dealing with a large number of entities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，跟踪是有代价的。这可能会增加开销和内存使用，尤其是在处理大量实体时。
- en: We introduced a little bit about tracking in [*Chapter 5*](B18971_05.xhtml#_idTextAnchor198).
    Let's see an example of tracking. You can find the sample code for this section
    from the `/samples/chapter7/EfCoreDemo` folder in this chapter's GitHub repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第五章*](B18971_05.xhtml#_idTextAnchor198)中简要介绍了跟踪的相关内容。让我们来看一个跟踪的例子。您可以从本章GitHub仓库的`/samples/chapter7/EfCoreDemo`文件夹中找到本节示例代码。
- en: 'In the sample `EfCoreDemo` project, you can find the `GetInvoice` action in
    the `InvoicesController` class. The following code shows how the tracking works:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例`EfCoreDemo`项目中，您可以在`InvoicesController`类中找到`GetInvoice`操作。以下代码展示了跟踪是如何工作的：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we added some logging statements to see how EF Core
    calls the database. Run the application and call the `GetInvoice` action. You
    will see an output in the console like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一些日志语句来查看 EF Core 如何调用数据库。运行应用程序并调用 `GetInvoice` 动作。你将在控制台看到如下输出：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we call the `context.Invoices.FindAsync(id)` method for the first time,
    EF Core will query the database and return the `Invoice` entity. The second time,
    EF Core will return the `Invoice` entity from the context because the `Invoice`
    entity is already in the context.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次调用 `context.Invoices.FindAsync(id)` 方法时，EF Core 将查询数据库并返回 `Invoice` 实体。第二次，EF
    Core 将从上下文中返回 `Invoice` 实体，因为 `Invoice` 实体已经存在于上下文中。
- en: Find() versus Single()
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find()` 与 `Single()` 的比较'
- en: When we get an entity from the database by its primary key, we can use the `Find()`
    or `FindAsync()` methods. Also, we can use the `Single()` or `SingleOrDefault()`
    methods. They are similar, but they are not the same. The `Find()` and `FindAsync()`
    methods are methods of the `DbSet` class. If an entity with the given primary
    key values is being tracked by the context, the `Find()` or `FindAsync()` methods
    will return the tracked entity without making a request to the database. Otherwise,
    EF Core will make a query to the database to get the entity, attach it to the
    context, and return it. But if you use the `Single()` or `SingleOrDefault()` methods,
    EF Core will always make a query to the database to get the entity. The same is
    true for the `First()` and `FirstOrDefault()` methods. So, the `Find()` and `FindAsync()`
    methods are more efficient for getting an entity by its primary key. But in rare
    cases, `Find()` and `FindAsync()` may return outdated data if the entity is updated
    in the database after it is loaded into the context. For example, if you use the
    bulk-update `ExecuteUpdateAsync()` method, the update will not be tracked by `DbContext`.
    Then, if you use `Find()` or `FindAsync()` to get the entity from `DbContext`,
    you will get the outdated data. In this case, you should use `Single()` or `SingleOrDefault()`
    to get the entity from the database again. In most cases, you can use the `Find()`
    or `FindAsync()` methods to get an entity by its primary key when you are sure
    the entity is always tracked by the `DbContext`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过其主键从数据库获取实体时，我们可以使用 `Find()` 或 `FindAsync()` 方法。我们还可以使用 `Single()` 或 `SingleOrDefault()`
    方法。它们很相似，但并不相同。`Find()` 和 `FindAsync()` 方法是 `DbSet` 类的方法。如果具有给定主键值的实体被上下文跟踪，`Find()`
    或 `FindAsync()` 方法将返回被跟踪的实体，而不会向数据库发出请求。否则，EF Core 将查询数据库以获取实体，将其附加到上下文，并返回它。但是，如果你使用
    `Single()` 或 `SingleOrDefault()` 方法，EF Core 将始终查询数据库以获取实体。对于 `First()` 和 `FirstOrDefault()`
    方法也是如此。因此，`Find()` 和 `FindAsync()` 方法在通过主键获取实体时更有效。但在罕见情况下，如果实体在加载到上下文后数据库中已更新，`Find()`
    和 `FindAsync()` 可能会返回过时数据。例如，如果你使用批量更新 `ExecuteUpdateAsync()` 方法，更新将不会被 `DbContext`
    跟踪。然后，如果你使用 `Find()` 或 `FindAsync()` 从 `DbContext` 获取实体，你将得到过时数据。在这种情况下，你应该使用
    `Single()` 或 `SingleOrDefault()` 再次从数据库获取实体。在大多数情况下，当你确信实体始终被 `DbContext` 跟踪时，你可以使用
    `Find()` 或 `FindAsync()` 方法通过主键获取实体。
- en: 'An entity has one of the following `EntityState` values: `Detached`, `Added`,
    `Unchanged`, `Modified`, or `Deleted`. We introduced the `EntityState` enum in
    [*Chapter 5*](B18971_05.xhtml#_idTextAnchor198). The following is how the states
    change:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实体具有以下 `EntityState` 值之一：`Detached`、`Added`、`Unchanged`、`Modified` 或 `Deleted`。我们介绍了
    `EntityState` 枚举在 [*第 5 章*](B18971_05.xhtml#_idTextAnchor198)。以下是如何改变状态：
- en: All the entities that are returned by the query (such as `Find()`, `Single()`,
    `First()`, `ToList()`, and their `async` overloads) are in the `Unchanged` state
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的所有实体（例如 `Find()`、`Single()`、`First()`、`ToList()` 以及它们的 `async` 重载）都处于 `Unchanged`
    状态。
- en: If you update the properties of the entity, EF Core will change the state to
    `Modified`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你更新实体的属性，EF Core 将状态更改为 `Modified`。
- en: If you call the `Remove()` method on the entity, EF Core will change the state
    to `Deleted`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在一个实体上调用 `Remove()` 方法，EF Core 将状态更改为 `Deleted`。
- en: If you call the `Add()` method on the entity, EF Core will change the state
    to `Added`
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在一个实体上调用 `Add()` 方法，EF Core 将状态更改为 `Added`。
- en: If you call the `Attach()` method on the untracked entity, EF Core will track
    the entity and set the state to `Unchanged`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在一个未跟踪的实体上调用 `Attach()` 方法，EF Core 将跟踪该实体并将状态设置为 `Unchanged`。
- en: If you call the `Detach()` method on the tracked entity, EF Core will not track
    the entity and will change the state to `Detached`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在一个被跟踪的实体上调用 `Detach()` 方法，EF Core 将不会跟踪该实体，并将状态更改为 `Detached`。
- en: Note that EF Core can track the changes at the property level, meaning that
    if you update a property of an entity, EF Core will only update the property when
    you call the `SaveChanges` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，EF Core 可以在属性级别跟踪更改，这意味着如果你更新一个实体的属性，EF Core 只有在你调用 `SaveChanges` 方法时才会更新该属性。
- en: 'To retrieve the `EntityEntry` object for an entity, we can use the `Entry()`
    method, which contains the state of the entity and the changed properties. Use
    the sample `EfCoreDemo` project in the `/samples/chapter7/EfCoreDemo` folder.
    You can find the `PutInvoice` action within the `InvoicesController` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取实体的 `EntityEntry` 对象，我们可以使用 `Entry()` 方法，它包含实体的状态和已更改的属性。请使用位于 `/samples/chapter7/EfCoreDemo`
    文件夹中的 `EfCoreDemo` 示例项目。你可以在 `InvoicesController` 类中找到 `PutInvoice` 动作：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code snippet, we obtained the `EntityEntry` object for the
    `Invoice` entity using the `Entry()` method and set its state to `Modified`. When
    `SaveChanges()` is called, EF Core persists the changes to the database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用 `Entry()` 方法获取了 `Invoice` 实体的 `EntityEntry` 对象，并将其状态设置为 `Modified`。当调用
    `SaveChanges()` 时，EF Core 将更改持久化到数据库。
- en: 'By default, tracking is enabled in EF Core. However, there may be scenarios
    where you do not want EF Core to track changes to entities. For instance, in read-only
    queries within `Get` actions, where the `DbContext` only exists for the duration
    of the request, tracking is not necessary. Disabling tracking can enhance performance
    and save memory. If you don’t intend to modify entities, you should disable tracking
    by calling the `AsNoTracking()` method on the query. Here’s an example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，EF Core 启用跟踪。但是，可能存在你不想让 EF Core 跟踪实体更改的场景。例如，在 `Get` 动作中的只读查询内，`DbContext`
    只存在于请求期间，跟踪是不必要的。禁用跟踪可以提高性能并节省内存。如果你不打算修改实体，你应该通过在查询上调用 `AsNoTracking()` 方法来禁用跟踪。以下是一个示例：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you have lots of read-only queries and you feel it is tedious to call the
    `AsNoTracking()` method every time, you can disable tracking globally when you
    configure the `DbContext`. The following code shows how to do this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多只读查询，并且觉得每次都调用 `AsNoTracking()` 方法很麻烦，你可以在配置 `DbContext` 时全局禁用跟踪。以下代码显示了如何进行此操作：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For any other queries that you want to track, you can call the `AsTracking()`
    method on the query, as shown in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你想要跟踪的任何其他查询，你可以在查询上调用 `AsTracking()` 方法，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we explicitly call the `AsTracking()` method to enable
    tracking for the query, so that we can update the entity and save the changes
    to the database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们显式调用 `AsTracking()` 方法来启用查询的跟踪，这样我们就可以更新实体并将更改保存到数据库中。
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If an entity is a keyless entity, EF Core will never track it. Keyless entity
    types do not have keys defined on them. They are configured by a `[Keyless]` data
    annotation or a Fluent API `HasNoKey()` method. The keyless entity is often used
    for read-only queries or views. We will not discuss keyless entities in detail
    in this book. You can refer to the official documentation at [https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types](https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types)
    for more information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个实体是无键实体，EF Core 将永远不会跟踪它。无键实体类型上没有定义键。它们通过 `[Keyless]` 数据注释或 Fluent API
    的 `HasNoKey()` 方法进行配置。无键实体通常用于只读查询或视图。我们不会在本书中详细讨论无键实体。有关更多信息，请参阅官方文档[https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types](https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types)。
- en: Using no-tracking queries is a good way to improve performance for read-only
    scenarios. However, keep in mind that if you disable tracking, you will not be
    able to update the entities when you call the `SaveChanges()` method because EF
    Core cannot detect changes to untracked entities. So, it is important to consider
    the implications of using no-tracking queries before implementing them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无跟踪查询是提高只读场景性能的好方法。然而，请注意，如果你禁用跟踪，当你调用 `SaveChanges()` 方法时将无法更新实体，因为 EF Core
    无法检测未跟踪实体的更改。因此，在实施之前考虑使用无跟踪查询的后果是很重要的。
- en: In addition to non-tracking queries, there are other factors that can affect
    the performance of data queries in EF Core. We will explore the differences between
    `IQueryable` and `IEnumerable` and how they impact query performance in the next
    section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非跟踪查询之外，还有其他因素会影响 EF Core 中数据查询的性能。我们将在下一节探讨 `IQueryable` 和 `IEnumerable`
    之间的差异以及它们如何影响查询性能。
- en: Understanding the difference between IQueryable and IEnumerable
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 IQueryable 和 IEnumerable 之间的区别
- en: 'When working with EF Core, you have two interfaces available to query the database:
    `IQueryable` and `IEnumerable`. Although these interfaces may seem similar at
    first glance, they have important differences that can affect your application’s
    performance. In this section, we will discuss the differences between `IQueryable`
    and `IEnumerable`, how they work, and when to use each of them.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 EF Core 时，你有两个接口可用于查询数据库：`IQueryable` 和 `IEnumerable`。尽管这些接口乍一看可能很相似，但它们之间的重要区别可能会影响应用程序的性能。在本节中，我们将讨论
    `IQueryable` 和 `IEnumerable` 之间的区别，它们的工作方式以及何时使用每个接口。
- en: You might be familiar with the `IEnumerable` interface. The `IEnumerable` interface
    is a standard .NET interface that is used to represent a collection of objects.
    It is used to iterate through the collection. Many .NET collections implement
    the `IEnumerable` interface, such as `List`, `Array`, `Dictionary`, and so on.
    The `IEnumerable` interface has a single method called `GetEnumerator`, which
    returns an `IEnumerator` object. The `IEnumerator` object is used to iterate through
    the collection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉 `IEnumerable` 接口。`IEnumerable` 接口是一个标准的 .NET 接口，用于表示对象的集合。它用于遍历集合。许多 .NET
    集合实现了 `IEnumerable` 接口，例如 `List`、`Array`、`Dictionary` 等。`IEnumerable` 接口有一个名为
    `GetEnumerator` 的单一方法，它返回一个 `IEnumerator` 对象。`IEnumerator` 对象用于遍历集合。
- en: The first difference between `IQueryable` and `IEnumerable` is that `IQueryable`
    is in the `System.Linq` namespace, while `IEnumerable` is in the `System.Collections`
    namespace. The `IQueryable` interface inherits from the `IEnumerable` interface,
    so `IQueryable` can do everything that `IEnumerable` does. But why do we need
    the `IQueryable` interface?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`IQueryable` 和 `IEnumerable` 之间的第一个区别是，`IQueryable` 位于 `System.Linq` 命名空间中，而
    `IEnumerable` 位于 `System.Collections` 命名空间中。`IQueryable` 接口继承自 `IEnumerable` 接口，因此
    `IQueryable` 可以做 `IEnumerable` 能做的所有事情。但为什么我们需要 `IQueryable` 接口呢？'
- en: One of the key differences between `IQueryable` and `IEnumerable` is that `IQueryable`
    is used to query data from a specific data source, such as a database. `IEnumerable`
    is used to iterate through a collection in memory. When we use `IQueryable`, the
    query will be translated into a specific query language, such as SQL, and executed
    against the data source to get the results when we call the `ToList()` (or `ToAway()`)
    method or iterate the items in the collection.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`IQueryable` 和 `IEnumerable` 之间的一个关键区别在于，`IQueryable` 用于从特定的数据源查询数据，例如数据库。`IEnumerable`
    用于在内存中遍历集合。当我们使用 `IQueryable` 时，查询将被转换成特定的查询语言，例如 SQL，并在我们调用 `ToList()`（或 `ToAway()`）方法或遍历集合中的项时，针对数据源执行以获取结果。'
- en: Download the sample code from the `/samples/chapter7/EfCoreDemo` folder in the
    chapter's GitHub repository. You can find a `GetInvoices` action in the `InvoicesController`
    class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从章节的 GitHub 仓库 `/samples/chapter7/EfCoreDemo` 文件夹中下载示例代码。你可以在 `InvoicesController`
    类中找到一个 `GetInvoices` 动作。
- en: 'First, let''s use the `IQueryable` interface to query the database:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 `IQueryable` 接口查询数据库：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, `context.Invoices` is a `DbSet<TEntity>` object, which
    implements the `IQueryable` interface. The `Where()` method is used to filter
    the invoices by status, and returns an `IQueryable` object. Then, we use some
    other methods to sort and paginate the invoices. When we call the `ToListAsync()`
    method, the query will be translated into a SQL query and executed against the
    database to get the results. The logs show the execution order of the code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`context.Invoices` 是一个实现 `IQueryable` 接口的 `DbSet<TEntity>` 对象。`Where()`
    方法用于按状态过滤发票，并返回一个 `IQueryable` 对象。然后，我们使用其他一些方法对发票进行排序和分页。当我们调用 `ToListAsync()`
    方法时，查询将被转换成 SQL 查询并在数据库上执行以获取结果。日志显示了代码的执行顺序：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the logs, we can see that the query is executed against the database when
    we call the `ToListAsync()` method. The query contains the `ORDER BY`, `OFFSET`,
    and `FETCH NEXT` clauses, which means the query is executed on the database server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志中我们可以看到，当我们调用 `ToListAsync()` 方法时，查询将在数据库上执行。查询包含 `ORDER BY`、`OFFSET` 和 `FETCH
    NEXT` 子句，这意味着查询是在数据库服务器上执行的。
- en: 'Next, let us use the `IEnumerable` interface to query the database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `IEnumerable` 接口查询数据库：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we use the `AsEnumerable()` method to convert the `IQueryable`
    object to an `IEnumerable` object. Then, we sort and paginate the invoices and
    call the `ToList()` method to get the results. The logs show the execution order
    of the code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `AsEnumerable()` 方法将 `IQueryable` 对象转换为 `IEnumerable` 对象。然后，我们对发票进行排序和分页，并调用
    `ToList()` 方法以获取结果。日志显示了代码的执行顺序：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Look at the logs. The generated SQL query does not contain the `ORDER BY`, `OFFSET`,
    and `FETCH NEXT` clauses, which means the query fetched all the invoices from
    the database and then filtered, sorted, and paged the invoices in memory. If we
    have a large number of entities in the database, the second query will be very
    slow and inefficient.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 看看日志。生成的 SQL 查询不包含 `ORDER BY`、`OFFSET` 和 `FETCH NEXT` 子句，这意味着查询从数据库中检索了所有发票，然后在内存中对发票进行过滤、排序和分页。如果我们数据库中有大量实体，第二个查询将非常慢且效率低下。
- en: Now, we can see the difference between the two interfaces. The `IQueryable`
    interface is a deferred execution query, which means the query is not executed
    when we add more conditions to the query. The query will be executed against the
    database when we call the `ToList()` or `ToArray()` methods or iterate the items
    in the collection. So, in complex and heavy queries, we should always use the
    `IQueryable` interface to avoid fetching all the data from the database. Be careful
    when you call the `ToList()` or `ToArray()` methods because `ToList()` or `ToArray()`
    (and their `async` overloads) will execute the query immediately.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到两个接口之间的区别。`IQueryable` 接口是一个延迟执行查询，这意味着当我们向查询添加更多条件时，查询不会执行。当调用 `ToList()`
    或 `ToArray()` 方法或遍历集合中的项时，查询将对数据库执行。因此，在复杂和重量级的查询中，我们应该始终使用 `IQueryable` 接口以避免从数据库中检索所有数据。在调用
    `ToList()` 或 `ToArray()` 方法时要小心，因为 `ToList()` 或 `ToArray()`（及其 `async` 重载）将立即执行查询。
- en: What LINQ methods can cause the query to be executed immediately?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些 LINQ 方法会导致查询立即执行？
- en: 'There are a couple of operations that result in the query being executed immediately:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些操作会导致查询立即执行：
- en: Use the `for` or `foreach` loop to iterate the items in the collection
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `for` 或 `foreach` 循环遍历集合中的项
- en: Use the `ToList()`, `ToArray()`, `Single()`, `SingleOrDefault()`, `First()`,
    `FirstOrDefault()`, or `Count()` methods, or the `async` overloads of these methods
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ToList()`、`ToArray()`、`Single()`、`SingleOrDefault()`、`First()`、`FirstOrDefault()`
    或 `Count()` 方法，或这些方法的 `async` 重载
- en: In this section, we explored the differences between `IQueryable` and `IEnumerable`.
    It is important to understand why we should use `IQueryable` instead of `IEnumerable`
    when querying the database for complex and heavy queries. Loading all the data
    from the database can cause performance issues if there are a large number of
    entities in the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 `IQueryable` 和 `IEnumerable` 之间的区别。了解为什么在查询数据库的复杂和重量级查询时应该使用 `IQueryable`
    而不是 `IEnumerable` 非常重要。如果数据库中有大量实体，从数据库中加载数据可能会导致性能问题。
- en: 'Moving on, we will discuss another factor that can affect performance: client
    evaluation.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一个可能影响性能的因素：客户端评估。
- en: Client evaluation versus server evaluation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端评估与服务器评估
- en: In this section, we will discuss the difference between client evaluation and
    server evaluation. In the old versions of EF Core (earlier than EF Core 3.0),
    the wrong usage of LINQ queries that have client evaluation can cause significant
    performance issues. Let's see what client evaluation and server evaluation are.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论客户端评估和服务器评估之间的区别。在 EF Core 的旧版本（早于 EF Core 3.0）中，对具有客户端评估的 LINQ 查询的错误使用可能导致严重的性能问题。让我们看看客户端评估和服务器评估是什么。
- en: 'When we use EF Core to query data from the database, we can just write LINQ
    queries, and EF Core will translate the LINQ queries into SQL queries and execute
    them against the database. However, sometimes, the LINQ operation must be executed
    on the client side. Check the following code in the `SearchInvoices` action method
    in the `InvoicesController` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 EF Core 从数据库查询数据时，我们只需编写 LINQ 查询，EF Core 将 LINQ 查询转换为 SQL 查询并在数据库上执行它们。然而，有时
    LINQ 操作必须在客户端执行。检查 `InvoicesController` 类中的 `SearchInvoices` 动作方法中的以下代码：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we use the `Contains()` method, EF Core can translate the LINQ query into
    the following SQL query:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Contains()` 方法时，EF Core 可以将 LINQ 查询转换为以下 SQL 查询：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that the SQL query uses some native SQL functions to filter the
    data, which means that the SQL query is executed on the database server. This
    is called **server evaluation**. EF Core tries to run server evaluation as much
    as possible.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到SQL查询使用了某些原生SQL函数来过滤数据，这意味着SQL查询是在数据库服务器上执行的。这被称为**服务器评估**。EF Core尽可能多地尝试运行服务器评估。
- en: Now, let's say we want to return the GST tax amount for each invoice. We can
    transfer the entity to a new object with the GST tax amount. Of course, the better
    way is to add a property for the tax in the `Invoice` entity. The following is
    a demonstration of how to do this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要返回每个发票的GST税额。我们可以将实体转换为新对象，并包含GST税额。当然，更好的方法是向`Invoice`实体中添加一个表示税的属性。以下是如何做到这一点的演示。
- en: 'Add a `static` method to calculate the GST tax amount:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个用于计算GST税额的`static`方法：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update the code as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新代码：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We updated the `Description` property by adding the GST tax calculation. When
    we run the application and call the endpoint, we will see the generated SQL query
    is the same as the previous query. But the `Description` property has been updated
    in the result. This means the conversion is done on the client side. This is called
    **client evaluation**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加GST税计算更新了`Description`属性。当我们运行应用程序并调用端点时，我们将看到生成的SQL查询与之前的查询相同。但`Description`属性在结果中已被更新。这意味着转换是在客户端完成的。这被称为**客户端评估**。
- en: 'This kind of client evaluation is acceptable because the query does need to
    fetch the data from the database. The cost is very low. However, it might cause
    problems for some queries. For example, we want to query the invoices that have
    a GST tax amount greater than $10\. Update the code as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种客户端评估是可以接受的，因为查询确实需要从数据库中获取数据。成本非常低。然而，它可能对某些查询造成问题。例如，我们想要查询GST税额大于$10的发票。按照以下方式更新代码：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we call the endpoint, we will see the following error:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用端点时，我们将看到以下错误：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The error message is very clear. This is because the `CalculateTax()` method
    is not supported by EF Core. In old versions of EF Core (earlier than EF Core
    3.0), EF Core will fetch all the data from the database and then filter the data
    in memory. It could cause performance issues. After EF Core 3.0, EF Core will
    throw an exception if the query cannot be translated correctly, to avoid potential
    performance issues.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息非常明确。这是因为`CalculateTax()`方法不受EF Core支持。在EF Core的旧版本（早于EF Core 3.0）中，EF Core将从数据库中获取所有数据，然后在内存中过滤数据。这可能导致性能问题。在EF
    Core 3.0之后，如果查询无法正确转换，EF Core将抛出异常，以避免潜在的性能问题。
- en: But if you are sure the client evaluation is safe, such as when dealing with
    a small data size, you can explicitly use the `AsEnumerable()` method (or `AsAsyncEnumerable()`,
    `ToList()`, or `ToListAsync()`) to force EF Core to fetch all the data and then
    execute the query on the client side. Make sure you know what you are doing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你确定客户端评估是安全的，例如在处理小数据量时，你可以显式使用`AsEnumerable()`方法（或`AsAsyncEnumerable()`、`ToList()`或`ToListAsync()`）来强制EF
    Core获取所有数据，然后在客户端执行查询。确保你知道你在做什么。
- en: Why must the CalculateTax() method be static?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`CalculateTax()`方法必须是静态的？
- en: EF Core caches the compiled query due to the expensive nature of compiling the
    query. If the `CalculateTax()` method is not static, EF Core will need to maintain
    a reference to a constant expression of the `InvoicesController` through the `CalculateTax()`
    instance method, which could potentially lead to memory leaks. To prevent this,
    EF Core throws an exception if the `CalculateTax()` method is not static. Making
    the method static will ensure that EF Core does not capture constant in the instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询编译的成本很高，EF Core会缓存编译后的查询。如果`CalculateTax()`方法不是静态的，EF Core将需要通过`CalculateTax()`实例方法维护对`InvoicesController`的常量表达式的引用，这可能导致内存泄漏。为了防止这种情况，EF
    Core如果`CalculateTax()`方法不是静态的，将抛出异常。将方法设置为静态将确保EF Core不会捕获实例中的常量。
- en: The latest version of EF Core offers the benefit of preventing potential performance
    issues caused by client evaluation. If you encounter an exception similar to a
    previous one, you can review the query to ensure it is being translated correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core的最新版本提供了防止由客户端评估引起的潜在性能问题的好处。如果你遇到与之前类似的异常，你可以检查查询以确保它正在被正确转换。
- en: Next, we will discuss how to use raw SQL queries in EF Core. For some scenarios,
    we need to write raw SQL queries to execute complex queries.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何在EF Core中使用原始SQL查询。在某些场景下，我们需要编写原始SQL查询来执行复杂查询。
- en: Using raw SQL queries
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始 SQL 查询
- en: Although EF Core can translate most LINQ queries into SQL queries, which is
    very convenient, sometimes we need to write raw SQL queries if the required query
    cannot be written in LINQ, or the generated SQL query is not efficient. In this
    section, we will explore how to use raw SQL queries in EF Core.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 EF Core 可以将大多数 LINQ 查询转换为 SQL 查询，这非常方便，但有时如果所需的查询无法用 LINQ 编写，或者生成的 SQL 查询效率不高，我们需要编写原始
    SQL 查询。在本节中，我们将探讨如何在 EF Core 中使用原始 SQL 查询。
- en: 'EF Core provides several methods to execute raw SQL queries:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 提供了几个方法来执行原始 SQL 查询：
- en: '`FromSql()`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromSql()`'
- en: '`FromSqlRaw()`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromSqlRaw()`'
- en: '`SqlQuery()`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SqlQuery()`'
- en: '`SqlQueryRaw()`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SqlQueryRaw()`'
- en: '`ExecuteSql()`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecuteSql()`'
- en: '`ExecuteSqlRaw()`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecuteSqlRaw()`'
- en: When we execute raw SQL queries, we must be careful to avoid SQL injection attacks.
    Let's see when we should use raw SQL queries and how to use them properly. You
    can download the sample code from the `/samples/chapter7/EfCoreDemo` folder in
    the chapter's GitHub repository.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行原始 SQL 查询时，我们必须小心避免 SQL 注入攻击。让我们看看何时应该使用原始 SQL 查询以及如何正确使用它们。您可以从章节的 GitHub
    仓库中的 `/samples/chapter7/EfCoreDemo` 文件夹下载示例代码。
- en: FromSql() and FromSqlRaw()
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FromSql() 和 FromSqlRaw()
- en: We can use the `FromSql()` method to create a LINQ query based on an interpolated
    string. The `FromSql()` method is available in EF Core 7.0 and later versions.
    There is a similar method called `FromSqlInterpolated()` in older versions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `FromSql()` 方法根据一个插值字符串创建一个 LINQ 查询。`FromSql()` 方法在 EF Core 7.0 及更高版本中可用。在旧版本中有一个类似的方法称为
    `FromSqlInterpolated()`。
- en: 'To execute the raw SQL query, we just need to pass the interpolated string
    to the `FromSql()` method, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行原始 SQL 查询，我们只需将插值字符串传递给 `FromSql()` 方法，如下所示：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also pass parameters to the raw SQL query. For example, we want to query
    the invoices that have a specific status:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向原始 SQL 查询传递参数。例如，我们想要查询具有特定状态的发票：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Wait, is it safe to insert a string into the SQL query directly? What if the
    `status` parameter is `'; DROP TABLE Invoices; --`? Will it cause a SQL injection
    attack?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，直接将字符串插入 SQL 查询是否安全？如果 `status` 参数是 `'; DROP TABLE Invoices; --`，会发生什么？它会导致
    SQL 注入攻击吗？
- en: 'That is a good question. Let us see how EF Core handles the parameters. Run
    the application and call the `/api/invoices/status?status=AwaitPayment` endpoint.
    We will see the generated SQL query is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好问题。让我们看看 EF Core 如何处理参数。运行应用程序并调用 `/api/invoices/status?status=AwaitPayment`
    端点。我们将看到生成的 SQL 查询如下：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The parameter is not inserted into the SQL query directly. Instead, EF Core
    uses the `@p0` parameter placeholder and passes the parameter value to the SQL
    query. This is called a parameterized query. It is safe to use the parameterized
    query to avoid SQL injection attacks. So, we do not need to worry about the safety
    of the `FromSql` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 参数不是直接插入到 SQL 查询中。相反，EF Core 使用 `@p0` 参数占位符并将参数值传递到 SQL 查询中。这被称为参数化查询。使用参数化查询来避免
    SQL 注入攻击是安全的。因此，我们不需要担心 `FromSql` 方法的安全性。
- en: Why FromSql() is safe to use
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 FromSql() 是安全的
- en: The `FromSql()` method expects a parameter as the `FormattableString` type.
    So, it is required to use the interpolated string syntax by using the `$` prefix.
    The syntax looks like regular C# string interpolation, but it is not the same
    thing. A `FormattableString` type can include interpolated parameter placeholders.
    The interpolated parameter values will be automatically converted to the `DbParameter`
    type. So, it is safe to use the `FromSql()` method to avoid SQL injection attacks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromSql()` 方法期望一个参数作为 `FormattableString` 类型。因此，必须使用 `$` 前缀来使用插值字符串语法。语法看起来像常规的
    C# 字符串插值，但它不是同一回事。`FormattableString` 类型可以包含插值参数占位符。插值参数值将自动转换为 `DbParameter`
    类型。因此，使用 `FromSql()` 方法来避免 SQL 注入攻击是安全的。'
- en: 'For some scenarios, we might need to build dynamic SQL queries. For example,
    we want to query the invoices according to user input, which specifies the property
    name and property value. For this case, we cannot use `FromSql` because it is
    not allowed to parameterize the column names. We need to use `FromSqlRaw` instead.
    However, we must be careful to avoid SQL injection attacks. It is the developer’s
    responsibility to make sure the SQL query is safe. Here is an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些场景，我们可能需要构建动态 SQL 查询。例如，我们想要根据用户输入查询发票，该输入指定了属性名称和属性值。在这种情况下，我们不能使用 `FromSql`，因为不允许对列名进行参数化。我们需要使用
    `FromSqlRaw`。然而，我们必须小心避免 SQL 注入攻击。确保 SQL 查询安全是开发者的责任。以下是一个示例：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, the column name is not parameterized. Therefore, we
    must be careful to avoid SQL injection attacks. It is required to sanitize the
    `propertyName` value to make sure it is safe. Maybe you can check whether the
    value contains any special characters, such as `;`, `--`, and so on. If the value
    contains any special characters, you can throw an exception or remove the special
    characters before executing the SQL query. Also, if you allow the user to specify
    the column name, it will increase the effort to validate the column name because
    you need to check whether the column name exists in the database or whether the
    column has the correct index. Make sure you know what you are doing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，列名没有被参数化。因此，我们必须小心避免 SQL 注入攻击。需要清理 `propertyName` 的值以确保其安全性。也许你可以检查该值是否包含任何特殊字符，例如
    `;`、`--` 等。如果值包含任何特殊字符，你可以在执行 SQL 查询之前抛出异常或删除这些特殊字符。此外，如果你允许用户指定列名，这将增加验证列名的努力，因为你需要检查该列名是否存在于数据库中或该列是否有正确的索引。确保你知道你在做什么。
- en: The `propertyValue` is parameterized, so it is safe to use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`propertyValue` 是参数化的，因此使用它是安全的。'
- en: After you build the SQL query using `FromSql()`, you can then apply the LINQ
    query operators to filter the data as you want. Remember that it is better to
    use `FromSql()` than `FromSqlRaw()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `FromSql()` 构建了 SQL 查询之后，你可以然后应用 LINQ 查询运算符来过滤数据，正如你想要的。记住，使用 `FromSql()`
    比使用 `FromSqlRaw()` 更好。
- en: 'When we use the `FromSql()` or `FromSqlRaw()` methods, keep in mind that there
    are some limitations:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `FromSql()` 或 `FromSqlRaw()` 方法时，请记住有一些限制：
- en: The data returned from the SQL query must contain all the properties of the
    entity, otherwise, EF Core cannot map the data to the entity.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 查询返回的数据必须包含实体的所有属性，否则 EF Core 无法将数据映射到实体。
- en: The column names returned from the SQL query must match the column names that
    the entity properties are mapped to.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 查询返回的列名必须与实体属性映射到的列名匹配。
- en: The SQL query can only query one table. If you need to query multiple tables,
    you can build the raw query first and then use the `Include()` method to include
    the related entities.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 查询只能查询一个表。如果你需要查询多个表，你可以先构建原始查询，然后使用 `Include()` 方法包含相关实体。
- en: SqlQuery() and SqlQueryRaw()
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SqlQuery() 和 SqlQueryRaw()
- en: 'The `FromSql()` method is useful when we want to query entities from the database
    using a raw SQL query. For some cases, we want to execute the raw SQL query and
    return a scalar value or non-entity type. For example, we want to query the IDs
    of invoices that have a specific status. We can use the `SqlQuery()` method to
    execute the raw SQL query and return a list of IDs. Here is an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想使用原始 SQL 查询从数据库中查询实体时，`FromSql()` 方法很有用。在某些情况下，我们想执行原始 SQL 查询并返回标量值或非实体类型。例如，我们想查询具有特定状态的发票的
    ID。我们可以使用 `SqlQuery()` 方法执行原始 SQL 查询并返回 ID 列表。以下是一个示例：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The translated SQL query is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译后的 SQL 查询如下：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the `SqlQuery()` method is used on the `Database` property of the
    `DbContext` object. It is not available on the `DbSet` object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`SqlQuery()` 方法是在 `DbContext` 对象的 `Database` 属性上使用的。它不可在 `DbSet` 对象上使用。
- en: The `SqlQueryRaw()` method is similar to the `SqlQuery()` method, but it allows
    us to build dynamic SQL queries like the `FromSqlRaw()` method. Similarly, you
    must take responsibility to avoid SQL injection attacks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlQueryRaw()` 方法与 `SqlQuery()` 方法类似，但它允许我们构建类似于 `FromSqlRaw()` 方法的动态 SQL
    查询。同样，你必须承担责任以避免 SQL 注入攻击。'
- en: ExecuteSql() and ExecuteSqlRaw()
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ExecuteSql() 和 ExecuteSqlRaw()
- en: 'For some scenarios, where we do not need return values, we can use the `ExecuteSql`
    method to execute a raw SQL query. Normally, it is used to update or delete data
    or call a `ExecuteSql()` method to execute the raw SQL query. Here is an example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些不需要返回值的情况，我们可以使用 `ExecuteSql` 方法来执行原始 SQL 查询。通常，它用于更新或删除数据或调用 `ExecuteSql()`
    方法来执行原始 SQL 查询。以下是一个示例：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this way, we do not need to load the entities from the database and then
    delete them one by one. It is much more efficient to use the `ExecuteSql()` method
    to execute the raw SQL query.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们不需要从数据库中加载实体然后逐个删除。使用 `ExecuteSql()` 方法执行原始 SQL 查询要高效得多。
- en: The `ExecuteSqlRaw()` method is similar to the `ExecuteSql()` method, but it
    allows us to build dynamic SQL queries like the `FromSqlRaw()` method. Similarly,
    you must be very careful to sanitize the SQL query to avoid SQL injection attacks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteSqlRaw()` 方法与 `ExecuteSql()` 方法类似，但它允许我们构建类似于 `FromSqlRaw()` 方法的动态
    SQL 查询。同样，您必须非常小心地清理 SQL 查询以避免 SQL 注入攻击。'
- en: In this section, we introduced how to use raw SQL queries in EF Core. We discussed
    the differences between `FromSql()` and `FromSqlRaw()`, `SqlQuery()` and `SqlQueryRaw()`,
    and `ExecuteSql()` and `ExecuteSqlRaw()`. We also discussed the limitations of
    these methods. Again, we must be very careful to avoid SQL injection attacks when
    we use raw SQL queries.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何在 EF Core 中使用原始 SQL 查询。我们讨论了 `FromSql()` 和 `FromSqlRaw()`、`SqlQuery()`
    和 `SqlQueryRaw()`、`ExecuteSql()` 和 `ExecuteSqlRaw()` 之间的区别。我们还讨论了这些方法的局限性。再次强调，当我们使用原始
    SQL 查询时，必须非常小心以避免 SQL 注入攻击。
- en: In one of the examples in this section, we showed you how to run a raw SQL query
    to delete a set of entities. EF Core 7.0 introduces a bulk operations feature
    that can make this easier. There are two new methods available for bulk operations,
    `ExecuteUpdate()` and `ExecuteDelete()`, which provide a more efficient way to
    update or delete data. In the following section, we will discuss this feature
    in more detail.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的一个示例中，我们向您展示了如何运行原始 SQL 查询来删除一组实体。EF Core 7.0 引入了一个批量操作功能，可以使这个过程更容易。现在有两个新的批量操作方法可用，即
    `ExecuteUpdate()` 和 `ExecuteDelete()`，它们提供了一种更有效的方式来更新或删除数据。在接下来的部分中，我们将更详细地讨论这个功能。
- en: Using bulk operations
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用批量操作
- en: In this section, we will explore how to effectively update/delete data using
    EF Core. EF Core 7.0 or later offers the ability of bulk operations, which are
    easy to use and can improve the performance of update/delete operations. To take
    advantage of this feature, ensure you are using the most recent version of EF
    Core.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何有效地使用 EF Core 更新/删除数据。EF Core 7.0 或更高版本提供了批量操作的能力，这些操作易于使用，可以提高更新/删除操作的性能。为了利用这个功能，请确保您正在使用
    EF Core 的最新版本。
- en: As we mentioned in the previous section, EF Core tracks the changes in entities.
    To update an entity, normally, we need to load the entity from the database, update
    the entity properties, and then call the `SaveChanges()` method to save the changes
    to the database. This is a very common scenario. Deleting an entity is similar.
    However, if we want to update or delete a large number of entities, it is not
    efficient to load the entities one by one and then update or delete them. For
    these scenarios, it is not required to track the changes in the entities. So,
    it would be better to use the bulk operations feature to update or delete data.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，EF Core 跟踪实体的变化。要更新一个实体，通常情况下，我们需要从数据库中加载实体，更新实体属性，然后调用 `SaveChanges()`
    方法将更改保存到数据库。这是一个非常常见的场景。删除实体的情况类似。然而，如果我们想要更新或删除大量实体，逐个加载实体并更新或删除它们并不高效。对于这些场景，不需要跟踪实体的变化。因此，使用批量操作功能来更新或删除数据会更好。
- en: We can use a raw SQL query to update or delete data using the `ExecuteSql()`
    method. However, it lacks strong type support. Hardcoding the column names in
    the SQL query is not a good practice. From EF Core 7.0, we can use the `ExecuteUpdate()`
    and `ExecuteDelete()` methods to update or delete data. Note that these two methods
    do not involve the entity tracking feature. So, once you call these two methods,
    the changes will be executed immediately. There is no need to call the `SaveChanges()`
    method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原始 SQL 查询通过 `ExecuteSql()` 方法来更新或删除数据。然而，它缺乏强类型支持。在 SQL 查询中硬编码列名不是一种好的做法。从
    EF Core 7.0 开始，我们可以使用 `ExecuteUpdate()` 和 `ExecuteDelete()` 方法来更新或删除数据。请注意，这两个方法不涉及实体跟踪功能。因此，一旦您调用这两个方法，更改将立即执行。不需要调用
    `SaveChanges()` 方法。
- en: Next, let us see how to use these two methods. We will show you how to use the
    `ExecuteUpdate()` method and what SQL query is generated. The `ExecuteDelete()`
    method is similar. The sample code is located at the `/samples/chapter7/EfCoreDemo`
    folder in the chapter's GitHub repository.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用这两个方法。我们将向您展示如何使用 `ExecuteUpdate()` 方法以及生成的 SQL 查询。`ExecuteDelete()`
    方法类似。示例代码位于章节的 GitHub 仓库 `/samples/chapter7/EfCoreDemo` 文件夹中。
- en: ExecuteUpdate()
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ExecuteUpdate()
- en: The `ExecuteUpdate()` method is used to update data without loading the entities
    from the database. You can use it to update one or more entities by adding the
    `Where()` clause.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteUpdate()` 方法用于在不从数据库加载实体的情况下更新数据。您可以通过添加 `Where()` 子句来更新一个或多个实体。'
- en: 'For example, we want to update the status of the invoices that were created
    before a specific date. The code is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要更新在特定日期之前创建的发票的状态。代码如下：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The generated SQL query is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SQL 查询如下：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This query can update multiple invoices at the same time. It does benefit from
    the strong type support but has the same efficiency as the raw SQL query. If you
    need to update more than one property, you can use the `SetProperty()` method
    multiple times, as seen in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询可以同时更新多个发票。它确实受益于强大的类型支持，但效率与原始 SQL 查询相同。如果您需要更新多个属性，可以使用 `SetProperty()`
    方法多次，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In addition, the `Where()` clause can reference the other entities. So, the
    `ExecuteUpdate()` method is always recommended to update multiple entities, instead
    of using the raw SQL query.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Where()` 子句可以引用其他实体。因此，始终推荐使用 `ExecuteUpdate()` 方法来更新多个实体，而不是使用原始 SQL 查询。
- en: ExecuteDelete()
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ExecuteDelete()`'
- en: 'Similarly, we can use the `ExecuteDelete()` method to delete data without loading
    the entities from the database. This method can be used to delete one or more
    entities by adding the `Where` clause. For example, we want to delete the invoices
    that were created before a specific date. The code is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `ExecuteDelete()` 方法来删除数据，而无需从数据库中加载实体。此方法可以通过添加 `Where` 子句来删除一个或多个实体。例如，我们想要删除在特定日期之前创建的发票。代码如下：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, these bulk operations do not track the changes in the entities. If a
    `DbContext` instance already loaded the entities, after the bulk update or delete,
    the entities in the context will still keep the old values. So, be careful when
    using these bulk operations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些批量操作不会跟踪实体的变化。如果一个 `DbContext` 实例已经加载了实体，在批量更新或删除之后，上下文中的实体仍然会保留旧值。因此，在使用这些批量操作时要格外小心。
- en: In this section, we discussed how to use the bulk operations feature in EF Core.
    We introduced the `ExecuteUpdate()` and `ExecuteDelete()` methods, which can be
    used to update or delete data without loading the entities from the database.
    Compared to a raw SQL query, these two methods have strong type support. It is
    recommended to use these two methods to update or delete multiple entities.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何在 EF Core 中使用批量操作功能。我们介绍了 `ExecuteUpdate()` 和 `ExecuteDelete()`
    方法，这些方法可以用来更新或删除数据，而无需从数据库中加载实体。与原始 SQL 查询相比，这两种方法具有强大的类型支持。建议使用这两种方法来更新或删除多个实体。
- en: Next, we will learn how to manage concurrency conflicts when updating data.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何在更新数据时管理并发冲突。
- en: Understanding concurrency conflicts
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并发冲突
- en: An API endpoint can be called by multiple clients at the same time. If the endpoint
    updates data, the data may be updated by another client before the current client
    completes the update. When the same entity is updated by multiple clients, it
    can cause a concurrency conflict, which may result in data loss or inconsistency,
    or even cause data corruption. In this section, we will discuss how to handle
    concurrency conflicts in EF Core. You can download the sample project `ConcurrencyConflictDemo`
    from the `/samples/chapter7/ConcurrencyConflictDemo` folder in the chapter's GitHub
    repository.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 API 端点可以同时被多个客户端调用。如果端点更新数据，数据可能在当前客户端完成更新之前被另一个客户端更新。当同一实体被多个客户端更新时，可能会引起并发冲突，这可能导致数据丢失或不一致，甚至可能造成数据损坏。在本节中，我们将讨论如何在
    EF Core 中处理并发冲突。您可以从章节的 GitHub 仓库 `/samples/chapter7/ConcurrencyConflictDemo`
    文件夹中下载示例项目 `ConcurrencyConflictDemo`。
- en: 'There are two ways to handle concurrency conflicts:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 处理并发冲突有两种方式：
- en: '**Pessimistic concurrency control**: This uses database locks to prevent multiple
    clients from updating the same entity at the same time. When a client tries to
    update an entity, it will first acquire a lock on the entity. If the lock is acquired
    successfully, only this client can update the entity, and all other clients will
    be blocked from updating the entity until the lock is released. However, this
    approach may result in performance issues when the number of concurrent clients
    is large because managing locks is expensive. EF Core does not have built-in support
    for pessimistic concurrency control.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**悲观并发控制**：这种方法使用数据库锁来防止多个客户端同时更新同一实体。当客户端尝试更新一个实体时，它将首先对该实体获取一个锁。如果锁获取成功，则只有这个客户端可以更新实体，而所有其他客户端将无法更新该实体，直到锁被释放。然而，当并发客户端数量较多时，这种方法可能会导致性能问题，因为管理锁的成本很高。EF
    Core 不支持内置的悲观并发控制。'
- en: '**Optimistic concurrency control**: This way does not involve locks; instead,
    a version column is used to detect concurrency conflicts. When a client tries
    to update an entity, it will first get the value of the version column, and then
    compare this value with the old value when updating the entity. If the value of
    the version column is the same, it means that no other client has updated the
    entity. In this case, the client can update the entity. But if the value of the
    version column is different from the old value, it means that another client has
    updated the entity. In this case, EF Core will throw an exception to indicate
    the concurrency conflict. The client can then handle the exception and retry the
    update operation.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乐观并发控制**：这种方法不涉及锁；相反，使用版本列来检测并发冲突。当客户端尝试更新一个实体时，它将首先获取版本列的值，然后在更新实体时将其与旧值进行比较。如果版本列的值与旧值相同，这意味着没有其他客户端已更新该实体。在这种情况下，客户端可以更新实体。但如果版本列的值与旧值不同，这意味着另一个客户端已更新该实体。在这种情况下，EF
    Core将抛出一个异常来指示并发冲突。然后客户端可以处理异常并重试更新操作。'
- en: 'Let''s see an example of concurrency conflicts. In the `ConcurrencyConflictDemo`
    project, we have a `Product` entity with an `Inventory` property, which is used
    to store the number of products in stock. We want to create an API endpoint to
    sell a product. When a client calls this endpoint, it will pass the product ID
    and the number of products to sell. The endpoint will then update the `Inventory`
    property by subtracting the number of products to sell. The logic is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看并发冲突的一个例子。在`ConcurrencyConflictDemo`项目中，我们有一个具有`Inventory`属性的`Product`实体，该属性用于存储库存中的产品数量。我们想要创建一个API端点来销售产品。当客户端调用此端点时，它将传递产品ID和要销售的产品数量。端点将更新`Inventory`属性，减去要销售的产品数量。逻辑如下：
- en: The client calls the API endpoint to sell a product.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端调用API端点来销售产品。
- en: The application gets the product from the database.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序从数据库中获取产品。
- en: 'The application checks the `Inventory` property to make sure that the number
    of products in stock is enough for the sale:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序检查`Inventory`属性以确保库存中的产品数量足以销售：
- en: If the number of products in stock is enough, the application subtracts the
    number of products being sold from the `Inventory` property and then calls the
    `SaveChanges()` method to save the changes to the database
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库存中的产品数量足够，应用程序将从`Inventory`属性中减去正在销售的产品数量，然后调用`SaveChanges()`方法将更改保存到数据库。
- en: If the number of products in stock is not enough, the application returns an
    error message to the client
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库存中的产品数量不足，应用程序将向客户端返回错误信息。
- en: Important note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The example project uses the following code to reset the database in the `Program.cs`
    file when the application starts:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目使用以下代码在`Program.cs`文件中启动应用程序时重置数据库：
- en: '`dbContext.Database.EnsureDeleted();`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbContext.Database.EnsureDeleted();`'
- en: '`dbContext.Database.EnsureCreated();`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbContext.Database.EnsureCreated();`'
- en: So, when you run the application, the database will be reset, and the `Inventory`
    property of product 1 will be set to `15`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你运行应用程序时，数据库将被重置，产品1的`Inventory`属性将被设置为`15`。
- en: 'The following code shows the first version of the implementation of the API
    endpoint:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了API端点的实现的第一版本：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There should be some other logic that handles the order creation and payment,
    and so on. We will not discuss that here; instead, we will focus on the concurrency
    conflicts caused by the product inventory update:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 应该还有一些其他逻辑来处理订单创建和支付等操作。我们在这里不会讨论这些；相反，我们将专注于由产品库存更新引起的并发冲突：
- en: 'To simulate this concurrent scenario, we can pass a `delay` parameter to add
    a delay before saving the changes to the database. The following code shows how
    to add a delay:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟这种并发场景，我们可以在保存更改到数据库之前传递一个`delay`参数来添加延迟。以下代码显示了如何添加延迟：
- en: '[PRE31]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let us try to call the API endpoint twice in a short time. The first `POST`
    request will pass a `delay` parameter with a value of `2` seconds:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在短时间内两次调用API端点。第一次`POST`请求将传递一个值为`2`秒的`delay`参数：
- en: '[PRE32]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second `POST` request will pass the `delay` parameter with a value of `3`
    seconds:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二次`POST`请求将传递一个值为`3`秒的`delay`参数：
- en: '[PRE33]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Send the first request and then send the second request in `2` seconds. The
    expected result should be that the first request will succeed and the second request
    will fail. But actually, both requests will succeed. The responses show that the
    `Inventory` property of the product is updated to `5`, which is incorrect. The
    initial value of the `Inventory` property is `15`, and we sold 20 products, so
    how can the `Inventory` property be updated to `5`?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先发送第一个请求，然后隔`2`秒发送第二个请求。预期结果是第一个请求成功，第二个请求失败。但实际上，两个请求都成功了。响应显示产品的`Inventory`属性已更新为`5`，这是不正确的。`Inventory`属性的初始值是`15`，而我们卖出了20个产品，那么`Inventory`属性怎么会被更新为`5`呢？
- en: 'Let us see what happens in the application:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看应用中会发生什么：
- en: Client A calls the API endpoint to sell a product and wants to sell 10 products.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端A调用API端点来销售产品，并希望销售10个产品。
- en: Client A checks the `Inventory` property and finds that the number of products
    in stock is 15, which is enough to sell.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端A检查`Inventory`属性，发现库存中的产品数量为15，这足以销售。
- en: Almost at the same time, client B calls the API endpoint to sell a product and
    wants to sell 10 products.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几乎同时，客户端B调用API端点来销售产品，并希望销售10个产品。
- en: Client B checks the `Inventory` property and finds that the number of products
    in stock is 15 because client A has not updated the `Inventory` property yet.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端B检查`Inventory`属性，发现库存中的产品数量为15，因为客户端A尚未更新`Inventory`属性。
- en: Client A subtracts 10 from the `Inventory` property, which results in a value
    of `5`, and saves the changes to the database. Now, the number of products in
    stock is `5`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端A从`Inventory`属性中减去10，结果值为`5`，并将更改保存到数据库中。现在，库存中的产品数量为`5`。
- en: Client B also subtracts 10 from the `Inventory` property and saves the changes
    to the database. The problem is that the number of products in stock has been
    updated to `5` by client A, but client B does not know this. So, client B also
    updates the `Inventory` property to `5`, which is incorrect.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端B也从`Inventory`属性中减去10并保存更改到数据库。问题是客户端A已经将库存数量更新为`5`，但客户端B并不知道这一点。因此，客户端B也将`Inventory`属性更新为`5`，这是不正确的。
- en: This is an example of concurrency conflict. Multiple clients try to update the
    same entity at the same time, and the result is not what we expected. In this
    case, client B should not be able to update the `Inventory` property because the
    number of products in stock is not enough. However, if the application does not
    handle concurrency conflicts, we may end up with incorrect data in the database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个并发冲突的例子。多个客户端试图同时更新同一个实体，结果并非我们所期望的。在这种情况下，客户端B不应该能够更新`Inventory`属性，因为库存中的产品数量不足。然而，如果应用程序没有处理并发冲突，我们可能会在数据库中得到错误的数据。
- en: 'To solve this problem, EF Core provides optimistic concurrency control. There
    are two ways to use optimistic concurrency control:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，EF Core提供了乐观并发控制。有两种方式可以使用乐观并发控制：
- en: Native database-generated concurrency token
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生数据库生成的并发令牌
- en: Application-managed concurrency token
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序管理的并发令牌
- en: Let us see how to use these two ways to handle concurrency conflicts.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这两种方式来处理并发冲突。
- en: Native database-generated concurrency token
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生数据库生成的并发令牌
- en: 'Some databases, such as SQL Server, provide a native mechanism to handle concurrency
    conflicts. To use the native database-generated concurrency token in SQL Server,
    we need to create a new property for the `Product` class and add a `[Timestamp]`
    attribute to it. The following code shows the updated `Product` class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库，如SQL Server，提供原生机制来处理并发冲突。要在SQL Server中使用原生数据库生成的并发令牌，我们需要为`Product`类创建一个新的属性，并给它添加一个`[Timestamp]`属性。下面的代码显示了更新的`Product`类：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the Fluent API configuration, we need to add the following code to map the
    `RowVersion` property to the `rowversion` column in the database:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fluent API配置中，我们需要添加以下代码来将`RowVersion`属性映射到数据库中的`rowversion`列：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you prefer to use the data annotation configuration, you can add the `[Timestamp]`
    attribute to the `RowVersion` property, and EF Core will automatically map it
    to the `rowversion` column in the database, as shown in the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用数据注释配置，你可以在`RowVersion`属性上添加`[Timestamp]`属性，EF Core将自动将其映射到数据库中的`rowversion`列，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Do not forget to run the `dotnet ef migrations add AddConcurrencyControl` command
    to create a new migration. There is no need to run the `dotnet ef database update`
    command this time because we have the code to reset the database when the application
    starts.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记运行`dotnet ef migrations add AddConcurrencyControl`命令来创建一个新的迁移。这次不需要运行`dotnet
    ef database update`命令，因为我们有代码在应用程序启动时重置数据库。
- en: Important note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you want to configure the mapping in Fluent API, you can use the following
    code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Fluent API中配置映射，可以使用以下代码：
- en: '`modelBuilder.Entity<Product>()`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`modelBuilder.Entity<Product>()`'
- en: '`.Property(p =>` `p.RowVersion)`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Property(p =>` `p.RowVersion)`'
- en: '`.``IsRowVersion();`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`.``IsRowVersion();`'
- en: 'This will generate the following migration:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下迁移：
- en: '`migrationBuilder.AddColumn<byte[]>(`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrationBuilder.AddColumn<byte[]>(`'
- en: '`name: "RowVersion",`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`name: "RowVersion",`'
- en: '`table: "Products",`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`table: "Products",`'
- en: '`type: "rowversion",`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`type: "rowversion",`'
- en: '`rowVersion: true,`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowVersion: true,`'
- en: '`nullable: false,`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`nullable: false,`'
- en: '`defaultValue:` `new byte[0]);`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultValue:` `new byte[0]);`'
- en: 'Now, let''s try to call the API endpoint again. Use the same requests as before,
    one with a `delay` parameter of `2` seconds, and the other with a `delay` parameter
    of `3` seconds. This time, we should see that the first request will succeed,
    but the second request will fail with a `DbUpdateConcurrencyException` exception:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试调用API端点。使用之前相同的请求，一个带有`2`秒`delay`参数，另一个带有`3`秒`delay`参数。这次，我们应该看到第一个请求将成功，但第二个请求将失败，并抛出`DbUpdateConcurrencyException`异常：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Check the database. The `Inventory` column of product 1 has been updated to
    `5`, which is correct.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 检查数据库。产品1的`Inventory`列已更新为`5`，这是正确的。
- en: 'If you check the SQL statement generated by EF Core, you will find that the
    `rowversion` column is included in the `WHERE` clause of the `UPDATE` statement:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查EF Core生成的SQL语句，你会发现`rowversion`列被包含在`UPDATE`语句的`WHERE`子句中：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By using concurrency control, EF Core not only checks the ID of the entity but
    also checks the value of the `rowversion` column. If the value of the `rowversion`
    column is not the same as the value in the database, it means that the entity
    has been updated by another client, and the current update operation should be
    aborted.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用并发控制，EF Core不仅检查实体的ID，还检查`rowversion`列的值。如果`rowversion`列的值与数据库中的值不同，这意味着实体已被另一个客户端更新，当前的更新操作应该被中止。
- en: Note that the `rowversion` column type is available for SQL Server, but not
    for other databases, such as SQLite. Different databases may have different types
    of concurrency tokens, or may not support the concurrency token at all. Please
    check the documentation of the database you are using to see whether it supports
    the built-in concurrency token. If not, you need to use the application-managed
    concurrency token, as shown in the next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`rowversion`列类型适用于SQL Server，但不适用于其他数据库，如SQLite。不同的数据库可能有不同类型的并发令牌，或者根本不支持并发令牌。请查看您所使用数据库的文档，以了解它是否支持内置的并发令牌。如果不支持，您需要使用应用程序管理的并发令牌，如下一节所示。
- en: Application-managed concurrency token
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序管理的并发令牌
- en: If the database does not support the built-in concurrency token, we can manually
    manage the concurrency token in the application. Instead of using the `rowversion`
    column, which can be automatically updated by the database, we can use a property
    in the entity class to manage the concurrency token and assign a new value to
    it every time the entity is updated.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库不支持内置的并发令牌，我们可以在应用程序中手动管理并发令牌。而不是使用数据库可以自动更新的`rowversion`列，我们可以使用实体类中的一个属性来管理并发令牌，并在每次实体更新时为其分配一个新的值。
- en: 'Here is an example of using the application-managed concurrency token:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用应用程序管理的并发令牌的示例：
- en: 'First, we need to add a new property to the `Product` class, as shown in the
    following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`Product`类中添加一个新的属性，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Update the Fluent API configuration to specify the `Version` property as the
    concurrency token:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Fluent API配置以指定`Version`属性作为并发令牌：
- en: '[PRE40]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The corresponding data annotation configuration is as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相应的数据注释配置如下：
- en: '[PRE41]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Because this `Version` property is not managed by the database, we need to manually
    assign a new value whenever the entity is updated.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为这个`Version`属性不由数据库管理，所以每当实体被更新时，我们需要手动分配一个新的值。
- en: 'The following code shows how to update the `Version` property when the entity
    is updated:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了在实体更新时如何更新`Version`属性：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can use the application-managed concurrency token in SQL Server as well.
    The only difference is that you need to manually assign a new value to the concurrency
    token property every time the entity is updated. But if you use the built-in concurrency
    token in SQL Server, you do not need to do that.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 SQL Server 中使用应用管理的并发令牌。唯一的区别是每次实体更新时，您需要手动将新值分配给并发令牌属性。但如果你使用 SQL Server
    中的内置并发令牌，则不需要这样做。
- en: In the event of a concurrency conflict, it is essential to take the necessary
    steps to resolve the issue. This will be addressed in the following section.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发冲突发生的情况下，采取必要的步骤来解决问题是至关重要的。这将在下一节中讨论。
- en: Handling concurrency conflicts
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理并发冲突
- en: 'When a concurrency conflict occurs, EF Core will throw a `DbUpdateConcurrencyException`
    exception. We can catch this exception and handle it in the application. For example,
    we can return a `409 Conflict` status code to the client, and let the client decide
    what to do next:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生并发冲突时，EF Core 将抛出 `DbUpdateConcurrencyException` 异常。我们可以捕获这个异常并在应用程序中处理它。例如，我们可以向客户端返回
    `409 冲突` 状态码，并让客户端决定下一步做什么：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code returns a `409 Conflict` status code to the client when a
    concurrency conflict occurs. The client can then handle the exception and retry
    the update operation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生并发冲突时，前面的代码会向客户端返回 `409 冲突` 状态码。然后客户端可以处理异常并重试更新操作。
- en: Important note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Some databases provide different isolation levels to handle concurrency conflicts.
    For example, SQL Server provides four isolation levels: `ReadUncommitted`, `ReadCommitted`,
    `RepeatableRead`, and `Serializable`. The default isolation level is `ReadCommitted`.
    Each isolation level has different behaviors when a concurrency conflict occurs
    and has its own pros and cons. Higher levels of isolation provide more consistency
    but also reduce concurrency. For more information, see *Isolation Levels* at [https://learn.microsoft.com/en-gb/sql/t-sql/statements/set-transaction-isolation-level-transact-sql](https://learn.microsoft.com/en-gb/sql/t-sql/statements/set-transaction-isolation-level-transact-sql).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库提供了不同的隔离级别来处理并发冲突。例如，SQL Server 提供了四个隔离级别：`ReadUncommitted`、`ReadCommitted`、`RepeatableRead`
    和 `Serializable`。默认隔离级别是 `ReadCommitted`。当发生并发冲突时，每个隔离级别都有不同的行为，并且各有优缺点。更高的隔离级别提供了更多的一致性，但也会降低并发性。有关更多信息，请参阅[隔离级别](https://learn.microsoft.com/en-gb/sql/t-sql/statements/set-transaction-isolation-level-transact-sql)。
- en: 'In this section, we discussed how to handle concurrency conflicts in EF Core.
    We introduced two ways to handle concurrency conflicts: native database-generated
    concurrency tokens and application-managed concurrency tokens. We also discussed
    how to handle exceptions when concurrency conflicts occur. Concurrency conflicts
    are a common issue in a highly concurrent environment. It is important to handle
    them properly to avoid data loss or inconsistency.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何在 EF Core 中处理并发冲突。我们介绍了两种处理并发冲突的方法：原生数据库生成的并发令牌和应用管理的并发令牌。我们还讨论了当并发冲突发生时如何处理异常。并发冲突在高并发环境中是一个常见问题。正确处理它们对于避免数据丢失或不一致非常重要。
- en: Reverse engineering
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向工程
- en: So far, we have learned how to use EF Core to create a database schema from
    the entity classes. This is called *code-first*. However, sometimes we need to
    work with an existing database. In this case, we need to create the entity classes
    and `DbContext` from the existing database schema. This is called *database-first*
    or *reverse engineering*. In this section, we will discuss how to use EF Core
    to reverse engineer the entity classes and `DbContext` from an existing database
    schema. This is useful when we want to migrate an existing application to EF Core.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 EF Core 从实体类创建数据库架构。这被称为 *代码优先*。然而，有时我们需要处理现有的数据库。在这种情况下，我们需要从现有的数据库架构创建实体类和
    `DbContext`。这被称为 *数据库优先* 或 *反向工程*。在本节中，我们将讨论如何使用 EF Core 从现有的数据库架构反向工程实体类和 `DbContext`。当我们想要将现有应用程序迁移到
    EF Core 时，这非常有用。
- en: Let's use the `EfCoreRelationshipsDemoDb` database as an example. If you have
    not created this database, please follow the steps in [*Chapter 6*](B18971_06.xhtml#_idTextAnchor245)
    to create it. The sample code is located at the `/samples/chapter7/EfCoreReverseEngineeringDemo`
    folder in the chapter's GitHub repository.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`EfCoreRelationshipsDemoDb`数据库为例。如果您还没有创建此数据库，请按照[*第六章*](B18971_06.xhtml#_idTextAnchor245)中的步骤创建它。示例代码位于该章节GitHub仓库的`/samples/chapter7/EfCoreReverseEngineeringDemo`文件夹中。
- en: 'First, let us create a new web API project. Run the following command in the
    terminal:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的Web API项目。在终端中运行以下命令：
- en: '[PRE44]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Microsoft.EntityFrameworkCore.SqlServer NuGet package to the project:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`Microsoft.EntityFrameworkCore.SqlServer` NuGet包添加到项目中：
- en: '[PRE45]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we will use the `dbcontext scaffold` command to generate the entity classes
    and `DbContext` from the database schema. This command needs the connection string
    of the database and the name of the database provider. We can run the following
    command in the terminal:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`dbcontext scaffold`命令从数据库模式生成实体类和`DbContext`。此命令需要数据库的连接字符串和数据库提供者的名称。您可以在终端中运行以下命令：
- en: '[PRE47]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Open the `AppDbContext.cs` file, and we will see a warning in the following
    code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AppDbContext.cs`文件，我们将在以下代码中看到一个警告：
- en: '[PRE49]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This warning tells us that we should not store the connection string in the
    source code. Instead, we should store it in a configuration file, such as `appsettings.json`.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个警告告诉我们，我们不应该在源代码中存储连接字符串。相反，我们应该将其存储在配置文件中，例如`appsettings.json`。
- en: In the `OnModelCreating` method, we can see the entity classes and their relationships
    have been configured in Fluent API style. If you prefer to use data annotations,
    you can use the `--data-annotations` option when you run the `dbcontext scaffold`
    command. But as we mentioned in [*Chapter 5*](B18971_05.xhtml#_idTextAnchor198),
    Fluent API is more powerful than data annotations, and it is recommended to use
    Fluent API.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnModelCreating`方法中，我们可以看到实体类及其关系已经以Fluent API风格配置。如果您更喜欢使用数据注释，可以在运行`dbcontext
    scaffold`命令时使用`--data-annotations`选项。但正如我们在[*第五章*](B18971_05.xhtml#_idTextAnchor198)中提到的，Fluent
    API比数据注释更强大，建议使用Fluent API。
- en: EF Core is smart enough to detect the relationships between the entity classes
    if your database schema follows the conventions. However, if this is not the case,
    you may get unexpected results. Please review the generated code carefully to
    make sure the relationships are configured correctly.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core足够智能，可以检测实体类之间的关系，如果您的数据库模式遵循约定。然而，如果这不是这种情况，您可能会得到意外的结果。请仔细检查生成的代码，以确保关系配置正确。
- en: Keep in mind that the generated code is just a starting point. Some models or
    properties may not be represented correctly in the database. For example, if your
    models have inheritance, the generated code will not include the base class because
    the base class is not represented in the database. Also, some column types may
    not be able to be mapped to the corresponding CLR types. For example, the `Status`
    column in the `Invoice` table is of the `nvarchar(16)` type, which will be mapped
    to the `string` type in the generated code, instead of the `Status` enum type.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，生成的代码只是一个起点。一些模型或属性可能无法在数据库中正确表示。例如，如果您的模型具有继承，生成的代码将不会包括基类，因为基类在数据库中没有表示。此外，某些列类型可能无法映射到相应的CLR类型。例如，`Invoice`表中的`Status`列是`nvarchar(16)`类型，在生成的代码中将映射到`string`类型，而不是`Status`枚举类型。
- en: You can update the generated code to suit your needs, but be aware that the
    next time you run the `dbcontext scaffold` command, the changes will be overwritten.
    You can use partial classes to add your own code to the generated classes, as
    the generated classes are declared as `partial`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更新生成的代码以满足您的需求，但请注意，下次您运行`dbcontext scaffold`命令时，更改将被覆盖。您可以使用部分类向生成的类中添加自己的代码，因为生成的类被声明为`partial`。
- en: In this section, we discussed how to use EF Core to reverse engineer the entity
    classes and `DbContext` from an existing database schema. It should be noted that
    EF Core strongly prefers the code-first approach. Unless you are working with
    an existing database, it is recommended to use the code-first approach to take
    advantage of the EF Core migrations feature.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何使用EF Core从现有的数据库模式反向工程实体类和`DbContext`。需要注意的是，EF Core强烈偏好代码优先的方法。除非您正在处理现有的数据库，否则建议使用代码优先的方法以利用EF
    Core迁移功能。
- en: Other ORM frameworks
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他ORM框架
- en: 'In addition to EF Core, there are numerous other ORM frameworks available for
    .NET. Some of the most popular include the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 EF Core 之外，还有许多其他 ORM 框架可用于 .NET。其中一些最受欢迎的包括以下：
- en: '**Dapper** ([https://dapperlib.github.io/Dapper/](https://dapperlib.github.io/Dapper/)):
    Dapper is a micro-ORM framework that is designed to be fast and lightweight. Dapper
    does not support change tracking, but it is easy to use, and it is very fast.
    As the official documentation says, “*Dapper’s simplicity means that many features
    that ORMs ship with are stripped out. It worries about the 95% scenario and gives
    you the tools you need most of the time. It doesn’t attempt to solve every problem.*”
    The performance is one of the most important features of Dapper. Maybe it is not
    fair to compare Dapper’s performance with EF Core, because EF Core provides many
    more features than Dapper. If you are looking for a simple ORM framework that
    is fast and easy to use, Dapper is a good choice. In some projects, Dapper is
    used with EF Core to provide the best of both worlds. Dapper is open-source and
    originally developed by Stack Overflow.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dapper** ([https://dapperlib.github.io/Dapper/](https://dapperlib.github.io/Dapper/)):
    Dapper 是一个设计为快速和轻量级的微型 ORM 框架。Dapper 不支持变更跟踪，但它易于使用，并且非常快速。正如官方文档所说，“*Dapper 的简单性意味着许多
    ORM 框架自带的功能都被移除了。它关注 95% 的场景，并为你提供大多数情况下需要的工具。它不试图解决每个问题。*”性能是 Dapper 最重要的特性之一。也许将
    Dapper 的性能与 EF Core 进行比较并不公平，因为 EF Core 提供了比 Dapper 更多的功能。如果你正在寻找一个简单、快速且易于使用的
    ORM 框架，Dapper 是一个好的选择。在某些项目中，Dapper 与 EF Core 结合使用，以提供两者的最佳结合。Dapper 是开源的，最初由
    Stack Overflow 开发。'
- en: '**NHibernate** ([https://nhibernate.info/](https://nhibernate.info/)): Like
    NUnit, NHibernate is a .NET implementation of the Hibernate ORM framework in Java.
    It is a mature, open-source ORM framework that has been around for a long time.
    It is very powerful and flexible. NHibernate is maintained by a community of developers.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NHibernate** ([https://nhibernate.info/](https://nhibernate.info/)): 与 NUnit
    类似，NHibernate 是 Java 中 Hibernate ORM 框架的 .NET 实现。它是一个成熟、开源的 ORM 框架，已经存在很长时间了。它非常强大且灵活。NHibernate
    由一群开发者维护。'
- en: '**PetaPoco** ([https://github.com/CollaboratingPlatypus/PetaPoco](https://github.com/CollaboratingPlatypus/PetaPoco)):
    PetaPoco is a tiny, fast, easy-to-use micro-ORM framework, which only had 1,000+
    lines of code in the original version. PetaPoco has a similar performance to Dapper
    because it uses dynamic method generation (MSIL) to assign column values to properties.
    PetaPoco now supports SQL Server, SQL Server CE, MS Access, SQLite, MySQL, MariaDB,
    PostgreSQL, Firebird DB, and Oracle. It uses T4 templates to generate the code.
    PetaPoco is open-source and currently maintained by a few core developers.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PetaPoco** ([https://github.com/CollaboratingPlatypus/PetaPoco](https://github.com/CollaboratingPlatypus/PetaPoco)):
    PetaPoco 是一个小巧、快速、易于使用的微型 ORM 框架，原始版本中只有 1,000+ 行代码。PetaPoco 通过使用动态方法生成（MSIL）将列值分配给属性，其性能与
    Dapper 相似。PetaPoco 现在支持 SQL Server、SQL Server CE、MS Access、SQLite、MySQL、MariaDB、PostgreSQL、Firebird
    DB 和 Oracle。它使用 T4 模板生成代码。PetaPoco 是开源的，目前由几位核心开发者维护。'
- en: It is hard to say which one is the best. It depends on your needs. Dapper is
    known for its speed and performance, while EF Core is more feature-rich and provides
    better support for complex queries and relationships. When deciding which framework
    to use for a particular task, consider the performance implications of each approach,
    and also the trade-offs between the features and flexibility of the framework.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 很难说哪一个是最好的。这取决于你的需求。Dapper 以其速度和性能而闻名，而 EF Core 则功能更丰富，提供了对复杂查询和关系的更好支持。在决定为特定任务使用哪个框架时，考虑每种方法的性能影响，以及框架功能和灵活性之间的权衡。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into some advanced topics of Entity Framework. We
    started by exploring how to improve the performance of our application by using
    `DbContext` pooling and no-tracking queries. We then learned how to execute raw
    SQL queries safely and efficiently using parameterized queries, and how to leverage
    the new bulk operations feature in EF Core for faster data manipulation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Entity Framework 的一些高级主题。我们首先探讨了如何通过使用 `DbContext` 缓存和无跟踪查询来提高我们应用程序的性能。然后我们学习了如何使用参数化查询安全有效地执行原始
    SQL 查询，以及如何利用 EF Core 中的新批量操作功能来加快数据操作。
- en: Next, we looked at how to handle concurrency scenarios using optimistic concurrency
    control, which allows multiple users to access and modify the same data simultaneously
    without conflicts. We also covered reverse engineering, a technique for generating
    entity classes and `DbContext` classes from an existing database schema, which
    can save time and effort in creating a data access layer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了如何使用乐观并发控制来处理并发场景，这允许多个用户同时访问和修改相同的数据而不发生冲突。我们还介绍了逆向工程，这是一种从现有数据库模式生成实体类和`DbContext`类的技术，这可以在创建数据访问层时节省时间和精力。
- en: To broaden our horizons beyond EF Core, we briefly introduced some other popular
    ORM frameworks, such as Dapper, NHibernate, and PetaPoco, and discussed their
    strengths and weaknesses. By the end of this chapter, you should have a solid
    understanding of how to leverage EF Core in a web API project to efficiently access
    and manipulate data, as well as some insights into other ORM options available
    to you.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拓宽我们的视野，除了EF Core之外，我们还简要介绍了其他一些流行的ORM框架，例如Dapper、NHibernate和PetaPoco，并讨论了它们的优缺点。到本章结束时，你应该对如何在Web
    API项目中利用EF Core高效地访问和操作数据有一个稳固的理解，以及对你可用的其他ORM选项的一些见解。
- en: However, EF Core is a very large topic, and we cannot cover everything in this
    book. For more information about EF Core, please refer to the official documentation
    at [https://learn.microsoft.com/en-us/ef/](https://learn.microsoft.com/en-us/ef/).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，EF Core是一个非常广泛的话题，我们无法在这本书中涵盖所有内容。有关EF Core的更多信息，请参阅官方文档[https://learn.microsoft.com/en-us/ef/](https://learn.microsoft.com/en-us/ef/)。
- en: In the next chapter, we will learn how to secure our web API project using authentication
    and authorization.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用身份验证和授权来确保我们的Web API项目安全。
