- en: Evaluating Performance Problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估性能问题
- en: Performance evaluation for most software products is a very scientific process.
    First, we determine the maximum/minimum supported performance metrics, such as
    the allowed memory usage, acceptable CPU consumption, and the number of concurrent
    users. Next, we perform load testing against the application in scenarios with
    a version of the application built for the target platform, and test it while
    gathering instrumentation data. Once this data is collected, we analyze and search
    it for performance bottlenecks. If problems are discovered, we complete a **Root
    Cause Analysis** (**RCA**), and then make changes in the configuration or application
    code to fix the issue and repeat it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数软件产品来说，性能评估是一个非常科学的过程。首先，我们确定最大/最小支持的性能指标，例如允许的内存使用量、可接受的CPU消耗量和并发用户数。接下来，我们在针对目标平台构建的应用程序版本上进行负载测试，同时收集仪表数据。一旦收集到这些数据，我们就分析和搜索以寻找性能瓶颈。如果发现问题，我们完成**根本原因分析**（**RCA**），然后更改配置或应用程序代码以修复问题并重复测试。
- en: Although game development is a very artistic process, it is still exceptionally
    technical. Our game should have a target audience in mind, which can tell us what
    hardware limitations our game might be operating under and, perhaps, tell us exactly
    what performance targets we need to meet (particularly in the case of console
    and mobile games). We can perform runtime testing on our application, gather performance
    data from multiple subsystems (CPU, GPU memory, the physics engine, the Rendering
    Pipeline, and so on), and compare them against what we consider to be acceptable.
    We can then use this data to identify bottlenecks in our application, perform
    additional instrumentation measurements, and determine the root cause of the issue.
    Finally, depending on the type of problem, we should be capable of applying a
    number of solutions to improve our application's performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然游戏开发是一个非常艺术的过程，但它仍然非常技术性。我们的游戏应该有一个目标受众，这可以告诉我们游戏可能运行在哪些硬件限制下，也许还能告诉我们确切需要达到的性能目标（尤其是在控制台和移动游戏的情况下）。我们可以在应用程序上执行运行时测试，从多个子系统（CPU、GPU内存、物理引擎、渲染管线等）收集性能数据，并将它们与我们认为可接受的数据进行比较。然后我们可以使用这些数据来识别应用程序中的瓶颈，进行额外的仪表测量，并确定问题的根本原因。最后，根据问题的类型，我们应该能够应用多种解决方案来提高应用程序的性能。
- en: However, before we spend even a single moment making performance fixes, we will
    first need to prove that a performance problem exists. It is unwise to spend time
    rewriting and refactoring code until there is a good reason to do so since pre-optimization
    is rarely worth the hassle. Once we have proof of a performance issue, the next
    task is figuring out exactly where the bottleneck is located. It is important
    to ensure that we understand why the performance issue is happening; otherwise,
    we could waste even more time applying fixes that are little more than educated
    guesses. Doing so often means that we only fix a symptom of the issue, not its
    root cause, and so we risk it manifesting itself in other ways in the future,
    or in ways we haven't yet detected.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们花费哪怕一秒钟时间进行性能优化之前，我们首先需要证明确实存在性能问题。在没有充分理由的情况下花费时间重写和重构代码是不明智的，因为预先优化很少值得麻烦。一旦我们有性能问题的证据，接下来的任务就是找出瓶颈的确切位置。确保我们理解性能问题发生的原因非常重要；否则，我们可能会浪费更多时间应用那些只是基于猜测的修复。这样做通常意味着我们只解决了问题的症状，而不是其根本原因，因此我们冒着它在未来以其他方式或我们尚未检测到的方式表现出来的风险。
- en: 'In this chapter, we will explore the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: How to gather profiling data using the Unity Profiler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Unity Profiler收集性能分析数据
- en: How to analyze Profiler data for performance bottlenecks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何分析Profiler数据以确定性能瓶颈
- en: Techniques to isolate a performance problem and determine its root cause
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离性能问题和确定其根本原因的技术
- en: With a thorough understanding of the problems you're likely to face, you will
    then be ready for the information presented in the remaining chapters, where you
    will learn what solutions are available for the types of issue we detect.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对你可能会遇到的问题有深入的理解后，你将准备好阅读剩余章节中提供的信息，在那里你将学习到针对我们检测到的问题类型有哪些解决方案可用。
- en: Gathering profiling data using the Unity Profiler
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity Profiler收集性能分析数据
- en: 'The Unity Profiler is built into the Unity Editor itself and provides an expedient
    way of narrowing down our search for performance bottlenecks by generating usage
    and statistics reports on a multitude of Unity3D subsystems during runtime. The
    different subsystems for which it can gather data are listed as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Profiler集成在Unity编辑器本身中，提供了一种便捷的方法，在运行时通过生成关于众多Unity3D子系统的使用和统计报告来缩小我们寻找性能瓶颈的范围。它可以收集数据的不同子系统如下：
- en: CPU consumption (per-major subsystem)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU消耗（每个主要子系统）
- en: Basic and detailed rendering and GPU information
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本和详细的渲染和GPU信息
- en: Runtime memory allocations and overall consumption
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时内存分配和总体消耗
- en: Audio source/data usage
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频源/数据使用
- en: Physics engine (2D and 3D) usage
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引擎（2D和3D）使用
- en: Network messaging and operation usage
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络消息和操作使用
- en: Video playback usage
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频播放使用
- en: Basic and detailed user interface performance
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本和详细的用户界面性能
- en: '**Global Illumination** (**GI**) statistics'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局照明**（**GI**）统计'
- en: 'There are generally two approaches to making use of a profiling tool: **instrumentation** and
    **benchmarking** (although, admittedly, the two terms are often used interchangeably).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种方法来利用性能分析工具：**仪表化**和**基准测试**（尽管，诚然，这两个术语经常被互换使用）。
- en: '**Instrumentation** typically means taking a close look into the inner workings
    of the application by observing the behavior of targeted function calls, where/how
    much memory is being allocated, and, generally getting an accurate picture of
    what is happening with the hope of finding the root cause of a problem. However,
    this is normally not an efficient way of starting to identify performance problems
    because profiling of any application comes with a performance cost of its own.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**仪表化**通常意味着通过观察目标函数调用的行为、内存分配的多少以及/或者在哪里分配，来仔细研究应用程序的内部工作原理，从而获得一个准确的情况，希望找到问题的根本原因。然而，这通常不是开始识别性能问题的有效方法，因为任何应用程序的性能分析都会带来其自身的性能成本。'
- en: 'When a Unity application is compiled in Development Mode (determined by the
    Development Build flag in the Build Settings menu), additional compiler flags
    are enabled causing the application to generate special events at runtime, which
    get logged and stored by the Profiler. Naturally, this will cause additional CPU
    and memory overhead at runtime due to all of the extra workload the application
    takes on. Even worse, if the application is being profiled through the Unity Editor,
    then even more CPU and memory use will be incurred, ensuring that the Editor updates
    its interface, renders additional windows (such as the Scene window), and handles
    background tasks. This profiling cost is not always negligible. In excessively
    large projects, it can sometimes cause all kinds of inconsistent and unexpected
    behavior when the Profiler is enabled: Unity can go out of memory, some scripts
    may refuse to run, physics may stop being updated (the time used for a frame may
    be so large that the physics engine reaches the maximum allowed updates per frame),
    and more. This is a necessary price we pay for a deep analysis of our code''s
    behavior at runtime, and we should always be aware of its implications. Therefore,
    before we get ahead of ourselves and start analyzing every line of code in our
    application, it would be wiser to do some **benchmarking.**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unity应用程序以开发模式编译时（由构建设置菜单中的开发构建标志确定），将启用额外的编译器标志，导致应用程序在运行时生成特殊事件，这些事件会被Profiler记录并存储。自然地，这将在运行时由于应用程序承担的所有额外工作负载而造成额外的CPU和内存开销。更糟糕的是，如果应用程序通过Unity编辑器进行性能分析，那么还会产生更多的CPU和内存使用，确保编辑器更新其界面，渲染额外的窗口（例如场景窗口），并处理后台任务。这种性能分析的成本并不总是可以忽略不计的。在过度庞大的项目中，有时在启用Profiler时可能会引起各种不一致和意外的行为：Unity可能会耗尽内存，一些脚本可能拒绝运行，物理引擎可能停止更新（一帧所用的时间可能如此之大，以至于物理引擎达到了每帧允许的最大更新次数），等等。这是我们为了深入分析代码在运行时的行为而必须付出的必要代价，我们应该始终意识到其影响。因此，在我们开始分析应用程序中的每一行代码之前，做一些**基准测试**会更明智。
- en: '**Benchmarking** involves performing a surface-level measurement of the application.
    We should gather some rudimentary data and perform test scenarios during a runtime
    session of our game while it runs on the target hardware; the test case could
    simply be, for example, a few seconds of gameplay, playback of a cutscene, or
    a partial playthrough of a level. The idea of this activity is to get a general
    feel for what the user might experience and keep watching for moments when performance
    becomes noticeably worse. Such problems may be severe enough to warrant further
    analysis.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**基准测试**涉及对应用程序进行表面级别的测量。我们应该在游戏在目标硬件上运行时的运行时会话中收集一些基本数据并执行测试场景；测试用例可以是，例如，几秒钟的游戏玩法，播放一段场景，或者一个级别的部分游玩。这个活动的目的是了解用户可能会经历什么，并持续关注性能明显变差的时刻。这些问题可能严重到需要进一步分析。'
- en: 'The important metrics we''re interested in when we carry out a benchmarking
    process are often the number of **frames per-second** (**FPS**) being rendered,
    overall memory consumption, how CPU activity behaves (looking for large spikes
    in activity), and sometimes CPU/GPU temperature. These are all relatively simple
    metrics to collect and can be used as a go-to first approach to performance analysis
    for one important reason: it will save us an enormous amount of time in the long
    run. It ensures that we only spend our time investigating problems that users
    would notice.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行基准测试过程中，我们感兴趣的指标通常是每秒渲染的帧数（**FPS**），整体内存消耗，CPU活动如何（寻找活动的大峰值），有时还有CPU/GPU温度。这些都是相对简单的指标，可以用作性能分析的第一步，原因之一是：从长远来看，这将为我们节省大量的时间。它确保我们只花时间调查用户会注意到的问题。
- en: We should dig deeper into instrumentation only after a benchmarking test indicates
    that further analysis is required. It is also very important to benchmark by simulating
    actual platform behavior as much as possible if we want a realistic data sample.
    As such, we should never accept benchmarking data that was generated through Editor
    mode as being representative of real gameplay, since Editor mode comes with some
    additional overhead costs that might mislead us, or hide potential race conditions
    in a real application. Instead, we should hook the profiling tool into the application
    while it is running in a standalone format on the target hardware.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在基准测试表明需要进一步分析之后，才深入进行仪器测试。如果我们想得到一个真实的数据样本，那么尽可能模拟实际平台行为进行基准测试也非常重要。因此，我们绝不应该接受通过编辑器模式生成的基准测试数据，因为编辑器模式附带一些额外的开销成本，可能会误导我们，或者隐藏真实应用程序中可能存在的潜在竞争条件。相反，我们应该在应用程序在目标硬件上以独立格式运行时将其分析工具连接到应用程序。
- en: Many Unity developers are surprised to find that the Editor sometimes calculates
    the results of operations much faster than a standalone application does. This
    is particularly common when dealing with serialized data such as audio files,
    Prefabs, and scriptable objects. This is because the Editor will cache previously
    imported data and is able to access it much faster than a real application would.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Unity开发者惊讶地发现，编辑器有时计算操作结果的速度比独立应用程序快得多。这在与序列化数据（如音频文件、预制件和可脚本对象）打交道时尤其常见。这是因为编辑器会缓存之前导入的数据，并且能够比真实应用程序更快地访问它。
- en: Now, let's cover how to access the Unity Profiler and connect it to the target
    device so that we can start to make accurate benchmarking tests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈如何访问Unity分析器并将其连接到目标设备，这样我们就可以开始进行准确的基准测试。
- en: Users who are already familiar with connecting the Unity Profiler to their applications
    can skip to the section entitled *The Profiler window*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 已经熟悉将Unity分析器连接到其应用程序的用户可以跳转到名为“分析器窗口”的部分。
- en: Launching the Profiler
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动分析器
- en: 'We will begin with a brief tutorial on how to connect our game to the Unity
    Profiler within a variety of contexts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始一个简短的教程，介绍如何在各种环境中将我们的游戏连接到Unity分析器：
- en: Local instances of the application, either through the Editor or a standalone
    instance
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编辑器或独立实例的应用程序本地实例
- en: Local instances of a WebGL application running in a browser
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中运行的WebGL应用程序的本地实例
- en: Remote instances of the application on an iOS device (for example, iPhone or
    iPad)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS设备上的应用程序远程实例（例如，iPhone或iPad）
- en: Remote instances of the application on an Android device (for example, an Android
    tablet or phone)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android设备上的应用程序远程实例（例如，Android平板电脑或手机）
- en: Profiling the Editor itself
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析编辑器本身
- en: We will briefly cover the requirements for setting up the Profiler in each of
    these contexts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍在每个上下文中设置分析器的要求。
- en: Editor or standalone instances
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器或独立实例
- en: In this instance, the only way to access the Profiler is to launch it through
    the Unity Editor and connect it to a running instance of our application. We will
    use the same Profiler windows irrespective of whether we execute our game in Playmode
    within the Editor, running a standalone application on the local or remote device,
    or wish to profile the Editor itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实例中，访问分析器唯一的方法是通过 Unity 编辑器启动它，并将其连接到正在运行的应用程序实例。无论我们在编辑器中执行游戏（在 Playmode
    下），在本地或远程设备上运行独立应用程序，还是希望分析编辑器本身，我们都会使用相同的分析器窗口。
- en: 'To open Profiler, navigate to Window | Analysis | Profiler within the Editor
    or use *Ctrl *+ *7* (or *cmd* + *7* on macOS):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开分析器，在编辑器中导航到窗口 | 分析 | 分析器，或使用 *Ctrl* + *7*（或在 macOS 上为 *cmd* + *7*）：
- en: '![](img/b1530dce-4911-423e-914d-10a6f3dd19c5.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1530dce-4911-423e-914d-10a6f3dd19c5.png)'
- en: If the Editor is already running in Playmode, then we should see profiling data
    continuously populating the Profiler window.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编辑器已经在 Playmode 下运行，那么我们应该会看到分析数据持续填充分析器窗口。
- en: To profile standalone projects, ensure that the Development Build and Autoconnect
    Profiler flags are enabled when the application is built.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析独立项目，确保在构建应用程序时启用开发构建和分析器自动连接标志。
- en: 'Choosing whether to profile an Editor-based instance (through the Editor''s
    Playmode) or a standalone instance (built and running separately from the Editor)
    can be achieved through the **Connected Player** option in the Profiler window:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析器窗口中的**连接玩家**选项选择是否分析基于编辑器的实例（通过编辑器的 Playmode）或独立实例（从编辑器外部分别构建和运行）：
- en: '![](img/e7529962-08ce-4474-85ed-d192f8e7178f.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7529962-08ce-4474-85ed-d192f8e7178f.png)'
- en: Note that switching back to the Unity Editor while profiling a separate standalone
    project will halt all data collection since the application will not be updated
    while it is in the background.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在分析单独的独立项目时切换回 Unity 编辑器将停止所有数据收集，因为应用程序在后台时不会更新。
- en: Connecting to a WebGL instance
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 WebGL 实例
- en: The Profiler can also be connected to an instance of the Unity WebGL Player.
    This can be achieved by ensuring that the Development Build and Autoconnect Profiler flags
    are enabled when the WebGL application is built and run from the Editor. The application
    will then be launched through the operating system's default browser. This enables
    us to profile our web-based application in a more real-world scenario through
    the target browser and test multiple browser types for inconsistencies in behavior
    (although this requires us to keep changing the default browser).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器还可以连接到 Unity WebGL Player 的实例。这可以通过确保在从编辑器构建和运行 WebGL 应用程序时启用开发构建和分析器自动连接标志来实现。然后，应用程序将通过操作系统的默认浏览器启动。这使我们能够通过目标浏览器在更真实的环境中分析我们的基于
    Web 的应用程序，并测试多种浏览器类型的行为一致性（尽管这要求我们不断更改默认浏览器）。
- en: Unfortunately, the Profiler connection can only be established when the application
    is first launched from the Editor. It currently cannot be connected to a standalone
    WebGL instance already running in a browser. This limits the accuracy of benchmarking
    WebGL applications since there will be some Editor-based overhead, but it's the
    only option we have available for the moment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，分析器连接只能在应用程序首次从编辑器启动时建立。目前无法连接到已在浏览器中运行的独立 WebGL 实例。这限制了 WebGL 应用程序的基准测试准确性，因为会有一些基于编辑器的开销，但这是我们目前唯一可用的选项。
- en: Remote connection to an iOS device
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程连接到 iOS 设备
- en: The Profiler can also be connected to an active instance of an application running
    remotely on an iOS device, such as an iPad or iPhone. This can be achieved through
    a shared Wi-Fi connection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器还可以连接到在远程 iOS 设备上运行的活动的应用程序实例，例如 iPad 或 iPhone。这可以通过共享 Wi-Fi 连接来实现。
- en: Note that remote connection to an iOS device is only possible when Unity (and
    hence the Profiler) is running on an Apple Mac device.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有当 Unity（以及分析器）在 Apple Mac 设备上运行时，才能远程连接到 iOS 设备。
- en: 'Observe the following steps to connect the Profiler to an iOS device:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下步骤以将分析器连接到 iOS 设备：
- en: Ensure that the Development Build and Autoconnect Profiler flags are enabled
    when the application is built
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在构建应用程序时启用开发构建和分析器自动连接标志。
- en: Connect both the iOS device and macOS device to a local Wi-Fi network, or to
    an ad hoc Wi-Fi network
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将iOS设备和macOS设备连接到本地Wi-Fi网络，或连接到ad hoc Wi-Fi网络
- en: Attach the iOS device to the macOS via the USB or Lightning Cable
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过USB或Lightning线将iOS设备连接到macOS
- en: Begin building the application with the Build & Run option as usual
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规使用Build & Run选项开始构建应用程序
- en: Open the Profiler window in the Unity Editor and select the device under Connected
    Player
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中打开Profiler窗口，并选择“已连接玩家”下的设备
- en: You should now see the iOS device's profiling data gathering in the Profiler
    window.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能在Profiler窗口中看到iOS设备的性能数据收集情况。
- en: The Profiler uses ports `54998` to `55511` to broadcast profiling data. Ensure
    that these ports are available for outbound traffic if there is a firewall on
    the network.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Profiler使用端口`54998`到`55511`来广播性能数据。如果网络上有防火墙，请确保这些端口可用于出站流量。
- en: To troubleshoot problems with building iOS applications and connecting the Profiler
    to them, consult the following documentation page: [https://docs.unity3d.com/Manual/TroubleShootingIPhone.html](https://docs.unity3d.com/Manual/TroubleShootingIPhone.html).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决构建iOS应用程序和将Profiler连接到它们的问题，请参考以下文档页面：[https://docs.unity3d.com/Manual/TroubleShootingIPhone.html](https://docs.unity3d.com/Manual/TroubleShootingIPhone.html)。
- en: Remote connection to an Android device
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程连接到Android设备
- en: 'There are two different methods for connecting an Android device to the Unity
    Profiler: either through a Wi-Fi connection or by using the **Android Debug Bridge**
    (**ADB**) tool. Either of these approaches will work from an Apple macOS, or a
    Windows PC.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将Android设备连接到Unity Profiler有两种不同的方法：通过Wi-Fi连接或使用**Android调试桥接器**（**ADB**）工具。这两种方法都可以在Apple
    macOS或Windows PC上使用。
- en: 'Perform the following steps to connect an Android device over a Wi-Fi connection:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以通过Wi-Fi连接连接Android设备：
- en: Ensure that the Development Build and Autoconnect Profiler flags are enabled
    when the application is built
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在构建应用程序时启用了开发构建和自动连接Profiler标志
- en: Connect both the Android and desktop devices to a local Wi-Fi network
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Android设备和桌面设备连接到本地Wi-Fi网络
- en: Attach the Android device to the desktop device via a USB cable
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过USB线将Android设备连接到桌面设备
- en: Begin building the application with the Build & Run option as usual
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规使用Build & Run选项开始构建应用程序
- en: Open the Profiler window in the Unity Editor and select the device under Connected
    Player
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中打开Profiler窗口，并选择“已连接玩家”下的设备
- en: The application should then be built and pushed to the Android device through
    the USB connection, and the Profiler should connect through the Wi-Fi connection.
    You should then see the Android device's profiling data gathering in the Profiler
    window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该通过USB连接构建并推送到Android设备，Profiler应通过Wi-Fi连接。然后你应该能在Profiler窗口中看到Android设备的性能数据收集情况。
- en: 'The second option is to use ADB. This is a suite of debugging tools that comes
    bundled with the Android **Software Development Kit** (**SDK**). For ADB profiling,
    perform the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用ADB。ADB是一套与Android**软件开发工具包**（**SDK**）捆绑的调试工具。对于ADB性能分析，请执行以下步骤：
- en: Ensure that the Android SDK is installed by following Unity's guide for Android
    SDK/NDK setup: [https://docs.unity3d.com/Manual/android-sdksetup.html](https://docs.unity3d.com/Manual/android-sdksetup.html)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过遵循Unity的Android SDK/NDK设置指南来确保已安装Android SDK：[https://docs.unity3d.com/Manual/android-sdksetup.html](https://docs.unity3d.com/Manual/android-sdksetup.html)
- en: Connect the Android device to your desktop machine via the USB cable
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过USB线将Android设备连接到您的桌面计算机
- en: Ensure that the Development Build and Autoconnect Profiler flags are enabled
    when the application is built
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在构建应用程序时启用了开发构建和自动连接Profiler标志
- en: Begin building the application with the Build & Run option as usual
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规使用Build & Run选项开始构建应用程序
- en: Open the Profiler window in the Unity Editor and select the device under Connected
    Player
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中打开Profiler窗口，并选择“已连接玩家”下的设备
- en: You should now see the Android device's profiling data gathering in the Profiler
    window.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能在Profiler窗口中看到Android设备的性能数据收集情况。
- en: To troubleshoot problems with building Android applications and connecting the
    Profiler to them, consult the following documentation page: [https://docs.unity3d.com/Manual/TroubleShootingAndroid.html](https://docs.unity3d.com/Manual/TroubleShootingAndroid.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决构建Android应用程序和将Profiler连接到它们的问题，请参考以下文档页面：[https://docs.unity3d.com/Manual/TroubleShootingAndroid.html](https://docs.unity3d.com/Manual/TroubleShootingAndroid.html)。
- en: Editor profiling
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器性能分析
- en: 'We can profile the Editor itself. This is normally used when trying to profile
    the performance of custom editor scripts. This can be achieved by enabling the
    Profile Editor option in the Profiler window and configuring the Connected Player
    option to Editor, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分析 Editor 本身。这通常用于尝试分析自定义编辑器脚本的性能。这可以通过在性能分析器窗口中启用“分析 Editor”选项，并将“已连接玩家”选项配置为
    Editor 来实现，如以下屏幕截图所示：
- en: '![](img/53496738-08bf-402c-a280-93be2f816519.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53496738-08bf-402c-a280-93be2f816519.png)'
- en: Note that both options must be configured if we want to profile the Editor: if
    nothing happens in the graph, then it is possible you have not selected the Profile
    Editor button, or you may accidentally be connected to another game build!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想分析 Editor，则必须配置这两个选项：如果图表中没有发生任何操作，那么可能你没有选择“分析 Editor”按钮，或者你可能意外地连接到了另一个游戏构建版本！
- en: The Profiler window
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析器窗口
- en: We will now cover the essential features of the Profiler as they can be found
    within the interface.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍性能分析器在界面中的基本功能。
- en: 'The Profiler window is split into four main sections:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器窗口分为四个主要部分：
- en: '**Profiler Controls**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能分析器控制**'
- en: '**Timeline View**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间轴视图**'
- en: '**Breakdown View Controls**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解视图控制**'
- en: '**Breakdown View**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解视图**'
- en: 'These sections are shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分在以下屏幕截图中显示：
- en: '![](img/eb1c0875-e544-4354-b637-6defaad06c16.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb1c0875-e544-4354-b637-6defaad06c16.png)'
- en: We'll now cover each of these sections in detail.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将详细介绍这些部分。
- en: 'Timeline View has a lot of colors, but not everyone sees colors in the same
    way. Luckily, if you are colorblind, Unity has thought of you! In the top-right
    hamburger menu, you can enable Color Blind Mode:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴视图有很多颜色，但并不是每个人都以相同的方式看到颜色。幸运的是，如果你是色盲，Unity 已经为你考虑到了！在右上角的汉堡菜单中，你可以启用色盲模式：
- en: '![](img/66f6144d-0dfd-4b8c-889a-df58c9552b2d.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66f6144d-0dfd-4b8c-889a-df58c9552b2d.png)'
- en: Profiler controls
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析器控制
- en: The top bar in the previous screenshot contains multiple drop-down and toggle
    buttons we can use to affect what is being profiled and how deeply in the subsystem
    that data is gathered from. These are covered in the next subsections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图中的顶部栏包含多个下拉和切换按钮，我们可以使用这些按钮来影响正在分析的内容以及从子系统收集数据的深度。这些内容将在下一节中介绍。
- en: Add Profiler
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加性能分析器
- en: By default, the Profiler will collect data for several different subsystems
    that cover the majority of the Unity engine's subsystems in Timeline View. These
    subsystems are organized into various areas containing relevant data. The Add
    Profiler option can be used to add additional areas or restore them if they have
    been removed. Refer to the Timeline View section for a complete list of subsystems
    we can profile.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，性能分析器将收集多个不同子系统的数据，这些子系统在时间轴视图中涵盖了 Unity 引擎的大多数子系统。这些子系统被组织成包含相关数据的各个区域。可以使用“添加性能分析器”选项添加额外的区域或恢复已删除的区域。请参阅时间轴视图部分，以获取我们可以分析的完整子系统列表。
- en: Playmode
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Playmode
- en: The Playmode drop-down lets us select the target instance of Unity we want to
    profile. This can be the current Editor application, a local standalone instance
    of our application, or an instance of our application running on a remote device.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Playmode 下拉菜单允许我们选择要分析的目标 Unity 实例。这可以是当前的 Editor 应用程序、我们应用程序的本地独立实例，或者运行在远程设备上的我们应用程序的实例。
- en: Record
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: Enabling the Record option (the record icon) makes the Profiler record profiling
    data. This will happen continuously while this option is enabled. Note that runtime
    data can only be recorded if the application is actively running. For an app running
    in the Editor, this means that Playmode must be enabled and it should not be paused;
    alternatively, for a standalone app, it must be the active window. If Profile
    Editor is enabled, then the data that appears will be collected for the Editor
    itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 启用“记录”选项（记录图标）会使性能分析器记录分析数据。在启用此选项时，这将持续发生。请注意，只有当应用程序正在积极运行时，才能记录运行时数据。对于在
    Editor 中运行的应用程序，这意味着 Playmode 必须启用，并且它不应该暂停；或者，对于独立应用程序，它必须是活动窗口。如果启用了“分析 Editor”，则显示的数据将是针对
    Editor 本身收集的。
- en: Deep Profile
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度分析
- en: Ordinary profiling will only record the time and memory allocations made by
    common Unity callback methods, such as `Awake()`, `Start()`, `Update()`, and `FixedUpdate()`.
    Enabling the Deep Profile option recompiles our scripts with a much deeper level
    of instrumentation, allowing it to measure each and every invoked method. This
    causes a significantly greater instrumentation cost during runtime than normal,
    and uses substantially more memory since data is being collected for the entire
    callstack at runtime. As a consequence, deep profiling may not even be possible
    in large projects, as Unity may run out of memory before testing even begins,
    or the application may run so slowly as to make the test pointless.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 普通分析将仅记录由常见的Unity回调方法（如`Awake()`、`Start()`、`Update()`、`FixedUpdate()`）做出的时间和内存分配。启用深度分析选项会以更深的级别对脚本进行重新编译，使其能够测量每个被调用的方法。这导致在运行时产生显著更大的分析成本，并且由于在运行时收集整个调用栈的数据，因此使用大量内存。因此，深度分析可能甚至在大项目中都不可能进行，因为Unity可能在测试开始之前就耗尽内存，或者应用程序运行得如此缓慢，以至于测试变得毫无意义。
- en: Note that toggling Deep Profile requires the entire project to be completely
    recompiled before profiling can begin again, so it is best to avoid toggling the
    option back and forth between tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，切换深度分析需要整个项目完全重新编译后才能再次开始分析，因此最好避免在测试之间来回切换选项。
- en: Since this option blindly measures the entire callstack, it would be unwise
    to keep it enabled during most of our profiling tests. This option is best reserved
    for when default profiling does not provide sufficient detail to figure out the
    root cause, or if we're testing the performance of a small test scene, which we're
    using to isolate certain activities.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此选项盲目地测量整个调用栈，因此在大多数性能测试期间保持它启用是不明智的。此选项最好保留在默认分析不足以确定根本原因时，或者当我们测试小型测试场景的性能时，我们使用它来隔离某些活动。
- en: If deep profiling is required for larger projects and scenes, but the Deep Profile
    option is too much of a hindrance during runtime, then there are alternative approaches
    that can be used to perform more detailed profiling; see the upcoming section
    entitled *Targeted profiling of code segments*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要为大型项目和场景进行深度分析，但深度分析选项在运行时过于阻碍，那么可以使用其他方法来执行更详细的分析；请参阅即将到来的标题为“代码段针对性分析”的部分。
- en: Allocation Callstack
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配调用栈
- en: 'By activating the Allocation Callstack option, Unity Profiler will collect
    more info about the game''s memory allocations without requiring Deep Profile:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过激活分配调用栈选项，Unity Profiler将收集有关游戏内存分配的更多信息，而无需深度分析：
- en: '![](img/501b0f1a-c916-4fd5-9122-f885a8edcf1d.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/501b0f1a-c916-4fd5-9122-f885a8edcf1d.png)'
- en: 'If the option is enabled, you can click on the red boxes representing memory
    allocations and Profiler will show you the origin and the cause of that memory
    allocation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选项已启用，你可以点击代表内存分配的红框，Profiler将显示该内存分配的来源和原因：
- en: '![](img/e335a8b7-6a99-45be-ada0-4839996ffc9d.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e335a8b7-6a99-45be-ada0-4839996ffc9d.png)'
- en: In Hierarchy view, instead, you still need to select an allocation call. Then,
    you need to switch to Show Related Objects in the drop-down menu in the upper-right
    corner and then select one of the N/A objects. After that, you'll see Callstack
    info in the box underneath.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构视图中，相反，你仍然需要选择一个分配调用。然后，你需要切换到右上角的下拉菜单中的“显示相关对象”，然后选择一个N/A对象。之后，你将在下面的框中看到调用栈信息。
- en: We will talk more about memory allocations in [Chapter 8](eb7d9924-d92d-4cfa-ae68-ddd0f77a15a0.xhtml), *Masterful
    Memory Management*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](eb7d9924-d92d-4cfa-ae68-ddd0f77a15a0.xhtml)“精湛的内存管理”中更多地讨论内存分配。
- en: At the time of writing, in Unity 2019.1, Allocation Callstack works only when
    profiling in the Editor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，在Unity 2019.1中，分配调用栈仅在编辑器中进行性能分析时才工作。
- en: Clear
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除
- en: The Clear button clears all profiling data from Timeline View.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清除按钮将清除时间轴视图中的所有性能数据。
- en: Load
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载
- en: The Load icon button will open up a dialog window to load in any previously
    saved profiling data (by using the Save option).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Load图标按钮将打开一个对话框窗口，以加载之前保存的性能数据（使用保存选项）。
- en: Save
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存
- en: The Save icon button saves any Profiler data currently presented in Timeline
    View to a file. Only 300 frames of data can be saved in this fashion at a time,
    and a new file must be manually created for any more data. This is typically sufficient
    for most situations, since, when a performance spike occurs, we then have about
    five to ten seconds to pause the application and save the data for future analysis
    (such as attaching it to a bug report) before it gets pushed off the left-hand
    side of Timeline View. Any saved Profiler data can be loaded into the Profiler
    for future examination using the Load option.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 保存图标按钮将时间轴视图中当前显示的任何分析器数据保存到文件中。一次只能以这种方式保存300帧数据，并且必须手动创建新文件以保存更多数据。这通常对大多数情况来说足够了，因为当性能出现峰值时，我们就有大约五到十秒的时间暂停应用程序并保存数据以供将来分析（例如将其附加到错误报告）之前，它被推离时间轴视图的左侧。任何保存的分析器数据都可以通过加载选项加载到分析器中进行未来的检查。
- en: Frame Selection
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧选择
- en: The frame selection area is composed of several sub-elements. The Frame Counter
    shows how many frames have been profiled and which frame is currently selected
    in Timeline View. There are two buttons to move the currently selected frame forward
    or backward by one frame and a third button (the Current button) that resets the
    selected frame to the most recent frame and keeps that position. This will cause
    Breakdown View to always show profiling data for the current frame during runtime
    profiling; it will display the word Current.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 帧选择区域由几个子元素组成。帧计数器显示已分析了多少帧以及时间轴视图中当前选中的帧。有两个按钮可以向前或向后移动当前选中的帧一个帧，还有一个第三按钮（当前按钮），它将选中的帧重置为最新帧并保持该位置。这将导致分解视图在运行时分析期间始终显示当前帧的配置文件数据；它将显示“当前”一词。
- en: Timeline View
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间轴视图
- en: Timeline View reveals during runtime,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴视图在运行时显示，
- en: A graphical representation of profiling data on the right
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的配置文件数据的图形表示
- en: 'A series of checkboxes (the colored squares in the following screenshot) to
    enable/disable different activities/data types on the left:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列复选框（以下截图中的彩色方块）用于在左侧启用/禁用不同的活动/数据类型：
- en: '![](img/3d14efc5-d723-440e-a9b2-b6fed6dddede.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d14efc5-d723-440e-a9b2-b6fed6dddede.png)'
- en: These colored boxes can be toggled, which changes the visibility of the corresponding
    data types within the graphical section of Timeline View.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些彩色框可以切换，这会改变在时间轴视图图形部分中相应数据类型的可见性。
- en: When an area is selected in Timeline View, more detailed information for that
    subsystem will be revealed in Breakdown View (beneath Timeline View) for the currently
    selected frame. The kind of information displayed in Breakdown View varies depending
    on which area is currently selected in Timeline View.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当在时间轴视图中选择一个区域时，该子系统更详细的信息将在分解视图（位于时间轴视图下方）中显示，针对当前选中的帧。分解视图中显示的信息类型取决于时间轴视图中当前选中的区域。
- en: Areas can be removed from Timeline View by clicking on the X in the top-right
    corner of an area. If you want to show an area that you removed again, you can
    use the Add Profiler option in the Controls bar.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过单击区域右上角的X从时间轴视图中删除区域。如果您想再次显示已删除的区域，可以使用控制栏中的添加分析器选项。
- en: At any time, we can click a location in the graphical part of Timeline View
    to reveal information about a given frame. A large vertical white bar will appear
    (usually with some additional information on either side coinciding with the line
    graphs), showing us which frame is selected.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，我们都可以单击时间轴视图图形部分中的位置，以显示有关给定帧的信息。将出现一个大的垂直白色栏（通常在两侧有一些附加信息与线图相对应），显示我们已选择了哪个帧。
- en: Depending on which area is currently selected (determined by which area is currently
    highlighted in blue), different information will be available in Breakdown View,
    and different options will be available in Breakdown View Controls. Changing the
    area that is selected is as simple as clicking on the relevant box on the left-hand
    side of Timeline View or on the graphical side; however, clicking inside the graphical
    area might also change which frame has been selected, so be careful clicking in
    the graphical area if you wish to see Breakdown View information for the same
    frame.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前选中的区域（由当前突出显示为蓝色的区域确定），在分解视图中将提供不同的信息，在分解视图控制中也将提供不同的选项。更改选定的区域很简单，只需单击时间轴视图左侧或图形侧的相关框即可；然而，在图形区域内单击可能会更改选中的帧，所以如果您想查看同一帧的分解视图信息，请小心在图形区域内单击。
- en: Breakdown View Controls
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分视图控件
- en: Different dropdowns and toggle button options will appear within Breakdown View
    Controls, depending on which area is currently selected in Timeline View. Different
    areas offer different controls, and these options dictate what information is
    available, and how that information is presented in Breakdown View.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在时间线视图中当前选定的区域，拆分视图控件中会出现不同的下拉菜单和切换按钮选项。不同的区域提供不同的控件，这些选项决定了在拆分视图中可用的信息，以及如何呈现这些信息。
- en: Breakdown View
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分视图
- en: The information revealed in Breakdown View will vary enormously based on which
    area is currently selected and which Breakdown View Controls options are selected.
    For instance, some areas offer different modes in a dropdown within Breakdown
    View Controls, which can provide Simple or Detailed views of the information or
    even a graphical layout of the same information so that it can be parsed more
    easily.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分视图揭示的信息将根据当前选定的区域和选定的拆分视图控件选项而有很大差异。例如，一些区域在拆分视图控件中的下拉菜单中提供不同的模式，这可以提供信息的简单或详细视图，甚至可以提供相同信息的图形布局，以便更容易解析。
- en: Now, let's cover each area and the different kinds of information and options
    available in Breakdown View.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分别介绍每个区域以及拆分视图中可用的不同类型的信息和选项。
- en: The CPU Usage area
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU 使用区域
- en: This area shows data for all CPU Usage and statistics. It is perhaps the most
    complex and useful since it covers a large number of Unity subsystems, such as
    `MonoBehaviour` components, cameras, some rendering and physics processes, the
    user interface (including the Editor's interface, if we're running through the
    Editor), audio processing, the Profiler itself, and more.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此区域显示所有 CPU 使用和统计信息。它可能是最复杂和最有用的，因为它涵盖了大量的 Unity 子系统，例如 `MonoBehaviour` 组件、相机、一些渲染和物理过程、用户界面（包括如果我们在通过编辑器运行时编辑器的界面）、音频处理、Profiler
    本身，等等。
- en: 'There are three different modes for displaying CPU Usage data in Breakdown
    View:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在拆分视图中显示 CPU 使用数据有三种不同的模式：
- en: Hierarchy mode
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次模式
- en: Raw Hierarchy mode
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始层次模式
- en: Timeline mode
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间线模式
- en: 'Let''s take a look at each of these modes individually:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些模式：
- en: Hierarchy mode reveals most callstack invocations, while grouping similar data
    elements and global Unity function calls together for convenience. For instance,
    rendering delimiters, such as `BeginGUI()` and `EndGUI()` calls, are combined
    together in this mode. Hierarchy mode is helpful as an initial first step for
    determining which function calls take the most CPU time to execute.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次模式揭示了大多数调用栈调用，同时将相似的数据元素和全局 Unity 函数调用分组在一起以便于使用。例如，渲染分隔符，如 `BeginGUI()` 和
    `EndGUI()` 调用，在此模式中会合并在一起。层次模式有助于作为确定哪些函数调用执行所需 CPU 时间最多的初始第一步。
- en: Raw Hierarchy mode is similar to Hierarchy mode, except it will separate global
    Unity function calls into separate entries rather than their being combined into
    one bulk entry. This will tend to make Breakdown View more difficult to read,
    but may be helpful if we're trying to count how many times a particular global
    method is invoked, or for determining whether one of these calls is costing more
    CPU/memory than anticipated. For example, each `BeginGUI()` and `EndGUI()` call
    will be separated into different entries, making it clearer how many times each
    is being called compared to the Hierarchy mode.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始层次模式与层次模式类似，但它将全局 Unity 函数调用分离成单独的条目，而不是将它们合并成一个整体条目。这可能会使拆分视图更难以阅读，但如果我们试图计算特定全局方法被调用的次数，或者确定这些调用中是否有任何调用比预期的消耗更多的
    CPU/内存，这可能是有帮助的。例如，每个 `BeginGUI()` 和 `EndGUI()` 调用都会被分离成不同的条目，使得与层次模式相比，每个调用被调用的次数更清晰。
- en: Perhaps the most useful mode for the CPU Usage area is the Timeline mode option
    (not to be confused with the main Timeline View). This mode organizes CPU Usage
    during the current frame in line with how the callstack expanded and contracted
    during processing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CPU 使用区域来说，最有用的模式可能是时间线模式选项（不要与主时间线视图混淆）。此模式将当前帧中的 CPU 使用情况与处理过程中调用栈的展开和收缩相一致地组织。
- en: Timeline mode organizes Breakdown View vertically into different sections that
    represent different threads at runtime, such as Main Thread, Render Thread, and
    various background job threads called the Unity Job System, used for loading activities
    such as scenes and other assets. The horizontal axis represents time, so wider
    blocks are consuming more CPU time than narrower blocks. The horizontal size also
    represents relative time, making it easy to compare how much time one function
    call took compared to another. The vertical axis represents the callstack, so
    deeper chains represent more calls in the callstack at that time.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间轴模式将分解视图垂直组织成不同的部分，这些部分代表运行时不同的线程，例如主线程、渲染线程以及称为 Unity 作业系统的各种后台作业线程，用于加载场景和其他资产等活动。水平轴代表时间，因此较宽的块比较窄的块消耗了更多的
    CPU 时间。水平尺寸也代表相对时间，这使得比较一个函数调用与另一个函数调用所花费的时间变得容易。垂直轴代表调用栈，因此较深的链表示在那时调用栈中的调用更多。
- en: Under Timeline mode, blocks at the top of Breakdown View are functions (or,
    technically, callbacks) called by the Unity Engine at runtime (such as `Start()`,
    `Awake()`, or `Update()` ), whereas blocks beneath them are functions that those
    functions had called into, which can include functions on other components or
    regular C# objects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间轴模式下，分解视图顶部的块是 Unity 引擎在运行时调用的函数（或者技术上，回调函数），例如 `Start()`、`Awake()` 或 `Update()`，而它们下面的块是这些函数调用的函数，这可能包括其他组件上的函数或常规
    C# 对象。
- en: The Timeline mode offers a very clean and organized way to determine which particular
    method in the callstack consumes the most time and how that processing time measures
    up against other methods being called during the same frame. This allows us to
    gauge the method that is the biggest cause of performance problems with minimal
    effort.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴模式提供了一种非常干净和有序的方式来确定调用栈中哪个特定的方法消耗了最多时间，以及该处理时间与其他在同一帧中调用的方法相比如何。这使得我们可以以最小的努力评估造成性能问题的最大原因的方法。
- en: 'For example, let''s assume that we are looking at a performance problem in
    the following screenshot. We can tell, with a quick glance, that there are three
    methods that are causing a problem, and they each consume similar amounts of processing
    time, due to their similar widths:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在查看以下截图中的性能问题。我们可以快速地看出，有三个方法导致了问题，并且由于它们的宽度相似，它们各自消耗了相似的处理时间：
- en: '![](img/23efdf47-d188-4d77-95dc-00c75d64bb89.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23efdf47-d188-4d77-95dc-00c75d64bb89.png)'
- en: In the previous screenshot, we have exceeded our 16.667 ms budget with calls
    to three different `MonoBehaviour` components. The good news is that we have three
    possible methods through which we can find performance improvements, which means
    lots of opportunities to find code that can be improved. The bad news is that
    increasing the performance of one method will only improve about one-third of
    the total processing for that frame. Hence, all three methods may need to be examined
    and optimized in order get back under budget.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个截图中，我们通过调用三个不同的 `MonoBehaviour` 组件超出了我们的 16.667 毫秒预算。好消息是我们有三种可能的方法可以通过它们来找到性能改进，这意味着有很多机会找到可以改进的代码。坏消息是提高一个方法的速度只会改善该帧总处理时间的约三分之一。因此，可能需要检查和优化所有三个方法，才能回到预算之下。
- en: It's a good idea to collapse the Unity Job System list when using Timeline mode,
    as it tends to obstruct the visibility of items shown in the Main Thread block,
    which is probably what we're most interested in.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用时间轴模式时，折叠 Unity 作业系统列表是个好主意，因为它往往会阻碍对主线程块中显示的项目可见性，而这可能是我们最感兴趣的。
- en: In general, the CPU Usage area will be most useful for detecting issues that
    can be solved by solutions that will be explored in Chapter 2, *Scripting Strategies*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，CPU 使用区域将最有用，用于检测可以通过第 2 章中探讨的解决方案解决的问题。
- en: The GPU Usage area
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU 使用区域
- en: The GPU Usage area is similar to the CPU Usage area, except that it shows method
    calls and processing time as it occurs on the GPU. Relevant Unity method calls
    in this area will relate to cameras, drawing, opaque and transparent geometry,
    lighting and shadows, and so on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 使用区域类似于 CPU 使用区域，但它显示了在 GPU 上发生的函数调用和处理时间。此区域中的相关 Unity 函数调用将涉及相机、绘图、不透明和透明几何体、光照和阴影等。
- en: The GPU Usage area offers hierarchical information similar to the CPU Usage
    area and estimates the time spent calling into various rendering functions such
    as `Camera.Render()` (provided rendering actually occurs during the frame currently
    selected in Timeline View).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: GPU使用区域提供了类似于CPU使用区域分层的信息，并估计调用各种渲染函数（如`Camera.Render()`）所花费的时间（前提是在时间轴视图中当前选中的帧中确实发生了渲染）。
- en: The GPU Usage area will be a useful tool to refer to when you go through Chapter
    6, *Dynamic Graphics*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读第6章“动态图形”时，GPU使用区域将是一个有用的参考工具。
- en: The Rendering area
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染区域
- en: The Rendering area provides some generic rendering statistics that tend to focus
    on activities related to preparing the GPU for rendering, which involves a set
    of activities that occur on the CPU (as opposed to the act of rendering, which
    is an activity handled within the GPU and is detailed in the GPU Usage area).
    Breakdown View offers useful information, such as the number of SetPass calls
    (otherwise known as draw calls), the total number of batches used to render the
    scene, the number of batches saved from dynamic batching and static batching and
    how they are being generated, and memory consumed for textures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染区域提供了一些通用的渲染统计信息，这些信息往往关注与为渲染准备GPU相关的活动，这涉及在CPU上发生的一系列活动（与在GPU内处理的渲染活动相对，渲染活动在GPU使用区域中详细说明）。拆分视图提供了有用的信息，例如SetPass调用次数（也称为绘制调用），渲染场景使用的批次数总和，从动态批处理和静态批处理中保存的批次数以及它们的生成方式，以及纹理消耗的内存。
- en: The Rendering area also offers a button to open Frame Debugger, which will be
    explored more in Chapter 3, *The Benefits of Batching*. The remainder of this
    area's information will prove useful when you go through Chapter 3, *The Benefits
    of Batching*, and Chapter 6, *Dynamic Graphics*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染区域还提供了一个按钮来打开帧调试器，这将在第3章“批处理的好处”中进一步探讨。本区域剩余的信息将在你阅读第3章“批处理的好处”和第6章“动态图形”时变得非常有用。
- en: The Memory area
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存区域
- en: 'The Memory area allows us to inspect the memory usage of the application in
    Breakdown View in the following two modes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 内存区域允许我们在拆分视图中以以下两种模式检查应用程序的内存使用情况：
- en: Simple mode
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单模式
- en: Detailed mode
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细模式
- en: Simple mode provides only a high-level overview of the memory consumption of
    subsystems. This include Unity's low-level Engine, the Mono framework (total heap
    size that is being watched by the garbage collector), graphical assets, audio
    assets and buffers, and even memory used to store data collected by the Profiler.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 简单模式仅提供子系统内存消耗的高级概述。这包括Unity的低级引擎、Mono框架（垃圾收集器监视的总堆大小）、图形资产、音频资产和缓冲区，甚至用于存储Profiler收集的数据的内存。
- en: Detailed mode shows memory consumption of individual GameObjects and MonoBehaviours for
    both their native and managed representations. It also has a column explaining
    the reason why an object may be consuming memory and when it might be deallocated.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 详细模式显示单个GameObject和MonoBehaviours的内存消耗，包括它们的原生和托管表示。它还有一个列解释了为什么一个对象可能会消耗内存以及它何时可能会被释放。
- en: The garbage collector is a common feature provided by C#—the Unity's scripting
    language of choice—that automatically releases any memory we have allocated to
    store data; but, if it is handled poorly, it has the potential to stall our application
    for brief moments. This topic, and many more related topics, such as native and
    managed memory spaces, will be explored in Chapter 8, *Masterful Memory Management*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器是C#（Unity首选脚本语言）提供的一个常见功能，它会自动释放我们为存储数据而分配的任何内存；但如果处理不当，它可能会使我们的应用程序在短时间内停滞。这个主题以及许多相关主题，例如原生和托管内存空间，将在第8章“精通内存管理”中探讨。
- en: 'Note that information only appears in Detailed mode through manual sampling
    by clicking on the Take Sample <TargetName> button. This is the only way to gather
    information when using Detailed mode, since performing this kind of analysis automatically
    for each update would be prohibitively expensive:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，信息仅在详细模式下通过手动采样（点击“获取样本 <目标名称>”按钮）出现。这是在详细模式下收集信息的唯一方法，因为为每次更新自动执行此类分析将过于昂贵：
- en: '![](img/03671341-5f59-4a15-83b8-2ecce6434164.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03671341-5f59-4a15-83b8-2ecce6434164.png)'
- en: Breakdown View also provides a button labelled Gather Object References, which
    can gather more in-depth memory information pertaining to some objects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分视图还提供了一个标签为“收集对象引用”的按钮，可以收集有关某些对象的更深入内存信息。
- en: The Memory area will be a useful tool to use when we dive into the complexities
    of memory management, native versus managed memory, and the garbage collector
    in Chapter 8, *Masterful Memory Management*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 内存区域将在我们深入研究内存管理、本地与托管内存以及第8章*精湛的内存管理*中的垃圾收集器复杂性时成为一个有用的工具。
- en: The Audio area
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频区域
- en: The Audio area grants an overview of audio statistics and can be used both to
    measure CPU Usage from the audio system and total memory consumed by audio sources
    (both for those that are playing or paused) and audio clips.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 音频区域提供了音频统计概览，并且可以用来测量音频系统中的CPU使用情况以及音频源（包括播放或暂停的）和音频剪辑消耗的总内存。
- en: Breakdown View provides lots of useful insights into how the audio system is
    operating and how various audio channels and groups are being used.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分视图提供了许多关于音频系统如何运行以及各种音频通道和组如何被使用的有用见解。
- en: The Audio area may come in handy as we explore art assets in Chapter 4, *Optimizing
    Your Art Assets*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第4章*优化您的艺术资产*中探索艺术资产时，音频区域可能会很有用。
- en: Audio is often overlooked when it comes to performance optimization, but audio
    can become a surprisingly large source of bottlenecks if it is not managed properly
    due to the potential amount of hard disk access and CPU processing required. Don't
    neglect it!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能优化方面，音频往往被忽视，但如果管理不当，由于所需的硬盘访问和CPU处理量，音频可能会成为出人意料的瓶颈来源。不要忽视它！
- en: The Physics 3D and Physics 2D areas
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D物理和2D物理区域
- en: There are two different physics areas, one for Physics 3D  (NVIDIA 's PhysX),
    and another for the Physics 2D system (**Box2D**). This area provides various
    physics statistics, such as Rigidbody, Collider, and Contact counts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个不同的物理区域，一个用于3D物理（NVIDIA的PhysX），另一个用于2D物理系统（**Box2D**）。这个区域提供了各种物理统计信息，例如刚体、碰撞体和接触计数。
- en: The Breakdown View for each physics area provides some rudimentary insight into
    the subsystem's inner workings, but we can gain further insight by exploring the
    physics debugger, which we will introduce in Chapter 5, *Faster Physics*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每个物理区域的拆分视图提供了对子系统内部工作的一些基本了解，但我们可以通过探索第5章*更快的物理*中将要介绍的物理调试器来获得更深入的见解。
- en: The network messages and network operations areas
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络消息和网络操作区域
- en: These two areas provide information about Unity's networking system, which was
    introduced during the Unity 5 release cycle. The information present will depend
    on whether the application is using the **High-Level API** (**HLAPI**) or **Transport
    Layer API** (**TLAPI**) provided by Unity. HLAPI is an easier-to-use system for
    managing player and `GameObject` network synchronization automatically, whereas
    TLAPI is a thin layer that operates just above the socket level, allowing Unity
    developers to conjure up their own networking system.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个区域提供了关于Unity网络系统信息，该系统是在Unity 5发布周期中引入的。现有信息将取决于应用程序是否使用Unity提供的**高级API**（**HLAPI**）或**传输层API**（**TLAPI**）。HLAPI是一个易于使用的系统，用于自动管理玩家和`GameObject`的网络同步，而TLAPI则是一个位于套接字之上的薄层，允许Unity开发者构建自己的网络系统。
- en: Optimizing network traffic is a subject that fills an entire book all by itself,
    where the right solution is typically very dependent on the particular needs of
    the application. This will not be a Unity-specific problem, and, as such, the
    topic of network traffic optimization will not be explored in this book.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 优化网络流量是一个单独占据整本书的主题，其中正确的解决方案通常非常依赖于应用程序的特定需求。这不会是一个Unity特定的问题，因此，网络流量优化的主题将不会在本书中进行探讨。
- en: The Video area
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频区域
- en: If our application happens to make use of Unity's VideoPlayer API, then we might
    find this area useful for profiling video playback behavior.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序恰好使用了Unity的VideoPlayer API，那么这个区域可能会对分析视频播放行为很有用。
- en: Optimization of media playback is also a complex, non-Unity-specific topic and
    will not be explored in this book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体播放的优化也是一个复杂且非Unity特定的主题，本书将不会对其进行探讨。
- en: The UI and UI Details areas
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI和UI详细信息区域
- en: These areas provide insight into applications making use of Unity's built-in
    user interface system. If we're using a custom-built or third-party user interface
    system (such as the popular Asset Store plugin **Next-Gen UI** (**NGUI**)), then
    these areas will probably provide little benefit.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区域提供了关于使用Unity内置用户界面系统的应用程序的见解。如果我们使用的是自定义构建或第三方用户界面系统（如流行的Asset Store插件**Next-Gen
    UI**（**NGUI**）），那么这些区域可能提供的好处很少。
- en: A poorly optimized user interface can often affect one or both of the CPU and
    GPU, so we will investigate some code optimization strategies for UIs in Chapter
    2, *Scripting Strategies*, and graphics-related approaches in Chapter 6, *Dynamic
    Graphics*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优化不良的用户界面可能会影响CPU和GPU中的一个或两个，因此我们将在第2章 *脚本策略* 中探讨UI的代码优化策略，并在第6章 *动态图形* 中探讨与图形相关的技术。
- en: The Global Illumination area
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局照明领域
- en: The Global Illumination area gives us a very detailed insight into Unity's GI system.
    If our application makes use of GI, then we should refer to this area to verify
    that it is performing properly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 全局照明领域为我们提供了对Unity的GI系统非常详细的洞察。如果我们的应用程序使用了GI，那么我们应该参考这个领域来验证它是否运行正常。
- en: This area may prove useful as we explore lighting and shadowing in Chapter 6,
    *Dynamic Graphics*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索第6章 *动态图形* 中的光照和阴影时，这个领域可能会证明是有用的。
- en: Best approaches to performance analysis
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析的最佳方法
- en: Good coding practices and project asset management often make finding the root
    cause of a performance issue relatively simple, at which point the only real problem
    is figuring out how to improve the code. For instance, if the method only processes
    a single gigantic `for` loop, then it will be a pretty safe assumption that the
    problem is either with how many iterations the loop is performing, whether or
    not the loop is causing cache misses by reading memory in a non-sequential fashion,
    how much work is done in each iteration, or how much work it takes to prepare
    for the next iteration.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的编码实践和项目资产管理通常使找到性能问题的根本原因相对简单，此时唯一真正的问题是弄清楚如何改进代码。例如，如果该方法只处理单个巨大的`for`循环，那么可以相当安全地假设问题可能是与循环执行的迭代次数有关，或者循环是否通过以非顺序方式读取内存而导致缓存未命中，每个迭代中完成的工作量，或者为下一次迭代做准备所需的工作量。
- en: Of course, whether we're working individually or in a group setting, a lot of
    our code is not always written in the cleanest way possible, and we should expect
    to have to profile some poor coding work from time to time. Sometimes, we are
    forced to implement a hacky solution for the sake of speed, and we don't always
    have the time to go back and refactor everything to keep up with our best coding
    practices. In fact, many code changes made in the name of performance optimization
    tend to appear very strange or arcane, often making our code base more difficult
    to read. The common goal of software development is to make code that is clean,
    feature-rich, and fast. Achieving one of these is relatively easy, but the reality
    is that achieving two will cost significantly more time and effort, while achieving
    all three is a near-impossibility.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，无论我们是单独工作还是在团队环境中，我们的大部分代码并不总是以最干净的方式编写，我们应该预期有时需要分析一些糟糕的编码工作。有时，为了速度，我们被迫实施一些蹩脚的解决方案，而且我们并不总是有时间回头重构一切以保持最佳编码实践。事实上，许多以性能优化为名的代码更改往往显得非常奇怪或晦涩，通常使我们的代码库更难以阅读。软件开发的一个共同目标是编写干净、功能丰富且快速的代码。实现其中之一相对容易，但现实是，实现两个将花费更多的时间和精力，而实现所有三个几乎是不可能的。
- en: At its most basic level, performance optimization is just another form of problem
    solving, and when we overlook the obvious while problem solving, it can be an
    expensive mistake. Our goal is to use benchmarking to observe our application
    looking for instances of problematic behavior, and to then use instrumentation
    to hunt through the code for clues about where the problem originates. Unfortunately,
    it's often very easy to get distracted by invalid data or jump to conclusions
    because we're being too impatient or have overlooked a subtle detail. Many of
    us have run into occasions during software debugging where we could have found
    the root cause of the problem much faster if we had simply challenged and verified
    our earlier assumptions. Hunting down performance issues is no different.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本层面上，性能优化只是另一种问题解决形式，当我们解决问题时忽略明显的问题，可能会犯下代价高昂的错误。我们的目标是使用基准测试来观察我们的应用程序，寻找问题行为的实例，然后使用仪器在代码中寻找关于问题起源的线索。不幸的是，由于我们过于急躁或忽略了细微的细节，很容易被无效数据分散注意力或得出结论。我们中的许多人都在软件调试过程中遇到过这样的情况，如果我们简单地挑战和验证早期的假设，我们就能更快地找到问题的根源。追查性能问题也是如此。
- en: 'A checklist of tasks would be helpful to keep us focused on the issue, and
    ensure we don''t waste time by trying to implement any possible optimization that
    has no effect on the main performance bottleneck. Of course, every project is
    different, with its own unique challenges to overcome, but the following checklist
    is general enough that it should be able to apply to any Unity project:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务清单将有助于我们专注于问题，并确保我们不会浪费时间尝试实现任何没有影响主要性能瓶颈的优化。当然，每个项目都是不同的，都有其独特的挑战需要克服，但以下清单足够通用，应该适用于任何Unity项目：
- en: Verify that the target script is present in the scene
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认目标脚本存在于场景中
- en: Verify that the script appears in the scene the correct number of times
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证脚本在场景中出现的次数是否正确
- en: Verify the correct order of events
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证事件顺序的正确性
- en: Minimize ongoing code changes
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化持续代码更改
- en: Minimize internal distractions
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化内部干扰
- en: Minimize external distractions
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化外部干扰
- en: Verifying script presence
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证脚本存在
- en: Sometimes, there are things we expect to see, but don't. These are usually easy
    to spot because the human brain is very good at pattern recognition and spotting
    differences we didn't expect. However, there are also times where we assume that
    something has been happening, but it didn't. These are generally more difficult
    to notice, because we're often scanning for the first kind of problem, and we’re
    assuming that the things we don't see are working as intended. In the context
    of Unity, one problem that manifests itself this way is verifying that the scripts
    we expect to be operating are actually present in the scene.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会期望看到某些东西，但并没有看到。这些通常很容易发现，因为人脑在模式识别和发现我们未预期的差异方面非常出色。然而，也有时候我们假设某些事情正在发生，但实际上并没有。这些通常更难注意到，因为我们经常在寻找第一种问题，并假设我们没有看到的东西是按预期工作的。在Unity的上下文中，一个问题就是验证我们期望运行的脚本实际上是否存在于场景中。
- en: 'Script presence can be quickly verified by typing the following into the Hierarchy
    window textbox:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在层次结构窗口文本框中输入以下内容来快速验证脚本的存在：
- en: '[PRE0]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example, typing `t:mytestmonobehaviour` (note that it is not case-sensitive)
    into the Hierarchy textbox will show a shortlist of all GameObjects that currently
    have at least one `MyTestMonoBehaviour` script attached as a component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将`t:mytestmonobehaviour`（注意它不区分大小写）输入到层次结构文本框中，将显示所有当前至少附加了一个`MyTestMonoBehaviour`脚本的GameObject的简短列表。
- en: Note that this shortlist feature also includes any GameObjects with components
    that derive from the given script name.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此简短列表功能还包括任何具有从给定脚本名称派生的组件的GameObject。
- en: We should also double check that the GameObjects they are attached to are still
    enabled, since we may have disabled them during earlier testing since someone
    or something may have accidentally deactivated the object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该再次检查它们附加到的GameObject是否仍然处于启用状态，因为我们可能在之前的测试中禁用了它们，可能是由于有人或某物意外地关闭了该对象。
- en: Verifying script count
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证脚本数量
- en: If we're looking at our Profiler data and note that a certain `MonoBehaviour`
    method is being executed more times than expected, or is taking longer than expected,
    we might want to double-check that it only occurs as many times in the scene as
    we expect it to. It's entirely feasible that someone created the object more times
    than expected in the scene file, or that we accidentally instantiated the object
    more than the expected number of times from code. If so, the problem could be
    due to conflicting or duplicated method invocations generating a performance bottleneck.
    We can verify the count using the same shortlist method used in the *Best approaches
    to performance analysis* section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在查看Profiler数据时注意到某个`MonoBehaviour`方法被执行的次数比预期多，或者执行时间比预期长，我们可能想要再次确认它在场景中出现的次数与我们预期的次数相符。完全有可能有人在场景文件中创建了比预期更多的对象，或者我们可能意外地从代码中实例化了比预期更多的对象。如果是这样，问题可能是由于冲突或重复的方法调用产生了性能瓶颈。我们可以使用与*最佳性能分析方法*部分中使用的相同的方法来验证数量。
- en: If we expected a specific number of components to appear in the scene, but the
    shortlist revealed more (or  fewer!) of these components, then it might be wise
    to write some initialization code that prevents this from ever happening again.
    We could also write some custom Editor helpers to display warnings to any level
    designers who might be making this mistake.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们期望场景中出现特定数量的组件，但简短列表显示出现了更多（或更少！）这些组件，那么编写一些初始化代码来防止这种情况再次发生可能是明智的。我们还可以编写一些自定义编辑器辅助工具，向可能犯这种错误的所有级别设计师显示警告。
- en: Preventing casual mistakes such as this is essential for good productivity,
    since experience tells us that, if we don't explicitly disallow something, then
    someone, somewhere, at some point, for whatever reason, will do it anyway. This
    is likely to cost us a frustrating afternoon hunting down a problem that eventually
    turned out to be caused by human error.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 防止此类偶然错误对于提高生产力至关重要，因为经验告诉我们，如果我们没有明确禁止某事，那么无论何时何地，出于何种原因，总有人会这样做。这很可能会让我们花费一个令人沮丧的下午去追踪一个最终证明是由人为错误引起的问题。
- en: Verifying the order of events
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证事件顺序
- en: Unity applications mostly operate as a series of callbacks from *Native code*
    to *Managed code*. This concept will be explained in more detail in Chapter 8,
    *Masterful Memory Management*, but for the sake of a brief summary, Unity's main
    thread doesn't operate as a simple console application would. In such applications,
    code would be executed with some obvious starting point (usually a `main()` function),
    and we would then have direct control of the game engine, where we initialize
    major subsystems, and then the game runs in a big `while` loop (often called the
    game loop) that checks for user input, updates the game, renders the current scene,
    and repeats. This loop only exits once the player chooses to quit the game.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Unity应用程序主要作为从*Native代码*到*Managed代码*的一系列回调操作。这一概念将在第8章*精通内存管理*中更详细地解释，但为了简要总结，Unity的主线程并不像简单的控制台应用程序那样运行。在这样的应用程序中，代码会从一个明显的起点（通常是`main()`函数）执行，然后我们会直接控制游戏引擎，初始化主要子系统，然后游戏在一个大的`while`循环（通常称为游戏循环）中运行，该循环检查用户输入，更新游戏，渲染当前场景，并重复。这个循环只有在玩家选择退出游戏时才会退出。
- en: Instead, Unity handles the game loop for us, and we expect callbacks such as `Awake()`,
    `Start()`, `Update()`, and `FixedUpdate()` to be called at specific moments. The
    big difference is that we don't have fine-grained control over the order in which
    events of the same type are called. When a new scene is loaded (whether it's the
    first scene of the game or a later scene), every `MonoBehaviour` component's `Awake()`
    callback gets called, but there's no way of predicting the order in which this
    will happen.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Unity为我们处理游戏循环，我们期望`Awake()`、`Start()`、`Update()`和`FixedUpdate()`等回调在特定时刻被调用。最大的不同之处在于，我们没有对同一类型事件调用的顺序进行精细控制。当加载新场景（无论是游戏的第一场景还是后来的场景）时，每个`MonoBehaviour`组件的`Awake()`回调都会被调用，但无法预测这一发生的顺序。
- en: So, if we take one set of objects that configure some data in their `Awake()`
    callback, and then another set of objects does something with that configured
    data in its own `Awake()` callback, some reorganization or recreation of scene
    objects or a random change in the code base or compilation process (it's unclear
    what exactly causes it) may cause the order of these `Awake()` calls to change,
    and then the dependent objects will probably try to do things with data that wasn't
    initialized how we expected. The same goes for all other callbacks provided by
    `MonoBehaviour` components, such as `Start()` and `Update()`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一组对象在它们的`Awake()`回调中配置一些数据，然后另一组对象在其自己的`Awake()`回调中使用这些配置数据，那么一些场景对象的重新组织或重建，或者代码库或编译过程中的随机变化（不清楚确切原因是什么）可能会改变这些`Awake()`调用的顺序，然后依赖的对象可能会尝试使用我们没有预期初始化的数据。对于`MonoBehaviour`组件提供的所有其他回调，例如`Start()`和`Update()`，也是如此。
- en: In any sufficiently complex project, there's no way of telling the order in
    which the same type of callback gets called among a group of `MonoBehaviour` components,
    so we should be very careful not to assume that object callbacks are happening
    in a specific order. In fact, it is essential practice to never write code in
    a way that assumes these callbacks will need to be called in a certain order because
    it could break at any time.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何足够复杂的项目中，都无法确定同一类型的回调在 `MonoBehaviour` 组件组中被调用的顺序，因此我们应该非常小心，不要假设对象回调会按照特定的顺序发生。实际上，永远不要编写假设这些回调需要按照特定顺序调用的代码是一种基本实践，因为这可能在任何时候导致崩溃。
- en: A better place to handle late-stage initialization is in a `MonoBehaviour` component's
    `Start()` callback, which is always called after every object's `Awake()` callback
    is called and just before its first `Update()` call. Late-stage updates can also
    be done in the `LateUpdate()` callback.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 处理后期初始化的更好地方是在 `MonoBehaviour` 组件的 `Start()` 回调中，这个回调总是在每个对象的 `Awake()` 回调之后调用，并在第一次
    `Update()` 调用之前。后期更新也可以在 `LateUpdate()` 回调中进行。
- en: If you're having trouble determining the actual order of events, then this is
    best handled by either step-through debugging with an IDE (MonoDevelop, Visual
    Studio, and so on) or by printing simple logging statements with `Debug.Log()`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以确定事件的实际顺序，那么这最好通过在 IDE（MonoDevelop、Visual Studio 等等）中进行逐步调试或通过使用 `Debug.Log()`
    打印简单的日志语句来处理。
- en: Be warned that Unity's logger is notoriously expensive. Logging is unlikely
    to change the order of the callbacks, but it can cause some unwanted spikes in
    performance if used too aggressively. Be smart and do targeted logging only on
    the most relevant parts of the code base.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Unity 的日志记录器臭名昭著地昂贵。日志记录不太可能改变回调的顺序，但如果使用过于激进，它可能会引起一些不希望的性能峰值。要聪明，只在代码库中最相关的部分进行有针对性的日志记录。
- en: Coroutines are typically used to script some sequence of events, and when they're
    triggered will depend on what `yield` types are being used. The most difficult
    and unpredictable type to debug is perhaps the `WaitForSeconds` yield type. The
    Unity Engine is non-deterministic, meaning that you'll get a slightly different
    behavior from one session to the next, even on the same hardware. For example,
    you might get 60 updates called during the first second of application runtime
    during one session, 59 in the next, and 62 in the one after that. In another session,
    you might get 61 updates in the first second, followed by 60, and then 59.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 协程通常用于编写一系列事件的脚本，它们何时被触发将取决于所使用的 `yield` 类型。可能最难调试且不可预测的类型是 `WaitForSeconds`
    yield 类型。Unity 引擎是非确定性的，这意味着在不同的会话中，即使是在相同的硬件上，你也会得到略有不同的行为。例如，在一个会话中，你可能会在应用运行的第一秒内调用
    60 次更新，在下一个会话中是 59 次，而在下一个会话中是 62 次。在另一个会话中，你可能会在第一秒内得到 61 次更新，然后是 60 次，接着是 59
    次。
- en: A variable number of `Update()` callbacks will be called between when the coroutine
    starts and when it ends, and so if the coroutine depends on the `Update()` function
    of something being called a specific number of times, we will run into problems.
    It's best to keep a coroutine's behavior dead simple and dependency-free of other
    behavior once it begins. Breaking this rule may be tempting, but it's essentially
    guaranteed that some future change is going to interact with the coroutine in
    an unexpected way, leading to a long, painful debugging session for a game-breaking
    bug that's very hard to reproduce.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程开始和结束之间，将调用不同数量的 `Update()` 回调，因此如果协程依赖于某个东西被调用特定次数的 `Update()` 函数，我们就会遇到问题。最好保持协程的行为简单且一旦开始就无需依赖其他行为。打破这条规则可能很有诱惑力，但基本上可以保证未来的某些更改将以意想不到的方式与协程交互，导致长时间、痛苦的调试会话，并引发一个难以重现的游戏破坏性错误。
- en: Minimizing ongoing code changes
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化持续代码更改
- en: Making code changes to the application in order to hunt down performance issues
    is best done carefully, as the changes are easy to forget as time wears on. Adding
    debug logging statements to our code can be tempting, but remember that it costs
    us time to introduce these calls, recompile our code, and remove these calls once
    our analysis is complete. In addition, if we forget to remove them, then they
    can incur unnecessary runtime overhead in the final build since Unity's debug
    Console window logging can be prohibitively expensive in terms of both CPU and
    memory.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追踪性能问题而更改应用程序的代码最好谨慎进行，因为随着时间的推移，这些更改很容易被忘记。向我们的代码中添加调试日志语句可能很有吸引力，但请记住，引入这些调用、重新编译我们的代码以及分析完成后移除这些调用都会花费我们时间。此外，如果我们忘记移除它们，那么它们可能会在最终构建中产生不必要的运行时开销，因为
    Unity 的调试控制台窗口日志在 CPU 和内存方面可能非常昂贵。
- en: A good way to combat this problem is to add a flag or comment anywhere we made
    a change with our name so that it's easy to find and remove it later. Hopefully,
    we're also wise enough to use a source control tool for our code base, making
    it easy to differentiate between the content of any modified files and revert
    them to their original state. This is an excellent way to ensure that unnecessary
    changes don't make it into the final version. Of course, this is by no means a
    guaranteed solution if we also applied a fix at the same time and didn't double-check
    all of our modified files before committing the change.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '解决这个问题的好方法是在我们进行更改的地方添加一个标志或注释，这样就可以轻松找到并在以后移除它。希望我们也很明智地使用源控制工具来管理我们的代码库，这样就可以轻松区分任何修改文件的更改内容，并将它们恢复到原始状态。这是确保不必要的更改不会进入最终版本的一个极好方法。当然，这绝对不是一种保证的解决方案，如果我们同时应用了一个修复程序，并且在提交更改之前没有仔细检查所有修改的文件。 '
- en: Making use of breakpoints during runtime debugging is the preferred approach,
    as we can trace the full callstack, variable data, and conditional code paths
    (for example, `if-else` blocks), without risking any code changes or wasting time
    on recompilation. Of course, this is not always an option if, for example, we're
    trying to figure out what causes something strange to happen in one out of a thousand
    frames. In this case, it's better to determine a threshold value to look for and
    add an `if` statement, with a breakpoint inside, which will be triggered when
    the value has exceeded the threshold.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时调试期间使用断点是首选方法，因为我们能够追踪完整的调用栈、变量数据和条件代码路径（例如，`if-else` 块），而不会冒任何代码更改的风险或浪费时间在重新编译上。当然，如果我们试图弄清楚在成千上万的帧中发生奇怪现象的原因，这通常不是一个选项。在这种情况下，最好确定一个阈值值来查找，并添加一个包含断点的
    `if` 语句，当值超过阈值时，该语句将被触发。
- en: Minimizing internal distractions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化内部干扰
- en: The Unity Editor has its own little quirks and nuances, which can sometimes
    make it confusing to debug some kinds of problems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 编辑器有其独特的怪癖和细微差别，这有时会使调试某些类型的问题变得令人困惑。
- en: Firstly, if a single frame takes a long time to process, such that our game
    noticeably freezes, then the Profiler may not be capable of picking up the results
    and recording them in the Profiler window. This can be especially annoying if
    we wish to catch data during application/scene initialization. The *Custom CPU
    profiling*, section later will offer some alternatives to explore with a view
    to solving this problem.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果单个帧处理时间过长，以至于我们的游戏明显冻结，那么分析器可能无法捕捉到结果并在分析器窗口中记录它们。如果我们希望在应用程序/场景初始化期间捕获数据，这可能会特别令人烦恼。稍后将在
    *自定义 CPU 分析* 部分提供一些替代方案，以探索解决此问题的方法。
- en: One common mistake (that I have admittedly fallen victim to multiple times during
    the writing of this book) is that if we are trying to initiate a test with a keystroke
    and have the Profiler window open, we should not forget to click back into the
    Editor's Game window before triggering the keystroke. If the Profiler is the most
    recently clicked window, then the Editor will send keystroke events to that, instead
    of the runtime application, and hence, no `GameObject` will catch the event for
    that keystroke. This can also apply to the GameView for rendering tasks and even
    coroutines using the `WaitForEndOfFrame` yield type. If the Game window is not
    visible and active in the Editor, then nothing is being rendered to that view,
    and therefore, no events that rely on Game window rendering will be triggered.
    Be warned!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误（我在撰写本书的过程中不幸多次成为受害者）是，如果我们试图通过按键来启动测试，并且已经打开了Profiler窗口，那么在触发按键之前，我们不应该忘记点击回到Editor的Game窗口。如果Profiler是最近点击的窗口，那么Editor将向该窗口发送按键事件，而不是运行中的应用程序，因此，没有任何`GameObject`会捕获该按键的事件。这也适用于GameView的渲染任务，甚至使用`WaitForEndOfFrame`yield类型的协程。如果Game窗口在Editor中不可见且未激活，那么该视图就不会有任何渲染，因此，依赖于Game窗口渲染的事件将不会被触发。请注意！
- en: Vertical sync (otherwise known as VSync) is used to match the application's
    frame rate to the frame rate of the device it is being displayed to; for example,
    a monitor may run at 60 Hertz (60 cycles per second, about 16 ms). If a rendering
    loop in our game is running faster than a monitor cycle – for instance, 10 ms
    – then the game will sit and wait for another 6 ms before outputting the rendered
    frame. This feature reduces screen tearing, which occurs when a new image is pushed
    to the monitor before the previous image was finished, and, for a brief moment,
    part of the new image overlaps the old image.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直同步（通常称为VSync）用于将应用程序的帧率与显示其的设备的帧率相匹配；例如，一个显示器可能以60赫兹（每秒60次循环，大约16毫秒）运行。如果我们的游戏中的渲染循环运行速度比显示器循环快——例如，10毫秒——那么游戏将等待另一个6毫秒，然后输出渲染的帧。这个功能减少了屏幕撕裂，屏幕撕裂发生在新图像在旧图像完成之前推送到显示器上，并且在新图像的短暂时刻，新图像的一部分与旧图像重叠。
- en: Executing the Profiler with VSync enabled will probably generate a lot of noisy
    spikes in the CPU Usage area under the WaitForTargetFPS heading, as the application
    intentionally slows itself down to match the frame rate of the display. These
    spikes often appear very large in Editor mode, since the Editor is typically rendering
    to a very small window, which doesn’t take a lot of CPU or GPU work to render.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用VSync启用Profiler可能会在`WaitForTargetFPS`标题下的CPU Usage区域产生大量的噪声峰值，因为应用程序有意减慢自身速度以匹配显示器的帧率。这些峰值在编辑器模式下通常看起来非常大，因为编辑器通常渲染到一个非常小的窗口，这不需要太多的CPU或GPU工作来渲染。
- en: This will generate unnecessary clutter, making it harder to spot the real issue(s).
    We should ensure that we disable the VSync checkbox under the CPU Usage area when
    we're on the lookout for CPU spikes during performance tests. We can disable the
    VSync feature entirely by navigating to Edit | Project Settings | Quality and
    then to the sub-page for the currently selected platform.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生不必要的杂乱，使得难以发现真正的问题。我们应该确保在性能测试期间寻找CPU峰值时，在CPU Usage区域禁用VSync复选框。我们可以通过导航到Edit
    | Project Settings | Quality然后转到当前选定平台的子页面来完全禁用VSync功能。
- en: We should also ensure that a drop in performance isn't a direct result of a
    massive number of exceptions and error messages appearing in the Editor Console
    window. Unity's `Debug.Log()` and similar methods, such as `Debug.LogError()` and
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该确保性能下降不是大量异常和错误消息直接出现在Editor控制台窗口的结果。Unity的`Debug.Log()`以及类似的`Debug.LogError()`和`Debug.LogWarning()`方法，在CPU使用率和堆内存消耗方面非常昂贵，这可能导致垃圾回收发生，从而造成更多的CPU周期损失（有关这些主题的更多信息，请参阅第8章，*精通内存管理*）。
- en: '`Debug.LogWarning()`, are notoriously expensive in terms of CPU Usage and heap
    memory consumption, which can then cause garbage collection to occur resulting
    in even more lost CPU cycles (refer to Chapter 8, *Masterful Memory Management*,
    for more information on these topics).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug.LogWarning()`，在CPU使用率和堆内存消耗方面非常昂贵，这可能导致垃圾回收发生，从而造成更多的CPU周期损失（有关这些主题的更多信息，请参阅第8章，*精通内存管理*）。'
- en: This overhead is usually unnoticeable to a human being looking at the project
    in Editor mode, where most errors come from the compiler or misconfigured objects.
    However, they can be problematic when used during any kind of runtime process,
    especially during profiling, where we wish to observe how the game runs in the
    absence of external disruptions. For example, if we are missing an object reference
    that we were supposed to assign through the Editor, and it is being used in an
    `Update()` callback, then a single `MonoBehaviour` instance could throw new exceptions
    every single update. This adds lots of unnecessary noise to our profiling data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开销对于在编辑器模式下查看项目的普通人来说通常是不可察觉的，因为大多数错误来自编译器或配置不当的对象。然而，在运行时过程中，尤其是在分析时，它们可能会成为问题，尤其是在我们希望在没有外部干扰的情况下观察游戏运行时。例如，如果我们遗漏了一个应该通过编辑器分配的对象引用，并且它在
    `Update()` 回调中使用，那么单个 `MonoBehaviour` 实例可能会在每次更新时抛出新的异常。这会给我们的分析数据添加很多不必要的噪音。
- en: 'Note that we can hide different log level types with the buttons shown in the
    next screenshot. The extra logging still costs CPU and memory to execute, even
    though they are not being rendered, but it does allow us to filter out the junk
    we don''t want. However, it is often good practice to keep all of these options
    enabled to verify that we''re not missing anything important:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过下一张截图中的按钮隐藏不同的日志级别类型。即使这些额外的日志没有被渲染，它们仍然需要 CPU 和内存来执行，但它们确实允许我们过滤掉我们不需要的垃圾信息。然而，通常来说，保持所有这些选项都启用是一个好的实践，以确保我们没有错过任何重要的事情：
- en: '![](img/dc862c86-4275-48b0-9ebc-e547a0490e38.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc862c86-4275-48b0-9ebc-e547a0490e38.png)'
- en: Minimizing external distractions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化外部干扰
- en: This one is simple, but absolutely necessary. We should double-check that there
    are no background processes eating away CPU cycles or consuming vast swathes of
    memory. Being low on available memory will generally interfere with our testing,
    as it can cause more cache misses, hard drive access for virtual memory page-file
    swapping, and generally slow responsiveness on the part of the application. If
    our application is suddenly behaving significantly worse than anticipated, double-check
    the system's task manager (or equivalent) for any CPU/memory/hard disk activity
    that might be causing problems.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很简单，但绝对必要。我们应该检查是否有后台进程正在消耗 CPU 周期或消耗大量内存。内存不足通常会影响我们的测试，因为它可能导致更多的缓存未命中，对虚拟内存页面交换文件的硬盘访问，以及应用程序响应速度的普遍减慢。如果我们的应用程序突然表现远低于预期，请检查系统的任务管理器（或等效工具）中是否有任何可能导致问题的
    CPU/内存/硬盘活动。
- en: Targeted profiling of code segments
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码段的目标分析
- en: If our performance problem isn't resolved by the checklist mentioned previously,
    then we probably have a real issue on our hands that demands further analysis.
    The Profiler window is effective at showing us a broad overview of performance;
    it can help us find specific frames to investigate and can quickly inform us which
    `MonoBehaviour` and/or method may be causing issues. We would then need to figure
    out whether the problem is reproducible, under what circumstances a performance
    bottleneck arises, and from where exactly within the problematic code block the
    issue is originating.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前提到的清单没有解决我们的性能问题，那么我们可能真的遇到了需要进一步分析的问题。Profiler 窗口能够有效地显示性能的总体概述；它可以帮助我们找到需要调查的具体帧，并可以快速告知我们哪个
    `MonoBehaviour` 和/或方法可能存在问题。然后我们需要确定问题是否可重现，在什么情况下性能瓶颈出现，以及问题确实是从有问题的代码块中的哪个部分开始的。
- en: 'To accomplish these, we will need to perform some profiling of targeted sections
    of our code, and there are a handful of useful techniques we can employ for this
    task. For Unity projects, they essentially fit into two categories:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这些，我们需要对我们代码的目标部分进行一些分析，并且有一些有用的技术我们可以用于这项任务。对于 Unity 项目，它们基本上可以分为两大类：
- en: Controlling the Profiler from script code
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从脚本代码控制 Profiler
- en: Custom timing and logging methods
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义计时和日志方法
- en: Note that the next section focuses on how to investigate scripting bottlenecks
    through C# code. Detecting the source of bottlenecks in other engine subsystems
    will be discussed in their related chapters.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，下一节将重点介绍如何通过 C# 代码来调查脚本瓶颈。其他引擎子系统的瓶颈来源将在相关章节中讨论。
- en: Profiler script control
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Profiler 脚本控制
- en: The Profiler can be controlled in script code through the `Profiler` class.
    There are several useful methods in this class that we can explore within the
    Unity documentation, but the most important methods are the delimiter methods
    that activate and deactivate profiling at runtime. These can be accessed through
    the `UnityEngine.Profiling.Profiler` class through its `BeginSample()` and `EndSample()` methods.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过脚本代码通过`Profiler`类来控制分析器。这个类中有几个有用的方法，我们可以在Unity文档中探索，但最重要的方法是激活和停用运行时分析的定界符方法。这些方法可以通过`UnityEngine.Profiling.Profiler`类通过其`BeginSample()`和`EndSample()`方法访问。
- en: Note that the delimiter methods, `BeginSample()` and `EndSample()`, are only
    compiled in development builds, and, as such, they will not be compiled or executed
    in release builds where Development Mode is unchecked. This is commonly known
    as **non-operation**, or **no-op**, code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，定界符方法`BeginSample()`和`EndSample()`仅在开发构建中编译，因此它们在未勾选开发模式的情况下不会编译或执行，这通常被称为**非操作**，或**no-op**代码。
- en: 'The `BeginSample()` method has an overload that allows a custom name for the
    sample to appear in the CPU Usage area''s Hierarchy mode. For example, the following
    code will profile invocations of this method and make the data appear in Breakdown
    View under a custom heading, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeginSample()`方法有一个重载，允许为样本指定一个自定义名称，使其在CPU使用区域的层次结构模式下显示。例如，以下代码将分析此方法的调用，并将数据显示在自定义标题下的分解视图中，如下所示：'
- en: '[PRE1]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the *Packt Publishing* books you have purchased. If you purchased this
    book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有*Packt Publishing*书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'We should expect that invoking this poorly designed method (which generates
    a `List` containing a million integers, and then does absolutely nothing with
    it) will cause a huge spike in CPU Usage, chew up several megabytes of memory,
    and appear in the Profiler Breakdown View under the My Profiler Sample heading, as
    shown in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该预期，调用这个设计不佳的方法（该方法生成一个包含一百万个整数的`List`，然后对其绝对不做任何处理）将导致CPU使用率激增，消耗数兆字节的内存，并在“我的分析器样本”标题下的分析器分解视图中出现，如下面的截图所示：
- en: '![](img/d8dc0c20-ec0f-44a7-80e9-21dd1dec1d94.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d8dc0c20-ec0f-44a7-80e9-21dd1dec1d94.png)'
- en: Custom CPU profiling
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义CPU分析
- en: The Profiler is just one tool at our disposal. Sometimes, we may want to perform
    customized profiling and logging of our code. Maybe we're not confident that the
    Unity Profiler is giving us the right answer, maybe we consider its overhead cost
    too great, or maybe we just like having complete control of every single aspect
    of our application. Whatever our motivations, knowing some techniques to perform
    an independent analysis of our code is a useful skill to have. It's unlikely we'll
    only be working with Unity for the entirety of our game development careers, after
    all.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器只是我们可用的工具之一。有时，我们可能想要对我们的代码进行自定义分析和记录。也许我们不确定Unity分析器是否给出了正确的答案，也许我们认为它的开销成本太大，或者也许我们只是喜欢对我们的应用程序的每个方面都拥有完全的控制。无论如何，了解一些进行独立代码分析的技术是有用的技能。毕竟，我们不太可能在整个游戏开发生涯中只使用Unity。
- en: Profiling tools are generally very complex, so it's unlikely we would be able
    to generate a comparable solution on our own within a reasonable time frame. When
    it comes to testing CPU Usage, all we should really need is an accurate timing
    system, a fast, low-cost way of logging that information, and some piece of code
    to test against. It just so happens that the .NET library (or, technically, the
    Mono framework) comes with a `Stopwatch` class under the `System.Diagnostics`
    namespace. We can stop and start a `Stopwatch` object at any time, and we can
    easily acquire a measure of how much time has passed since the `Stopwatch` object
    was started.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 分析工具通常非常复杂，所以我们不太可能在合理的时间内自己生成一个可比较的解决方案。当涉及到测试CPU使用率时，我们真正需要的只是一个精确的计时系统、一种快速、低成本的记录信息的方法，以及一些用于测试的代码。碰巧的是，.NET库（或者技术上讲，Mono框架）在`System.Diagnostics`命名空间下提供了一个`Stopwatch`类。我们可以在任何时候停止和启动`Stopwatch`对象，并且我们可以轻松地获取自`Stopwatch`对象启动以来经过的时间。
- en: Unfortunately, this class is not perfectly accurate; it is accurate only to
    milliseconds, or tenths of a millisecond, at best. Counting in a high-precision,
    real-time manner with a CPU clock can be a surprisingly difficult task when we
    start to get into it. So, in order to avoid a detailed discussion of the topic,
    we should try to find a way for the `Stopwatch` class to satisfy our needs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个类并不完全准确；它最多只能精确到毫秒，或者最多到十分之一毫秒。当开始深入研究时，使用CPU时钟以高精度、实时方式计数可以是一个令人惊讶的困难任务。因此，为了避免对这一主题进行详细讨论，我们应该尝试找到一种方法，让`Stopwatch`类满足我们的需求。
- en: If precision is important, then one effective way to increase it is by running
    the same test multiple times. Assuming that the test code block is both easily
    repeatable and not exceptionally long, we should be able to run thousands, or
    even millions, of tests within a reasonable time frame and then divide the total
    elapsed time by the number of tests we just performed to get a more accurate time
    for a single test.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果精度很重要，那么一种有效的方法是多次运行相同的测试。假设测试代码块既容易重复，又不特别长，我们应该能够在合理的时间内运行数千次，甚至数百万次测试，然后将总耗时除以我们刚刚运行的测试次数，以获得单个测试的更准确时间。
- en: Before we get obsessed with the topic of high precision, we should first ask
    ourselves if we even need it. Most games expect to run at 30 FPS or 60 FPS, which
    means that they only have around 33 ms or 16 ms, respectively, to compute everything
    for the entire frame. So, hypothetically, if we need to bring only the performance
    of a particular code block under 10 ms, then repeating the test thousands of times
    to get microsecond precision is too many orders of magnitude away from the target
    to be worthwhile.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们沉迷于高精度的话题之前，我们首先应该问自己我们是否真的需要它。大多数游戏期望以30 FPS或60 FPS的速度运行，这意味着它们只有大约33毫秒或16毫秒的时间来计算整个帧的所有内容。所以，假设我们只需要将特定代码块的性能降低到10毫秒以下，那么重复测试数千次以获得微秒级的精度与目标相差太远，不值得。
- en: 'The following is a class definition for a custom timer that uses a `Stopwatch` object
    to count time for a given number of tests:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个自定义计时器的类定义，它使用`Stopwatch`对象来计算给定次数的测试时间：
- en: '[PRE2]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding an underscore before member variable names is a common and useful way
    of distinguishing a class's member variables (also known as fields) from a method's
    arguments and local variables.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在成员变量名前添加下划线是区分类的成员变量（也称为字段）和方法参数以及局部变量的常见且有用的方式。
- en: 'The following is an example of `CustomTimer` class usage:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`CustomTimer`类使用的示例：
- en: '[PRE3]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are three things to note when using this approach:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法时，有三个需要注意的事项：
- en: Firstly, we are only making an average of multiple method invocations. If processing
    time varies enormously between invocations, then that will not be well represented
    in the final average.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们只是在多个方法调用中取平均值。如果调用之间的处理时间差异很大，那么这最终的平均值将不会很好地反映出来。
- en: Secondly, if memory access is common, then repeatedly requesting the same blocks
    of memory will result in an artificially higher cache hit rate (where the CPU
    can find data in memory very quickly because it's accessed the same region recently),
    which will bring the average time down when compared to a typical invocation.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，如果内存访问很常见，那么反复请求相同的内存块将导致人为地提高缓存命中率（因为CPU最近访问了相同的区域，所以可以在内存中非常快速地找到数据），与典型调用相比，这会降低平均时间。
- en: Thirdly, the effects of **Just-In-Time** (**JIT**) compilation will be effectively
    hidden for similarly artificial reasons, as it only affects the first invocation
    of the method. JIT compilation is a .NET feature that will be covered in more
    detail in Chapter 8, *Masterful Memory Management*.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，**即时编译**（**JIT**）的效果将由于类似的人工原因而有效地被隐藏，因为它只影响方法的第一次调用。JIT编译是.NET的一个特性，将在第8章“精通内存管理”中更详细地介绍。
- en: The `using` block is typically used to safely ensure that unmanaged resources
    are properly destroyed when they go out of scope. When the `using` block ends,
    it will automatically invoke the object's `Dispose()` method to handle any cleanup
    operations. In order to achieve this, the object must implement the `IDisposable`
    interface, which forces it to define the `Dispose()` method.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`块通常用于在作用域结束时安全地确保未托管资源被正确销毁。当`using`块结束时，它将自动调用对象的`Dispose()`方法来处理任何清理操作。为了实现这一点，对象必须实现`IDisposable`接口，这迫使它定义`Dispose()`方法。'
- en: However, the same language feature can be used to create a distinct code block,
    which creates a short-term object, which then automatically processes something
    useful when the code block ends; this is how it is being used in the preceding
    code block.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相同的语言特性也可以用来创建一个独立的代码块，该代码块创建一个短期对象，当代码块结束时自动处理一些有用的东西；这就是它在前面代码块中的使用方式。
- en: Note that the `using` block should not be confused with the `using` statement,
    which is used at the start of a script file to pull in additional namespaces.
    It's extremely ironic that the keyword for managing namespaces in C# has a naming
    conflict with another keyword.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`using` 块不应与用于在脚本文件开头引入附加命名空间的 `using` 语句混淆。在 C# 中用于管理命名空间的关键字与另一个关键字存在命名冲突，这非常具有讽刺意味。
- en: As a result, the `using` block and the `CustomTimer` class give us a clean way
    of wrapping our test code that makes it obvious when and where it is being used.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`using` 块和 `CustomTimer` 类为我们提供了一个干净的方式来包装我们的测试代码，使得使用的时间和地点一目了然。
- en: Something else to worry about is application warm-up time. Unity has a significant
    start-up cost when a scene begins, given the amount of data that needs to be loaded
    from disk, the initialization of complex subsystems, such as the physics and rendering
    systems, and the number of calls to various `Awake()` and `Start()` callbacks
    that need to be resolved before anything else can happen. This early overhead
    might only last a second, but that can have a significant effect on the results
    of our testing if the code is also executed during this early initialization period.
    This makes it crucial that, if we want an accurate test, then any runtime testing
    should begin only after the application has reached a steady state.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要担心的事情是应用程序的预热时间。当场景开始时，Unity 需要从磁盘加载大量数据，初始化复杂的子系统，如物理和渲染系统，以及需要解决的各种 `Awake()`
    和 `Start()` 回调调用，这给 Unity 带来了显著的开销。这种早期开销可能只持续一秒钟，但如果代码也在这个早期初始化期间执行，这可能会对我们的测试结果产生重大影响。这使得，如果我们想要一个准确的测试，那么任何运行时测试都应该在应用程序达到稳定状态后才开始。
- en: 'Ideally, we would be able to execute the target code block in its own scene
    after its initialization has completed. This is not always possible; so, as a
    backup plan, we could wrap the target code block in an `Input.GetKeyDown()` check
    in order to assume control over it when it is invoked. For example, the following
    code will execute our test method only when the spacebar is pressed:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们能够在初始化完成后在它自己的场景中执行目标代码块。这并不总是可能的；因此，作为备用计划，我们可以在目标代码块周围包裹一个 `Input.GetKeyDown()`
    检查，以便在它被调用时控制它。例如，以下代码只有在按下空格键时才会执行我们的测试方法：
- en: '[PRE4]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As mentioned previously, Unity's Console window logging mechanism is prohibitively
    expensive. As a result, we should try not to use these logging methods in the
    middle of a profiling test (or during gameplay, for that matter). If we find ourselves
    absolutely in need of detailed profiling data that prints out lots of individual
    messages (such as performing a timing test on a loop to figure out which iteration
    is costing more time than the rest), then it would be wiser to cache the logging
    data and print it all out at the end, as the `CustomTimer` class does. This will
    reduce runtime overhead, at the cost of some memory consumption. The alternative
    is that many milliseconds are lost to printing each `Debug.Log()` message in the
    middle of the test, which pollutes the results.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Unity 的控制台窗口日志机制成本极高。因此，我们应该尽量避免在性能测试过程中（或者游戏过程中）使用这些日志方法。如果我们发现自己迫切需要打印出大量单独消息的详细性能数据（例如，通过在循环中执行计时测试以确定哪个迭代花费的时间比其他迭代多），那么最好是将日志数据缓存起来，并在结束时全部打印出来，就像
    `CustomTimer` 类所做的那样。这将减少运行时开销，但会以一些内存消耗为代价。另一种选择是在测试过程中打印每个 `Debug.Log()` 消息会损失许多毫秒，这会污染结果。
- en: The `CustomTimer` class also makes use of `string.Format()`. This will be covered
    in more detail in Chapter 8, *Masterful Memory Management*, but a short explanation
    is that this method is used because generating a custom `string` object using
    the `+` operator (for example, code such as `Debug.Log("Test: " + output);`) can
    result in a surprisingly large number of memory allocations, which attracts the
    attention of the garbage collector. Doing otherwise would conflict with our goal
    of achieving accurate timing and analysis and should be avoided.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomTimer`类也使用了`string.Format()`。这将在第8章*精湛的内存管理*中更详细地介绍，但简短的解释是，这个方法被使用是因为使用`+`运算符（例如，如`Debug.Log("Test:
    " + output);`这样的代码）生成自定义的`string`对象会导致出人意料的大量内存分配，这会吸引垃圾收集器的注意。否则，将与我们实现准确计时和分析的目标相冲突，应避免这样做。'
- en: Final thoughts on profiling and analysis
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于性能分析和分析的最终思考
- en: One way of thinking about performance optimization is *the act of stripping
    away unnecessary tasks that waste valuable resources*. We can do the same and
    maximize our own productivity by minimizing any wasted effort. Effective use of
    the tools we have at our disposal is of paramount importance. It would serve us
    well to optimize our own workflow by remaining aware of some best practices and
    techniques.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 关于性能优化的思考方式是*去除不必要的任务，这些任务浪费了宝贵的资源*。我们可以做同样的事情，通过最小化任何浪费的努力来最大化我们的生产力。有效使用我们可用的工具至关重要。通过保持对一些最佳实践和技术保持警觉，我们可以优化自己的工作流程。
- en: 'Most, if not all, advice for using any kind of data-gathering tool properly
    can be summarized into three different strategies:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于如何正确使用任何类型的数据收集工具的建议，大部分可以总结为三种不同的策略：
- en: Understanding the tool
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解工具
- en: Reducing noise
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少噪声
- en: Focusing on the issue
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注问题
- en: Understanding the Profiler
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解性能分析器
- en: The Profiler is a well-designed and intuitive tool, so understanding the majority
    of its feature set can be gained by simply spending an hour or two exploring its
    options with a test project and reading its documentation. The more we know about
    a tool in terms of its benefits, pitfalls, features, and limitations, the more
    sense we can make of the information it is giving us, so it is worth spending
    the time to use it in a playground setting. We don't want to be two weeks away
    from release, with a hundred performance defects to fix, with no idea how to do
    performance analysis efficiently.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器是一个设计精良且直观的工具，因此通过花一两个小时用测试项目探索其选项并阅读其文档，就可以理解其大多数功能集。我们对工具的了解越多，包括其优点、缺点、功能和限制，我们就能更好地理解它提供的信息，因此花时间在游乐场环境中使用它是值得的。我们不希望距离发布还有两周，有一百个性能缺陷需要修复，却不知道如何有效地进行性能分析。
- en: For example, always remain aware of the relative nature of Timeline View graphical
    display. Timeline View does not provide values on its vertical axis and automatically
    readjusts this axis based on the content of the last 300 frames; it can make small
    spikes appear to be a bigger problem than they really are because of the relative
    change. So, just because a spike or resting state in the timeline seems large
    and threatening does not necessarily mean there is a performance issue.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，始终意识到时间轴视图图形显示的相对性质。时间轴视图不提供其垂直轴上的值，并自动根据最后300帧的内容调整此轴；由于相对变化，它可以使小的峰值看起来比实际情况更严重。因此，即使时间轴中的峰值或静止状态看起来很大且具有威胁性，也不一定意味着存在性能问题。
- en: Several areas in Timeline View provide helpful benchmark bars, which appear
    as horizontal lines with a timing and FPS value associated with them. These should
    be used to determine the magnitude of the problem. Don't let the Profiler trick
    us into thinking that big spikes are always bad. As always, it's only important
    if the user will notice it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴视图中的几个区域提供了有用的基准条，这些条目以带有时间和FPS值的水平线形式出现。这些条目应用于确定问题的严重程度。不要让性能分析器误导我们，认为大的峰值总是不好的。一如既往，只有当用户会注意到它时，它才重要。
- en: As an example, if a large CPU Usage spike does not exceed the 60 FPS or 30 FPS
    benchmark bars (depending on the application's target frame rate), then it would
    be wise to ignore it and search elsewhere for CPU performance issues, since no
    matter how much we improve the offending piece of code, it will probably never
    be noticed by the end user, and therefore isn't a critical issue that affects
    user experience.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果CPU使用量的大幅激增没有超过60 FPS或30 FPS的基准条（取决于应用程序的目标帧率），那么明智的做法是忽略它，并在其他地方寻找CPU性能问题，因为无论我们如何改进有问题的代码片段，它可能永远不会被最终用户注意到，因此这不是影响用户体验的关键问题。
- en: Reducing noise
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少噪声
- en: The classical definition of noise (at least in the realm of computer science)
    is meaningless data, and a batch of profiling data that was blindly captured with
    no specific target in mind is always full of data that won't interest us. More
    sources of data take more time to mentally process and filter, which can be very
    distracting. One of the best methods to avoid this is to simply reduce the amount
    of data we need to process by stripping away any data deemed non-vital to the
    current situation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 噪声的经典定义（至少在计算机科学领域）是无意义的数据，而一批没有特定目标盲目捕获的分析数据总是充满了对我们不感兴趣的数据。更多的数据来源需要更多的时间来心理处理和筛选，这可能会非常分散注意力。避免这种情况的最好方法之一是简单地减少我们需要处理的数据量，通过去除任何被认为对当前情况非必要的数据。
- en: Reducing the clutter in the Profiler's graphical interface will make it easier
    to determine which subsystems are causing a spike in resource usage. Remember
    to use the colored checkboxes in each Timeline View area to narrow the search.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 减少分析器图形界面上的杂乱将使确定哪些子系统导致资源使用激增变得更容易。请记住，在时间轴视图区域的每个区域使用彩色复选框来缩小搜索范围。
- en: Be warned that these settings are autosaved in the Editor, so ensure that you
    re-enable them for the next profiling session, as this might cause us to miss
    something important next time.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这些设置在编辑器中会自动保存，所以请确保您在下一个分析会话中重新启用它们，因为这可能会使我们错过下次重要的东西。
- en: Also, GameObjects can be deactivated to prevent them from generating profiling
    data, which will also help to reduce clutter in our profiling data. This will
    naturally cause a slight performance boost for each object we deactivate. However,
    if we're gradually deactivating objects and performance suddenly becomes significantly
    more acceptable when a specific object is deactivated, then clearly that object
    is related to the root cause of the problem.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以禁用GameObject以防止它们生成分析数据，这也有助于减少我们的分析数据中的杂乱。这将自然地使每个我们禁用的对象略微提高性能。然而，如果我们逐渐禁用对象，并且当特定对象被禁用时性能突然变得显著可接受，那么很明显，该对象与问题的根本原因有关。
- en: Focusing on the issue
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专注于问题
- en: This category may seem redundant, given that we've already covered reducing
    noise. All we should have left is the issue at hand, right? Not exactly. Focus
    is the skill of not letting ourselves become distracted by inconsequential tasks
    and wild-goose chases.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别可能看起来是多余的，因为我们已经讨论了减少噪声的问题。我们剩下的应该就是手头的问题，对吧？并不完全是这样。专注是一种技能，它让我们不会让自己被无关紧要的任务和无谓的追求所分散注意力。
- en: You will recall that profiling with the Unity Profiler comes with a minor performance
    cost. This cost is even more severe when using the Deep Profile option. We might
    even introduce more minor performance costs into our application with additional
    logging. It's easy to forget when and where we introduced profiling code if the
    hunt continues for several hours.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得，使用Unity分析器进行性能分析会带来一定的性能成本。当使用深度分析选项时，这种成本会更严重。我们甚至可能通过添加额外的日志将更多的轻微性能成本引入我们的应用程序。如果搜索持续几个小时，很容易忘记何时何地引入了性能分析代码。
- en: We are effectively changing the result by measuring it. Any changes we implement
    during data sampling can sometimes lead us to chase after non-existent bugs in
    the application when we could have saved ourselves a lot of time by attempting
    to replicate the scenario without additional profiling instrumentation. If the
    bottleneck is reproducible and noticeable without profiling, then it's a candidate
    for beginning an investigation. However, if new bottlenecks keep appearing in
    the middle of an existing investigation, then keep in mind that they could be
    bottlenecks we introduced with our test code and not an existing problem that's
    been newly exposed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过测量实际上是在改变结果。我们在数据采样期间实施的任何更改有时会导致我们追逐应用程序中不存在的错误，而如果我们尝试在没有额外的性能分析工具的情况下复制场景，我们本可以节省很多时间。如果瓶颈是可复制的，并且在没有性能分析的情况下可察觉，那么它就是开始调查的候选者。然而，如果新的瓶颈在现有调查过程中不断出现，那么请记住，它们可能是我们测试代码中引入的瓶颈，而不是新暴露的现有问题。
- en: Finally, when we have finished profiling, completed our fixes, and are now ready
    to move on to the next investigation, we should make sure to profile the application
    one last time to verify that the changes have had the intended effect.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们完成性能分析、完成修复并准备进行下一项调查时，我们应该确保再次对应用程序进行一次性能分析，以验证更改是否产生了预期的效果。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a great deal throughout this chapter on how to detect and analyze
    performance issues within your applications. You learned about many of the Profiler's
    features and secrets, explored a variety of tactics to investigate performance
    issues with a more hands-on approach, and have been introduced to a variety of
    different tips and strategies to follow. You can use these to improve your productivity
    immensely, so long as you appreciate the wisdom behind them and remember to exploit
    them when the situation makes it possible.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多关于如何在应用程序中检测和分析性能问题的知识。你了解了Profiler的许多功能和秘密，探索了各种策略以更实际的方法调查性能问题，并介绍了一系列不同的技巧和策略供你遵循。只要你欣赏背后的智慧并记住在可能的情况下利用它们，你就可以极大地提高你的生产力。
- en: This chapter has introduced us to the tips, tactics, and strategies we need
    in order to identify a performance issue that requires improvement. In the remaining
    chapters, we will explore methods on how to fix issues and improve performance
    whenever possible. So, give yourself a pat on the back for getting through the
    boring part first. We will now move on to best practices for C# development and
    how to avoid common performance pitfalls in your Unity scripts.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了识别需要改进的性能问题的技巧、策略和策略。在接下来的章节中，我们将探讨如何修复问题和尽可能提高性能的方法。所以，恭喜你首先完成了枯燥的部分。现在，我们将继续探讨C#开发的最佳实践以及如何在Unity脚本中避免常见的性能陷阱。
