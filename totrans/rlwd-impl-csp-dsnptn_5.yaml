- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Wrangling Problem Code by Applying Behavioral Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过应用行为模式整理问题代码
- en: 'Do you want to have some fun that doesn’t involve code for once? Next time
    you find yourself in a tall building with an elevator, get with three or four
    friends and ride to the top floor. Here’s the fun part: have everyone in your
    group face the back of the elevator. As other people get on the elevator, they
    will almost always follow your lead and face the rear. This is because human behavior
    follows patterns! There are entire fields of study devoted to this fact, including
    psychology, sociology, and the applied fields of marketing and human relations.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你想找点不涉及代码的乐子吗？下次当你发现自己在一座高楼里，有电梯的时候，和三四个朋友一起坐电梯到顶层。这里有趣的部分是：让你们小组的每个人都面朝电梯的后方。当其他人上电梯时，他们几乎总是会跟随你的领导，面朝后方。这是因为人类行为遵循模式！有整个研究领域致力于这一事实，包括心理学、社会学，以及市场营销和人际关系应用的领域。
- en: Software is a human invention, so it should come as no surprise that software
    can be made to follow behavioral patterns too. Behavioral patterns are patterns
    that deal with algorithms implemented within your classes and how those classes
    interact and share responsibilities for executing those algorithms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是人类发明，所以软件也可以被设计成遵循行为模式也就不足为奇了。行为模式是处理你类中实现的算法以及这些类如何交互和共享执行这些算法的责任的模式。
- en: 'As our story continues, Kitty and Phoebe will be facing challenges that will
    require them to learn and implement four of the most popular behavioral patterns:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着故事的发展，Kitty和Phoebe将面临需要他们学习和实现四种最受欢迎的行为模式的挑战：
- en: '**The Command pattern**'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令模式**'
- en: '**The Iterator pattern**'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器模式**'
- en: '**The Observer pattern**'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者模式**'
- en: '**The Strategy pattern**'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略模式**'
- en: As you ride along with them on their journey, you will learn how to diagram
    and implement the four most popular behavioral patterns using the **C#** language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在你跟随他们的旅程中，你将学习如何使用 **C#** 语言绘制和实现四种最受欢迎的行为模式。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Throughout this book, I assume you know how to create new C# projects in your
    favorite **Integrated Development Environment** (**IDE**), so I won’t spend any
    time on the mechanics of setting up and running projects in the chapters themselves.
    There is a short tutorial on the three most popular IDEs in [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    of this book. Should you decide to follow along, you’ll need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我假设你知道如何在你的首选 **集成开发环境**（**IDE**）中创建新的C#项目，所以我在章节本身中不会花费时间在设置和运行项目的机制上。这本书的[附录1](B18605_Appendix_1.xhtml#_idTextAnchor178)中有关于三个最受欢迎的IDE的简短教程。如果你决定跟随，你需要以下内容：
- en: A computer running the **Windows** operating system. I’m using **Windows 10**.
    Since the projects are simple command-line projects, I’m pretty sure everything
    here would also work on a **Mac** or **Linux**, but I haven’t tested the projects
    on those operating systems.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 **Windows** 操作系统的计算机。我使用的是 **Windows 10**。由于项目是简单的命令行项目，我相当确信这些内容在 **Mac**
    或 **Linux** 上也能工作，但我还没有在这些操作系统上测试过这些项目。
- en: A supported IDE such as **Visual Studio**, **JetBrains Rider**, or **Visual
    Studio Code** with C# extensions. I’m using **Rider 2021.3.3**.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持的开发环境，例如 **Visual Studio**、**JetBrains Rider** 或 **Visual Studio Code**
    并带有C#扩展。我使用的是 **Rider 2021.3.3**。
- en: Some versions of the the **.NET SDK**. Again, the projects are simple enough
    that our code shouldn’t be reliant on any particular version. I happen to be using
    the **.NET Core 6 SDK**, and my code’s syntax may reflect that.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些版本的 **.NET SDK**。同样，项目足够简单，我们的代码不应该依赖于任何特定版本。我恰好使用的是 **.NET Core 6 SDK**，我的代码的语法可能反映了这一点。
- en: You can find the completed project files for this chapter on GitHub at [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-5](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-5).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的完整项目文件，地址为[https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-5](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-5)。
- en: Meanwhile, back at the bicycle factory
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时，回到自行车工厂
- en: '*“W00t!”* Phoebe exclaimed. Kitty was startled and amazed. Her sister had somehow
    managed to pronounce the hacker slang word while intimating excitement in such
    a way that Kitty could hear the zeros that replaced the phonetics of the double-o.
    *“What?”* Kitty inquired. Phoebe didn’t answer right away, so Kitty looked up
    and found Phoebe dancing in circles. Phoebe was clad in dirty coveralls and had
    her hair pulled back in a ponytail. The sight of a dancing Phoebe was not unusual.
    Kitty realized there was a line of 10 robotic arms bolted to the floor. The arms
    were mimicking Phoebe’s dance moves to the best of their limited ability.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “W00t！”菲比惊呼。基蒂吓了一跳，感到惊讶。她的妹妹不知怎么的，竟然用一种充满兴奋的方式发出了黑客俚语词汇，基蒂甚至能听到双-o的音节被零所取代。“什么？”基蒂问道。菲比没有立即回答，于是基蒂抬头看，发现菲比正在围圈跳舞。穿着脏兮兮的工作服，把头发扎成马尾辫的菲比跳舞的样子并不罕见。基蒂意识到地板上有一排10个机器人手臂。这些手臂尽力模仿菲比的舞步。
- en: The unchoreographed ballet of arms was unimpressive by the standards of the
    Vaganova academy. However, within the context of a hand-built robotic factory
    created by two fourth-year college students in an abandoned warehouse, it was
    an astonishing achievement. *“That’s amazing!”* Kitty laughed. The sisters held
    hands and danced in circles, which almost caused a large collision as the robots
    attempted their emulation. They stopped dancing and laughed again. *“So, we’re
    done?”* Kitty asked. *“No. Right now, they just mimic what they see,”* Phoebe
    replied. *“What do you mean by see? Vision was never a part of our specification,”*
    Kitty pointed out. *“I know,”* said Phoebe. *“I found one of Boomer’s old Xbox’s
    in a crate upstairs. It had a Kinect attached to it, so I dusted it off and connected
    it to our test client program.”* Boomer is Kitty and Phoebe’s cousin. He is a
    year older than Kitty and graduated from the University of Las Vegas last year.
    He went to college on an eSports scholarship and is now a pro. Naturally, he always
    had the best gaming gear.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这群没有编排的机械舞手臂，按照瓦加诺娃学院的标准来看并不令人印象深刻。然而，在这个由两名大四学生在废弃仓库里手工建造的机器人工厂的背景下，这却是一项惊人的成就。“太棒了！”基蒂笑着说道。姐妹俩手拉手围圈跳舞，几乎造成了一次大碰撞，因为机器人试图模仿她们的舞步。她们停止了跳舞，又笑了起来。“所以，我们完成了？”基蒂问道。“不，现在它们只是模仿它们看到的，”菲比回答道。“你说的‘看到’是什么意思？视觉从未是我们规格的一部分，”基蒂指出。“我知道，”菲比说。“我在楼上的一箱子里找到了布默的旧Xbox。它上面连接了一个Kinect，所以我把它清理干净，并将其连接到我们的测试客户端程序上。”布默是基蒂和菲比的表兄。他比基蒂大一岁，去年从拉斯维加斯大学毕业。他凭借电子竞技奖学金上大学，现在是一名职业选手。自然，他总是拥有最好的游戏装备。
- en: Kitty remembered that Kinect was a camera system Microsoft sold years earlier
    as part of its Xbox console game platform. It provided a rudimentary computer
    vision system that was capable of recognizing the shape of a human body. There
    had been games based on the idea that you could move in front of the camera and
    the characters in your game would act according to how they  “saw” you move. Naturally,
    being a Microsoft technology, the SDKs were readily available for C#.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂记得Kinect是微软多年前作为其Xbox游戏平台的一部分出售的摄像头系统。它提供了一个基本的计算机视觉系统，能够识别人体形状。有一些游戏基于这样的想法：你可以站在摄像头前，游戏中的角色会根据他们“看到”你的移动方式来行动。自然，作为微软的技术，C#的SDKs很容易获得。
- en: '*“What a neat idea!”* Kitty exclaimed. Phoebe breathlessly continued, *“So,
    we have a good object structure from our work with Creational patterns and we
    also have the skeleton of a working system in place because of our structural
    patterns.”* Kitty countered, *“True, but we have not done much with the actual
    command and control system that drives the robots. The robots can function on
    their own with our test programs. They can even make bicycle parts by themselves."*
    Phoebe finished Kitty’s thought in a way only sisters can do: *“What they can’t
    do is work together! I did some more reading last night. It turns out there is
    a whole collection of patterns that will enable the robots to work together. They*
    *are called Behavioral patterns! I think we can use them to control a lot of our
    systems and orchestrate the robots so that they may work together.”* Phoebe walked
    to the whiteboard and explained the next steps needed to code a control system
    for the necessary robotics.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “真是个不错的主意！”凯蒂惊叹道。菲比喘着气继续说，“所以，我们从创世模式的工作中得到了一个良好的对象结构，也因为我们的结构模式，我们已经有一个工作系统的框架。”凯蒂反驳道，“确实如此，但我们还没有真正处理过驱动机器人的实际命令和控制系统。机器人可以凭借我们的测试程序独立运行。它们甚至可以自己制作自行车零件。”菲比以只有姐妹才能做到的方式完成了凯蒂的想法：“它们做不到的是一起工作！我昨晚又读了一些东西。结果发现有一整套模式可以使机器人协同工作。它们被称为行为模式！我认为我们可以用它们来控制我们的大多数系统，并编排机器人，使它们能够协同工作。”菲比走到白板前，解释了编写必要机器人控制系统的下一步步骤。
- en: The Command pattern
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: At this point, Phoebe has designed two different models of the robotic arm.
    One set of arms was large and bolted to the floor. These arms were stationary.
    The second set of arms was mounted on tracks and could move. These were mainly
    used for moving the parts, materials, and partially finished bicycles around to
    different stations. Once at a station, the larger arms would do most of the real
    work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，菲比已经设计了两种不同的机器人臂模型。一套臂是大型并固定在地面上的。这些臂是固定的。第二套臂安装在轨道上，可以移动。这些臂主要用于将零件、材料和部分完成的自行车移动到不同的站点。一旦到达站点，较大的臂就会做大部分实际工作。
- en: The larger arms that were bolted to the floor had interchangeable attachments
    that allowed them to perform different tasks. Phoebe designed this behavior based
    on the Decorator pattern. Remember, a decorator allows you to add new behavior
    to an existing class without you having to modify it directly. This is done by
    creating a new class that wraps around the structure of the original class, then
    adds the additional behavior. In this case, the decorators are physical hardware.
    Phoebe marveled at the patterns. She understood how working with the patterns
    might be considered a design philosophy as much as a software engineering practice.
    Phoebe remembered that patterns were devised by architects of the physical world
    at a time when software engineering was only done by scientists in top-secret
    military labs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 钉在地面的较大机械臂具有可互换的附件，这使得它们能够执行不同的任务。菲比根据装饰者模式设计了这种行为。记住，装饰者允许你在不直接修改现有类的情况下向其添加新行为。这是通过创建一个围绕原始类结构的新类来完成的，然后添加额外的行为。在这种情况下，装饰者是物理硬件。菲比对模式感到惊奇。她理解了与模式一起工作可能被视为一种设计哲学，就像是一种软件工程实践一样。菲比记得，模式是在软件工程仅由科学家在绝密军事实验室中进行的时候，由物理世界的建筑师设计的。
- en: Each of the large stationary robotic arms could affix a different attachment
    for welding or another for buffing and polishing. Each arm could be programmed
    to take a handoff of materials brought by the smaller, mobile track-mounted robots.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个大型的固定式机械臂都可以安装不同的附件，用于焊接或用于抛光和打磨。每个机械臂都可以编程，以接收由较小的、可移动的轨道式机器人带来的材料。
- en: Phoebe drew out her idea for Kitty, explaining how she could model a command
    for the necessary robotics in a way that was flexible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比画出了她为凯蒂的想法，解释了她如何能够以灵活的方式模拟必要的机器人命令。
- en: '*“Think of it this way, Kitty,”* Phoebe began. *“When we order clothes and
    shoes online, we pick out the clothes we want to buy. We decide which dresses
    went want, as well as their color and size. Then, we tell the store where we’d
    like the clothes to be shipped. Finally, we give the retailer the payment details
    and a way to contact us if there are questions or problems. The order is a structure
    that holds all of that information. That’s what I want to do here. I want a pattern
    where I can send a command. The command should contain everything that the robot
    needs to know so that it can do its job. The command shouldn’t be tightly coupled
    to the robot’s control API. In effect, I should be able to send a command to any
    piece of hardware we have. It isn’t specific to any one robot, or even the attachment
    it’s using at the time.”*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “凯蒂，你就这么想，”菲比开始说。“当我们在线订购衣服和鞋子时，我们挑选出我们想要购买的衣物。我们决定想要哪些连衣裙，以及它们的颜色和尺码。然后，我们告诉商店我们希望将衣物寄送到哪里。最后，我们向零售商提供付款详情，以及如果出现问题或疑问时如何联系我们的方式。订单是一个包含所有这些信息的结构。这正是我想做的。我想有一个可以发送命令的模式。命令应该包含机器人完成工作所需的所有信息。命令不应该与机器人的控制
    API 紧密耦合。实际上，我应该能够向任何我们拥有的硬件发送命令。它并不特定于任何一台机器人，甚至不是它当时使用的附件。”
- en: '*“I see,”* said Kitty. *“So, the order that contains all the information for
    the clothes we want to buy could just as easily be sent to any store in the world.
    We are the senders of the command. We compile the information and send it to a
    receiver. The receiver isn’t unique to a single store and that receiver could
    be anything equipped to receive our command. We’re packaging up everything needed
    to complete an order or a command and it’s up to the receiver to act on it.”*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “我明白了，”凯蒂说。“所以，包含我们想要购买的衣物所有信息的订单可以同样容易地发送到世界上的任何一家商店。我们是命令的发送者。我们编译信息并发送给接收者。接收者并不特定于某一家商店，而且这个接收者可以是任何能够接收我们命令的设备。我们打包完成订单或命令所需的一切，然后由接收者来执行。”
- en: '*“You’ve got it, sis!”* Phoebe beamed. They were excited to get started. Phoebe
    brought up a diagram she had found online that showed the pattern in its generic
    form, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “你明白了，妹妹！”菲比兴奋地说。她们都迫不及待地想要开始。菲比拿出了一张她在网上找到的图表，展示了模式的通用形式，如下所示：
- en: '![Figure 5.1 – The Command pattern. ](img/B18605_Figure_5.1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 命令模式](img/B18605_Figure_5.1.jpg)'
- en: Figure 5.1 – The Command pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 命令模式。
- en: 'Let’s review the different parts of the pattern, which have been numbered appropriately:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下模式的各个部分，它们已经适当编号：
- en: A `Sender` object is responsible for invoking a request. For example, when Phoebe
    orders a dress online, the website is gathering the necessary information and
    is responsible for sending the order.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sender` 对象负责调用请求。例如，当菲比在线订购连衣裙时，网站正在收集必要的信息，并负责发送订单。'
- en: The `ICommand` interface defines a single method that’s used to execute a command.
    The sender doesn’t create the command. Instead, it receives it in the constructor,
    or it can be set as a property.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ICommand` 接口定义了一个用于执行命令的单个方法。发送者不创建命令。相反，它在构造函数中接收它，或者它可以作为一个属性设置。'
- en: The `Receiver` class contains business logic and performs the actual work. The
    shop that receives the online order is the receiver when Phoebe orders online.
    The business logic might be different from store to store. Each might have a different
    process for the way the order is picked, pulled, settled, then shipped. The logic
    is up to the receiver. It receives the command that contains what it needs to
    perform the logic independently from the sender.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Receiver` 类包含业务逻辑并执行实际工作。当菲比在线订购时，接收订单的商店就是接收者。业务逻辑可能因商店而异。每个商店可能都有不同的订单挑选、提取、结算和发货流程。逻辑由接收者决定。它接收包含它需要独立于发送者执行逻辑的命令。'
- en: Concrete command classes implement the `ICommand` interface, but also contain
    a reference to the receiver that will execute the command, along with any properties
    or parameters needed to execute the command.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体的命令类实现了 `ICommand` 接口，但同时也包含了一个指向接收器的引用，该接收器将执行命令，以及执行命令所需的任何属性或参数。
- en: The client instantiates the concrete command class (**4**) and passes in or
    sets any parameters or properties needed by the command, including an instance
    of the receiver.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户实例化具体的命令类（**4**）并传入或设置命令所需的任何参数或属性，包括接收器的一个实例。
- en: Applying the Command pattern
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用命令模式
- en: 'Phoebe drew her pattern idea while adapting what she had learned from the generic
    example. The following is her drawing:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比在适应从通用示例中学到的内容时绘制了她的模式想法。以下是她绘制的图案：
- en: '![Figure 5.2 – Phoebe’s drawing of the Command pattern. ](img/B18605_Figure_5.2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 菲比绘制的命令模式图](img/B18605_Figure_5.2.jpg)'
- en: Figure 5.2 – Phoebe’s drawing of the Command pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 菲比绘制的命令模式图。
- en: Kitty studied the diagram for a few minutes. Phoebe watched her closely. Kitty
    always got a look on her face before an idea clicked. After a minute, there it
    was. *“I got this!”* Kitty said as she walked to her corner of the warehouse and
    she started to work. After a few hours, she produced the implementation of the
    Command pattern. You can review this in the `CommandExample` project in this chapter’s
    code, which can be found in this book’s GitHub repository.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂研究了这张图几分钟。菲比密切地观察着她。基蒂在想法突然闪现之前，脸上总是会有一种表情。一分钟过后，她说道：“我明白了！”当她走到仓库的角落并开始工作时，她已经开始工作了。几个小时后，她完成了命令模式的实现。你可以在本章代码的
    `CommandExample` 项目中查看这个实现，该项目位于本书的 GitHub 仓库中。
- en: Coding the Command pattern
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写命令模式
- en: 'Kitty started by creating the `ICommand` interface:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂首先创建了 `ICommand` 接口：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, she made a concrete command that implements this interface:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，她创建了一个具体命令，该命令实现了这个接口：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember, a command object has everything a receiver needs to execute the intent,
    except the business logic. If you remember Phoebe’s explanation, it even includes
    a `private` field to hold the receiver itself. A command is self-contained. In
    addition to the receiver, it needs the information on the bicycle that the command
    is responsible for building. Kitty added a project reference to `BumbleBikesLibrary`,
    which we covered in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)*, Getting
    Creative with Creational Patterns*. We extended the library to include the `IPaintableBicycle`
    interface that was created using the Bridge pattern in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)*,
    Getting Creative with Creational Patterns*. As a reminder, always use an interface
    wherever you can. Concrete objects should come into play as late as possible.
    This keeps your design flexible and honors **SOLID** principles:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，命令对象拥有接收器执行意图所需的一切，除了业务逻辑。如果你还记得菲比的解释，它甚至包括一个 `private` 字段来保存接收器本身。命令是自包含的。除了接收器，它还需要关于它负责构建的自行车的信息。基蒂添加了对
    `BumbleBikesLibrary` 的项目引用，我们在 [*第 3 章*](B18605_03.xhtml#_idTextAnchor063)*，用创建型模式进行创新*
    中讨论过。我们扩展了库以包括使用桥接模式在 [*第 3 章*](B18605_03.xhtml#_idTextAnchor063)*，用创建型模式进行创新*
    中创建的 `IPaintableBicycle` 接口。作为提醒，尽可能使用接口。具体对象应该尽可能晚地发挥作用。这使你的设计更加灵活，并尊重 **SOLID**
    原则：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next comes a constructor where we pass in the receiver and `IPaintableBicycle`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个构造函数，我们传递接收器和 `IPaintableBicycle`：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lastly, we have the `Execute()` method, which is required by the `ICommand`
    interface. All it does is run the business logic contained within the receiver:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `Execute()` 方法，这是 `ICommand` 接口所要求的。它所做的只是运行接收器内包含的业务逻辑：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `BuildFrameCommand` class is done. Now, we need a sender. As mentioned
    previously, there isn’t much going on in the sender. All it needs is a command,
    which Kitty specified as `ICommand`, and a method to execute the command, which
    Kitty has specified as `DoCommand()`. The `DoCommand()` method executes the command.
    This seems a little counterintuitive; you’d think the receiver executes the command.
    It does, but not directly. If you coded it to execute more directly, you’d likely
    be tightly coupling the sender, receiver, and command logic together, which is
    exactly what we want to avoid:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildFrameCommand` 类已经完成。现在，我们需要一个发送者。如前所述，发送者中并没有太多的事情发生。它只需要一个命令，基蒂指定为 `ICommand`，以及一个执行命令的方法，基蒂指定为
    `DoCommand()`。`DoCommand()` 方法执行命令。这看起来有点反直觉；你可能会认为接收器执行命令。确实如此，但不是直接执行。如果你直接编写代码来执行，你很可能会将发送者、接收器和命令逻辑紧密耦合在一起，这正是我们想要避免的：'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Kitty finishes up with the receiver, which she calls `AssemblyLineReceiver`.
    The idea behind this class is that it acts as a master control for the whole assembly
    line. This is a major part of the orchestration that the girls are trying to achieve.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂完成了接收器的部分，她称之为 `AssemblyLineReceiver`。这个类背后的想法是它作为整个装配线的总控制。这是女孩们试图实现的整体编排的一部分。
- en: The `AssemblyLineReceiver` class needs a project reference to the work we did
    with the Façade pattern in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)*, Getting
    Creative with Creational Patterns*. As you may recall, the Façade pattern allows
    us to present a myriad of complicated APIs as a single, easy-to-use point of contact.
    In this case, the APIs for the robotics came from the manufacturers. The microcontrollers
    for the different robot arm attachments (the welder, the buffer, and the grabber)
    all came from different manufacturers with different APIs. In [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)*,
    Getting Creative with Creational Patterns*, Kitty and Phoebe wrote a Façade pattern
    to make this easier to use and to insulate them from repercussions inflicted by
    future changes to the third-party code, which will evolve independently of the
    business requirements of Bumble Bike’s manufacturing process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyLineReceiver` 类需要一个项目引用，指向我们在 [*第3章*](B18605_03.xhtml#_idTextAnchor063)
    *《创意使用创建型模式》* 中使用外观模式所做的工程。如您所回忆的那样，外观模式允许我们将众多复杂的API呈现为一个单一、易于使用的接触点。在这种情况下，机器人的API来自不同的制造商。不同机器人手臂附件（焊接机、缓冲器和抓取器）的微控制器都来自不同的制造商，具有不同的API。在
    [*第3章*](B18605_03.xhtml#_idTextAnchor063) *《创意使用创建型模式》* 中，Kitty 和 Phoebe 编写了一个外观模式，使其更容易使用，并隔离它们免受第三方代码未来变更带来的影响，这些变更将独立于Bumble
    Bike制造流程的业务需求而发展。'
- en: The Façade pattern also contained an encapsulation of how the line of floor-mounted
    robots should work. The girls have opted to use `struct` common to the gaming
    industry, to represent the spatial layout of their assembly line. The quaternion
    struct can be found in the `System.Numerics` library of the .NET framework.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式还包含了对地面安装的机器人线应该如何工作的封装。女孩们选择使用游戏行业通用的 `struct` 来表示装配线的空间布局。四元数 `struct`
    可以在.NET框架的 `System.Numerics` 库中找到。
- en: 'The first part of the `AssemblyLineReceiver` class just sets up what we need
    to use for the façade:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyLineReceiver` 类的第一部分只是设置了我们需要用于外观的内容：'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Quaternions are a complicated concept. I’m not selling short your intelligence;
    I’m paraphrasing the documentation for Unity 3D, a popular video game framework
    written in C#. In video game work with Unity, you can’t swing a virtual cat without
    hitting a quaternion. The position and angle of the virtual cat would be defined
    using a quaternion. The Unity documentation straight-up tells you that quaternions
    are an advanced mathematical concept. The short version is that a quaternion is
    a combination of three points in space represented as *X*, *Y*, and *Z*, along
    with a rotational vector represented as *W*. Since we don’t need to get into the
    guts of quaternions in a book on patterns, we have simplified the layout of the
    assembly line by deciding it is a straight line. As such, only one coordinate
    in the quaternion is different from station to station, and for us, that is the
    *X* coordinate. The remainder can be held constant at a standard height (*Y*)
    and a standard depth (*Z*) within the confines of the factory floor. We will also
    hold the rotation constant at 90 degrees for the sake of simplicity. To summarize,
    to represent where a robot sits on the assembly line, we have four coordinates
    (*X*, *Y*, *Z*, and *W*) but we keep three constant. Only *X* varies as you move
    from one end of the assembly line to the other.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数是一个复杂的概念。我并不是低估您的智慧；我只是在转述Unity 3D的文档，这是一个流行的C#编写的视频游戏框架。在Unity的视频游戏工作中，你几乎无处不在都会遇到四元数。虚拟猫的位置和角度将使用四元数来定义。Unity文档直接告诉你四元数是一个高级数学概念。简而言之，四元数是空间中三个点（用
    *X*、*Y* 和 *Z* 表示）的组合，以及一个旋转向量（用 *W* 表示）。由于我们不需要在关于模式的书中深入研究四元数的内部结构，我们通过决定将其视为一条直线来简化了装配线的布局。因此，四元数中只有一个坐标在各个站点之间不同，对我们来说，那就是
    *X* 坐标。其余的可以在工厂地面的标准高度（*Y*）和标准深度（*Z*）内保持不变。我们还将旋转保持为90度，以简化问题。总结来说，为了表示机器人在装配线上的位置，我们有四个坐标（*X*、*Y*、*Z*
    和 *W*），但我们保持其中三个不变。只有 *X* 随着你在装配线一端到另一端移动而变化。
- en: 'The location of each assembly for the stations is held in an array of quaternions.
    10 arms can service 20 stations. In the receiver’s constructor, we set up our
    façade, along with the locations of each station, by populating the `_assemblyStations`
    arrays with 20 quaternions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个站点的装配位置都存储在一个四元数数组中。10个手臂可以为20个站点提供服务。在接收器的构造函数中，我们通过用20个四元数填充 `_assemblyStations`
    数组来设置我们的外观，以及每个站点的位置：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That was a lot of setup, but it is also a nice example of how patterns can
    be combined. They are all pieces of the bigger puzzle. Next, we will look at the
    interesting part: the code that performs the business logic. This is going to
    look familiar.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要很多设置，但也是一个很好的例子，说明了模式如何结合使用。它们都是更大谜题的一部分。接下来，我们将看看有趣的部分：执行业务逻辑的代码。这看起来会很熟悉。
- en: The girls had this code in their test `Program.cs` file in the `FacadeExample`
    code we saw back in [*Chapter 4*](B18605_04.xhtml#_idTextAnchor078)*, Fortify
    Your Code with Structural Patterns*. The logic itself isn’t really important.
    In this case, it’s a set of steps to move a bicycle frame from station to station
    as it is assembled and painted. The key takeaway is that this is where the actual
    business logic lives. It is kept separate from the sender. In our earlier example,
    store owners would not want Phoebe telling them how best to pick, pack, and ship
    the dress she selected. The business logic is not driven by the sender. Likewise,
    we don’t want the logic in the command itself. The command represents everything
    needed to perform the logic. It’s the order, not the store workers, executing
    the order.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 女孩们将这段代码放在了测试`Program.cs`文件中，这是我们在[*第4章*](B18605_04.xhtml#_idTextAnchor078)*，使用结构化模式强化代码*中看到的`FacadeExample`代码。逻辑本身并不重要。在这种情况下，它是一系列步骤，将自行车框架从工作站移动到工作站，在组装和喷漆过程中进行。关键点是这里实际的业务逻辑所在。它被独立于发送者。在我们之前的例子中，店主不希望Phoebe告诉他们如何最好地挑选、包装和运送她选择的连衣裙。业务逻辑不是由发送者驱动的。同样，我们也不希望在命令本身中包含逻辑。命令代表执行逻辑所需的一切。它是订单，而不是店员在执行订单。
- en: 'In Kitty’s program, the `DoBusinessLogic` method takes the `IPaintableBicycle`
    object (essentially the order for the bicycle) and uses the façade to manipulate
    the robots to manufacture the bicycle:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kitty的程序中，`DoBusinessLogic`方法接收`IPaintableBicycle`对象（本质上是对自行车的订单）并使用外观来操控机器人制造自行车：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s move on to the last part, which is the client.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到最后一部分，即客户端。
- en: Testing the Command pattern’s code
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试命令模式的代码
- en: Rather than showing you all of Kitty’s client code, which is extensive and complex,
    I’ll just show you her simple test program for the logic found in `Program.cs`
    in the sample code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会展示Kitty的所有客户端代码，因为它们既广泛又复杂，而是只展示她为`Program.cs`中的逻辑编写的简单测试程序。
- en: 'Remember, it is the client’s job to create the command. In this example, Phoebe’s
    job, as the customer, is to pick out a dress online, specify its color, and give
    her payment and shipping details. Here, the client is specifying what type of
    bicycle to build and draws on the Bridge pattern. It can also specify the paint
    job. Here, we’re going with a simple black paint job that is standard for our
    mountain bike:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，创建命令是客户端的职责。在这个例子中，作为顾客，Phoebe的任务是在网上挑选一件连衣裙，指定其颜色，并提供她的支付和运输详情。在这里，客户端指定要建造的自行车类型，并利用桥接模式。它还可以指定喷漆工作。在这里，我们选择了一种简单的黑色喷漆，这是我们山地自行车的标准喷漆：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We need access to the control logic for the robot arm façade:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要访问机器人手臂外观的控制逻辑：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We must create a command and pass in the data needed to complete the command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建一个命令，并传入完成命令所需的数据：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we must make a sender object and set everything in motion by calling
    the `DoCommand` method on the sender. As promised, the sender initiates the action,
    but it doesn’t perform any action itself. When Phoebe chooses a dress online,
    she submits the order. It is the receiver that does the work:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须创建一个发送者对象，并通过在发送者上调用`DoCommand`方法来启动一切。正如承诺的那样，发送者启动了动作，但它本身并不执行任何操作。当Phoebe在网上选择一件连衣裙时，她提交订单。是接收者来完成工作：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Command pattern is one of the most useful and popular of all the patterns
    we’ll discuss. The *GoF* book, along with many others, discusses how it can be
    applied to the user interface layer of a desktop or web application. Commands
    within a UI can be created and sent to other parts of the program from several
    different parts of the UI. An easy example of this is when you save a file – you
    typically have a **File** menu option in your program. You likely also have a
    menu bar with a **Save** button, and a key combination such as *Ctrl*/*Command*
    + *S*. Those are all senders. The Command pattern allows you to encapsulate the
    receiver logic in one place.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是我们将要讨论的所有模式中最有用和最受欢迎的模式之一。《设计模式：可复用面向对象软件的基础》（GoF）一书以及其他许多书籍都讨论了它如何应用于桌面或Web应用程序的用户界面层。UI中的命令可以从UI的几个不同部分创建并发送到程序的其它部分。一个简单的例子是在保存文件时——你通常在程序中有一个**文件**菜单选项。你可能还有一个带有**保存**按钮的菜单栏，以及一个如*Ctrl*/*Command*
    + *S*这样的快捷键组合。这些都是发送者。命令模式允许你将接收器逻辑封装在一个地方。
- en: You can use the Command pattern any time you have logic to perform an action
    and you want to isolate it from tightly coupling to anything that may want to
    call that logic. The giving, receiving, and execution of commands in the real
    world is a pattern familiar to anyone who has been a parent giving a command and
    their child executing it. The command is initiated by a sender and executed by
    a receiver. The chain of events represents a pattern of behavior we all understand
    and recognize.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要执行一个动作且希望将其与可能调用该逻辑的任何紧密耦合的事物隔离时，你可以使用命令模式。在现实世界中，命令的给予、接收和执行是一个任何当过父母并下达命令、孩子执行命令的人都会熟悉的模式。命令由发送者发起，由接收者执行。事件链代表了一种我们都能理解和识别的行为模式。
- en: A full bicycle order would, in reality, comprise many of these commands. Here,
    we have built the frame and painted it. Kitty will build the rest of the logic
    needed to control the assembly process using commands, so we’ll leave her to do
    that while we explore more patterns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一个完整的自行车订单将包含许多这些命令。在这里，我们已经搭建了车架并对其进行了喷漆。凯蒂将使用命令构建控制组装过程的其余逻辑，所以我们让她去做这件事，而我们则探索更多的模式。
- en: 'Next, we’ll address another fundamental concept in C#: collections. While discussing
    collections, we’ll focus on a pattern you have used many times maybe without even
    knowing it was a pattern: the Iterator pattern.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论C#中的另一个基本概念：集合。在讨论集合时，我们将关注一个你可能多次使用过，甚至可能不知道它是一个模式的模式：迭代器模式。
- en: The Iterator pattern
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: Things were going well for Kitty as she worked on the control system, making
    liberal use of the Command pattern. Then, she hit something of a roadblock. Kitty’s
    command receiver logic was just taking bicycle orders from the customer ordering
    systems, such as direct sales, and the dealerships. The requests were processed
    in the order they were received. Due to this, Kitty and Phoebe noticed a slowdown.
    While the algorithms in `AssemblyLineReceiver` were optimized to efficiently produce
    bicycles, Kitty failed to consider the painting process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂在控制系统中工作进展顺利，她大量使用了命令模式。然后，她遇到了一些障碍。凯蒂的命令接收器逻辑只是从客户订单系统（如直接销售和经销商）接收自行车订单，请求按照接收的顺序进行处理。因此，凯蒂和菲比注意到了速度的下降。尽管`AssemblyLineReceiver`中的算法已经优化，可以高效地生产自行车，但凯蒂没有考虑到喷漆过程。
- en: The costliest part of the painting process in terms of time and money was setting
    everything up to paint a bicycle. This was very easy earlier when each bicycle
    was only allowed to be built in one color. Now, Bumble Bikes supports custom paint
    jobs. The sisters were losing time and money on custom jobs because the paint
    equipment had to be thoroughly cleaned and reset when a custom order was placed.
    The paint system would have to mix the colors requested, apply them to the custom
    order, and then reset to a more common color such as red or black. This was happening
    many times per day, so when a custom job request was received, it held up all
    the other bicycles behind it. Phoebe pointed out that when her father had done
    printing work many years ago, he would group his jobs based on ink color requirements
    to minimize the number of times he had to clean and re-ink the press. The sisters
    needed to group their orders by paint job type so that they could do all the custom
    work in batches and only need to clean and reset once per day. They could have
    adjusted customer expectations concerning delivery dates on custom paint requests,
    but that isn’t an abnormal retail situation. Kitty needed to figure out how to
    group the paint orders efficiently and flexibly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从时间和金钱的角度来看，喷漆过程中最昂贵的部分是设置一切以便喷漆自行车。在每种自行车只能喷一种颜色的时候，这很容易。现在，Bumble Bikes支持定制喷漆。由于在放置定制订单时必须彻底清洁和重置喷漆设备，姐妹们因定制工作而浪费了时间和金钱。喷漆系统必须混合所需的颜色，将其应用于定制订单，然后重置为更常见的颜色，如红色或黑色。这每天会发生多次，因此当收到定制工作请求时，它会阻碍其后的所有其他自行车。Phoebe指出，在她父亲多年前做印刷工作时，他会根据墨水颜色要求分组他的工作，以最大限度地减少他必须清洁和重新上墨印刷机次数。姐妹们需要按喷漆工作类型分组订单，这样她们就可以批量完成所有定制工作，并且每天只需要清洁和重置一次。她们可以调整客户对定制喷漆请求的交货日期的期望，但这并不是不正常的零售情况。Kitty需要找出如何高效灵活地分组喷漆订单。
- en: Kitty’s first thought was to incorporate `foreach` loop. While it is neat, it
    could be a problem at the scale she hoped her software might one day require.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty的第一个想法是采用`foreach`循环。虽然这样做很整洁，但在她希望她的软件可能有一天需要扩展的规模上可能会出现问题。
- en: 'In C# work, `foreach` loops against collections and allows you to iterate over
    its elements – that is, you can process each item in the collection, one at a
    time. Collections in C# are strongly typed, meaning every object in the collection,
    such as a `List`, is of the same type. The incoming orders for bicycles were stored
    in a database and loaded into a `List<BicycleOrder>` in batches throughout the
    day. The code for the `BicycleOrder` class looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#的工作中，`foreach`循环针对集合，并允许您遍历其元素——也就是说，您可以逐个处理集合中的每个项目。C#中的集合是强类型的，这意味着集合中的每个对象，例如一个`List`，都是同一类型。自行车的订单订单被存储在数据库中，并在一天中分批加载到`List<BicycleOrder>`中。`BicycleOrder`类的代码如下：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The standard iterator that’s used by C# in the `foreach` loop is what returns
    the orders in the order they were added. This is to say, they operate `foreach`
    loop processes. What Kitty needed was an iterator that gave her all the regular
    paint job orders first, and the custom paint jobs last. In short, she needed a
    custom iterator. Iterators in C# follow the Iterator pattern. This should hardly
    be surprising, though you may not have known it was a pattern at play. The Iterator
    pattern is shown graphically using UML in the following diagram:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: C#在`foreach`循环中使用的标准迭代器是按添加顺序返回订单的。也就是说，它们操作`foreach`循环处理。Kitty需要的是一个先返回所有常规喷漆订单，然后是定制喷漆订单的迭代器。简而言之，她需要一个自定义迭代器。C#中的迭代器遵循迭代器模式。这应该不会令人惊讶，尽管你可能不知道这是一个模式。以下图示使用UML展示了迭代器模式：
- en: '![Figure 5.3 – A custom iterator follows the Iterator pattern, which is partly
    already implemented for you in C#. ](img/B18605_Figure_5.3_New.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 一个自定义迭代器遵循迭代器模式，其中C#已经为您部分实现了。](img/B18605_Figure_5.3_New.jpg)'
- en: Figure 5.3 – A custom iterator follows the Iterator pattern, which is partly
    already implemented for you in C#.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 一个自定义迭代器遵循迭代器模式，其中C#已经为您部分实现了。
- en: 'Let’s review the different parts of the pattern, which have been numbered appropriately:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下模式的各个部分，它们已经被适当地编号：
- en: The `IEnumerator` interface is part of the .NET framework, so this time, you
    won’t need to make it from scratch. The interface requires one property, `Current`,
    which returns the current element in the iteration. The required `MoveNext()`
    method is the mechanism used to advance the iteration to the next element.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IEnumerator` 接口是 .NET 框架的一部分，因此这次你不需要从头开始创建它。该接口需要一个名为 `Current` 的属性，它返回迭代中的当前元素。所需的
    `MoveNext()` 方法是用于将迭代推进到下一个元素的机制。'
- en: '`IEnumerable` is another interface that comes with C#, so again, you don’t
    need to create it. It requires a method, `GetEnumerator()`, which is what provides
    an instance of our custom enumerator.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IEnumerable` 是 C# 中另一个接口，因此，你同样不需要自己创建它。它需要一个名为 `GetEnumerator()` 的方法，这个方法提供了我们自定义枚举器的实例。'
- en: A concrete iterator that implements the `IEnumerator` interface will have the
    collection in a `private` field with the class. Collections, and by extension
    iterators, work using generics, as indicated by `<T>`. This means they can adapt
    to any type, including any classes you create. The class has a constructor that
    takes a concrete collection. By this, we mean the collection you intend to iterate
    that was implemented in `ConcreteCollection`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `IEnumerator` 接口的具体迭代器将在类的 `private` 字段中拥有集合。集合，以及通过扩展迭代器，使用泛型工作，如 `<T>`
    所示。这意味着它们可以适应任何类型，包括你创建的任何类。该类有一个构造函数，它接受一个具体集合。通过这种方式，我们指的是在 `ConcreteCollection`
    中实现的打算迭代的集合。
- en: A concrete collection.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个具体集合。
- en: As described, a standard iterator just gives you a way to work through a collection.
    Every collection in C# – and there are many – has a common iterator that steps
    through the collection in order. Any time your business logic requires your iteration
    to be anything besides FIFO, it is best to encapsulate the algorithm in a custom
    iterator. We have reached one of those times. Maybe your iterator will have a
    novel algorithm for moving through the collection. A contrived example might be
    to have an iterator that only iterates on odd or even elements in the collection.
    Maybe you need an iterator that iterates strings in alphabetical order. Kitty’s
    problem is a real-world one – she needs the collection to be filtered and sorted
    based on paint requirements before a normal iteration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如所述，标准迭代器只是提供了一个遍历集合的方法。C# 中的每个集合——而且有很多——都有一个通用的迭代器，它按顺序遍历集合。任何时候你的业务逻辑需要你的迭代不是
    FIFO（先进先出）时，最好将算法封装在自定义迭代器中。我们已达到这样的时刻。也许你的迭代器将具有在集合中移动的独创算法。一个虚构的例子可能是一个只迭代集合中奇数或偶数元素的迭代器。也许你需要一个按字母顺序迭代字符串的迭代器。Kitty
    的问题是现实世界的问题——她需要在正常迭代之前根据油漆要求过滤和排序集合。
- en: Applying the Iterator pattern
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用迭代器模式
- en: 'Let’s look at how Kitty applied the pattern, as shown in the following diagram.
    Please note that `IEnumerable` and `IEnumerator` are part of the .NET framework
    and do not require actual implementation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Kitty 如何应用这个模式，如下面的图所示。请注意，`IEnumerable` 和 `IEnumerator` 是 .NET 框架的一部分，不需要实际实现：
- en: '![Figure 5.4 – Kitty’s implementation of the Iterator pattern. ](img/B18605_Figure_5.4.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – Kitty 实现的迭代器模式](img/B18605_Figure_5.4.jpg)'
- en: Figure 5.4 – Kitty’s implementation of the Iterator pattern.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – Kitty 实现的迭代器模式。
- en: Iterators always have the same parts. Our concrete collection is called `OrderCollection`,
    which ultimately implements the C# `IEnumerable` interface via an abstract class
    called `IteratorAggregate`. The concrete iterator is a class called `PaintJobIterator`,
    which inherits from an abstract base class that will implement the requirements
    of the interface. The `PaintJobIterator` class contains the logic that will sort
    the collection based on the type of paint job. The custom jobs will be done last
    so that we can get our standard order bicycles shipped right away. Our customers
    are okay with waiting an extra day for their custom paint jobs, so those are done
    last.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器总是具有相同的部分。我们的具体集合称为 `OrderCollection`，它最终通过一个名为 `IteratorAggregate` 的抽象类实现了
    C# 的 `IEnumerable` 接口。具体的迭代器是一个名为 `PaintJobIterator` 的类，它继承自一个将实现接口要求的抽象基类。`PaintJobIterator`
    类包含根据油漆作业类型对集合进行排序的逻辑。自定义作业将最后完成，这样我们就可以立即发货标准订单自行车。我们的客户对等待额外一天以完成定制油漆作业是可以接受的，因此这些作业最后完成。
- en: The `OrderCollection` and `PaintJobIterator` classes inherit from the `IteratorAggregate`
    and `Iterator` base classes, respectively. These classes are just abstract classes
    that implement the respective interfaces. They are useful if you intend to create
    more than one custom iterator within your project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderCollection`和`PaintJobIterator`类分别从`IteratorAggregate`和`Iterator`基类继承。这些类只是实现相应接口的抽象类。如果你打算在项目中创建多个自定义迭代器，它们是有用的。'
- en: Coding the Iterator pattern
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写迭代器模式
- en: 'We’ve seen the code for the `BicycleOrder` class already. This contains a reference
    to another class called `Customer`, which is pretty much what you’d expect. Kitty
    used the `MailAddress` class from `System.Net.Mail`. Everything else is just strings:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`BicycleOrder`类的代码。这个类包含对另一个名为`Customer`的类的引用，这基本上是你所期望的。Kitty使用了`System.Net.Mail`中的`MailAddress`类。其余的都是字符串：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Remember that the `IEnumerator` and `IEnumerable` interfaces are part of the
    .NET framework from `System.Collections`, so we don’t code those. However, Kitty
    did opt to make abstract classes for them. The first is in the `Iterator.cs` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`IEnumerator`和`IEnumerable`接口是.NET框架中`System.Collections`的一部分，所以我们不需要编写这些代码。然而，Kitty选择为它们创建抽象类。第一个在`Iterator.cs`文件中：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is just an abstract class that implements the `IEnumerator` interface.
    Kitty has another for the `IEnumerable` interface in the `IteratorAggregate.cs`
    file. One method is required to comply with that interface:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实现`IEnumerator`接口的抽象类。Kitty在`IteratorAggregate.cs`文件中为`IEnumerable`接口创建了另一个。需要实现一个方法来符合该接口：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So far, this is just boilerplate code. Now, let’s move on to the good parts.
    The first part is the customized collection Kitty called `OrdersCollection`. This
    is just a wrapper around a `List<BicycleOrder>`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这只是一些样板代码。现在，让我们继续到好的部分。第一部分是Kitty自定义的集合，称为`OrdersCollection`。这只是一个`List<BicycleOrder>`的包装：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A simple parameterless constructor ensures we start with an empty list:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无参数的构造函数确保我们从空列表开始：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have a simple pass-through to the `Add` method of `List`. Pop quiz:
    does this look like another pattern we’ve covered already? Maybe the Decorator
    pattern?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的传递到`List`的`Add`方法。小测验：这看起来像我们已经覆盖过的另一个模式吗？可能是装饰者模式？
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s the magical part. When we implement our collection, we need the `GetEnumerator`
    method to return our custom iterator, which we haven’t written yet. We are overriding
    the abstract method in the abstract `IteratorAggregate` class mentioned earlier
    and we are returning `PaintOrderIterator`, as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是神奇的部分。当我们实现我们的集合时，我们需要`GetEnumerator`方法返回我们的自定义迭代器，我们还没有编写它。我们正在覆盖前面提到的抽象`IteratorAggregate`类中的抽象方法，并且我们返回`PaintOrderIterator`，如下所示：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we have the heart of this pattern – the actual iterator itself:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了这个模式的核心——实际的迭代器本身：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most of the contents in this class are implementations of the requirements
    expressed in the `IEnumerator` interface, which we express in the abstract `Iterator`
    class we saw earlier. First, we can see a `private` field that holds a reference
    to the `OrdersCollection` class we just saw:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的大部分内容是实现`IEnumerator`接口中表达的要求，我们在前面看到的抽象`Iterator`类中表达这些要求。首先，我们可以看到一个`private`字段，它持有我们刚刚看到的`OrdersCollection`类的引用：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As the iterator moves through the collection, we need to track its position:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代器在集合中移动时，我们需要跟踪其位置：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A constructor takes in `OrdersCollection` and sets the `private` field, as
    well as the initial position. The initial position starts at `-1` because we haven’t
    begun iterating yet and if we set it to `0`, we’d be indicating an actual position
    in the collection:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受`OrdersCollection`并设置`private`字段，以及初始位置。初始位置从`-1`开始，因为我们还没有开始迭代，如果我们将其设置为`0`，我们将指示集合中的实际位置：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We may need a way to get the private `_position` field. We’ll use a read-only
    `Key()` method for this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要一种方法来获取私有`_position`字段。我们将使用只读的`Key()`方法来完成此操作：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The iterator is invoked via a `foreach` loop, which invokes the `MoveNext()`
    method to move the iteration forward until it reaches the end of the collection:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器通过`foreach`循环被调用，该循环调用`MoveNext()`方法将迭代向前移动，直到达到集合的末尾：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The interface requires that have a way to reset the iterator position back
    to the beginning of the collection:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接口要求必须有一种方法可以将迭代器位置重置到集合的开始位置：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Current()` gives us the current iteration’s object in the collection. Don’t
    confuse this with the `Key()` method we saw a minute ago. `Key()` gives you the
    numeric index or the position, whereas `Current()` gives you the contents at the
    key’s position:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Current()` 给我们集合中当前迭代的对象。不要与一分钟前我们看到的 `Key()` 方法混淆。`Key()` 给你数字索引或位置，而 `Current()`
    给你键的位置的内容：'
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s our customization. All we’re doing here is reordering the collection
    before the iteration takes place. Kitty made two lists. One will hold `BicycleOrder`
    objects, where the class in the `PaintJob` property is a standard paint job, while
    the other will hold the custom paint job orders. When we have separated them,
    it is simply a matter of recombining the list with the custom jobs at the end:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的定制。我们在这里所做的只是迭代开始之前重新排序集合。Kitty 制作了两个列表。一个将包含 `BicycleOrder` 对象，其中 `PaintJob`
    属性中的类是标准喷漆工作，而另一个将包含定制喷漆订单。当我们将它们分开后，简单地重新组合带有定制工作的列表即可：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you remember when we built this during our coverage of the Bridge pattern,
    standard one-color paint jobs are expressed with the `IPaintJob` interface. Then
    again, so are custom paint jobs. Our custom paint job was defined in the `CustomGradientPaintJob`
    class, which is a different implementation of `IPaintJob`. Kitty used an abstract
    class in between the `IPaintJob` interface and the actual implementation. The
    intermediary class is called `CustomGradientPaintJob`, which means we can detect
    the base class of the paint job and act accordingly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们在桥接模式覆盖期间构建这个类的时候，标准单色喷漆工作是用 `IPaintJob` 接口表示的。同样，定制喷漆工作也是。我们的定制喷漆工作是在
    `CustomGradientPaintJob` 类中定义的，它是 `IPaintJob` 的不同实现。Kitty 在 `IPaintJob` 接口和实际实现之间使用了一个抽象类。这个中间类被称为
    `CustomGradientPaintJob`，这意味着我们可以检测喷漆工作的基类并根据情况采取行动：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have a list of regular paint orders and a list of custom paint
    orders, we can replace the contents of the original `orders` list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了常规喷漆订单列表和定制喷漆订单列表，我们可以替换原始 `orders` 列表的内容：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we can add the standard orders back in:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将标准订单重新添加进去：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is followed by the custom paint orders:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这后面跟着定制喷漆订单：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Done! Now, all Kitty needs is a quick program to test with in `Program.cs`.
    When I say *quick*, it’s a few lines long because we need to create all the parts
    in the test program, including the customer, the bikes, the order list, and the
    custom iterator via a `foreach` loop. Remember that we’re pulling in some classes
    from different packages. The `Customer` class uses `System.Net.Mail`, which is
    part of the .NET framework. The bicycles are going to be from `BumbleBikesLibrary.PaintableBicycles`,
    while the paint jobs are going to be from `BumbleBikesLibrary.PaintableBicycle.CommonPaintJobs`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，Kitty 需要一个快速程序来在 `Program.cs` 中进行测试。当我说是“快速”的时候，它只有几行长，因为我们需要在测试程序中创建所有部分，包括客户、自行车、订单列表以及通过
    `foreach` 循环创建的自定义迭代器。记住，我们正在从不同的包中引入一些类。`Customer` 类使用 `System.Net.Mail`，它是 .NET
    框架的一部分。自行车将来自 `BumbleBikesLibrary.PaintableBicycles`，而喷漆工作将来自 `BumbleBikesLibrary.PaintableBicycle.CommonPaintJobs`：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An iterator needs something to iterate, so let’s make our empty `OrdersCollection`
    class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器需要一些可以迭代的内容，所以让我们创建一个空的 `OrdersCollection` 类：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we need a customer. In real life, there would be several, but for our
    example, we’ll just use one:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个客户。在现实生活中，可能会有几个，但为了我们的示例，我们只使用一个：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we need bicycles to put in the orders. Let’s not waste time and make one
    with a custom paint job! This way, we know there’s one at the front of the list.
    When the iterator reorders the list, all these should be at the end:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要自行车来放入订单。让我们不要浪费时间，制作一辆带有定制喷漆工作的自行车！这样，我们知道列表前面有一辆。当迭代器重新排序列表时，所有这些都应该在最后：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once you have a bicycle with a paint job and a customer, you can make an order
    and add it to the `orders` list:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一辆带有喷漆和客户的自行车，你就可以创建一个订单并将其添加到 `orders` 列表中：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, let’s do the same thing with some standard paint jobs that will wind
    up at the front of the list when we iterate. First, let’s add a turquoise cruiser
    bike:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们对一些标准喷漆工作做同样的事情，当我们在迭代时，这些工作将出现在列表的前面。首先，让我们添加一辆青绿色巡航自行车：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How about a white road bike?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一辆白色公路自行车呢？
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To keep things interesting, let’s add another custom bike. This time, we’ll
    add a recumbent model with a custom gradient paint job:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持有趣，让我们再添加一辆定制自行车。这次，我们将添加一辆带有定制渐变喷漆的躺式自行车：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here’s a standard red road bike:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的红色公路自行车：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That should be enough for a meaningful test.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足够进行有意义的测试。
- en: Trying out the new iterator
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试新的迭代器
- en: 'Now, let’s try out our iterator. If all goes well, this should look exactly
    like any of the iterations you see in C#:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试我们的迭代器。如果一切顺利，这应该看起来就像你在C#中看到的任何迭代一样：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `foreach` loop is almost anti-climactic, isn’t it? That’s how we know we
    did a good job. You can’t tell that our custom iterator is any different from
    any of the common iterators that ship with C# or .NET. The regular `foreach` loop
    contains the mechanism to pull out our custom iterator and use it to move through
    the collection via the `MoveNext()` and `Current` methods we have in our concrete
    classes. When Kitty runs the test program, she can see what we’d hoped for:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`循环几乎没有什么悬念，不是吗？这就是我们知道我们做得好的原因。你无法分辨出我们的自定义迭代器与C#或.NET中提供的任何常见迭代器有何不同。常规的`foreach`循环包含了提取我们的自定义迭代器并使用它通过`MoveNext()`和`Current`方法（我们具体类中拥有的方法）在集合中移动的机制。当Kitty运行测试程序时，她可以看到我们希望看到的结果：'
- en: '![Figure 5.5 – Kitty’s test run of her custom iterator. ](img/B18605_Figure_5.5.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – Kitty对她自定义迭代器的测试运行](img/B18605_Figure_5.5.jpg)'
- en: Figure 5.5 – Kitty’s test run of her custom iterator.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – Kitty对她自定义迭代器的测试运行。
- en: As Kitty learned, the Iterator pattern is one of the most important patterns
    in our daily work. It isn’t very complex, despite having a few different parts.
    You can use this pattern any time you need to process any kind of collection in
    a manner other than the standard FIFO processing order.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Kitty学到的，迭代器模式是我们日常工作中最重要的模式之一。尽管有几个不同的部分，但它并不复杂。当你需要以不同于标准FIFO处理顺序的方式处理任何类型的集合时，你都可以使用这个模式。
- en: You should always be watching for chances to use this pattern. *Watching*… Hey,
    that reminds me of our next pattern!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该总是寻找机会使用这种模式。*寻找*…嘿，这让我想起了我们下一个模式！
- en: The Observer pattern
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Our worst fear is becoming a reality. Bumble Bikes has become so popular that
    Kitty and Phoebe are starting to have logistics problems. *“Don’t get me wrong,”*
    Phoebe said. *“This is a good problem to have. We could be more profitable if
    we could optimize our shipping costs. The hardest part is the first mile. How
    can we be more efficient at getting our bikes to a national shipper’s depot?”*
    Kitty arranged a **Zoom** call with *ExFed*, a small business owner who provides
    packing and shipping support as a service. Cathy, the *ExFed* representative near
    Phoebe’s factory in Dallas, and John, the representative based in Alpine, where
    Kitty’s factory was located, listened carefully to Bumble Bikes’ predicament.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最大的恐惧变成了现实。Bumble Bikes变得如此受欢迎，以至于Kitty和Phoebe开始遇到物流问题。“别误会我，”Phoebe说。“这是一个好问题。如果我们能优化我们的运输成本，我们可能会更有利可图。最难的部分是第一英里。我们如何能更有效地把自行车运到全国货运站的仓库呢？”Kitty安排了一个**Zoom**会议，与提供包装和运输支持作为服务的**ExFed**的小企业主进行了交流。Cathy是位于达拉斯的**ExFed**代表，John是位于Kitty工厂所在地的Alpine的代表，他们仔细听取了Bumble
    Bikes的困境。
- en: '*“The key to a good logistics workflow,”* Cathy said, *“is to make sure every
    time a truck leaves your factory, it’s full of bikes. When the truck comes back,
    it should be full of raw materials for the next batch of bikes.”* The girls had
    not considered the second part of what Cathy had explained. John concurred. The
    four worked out some details on the call after Phoebe had explained how her automated
    factory worked.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: “良好的物流工作流程的关键，”Cathy说，“是确保每次卡车离开你的工厂时，它都装满了自行车。当卡车回来时，它应该装满了为下一批自行车准备的原料。”女孩们还没有考虑到Cathy解释的第二部分。John表示同意。在Phoebe解释了她的自动化工厂是如何工作之后，四个人在电话中商讨了一些细节。
- en: '*“You’ve already got a signal going to your raw materials supplier that tells
    them when you consume the materials to make a bike,”* John pointed out. Cathy
    picked up on his train of thought and completed it. *“Right – all we’d need to
    do is get a signal to our systems that lets us know when you have a truckload
    of bicycles for us to pick up. Our trucks can take the bicycles to the national
    shipper’s depot where they ship out like any other freight.”*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: “你已经向原材料供应商发出了一个信号，告诉他们何时消耗材料来制作自行车，”John指出。Cathy接过了他的思路并完成了它。“对——我们需要的只是得到一个信号，让我们知道何时有一车自行车供我们取货。我们的卡车可以把自行车运到全国货运站的仓库，就像其他任何货运一样。”
- en: Phoebe said, *“No problem! We’ll just add another decorator class to our bicycle
    object.”* John and Cathy stared blankly at their respective cameras. *“Phoebe!
    They don’t speak* *nerd as we do!”* Kitty chided. *“Besides, that won’t work.
    The raw material usage is reported for every bicycle. We don’t want to send a
    pickup signal for every bicycle. That would be inefficient.”*
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比说：“没问题！我们只需在我们的自行车对象中添加另一个装饰器类。”约翰和凯西茫然地看着他们各自的摄像头。“菲比！他们说的不是我们说的*极客话*！”凯蒂责备道。“而且，那不会起作用。每辆自行车的原材料使用情况都会报告。我们不想为每辆自行车发送取货信号。那会效率低下。”
- en: '*“It would,”* John said. *“If you did that, you’d risk us leaving with a half-loaded
    truck. Based on the dimensions of your packaging, we need at least 10 bicycles
    in every load to make our service cost-effective.”*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: “如果那样做，你会，”约翰说，“我们可能会带着半满的卡车离开。根据你的包装尺寸，我们需要每批至少有 10 辆自行车才能使我们的服务具有成本效益。”
- en: '*“What we need,”* Kitty began, *“is something that sends a signal when there
    are at least 10 bicycles ready to be picked up.”*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: “我们需要的是，”凯蒂开始说，“当至少有 10 辆自行车准备好被取走时，能够发送信号的某种东西。”
- en: '*“Right,”* said Cathy. *“You need to have someone at the end of the assembly
    line count the bicycles and when they get 10, click a button on our website. After
    that, it will take about 30 minutes to get the truck to your dock.”*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: “好吧，”凯西说，“你需要有人在装配线的末端数自行车，当它们达到 10 辆时，在我们的网站上点击一个按钮。之后，大约需要 30 分钟才能把卡车开到你的码头。”
- en: Phoebe rolled her eyes imperceptibly. Her sister smirked. Think about all those
    *normal* people in the world who don’t speak nerd, and don’t understand software
    automation. What difficult and unfulfilled lives they must lead! Phoebe and Kitty
    knew they were going to find a way to automate their supply requests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比不露痕迹地翻了个白眼。她的妹妹轻蔑地笑了笑。想想世界上所有那些不会说“极客话”且不理解软件自动化的“普通人”，他们过着多么艰难和未满足的生活！菲比和凯蒂知道他们一定会找到一种自动化他们的供应请求的方法。
- en: '*“But during that delay,”* continued Phoebe, *“we’ve probably made another
    5 to 10 bicycles. Is that a problem?”*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: “但是在这段时间里，”菲比继续说，“我们可能又制造了 5 到 10 辆自行车。这有问题吗？”
- en: '*“No,”* said John. *“We need just a minimum of 10.”*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: “不，”约翰说，“我们只需要至少 10 辆。”
- en: John and Cathy dropped off the call with a list of to-dos and a virtual handshake
    deal to handle Bumble Bikes’ first-mile logistics. Kitty and Phoebe stayed on
    Zoom and continued brainstorming. *“Cathy said we needed someone to count bicycles
    as they come off the assembly line. I don’t want to pay someone to just sit around
    and observe.”*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰和凯西挂断了电话，列出了待办事项清单，并通过虚拟握手达成了一项处理 Bumble Bikes 首公里物流的协议。凯蒂和菲比继续在 Zoom 上进行头脑风暴。“凯西说我们需要有人在自行车从装配线下来时进行计数。我不想付钱给某人只是坐着观察。”
- en: '*“That’s it! Kitty, you’re a genius!”* Phoebe exclaimed. Kitty beamed quizzically.
    She wasn’t sure what she’d done to merit this rare moment of sisterly praise.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: “就这样了！凯蒂，你真是个天才！”菲比大声说道。凯蒂带着疑惑的笑容。她不确定自己做了什么值得这种罕见的姐妹赞扬。
- en: 'Phoebe realized this situation was calling for the **Observer pattern**. Cathy
    had envisioned a person observing the process and reacting when the bicycle count
    reached a minimum of 10 bicycles. To automate this, the girls will have to write
    software that can *observe* the production process and generate a signal to the
    logistics company when the requisite bicycle inventory has been reached. A generic
    diagram of the Observer pattern is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比意识到这种情况需要的是**观察者模式**。凯西设想了一个人在自行车计数达到至少 10 辆时观察过程并做出反应。为了自动化这个过程，女孩们将不得不编写能够**观察**生产过程并在达到所需的自行车库存时向物流公司发出信号的软件。观察者模式的通用图示如下：
- en: '![Figure 5.6 – The Observer pattern ](img/B18605_Figure_5.6.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 观察者模式](img/B18605_Figure_5.6.jpg)'
- en: Figure 5.6 – The Observer pattern
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 观察者模式
- en: 'There are two basic parts to the Observer pattern – a **subject** and one or
    more **observers**. Let’s review the different parts of the pattern, which have
    been numbered appropriately:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式有两个基本部分——一个**主题**和一个或多个**观察者**。让我们回顾一下模式的各个部分，它们已经被适当地编号：
- en: An interface describes the method requirement of the observer. This interface
    defines a public `Update()` method. `Update()` is called whenever the observer
    “sees” something interesting happen in the object it is observing.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口描述了观察者的方法要求。该接口定义了一个公共的 `Update()` 方法。每当观察者“看到”它所观察的对象中发生有趣的事情时，就会调用 `Update()`
    方法。
- en: Our concrete observer contains the implementation logic for the behavior that
    happens when the observer “sees” some interesting change in the subject’s state.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的观察者具体实现逻辑包含了当观察者“看到”主题状态中的一些有趣变化时发生的行为。
- en: The subject is doing some useful piece of work and maintains its state while
    the observer waits. Note that the observers are contained inside a collection
    within the subject. Also, note that the `state` property is `private`. We’ll need
    some way to let the observers know something interesting happened. For this, we
    have a function called `Notify()`. When a triggering condition takes place, the
    `Notify()` method can iterate over each attached observer and call its `Update()`
    method.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主题在进行一些有用的工作并保持其状态的同时，观察者在等待。请注意，观察者包含在主题内的一个集合中。另外，请注意`state`属性是`private`的。我们需要一种方式让观察者知道发生了有趣的事情。为此，我们有一个名为`Notify()`的函数。当触发条件发生时，`Notify()`方法可以遍历每个附加的观察者并调用其`Update()`方法。
- en: The whole process is invoked by some larger program we’ll call *the client*.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个过程由我们称之为“客户端”的更大程序调用。
- en: Applying the Observer pattern
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用观察者模式
- en: 'Kitty brings up Zoom’s whiteboard and they collaborate on their implementation
    of the Observer pattern that will solve this problem, as shown in the following
    diagram:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂打开Zoom的白板，他们合作实现了观察者模式，以解决以下图表所示的问题：
- en: '![Figure 5.7 – Phoebe and Kitty’s implementation of the Observer pattern that
    can signal ExFed’s trucks to pick up an order of bicycles. ](img/B18605_Figure_5.7.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 菲比和凯蒂实现的观察者模式，该模式可以发出信号让ExFed的卡车取走一批自行车。](img/B18605_Figure_5.7.jpg)'
- en: Figure 5.7 – Phoebe and Kitty’s implementation of the Observer pattern that
    can signal ExFed’s trucks to pick up an order of bicycles.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 菲比和凯蒂实现的观察者模式，该模式可以发出信号让ExFed的卡车取走一批自行车。
- en: This one is pretty simple – we need a subject and an observer. The girls used
    an interface, `ILogisticsObserver`, to prevent tight coupling between the `LogisticsSubject`
    class and the concrete observer class called `ExFedObserver`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单——我们需要一个主题和一个观察者。女孩们使用了一个接口，`ILogisticsObserver`，以防止`LogisticsSubject`类和名为`ExFedObserver`的具体观察者类之间的紧密耦合。
- en: Once they had drawn the diagram, they each opened their favorite IDE, which
    contains a collaborative coding feature. This means the girls can code together
    as though they were sitting next to each other.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们画出了图表，他们各自打开了他们最喜欢的IDE，该IDE包含协作编码功能。这意味着女孩们可以像坐在彼此旁边一样一起编码。
- en: Coding the Observer pattern
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码观察者模式
- en: 'Phoebe makes short work of the `ILogisticsObserver` interface:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比轻松处理了`ILogisticsObserver`接口：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Kitty follows up with a concrete observer that consumes Phoebe’s interface:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂随后添加了一个具体观察者，该观察者消费了菲比的接口：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: I left out the actual API call because Kitty and Phoebe were worried that I
    might accidentally reveal their API key. As we all know, only amateurs check API
    keys into GitHub, and the code won’t work without it, so I put it in a `Console.WriteLine`
    statement as a substitute.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了实际的API调用，因为凯蒂和菲比担心我可能会不小心泄露他们的API密钥。众所周知，只有业余爱好者会将API密钥提交到GitHub，没有它代码将无法工作，所以我将其放在一个`Console.WriteLine`语句中作为替代。
- en: 'The `LogisticsSubject` class is where the real action lies. It’s a little longer,
    so the girls work on it together:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogisticsSubject`类是真正的行动所在。它稍微长一些，所以女孩们一起工作：'
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Kitty adds a `List<ILogisticsObserver>` field to hold all the observers. She
    follows that with a typical constructor, which initializes the field:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂添加了一个`List<ILogisticsObserver>`字段来存储所有观察者。然后她跟着一个典型的构造函数，初始化该字段：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Phoebe adds an `Attach` method that allows us to add one or more observers,
    which are objects that conform to the `ILogisticObserver` interface:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比添加了一个`Attach`方法，允许我们添加一个或多个观察者，这些观察者是符合`ILogisticObserver`接口的对象：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Likewise, she also adds a method that can remove the observer from the list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，她还添加了一个可以从列表中删除观察者的方法：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Kitty realizes their testing will be easier if they have a way to see the observers
    in the list, so she adds a quick method to provide some output for the initial
    runs. The method simply prints the number of observers stored within the private
    `_logisticsObservers` field:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂意识到，如果他们有一种方法可以看到列表中的观察者，测试将会更容易。因此，她添加了一个快速方法来为初始运行提供一些输出。该方法简单地打印出存储在私有`_logisticsObservers`字段中的观察者数量：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, we need to notify our observers. The generic UML diagram specified
    a `Notify()` method. We called ours `NotifyPickupAvailable()`. It simply iterates
    through the observers and calls the `SchedulePickup()` method on each one in the
    list:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要通知我们的观察者。通用的UML图指定了一个`Notify()`方法。我们称之为`NotifyPickupAvailable()`。它简单地遍历观察者，并在列表中的每个观察者上调用`SchedulePickup()`方法：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Following her sister’s lead, Phoebe writes the test program in `Program.cs`.
    First, she creates an instance of `LogisticsSubject`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着姐姐的榜样，菲比在`Program.cs`中编写了测试程序。首先，她创建了一个`LogisticsSubject`的实例：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, she makes the observer and attaches it to the subject:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，她创建了观察者并将其附加到主题上：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, let’s simulate making 100 bikes. Each time we have 10, we’ll send a notification:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们模拟制造100辆自行车。每次我们有10辆，我们就会发送一个通知：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, Phoebe is just simulating a passage of time in an attempt to keep it
    a real simulation. She wishes her robots could build a bike in 3 seconds. After
    the delay, she writes out the bike with the `ToString` method and adds the bike
    to the `pickupOrder` list:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，菲比只是在模拟时间的流逝，试图保持这是一个真实的模拟。她希望她的机器人能在3秒内制造出一辆自行车。在延迟之后，她使用`ToString`方法写出了自行车，并将其添加到`pickupOrder`列表中：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our observer logic checks whether we have enough bikes. If so, it triggers
    the `NotifyPickupAvailable()` method, which loops through all the observers and
    calls their `SchedulePickup()` methods:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观察者逻辑检查我们是否有足够的自行车。如果有，它就会触发`NotifyPickupAvailable()`方法，该方法遍历所有观察者，并调用它们各自的`SchedulePickup()`方法：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the real world, 30 minutes would pass before a truck arrived at Bumble Bikes
    to take their inventory. However, no one wants to simulate that, so we’ll simply
    pretend we did and clear out the order:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，30分钟后，一辆卡车才会到达Bumble Bikes取走他们的库存。然而，没有人想模拟这个过程，所以我们只是假装我们完成了，并清除了订单：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When we are done making bikes for the day, we can detach. Phoebe understands
    the importance of work-life balance for her factory robots:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成一天的自行车制造后，我们可以断开连接。菲比理解工作与生活平衡对她工厂机器人的重要性：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As the girls’ software operation saw more and more patterns in use, the number
    of problems left to solve was dwindling rapidly. They were moving into the phase
    you’ll see in every software project, where the work shifts from developing new
    code to maintaining it. Usually, about this time, the senior developers start
    to get bored because all the big problems have been solved. Those developers must
    now make a choice: stick with the project or find another project with new challenges.
    That’s what happens in most software shops. Surely Phoebe, being the brilliant
    owner of a bicycle manufacturing startup, would never succumb to the temptations
    fostered by monotony?'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 随着女孩们的软件操作使用中发现了越来越多的模式，需要解决的问题数量迅速减少。他们进入了每个软件项目都会经历的阶段，工作从开发新代码转向维护它。通常，在这个时候，高级开发者开始感到无聊，因为所有的大问题都已经被解决了。这些开发者必须做出选择：继续留在项目中，还是寻找另一个有新挑战的项目。这就是大多数软件公司发生的事情。当然，菲比作为一家自行车制造初创公司的杰出老板，绝不会屈服于单调乏味的诱惑？
- en: The Strategy pattern
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: '*“I’m BORED!”* Phoebe yelled across the room at her sister. Kitty had come
    up from Alpine to go over some spreadsheets with Lexi, the head of accounting
    for Bumble Bikes. Phoebe and Lexi had been friends for many years, so when Phoebe
    had the chance to recruit her, she took it. Lexi, who was used to Phoebe’s peculiarities,
    smiled at Kitty, folded her laptop, and said, *“I’ll have this done for you tomorrow.”*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*“我无聊死了！”* 菲比对着房间另一边的姐姐大喊。凯蒂从阿尔卑斯山下来和Lexi一起审查一些电子表格，Lexi是Bumble Bikes的会计主管。菲比和Lexi已经相识多年，所以当菲比有机会招募她时，她毫不犹豫地接受了。Lexi习惯了菲比的古怪，对凯蒂笑了笑，合上笔记本电脑，说，*“我明天会帮你完成这件事。”*'
- en: As Lexi left the office, Phoebe flopped upside down on the couch, flipping through
    channels on the TV with the sound off. She wound up on channel 52,381, which was
    *The Bike Channel*. Bumble Bikes advertised heavily on this channel, and at that
    moment, a talking head was reviewing bike computers. A **bike computer** is an
    electronic device that reports your speed and distance traveled. Fancy models
    can keep track of your cadence, which is the pace at which you pedal. Some even
    track your heart rate and the electrical wattage produced by the effort a rider
    imposes on the pedals.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当莱克西离开办公室时，菲比倒扣在沙发上，关掉电视声音，翻看着频道。她最终调到了第52,381频道，也就是*自行车频道*。Bumble Bikes在这个频道上做了大量广告，此时，一个评论员正在评论自行车电脑。一个**自行车电脑**是一种报告你的速度和行驶距离的电子设备。高级型号可以追踪你的踏频，即你踩踏的节奏。一些甚至可以追踪你的心率以及骑手对踏板施加的力的电功率。
- en: Phoebe’s face was starting to turn red. She had been upside down too long and
    blood had rushed to her head. She flopped the rest of the way over and revealed
    that look she got when she had a million-dollar idea.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 菲的脸开始变红。她倒扣的时间太长了，血液涌到了头部。她完全翻过来，露出了当她有一个价值百万美元的想法时的那个表情。
- en: Her sister could see it without even looking at her. *“What?”* Kitty asked.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 她的妹妹甚至不用看她就能看出她的想法。*“什么？”* 基蒂问。
- en: Phoebe stared at the ceiling a little longer, her eyes flitting back and forth.
    She was inventing something in her mind. Kitty looked up and could see the wheels
    turning in Phoebe’s head.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比盯着天花板看了更长一段时间，她的眼睛来回移动。她在心里发明着什么。基蒂抬头看，能看到菲比头脑中的齿轮在转动。
- en: '*“Bike computers!”* Phoebe yelled at last. *“Why are they so boring? I mean
    really! All they do is tell jocks how great they are. Who needs a computer for
    that?”* It was an odd statement, but coming from Phoebe, it rated at most a 4
    on a scale from 1 being something such as a pizza order to 10, which might be
    a non-sequitur completion of an engineering problem she’d given up on privately
    a week prior.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*“自行车电脑！”* 菲比最后大喊道。*“它们为什么这么无聊？我是说真的！它们所做的只是告诉那些自行车爱好者他们有多棒。谁需要电脑来做这个？”* 这句话有点奇怪，但出自菲比之口，在1到10的评分中最多只有4分，1分可能是像订购披萨这样的小事，10分可能是她私下里已经放弃的工程问题的非连续性完成。'
- en: '*“What if a bike computer did something cool, like what we have with our car
    computers? Sure, it would be track speed, distance, wattage, and whatever jocks
    pay for in a bike computer. but It would also have navigation routes, trail, and
    road conditions. This is information a rider would want to know and have so that
    they can complete their next epic ride,”* Phoebe blurted. This was usually the
    part where Phoebe ran to her lab and ordered a stack of pizzas and fizzy water.
    Then, she would disappear for a few days. The sister’s recent success gave the
    girls the ability to move their labs to their respective factories. Phoebe’s lab
    had a bathroom and a bed that stretched between the far wall and what looked like
    a *Van de Graaff* generator. *“Why does she need that?”* Kitty thought silently.
    She’d long since given up asking out loud. The bed, covered in pizza boxes from
    previous engineering adventures, appeared to have never been slept in.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*“如果一辆自行车电脑能做一些酷炫的事情，就像我们汽车电脑那样？当然，它可能会追踪速度、距离、功率，以及那些自行车爱好者愿意为自行车电脑支付的一切。但它还会提供导航路线、小径和路况。这是骑手们想要了解和拥有的信息，以便他们能够完成下一次史诗般的骑行，”*
    菲比脱口而出。这通常是菲比跑到她的实验室，订购一摞披萨和汽水的时候。然后，她会消失几天。姐妹俩最近的成功让她们有能力将实验室搬到各自的工厂。菲比的实验室里有一个浴室和一张从远墙到看起来像范德格拉夫发生器的床。*“她为什么需要那个？”*
    基蒂默默地想。她早已放弃大声询问。那张床，铺满了之前工程冒险中的披萨盒子，看起来似乎从未有人睡过。'
- en: Kitty didn’t respond to her sister’s question concerning the use of a bike computer.
    She knew it was a question that wasn’t meant to be answered. When Kitty came in
    the next morning, she noticed a stack of discarded pizza boxes and empty cans
    of fizzy water littered throughout the office. A small black box was mounted to
    a handlebar assembly on Phoebe’s workbench. Phoebe was asleep in her lab.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 基蒂没有回应她姐姐关于自行车电脑用途的问题。她知道这是一个不应该被回答的问题。当基蒂第二天早上进来时，她注意到办公室里到处都是丢弃的披萨盒子和空汽水瓶。一个黑色的小盒子被安装在了菲比工作台上的把手组件上。菲比在她的实验室里睡着了。
- en: 'Curious, Kitty fiddled with the buttons on the box’s apparent interface. Phoebe
    had made a small computer with some sensors attached. Kitty was able to find the
    navigation feature that had captured Phoebe’s imagination. It was crudely designed,
    but functional. *“Hey, sis,”* Phoebe muttered sleepily. *“It’s not working yet.
    I’m stuck on the navigation.”* Phoebe’s head flopped back down on the pillow.
    Kitty continued fiddling with the navigation. She saw the problem: the UI on the
    navigation allowed you to pick from several kinds of terrains. You could search
    for routes on paved roads, gravel trails, or mountain trails. However, the search
    results consistently showed only paved roads. It was easy to figure out why.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的小猫摆弄着盒子表面的按钮。菲比制作了一个带有一些传感器的迷你电脑。小猫能够找到吸引菲比想象力的导航功能。设计得很简陋，但功能齐全。*“嘿，姐姐，”*菲比含糊地咕哝着。*“它还没工作。我卡在导航上了。”*菲比的头又重重地倒在枕头上。小猫继续摆弄导航。她发现了问题：导航界面上允许你选择几种不同的地形。你可以搜索铺砌道路、砾石小径或山地小径的路线。然而，搜索结果始终只显示铺砌道路。原因很容易理解。
- en: Phoebe was leveraging well-known GPS APIs to compute her route. Naturally, these
    were favoring paved roads. Phoebe was able to create a façade for the API and
    a decorator that slightly altered the default behavior so that the API stayed
    away from recommending busy highways, even when they were the most direct route.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 菲比正在利用知名的GPS API来计算她的路线。自然，这些API倾向于推荐铺砌的道路。菲比能够创建一个API的伪装和一个装饰器，稍微改变了默认行为，使得API不会推荐繁忙的高速公路，即使它们是最直接的路线。
- en: For the next few hours, Kitty researched alternative mapping APIs that would
    focus more on the roads less traveled and gave preference to those inaccessible
    to cars. She found that each time she added different APIs and pathfinding algorithms,
    her code started to become complex. She could easily see the beginnings of a big
    ball of mud on her growing plate of spaghetti.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小时里，小猫研究了替代的地图API，这些API更关注那些少有人走的道路，并优先考虑那些汽车无法到达的地方。她发现，每次她添加不同的API和路径查找算法，她的代码就开始变得复杂。她很容易看到在她不断增长的意大利面盘上，一个巨大的泥球正在形成。
- en: 'After some refactoring and some thinking, she settled upon a strategy that
    should work. Spoiler alert: *strategy* is the name of the pattern she used. This
    pattern is easy to explain because the pattern means the same thing as the word
    *pattern* means in plain English. If you’re trying to achieve a complicated objective,
    you create a strategy. In software engineering, the Strategy pattern refers to
    working with a set of algorithms flexibly and interchangeably. An *algorithm*
    is simply a set of steps you can follow to solve a problem that gives a consistent
    result within a reasonable amount of time. If you were to create an algorithm
    to create a peanut butter and jelly sandwich, the steps would be simple:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番重构和思考，她确定了一个应该可行的策略。剧透一下：*策略*就是她使用的模式的名字。这个模式很容易解释，因为模式的意思和英文中*pattern*这个词的意思是一样的。如果你试图实现一个复杂的目标，你就可以制定一个策略。在软件工程中，策略模式指的是灵活且可互换地处理一组算法。*算法*简单来说就是一组你可以遵循的步骤，用以在合理的时间内解决问题，并给出一致的结果。如果你要创建一个制作花生酱果酱三明治的算法，步骤将会很简单：
- en: Put two slices of bread on a plate.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在盘子上放两片面包。
- en: Open the peanut butter.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开花生酱。
- en: Using a dull knife, spread peanut butter on one side of one slice of bread.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一把钝刀，在一片面包的一侧涂上花生酱。
- en: Close the peanut butter jar.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭花生酱罐。
- en: Open the jelly.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开果酱。
- en: Using a different dull knife (don’t you hate it when someone uses the same knife
    and gets peanut butter in your jelly?), spread some jelly on one side of the second
    slide of bread.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用另一把钝刀（你不喜欢别人用同一把刀，结果果酱弄到了你的果酱上吧？），在第二片面包的另一侧涂上一些果酱。
- en: Close the jelly jar.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭果酱罐。
- en: Place the first slice of bread on top of the second so that the peanut butter
    and jelly meet between the slices of bread.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把第一片面包放在第二片面包上，让花生酱和果酱在面包片之间相遇。
- en: That’s an algorithm. If you follow that algorithm, I can guarantee that you’ll
    always wind up with a peanut butter and jelly sandwich. This algorithm can be
    completed in a few minutes, which to me, is a reasonable amount of time. I could
    easily make a second algorithm to make a turkey sandwich, and another to make
    a cheese sandwich. If I encapsulate each algorithm using a common interface, I
    can choose a sandwich-making strategy based on what kind of sandwich I desire.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个算法。如果你遵循这个算法，我可以保证你最终会得到一个花生酱果酱三明治。这个算法可以在几分钟内完成，对我来说，这是一个合理的时间。我可以轻松地制作第二个算法来制作火鸡三明治，再制作一个来制作奶酪三明治。如果我用一个公共接口封装每个算法，我就可以根据我想要的哪种三明治来选择三明治制作策略。
- en: Kitty has a situation where she needs an algorithm to get from point A to point
    B. She needs three different strategies, which are coded as three different algorithms.
    The first algorithm will find a path strictly on paved roads. The second will
    try to make use of gravel or unpaved roads. The third will find a path with no
    roads at all, but that is otherwise passable on a bicycle. She needs these routes
    from A to B to follow a common interface, and she needs the algorithms themselves
    to follow a common interface so that she can swap them as appropriate.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty有一个需要算法从A点到B点的情况。她需要三种不同的策略，这些策略被编码为三个不同的算法。第一个算法将在铺砌的道路上找到一条路径。第二个将尝试使用砾石或未铺砌的道路。第三个将找到一条完全没有道路但可以用自行车通行的路径。她需要从A到B的这些路线遵循一个公共接口，并且她需要算法本身遵循一个公共接口，这样她就可以根据需要交换它们。
- en: 'We can express this with UML, as shown in the following diagram:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用UML来表示，如下面的图表所示：
- en: '![Figure 5.8 – The Strategy pattern. ](img/B18605_Figure_5.8_New.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 策略模式](img/B18605_Figure_5.8_New.jpg)'
- en: Figure 5.8 – The Strategy pattern.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 策略模式。
- en: 'Let’s review the different parts of the pattern, which have been numbered appropriately:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下模式的各个部分，它们已经被适当编号：
- en: The `IStrategy` interface defines a method that implements your algorithm. In
    our case, it will be called `Run`, and we can pass in any data the algorithm may
    need, such as the geospatial coordinates of your starting and ending locations.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IStrategy`接口定义了一个实现你的算法的方法。在我们的例子中，它将被命名为`Run`，我们可以传递算法可能需要的任何数据，例如起始和结束位置的地理坐标。'
- en: A concrete strategy object that implements the `IStrategy` interface will implement
    your algorithm.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个具体的策略对象，实现了`IStrategy`接口，将实现你的算法。
- en: A context object holds the strategy and can execute it with some method. We
    have called ours `DoBehavior()`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个上下文对象持有策略并可以使用某种方法执行它。我们称之为`DoBehavior()`。
- en: The key here is that all the algorithms follow the `IStrategy` interface. This
    means I can pass any algorithm contained in a concrete strategy object containing
    a `Run` method to invoke the algorithm. At this point, the algorithms are interchangeable.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于所有算法都遵循`IStrategy`接口。这意味着我可以传递任何包含`Run`方法的策略对象中的算法来调用算法。在这个时候，算法是可以互换的。
- en: Applying the Strategy pattern
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用策略模式
- en: 'Kitty comes up with a diagram for her implementation, as shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty为她自己的实现提出了一个图表，如下所示：
- en: '![Figure 5.9 – Kitty’s drawing of their implementation of the Strategy pattern.
    ](img/B18605_Figure_5.9.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – Kitty对策略模式实现的绘图](img/B18605_Figure_5.9.jpg)'
- en: Figure 5.9 – Kitty’s drawing of their implementation of the Strategy pattern.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – Kitty对策略模式实现的绘图。
- en: Kitty looked over at Phoebe who was in a deep sleep. Maybe with the Strategy
    pattern, she could fix up this software before she wakes up.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty看了看正在深度睡眠中的Phoebe。也许通过策略模式，她可以在她醒来之前修复这个软件。
- en: Coding the Strategy pattern
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码策略模式
- en: 'Phoebe already had the data structures at the bottom of the diagram. She had
    typed `INavigationRoute`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Phoebe已经在图表的底部有了数据结构。她输入了`INavigationRoute`：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'She also had a concrete `NavigationRoute` class. Unfortunately, Karina, the
    attorney representing Bumble Bikes, will not allow me to show this part of the
    code. That’s okay. We’re here for the pattern. Neither the interface nor the class
    is part of the pattern. They’re just structures used in the implementation. In
    place of Kitty’s highly proprietary data structure, I’ll give you a simple string:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 她还有一个具体的`NavigationRoute`类。不幸的是，代表Bumble Bikes的律师Karina不允许我展示这部分代码。没关系。我们在这里是为了模式。接口和类都不是模式的一部分。它们只是实现中使用的结构。代替Kitty高度专有的数据结构，我将给你一个简单的字符串：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let’s move on to the code that is part of the strategy. We’ll start with the
    `INavigationStrategy` interface. This interface is used to conform your algorithms
    to a common structure so that they can become interchangeable:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到策略的一部分代码。我们将从`INavigationStrategy`接口开始。此接口用于使你的算法符合一个通用结构，以便它们可以互换：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As mentioned previously, Kitty needs three concrete implementations. The first
    is for finding routes on paved roads. Phoebe had this one working, so Kitty simply
    refactored it to fit the interface:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kitty需要三个具体实现。第一个是用于在铺砌道路上寻找路线。Phoebe已经实现了这个功能，所以Kitty只是重构了它以适应接口：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, Kitty created an algorithm to find gravel road routes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Kitty创建了一个算法来寻找砾石道路路线：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At this point, I predict you will not be surprised by the third implementation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我预测你不会对第三个实现感到惊讶：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The only thing left is the `NavigationContext` class:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是`NavigationContext`类：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Kitty used a simple property to hold her navigation strategy. Naturally, she
    declared the interface, not a concrete object:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty使用一个简单的属性来保存她的导航策略。自然地，她声明了接口，而不是一个具体对象：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next is a standard constructor. She set the default to a road navigation strategy
    since that is the default for Phoebe’s device:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个标准的构造函数。她将默认值设置为道路导航策略，因为这是Phoebe设备的默认设置：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, we have a method to start the algorithms on finding the path we’re
    looking for based on the current strategy in the `NavigationStrategy` property:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个方法来根据`NavigationStrategy`属性中的当前策略启动寻找我们正在寻找的路径的算法：
- en: '[PRE68]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There was a lot of cool business logic here. Eventually, Kitty generates the
    route using the strategy:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多酷的业务逻辑。最终，Kitty使用策略生成路线：
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Honestly, this is the most innovative set of algorithms I have ever seen. Too
    bad the lawyers got involved. However, we did get to see the pattern, which turned
    out to be very simple compared to some of the more complicated patterns we’ve
    seen.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 实话实说，这是我见过的最具创新性的算法集。遗憾的是律师介入了。然而，我们确实看到了这个模式，它最终证明与一些更复杂的模式相比非常简单。
- en: The Strategy pattern is used when you need to be able to choose from a set of
    related algorithms all aimed at a common objective. Whether it’s making sandwiches
    or devising a novel set of interchangeable geospatial pathfinding algorithms,
    using a Strategy pattern will help keep your code maintainable and easy to read.
    Kitty can easily add more algorithms as she thinks of them, without breaking any
    of the existing strategies.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要从一组相关算法中选择，这些算法都旨在实现一个共同目标时，就会使用策略模式。无论是制作三明治还是设计一套可互换的地理空间路径查找算法，使用策略模式将有助于保持你的代码可维护和易于阅读。Kitty可以轻松地添加更多算法，而不会破坏任何现有的策略。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Behavioral patterns work with algorithms in ways that keep your software manageable.
    In this chapter, we looked at four very useful and popular patterns that can be
    employed to solve a variety of design problems.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式以保持软件可管理的方式与算法协同工作。在本章中，我们探讨了四种非常有用且流行的模式，这些模式可以用于解决各种设计问题。
- en: The Command pattern can be used to isolate instructions from the objects responsible
    for executing them. This is one of the most common causes of the antipatterns
    we discussed in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016), *There’s a Big
    Ball of Mud on Your Plate of Spaghetti*. Tightly coupling logic with concrete
    structures yields software that is brittle and prone to grow in complexity. The
    Command pattern will help you avoid this trap.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式可以用来隔离指令与执行它们的对象。这是我们在[*第一章*](B18605_01.xhtml#_idTextAnchor016)，“你的意大利面盘上有一个大泥球”中讨论的反模式之一。将逻辑与具体结构紧密耦合会导致软件脆弱且易于复杂化。命令模式将帮助你避免这个陷阱。
- en: The Iterator pattern is used any time you need to iterate over a collection
    in some manner not handled by the standard .NET iterator. This pattern works with
    a collection and starts with the first item before iterating in a straight line
    to the last. This can take the form of manipulating the collection before processing,
    or it might be a novel way of moving through the collection to meet a business
    requirement. Some of the basic building blocks for this pattern are built into
    the .NET framework within the `System.Collections` namespace. Before building
    an iterator, you should check if one already exists.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式在需要以某种方式迭代集合，而这种方式不是由标准的.NET迭代器处理时使用。这个模式与一个集合一起工作，从第一个项目开始，然后直线迭代到最后一个项目。这可能是在处理之前操纵集合，或者可能是一种新颖的移动方式以满足业务需求。这个模式的一些基本构建块已经内置到.NET框架的`System.Collections`命名空间中。在构建迭代器之前，你应该检查是否已经存在一个。
- en: The Observer pattern consists of a subject and one or more observers. The subject
    notifies the observers of a particular trigger condition within the subject’s
    state. The Observer pattern is widely used with a myriad of applications. Many
    software developers who have used event listeners have seen and understand the
    power of this technique.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式由一个主题和一个或多个观察者组成。主题通知观察者主题状态中的特定触发条件。观察者模式广泛应用于众多应用中。许多使用过事件监听器的软件开发者都见识过并理解了这种技术的力量。
- en: The last pattern we discovered was the Strategy pattern. We use the Strategy
    pattern any time we have a set of algorithms with a common purpose. The Strategy
    pattern works by conforming the algorithms to a common interface that is injected
    into a context. Then, the algorithms can be used interchangeably as business needs
    require.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后发现的模式是策略模式。当我们有一组具有共同目的的算法时，我们使用策略模式。策略模式通过将算法符合一个共同的接口来实现，该接口被注入到上下文中。然后，根据业务需求，算法可以互换使用。
- en: In the next chapter, a fateful turn of events will force Kitty and Phoebe to
    enlist the help of a stranger. Bumble Bikes began as a passion project and turned
    into a business venture, but it will quickly become a humanitarian outreach. Too
    few software developers, engineers, and architects understand they have a superpower
    that can change the world. The stakes are high, and Kitty and Phoebe are stretched
    too thin. They need someone who understands SOLID principles and patterns to head
    up a very important project. Will this understated stranger be up to the task?
    Would you be?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，一系列命运多舛的事件将迫使Kitty和Phoebe寻求一个陌生人的帮助。Bumble Bikes最初是一个激情项目，后来变成了一项商业冒险，但它很快将变成一项人道主义援助。太多的软件开发者、工程师和架构师没有意识到他们拥有可以改变世界的超能力。赌注很高，Kitty和Phoebe的压力太大。他们需要一个理解SOLID原则和模式的人来领导一个非常重要的项目。这个低调的陌生人能够胜任这项任务吗？你会吗？
- en: Questions
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: Which pattern is used to make algorithms with a common purpose interchangeable
    within a context?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个上下文中，哪种模式用于使具有共同目的的算法可互换？
- en: Which pattern is used to encapsulate and send instructions to a receiver, while
    avoiding tight coupling between the data needed to execute the instruction and
    the logic that executes the instruction?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种模式用于封装并发送指令到接收者，同时避免执行指令所需的数据和执行指令的逻辑之间的紧密耦合？
- en: Which pattern involves a *subject* and an *observer*? Please note that if you
    miss this question, it will go on your permanent record.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种模式涉及一个*主题*和一个*观察者*？请注意，如果你错过这个问题，它将记录在你的永久记录中。
- en: Which pattern is used to process collections in a way other than FIFO?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种模式用于以非FIFO的方式处理集合？
- en: What two interfaces from the .NET framework are useful when implementing the
    Iterator pattern?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现迭代器模式时，.NET框架中有哪两个接口是有用的？
- en: '![](img/part-3-version-2.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/part-3-version-2.jpg)'
- en: 'Part 3: Designing New Projects Using Patterns'
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：使用模式设计新项目
- en: 'Having learned about some patterns, let’s take a look at the design process.
    So far, we’ve been making things up as we go along. How much easier would things
    be, and how many problems could we avoid, if we took a step back first and designed
    our project with patterns and UML instead of diving into the code? This section
    works through a new project from this perspective. We will design the new project
    purely as a set of diagrams first in [*Chapter 6*](B18605_06.xhtml#_idTextAnchor110),
    *Step Away from the IDE! Designing with Patterns Before you Code*. Then, we will
    implement the project in [*Chapter 7*](B18605_07.xhtml#_idTextAnchor136), *Nothing
    Left but the Typing: Implementing the Wheelchair Project*. The final chapter wraps
    up the book and aims to show you there are more patterns out there. In fact, they’re
    everywhere! There are development patterns beyond the usual Gang of Four sets
    and even more beyond the realm of **Object-Oriented Programming** (**OOP**). You’ll
    even learn the documentation process for creating and publishing your very own
    patterns! I’ve included an appendix at the end to review the basic concepts in
    case you’re new to C#, OOP, or UML.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了某些模式之后，让我们来看看设计过程。到目前为止，我们一直是在走一步看一步。如果我们首先退一步，用模式和UML来设计我们的项目，而不是直接进入代码，事情会变得多么容易，我们又能避免多少问题？本节将从这一角度探讨一个新的项目。我们首先将在[*第6章*](B18605_06.xhtml#_idTextAnchor110)，*在编码前使用模式进行设计！远离IDE*中，将新项目纯粹地设计成一系列图表。然后，我们将在[*第7章*](B18605_07.xhtml#_idTextAnchor136)，*除了打字外别无他物：实现轮椅项目*中实现这个项目。最后一章总结了全书内容，旨在向您展示还有更多模式存在。实际上，它们无处不在！除了常见的四人帮集合之外，还有更多的发展模式，甚至还有更多超出了**面向对象编程**（**OOP**）的领域。你甚至还将学习创建和发布你自己的模式的文档过程！为了以防你是C#、OOP或UML的新手，我在最后附上了一个附录来回顾基本概念。
- en: 'This part covers the following chapters:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖了以下章节：
- en: '[*Chapter 6*](B18605_06.xhtml#_idTextAnchor110), *Step Away from the IDE! Designing
    with Patterns Before You Code*'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18605_06.xhtml#_idTextAnchor110), *在编码前使用模式进行设计！远离IDE*'
- en: '[*Chapter 7*](B18605_07.xhtml#_idTextAnchor136), *Nothing Left but the Typing:
    Implementing the Wheelchair Project*'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18605_07.xhtml#_idTextAnchor136), *除了打字外别无他物：实现轮椅项目*'
- en: '[*Chapter 8*](B18605_08.xhtml#_idTextAnchor152), *Now You Know Some Patterns.
    What Next?*'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18605_08.xhtml#_idTextAnchor152), *你现在知道了一些模式。接下来是什么？*'
- en: '[*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178), *A Brief Review of
    OOP Principles in C#*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178), *C#中面向对象原则的简要回顾*'
- en: '[*Appendix 2*](B18605_Appendix_2.xhtml#_idTextAnchor204), *A Primer on the
    Unified Modeling Language*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*附录2*](B18605_Appendix_2.xhtml#_idTextAnchor204), *统一建模语言入门*'
