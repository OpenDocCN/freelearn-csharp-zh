- en: '*Chapter 4*: Designing a Solution Architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about some of the essential traits and skills
    that are needed to build your potential and become an effective solution architect.
    We also looked at a quick overview of what solution architecture is.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll begin to focus more on solution architecture practices.
    In particular, we'll take a look at the key principles of solution architecture,
    and we'll explore popular **Unified Modeling Language** (**UML**) diagrams that
    are recommended for designing medium- to large-scale solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the key principles of solution architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into the most frequently used UML diagrams with concrete examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking through the process of creating a design architecture with UML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have enriched your knowledge and understanding
    of popular UML diagrams, and you will have learned how to use them in your design.
    Additionally, you will learn about the key principles of solution architecture
    and how they can influence your design process.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the key principles of solution architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecture principles outline the fundamental procedures and guidelines that
    are required to design, build, and deploy a successful software solution. They
    are meant to influence your architecture approach and improve the quality attributes
    of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: There are many principles out there that we can adopt in our methodology of
    work to prepare the design architecture. We can even define our own principles
    if we think they will add value to the architecture design or if we think they
    will efficiently improve the design process. Most importantly, we need to make
    sure we offer a good balance between theory and practice and that we adopt practical
    and powerful principles that will drive the business and technical changes in
    our solution's architectures.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we should aim for between 10 and 20 guiding principles for our solution
    architecture practices. Make sure that you do not have too many principles. This
    is because they become hard to remember and difficult to apply, which will limit
    our architecture's flexibility. In such cases, it is better to keep them simple
    and focused.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a standard way and recommended format that you can use to define an
    architecture principle. Usually, a principle is divided into four main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: The name should reflect the core value of the principle. It should
    be simple and easy to remember.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: The description is a statement that clearly defines and explains
    the principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rationale**: The rationale is a statement that highlights the business benefits
    of obeying the principle. It can also explain the correlation with other principles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implications**: The implications should highlight the technical requirements
    and business requirements that are needed to adopt this principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These elements are meant to support the understanding of each principle and
    justify its usage in the solution architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any principle we adopt should fall into a specific category or domain. According
    to **The Open Group Architecture Framework** (**TOGAF**), architecture principles
    broadly fall into four domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business principles**: These are a set of guidelines that focus on the business
    aspects of the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data principles**: These define the standard guidelines to manage and structure
    data. Additionally, they enforce a set of security measures in which to protect
    the solution assets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application principles**: These deal with the attributes of an application
    such as performance, user experience, and how modules or subsystems interact with
    each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology principles**: These elaborate on the technical guidelines and
    requirements that are necessary for the success and continuity of the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TOGAF is a framework and methodology that has been developed to provide a high-level
    approach to design and also build enterprise information technology architecture.
    You can learn more about architecture principles, as defined by TOGAF, at [https://pubs.opengroup.org/architecture/togaf9-doc/arch/chap20.html](https://pubs.opengroup.org/architecture/togaf9-doc/arch/chap20.html
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustration that highlights the key principles of solution architecture.
    You can see that the four domains are consolidating a set of design guidelines
    in different domains to produce a solution that is flexible, scalable, and reusable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: The recommended key principles of the .NET solution architecture](img/Figure_4.01_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The recommended key principles of the .NET solution architecture'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will explore the preceding principles that you
    really need to know. We can adopt these principles as is, or we can add, modify,
    and remove some principles based on our needs. However, always remember that a
    principle is made to benefit the solution we are suggesting, not to add any obstacles
    or complications.
  prefs: []
  type: TYPE_NORMAL
- en: Business principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution architecture, including all the development deliverables and their
    quality, is of critical importance. However, we shouldn't only focus on the project
    plan, schedule, and outcome. Remember that the reason you are building the solution
    is to solve business problems. Therefore, it is a must for the solution architecture
    to align with the business goals and objectives. In the following sections, we
    will discuss three business principles that should be taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: Maximizing the benefit to the enterprise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All architectural and information management decisions must be made in a way
    that ensures the maximum number of benefits to the entire enterprise. For instance,
    the solution should bring long-term values to all entities within the enterprise,
    not solely to one department or minor group. This principle encourages the high-performing
    collaboration of service above self.
  prefs: []
  type: TYPE_NORMAL
- en: Information management is everybody's business
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All key stakeholders, business experts, and technical teams are responsible
    for coordinating together as one committee to define the business objectives of
    the solution and ensuring that they align with the enterprise goals. Essentially,
    everyone in this committee is responsible for doing their own part in building
    the solution and managing it.
  prefs: []
  type: TYPE_NORMAL
- en: Business continuity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case of system failure, the solution architecture should ensure the business
    continuity of the enterprise. Put simply, any kind of system failure, including
    hardware, software, and data corruption should not affect the continuity of the
    business activities and operations. For instance, the solution design should suggest
    a state-of-the-art recovery mechanism, system redundancy, or failover backup plan
    to smooth the operation of the business functions in the case of disasters. The
    key stakeholders should define the criticality of the solution to the enterprise
    operations and decide what type of failover plan should be applied to ensure business
    continuity.
  prefs: []
  type: TYPE_NORMAL
- en: Data principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data is an essential part of business processes; it is a valuable asset that
    empowers enterprise stakeholders to make strategic decisions based on key metrics
    and performance indicators. There are three data principles that should be taken
    into account when designing and building a software solution. We will explore
    each of them next.
  prefs: []
  type: TYPE_NORMAL
- en: Data is an asset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although many architects know about this principle already, we still find that
    data is not considered with a high level of importance in the way it should be.
    Data is a core business asset of the organization. Therefore, the design of a
    solution should ensure the proper storing, managing, and retrieving of the data
    with high-security measures for better protection.
  prefs: []
  type: TYPE_NORMAL
- en: Data is shared
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accurate data that is stored in a centralized repository is the backbone of
    the software solution, and timely access to the data is very important to improve
    the efficiency of the decision-makers who are using the solution. Additionally,
    business users need data in order to perform their daily duties. Therefore, your
    solution design should allow timely access to the data based on the access rights
    of your users.
  prefs: []
  type: TYPE_NORMAL
- en: Data security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The software solution should ensure the integrity and confidentiality of the
    data. It should protect the data and prohibit unauthorized access or unlawful
    processing. There are many data policies out there to protect the data; we need
    to comply with these policies based on our target users. For instance, if we are
    building a software solution targeting European citizens, then complying with
    the **General Data Protection Regulation** (**GDPR**) is a must.
  prefs: []
  type: TYPE_NORMAL
- en: Application principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The guiding principles of modern applications are evolving. They should be dynamic
    principles; remember that what was applicable in the past is not relevant in today's
    architecture. Always look to improve the principles that you adopt and make it
    a continuous phenomenon. Here are the principles that really matter and that make
    a difference in the delivery of modern and efficient applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ease of use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application should be user-friendly, easy to use, and visually appealing.
    We should embrace simplicity; that is because the easier an application is to
    use the higher the chance that it will be adopted by our end users. Always put
    the users first; they are looking to use applications that can facilitate their
    work and make it efficient in a short period without having to spend a long time
    learning about it before they start getting value from it.
  prefs: []
  type: TYPE_NORMAL
- en: Optimized application speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We live in the era of digital transformation; users are looking for real-time
    response applications. Therefore, the speed of the application is an important
    factor to consider, as it can affect the entire user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Technology principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our technology principles should always follow the latest technology trends.
    It is very important to modernize your company's technology platforms and development
    practices. This will allow you to design modern digital solutions. Let's explore
    the three principles that should be adopted in any .NET development team. We have
    listed them next.
  prefs: []
  type: TYPE_NORMAL
- en: Working toward a cloud-native future
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cloud-native applications have proven to be the future of software. The solution
    we are trying to build can benefit from the platforms, services, and processes
    that are hosted in the cloud. For instance, the Azure services are highly scalable,
    easy to modify, and connected, which allows us to extend the application's capabilities
    with less coding.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET Core (.NET 5 or later)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The latest release of .NET Core is called **.NET 5**. It is a free and open
    source framework that can be used to build any type of application. It is a cross-platform
    framework that has inherited all the significant advantages of the regular .NET
    Framework. One of the key improvements of .NET Core is the performance, so consider
    using this framework when you are building new solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Automating repetitive development tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Preparing the release of your solution can be time-consuming, particularly if
    you are aiming to release several builds and hotfixes. You can plan out automated
    jobs to minimize the manual intervention needed within such tasks, make use of
    DevOps' tools to automate your builds, and test plans, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned about the key principles that should be adopted
    in your solution architecture. These principles provide guidelines for four primary
    aspects of the solution: business, data, application, and technology. Applying
    these principles will give you the ability to deliver a solid solution that is
    scalable, reusable, and easy to maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore six popular UML diagrams that you should
    use when designing a software solution.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to model software architecture using UML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UML is a standard graphical representation that allows us to visualize the specification
    and design architecture of the software solution; it is a simplified way in which
    to communicate our architecture to the solution stakeholders. The purpose of the
    UML is to provide the development team and the business analysts with a unified
    design modeling notation that empowers them to explain complex business processes
    with simplified diagrams. Additionally, it enables us to construct and visualize
    the different software components and how they relate together, which defines
    the entire design architecture of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two categories of UML diagrams: **structural** and **behavioral**.
    Structural diagrams emphasize the static view of the system. They are used to
    visualize the different components and objects of the software. Mainly, they describe
    what is contained in a system.'
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral diagrams emphasize the dynamic view of the system. They are used
    to visualize the business specifications by describing the processes and functionalities
    supported by the software. Primarily, they describe what must happen in a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the different types of UML diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: A list of UML diagram types](img/Figure_4.02_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: A list of UML diagram types'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming sections, we will explore the most frequently used diagrams.
    Although there are many different types of UML diagrams that we can use to model
    solution architecture or describe system functionalities, we will explore the
    popular UML diagrams that are frequently used by most architects to document the
    different aspects of a software solution. They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Component diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn when to use each diagram, and we will also explore the different
    notations and symbols of each. Then, we will examine an example of each diagram.
    Let's start learning about these diagrams next.
  prefs: []
  type: TYPE_NORMAL
- en: Component diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UML component diagram is used to graphically represent the different modules
    and components in the software system, including the relationship and interaction
    between these modules. A module is a set of classes or interfaces that provides
    different functionalities but are grouped into one business routine.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of component diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Component diagrams can help you by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the overall physical structure of the software system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the system's components and how they are related
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping the object-oriented classes based on a common service objective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling the .NET source code or the database of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notations and symbols of a component diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the different shapes and symbols used to draw a component diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: The notations and symbols of a component diagram](img/Figure_4.03_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The notations and symbols of a component diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The component diagram of a shopping system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's assume that we want to build a simple online shopping solution. We will
    use a component diagram to describe the different components in this system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to identify these components by grouping the functional requirements
    according to their purpose. In this example, we have three components:'
  prefs: []
  type: TYPE_NORMAL
- en: The orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The customer accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The products inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we need to identify and visualize the relationships between these components.
    To make an order, the customer should provide the necessary input to finalize
    the order. That''s why we need to use the interface symbol to relate the order
    to the customer; the customer should then select one or more products from the
    inventory. This will ensure that an order is fully associated with the products.
    So, we will use the dependency symbol to relate the order to the products. Here
    is an example of a component diagram describing the three components along with
    their interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: A UML component diagram for online shopping](img/Figure_4.04_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: A UML component diagram for online shopping'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can use the component diagram to illustrate the physical files
    in your source code. This is very helpful when doing forward or reverse engineering
    to identify the set of source code files. Additionally, you can use the component
    diagram to model a physical database.
  prefs: []
  type: TYPE_NORMAL
- en: Class diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UML class diagram is used to describe the structure of the object-oriented
    system by graphically representing the classes with their attributes and operations,
    including the relationships between these classes.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of class diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Class diagrams are very popular among software engineers. They are very powerful
    and can be beneficial when you want to describe the object-oriented classes within
    the software system. We can use UML class diagrams to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe each class in the system with its structural features (attributes)
    along with its behavioral futures (operations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw the relationships between classes, such as **abstraction** and **association**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualize the data models of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a detailed model of the software from a business perspective, which is
    very helpful for non-technical stakeholders in order to understand the general
    overview of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate **C#** source code from the class diagrams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notations and symbols of a class diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Class diagrams are simple and easy to read. Here is an example class diagram
    to help you understand the different notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: An example class diagram](img/Figure_4.05_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: An example class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the standard class notation is composed of three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The upper section contains the name of the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle section contains the class attributes/members with their types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom section contains the class methods displayed in a list format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are different visibility symbols that are used to indicate the access
    level of information contained in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: C# access modifiers and their symbols in UML](img/Figure_4.06_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: C# access modifiers and their symbols in UML'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use cardinality notations to define the type of relationship between
    two classes. For example, one customer can have one or more orders (that is, one
    to many relationships), while another order can have one customer (that is, one
    to one). The following table shows the different symbols of cardinality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Cardinality types](img/Figure_4.07_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Cardinality types'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of relationships between classes. The following table
    shows the symbols of these relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: The relationship types between classes](img/Figure_4.08_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: The relationship types between classes'
  prefs: []
  type: TYPE_NORMAL
- en: The class diagram of an online shopping system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *The component diagram of an online shopping system* section, we visualized
    the component diagram for an online shopping system. In this section, we will
    illustrate the class diagram of this system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: A class diagram of an online shopping system](img/Figure_4.09_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: A class diagram of an online shopping system'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, each box represents a class in the header. We should provide
    the class name and then list all the properties and operations of the class. The
    interaction between the classes is visualized through the lines. We call them
    relationships.
  prefs: []
  type: TYPE_NORMAL
- en: The class diagram can be used during the entire life cycle of the software,
    starting with visualizing the high-level conceptual idea of the software, then
    when creating a detailed understanding of the specifications, and, finally, during
    the implementation of the software. The class diagram is an essential modeling
    technique that is used to visualize all the object-oriented objects in your system,
    so make sure you master it.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sequence diagram is used to document a business or logical process. It illustrates
    the flow of events and messages exchanged between objects during the execution
    of a process. It is considered an interactive diagram because it can describe
    a use case or an operation supported by the software.
  prefs: []
  type: TYPE_NORMAL
- en: This interactive operation can happen between a user and the software you are
    building, between your software and other systems (such as middleware integrations),
    or between the sub-modules within the same software. For example, we can use the
    sequence diagram to explain the authentication mechanism in our system or to illustrate
    the booking process of a hotel reservation system.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of sequence diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sequence diagrams are very helpful when it comes to describing a complex operation
    or a use case. You simply highlight the objects involved, the order of the steps
    in the operation, and the messages exchanged from the beginning of the process
    until completion. You can use sequence diagrams if you want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain a complex use case with several steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model the interaction between objects and components during an operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illustrate an integrated procedure between your system and another third-party
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notations and symbols of a sequence diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table lists the basic notations and symbols that you must know
    in order to create a sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: The notations and symbols of a sequence diagram](img/Figure_4.10_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: The notations and symbols of a sequence diagram'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll create a sequence diagram.
  prefs: []
  type: TYPE_NORMAL
- en: The sequence diagram of a shopping cart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following example, we have illustrated a simple sequence diagram of
    an example use case for an online shopping process. The diagram includes these
    lifelines:'
  prefs: []
  type: TYPE_NORMAL
- en: The customer who wants to shop from the online system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shopping cart interface, which holds the items that a user wants to buy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order module, which processes the user request and confirms the payment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process is described using these sequence messages:'
  prefs: []
  type: TYPE_NORMAL
- en: Users can add a product to the shopping cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can remove a product from the shopping cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can adjust the number of items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can see the total price of the selected items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can confirm the order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram contains a loop fragment that allows the user to add
    more products or items to the shopping cart before confirming the final order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: A sequence diagram of the shopping cart process](img/Figure_4.11_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: A sequence diagram of the shopping cart process'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn about state diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: State diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A state diagram (or a state machine diagram) is typically convenient when you
    want to describe how your system behaves and responds. It is a combination of
    states, transitions, events, and activities. It is used to model the process of
    a particular function and shows all of the transitions from one state to another.
    It can also describe a single object and illustrate how that object behaves in
    response to a series of events in your system. The state of an entity is defined
    by the values of its attributes, which are controlled by a particular event at
    a specific time.
  prefs: []
  type: TYPE_NORMAL
- en: State diagrams are very useful when you wish to model the behavior of an interface,
    class, or collaboration, and the business processes triggered by specific events.
    It also helps you improve processes by eliminating unnecessary steps and identifying
    missing steps that should be added to the process to make it more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of state diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'State diagrams are used to describe how an event can change the behavior of
    a process. We can use state diagrams to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visualize the dynamic view of a system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model the flow of states in a business process scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain an event-driven process using the state of objects when they move from
    one step to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illustrate interactive functionalities in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notations and symbols of a state diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table lists the basic notations and symbols that you must know
    in order to create a state diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: The notations and symbols of a state diagram](img/Figure_4.12_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: The notations and symbols of a state diagram'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use these symbols to draw a state diagram to describe
    a two-factor authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: The state diagram of a two-factor authentication process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following diagram, we have described the events of a two-factor authentication
    process along with the transitions from one state to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: A state diagram describing an authentication process](img/Figure_4.13_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: A state diagram describing an authentication process'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the first event that occurs as a result of the user
    providing their login credentials. Then, the system validates the credentials
    and sends the authentication token back to the user if the credentials are valid;
    otherwise, the user is requested to enter the valid credentials again. After that,
    the user should submit the token for verification by the system, which will decide
    to complete the login process if the token is valid; otherwise, the user is requested
    to re-enter the token to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Activity diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the important diagrams in UML is the activity diagram. It is similar
    to the state diagram in terms of illustrating the dynamic view of the system.
    An activity diagram is a flowchart that describes the flow of control from one
    activity to another activity among the objects in a system. It is mostly used
    to model business processes. The activities described in an activity diagram can
    be sequential and concurrent.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of activity diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An activity diagram is a useful flowchart that describes the activities performed
    by a process in our system. Activity diagrams can help us to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the steps of a use case scenario by describing all of the activities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the logic of a particular algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brainstorm and model business processes and workflows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notations and symbols of an activity diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you begin creating an activity diagram, you must understand its notations
    and symbols. The following table lists the main symbols of an activity diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: The notations and symbols of an activity diagram](img/Figure_4.14_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: The notations and symbols of an activity diagram'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll take a look at an example of an activity diagram.
  prefs: []
  type: TYPE_NORMAL
- en: The activity diagram of an ATM system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following example, we have described a basic process for an ATM system
    using an activity diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: An activity diagram for an ATM system](img/Figure_4.15_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: An activity diagram for an ATM system'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the preceding diagram describes the process of an ATM transaction.
    It starts by inserting the card and then providing the PIN code. Initially, the
    server will verify the PIN code. If it is valid, then the server will advise the
    ATM to allow the customer to proceed, enter the withdrawal amount, and complete
    the transaction; otherwise, the card will be ejected.
  prefs: []
  type: TYPE_NORMAL
- en: Package diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main purpose of using a package diagram is to describe the high-level logical
    architecture of our system by visualizing the various layers along with their
    dependencies in which a layer represents a group of classes. The physical components
    in the system are grouped into layers based on their roles and the tasks they
    perform in the system. It is possible to create nested layers within a single
    layer to describe the advanced details of a major component.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the main layers in your system, we need to visualize the dependencies
    or relationships between the layers. This will describe the interactions that
    are occurring between layers.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of package diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By unifying the major components into layers, a package diagram can make our
    architecture easy to understand. We can use the package diagram to help us perform
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the high-level logical architecture and structure of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualize the major components or functional units of the design and their interdependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the possibilities of integrating your system with a third-party system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover gaps in the architecture that could prevent your system from evolving.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate the effort that is required in the case of a major change that might
    affect several layers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Align with the development team on the intended architecture. This diagram provides
    you with the ability to compare your architecture with what is being implemented
    during the development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notations and symbols of a package diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table lists the main symbols of the package diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: The notations and symbols of a layer diagram](img/Figure_4.16_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: The notations and symbols of a layer diagram'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll examine the package diagram of an ASP.NET web
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: The package diagram of an ASP.NET web solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following diagram, we have used a package diagram to describe the high-level
    architecture of a typical ASP.NET solution without mentioning any details about
    the classes and assets within each package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: A package diagram for a typical ASP.NET solution](img/Figure_4.17_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: A package diagram for a typical ASP.NET solution'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we have represented the packages within the multitier
    architecture of an ASP.NET solution. The **Presentation Layer** includes the user
    interface of the solution, and the **Services Layer** represents a middleware
    service that provides high-level communication services to web and mobile apps.
    The **Business Layer** holds all the business logic and entities. As for the **Data
    Layer**, this includes methods in which to access data stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Use case diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most exciting moments in software engineering is the point at which
    the product you are designing and developing meets the customer''s needs. There
    is nothing better than having clear use cases to reach this target. Use cases
    are essential for describing the product from the client''s perspective. There
    are two types of use cases: **textual** and **visual**.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17366_01_Final_NM_ePub.xhtml#_idTextAnchor013), *Principles
    of the Software Development Life Cycle*, we learned about textual use cases and
    how to prepare them. In this section, we are going to cover the visual representations
    of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: A use case diagram is used to visualize the user's requirements; more specifically,
    it is used to visualize the system behavior and the interaction between the users
    and the system.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of use case diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A use case diagram is a simple and effective technique that can be used to
    visualize the user''s interaction with the system. It doesn''t show all the detailed
    user requirements but only the interaction of the use case. Use case diagrams
    can help you by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Illustrating the users' interaction with the software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing the functional needs and the scope of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the high-level steps of a use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning the user's requirements with the implementation and supporting the
    generation of the test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notations and symbols of a use case diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The notations of a use case diagram are simple and straightforward. The following
    table lists the main symbols of a use case diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: The notations and symbols of a use case diagram](img/Figure_4.18_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: The notations and symbols of a use case diagram'
  prefs: []
  type: TYPE_NORMAL
- en: A use case diagram for the interaction between the customer and the ATM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following diagram, we created a use case diagram to describe the main
    functionalities supported by the ATM system, including the interaction with the
    customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: A use case diagram for an ATM system](img/Figure_4.19_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: A use case diagram for an ATM system'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the actor is the customer who is using the ATM system
    and trying to authenticate to complete a transaction. The colored ellipses represent
    the functionalities supported by the system, and the lines represent the association
    and interaction between the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the most frequently used UML diagrams that
    are essential to document many aspects of the solution such as the solution design,
    the structure of the object-oriented system, and the business and logical processes.
    We also learned about how our system behaves and responds to user interactions,
    the flow of control from one activity to another activity among the objects in
    the system, the high-level logical layers of your system with their dependencies,
    and the requirements from the client's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to create a solution architecture using
    UML.
  prefs: []
  type: TYPE_NORMAL
- en: Designing architecture with UML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned that a UML diagram is a single simplified representation
    of the software. We will need to build various UML diagrams in order to understand
    the complete aspects of the system and to communicate our architecture design
    to stakeholders and different types of users. Grouping these UML diagrams into
    logical subsets will create a particular view of the system. The architecture
    design is represented in a collection of five views. These views are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case view**: The **use case view** represents the focal point for all
    of the other views because it includes the user requirements, including all of
    the system functionalities. Without this view, you cannot build the other views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design view**: The **design view** is intended to illustrate how the functionality
    defined in the use case view is designed inside the system in terms of classes
    and their relationships. This view is mainly described by the UML class diagram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation view**: The **implementation view** describes the core components
    of the system and the interaction between them. It is mainly represented by the
    UML component diagram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process view**: The **process view** describes the flow supported by the
    system. It does this by converging the performance, scalability, and throughput
    of the system. It is mainly represented by the UML class diagram and is similar
    to the **design view**, but focuses on the active classes involved in the processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment view**: The **deployment view** describes the deployment of the
    system by focusing on the system topology, distribution, delivery, and installation.
    It is represented by the UML deployment diagram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the five views along with the use case view
    in the center, which is connected to all of the other views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: System architecture views](img/Figure_4.20_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: System architecture views'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the architecture views, along with the related
    UML diagrams, to help in the understanding of the different aspects of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: System architecture views along with their related UML diagrams](img/Figure_4.21_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: System architecture views along with their related UML diagrams'
  prefs: []
  type: TYPE_NORMAL
- en: The solution architect is responsible for creating the initial version of these
    views with their related diagrams and handling the updates that construct the
    solution architecture. The entire solution architecture is used to influence and
    guide the development activities throughout the project life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the key principles that outline the fundamental
    procedures and guidelines required to design, build, and deploy a software solution.
    Additionally, we learned about the essential UML diagrams with real examples to
    illustrate the different elements in each diagram, along with their benefits,
    and when to use each of them. Later in this chapter, we explored the process that
    is involved when constructing a solution architecture with UML.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig deep into the core architecture patterns. We
    will focus on the microservices architecture, and we will learn how to choose
    the right pattern for a specific solution.
  prefs: []
  type: TYPE_NORMAL
