- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Managing State – Part 2
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理状态 – 第2部分
- en: In this chapter, we continue to look at managing state. Most applications manage
    state in some form.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续探讨状态管理。大多数应用程序都以某种形式管理状态。
- en: A state is simply information that is persisted in some way. It can be data
    stored in a database, session states, or even something stored in a URL.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 状态只是以某种方式持久化的信息。它可以是存储在数据库中的数据，会话状态，甚至存储在URL中的内容。
- en: The user state is stored in memory either in the web browser or on the server.
    It contains the component hierarchy and the most recently rendered UI (render
    tree). It also contains the values or fields and properties in the component instances
    as well as the data stored in service instances in dependency injection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 用户状态存储在内存中，无论是在网页浏览器还是在服务器上。它包含组件层次结构和最近渲染的UI（渲染树）。它还包含组件实例中的值或字段和属性，以及依赖注入中服务实例存储的数据。
- en: If we make JavaScript calls, the values we set are also stored in memory. Blazor
    Server relies on the circuit (SignalR connection) to hold the user state, and
    Blazor WebAssembly relies on the browser’s memory. But when we have a mix of both
    states, state management becomes a bit trickier. If we reload the page, the circuit
    and the memory will be lost. The same goes for switching pages; if there are no
    more `InteractiveServer` components on the page, the SignalR connection will be
    terminated and the state lost. Managing state is not about handling connections
    or connection issues but rather how we can keep the data even if we reload the
    web browser.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用JavaScript，我们设置的值也会存储在内存中。Blazor Server依赖于电路（SignalR连接）来保持用户状态，而Blazor
    WebAssembly依赖于浏览器的内存。但是，当我们混合这两种状态时，状态管理就会变得有些复杂。如果我们重新加载页面，电路和内存都会丢失。切换页面也是如此；如果没有更多的`InteractiveServer`组件在页面上，SignalR连接将被终止，状态丢失。管理状态不是关于处理连接或连接问题，而是关于我们如何在重新加载网页的情况下保持数据。
- en: Saving state between page navigations or sessions improves the user experience
    and could be the difference between a sale and no sale. Imagine reloading the
    page and all your items in the shopping cart are gone; the chances are you won’t
    shop there again.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面导航或会话之间保存状态可以改善用户体验，可能是销售与否的区别。想象一下重新加载页面，购物车中的所有项目都消失了；你很可能不会再在那里购物。
- en: Now imagine returning to a page a week or month later and all those things are
    still there.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，一周或一个月后返回页面，所有那些东西仍然在那里。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Storing data on the server side
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端存储数据
- en: Storing data in the URL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URL中存储数据
- en: Implementing browser storage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现浏览器存储
- en: Using an in-memory state container service
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存状态容器服务
- en: State management frameworks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理框架
- en: Root-level cascading values
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根级级联值
- en: We have already talked about and even implemented some of these things. Let’s
    take this opportunity to recap the things we have already talked about, as well
    as introduce some new techniques.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，甚至实现了一些这些内容。让我们利用这个机会回顾我们已经讨论过的事情，以及介绍一些新技术。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure you have followed the previous chapters or use the `Chapter10` folder
    as a starting point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经阅读了前面的章节，或者以`Chapter10`文件夹作为起点。
- en: You can find the source code for this chapter’s end result a[t https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter11)11.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节的最终结果源代码[https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter11)11中找到。
- en: If you are jumping into this chapter using the code from GitHub, make sure you
    have added `Auth0` account information in the `Settings` files. You can find the
    instructions in *Chapter 8*, *Authentication and Authorization*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用GitHub上的代码跳转到本章，请确保你在`Settings`文件中添加了`Auth0`账户信息。你可以在*第8章*，*认证和授权*中找到说明。
- en: Storing data on the server side
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器端存储数据
- en: There are many different ways in which to store data on the server side. The
    only thing to remember is that Blazor WebAssembly (or `InteractiveWebAssembly`)
    will always need an API. Blazor Server (or `InteractiveServer`) doesn’t need an
    API since we can access the server-side resources directly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端存储数据有许多不同的方式。唯一需要记住的是，Blazor WebAssembly（或`InteractiveWebAssembly`）始终需要一个API。Blazor
    Server（或`InteractiveServer`）不需要API，因为我们可以直接访问服务器端资源。
- en: I have had discussions with many developers regarding APIs or direct access,
    which all boils down to what you intend to do with the application. If you are
    building a Blazor Server application and have no interest in moving to Blazor
    WebAssembly, I would probably go for direct access, as we have done in the `MyBlog`
    project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我与许多开发人员就API或直接访问进行了讨论，这些都归结为你打算如何使用应用程序。如果你正在构建Blazor Server应用程序，并且没有兴趣迁移到Blazor
    WebAssembly，我可能会选择直接访问，就像我们在`MyBlog`项目中做的那样。
- en: I would not do direct database queries in the components, though. I would keep
    them in an API, just not a Web API. As we have seen, exposing those API functions
    in an API, as we did in *Chapter 7*, *Creating an API*, does not require a lot
    of steps. We can always start with direct server access and move to an API if
    we want to.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我并不会在组件中直接进行数据库查询。我会将它们保留在API中，只是不是Web API。正如我们所看到的，在*第7章* *创建API*中，将那些API函数公开在API中，并不需要很多步骤。我们始终可以从直接服务器访问开始，如果我们想的话，再转向API。
- en: When it comes to storing data, we can save it in Blob storage, key-value storage,
    a relational database, a document database, table storage, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到存储数据时，我们可以将其保存在Blob存储、键值存储、关系数据库、文档数据库、表存储中等。
- en: There is no end to the possibilities. If .NET can communicate with the technology,
    we will be able to use it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性是无限的。如果.NET可以与该技术通信，我们就能使用它。
- en: Storing data in the URL
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在URL中存储数据
- en: At first glance, this option might sound horrific but it’s not. Data, in this
    case, can be the blog post ID or the page number if we use paging. Typically,
    the things you want to save in the URL are things you want to be able to link
    to later on, such as blog posts in our case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这个选项可能听起来很可怕，但事实并非如此。在这种情况下，数据可以是博客帖子ID或页码，如果我们使用分页的话。通常，你想要在URL中保存的东西是你希望以后能够链接到的东西，例如在我们的例子中是博客帖子。
- en: 'To read a parameter from the URL, we use the following syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要从URL中读取参数，我们使用以下语法：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The URL is `posts` followed by the page number (for paging through blog posts)
    of the post.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: URL由`posts`后跟帖子的页码（用于浏览博客帖子）组成。
- en: To find that particular route, `PageNumber` must be an integer; otherwise, the
    route won’t be found.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到那个特定的路由，`PageNumber`必须是一个整数；否则，路由将无法找到。
- en: 'We also need a `public` parameter with the same name:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个同名的`public`参数：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we store data in the URL, we need to make sure to use the `OnParametersSet`
    or `OnParametersSetAsync` method; otherwise, the data won’t get reloaded if we
    change the parameter. If the parameter changes, Blazor won’t run `OnInitializedAsync`
    again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在URL中存储数据，我们需要确保使用`OnParametersSet`或`OnParametersSetAsync`方法；否则，如果更改参数，数据将不会重新加载。如果参数更改，Blazor不会再次运行`OnInitializedAsync`。
- en: This is why our `post.razor` component loads the things that change based on
    the parameter in the URL in `OnParametersSet`, and loads the things that are not
    affected by the parameter in `OnInitializedAsync`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们的`post.razor`组件在`OnParametersSet`中加载基于URL参数变化的内容，并在`OnInitializedAsync`中加载不受参数影响的内容。
- en: 'We can use optional parameters by specifying them as nullable, like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定它们为可空类型来使用可选参数，如下所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So this route would match “`/post/`" and “`/post/42`", for example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个路由将匹配“`/post/`”和“`/post/42`”等。
- en: Route constraints
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由约束
- en: When we specify what type the parameter should be, this is called a **route
    constraint**. We add a constraint so the match will only happen if the parameter
    value can be converted into the type we specified.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指定参数的类型时，这被称为**路由约束**。我们添加约束，以便只有在参数值可以转换为指定的类型时，匹配才会发生。
- en: 'The following constraints are available:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可用的约束：
- en: '`bool`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`'
- en: '`datetime`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datetime`'
- en: '`decimal`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`'
- en: '`float`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`guid`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guid`'
- en: '`int`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`long`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: The URL elements will be converted in to a **C#** object. Therefore, it’s important
    to use an invariant culture when adding them to a URL. string is not part of the
    list because that is the default behavior.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: URL元素将被转换为**C#**对象。因此，在将它们添加到URL时使用不变文化是很重要的。`string`不是列表的一部分，因为这已经是默认行为。
- en: Using a query string
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询字符串
- en: So far, we have only talked about routes that are specified in the `page` directive,
    but we can also read data from the query string.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了在`page`指令中指定的路由，但我们也可以从查询字符串中读取数据。
- en: '`NavigationManager` gives us access to the URI, so by using this code, we can
    access the query string parameters:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigationManager`为我们提供了访问URI的权限，因此通过使用此代码，我们可以访问查询字符串参数：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We won’t dig deeper into this, but now we know that it is possible to access
    query string parameters if we need to.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这个问题，但现在我们知道，如果我们需要访问查询字符串参数，这是可能的。
- en: 'We can also access the `query` parameter using an attribute like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用类似这样的属性来访问`query`参数：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This syntax is a bit nicer to work with.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法更易于使用。
- en: Having data in the URL does not really mean storing the data. If we navigate
    to another page, we need to make sure to include the new URL; otherwise, it would
    be lost. We can use the browser storage instead if we want to store data that
    we don’t need to include every time in the URL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在URL中存在并不意味着存储数据。如果我们导航到另一个页面，我们需要确保包含新的URL；否则，它将会丢失。如果我们想存储不需要每次都包含在URL中的数据，我们可以使用浏览器存储。
- en: Implementing browser storage
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现浏览器存储
- en: The browser has a bunch of different ways of storing data in the web browser.
    They are handled differently depending on what type we use. **Local storage**
    is scoped to the user’s browser window. The data will still be saved if the user
    reloads the page or even closes the web browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器有多种不同的方式在网页浏览器中存储数据。它们根据我们使用的数据类型而有所不同。**本地存储**的范围限定在用户的浏览器窗口。即使用户重新加载页面或关闭网页浏览器，数据仍然会被保存。
- en: The data is also shared across tabs. **Session storage** is scoped to the **Browser**
    tab; if you reload the tab, the data will be saved, but if you close the tab,
    the data will be lost. `SessionsStorage` is, in a way, safer to use because we
    avoid risks with bugs that may occur due to multiple tabs manipulating the same
    values in storage.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也会在标签页之间共享。**会话存储**的范围限定在**浏览器**标签页；如果你重新加载该标签页，数据将被保存，但如果你关闭该标签页，数据将会丢失。`SessionsStorage`在某种程度上更安全使用，因为我们避免了由于多个标签页操作存储中的相同值而可能出现的bug风险。
- en: To be able to access the browser storage, we need to use JavaScript. Luckily,
    we won’t need to write the code ourselves.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问浏览器存储，我们需要使用JavaScript。幸运的是，我们不需要自己编写代码。
- en: In .NET 5, Microsoft introduced **Protected Browser Storage**, which uses data
    protection in ASP.NET Core and is not available in WebAssembly. We can, however,
    use an open-source library called `Blazored.LocalStorage`, which can be used by
    both Blazor Server and Blazor WebAssembly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 5中，微软引入了**受保护浏览器存储**，它使用ASP.NET Core中的数据保护，但在WebAssembly中不可用。然而，我们可以使用一个名为`Blazored.LocalStorage`的开源库，它既可以用于Blazor
    Server，也可以用于Blazor WebAssembly。
- en: But we are here to learn new things, right?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在这里是为了学习新事物，对吧？
- en: So, let’s implement an interface so that we can use both versions in our app,
    depending on which hosting model we are using. There is a problem with this implementation.
    If we are running in `AutoMode`, the state will not be shared between the different
    hosting models. The solution is to stick to `Blazored.LocalStorage` in both implementations.
    But to show the difference between the implementations, we will do both in this
    case. Please note that this is stored in clear text on the user’s computer, so
    be careful with what you store.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现一个接口，这样我们就可以根据我们使用的托管模型使用两种版本。这个实现有一个问题。如果我们以`AutoMode`运行，不同托管模型之间的状态将不会共享。解决方案是在两种实现中都坚持使用`Blazored.LocalStorage`。但为了展示实现之间的差异，我们将在这个案例中同时进行。请注意，这是在用户的计算机上以明文形式存储的，所以请小心存储的内容。
- en: Creating an interface
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个接口
- en: 'First, we need an interface that can read and write to storage:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个可以读取和写入存储的接口：
- en: In the `SharedComponents` project, create a new folder called `Interfaces`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，创建一个名为`Interfaces`的新文件夹。
- en: In the new folder, create a new class called `IBrowserStorage.cs`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中，创建一个名为`IBrowserStorage.cs`的新类。
- en: 'Replace the content in the file with the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件中的内容替换为以下代码：
- en: '[PRE5]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we have an interface containing `get`, `set`, and `delete` methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含`get`、`set`和`delete`方法的接口。
- en: Implementing Blazor Server (InteractiveServer)
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Blazor Server（InteractiveServer）
- en: 'For Blazor Server, we will use protected browser storage:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Blazor Server，我们将使用受保护浏览器存储：
- en: In the `BlazorWebApp` project, add a new folder called `Services`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp`项目中，添加一个名为`Services`的新文件夹。
- en: In the new folder, create a new class called `BlogProtectedBrowserStorage.cs`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中，创建一个名为`BlogProtectedBrowserStorage.cs`的新类。
- en: (I realize the naming is overkill, but it will be easier to tell the Blazor
    Server and the Blazor WebAssembly implementation apart because we will soon create
    another one.)
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （我意识到命名有些过度，但这将有助于我们区分Blazor Server和Blazor WebAssembly实现，因为我们很快将创建另一个实现。）
- en: 'Open the new file and add the following `using` statements:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新文件并添加以下`using`语句：
- en: '[PRE6]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the class with this one:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类替换为以下内容：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `BlogProtectedBrowserStorage` class implements the `IBrowserStorage` interface
    for protected browser storage. We inject a `ProtectedSessionStorage` instance
    and implement the `set`, `get`, and `delete` methods.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BlogProtectedBrowserStorage` 类实现了 `IBrowserStorage` 接口以用于受保护的浏览器存储。我们注入一个
    `ProtectedSessionStorage` 实例并实现了 `set`、`get` 和 `delete` 方法。'
- en: 'In `Program.cs`, add the following namespaces:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下命名空间：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following just beneath the line ending with `.AddInteractiveWebAssemblyComponents();`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AddInteractiveWebAssemblyComponents();` 结尾的行下方添加以下内容：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are configuring Blazor to return an instance of `BlogProtectedBrowserStorage`
    when we inject `IBrowserStorage`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在配置Blazor，当注入 `IBrowserStorage` 时返回 `BlogProtectedBrowserStorage` 实例。
- en: This is the same as we did with the API. We inject different implementations
    depending on the platform.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们对API所做的是相同的。根据平台注入不同的实现。
- en: Implementing WebAssembly (InteractiveWebAssembly)
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现WebAssembly（交互式WebAssembly）
- en: 'For Blazor WebAssembly, we will use `Blazored.SessionStorage`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Blazor WebAssembly，我们将使用 `Blazored.SessionStorage`：
- en: In the `BlazorWebApp.Client`project, add a `NuGet` reference to `Blazored.SessionStorage`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp.Client` 项目中，添加对 `Blazored.SessionStorage` 的 `NuGet` 引用。
- en: Add a new folder called `Services`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Services` 的新文件夹。
- en: In the new folder, create a new class called `BlogBrowserStorage.cs`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中，创建一个名为 `BlogBrowserStorage.cs` 的新类。
- en: 'Open the new file and replace the content with the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新文件，并将内容替换为以下代码：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The implementations of `ProtectedBrowserStorage` and `Blazored.SessionStorage`
    are pretty similar to one another. The names of the methods are different but
    the parameters are the same.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ProtectedBrowserStorage` 和 `Blazored.SessionStorage` 的实现方式非常相似。方法名称不同，但参数相同。'
- en: 'In the `Program.cs` file, add the following namespaces:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下命名空间：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Just above `await builder.Build().RunAsync();` add the following:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `await builder.Build().RunAsync();` 之上添加以下内容：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `AddBlazoredSessionStorage` extension method hooks up everything so that
    we can start using the browser session storage.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddBlazoredSessionStorage` 扩展方法将所有内容连接起来，以便我们可以开始使用浏览器会话存储。'
- en: Then we add our configuration for `IBrowserStorage`, just as we did with the
    server, but in this case, we return `BlogBrowserStorage` when we ask the dependency
    injection for `IBrowserStorage`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加 `IBrowserStorage` 的配置，就像我们在服务器上所做的那样，但在这个情况下，当我们请求依赖注入 `IBrowserStorage`
    时，我们返回 `BlogBrowserStorage`。
- en: Implementing the shared code
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现共享代码
- en: 'We also need to implement some code that calls the services we just created:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现一些调用我们刚刚创建的服务的代码：
- en: In the `SharedComponents` project, open `Pages/Admin/BlogPostEdit.razor`. We
    are going to make a couple of changes to the file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，打开 `Pages/Admin/BlogPostEdit.razor` 文件。我们将对该文件进行一些修改。
- en: 'Inject `IBrowserStorage`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入 `IBrowserStorage`：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since we can only run JavaScript calls when doing an action (like a click)
    or in the `OnAfterRender` method, let’s create an `OnAfterRenderMethod`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们只能在执行动作（如点击）或 `OnAfterRender` 方法中运行JavaScript调用，让我们创建一个 `OnAfterRenderMethod`：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we load the component and the `Id` is `null`, this means we are editing
    a new file, and then we can check whether we have a file saved in browser storage.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们加载组件且 `Id` 为 `null` 时，这意味着我们正在编辑一个新文件，然后我们可以检查浏览器存储中是否有保存的文件。
- en: This implementation can only have one file in the drafts and only saves new
    posts. If we were to edit an existing post, it would not save those changes.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此实现只能在草稿中有一个文件，并且只保存新帖子。如果我们编辑现有的帖子，则不会保存这些更改。
- en: 'We need our `UpdateHTML` method to become async. Change the method to look
    like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将 `UpdateHTML` 方法改为异步。将方法修改如下：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If `Id` on the blog post is `null`, we will store the post in the browser storage.
    Make sure to change all the references from `UpdateHTML` to `UpdateHTMLAsync`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果博客帖子的 `Id` 为 `null`，我们将把帖子存储在浏览器存储中。确保将所有对 `UpdateHTML` 的引用更改为 `UpdateHTMLAsync`。
- en: 'Make sure to await the call as well in the `OnParametersSetAsync` method like
    this:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保在 `OnParametersSetAsync` 方法中也等待调用，如下所示：
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is one problem with this implementation: we are currently prerendering
    our components. When we are prerendering, no connection is made to the web browser.
    There is no state to retrieve. Simply put, we need to disable the prerendering
    on this component to make it work. So, let’s do that!'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此实现存在一个问题：我们目前正在预渲染我们的组件。当我们预渲染时，没有连接到网络浏览器。没有状态可以检索。简单来说，我们需要禁用此组件的预渲染功能以使其工作。所以，让我们这么做吧！
- en: 'Change `@rendermode InteractiveServer` to:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@rendermode InteractiveServer`更改为：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are done. Now it’s time to test the implementation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。现在是时候测试实现：
- en: Run the project by pressing *Ctrl* + *F5*.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *F5*键运行项目。
- en: Log in to the site (so we can access the admin tools).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到网站（这样我们就可以访问管理工具）。
- en: Click **Blog posts** followed by **New blog post**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**博客文章**然后点击**新建博客文章**。
- en: Type anything in the boxes, and as soon as we type something in the text area,
    it will save the post to storage.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在框中输入任何内容，一旦我们在文本区域中输入一些内容，它就会将文章保存到存储中。
- en: Click **Blog posts** (so we navigate away from our blog post).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**博客文章**（这样我们就从我们的博客文章中导航出去）。
- en: Click **New blog post** and all the information will still be there.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建博客文章**，所有信息仍然保留。
- en: Press *F12* to see the browser developer tools. Click **Application** | **Session
    storage** | **https://localhost:portnumber**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F12*键以查看浏览器开发者工具。点击**应用程序** | **会话存储** | **https://localhost:portnumber**。
- en: 'You should see one post with the key `EditCurrentPost`, and the value of that
    post should be an encrypted string, as seen in *Figure 11.1*:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到一个键为`EditCurrentPost`的文章，该文章的值应该是一个加密字符串，如*图11.1*所示：
- en: '![Figure 11.1 – The encrypted protected browser storage ](img/B21849_11_01.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图11.1 – 加密的受保护浏览器存储](img/B21849_11_01.png)'
- en: 'Figure 11.1: The encrypted protected browser storage'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.1：加密的受保护浏览器存储
- en: Let’s test Blazor WebAssembly (InteractiveWebAssembly) next.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们接下来测试Blazor WebAssembly（InteractiveWebAssembly）。
- en: 'Open the `EditPost.razor` file again and change `@rendermode @(new InteractiveServerRenderMode(prerender:
    false))` to:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '再次打开`EditPost.razor`文件，将`@rendermode @(new InteractiveServerRenderMode(prerender:
    false))`更改为：'
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might need to clean and rebuild your project to make this work.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要清理和重新构建你的项目才能使其工作。
- en: Log in to the site (so we can access the admin tools).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到网站（这样我们就可以访问管理工具）。
- en: Click **Blog posts** and then **New blog post**. You may notice that there is
    a delay between loading the page and the components showing up. This is the initial
    WebAssembly load time to get everything started.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**博客文章**然后**新建博客文章**。你可能注意到页面加载和组件显示之间存在延迟。这是WebAssembly的初始加载时间，用于启动一切。
- en: Type anything in the boxes, and as soon as we type something in the text area,
    it will save the post to storage.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在框中输入任何内容，一旦我们在文本区域中输入一些内容，它就会将文章保存到存储中。
- en: Click **Blog posts** (so we navigate away from our blog post).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**博客文章**（这样我们就从我们的博客文章中导航出去）。
- en: Click **New blog post** and all the information should still be there.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建博客文章**，所有信息应该仍然保留在那里。
- en: Press *F12* to see the browser developer tools. Click **Application** | **Session
    storage** | **https://localhost:portnumber**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F12*键以查看浏览器开发者工具。点击**应用程序** | **会话存储** | **https://localhost:portnumber**。
- en: You should see one post with the key `EditCurrentPost`, and the value of that
    post should be a JSON string, as seen in *Figure 11.2*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个键为`EditCurrentPost`的文章，该文章的值应该是一个JSON字符串，如*图11.2*所示。
- en: 'If we were to change the data in the storage, it would also change in the application,
    so keep in mind that this is plain text, and the end user can manipulate the data:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改存储中的数据，它也会在应用程序中更改，所以请记住，这是纯文本，最终用户可以操作数据：
- en: '![Figure 11.2 – Browser storage that is unprotected ](img/B21849_11_02.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 未受保护的浏览器存储](img/B21849_11_02.png)'
- en: 'Figure 11.2: Browser storage that is unprotected'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：未受保护的浏览器存储
- en: Now, we have implemented protected browser storage for Blazor Server and session
    storage for Blazor WebAssembly. The way we can mix and match the hosting model
    where we need it is a really amazing power of .NET 8.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为Blazor Server实现了受保护的浏览器存储，为Blazor WebAssembly实现了会话存储。我们可以在需要的地方混合和匹配托管模型，这是.NET
    8的一个真正惊人的功能。
- en: We only have one way left to go through, so let’s make it the most fun.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下一种方法可以尝试，让我们让它变得最有趣。
- en: Using an in-memory state container service
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存状态容器服务
- en: When it comes to in-memory state containers, we simply use dependency injection
    to keep the instance of the service in memory for the predetermined time (scoped,
    singleton, or transient).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到内存状态容器时，我们只需使用依赖注入来保持服务实例在内存中的预定时间（作用域、单例或瞬态）。
- en: In *Chapter 4*, *Understanding Basic Blazor Components*, we discussed how the
    scope of dependency injections differs from Blazor Server and Blazor WebAssembly.
    The big difference for us in this section is the fact that Blazor WebAssembly
    runs inside the web browser and doesn’t have a connection to the server or other
    users.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*理解基本Blazor组件*中，我们讨论了依赖注入的作用域如何与Blazor Server和Blazor WebAssembly不同。在本节中，对我们来说最大的区别是Blazor
    WebAssembly在浏览器内部运行，并且没有与服务器或其他用户的连接。
- en: To show how the in-memory state works, we will do something that might seem
    a bit overkill for a blog but it will be cool to see. When we edit our blog post,
    we will update all the web browsers connected to our blog in real time (I did
    say overkill).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示内存状态的工作方式，我们将做一些可能对博客来说有点过度的事情，但看到它会很酷。当我们编辑我们的博客帖子时，我们将实时更新连接到我们博客的所有网络浏览器（我确实说过过度）。
- en: We will have to implement that a bit differently, depending on the host. Let’s
    start with Blazor Server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据宿主的不同，我们可能需要以不同的方式实现这一点。让我们从Blazor Server开始。
- en: Implementing real-time updates on Blazor Server
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Blazor Server上实现实时更新
- en: 'The implementation for Blazor Server can also be used for Blazor WebAssembly.
    Since WebAssembly is running in our browser, it would only notify the users connected
    to the site, which would be just you. But it might be good to know that the same
    thing works in Blazor Server as well as Blazor WebAssembly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor Server的实现也可以用于Blazor WebAssembly。由于WebAssembly在我们的浏览器中运行，它只会通知连接到该站点的用户，这将是您自己。但了解这一点可能很好，因为同样的东西在Blazor
    Server和Blazor WebAssembly中都可以工作：
- en: In the `SharedComponents` project, in the `Interfaces` folder, create an interface
    called `IBlogNotificationService.cs`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，在`Interfaces`文件夹中，创建一个名为`IBlogNotificationService.cs`的接口。
- en: 'Add the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have an action that we can subscribe to when the blog post is updated and
    a method we can call when we update a post.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有一个可以在博客帖子更新时订阅的动作，以及一个在我们更新帖子时可以调用的方法。
- en: In the `Services` folder in the `BlazorWebServer` project, add a new class called
    `BlazorServerBlogNotificationService.cs`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebServer`项目的`Services`文件夹中，添加一个名为`BlazorServerBlogNotificationService.cs`的新类。
- en: It might seem unnecessary to give the class a name that includes `BlazorServer`,
    but it makes sure we can easily tell the classes apart.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给类起一个包含`BlazorServer`的名字可能看起来不必要，但它确保我们可以轻松地区分这些类。
- en: 'Replace the content with the following code:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将内容替换为以下代码：
- en: '[PRE20]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code is pretty straightforward here. If we call `SendNotification`, it will
    check whether anyone is listening for the `BlogPostChanged` action and whether
    to trigger the action.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的代码相当简单。如果我们调用`SendNotification`，它将检查是否有人正在监听`BlogPostChanged`动作，并决定是否触发该动作。
- en: 'In `Program.cs`, add the dependency injection:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加依赖注入：
- en: '[PRE21]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Whenever we ask for an instance of the `IBlogNotificationService` type, we will
    get back an instance of `BlazorServerBlogNotificationService`.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当我们请求`IBlogNotificationService`类型的实例时，我们都会得到`BlazorServerBlogNotificationService`的一个实例。
- en: We add this dependency injection as a singleton. I can’t stress this enough.
    When using Blazor Server, this will be the same instance for *ALL* users, so we
    must be careful when we use `Singleton`.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将这个依赖注入作为单例。我必须强调这一点。当使用Blazor Server时，这将是所有用户的相同实例，因此我们必须在使用`Singleton`时格外小心。
- en: In this case, we want the service to notify all the visitors of our blog that
    the blog post has changed.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望该服务通知我们博客的所有访客博客帖子已更改。
- en: In the `SharedComponents` project, open `Post.razor`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中打开`Post.razor`。
- en: 'Add the following code at the top (or close to the top) of the page:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面顶部（或接近顶部）添加以下代码：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We add dependency injection for `IBlogNotificationService` and we also need
    to implement `IDisposable` to prevent any memory leaks.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为`IBlogNotificationService`添加了依赖注入，并且还需要实现`IDisposable`以防止任何内存泄漏。
- en: 'At the top of the `OnInitializedAsync` method, add the following:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`OnInitializedAsync`方法的顶部添加以下代码：
- en: '[PRE23]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We added a listener to the event so we know when we should update the information.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们向事件添加了一个监听器，以便我们知道何时应该更新信息。
- en: 'We also need the `PostChanged` method, so add this code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要`PostChanged`方法，所以添加以下代码：
- en: '[PRE24]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the parameter has the same ID as the post we are currently viewing, then
    replace the content with the post in the event and call `StateHasChanged`.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果参数具有与我们当前查看的帖子相同的ID，则将事件中的内容替换为帖子并调用`StateHasChanged`。
- en: Since this is happening on another thread, we need to call `StateHasChanged`
    using `InvokeAsync` so that it runs on the UI thread.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这发生在另一个线程上，我们需要使用`InvokeAsync`调用`StateHasChanged`，以确保它在UI线程上运行。
- en: 'We also need to stop listening to the updates by implementing the `Dispose`
    method. Add the following:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要通过实现`Dispose`方法来停止监听更新。添加以下内容：
- en: '[PRE25]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We remove the event listener to prevent any memory leaks.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们移除事件监听器以防止任何内存泄漏。
- en: The `Post` component is currently a static rendered component. We don’t have
    any interactivity, so let’s enable that.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Post`组件目前是一个静态渲染组件。我们没有任何交互性，所以让我们启用它。'
- en: 'Add this to the component:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下内容添加到组件中：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `SharedComponents` project, open the `Pages/Admin/BlogPostEdit.Razor`
    file.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，打开`Pages/Admin/BlogPostEdit.Razor`文件。
- en: 'When we make changes to our blog post, we need to send a notification as well.
    At the top of the file, add the following:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们修改我们的博客文章时，我们还需要发送一个通知。在文件顶部添加以下内容：
- en: '[PRE27]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We add a namespace and inject our notification service.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加一个命名空间并注入我们的通知服务。
- en: 'In the `UpdateHTMLAsync` method, add the following just under the `!string.IsNullOrEmpty(Post.Text)`
    `if` statement:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UpdateHTMLAsync`方法中，在`!string.IsNullOrEmpty(Post.Text)` `if`语句下方添加以下内容：
- en: '[PRE28]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Every time we change something, it will now send a notification that the blog
    post has changed. I do realize that it would make more sense to do this when we
    save a post, but it makes for a much cooler demo.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次我们更改内容时，现在都会发送一个通知，表明博客文章已更改。我确实意识到在保存帖子时这样做可能更有意义，但这会使演示更加酷。
- en: 'Let’s start with testing `InteractiveServer`. In `BlogPortEditPage.razor`,
    change `@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))`
    to:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '让我们从测试`InteractiveServer`开始。在`BlogPortEditPage.razor`中，将`@rendermode @(new
    InteractiveWebAssemblyRenderMode(prerender: false))`更改为：'
- en: '[PRE29]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run the project by pressing *Ctrl* + *F5*.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *F5*运行项目。
- en: Copy the URL and open another web browser. We should now have two web browser
    windows open showing us the blog.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制URL并在另一个网络浏览器中打开。现在我们应该有两个网络浏览器窗口打开，显示我们的博客。
- en: In the first window, open a blog post (doesn’t matter which one), and in the
    second window, log in and edit the same blog post.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个窗口中，打开一个博客文章（哪个都行），然后在第二个窗口中登录并编辑同一篇博客文章。
- en: When we change the text of the blog post in the second window, the change should
    be reflected in real time in the first window.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第二个窗口中更改博客文章的文本时，更改应该会实时反映在第一个窗口中。
- en: I am constantly amazed how a feature that would be a bit tricky to implement
    without using Blazor only requires 10 steps (not counting the test), and if we
    didn’t prepare for the next step, it would take even fewer steps.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是很惊讶，没有使用Blazor实现的功能可能有点棘手，但现在只需要10步（不算测试），如果我们没有为下一步做准备，步骤会更少。
- en: Next, we will implement the same feature for Blazor WebAssembly, but Blazor
    WebAssembly runs inside the user’s web browser. There is no real-time communication
    built in, as with Blazor Server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为Blazor WebAssembly实现相同的功能，但Blazor WebAssembly是在用户的网络浏览器中运行的。与Blazor
    Server一样，它没有内置的实时通信。
- en: Implementing real-time updates on Blazor WebAssembly
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Blazor WebAssembly的实时更新
- en: We already have a lot of things in place. We only need to add a real-time messaging
    system. Since SignalR is both easy to implement and awesome, let’s use that.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有很多东西准备好了。我们只需要添加一个实时消息系统。由于SignalR既容易实现又很棒，让我们使用它。
- en: The first time I used SignalR, my first thought was, “Wait, it can’t be that
    easy. I must have forgotten something, or something must be missing”. Hopefully,
    we will have the same experience now.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次使用SignalR时，我的第一个想法是，“等等，这不可能那么简单。我一定是忘记了什么，或者缺少了什么”。希望我们现在会有同样的体验。
- en: 'Let’s see whether that still holds true today:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这今天是否仍然成立：
- en: In the `BlazorWebApp` project, add a new folder called `Hubs`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp`项目中，添加一个名为`Hubs`的新文件夹。
- en: In the new folder, create a class called `BlogNotificationHub.cs`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中，创建一个名为`BlogNotificationHub.cs`的类。
- en: 'Replace the code with the following:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码替换为以下内容：
- en: '[PRE30]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The class inherits from the `Hub` class. There is a method called `SendNotification`.
    Keep that name in mind; we will come back to that.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该类继承自`Hub`类。有一个名为`SendNotification`的方法。记住这个名字；我们很快就会回到它。
- en: We call `Clients.All.SendAsync`, which means we will send a message called `BlogPostChanged`
    with the content of a blog post.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们调用`Clients.All.SendAsync`，这意味着我们将发送一个名为`BlogPostChanged`的消息，包含博客文章的内容。
- en: The name `BlogPostChanged` is also important, so keep that in mind as well.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称`BlogPostChanged`也很重要，所以请记住这一点。
- en: 'In the `Program.cs` file, add the following:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下内容：
- en: '[PRE31]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This adds SignalR. We already have access to SignalR since this project is a
    mix of hosting models.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这添加了SignalR。由于这个项目是托管模型的混合，我们已经有权限访问SignalR。
- en: 'Add the following namespace:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下命名空间：
- en: '[PRE32]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Just above `app.MapRazorComponents<App>()`, add:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.MapRazorComponents<App>()`之上添加：
- en: '[PRE33]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we configure what URL `BlogNotificationHub` should use. In this case,
    we are using the same URL as the name of the hub.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们配置`BlogNotificationHub`应该使用哪个URL。在这种情况下，我们使用与hub名称相同的URL。
- en: The URL here is also important. We will use that in just a bit.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的URL也很重要。我们将在稍后使用它。
- en: In the `BlazorWebApp.Client`, add a reference to the `Microsoft.AspNetCore.SignalR.Client
    NuGet` package.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp.Client`中添加对`Microsoft.AspNetCore.SignalR.Client NuGet`包的引用。
- en: In the `Services` folder, create a class called `BlazorWebAssemblyBlogNotificationService.cs`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Services`文件夹中，创建一个名为`BlazorWebAssemblyBlogNotificationService.cs`的类。
- en: In this file, we will implement the SignalR communication.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此文件中，我们将实现SignalR通信。
- en: 'Add the following namespaces:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下命名空间：
- en: '[PRE34]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add this class:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此类：
- en: '[PRE35]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A lot is happening here. The class is implementing `IBlogNotificationService`
    and `IAsyncDisposable`.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里发生了很多事情。这个类实现了`IBlogNotificationService`和`IAsyncDisposable`。
- en: In the constructor, we use dependency injection to get `NavigationManager` so
    we can figure out the URL to the server.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用依赖注入来获取`NavigationManager`，这样我们就可以确定服务器的URL。
- en: Then, we configure the connection to the hub. Then, we specify the URL to the
    hub; this should be the same as we specified in *step 7*.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们配置到hub的连接。然后，我们指定hub的URL；这应该与我们在*步骤7*中指定的相同。
- en: Now, we can configure the hub connection to listen for events. In this case,
    we listen for the `BlogPostChanged` event, the same name we specified in *step
    3*. When someone sends the event, the method we specify will run.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以配置hub连接以监听事件。在这种情况下，我们监听`BlogPostChanged`事件，这与我们在*步骤3*中指定的名称相同。当有人发送事件时，我们将指定的方法将运行。
- en: The method, in this case, triggers the event we have in `IBlogNotificationService`.
    Then, we start the connection. Since the constructor can’t be async, we won’t
    await the `StartAsync` method.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，该方法触发我们在`IBlogNotificationService`中定义的事件。然后，我们开始建立连接。由于构造函数不能是异步的，所以我们不会等待`StartAsync`方法。
- en: '`IBlogNotificationService` also implements the `SendNotification` method, and
    we trigger the event with the same name on the hub, which will result in the hub
    sending the `BlogPostChanged` event to all connected clients.'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IBlogNotificationService`还实现了`SendNotification`方法，我们在hub上触发具有相同名称的事件，这将导致hub向所有已连接客户端发送`BlogPostChanged`事件。'
- en: The last thing we do is make sure that we dispose of the hub connection.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最后要确保我们处理了hub连接。
- en: 'In the `Program.cs` file, we need to configure dependency injection. Just above
    `await builder.Build().RunAsync();`, add the following:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，我们需要配置依赖注入。在`await builder.Build().RunAsync();`之上，添加以下内容：
- en: '[PRE36]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is where things get a bit tricky, since we have different implementations
    depending on whether we’re using InteractiveServer or InteractiveWebAssembly.
    We need to make sure to run it in the same way both for `EditPost` and the `Post`
    component. In a mixed scenario like this, it is a better option to always implement
    it with a SignalR connection because then we can use the same implementation regardless
    of the hosting model. In the `SharedComponents` project, open `Pages/Admin/BlogPostEdit.razor`
    and change `@rendermode @(new InteractiveServerRenderMode(prerender: false))`
    to:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这里事情变得有点复杂，因为我们根据是否使用InteractiveServer或InteractiveWebAssembly有不同的实现。我们需要确保以相同的方式运行`EditPost`和`Post`组件。在这种混合场景中，始终使用SignalR连接是一个更好的选择，因为这样我们可以使用相同的实现，无论托管模型如何。在`SharedComponents`项目中，打开`Pages/Admin/BlogPostEdit.razor`并将`@rendermode
    @(new InteractiveServerRenderMode(prerender: false))`更改为：'
- en: '[PRE37]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You might need to clean and rebuild the solution to make it work.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能需要清理并重新构建解决方案才能使其工作。
- en: 'Open `Post.razor` and do the same thing; change `@rendermode InteractiveServer`
    to:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Post.razor`并执行相同操作；将`@rendermode InteractiveServer`更改为：
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, it’s time to carry out testing, run the project by pressing *Ctrl* + *F5*.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，是时候进行测试了，通过按*Ctrl* + *F5*来运行项目。
- en: Copy the URL and open another web browser. We should now have two web browser
    windows open showing us the blog.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制URL并打开另一个网络浏览器。现在，我们应该有两个网络浏览器窗口打开，显示博客。
- en: In the first window, open a blog post (it doesn’t matter which one), and in
    the second window, log in and edit the same blog post.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个窗口中，打开一个博客文章（任何一篇都可以），在第二个窗口中，登录并编辑同一篇博客文章。
- en: When we change the text of the blog post in the second window, the change should
    be reflected in real time in the first window.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第二个窗口中更改博客文章的文本时，该更改应该实时反映在第一个窗口中。
- en: In *13* steps (not counting testing), we have implemented real-time communication
    between the server and client, a Blazor WebAssembly client with .NET code running
    inside the web browser.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *13* 个步骤（不包括测试）中，我们实现了服务器和客户端之间的实时通信，一个运行在网页浏览器内的 .NET 代码的 Blazor WebAssembly
    客户端。
- en: And no JavaScript!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 而且不需要 JavaScript！
- en: State management frameworks
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态管理框架
- en: Speaking of JavaScript, in the JavaScript framework world of Angular, React,
    and so on, there are frameworks we can use to manage state (**Redux** and **ngRX**,
    to name a couple). This is the case for Blazor as well. Very simply, we have a
    state that we can change using methods; if the state changes, the components that
    are listening to that change will be notified.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到 JavaScript，在 Angular、React 等等 JavaScript 框架的世界中，有一些我们可以用来管理状态的框架（例如 **Redux**
    和 **ngRX**）。Blazor 也是如此。非常简单，我们有一个可以通过方法更改的状态；如果状态发生变化，监听该变化的组件将会收到通知。
- en: There are a bunch of frameworks like that for Blazor. I have personally never
    used a framework but instead built a `Singleton` service and connected my components
    to that (basically what these frameworks do).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Blazor，有大量类似的框架。我个人从未使用过框架，而是构建了一个 `Singleton` 服务并将我的组件连接到该服务（基本上就是这些框架所做的事情）。
- en: Check out Fluxor or Blazor-State if you want to dive deeper into that. There
    is another way to share state between components, which is called root-level cascading
    values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解，可以查看 Fluxor 或 Blazor-State。在组件之间共享状态的另一种方法是称为根级级联值。
- en: Root-level cascading values
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根级级联值
- en: Root-level cascading values are a new feature in .NET 8\. This is a great way
    to share state not only between components but also between different render modes.
    It will automatically add a cascading value; we have already used this feature,
    and then we added `AddCascadingAuthenticationState()`, which uses the root-level
    cascading value in the background.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 根级级联值是 .NET 8 中的一个新特性。这是在组件之间以及不同渲染模式之间共享状态的一个好方法。它将自动添加一个级联值；我们已经使用了这个特性，然后添加了
    `AddCascadingAuthenticationState()`，它在后台使用根级级联值。
- en: This does not share the value between InteractiveServer and InteractiveWebAssembly,
    though, but gives us a way to share the state between components without using
    dependency injection.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不在 InteractiveServer 和 InteractiveWebAssembly 之间共享值，但它为我们提供了一种在不使用依赖注入的情况下在组件之间共享状态的方法。
- en: The really nice thing is that if the value changes, it will automatically change
    the parameter and trigger a rerender of the component. No special code is needed
    inside the component. But subscribing to value changes does have a cost, so be
    careful with how many things you use with root-level cascading values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 真正美妙的是，如果值发生变化，它将自动更改参数并触发组件的重渲染。组件内部不需要特殊代码。但是订阅值变化确实有成本，所以使用根级级联值时要小心，不要使用太多。
- en: 'Usage could look something like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式可能看起来像这样：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And in `Program.cs`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is possible to update the values by calling the `NotifyChangedAsync` method
    on `CascadingValueSource`. An implementation could look something like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `CascadingValueSource` 上调用 `NotifyChangedAsync` 方法来更新值。一个实现可能看起来像这样：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we are using the `INotifyPropertyChanged` interface to call `NotifyChangedAsync`
    when we change the property. On GitHub, you can find a full example of this if
    you want to play further with it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `INotifyPropertyChanged` 接口在更改属性时调用 `NotifyChangedAsync`。如果你想要进一步探索，你可以在
    GitHub 上找到一个完整的示例。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how we can handle state in our application and how
    we can use local storage to store data, both encrypted and not. We looked at different
    ways of doing that, and we also made sure to include SignalR to be able to use
    real-time communication with the server.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何在我们的应用程序中处理状态，以及如何使用本地存储来存储数据，无论是加密的还是未加密的。我们探讨了不同的方法，并确保包括 SignalR
    以便能够使用与服务器之间的实时通信。
- en: Almost all applications need to save data in some form. Perhaps it can be settings
    or preferences. The things we covered in the chapter are the most common ones,
    but we should also know that there are many open-source projects we can use to
    persist state. I personally prefer the components to load state from a database
    when needed be self-contained, and not have to rely on state coming or being somewhere
    else. This approach has served me well in the past.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有应用程序都需要以某种形式保存数据。这可能包括设置或偏好。本章中我们讨论的内容是最常见的，但我们也应该知道，有许多开源项目我们可以用来持久化状态。我个人更喜欢组件在需要时从数据库中加载数据，这样就可以自给自足，而不必依赖于状态来自其他地方或某处。这种方法在过去一直为我服务得很好。
- en: In the next chapter, we will take a look at debugging. Hopefully, you haven’t
    needed to know how to debug yet!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨调试。希望你还没有必要知道如何调试！
