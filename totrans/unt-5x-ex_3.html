<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Project B &#x2013; the Space Shooter"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Project B – the Space Shooter</h1></div></div></div><p>This chapter enters new territory now as we begin development work on our second game, which is a twin-stick space shooter. The twin-stick genre simply refers to any game in which the player input for motion spans two dimensions or axes, typically one axis for movement and one for rotation. Example twin-stick games include <span class="emphasis"><em>Zombies Ate My Neighbors</em></span> and <span class="emphasis"><em>Geometry Wars</em></span>. Our game will rely heavily on coding in C#, as we'll see. The primary purpose of this is to demonstrate by example just how much can be achieved with Unity procedurally (that is, via script), even without using the editor and level-building tools. We'll still use these tools to some extent but not as much here, and that's a deliberate and not an accidental move. Consequently, this chapter assumes that you have not only completed the game project created in the previous two chapters, but also have a good, basic knowledge of C# scripting generally, though not necessarily in Unity. So, let's roll up our sleeves, if we have any, and get stuck in making a twin-stick shooter. This chapter covers the following important topics as well as others:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spawning and prefabs</li><li class="listitem" style="list-style-type: disc">Twin-stick controls and axial movement</li><li class="listitem" style="list-style-type: disc">Player controllers and shooting mechanics</li><li class="listitem" style="list-style-type: disc">Basic enemy movement and AI</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Remember to see the game created here, and its related work, in abstract terms, that is, as general tools and concepts with multiple applications. For your own projects, you may not want to make a twin-stick shooter, and that's fine. I cannot possibly know every kind of game that you want to make. However, it's important to see the ideas and tools used here as being transferrable, as being the kind of things you can creatively use for your own games. Being able to see this is very important when working with Unity or any engine.</p></div></div><div class="section" title="Looking ahead – the completed project"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Looking ahead – the completed project</h1></div></div></div><p>Before getting stuck in <a id="id176" class="indexterm"/>with the twin-stick shooter game, let's see what the completed project looks like and how it works. See <span class="emphasis"><em>Figure 3.1</em></span>. The game to be created will contain one scene only. In this scene, the player controls a spaceship that can shoot oncoming enemies. The directional keyboard arrows, and WASD, move the spaceship around the level, and it will always turn to face the mouse pointer. Clicking the left mouse button will fire ammo.</p><div class="mediaobject"><img src="graphics/B05118_03_01.png.jpg" alt="Looking ahead – the completed project"/><div class="caption"><p>Figure 3.1: The completed twin-stick shooter game</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The completed <code class="literal">TwinStickShooter</code> project, as discussed in this chapter and the next, can be found in the book companion files in the <code class="literal">Chapter03/TwinStickShooter folder</code>.</p><p>Most assets for this game (including sound and textures) were sourced from the freely accessible site, <a class="ulink" href="http://OpenGameArt.org">OpenGameArt.org</a>. Here, you can find many game assets available <a id="id177" class="indexterm"/>through the public domain or creative common licenses or other licenses.</p></div></div></div></div>
<div class="section" title="Getting started with a space shooter"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Getting started with a space shooter</h1></div></div></div><p>To get started, create <a id="id178" class="indexterm"/>a blank Unity 3D project without any packages or specific assets. Details about creating new projects can be found in <a class="link" href="ch01.html" title="Chapter 1. The Coin Collection Game – Part 1">Chapter 1</a>, <span class="emphasis"><em>The Coin Collection Game – Part 1</em></span>. We'll be coding everything from scratch this time around. Once a project is generated, create some basic folders to structure and organize the project assets from the outset. This is very important to keep track of your files as you work. Create folders for <code class="literal">Textures</code>, <code class="literal">Scenes</code>, <code class="literal">Materials</code>, <code class="literal">Audio</code>, <code class="literal">Prefabs</code>, and <code class="literal">Scripts</code>. See <span class="emphasis"><em>Figure 3.2</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_02.png.jpg" alt="Getting started with a space shooter"/><div class="caption"><p>Figure 3.2: Create folders for structure and organization</p></div></div><p>Next, our game will depend on some graphical and audio assets. These are included in the book companion files in the <code class="literal">Chapter03/Assets</code> folder, but can also be downloaded online from <a class="ulink" href="http://OpenGameArt.org">OpenGameArt.org</a>. Let's start with textures for the player spaceship, enemy spaceships, and star-field background. Drag and drop <code class="literal">Textures</code> from Windows Explorer or Finder to the Unity <span class="strong"><strong>Project</strong></span> panel in the <code class="literal">Textures</code> folder. Unity imports and configures the <a id="id179" class="indexterm"/>textures automatically. <span class="emphasis"><em>See Figure 3.3</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_03.png.jpg" alt="Getting started with a space shooter"/><div class="caption"><p>Figure 3.3: Importing Texture assets for the spaceship, enemies, star background, and ammo</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Use of the provided assets is optional. You can create your own if you prefer. Just drag and drop your own textures in place of the included assets, and you can still follow along with the tutorial just fine.</p></div></div><p>By default, Unity imports image files as regular textures for use on 3D objects, and it assumes that their pixel dimensions are a power-2 size (4, 8, 16, 32, 64, 128, 256, and so on). If the size is not actually one of these, then Unity will up-scale or down-scale the texture to the nearest valid size. This is not appropriate behavior, however, for a 2D top-down space shooter game in which imported textures should appear at their native (imported) size without any scaling or automatic adjustment. To fix this, select all the imported textures and, from the <span class="strong"><strong>Object Inspector</strong></span>, change their <span class="strong"><strong>Texture Type</strong></span> from <span class="strong"><strong>Texture</strong></span> to <span class="strong"><strong>Sprite (2D and UI)</strong></span>. Once changed, click on the <span class="strong"><strong>Apply</strong></span> button to update the settings and the <a id="id180" class="indexterm"/>textures will retain their imported dimensions. See <span class="emphasis"><em>Figure 3.4</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_04.png.jpg" alt="Getting started with a space shooter"/><div class="caption"><p>Figure 3.4: Changing the Texture type for imported textures</p></div></div><p>After changing the <span class="strong"><strong>Texture Type</strong></span> setting to <span class="strong"><strong>Sprite (2D and UI)</strong></span>, also remove the check mark from the <span class="strong"><strong>Generate Mip Maps</strong></span> box, in case this box is enabled. This will prevent Unity from automatically downgrading the quality of textures based on their distance from the camera in the scene. This ensures that your textures retain their highest quality. More information on <a id="id181" class="indexterm"/>2D texture settings and Mip Maps can be found at the online Unity documentationat <a class="ulink" href="http://docs.unity3d.com/Manual/class-TextureImporter.html">http://docs.unity3d.com/Manual/class-TextureImporter.html</a>. <span class="emphasis"><em>See Figure 3.5</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_05.png.jpg" alt="Getting started with a space shooter"/><div class="caption"><p>Figure 3.5: Removing MipMapping from imported textures</p></div></div><p>Now you can easily drag and drop your textures to the scene adding them as sprite objects. You can't drag and drop them from the <span class="strong"><strong>Project</strong></span> panel to the viewport, but you can drag and drop them from the <span class="strong"><strong>Project</strong></span> panel to the <span class="strong"><strong>Hierarchy</strong></span> panel. When you do this, the texture will automatically be added as a sprite object in the <span class="strong"><strong>Scene</strong></span>. We'll make frequent use of this <a id="id182" class="indexterm"/>feature as we work at creating spaceship objects. See <span class="emphasis"><em>Figure 3.6</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_06.png.jpg" alt="Getting started with a space shooter"/><div class="caption"><p>Figure 3.6: Adding sprites to the scene</p></div></div><p>Next, let's import music and sound effects, which are also included in the book companion files in the <code class="literal">Chapter03/Assets/Audio</code> folder. These assets were downloaded from <a class="ulink" href="http://OpenGameArt.org">OpenGameArt.org</a>. To import the audio, simply drag and drop the files from Windows Explorer or Mac Finder to the <span class="strong"><strong>Project</strong></span> panel. When you do this, Unity automatically imports and configures the assets. You can give the audio a test from within the Unity <a id="id183" class="indexterm"/>Editor by pressing play on the preview toolbar from the <span class="strong"><strong>Object Inspector</strong></span>. See <span class="emphasis"><em>Figure 3.7</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_07.png.jpg" alt="Getting started with a space shooter"/><div class="caption"><p>Figure 3.7: Previewing audio from the Object Inspector</p></div></div><p>As with texture files, Unity imports audio files using a set of default parameters. These parameters are typically suitable for short sound effects such as footsteps, gunshots, and explosions, but for longer tracks such as music, they can be problematic, causing long level-loading times. To fix this, select the music track in the <span class="strong"><strong>Project</strong></span> panel, and from the <span class="strong"><strong>Object Inspector</strong></span>, disable the <span class="strong"><strong>Preload Audio Data</strong></span> checkbox. From the <span class="strong"><strong>Load Type</strong></span> drop-down box, select the <span class="strong"><strong>Streaming</strong></span> option. This ensures that the music track is streamed as opposed to loaded wholly in memory at level startup. See <span class="emphasis"><em>Figure 3.8</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_08.png.jpg" alt="Getting started with a space shooter"/><div class="caption"><p>Figure 3.8: Configuring music tracks for streaming</p></div></div></div>
<div class="section" title="Creating a player object"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Creating a player object</h1></div></div></div><p>We've now <a id="id184" class="indexterm"/>imported most assets for the twin-stick shooter and we're ready to create a player spaceship object, that is, the object that the player will control and move around. Creating this might seem a trivial matter of simply dragging and dropping the relevant player sprite from the <span class="strong"><strong>Project</strong></span> panel to the scene, but things are not so simple. The player is a complex object with many different behaviors, as we'll see. For this reason, more care needs to be taken about creating the player. To get started, create an empty game object in the scene by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu and name the object, <code class="literal">Player</code>. See <span class="emphasis"><em>Figure 3.9</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_09.png.jpg" alt="Creating a player object"/><div class="caption"><p>Figure 3.9: Starting to create the player</p></div></div><p>The newly created object may or may not be centered at the world origin of <span class="emphasis"><em>(0, 0, 0)</em></span> and its rotation properties may not be consistently <code class="literal">0</code> across <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span>. To ensure a completely zeroed transform, you could manually set the values to <code class="literal">0</code> by entering them directly in the <span class="strong"><strong>Transform</strong></span> component for the object in the <span class="strong"><strong>Object Inspector</strong></span>. However, you can set them all to <code class="literal">0</code> automatically by clicking on the cog icon at the top left corner of the <span class="strong"><strong>Transform</strong></span> component and selecting <span class="strong"><strong>Reset</strong></span> from the context menu. See <span class="emphasis"><em>Figure 3.10</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_10.png.jpg" alt="Creating a player object"/><div class="caption"><p>Figure 3.10: Resetting the Transform component</p></div></div><p>Next, drag and drop the <code class="literal">Player</code> drop ship sprite (in the <code class="literal">Textures</code> folder) from the <span class="strong"><strong>Project</strong></span> panel to the <span class="strong"><strong>Hierarchy</strong></span> panel, making it a child of the empty player object. Then, rotate the drop ship sprite by <code class="literal">90</code> degrees in <span class="strong"><strong>X</strong></span> and <code class="literal">-90</code> degrees in <span class="strong"><strong>Y</strong></span>. This makes the sprite oriented in the <a id="id185" class="indexterm"/>direction of its parent's forward vector and also flattened on the ground plane. The game camera will take a top-down view. See <span class="emphasis"><em>Figure 3.11</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_11.png.jpg" alt="Creating a player object"/><div class="caption"><p>Figure 3.11: Aligning the Player ship</p></div></div><p>You can confirm that the ship sprite has been aligned correctly in relation to its parent by selecting the <code class="literal">Player</code> object and viewing the blue forward vector arrow. The front of the ship sprite and the blue forward vector should be pointing in the same direction. If they're not, then continue to rotate the sprite by 90 degrees until they're in alignment. This will be important later when coding player movement to make the ship travel in the direction it's looking. See <span class="emphasis"><em>Figure 3.12</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_12.png.jpg" alt="Creating a player object"/><div class="caption"><p>Figure 3.12: The blue arrow is called the forward vector</p></div></div><p>Next, the <code class="literal">Player</code> object should react to physics, that is, the <code class="literal">Player</code> object is solid and affected by physical forces. It must collide with other solids and also take damage from enemy ammo when <a id="id186" class="indexterm"/>hit. To facilitate this, two additional components should be added to the <code class="literal">Player</code> object, specifically, a <span class="strong"><strong>Rigidbody</strong></span> and <span class="strong"><strong>Collider</strong></span>. To do this, select the <code class="literal">Player</code> object (not the <code class="literal">Sprite</code> object) and navigate to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Rigidbody</strong></span> from the application menu. Then, choose <code class="literal">Component</code> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Capsule Collider</strong></span> from the menu. This adds both a <span class="strong"><strong>Rigidbody</strong></span> and <span class="strong"><strong>Collider</strong></span>. See <span class="emphasis"><em>Figure 3.13</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_13.png.jpg" alt="Creating a player object"/><div class="caption"><p>Figure 3.13: Adding a Rigidbody and Capsule Collider to the Player object</p></div></div><p>The <span class="strong"><strong>Collider</strong></span> component is used to approximate the volume of the object and the <span class="strong"><strong>Rigibody</strong></span> component uses the <span class="strong"><strong>Collider</strong></span> to determine how physical forces should be applied realistically. Let's adjust <span class="strong"><strong>Capsule Collider</strong></span> a little because the default settings typically do not match up with the <code class="literal">Player</code> sprite as intended. Specifically, adjust the <span class="strong"><strong>Direction</strong></span>, <span class="strong"><strong>Radius</strong></span>, and <span class="strong"><strong>Height</strong></span> values until <span class="strong"><strong>Capsule</strong></span> encompasses the <code class="literal">Player</code> sprite and represents the <a id="id187" class="indexterm"/>volume of the player. See <span class="emphasis"><em>Figure 3.14</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_14.png.jpg" alt="Creating a player object"/><div class="caption"><p>Figure 3.14: Adjusting the spaceship Capsule Collider</p></div></div><p>By default, the <code class="literal">Rigidbody</code> component is configured to approximate objects that are affected by gravity and fall to the ground, bumping into and reacting to other solids in the scene. This is not appropriate for a spaceship that flies around. Consequently, the <code class="literal">Rigidbody</code> should be adjusted. Specifically, remove the <span class="strong"><strong>Use Gravity</strong></span> check mark to prevent the object from falling to the ground. Additionally, enable the <span class="strong"><strong>Freeze Position</strong></span> <span class="strong"><strong>Y</strong></span> checkbox and the <span class="strong"><strong>Freeze Rotation</strong></span> <span class="strong"><strong>Z</strong></span> checkbox to prevent the spaceship moving and rotating around axes that are undesirable in a 2D top-down game. See <span class="emphasis"><em>Figure 3.15</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_15.png.jpg" alt="Creating a player object"/><div class="caption"><p>Figure 3.15: Configuring the Rigidbody component for the player spaceship</p></div></div><p>Excellent work! We've now configured the player spaceship object successfully. Of course, it still doesn't move or do anything specific in the game. This is simply because we haven't added any <a id="id188" class="indexterm"/>code yet. That's something we'll turn to next—making the player object respond to user input.</p></div>
<div class="section" title="Player input"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Player input</h1></div></div></div><p>The <code class="literal">Player</code> object is <a id="id189" class="indexterm"/>now created in the scene, configured with both <span class="strong"><strong>Rigidbody</strong></span> and <span class="strong"><strong>Collider</strong></span> components. However, this object doesn't respond to player controls. In a twin-stick shooter, the player provides input on two axes and can typically shoot a weapon. This often means that keyboard WASD buttons guide player movements up, down, left, and right. In addition, mouse movement controls the direction in which the player is looking and aiming and the left mouse button typically fires a weapon. This is the control scheme required for our game. To implement this, we'll need to create a <code class="literal">PlayerController</code> script file. Right-click on the <code class="literal">Scripts</code> folder of the <span class="strong"><strong>Project</strong></span> panel and create a new C# script file named <code class="literal">PlayerController.cs</code>. See <span class="emphasis"><em>Figure 3.16</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_16.png.jpg" alt="Player input"/><div class="caption"><p>Figure 3.16: Creating a player controller C# script file</p></div></div><p>In the <code class="literal">PlayerController.cs</code> script file, the following code (as shown in <span class="emphasis"><em>Code Sample 3.1</em></span>) should be featured. Comments follow this sample:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class PlayerController : MonoBehaviour
{
  //------------------------------
  private Rigidbody ThisBody = null;
  private Transform ThisTransform = null;
  
  public bool MouseLook = true;
  <span class="strong"><strong>public string HorzAxis = "Horizontal";</strong></span>
  <span class="strong"><strong>public string VertAxis = "Vertical";</strong></span>
  <span class="strong"><strong>public string FireAxis = "Fire1";</strong></span>
  public float MaxSpeed = 5f;

  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    ThisBody = GetComponent&lt;Rigidbody&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //Update movement
    <span class="strong"><strong>float Horz = Input.GetAxis(HorzAxis);</strong></span>
    <span class="strong"><strong>float Vert = Input.GetAxis(VertAxis);</strong></span>
    Vector3 MoveDirection = new Vector3(Horz, 0.0f, Vert);
    <span class="strong"><strong>ThisBody.AddForce</strong></span>(MoveDirection.normalized * MaxSpeed);
    
    //Clamp speed
    ThisBody.velocity = new Vector3(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed),
      Mathf.Clamp(ThisBody.velocity.y, -MaxSpeed, MaxSpeed),
      Mathf.Clamp(ThisBody.velocity.z, -MaxSpeed, MaxSpeed));
    
    //Should look with mouse?
    <span class="strong"><strong>if(MouseLook)</strong></span>
    {
      //Update rotation - turn to face mouse pointer
      Vector3 MousePosWorld = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x,Input.mousePosition.y, 0.0f));
        MousePosWorld = new Vector3(MousePosWorld.x, 0.0f, MousePosWorld.z);
      //Get direction to cursor
      Vector3 LookDirection = MousePosWorld - ThisTransform.position;
      
      //FixedUpdate rotation
      <span class="strong"><strong>ThisTransform.localRotation</strong></span> = Quaternion.LookRotation(LookDirection.normalized,Vector3.up);
    }

  }
}
//------------------------------</pre></div><div class="section" title="Code Sample 3.1"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Code Sample 3.1</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">PlayerController</code> class should be attached to the <code class="literal">Player</code> object in the scene. Overall, it accepts input from the player and will control the movement of the spaceship.</li><li class="listitem" style="list-style-type: disc">The <a id="id190" class="indexterm"/><code class="literal">Awake</code> function is called once when the object is created at the level start. During this function, two components are retrieved, namely, the <span class="strong"><strong>Transform</strong></span> component for controller player rotation and the <span class="strong"><strong>Rigidbody</strong></span> component for controller player movement. The <span class="strong"><strong>Transform</strong></span> component can be used to control player movement through the <span class="strong"><strong>Position</strong></span> property, but this ignores collisions and solid objects. The <span class="strong"><strong>Rigidbody</strong></span> component, in contrast, prevents the player object from passing through other solids.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">FixedUpdate</code> function is called once on each update of the physics system, which is a fixed number of times per second. <code class="literal">FixedUpdate</code> differs from <code class="literal">Update</code>, which is called once per frame and can vary on a per second basis as the frame rate fluctuates. If you ever need to control an object through the physics system, using components such as <span class="strong"><strong>Rigidbody</strong></span>, then you should always do so in <code class="literal">FixedUpdate</code> and not <code class="literal">Update</code>. This is a Unity convention that you should remember for best results.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Input.GetAxis</code> function is called on each <code class="literal">FixedUpdate</code> to read the axial input data from an input device, such as the keyboard or gamepad. This function reads from two named axes, <code class="literal">Horizontal</code> (left-right) and <code class="literal">Vertical</code> (up-down). These work in a normalized space of <span class="emphasis"><em>-1</em></span> to <span class="emphasis"><em>1</em></span>. This means that when the left key is pressed and held down, the <code class="literal">Horizontal</code> axis returns <span class="emphasis"><em>-1</em></span> and, when the right key is being pressed and held down, the <code class="literal">Horizontal</code> axis returns <span class="emphasis"><em>1</em></span>. A value of <span class="emphasis"><em>0</em></span> indicates that either no relevant key is being pressed or both left and right are being pressed together, canceling each other out. A similar principle applies for the <code class="literal">Vertical</code> axis. Up refers to <span class="emphasis"><em>1</em></span>, down to <span class="emphasis"><em>-1</em></span>, and no keypress relates to <span class="emphasis"><em>0</em></span>. More information on the <code class="literal">GetAxis</code> function can be found <a id="id191" class="indexterm"/>online in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Input.GetAxis.html">http://docs.unity3d.com/ScriptReference/Input.GetAxis.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Rigidbody.AddForce</code> function is used to apply a physical force to the <code class="literal">Player</code> object, moving it in a specific direction. <code class="literal">AddForce</code> encodes a velocity, moving the object in a specific direction by a specific strength. The direction is encoded in the <code class="literal">MoveDirection</code> vector, which is based on player input from both the <code class="literal">Horizontal</code> and <code class="literal">Vertical</code> axes. This direction is multiplied by our maximum speed to ensure that the object travels as fast as needed. For more <a id="id192" class="indexterm"/>information on <code class="literal">AddForce</code>, see the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html">http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html</a>.</li><li class="listitem" style="list-style-type: disc">The <a id="id193" class="indexterm"/><code class="literal">Camera.ScreenToWorldPoint</code> function is used to convert the screen position of the mouse cursor in the game window into a position in the game world, giving the player a target destination to look at. This code is responsible for making the player look at the mouse cursor always. However, as we'll see soon, some further tweaking is required to make this code work properly. For <a id="id194" class="indexterm"/>more information on <code class="literal">ScreenToWorldPoint</code>, see the Unity online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html">http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html</a>.</li></ul></div></div></div>
<div class="section" title="Configuring the game camera"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Configuring the game camera</h1></div></div></div><p>The preceding <a id="id195" class="indexterm"/>code allows you to control the <code class="literal">Player</code> object, but there are some problems. One of them is that the player doesn't seem to face the position of the mouse cursor, even though our code is designed to achieve this behavior. The reason is that the camera, by default, is not configured as it needs to be for a top-down 2D game. We'll fix this in this section. To get started, the scene camera should have a top-down view of the scene. To achieve this, switch the <span class="strong"><strong>Scene</strong></span> viewport to a top-down 2D view by clicking on the <span class="strong"><strong>ViewCube</strong></span>, the up arrow in the top right corner of the <span class="strong"><strong>Scene</strong></span> viewport. This switches your viewport to a top view. See <span class="emphasis"><em>Figure 3.17</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_17.png.jpg" alt="Configuring the game camera"/><div class="caption"><p>Figure 3.17: The viewcube can change the viewport perspective</p></div></div><p>You can see <a id="id196" class="indexterm"/>that the viewport is in a top view because the viewcube will list <span class="strong"><strong>Top</strong></span> as the current view. See <span class="emphasis"><em>Figure 3.18</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_18.png.jpg" alt="Configuring the game camera"/><div class="caption"><p>Figure 3.18: Top view in the Scene viewport</p></div></div><p>From here, you can have the scene camera conform to the viewport camera exactly, giving you an instant top-down view for your game. To do this, select the <span class="strong"><strong>Camera</strong></span> in the <span class="strong"><strong>Scene</strong></span> (or from the <span class="strong"><strong>Hierarchy</strong></span> panel) and then choose <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Align With View</strong></span> from the application menu. See <span class="emphasis"><em>Figure 3.19</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_19.png.jpg" alt="Configuring the game camera"/><div class="caption"><p>Figure 3.19: Aligning the camera to the Scene viewport</p></div></div><p>This makes your <a id="id197" class="indexterm"/>game look much better than before, but there's still a problem. When the game is running, the spaceship still doesn't look at the mouse cursor as intended. This is because the camera is a <span class="strong"><strong>Perspective</strong></span> camera and the conversion between a screen point and world point is leading to unexpected results. We can fix this by changing the camera to an <span class="strong"><strong>Orthographic</strong></span> camera, which is a truly 2D camera that allows no perspective distortion. To do this, select the <span class="strong"><strong>Camera</strong></span> in the scene, and from the <span class="strong"><strong>Object Inspector</strong></span>, change the <span class="strong"><strong>Projection</strong></span> setting from <span class="strong"><strong>Perspective</strong></span> to <span class="strong"><strong>Orthographic</strong></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_20.png.jpg" alt="Configuring the game camera"/><div class="caption"><p>Figure 3.20: Changing the Camera to Orthographic mode</p></div></div><p>Every orthographic camera has a <span class="strong"><strong>Size</strong></span> field in the <span class="strong"><strong>Object Inspector</strong></span>, which is not present for perspective cameras. This field controls how many units in the world view correspond to pixels on the screen. We want a 1:1 ratio or relationship between world units to pixels in order to ensure that our textures appear at the correct size and cursor movement has the intended effect. The <a id="id198" class="indexterm"/>target resolution for our game will be Full HD, which is 1920 x 1080, and this has an aspect ratio of 16:9. For this resolution, the orthographic <span class="strong"><strong>Size</strong></span> should be <code class="literal">5.4</code>. The reasons for this value are beyond the scope of this book, but the formula to arrive at it is <span class="emphasis"><em>screen height (in pixels) / 2 / 100</em></span>. Therefore, <span class="emphasis"><em>1080 / 2 / 100 = 5.4</em></span>. See <span class="emphasis"><em>Figure 3.21</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_21.png.jpg" alt="Configuring the game camera"/><div class="caption"><p>Figure 3.21: Changing orthographic size for a 1:1 pixel-to-screen ratio</p></div></div><p>Finally, make sure that your <span class="strong"><strong>Game</strong></span> tab view is configured to display the game at a <span class="strong"><strong>16:9</strong></span> aspect ratio. If it isn't, click on the aspect drop-down list at the top left corner of the <span class="strong"><strong>Game</strong></span> view and choose the <span class="strong"><strong>16:9</strong></span> option. See <span class="emphasis"><em>Figure 3.22</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_22.png.jpg" alt="Configuring the game camera"/><div class="caption"><p>Figure 3.22: Displaying the game at a 16:9 aspect ratio</p></div></div><p>Now try running the game, and you have a player spaceship that moves based on WASD input and also turns to face the mouse cursor. Great work! See <span class="emphasis"><em>Figure 3.23</em></span>. The game is really taking <a id="id199" class="indexterm"/>shape. However, there's lots more work to do.</p><div class="mediaobject"><img src="graphics/B05118_03_23.png.jpg" alt="Configuring the game camera"/><div class="caption"><p>Figure 3.23: Turning to face the cursor!</p></div></div></div>
<div class="section" title="Bounds locking"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Bounds locking</h1></div></div></div><p>On previewing the <a id="id200" class="indexterm"/>game thus far, the spaceship probably looks too large. We can fix this easily by changing the scale of the <code class="literal">Player</code> object. I've used a value of <code class="literal">0.5</code> for the <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> axes. See <span class="emphasis"><em>Figure 3.24</em></span>. However, even with a more sensible scale, a problem remains. Specifically, it's possible to move the player outside the boundaries of the screen without limit. This means that the player can fly off into the distance, out of view, and never be seen again. Instead, the camera should remain still and the player movement should be limited to the camera view or bounds so that it never exits the view.</p><div class="mediaobject"><img src="graphics/B05118_03_24.png.jpg" alt="Bounds locking"/><div class="caption"><p>Figure 3.24: Rescaling the player</p></div></div><p>There are different ways to achieve bounds locking, most of which involve scripting. One way is to simply clamp the positional values of the <code class="literal">Player</code> object between a specified range, a minimum and maximum. Consider <span class="emphasis"><em>Code Sample 3.2</em></span> for a new C# class called <code class="literal">BoundsLock</code>. This <a id="id201" class="indexterm"/>script file should be attached to the player.</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class BoundsLock : MonoBehaviour 
{
  //------------------------------
  private Transform ThisTransform = null;
  public Vector2 HorzRange = Vector2.zero;
  public Vector2 VertRange = Vector2.zero;
  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void <span class="strong"><strong>LateUpdate</strong></span> () 
  {
    //Clamp position
    ThisTransform.position = new Vector3(Mathf.Clamp(ThisTransform.position.x, HorzRange.x, HorzRange.y),
    ThisTransform.position.y,
    Mathf.Clamp(ThisTransform.position.z, VertRange.x, VertRange.y));
  }
  //------------------------------
}
//------------------------------</pre></div><div class="section" title="Code Sample 3.2"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Code Sample 3.2</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id202" class="indexterm"/><code class="literal">LateUpdate</code> function is always called after all the <code class="literal">FixedUpdate</code> and <code class="literal">Update</code> calls, allowing an object to modify its position before it's rendered to the screen. More information <a id="id203" class="indexterm"/>on <code class="literal">LateUpdate</code> can be found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Mathf.Clamp</code> function ensures that a specified value is capped between a minimum and maximum range.</li><li class="listitem" style="list-style-type: disc">To use the <code class="literal">BoundsLock</code> script, simply drag and drop the file to the <code class="literal">Player</code> object and specify minimum and maximum values for its position. These values are specified in world position coordinates and can be determined by temporarily moving the <code class="literal">Player</code> object to the camera extremes and recording its position from the <span class="strong"><strong>Transform</strong></span> component:</li></ul></div><div class="mediaobject"><img src="graphics/B05118_03_25.png.jpg" alt="Code Sample 3.2"/><div class="caption"><p>Figure 3.25: Setting Bounds Lock</p></div></div><p>Now take the game for a test run by pressing play on the toolbar. The player spaceship should remain in view and be unable to move offscreen. Splendid!</p></div></div>
<div class="section" title="Health"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Health</h1></div></div></div><p>Both the player <a id="id204" class="indexterm"/>spaceship and enemies need health. Health is a measure of a character's presence and legitimacy in the scene, typically scored as a value between 0-100. 0 means death and 100 means full health. Now, although health is, in many respects, specific to each instance, (The player has a unique health bar and each enemy has theirs.) there are nevertheless so many things in common, in terms of behavior, between player and enemy health that it makes sense to code health as a separate component and class that can be attached to all objects that need health. Consider <span class="emphasis"><em>Code Sample 3.3</em></span>, which should be attached to the player and all enemies or objects that need health. Comments follow:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------
public class Health : MonoBehaviour
{
  public GameObject DeathParticlesPrefab = null;
  private Transform ThisTransform = null;
  public bool ShouldDestroyOnDeath = true;
  //------------------------------
  void Start()
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  <span class="strong"><strong>public float HealthPoints</strong></span>
  {
    get
    {
      return _HealthPoints;
    }

    set
    {
      _HealthPoints = value;

      <span class="strong"><strong>if(_HealthPoints &lt;= 0)</strong></span>
      {
        <span class="strong"><strong>SendMessage</strong></span>("Die", SendMessageOptions.DontRequireReceiver);

        if(DeathParticlesPrefab != null)
          Instantiate(DeathParticlesPrefab, ThisTransform.position, ThisTransform.rotation);

        if(ShouldDestroyOnDeath)
          Destroy(gameObject);
      }
    }
  }
  //------------------------------
  <span class="strong"><strong>[SerializeField]</strong></span>
  private float _HealthPoints = 100f;
}
//------------------------------</pre></div><div class="section" title="Code Sample 3.3"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Code Sample 3.3</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id205" class="indexterm"/><code class="literal">Health</code> class maintains object health through a <code class="literal">private</code> variable, <code class="literal">_HealthPoints</code>, which is accessed through a C# property, <code class="literal">HealthPoints</code>. This property features both <code class="literal">get</code> and <code class="literal">set</code> accessors to return and set the <code class="literal">Health</code> variable.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">_HealthPoints</code> variable is declared as <code class="literal">SerializedField</code>, allowing its value to be visible in the <span class="strong"><strong>Inspector</strong></span>. This helps us see the value of the player's health during runtime and debug and test the effects of our code.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Health</code> class is an example of event-driven programming. This is because the class could have continually checked the status of object health during an <code class="literal">Update</code> function; checking to see whether the object had died by its health falling below <span class="emphasis"><em>0</em></span>. Instead, the check for death is made during the C# property <code class="literal">set</code> method. This makes sense because <code class="literal">set</code> is the only place where health will ever change. This means that Unity is saved from a lot of work in each frame. That's great performance saving!</li><li class="listitem" style="list-style-type: disc"><code class="literal">Health</code> class uses the <code class="literal">SendMessage</code> function. This function lets you call any other public function on any component attached to the object by specifying the function name as a string. In this case, a function called <code class="literal">Die</code> will be executed on every component attached to the object (if such a function exists). If no function of a matching name exists, then nothing happens for that component. This is a quick and easy way to run customized behavior on an object in a type-agnostic way without using any polymorphism. The disadvantage is that <code class="literal">SendMessage</code> internally uses a process called <code class="literal">Reflection</code>, which is slow and performance-prohibitive. For this reason, <code class="literal">SendMessage</code> should be used infrequently only for death events and similar events, but not frequently, such as every frame. More information on <code class="literal">SendMessage</code> can <a id="id206" class="indexterm"/>be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html</a>.</li><li class="listitem" style="list-style-type: disc">When health falls below <span class="emphasis"><em>0</em></span>, triggering a death condition, the code will instantiate a death particle system to show an effect on death if a particle system is specified (more on this shortly).</li></ul></div><p>When the <a id="id207" class="indexterm"/>
<code class="literal">Health</code> script is attached to the player spaceship, it appears as a component in the <span class="strong"><strong>Inspector</strong></span>. It contains a field for a <span class="strong"><strong>Death Particles Prefab</strong></span>. This is an optional field (it can be null), specifying a particle system to be spawned when the object dies. This lets you create explosions or blood splatter effects easily when objects die. See <span class="emphasis"><em>Figure 3.26</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_26.png.jpg" alt="Code Sample 3.3"/><div class="caption"><p>Figure 3.26: Attaching the Health script</p></div></div></div></div>
<div class="section" title="Death and particles"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Death and particles</h1></div></div></div><p>In this <a id="id208" class="indexterm"/>twin-stick shooter game, both the player and enemies are spaceships. When they're destroyed, they should explode in a fiery ball. This is really the only kind of effect that would be believable. To achieve explosions, we can use a particle system. This simply refers to a special kind of object that features two main parts, namely, a <span class="strong"><strong>Hose</strong></span> (or <span class="strong"><strong>Emitter</strong></span>) and <span class="strong"><strong>Particles</strong></span>. The emitter refers to the part that spawns or generates new particles into the world and the particles are many small <a id="id209" class="indexterm"/>objects or pieces that, once spawned, move and travel along their own trajectories. In short, particle systems are ideal to create rain, snow, fog, sparkles, and explosions. We can create our own Particle Systems from scratch using the menu option, <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Particle System</strong></span>, or we can use any premade particle system included with Unity. Let's use some of the premade particle systems. To do this, import the <code class="literal">ParticleSystems</code> package to the project by navigating to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Import Package</strong></span> | <span class="strong"><strong>ParticleSystems</strong></span> from the application menu. See <span class="emphasis"><em>Figure 3.27</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_27.png.jpg" alt="Death and particles"/><div class="caption"><p>Figure 3.27: Importing Particle Systems to the project</p></div></div><p>After the <span class="strong"><strong>Import</strong></span> dialog appears, leave all settings at their defaults, and simply click on <span class="strong"><strong>Import</strong></span> to import the complete package, including all particle systems. The <code class="literal">ParticleSystems</code> will be added to the <span class="strong"><strong>Project</strong></span> panel in the <code class="literal">Standard Assets</code> | <code class="literal">ParticleSystems</code> | <code class="literal">Prefabs</code> folder. See <span class="emphasis"><em>Figure 3.28</em></span>. You can test each of the particle systems by <a id="id210" class="indexterm"/>simply dragging and dropping each prefab to the scene. Note that you can only preview a particle system in the <span class="strong"><strong>Scene</strong></span> viewport while it is selected.</p><div class="mediaobject"><img src="graphics/B05118_03_28.png.jpg" alt="Death and particles"/><div class="caption"><p>Figure 3.28: Particle Systems imported to the Project panel</p></div></div><p>Notice from <span class="emphasis"><em>Figure 3.28</em></span> that an <span class="strong"><strong>Explosion</strong></span> system is included among the default assets, which is great news! To test, we can just drag and drop the explosion to the scene, press play on the toolbar, and see the explosion in action. Good! We're almost done, but there's still a bit more work. We've now seen that an appropriate particle system is available and we could just drag and drop this system to the <span class="strong"><strong>Death Particles Prefab</strong></span> slot in the <span class="strong"><strong>Health</strong></span> component in the <span class="strong"><strong>Inspector</strong></span>. This will work technically: when a player or enemy dies, the explosion system will be spawned, creating an explosion effect. However, the particle system will never be destroyed! This is problematic because, on each enemy death, a new particle system will be spawned. This raises the possibility that, after many deaths, the scene will be full of disused particle systems. We don't want this; it's bad for performance and memory usage to have a scene full of unused objects lingering around. To fix this, we'll modify the explosion system slightly, creating a new and modified prefab that'll suit our needs. To <a id="id211" class="indexterm"/>create this, drag and drop the existing explosion system anywhere to the scene and position it at the world origin. See <span class="emphasis"><em>Figure 3.29</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_29.png.jpg" alt="Death and particles"/><div class="caption"><p>Figure 3.29: Adding an Explosion system to the scene for modification</p></div></div><p>Next, we must refine the particle system to destroy itself soon after instantiation. By making a prefab from this arrangement, each and every generated explosion will eventually destroy itself. To make an object destroy itself after a specified interval, we'll create a new C# script. I'll name this script <code class="literal">TimeDestroy.cs</code>. Refer the following code in <span class="emphasis"><em>Code Sample 3.4</em></span>:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class TimedDestroy : MonoBehaviour 
{
  public float DestroyTime = 2f;

  //------------------------------
  // Use this for initialization
  void Start ()
  {
    Invoke("Die", DestroyTime);
  }
  
  
  void Die () 
  {
    Destroy(gameObject);
  }
  //------------------------------
}
//------------------------------</pre></div><div class="section" title="Code Sample 3.4"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Code Sample 3.4</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id212" class="indexterm"/><code class="literal">TimeDestroy</code> class simply destroys the object to which it's attached after a specified interval (<code class="literal">DestroyTime</code>) has elapsed.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Invoke</code> function is called in the <code class="literal">Start</code> event. Invoke will execute a function of the specified name once, and only once, after a specified interval has elapsed. The interval is measured in seconds.</li><li class="listitem" style="list-style-type: disc">Like <code class="literal">SendMessage</code>, the <code class="literal">Invoke</code> function relies on <code class="literal">Reflection</code>. For this reason, it should be used sparingly for best performance.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Die</code> function will be executed by <code class="literal">Invoke</code> after a specified interval to destroy the <code class="literal">gameobject</code> (such as a particle system).</li></ul></div><p>Now, drag and drop the <code class="literal">TimedDestroy</code> script file to the explosion particle system in the scene and then press play on the toolbar to test that the code works and the object is destroyed after the specified interval, which can be adjusted from the <span class="strong"><strong>Inspector</strong></span>. See <span class="emphasis"><em>Figure 3.30</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_30.png.jpg" alt="Code Sample 3.4"/><div class="caption"><p>Figure 3.30: Adding a TimeDestroy script to an explosion Particle System</p></div></div><p>The <code class="literal">TimeDestroy</code> script should remove the explosion particle system after the delay expires. So let's <a id="id213" class="indexterm"/>create a new and separate prefab from this modified version. To do this, rename the explosion system in the <span class="strong"><strong>Hierarchy</strong></span> panel to <code class="literal">ExplosionDestroy</code>, and then drag and drop the system from the <span class="strong"><strong>Hierarchy</strong></span> to the <span class="strong"><strong>Project</strong></span> panel in the <code class="literal">Prefabs</code> folder. Unity automatically creates a new prefab, representing the modified particle system. See <span class="emphasis"><em>Figure 3.31</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_31.png.jpg" alt="Code Sample 3.4"/><div class="caption"><p>Figure 3.31: Create a timed explosion prefab</p></div></div><p>Now, drag and drop the newly created prefab from the <span class="strong"><strong>Project</strong></span> panel to the <span class="strong"><strong>Death Particle System</strong></span> slot on the <span class="strong"><strong>Health</strong></span> component for the <span class="strong"><strong>Player</strong></span> in the <span class="strong"><strong>Object Inspector</strong></span>. This ensures <a id="id214" class="indexterm"/>that the prefab is instantiated when the player dies. See <span class="emphasis"><em>Figure 3.32</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_32.png.jpg" alt="Code Sample 3.4"/><div class="caption"><p>Figure 3.32: Configuring the health script</p></div></div><p>If you run the game now, you'll see that you cannot initiate a player death event to test the particle system generation. Nothing exists in the scene to destroy or damage the player, and you cannot manually set the <span class="strong"><strong>Health</strong></span> points to <code class="literal">0</code> from the <span class="strong"><strong>Inspector</strong></span> in a way that is detected by the C# property <code class="literal">set</code> function. For now, however, we can insert some test death functionality into the <code class="literal">Health</code> script that triggers an instant kill when the spacebar is pressed. Refer to <span class="emphasis"><em>Code Sample 3.5</em></span> for the modified <code class="literal">Health</code> script:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class Health : MonoBehaviour
{
  public GameObject DeathParticlesPrefab = null;
  private Transform ThisTransform = null;
  public bool ShouldDestroyOnDeath = true;
  //------------------------------
  void Start()
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  public float HealthPoints
  {
    get
    {
      return _HealthPoints;
    }

    set
    {
      _HealthPoints = value;

      if(_HealthPoints &lt;= 0)
      {
        SendMessage("Die", SendMessageOptions.DontRequireReceiver);

        if(DeathParticlesPrefab != null)
          Instantiate(DeathParticlesPrefab, ThisTransform.position, ThisTransform.rotation);

        if(ShouldDestroyOnDeath)Destroy(gameObject);
      }
    }
  }
  //------------------------------
  <span class="strong"><strong>void Update()</strong></span>
  <span class="strong"><strong>{</strong></span>
    <span class="strong"><strong>if(Input.GetKeyDown(KeyCode.Space))</strong></span>
      <span class="strong"><strong>HealthPoints = 0;</strong></span>
  <span class="strong"><strong>}</strong></span>
  //------------------------------
  [SerializeField]
  private float _HealthPoints = 100f;
}
//------------------------------</pre></div><p>On running the game now, with the modified <code class="literal">Health</code> script, you can trigger an instant player death by <a id="id215" class="indexterm"/>pressing the spacebar key on the keyboard. When you do this, the player object is destroyed and the particle system is generated until the timer destroys that too. Excellent work! We now have a playable, controllable player character that supports health and death functionality. Things are looking good. See <span class="emphasis"><em>Figure 3.33</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_33.png.jpg" alt="Code Sample 3.4"/><div class="caption"><p>Figure 3.33: Trigger the Explosion particle system</p></div></div></div></div>
<div class="section" title="Enemies"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Enemies</h1></div></div></div><p>The next step is to <a id="id216" class="indexterm"/>create something for the player to shoot and destroy, which can also destroy us, namely, enemy characters. These take the form of roaming spaceships that will be spawned into the scene at regular intervals and will follow the player, drawing nearer and nearer. Essentially, each enemy represents a complex of multiple behaviors working together and these should be implemented as separate scripts. Let's <a id="id217" class="indexterm"/>consider them in turn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Health</strong></span>: Each enemy supports health functionality. They begin the scene with a specified amount of health and will be destroyed when that health falls below <span class="emphasis"><em>0</em></span>. We already have a <code class="literal">Health</code> script created to handle this behavior.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Movement</strong></span>: Each enemy will constantly be in motion, traveling in a straight line along a forward trajectory. That is, each enemy will continually travel forward in the direction it is looking.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Turning</strong></span>: Each enemy will rotate and turn toward the player even when the player moves. This ensures that the enemy always faces the player and, in combination with the movement functionality, will always be traveling toward the player.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scoring</strong></span>: Each enemy rewards the player with a score value when destroyed. Thus, the death of an enemy will increase the player score.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Damage</strong></span>: Each enemy causes damage to the player on collision. Enemies cannot shoot but will harm the player on proximity.</li></ul></div><p>Now that we've identified the range of behaviors applicable to an enemy, let's create an enemy in the scene. We'll make one specific enemy, create a prefab from that, and use it as the basis to instantiate many enemies. Start by selecting the player character in the scene and duplicate the object with <span class="emphasis"><em>Ctrl</em></span> + <span class="strong"><strong>D</strong></span> or select <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Duplicate</strong></span> from the application menu. This <a id="id218" class="indexterm"/>initially creates a second player. See <span class="emphasis"><em>Figure 3.34</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_34.png.jpg" alt="Enemies"/><div class="caption"><p>Figure 3.34: Duplicating the Player object</p></div></div><p>Rename the object to <code class="literal">Enemy</code> and ensure that it is not tagged as <code class="literal">Player</code>, as there should be one and only one object in the scene with the <code class="literal">Player</code> tag, namely, the real player. In addition, temporarily disable the <code class="literal">Player</code> game object, allowing us to focus more clearly on the <code class="literal">Enemy</code> object in the <span class="strong"><strong>Scene</strong></span> tab. See <span class="emphasis"><em>Figure 3.35</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_35.png.jpg" alt="Enemies"/><div class="caption"><p>Figure 3.35: Removing a Player tag from the enemy, if applicable</p></div></div><p>Select the sprite child object of the duplicated enemy, and from the <span class="strong"><strong>Object Inspector</strong></span>, click on the <span class="strong"><strong>Sprite</strong></span> field of the <span class="strong"><strong>Sprite Renderer</strong></span> component to pick a new sprite. Pick one of the darker imperial ships for the enemy character, and the sprite will update for the object in the <a id="id219" class="indexterm"/>viewport. See <span class="emphasis"><em>Figure 3.36</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_36.png.jpg" alt="Enemies"/><div class="caption"><p>Figure 3.36: Selecting a sprite for the Sprite Renderer component</p></div></div><p>After changing the sprite to an enemy character, you may need to adjust the rotation values to align the sprite to the parent forward vector, ensuring that the sprite is looking in the same direction as the forward vector. See <span class="emphasis"><em>Figure 3.37</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_37.png.jpg" alt="Enemies"/><div class="caption"><p>Figure 3.37: Adjusting enemy sprite rotation</p></div></div><p>Now, select the parent object for the enemy and remove the <span class="strong"><strong>Rigidbody</strong></span>, <span class="strong"><strong>PlayerController</strong></span>, and <code class="literal">BoundsLock</code> components, but keep the <span class="strong"><strong>Health</strong></span> component as the enemy should support health. See <span class="emphasis"><em>Figure 3.38</em></span>. In addition, feel free to resize the <span class="strong"><strong>Capsule Collider</strong></span> <a id="id220" class="indexterm"/>component to better approximate the <code class="literal">Enemy</code> object.</p><div class="mediaobject"><img src="graphics/B05118_03_38.png.jpg" alt="Enemies"/><div class="caption"><p>Figure 3.38: Adjusting enemy sprite rotation</p></div></div><p>Let's start coding the enemy, focusing on movement. Specifically, the enemy should continually move in the forward direction at a specified speed. To achieve this, create a new script file named <code class="literal">Mover.cs</code>. This should be attached to the <code class="literal">Enemy</code> object. The code for this class is included in <span class="emphasis"><em>Code Sample 3.6</em></span>.</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class Mover : MonoBehaviour
{
  //------------------------------
  private Transform ThisTransform = null;
  public float MaxSpeed = 10f;
  //------------------------------
  // Use this for initialization
  void Awake () 
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void Update () 
  {
    ThisTransform.position += ThisTransform.forward * MaxSpeed * Time.deltaTime;
  }
  //------------------------------
}
//------------------------------</pre></div><div class="section" title="Code Sample 3.6"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Code Sample 3.6</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id221" class="indexterm"/><code class="literal">Mover</code> script moves an object at a specified speed (<code class="literal">MaxSpeed</code> per second) along its forward vector. To do this, it uses the <span class="strong"><strong>Transform</strong></span> component.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Update</code> function is responsible for updating the position of the object. In short, it multiplies the forward vector by the object speed and adds this to its existing position to move the object further along its line of sight. The <code class="literal">Time.deltaTime</code> value is used to make the motion frame rate independent—moving the object per second as opposed to per frame. More information on <a id="id222" class="indexterm"/><code class="literal">deltaTime</code> can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Time-deltaTime.html">http://docs.unity3d.com/ScriptReference/Time-deltaTime.html</a>.</li></ul></div><p>Press play on the toolbar to test run your code. It's always good practice to frequently test code like this. Your enemy may move too slow or too fast. If so, stop playback to exit game mode, and select the enemy in the scene. From the <span class="strong"><strong>Object Inspector</strong></span>, adjust the <span class="strong"><strong>Max Speed</strong></span> value of the <span class="strong"><strong>Mover</strong></span> component. See <span class="emphasis"><em>Figure 3.39</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_39.png.jpg" alt="Code Sample 3.6"/><div class="caption"><p>Figure 3.39: Adjusting enemy speed</p></div></div><p>In addition to moving in a straight line, the enemy should also continually turn to face the player wherever they move. To achieve this, we'll need another script file that works similarly to the player controller script. While the player turns to face the cursor, the enemy turns to face the player. This functionality should be encoded in a new script file called <a id="id223" class="indexterm"/>
<code class="literal">ObjFace.cs</code>. This script should be attached to the enemy. See <span class="emphasis"><em>Code Sample 3.7</em></span>:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class ObjFace : MonoBehaviour
{
  //------------------------------
  public Transform ObjToFollow = null;
  public bool FollowPlayer = false;
  private Transform ThisTransform = null;
  //------------------------------
  // Use this for initialization
  void Awake () 
  {
    //Get local transform
    ThisTransform = GetComponent&lt;Transform&gt;();

    //Should face player?
    if(!FollowPlayer)return;

    //Get player transform
    GameObject PlayerObj = GameObject.<span class="strong"><strong>FindGameObjectWithTag</strong></span>("Player");
    if(PlayerObj != null)
      ObjToFollow = PlayerObj.GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void Update ()
  {
    //Follow destination object
    if(ObjToFollow==null)return;

    //Get direction to follow object
    Vector3 DirToObject = ObjToFollow.position - ThisTransform.position;

    if(DirToObject != Vector3.zero)
      ThisTransform.localRotation = <span class="strong"><strong>Quaternion.LookRotation</strong></span>(DirToObject.normalized,Vector3.up);
  }
  //------------------------------
}
//------------------------------</pre></div></div><div class="section" title="Code Sample 3.7"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Code Sample 3.7</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id224" class="indexterm"/><code class="literal">ObjFace</code> script will always rotate an object so that its forward vector points towards a destination point in the scene.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">Awake</code> event, the <code class="literal">FindGameObjectWithTag</code> function is called to retrieve a reference to the one and only object in the scene tagged as a player, which should be the player spaceship. The player represents the default look-at destination for an enemy object.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Update</code> function is called automatically once per frame and will generate a displacement vector from the object location to the destination location, and this represents the direction in which the object should be looking. The <code class="literal">Quaternion.LookRotation</code> function accepts a direction vector and will rotate an object to align the forward vector with the supplied direction. This keeps the object looking towards the destination. More information on <a id="id225" class="indexterm"/><code class="literal">LookRotation</code> can be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html">http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html</a>.</li></ul></div><p>This is looking excellent! However, before testing this code, make sure that the <code class="literal">Player</code> object in the scene is tagged as <span class="strong"><strong>Player</strong></span>, is enabled, and the enemy is offset away from the player. Be sure to enable the <span class="strong"><strong>Follow Player</strong></span> checkbox from the <span class="strong"><strong>Obj Face</strong></span> component in the <span class="strong"><strong>Object Inspector</strong></span>. When you do this, the enemy will always turn to face the player. See <span class="emphasis"><em>Figure 3.40</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_40.png.jpg" alt="Code Sample 3.7"/><div class="caption"><p>Figure 3.40: Enemy spaceship moving towards the player</p></div></div><p>Now, if and when the enemy finally collides with the player, it should deal out damage and <a id="id226" class="indexterm"/>potentially kill the player. To achieve this, a collision between the enemy and player must be detected. Let's start by configuring the enemy. Select the <span class="strong"><strong>Enemy</strong></span> object, and from the <span class="strong"><strong>Object Inspector</strong></span>, enable the <span class="strong"><strong>Is Trigger</strong></span> checkbox in the <span class="strong"><strong>Capsule Collider</strong></span> component. This changes the <span class="strong"><strong>Capsule Collider</strong></span> component to allow a true intersection between the player and enemy and prevent Unity from blocking the collision. See <span class="emphasis"><em>Figure 3.41</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_41.png.jpg" alt="Code Sample 3.7"/><div class="caption"><p>Figure 3.41: Changing the Enemy Collider to a trigger</p></div></div><p>Next, we'll create a script that detects collisions and will continually deal out damage to the player as and when they occur and for as long as the collision state remains. Refer to the following <a id="id227" class="indexterm"/>code (<code class="literal">ProxyDamage.cs</code>), which should be attached to the enemy character:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class ProxyDamage : MonoBehaviour
{
  //------------------------------
  //Damage per second
  public float DamageRate = 10f;
  //------------------------------
  void OnTriggerStay(Collider Col)
  {
    Health H = Col.gameObject.GetComponent&lt;Health&gt;();

    if(H == null)return;

    H.HealthPoints -= DamageRate * Time.deltaTime;
  }
  //------------------------------
}
//------------------------------</pre></div></div><div class="section" title="Code Sample 3.8"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Code Sample 3.8</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id228" class="indexterm"/><code class="literal">ProxyDamage</code> script should be attached to an enemy character and it will deal out damage to any colliding object with a <code class="literal">Health</code> component.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">OnTriggerStay</code> event is called once every frame for as long as an intersection state persists. During this function, the <code class="literal">HealthPoints</code> value of the <code class="literal">Health</code> component is reduced by the <code class="literal">DamageRate</code> (which is measured as damage per second).</li></ul></div><p>After attaching the <code class="literal">ProxyDamage</code> script to an enemy, use the <span class="strong"><strong>Object Inspector</strong></span> to set the <span class="strong"><strong>Damage Rate</strong></span> of the <span class="strong"><strong>Proxy Damage</strong></span> component. This represents how much health should be reduced on the player, per second, during a collision. For a challenge, I've set the value to <code class="literal">100</code> health points. See <span class="emphasis"><em>Figure 3.42</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_42.png.jpg" alt="Code Sample 3.8"/><div class="caption"><p>Figure 3.42: Setting the Damage Rate for a Proxy Damage component</p></div></div><p>Now let's give things a test run. Press play on the toolbar and attempt a collision between the player <a id="id229" class="indexterm"/>and enemy. After one second, the player should be destroyed. Things are coming along well. However, we'll need more than one enemy to make things challenging.</p></div></div>
<div class="section" title="Enemy spawning"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Enemy spawning</h1></div></div></div><p>To make the level fun and <a id="id230" class="indexterm"/>challenging, we'll need more than simply one enemy. In fact, for a game that's essentially endless, we'll need to continually add enemies. These should be added gradually over time. Essentially, we'll need either regular or intermittent spawning of enemies, and this section will add that functionality. Before we can do this, however, we'll need to make a prefab from the enemy object. This can be achieved easily. Select the enemy in the <span class="strong"><strong>Hierarchy</strong></span> panel and then drag and drop it to the <span class="strong"><strong>Project</strong></span> panel in the <code class="literal">Prefabs</code> folder. This creates an <code class="literal">Enemy</code> prefab. See <span class="emphasis"><em>Figure 3.43</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_43.png.jpg" alt="Enemy spawning"/><div class="caption"><p>Figure 3.43: Creating an Enemy prefab</p></div></div><p>Now, we'll make a new script (<code class="literal">Spawner.cs</code>) that spawns new enemies in the scene over time within a specified radius from the player spaceship. This script should be attached to a new, empty game <a id="id231" class="indexterm"/>object in the scene. See <span class="emphasis"><em>Code Sample 3.9</em></span>:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class Spawner : MonoBehaviour
{
  public float MaxRadius = 1f;
  public float Interval = 5f;
  public GameObject ObjToSpawn = null;
  private Transform Origin = null;
  //------------------------------
  void Awake()
  {
  Origin = GameObject.FindGameObjectWithTag("Player").GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Use this for initialization
  void Start () 
  {
    <span class="strong"><strong>InvokeRepeating("Spawn", 0f, Interval);</strong></span>
  }
  //------------------------------
  void Spawn () 
  {
    if(Origin == null)return;

    Vector3 SpawnPos = Origin.position + <span class="strong"><strong>Random.onUnitSphere *</strong></span> MaxRadius;
    SpawnPos = new Vector3(SpawnPos.x, 0f, SpawnPos.z);
    Instantiate(ObjToSpawn, SpawnPos, Quaternion.identity);
  }
  //------------------------------
}
//------------------------------</pre></div><div class="section" title="Code Sample 3.9"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Code Sample 3.9</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id232" class="indexterm"/><code class="literal">Spawner</code> class will spawn instances of <code class="literal">ObjToSpawn</code> (a prefab) on each interval of <code class="literal">Interval</code>. The interval is measured in seconds. The spawned objects will be created within a random radius from a center point, <code class="literal">Origin</code>.</li><li class="listitem" style="list-style-type: disc">During the <code class="literal">Start</code> event, the <code class="literal">InvokeRepeating</code> function is called to continually execute the <code class="literal">Spawn</code> function on every interval to spawn a new enemy.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Spawn</code> function will create instances of the enemy in the scene at a random radius from an origin point. Once spawned, the enemy will behave as normal, heading toward the player for an attack.</li></ul></div><p>The <code class="literal">Spawner</code> class is a global behavior that applies scene-wide. It does not depend on the player specifically, nor on any specific enemy. For this reason, it should be attached to an empty game object. Create one of these by selecting <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu. Name this <code class="literal">Spawner</code> and attach the <code class="literal">Spawner</code> script to it. See <span class="emphasis"><em>Figure 3.44</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_44.png.jpg" alt="Code Sample 3.9"/><div class="caption"><p>Figure 3.44: Creating an empty game object</p></div></div><p>Once added to the scene, from the <span class="strong"><strong>Object Inspector</strong></span>, drag and drop the <code class="literal">Enemy</code> prefab to the <span class="strong"><strong>Obj To Spawn</strong></span> field in the <span class="strong"><strong>Spawner</strong></span> component. Set the <span class="strong"><strong>Interval</strong></span> to <code class="literal">2</code> seconds and increase the <span class="strong"><strong>Max Radius</strong></span> to <code class="literal">5</code>. See <span class="emphasis"><em>Figure 3.45</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_45.png.jpg" alt="Code Sample 3.9"/><div class="caption"><p>Figure 3.45: Configuring the Spawner for Enemy objects</p></div></div><p>Now (drum roll), let's try the level. Press play on the toolbar and take the game for a test run. You <a id="id233" class="indexterm"/>should now have a level with a fully controllable player character surrounded by a growing army of tracking enemy ships! Excellent work! See <span class="emphasis"><em>Figure 3.46</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_03_46.png.jpg" alt="Code Sample 3.9"/><div class="caption"><p>Figure 3.46: Spawned enemy objects moving toward the player</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Summary</h1></div></div></div><p>Good job on getting this far! The space shooter is really taking shape now, featuring a controllable player character that relies on native physics, twin-stick mechanics, enemy ships, and a scene-wide spawner for enemies. All these ingredients together still don't make a game: we can't shoot, we can't increase the score, and we can't destroy enemies. These issues will need to be addressed, along with other technical issues that we'll certainly encounter. Nevertheless, we now have a solid foundation for moving further, and in <a id="id234" class="indexterm"/>the next chapter, we'll complete the shooter.</p></div></body></html>