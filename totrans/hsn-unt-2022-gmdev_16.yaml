- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Creating a UI with the UI Toolkit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UI Toolkit 创建 UI
- en: In the previous chapter, we discussed how to create user interfaces using **uGUI**
    (also known as **Canvas**), one of the most common Unity UI systems, but as we
    already mentioned, this is not the only one. While so far, uGUI is the most preferred
    option, Unity is working on a replacement called **UI Toolkit**, and even if it
    doesn’t have feature parity with uGUI yet, we thought it is worth covering it
    in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何使用 **uGUI**（也称为 **Canvas**），这是最常用的 Unity UI 系统之一，但正如我们已经提到的，这并不是唯一的选择。虽然到目前为止，uGUI
    是最受欢迎的选项，但 Unity 正在开发一个名为 **UI Toolkit** 的替代品，即使它还没有与 uGUI 具有相同的功能，我们认为在本书中介绍它仍然是有价值的。
- en: The idea of this chapter is to create the same UI we created previously but
    with UI Toolkit, so you can get an idea of how creating a UI in Unity will look
    soon.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是创建之前创建的相同 UI，但使用 UI Toolkit，这样你可以了解在 Unity 中创建 UI 将会是什么样子。
- en: 'In this chapter, we will examine the following UI concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下 UI 概念：
- en: Why learn UI Toolkit?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么学习 UI Toolkit？
- en: Creating a UI with UI Toolkit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI Toolkit 创建 UI
- en: Making a responsive UI with UI Toolkit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI Toolkit 制作响应式 UI
- en: 'By the end of the chapter, you will know how to use UI Toolkit to create basic
    UIs for our game, redoing the UI we did in the last chapter as a point of reference.
    So, let’s start by discussing the following question first: why are we using UI
    Toolkit?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何使用 UI Toolkit 创建基本的 UI，作为参考重新做上一章的 UI。所以，让我们首先讨论以下问题：为什么我们要使用 UI
    Toolkit？
- en: Why learn UI Toolkit?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么学习 UI Toolkit？
- en: I know the topic of this chapter might sound a little bit confusing; we just
    learned how to use a whole Unity system to create our UI, and now we are learning
    another one! Why didn’t we just learn this new one?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道本章的主题可能听起来有些令人困惑；我们刚刚学习了如何使用整个 Unity 系统来创建我们的 UI，而现在我们又在学习另一个！为什么我们不直接学习这个新的呢？
- en: Well, the first part of the answer is that UI Toolkit doesn’t have feature parity
    with uGUI yet, meaning that it doesn’t have all the features necessary to use
    it in real production environments. Another thing to take into account is that
    even if UI Toolkit is stable enough, it’s still a relatively new system, and there
    are still lots of games in development that were created on older Unity versions
    that don’t support it. This means that in order to land a job in this industry,
    we need to get a decent amount of exposure to uGUI due to most games being created
    with this technology. This happens because it’s not safe or practical to update
    an already-tested and working game with new technologies; such changes could lead
    to a major rework of the game to make it compatible with the new versions. Also,
    this could potentially introduce tons of bugs that could delay the release of
    new versions—not to mention the time it will take to remake a full app with a
    new system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，答案的第一部分是 UI Toolkit 还没有与 uGUI 具有相同的功能，这意味着它还没有所有在真实生产环境中使用所需的特性。另一个需要考虑的事情是，即使
    UI Toolkit 已经足够稳定，它仍然是一个相对较新的系统，还有很多游戏正在开发中，这些游戏是在旧的 Unity 版本上创建的，不支持它。这意味着为了在这个行业中找到工作，我们需要对
    uGUI 有足够的了解，因为大多数游戏都是使用这项技术创建的。这是因为用新技术更新已经测试并正常工作的游戏是不安全或不切实际的；这些更改可能导致游戏需要进行重大修改以兼容新版本。此外，这可能会引入大量的错误，可能会延迟新版本的发布——更不用说用新系统重做一个完整应用程序所需的时间了。
- en: That being said, we believe it’s still worth learning the basic concepts of
    UI Toolkit to be prepared to use it in newer Unity versions, so let’s dive into
    it now.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们认为学习 UI Toolkit 的基本概念仍然值得，以便为在新版 Unity 中使用它做好准备，所以现在让我们深入探讨。
- en: Creating a UI with UI Toolkit
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UI Toolkit 创建 UI
- en: 'In this section, we are going to learn how to create UI Documents, an asset
    that will define the elements our UI has. To do this, we are going to discuss
    the following concepts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何创建 UI 文档，这是一个将定义我们的 UI 元素的资产。为此，我们将讨论以下概念：
- en: Creating UI Documents
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UI 文档
- en: Editing UI Documents
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑 UI 文档
- en: Creating UI Stylesheets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UI 样式表
- en: Let’s start by seeing how we can create our first UI Document.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们如何创建我们的第一个 UI 文档。
- en: Creating UI Documents
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 UI 文档
- en: When creating a UI with uGUI, we need to create GameObjects and attach components
    like **Button**, **Image**, or **Text**, but with UI Toolkit, we need to create
    a **UI Document** instead. UI Document is a special kind of asset that will contain
    the definition of the elements our UI will have and its hierarchy. We will have
    a GameObject with a **UI Document** component (yes, it’s called the same, so pay
    attention here) that will reference this UI document asset and render its contents.
    It’s like a mesh asset that contains information about the Mesh, and the `MeshRenderer`
    component that will render it. In this case, the elements to render are contained
    in an asset and we have a component that reads the asset and renders its content
    (UI in this case).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用uGUI创建UI时，我们需要创建GameObject并附加**按钮**、**图像**或**文本**等组件，但使用UI Toolkit时，我们需要创建一个**UI文档**。UI文档是一种特殊的资产，它将包含我们的UI将具有的定义及其层次结构。我们将有一个带有**UI文档**组件的GameObject（是的，它叫法相同，所以请注意这里），它将引用这个UI文档资产并渲染其内容。它就像一个包含有关Mesh信息的资产，以及将渲染它的`MeshRenderer`组件。在这种情况下，要渲染的元素包含在一个资产中，我们有一个读取资产并渲染其内容（在这种情况下是UI）的组件。
- en: 'UI Documents are actually plain text files. You can open one with a text editor
    and easily see its contents. If you do that and you are familiar with HTML, you
    will recognize the XML-like format used to define the elements our UI will be
    composed of; Unity calls this format **UXML**. With UI Toolkit, Unity is attempting
    to make it easy for web developers to jump into Unity and create UIs. In the following
    code, you can see the typical look of an UXML document’s file contents:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: UI文档实际上是纯文本文件。你可以用文本编辑器打开它，并轻松查看其内容。如果你这样做，并且熟悉HTML，你会认出用于定义我们的UI将包含的元素的XML-like格式；Unity称这种格式为**UXML**。使用UI
    Toolkit，Unity试图让网页开发者更容易地进入Unity并创建UI。在下面的代码中，你可以看到UXML文档文件内容的典型外观：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don’t worry if you don’t know XML; we will explain the core concepts in this
    chapter. Also, don’t worry about the UXML format; later in this chapter, we will
    be using a visual editor called **UI Builder** to edit our UI without writing
    UXML at all, but it is worth knowing how it actually works.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉XML，我们将在本章中解释核心概念。同时，不要担心UXML格式；在本章的后面部分，我们将使用一个名为**UI构建器**的可视编辑器来编辑我们的UI，而无需编写任何UXML，但了解它是如何实际工作的还是有价值的。
- en: 'In order to create a UI Document and add it to the scene, we need to do the
    following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建UI文档并将其添加到场景中，我们需要执行以下操作：
- en: 'Click the **+** | **UI Toolkit** | **UI Document** option in the **Project**
    view to create a UI Document asset and name it `GameHUD`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中点击**+** | **UI工具包** | **UI文档**选项来创建一个UI文档资产，并将其命名为`GameHUD`：
- en: '![](img/B18585_16_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_01.png)'
- en: 'Figure 16.1: Creating the UI Document asset'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：创建UI文档资产
- en: Click the **Game Object** | **UI Tookit** | **UI Document** option to create
    a GameObject in your scene with the UI Document component, which is capable of
    rendering the UI Document.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**游戏对象** | **UI工具包** | **UI文档**选项，在场景中创建一个带有UI文档组件的GameObject，该组件能够渲染UI文档。
- en: 'Select it and drag the **GameHUD** UI Document asset (the one created in *step
    1*) to the **Source Asset** property of the UI Document GameObject (the one created
    in *step 2*):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它，并将**GameHUD** UI文档资产（在*步骤1*中创建的）拖放到UI文档GameObject的**源资产**属性中（在*步骤2*中创建的）：
- en: '![](img/B18585_16_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_02.png)'
- en: 'Figure 16.2: Making the UI Document component to render our UI Document asset'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：使UI文档组件渲染我们的UI文档资产
- en: And that’s it! Of course, we won’t see anything yet on our screen as the UI
    Document is blank, so let’s start adding elements to it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！当然，由于UI文档是空的，我们屏幕上目前什么也看不到，所以让我们开始向其中添加元素。
- en: Editing UI Documents
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑UI文档
- en: 'As our goal is to recreate the same UI we created in the last chapter, let’s
    start with the simplest part: adding the player avatar to the top-left corner.
    One option would be to open the UI Document asset with any text editor and start
    writing the UXML code, but luckily, we have an easier way, which is using the
    **UI Builder** editor. This editor allows us to generate the UXML code visually,
    by dragging and dropping elements.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是重新创建上一章中创建的相同UI，让我们从最简单的一部分开始：将玩家头像添加到左上角。一个选择是使用任何文本编辑器打开UI文档资产并开始编写UXML代码，但幸运的是，我们有一个更简单的方法，那就是使用**UI构建器**编辑器。这个编辑器允许我们通过拖放元素来可视化地生成UXML代码。
- en: 'In order to do that, let’s first see how the **UI Builder** window works:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们首先看看**UI构建器**窗口是如何工作的：
- en: 'Double-click the **GameHUD** asset in the Project view to make **UI Builder**
    open it:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击项目视图中的**GameHUD**资产以打开**UI Builder**：
- en: '![](img/B18585_16_03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_03.png)'
- en: 'Figure 16.3: The UI Builder editor'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：UI Builder编辑器
- en: In the **Hierarchy** panel inside the UI Builder (*not* the **Hierarchy** panel
    we’ve used so far in previous chapters), select `GameHUD.uxml`, which is the container
    element of the UI.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI Builder内部的**层次结构**面板中（*不是*我们在前几章中使用的**层次结构**面板），选择`GameHUD.uxml`，这是UI的容器元素。
- en: '![](img/B18585_16_04.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_04.png)'
- en: 'Figure 16.4: Selecting the asset name in Hierarchy to edit the general UI settings'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：在层次结构中选择资产名称以编辑通用UI设置
- en: 'Look at the **Inspector** panel at the right of the UI Builder window (*not*
    the **Inspector** we’ve used so far to modify GameObjects). Set the **Size** property
    to a **Width** of `1920` and a **Height** of `1080`. This will allow us to view
    how our UI will look in this resolution. You can later change this value to see
    how it adapts to different sizes, but more on that later:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看UI Builder窗口右侧的**检查器**面板（*不是*我们之前用来修改GameObject的**检查器**）。将**大小**属性设置为**宽度**为`1920`和**高度**为`1080`。这将允许我们查看我们的UI在这个分辨率下的外观。您稍后可以更改此值以查看它如何适应不同的大小，但关于这一点我们稍后再说：
- en: '![](img/B18585_16_05.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_05.png)'
- en: 'Figure 16.5: Setting the preview UI resolution'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：设置预览UI分辨率
- en: You can pan the viewport to navigate the UI by pressing the *Mouse Wheel Button*
    (also known as *Middle Button*) and moving the mouse. On Mac, you can also press
    *Option + Command* and click and drag any free area of the viewport (places without
    our UI) to do the same.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过按*鼠标滚轮按钮*（也称为*中间按钮*）并移动鼠标来平移视口以导航UI。在Mac上，您还可以按*Option + Command*并点击并拖动视口的任何自由区域（没有我们的UI的地方）来完成相同的操作。
- en: 'You can also use the *Mouse Scroll Wheel* to zoom in and out. Finally, you
    can use the zoom percentage selection at the top-left part of the **viewport**
    and the **Fit Canvas** button to automatically fit the entire UI in your **viewport**:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用*鼠标滚轮*来放大和缩小。最后，您可以使用**视口**左上角的缩放百分比选择和**适应画布**按钮自动将整个UI适应到您的**视口**中：
- en: '![](img/B18585_16_06.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_06.png)'
- en: 'Figure 16.6: Setting the preview zoom'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：设置预览缩放
- en: 'Now that we know the basics of UI Builder, let’s add our image to the UI:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了UI Builder的基础知识，让我们将我们的图片添加到UI中：
- en: 'Drag the **VisualElement** icon from the **Library** at the bottom left to
    the **Hierarchy** section on the left. This will create a basic UI element capable
    of rendering an image and much more:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左下角的**库**中将**VisualElement**图标拖到左边的**层次结构**部分。这将创建一个基本的UI元素，可以渲染图像以及更多内容：
- en: '![](img/B18585_16_07.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_07.png)'
- en: 'Figure 16.7: Creating a Visual Element'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：创建视觉元素
- en: Select the **VisualElement** in the **Hierarchy** (under `GameHUD.uxml`) and
    look at the **Inspector** at the right part of the UI Builder window (again, not
    the regular Unity Inspector panel) for the **Position** section. Expand it if
    not already expanded (using the arrow on the left).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**（在`GameHUD.uxml`下）中选择**VisualElement**，并查看UI Builder窗口右侧的**检查器**（*不是*我们之前用来修改GameObject的常规Unity检查器面板）中的**位置**部分。如果尚未展开，请展开它（使用左侧的箭头）。
- en: 'Set **Position** to **Absolute** in order to allow us to move our element freely
    around the UI. Later in this chapter, in the *Using relative positions* section,
    we will explain how **Relative** mode works:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**位置**设置为**绝对**，以便我们可以自由地在UI中移动我们的元素。在本章的后续部分，在*使用相对位置*部分，我们将解释**相对**模式是如何工作的：
- en: '![](img/B18585_16_08.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_08.png)'
- en: 'Figure 16.8: Setting our UI Element to be freely moved around'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：设置我们的UI元素可以自由移动
- en: 'Open the **Size** section and set **Width** and **Height** to `100` to make
    our UI element have a non-zero size. This way, we can see its area in the **Viewport**:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**大小**部分，将**宽度**和**高度**设置为`100`，使我们的UI元素具有非零大小。这样，我们就可以在**视口**中看到其区域：
- en: '![](img/B18585_16_09.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_09.png)'
- en: 'Figure 16.9: Setting our UI Element size'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：设置我们的UI元素大小
- en: 'In the **Viewport** pane, you can drag your element around and use the blue
    rectangles in the corners to change its size. Position your element at the top-left
    corner of the UI. If you don’t see your element in the **Viewport**, select it
    in the **Hierarchy** (the one of UI Builder):'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**视口**面板中，您可以拖动您的元素并使用角落的蓝色矩形来更改其大小。将您的元素放置在UI的左上角。如果您在**视口**中看不到您的元素，请在**层次结构**（UI
    Builder的那个）中选择它：
- en: '![](img/B18585_16_10.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_10.png)'
- en: 'Figure 16.10: Moving VisualElements'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：移动VisualElements
- en: 'In order to set an exact position, you can set the **Left** and **Top** values
    of the **Position** section in the **Inspector** to specify the exact *x* and
    *y* coordinates respectively, expressed in pixels:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了设置精确的位置，您可以在**检查器**的**位置**部分的**左**和**上**值中设置，以分别指定精确的*x*和*y*坐标，以像素为单位：
- en: '![](img/B18585_16_11.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_11.png)'
- en: 'Figure 16.11: Setting the Position'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：设置位置
- en: In the **Background** section of the **Inspector**, set the **Image** mode to
    **Sprite** using the combo box at the right of the **Image** property. This allows
    us to apply a sprite as the background of our element.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**的**背景**部分，使用**图像**属性右侧的组合框将**图像**模式设置为**精灵**。这允许我们将精灵作为元素的背景应用。
- en: 'Drag the sprite asset (the image) of our player avatar we imported in *Chapter
    15*, *User Interface Design*, from the **Project** panel to the **Image** property
    in order to set it. Also, you can use the target button (circle button with the
    dot in the middle) to select the sprite asset from the picker window:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在第15章“用户界面设计”中导入的玩家头像的精灵资产（图片）从**项目**面板拖动到**图像**属性，以设置它。此外，您还可以使用目标按钮（中间带点的圆形按钮）从选择窗口中选择精灵资产：
- en: '![](img/B18585_16_12.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_12.png)'
- en: 'Figure 16.12: Setting the Background image of the element'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：设置元素的背景图片
- en: Return to the regular **Game** panel to see the results. If you don’t see a
    change, you can turn off and on the GameObject that renders our UI (the one we
    created with the UI Document).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回常规的**游戏**面板查看结果。如果您没有看到变化，您可以关闭并重新打开渲染我们的UI（使用UI文档创建的那个）的GameObject。
- en: 'Now that we have created the player avatar, we can create the player health
    bar by doing the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了玩家头像，我们可以通过以下步骤创建玩家生命条：
- en: Repeat the previous *steps* *1* to *6* to create a new element that will serve
    as the player health bar container. It won’t have any image as it will just be
    the container of the rest of the elements that will compose the health bar.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复之前的*步骤*1到*6*，创建一个新的元素，该元素将作为玩家生命条容器。它将没有任何图像，它只是其他将组成生命条的元素容器。
- en: Position it right next to the player avatar and set a width and height to resemble
    a classic health bar. Remember you can do this by dragging the image and the squares
    at the corners, or through the **Size** and **Position** properties as we did
    before.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放置在玩家头像的旁边，并设置宽度和高度以类似于经典的生命条。记住，您可以通过拖动图像和角落的方块，或者通过**大小**和**位置**属性来完成此操作，就像我们之前所做的那样。
- en: Drag a new **VisualElement** to the Hierarchy, as we did in *step 1*, but this
    time drop it over the element created in *step 1*. This will make this new element
    a child of it, which will make that element’s position and size depend on its
    parent, the same as what happened when we parented Canvas objects in *Chapter
    15*, *User Interface Design*.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第1步，将一个新的**视觉元素**拖动到**层次结构**中，但这次将其拖动到第1步中创建的元素上。这将使这个新元素成为其子元素，这将使该元素的位置和大小取决于其父元素，就像我们在第15章“用户界面设计”中父化Canvas对象时发生的那样。
- en: 'Select the parent Visual Element and in the **Inspector**, set the **Name**
    property to `PlayerHealth` to easily identify it. Do the same with the child element,
    calling it `Filling`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择父级视觉元素，并在**检查器**中设置**名称**属性为`PlayerHealth`，以便轻松识别。对子元素也执行相同的操作，将其命名为`Filling`：
- en: '![](img/B18585_16_13.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_13.png)'
- en: 'Figure 16.13: Parenting and naming Visual Elements'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13：父化和命名视觉元素
- en: Select the **Filling** element in the **Hierarchy** and look at the **Inspector**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**Filling**元素，并查看**检查器**。
- en: 'In the **Background** section, set the **Color** property to red, clicking
    on the color box and using the **Color Picker**. This will fill our UI Element
    background with plain red instead of using an image:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**背景**部分，将**颜色**属性设置为红色，点击颜色框并使用**颜色选择器**。这将用纯红色填充我们的UI元素背景，而不是使用图像：
- en: '![](img/B18585_16_14.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_14.png)'
- en: 'Figure 16.14: Setting a pure red background for our element'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14：为我们的元素设置纯红色背景
- en: As usual, set the **Position** to **Absolute**, and also the **Left** and **Top**
    properties to `0`. As this is a child of another element, the position will be
    relative to its parent position, so by specifying a **Left** and **Top** value
    of `0`, we are saying that we will be at 0 pixels from the left and top sides
    of our parent. This means that if our parent moves, this child element will move
    along with it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，将**位置**设置为**绝对**，并将**左**和**顶**属性设置为`0`。由于这是一个元素的子元素，其位置将相对于其父元素的位置，因此通过指定**左**和**顶**值为`0`，我们表示我们将位于父元素的左侧和顶部0像素处。这意味着如果父元素移动，这个子元素将随之一同移动。
- en: 'Set **Size**’s **Width** and **Height** to `100` and change the unit of measurement
    from `px` (pixels) to `%` (percentage) by clicking on the **px** button and selecting
    **%**. This will make the **Filling** element size the same as its parent (100
    percent the parent size):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**大小**的**宽度**和**高度**设置为`100`，并通过单击**px**按钮并选择**%**来更改度量单位从`px`（像素）到`%`（百分比）。这将使**填充**元素的大小与其父元素相同（100%的父元素大小）：
- en: '![](img/B18585_16_15.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_15.png)'
- en: 'Figure 16.15: Setting our size as the same size as our parent element'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：将我们的大小设置为与父元素相同
- en: Add a new **VisualElement** as a child of **PlayerHealth** (a sibling of **Filling**)
    and call it `Border`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的**VisualElement**作为**PlayerHealth**（**填充**的兄弟元素）的子元素添加，并命名为`Border`。
- en: Set the **Position** and **Size** as we did in *steps* *7* and *8* for the **Filling**
    element, but don’t set the background color.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**位置**和**大小**设置为我们在步骤*7*和*8*中为**填充**元素所做的设置，但不要设置背景颜色。
- en: Set the **Background** section’s **Image** property to be the same border image
    we used in the previous chapter. Remember to set the **Image** mode to **Sprite**
    instead of **Texture**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**背景**部分的**图像**属性设置为我们在上一章中使用的相同边框图像。请记住将**图像**模式设置为**精灵**而不是**纹理**。
- en: 'Set the **Slice** property in the **Background** section to `15`. This applies
    the nine-slices technique we used in *Chapter 15*, *User Interface Design*, to
    expand an object without stretching it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**背景**部分设置**切片**属性为`15`。这应用了我们在第15章，**用户界面设计**中使用的九宫格技术，以在不拉伸对象的情况下扩展对象：
- en: '![](img/B18585_16_16.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_16.png)'
- en: 'Figure 16.16: Setting the nine-slices sizes in the element directly'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16：在元素中直接设置九宫格大小
- en: 'Select the **Filling** visual element in the **Hierarchy** and set its **Size**
    section’s **Width** property to simulate the **Fill Amount** property of the images
    we used in *Chapter 11*, *User Interface Design*. Later, we will change this **Size**
    to be directly proportional to the player’s health number via code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**填充**视觉元素，并设置其**大小**部分的**宽度**属性以模拟我们在第11章，**用户界面设计**中使用的图像的**填充量**属性。稍后，我们将通过代码将此**大小**直接与玩家的健康数值成比例：
- en: '![](img/B18585_16_17.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_17.png)'
- en: 'Figure 16.17: Health bar result'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17：健康条结果
- en: Repeat *steps* *1* to *12* to create the bottom of the **Base Health** bar.
    Remember the filling must be green this time. Alternatively, you can just copy
    and paste the **PlayerHealth** container, but I recommend you repeat the steps
    for learning purposes.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤*1*到*12*以创建**基础健康**条的底部。记住这次填充必须是绿色。或者，您也可以直接复制并粘贴**PlayerHealth**容器，但我建议您为了学习目的重复这些步骤。
- en: In previous steps, we basically saw how to compose several UI Elements to create
    a complex object. We needed a parent container element to drive the size of our
    child’s so that the inner elements adapt to it, especially the filling, which
    requires a percentage value to represent the current player health.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们基本上看到了如何组合几个UI元素来创建一个复杂对象。我们需要一个父容器元素来驱动子元素的大小，以便内部元素适应它，特别是填充，它需要一个百分比值来表示当前玩家的健康。
- en: Now we have our Life Bar! Well, not quite yet; those red corners from the filling
    that our border doesn’t cover are pretty rough! We will improve that later in
    this chapter when discussing how to make our UI responsive, so for now, let’s
    keep it as is.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的生命条！嗯，还不完全是这样；填充的红色角落，我们的边框没有覆盖，看起来相当粗糙！我们将在本章后面讨论如何使我们的UI响应时改进这一点，所以现在让我们保持原样。
- en: Finally, let’s add text elements to the UI by doing the following, but first,
    we will need to think about fonts. If you download a TTF font, you will need to
    create a Font Asset as we did in *Chapter 15*, *User Interface Design*, for it
    to be used in UI Toolkit. But with the current release of UI Toolkit, the Font
    Asset we created in the last chapter is not compatible. We will need to create
    a Font Asset using the UI Toolkit Font Asset Creator, instead of the Text Mesh
    Pro one. The reason behind the existence of duplicated tools is that Unity is
    integrating the Text Mesh Pro package into a new, improved one called Text Core,
    one of those improvements being compatibility with UI Toolkit and other Unity
    systems.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过以下步骤将文本元素添加到 UI 中，但首先，我们需要考虑字体。如果你下载了 TTF 字体，你需要创建一个字体资产，就像我们在*第 15
    章*，*用户界面设计*中做的那样，以便在 UI 工具包中使用。但是，根据当前 UI 工具包的版本，我们在上一章中创建的字体资产不兼容。我们需要使用 UI 工具包字体资产创建器来创建字体资产，而不是使用
    Text Mesh Pro。存在重复工具的原因是 Unity 正在将 Text Mesh Pro 包集成到一个新的、改进的包中，称为 Text Core，其中一项改进是与
    UI 工具包和其他 Unity 系统的兼容性。
- en: Considering this, in order to convert the TTF to a Font Asset compatible with
    UI Toolkit, you can just right-click the TTF asset in the **Project** panel and
    select **Create** | **Text** | **Font Asset**. This will create a new asset that
    will be the one we will be using to define the font of our UI Toolkit text.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，为了将 TTF 转换为与 UI 工具包兼容的字体资产，你只需在**项目**面板中右键单击 TTF 资产，然后选择**创建** | **文本**
    | **字体资产**。这将创建一个新的资产，我们将使用它来定义 UI 工具包文本的字体。
- en: 'Having solved this, let’s create the UI Element for text, that is, **Label**:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这个问题后，让我们创建一个用于文本的 UI 元素，即**标签**：
- en: Drag the **Label** icon from the **Library** pane of the UI Builder window to
    its **Hierarchy** panel. This will add a UI element capable of rendering not only
    an image in its background but also text (yes, you can add a background to the
    text if you want to).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 UI 建造窗口的**库**面板中的**标签**图标拖动到其**层次结构**面板。这将添加一个 UI 元素，它不仅能够在其背景中渲染图像，还可以渲染文本（是的，如果你想的话，你可以给文本添加背景）。
- en: As usual, set its **Position** and **Size**, this time putting it in the top-right
    corner of the screen. Remember you can simply drag the element; you don’t need
    to set the specific coordinates by hand (although you can if you want to).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，设置其**位置**和**大小**，这次将其放置在屏幕的右上角。记住你可以简单地拖动元素；你不需要手动设置特定的坐标（尽管如果你想的话也可以）。
- en: 'Change the **Text** property in the **Label** section of the **Inspector**
    to the needed text; in our case, this will be `Score: 0`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**检查器**中**标签**部分的**文本**属性更改为所需的文本；在我们的例子中，这将是一个`得分：0`：
- en: '![](img/B18585_16_18.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_18.png)'
- en: 'Figure 16.18: Setting the text to display'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.18：设置要显示的文本
- en: Drag the **Font** asset created just before these steps to the **Font Asset**
    property in the **Text** section of the **Inspector**. Don’t confuse it with the
    **Font** property (the one above **Font Asset**). That one allows you to drag
    TTF assets directly, but that will be deprecated soon, so let’s stick with the
    Unity-recommended approach.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些步骤之前创建的**字体**资产拖动到**检查器**中**文本**部分的**字体资产**属性。不要将其与**字体**属性（位于**字体资产**之上）混淆。那个属性允许你直接拖动
    TTF 资产，但这个功能很快就会过时，所以让我们坚持使用 Unity 推荐的方法。
- en: If you notice your **Font** asset doesn’t work, try putting it in the **UI Toolkit**
    | **Resources** | **Fonts & Materials** folder in the **Project** panel. While
    this shouldn’t be necessary in the latest Unity versions, I’ve noticed that this
    solves these sorts of issues in the past. Also, there’s a bug that makes the font
    not recognized sometimes, which can be fixed by deleting and recreating the **Label**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你注意到你的**字体**资产不起作用，尝试将其放入**项目**面板中的**UI Toolkit** | **资源** | **字体和材质**文件夹。虽然这不应该在最新的
    Unity 版本中是必要的，但我注意到过去这解决了这类问题。此外，有一个错误有时会导致字体不被识别，可以通过删除并重新创建**标签**来修复。
- en: 'Set the **Size** property of the **Text** section to any size that seems fit:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**文本**部分的**大小**属性设置为任何合适的大小：
- en: '![](img/B18585_16_19.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_19.png)'
- en: 'Figure 16.19: Setting the Text Font and Size of a Label'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.19：设置标签的文本字体和大小
- en: Repeat *steps* *1* to *6* to add all the remaining **labels** to the UI.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤 1*到*6*，将所有剩余的**标签**添加到 UI 中。
- en: One last thing we need to do is save, which can be simply done by pressing *Ctrl
    + S* (*Command + S* on Mac) or using the **File** | **Save** menu in the top-left
    part of the **Viewport** section in the **UI Builder** window. Note that previous
    versions of UI Toolkit had a bug where this could make the Viewport become corrupt.
    Please close it and reopen UI Builder again if this happens.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是保存，这可以通过按*Ctrl + S*（在Mac上为*Command + S*）或使用**UI Builder**窗口顶部的**视图**部分左上角的**文件**
    | **保存**菜单来完成。请注意，UI Toolkit的早期版本中存在一个错误，这可能会导致视图损坏。如果发生这种情况，请关闭它并重新打开UI Builder。
- en: Now that we have created our UI, you probably noticed the need to repeat several
    settings to make several objects look the same, like our health bars and labels.
    While this is perfectly viable, we could improve our workflow greatly by reusing
    styles, and **Stylesheets** are the exact feature we need to accomplish that,
    so let’s see them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了UI，你可能已经注意到需要重复设置以使多个对象看起来相同，比如我们的生命条和标签。虽然这是完全可行的，但通过重用样式，我们可以极大地提高我们的工作流程，而**样式表**正是我们完成这一目标所需的确切功能，所以让我们来看看它们。
- en: Creating UI Stylesheets
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UI样式表
- en: When creating UIs, you will find scenarios where several elements throughout
    the whole game will share the same style, for example, buttons with the same background,
    font, size, borders, etc. When creating the UI with uGUI, one way to not repeat
    configurations for each element would be to create a Prefab for the button and
    create instances (and Prefab variants where necessary). The problem is that here,
    we don’t have GameObjects, hence there are no Prefabs, but luckily, we have **Stylesheets**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建UI时，你可能会遇到整个游戏中多个元素共享相同样式的场景，例如具有相同背景、字体、大小、边框等的按钮。当使用uGUI创建UI时，避免为每个元素重复配置的一种方法是为按钮创建一个Prefab并创建实例（以及必要时创建Prefab变体）。问题是这里我们没有GameObject，因此没有Prefab，但幸运的是，我们有**样式表**。
- en: '**Stylesheets** are separated assets that contain a series of styling presets
    for our UI elements. We can define a set of styles (for example, background, borders,
    font, size, etc.) and apply those to several elements across different UI Elements.
    This way, if we change a style in a Stylesheet asset, all UI Elements using that
    style will change, in a similar way to how materials work.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**样式表**是包含一系列针对我们UI元素样式预设的独立资产。我们可以定义一组样式（例如，背景、边框、字体、大小等）并将这些样式应用到不同UI元素中的多个元素上。这样，如果我们更改样式表资产中的样式，使用该样式的所有UI元素都会相应改变，这与材质的工作方式类似。'
- en: There are several ways to create styles in a Stylesheet. One example is the
    selector system. This system allows you to apply a series of rules to pick which
    elements should have a style applied (if you are thinking this is like CSS, then
    you are right), but for now, let’s stick with the basics, creating **Stylesheet
    Classes**. A **Class** is basically a style we can apply to any element via its
    name. For example, we can create a Class called `Button` and add that class to
    every button in the UI that we want to have that style. Please consider that the
    concept of Class here is something completely different from what a Class means
    in coding.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式表中创建样式有几种方法。一个例子是选择器系统。这个系统允许你应用一系列规则来选择哪些元素应该应用样式（如果你认为这类似于CSS，那么你是正确的），但让我们现在先从基础开始，创建**样式表类**。**类**基本上是一种可以通过其名称应用到任何元素上的样式。例如，我们可以创建一个名为`Button`的类，并将该类添加到UI中我们希望应用该样式的每个按钮上。请考虑，这里的类概念与编程中的类概念完全不同。
- en: 'So, in this case, let’s create a Class for all the labels in our UI so that
    the appearance of all of them can be modified by simply changing the style:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，让我们为UI中的所有标签创建一个类，这样只需更改样式就可以修改它们的外观：
- en: 'In the **StyleSheets** panel of the **UI Builder**, click the Add (**+**) button
    and click **Create New USS** (Unity StyleSheet). If that doesn’t work, try restarting
    Unity; there’s a bug in the current version of UI Toolkit that could cause this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**UI Builder**的**样式表**面板中，点击添加（**+**）按钮，然后点击**创建新USS**（Unity StyleSheet）。如果不起作用，请尝试重新启动Unity；当前版本的UI
    Toolkit中存在一个错误，可能会导致此问题：
- en: '![](img/B18585_16_20.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_20.png)'
- en: 'Figure 16.20: Creating a Unity StyleSheet'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20：创建Unity StyleSheet
- en: Name the USS as you like (`GameUSS` in my case) and save the file.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将USS命名为你喜欢的名称（例如，我的情况是`GameUSS`）并保存文件。
- en: Select one of the label elements we have in our UI Document and look at the
    **Inspector**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的UI文档中选择一个标签元素，并查看**检查器**。
- en: In the **StyleSheet** pane of the **Inspector**, type `HUDText` in the **Style
    Class List** input field, but don’t press *Enter* yet.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**的**样式表**面板中，在**样式类列表**输入字段中键入`HUDText`，但不要按*Enter*。
- en: 'Click the **Extract Inlined Styles to New Class** button. This will take all
    style modifications we did to our Label (position, size, font, etc.) and save
    them into a new style class called `HUDText`. You can observe that it was added
    to the list of classes applied to the element (those labels at the bottom of the
    **StyleSheet** section in the **Inspector**):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**将内联样式提取到新类**按钮。这将把我们为标签（位置、大小、字体等）所做的所有样式修改保存到一个名为`HUDText`的新样式类中。你可以观察到它被添加到元素应用的类列表中（那些在**检查器**中**样式表**部分底部的标签）：
- en: '![](img/B18585_16_21.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_21.png)'
- en: 'Figure 16.21: Extracting settings into a Style Class'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21：将设置提取到样式类
- en: With these steps, we have taken a Label with the style we need to apply to others
    and extract it into a class named **HUDText**. This way, we can simply add the
    class **HUDText** to other elements in our UI, and we can even add the same USS
    asset to other UI Documents (click the **+** button on the **StyleSheets** pane
    | **Add Existing USS**) to add this class to the elements in it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们已经将具有我们需要应用到其他元素上的样式的标签提取到一个名为**HUDText**的类中。这样，我们只需将**HUDText**类添加到我们的UI中的其他元素，甚至可以将相同的USS资产添加到其他UI文档中（在**样式表**面板上点击**+**按钮
    | **添加现有USS**）以将此类添加到其中的元素。
- en: Also, if you select the label again, you can notice how properties that previously
    were in bold now became normal again; that’s because properties in bold represent
    changed properties, and we have extracted them, so the default values became whatever
    the style classes define. Luckily, not everything is extracted to the new USS
    Class; for example, the **Text** field still has our specific desired text, as
    it is highly unlikely you would want to put the same text in other objects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你再次选择标签，你可以注意到之前加粗的属性现在又变回了正常；这是因为加粗的属性表示已更改的属性，我们已经提取了它们，因此默认值变成了样式类定义的任何值。幸运的是，并不是所有内容都被提取到新的USS类中；例如，**文本**字段仍然有我们特定的所需文本，因为你不太可能希望在其他对象中放入相同的文本。
- en: '![](img/B18585_16_22.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_22.png)'
- en: 'Figure 16.22: The Text property is bold, indicating it is different from the
    default values. On the other end, Enable Rich Text is not bold, meaning it follows
    the default values and the Classes ones'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22：文本属性加粗，表示它与默认值不同。另一方面，启用富文本没有加粗，这意味着它遵循默认值和类值
- en: If you forgot some change in the style when extracting the class, you can easily
    modify it by selecting it in the **StyleSheets** section at the top-left part
    of the **UI Builder**. Then, select the class **HUDText** in the list. If you
    don’t see it, try expanding the **GameUSS.uss** section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在提取类时忘记了某些样式更改，你可以在**UI Builder**的右上部分选择**样式表**部分，然后选择列表中的**HUDText**类。如果你看不到它，尝试展开**GameUSS.uss**部分。
- en: 'Once selected, you can change it in the Inspector panel, similarly to when
    we change the properties of a UI Element:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择，你可以在检查器面板中更改它，类似于我们更改UI元素的属性：
- en: '![](img/B18585_16_23.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_23.png)'
- en: 'Figure 16.23: Selecting a Style Class for modification'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23：选择样式类进行修改
- en: 'This way, we have edited our `HUDText` class. If other elements had this class
    applied, they would have these changes applied also. Consider that another option
    would be to create the Class first, typing the name in the **StyleSheets** input
    field and pressing *Enter*, and then applying it to UI elements. This way, you
    will avoid needing to revert unwanted changes, but if you created the element
    first, it’s convenient to have the option to revert:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就编辑了我们的`HUDText`类。如果其他元素应用了此类，它们也会应用这些更改。考虑另一种选项是首先创建类，在**样式表**输入字段中键入名称并按*Enter*，然后将其应用到UI元素上。这样，你将避免需要撤销不希望的变化，但如果首先创建了元素，则方便有撤销选项：
- en: '![](img/B18585_16_24.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_24.png)'
- en: 'Figure 16.24: Creating a Style Class from scratch'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24：从头创建样式类
- en: 'Now that we have our Style Class, let’s apply it to other elements by doing
    the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的样式类，让我们通过以下步骤将其应用到其他元素上：
- en: Select another label of our UI.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的UI中的另一个标签。
- en: 'Drag the **HUDText** style from the **Stylesheet** pane at the top-left part
    of the UI Builder window all the way to our element on the Viewport. You can also
    drag it to the **Hierarchy** element if you prefer:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**HUDText**样式从UI构建器窗口左上角的**样式表**面板拖动到视口上的元素。你也可以选择将其拖动到**层次结构**元素：
- en: '![](img/B18585_16_25.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_25.png)'
- en: 'Figure 16.25: Applying a Class to an element'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.25：将类应用到元素
- en: Select the **Label** and check how the **HUDText** class has been added to the
    **StyleSheet** section on the **Inspector**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**标签**并检查**HUDText**类是否已添加到**检查器**上的**样式表**部分。
- en: Now, consider that even if the element now has the class applied, the element
    itself has changes to the text we did in previous steps, overriding the style
    in our class. You can easily check this by selecting the class again (in the **StyleSheets**
    section at the top-left part of the **UI Builder** window) and changing any setting,
    like the size, and seeing how not all elements have changed. This shows how the
    override system works; the changes on the element take precedence over the ones
    in the classes it has applied.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑即使元素现在应用了类，元素本身对我们在之前步骤中做的文本更改也有影响，覆盖了我们类中的样式。你可以通过再次选择类（在**UI构建器**窗口左上角的**样式表**部分）并更改任何设置，如大小，来轻松检查这一点，看看不是所有元素都发生了变化。这显示了覆盖系统是如何工作的；元素上的更改优先于它所应用的类中的更改。
- en: If you want to remove these overrides, you can simply select the element (not
    the class), right-click on the overridden properties, and unset the changes by
    right-clicking and then selecting **Unset**. In the case of our **Label**, we
    can unset the entire **Text** section and probably the **Absolute** position (as
    the desired values are already contained in the class).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想移除这些覆盖，你可以简单地选择元素（不是类），在覆盖的属性上右键点击，然后通过右键点击并选择**取消设置**来撤销更改。在我们的**标签**例子中，我们可以取消整个**文本**部分以及可能的全局**绝对**位置（因为期望的值已经包含在类中）。
- en: '![](img/B18585_16_26.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_26.png)'
- en: 'Figure 16.26: Reverting an override to use the default values of the Classes
    applied to the element'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.26：撤销覆盖以使用应用于元素的类的默认值
- en: So, with these steps, we created a new **StyleSheet** asset and added it to
    the UI Document for it to use it. We have created a new Style Class in it, extracting
    the changes of an existing UI Element into it, and then adjusted which changes
    we wanted to keep. Finally, we applied that style to another element. With this,
    we just scratched the surface of the real power of StyleSheets. We can start doing
    things like combining different classes from different StyleSheets or using selectors
    to dynamically set styles, but that’s outside the scope of this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这些步骤，我们创建了一个新的**样式表**资产，并将其添加到UI文档中以便使用。我们在其中创建了一个新的样式类，将现有UI元素的更改提取到其中，然后调整我们想要保留的更改。最后，我们将这种样式应用到另一个元素上。通过这种方式，我们只是触及了样式表的真正力量。我们可以开始做一些事情，比如从不同的样式表中组合不同的类，或者使用选择器动态设置样式，但这超出了本章的范围。
- en: Something interesting is that even if the documentation of UI Toolkit is pretty
    basic at the moment, all these advanced concepts can be learned by reading about
    CSS, the web technology that Unity based the stylesheet system on. It won’t be
    exactly the same, but the basic idea and best practices still apply.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管UI工具包的文档目前相当基础，但所有这些高级概念都可以通过阅读CSS来学习，这是Unity基于样式表系统的基础技术。它不会完全相同，但基本思想和最佳实践仍然适用。
- en: Now, the UI looks almost exactly the same as it does in *Chapter 15*, *User
    Interface Design*, but it won’t behave in the same way. If you try changing the
    size of the viewport (selecting **GameHUD.uxml** in the Hierarchy and changing
    **Width** and **Height** as we did at the beginning of the chapter), you will
    see the UI won’t adapt properly, so let’s fix this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，UI看起来几乎与第15章“用户界面设计”中的样子完全一样，但它不会以相同的方式表现。如果你尝试更改视口的大小（在层次结构中选择**GameHUD.uxml**并更改**宽度**和**高度**，就像我们在本章开头做的那样），你会看到UI不会正确适应，所以让我们来修复这个问题。
- en: Making a responsive UI
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作响应式UI
- en: 'In this section, we are going to learn how to make the UI we created previously
    adapt to different screen sizes. We are going to discuss the following concepts:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使之前创建的UI适应不同的屏幕尺寸。我们将讨论以下概念：
- en: Dynamic positioning and sizing
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态定位和尺寸
- en: Dynamic scaling
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态缩放
- en: Using relative positions
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相对位置
- en: Let’s start by discussing how we can make the **Position** and **Size** of our
    objects adapt to the screen size.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一下我们如何使我们的对象的**位置**和**大小**适应屏幕大小。
- en: Dynamic positioning and sizing
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态定位和大小
- en: So far, we have used the **Left** and **Top** position attributes in order to
    specify the *x* and *y* positions of our elements with respect to the top-left
    corner of the screen, and then **Width** and **Height** to define the **Size**.
    While essentially that’s all that’s needed to define an object’s position and
    size, it is not very useful in all cases, especially when we need to adapt to
    different screen sizes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了**左**和**顶**位置属性来指定我们的元素相对于屏幕左上角的位置，然后使用**宽度**和**高度**来定义**大小**。虽然本质上这就是定义一个对象位置和大小的全部所需，但在所有情况下它并不非常实用，尤其是在我们需要适应不同屏幕尺寸时。
- en: For example, if you need to place an object in the top-right corner of the screen,
    knowing its size is `100x100` pixels and the screen size is `1920x1080` pixels,
    we can put the **Left** and **Right** position attributes as `1820x980` pixels,
    and this will work, but only for that specific resolution.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您需要将一个对象放置在屏幕的右上角，其大小为`100x100`像素，屏幕大小为`1920x1080`像素，我们可以将**左**和**右**位置属性设置为`1820x980`像素，这将有效，但仅适用于该特定分辨率。
- en: So, what happens if the user runs the game at `1280x720` pixels? The object
    will be outside the screen! In uGUI, we used **Anchors** to solve this issue,
    but we don’t have them here. Luckily, we have **Right** and **Bottom** to help.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果用户以`1280x720`像素运行游戏会发生什么？对象将超出屏幕！在uGUI中，我们使用了**锚点**来解决这个问题，但这里没有。幸运的是，我们有**右**和**底**来帮助。
- en: 'As **Left** and **Top** attributes, **Right** and **Bottom** define distances
    from the parent element’s sides (if there is no parent, then just from the entire
    screen). Right now, we have both set to **auto**, meaning that the position will
    be driven by **Left** and **Right** exclusively, but interesting things can happen
    by changing those values, so let’s use them to make our **Score** and **Bullet**
    labels stick to the top-right corner of the screen instead, by doing the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与**左**和**顶**属性一样，**右**和**底**定义了从父元素边界的距离（如果没有父元素，则直接从整个屏幕开始）。目前，这两个都设置为**auto**，这意味着位置将由**左**和**右**独立驱动，但通过改变这些值可以发生有趣的事情，所以让我们使用它们来使我们的**得分**和**子弹**标签粘附到屏幕的右上角，具体操作如下：
- en: Put the cursor in the bottom part of the UI in the **Viewport** until a white
    bar appears.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标放在**视口**中UI的底部，直到出现一个白色条。
- en: Drag that bar to resize the screen and see how our adapts (or not) to the different
    size.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动该条来调整屏幕大小并查看我们的元素是如何适应（或没有适应）不同大小的。
- en: 'Do the same on the laterals to also see how it adapts to different screen widths:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在侧边栏也做同样的操作，以查看它如何适应不同的屏幕宽度：
- en: '![](img/B18585_16_27.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_27.png)'
- en: 'Figure 16.27: UI not adapting to different screen sizes'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.27：UI没有适应不同的屏幕大小
- en: Select the score label on the **Viewport** and look at the **Inspector**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**视口**中选择得分标签并查看**检查器**。
- en: Set the **Top** and **Right** values in the **Position** section to `30`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**位置**部分将**顶**和**右**的值设置为`30`。
- en: 'Set the **Left** and **Bottom** values to `auto` by clicking the **px** button
    at the right of each attribute and selecting `auto`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击每个属性右侧的**px**按钮并选择**auto**来将**左**和**底**的值设置为`auto`：
- en: '![](img/B18585_16_28.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_28.png)'
- en: 'Figure 16.28: Changing the unit type of the Position attributes to auto mode'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.28：将位置属性的单位类型更改为自适应模式
- en: 'Notice the right and top golden-colored squares at the sides of the label became
    filled, while the left and bottom are hollow. This means that the left and bottom
    are in **auto** mode. You can also toggle **auto** mode by clicking those boxes
    if needed:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意标签两侧的金色方块变成了实心，而左侧和底部是空心的。这意味着左侧和底部处于**auto**模式。如果需要，您也可以通过点击这些方块来切换**auto**模式：
- en: '![](img/B18585_16_29.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_29.png)'
- en: 'Figure 16.29: Toggling auto mode of our element position attributes'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.29：切换元素位置属性的自适应模式
- en: Try changing the size of the UI container again as we did in *steps* *1* and
    *2* to see how our **Score** label is always aligned to the top-right corner.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试改变UI容器的尺寸，就像我们在步骤*1*和*2*中所做的那样，以查看我们的**得分**标签是如何始终对齐到右上角的。
- en: Repeat *steps* *4* to *6* for the **Bullets** label, this time setting the **Top**
    property to `140`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**子弹**标签，重复步骤*4*到*6*，这次将**顶**属性设置为`140`。
- en: What we did with these steps was essentially make the position of the object
    expressed as a distance in pixels against the **Top** and **Right** sides of the
    UI, or the top-right corner of the screen. We needed to set the other sides to
    `auto` mode, so they won’t participate in the position calculations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use the **Position** attribute in other ways as well. As you might
    imagine by now, we can start combining **Left** and **Right** and **Top** and
    **Bottom** if we wish. In such cases, **Left** and **Top** will take precedence
    in defining the position, but then, what do **Right** and **Bottom** do? They
    define the size of the element.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have an element with **Left** and **Right** attributes set
    to `100px` each and we are seeing our UI on a screen with a width of `1920` pixels,
    the final width of our element will be `1720` (`1920` minus `100` from **Left**
    minus `100` from **Right**). This way, the **Position** attributes represent the
    distances of the sides of our element from the sides of the screen (or the parent
    element).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action by making the bottom health bar adapt to the screen
    width while preserving its position relative to the bottom of the screen by doing
    the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Select the bottom health bar parent in the **Hierarchy**. Don’t select it in
    the **Viewport** as you will only be selecting its filling or border.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Left**, **Right**, and **Bottom** to `50px`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Top** to auto (click on the **px** button at the right and select **auto**).
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Size** section, set **Width** to **auto** also.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Height** to `35px`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_16_30.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.30: Making the player’s base health bar adapt to the screen width'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Change the size of the UI to see how it adapts.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these steps, we defined the bar distance from the sides of the screen as
    `50` pixels for it to adapt to any screen width, while keeping the distance from
    the border and height fixed. We basically achieved the same behavior as split
    anchors in uGUI! Consider that we needed to set **Size**’s **Width** attributes
    to **auto** to let the **Left** and **Right** attributes drive the position; if
    you don’t do that, the **Width** attributes take precedence and **Right** won’t
    have any effect. I invite you to experiment with other combinations of **px**/**auto**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'One last trick we can do here is to use negative values in the **Left**, **Top**,
    **Right**, and **Bottom** **Position** attributes of the health bar borders to
    make the borders slightly bigger than the container and cover the filling borders.
    Just set **Left**, **Top**, **Right**, and **Bottom** to `-15px` in this case
    and remember to set both the **Size** **Width** and **Height** attributes to **auto**.
    You might want to reduce the **Height** of the bar container (not the border)
    a little bit, as now it will look thicker due to this change:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18585_16_31.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.31: Using negative Position attributes to cover the filling'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Another mode aside from **px** (pixels) or **auto** mode is the percentual (`%`)
    mode, which allows us to represent values as percentages relative to the screen
    (or parent element if present) size. For example, if we set **Top** and **Bottom**
    to `25%`, this means that our element will be vertically centered with a size
    of 50% of the Screen height (remember to set **Height** mode to `auto` here).
    We could achieve the same result if we set **Top** to `25%`, **Bottom** to `Auto`,
    and **Height** to `50%`; as you can see, we can achieve a clever combination of
    those values.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**px**（像素）或**自动**模式之外，还有一种百分比（`%`）模式，它允许我们以相对于屏幕（或如果有，父元素）大小的百分比来表示值。例如，如果我们将**顶部**和**底部**设置为`25%`，这意味着我们的元素将在垂直居中，其大小为屏幕高度的50%（请记住在此处将**高度**模式设置为`自动`）。如果我们将**顶部**设置为`25%`，**底部**设置为**自动**，**高度**设置为`50%`，我们也可以达到相同的结果；如您所见，我们可以巧妙地组合这些值。
- en: In our case, we will use percentual values in our Life Bar fillings so that
    we can express its size in percentages. We need this as later in the code, we
    can specify the width of the bar as a percentage of the player’s life (for example,
    a player with `25` life points and a max of `100` points has `25%` life).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用百分比值在我们的生命条填充中，这样我们就可以用百分比来表示其大小。我们需要这一点，因为稍后我们可以在代码中将条宽指定为玩家生命值的百分比（例如，一个有`25`生命值和最大`100`点的玩家有`25%`的生命）。
- en: Now, while we solved the positioning adaption to the screen size with the usage
    of the **Left**, **Top**, **Right**, and **Bottom** properties, we still didn’t
    solve the dynamic sizing of the elements. With sizing this time, we are referring
    to screens with a different number of **DPI** (**dots per inch**), so let’s discuss
    how we can achieve that with the **Panel Settings** asset.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然我们通过使用**左**、**顶**、**右**和**底**属性解决了屏幕大小的定位适应问题，但我们还没有解决元素的动态大小问题。这次，我们指的是具有不同**DPI**（每英寸点数）的屏幕，因此让我们讨论如何通过**面板设置**资产来实现这一点。
- en: Dynamic scaling
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态缩放
- en: We used `1920x1080` as the UI base resolution to position and size our elements
    so that they look nice in that resolution. We also changed the UI size to see
    how the elements adapt their position with different screen sizes, and while that
    worked nicely, you can notice how the elements looked bigger or smaller while
    doing that.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`1920x1080`作为UI基本分辨率来定位和调整元素的大小，以便在该分辨率下看起来很漂亮。我们还更改了UI大小，以查看元素如何适应不同的屏幕尺寸；虽然这效果很好，但您会注意到在这样做时元素看起来更大或更小。
- en: While having a base reference resolution is good to design our UI, we should
    consider the sizing of elements on different resolutions, especially on screens
    with high DPI. Sometimes, you can have screens with higher resolution but the
    same physical size in centimeters. This means pixels are smaller in the ones with
    higher resolution, hence they have a larger DPI, so elements can seem smaller
    if not scaled properly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个基本参考分辨率对于设计我们的UI是好的，但我们应考虑不同分辨率下元素的大小，尤其是在高DPI的屏幕上。有时，您可能会有更高分辨率的屏幕，但物理尺寸相同（以厘米为单位）。这意味着高分辨率中的像素更小，因此它们具有更高的DPI，所以如果未正确缩放，元素看起来可能会更小。
- en: 'In the past, we used the **Canvas Scaler** component of the **Canvas** to make
    the UI scale the size of its elements according to the screen resolution. We have
    the exact same settings here as in the **Panel Settings** asset referenced in
    our UI Document component, so let’s configure it by doing the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们使用**画布缩放器**组件的**画布**来使UI根据屏幕分辨率调整其元素的大小。我们在这里的设置与UI文档组件中引用的**面板设置**资产中的设置完全相同，因此让我们通过以下方式来配置它：
- en: 'Look for the **Panel Settings** asset in the **Project** panel and select it.
    Another option would be to select the `UI Document` GameObject in the Main Editor
    Hierarchy and click the asset referenced in the **Panel Settings** property:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中查找**面板设置**资产并选择它。另一种选择是在主编辑器层次结构中选择`UI文档`GameObject，并点击**面板设置**属性中引用的资产：
- en: '![](img/B18585_16_32.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_32.png)'
- en: 'Figure 16.32: Panel Settings being referenced in the UI Document component'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.32：UI文档组件中引用的面板设置
- en: Set **Scale Mode** to **Scale With Screen Size**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**缩放模式**设置为**与屏幕大小缩放**。
- en: Set **Screen Match Mode** to **Match Width Or Height**.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**屏幕匹配模式**设置为**匹配宽度或高度**。
- en: Set the **Reference Resolution** **X** value to `1920` and **Y** to `1080`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**参考分辨率**的**X**值设置为`1920`，**Y**值设置为`1080`。
- en: 'Move the **Match** slider all the way to the right, toward the end labeled
    **Height**:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**匹配**滑块完全向右移动，直到标记为**高度**的末端：
- en: '![](img/B18585_16_33.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_33.png)'
- en: 'Figure 16.33: Setting the scaling of our UI'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.33：设置我们的UI缩放
- en: Observe how changing the height of the **Game** panel of the Unity editor will
    make the UI adapt its element sizes accordingly (change the whole Unity editor
    window height).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察如何改变Unity编辑器中**游戏**面板的高度，将使UI相应地调整元素大小（改变整个Unity编辑器窗口的高度）。
- en: What we did with those changes was first set **Reference Resolution** to whatever
    resolution we designed our UI, in our case, `1920x1080`. Then, we set **Screen
    Match Mode** to allow us to scale our elements according to one of the sides,
    **Width**, **Height**, or a combination of the two if we prefer. In our case,
    we chose **Height**, mainly because our game is targeted at PC, where the screens
    are wide rather than tall. This means that on different screen widths, the elements
    will look the same size, but on different heights, the elements will be bigger
    or smaller.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过这些更改首先将**参考分辨率**设置为我们的UI设计的任何分辨率，在我们的例子中，是`1920x1080`。然后，我们将**屏幕匹配模式**设置为允许我们根据一边、**宽度**、**高度**或两者的组合来缩放我们的元素，如果我们更喜欢的话。在我们的例子中，我们选择了**高度**，主要是因为我们的游戏针对PC，那里的屏幕更宽而不是更高。这意味着在不同的屏幕宽度上，元素看起来大小相同，但在不同的高度上，元素会更大或更小。
- en: With these settings, we can do some math to understand the values. If our screen
    is the same as the reference resolution (`1920x1080`), the element sizes will
    be the same as we specified in the size of our elements in pixels, so for the
    case of our player avatar, it will be `150x150` pixels. Remember that the physical
    size in centimeters depends on the DPI of the screen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置，我们可以做一些数学计算来理解这些值。如果我们的屏幕分辨率与参考分辨率（`1920x1080`）相同，那么元素的大小将与我们在像素大小中指定的元素大小相同，所以对于我们的玩家角色来说，它将是`150x150`像素。记住，物理大小以厘米为单位取决于屏幕的DPI。
- en: Now, imagine that we have a 4k screen, meaning a resolution of `3840x2160`.
    As we specified that our UI matches via **Height**, we can determine that our
    elements will double in size because our screen has a height that is double the
    reference resolution (`2160` divided `1080`). Our player avatar will be `300x300`,
    making the element have the same physical size in a 4k screen, double size but
    double pixel density achieves that. Finally, consider an ultra-wide standard resolution
    of `2560×1080` (yes, very wide screens), in which case the elements will be the
    same size as the only change is the width; the only difference is that the elements
    will have more horizontal separation due to the screen size. I know these calculations
    can be confusing but keep experimenting with the values of the **Panel Settings**
    and **Game View** sizes to understand them better.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们有一个4k屏幕，这意味着分辨率为`3840x2160`。因为我们指定了我们的UI通过**高度**匹配，所以我们可以确定我们的元素大小将加倍，因为我们的屏幕高度是参考分辨率的两倍（`2160`除以`1080`）。我们的玩家角色将是`300x300`，使得元素在4k屏幕上具有相同的物理大小，双倍大小但双倍像素密度实现了这一点。最后，考虑一个超宽标准分辨率`2560×1080`（是的，非常宽的屏幕），在这种情况下，元素的大小将与宽度唯一的变化相同；唯一的区别是，由于屏幕大小，元素将会有更多的水平间隔。我知道这些计算可能会让人困惑，但请继续实验**面板设置**和**游戏视图**大小，以更好地理解它们。
- en: Great, now we really have the same HUD. We could start applying the concepts
    seen so far to the **Options** menu, but let’s take the opportunity to do it in
    a different way, using **relative** **positions**, a way to create a flow of elements
    where the elements’ positions depend on each other.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们真的有了相同的HUD。我们可以开始将到目前为止看到的概念应用到**选项**菜单中，但让我们抓住机会以不同的方式来做，使用**相对**位置，这是一种创建元素流动的方法，其中元素的位置相互依赖。
- en: Using relative positions
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用相对位置
- en: In the HUD of our game, each element requires its own **Position** and **Size**,
    and the different elements’ positions can be resized and repositioned without
    affecting others. We might observe the case of the player health bar and the avatar,
    but the changes would be trivial in this case. There are other cases where this
    is not that trivial, as in the case of a **List** of elements (for example, a
    list of matches to join in a multiplayer game) that needs to adapt vertically
    or horizontally, and here is where **relative positions** help us.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们游戏的HUD（抬头显示）中，每个元素都需要其自己的**位置**和**大小**，并且不同元素的位位置可以调整大小和重新定位，而不会影响其他元素。我们可以观察到玩家生命条和角色的例子，但在这个情况下变化是微不足道的。还有其他情况，这种情况并不那么简单，比如一个**列表**元素（例如，在多人游戏中要加入的匹配列表）需要垂直或水平调整，这就是相对位置帮我们解决问题的地方。
- en: Relative positions allow us to make the positions of the elements relative to
    each other; in a way, the position of one element will depend on the position
    of the previous one, and that one to its previous, and so on, forming a chain
    or **flow**. This works like **Vertical** and **Horizontal Layouts** on uGUI.
    In our case, we will make the **Pause** label and the **Options** and **Exit**
    buttons of our options menu be vertically aligned and centered along its parent
    using those.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 相对位置允许我们使元素的位置相互关联；从某种意义上说，一个元素的位置将取决于前一个元素的位置，前一个元素的位置又取决于其前一个元素，依此类推，形成一个链或**流**。这就像在uGUI上的**垂直**和**水平布局**一样工作。在我们的情况下，我们将使用这些来使我们的选项菜单中的**暂停**标签以及**选项**和**退出**按钮垂直对齐并沿其父元素居中。
- en: 'Let’s start creating the menu by doing the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建菜单，按照以下步骤操作：
- en: Create a new UI Document (click the **+** button after going to **Project View**
    | **UI Tookit** | **UI Document**) and call it `OptionsMenu`. We can work on the
    previous UI Document but let’s keep those pieces of UI separated for easy activation
    and deactivation, and general assets organization.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的UI文档（在**项目视图** | **UI Tookit** | **UI Document**后点击**+**按钮）并命名为`OptionsMenu`。我们可以继续在之前的UI文档上工作，但让我们将这些UI部分分开，以便于激活和停用，以及一般资产组织。
- en: Double-click the asset to set it as the current UI being edited by the **UI
    Builder**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击资产将其设置为当前由**UI Builder**编辑的UI。
- en: Select the root object (**OptionsMenu.uxml** in the **Hierarchy**) and set the
    **Width** and **Height** **Inspector** properties to `1920x1080` pixels.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择根对象（**OptionsMenu.uxml**在**Hierarchy**中）并将**宽度**和**高度**的**检查器**属性设置为`1920x1080`像素。
- en: Create a new GameObject with the UI Document component (**GameObject** | **UI
    Toolkit** | **UI Document**) and drag the asset for this object to render it (as
    we did with the HUD created earlier in the chapter).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的具有UI文档组件（**GameObject** | **UI Toolkit** | **UI Document**）的GameObject，并将此对象的资产拖动以渲染它（就像我们在本章早期创建的HUD所做的那样）。
- en: Double-click the UI Document asset to open the **UI Builder** window to edit
    it, and in that window, drag a new **Visual Element** to the **Hierarchy** or
    **Viewport** and call it `Container` (the **Name** property in the **Inspector**
    in **UI Builder**).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击UI文档资产以打开**UI Builder**窗口进行编辑，并在该窗口中，将一个新的**视觉元素**拖动到**Hierarchy**或**视口**并命名为`Container`（在**UI
    Builder**的**检查器**中的**名称**属性）。
- en: Set the **Left**, **Right**, **Top**, and **Right** **Position** attributes
    to `0px`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**左**、**右**、**上**和**右**的**位置**属性设置为`0px`。
- en: Set **Position** to **Absolute**.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**位置**设置为**绝对**。
- en: Set **Width** and **Height** in the **Size** section to **auto**. This will
    make the container fit the entire screen.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**大小**部分将**宽度**和**高度**设置为**自动**。这将使容器适应整个屏幕。
- en: Drag a new **Visual Element** to be a child of the **Container** and call it
    `Background`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的**视觉元素**拖动到**容器**下作为子元素并命名为`Background`。
- en: Leave **Position** as **Relative** this time.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次将**位置**保留为**相对**。
- en: Set **Size**’s **Width** and **Height** to `500px`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**大小**的**宽度**和**高度**设置为`500px`。
- en: Set the **Background Image** of the **Background** object to use the same background
    sprite used in the previous chapter.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**背景图像**的**背景**对象设置为使用上一章中使用的相同背景精灵。
- en: Select the **Container** parent object (not the **Background**).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**容器**父对象（不是**背景**）。
- en: In the **Inspector**, set the **Align Items** property of the **Align** section
    to `center`, which is the third button. If you hover the mouse over the icons,
    they will show their names in a tooltip.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**对齐项**属性设置为**居中**，这是第三个按钮。如果将鼠标悬停在图标上，它们将在工具提示中显示其名称。
- en: 'Set **Justify Content** to **Center** (second button):'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Justify Content**设置为**居中**（第二个按钮）：
- en: '![](img/B18585_16_34.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_34.png)'
- en: 'Figure 16.34: Preparing the UI background to host elements inside'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.34：准备UI背景以容纳内部元素
- en: Change the size of the UI using the white bars at the sides to see how the background
    is always centered.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用侧面的白色条调整UI的大小，以查看背景始终居中。
- en: Even if we have only one element, we can start seeing how the relative positions
    work. First, we created an empty object that will always adapt to the screen size,
    allowing us to make the children’s elements depend on the full screen size. Then,
    we created an image element with a fixed size, but with relative position, meaning
    its position will be calculated by the parent container. Finally, we told the
    **Container** to make its child objects aligned to its horizontal and vertical
    center, so the background immediately became centered whatever the screen size
    is. When working with absolute positions, the Align properties didn’t work, so
    this is one of the first benefits of **relative** positioning.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有一个元素，我们也可以开始看到相对位置是如何工作的。首先，我们创建了一个始终适应屏幕大小的空对象，使我们能够使子元素依赖于整个屏幕大小。然后，我们创建了一个具有固定大小的图像元素，但具有相对位置，这意味着其位置将由父容器计算。最后，我们告诉**容器**使其子对象与它的水平和垂直中心对齐，因此背景立即居中，无论屏幕大小如何。当使用绝对位置时，对齐属性不起作用，因此这是**相对**定位的第一个好处之一。
- en: 'But **relative** positioning becomes more powerful with multiple elements,
    so let’s add the **Label** and **Buttons** to our **Background** element to explore
    this concept further by doing the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但**相对**定位在多个元素中变得更加强大，因此让我们将**标签**和**按钮**添加到我们的**背景**元素中，通过以下方式进一步探索这一概念：
- en: 'From the **Library** pane at the bottom left of **UI Builder**, drag a **Label**
    and two **Button** elements inside the **Background** in the **Hierarchy**. Note
    that there’s a bug where sometimes, even if you drag and drop a new element inside
    the desired object, it won’t be its child. Just drag the one created in the Hierarchy
    this time:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**UI Builder**左下角的**库**面板中，拖动一个**标签**和两个**按钮**元素到**层次结构**中的**背景**内。注意，有时即使你将新元素拖放到目标对象内，它也不会成为其子元素。这次请只拖动在层次结构中创建的元素：
- en: '![](img/B18585_16_35.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_35.png)'
- en: 'Figure 16.35: Adding elements inside the menu background'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.35：在菜单背景内添加元素
- en: 'Observe how by default, the elements became vertically aligned one on top of
    the other due to the relative position’s default settings:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察默认情况下，由于相对位置的默认设置，元素如何垂直对齐，一个叠在另一个上面：
- en: '![](img/B18585_16_36.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_36.png)'
- en: 'Figure 16.36: Automatic relative vertical positioning'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.36：自动相对垂直定位
- en: Select the **Background** element and set **Justify Content** to `space-around`
    (fifth button). This will spread the elements along the background.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**背景**元素，并将**内容对齐**设置为`space-around`（第五个按钮）。这将使元素沿背景分布。
- en: 'Set **Align Items** to **center** (third option) to center elements horizontally:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**对齐元素**设置为**居中**（第三个选项）以水平居中元素：
- en: '![](img/B18585_16_37.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_16_37.png)'
- en: 'Figure 16.37: Automatic relative vertical positioning'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.37：自动相对垂直定位
- en: There is a similar mode for **Justify Content** called “space-between” (the
    fourth button in Justify Content) that will also spread the elements along the
    vertical axis but won’t leave space on top of the first element or the bottom
    of the last one. Also, **Align Items** has an option called **stretch** (the fifth
    option) that, like **center**, will center elements horizontally, but also stretch
    them instead of respecting each element’s width. I recommend experimenting with
    the different aligning modes to discover all opportunities.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**内容对齐**有一个类似的模式，称为“space-between”（在内容对齐中的第四个按钮），它也会沿着垂直轴分布元素，但不会在第一个元素的顶部或最后一个元素的底部留下空间。此外，**对齐元素**有一个名为**拉伸**（第五个选项）的选项，与**居中**类似，它将在水平方向上居中元素，但也会拉伸它们而不是尊重每个元素的宽度。我建议尝试不同的对齐模式，以发现所有机会。
- en: Set the **Label** **Text**’s **Font** and **Size** attributes to whatever seems
    fit. In my case, I used the imported font and a size of `60px`. Remember to also
    set the **Text** to `Pause`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**标签**的**文本**的**字体**和**大小**属性设置为适合的任何值。在我的情况下，我使用了导入的字体和`60px`的大小。记得也要将**文本**设置为`暂停`。
- en: Set the **Buttons** **Background Image** to use the same used for the button
    in the last chapter.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**按钮**的**背景图片**设置为与上一章中使用的按钮相同的图片。
- en: Set the **Color** property of the **Background** section to a color with no
    alpha. You can achieve this by clicking the color rectangle and reducing the **A**
    channel in the color picker to `0`. The idea of this color is to act as a background
    for our image, but we don’t need it, so we made it completely transparent.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Background**部分的**Color**属性设置为没有alpha的颜色。你可以通过点击颜色矩形并减少颜色选择器中的**A**通道到`0`来实现这一点。这种颜色的想法是作为我们图像的背景，但我们不需要它，所以我们使其完全透明。
- en: Set the Buttons **Text**’s **Font**, **Size**, and **Color** to whatever seems
    fit to you. In my case, I’m using `50` and gray color.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的**Text**的**Font**、**Size**和**Color**设置为对你来说合适的内容。在我的情况下，我使用`50`和灰色。
- en: 'In the **Margin and Padding** section, set **Padding** to have some spacing
    between the text and the borders of the button. In my case, `30px` did the trick:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Margin and Padding**部分，将**Padding**设置为在文本和按钮边框之间留出一些空间。在我的情况下，`30px`就做到了这一点：
- en: '![](img/B18585_16_38.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_38.png)'
- en: 'Figure 16.38: Adding inner padding to the button contents (the text in this
    case)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.38：为按钮内容添加内部填充（在这个例子中是文本）
- en: Also, set the **Top** and **Bottom** **Padding** of the **Background** to allow
    some space between the borders of the window and its elements. In my case, it
    is `40px` each.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要设置**Background**的**Top**和**Bottom****Padding**，以便在窗口边框和其元素之间留出一些空间。在我的情况下，每个都是`40px`。
- en: As you can see, we changed different settings to set the size of the elements
    dynamically, like font sizes and paddings, and the relative system along with
    the align settings took the role of determining the position of the elements automatically.
    We can rearrange the order of the elements by dragging them in the Hierarchy and
    they will be accommodated automatically. We could have also set the size of the
    elements with the **Size** property, and we can also apply some offsets if desired
    using the **Position** properties, but I encourage you to see how these properties
    behave in Relative mode on your own.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们更改了不同的设置来动态设置元素的大小，如字体大小和填充，以及相对系统以及对齐设置自动确定元素的位置。我们可以通过在层次结构中拖动元素来重新排列元素的顺序，它们将自动适应。我们也可以使用**Size**属性设置元素的大小，并且我们可以使用**Position**属性应用一些偏移量，如果需要的话，但我鼓励你自己看看这些属性在相对模式下的行为。
- en: One last setting I want you to explore is the **Direction** attribute of the
    **Flex** section, which, as you can imagine, will determine the orientation the
    elements will follow, vertically from top to bottom or bottom to top, and horizontally
    from left to right or right to left. For example, you could set **Direction**
    to distribute the elements from left to right using the **row** mode (third button)
    and make the background wider to have a horizontal options menu if you wish.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个我想让你探索的设置是**Flex**部分的**Direction**属性，正如你可以想象的那样，这将决定元素将遵循的朝向，垂直方向从上到下或从下到上，以及水平方向从左到右或从右到左。例如，你可以将**Direction**设置为使用**row**模式（第三个按钮）从左到右分配元素，如果你希望的话，可以使背景更宽以拥有一个水平选项菜单。
- en: '![](img/B18585_16_39.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_16_39.png)'
- en: 'Figure 16.39: Changing to a vertical orientation of elements'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.39：将元素更改为垂直方向
- en: As a side note, you might notice that the images for the background and buttons
    will look bigger than the options menu done in the last chapter. That’s because
    the **Pixels per Unit** setting that we changed on the **Texture** assets to control
    the scaling of the textures won’t take effect in UI Toolkit; you will need to
    manually change the texture file size in any image editor to give it its proper
    size. The best practice here would be to always create the images with a size
    that will look fine in our maximum supported resolution. Usually, this is `1920x1080`
    on PC but note that 4k resolutions are becoming more popular every day.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，你可能注意到背景和按钮的图像看起来比上一章中完成的选项菜单要大。这是因为我们在**Texture**资产上更改的**Pixels per Unit**设置，用于控制纹理的缩放，在UI
    Toolkit中不会生效；你需要手动在任何图像编辑器中更改纹理文件大小以给出适当的大小。这里的最佳实践是始终创建大小适合我们最大支持的分辨率的图像。通常，在PC上是`1920x1080`，但请注意，4k分辨率每天都在变得越来越流行。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had an introduction to the key concepts of UI Toolkit and
    how to create UI Documents and Stylesheets. Regarding UI Documents, we learned
    how to create different elements like images, text, and buttons and how to position
    and size them using different methods, like absolute and relative positioning,
    and pixel or percentual units. Also, we saw how to make the UI adapt to different
    sizes using different combinations of **Position** attributes. Finally, we learned
    how to use USS Stylesheets to share styles between different elements to easily
    manage our whole UI skinning.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了UI工具包的关键概念以及如何创建UI文档和样式表。关于UI文档，我们学习了如何创建不同的元素，如图片、文本和按钮，以及如何使用不同的方法（如绝对和相对定位，以及像素或百分比单位）来定位和调整它们的大小。此外，我们还看到了如何通过不同的**位置**属性组合来使UI适应不同的尺寸。最后，我们学习了如何使用USS样式表在不同元素之间共享样式，以便轻松管理整个UI皮肤。
- en: Essentially, we learned again how to make UIs with a different system. Again,
    please note that this system is still in the experimental phase and is not recommended
    for real production projects. We used all these concepts to recreate the same
    UI created in *Chapter 15*, *User Interface Design*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们再次学习了如何使用不同的系统来制作UI界面。再次提醒，这个系统仍然处于实验阶段，不建议用于实际的生产项目。我们使用所有这些概念来重新创建在*第15章*，*用户界面设计*中创建的相同UI界面。
- en: In the next chapter, we are going to see how to add animations to our game to
    make our character move. We will also see how to create cut-scenes and dynamic
    cameras.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何为我们的游戏添加动画，使我们的角色移动。我们还将了解如何创建剪辑场景和动态摄像机。
