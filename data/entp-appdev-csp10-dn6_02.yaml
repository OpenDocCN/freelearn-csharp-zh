- en: '*Chapter 1*: Designing and Architecting the Enterprise Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：设计和架构企业应用程序'
- en: Enterprise applications are software solutions designed to solve large and complex
    problems for enterprise organizations. They enable *Order-to-Fulfillment* capabilities
    for enterprise customers in the IT, government, education, and public sectors.
    They empower them to digitally transform their businesses with capabilities such
    as product purchasing, payment processing, automated billing, and customer management.
    When it comes to enterprise applications, the number of integrations is quite
    high, and the volume of users is also very high as, typically, applications are
    targeted at a global audience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序是为解决企业组织的大规模和复杂问题而设计的软件解决方案。它们为IT、政府、教育和公共部门的企业客户提供从订单到履行的能力。它们使企业能够通过产品采购、支付处理、自动计费和客户管理等功能，以数字化方式转型其业务。在企业应用程序方面，集成数量相当高，用户数量也非常高，因为通常这些应用程序针对的是全球受众。
- en: To ensure that enterprise systems remain highly reliable, highly available,
    and highly performant, getting the design and architecture right is very important.
    Design and architecture form the foundation of any good software. They form the
    basis of the rest of the software development life cycle; therefore, it is very
    important to, first, get the right design to avoid any rework later, which could
    prove very expensive, depending on the changes required. So, you need a flexible,
    scalable, extensible, and maintainable design and architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保企业系统保持高度可靠、高度可用和高度性能，正确的设计和架构至关重要。设计和架构是任何优秀软件的基础。它们构成了软件开发生命周期的基石；因此，首先获得正确的设计，以避免后续的任何返工，这一点非常重要，因为根据所需的变化，返工可能会非常昂贵。所以，你需要一个灵活、可扩展、可扩展和可维护的设计和架构。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A primer on common design principles and patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见设计原则和模式的入门指南
- en: Understanding common enterprise architectures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解常见的企业架构
- en: Identifying enterprise application requirements (business and technical)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别企业应用程序需求（业务和技术）
- en: Architecting an enterprise application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构企业应用程序
- en: Solution structuring for an enterprise application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业应用程序的解决方案结构
- en: By the end of this chapter, you will be able to start designing and architecting
    enterprise applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够开始设计和架构企业应用程序。
- en: A primer on common design principles and patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见设计原则和模式的入门指南
- en: Every piece of software in the world solves at least one real-world problem.
    As time goes by, things change, including what we expect from any specific software.
    To manage this change and deal with various aspects of software, engineers have
    developed several programming paradigms, frameworks, tools, techniques, processes,
    and principles. These principles and patterns, proven over time, have become guiding
    stars for engineers to build quality software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上每一块软件都至少解决了一个现实世界的问题。随着时间的推移，事物会发生变化，包括我们对任何特定软件的期望。为了管理这种变化并处理软件的各个方面，工程师们已经开发了几种编程范式、框架、工具、技术、流程和原则。这些经过时间考验的原则和模式已成为工程师构建高质量软件的指南星。
- en: Principles are high-level abstract guidelines to be followed while designing.
    They are applicable regardless of the programming language being used. They do
    not provide implementation guidelines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 原则是设计时遵循的高级抽象指南。它们适用于使用的任何编程语言。它们不提供实现指南。
- en: Patterns are low-level specific implementation guidelines that are proven, reusable
    solutions for recurring problems. First, let's start with design principles.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是针对重复出现的问题的经过验证、可重用的解决方案的低级具体实现指南。首先，让我们从设计原则开始。
- en: Design principles
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计原则
- en: Techniques become principles if they are widely accepted, practiced, and proven
    to be useful in any industry. Those principles become solutions to make software
    designs more understandable, flexible, and maintainable. In this section, we will
    cover the SOLID, KISS, and DRY design principles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果技术被广泛接受、实践并被证明在任何行业中都有用，那么它们就会成为原则。这些原则成为使软件设计更易于理解、灵活和可维护的解决方案。在本节中，我们将介绍SOLID、KISS和DRY设计原则。
- en: SOLID
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SOLID
- en: The SOLID principles are a subset of the many principles promoted by an American
    software engineer and instructor, Robert C. Martin. These principles have become
    the de facto standard principles in the OOP world and have become part of the
    core philosophy for other methodologies and paradigms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 原则是美国软件工程师和讲师罗伯特·C·马丁（Robert C. Martin）推广的许多原则的一个子集。这些原则已经成为面向对象（OOP）世界中的事实标准原则，并已成为其他方法和范式的核心哲学的一部分。
- en: 'SOLID is an acronym for the following five principles:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 是以下五个原则的缩写：
- en: '**Single-responsibility principle** (**SRP**): An entity or software module
    should only have a single responsibility. You should avoid granting multiple responsibilities
    to one entity.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）：实体或软件模块应该只有一个职责。你应该避免将多个职责赋予一个实体。'
- en: '![Figure 1.1 – SRP'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – SRP](img/Figure_1.1_B18507.jpg)'
- en: '](img/Figure_1.1_B18507.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – B18507](img/Figure_1.1_B18507.jpg)'
- en: Figure 1.1 – SRP
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – SRP
- en: '**Open-closed principle** (**OCP**): Entities should be designed in such a
    way that they are open for extension but closed for modification. This means the
    regression testing of existing behaviors can be avoided; only extensions need
    to be tested.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开闭原则**（**OCP**）：实体应该设计成这样，即它们对扩展是开放的，但对修改是封闭的。这意味着可以避免现有行为的回归测试；只需测试扩展即可。'
- en: '![Figure 1.2 – OCP'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – OCP](img/Figure_1.2_B18507.jpg)'
- en: '](img/Figure_1.2_B18507.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – B18507](img/Figure_1.2_B18507.jpg)'
- en: Figure 1.2 – OCP
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – OCP
- en: '**Liskov substitution principle** (**LSP**): Parent or base class instances
    should be replaceable with instances of their derived classes or subtypes without
    altering the sanity of the program.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**（**LSP**）：父类或基类实例应该可以用其派生类或子类型实例替换，而不会改变程序的合理性。'
- en: '![Figure 1.3 – LSP'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – LSP](img/Figure_1.3_B18507.jpg)'
- en: '](img/Figure_1.3_B18507.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – B18507](img/Figure_1.3_B18507.jpg)'
- en: Figure 1.3 – LSP
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – LSP
- en: '**Interface segregation principle** (**ISP**): Instead of one common large
    interface, you should plan multiple, scenario-specific interfaces for better decoupling
    and change management:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）：而不是一个通用的一个大接口，你应该计划多个、场景特定的接口，以实现更好的解耦和变更管理：'
- en: '![Figure 1.4 – ISP'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – ISP](img/Figure_1.4_B18507.jpg)'
- en: '](img/Figure_1.4_B18507.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – B18507](img/Figure_1.4_B18507.jpg)'
- en: Figure 1.4 – ISP
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – ISP
- en: '**Dependency inversion principle** (**DIP**): You should avoid having any direct
    dependency on concrete implementations. High-level modules and low-level modules
    should not depend on each other directly. Instead, both should depend on abstractions
    as much as possible. Abstractions should not depend on details, and details should
    depend on abstractions.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）：你应该避免对具体实现有任何直接依赖。高层模块和低层模块不应直接相互依赖。相反，两者应尽可能依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。'
- en: '![Figure 1.5 – DIP'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – DIP](img/Figure_1.5_B18507.jpg)'
- en: '](img/Figure_1.5_B18507.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – DIP](img/Figure_1.5_B18507.jpg)'
- en: Figure 1.5 – DIP
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – DIP
- en: Don't Repeat Yourself (DRY)
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要重复自己（DRY）
- en: With DRY, a system should be designed in such a way that the implementation
    of a feature or a pattern should not be repeated in multiple places. This would
    result in maintenance overhead, as a change in requirements would result in modifications
    being needed at multiple places. If you fail to make a necessary update in one
    place by mistake, the behavior of the system will become inconsistent. Rather,
    the feature should be wrapped into a package and should be reused in all places.
    In the case of a database, you should look at using data normalization to reduce
    redundancy.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DRY 原则，系统应该设计成这样，即一个功能或模式的实现不应该在多个地方重复。这会导致维护开销，因为需求的变化会导致多个地方需要修改。如果你不小心在一个地方没有进行必要的更新，系统的行为将变得不一致。相反，该功能应该被封装成一个包，并在所有地方重用。在数据库的情况下，你应该考虑使用数据规范化来减少冗余。
- en: '![Figure 1.6 – DRY'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – DRY](img/Figure_1.6_B18507.jpg)'
- en: '](img/Figure_1.6_B18507.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – B18507](img/Figure_1.6_B18507.jpg)'
- en: Figure 1.6 – DRY
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – DRY
- en: This strategy helps in reducing redundancy and promoting reuse. This principle
    helps an organization's culture too, encouraging more collaboration.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略有助于减少冗余并促进重用。这个原则也有助于组织文化，鼓励更多的协作。
- en: Keep it simple, stupid (KISS)
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单就是最好（KISS）
- en: With KISS, a system should be designed as simply as possible, avoiding complicated
    designs, algorithms, new untried technologies, and more. You should focus on leveraging
    the right OOP concepts and reusing proven patterns and principles. Include new
    or non-simple things only if it is necessary and adds value to the implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 KISS 原则，系统应该尽可能简单地进行设计，避免复杂的设计、算法、新技术以及更多。你应该专注于利用正确的面向对象概念和重用经过验证的模式和原则。只有当它是必要的并且增加了实现的价值时，才包括新或不简单的事物。
- en: 'When you keep it simple, you will be able to do the following better:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保持简单时，你将能够更好地做到以下事情：
- en: Avoid mistakes while designing/developing.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计/开发过程中避免错误。
- en: Keep the train running (there is always a team whose job is to maintain the
    system, even though they are not the team that developed the system in the first
    place).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持列车运行（总有一个团队负责维护系统，即使他们最初并没有开发系统）。
- en: Read and understand your system code (your system code needs to be understandable
    to people who are new to it or for people who will use it in the future).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读并理解你的系统代码（你的系统代码需要对新来的人或未来将使用它的人可理解）。
- en: Do better and less error-prone change management.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做得更好，减少错误的风险进行变更管理。
- en: With this, we are done with our primer on common design principles; we have
    learned about SOLID, DRY, and KISS. In the next section, we'll look at some common
    design patterns in the context of real-world examples to help you understand the
    difference between principles and patterns and when to leverage which pattern—a
    skill that's essential for good design and architecture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们完成了对常见设计原则的入门介绍；我们学习了 SOLID、DRY 和 KISS。在下一节中，我们将通过现实世界的例子来探讨一些常见的设计模式，以帮助您理解原则和模式之间的区别以及何时使用哪种模式——这是良好设计和架构所必需的技能。
- en: Design patterns
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式
- en: 'While following design principles in the OOP paradigm, you might see the same
    structures and patterns repeating over and again. These repeating structures and
    techniques are proven solutions to common problems and are known as **design patterns**.
    Proven design patterns are easy to reuse, implement, change, and test. The well-known
    book, *Design Patterns: Elements of Reusable Object-Oriented Software*, comprising
    what is known as the **Gang of Four** (**GOF**) design patterns, is considered
    the bible of patterns.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循面向对象（OOP）范式的设计原则时，你可能会看到相同的结构和模式反复出现。这些重复的结构和技术是解决常见问题的既定解决方案，被称为**设计模式**。经过验证的设计模式易于重用、实现、更改和测试。著名的书籍《设计模式：可重用面向对象软件的元素》，包含了被称为**四人帮**（**GOF**）的设计模式，被认为是模式的圣经。
- en: 'We can categorize the GOF patterns as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 GOF 模式分类如下：
- en: '**Creative**: Helpful in creating objects'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创造**：有助于创建对象'
- en: '**Structural**: Helpful in dealing with the composition of objects'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构**：有助于处理对象的组成'
- en: '**Behavioral**: Helpful in defining the interactions between objects and distributing
    responsibility'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为**：有助于定义对象之间的交互和分配责任'
- en: Let's look at these patterns with some real-life examples.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些现实生活中的例子来看看这些模式。
- en: Creational design patterns
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: 'Let''s take a look at some creational design patterns, along with relevant
    examples, in the following table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下表格中的一些创建型设计模式及其相关示例：
- en: '![Table 1.1 – Creational design patterns'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 1.1 – 创建型设计模式'
- en: '](img/Table_1.1.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_1.1.jpg)'
- en: Table 1.1 – Creational design patterns
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 创建型设计模式
- en: Structural design patterns
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: 'The following table includes some examples of structural design patterns:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了一些结构设计模式的示例：
- en: '![Table 1.2 – Structural design patterns'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 1.2 – 结构设计模式'
- en: '](img/Table_1.2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_1.2.jpg)'
- en: Table 1.2 – Structural design patterns
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.2 – 结构设计模式
- en: Behavioral design patterns
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: 'The following table includes some examples of behavioral design patterns:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了一些行为设计模式的示例：
- en: '![Table 1.3 – Behavioral design patterns'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 1.3 – 行为设计模式'
- en: '](img/Table_1.3.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_1.3.jpg)'
- en: Table 1.3 – Behavioral design patterns
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.3 – 行为设计模式
- en: Sometimes, you can become overwhelmed by all these patterns being inside the
    table. But really, any design is a good design until it violates the basic principles.
    One rule of thumb that we can use is to *go back to the basics*, and in design,
    principles are the basics.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能会被所有这些模式在表格中的内容所淹没。但事实上，任何设计只要不违反基本原理，都是好的设计。我们可以使用的一个经验法则是**回归基本**，在设计上，原则是基础。
- en: '![Figure 1.7 – Patterns versus principles'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 模式与原则'
- en: '](img/Figure_1.7_B18507.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.7_B18507.jpg)'
- en: Figure 1.7 – Patterns versus principles
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 模式与原则
- en: With this, we are done with our primer on common design principles and patterns.
    By now, you should have a good understanding of the different principles and patterns,
    where to use them, and what it takes to build a great solution. Now, let's spend
    some time looking at common enterprise architectures.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们完成了对常见设计原则和模式的入门介绍。到现在，你应该对不同的原则和模式、它们的使用场景以及构建优秀解决方案所需的内容有了很好的理解。现在，让我们花些时间来了解常见的企业架构。
- en: Understanding common enterprise architectures
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常见的企业架构
- en: There are a few principles and architectures that are commonly practiced when
    designing enterprise applications. First and foremost, the goal of any architecture
    is to support business needs at the lowest cost possible (costs being time and
    resources). A business wants software to enable it rather than act as a bottleneck.
    In today's world, availability, reliability, and performance are the three KPIs
    of any system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计企业应用程序时，通常遵循一些原则和架构。首先，任何架构的目标都是以尽可能低的成本支持业务需求（成本是时间和资源）。企业希望软件能够使其业务更高效，而不是成为瓶颈。在当今世界，可用性、可靠性和性能是任何系统的三个关键绩效指标。
- en: In this section, first, we will look at the issues with monolithic architectures,
    and then we will see how to avoid them by using widely adopted and proven architectures
    for developing enterprise applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，首先，我们将探讨单体架构的问题，然后我们将看到如何通过使用广泛采用和经过验证的企业应用程序开发架构来避免这些问题。
- en: 'Consider a classical monolithic e-commerce website application, such as the
    one shown in the following diagram, with all the business providers and functionality
    in a single app and data being stored in a classical SQL database:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个经典的单体电子商务网站应用，如下面的图所示，所有业务提供者和功能都在一个应用程序中，数据存储在传统的SQL数据库中：
- en: '![Figure 1.8 – A monolithic app'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 – 单体应用'
- en: '](img/Figure_1.8_B18507.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.8_B18507.jpg)'
- en: Figure 1.8 – A monolithic app
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 单体应用
- en: The monolithic architecture was widely adopted 15–20 years ago, but plenty of
    problems arose for software engineering teams when systems grew and business needs
    expanded over time. Let's look at some of the common issues with this approach.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构在15-20年前被广泛采用，但随着系统增长和业务需求随时间扩展，软件工程团队出现了许多问题。让我们看看这种方法的常见问题。
- en: Common issues with monolithic apps
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体应用的常见问题
- en: 'Let''s take a look at the scaling issues:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看扩展性问题：
- en: In a monolithic app, the only way to horizontally scale is by adding more compute
    to the system. This leads to higher operational costs and unoptimized resource
    utilization. Sometimes, scaling becomes impossible due to conflicting needs in
    terms of resources.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单体应用中，横向扩展的唯一方式是通过向系统中添加更多计算资源。这导致更高的运营成本和未优化的资源利用率。有时，由于资源需求冲突，扩展变得不可能。
- en: As all the features mostly use single storage, there is the possibility of locks
    leading to high latency, and there will also be physical limits as to how far
    a single storage instance can scale.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于所有功能大多使用单一存储，存在锁导致高延迟的可能性，同时也会存在单一存储实例可扩展的物理限制。
- en: 'Here is a list of issues associated with availability, reliability, and performance:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些与可用性、可靠性和性能相关的问题：
- en: Any changes in the system will require the redeployment of all components, leading
    to downtime and low availability.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何系统中的更改都要求重新部署所有组件，导致停机时间和低可用性。
- en: Any non-persistent state, such as sessions stored in a web app, will be lost
    after every deployment. This will lead to the abandonment of all workflows that
    were triggered by users.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何非持久状态，如存储在Web应用程序中的会话，在每次部署后都会丢失。这将导致所有由用户触发的流程被放弃。
- en: Any bugs in a module, such as memory leaks or security bugs, make all the modules
    vulnerable and have the potential to impact the whole system.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何模块中的错误，如内存泄漏或安全漏洞，都会使所有模块变得脆弱，并有可能影响整个系统。
- en: Due to the highly coupled nature and sharing of resources within modules, there
    will always be unoptimized use of resources, leading to high latency in the system.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于模块内部高度耦合和资源共享的特性，资源总会存在未被优化的使用，导致系统中的高延迟。
- en: 'Lastly, let''s see what the impact on the business and engineering teams is:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看这对业务和工程团队的影响：
- en: The impact of a change is difficult to quantify and requires extensive testing.
    Hence, it slows down the rate of delivery to production. Even a small change will
    require the entire system to be deployed again.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化的影响难以量化，需要广泛的测试。因此，它减缓了向生产交付的速度。即使是微小的变化，也需要重新部署整个系统。
- en: In a single highly coupled system, there will always be physical limits on collaborations
    across teams to deliver any features.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个高度耦合的系统中，跨团队交付任何功能都会有物理限制。
- en: New scenarios such as mobile apps, chatbots, and analysis engines will take
    more effort as there are no independent reusable components or services.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新场景，如移动应用、聊天机器人和分析引擎，需要更多的努力，因为没有独立的可重用组件或服务。
- en: Continuous deployment is almost impossible.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署几乎是不可能的。
- en: Let's try to solve these common problems by adopting some proven principles/
    architectures.
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们通过采用一些经过验证的原则/架构来尝试解决这些常见问题。
- en: Separation of concerns/single-responsibility architecture
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离/单一职责架构
- en: Software should be divided into components or modules based on the kind of work
    it performs where every module or component owns a single responsibility from
    the entire software's responsibility. Interaction between components happens via
    interfaces or messaging systems. Let's look at the n-tier and microservices architecture
    and how the separation of concerns is taken care of.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应根据其执行的工作类型划分为组件或模块，其中每个模块或组件都拥有整个软件的单一职责。组件之间的交互通过接口或消息系统进行。让我们看看 n 层架构和微服务架构以及如何处理关注点分离。
- en: N-tier architecture
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: N 层架构
- en: 'N-tier architecture divides the application of a system into three (or n) tiers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: N 层架构将系统的应用划分为三个（或 n）层：
- en: '**Presentation** (known as the UX layer, the UI layer, or the work surface)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示**（称为 UX 层、UI 层或工作表面）'
- en: '**Business** (known as the business rules layer or the services layer)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务**（称为业务规则层或服务层）'
- en: '**Data** (known as the data storage and access layer)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**（称为数据存储和访问层）'
- en: '![Figure 1.9 – N-tier architecture'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – N 层架构'
- en: '](img/Figure_1.9_B18507.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.9](img/Figure_1.9_B18507.jpg)'
- en: Figure 1.9 – N-tier architecture
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – N 层架构
- en: These tiers can be owned/managed/deployed separately. For example, multiple
    presentation layers, such as the web, mobile, and bot layers, can leverage the
    same business and data tier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些层可以分别拥有/管理/部署。例如，多个表示层，如网页、移动和机器人层，可以利用相同的企业和数据层。
- en: Microservices architecture
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务架构
- en: 'Microservices architecture consists of small, loosely coupled, independent,
    and autonomous services. Let''s see their benefits:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构由小型、松散耦合、独立和自治的服务组成。让我们看看它们的优点：
- en: Services can be deployed and scaled independently. An issue in one service will
    have a local impact and can be fixed by just deploying the impacted service. There
    is no compulsion to share technology or frameworks.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以独立部署和扩展。一个服务的问题只会产生局部影响，只需部署受影响的服务即可修复。没有共享技术或框架的强制要求。
- en: Services communicate with each other via well-defined APIs or messaging systems
    such as the Azure service bus.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务通过定义良好的 API 或如 Azure 服务总线之类的消息系统相互通信。
- en: '![Figure 1.10 – Microservices architecture'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 微服务架构'
- en: '](img/Figure_1.10_B18507.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.10](img/Figure_1.10_B18507.jpg)'
- en: Figure 1.10 – Microservices architecture
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 微服务架构
- en: As you can see in the preceding diagram, a service can be owned by independent
    teams and have its own cycle. Services are responsible for managing their own
    data stores. Scenarios demanding lower latency can be optimized by bringing in
    a cache or high-performance NoSQL stores.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，一个服务可以由独立的团队拥有并拥有自己的周期。服务负责管理自己的数据存储。对于需要较低延迟的场景，可以通过引入缓存或高性能 NoSQL 存储进行优化。
- en: Stateless services architecture
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态服务架构
- en: Services should not have any state. State and data should be managed independently
    from services, that is, externally through a data store such as a distributed
    cache or a database. By delegating the state externally, services will have the
    resources to serve more requests with high reliability. The following diagram
    shows an example of stateful services on the left-hand side. Here, state is maintained
    in each service through an in-memory cache or session provider, whereas a stateless
    service, as shown on the right-hand side, manages state and data externally.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 服务不应有任何状态。状态和数据应独立于服务进行管理，即通过外部数据存储，如分布式缓存或数据库。通过将状态委托给外部，服务将拥有资源以高可靠性服务更多请求。以下图示展示了左侧的状态服务示例。在这里，状态通过内存缓存或会话提供者在每个服务中维护，而右侧所示的无状态服务则在外部管理状态和数据。
- en: '![Figure 1.11 – Stateful (left) versus stateless (right)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11 – 有状态（左侧）与无状态（右侧）'
- en: '](img/Figure_1.11_B18507.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.11_B18507.jpg)'
- en: Figure 1.11 – Stateful (left) versus stateless (right)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 有状态（左侧）与无状态（右侧）
- en: Session affinity should not be enabled as it leads to sticky session issues
    and will stop you from getting the benefits of load balancing, scalability, and
    the distribution of traffic.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不应启用会话亲和性，因为它会导致会话粘性问题，并阻止您获得负载均衡、可扩展性和流量分布的好处。
- en: Event-driven architecture
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: 'The main features of event-driven architectures are listed as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构的主要特点如下：
- en: In an event-driven architecture, communication, which is generally known as
    **publisher-subscriber communication**, between modules, is primarily asynchronous
    and achieved via events. Producers and consumers are totally decoupled from each
    other. The structure of the event is the only contract that is exchanged between
    them.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件驱动架构中，模块之间的通信，通常称为**发布者-订阅者通信**，主要是异步的，并通过事件实现。生产者和消费者彼此完全解耦。事件的结构是他们之间交换的唯一合约。
- en: There can be multiple consumers of the same event taking care of their specific
    operations; ideally, they won't even be aware of each other. Producers can continuously
    push events without worrying about the availability of consumers.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个事件可以有多个消费者负责它们特定的操作；理想情况下，它们甚至不会意识到彼此的存在。生产者可以持续推送事件，无需担心消费者的可用性。
- en: Publishers publish events via a messaging infrastructure such as queues or a
    service bus. Once an event has been published, the messaging infrastructure is
    responsible for sending the event to eligible subscribers.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者通过消息基础设施，如队列或服务总线，发布事件。一旦事件被发布，消息基础设施就负责将事件发送给合格的订阅者。
- en: '![Figure 1.12 – Event-driven architecture'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – 事件驱动架构'
- en: '](img/Figure_1.12_B18507.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.12_B18507.jpg)'
- en: Figure 1.12 – Event-driven architecture
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 事件驱动架构
- en: This architecture is best suited for scenarios that are asynchronous in nature.
    For example, long-running operations can be queued for processing. A client might
    poll for status or even act as a subscriber for an event.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构最适合本质上是异步的场景。例如，长时间运行的操作可以排队处理。客户端可能会轮询状态，甚至充当事件的订阅者。
- en: Resiliency architecture
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性架构
- en: As the communication between components increases, so does the possibility of
    failures. A system should be designed to recover from any kind of failure. We
    will cover a few strategies for building a fault-tolerant system that can heal
    itself in the case of failures.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组件之间通信的增加，故障的可能性也会增加。系统应该设计成能够从任何类型的故障中恢复。我们将介绍一些构建容错系统的方法，该系统在出现故障时可以自我修复。
- en: If you are familiar with Azure, you'll know that applications, services, and
    data should be replicated globally in at least two Azure regions for planned downtime
    and unplanned transient or permanent failures, as shown in the following screenshot.
    In these scenarios, choosing Azure App Service to host web applications, using
    REST APIs, and choosing a globally distributed database service, such as Azure
    Cosmos DB, is wise. Choosing Azure paired regions will help in **business continuity
    and disaster recovery** (**BCDR**), as at least one region in each pair will be
    prioritized for recovery if an outage affects multiple regions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Azure，你会知道应用程序、服务和数据应该在全球至少两个Azure区域中进行复制，以应对计划内的停机时间和计划外瞬态或永久性故障，如下面的截图所示。在这些场景中，选择Azure
    App Service托管Web应用程序、使用REST API以及选择全球分布式数据库服务，如Azure Cosmos DB，是明智的。选择Azure配对区域将有助于**业务连续性和灾难恢复**（**BCDR**），因为如果多个区域出现故障，至少每个配对中的一个区域将优先用于恢复。
- en: '![Figure 1.13 – Resiliency architecture'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13 – 弹性架构'
- en: '](img/Figure_1.13_B18507.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.13_B18507.jpg]'
- en: Figure 1.13 – Resiliency architecture
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 弹性架构
- en: Now, let's see how to tackle different types of faults.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何处理不同类型的故障。
- en: 'Transient faults can occur in any type of communication or service. You need
    to have a strategy to recover from transient faults, such as the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬态故障可能发生在任何类型的通信或服务中。你需要有一个从瞬态故障中恢复的策略，如下所示：
- en: Identify the operation and type of transient fault. Then, determine the appropriate
    retry count and interval.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别操作和瞬态故障的类型。然后，确定适当的重试次数和间隔。
- en: Avoid anti-patterns such as endless retry mechanisms with a finite number of
    retries or circuit breakers.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免如有限重试次数的无限重试机制或断路器等反模式。
- en: 'If a failure is not transient, you should respond to the failure gracefully
    by choosing some of the following options:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果故障不是瞬态的，你应该通过选择以下一些选项来优雅地响应故障：
- en: Failing over
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障转移
- en: Compensating for any failed operations
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补偿任何失败的操作
- en: Throttling/blocking the bad client/actor
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制/阻止不良客户端/参与者
- en: Using a leader election to select a leader in the case of a failure
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现故障的情况下，使用领导者选举来选择领导者
- en: Here, telemetry plays a big role; you should have custom metrics to keep a tab
    on the health of any component. Alerts can be raised when a custom event occurs
    or a specific metric reaches a certain threshold.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，遥测发挥着重要作用；你应该有自定义指标来监控任何组件的健康状况。当发生自定义事件或特定指标达到某个阈值时，可以发出警报。
- en: With this, we are done with our coverage of common enterprise architectures.
    Next, we will look at the requirements of enterprise applications and their different
    architectures through the lens of the design principles and common architectures
    that we learned about earlier.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们完成了对常见企业架构的覆盖。接下来，我们将通过之前学到的设计原则和常见架构的视角，探讨企业应用程序的需求及其不同的架构。
- en: Identifying enterprise application requirements (business and technical)
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别企业应用程序需求（商业和技术）
- en: In the next few chapters, we will build a working e-commerce application. It
    will be a three-tier application consisting of a UI layer, a service layer, and
    a database. Let's look at the requirements for this e-commerce application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将构建一个可工作的电子商务应用程序。它将是一个三层应用程序，包括UI层、服务层和数据库。让我们看看这个电子商务应用程序的需求。
- en: The solution requirements are the capabilities to be implemented and made available
    in the product to solve a problem or achieve an objective.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案需求是在产品中实现并提供的功能，以解决一个问题或实现一个目标。
- en: The business requirements are simply the end customer's needs. In the IT world,
    *business, generally, refers to customers*. These requirements are collected from
    various stakeholders and documented as a single source of truth for everyone's
    preference. Eventually, this becomes the backlog and scope of work to be completed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 商业需求仅仅是最终客户的需求。在IT领域，*商业通常指的是客户*。这些需求从各个利益相关者那里收集，并作为每个人偏好的单一真实来源进行记录。最终，这成为待完成的工作的待办事项和范围。
- en: The technical requirements are the technology-related aspects that a system
    should implement, such as reliability, availability, performance, and BCDR. These
    are also known as **quality-of-service** (**QoS**) requirements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 技术需求是一个系统应该实施的技术相关方面，例如可靠性、可用性、性能和BCDR。这些也被称为**服务质量**（**QoS**）需求。
- en: 'Let''s break the typical business requirements for an e-commerce application
    site down into the following categories: **Epic**, **Feature**, and **User Story**.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将电子商务应用程序的典型业务需求分解为以下类别：**史诗**、**功能**和**用户故事**。
- en: The application's business requirements
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的业务需求
- en: The following screenshot, from Azure DevOps, shows a summary of the backlog
    of our business requirements. You can see the different features that are expected
    in our application along with the user stories.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 Azure DevOps 中获取的屏幕截图，显示了业务需求待办事项的摘要。您可以看到我们应用程序中预期的不同功能以及用户故事。
- en: '![Figure 1.14 – Requirement backlog from Azure DevOps'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.14 – 来自 Azure DevOps 的需求待办事项](img/Figure_1.14_B18507.jpg)'
- en: '](img/Figure_1.14_B18507.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.14_B18507.jpg](img/Figure_1.14_B18507.jpg)'
- en: Figure 1.14 – Requirement backlog from Azure DevOps
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – 来自 Azure DevOps 的需求待办事项
- en: The application's technical requirements
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的技术需求
- en: 'Having seen the business requirements, let''s now go through the technical
    requirements:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了业务需求后，现在让我们来探讨技术需求：
- en: The e-commerce application should be **highly available**, that is, available
    for 99.99% of the time during any 24-hour period.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务应用程序应具有**高可用性**，即在任何 24 小时周期内，99.99% 的时间内可用。
- en: The e-commerce application should be **highly reliable**, that is, reliable
    for 99.99% of the time during any 24-hour period.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务应用程序应具有**高可靠性**，即在任何 24 小时周期内，99.99% 的时间内是可靠的。
- en: The e-commerce application should be **highly performant**, that is, 95% of
    operations should take less than or be equal to 3 seconds during any 24-hour period.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务应用程序应具有**高度性能**，即在任何 24 小时周期内，95% 的操作应少于或等于 3 秒。
- en: 'The e-commerce application should be **highly scalable**: It should automatically
    scale up/down based on the varying load.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务应用程序应具有**高度可扩展性**：它应根据不同的负载自动进行扩展/缩减。
- en: 'The e-commerce application should have **monitoring and alerts**: An alert
    should be sent to a support engineer in the case of any system failures.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务应用程序应具有**监控和警报**：在发生任何系统故障的情况下，应向支持工程师发送警报。
- en: 'Here are the **technical aspects** and requirements that have been identified
    for the e-commerce application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是已识别的电子商务应用程序的**技术方面**和需求：
- en: The frontend
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: A web application (e-commerce) using ASP.Net 6.0
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASP.Net 6.0 的 Web 应用程序（电子商务）
- en: The core components
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心组件
- en: Logging/caching/configuration in C# 10.0 and .Net 6.0
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 10.0 和 .Net 6.0 中的日志记录/缓存/配置
- en: The middle tier
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间层
- en: An Azure API gateway to implement authentication
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure API 网关用于实现身份验证
- en: A user management service through an ASP.NET 6.0 web API to add/remove users
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ASP.NET 6.0 Web API 实现的用户管理服务以添加/删除用户
- en: Product and pricing services through an ASP.NET 6.0 web API to get products
    from the data store
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ASP.NET 6.0 Web API 实现的产品和定价服务，从数据存储中获取产品
- en: A domain data service through an ASP.NET 6.0 web API to get the domain data,
    such as country data
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ASP.NET 6.0 Web API 实现的领域数据服务，以获取领域数据，例如国家数据
- en: A payment service through an ASP.NET 6.0 web API to complete payments
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ASP.NET 6.0 Web API 实现的支付服务以完成支付
- en: An order processing service through an ASP.NET 6.0 web API to submit and search
    orders
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ASP.NET 6.0 Web API 实现的订单处理服务，用于提交和搜索订单
- en: An invoice processing service through an ASP.NET 6.0 web API to generate invoices
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ASP.NET 6.0 Web API 实现的发票处理服务以生成发票
- en: A notification service through an ASP.NET 6.0 web API to send notifications
    such as emails
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ASP.NET 6.0 Web API 实现的通知服务，用于发送电子邮件等通知
- en: The data tier
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据层
- en: A data access service through an ASP.NET 6.0 web API to talk to Azure Cosmos
    DB to read/write data
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ASP.NET 6.0 Web API 实现的数据访问服务，用于与 Azure Cosmos DB 通信以读取/写入数据
- en: Entity Framework Core to access data
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core 用于访问数据
- en: Azure Stack
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Stack
- en: Azure Cosmos DB as a backend data store
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Cosmos DB 作为后端数据存储
- en: Azure Service Bus for asynchronous message processing
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Service Bus 用于异步消息处理
- en: Azure App Service to host the web application and web APIs
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure App Service 用于托管 Web 应用程序和 Web API
- en: Azure Traffic Manager for high availability and responsiveness
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Traffic Manager 用于高可用性和响应性
- en: Azure Application Insights for diagnostics and telemetry
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Application Insights 用于诊断和遥测
- en: Azure paired regions for better resiliency
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 配对区域以提高容错能力
- en: Azure resource groups to create **Azure Resource Manager** (**ARM**) templates
    and deploy them to the Azure subscription
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 资源组用于创建 **Azure 资源管理器**（**ARM**）模板并将它们部署到 Azure 订阅
- en: Azure Pipelines for **continuous integration and continuous deployment** (**CI/CD**)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Pipelines 用于**持续集成和持续部署**（**CI/CD**）
- en: We are now done with the requirements of the enterprise application. Next, we
    will look at how to architect an enterprise application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了企业应用的需求。接下来，我们将探讨如何架构一个企业应用。
- en: Architecting an enterprise application
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构企业应用
- en: 'The following architectural diagram depicts what we are building. We need to
    bear in mind all of the design principles, patterns, and requirements that we
    have seen in this chapter when we are architecting and developing the application.
    The following diagram shows the proposed architecture for our e-commerce enterprise
    application:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构图展示了我们将要构建的内容。在架构和开发应用时，我们需要牢记我们在本章中看到的所有的设计原则、模式和需求。以下图显示了我们的电子商务企业应用的建议架构：
- en: '![Figure 1.15 – The e-commerce application''s three-tier architecture'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.15 – 电子商务应用的三层架构'
- en: '](img/Figure_1.15_B18507.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.15_B18507.jpg)'
- en: Figure 1.15 – The e-commerce application's three-tier architecture
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 电子商务应用的三层架构
- en: '**Separation of concerns/SRP** has been taken care of at each tier. The presentation
    tier, containing the UI, is separated from the services tier containing the business
    logic. This is again separated from the data access tier containing the data store.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注点分离/单一职责原则**在每个层级都得到了妥善处理。包含用户界面的表示层与包含业务逻辑的服务层分离。这又与包含数据存储的数据访问层分离。'
- en: The high-level components are unaware of the low-level components consuming
    them. The data access tier is unaware of the services consuming it, and the services
    are unaware of the UX tier consuming them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 高级组件对它们所消耗的低级组件不知情。数据访问层对消耗它的服务不知情，而服务对消耗它们的 UX 层也不知情。
- en: Each service is separated based on the business logic and functionality it is
    supposed to perform.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都是根据其应执行的业务逻辑和功能进行分离的。
- en: '**Encapsulation** has been taken care of at the architecture level and should
    be taken care of during development, too. Each component in the architecture will
    be interacting with other components through well-defined interfaces and contracts.
    We should be able to replace any component in the diagram without having to worry
    about its internal implementation and whether it adheres to the contracts.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**在架构层面得到了妥善处理，并且在开发过程中也应该得到妥善处理。架构中的每个组件将通过定义良好的接口和合同与其他组件进行交互。我们应该能够替换图中的任何组件，而无需担心其内部实现以及它是否遵守合同。'
- en: The loosely coupled architecture here also helps with faster development and
    faster deployment to the market for customers. Multiple teams can work, in parallel,
    on each of their components independently. They share the contracts and timelines
    for integration testing at the start, and once the internal implementation and
    unit tests are done, they can start with integration testing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的松散耦合架构也有助于加快开发速度和更快地将产品部署到市场。多个团队可以并行工作，独立地开发各自的组件。他们在开始时共享集成测试的合同和进度表，一旦内部实现和单元测试完成，他们就可以开始集成测试。
- en: 'Refer to the following diagram:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下图：
- en: '![Figure 1.16 – The eCommerce application''s three-tier architecture with highlighted
    chapters'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.16 – 电子商务应用的三层架构，突出显示的章节'
- en: '](img/Figure_1.16_B18507.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.16_B18507.jpg)'
- en: Figure 1.16 – The eCommerce application's three-tier architecture with highlighted
    chapters
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 电子商务应用的三层架构，突出显示的章节
- en: 'From the preceding diagram, we can identify the chapters in which different
    parts of the e-commerce application that we will build will be covered. They can
    be explained as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以识别出我们将要构建的电子商务应用的不同部分将在哪些章节中介绍。它们可以解释如下：
- en: Creating an ASP.NET web application (our e-commerce portal) will be covered
    in [*Chapter 11*](B18507_11_Epub.xhtml#_idTextAnchor1228), *Creating an ASP.NET
    Core 6 Web Application*.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 ASP.NET 网络应用（我们的电子商务门户）将在[*第 11 章*](B18507_11_Epub.xhtml#_idTextAnchor1228)
    *创建 ASP.NET Core 6 网络应用* 中介绍。
- en: Authentication will be covered in [*Chapter 12*](B18507_12_Epub.xhtml#_idTextAnchor1389),
    *Understanding Authentication*.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证将在[*第 12 章*](B18507_12_Epub.xhtml#_idTextAnchor1389) *理解认证* 中介绍。
- en: The order processing service and the invoice processing service are the two
    core services for generating orders and invoicing. They will be the heart of the
    e-commerce application as they are the ones that are responsible for the revenue.
    Creating an ASP.NET Core web API will be covered in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*, and cross-cutting concerns will be covered
    in [*Chapter 5*](B18507_05_Epub.xhtml#_idTextAnchor445), *Dependency Injection
    in .NET 6*, [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473), *Configuration
    in .NET 6*, and [*Chapter 7*](B18507_07_Epub.xhtml#_idTextAnchor596), *Logging
    in .NET 6*, respectively. The DRY principle will be taken care of by reusing core
    components and cross-cutting concerns instead of repeating implementations.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单处理服务和发票处理服务是生成订单和开票的两个核心服务。它们将是电子商务应用的核心，因为它们负责收入。在[*第10章*](B18507_10_Epub.xhtml#_idTextAnchor1040)“创建
    ASP.NET Core 6 Web API”中，我们将介绍如何创建 ASP.NET Core web API，而跨切面关注点将在[*第5章*](B18507_05_Epub.xhtml#_idTextAnchor445)“.NET
    6中的依赖注入”、[*第6章*](B18507_06_Epub.xhtml#_idTextAnchor473)“.NET 6中的配置”和[*第7章*](B18507_07_Epub.xhtml#_idTextAnchor596)“.NET
    6中的日志记录”中分别介绍。通过重用核心组件和跨切面关注点而不是重复实现，我们将遵循DRY原则。
- en: Caching will be covered as part of the product pricing service in [*Chapter
    8*](B18507_08_Epub.xhtml#_idTextAnchor714), *All You Need to Know about Caching*.
    Caching will help us to improve the performance and scalability of our system,
    with temporary copies of frequently accessed data being available in memory.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存作为产品定价服务的一部分将在[*第8章*](B18507_08_Epub.xhtml#_idTextAnchor714)“所有关于缓存的知识”中进行介绍。缓存将帮助我们提高系统的性能和可扩展性，因为频繁访问的数据可以在内存中提供临时副本。
- en: Data storage, access, and the number of providers will be covered as part of
    the data access layer in [*Chapter 9*](B18507_09_Epub.xhtml#_idTextAnchor860),
    *Working with Data in .NET 6*. The kind of architecture that we have adopted,
    where data and access to it are separate from the rest of the application, gives
    us better maintenance. Azure Cosmos DB is our choice to scale throughput and storage
    elastically and independently across any number of Azure regions worldwide. Additionally,
    it is secure by default and enterprise-ready.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储、访问和提供者的数量将在[*第9章*](B18507_09_Epub.xhtml#_idTextAnchor860)“在 .NET 6 中处理数据”的数据访问层部分进行介绍。我们采用的架构，其中数据和对其的访问与应用程序的其余部分分离，使我们能够更好地维护。我们选择Azure
    Cosmos DB来弹性地、独立地扩展任何数量的Azure区域的全局吞吐量和存储。此外，它默认安全且适用于企业。
- en: This concludes our discussion on architecting our enterprise application. Next,
    we will look at the solution structure for our enterprise application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对构建企业应用程序的讨论。接下来，我们将查看企业应用程序的解决方案结构。
- en: Solution structuring of the application
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的解决方案结构
- en: 'To keep things simple, we will go with a single solution for all our projects,
    as shown in the following screenshot. The other approach of having separate solutions
    for the UI, shared components, and web APIs can also be considered when the number
    of projects in the solution explodes and causes maintenance issues. The following
    screenshot shows our application''s solution structure:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将为所有项目使用单个解决方案，如下面的截图所示。当解决方案中的项目数量激增并导致维护问题时，也可以考虑为UI、共享组件和Web API使用单独的解决方案的方法。下面的截图显示了我们的应用程序的解决方案结构：
- en: '![Figure 1.17 – The solution structure of the e-commerce application'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.17 – 电子商务应用程序的解决方案结构'
- en: '](img/Figure_1.17_B18507.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.17_B18507.jpg](img/Figure_1.17_B18507.jpg)'
- en: Figure 1.17 – The solution structure of the e-commerce application
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.17 – 电子商务应用程序的解决方案结构
- en: Here, we have adopted separation of concerns by having separate folder structures
    and projects for UX, Service, Data, Core, and Testing.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过为UX、服务、数据、核心和测试分别设置单独的文件夹结构和项目来实现关注点的分离。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about common design principles such as SOLID, DRY,
    and KISS. Also, we looked at various design patterns with real-world examples.
    Then, we looked at different enterprise architectures, identified the requirements
    for the e-commerce application that we are going to build, and applied what we
    learned to architect our e-commerce application. You can now apply what you have
    learned here when you design any application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了常见的原则，如SOLID、DRY和KISS。我们还通过实际案例研究了各种设计模式。然后，我们探讨了不同的企业架构，确定了我们将要构建的电子商务应用程序的需求，并将所学知识应用于我们的电子商务应用程序的架构。现在，当你设计任何应用程序时，你可以应用在这里学到的知识。
- en: In the next chapter, we will learn about .NET 6 Core and Standard.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习.NET 6 Core和标准。
- en: Questions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the LSP?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是LSP？
- en: a. Base class instances should be replaceable with instances of their derived
    type.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: a. 基类实例应该可以替换为派生类实例。
- en: b. Derived class instances should be replaceable with instances of their base
    type.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: b. 派生类实例应该可以替换为基类实例。
- en: c. Designing for generics that can work with any data type.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: c. 为通用泛型设计，使其能够与任何数据类型一起工作。
- en: '**Answer: a**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: What is SRP?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是SRP？
- en: a. Instead of one common large interface, plan for multiple scenario-specific
    interfaces for better decoupling and change management.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: a. 而不是使用一个通用的庞大接口，应该计划多个针对特定场景的接口，以实现更好的解耦和变更管理。
- en: b. You should avoid taking a direct dependency approach on concrete implementation.
    Instead, you should depend on abstractions as much as possible.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: b. 你应该避免直接依赖具体实现。相反，你应该尽可能依赖抽象。
- en: c. An entity should only have a single responsibility. You should avoid empowering
    one entity with multiple responsibilities.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: c. 实体应该只有一个责任。你应该避免赋予一个实体多个责任。
- en: d. Entities should be designed in such a way that they should be open for extension
    but closed for modification.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: d. 实体应该以这种方式设计，以便它们易于扩展但难以修改。
- en: '**Answer: c**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
- en: What is OCP?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是OCP？
- en: a. Entities should be open to modification but closed for extension.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: a. 实体应该易于修改但难以扩展。
- en: b. Entities should be open to extension but closed for modification.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: b. 实体应该易于扩展但难以修改。
- en: c. Entities should be open to composition but closed for extension.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: c. 实体应该易于组合但难以扩展。
- en: d. Entities should be open to abstraction but closed for inheritance.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: d. 实体应该易于抽象但难以继承。
- en: '**Answer: b**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: Which pattern is used to make two incompatible interfaces work together?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个模式用于使两个不兼容的接口协同工作？
- en: a. Proxy
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: a. 代理模式
- en: b. Bridge
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: b. 桥接模式
- en: c. Iterator
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: c. 迭代器模式
- en: d. Adapter
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: d. 适配器模式
- en: '**Answer: d**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：d**'
- en: Which principle ensures that services can be deployed and scaled independently
    and that an issue in one service will have a local impact, which can be fixed
    by just redeploying the impacted service?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个原则确保服务可以独立部署和扩展，并且一个服务的问题将产生局部影响，这可以通过仅重新部署受影响的服务来解决？
- en: a. The domain-driven design principle
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: a. 领域驱动设计原则
- en: b. The single-responsibility principle
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: b. 单一职责原则
- en: c. The stateless service principle
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: c. 无状态服务原则
- en: d. The resiliency principle
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: d. 弹性原则
- en: '**Answer: b**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
