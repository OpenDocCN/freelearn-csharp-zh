- en: Implementing a Game Manager with the Singleton
  prefs: []
  type: TYPE_NORMAL
- en: In this first hands-on chapter, we will review one of the most infamous software
    design patterns in the field of programming, the **Singleton**. It could be argued
    by many that the Singleton is the most widely used pattern among Unity developers,
    maybe because it's the most straightforward pattern to learn. But it can also
    quickly become the "duct tape" in our programming toolbox that we reach for every
    time we need a quick fix for a complex architectural problem.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when using this pattern, we can quickly establish a simple code
    architecture revolving around wrapping and managing all the core systems of our
    game in individual manager classes. Then we could have these managers expose clean
    and straightforward interfaces that will conceal the inner complexity of the systems.
    Also, to make sure that these managers are easily accessible and only a single
    instance runs at a time, we would implement them as Singletons. This approach
    might sound solid and beneficial, but it's full of pitfalls as it will create
    strong coupling between core components and make unit testing very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will attempt to move away from this type of architecture and
    use design patterns to establish a more robust, modular, and scalable code base.
    But this doesn't mean that we will ignore the Singleton and judge it as inherently
    faulty. Instead, in this chapter, we will explore a use case in which this pattern
    is well suited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the Singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a reusable Singleton class in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a globally accessible GameManager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a hands-on chapter; you will need to have a basic understanding of Unity
    and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concept:
    **Generics**.'
  prefs: []
  type: TYPE_NORMAL
- en: If unfamiliar with this concept, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml),
    *A Short Primer to Programming in Unity*.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter04](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3wDbM6W](https://bit.ly/3wDbM6W)'
  prefs: []
  type: TYPE_NORMAL
- en: Generics is a compelling C# feature that permits us to defer the type for a
    class at runtime. When we say a class is generic, it means that it doesn't have
    a defined object type. This approach is advantageous because we can assign it
    a specific type when we initialize it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name implies, the Singleton pattern's primary goal is to guarantee singularity.
    This approach means if a class implements this pattern correctly, once initialized,
    it will have only one instance of itself in memory during runtime. This mechanism
    can be helpful when you have a class that manages a system that needs to be globally
    accessible from a singular and consistent entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of the Singleton is quite simple. When you implement a Singleton
    class, it becomes responsible for making sure there''s only a single occurrence
    of itself in memory. Once a Singleton detects an instance of an object of the
    same type as itself, it will destroy it immediately. Therefore, it''s pretty ruthless
    and doesn''t tolerate any competition. The following diagram illustrates the process
    to a certain degree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6462456-8fd3-4b52-8ace-904528704212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – UML diagram of the Singleton pattern
  prefs: []
  type: TYPE_NORMAL
- en: The most important takeaway from this description of the Singleton pattern is
    that if well implemented, it makes sure that there can only be one of itself;
    if not, it fails at its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are some of the benefits of the Singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Globally accessible**: We can use the Singleton pattern to create a global
    access point to resources or services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control concurrency**: The pattern can be used to limit concurrent access
    to shared resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some of the drawbacks of the Singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: If overly used, the Singleton can make unit testing very
    difficult. We might end up with Singleton objects being dependent on other Singletons.
    If one is missing at any moment, the chain of dependency gets broken. This issue
    often happens when combining Facade and Singleton to set up front-facing interfaces
    to core systems. We end up with an array of manager classes, each managing a specific
    core component of the game, all dependent on each other to function. Therefore,
    it becomes impossible to test and debug in isolation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Laziness**: Because of its ease of use, the Singleton is a pattern that can
    quickly instill faulty programming habits. As mentioned in the *Unit testing*
    drawback, we can easily make everything accessible from anywhere with the Singleton.
    The simplicity it offers can also make us unwilling to test out more sophisticated
    approaches when writing code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When making design choices, it's essential to always keep in mind whether your
    architecture is maintainable, scalable, and testable. When it comes to testable,
    I often ask myself whether I can easily test my core systems, components, and
    mechanics individually and in isolation. If not, then I know I made some potentially
    unwise decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a Game Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A standard class we often see in Unity projects is the Game Manager. It's usually
    implemented as a Singleton by developers, but its responsibility varies from one
    code base to another. Some programmers use it to manage top-level game states
    or as a globally accessible front-facing interface to core game systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this chapter, we will give it the singular responsibility
    of managing a game session. Similar to the concept of a game master in board gaming,
    it will be responsible for setting up the game for the player. It can also take
    on additional responsibilities, such as communicating with backend services, initializing
    global settings, logging, and saving the player's progress.
  prefs: []
  type: TYPE_NORMAL
- en: The critical thing to keep in mind is that Game Manager will be alive for the
    entire lifespan of the game. Therefore, there will be a singular but persistent
    instance of it in memory at all times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the overall concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d61677e1-5c53-4159-9d2b-54e8d2743a9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Diagram that illustrates the lifespan of the Game Manager
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to take the design we just reviewed and translate
    it into code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Game Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement a Singleton and Game Manager class. We will
    attempt to utilize some core Unity API features to adapt the pattern for use in
    the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first step of the process, we will implement the `Singleton` class.
    To make it easier to understand its intricacies, we will split it up into two
    distinct segments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the first segment of the `Singleton<T>` class, we can see that we implemented
    a `public static` property with a `get` accessor. In this accessor, we are making
    sure that there's no existing instance of this object before initializing a new
    one. `FindObjectOfType<T>()` searches for the first loaded object of a specified
    type. If we can't find one, then we create a new `GameObject`, rename it, and
    add a component to it of a non-specified type.
  prefs: []
  type: TYPE_NORMAL
- en: This process will be more evident when we implement the `GameManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the final segment of the `Singleton` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the last segment of the class, we have an `Awake()` method that we marked
    as `virtual`, which means it can be overridden by a derived class. What is essential
    to understand is that when the `Awake()` method gets called by the engine, the
    Singleton component will check whether there's already an instance of itself initialized
    in memory. If not, then it will become the current instance. But if one already
    exists, it will destroy itself to prevent duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, there can only be one instance of a specific type of Singleton in
    a Scene at once. If you try to add two, one will get automatically destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important detail to review is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`DontDestroyOnLoad` is a public static method that is included in the Unity
    API; it prevents a target object from being destroyed when a new scene is loaded.
    In other words, it makes sure that the current instance of an object persists
    even when switching between scenes. This API feature is handy for our Singleton
    because it guarantees the object will be available throughout the application''s
    lifespan, in this context, the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final steps of our implementation, we will write a skeleton version
    of the `GameManager` class. We will focus only on code that will validate our
    `Singleton` implementation for reasons of brevity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To give more context to `GameManager`, we left a `TODO` list of potential tasks
    for the class to accomplish. But we also added a timer and a GUI button. Both
    will help us validate whether our `Singleton` is working when we start the testing
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'But at the moment, our `GameManager` is not a `Singleton`; to make it one,
    we just need to make one change to a single line of code, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as that; we took a regular `MonoBehaviour` class and converted
    it into a `Singleton` with one line of code. This is made possible because we
    are using Generics. Hence, our `Singleton` class can be anything until we assign
    it a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for our last step, we took our `GameManager` class and converted it into
    `Singleton`, as seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have prepared all our ingredients, it's time to start the testing
    phase, which we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Game Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to test the classes you just wrote in your instance of Unity, then
    you should go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty Unity scene called `Init`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Init` scene, add an empty `GameObject` and attach the `GameManager`
    class to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create several empty Unity scenes, as many as you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Build Settings** under the **File** menu, add the **Init** scene at index
    0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a040acf-a6ed-45b1-8185-575116bbc459.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Build Settings
  prefs: []
  type: TYPE_NORMAL
- en: Then add your new empty Unity scenes to the **Build Settings** list, as many
    as you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you now start the `Init` scene, you should see a GUI button named Next Scene
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2e01498-e545-48b7-9875-a23bf0bf34e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Screenshot of the code example in action
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the Next Scene button, you will cycle through each of the scenes
    you added in Build Settings, and the GUI will persist onscreen. If you stop running
    the game, you should see in the console log the duration of your session. If you
    try to add additional GameManagers to GameObjects in any scene, you will notice
    that they get destroyed, as only one can exist during the entire lifespan of the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our tests; we now have the first draft of a GameManager class
    and a reusable Singleton implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we tackled one of the most controversial design patterns out
    there. But we found a way to implement it with a consistent and reusable approach.
    The Singleton is a pattern that's perfectly suited to Unity's coding model but
    overusing it can lead you to become too dependent on it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review the State pattern, which we will use to
    implement a controller class for the main ingredient of our game, the racing bike.
  prefs: []
  type: TYPE_NORMAL
