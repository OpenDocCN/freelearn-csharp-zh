- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Getting Started with Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始单元测试
- en: '**Unit testing** is the core of TDD and a prerequisite for practicing it. I
    want to briefly go through the minimal necessary theory and focus more instead
    on familiarizing you with the tools and techniques that unit testing practitioners
    utilize in their daily code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是TDD的核心，也是实践TDD的先决条件。我想简要地介绍必要的最小理论，并更多地熟悉您日常代码中单元测试实践者使用的工具和技术。'
- en: Here, you will learn how to write unit tests that cover moderate coding scenarios.
    In *Part 2*, *Building an Application with TDD*, of this book, we will take the
    knowledge acquired in this chapter to a higher level and use it in a lifelike
    fashion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将学习如何编写覆盖适度编码场景的单元测试。在这本书的*第2部分*，*使用TDD构建应用程序*中，我们将把本章学到的知识提升到更高水平，并以更真实的方式使用它。
- en: In the previous chapter, we built the **weather forecasting application** (**WFA**)
    and made it a **dependency injection** (**DI**)-ready. We will use this application
    in this chapter as the basis for learning about unit testing. If you are not familiar
    with DI and DI containers, I recommend starting with [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037),
    *Understanding Dependency Injection by Example*, first.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了**天气预报应用程序**（**WFA**）并将其转换为**依赖注入**（**DI**）就绪。我们将在这个章节中使用这个应用程序作为学习单元测试的基础。如果你不熟悉DI和DI容器，我建议首先从[*第2章*](B18370_02.xhtml#_idTextAnchor037)，*通过示例理解依赖注入*开始。
- en: 'In this chapter, we will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下几件事：
- en: Introduce unit testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍单元测试
- en: Explain the structure of a unit testing project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释单元测试项目的结构
- en: Analyze the anatomy of a unit test class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析单元测试类的结构
- en: Discuss the basics of xUnit
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论xUnit的基本知识
- en: Show how SOLID principles and unit testing are related
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示SOLID原则和单元测试之间的关系
- en: By the end of the chapter, you will be able to write basic unit tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够编写基本的单元测试。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch03](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch03)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch03](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch03)'
- en: Introducing unit testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍单元测试
- en: As a TDD practitioner, you will be writing much more unit test code than production
    code (the regular application code). Unlike other test categories, unit tests
    will dictate some architectural decisions of your application and enforce DI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为TDD实践者，你将编写的单元测试代码比生产代码（常规应用程序代码）要多得多。与其他测试类别不同，单元测试将指导你的应用程序的一些架构决策并强制执行依赖注入。
- en: We won’t dwell on long definitions. Instead, we will demonstrate unit testing
    with a plethora of examples. In this section, we will discuss the xUnit unit testing
    framework and the unit test structure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地停留在长定义上。相反，我们将通过大量的示例来展示单元测试。在本节中，我们将讨论xUnit单元测试框架和单元测试结构。
- en: What is unit testing?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是单元测试？
- en: '*Unit testing is testing a behavior while swapping real dependencies with test
    doubles*. Let me back up this definition with an example from `WeatherForecastController`
    in the WFA:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试是在交换真实依赖项与测试替身的同时测试一个行为**。让我用一个来自WFA的`WeatherForecastController`的例子来支持这个定义。'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method converts Celsius to Fahrenheit and logs every call. Logging is not
    the concern here because this method’s concern is the conversion.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将摄氏度转换为华氏度并记录每次调用。在这里，日志不是关注点，因为这个方法关注的是转换。
- en: The *behavior* of this method is *converting input degrees from Celsius to Fahrenheit*,
    and the logging *dependency* here is accessed through the `_logger` object. At
    runtime, we are injecting a `Logger<>` that will be writing to a physical medium,
    but we possibly want to eliminate the writing side effect when testing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的*行为*是将输入的摄氏度转换为华氏度，这里的日志*依赖项*是通过`_logger`对象访问的。在运行时，我们正在注入一个`Logger<>`，它将写入物理介质，但在测试时我们可能希望消除写入的副作用。
- en: Based on the earlier definition, we need to *swap the real dependency* that
    `_logger` uses at runtime with its test double counterpart and test the conversion
    behavior. We will show how to do this later on in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的定义，我们需要在运行时将`_logger`使用的真实依赖项与其测试替身交换，并测试转换行为。我们将在本章后面展示如何做这件事。
- en: 'Take another example from the same class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从同一个类中再举一个例子：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The behavior of this method is getting the real weather forecast and passing
    it to the caller. The `_client` object here represents the OpenWeather dependency.
    This method’s behavior is *not* about interacting with the details of the RESTful
    protocol of the OpenWeather API or the HTTP protocol. This is handled by `_client`.
    We need to swap the real dependency, `Client`, that `_client` uses at runtime,
    and replace it with one that is suitable for testing (we call this a **test double**).
    I will show how this is done, in many ways, in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097),
    *Real Unit Testing with Test Doubles*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的行为是获取实际的天气预报并将其传递给调用者。这里的 `_client` 对象代表 OpenWeather 依赖项。这个方法的行为 *不是* 与
    OpenWeather API 的 RESTful 协议或 HTTP 协议的细节进行交互。这由 `_client` 处理。我们需要在运行时交换 `_client`
    使用的真实依赖项 `Client`，并用一个适合测试的依赖项替换它（我们称之为 **测试替身**）。我将在 [*第 4 章*](B18370_04.xhtml#_idTextAnchor097)，*使用测试替身的真实单元测试*
    中展示如何做到这一点。
- en: At this stage, the concept is still cryptic, I know; just bear with me, and
    we will start expanding gently. In the next section, we will discuss unit testing
    frameworks. We will need this to unit test the preceding examples and the WFA.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，这个概念可能仍然很晦涩，我知道；请耐心等待，我们将开始逐步展开。在下一节中，我们将讨论单元测试框架。我们需要这些来对前面的示例和 WFA 进行单元测试。
- en: Unit testing frameworks
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试框架
- en: '.NET 6 has three major unit testing frameworks. The most popular one is **xUnit**,
    which we will use across this book. The other two are **NUnit** and **MSTest**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 有三个主要的单元测试框架。最受欢迎的是 **xUnit**，我们将在这本书中使用它。其他两个是 **NUnit** 和 **MSTest**：
- en: '*NUnit* is an open source library. It started as a port from Java’s JUnit framework
    and was then completely rewritten. You will still encounter it in legacy projects,
    but the majority of today’s projects start with xUnit.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NUnit* 是一个开源库。它最初是从 Java 的 JUnit 框架移植过来的，后来被完全重写。你仍然会在遗留项目中遇到它，但今天的大多数项目都是从
    xUnit 开始的。'
- en: '*MSTest* is Microsoft’s unit testing framework that gained popularity because
    it used to be shipped with Visual Studio and no extra effort was needed to install
    it, especially since NuGet did not exist back then. It became open source in version
    2, and it was always lagging behind NUnit and then xUnit in terms of features.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MSTest* 是微软的单元测试框架，因其曾随 Visual Studio 一起提供而受到欢迎，当时无需额外努力即可安装它，尤其是在 NuGet 还不存在的时候。它从版本
    2 开始开源，并且在功能上一直落后于 NUnit 和 xUnit。'
- en: '*xUnit* is an open source project that was started by developers from NUnit.
    It is feature-rich and in constant development.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*xUnit* 是一个由 NUnit 开发者发起的开源项目。它功能丰富，并且处于持续开发中。'
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term **XUnit** is an umbrella term for different languages’ unit test frameworks,
    such as **JUnit** (**Java**), **NUnit** (**.NET**), **xUnit** (**.NET**), and
    **CUnit** (**C language**). This should not be confused with the library name
    *xUnit*, which is a .NET unit test library, where the founders picked an already-taken
    and confusing name.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**XUnit** 这个术语是一个涵盖不同语言单元测试框架的总称，例如 **JUnit**（**Java**）、**NUnit**（**.NET**）、**xUnit**（**.NET**）和
    **CUnit**（**C 语言**）。这个术语不应与库名称 *xUnit* 混淆，*xUnit* 是一个 .NET 单元测试库，其创始人选择了一个已被占用且容易混淆的名字。'
- en: Learning one framework and then switching to another should take no time, as
    they are similar, and you just need to figure out the terminology used by the
    specific framework. Next, we will add an xUnit project to the solution to unit
    test the WFA.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一个框架然后切换到另一个框架应该不会花费太多时间，因为它们很相似，你只需要了解特定框架使用的术语。接下来，我们将向解决方案中添加一个 xUnit 项目来对
    WFA 进行单元测试。
- en: Understanding test projects
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试项目
- en: xUnit templates come as part of VS. We will show how to add an xUnit project
    using the **.NET CLI** approach. At this stage, if you have not opened the companion
    source code that is ported from [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037),
    *Understanding Dependency Injection by Example*, to this chapter, I encourage
    you to do so.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit 模板是 VS 的一部分。我们将展示如何使用 **.NET CLI** 方法添加 xUnit 项目。在这个阶段，如果你还没有打开从 [*第 2
    章*](B18370_02.xhtml#_idTextAnchor037)，*通过示例理解依赖注入* 转移到这一章的配套源代码，我鼓励你这样做。
- en: Adding xUnit via the CLI
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 CLI 添加 xUnit
- en: 'Currently, we have a solution with one ASP.NET Core project. Now, we want to
    add the unit tests library to our solution. To do so, create a new xUnit project
    called `Uqs.Weather.Tests.Unit` in a directory with the same name, and use .NET
    6.0:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个包含一个 ASP.NET Core 项目的解决方案。现在，我们想要将单元测试库添加到我们的解决方案中。为此，在同名目录下创建一个新的 xUnit
    项目，命名为 `Uqs.Weather.Tests.Unit`，并使用 .NET 6.0：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the newly created project to the solution file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将新创建的项目添加到解决方案文件中：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we have two projects in our solution. As the unit test project will be
    testing the ASP.NET Core project, the unit test project should have a reference
    to the ASP.NET Core project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的解决方案中有两个项目。由于单元测试项目将测试ASP.NET Core项目，单元测试项目应引用ASP.NET Core项目。
- en: 'Add a project reference from `Uqs.Weather.Tests.Unit` on `Uqs.Weather`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Uqs.Weather.Tests.Unit`在`Uqs.Weather`上添加项目引用：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now have our solution fully constructed via the CLI. You can see the full
    interaction here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已通过CLI完全构建了解决方案。你可以在这里看到完整的交互：
- en: '![Figure 3.1 – Creating a new xUnit project in a solution via the CLI ](img/Figure_3.1_B18370.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 通过CLI在解决方案中创建新的xUnit项目](img/Figure_3.1_B18370.jpg)'
- en: Figure 3.1 – Creating a new xUnit project in a solution via the CLI
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 通过CLI在解决方案中创建新的xUnit项目
- en: We now have a project to contain our unit tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个项目来存放我们的单元测试。
- en: Test project naming convention
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试项目命名约定
- en: You have noticed that we have appended `.Tests.Unit` to the original project
    name, so the unit test project became `Uqs.Weather.Tests.Unit`. This is a common
    convention in naming test projects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经注意到我们将`.Tests.Unit`附加到原始项目名称上，因此单元测试项目变为`Uqs.Weather.Tests.Unit`。这是命名测试项目的常见约定。
- en: 'This convention extends to other testing projects, such as integration testing
    and Sintegration testing, to be discussed in the *More testing categories* section
    in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097). You might also have the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此约定也适用于其他测试项目，例如集成测试和S集成测试，将在[*第4章*](B18370_04.xhtml#_idTextAnchor097)“更多测试类别”部分中讨论。你可能还会有以下情况：
- en: '`Uqs.Weather.Tests.Integration`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uqs.Weather.Tests.Integration`'
- en: '`Uqs.Weather.Tests.Sintegration`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uqs.Weather.Tests.Sintegration`'
- en: 'The wisdom behind this convention is that you can look at your list of projects
    and rapidly find the test projects related to one production code project ordered
    next to each other, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此约定的智慧在于，你可以查看你的项目列表，并快速找到与一个生产代码项目相关的测试项目，它们按顺序排列，如下所示：
- en: '![Figure 3.2 – Ordered unit test projects ](img/Figure_3.2_B18370.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 有序单元测试项目](img/Figure_3.2_B18370.jpg)'
- en: Figure 3.2 – Ordered unit test projects
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 有序单元测试项目
- en: 'The convention also helps in targeting all your test projects in the continuous
    integration, which will be covered in [*Chapter 11*](B18370_11.xhtml#_idTextAnchor265),
    *Implementing Continuous Integration with GitHub Actions*, in case you wanted
    to run all categories of tests. Here is an example: `Uqs.Weather.Tests.*`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此约定还有助于在持续集成中针对所有测试项目，这将在[*第11章*](B18370_11.xhtml#_idTextAnchor265)“使用GitHub
    Actions实现持续集成”中介绍，如果你想要运行所有测试类别。以下是一个示例：`Uqs.Weather.Tests.*`。
- en: Running the sample unit test
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例单元测试
- en: 'The xUnit template comes with a sample unit test class called `UnitTest1.cs`
    that has a sample unit test method with the following content:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit模板附带一个名为`UnitTest1.cs`的示例单元测试类，其中包含以下内容的示例单元测试方法：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This has a single unit test called `Test1` that is empty and does nothing at
    the moment. To check that the xUnit framework and the integration with VS does
    work, you can try executing this single test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个名为`Test1`的单个单元测试，目前它是空的，不做任何事情。为了检查xUnit框架和与VS的集成是否正常工作，你可以尝试执行此单个测试。
- en: From the VS menu, select **Test** | **Run All Tests** or similarly use the *Ctrl*
    + *R*, *A* keyboard shortcut. This will execute all your tests in the project
    (which is currently one test), and you will have the following tool, known as
    **Test Explorer**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从VS菜单中选择**测试**|**运行所有测试**或使用类似的方法，通过*Ctrl* + *R*, *A*键盘快捷键执行。这将执行项目中的所有测试（目前只有一个测试），你将拥有以下工具，称为**测试资源管理器**。
- en: '![Figure 3.3 – Test Explorer ](img/Figure_3.3_B18370.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 测试资源管理器](img/Figure_3.3_B18370.jpg)'
- en: Figure 3.3 – Test Explorer
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 测试资源管理器
- en: The hierarchy displayed here is **Project Name** | **Test Class Namespace**
    | **Test Class Name** | **Test Method Name**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的层次结构是**项目名称**|**测试类命名空间**|**测试类名称**|**测试方法名称**。
- en: 'If you are the CLI kind of person, you can go to the solution directory with
    the command prompt and execute the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢CLI，你可以使用命令提示符进入解决方案目录并执行以下操作：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is what you may get:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能就是你得到的结果：
- en: '![Figure 3.4 – CLI dotnet test results ](img/Figure_3.4_B18370.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – CLI dotnet测试结果](img/Figure_3.4_B18370.jpg)'
- en: Figure 3.4 – CLI dotnet test results
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – CLI dotnet测试结果
- en: I have seen **Test Explorer** used more in day-to-day TDD-style development
    than the CLI. The CLI is useful for running the whole solution or for continuous
    integration and automated runs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到**测试资源管理器**在日常TDD风格开发中比CLI（命令行界面）使用得更多。CLI对于运行整个解决方案或进行持续集成和自动化运行很有用。
- en: Test Explorer
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试资源管理器
- en: Test Explorer comes with VS. Additionally, xUnit adds a few libraries that allow
    Test Explorer and VS to interact with xUnit tests. There are third-party providers
    that have more advanced test runners. One of them is *JetBrains ReSharper Unit
    Test Explorer*. We have everything ready to start writing unit test code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 测试资源管理器是VS的一部分。此外，xUnit添加了一些库，允许测试资源管理器和VS与xUnit测试交互。还有一些第三方提供程序具有更高级的测试运行器。其中之一是*JetBrains
    ReSharper Unit Test Explorer*。我们已经准备好开始编写单元测试代码。
- en: Unit test class anatomy
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试类结构
- en: When we unit test, we tend to write a **unit test class** that is targeting
    a parallel production class – one test class against one production class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行单元测试时，我们倾向于编写一个针对并行生成类的**单元测试类**——一个测试类对应一个生成类。
- en: Applying this concept to our WFA project, our production class is `WeatherForecastController`
    and the unit test class is going to be called `WeatherForecastControllerTests`.
    So, rename the `UnitTest1` sample class to `WeatherForecastControllerTests`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将此概念应用于我们的WFA项目，我们的生成类是`WeatherForecastController`，单元测试类将被命名为`WeatherForecastControllerTests`。因此，将`UnitTest1`示例类重命名为`WeatherForecastControllerTests`。
- en: Tip
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can set your text cursor anywhere within the class name in the source code
    (in the previous case, it was `UnitTest1`) and hit *Ctrl* + *R*, *R* (hold *Ctrl*
    then press *R* quickly twice). Type the new name `WeatherForecastControllerTests`
    and hit *Enter*. This will also rename the file if the **Rename symbol’s file**
    checkbox is ticked.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源代码中类的名称内的任何位置设置你的文本光标（在前一个例子中，它是`UnitTest1`）并按*Ctrl* + *R*，*R*（按住*Ctrl*然后快速连续按两次*R*）。输入新名称`WeatherForecastControllerTests`并按*Enter*。如果勾选了**重命名符号的文件**复选框，这也会重命名文件。
- en: Next, we will see how to organize our unit test class and its methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何组织我们的单元测试类及其方法。
- en: Class naming convention
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类命名约定
- en: I found the most commonly used convention is calling the unit test class name
    the same as the production code class name, appending the `Tests` suffix. For
    example, the `MyProductionCode` test class counterpart would be `MyProductionCodeTests`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现最常用的约定是将单元测试类的名称与生成代码类的名称相同，并附加`Tests`后缀。例如，`MyProductionCode`测试类的对应项将是`MyProductionCodeTests`。
- en: When practicing TDD, you will need to switch between the test class and its
    counterpart production code class multiple times in a short period. Naming them
    using this pattern allows you to find the test and its related counterpart easily,
    or vice versa. It also clarifies the relationship between the two classes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践TDD（测试驱动开发）时，你需要在短时间内多次在测试类及其对应的生成代码类之间切换。使用这种模式命名可以使你轻松找到测试及其相关对应项，反之亦然。这也有助于阐明两个类之间的关系。
- en: Test methods
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试方法
- en: Each test class contains methods that test pieces of functionality, known as
    units, from the production code class. Let’s take the example of testing the `ConvertCToF`
    method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试类包含测试生产代码类中功能片段的方法，这些片段被称为单元。以测试`ConvertCToF`方法为例。
- en: Test example 1
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试示例 1
- en: 'Part of the requirements that we have is testing the conversion with a single
    decimal point accuracy. So, let’s consider one testing case by taking a zero degree
    (0.0 C) and testing if the method is returning 32.0 F. To do that, we can delete
    the `Test1` method in the unit tests class and replace it with the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的部分要求是测试具有单个小数点精度的转换。因此，让我们考虑一个测试案例，取一个零度（0.0 C）并测试方法是否返回32.0 F。为此，我们可以在单元测试类中删除`Test1`方法，并用以下内容替换它：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code initializes the production code class, calls the method under test,
    and then assesses the results of the test with our expectations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码初始化生成代码类，调用测试中的方法，然后评估测试结果与我们的预期。
- en: '`Fact` is an attribute that makes a method a unit test. `Assert` is a static
    class that has useful methods for comparing expected results to actual results.
    Both `Fact` and `Assert` are part of the xUnit framework.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fact`是一个属性，它使方法成为单元测试。`Assert`是一个静态类，它包含用于比较预期结果与实际结果的有用方法。`Fact`和`Assert`都是xUnit框架的一部分。'
- en: 'Run this test with Test Explorer using *Ctrl* + *R*, *A*, and the test will
    yield the following screen:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *R*，*A*通过测试资源管理器运行此测试，测试将显示以下屏幕：
- en: '![Figure 3.5 – Fail output in Test Explorer ](img/Figure_3.5_B18370.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 测试资源管理器中的失败输出](img/Figure_3.5_B18370.jpg)'
- en: Figure 3.5 – Fail output in Test Explorer
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 测试资源管理器中的失败输出
- en: 'If we look inside the controller, we find that VS has a red sign to map the
    route that led to this failure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看控制器内部，我们会发现VS有一个红色标志来映射导致此失败的路径：
- en: '![Figure 3.6 – VS showing the failed test route ](img/Figure_3.6_B18370.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – VS显示失败的测试路径](img/Figure_3.6_B18370.jpg)'
- en: Figure 3.6 – VS showing the failed test route
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – VS显示失败的测试路径
- en: 'It is apparent from the error message what is causing `ArgumentNullException`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从错误信息中可以明显看出导致`ArgumentNullException`的原因：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is expected, as we have passed the `logger` parameter from the unit test
    as `null`. We want `_logger.LogInformation` to do nothing, and in order to do
    that, we will be using `NullLogger<>`, which does nothing, as indicated by the
    official documentation. Our unit test code needs to change to the following so
    that we can replace the real logger with a dummy one:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，因为我们已经将`logger`参数从单元测试中作为`null`传递。我们希望`_logger.LogInformation`不执行任何操作，为此，我们将使用官方文档中指示的`NullLogger<>`，它不执行任何操作。我们的单元测试代码需要更改为以下内容，以便我们可以用模拟器替换真实日志记录器：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you run the test again, all the reds will turn green, and the test will pass.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行测试，所有红色都将变为绿色，测试将通过。
- en: Test example 2
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试示例2
- en: 'To test another input and output for the method, we can add more unit tests
    to the class and follow the same test method name pattern. We can have the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试方法的其他输入和输出，我们可以在类中添加更多单元测试，并遵循相同的测试方法名称模式。我们可以有以下几种：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But, there is a succinct solution for avoiding writing a similar unit test
    for every value combination, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有一个简洁的解决方案可以避免为每个值组合编写类似的单元测试，如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we are using `Theory` rather than `Fact`. Every `InlineData` will
    act as a single unit test. You can even eliminate *example 1* and make it an `InlineData`
    attribute. No need to say that `Theory` and `InlineData` are attributes from xUnit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的是`Theory`而不是`Fact`。每个`InlineData`都将作为一个单独的单元测试。您甚至可以消除*示例1*并将其作为`InlineData`属性。无需说明`Theory`和`InlineData`是来自xUnit的属性。
- en: You can go ahead and run the tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续运行测试。
- en: Other examples are covered in [*Chapter 1*](B18370_01.xhtml#_idTextAnchor014),
    *Writing Your First TDD Implementation*, similar to the previous ones in this
    chapter, so you could have a look for more clarity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其他示例在[*第1章*](B18370_01.xhtml#_idTextAnchor014)《编写您的第一个TDD实现》中有所介绍，与本章中前面的示例类似，因此您可以查看以获得更多清晰度。
- en: '*Examples 1* and *2* target a simple method, `ConvertCToF`, that has a single
    dependency, `_logger`. We will cover more sophisticated testing scenarios after
    learning about test doubles in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097),
    *Real Unit Testing with Test Doubles*. In reality, your production code will be
    more complicated than a simple conversion method and will contain multiple dependencies,
    but there is a first step for everything.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例1*和*示例2*针对一个简单的方法`ConvertCToF`，它有一个单一的依赖项`_logger`。在学习了[*第4章*](B18370_04.xhtml#_idTextAnchor097)《使用测试替身进行真实单元测试》中的测试替身后，我们将涵盖更复杂的测试场景。实际上，您的生产代码将比简单的转换方法更复杂，并将包含多个依赖项，但万事开头难。'
- en: Naming convention
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名约定
- en: 'Unit test method names follow a popular convention: `MethodUnderTest_Condition_Expectation`.
    We have seen this convention used earlier. Here are more hypothetical examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试方法名称遵循一个流行的约定：`待测试方法_条件_预期`。我们之前已经看到了这个约定的使用。以下是一些假设的示例：
- en: '`SaveData_CannotConnectToDB_InvalidOperationException`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SaveData_CannotConnectToDB_InvalidOperationException`'
- en: '`OrderShoppingBasket_EmptyBasket_NoAction`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderShoppingBasket_EmptyBasket_NoAction`'
- en: This book contains plenty of other examples that should clarify this convention
    further.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本书还包含许多其他示例，这些示例应进一步阐明此约定。
- en: The Arrange-Act-Assert pattern
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安排-行动-断言模式
- en: 'The previous test method, and generally all unit test methods, follows a similar
    pattern:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试方法和一般所有的单元测试方法都遵循类似的模式：
- en: Create a state, declare some variables, and do some preparations.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个状态，声明一些变量，并进行一些准备工作。
- en: Call the method under test.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用待测试的方法。
- en: Assert the actual results against expectations.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实际结果与预期进行断言。
- en: 'Practitioners decided to give these three stages the following names:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实践者决定给这三个阶段以下名称：
- en: '**Arrange**, **Act**, and **Assert** (**AAA**).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**安排**、**行动**和**断言**（**AAA**）。'
- en: 'They mark the code with a comment to show the stages and emphasize the separation.
    According to this, we can write one of the previous test methods as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 他们通过注释标记代码以显示阶段并强调分隔。根据这一点，我们可以将之前的测试方法写成如下：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the comments that were added to the code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码中添加的注释。
- en: Important Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some teams dislike having the separation by writing comments. Instead, they
    choose a different way to mark AAA, for example, by leaving a single line space
    between each section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有些团队不喜欢通过注释来分隔，相反，他们选择不同的方式来标记 AAA，例如，在每一部分之间留一个空行。
- en: The AAA practice is more than a convention. It makes the method easier to read
    on-the-fly. It also emphasizes that there should be only one *Act* in a unit test
    method. Consequently, a unit test, based on best practices, is not supposed to
    have more than a single AAA structure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: AAA 实践不仅仅是一种约定。它使得方法在即时阅读时更容易理解。它还强调单元测试方法中应该只有一个 *操作*。因此，根据最佳实践，单元测试不应该有超过一个
    AAA 结构。
- en: Using VS code snippets
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 VS 代码片段
- en: Every unit test is going to have the same structure. VS allows you to cut down
    on writing the same structure with the help of `CodeSnippets` directory in this
    chapter source code. It is called `aaa.snippet`. You can open it and view/edit
    its content via a regular text editor (not a word processor).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元测试都将具有相同的结构。VS 允许你通过本章源代码中的 `CodeSnippets` 目录来减少编写相同结构的代码。它被称为 `aaa.snippet`。你可以通过常规文本编辑器（而不是文字处理器）打开它并查看/编辑其内容。
- en: 'To use this snippet on Windows, copy `aaa.snippet` to this directory (choosing
    the right VS version):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上使用此片段，请将 `aaa.snippet` 复制到该目录（选择正确的 VS 版本）：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once this is copied, in your unit test class, type `aaa`, then hit the *Tab*
    button, and you will get the following generated code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦复制完成，在你的单元测试类中输入 `aaa`，然后按 *Tab* 键，你将得到以下生成的代码：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rather than speaking more about having a single AAA in your unit test, we will
    demonstrate this across this book to illuminate the style that seniors use in
    writing unit tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在单元测试中过多地谈论只有一个 AAA，我们将在这本书中通过示例来展示资深开发者编写单元测试时所使用的风格。
- en: 'Now that we had an overview of the class anatomy and the unit test method structure,
    we will explore the unit test class’s counterpart: the system under test.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对类的结构和单元测试方法的结构有了概述，我们将探讨单元测试类的对应物：系统测试对象。
- en: System under test
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统测试对象
- en: 'A unit test is meant to test a single functionality of a production code. Each
    unit test class has a production code counterpart that is being tested. We refer
    to the production code being tested as the **system under test** (**SUT**). You
    can see here an illustration of what the SUT is:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试旨在测试生产代码的一个单一功能。每个单元测试类都有一个正在被测试的生产代码对应物。我们将被测试的生产代码称为 **系统测试对象**（**SUT**）。你可以在这里看到
    SUT 的一个示意图：
- en: '![Figure 3.7 – Unit tests operating against the SUT ](img/Figure_3.7_B18370.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 单元测试对 SUT 的操作](img/Figure_3.7_B18370.jpg)'
- en: Figure 3.7 – Unit tests operating against the SUT
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 对 SUT 执行的单元测试
- en: The term SUT is the most dominant one, but you might find others refer to it
    as **class under test** (**CUT**), **code under test** (**CUT** – yes, it is the
    same acronym), or **method under test** (**MUT**).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SUT 这个术语是最常用的，但你可能会发现其他人将其称为 **测试类**（**CUT**）、**测试代码**（**CUT** – 是的，它是同一个缩写），或者
    **测试方法**（**MUT**）。
- en: 'The term *SUT* is used in developers’ conversations, and it is also commonly
    used in the code to make it clear what is being tested, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*SUT* 这个术语在开发者的对话中使用，也常在代码中使用，以明确指出正在测试的内容，如下所示：'
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is important to understand the SUT of your unit test class. You will gradually
    notice as your project grows that you will have a pattern being formed, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 理解你的单元测试类的 SUT 非常重要。随着你的项目逐渐增长，你将逐渐注意到形成了一种模式，如下所示：
- en: '![Figure 3.8 – Unit test project versus production code project ](img/Figure_3.8_B18370.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 单元测试项目与生产代码项目对比](img/Figure_3.8_B18370.jpg)'
- en: Figure 3.8 – Unit test project versus production code project
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 单元测试项目与生产代码项目对比
- en: Every unit test class is paired with an SUT counterpart.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元测试类都与一个 SUT 对应物配对。
- en: Now that we have seen a few features of xUnit both here and in [*Chapter 1*](B18370_01.xhtml#_idTextAnchor014),
    *Writing Your First TDD Implementation*, it is time to have a closer look at xUnit.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在这里和 [*第 1 章*](B18370_01.xhtml#_idTextAnchor014) 中看到了 xUnit 的几个特性，现在是时候更深入地了解
    xUnit 了。
- en: The basics of xUnit
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: xUnit 的基础知识
- en: xUnit provides the hosting environment for your tests. One important feature
    of xUnit is that it is AAA-convention friendly. It also integrates with the VS
    IDE and its Test Explorer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit为你的测试提供托管环境。xUnit的一个重要特性是它对AAA约定友好。它还与VS IDE及其测试资源管理器集成。
- en: Extensive examples using xUnit appear naturally in this book. However, it is
    worth dedicating a few sections to discussing the principal features of this framework.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本书自然地出现了大量使用xUnit的示例。然而，值得专门用几个部分来讨论这个框架的主要特性。
- en: Fact and theory attributes
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fact 和理论属性
- en: In your test project, any method that is decorated with `Fact` or `Theory` will
    become a test method. `Fact` is meant for a non-parametrized unit test, and `Theory`
    is for a parametrized one. With `Theory`, you can add other attributes, such as
    `InlineData`, for parametrization.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试项目中，任何被`Fact`或`Theory`装饰的方法都将成为测试方法。`Fact`用于非参数化单元测试，而`Theory`用于参数化测试。使用`Theory`，你可以添加其他属性，例如`InlineData`，用于参数化。
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: VS will give you a visual indication above the method name that you can run
    the methods decorated with these attributes, but sometimes it doesn’t until you
    run all the tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: VS会在方法名上方给出一个视觉指示，表明你可以运行带有这些属性的装饰方法，但有时直到你运行所有测试才会出现。
- en: Running the tests
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'Each unit test will *run independently* and instantiate the class. The unit
    tests *do not share* each other’s states. So, a unit test class runs differently
    than a normal class. Let me elaborate with a sample code, shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元测试将**独立运行**并实例化该类。单元测试**不共享**彼此的状态。因此，单元测试类与普通类的运行方式不同。让我用一个示例代码来详细说明，如下所示：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous unit tests do pass. Notice that while I am incrementing `_instanceField`
    in both test methods, the value of `_instanceField` is not shared between the
    two methods, and every time xUnit is instantiating a method, all my class is instantiated
    again. This is why the value is reset back to `0` before every method execution.
    This characteristic of xUnit promotes a unit test principle known as **no interdependency**,
    which will be discussed in [*Chapter 6*](B18370_06.xhtml#_idTextAnchor140), *The
    FIRSTHAND Guidelines of TDD*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的单元测试是可以通过的。注意，虽然我在两个测试方法中都增加了`_instanceField`的值，但`_instanceField`的值在这两个方法之间并不共享，每次xUnit实例化一个方法时，我的整个类都会再次实例化。这就是为什么每次方法执行之前都会将值重置为`0`的原因。xUnit的这个特性促进了单元测试原则中的一种称为**无依赖性**的原则，这将在[*第6章*](B18370_06.xhtml#_idTextAnchor140)，*TDD的FIRSTHAND指南*中讨论。
- en: On the other hand, the static field was shared between the two methods and its
    value has changed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，静态字段在两个方法之间共享，其值已更改。
- en: Important Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While I have used both instance and static fields to illustrate the distinctive
    behavior of a unit test class, I want to emphasize that using a static `read-write`
    field in a unit test is an anti-pattern because this breaks the *no interdependency*
    principle. In general, you should have no common `write` fields in unit test classes,
    and fields are better to be marked with the `readonly` keyword.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我已经使用实例和静态字段来展示单元测试类的独特行为，但我想要强调，在单元测试中使用静态的`read-write`字段是一种反模式，因为这打破了**无依赖性**原则。一般来说，你应该在单元测试类中没有公共的`write`字段，字段最好用`readonly`关键字标记。
- en: Instead, if the same methods are part of a regular code class (not a unit test
    class) and both are called, we expect to find the value of `_instanceField` incremented
    to `2`, but this was not the case here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果相同的方法是常规代码类（不是单元测试类）的一部分，并且都被调用，我们期望找到`_instanceField`的值增加到`2`，但这里并非如此。
- en: Assert class
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Assert 类
- en: '`Assert` is a static class, and it is part of xUnit. This is how the official
    documentation defines the `Assert` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`是一个静态类，它是xUnit的一部分。这是官方文档对`Assert`类的定义：'
- en: Contains various static methods that are used to verify0 that conditions are
    met.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 包含各种静态方法，用于验证条件是否满足。
- en: 'Let’s have a quick overview of some of the methods of `Assert`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速概述一下`Assert`的一些方法：
- en: '`Equal(expected, actual)`: These are a series of overloads that will compare
    the expectations to actuals. You have seen a few examples of `Equal` in [*Chapter
    1*](B18370_01.xhtml#_idTextAnchor014), *Writing Your First TDD Implementation*,
    and in this chapter.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Equal(expected, actual)`: 这是一系列重载，将比较期望值与实际值。你已经在[*第1章*](B18370_01.xhtml#_idTextAnchor014)，*编写你的第一个TDD实现*和本章中看到了一些`Equal`的例子。'
- en: '`True(actual)`: Rather than using `Equal` to compare two objects, you can use
    this one where relevant to promote readability. Let’s clarify this with an example:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`True(actual)`: 与使用`Equal`比较两个对象相比，在相关的地方可以使用这个方法来提高可读性。让我们用一个例子来澄清这一点：'
- en: '[PRE17]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`False(actual)`: The opposite of the previous method.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`False(actual)`: 之前方法的相反。'
- en: '`Contains(expected, collection)`: A group of overloads that check for the existence
    of a single element in a collection.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains(expected, collection)`: 一组重载，用于检查集合中是否存在单个元素。'
- en: '`DoesNotContain(expected, collection)`: The opposite of the previous method.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoesNotContain(expected, collection)`: 之前方法的相反。'
- en: '`Empty(collection)`: This verifies that a collection is empty.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Empty(collection)`: 这验证了一个集合是否为空。'
- en: '`Assert.IsType<Type>(actual)`: This verifies whether an object is of a certain
    type.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.IsType<Type>(actual)`: 这验证了一个对象是否为特定类型。'
- en: 'As there are more methods, I encourage you to visit the official xUnit site
    to have a look, or to do what most developers do: write `Assert` in a unit test
    class, and type a *dot* after it to trigger IntelliSense and view the displayed
    methods.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有更多方法，我鼓励你访问官方xUnit网站查看，或者像大多数开发者一样：在一个单元测试类中编写`Assert`，并在其后输入一个*点*来触发IntelliSense并查看显示的方法。
- en: The methods of `Assert` will communicate with the test runner, such as Test
    Explorer, to report back the result of the assertions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`方法将与测试运行器（如测试资源管理器）通信，以报告断言的结果。'
- en: Record class
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录类
- en: 'The `Record` class is a static class that records exceptions so that you can
    test whether your method is throwing or not throwing the right exception. This
    is an example of one of its static methods, which is called `Exception()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record`类是一个静态类，用于记录异常，以便你可以测试你的方法是否抛出了正确的异常。这是其静态方法之一，称为`Exception()`的示例：'
- en: '`public static System.Exception Exception(Action testCode)`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static System.Exception Exception(Action testCode)`'
- en: 'The previous code returns the exception that is thrown by `Action`. Let’s take
    this example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码返回`Action`抛出的异常。让我们以这个例子为例：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are checking whether the `Load` method will throw `FormatException`
    if it is presented with an invalid JSON input.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查当`Load`方法遇到无效的JSON输入时，是否会抛出`FormatException`。
- en: This was a summary of xUnit’s functionality, and this should get you started
    writing basic unit tests.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对xUnit功能的一个总结，这应该能帮助你开始编写基本的单元测试。
- en: Applying SOLID principles to unit testing
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SOLID原则应用于单元测试
- en: 'The SOLID principles are highly covered and advertised on the web and in books.
    Chances are that this is not the first time that you’ve heard or read about them.
    They are a popular interview question as well. SOLID principles stand for the
    following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则在网络上和书籍中被广泛覆盖和宣传。很可能这不是你第一次听说或读到它们。它们也是流行的面试问题。SOLID原则代表以下内容：
- en: '*S*ingle-responsibility principle'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单一职责原则*：'
- en: '*O*pen-closed principle'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开放封闭原则*：'
- en: '*L*iskov Substitution principle'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*里氏替换原则*：'
- en: '*I*nterface Segregation principle'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接口隔离原则*：'
- en: '*D*ependency Inversion'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖倒置*：'
- en: In this section, we are interested mostly in the relationship between the SOLID
    principles and unit testing. While not all the principles have strong ties with
    unit testing, we will cover all of them for completion.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们主要关注SOLID原则与单元测试之间的关系。虽然并非所有原则都与单元测试有很强的联系，但我们将涵盖所有原则以完成。
- en: Single-responsibility principle
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'The **single-responsibility principle** (**SRP**) is about having each class
    with one responsibility only. This will lead it to have one reason to change.
    The benefits of this approach are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）是关于每个类只具有一个职责。这将导致它只有一个变更的理由。这种方法的优点如下：'
- en: '**Easier to read and understand classes**:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易阅读和理解的类**：'
- en: The classes will have fewer methods, which should cause less code. Its interface
    will have fewer methods as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类将拥有更少的方法，这应该会导致更少的代码。其接口也将拥有更少的方法。
- en: '**Less rippling effect when changing a feature**:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改功能时的涟漪效应更小**：'
- en: There are fewer classes to change, which would lead to an easier change.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有更少的类需要更改，这将导致更改更容易。
- en: '**Less probability of change, which means fewer potential bugs**:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的变更概率，这意味着更少的潜在错误**：'
- en: More code means more potential bugs, and changing code would also lead to potential
    bugs. Having less code in the first place means fewer code changes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 代码越多，潜在的错误就越多，更改代码也会导致潜在的错误。一开始就有更少的代码意味着更少的代码更改。
- en: Example
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: The SRP is not an exact science, and the challenge is being able to decide what
    *responsibility* is. Every developer has their own view. The next example illustrates
    the idea.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: SRP（单一职责原则）不是一门精确的科学，挑战在于能够决定什么是 *职责*。每个开发者都有自己的看法。下一个例子将说明这个想法。
- en: 'Let’s assume you have created your own file format called *ABCML* to solve
    a particular problem, as the existing file formats (such as JSON, XML, and others)
    do not satisfy your specific need. A set of classes with each having a single
    responsibility could be as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你创建了自己的文件格式称为 *ABCML* 来解决特定问题，因为现有的文件格式（如 JSON、XML 等）不能满足你的特定需求。一组具有单一职责的类可能如下所示：
- en: A class to validate whether the content of the file is in the right structure
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于验证文件内容是否具有正确结构的类
- en: A class to export ABCML to a generic format
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于将 ABCML 导出为通用格式的类
- en: A class that inherits the generic ABCML export to support exporting to JSON,
    and another class that supports exporting to XML
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个继承通用 ABCML 导出以支持导出到 JSON 的类，以及一个支持导出到 XML 的类
- en: A class that represents a node in your ABCML
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示 ABCML 中的节点的类
- en: More classes
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多类
- en: You can see how I split responsibilities into individual classes, although there
    is no single design for having a single responsibility.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我是如何将职责分割成单个类的，尽管没有单一的设计来确保单一职责。
- en: SRP and unit testing
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SRP 和单元测试
- en: Naturally, when doing unit testing, you think of a single responsibility for
    a class, and you call your unit test class the same name with the `tests` suffix.
    So, if you are thinking of testing the validation of the ABCML file format, you
    might have `ABCMLValidationTests`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，在进行单元测试时，你会考虑一个类的单一职责，并且你将你的单元测试类命名为与 `tests` 后缀相同的名称。所以，如果你正在考虑测试 ABCML
    文件格式的验证，你可能有 `ABCMLValidationTests`。
- en: In your unit test class, each unit test targets a single behavior in your SUT.
    Those behaviors combined lead to a single responsibility.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的单元测试类中，每个单元测试都针对你的 SUT（系统单元）中的单一行为。这些行为结合起来导致一个单一职责。
- en: '![Figure 3.9 – Multiple single behavior tests targeting a single responsibility
    ](img/Figure_3.9_B18370.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 针对一个单一职责的多个单一行为测试](img/Figure_3.9_B18370.jpg)'
- en: Figure 3.9 – Multiple single behavior tests targeting a single responsibility
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 针对一个单一职责的多个单一行为测试
- en: 'The previous figure shows multiple tests, each test is focused on a single
    behavior, and they are targeting one responsibility: *validation*. On the right,
    there is one method, but this is only for illustration, as you might have multiple
    public methods and you can still have a single responsibility.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上一图显示了多个测试，每个测试都专注于单一行为，并且它们针对一个职责：*验证*。在右侧，有一个方法，但这只是为了说明，因为你可能有多个公共方法，你仍然可以有一个单一职责。
- en: In [*Chapter 6*](B18370_06.xhtml#_idTextAnchor140), *The FIRSTHAND Guidelines
    of TDD*, we will introduce a guideline known as the *single-behavior guideline*.
    This guideline works with TDD and unit tests to encourage the SRP.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B18370_06.xhtml#_idTextAnchor140) 的 *TDD 的 FIRSTHAND 指南* 中，我们将介绍一个称为
    *单一行为指南* 的指南。这个指南与 TDD 和单元测试一起工作，以鼓励 SRP。
- en: Open-closed principle
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: The **open-closed principle** (**OCP**) is about preparing your class to be
    inheritable (having it open) so that any feature addition could just inherit this
    class without modifying it (having it closed).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放封闭原则**（**OCP**）是关于准备你的类以便它可以被继承（使其开放），这样任何新功能的添加都可以直接继承这个类而不需要修改它（使其封闭）。'
- en: The essence of this principle is to minimize unnecessary changes every time
    a new feature is added.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则的本质是在每次添加新功能时最小化不必要的更改。
- en: Example
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'Let’s take an example that will make this clearer. Assume we have created a
    library to do arithmetic calculations. Let’s start by *not being OCP-compliant*,
    as shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点更清楚。假设我们创建了一个用于进行算术计算的库。让我们首先 *不遵守 OCP*，如下所示：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Calculate` method in the preceding code will have to change every time
    we add a new `ArithmeticOperation`. If we want to add the multiplication operation,
    per the commented line, as a feature at a later stage, then the `Calculate` method
    will need to change to accommodate the new feature.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的 `Calculate` 方法每次添加新的 `ArithmeticOperation` 时都需要更改。如果我们想在稍后阶段添加乘法操作作为功能，根据注释行，`Calculate`
    方法需要更改以适应新功能。
- en: 'We can make this implementation more OCP-compliant by eliminating the need
    to change the `Calculate` method every time a new operation is added. Let’s see
    how this can be done:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过消除每次添加新操作时更改`Calculate`方法的需求来使实现更符合OCP。让我们看看如何做到这一点：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous example leveraged polymorphism to stop the `Calculation` method
    from being changed every time a new operation is added. You can see from the commented
    line how a new multiplication operation can be added. This is a more OCP-compliant
    approach.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例利用多态来阻止每次添加新操作时更改`Calculation`方法。你可以从注释行中看到如何添加新的乘法操作。这是一个更符合OCP的方法。
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While I had all the classes and interfaces listed together here and on the GitHub
    code, I did this for illustration, as they are usually separated into their own
    files. So, with the OCP, you also reduce the chance of changing the file and make
    it easier on the source control level to understand what changed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我把所有类和接口在这里和GitHub代码中一起列出时，我这样做是为了说明，因为它们通常被分到自己的文件中。所以，使用OCP，你也可以减少更改文件的机会，并在源代码控制级别更容易理解更改的内容。
- en: OCP and unit testing
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OCP和单元测试
- en: Unit testing protects changes in any class by making sure that a change does
    not inadvertently break an existing feature. The OCP and unit testing work hand
    in hand. So, while the OCP reduces the chance of avoidable changes, the unit testing
    adds an additional protection layer when a change is made by verifying business
    rules.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通过确保更改不会意外地破坏现有功能来保护任何类的更改。OCP和单元测试是相辅相成的。因此，虽然OCP减少了可避免更改的机会，但单元测试在更改时通过验证业务规则增加了额外的保护层。
- en: Liskov substitution principle
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: The **Liskov substitution principle** (**LSP**) states that an instance of a
    child class must replace an instance of the parent class without affecting the
    results that we would get from an instance of the base class itself. A child class
    should be a true representation of its parent class.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**Liskov替换原则**（**LSP**）指出，子类的一个实例必须替换父类的一个实例，而不会影响我们从基类实例本身得到的结果。子类应该是其父类的真实表示。'
- en: Example
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'We shall use an academic type of example that will make the concept easier
    to understand. Let’s take the following example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种学术类型的例子来使概念更容易理解。让我们看看以下例子：
- en: '[PRE21]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the previous code, and according to LSP, `Ostrich` should not have inherited
    `Bird`. Let’s rectify the code to comply with the LSP:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，根据LSP，`Ostrich`不应该继承`Bird`。让我们修正代码以符合LSP：
- en: '[PRE22]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have changed the inheritance hierarchy by introducing a new intermediary
    class called `FlyingBird` for compliance with the LSP.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过引入一个名为`FlyingBird`的新中间类来改变继承层次结构，以符合LSP。
- en: LSP and unit testing
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LSP和单元测试
- en: Unit testing has no direct impact on the LSP, but the LSP is mentioned here
    for completion.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对LSP没有直接影响，但在这里提及LSP是为了完整性。
- en: Interface segregation principle
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The **interface segregation principle** (**ISP**) states that child classes
    should not be forced to depend upon interfaces that they do not use. Interfaces
    should be smaller so that whoever is implementing them can mix and match.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）指出，子类不应该被迫依赖于它们不使用的接口。接口应该更小，以便实现它们的任何人都可以混合和匹配。'
- en: Example
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'I always find the way collections implement in .NET is the best example to
    explain this principle. Let’s look at how `List<T>` is declared:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是认为.NET中集合的实现是解释这个原则的最佳例子。让我们看看`List<T>`是如何声明的：
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is implementing six interfaces. Each interface contains a limited number
    of methods. `List<T>` provides a huge number of methods, but the way it does that
    is by selecting multiple interfaces, with each interface adding a few of the methods.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了六个接口。每个接口包含有限数量的方法。`List<T>`提供了大量的方法，但它这样做是通过选择多个接口，每个接口添加几个方法。
- en: One method that `List<T>` exposes is `GetEnumerator()`. This method comes from
    the `IEnumerable<T>` interface; actually, it is the only method on `IEnumerable<T>`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`公开的一个方法是`GetEnumerator()`。此方法来自`IEnumerable<T>`接口；实际上，它是`IEnumerable<T>`上的唯一方法。'
- en: By having small interfaces (interfaces of few and related methods), as in this
    example, `List<T>` was able to choose what it needs to implement, no more and
    no less.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有小的接口（如本例中的接口，包含少量相关方法），`List<T>`能够选择它需要实现的内容，不多也不少。
- en: ISP and unit testing
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ISP和单元测试
- en: Unit testing has no direct impact on the ISP, but the ISP is mentioned here
    for completion.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对ISP没有直接影响，但在这里提及ISP是为了完整性。
- en: Dependency inversion principle
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The **dependency inversion principle** (**DIP**) states that high-level modules
    should not depend on low-level modules. Both should depend on abstractions. Abstractions
    should not depend on details. Details should depend on abstractions. In other
    words, the DIP is a principle that promotes loose coupling between classes by
    using abstractions and DI.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）指出，高级模块不应该依赖于低级模块。两者都应依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。换句话说，DIP是一个通过使用抽象和DI来促进类之间松耦合的原则。'
- en: Example
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: '[*Chapter 2*](B18370_02.xhtml#_idTextAnchor037), *Understanding Dependency
    Injection by Example*, is focused on this topic, and it is rich with examples
    of changing the code to enable DI.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第二章*](B18370_02.xhtml#_idTextAnchor037)，*通过示例理解依赖注入*，专注于这个主题，并富含将代码修改为启用DI的示例。'
- en: DIP and unit testing
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DIP和单元测试
- en: There is a tight relationship between the DIP and unit testing. Real unit tests
    cannot function without DI. In fact, the effort spent on making everything injectable
    and having the proper interface designs for classes without interfaces promotes
    the DIP as a byproduct.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: DIP和单元测试之间存在紧密的关系。没有DI，真正的单元测试无法运行。事实上，花费在使一切可注入并为没有接口的类提供适当接口设计上的努力，作为副产品促进了DIP。
- en: You can see that the SRP and the DIP are promoted by unit testing. So, while
    you are increasing your production quality, your design quality is improving as
    a result. There is no argument that unit testing requires effort, but part of
    this effort is already paid into your design quality and code readability.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，SRP和DIP都是由单元测试所促进的。因此，当您提高生产质量的同时，设计质量也在提高。单元测试需要付出努力，这是毫无疑问的，但其中一部分努力已经投入到您的代码设计质量和可读性中。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we touched on basic unit testing-related topics, and we went
    through several examples.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了基本的单元测试相关主题，并探讨了几个示例。
- en: If I was to categorize unit testing experience from 1 to 5, with level 1 being
    a beginner and 5 being an expert, this chapter should get you to level 2\. Fear
    not! After going through the rest of the book, where more realistic examples will
    come, you will be at level 4, so I am glad you have made it so far. Keep going!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要将单元测试经验从1到5进行分类，其中1级是初学者，5级是专家，那么本章应该能帮助您达到2级。别担心！在阅读完本书的其余部分，其中将包含更多现实世界的示例后，您将达到4级，所以我很高兴您已经走这么远了。继续前进！
- en: '*Is this book going to take me to level 5?* I hear you asking. Well, unit testing
    is not a sprint, it is a marathon; it takes years of practice to get to that level,
    and only getting your hands dirty in unit testing will get you there.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*这本书会带我达到5级水平吗？* 我听到您在问。嗯，单元测试不是短跑，而是一场马拉松；要达到那个水平需要多年的实践，只有真正动手做单元测试才能达到那个水平。'
- en: We also covered the relationship between SOLID principles and unit testing to
    show you the big picture and how everything fits nicely together.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了SOLID原则与单元测试之间的关系，以展示整体图景以及所有内容是如何完美结合在一起的。
- en: In this chapter, I have deliberately avoided examples that require a deep understanding
    of test doubles, so as to introduce you to unit testing in a gentle way. However,
    in reality, most unit tests will require test doubles. Let’s move forward to a
    more realistic spectrum and dive into this concept in the next chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我故意避免了需要深入了解测试替身的示例，以便以温和的方式向您介绍单元测试。然而，在现实中，大多数单元测试都将需要测试替身。让我们向前迈进到一个更现实的范围，并在下一章深入探讨这个概念。
- en: Further reading
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，您可以参考以下链接：
- en: '*Walkthrough: Create a code snippet*: [https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet](https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码片段创建流程：* [https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet](https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet)'
- en: '*xUnit*: [https://xunit.net](https://xunit.net)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*xUnit*: [https://xunit.net](https://xunit.net)'
