- en: '*Chapter 7*: LINQ Performance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*: LINQ 性能'
- en: LINQ has a reputation for being slow. But contrary to people's views, there
    are ways to use LINQ that ensure optimal performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 以其速度慢而闻名。但与人们的观点相反，有方法可以确保使用 LINQ 的最佳性能。
- en: In this chapter, you will learn how to perform LINQ queries with performance
    in mind. Depending on how you use LINQ, different methods that return the same
    result can behave and perform differently. And so, in this chapter, you will learn
    how best to perform queries on LINQ to improve the performance of your applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何以性能为导向执行 LINQ 查询。根据你如何使用 LINQ，返回相同结果的不同方法可能会有不同的行为和性能。因此，在本章中，你将学习如何最好地执行
    LINQ 查询以提高你应用程序的性能。
- en: Here, you will benchmark different ways to determine the most performative ways
    to obtain the last element of a LINQ query. You will learn about the performance
    penalty of using the `let` keyword in LINQ statements, and why you should avoid
    using it. Benchmarking different `Group By` methods, you will gain insight into
    the most performant way to perform GroupBy queries using LINQ. When performing
    queries and data manipulation using LINQ, there may be times when you need to
    use closures. By writing parametrized and non-parameterized closures, you will
    see that parameterized closures perform much better than non-parameterized closures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将对确定 LINQ 查询中最后一个元素的最有效方法进行基准测试。你将了解在 LINQ 语句中使用 `let` 关键字的性能惩罚，以及为什么你应该避免使用它。通过基准测试不同的
    `Group By` 方法，你将深入了解使用 LINQ 执行 GroupBy 查询的最有效方式。在执行查询和数据操作时，你可能会需要使用闭包。通过编写参数化和非参数化闭包，你会发现参数化闭包的性能远优于非参数化闭包。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up our sample database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的示例数据库
- en: Setting up our in-memory sample data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的内存中示例数据
- en: Querying a database using LINQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LINQ 查询数据库
- en: Getting the last value of a collection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取集合的最后一个值
- en: Avoid using the let keyword in LINQ queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在 LINQ 查询中使用 let 关键字
- en: Increasing Group By performance in LINQ queries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高 LINQ 查询中 Group By 的性能
- en: Filtering lists
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤列表
- en: Understanding closures
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解闭包
- en: By the end of this chapter, you will have the skills to securely store secrets
    and query databases and in-memory data using efficient LINQ. You will also be
    able to understand the performance impact of using the `let` keyword in your queries
    and performing efficient filtering and grouping of data using LINQ.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备使用高效的 LINQ 安全存储秘密、查询数据库和内存中数据所需的技能。你还将能够理解在查询中使用 `let` 关键字对性能的影响，以及如何使用
    LINQ 进行有效的过滤和分组数据。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to follow along with this chapter, you will need access to the following
    tools:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上本章的内容，你需要访问以下工具：
- en: Visual Studio 2022
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022
- en: SQL Server 2019
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 2019
- en: SQL Server Management Studio
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server Management Studio
- en: 'The book''s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07
    )'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍的源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07)
- en: Setting up a sample database
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置示例数据库
- en: In this chapter, we will be demonstrating the difference between how different
    collection interfaces handle data, and for the demonstrations, you require access
    to database data. To do so, you will create a database, add a table, and populate
    it with data. You will use SQL Server for your database engine, and use SQL Server
    Management Studio to develop your sample database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示不同的集合接口如何处理数据，为了演示，你需要访问数据库数据。为此，你将创建一个数据库，添加一个表，并用数据填充它。你将使用 SQL
    Server 作为你的数据库引擎，并使用 SQL Server Management Studio 来开发你的示例数据库。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the `CH07_LinqPerformance.Data` source code folder, you will find a database
    creation script called `SampleData.Product.sql` that creates the database and
    populates it with data. You can run this script in SQL Server Management Studio.
    This will save you from having to run through setting up the database in this
    section. But if you are new to SQL Server, you may want to run through this section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CH07_LinqPerformance.Data` 源代码文件夹中，你可以找到一个名为 `SampleData.Product.sql` 的数据库创建脚本，该脚本创建数据库并用数据填充。你可以在
    SQL Server Management Studio 中运行此脚本。这将让你免于在本节中设置数据库。但如果你是 SQL Server 新手，你可能想运行这一节。
- en: 'To add your database, follow these steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加你的数据库，请按照以下步骤操作：
- en: Open SQL Server Management Studio and connect to your database engine.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 SQL Server Management Studio 并连接到你的数据库引擎。
- en: 'Right-click on the **Databases** folder in **Object Explorer** as shown in
    *Figure 7.1*:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象资源管理器**中右键单击**数据库**文件夹，如图 7.1 所示：
- en: '![Figure 7.1: The SQL Server Management Studio Object Explorer tab'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1：SQL Server Management Studio 对象资源管理器选项卡'
- en: '](img/B16617_07_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_07_01.jpg)'
- en: 'Figure 7.1: The SQL Server Management Studio Object Explorer tab'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：SQL Server Management Studio 对象资源管理器选项卡
- en: 'Select **New Database** from the context menu. This will display the **New
    Database** dialog as shown in *Figure 7.2*:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择**新建数据库**。这将显示如图 7.2 所示的**新建数据库**对话框：
- en: '![Figure 7.2: The SQL Server Management Studio New Database dialog'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2：SQL Server Management Studio 新数据库对话框'
- en: '](img/B16617_07_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_07_02.jpg)'
- en: 'Figure 7.2: The SQL Server Management Studio New Database dialog'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：SQL Server Management Studio 新数据库对话框
- en: Once you have entered `SampleData` for the database name, click on the **OK**
    button to create the database.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你为数据库名称输入了`SampleData`，点击**确定**按钮来创建数据库。
- en: 'Locate the database by expanding the `Products` as shown in the following figure:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下图示展开 `Products` 来定位数据库：
- en: '![Table 7.1: The Products table design'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 7.1：产品表设计'
- en: '](img/Table_7.1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_7.1.jpg)'
- en: 'Table 7.1: The Products table design'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1：产品表设计
- en: Save the table and then expand the **Tables** folder. Right-click on the **Products**
    table and select **Edit Top n records** where *n* will be the number of configured
    records to edit, which is *200* by default.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存表，然后展开**表**文件夹。右键单击**产品**表，选择**编辑前 n 条记录**，其中 *n* 将是配置的记录数，默认为 *200*。
- en: 'Add the data shown in the following figure to the **Product** table:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下图中的数据添加到**产品**表中：
- en: '![Table 7.2: The Product table row data'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 7.2：产品表行数据'
- en: '](img/Table_7.2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_7.2.jpg)'
- en: 'Table 7.2: The Product table row data'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2：产品表行数据
- en: We now have a database with a single table filled with data that we will use
    later in the chapter. In the next section, we will be adding our in-memory sample
    data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个数据库，其中只有一个表，表里填充了我们将要在本章后面使用的数据。在下一节中，我们将添加我们的内存样本数据。
- en: Setting up our in-memory sample data
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的内存样本数据
- en: You will be studying LINQ performance, therefore, you are going to need a collection
    to work with. You will work with a collection of `Person` objects. Each person
    will be named from the Greek alphabet. A `Person` object will consist of a `FirstName`,
    `LastName`, and `FullName` property. The `FullName` property will be an interpolated
    string that combines the first and last name of the person.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将研究 LINQ 性能，因此你需要一个集合来工作。你将使用一个`Person`对象的集合。每个人将被命名为希腊字母。一个`Person`对象将包含一个`FirstName`、`LastName`和`FullName`属性。`FullName`属性将是一个插值字符串，它结合了人的名字和姓氏。
- en: 'Let us now begin coding our LINQ coding combined with **benchmarking**, so
    that we can measure the performance of our LINQ statements:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始编写我们的 LINQ 代码，并结合**基准测试**，以便我们可以测量我们的 LINQ 语句的性能：
- en: Create a new .NET 6.0 console application called `CH07_LinqPerformance`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CH07_LinqPerformance` 的新 .NET 6.0 控制台应用程序。
- en: Install the NuGet package `BenchmarkDotNet`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 NuGet 包 `BenchmarkDotNet`。
- en: 'Add the following `Person` struct:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `Person` 结构体：
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This structure defines the `Person` with their `FirstName`, `LastName`, and
    computed `FullName`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构定义了具有 `FirstName`、`LastName` 和计算出的 `FullName` 的 `Person`。
- en: 'Now, add a new class called `LinqPerformance` with the following `using` statements:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为 `LinqPerformance` 的新类，并包含以下 `using` 语句：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These `using` statements provide you with access to benchmarking, generic collections,
    and LINQ classes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `using` 语句为你提供了访问基准测试、泛型集合和 LINQ 类的权限。
- en: 'Add the following code to the top of the class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类的顶部：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You have declared a list of people and two arrays. Both these arrays contain
    the surnames of people in lowercase that belong to those groups.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你已声明了一个人员列表和两个数组。这两个数组都包含属于那些组的人员的姓氏，且均为小写。
- en: 'Now, add the global setup class that will prepare your collection for benchmarking
    various LINQ queries:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个全局设置类，该类将为基准测试各种 LINQ 查询准备你的集合：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You now have your sample database and in-memory sample data in place for the
    topics we will be covering in this chapter. So, let us start by investigating
    various ways of querying a database and their effects on LINQ query performance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经为我们将在本章中讨论的主题设置了示例数据库和内存中的示例数据。因此，让我们首先调查查询数据库的各种方法及其对 LINQ 查询性能的影响。
- en: Database query performance
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库查询性能
- en: 'We saw in [*Chapter 6*](B16617_06_Final_SB_Epub.xhtml#_idTextAnchor117), *The
    .NET Collection*, how `IEnumerator` is different from `IEnumerable`, and how `IEnumerator`
    performs faster than `IEnumerable` when iterating through an in-memory collection.
    Now, we will query a database and iterate through the resulting collection using
    various benchmarked techniques. To do so, we will follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B16617_06_Final_SB_Epub.xhtml#_idTextAnchor117)，“.NET 集合”中，我们看到了
    `IEnumerator` 与 `IEnumerable` 的区别，以及当遍历内存中的集合时，`IEnumerator` 的性能如何优于 `IEnumerable`。现在，我们将查询数据库，并使用各种基准技术遍历结果集合。为此，我们将遵循以下步骤：
- en: Add a new class called `IEnumeratorVsIQueryable`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `IEnumeratorVsIQueryable` 的新类。
- en: You will be connecting to a SQL Server database and will have the information
    you need to keep secret. Your `secret.json` files do not get checked into version
    control. So, right-click on the project and select **Manage User Secrets** from
    the context menu.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将连接到 SQL Server 数据库，并将需要保持秘密的信息。你的 `secret.json` 文件不会提交到版本控制。因此，右键单击项目，并从上下文菜单中选择
    **管理用户秘密**。
- en: A dialog will pop up informing you that additional packages are required. Click
    on **Yes**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出一个对话框，提示需要安装额外的包。单击 **是**。
- en: '![Figure 7.3: Dialog Informing you that additional packages are required to
    manage user secrets'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3：提示需要安装额外包以管理用户秘密的对话框'
- en: '](img/B16617_07_03.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_07_03.jpg)'
- en: 'Figure 7.3: Dialog Informing you that additional packages are required to manage
    user secrets'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：提示需要安装额外包以管理用户秘密的对话框
- en: Visual Studio will then open the `secrets.json` file in a new tab. This is where
    you will add your user secrets.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将在新的标签页中打开 `secrets.json` 文件。这是你添加用户秘密的地方。
- en: 'Open **Package Manager Console** and add the following packages:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **包管理控制台** 并添加以下包：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These packages enable you to connect to and extract data from the SQL Server
    database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包使你能够连接到并从 SQL Server 数据库中提取数据。
- en: 'Update your `secrets.json` file with the connection string to the database
    you created at the start of the chapter:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新你的 `secrets.json` 文件，其中包含你在本章开头创建的数据库的连接字符串：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This connection string will be used to connect to your database, perform a query
    that returns some data, and enable you to iterate through that data and perform
    operations on it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此连接字符串将用于连接到你的数据库，执行返回一些数据的查询，并允许你遍历这些数据并对其执行操作。
- en: 'Add a folder called `Configuration`, and in that folder, add a class called
    `SecretsManager` with an empty static constructor and the following `using` statements:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Configuration` 的文件夹，并在该文件夹中添加一个名为 `SecretsManager` 的类，该类具有空的静态构造函数和以下
    `using` 语句：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You need these `using` statements for your file I/O and system configuration
    such as obtaining secrets from a `secrets.json` file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要这些 `using` 语句来处理文件 I/O 和系统配置，例如从 `secrets.json` 文件中获取秘密。
- en: 'Add the following line at the top of the `SecretsManager` class:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SecretsManager` 类的顶部添加以下行：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This line declares your static configuration property that is used to obtain
    your configuration data within your application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此行声明了你的静态配置属性，该属性用于在应用程序中获取配置数据。
- en: 'Now add the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加以下代码：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code gets the environment variables for the .NET Core environment. It then
    gets the code to see if it is running in a software development environment or
    production environment. The configuration is then built for the environment it
    will be running in. So, if we are in debug mode, the configuration will be built
    for the development environment. And if we are in release mode, the configuration
    will be built for the production environment. If we are in development, then we
    add our `secrets` class as defined by the `T` variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码获取 .NET Core 环境的环境变量。然后获取代码以查看它是否在软件开发环境中运行或在生产环境中运行。然后为将要运行的环境构建配置。因此，如果我们处于调试模式，配置将为开发环境构建。如果我们处于发布模式，配置将为生产环境构建。如果我们处于开发模式，则添加由
    `T` 变量定义的 `secrets` 类。
- en: 'Create a new folder, `Models`, and add the `Product` class using the following
    code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，命名为 `Models`，并使用以下代码添加 `Product` 类：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our `Product` class provides the model for our product data with `Id`, `Name`,
    and `Description` properties that are set via the constructor. We also override
    the `ToString` method to return a textual representation of the property values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Product` 类通过 `Id`、`Name` 和 `Description` 属性提供产品数据模型，这些属性通过构造函数设置。我们还重写了
    `ToString` 方法以返回属性值的文本表示。
- en: Add a `using` statement for `System.ComponentModel.DataAnnotations`. Change
    the struct to a class, and add the `[Key]` attribute to the `Id` property. We
    need these changes since we are using Entity Framework to connect to a database
    and extract data.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `System.ComponentModel.DataAnnotations` 添加一个 `using` 语句。将结构体更改为类，并将 `[Key]`
    属性添加到 `Id` 属性。我们需要这些更改，因为我们正在使用 Entity Framework 连接到数据库并提取数据。
- en: 'In the `CH07_LinqPerformance.Data` folder, add the `DatabaseContext` class:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CH07_LinqPerformance.Data` 文件夹中添加 `DatabaseContext` 类：
- en: '[PRE10]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have declared our `DatabaseContext` class, which inherits from the `DbContext`
    class. Now we'll need to add its internals.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了我们的 `DatabaseContext` 类，它继承自 `DbContext` 类。现在我们需要添加其内部实现。
- en: 'Add the following items to the `DatabaseContext` class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下项添加到 `DatabaseContext` 类中：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code, we have declared our `DbSet` of products property, which will
    hold a collect of our `Product` class, and a connection string member variable
    that will hold the string that connects us to our database. Our constructor is
    then declared, which takes in a connection string, which we pass into the `GetOptions`
    method that then gets passed into the base class constructor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们声明了我们的产品 `DbSet` 属性，它将包含我们的 `Product` 类的集合，以及一个连接字符串成员变量，它将包含连接到我们的数据库的字符串。然后声明构造函数，它接受一个连接字符串，我们将其传递给
    `GetOptions` 方法，然后传递给基类构造函数。
- en: 'Add the `GetOptions` method to the `DatabaseContext` class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `GetOptions` 方法添加到 `DatabaseContext` 类中：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method returns the `DbContextOptions` for our SQL Server database connection.
    The connection string used is the one that is stored in our `secrets.json` file
    in development and in `appsettings.json` when in production.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回用于我们的 SQL Server 数据库连接的 `DbContextOptions`。所使用的连接字符串是在开发时存储在我们的 `secrets.json`
    文件中，在生产时存储在 `appsettings.json` 中。
- en: 'Add the `OnModelCreating` method:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `OnModelCreating` 方法：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are configuring our `Product` class that will be used in our `DbSet`.
    We are declaring that the `Id` field is our primary key and that the `Name` field
    has a maximum length of 50 while the `Description` field has a maximum length
    of 255.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在配置将在我们的 `DbSet` 中使用的 `Product` 类。我们声明 `Id` 字段是主键，而 `Name` 字段的最大长度为 50，`Description`
    字段的最大长度为 255。
- en: 'Add the `DatabaseSettings` class to the `Configuration` folder:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DatabaseSettings` 类添加到 `Configuration` 文件夹中：
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class has a single property called `ConnectionString` that will hold your
    connection string to our `SampleData` database. Notice that the name of the class
    and property match the name of the JSON section and property!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此类有一个名为 `ConnectionString` 的单个属性，它将保存到我们的 `SampleData` 数据库的连接字符串。请注意，类的名称和属性的名称与
    JSON 部分和属性的名称相匹配！
- en: 'Now, add `appsettings.json` to the root of your project with the following
    contents:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `appsettings.json` 添加到项目的根目录，并包含以下内容：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This file has the same layout as the `secrets.json` file and the `DatabaseSettings`
    class. This file is used to store your connection string. In development, it is
    set in the secrets file, and in production, it is set in Azure. Now that you have
    your database configuration in place, you can add your benchmarking code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件与 `secrets.json` 文件和 `DatabaseSettings` 类具有相同的布局。此文件用于存储您的连接字符串。在开发中，它设置在秘密文件中，在生产中设置在
    Azure 中。现在您已经设置了数据库配置，可以添加基准测试代码。
- en: 'Add a new class in the root of the project called `DatabaseQueryAndIteration`
    that implements `IDisposable` with the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中添加一个名为 `DatabaseQueryAndIteration` 的新类，该类实现 `IDisposable` 并具有以下代码：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code declares our class and defines the fact that it implements `IDisposable`.
    It is also configured to be benchmarked.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码声明了我们的类并定义了它实现了 `IDisposable` 接口。它也被配置为可进行基准测试。
- en: 'Implement the `IDisposable` interface in our class:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类中实现 `IDisposable` 接口：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code disposes of our managed resources and suppresses the call to the class
    finalizer method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码释放了我们的托管资源并抑制了对类终结器的调用。
- en: 'We have everything in place to benchmark the methods in this class, access
    database resources, and clean up after ourselves. Add the following code to the
    class:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经为在这个类中的方法进行基准测试、访问数据库资源以及清理工作做好了准备。将以下代码添加到类中：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `_context` variable provides us with our database access. The `GlobalSetup()`
    method gets our connection string from our secrets file, and creates a new `DatabaseContext`
    using the safely stored connection string. The `GlobalSetup()` method will run
    before our benchmarks. The `GlobalCleanup()` method calls the `Dispose(disposing)`
    method to clean up our managed resources after our benchmarks have finished running.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`_context` 变量为我们提供了数据库访问权限。`GlobalSetup()` 方法从我们的密钥文件中获取连接字符串，并使用安全存储的连接字符串创建一个新的
    `DatabaseContext`。`GlobalSetup()` 方法将在我们的基准测试之前运行。`GlobalCleanup()` 方法在基准测试完成后调用
    `Dispose(disposing)` 方法来清理我们的托管资源。'
- en: 'Next, add the `QueryDb()` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `QueryDb()` 方法：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `QueryDb()` method performs a simple LINQ query on the database by selecting
    products with an ID of greater than `1`. It then iterates each product in the
    `IQueryable<Product>` list and writes the product name out to the debug window.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryDb()` 方法通过选择具有大于 `1` 的 ID 的产品来在数据库上执行一个简单的 LINQ 查询。然后它遍历 `IQueryable<Product>`
    列表中的每个产品，并将产品名称写入调试窗口。'
- en: 'Now, add the `QueryDbAsList()` method:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `QueryDbAsList()` 方法：
- en: '[PRE20]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`QueryDbAsList()` performs the same query as `QueryDb()`, except the processed
    type is of type `List<Product>`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryDbAsList()` 执行与 `QueryDb()` 相同的查询，但处理的是 `List<Product>` 类型。'
- en: 'Add the `QueryDbAsIEnumerable()` method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `QueryDbAsIEnumerable()` 方法：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `QueryDbAsIEnumerable()` method performs the same query as `QueryDbAsList`,
    but processes a type of `IEnumerable<Product>` instead.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryDbAsIEnumerable()` 方法执行与 `QueryDbAsList` 相同的查询，但处理的是 `IEnumerable<Product>`
    类型。'
- en: 'Add the `QueryDbAsIEnumerator()` method:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `QueryDbAsIEnumerator()` 方法：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`QueryDbAsIEnumerator()` does the same as the previous methods but operates
    on a type of `IEnumerator<Product>` and iterates using a `while` loop instead
    of a `foreach` loop.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryDbAsIEnumerator()` 与前述方法执行相同，但操作的是 `IEnumerator<Product>` 类型，并使用 `while`
    循环而不是 `foreach` 循环进行迭代。'
- en: 'The final method in this class that we need to add is the `QueryDbAsIQueryable()`
    method:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加的这个类中的最后一个方法是 `QueryDbAsIQueryable()` 方法：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method is the same as `QueryDb` but explicitly operates on a type of `IQueryable<Product>`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与 `QueryDb` 相同，但明确地操作 `IQueryable<Product>` 类型。
- en: 'Replace the code in the `Main` method within the `Program` class with the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program` 类中的 `Main` 方法中的代码替换为以下内容：
- en: '[PRE24]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code runs your benchmarks. Do a release build of the code and run the
    executable from the command line. You should see a summary report similar to the
    following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码运行您的基准测试。进行代码的发布构建，并从命令行运行可执行文件。您应该看到类似于以下摘要报告：
- en: '![Figure 7.4: The different times and memory allocation of various database
    query types using LINQ'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4：使用 LINQ 的各种数据库查询类型的不同时间和内存分配]'
- en: '](img/B16617_07_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_07_04.jpg)'
- en: 'Figure 7.4: The different times and memory allocation of various database query
    types using LINQ'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：使用 LINQ 的各种数据库查询类型的不同时间和内存分配
- en: 'Let us summarize what we learn from the summary report after running our query
    benchmarks:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下，在运行查询基准测试后我们从摘要报告中学习到的东西：
- en: In terms of memory usage, the worst performer is the `QueryDb()` method followed
    by the `QueryDbAsList()` method. `QueryDbAsIEnumerable()` and `QueryDbAsIQueryable()`
    are both slightly better than the previous two. But the best performing method
    in terms of memory allocation out of all five methods is the `QueryDbAsIEnumerator()`
    method.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存使用方面，性能最差的是 `QueryDb()` 方法，其次是 `QueryDbAsList()` 方法。`QueryDbAsIEnumerable()`
    和 `QueryDbAsIQueryable()` 都比前两种方法略好。但所有五种方法中，内存分配性能最好的方法是 `QueryDbAsIEnumerator()`
    方法。
- en: Speed wise, the `QueryDb()` method was the worst again. Followed by `QueryDbAsIEnumerable()`,
    then `QueryDbAsList()`, and then `QueryDbAsIQueryable()`. And again, the best
    performer in terms of speed is the `QueryDbAsIEnumerator()` method.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在速度方面，`QueryDb()` 方法再次表现最差。其次是 `QueryDbAsIEnumerable()`，然后是 `QueryDbAsList()`，然后是
    `QueryDbAsIQueryable()`。再次，速度方面的最佳表现者是 `QueryDbAsIEnumerator()` 方法。
- en: So, we can see that the best performing method for querying and iterating a
    database in both speed and memory usage terms is the `QueryDbAsIEnumerator()`
    method out of all the methods we've chosen to investigate.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，在速度和内存使用方面，查询和迭代数据库的最佳方法是我们在选择调查的所有方法中性能最好的 `QueryDbAsIEnumerator()`
    方法。
- en: In the next section, we will be investigating which is the fastest method for
    obtaining the last item in a collection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究获取集合中最后一个项的最快方法。
- en: Getting the last value of a collection
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取集合的最后一个值
- en: 'You are now going to see how the LINQ method that obtains the last element
    in the collection is really slow when compared to directly accessing the item
    by its index. This will be accomplished using benchmarking to measure the performance
    of different methods:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您将看到，与直接通过索引访问项目相比，LINQ方法获取集合中的最后一个元素实际上非常慢。这将通过基准测试来测量不同方法的性能来完成：
- en: 'Update the `Main` method as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Main`方法如下：
- en: '[PRE25]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Open the `LinqPerformance` class.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LinqPerformance`类。
- en: 'Add the `GetLastPersonVersion1()` method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GetLastPersonVersion1()`方法：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method gets the last person in the collection using the LINQ-provided `Last()`
    method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用LINQ提供的`Last()`方法获取集合中的最后一个人员。
- en: 'Add the `GetLastPersonVersion2()` method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GetLastPersonVersion2()`方法：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we are using the index of the list to extract the last person in the
    list. At this point, it is worth noting that the difference between the two methods
    is that in the first method, this `Last()` method call is actually declared in
    `System.Linq.Enumerable`. The method signature is as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用列表的索引来提取列表中的最后一个人员。此时，值得注意的是，两种方法之间的区别在于，在第一种方法中，这个`Last()`方法调用实际上是在`System.Linq.Enumerable`中声明的。方法签名如下：
- en: '[PRE28]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So, the `Last()` call in the `GetLastPersonVersion1()` method performs various
    checks before the last value is returned. But the `GetLastPersonVersion2()` method
    does not perform these checks, and immediately returns the value at the last position.
    This explains why the method used in `GetLastPersonVersion1()` is much slower
    than accessing an element by its index in `GetLastPersonVersion2()`, as you will
    see in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`GetLastPersonVersion1()`方法在返回最后一个值之前执行了各种检查。但`GetLastPersonVersion2()`方法不执行这些检查，并立即返回最后一个位置上的值。这解释了为什么在`GetLastPersonVersion1()`中使用的方法比在`GetLastPersonVersion2()`中通过索引访问元素的方法慢得多，您将在下面的屏幕截图中看到：
- en: '![Figure 7.5: Get Last Person example performance using the Last() method and
    direct index access'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：使用Last()方法和直接索引访问获取最后一个人员的示例性能](img/B16617_07_05.jpg)'
- en: '](img/B16617_07_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_07_05.jpg](img/B16617_07_05.jpg)'
- en: 'Figure 7.5: Get Last Person example performance using the Last() method and
    direct index access'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：使用Last()方法和直接索引访问获取最后一个人员的示例性能
- en: Looking at the summary report of the benchmarks we have just run, it is evident
    that using the index for direct access is better than using the `Last()` method
    call in terms of improved performance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们刚刚运行的基准测试的总结报告，很明显，使用索引进行直接访问比使用`Last()`方法调用在性能提升方面更好。
- en: We have seen how we can quickly access the last element in a collection. Let
    us now consider why we should avoid using the `let` keyword in LINQ queries.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何快速访问集合中的最后一个元素。现在让我们考虑为什么我们应该避免在LINQ查询中使用`let`关键字。
- en: Avoid using the let keyword in LINQ queries
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在LINQ查询中使用`let`关键字
- en: You can use the `let` keyword to declare a variable and assign it a value to
    use in your LINQ query if the value is to be used several times within the query.
    At first glance, this may seem like you are improving performance since you only
    perform a single assignment, and then use the same variable several times. But
    this is not actually the case. Using the `let` keyword in your LINQ queries can
    actually decrease the performance of your LINQ query.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在查询中要多次使用某个值，您可以使用`let`关键字声明一个变量并为其赋值以在您的LINQ查询中使用。乍一看，这似乎表明您正在提高性能，因为您只执行一次赋值，然后在查询中多次使用相同的变量。但实际上并非如此。在您的LINQ查询中使用`let`关键字实际上可能会降低您的LINQ查询性能。
- en: 'Let us work through some benchmark examples. In the `LinqPerformance` class,
    do the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些基准测试示例来分析。在`LinqPerformance`类中，执行以下操作：
- en: 'Add the `ReadingDataWithoutUsingLet()` method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ReadingDataWithoutUsingLet()`方法：
- en: '[PRE29]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this method, we are selecting people from the `_people` list with a last
    name of *Omega*, and a first name of *Upsilon* using LINQ without the `let` keyword.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们使用LINQ而没有使用`let`关键字从`_people`列表中选择具有姓氏*Omega*和名字*Upsilon*的人员。
- en: 'Now, add the `ReadingDataUsingLet()` method:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`ReadingDataUsingLet()`方法：
- en: '[PRE30]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this method, we are also selecting people from the `_people` list with a
    last name of *Omega* and a first name of *Upsilon*. But this time, we use the
    `let` keyword for both the filters and use them in the `where` clause.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们也在选择具有姓氏*Omega*和名字*Upsilon*的人员从`_people`列表中。但这次，我们使用`let`关键字对两个过滤器进行操作，并在`where`子句中使用它们。
- en: 'Build the project and run the executable from the command line. You should
    see results similar to those shown in *Figure 7.6*:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并从命令行运行可执行文件。您应该看到与*图7.6*中显示的结果类似：
- en: '![Figure 7.6: BenchmarkDotNet results for reading data with and without using
    the let keyword'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.6: BenchmarkDotNet results for reading data with and without using
    the let keyword](img/B16617_07_06.jpg)'
- en: '](img/B16617_07_06.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_07_06.jpg](img/B16617_07_06.jpg)'
- en: 'Figure 7.6: BenchmarkDotNet results for reading data with and without using
    the let keyword'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：使用和不使用`let`关键字读取数据的BenchmarkDotNet结果
- en: As you can see from these results, the use of the `let` keyword in our query
    reduced the performance. The processing time increased and so did the memory allocation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些结果中可以看到，在我们的查询中使用`let`关键字降低了性能。处理时间增加，内存分配也是如此。
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will see websites that promote the use of the `let` keyword in LINQ queries
    to improve performance and readability. But as you have seen in the example we
    have worked through, using the `let` keyword can seriously slow down the performance
    of your queries and increase memory usage. So, as a rule of thumb, take to measuring
    your performance for your particular queries and choosing the method that performs
    best for your query task.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到一些网站宣传在LINQ查询中使用`let`关键字以提高性能和可读性。但正如我们在例子中所看到的，使用`let`关键字会严重减慢查询的性能并增加内存使用。因此，作为一个经验法则，请测量您特定查询的性能，并选择最适合您查询任务的执行方法。
- en: In this section, we have seen how the use of the `let` keyword can increase
    the time taken and memory used to perform a simple `select` query using LINQ.
    This performance decrease can become a real problem when working with large volumes
    of data. In the next section, we will look at several methods for grouping data
    and see which method performs the best.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了使用`let`关键字如何增加使用LINQ执行简单`select`查询所需的时间和内存。当处理大量数据时，这种性能下降可能成为一个真正的问题。在下一节中，我们将探讨几种分组数据的方法，并查看哪种方法表现最好。
- en: Increasing Group By performance in LINQ queries
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高LINQ查询中的Group By性能
- en: In this section, we will look at three different ways of performing the same
    `Group By` operation. Each way provides a different performance level. You will
    see by the end of this section which method is best for performing fast `Group
    By` queries. The methods that we add in this section will be added to the `LinqPerformance`
    class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨执行相同的`Group By`操作的三种不同方式。每种方式都提供不同的性能级别。您将在本节结束时看到哪种方法最适合执行快速的`Group
    By`查询。在本节中添加的方法将被添加到`LinqPerformance`类中。
- en: For our scenario, we want to get a list of people from a collection that all
    share the same name. To extract those people, we will perform a `Group By` operation.
    Then, we will extract all those for whom the group count is greater than one,
    and then add them to a list of people.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的场景，我们想要从一个所有人员都拥有相同名字的集合中获取人员列表。为了提取这些人，我们将执行一个`Group By`操作。然后，我们将提取那些组计数大于一的所有人员，并将他们添加到人员列表中。
- en: 'Let us add our three methods that use the `GroupBy` clause to return a list
    of people:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加使用`GroupBy`子句返回人员列表的三个方法：
- en: 'Add the `GroupByVersion1()` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GroupByVersion1()`方法：
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we are grouping on the person's last name. We then filter the
    groups to include only those groups with a count greater than *1*. Those groups
    are then selected and then returned as a list of people.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们是根据人的姓氏进行分组的。然后我们过滤这些组，只包括那些计数大于*1*的组。然后选择这些组，并将它们作为人员列表返回。
- en: 'Now, add the `GroupByVersion2()` method:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`GroupByVersion2()`方法：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this method, we obtain an enumerator by grouping people by their last name
    and then filtering the groups to only include those groups with a count of *2*
    or more. Then we declare a new list of people. We then loop through the enumerator
    and obtain the current `IGrouping<string, Person>`. The grouping is then iterated
    through, and each person in the group is added to the list of people.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们通过按姓氏分组人群，然后过滤这些组，只包括那些计数为*2*或更多的组，来获得一个枚举器。然后我们声明一个新的人员列表。接着我们遍历枚举器，获取当前的`IGrouping<string,
    Person>`。然后遍历分组，并将组中的每个人添加到人员列表中。
- en: 'Add the `GroupByVersion3()` method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GroupByVersion3()`方法：
- en: '[PRE33]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `GroupByVersion3()` method is the same as and behaves the same as the `GroupByVersion2()`
    method, but with one main difference. We convert the list of people to an array
    before we perform the `Group By`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupByVersion3()`方法与`GroupByVersion2()`方法相同，行为也相同，但有一个主要区别。我们在执行`Group By`之前将人员列表转换为数组。'
- en: 'Add the following annotations to the top of the `LinqPerformance` class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LinqPerformance`类的顶部添加以下注释：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These annotations will expand the data contained in the summary report as you
    will see shortly. Do a release build of the project and then run the project from
    the command line to benchmark these three methods. You should see the following
    benchmark summary report:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注释将扩展总结报告中的数据，您很快就会看到。进行项目的发布构建，然后从命令行运行项目以基准测试这三种方法。您应该会看到以下基准测试总结报告：
- en: '![Figure 7.7: The BenchmarkDotNet Group By summary report'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7：BenchmarkDotNet Group By总结报告](img/B16617_07_07.jpg)'
- en: '](img/B16617_07_07.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_07_07.jpg](img/B16617_07_07.jpg)'
- en: 'Figure 7.7: The BenchmarkDotNet Group By summary report'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：BenchmarkDotNet Group By总结报告
- en: As we can see, our first attempt at performing a `Group By` operation takes
    *2.204* microseconds, our second attempt takes *2.011* microseconds, and our third
    and final attempt takes *2.204* microseconds. So, we can see that converting our
    list to an array before performing a `Group By` speeds things up. Our final version
    is *0.243* microseconds faster than our original version, and that is despite
    the fact that more code is involved!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们执行`Group By`操作的第一次尝试需要*2.204*微秒，第二次尝试需要*2.011*微秒，第三次和最后一次尝试需要*2.204*微秒。因此，我们可以看到在执行`Group
    By`之前将列表转换为数组可以加快速度。我们的最终版本比原始版本快*0.243*微秒，尽管涉及更多的代码！
- en: The section that follows will take you through the benchmarking of five different
    ways to provide filtering of lists. You will see how the different methods affect
    the performance of LINQ queries.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将带您了解五种不同的提供列表过滤方式。您将看到不同的方法如何影响LINQ查询的性能。
- en: Filtering lists
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤列表
- en: 'In this section, we will look at various ways to filter a list using LINQ.
    We will see that the various ways all perform differently. By the end of this
    section, you will know the best way to filter a list for increased performance.
    You will be writing two different benchmarks that demonstrate query performance
    differences when using the `let` keyword and not using the `let` keyword. Let''s
    begin writing our benchmarks:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用LINQ过滤列表的各种方法。我们将看到各种方法的表现都不相同。在本节结束时，您将知道如何过滤列表以获得更高的性能。您将编写两个不同的基准测试，以展示使用和不使用`let`关键字时查询性能的差异。让我们开始编写我们的基准测试：
- en: 'Add the `FilterGroupsVersion1()` method:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`FilterGroupsVersion1()`方法：
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first of our benchmarks filters people that belong to `_group1` and `_group2`.
    Since the arrays are in lowercase, `LastName` is also converted to lowercase.
    The filtered people are then returned as a list of people.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个基准测试过滤属于`_group1`和`_group2`的人。由于数组是小写的，因此`LastName`也被转换为小写。然后，过滤的人作为人的列表返回。
- en: 'Add the `FilterGroupsVersion2()` benchmark:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`FilterGroupsVersion2()`基准测试：
- en: '[PRE36]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This does the same as our first benchmark. The main difference is that we introduce
    the `lastName` variable using the `let` keyword, and assign it the lowercase `LastName`
    of the person.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的第一个基准测试做的是同样的事情。主要区别在于我们使用`let`关键字引入了`lastName`变量，并将其分配给人的小写`LastName`。
- en: 'Compile the project in release mode and run it from the command line. The benchmarks
    will be generated, and you should see a benchmark report similar to the one in
    *Figure 7.8*:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以发布模式编译项目并从命令行运行。将生成基准测试，您应该会看到一个类似于*图7.8*的基准测试报告：
- en: '![Figure 7.8: Benchmark Report for LINQ with and without using the let keyword'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8：使用和不使用let关键字的LINQ基准测试报告](img/B16617_07_08.jpg)'
- en: '](img/B16617_07_08.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_07_08.jpg](img/B16617_07_08.jpg)'
- en: 'Figure 7.8: Benchmark Report for LINQ with and without using the let keyword'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：使用和不使用let关键字的LINQ基准测试报告
- en: We can see in the summary report that using the `let` keyword slows things down
    considerably. And so, we will now investigate why the `let` keyword slows things
    down.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在总结报告中看到，使用`let`关键字会显著减慢速度。因此，我们现在将调查为什么`let`关键字会减慢速度。
- en: Open `CH07_LinqPerformance.dll`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CH07_LinqPerformance.dll`。
- en: Expand `FilterGroupsVersion1` and `FilterGroupsVersion2`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`FilterGroupsVersion1`和`FilterGroupsVersion2`。
- en: Double-click on the method `FilterGroupsVersion1` to reveal the intermediate
    language generated by the compiler.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`FilterGroupsVersion1`方法以查看编译器生成的中间语言。
- en: Now, do the same with the `FilterGroupsVersion2` method. When you compare the
    IL for both methods, you will clearly see that the IL for `FilterGroupsVersion2`
    contains more lines of code than the IL for `FilterGroupsVersion1`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`FilterGroupsVersion2`方法做同样的操作。当您比较两种方法的IL时，您将清楚地看到`FilterGroupsVersion2`的IL比`FilterGroupsVersion1`的IL包含更多的代码行。
- en: And that explains why the `let` version of the code performs slower than the
    original code that does not use the `let` keyword. But can we do better than `FilterGroupsVersion1`
    in terms of performance? Well, it turns out that, yes, we can.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这就解释了为什么使用`let`关键字的代码版本比不使用`let`关键字的原始代码版本执行速度慢。但我们在性能方面能否做得比`FilterGroupsVersion1`更好？答案是，是的，我们可以。
- en: 'Add the `FilterGroupsVersion3` method:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`FilterGroupsVersion3`方法：
- en: '[PRE37]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, we create a new people list. We then loop through the `_people`
    list. For each person, we get them from the `_people` list. We then assign the
    lowercase form of their name to a local variable. Using this variable, we check
    to see if either `_group1` or `_group2` contains the names. If they do, then the
    person is added to the `_people` list. Once the iteration has finished, the `_people`
    collection is returned.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个新的人员列表。然后我们遍历`_people`列表。对于每个人，我们从`_people`列表中获取他们。然后我们将他们名字的小写形式赋值给一个局部变量。使用这个变量，我们检查`_group1`或`_group2`是否包含这些名字。如果包含，则将这个人添加到`_people`列表中。一旦迭代完成，`_people`集合将被返回。
- en: 'Build and run the code again. You should see the following report:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建和运行代码。您应该看到以下报告：
- en: '![Figure 7.9: The BenchmarkDotNet summary report showing FilterGroupsVersion3''s
    performance'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9：BenchmarkDotNet性能摘要报告显示FilterGroupsVersion3的性能'
- en: '](img/B16617_07_09.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：BenchmarkDotNet性能摘要报告显示FilterGroupsVersion4的性能'
- en: 'Figure 7.9: The BenchmarkDotNet summary report showing FilterGroupsVersion3''s
    performance'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9：BenchmarkDotNet性能摘要报告显示FilterGroupsVersion3的性能'
- en: As you can see, we have three different versions of the code that produce the
    same output, and each one's execution time is different. Between these three different
    methods, `FilterGroupsVersion3` is by far the quickest method in achieving the
    desired result.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有三种不同的代码版本产生相同的输出，但每个版本的执行时间不同。在这三种不同的方法中，`FilterGroupsVersion3`是达到预期结果最快的方法。
- en: 'We will have another go at improving the performance of our LINQ filter query.
    Add the `FilterGroupsVersion4` method:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次尝试改进LINQ过滤器查询的性能。添加`FilterGroupsVersion4`方法：
- en: '[PRE38]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It can be seen that the only difference between `FilterGroupsVersion3` and `FilterGroupsVersion4`
    is the ordering of the `if` condition check.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看出，`FilterGroupsVersion3`和`FilterGroupsVersion4`之间的唯一区别是`if`条件检查的顺序。
- en: 'Build the project and run the benchmark tests. *Figure 7.10* shows the performance
    summary:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并运行基准测试。*图7.10*显示了性能摘要：
- en: '![Figure 7.10: The BenchmarkDotNet summary report showing FilterGroupsVersion4''s
    performance'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：BenchmarkDotNet性能摘要报告显示FilterGroupsVersion4的性能'
- en: '](img/B16617_07_10.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：BenchmarkDotNet性能摘要报告显示FilterGroupsVersion4的性能'
- en: 'Figure 7.10: The BenchmarkDotNet summary report showing FilterGroupsVersion4''s
    performance'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：BenchmarkDotNet性能摘要报告显示FilterGroupsVersion4的性能'
- en: It is clear from the benchmark report that version 4 of our filter is the winning
    method in terms of performance. So, why is version 4 better than version 3? The
    `_group2` array contains fewer items than `_group1`. If you understand the business
    domain, you will be able to order the filter checks in such a way that the arrays
    with fewer items will be checked first.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从基准报告中可以看出，我们过滤器的第4版在性能方面是获胜的方法。那么，为什么第4版比第3版更好？`_group2`数组包含的项目比`_group1`少。如果您理解业务领域，您将能够以这种方式排序过滤检查，即首先检查项目较少的数组。
- en: You have seen how using the `let` keyword slows things down. But you have also
    seen how the ordering of checks in a conditional statement can also have an impact
    on performance. Placing the check with the least elements first within a conditional
    check statement will improve performance.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到使用`let`关键字会减慢速度。但您也看到了条件语句中检查的顺序如何影响性能。在条件检查语句中将具有最少元素的检查放在第一位将提高性能。
- en: In the next section, we will look at closures in LINQ statements and how they
    affect query performance.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨LINQ语句中的闭包以及它们如何影响查询性能。
- en: Understanding closures
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解闭包
- en: In this section, we will understand closures from a C# perspective, and apply
    them to LINQ queries. Let's start with the definition of computer programming
    closures according to the content on Wikipedia.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从C#的角度理解闭包，并将其应用于LINQ查询。让我们从维基百科上关于计算机编程闭包的定义开始。
- en: 'Wikipedia: "In programming languages, a closure, also lexical closure or function
    closure, is a technique for implementing lexically scoped name binding in a language
    with first-class functions.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科：“在编程语言中，闭包，也称为词法闭包或函数闭包，是一种在具有一等函数的语言中实现词法作用域名称绑定技术。”
- en: Operationally, a closure is a record storing a function together with an environment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作上，闭包是一个记录，它存储了一个函数及其环境。
- en: The environment is a mapping associating each free variable of the function
    (variables that are used locally but defined in an enclosing scope) with the value
    or reference to which the name was bound when the closure was created.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 环境是一个映射，它将函数的每个自由变量（在局部使用但在封装作用域中定义的变量）与在创建闭包时名称所绑定到的值或引用关联起来。
- en: Unlike a plain function, a closure allows the function to access those captured
    variables through the closure's copies of their values or references, even when
    the function is invoked outside their scope."
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通函数不同，闭包允许函数通过闭包对其值的副本或引用的捕获变量进行访问，即使函数在其作用域之外被调用。
- en: To understand what's being said here, we will begin by understanding what first-class
    functions are.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这里所说的内容，我们将首先理解一等函数是什么。
- en: A first-class function is a method that is treated by C# as a first-class data
    type. This means that you can assign a method to a variable and pass it around,
    and you can invoke it as you would a normal method. First-class functions can
    be created using anonymous methods and lambdas.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一等函数是 C# 将其视为一等数据类型的函数。这意味着你可以将方法分配给变量并传递它，你可以像调用普通方法一样调用它。一等函数可以使用匿名方法和 lambda
    表达式创建。
- en: Free variables are variables that are not parameter variables to a method, and
    they are variables that are not local to that method, which, in plain English,
    means that they are variables that exist outside of a method, but are being referenced
    within a method's closing scope.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 自由变量是那些不是方法参数变量的变量，它们也不是那个方法局部变量，换句话说，它们是存在于方法之外的变量，但在方法的作用域内被引用。
- en: 'We are going to apply closures to a LINQ expression and benchmark them. The
    first one will be using LINQ with a closure that takes parameters, and the second
    one will be using LINQ with a closure that uses free variables. Follow these steps:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把闭包应用到 LINQ 表达式并对其进行基准测试。第一个将使用带参数的闭包的 LINQ，第二个将使用使用自由变量的闭包的 LINQ。按照以下步骤进行：
- en: In the `LinqPerformance` class, comment out the current `[Benchmark]` annotated
    methods.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LinqPerformance` 类中，注释掉当前 `[Benchmark]` 注解的方法。
- en: 'Add the `LinqClosureUsingParameters` method:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `LinqClosureUsingParameters` 方法：
- en: '[PRE39]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the `LinqClosureUsingParameters` method, we declare closure using a delegate
    with parameters. We declare a variable called `IsBetween` and assign the `Between`
    method to it. Then we perform a LINQ query and filter the results by calling `IsBetween`.
    The result is that we will have only those people whose last name's first letters
    are between A and G.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LinqClosureUsingParameters` 方法中，我们使用带有参数的委托声明闭包。我们声明一个名为 `IsBetween` 的变量并将
    `Between` 方法分配给它。然后我们执行 LINQ 查询并通过调用 `IsBetween` 来过滤结果。结果是，我们只会得到那些姓氏首字母在 A 和
    G 之间的人。
- en: 'We can also use free variables. So, let us now look at a different example
    that uses free variables. Add the `LinqClosureUsingVariables` method:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用自由变量。因此，现在让我们看看一个使用自由变量的不同示例。添加 `LinqClosureUsingVariables` 方法：
- en: '[PRE40]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `LinqClosureUsingVariables` method, we declare our closure using free
    variables to declare the first and last characters used for filtering the dataset.
    We then assign the `Between` method to the `IsBetweenAG` variable. Then, we perform
    a LINQ query and filter the results by passing in the last name of each individual
    into the `IsBetweenAG` method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LinqClosureUsingVariables` 方法中，我们使用自由变量来声明用于过滤数据集的第一个和最后一个字符。然后，我们将 `Between`
    方法分配给 `IsBetweenAG` 变量。然后，我们执行 LINQ 查询并通过将每个个人的姓氏传递给 `IsBetweenAG` 方法来过滤结果。
- en: 'Add a method called `NonLinqFilter`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `NonLinqFilter` 的方法：
- en: '[PRE41]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this method, we simply filter a list using its own `FindAll` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们只是使用自己的 `FindAll` 方法过滤列表。
- en: 'Make sure you are in Release mode and then run your project. You should end
    up with results similar to those in the following screenshot:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你处于发布模式，然后运行你的项目。你应该得到以下截图中的类似结果：
- en: '![Figure 7.11: Closure benchmarks with and without parameters'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.11: Closure benchmarks with and without parameters](img/B16617_07_11.jpg)'
- en: '](img/B16617_07_11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_07_11.jpg](img/B16617_07_11.jpg)'
- en: 'Figure 7.11: Closure benchmarks with and without parameters'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：带参数和不带参数的闭包基准测试
- en: As we can clearly see in the benchmarks of *Figure 7.11*, closures with parameters
    are faster and allocate less memory than closures without parameters. But it is
    far better to use a list's own `FindAll` method for filtering as it is faster
    and uses less allocated memory than LINQ and closures.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.11*的基准测试所示，我们可以清楚地看到，带有参数的闭包比不带参数的闭包更快，并且分配的内存更少。但使用列表自己的`FindAll`方法进行过滤更好，因为它比LINQ和闭包更快，并且使用的分配内存更少。
- en: A situation when you may need to apply your own custom closures for use in LINQ
    queries is when you have complex data manipulation and query generation that cannot
    be dealt with easily with normal LINQ. In this case, closures would be of benefit
    to you. Having performed the benchmarking of closures, you now know to use closures
    with parameters for optimal performance when using LINQ. But if you don't need
    to use LINQ, then using a list's own methods may be more advantageous. And if
    you do have to work on lists, then it could pay to do the filtering of the dataset
    using non-LINQ methods first, then perform your LINQ queries on the filtered lists.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在自己的LINQ查询中使用自定义闭包时，可能的情况是，你有复杂的数据操作和查询生成，这些操作无法用正常的LINQ轻松处理。在这种情况下，闭包将对你有所帮助。在进行了闭包的基准测试后，你现在知道在使用LINQ时，为了获得最佳性能，应该使用带有参数的闭包。但如果你不需要使用LINQ，那么使用列表自己的方法可能更有利。而且如果你确实需要在列表上工作，那么首先使用非LINQ方法过滤数据集可能是有益的，然后在对过滤后的列表执行LINQ查询。
- en: This chapter is now complete. But before we move on to [*Chapter 8*](B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152),
    *File and Stream I/O*, let us summarize what we have learned in this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本章现在已完成。但在我们继续进入[*第8章*](B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152)，*文件和流I/O*之前，让我们总结一下本章学到的内容。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied LINQ performance by benchmarking a variety of ways
    to query, group, filter, and iterate data obtained from databases and in-memory
    collections. The most performant way to query a database was found to be using
    the `IEnumerator` interface. By disassembling code, we saw that the `let` keyword
    can degrade performance due to the extra lines of IL code produced by the compiler.
    We also saw how accessing the last element in a collection using its index is
    faster than calling the `Last()` method. And we also learned that filtering lists
    by filtering on objects with the least items first improves filter performance
    operations. Closures provided better overall performance when passing in parameters,
    compared to not passing in parameters.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过基准测试了查询、分组、过滤和迭代从数据库和内存集合中获取数据的各种方法，研究了LINQ的性能。发现查询数据库的最有效方法是使用`IEnumerator`接口。通过反汇编代码，我们看到`let`关键字可能会由于编译器产生的额外IL代码行而降低性能。我们还看到，使用索引访问集合中的最后一个元素比调用`Last()`方法更快。我们还了解到，首先过滤具有最少项的对象来过滤列表可以提高过滤操作的性能。与不传递参数相比，传递参数的闭包提供了更好的整体性能。
- en: In the next chapter, we will be looking at file and stream I/O performance.
    But for now, see if you can answer the following questions, and check out the
    further reading material to solidify what you have learned in this chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨文件和流I/O性能。但到目前为止，看看你是否能回答以下问题，并查看进一步阅读材料，以巩固本章学到的内容。
- en: Questions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name some ways to improve LINQ performance.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提出一些提高LINQ性能的方法。
- en: What is wrong with using the `let` keyword in a LINQ query?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在LINQ查询中使用`let`关键字有什么问题？
- en: What is the best way to improve the performance of a `Group By` query?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提高分组查询性能的最佳方法是什么？
- en: What performs better, closures with parameters, or closures without parameters?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带参数的闭包和不带参数的闭包哪个性能更好？
- en: Further reading
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Console User Secrets**: [https://github.com/jasonshave/ConsoleSecrets](https://github.com/jasonshave/ConsoleSecrets).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台用户秘密**：[https://github.com/jasonshave/ConsoleSecrets](https://github.com/jasonshave/ConsoleSecrets).'
- en: '**Optimising LINQ**: [https://mattwarren.org/2016/09/29/Optimising-LINQ/](https://mattwarren.org/2016/09/29/Optimising-LINQ/'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化LINQ**：[https://mattwarren.org/2016/09/29/Optimising-LINQ/](https://mattwarren.org/2016/09/29/Optimising-LINQ/)'
- en: )
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Five Tips to Improve LINQ to SQL Performance**: [https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx](https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高LINQ to SQL性能的五个技巧**：[https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx](https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx).'
- en: '**Make your C# applications faster with LINQ joins**: [https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins](https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins).'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用LINQ连接使您的C#应用程序更快**：[https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins](https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins).'
- en: '**LINQ Stinks – code smells in your LINQ**: [https://markheath.net/post/linq-stinks](https://markheath.net/post/linq-stinks).'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ很糟糕 – 您LINQ中的代码异味**：[https://markheath.net/post/linq-stinks](https://markheath.net/post/linq-stinks).'
- en: '**How to get a value out of a Span<T> with Linq expression trees?**: [https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees](https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees).'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何使用LINQ表达式树从Span<T>中获取值？**：[https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees](https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees).'
- en: '**Linq ToLookup Method in C#**: [https://dotnettutorials.net/lesson/linq-tolookup-operator/](https://dotnettutorials.net/lesson/linq-tolookup-operator/).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C#中的Linq ToLookup方法**：[https://dotnettutorials.net/lesson/linq-tolookup-operator/](https://dotnettutorials.net/lesson/linq-tolookup-operator/).'
- en: '**LINQ (C#) – ToLookup Operator Example And Tutorial**: [https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php](https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php).'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ (C#) – ToLookup运算符示例和教程**：[https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php](https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php).'
- en: '**A Simple Explanation of C# Closures**: [https://www.simplethread.com/c-closures-explained/](https://www.simplethread.com/c-closures-explained/).'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C#闭包的简单解释**：[https://www.simplethread.com/c-closures-explained/](https://www.simplethread.com/c-closures-explained/).'
