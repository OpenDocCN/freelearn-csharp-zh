- en: Chapter 2. Hello, Platforms!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。你好，平台！
- en: If you are familiar with developing applications using Visual Studio on Windows,
    then using Xamarin Studio should be very straightforward. Xamarin uses the same
    concept of a **solution** containing one or more **projects**, and it has created
    several new project types for iOS and Android applications. There are also several
    project templates to jump-start your development of common applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉在Windows上使用Visual Studio开发应用程序，那么使用Xamarin Studio应该非常简单。Xamarin使用与Visual
    Studio相同的**解决方案**概念，其中包含一个或多个**项目**，并为iOS和Android应用程序创建了几个新的项目类型。还有几个项目模板可以帮助您快速开始开发常见应用程序。
- en: Xamarin Studio supports several out-of-the-box project types, including standard
    `.NET` class libraries and console applications. You cannot natively develop Windows
    applications on a Mac with Xamarin Studio, but you can certainly develop the shared
    code portion of your application in Xamarin Studio. We'll focus on sharing code
    in the later chapters, but keep in mind that Xamarin enables you to share a common
    C# backend between most platforms that support C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio支持多种开箱即用的项目类型，包括标准的.NET类库和控制台应用程序。您无法在Mac上使用Xamarin Studio原生开发Windows应用程序，但您当然可以在Xamarin
    Studio中开发应用程序的共享代码部分。我们将在后面的章节中关注代码共享，但请记住，Xamarin使您能够在支持C#的大多数平台上共享通用的C#后端。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Creating a "Hello World" application for iOS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为iOS创建“Hello World”应用程序
- en: Apple's MVC pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果的MVC模式
- en: Xcode and storyboards
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xcode和故事板
- en: Creating a "Hello World" application for Android
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Android创建“Hello World”应用程序
- en: Android activities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android活动
- en: Xamarin's Android designer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin的Android设计器
- en: Building your first iOS application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的第一个iOS应用程序
- en: Launch Xamarin Studio and start a new solution. Just like in Visual Studio,
    there are lots of project types that can be created from the **New Solution**
    dialog. Xamarin Studio, formerly **MonoDevelop**, supports the development of
    many different types of projects such as C# console applications targeting the
    Mono runtime, NUnit test projects, and even other languages besides C#, such as
    VB or C++.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Xamarin Studio并开始一个新的解决方案。就像在Visual Studio中一样，可以从**新建解决方案**对话框创建许多项目类型。Xamarin
    Studio（以前称为MonoDevelop）支持开发许多不同类型的项目，例如针对Mono运行时的C#控制台应用程序、NUnit测试项目，甚至除了C#之外的其他语言，如VB或C++。
- en: 'Xamarin Studio supports the following project types for iOS:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio支持以下iOS项目类型：
- en: '**iPhone or iPad project**: These categories of projects use storyboards to
    lay out the UI and target either the iPad or iPhone only.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iPhone或iPad项目**：这些项目类别使用故事板来布局UI，并且仅针对iPad或iPhone。'
- en: '**Universal project**: This category supports both iPhone and iPad in the same
    iOS application. This is the preferred project type if you need to target both
    types of devices.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用项目**：此类别支持同一iOS应用程序中的iPhone和iPad。如果您需要针对这两种类型的设备，则这是首选的项目类型。'
- en: '**Single View Application**: This is the basic project type that sets up an
    iOS storyboard along with a single view and controller.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单视图应用程序**：这是基本的项目类型，它设置了一个iOS故事板、一个视图和一个控制器。'
- en: '**Tabbed Application**: This is a project type that automatically sets up **UITabViewController**
    for applications with a tab layout.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签应用程序**：这是一个自动设置**UITabViewController**的项目类型，用于具有标签布局的应用程序。'
- en: '**WebView Application**: This project type is for creating *hybrid* applications
    that are partially HTML and partially native. The application is set up to take
    advantage of the Razor templating features of Xamarin Studio.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebView应用程序**：此项目类型用于创建部分HTML和部分本地的*混合*应用程序。应用程序已配置为利用Xamarin Studio的Razor模板功能。'
- en: '**iOS binding project**: This is an iOS project that can create C# bindings
    for an Objective-C library.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS绑定项目**：这是一个iOS项目，可以为目标C#库创建Objective-C绑定。'
- en: '**iOS unit test project**: This is a special iOS application project that can
    run NUnit tests.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS单元测试项目**：这是一个特殊的iOS应用程序项目，可以运行NUnit测试。'
- en: '**iOS library project**: This is a class library used within other iOS application
    projects.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS库项目**：这是一个用于其他iOS应用程序项目的类库。'
- en: 'To get started, navigate to **iOS** | **iPhone**, and create **Single View
    Application** in the directory of your choice, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请导航到**iOS** | **iPhone**，并在您选择的目录中创建**单视图应用程序**，如图所示：
- en: '![Building your first iOS application](img/00011.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![构建你的第一个iOS应用程序](img/00011.jpeg)'
- en: 'You''ll notice that several files and folders are automatically created from
    the project template. These files are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，从项目模板中自动创建了几个文件和文件夹。这些文件如下：
- en: '`Components`: This folder will contain any components added from the Xamarin
    Component Store. See [Chapter 9](part0070_split_000.html#page "Chapter 9. Third-party
    Libraries"), *Third-party Libraries*, for more information about the Xamarin Component
    Store.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`组件`：这个文件夹将包含从Xamarin组件商店添加的任何组件。有关Xamarin组件商店的更多信息，请参阅[第9章](part0070_split_000.html#page
    "第9章。第三方库")，*第三方库*。'
- en: '`Resources`: This directory will contain any images or plain files that you
    want to be copied directly to your application bundle. Note that this will contain
    a black splash screen image, by default. This ensures that your iOS application
    runs full screen on the iPhone 5.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资源`：这个目录将包含你想要直接复制到应用程序包中的任何图像或纯文本文件。请注意，默认情况下，它将包含一个黑色启动画面图像。这确保了你的iOS应用程序在iPhone
    5上全屏运行。'
- en: '`AppDelegate.cs`: This is Apple''s main class that handles application-level
    events in your app.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDelegate.cs`：这是苹果处理应用程序级事件的主要类。'
- en: '`Entitlements.plist`: This is a settings file Apple uses to declare permissions
    for certain iOS features such as push notifications and iCloud. You will generally
    only have to use it for advanced iOS features.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entitlements.plist`：这是一个苹果用来声明某些iOS功能（如推送通知和iCloud）权限的设置文件。你通常只需要为高级iOS功能使用它。'
- en: '`*ViewController.cs`: This is the controller that represents the first screen
    in your app. It will have the same name as your project.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ViewController.cs`：这是代表你应用程序第一个屏幕的控制器。它将具有与你的项目相同的名称。'
- en: '`Info.plist`: This is Apple''s version of a `manifest` file that can declare
    various settings for your application such as the app title, icon, splash screens,
    and other common settings.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Info.plist`：这是苹果的`manifest`文件版本，可以声明你的应用程序的各种设置，如应用程序标题、图标、启动画面和其他常见设置。'
- en: '`Main.cs`: This file contains the standard entry point for a C# program: `static
    void Main()`. It''s most likely that you will not need to modify this file.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main.cs`：这个文件包含C#程序的常规入口点：`static void Main()`。你很可能不需要修改这个文件。'
- en: '`MainStoryboard.storyboard`: This is the storyboard definition file for your
    application. It will contain the layouts for the views in your app, list of controllers,
    and the transitions used to navigate throughout your app.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainStoryboard.storyboard`：这是你应用程序的故事板定义文件。它将包含你应用程序中视图的布局、控制器列表以及用于在应用程序中导航的过渡。'
- en: 'Now, let''s run the application to see what we get by default from the project
    template. Click on the large play button in the top-left corner of Xamarin Studio.
    You will be greeted by the simulator running your first iOS application, as shown
    in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行应用程序，看看从项目模板中默认得到什么。点击Xamarin Studio左上角的大号播放按钮。你会看到运行你第一个iOS应用程序的模拟器，如下面的截图所示：
- en: '![Building your first iOS application](img/00012.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![构建你的第一个iOS应用程序](img/00012.jpeg)'
- en: So far, your app is just a plain white screen, which is not very exciting or
    useful. Let's get a little more background on iOS development before moving forward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的应用程序只是一个普通的白色屏幕，既不令人兴奋也不实用。在继续前进之前，让我们先对iOS开发有一个更深入的了解。
- en: Depending on your application's minimum iOS target, you can also run the application
    on different versions of the iOS simulator. Apple also provides simulators for
    iPad and all the different iOS devices currently in the market. It is also important
    to know that these are simulators and not emulators. An emulator will run an encapsulated
    version of the mobile OS (just as Android does). Emulators generally exhibit slower
    performance but give you a closer replica of the real OS. Apple's simulators run
    in native Mac applications and are not true operating systems. The benefit is
    that they are very fast in comparison to Android emulators.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的应用程序的最低iOS目标，你还可以在不同的iOS模拟器版本上运行应用程序。苹果还提供了iPad和市场上所有不同iOS设备的模拟器。重要的是要知道，这些是模拟器而不是仿真器。仿真器将运行移动操作系统的封装版本（就像Android一样）。仿真器通常表现出较慢的性能，但提供了更接近真实操作系统的复制品。苹果的模拟器在原生Mac应用程序中运行，并不是真正的操作系统。好处是，与Android仿真器相比，它们运行得非常快。
- en: Understanding Apple's MVC pattern
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解苹果的MVC模式
- en: Before getting too far with iOS development, it is really important to get a
    foundation with Apple's design pattern to develop on iOS. You might have used
    the **Model View Controller** (**MVC**) pattern with other technologies such as
    **ASP.NET**, but Apple implements this paradigm in a slightly different way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入iOS开发之前，了解苹果的设计模式以在iOS上开发是非常重要的一步。你可能已经使用过**模型-视图-控制器**（**MVC**）模式与其他技术如**ASP.NET**一起使用，但苹果以略不同的方式实现了这个范式。
- en: 'The MVC design pattern includes the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: MVC设计模式包括以下内容：
- en: '**Model**: This is the backend business logic that drives the application.
    This can be any code that, for example, makes web requests to a server or saves
    data to a local **SQLite** database.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这是驱动应用程序的后端业务逻辑。这可以是任何代码，例如，向服务器发送网络请求或将数据保存到本地的**SQLite**数据库。'
- en: '**View**: This is the actual user interface seen on the screen. In iOS terms,
    this is any class that derives from `UIView`. Examples are toolbars, buttons,
    and anything else the user would see on the screen and interact with.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是屏幕上实际的用户界面。在iOS术语中，这是任何从`UIView`派生的类。例如，工具栏、按钮以及用户会在屏幕上看到并与之交互的任何内容。'
- en: '**Controller**: This is the workhorse of the MVC pattern. The controller interacts
    with the Model layer and updates the View layer with the results. Similar to the
    View layer, any controller class will derive from `UIViewController`. This is
    where a good portion of the code in iOS applications resides.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这是MVC模式中的工作马。控制器与模型层交互，并使用结果更新视图层。与视图层类似，任何控制器类都将从`UIViewController`派生。这是iOS应用程序中大部分代码所在的地方。'
- en: 'The following figure shows you the MVC design pattern:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了MVC设计模式：
- en: '![Understanding Apple''s MVC pattern](img/00013.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![理解苹果的MVC模式](img/00013.jpeg)'
- en: 'To understand this pattern better, let''s walk you through the following example
    of a common scenario:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个模式，让我们通过以下常见场景的例子来引导你：
- en: We have an iOS application with a search box that needs to query a website for
    a list of jobs.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个iOS应用程序，其中包含一个搜索框，需要查询网站以获取工作列表。
- en: The user will enter some text into the `UITextField` textbox and click on the
    `UIButton` button to start the search. This is the View layer.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将在`UITextField`文本框中输入一些文本，并点击`UIButton`按钮以开始搜索。这是视图层。
- en: Some code will respond to the button by interacting with the view, display a
    `UIActivityIndicatorView` spinner, and call a method in another class to perform
    the search. This is the Controller layer.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些代码将通过与视图交互来响应按钮，显示一个`UIActivityIndicatorView`加载指示器，并调用另一个类中的方法来执行搜索。这是控制器层。
- en: A web request will be made in the called class and a list of jobs will be returned
    asynchronously. This is the Model layer.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在被调用的类中将会发起一个网络请求，并异步返回工作列表。这是模型层。
- en: The controller will then update the view with the list of jobs and hide the
    spinner.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器将随后更新视图以显示工作列表并隐藏加载指示器。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on Apple's MVC pattern, see the documentation site at [https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/MVC.html](https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/MVC.html).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于苹果的MVC模式更多信息，请参阅[https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/MVC.html](https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/MVC.html)的文档网站。
- en: A point to note is that you are free to do anything you want in the Model layer
    of your application. This is where we can use plain C# classes that can be reused
    on other platforms such as Android. This includes any functionality using the
    C# **Base Class Libraries** (**BCL**), such as working with web services or a
    database. We'll dive deeper into cross-platform architecture and code-sharing
    concepts later in the book.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，在应用程序的模型层，你可以自由地做任何你想做的事情。这就是我们可以使用可以在其他平台如Android上重用的纯C#类的地方。这包括使用C#
    **基础类库**（**BCL**）的任何功能，例如处理Web服务或数据库。本书后面我们将更深入地探讨跨平台架构和代码共享的概念。
- en: Using the iOS designer
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用iOS设计器
- en: Since our plain white application is quite boring, let's modify the View layer
    of our application with some controls. To do this, we will modify the `MainStoryboard.storyboard`
    file in your project in Xamarin Studio. Optionally, you can open the storyboard
    file in Xcode, which was previously the method of editing storyboard files before
    the designer was available in Xamarin Studio. Using Xcode can still be useful
    if there is a feature in iOS storyboards that isn't available yet in the Xamarin
    designer or if you need to edit an older iOS format such as `XIB` files. However,
    Xcode is not quite as good of an experience, since custom controls in Xcode render
    as a plain white square. Xamarin's designer actually runs your drawing code in
    custom controls, so that you get an accurate view of what your application will
    look like at runtime.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的纯白色应用程序相当无聊，让我们通过添加一些控件来修改应用程序的View层。为此，我们将修改Xamarin Studio中项目中的`MainStoryboard.storyboard`文件。可选地，你可以在Xcode中打开故事板文件，这是在Xamarin
    Studio中提供设计器之前编辑故事板文件的方法。使用Xcode仍然可能很有用，如果iOS故事板中有一些功能在Xamarin设计器中尚未提供，或者你需要编辑较旧的iOS格式，如`XIB`文件。然而，Xcode的体验并不那么好，因为Xcode中的自定义控件渲染为纯白色方块。Xamarin的设计器实际上在自定义控件中运行你的绘图代码，这样你就可以准确地看到应用程序在运行时的外观。
- en: '![Using the iOS designer](img/00014.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![使用iOS设计器](img/00014.jpeg)'
- en: 'Let''s add some controls to our app by performing the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤向我们的应用程序添加一些控件：
- en: Open the project you created earlier in this chapter in Xamarin Studio.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章中创建的项目，在Xamarin Studio中打开。
- en: Double-click on the `MainStoryboard.storyboard` file.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件。
- en: The iOS designer will open, and you will see the layout for the single controller
    in your application.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: iOS设计器将打开，你将看到应用程序中单个控制器的布局。
- en: In the **Document Outline** tab on the right-hand side, you'll see that your
    controller contains a single view in its layout hierarchy.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的**文档大纲**选项卡中，你会看到你的控制器在其布局层次结构中包含一个视图。
- en: In the top-left corner, you'll notice a toolbox that contains several types
    of objects that you can drag and drop onto your controller's view.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角，你会注意到一个工具箱，其中包含你可以拖放到控制器视图上的几种类型的对象。
- en: In the search box, search for `UILabel` and drag the label onto your view at
    a location of your choice.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中，搜索`UILabel`并将标签拖放到你选择的视图位置。
- en: Double-click on the label to edit the text of the label to anything you wish.
    You can also fill out this value from the **Properties** tab in the bottom-right
    corner.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击标签以编辑标签的文本为任何你想要的。你也可以从底部右角的**属性**选项卡中填写这个值。
- en: Likewise, search for `UIButton` and drag the button onto your view somewhere
    above or below the label. You can edit the text on the button using the **Properties**
    tab. Double-clicking on the button will add a click event handler as you might
    be familiar in Visual Studio when developing for other platforms.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，搜索`UIButton`并将按钮拖放到视图中的某个位置，位于标签上方或下方。你可以使用**属性**选项卡编辑按钮上的文本。双击按钮将添加一个点击事件处理程序，就像你在为其他平台开发时在Visual
    Studio中熟悉的那样。
- en: Run the application.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。
- en: 'Your application should start looking a lot more like a real application, as
    shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序应该看起来更像一个真正的应用程序，如下面的截图所示：
- en: '![Using the iOS designer](img/00015.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用iOS设计器](img/00015.jpeg)'
- en: Now you might be wondering about adding user interaction options to the app
    at this point. In Xcode's iOS designer, you can make an **outlet** that will make
    each view visible from C#. An outlet is a reference to a view in a storyboard
    or `XIB` file that will be filled out with an instance of the view at runtime.
    You can compare this concept to naming a control in other technologies such as
    ASP.NET MVC, WebForms, or **Windows Presentation Foundation** (**WPF**). Luckily,
    Xamarin's iOS designer is a bit simpler than setting up an outlet in Xcode. You
    merely fill out the **Name** field in the **Properties** tab, and Xamarin Studio
    will generate a property in **partial class**, which gives you access to the label
    and button from your controller. Additionally, you can wire an **action** from
    a storyboard file, which is a method that will be called when an event occurs.
    Xamarin Studio exposes iOS actions as partial methods to be implemented in your
    classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道在这个时候如何向应用添加用户交互选项。在Xcode的iOS设计器中，你可以创建一个**outlet**，这将使每个视图从C#中可见。outlet是Storyboard或`XIB`文件中视图的引用，在运行时会用视图的实例填充。你可以将这个概念与其他技术（如ASP.NET
    MVC、WebForms或**Windows Presentation Foundation**（**WPF**）中的控件命名进行比较。幸运的是，Xamarin的iOS设计器在设置outlet方面比Xcode简单得多。你只需在**属性**选项卡中填写**名称**字段，Xamarin
    Studio就会在**部分类**中生成一个属性，这让你可以从控制器访问标签和按钮。此外，你还可以从Storyboard文件中连接一个**动作**，这是一个在事件发生时会被调用的方法。Xamarin
    Studio将iOS动作作为部分方法暴露出来，以便在类中实现。
- en: 'Let''s add some interactions to the app as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式向应用添加一些交互：
- en: Switch back to Xamarin Studio.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回Xamarin Studio。
- en: Double-click on the `MainStoryboard.storyboard` file again.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次双击`MainStoryboard.storyboard`文件。
- en: Select the label you created earlier and go to the **Properties** pane and make
    sure that you have the **Widget** tab selected.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你之前创建的标签，转到**属性**面板并确保已选择**小部件**选项卡。
- en: Enter the name `label` in the **Name** field.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**字段中输入名称`label`。
- en: Repeat this process for the button, and enter the name `button` into its **Name**
    field.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对按钮重复此过程，并在其**名称**字段中输入名称`button`。
- en: Xamarin has improved this experience greatly from what the experience used to
    be in Xcode. Xcode has a strange interface for those used to Visual Studio. The
    method used to create an outlet involved clicking and dragging from the control
    onto an Objective-C header file. Merely filling out a **Name** field is much simpler
    and much more intuitive for developers that have a C# background.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与Xcode中过去的使用体验相比，Xamarin大大改善了这一体验。对于习惯了Visual Studio的用户来说，Xcode的界面很奇怪。创建outlet的方法涉及从控件拖动到Objective-C头文件。仅填写**名称**字段对有C#背景的开发者来说要简单得多，也更直观。
- en: 'Now that we have two outlets defined, two new properties will be available
    from your controller. Expand the `*ViewController.cs` file in your solution and
    open the `*ViewController.designer.cs` file. You will see your properties defined
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了两个outlet，从你的控制器中将有两个新的属性可用。展开解决方案中的`*ViewController.cs`文件并打开`*ViewController.designer.cs`文件。你会看到你的属性如下定义：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is not a good idea to modify this file since Xamarin Studio can rebuild it
    if you make further changes in the designer or Xcode. Nevertheless, it is a good
    practice to learn how things are actually working behind the scenes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Xamarin Studio可以在设计器或Xcode中进行进一步更改时重新构建它，因此修改此文件不是一个好主意。尽管如此，了解幕后实际工作原理是一个好的实践。
- en: 'Open your `*ViewController.cs` file, and let''s enter the following code in
    your controller''s `ViewDidLoad` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`*ViewController.cs`文件，并在控制器中的`ViewDidLoad`方法中输入以下代码：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the `ViewDidLoad` method is called, your controller's view is loaded for
    the first time. This happens once in the lifetime of your controller. We subscribed
    to the `TouchUpInside` event, which is fired when the button is clicked; iOS does
    not have a click event, which might be what you are used to on Windows platforms.
    We also used C#'s convenient lambda expression syntax to update the label when
    the event is fired. A lambda expression is shorthand for an anonymous method,
    which is a feature that has been part of C# since .NET 4.0.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ViewDidLoad`方法被调用时，你的控制器视图将首次加载。这发生在控制器生命周期的某个时刻。我们订阅了`TouchUpInside`事件，当按钮被点击时，这个事件会被触发；iOS没有点击事件，这可能是在Windows平台上你习惯的。我们还使用了C#方便的lambda表达式语法来在事件触发时更新标签。lambda表达式是匿名方法的简写，这是自.NET
    4.0以来C#的一部分特性。
- en: 'Run your application, and you will be able to interact with your button and
    increment the value displayed in the label, as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用程序，你将能够与按钮交互并增加标签上显示的值，如下面的截图所示：
- en: '![Using the iOS designer](img/00016.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用iOS设计器](img/00016.jpeg)'
- en: Next, we need to make a transition from one controller to another. To do this,
    iOS has a concept called **segue**, which is basically some kind of animation
    that switches from one controller to the next. There are several types of segues,
    but the most common segue slides transition to a new controller from the right
    or bottom of the screen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从一个控制器转换到另一个控制器。为此，iOS有一个称为**segue**的概念，它基本上是一种从当前控制器切换到下一个控制器的动画。有几种类型的segue，但最常见的segue是从屏幕的右侧或底部滑动到新的控制器。
- en: 'Now, let''s add a second controller to the application as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤向应用程序添加第二个控制器：
- en: Return to your project in Xamarin Studio.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回你的项目在Xamarin Studio中。
- en: Double-click on the `MainStoryboard.storyboard` file.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件。
- en: Drag a new controller from the object library that is usually in the bottom-left
    corner next to the first controller.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从对象库中拖动一个新的控制器，通常位于第一个控制器的左下角。
- en: Click on the controller to select it.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击控制器以选择它。
- en: Select the **Properties** pane and make sure you are on the **Widget** tab.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**属性**面板并确保你处于**小部件**选项卡。
- en: Enter a name such as `SecondController` for the controller into the **Class**
    field.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中为控制器输入一个名称，例如`SecondController`。
- en: Now let's add a segue for the transition from the first controller to this one.
    Hold the *Ctrl* key while clicking on the button from the original controller
    to your new controller. A blue line will appear followed by a small pop-up menu.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为从第一个控制器到这个控制器的转换添加一个segue。在点击原始控制器上的按钮到你的新控制器时按住*Ctrl*键。会出现一条蓝色线条，随后是一个小的弹出菜单。
- en: Select **modal** from the pop-up menu.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出菜单中选择**模态**。
- en: Run the application from Xamarin Studio.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Xamarin Studio运行应用程序。
- en: Since we set up a modal segue from the first controller's button, your second
    controller will appear while clicking on it. However, there isn't a way to exit
    the new controller yet. If you return to Xamarin Studio, you'll notice that a
    `SecondController.cs` file and a `SecondController.designer.cs` file have been
    automatically created for you.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从第一个控制器的按钮设置了一个模态转换，点击第二个控制器时它将出现。然而，目前还没有退出新控制器的方法。如果你返回Xamarin Studio，你会注意到已经为你自动创建了一个`SecondController.cs`文件和一个`SecondController.designer.cs`文件。
- en: 'Let''s add a button to `SecondController` as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`SecondController`中添加一个按钮，如下所示：
- en: Return to Xamarin Studio.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Xamarin Studio。
- en: Double-click on the `MainStoryboard.storyboard` file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件。
- en: Drag a button from the object library onto the second controller.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从对象库中将一个按钮拖动到第二个控制器上。
- en: Navigate to the **Properties** pane and **Widget** tab.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**属性**面板和**小部件**选项卡。
- en: Set the **Name** of the button to `close`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的**名称**设置为`close`。
- en: Set the **Title** of the button to `Close`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的**标题**设置为`Close`。
- en: 'Open the `SecondController.cs` file and add the following method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`SecondController.cs`文件并添加以下方法：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you compile and run your application, clicking on the button will increment
    the value on the label and display the modal second controller. You can then close
    the second controller by tapping on the **Close** button. Notice the neat sliding
    animation; iOS automatically applies these kinds of transition effects and are
    very easy to customize on iOS:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行你的应用程序，点击按钮将增加标签上的值并显示模态第二个控制器。然后你可以通过点击**Close**按钮来关闭第二个控制器。注意整洁的滑动动画；iOS自动应用这些类型的转换效果，并且非常容易在iOS上自定义：
- en: '![Using the iOS designer](img/00017.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![使用iOS设计器](img/00017.jpeg)'
- en: Since we have gone over the basics of laying out controls in Xamarin's iOS designer
    and interacting with outlets in C#, let's go over the standard lifecycle of an
    iOS application. The primary location for handling application-level events is
    in the `AppDelegate` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经介绍了在Xamarin的iOS设计器中布局控件的基本知识以及与C#中的输出交互，让我们回顾一下iOS应用程序的标准生命周期。处理应用程序级事件的主要位置在`AppDelegate`类中。
- en: 'If you open your `AppDelegate.cs` file, you can override the following methods:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开你的`AppDelegate.cs`文件，你可以重写以下方法：
- en: '`FinishedLaunching`: This is the first entry point for the application, which
    should return `true`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FinishedLaunching`：这是应用程序的第一个入口点，它应该返回`true`。'
- en: '`DidEnterBackground`: This means that the user clicked on the home button on
    their device or another app, such as a phone call, came to the foreground. You
    should perform any action needed to save the user''s progress or state of the
    UI as the iOS might close your application to save memory once pushed to the background.
    While your application is in the background, the user could be navigating through
    the home screen or opening other apps. Your application is effectively paused
    in memory until resumed by the user.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DidEnterBackground`：这意味着用户点击了他们的设备上的主页按钮，或者另一个应用程序，如电话呼叫，进入了前台。你应该执行任何必要的操作来保存用户的进度或
    UI 的状态，因为 iOS 可能会关闭你的应用程序以节省内存，一旦被推送到后台。当你的应用程序在后台时，用户可能正在浏览主屏幕或打开其他应用程序。你的应用程序在内存中实际上是被暂停，直到用户恢复。'
- en: '`WillEnterForeground`: This means that the user has reopened your application
    from the background. You might need to perform other actions here such as refreshing
    the data on the screen and so on.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WillEnterForeground`：这意味着用户已从后台重新打开你的应用程序。你可能需要在这里执行其他操作，例如刷新屏幕上的数据等。'
- en: '`OnResignActivation`: This happens if the operating system displays a system
    popup on top of your application. Examples of this are calendar reminders or the
    menu the user can swipe down from the top of the screen.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnResignActivation`：如果操作系统在你的应用程序上方显示系统弹出窗口，就会发生这种情况。例如，这包括日历提醒或用户可以从屏幕顶部向下滑动的菜单。'
- en: '`OnActivated`: This happens immediately after the `OnResignActivation` method
    is executed as the user returns to your app.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActivated`：在用户返回你的应用程序后，`OnResignActivation` 方法执行后立即发生。'
- en: '`ReceiveMemoryWarning`: This is a warning from the operating system to free
    up the memory in your application. It is not commonly needed with Xamarin because
    of the C#''s garbage collector, but if there are any heavy objects such as images
    throughout your app, this is a good place to dispose them. If enough memory cannot
    be freed, the operating system can terminate your application.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReceiveMemoryWarning`：这是操作系统发出的警告，提示释放应用程序中的内存。由于 C# 的垃圾回收器，Xamarin 中通常不需要这个方法，但如果你的应用程序中存在像图像这样的重对象，这是一个很好的地方来销毁它们。如果无法释放足够的内存，操作系统可以终止你的应用程序。'
- en: '`HandleOpenUrl`: This is called if you implement a **URL scheme**, which is
    the iOS equivalent of file extension associations on a desktop platform. If you
    register your app to open different types of files or URLs, this method will be
    called.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandleOpenUrl`：如果你实现了 **URL scheme**，这将是 iOS 在桌面平台上的文件扩展名关联的等价物。如果你注册你的应用程序以打开不同类型的文件或
    URL，此方法将被调用。'
- en: 'Likewise, in your `*ViewController.cs` file, you can override the following
    methods on your controller:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在你的 `*ViewController.cs` 文件中，你可以覆盖控制器上的以下方法：
- en: '`ViewDidLoad`: This occurs when the view associated with your controller is
    loaded. It will occur only once on devices running iOS 6 or higher.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidLoad`：当与控制器关联的视图被加载时发生。在运行 iOS 6 或更高版本的设备上，它只会发生一次。'
- en: '`ViewWillAppear`: This occurs prior to your view appearing on the screen. If
    there are any views that need to be refreshed while navigating throughout your
    app, this is generally the best place to do it.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewWillAppear`：在视图出现在屏幕上之前发生。如果你在应用程序中导航时需要刷新任何视图，这通常是做这件事的最佳位置。'
- en: '`ViewDidAppear`: This occurs after the completion of any transition animations
    and your view is displayed on the screen. In some uncommon situations, you might
    need to perform actions here instead of in `ViewWillAppear`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidAppear`：在完成任何过渡动画并显示视图在屏幕上后发生。在某些不常见的情况下，你可能需要在这里执行操作，而不是在 `ViewWillAppear`
    中。'
- en: '`ViewWillDisappear`: This method is called prior to your view being hidden.
    You might need to perform some cleanup operations here.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewWillDisappear`：在视图被隐藏之前调用此方法。你可能需要在这里执行一些清理操作。'
- en: '`ViewDidDisappear`: This occurs after any transition animations are completed
    for displaying a different controller on the screen. Just like the methods for
    appearing, this occurs after `ViewWillDisappear`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidDisappear`：在完成显示屏幕上不同控制器的任何过渡动画后发生。就像出现的方法一样，这发生在 `ViewWillDisappear`
    之后。'
- en: There are several more methods available to override, but many are deprecated
    for recent versions of iOS. Familiarize yourself with Apple's documentation site
    at [http://developer.apple.com/library/ios](http://developer.apple.com/library/ios).
    It is very helpful to read the documentation on each class and method when trying
    to understand how Apple's APIs work. Learning how to read (not necessarily code)
    Objective-C is also a useful skill to learn so that you are able to convert Objective-C
    examples to C# when developing iOS applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多方法可供覆盖，但许多在iOS的最新版本中已被弃用。熟悉Apple的文档网站[http://developer.apple.com/library/ios](http://developer.apple.com/library/ios)很有帮助。在尝试理解Apple的API如何工作时，阅读每个类和方法的文档非常有用。学习如何阅读（不一定是代码）Objective-C也是一个有用的技能，这样你就可以在开发iOS应用程序时将Objective-C示例转换为C#。
- en: Building your first Android application
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的第一个Android应用程序
- en: Setting up an Android application in Xamarin Studio is just as easy as it is
    for iOS and is very similar to the experiences in Visual Studio. Xamarin Studio
    includes several project templates that are specific for Android to jump-start
    your development.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中设置Android应用程序与iOS一样简单，并且与Visual Studio中的体验非常相似。Xamarin Studio包括几个特定于Android的项目模板，以帮助你快速开始开发。
- en: 'Xamarin Studio includes the following project templates:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio包括以下项目模板：
- en: '**Android application**: A standard Android application that targets the newest
    Android SDKs installed on your machine.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android应用程序**：一个针对您机器上安装的最新Android SDK的标准Android应用程序。'
- en: '**Android Honeycomb application**: A project that targets Android Honeycomb,
    which is **API** (**Application Programming Interface**) level 12 and higher.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android Honeycomb应用程序**：一个针对Android Honeycomb（**API**（应用程序编程接口）级别12及以上）的项目。'
- en: '**Android Ice Cream Sandwich application**: A project that targets Android
    Ice Cream Sandwich, which is API level 15 and above.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android冰淇淋三明治应用程序**：一个针对Android冰淇淋三明治（API级别15及以上）的项目。'
- en: '**Android library project**: A class library that can only be referenced by
    Android application projects.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android库项目**：一个只能由Android应用程序项目引用的类库。'
- en: '**Android Java bindings library**: A project for setting up a Java library
    to be called from C#.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android Java绑定库**：一个用于设置从C#中调用的Java库的项目。'
- en: '**Android OpenGL application**: A project template to use low-level OpenGL
    for 3D or 2D rendering.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android OpenGL应用程序**：一个用于使用低级OpenGL进行3D或2D渲染的项目模板。'
- en: '**Android WebView application**: A project template for a hybrid app using
    HTML for certain parts. Support for Razor templating is available.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android WebView应用程序**：一个用于使用HTML进行某些部分的混合应用程序的项目模板。支持Razor模板。'
- en: '**Android unit test project**: A project for running NUnit tests on Android.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android单元测试项目**：一个用于在Android上运行NUnit测试的项目。'
- en: Launch Xamarin Studio and start a new solution. From the **New Solution** dialog,
    create a new **Android Application** under the **Android** section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Xamarin Studio并开始一个新的解决方案。从**新建解决方案**对话框中，在**Android**部分下创建一个新的**Android应用程序**。
- en: 'You will end up with a solution looking something similar to what is shown
    in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会得到一个类似于以下截图所示的项目解决方案：
- en: '![Building your first Android application](img/00018.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![构建你的第一个Android应用程序](img/00018.jpeg)'
- en: 'You''ll see that the following files and folders specific to Android have been
    created for you:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到为你创建了以下特定于Android的文件和文件夹：
- en: 'The `Components` folder: This is the same as for iOS projects; the place where
    components from the Xamarin Component Store can be added.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Components`文件夹：这与iOS项目相同；添加Xamarin Component Store组件的地方。'
- en: 'The `Assets` folder: This directory will contain files with a `build` action
    of `AndroidAsset`. This folder will contain raw files to be bundled with an Android
    application.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets`文件夹：此目录将包含具有`AndroidAsset`构建操作的文件。此文件夹将包含与Android应用程序捆绑的原始文件。'
- en: 'The `Properties/AndroidManifest.xml` file: This file contains standard declarations
    about your Android applications, such as the application name, ID, and permissions.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Properties/AndroidManifest.xml`文件：此文件包含有关您的Android应用程序的标准声明，例如应用程序名称、ID和权限。'
- en: 'The `Resources` folder: Resources are images, layouts, strings, and so on that
    can be loaded via Android''s resource system. Each file will have an ID generated
    in `Resources.designer.cs` that you can use to load the resource.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources`文件夹：资源包括图像、布局、字符串等，可以通过Android的资源系统加载。每个文件都会在`Resources.designer.cs`中生成一个ID，你可以使用它来加载资源。'
- en: 'The `Resources/drawable` folder: Any images used by your application are generally
    placed here.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources/drawable` 文件夹：你的应用程序使用的任何图像通常都放在这里。'
- en: 'The `Resources/layout` folder: This contains any `*.axml` (Android XML) files
    that Android uses to declare UIs. Layouts can be used for an entire **activity**,
    **fragment**, **dialog**, or **child control** to be displayed on the screen.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources/layout` 文件夹：这个文件夹包含 Android 使用来声明 UI 的任何 `*.axml`（Android XML）文件。布局可以用于整个
    **activity**、**fragment**、**dialog** 或 **child control** 在屏幕上显示。'
- en: 'The `Resources/values` folder: This contains XML files to declare key-value
    pairs for strings (and other types) throughout an application. This is how localization
    for multiple languages is normally set up on Android.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources/values` 文件夹：这个文件夹包含 XML 文件，用于在应用程序中声明字符串（和其他类型）的关键值对。这是在 Android
    上设置多语言本地化的常规方法。'
- en: 'The `MainActivity.cs` file: This is the `MainLauncher` action and the first
    activityof your Android application. There is no `static void Main` function in
    Android apps; execution begins on the activity that has `MainLauncher` set to
    `true`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainActivity.cs` 文件：这是 `MainLauncher` 动作和你的 Android 应用程序的第一个活动。在 Android 应用程序中没有
    `static void Main` 函数；执行从设置为 `true` 的 `MainLauncher` 活动开始。'
- en: 'Now let''s perform the following steps to run the application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行以下步骤来运行应用程序：
- en: Click on the play button to compile and run the application.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放按钮来编译和运行应用程序。
- en: A **Select Device** dialog will appear.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个 **选择设备** 对话框。
- en: Select the emulator of your choice and click on **Start Emulator**. If you have
    set up the x86 emulator in [Chapter 1](part0014_split_000.html#page "Chapter 1. Setting
    Up Xamarin"), *Setting Up Xamarin*, I would recommend that you use it.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要的模拟器并点击 **启动模拟器**。如果你在 [第 1 章](part0014_split_000.html#page "第 1 章。设置 Xamarin")
    中设置了 x86 模拟器，*设置 Xamarin*，我建议你使用它。
- en: Wait a few seconds for the emulator to start. Once it starts, it is a good idea
    to leave it running as long as you are working on an Android project. This will
    save you a good deal of time waiting.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，让模拟器启动。一旦启动，如果你正在处理 Android 项目，让它一直运行是个好主意。这将节省你大量等待的时间。
- en: You should see the emulator now enabled in the list of devices; select it, and
    click on **OK**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该能在设备列表中看到启用的模拟器；选择它，然后点击 **确定**。
- en: The very first time you deploy to an emulator or device, Xamarin Studio will
    have to install a few things such as the Mono shared runtime and Android platform
    tools.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一次将应用程序部署到模拟器或设备时，Xamarin Studio 将必须安装一些东西，例如 Mono 共享运行时和 Android 平台工具。
- en: Switch over to the Android emulator and your application will appear.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Android 模拟器，你的应用程序将显示出来。
- en: 'When all is done, you have deployed your first Android application, complete
    with a single button. Your app will look like what is shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切完成后，你已经部署了你的第一个 Android 应用程序，包含一个单按钮。你的应用将看起来像以下截图所示：
- en: '![Building your first Android application](img/00019.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![构建你的第一个 Android 应用程序](img/00019.jpeg)'
- en: Android activities
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 活动
- en: The Android operating system is very focused on the concept of an activity.
    An activity is a task or unit of work that users can perform on their screen.
    For example, users would perform a phone **activity** to dial a number and carry
    out a second activity that involves interacting with their address book to locate
    the number. Each Android application is a collection of one or more activities
    that users can launch and press the hardware's back key on their device to exit
    or cancel. The user's history is kept in the Android **back stack**, which you
    can manipulate from code in special cases. When a new activity starts, the previous
    one is paused and maintained in memory for later use, unless the operating system
    is running low on memory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Android 操作系统非常关注活动这个概念。活动是用户可以在其屏幕上执行的任务或工作单元。例如，用户会执行一个电话 **activity** 来拨号，并执行第二个涉及与他们的地址簿交互以定位号码的活动。每个
    Android 应用程序都是由一个或多个活动组成的集合，用户可以启动它们，并在设备上按下硬件的返回键来退出或取消。用户的历史记录保存在 Android **back
    stack** 中，你可以在特殊情况下从代码中操作它。当一个新的活动开始时，前一个活动会被暂停并保存在内存中，以供以后使用，除非操作系统内存不足。
- en: Activities are loosely coupled with each other; in some ways, you can think
    of them as having completely separate states from one another in memory. Static
    values will persist the life of the application as in .NET applications, but the
    common practice is to pass a state through an Android **bundle**. An Android bundle
    is a set of key-value pairs used to pass data from one Android object to another.
    This is useful to pass an identifier for an item displayed in a list to edit that
    item in a new activity.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 活动之间是松散耦合的；在某种程度上，你可以将它们视为在内存中具有完全独立的状态。静态值将持久化应用程序的生命周期，就像.NET应用程序一样，但常见的做法是通过Android
    **bundle**传递状态。Android bundle是一组键值对，用于在Android对象之间传递数据。这对于传递列表中显示的项目的标识符以在新活动中编辑该项目非常有用。
- en: 'Activities have the following lifecycle callback methods that you can override:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 活动有以下生命周期回调方法，你可以重写它们：
- en: '`OnCreate`: This is the first method called when your activity is created.
    Set up your views and perform other loading logic here. Most importantly, you
    will call `SetContentView` here to set up your activity''s view.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCreate`: 这是创建活动时首先调用的方法。在这里设置你的视图并执行其他加载逻辑。最重要的是，你将在这里调用`SetContentView`来设置活动的视图。'
- en: '`OnResume`: This is called when your activity''s view is visible on the screen.
    It is called if your activity is displayed for the first time, and when the user
    returns to it from another activity.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnResume`: 当你的活动视图在屏幕上可见时会被调用。如果活动首次显示，或者用户从另一个活动返回时，都会调用此方法。'
- en: '`OnPause`: This is called to notify that the user has left your activity. It
    can happen prior to navigating to a new activity within your app, locking the
    screen, or hitting the home button. Assume that the user might not return, so
    you need to save any changes the user made here.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPause`: 当用户离开你的活动时会被调用。它可能发生在导航到应用中的新活动之前、锁定屏幕或按home按钮时。假设用户可能不会返回，因此你需要在这里保存用户所做的任何更改。'
- en: '`OnStart`: This occurs immediately before `OnResume` when the activity''s view
    is about to be displayed on the screen. It occurs when an activity starts and
    when a user returns to it from another activity.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStart`: 这发生在`OnResume`之前，当活动的视图即将在屏幕上显示时。它发生在活动启动时，以及用户从另一个活动返回时。'
- en: '`OnStop`: This occurs immediately after `OnPause` when the activity''s view
    is no longer displayed on the screen.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStop`: 这发生在`OnPause`之后，当活动的视图不再显示在屏幕上时。'
- en: '`OnRestart`: This method occurs when the user returns to your activity from
    a previous activity.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnRestart`: 当用户从先前活动返回到你的活动时，此方法发生。'
- en: '`OnActivityResult`: This method is used to communicate with other activities
    in other applications on Android. It is used in conjunction with `StartActvityForResult`;
    for example, you will use this to interact with the Facebook application to log
    in a user.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActivityResult`: 此方法用于与Android上其他应用程序中的其他活动进行通信。它与`StartActvityForResult`一起使用；例如，你将使用此方法与Facebook应用程序交互以登录用户。'
- en: '`OnDestroy`: This is called when your activity is about to be freed from memory.
    Perform any additional cleanup that could help the operating system here, such
    as disposing of any other heavyweight objects the activity was using.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy`: 当你的活动即将从内存中释放时会被调用。在这里执行任何可能帮助操作系统的额外清理工作，例如处理活动使用过的任何其他重量级对象。'
- en: 'A flowchart of the Android lifecycle is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Android生命周期的流程图如下：
- en: '![Android activities](img/00020.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Android活动](img/00020.jpeg)'
- en: Unlike iOS, Android does not enforce any design patterns upon its developers.
    However, it is not possible to get away without understanding the Android activity
    lifecycle to some degree. Many concepts with activities are parallel to controllers
    on iOS; for example, `OnStart` is equivalent to `ViewWillAppear` and `OnResume`
    is equivalent to `ViewDidAppear`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS不同，Android不会对其开发者强制执行任何设计模式。然而，在一定程度上理解Android活动生命周期是不可避免的。许多与活动相关的概念与iOS中的控制器平行；例如，`OnStart`相当于`ViewWillAppear`，而`OnResume`相当于`ViewDidAppear`。
- en: 'Other methods for working with activities are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其他处理活动的方法如下：
- en: '`StartActivity(Type type)`: This method starts a new activity within your application
    and passes no extra information to the activity.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartActivity(Type type)`: 此方法在应用内启动一个新的活动，并传递没有额外信息给活动。'
- en: '`StartActivity(Intent intent)`: This is an overload method to start a new activity
    with `Intent`. This gives you the ability to pass additional information to the
    new activity, and you can also launch activities in other applications.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartActivity(Intent intent)`：这是一个重载方法，用于使用`Intent`启动新的活动。这让你能够向新活动传递额外的信息，你也可以在其他应用程序中启动活动。'
- en: '`StartActivityForResult`: This method starts a new activity with the anticipation
    of receiving `OnActivityResult` when the activity''s operation is completed.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartActivityForResult`：此方法在活动操作完成后预期接收`OnActivityResult`。'
- en: '`Finish`: This will close the current activity and invoke `OnDestroy` when
    it is completely closed and no longer displayed on the screen. Depending on what
    is currently on the back stack, the user will return to a previous activity or
    the home screen.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Finish`：这将关闭当前活动，并在活动完全关闭且不再显示在屏幕上时调用`OnDestroy`。根据当前后台栈中的内容，用户将返回到先前的活动或主屏幕。'
- en: '`SetContentView`: This method sets the primary view to be displayed for an
    activity. It should be called within the `OnCreate` method prior to the activity
    being displayed on the screen.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetContentView`：此方法设置要显示的活动的主视图。它应该在活动显示在屏幕上之前，在`OnCreate`方法中调用。'
- en: '`FindViewById`: This is a method to locate the view displayed in your activity.
    It has a generic version to return a view of the appropriate type.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindViewById`：这是一个用于定位活动显示的视图的方法。它有一个泛型版本，可以返回适当类型的视图。'
- en: You can think of `intent` as an object that describes the transition from one
    activity to another. You can pass additional data through intents as well as modify
    how the activity is displayed and the user's navigation history.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`intent`视为一个描述从活动到活动过渡的对象。你还可以通过intent传递额外的数据以及修改活动的显示和用户的导航历史。
- en: In addition to activities, Android has the concept of a fragment. You can think
    of a fragment to be a miniature activity that is displayed inside a parent activity.
    Fragments are useful for reusing different pieces of a UI throughout your apps
    and can also help you implement split screen navigation on tablets.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了活动之外，Android还有片段的概念。你可以将片段视为在父活动内部显示的微型活动。片段对于在应用程序中重用UI的不同部分非常有用，还可以帮助你实现平板电脑上的分屏导航。
- en: Xamarin's Android designer
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin的Android设计器
- en: The default template for Android projects has a little more built-in functionality
    than iOS. Android user interface layouts are defined in XML files that are readable
    by humans and editable. However, Xamarin Studio has provided an excellent design
    tool that allows you to drag and drop controls to define your Android layouts.
    Let's add some more features to your application and start using the Android designer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Android项目的默认模板比iOS有更多的内置功能。Android用户界面布局定义在人类可读和可编辑的XML文件中。然而，Xamarin Studio提供了一个优秀的设计工具，允许你拖放控件来定义你的Android布局。让我们给你的应用程序添加更多功能并开始使用Android设计器。
- en: 'Return to Xamarin Studio and carry out the following steps to add features
    to your app:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Xamarin Studio并执行以下步骤以添加应用程序功能：
- en: Open the Android project you created earlier in this chapter in Xamarin Studio.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中打开本章中创建的Android项目。
- en: Navigate to **Resources** | **layout** in your project and open `Main.axml`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目中的**资源** | **布局**，并打开`Main.axml`。
- en: You will see the Android designer open in Xamarin Studio.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到Android设计器在Xamarin Studio中打开。
- en: Drag **TextView** from the **Toolbox** section on the right to the layout just
    above the button labeled **Hello World, Click Me!**
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右侧的**工具箱**部分拖动**TextView**到按钮**Hello World, Click Me!**上方的布局中。
- en: 'Type some default text such as `Count: 0` into the label.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签中输入一些默认文本，例如`计数：0`。
- en: In the **Properties** pane on the right, you'll see the **id** value is set
    to `@+id/textView1`. Let's change it to `@+id/myText`, in order to be consistent
    with the button.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的**属性**面板中，你会看到**id**值设置为`@+id/textView1`。让我们将其更改为`@+id/myText`，以便与按钮保持一致。
- en: While we're here, go ahead and change the text on the button to something more
    appropriate such as `Add`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在这里时，请将按钮上的文本更改为更合适的内容，例如`添加`。
- en: Click on the play button to compile and run the application. If you still have
    the Android emulator, you can simply switch to it. Otherwise, you will have to
    start it again.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放按钮来编译并运行应用程序。如果你仍然有安卓模拟器，你可以直接切换到它。否则，你将需要重新启动它。
- en: 'Your Android application will now look identical to the changes you made in
    the designer as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Android应用程序现在将看起来与您在设计师中做出的更改完全相同，如下所示：
- en: '![Xamarin''s Android designer](img/00021.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin的Android设计师](img/00021.jpeg)'
- en: Now, let's interact with the new label from the code. Switch back to Xamarin
    Studio and open `MainActivity.cs`. Let's modify the activity to interact with
    the **TextView** field instead of the button. We use the `FindViewById` method
    to retrieve a view by the ID we set up in the layout file. Xamarin Studio has
    also auto-generated a static class named `Resource` to reference your identifiers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从代码中与新的标签进行交互。切换回Xamarin Studio并打开`MainActivity.cs`。让我们修改活动以与**TextView**字段而不是按钮进行交互。我们使用`FindViewById`方法通过在布局文件中设置的ID检索视图。Xamarin
    Studio还自动生成一个名为`Resource`的静态类来引用您的标识符。
- en: 'So let''s retrieve the instance of the **TextView** field by placing this code
    in `OnCreate` as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过在`OnCreate`中放置以下代码来检索**TextView**字段的实例：
- en: '[PRE3]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Resource` class is a static class that the Xamarin designer will populate
    for you. For future reference, you might have to build your Android project for
    new IDs and other resources to show up in your C# files in Xamarin Studio.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resource`类是一个Xamarin设计师将为您填充的静态类。为了将来参考，您可能需要构建您的Android项目以显示新ID和其他资源在Xamarin
    Studio中的C#文件中。'
- en: 'Next, let''s update the `Click` event on the button:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新按钮上的`Click`事件：
- en: '[PRE4]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will rewire the button to update the text in **TextView** instead of on
    the button itself. Now if we run the application, we''ll get an Android app that
    functions identically to the iOS one in the previous chapter. The Android app
    will look like what is shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新连接按钮以更新**TextView**中的文本而不是按钮本身。现在如果我们运行应用程序，我们将得到一个与上一章中iOS应用程序功能相同的Android应用程序。Android应用程序的外观如下截图所示：
- en: '![Xamarin''s Android designer](img/00022.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin的Android设计师](img/00022.jpeg)'
- en: Since we added some of our own views to our layout, let's add a second activity
    to build on our understanding of activities in Android.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在布局中添加了一些自己的视图，让我们添加一个第二个活动来加深我们对Android中活动理解的认识。
- en: 'Return to Xamarin Studio and perform the following steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Xamarin Studio并执行以下步骤：
- en: If needed, open the Android project you created earlier in the chapter in Xamarin
    Studio.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，请在Xamarin Studio中打开本章中创建的早期Android项目。
- en: Create a new Android activity in the project under the **Android** section.
    Name it `SecondActivity.cs`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Android**部分的项目中创建一个新的Android活动。命名为`SecondActivity.cs`。
- en: Navigate to **Resources** | **layouts**, and create a new Android layout named
    `Second.axml`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**资源** | **布局**，并创建一个名为`Second.axml`的新Android布局。
- en: 'Open `SecondActivity.cs` and add the following code to `OnCreate`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SecondActivity.cs`并在`OnCreate`中添加以下代码：
- en: '[PRE5]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open `MainActivity.cs` and add the following line of code to the `Click` event
    of your button:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.cs`并在按钮的`Click`事件中添加以下代码行：
- en: '[PRE6]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open `Second.axml` and drag a button into the view. Set its text to `Finish`,
    for example, and set its ID to `@+id/finish`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Second.axml`并将一个按钮拖入视图。将其文本设置为`Finish`，例如，并将其ID设置为`@+id/finish`。
- en: 'Finally, open `SecondActivity.cs` and add the following lines to its `OnCreate`
    method:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`SecondActivity.cs`并在其`OnCreate`方法中添加以下行：
- en: '[PRE7]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Build and run your application.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行您的应用程序。
- en: 'Your application''s button will now launch a new activity in addition to incrementing
    the count on the label. Once `SecondActivity` is visible, you can click on its
    button to finish the activity and return to the first activity. Down the road,
    if you need to pass information from one activity to another, you will need to
    create an `Intent` object to pass to `StartActivity`. The second activity of your
    app is shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序按钮现在除了在标签上增加计数外，还会启动一个新的活动。一旦`SecondActivity`可见，您就可以点击其按钮来结束活动并返回第一个活动。将来，如果您需要从一个活动传递信息到另一个活动，您将需要创建一个`Intent`对象并将其传递给`StartActivity`。您的应用程序的第二个活动如下截图所示：
- en: '![Xamarin''s Android designer](img/00023.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin的Android设计师](img/00023.jpeg)'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created our first iOS application in Xamarin Studio. We
    covered Apple's MVC design pattern to better understand the relationship between
    `UIViewController` and `UIView` and also covered how to use the iOS designer in
    Xamarin Studio to edit storyboard files. Next, we created our first Android application
    in Xamarin Studio and learned the activity lifecycle in Android. We also used
    Xamarin's Android designer to make changes to Android XML layouts.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在Xamarin Studio中创建了我们的第一个iOS应用程序。我们介绍了苹果的MVC设计模式，以便更好地理解`UIViewController`和`UIView`之间的关系，并介绍了如何在Xamarin
    Studio中使用iOS设计器来编辑storyboard文件。接下来，我们在Xamarin Studio中创建了我们的第一个Android应用程序，并学习了Android的活动生命周期。我们还使用了Xamarin的Android设计器来修改Android
    XML布局。
- en: From the topics covered in this chapter, you should be fairly confident in developing
    simple apps for iOS and Android using Xamarin's tools. You should have a basic
    understanding of the native SDKs and design patterns to accomplish tasks on iOS
    and Android.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章涵盖的主题来看，你应该对使用Xamarin的工具开发iOS和Android的简单应用程序有足够的信心。你应该对原生SDKs和设计模式有基本的了解，以便在iOS和Android上完成任务。
- en: In the next chapter, we'll cover various techniques used to share code across
    platforms with Xamarin Studio. We'll go over different ways of architecting your
    cross-platform application and how to set up Xamarin Studio projects and solutions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍使用Xamarin Studio在平台间共享代码的各种技术。我们将探讨不同的跨平台应用程序架构方式，以及如何设置Xamarin Studio项目和解决方案。
