<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>12. Reactive Programming Using .NET Rx Extensions</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;12.&#160;Reactive Programming Using .NET Rx Extensions">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch12"></a>Chapter&#160;12.&#160;Reactive Programming Using .NET Rx Extensions</h1>
            </div>
          </div>
        </div>
        <p>In the previous chapter, we saw how reactive programming shapes you up for scalability and responsiveness. We saw how these two attributes are supported in event-driven applications that enable it to readily respond to events, failures, and loads.</p>
        <p>Now in this chapter we will:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Take a deep dive into the Reactive Extensions (Rx) library and see how we write asynchronous and event-driven programs using observable sequences and LINQ query operators</li>
            <li class="listitem" style="list-style-type: disc">We will also take a detailed look at some sample use cases and their implementations with Rx to clearly understand how Observables, LINQ, and Schedulers in the .NET Framework are leveraged to create concurrent and responsive applications that can work with asynchronous data streams</li>
          </ul>
        </div>
        <p>By the end of this chapter, you will understand&#160;why Rx has been touted as the next big thing, and one that will become the de facto event-driven programming model, gaining traction and acceptance in various mainstream programming languages.</p>
        <div class="section" title="Streams as a way of life">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch12lvl1sec87"></a>Streams as a way of life</h1>
              </div>
            </div>
          </div>
          <p>As you saw in the previous chapter, the fundamental success to reactive programs is to convert events into immutable and observable streams. Program composition becomes very easy and intuitive with this format, and you can create a unifying interface using the .NET Rx extensions.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note53"></a>Note</h3>
              <p>This is really important to understand, as wielding a hammer like Rx doesn't make you Thor. You don't necessarily start seeing every single implementation as a nail and drive your hammer down on it. As Uncle Ben once advised Peter aka Spiderman - "With great power comes great responsibility".</p>
            </div>
          </div>
          <p>Let's understand this more by looking at the palette of options available, and making sound decisions on what can be done. Consider the following image:</p>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/image_12_001.jpg" alt="Streams as a way of life"/>
          </div>
          <p>
</p>
          <p>As you can see in the preceding figure, in terms of unifying the worlds, Rx brings forth bridges that help you work seamlessly across these programming models. To quickly recap what we read in <a class="link" href="dn-dsnptn_ch11.html" title="Chapter&#160;11.&#160;What is Reactive Programming?">Chapter 11</a>, <span class="emphasis"><em>What is Reactive Programming?</em></span>, take a look at the following table:</p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col/>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
<p>
<span class="strong"><strong>Factory methods</strong></span>
</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Unfold methods</strong></span>
</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Bridges</strong></span>
</p>
</td>
                </tr>
                <tr>
                  <td>
<p>
</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Return</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Empty</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Never</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Throw</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Create</code></li>
</ul>
</div>
<p>
</p>
</td>
                  <td>
<p>
</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Range</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Interval</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Timer</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Generate</code></li>
</ul>
</div>
<p>
</p>
</td>
                  <td>
<p>
</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Start</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.FromEventPattern</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Task.ToObservable</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Task&lt;T&gt;.ToObservable</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">IEnumerable&lt;T&gt;.ToObservable</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Observable.FromAsyncPattern</code></li>
</ul>
</div>
<p>
</p>
</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>As reiterated earlier, we don't replace existing asynchrony. The .NET events, async methods, tasks, and so on, have their use and are perfect in their own worlds.</p>
          <p>Rx just becomes the glue to unify these worlds, provides compositionality, and helps build bridges.</p>
          <p>Now, let's get started on some examples that will help us understand how to put Rx to best use in our day-to-day programming. Only certain pragmatic aspects are highlighted leveraging key constructs in Rx, as complete coverage warrants another book in its own size.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Spell checker using events composition">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch12lvl1sec88"></a>Spell checker using events composition</h1>
            </div>
          </div>
        </div>
        <p>This first example is a Windows application that integrates the previously implemented spell checker (from <a class="link" href="dn-dsnptn_ch09.html" title="Chapter&#160;9.&#160;Functional Programming Techniques for Better State Management">Chapter 9</a>, <span class="emphasis"><em>Functional Programming Techniques for Better State</em></span>
<span class="emphasis"><em>Management</em></span>) using Rx, and explores how this can be leveraged to suggest alternatives and corrections. Consider the following code snippet:</p>
        <pre class="programlisting">    static void Main() 
    { 
        ObservableEventsDemo(); 
    }  
</pre>
        <p>Initialize your input from here, with some basic controls that we will need, that is, a text box (used for keyword search) and a list box that provides suggestions/corrections for a given keyword. Take a look at the following code snippet:</p>
        <pre class="programlisting">&#160;   static void ObservableEventsDemo()
    {  
       // Input form

      var txtBoxSpellCorrect = new TextBox(); 
      var lstBoxSuggestions = new ListBox {
        Top = txtBoxSpellCorrect.Height + 10 }; 
      var frmSpellChecker = new Form { Controls = { txtBoxSpellCorrect,
        lstBoxSuggestions } }; 
</pre>
        <p>Now, we will need to create a <code class="literal">DispatcherScheduler</code> that schedules units of work on the dispatcher of the current UI thread. The delegate <code class="literal">onInputChange</code> is created to clear the suggestions in the list box whenever the input keyword changes. Consider the following code snippet:</p>
        <pre class="programlisting">    // Dispatcher scheduler for the UI thread

    var <span class="strong"><strong>_dispatcher</strong></span> = new DispatcherScheduler(
      System.Windows.Threading.Dispatcher.CurrentDispatcher); 
 
    Action&lt;string&gt; <span class="strong"><strong>onInputChange</strong></span> = word =&gt; 
    { 
        lstBoxSuggestions.Items.Clear(); 
        Console.WriteLine("Word Changed: " + word); 
    }; 
</pre>
        <p>We will define an observable stream/sequence on the input based by subscribing to the <code class="literal">TextChanged</code> event of the text box using the <code class="literal">FromEventPattern</code> bridge. We will further filter the input stream based on minimum characters (three, in this case) and distinct entries (helps us throttle the lookup frequency). A valid output from this input sequence will trigger the delegate that clears the list box contents and gets it ready to receive a new set of suggestions as and when they are available. Consider the following code snippet:</p>
        <pre class="programlisting">    var <span class="strong"><strong>input</strong></span> = Observable 
      <span class="strong"><strong>.FromEventPattern(txtBoxSpellCorrect, "TextChanged")</strong></span> 
      .Select(evt =&gt; ((TextBox)evt.Sender).Text) 
      .Timestamp().Select(evt =&gt; evt.Value) 
      .Where(evt =&gt; evt.Length &gt; 3) 
      .DistinctUntilChanged() 
      .Do(<span class="strong"><strong>onInputChange</strong></span>); 
</pre>
        <p>This defines the second observable sequence that fetches suggestions based on the first sequence (keyword) we defined in the preceding code:</p>
        <pre class="programlisting">    Func&lt;string, IObservable&lt;string&gt;&gt; <span class="strong"><strong>matches</strong></span> =
      searchText =&gt; NorvigSpellCheckerModel.
        Instance.SpellCheck(searchText, 5).ToObservable&lt;string&gt;(); 
 
</pre>
        <p>This is an important step where we declaratively specify to continue fetching suggestions until the keyword changes (the first observable sequence for us here). If you notice, this is done here using the <code class="literal">TakeUntil</code> operator:</p>
        <pre class="programlisting">    var result = from term in <span class="strong"><strong>input</strong></span> 
      from words in <span class="strong"><strong>matches</strong></span>(term)
      .TakeUntil(input)
      .Finally(() =&gt; 
      { 
         Console.WriteLine("Disposed Lookup For: " + term); 
      }) 
     select words; 
 
</pre>
        <p>We will then define delegates (<code class="literal">onEachSuggest</code>, <code class="literal">onSuggestError</code>, and <code class="literal">onSuggestComplete</code>) for the <code class="literal">Subscribe</code> method to receive push-based notifications, as shown in the following piece of code (<code class="literal">onEachSuggest</code> tend to add received suggestions to the list box as and when they are received):</p>
        <pre class="programlisting">    Action&lt;string&gt; <span class="strong"><strong>OnEachSuggest</strong></span> = word =&gt; 
    { 
        lstBoxSuggestions.Items.Add(word); 
        Console.WriteLine("Match: " + word); 
    }; 
 
    Action&lt;Exception&gt; <span class="strong"><strong>OnSuggestError</strong></span> = ex =&gt; 
    { 
        Console.WriteLine("Error: " + ex.Message); 
    }; 
 
    Action <span class="strong"><strong>OnSuggestComplete</strong></span> = () =&gt; 
    { 
        lstBoxSuggestions.Items.Clear(); 
        Console.WriteLine("Suggestion Complete!!!"); 
    };  
</pre>
        <p>This is the final step where we will specify to observe on the dispatcher of the UI thread (it is absolutely critical for you to make the necessary UI updates) and subscribe on the default task scheduler instance (Rx will decide one for you based on the principle of least concurrency). Consider the following code snippet:</p>
        <pre class="programlisting">    using (result.OnErrorResumeNext(
      Observable.Empty&lt;string&gt;()) 
      .ObserveOn(_dispatcher) 
      .SubscribeOn(Scheduler.Default) 
      .Subscribe(
<span class="strong"><strong>          OnEachSuggest,
          OnSuggestError, 
          OnSuggestComplete</strong></span>))                 
    Application.Run(frmSpellChecker); 
    }
</pre>
        <p>Let's quickly see the supporting Model code (refactored the earlier <code class="literal">NorvigSpellChecker</code> code to make it a singleton and implement the <code class="literal">ISpellCheckerModel</code> interface) as well. This interface helps in returning the results as an enumerable list, which can further be converted to an observable sequence. Lets take a look at the following code snippet:</p>
        <pre class="programlisting">    public interface <span class="strong"><strong>ISpellCheckerModel</strong></span> 
    { 
        IEnumerable&lt;string&gt; SpellCheck(string word, int count); 
    }  
</pre>
        <p>This is the old code from <a class="link" href="dn-dsnptn_ch09.html" title="Chapter&#160;9.&#160;Functional Programming Techniques for Better State Management">Chapter 9</a>, <span class="emphasis"><em>Functional Programming Techniques for Better State Management</em></span>, based on Peter Norvig's post: <a class="ulink" href="http://norvig.com/spell-correct.html">http://norvig.com/spell-correct.html</a>, modified to become a singleton. Consider the following code snippet:</p>
        <pre class="programlisting">    public sealed class NorvigSpellCheckerModel : <span class="strong"><strong>ISpellCheckerModel</strong></span> 
    { 
        <span class="strong"><strong>private static readonly Lazy&lt;NorvigSpellCheckerModel&gt;</strong></span>
        spellCheckerInstance = new Lazy&lt;NorvigSpellCheckerModel&gt;(() =&gt; 
          new NorvigSpellCheckerModel()); 
         
        private NorvigSpellCheckerModel() 
        { 
            //......... USE CODE FROM CHAPTER 9 HERE 
        } 
 
        public static NorvigSpellCheckerModel <span class="strong"><strong>Instance</strong></span> 
        { 
            get 
            { 
                return spellCheckerInstance.Value; 
            } 
        } 
 
        public IEnumerable&lt;string&gt; <span class="strong"><strong>SpellCheck</strong></span>(string word, int count) 
        { 
            //......... USE CODE FROM CHAPTER 9 HERE 
        } 
    } 
 
</pre>
        <p>Some key things to notice here are:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">The use of the <code class="literal">FromEventPattern</code> bridge to subscribe to the <code class="literal">TextChanged</code> event</li>
            <li class="listitem" style="list-style-type: disc">The classic use case for a Singleton (to prevent Training Model corpus creation repeatedly every time a word is looked up) to create and cache the dictionary for future use</li>
            <li class="listitem" style="list-style-type: disc">It will be worthwhile to take a look at the Singleton implementation that has leveraged .NET 4's <code class="literal">Lazy&lt;T&gt;</code> type for thread safety, lazy instantiation, and not resorting to the conventional double-check locking idiom, where explicit locking is used</li>
            <li class="listitem" style="list-style-type: disc">The use of the <code class="literal">Where</code> and <code class="literal">DistinctUntilChanged</code> operators to restrict lookup for unique four letter words and beyond</li>
          </ul>
        </div>
        <p>The screenshots of our spell checker in action are shown as follows:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/image_12_002.jpg" alt="Spell checker using events composition"/>
        </div>
        <p>
</p>
        <p>The supporting console helps you understand the sequence of actions behind the scenes, as shown in the following screenshot:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/image_12_003.jpg" alt="Spell checker using events composition"/>
        </div>
        <p>
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="MVVM on Rx">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch12lvl1sec89"></a>MVVM on Rx</h1>
            </div>
          </div>
        </div>
        <p>Now, let's convert the preceding example to see how we can apply this for a classic MVVM implementation.
</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note54"></a>Note</h3>
            <p>MVVM is an important application development framework that has its roots with <span class="strong"><strong>Windows Presentation Framework</strong></span> (<span class="strong"><strong>WPF</strong></span>). It is best suited for event-driven programming where you achieve clear <span class="strong"><strong>Separation of Concerns</strong></span>, thereby facilitating parallel development (Model, View, and View Model) and testability.</p>
          </div>
        </div>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/image_12_004.jpg" alt="MVVM on Rx"/>
        </div>
        <p>
</p>
        <p>As you observe (no pun intended) in the preceding solution model, the <code class="literal">TextChanged</code> event of the text box, where the word to be looked up is entered, will indicate to the <code class="literal">ISubject&lt;T&gt;</code> type here, one that implements both <code class="literal">IObservable&lt;T&gt;</code> and <code class="literal">IObserver&lt;T&gt;</code> interfaces, thereby enabling you to conveniently observe and publish items to subscribers.</p>
        <p>Ensure that you have the appropriate dependencies/packages installed via the&#160;<span class="strong"><strong>NuGet</strong></span> package manager and referenced properly. The ones under consideration here include the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">
              <code class="literal">System.Reactive.Core</code>
            </li>
            <li class="listitem" style="list-style-type: disc">
              <code class="literal">System.Reactive.Interfaces</code>
            </li>
            <li class="listitem" style="list-style-type: disc">
              <code class="literal">System.Reactive.Linq</code>
            </li>
            <li class="listitem" style="list-style-type: disc">
              <code class="literal">System.Reactive.PlatformServices</code>
            </li>
            <li class="listitem" style="list-style-type: disc">
              <code class="literal">System.Reactive.Windows.Threading</code>
            </li>
          </ul>
        </div>
        <p>The code for the View layer is shown as follows. Take note (highlighted) of the data binding with the corresponding view model:</p>
        <pre class="programlisting">    public partial class frmSpellChecker : Form 
    { 
        private SpellCheckerViewModel _spellCheckerViewModel; 
        public frmSpellChecker() 
        { 
            InitializeComponent(); 
            _spellCheckerViewModel = new 
            SpellCheckerViewModel(NorvigSpellCheckerModel.Instance); 
            //Data Binding Is Done Here 
            <span class="strong"><strong>lstBoxSuggestions.DataSource = 
              _spellCheckerViewModel.Corrections;</strong></span>         
        } 
 
        private void txtBoxSpellCorrect_TextChanged(
          object sender, EventArgs e) 
        {
           _spellCheckerViewModel.SearchChanges(((TextBox)sender).Text); 
        } 
    } 
 
</pre>
        <p>As you can see, an instance of View Model is created and the Model (code in reference is the same one used for the earlier example) instance is specified. The text changes are routed to the subject in View Model through the <code class="literal">TextChanged</code> event. Synchronization, with respect to the data bindings, (against the suggestion list box), happens automatically through property change notifications from View Model, which happens to implement the <code class="literal">INotifyPropertyChanged</code> interface. The data source for the bindings is retained in the View Model. Let's take a look at the View Model now:</p>
        <pre class="programlisting">    class SpellCheckerViewModel : INotifyPropertyChanged 
    { 
        private BindingList&lt;string&gt; _corrections; 
        private ISpellCheckerModel _spellChecker; 
        private ISubject&lt;string&gt; _searchChanged; 
        private IScheduler _dispatcher; 
        public event PropertyChangedEventHandler PropertyChanged; 
         
    public BindingList&lt;string&gt; Corrections 
    { 
        get 
        { 
            return this._corrections; 
        } 
 
        set 
        { 
            if (value != this._corrections) 
            { 
                this._corrections = value; 
                <span class="strong"><strong>NotifyPropertyChanged();</strong></span> 
            } 
        } 
    } 
 
</pre>
        <p>Here, we will use the <code class="literal">CallerMemberName</code> attribute to avoid specifying the member name as a string argument to the called method:</p>
        <pre class="programlisting"><span class="strong"><strong>    private void NotifyPropertyChanged([CallerMemberName]
    String propertyName = "")</strong></span> 
    { 
        if (PropertyChanged != null) 
        { 
            this.PropertyChanged(this, 
              new PropertyChangedEventArgs(propertyName)); 
        } 
    } 
 
    public void SearchChanges(string text) 
    { 
        _searchChanged.OnNext(text); 
    } 
 
    public ISubject&lt;string&gt; <span class="strong"><strong>SearchChanged</strong></span> 
    { 
        get 
        { 
            return _searchChanged; 
        } 
    } 
 
    public SpellCheckerViewModel(ISpellCheckerModel spellChecker) 
    { 
        _spellChecker = spellChecker; 
        _dispatcher = new DispatcherScheduler(
          System.Windows.Threading.Dispatcher.CurrentDispatcher); 
        _corrections = new BindingList&lt;string&gt;(); 
        _searchChanged = new Subject&lt;string&gt;(); 
        Func&lt;string, IObservable&lt;string&gt;&gt; <span class="strong"><strong>GetSuggestions</strong></span> = (searchText) =&gt; 
        { 
            IsProcessing = true; 
            Corrections.Clear(); 
            Error = null; 
            <span class="strong"><strong>return _spellChecker.SpellCheck(searchText, 5)
              .ToObservable&lt;string&gt;();</strong></span> 
        }; 
 
        var searches = this.SearchChanged.Select(<span class="strong"><strong>GetSuggestions</strong></span>); 
 
</pre>
        <p>Now, this final step provides the necessary magic in terms of:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Providing the most recent changes in the sequence (the <code class="literal">Switch</code> operator)</li>
            <li class="listitem" style="list-style-type: disc">Looking up suggestions for only four letter words and above (the <code class="literal">Where</code> operator)</li>
            <li class="listitem" style="list-style-type: disc">Looking up suggestions only if the new value entered is different from old (the <code class="literal">DistinctUntilChanged</code> operator)</li>
            <li class="listitem" style="list-style-type: disc">And, finally, looking up on a background thread using the schedulers task/thread pool and returning suggestions on the UI thread's dispatcher. Take a look at the following code snippet:</li>
          </ul>
        </div>
        <pre class="programlisting"><span class="strong"><strong>        searches</strong></span>.Switch() 
          .Where(s =&gt; s.Length &gt; 3) 
           .DistinctUntilChanged() 
           <span class="strong"><strong>.SubscribeOn</strong></span>(Scheduler.Default) 
           <span class="strong"><strong>.ObserveOn</strong></span>(_dispatcher) 
           .Subscribe(OnEachSuggest, OnSuggestError, 
             OnSuggestComplete); 
        } 
         
        private void OnEachSuggest(string searchText) 
        { 
            <span class="strong"><strong>Corrections.Add(searchText);</strong></span> 
        } 
    } 
 
</pre>
        <p>This View Model clearly shows how Observables, LINQ (<code class="literal">Where</code>&#160;and&#160;<code class="literal">DistinctUntilChanged</code>), and Schedulers are put to good practical use. As highlighted in the preceding code, the lookup, which is done on a background thread, lets the observer, in this case, the data source, that is, the <code class="literal">BindingList&lt;string&gt;</code>, know through property change notifications; thereby, triggering automatic content refresh in the <code class="literal">Suggestions</code> list box. Another thing to note is the adept usage of the <code class="literal">SubscribeOn</code>/<code class="literal">ObserveOn</code> pair to prevent blocking of UI thread and yet update UI objects on it.</p>
        <p>There are some key things to notice here:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">The use of <code class="literal">Switch</code> operator, in addition to the <code class="literal">Where</code> and <code class="literal">DistinctUntilChanged</code> operators, to ensure the liveliness in search in terms of showing the latest and relevant changes with respect to the sequence</li>
            <li class="listitem" style="list-style-type: disc">This will also serve as an example of the <span class="strong"><strong>Collection Pipeline</strong></span>&#160;pattern, where your computation becomes a sequence of operations by taking a collection/sequence from one operation and feeding to another</li>
          </ul>
        </div>
        <p>It leverages immutability, comprehensions (declarative query syntax in LINQ), laziness, and parallelism to achieve this.</p>
        <p>The screenshot of our spell checker in action is shown here:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/image_12_005.jpg" alt="MVVM on Rx"/>
        </div>
        <p>
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="An asynchronous logger">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch12lvl1sec90"></a>An asynchronous logger</h1>
            </div>
          </div>
        </div>
        <p>Logging and Audit trail is an important cross-cutting or horizontal concern in the day-to-day application that we create. There are various third-party tools that we leverage; and we have seen how to write one ourselves in depth in <a class="link" href="dn-dsnptn_ch03.html" title="Chapter&#160;3.&#160;A Logging Library">Chapter 3</a>, <span class="emphasis"><em>A Logging Library</em></span>. Here, we will see how to impart reactive behavior to a custom-logging component.</p>
        <p>We will use the same spell checker example in the preceding section and see how to integrate logging capability into the existing code base.</p>
        <p>We will start off by initializing the log collection as a <code class="literal">BindingList</code>, the same way we got the corrections/suggestions initialized:</p>
        <pre class="programlisting">    class SpellCheckerViewModel : INotifyPropertyChanged 
    { 
<span class="strong"><strong>        private BindingList&lt;string&gt; _logs;
</strong></span>
<span class="strong"><strong>        private ISubject&lt;string&gt; _logChanged;</strong></span> 
        public BindingList&lt;string&gt; Logs 
        { 
          get 
          { 
             return this._logs; 
          } 
 
          set 
          { 
             if (value != this._logs) 
             { 
                this._logs = value; 
                NotifyPropertyChanged(); 
             } 
           } 
        }   
 
</pre>
        <p>The following <code class="literal">AddToLog</code> method will be the generic logging method used to hand off the log text to the observer waiting on the <code class="literal">_logchanged</code> subject. You can see instrumentation code throughout the methods, shown as follows, for applicability and clarity:</p>
        <pre class="programlisting">    public void AddToLog(string text) 
    { 
        <span class="strong"><strong>_logChanged.OnNext(text);</strong></span> 
    } 
 
    public SpellCheckerViewModel(ISpellCheckerModel spellChecker) 
    { 
        <span class="strong"><strong>_logs = new BindingList&lt;string&gt;();
        _logChanged = new Subject&lt;string&gt;();</strong></span> 
 
        Func&lt;string, IObservable&lt;string&gt;&gt; GetSuggestions = (searchText) =&gt; 
        { 
            <span class="strong"><strong>AddToLog</strong></span>(string.Format("Searching for 
              suggestions : {0}", searchText)); 
            return _spellChecker.SpellCheck(searchText, 5)
              .ToObservable&lt;string&gt;(); 
        }; 
 
        var searches = _searchChanged 
            .Select(GetSuggestions) 
            .Finally(() =&gt; <span class="strong"><strong>AddToLog</strong></span>("Search DISPOSED!!!")); 
        searches 
            .Switch() 
            .Where(s =&gt; s.Length &gt; 3) 
            .DistinctUntilChanged() 
            .SubscribeOn(Scheduler.Default) 
            .ObserveOn(_dispatcher) 
            .Subscribe(OnEachSuggest, OnSuggestError, OnSuggestComplete); 
 
<span class="strong"><strong>        DoLogging(_logChanged);</strong></span> 
    } 
 
    private void OnEachSuggest(string searchText) 
    { 
        <span class="strong"><strong>AddToLog</strong></span>(string.Format("Suggestion Added : {0}", searchText)); 
    } 
 
    private IObservable&lt;string&gt; GetSuggestions(string searchText) 
    { 
        <span class="strong"><strong>AddToLog</strong></span>(string.Format("Searching for suggestions : 
          {0}", searchText)); 
    } 
 
    private void OnEachLog(string searchText) 
    { 
        <span class="strong"><strong>Logs.Add(searchText);</strong></span> 
    } 
 
</pre>
        <p>The following <code class="literal">DoLogging</code> method sets the observer, the <code class="literal">OnEachLog</code> method in our case, to listen for log text sequences/feeds from the observable <code class="literal">_logChanged</code> based on its <code class="literal">onNext</code> method invocations via the <code class="literal">AddToLog</code> method, thus, facilitating both publication and subscription using the <code class="literal">_logchanged</code> subject:</p>
        <pre class="programlisting">    private void DoLogging(IObservable&lt;string&gt; sequence) 
    { 
        sequence 
        .SubscribeOn(ThreadPoolScheduler.Instance) 
        .ObserveOn(_dispatcher) 
        .Subscribe(OnEachLog); 
    } 
  } 
 
</pre>
        <p>This binding list is bound to the <code class="literal">Listbox</code> specifically used in this example to view the logs. This change's property is further routed to the UI thread that senses the change in the bounded data source list in our case against the list box and forces a refresh. If you observe carefully, the logging feature is purely asynchronous and is handled by a background thread-a worker thread from thread pool in this case. Consider the following code snippet:</p>
        <pre class="programlisting">    public frmSpellChecker() 
    { 
        //Data Binding Is Done Here 
        lstBoxSuggestions.DataSource = _spellCheckerViewModel.Corrections; 
        lstBoxLog.DataSource = _spellCheckerViewModel.Logs; 
    } 
 
</pre>
        <p>The logs can be further persisted using the store, such as file, database, and so on, of your choice. You can also use this to clearly understand the data flow from an observer and subscriber standpoint. The modified application will look like the following:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/image_12_006.jpg" alt="An asynchronous logger"/>
        </div>
        <p>
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Near real-time visualizer/dashboard">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch12lvl1sec91"></a>Near real-time visualizer/dashboard</h1>
            </div>
          </div>
        </div>
        <p>Dashboards are natural candidates for viewing real-time, or near real-time, data. Reactive constructs can be very effectively utilized in realizing utility dashboards from a reporting standpoint. Let's look at an interesting scenario where election poll results are viewed on a real-time basis as and when the poll feeds come in from different states. Again, this has no resemblance to the actual polling process, but just conceptualized here in a fictitious manner that will enable learning and throw light on various interesting possibilities of leveraging reactive programming for such a reporting application. Consider the following code snippet:</p>
        <pre class="programlisting">    public partial class Form1 : Form 
    { 
        public enum Party { Republican, Democratic }; 
        public enum States { AZ, CA, FL, IN, NY }; 
        string[] xState = { "AZ", "CA", "FL", "IN", "NY" }; 
        double[] yRVotes = { 0, 0, 0, 0, 0 }; 
        double[] yDVotes = { 0, 0, 0, 0, 0 }; 
        Random random = new Random(); 
        class Vote 
        { 
            public Party VoteId { get; set; } 
            public string State { get; set; } 
        } 
         
        public Form1() 
        { 
            InitializeComponent(); 
            chart1.Series.Clear(); 
            <span class="strong"><strong>DrawSimulation</strong></span>(chart1); 
        } 
 
</pre>
        <p>This is the first stage in the prototype where we start building the simulation model for data sequences/streams, in our case, votes from multiple states. Here, we are initializing a certain number of votes per state. The <code class="literal">Take</code> query operator is utilized here, in case you noticed:</p>
        <pre class="programlisting">    private void <span class="strong"><strong>DrawSimulation</strong></span>(Chart chart1) 
    { 
        var azVotes = GenerateVotes&lt;Vote&gt;( 
          () =&gt; new Vote() { VoteId = CauchyDistribution(
            random.NextDouble()), State = "Arizona" }).Take(200000); 
        var caVotes = GenerateVotes&lt;Vote&gt;( 
          () =&gt; new Vote() { VoteId = CauchyDistribution(
            random.NextDouble()), State = "California" }).Take(500000); 
        var flVotes = GenerateVotes&lt;Vote&gt;( 
          () =&gt; new Vote() { VoteId = CauchyDistribution(
            random.NextDouble()), State = "Florida" }).Take(300000); 
        var inVotes = GenerateVotes&lt;Vote&gt;( 
          () =&gt; new Vote() { VoteId = CauchyDistribution(
            random.NextDouble()), State = "Indiana" }).Take(100000); 
        var nyVotes = GenerateVotes&lt;Vote&gt;( 
          () =&gt; new Vote() { VoteId = CauchyDistribution(
            random.NextDouble()), State = "New York" }).Take(700000);  
</pre>
        <p>This is the next stage in the prototype, where we will filter democratic and republican votes from the simulation model's stream source, which is generated in the preceding code:</p>
        <pre class="programlisting">        var azDVotes = from v in azVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Democratic 
                   select v; 
        var azRVotes = from v in azVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Republican 
                   select v; 
        var caDVotes = from v in caVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Democratic 
                   select v; 
        var caRVotes = from v in caVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Republican 
                   select v; 
        var flDVotes = from v in flVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Democratic 
                   select v; 
        var flRVotes = from v in flVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Republican 
                   select v; 
        var inDVotes = from v in inVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Democratic 
                   select v; 
        var inRVotes = from v in inVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Republican 
                   select v; 
        var nyDVotes = from v in nyVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Democratic 
                   select v; 
        var nyRVotes = from v in nyVotes.ToObservable&lt;Vote&gt;() 
                   where v.VoteId == Party.Republican 
                   select v; 
</pre>
        <p>Here, we will initialize and create the data series for the X and Y axis needed by the chart component. This way the series are bound to the charting component:</p>
        <pre class="programlisting">        Series democratic = new Series("Democratic"); 
        Series republican = new Series("Republican"); 
        chart1.Series.<span class="strong"><strong>Add</strong></span>(democratic); 
        chart1.Series.<span class="strong"><strong>Add</strong></span>(republican);              
</pre>
        <p>This is the stage where we kick-start simulation, that is, a generation of votes specified per state:</p>
        <pre class="programlisting">        GetDemocraticVotes(States.AZ, azDVotes); 
        GetRepublicanVotes(States.AZ, azRVotes); 
        GetDemocraticVotes(States.CA, caDVotes); 
        GetRepublicanVotes(States.CA, caRVotes); 
        GetDemocraticVotes(States.FL, flDVotes); 
        GetRepublicanVotes(States.FL, flRVotes); 
        GetDemocraticVotes(States.IN, inDVotes); 
        GetRepublicanVotes(States.IN, inRVotes); 
        GetDemocraticVotes(States.NY, nyDVotes); 
        GetRepublicanVotes(States.NY, nyRVotes); 
        } 
 
</pre>
        <p>The following two helper methods, <code class="literal">GetDemocraticVotes</code> and <code class="literal">GetRepublicanVotes</code>, used as a part of kick-starting simulation ensure that the observers (the following lambda function in this case) are bound and listening for changes as and when the votes start streaming in. The filtered votes are channeled to these respective helper methods and will continuously increment the respective vote counters on a near real-time basis:</p>
        <pre class="programlisting">    private void <span class="strong"><strong>GetDemocraticVotes</strong></span>(States state, IObservable&lt;Vote&gt; votes) 
    { 
        int stateIndex = (int)state; 
        <span class="strong"><strong>votes</strong></span>.SubscribeOn(Scheduler.Default) 
          .ObserveOn(NewThreadScheduler.Default) 
            .Subscribe(v =&gt; 
            { 
                double voteCount = yDVotes[stateIndex]; 
                yDVotes[stateIndex] = voteCount + 1; 
            }); 
    } 
 
    private void <span class="strong"><strong>GetRepublicanVotes</strong></span>(States state, IObservable&lt;Vote&gt; votes) 
    { 
        int stateIndex = (int)state; 
        <span class="strong"><strong>votes</strong></span>.SubscribeOn(Scheduler.Default) 
          .ObserveOn(NewThreadScheduler.Default) 
             .Subscribe(v =&gt; 
             { 
                double voteCount = yRVotes[stateIndex]; 
                yRVotes[stateIndex] = voteCount + 1; 
             }); 
    } 
 
</pre>
        <p>The following <code class="literal">GenerateVotes</code> method is the real vote generator (infinite, as you see) limited by the number specified using the Take operator, as indicated in the preceding code. This uses the generator function <code class="literal">CauchyDistribution</code> internally to generate the votes randomly and non-uniformly:</p>
        <pre class="programlisting">    public IEnumerable&lt;T&gt; GenerateVotes&lt;T&gt;(Func&lt;T&gt; generator) 
    { 
        <span class="strong"><strong>while (true) yield return generator();</strong></span> 
    } 
 
    private Party CauchyDistribution(double p) 
    { 
        <span class="strong"><strong>return Math.Tan(Math.PI * (p - 0.5)) &gt;= 0 ? 
          Party.Democratic : Party.Republican;</strong></span> 
    } 
 
</pre>
        <p>This timer control helps in refreshing the chart control, which is based on the preset frequency, with values indicating votes scored by the two parties in the various states under consideration. Now, one important thing that you need to understand here is that as and when you traverse layers of subscribers and observers, you tend to introduce latency, again, based on the kind of schedulers you employ for concurrency, which makes the final output near real-time as opposed to real time not to introduce any interpretable subjectivity here. One should strive to reduce these layers and choose the right schedulers through multiple trials and calibrations to minimize these latencies and meet the required SLAs. Consider the following code snippet:</p>
        <pre class="programlisting">    private void timer1_Tick(object sender, EventArgs e) 
    { 
        chart1.Series["Republican"].Points.<span class="strong"><strong>DataBindXY</strong></span>(xState, yRVotes); 
        chart1.Series["Democratic"].Points.<span class="strong"><strong>DataBindXY</strong></span>(xState, yDVotes); 
    } 
   } 
  } 
 
</pre>
        <p>As can you see, the program is divided into multiple stages, which are as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stage1</strong></span>: A simulation model building block</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stage2</strong></span>: Filtering votes based on <code class="literal">Party</code></li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stage3</strong></span>: Publish to subscribers</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stage4</strong></span>: Dashboard renderer</li>
          </ul>
        </div>
        <p>The near real-time dashboard will look like the following:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/image_12_007.jpg" alt="Near real-time visualizer/dashboard"/>
        </div>
        <p>
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch12lvl1sec92"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>As you saw, we have gone through some interesting and pragmatic examples that illustrate the applicability of reactive programming principles. The idea is to make you aware of the possibilities and warm you up for some serious programming tasks ahead. We believe you are in a position to appreciate this paradigm now, and possibly able to relate to it as a natural way of expressing solution models in a declarative manner, which involved a lot of plumbing code earlier. The power of composability that you get in this model is quite evident. Now, in the next chapter, we will go on to explore RxJS, the reactive programming JavaScript library that helps you brace for web programming.</p>
      </div>
    </div>
</body>
</html>