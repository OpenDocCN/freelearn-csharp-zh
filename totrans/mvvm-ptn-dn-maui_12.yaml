- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Localization with MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we’ve built this fantastic *Recipes!* app, and we’re quite pleased with
    its design and features. However, as it stands, the app is entirely in English.
    What about culinary enthusiasts from different parts of the world? The answer
    is localization, specifically focusing on translating all aspects of our app to
    make it accessible and user-friendly to a global audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll tackle localization through the lens of MVVM. We’ll
    be looking at translating the hardcoded `copy` labels that are baked into the
    app, but also at effectively fetching language-specific data from the API. To
    accomplish this, we’ll delve into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with cultures, resource files, and localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at a localization solution for MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a custom `Translate` markup extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching localized data from APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we dive into this chapter, remember that our journey through localization
    also showcases thoughtful app design with MVVM principles. By the end, not only
    will we have the tools and knowledge to extend the reach of our app to a diverse,
    global audience through the UI, but we’ll also see how the right design choices
    ensure that every layer of our app, down to the data we present, is coherent and
    organized.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, for hands-on experience and to keep pace with the content, head over
    to our GitHub repository at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12).
    Begin with the code in the `Start` folder, and, for a comprehensive view, you
    can always refer to the `Finish` folder, which houses the polished, end-of-chapter
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with cultures, resource files, and localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into the actual coding bits and look at how we can integrate
    localization in MVVM, let’s make sure we’re all on the same page about what we
    mean by *culture* in the .NET MAUI context. Culture, in this case, refers to the
    settings that determine the language to be used and the display format for items
    such as dates, times, currency, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with how to retrieve the user’s culture in .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the user’s culture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CultureInfo` class is part of the `System.Globalization` namespace in .NET
    and serves as a central point for obtaining culture-specific information, such
    as language, country, date formats, number formats, and more. It also contains
    `CurrentCulture` and `CurrentUICulture` properties that can be used to get or
    set the user’s current culture and “UI culture.”
  prefs: []
  type: TYPE_NORMAL
- en: CurrentCulture versus CurrentUICulture
  prefs: []
  type: TYPE_NORMAL
- en: '`CurrentCulture` defines how data types such as dates, numbers, and currencies
    should be formatted in the application. This ensures that the look and feel of
    the data aligns with the user’s cultural context. On the other hand, `CurrentUICulture`
    dictates the language used for the UI elements and text resources. `CurrentCulture`
    determines *how things look* (formatting), while `CurrentUICulture` controls *which
    language is being* *used* (localization).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user’s current culture settings can be easily obtained with the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will get the device’s culture settings, which the user has set up in their
    system settings. Let’s see how we can set a different culture.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a different culture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting a particular culture is as easy as assigning it to the relevant properties
    on the `CultureInfo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `DefaultThreadCurrentCulture` and `DefaultThreadCurrentUICulture` properties
    are used to set the default culture settings for all threads in a .NET application,
    including background threads that you may spin up for various tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity and to keep our focus on the overall process of localization,
    throughout this chapter we won’t be making a distinction between `CurrentCulture`
    and `CurrentUICulture` unless explicitly mentioned. When we talk about updating
    the culture settings, we’ll be updating both `CurrentCulture` and `CurrentUICulture`,
    as well as their `DefaultThread` counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want, we can allow users to select a culture from a list of supported
    cultures and save it for future sessions. Here’s a simplified example using `Microsoft.Maui.Storage.Preferences`
    to store the chosen culture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving and assigning the previously stored selected culture can be done
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Preferences`’s `Get` method accepts a second parameter that serves as
    a default value to return when no existing value for the given key exists. The
    string value that we retrieved can now be used to instantiate a new `CultureInfo`
    object, which we can then use to set the application’s culture. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the `CurrentCulture` property defines how particular data
    types are being displayed. So, let’s have a quick look at what we mean by that.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying formatted data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Culture settings have a direct impact on how data types such as dates and numbers
    are formatted when they are displayed in the UI. When you set `CultureInfo.CurrentCulture`,
    it will also influence the formatting in data-binding scenarios. This means that
    `DateTime` values, for instance, will be displayed according to the format rules
    of the set culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a `DateTime` property in our ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And we are binding this property to a `Label` in XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because we are not specifying how the data should be formatted, the `ToString`
    method will be called on the `DateTime` object, and that result will be shown
    on the screen. The `ToString` method will take the current culture settings into
    account. As a result, if the culture is set to US English (`en-US`), the date
    will be formatted as `7/3/2020 12:00:00 AM`, whereas if the culture is set to
    French (`fr-FR`), the date will appear as `03/07/2020 00:00:00`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StringFormat` property in XAML binding expressions allows us to define
    custom formatting for data types such as `DateTime`. What’s great is that `StringFormat`
    will also respect the current culture settings, so it’s a fantastic way to combine
    customization with localization. For instance, we could use `StringFormat` in
    XAML to specify how you’d like that date to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `StringFormat` is set to display the full month name, the day,
    and the full year. In US English, it will be displayed as `July 3, 2020`, whereas
    when the app’s culture is set to French, the date will automatically adjust to
    `juillet 3, 2020`. The format specified in `StringFormat` remains consistent,
    but the actual string values for the day and month adapt to the set culture.
  prefs: []
  type: TYPE_NORMAL
- en: The same principles apply to number formatting. Different cultures have various
    ways of representing numbers, particularly when it comes to separating thousands
    and decimal points. By being mindful of the culture settings, we ensure that our
    application displays numbers in a format that is both familiar and understandable
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the `CurrentCulture` property, the `CurrentUICulture` property
    determines the language that is being used in the app. So, let’s have a look at
    how this can be managed through resource files.
  prefs: []
  type: TYPE_NORMAL
- en: What are Resources Files?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Resources Files are a core feature of the .NET ecosystem, used to facilitate
    localization across a wide array of application types. Typically named with a
    `.resx` extension, these XML-based files allow you to define key-value pairs where
    the key represents a specific piece of text or asset in your application, and
    the value represents its localized equivalent. Visual Studio even provides an
    editor for `.resx` files, allowing developers to easily define keys and their
    value (*Figure 12**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Visual Studio .resx designer](img/B20941_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Visual Studio .resx designer'
  prefs: []
  type: TYPE_NORMAL
- en: What’s particularly handy is that a strongly typed class is automatically generated
    when you create a `.resx` file. This class allows us to access localized resources
    programmatically in a type-safe manner, eliminating the need to manually look
    up resource keys in your code. The name of this autogenerated class is derived
    from the name of the `resx` file itself. For example, if the resource file is
    named `AppResources.resx`, the generated class will be named `AppResources`.
  prefs: []
  type: TYPE_NORMAL
- en: By suffixing the name of the file, we can specify which culture a specific resource
    file belongs to – for example, `AppResources.resx` for the default culture of
    the app (let’s say English), `AppResources.fr-FR.resx` for French, `AppResources.es-ES.resx`
    for Spanish, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET MAUI will look in the `.resx` file that corresponds with the set culture
    for the requested value. Fetching a localized string can be done as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the current UI culture is set to French (`fr-FR`), .NET MAUI will automatically
    look for `AddAsFavorite` in the `AppResources.fr-FR.resx` file. If there is no
    resource file matching the current UI culture, the default file (the one without
    a suffix) will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, retrieving a value for the `AddAsFavorite` key can also be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A static property will be generated in the `AppResources` class for every key
    in the `.resx` file. These properties utilize `ResourceManager`’s `GetString`
    method to retrieve the corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the generated class will only be based on the default
    resource file. This means that only properties will be generated for the keys
    in the default file. So, it is very important to have the same keys in each of
    the different culture-specific files! Resolving a value for a key that is not
    present in the resource file of the current UI culture will result in an exception!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some resource files to our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `Resources` folder in the `Recipes.Mobile` project and select
    `Strings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click this folder and select **Add** | **New Item…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `resources`, select the `AppResources.resx` as the name (*Figure 12**.2*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2: Creating a new Resources File](img/B20941_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Creating a new Resources File'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-check the newly created file’s properties in the **Properties** window.
    The **Build Action** property should be set to **Embedded resource**, and the
    **Custom Tool** property should be set to **ResXFileCodeGenerator**, as *Figure*
    *12**.3* shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3: Properties of the AppResources.resx file](img/B20941_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Properties of the AppResources.resx file'
  prefs: []
  type: TYPE_NORMAL
- en: Add a second `AppResources.fr-FR.resx`. Note that only the default resource
    file has its **Custom Tool** property set to **ResXFileCodeGenerator**. Other
    resource files will not have this property set, but their **Build Action** property
    does have to be set to **Embedded resource** as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Chapter 12``/Resources` folder, you will find an `AppResources.resx`
    file and an `AppResources.fr-FR.resx` file containing the English and French resources
    respectively. Copy them over to the `Strings` folder in Visual Studio and override
    the files you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this in place, let’s have a look at how we can get those values on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting localized resources on the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In its simplest form, we can use the `x:Static` markup extension. This markup
    extension is used to reference static fields or properties from a specified class.
    As mentioned earlier, the generated `AppResources` class has a static property
    for each of the keys in the `x:Static` markup extension to reference the localized
    values. Let’s see how we can add this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `CreateMauiApp` method of the `MauiProgram` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will force the app’s culture to French.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to `AppShell.xaml` and add an XML namespace pointing to the namespace of
    the `AppResources` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, update the `Title` property of the first `Tab` element to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By leveraging the `x:Static` markup extension, we are pointing to the static
    `Tab1Title` property of the `AppResources` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Title` property of the second `Tab` element should point to the `Tab2Title`
    property as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, for this first example, head over to `RecipeDetailPage` and find
    the `MultiBinding` on the label that shows the `LastUpdated` and `Author` properties.
    The `x:Static` markup extension can also be used on the `StringFormat` property
    on a binding statement, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It’s worth mentioning that `ModifiedDateAuthorFormat` contains a `D` format
    specifier that represents a long date pattern. As a result, the notation of the
    date will be different depending on the selected culture. For example, when `CurrentCulture`
    is set to French (`fr-FR`), July 3, 2020, will be shown as `vendredi 3` `juillet
    2020`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we now run the app, we should immediately see that the titles of the two
    main tabs are now in French, as *Figure* *12**.4* shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Localized tab titles](img/B20941_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Localized tab titles'
  prefs: []
  type: TYPE_NORMAL
- en: 'When navigating to `RecipeDetailPage`, the label showing the `LastUpdated`
    and `Author` properties is now also translated. Now, go ahead and change the culture
    in the `CreateMauiApp` method to `nl-BE`. Run the app, and you should see the
    localized labels in English. That’s because there is no resource file for this
    culture, so the default one is used. Do note that the date is being formatted
    according to the Dutch (Belgium) notation: `vrijdag 3` `juli 2020`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As said, this approach is the simplest form of getting the localized resources
    on the screen. This is a perfectly valid approach, but it’s not very MVVM-friendly,
    and it has its limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: The biggest limitation is that `x:Static` doesn’t react to changes. If you change
    the value of the static property at runtime, the UI will not update to reflect
    the new value. This makes it unsuitable for scenarios where the localized text
    might change dynamically, such as when a user switches languages in-app. Only
    when navigating to a new page will the `x:Static` markup extension load the required
    values for the newly selected culture. When navigating (back) to pages that are
    in memory, the values of the previous culture will still be there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no way to access these resources from within our ViewModels. This can
    be an issue if we want to show dialogs or alerts from a ViewModel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, we’ve laid down the essential groundwork for understanding localization
    in .NET MAUI, including the role of resource files, the `CultureInfo` class, and
    the `x:Static` markup extension. While the methods and concepts we’ve discussed
    so far form the essential backbone of localization in .NET MAUI, our next section
    will explore how to seamlessly integrate them into MVVM. Ultimately, our goal
    is to make use of data binding to connect our UI to localized values. This enables
    dynamic updates: if the user switches languages or cultures during runtime, the
    displayed text will automatically reflect these changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The properties on a binding statement such as `StringFormat`, `FallbackValue`,
    and `TargetNullValue` aren’t bindable properties. This means that the only way
    to assign values from a resource file to these properties is by leveraging the
    `x:Static` markup extension, with its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at a localization solution for MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll look at a solution that’s not just functional but also
    fits well with the MVVM architectural pattern. Whether you need to localize text
    within your ViewModels or dynamically update language in your UI, this approach
    has you covered. It’s a solution that I’ve personally implemented in numerous
    projects over the years. While I’ve made some refinements along the way, the core
    concept has stood the test of time and proven its effectiveness in real-world
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Warning – culture settings are thread-specific
  prefs: []
  type: TYPE_NORMAL
- en: When allowing the user to switch cultures inside the app, we should be wary
    of the fact that when updating `CultureInfo` inside `async` operations, those
    changes will not automatically propagate to the parent thread. A localization
    strategy needs to be designed with this in mind to avoid inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code accompanying this chapter, two new projects have been added: `Localization`
    and `Localization.Maui`. The primary objective of the `Localization` project is
    to provide a framework-agnostic approach to manage and access localization settings
    and resources. By encapsulating this localization logic within its own project,
    we facilitate easy code sharing across different projects, paving the way for
    potential packaging and reuse in other projects.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `Localization.Maui` project is tailored specifically
    for .NET MAUI. It houses the code responsible for storing and retrieving localization
    information. Putting this logic separately from the rest of our *Recipes!* app
    code allows us to ensure that it remains modular and reusable for other .NET MAUI
    applications. Let’s discuss the `Localization` project first.
  prefs: []
  type: TYPE_NORMAL
- en: The Localization project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `ILocalizationManager` interface in the `Localization`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ILocalizationManager` interface defines three methods for managing localization
    settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RestorePreviousCulture` is a method that can be used to restore the previous
    culture used by the user. The `defaultCulture` parameter can be used to specify
    a fallback culture in case there is no previous culture set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateUserCulture` updates and stores the culture settings for the current
    user. The `cultureInfo` parameter specifies the new culture to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetUserCulture` method retrieves the stored culture settings. The `defaultCulture`
    parameter can be used to specify a fallback culture in case there is no culture
    set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary intent behind this interface is to abstract tasks related to the
    persistence and retrieval of user-specified cultures. In the context of a .NET
    MAUI-specific implementation, we might, for instance, opt to save the most recently
    chosen `CultureInfo` within `Preferences`, ensuring it’s available the next time
    the app launches so that it can be restored. We’ll delve deeper into this specific
    approach shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second interface in the `Localization` project is the `ILocalizedResourcesProvider`
    interface. Let’s see what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At its core, this interface facilitates the retrieval of localized string values
    that align with the user’s chosen `CultureInfo`. It provides a read-only indexer
    to fetch the localized string corresponding to a specified key. Additionally,
    the `UpdateCulture` method lets you modify the current `CultureInfo`, ensuring
    that subsequent localized string retrievals reflect the updated cultural context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll explore the `Localization` project’s concrete implementation of
    the `ILocalizedResourceProvider` interface – namely, `LocalizedResourcesProvider`.
    Let’s start by looking at its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes a single parameter, `resourceManager`. This is the `ResourceManager`
    that needs to be used to retrieve the localized values. The `currentCulture` field
    is initialized with a default value, being the current UI culture. Within the
    constructor, the current instance is assigned to the static `Instance` property.
    This allows us to access this `LocalizedResourcesProvider` implementation through
    a static property, which will be handy in data-binding scenarios, as we’ll see
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the current instance of `LocalizedResourcesProvider` to the static
    `Instance` property means there can only be one `LocalizedResourcesProvider` implementation
    throughout the app. While this is a limitation to be wary of, it should not pose
    a significant problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The indexer of this class allows us to get the localized string value for a
    given key. Here’s how this is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the key exists within our resources, the method fetches the corresponding
    localized string using the `currentCulture`. However, if the provided key doesn’t
    match any resource key, the key itself is returned as a fallback. It’s crucial
    to observe that we’re passing the `currentCulture` explicitly when calling `GetString`.
    This ensures that the `resourceManager` fetches values specific to the provided
    `currentCulture`, rather than defaulting to the `CultureInfo` of the currently
    executing thread. This design choice addresses potential challenges arising from
    culture settings being thread-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the `UpdateCulture` method within the `LocalizedResourcesProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method updates the `currentCulture` field. As a result, any subsequent
    calls to the class’s indexer will retrieve the localized string value for the
    given key, based on the updated `currentCulture`. Additionally, the method calls
    the `OnPropertyChanged` method, sending `Item` as its argument. In scenarios involving
    data binding, this prompts a re-evaluation of all bindings linked to the indexer.
    Consequently, any values that are data-bound to this indexer will refresh, returning
    the localized strings of the updated `CultureInfo`. Let’s transition our focus
    to the `Localization.Maui` project.
  prefs: []
  type: TYPE_NORMAL
- en: The Localization.Maui project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LocalizationManager` class in the `Localization.Maui` project is an implementation
    of the `ILocaliazationManager`. It has a dependency on `ILocalizedResourcesProvider`,
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By having this reference, we can, later on, call its `UpdateCulture` method,
    keeping the updated culture in sync with the `ILocalizedResourcesProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LocalizationManager` class should also store the selected `CultureInfo`
    so that it can be retrieved on subsequent app launches and restore the previous
    `CultureInfo`. The following code block shows how the `UpdateUserCulture` uses
    the `Preferences` API to store the given `CultureInfo`, assigns the updated value
    to the `currentCulture` field, updates the static properties on the `CultureInfo`
    object, and calls the `ILocalizedResourcesProvider`’s `UpdateCulture` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the updates on the `CultureInfo` object are dispatched to the main
    thread. Remember the note about `CultureInfo` being bound to the current thread?
    We want to ensure that the main thread’s `CultureInfo` is updated to maintain
    consistency. Failing to apply these changes to the main thread could result in
    data binding using the outdated or previous `CultureInfo`. This misalignment can
    lead to inaccuracies when formatting data, such as displaying `DateTime` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetUserCulture` method first checks if its `currentCulture` field is set.
    If it is, that value is returned directly. If not, the method tries to retrieve
    the culture based on the `UserCulture` key from `Preferences`. If no value is
    found there, it either resorts to the provided `defaultCulture` parameter or,
    in its absence, the current system culture. Once determined, this culture is assigned
    to the `currentCulture` field, which is then returned. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `RestorePreviousCulture` method uses the `GetUserCutlure` method
    to retrieve the previously used culture and passes this on to the `SetCulture`
    method, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method can be used when the app starts to set the current culture to the
    culture that the user selected previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’re familiar with the roles and workings of these classes, let’s
    integrate them into the *Recipes!* app. This will enable us to handle localization
    in a manner that complements the MVVM architectural pattern. Here’s a step-by-step
    guide:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `MauiProgram.cs` and add the following line of code to the `CreateMauiApp`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This registers an instance of `LocalizationManager` to the DI container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an instance of `LocalizedResourcesProvider`. Pass the `ResourceManager`
    of `AppResources` to its constructor, allowing `LocalizedResourceProvider` to
    access the resources defined in the `AppResources` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s register this `LocalizedResourcesProvider` as `Singleton` to the DI container,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By doing this, we’re ensuring a single instance of the `LocalizedResourcesProvider`
    class is used throughout the app. Any time this instance is resolved through DI,
    it’s guaranteed to be the same as that referred to by the `LocalizedResourcesProvider`’s
    static `Instance` property. This is essential for accessing localized resources
    consistently across the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This sets the foundation for a solid localization solution that is ready to
    be used in our app. Let’s see how we can integrate the `LocalizedResourcesProvider`
    and `LocalizationManager` in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Using the LocalizedResourcesProvider and LocalizationManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can use the `LocalizedResourcesProvider` and `LocalizationManager`
    to access localized resources from within a ViewModel. On the `SettingsPage`,
    the user can select a new language through the `PickLanguagePage`. When selecting
    a language, a prompt should ask, in the current language, whether the user wants
    to switch. After switching, an alert in the updated language should confirm the
    update. Here’s how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add the following two fields to `SettingsViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The DI container will automatically inject these additional dependencies into
    the constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we can update the `ConfirmSwitchLanguage` method to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See how we use the `_resources` field to fetch localized strings, which are
    then passed to the `IDialogService`’s `AskYesNo` method. The keys exactly match
    the keys present in the `AppResources` files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Likewise, we can also update the `NotifySwitch` method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we need to add the following line of code to the `SwitchLanguage` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is called when the user has confirmed switching to the new language.
    By calling the `_localizationManager`’s `UpdateUserCulture`, we’ll be persisting
    the selected culture, updating the `CultureInfo` properties, and notifying the
    `ILocalizedResourcesProvider` about the updated culture. As a result, subsequential
    calls to the `_resources` field will retrieve the localized values for the updated
    `CultureInfo`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now run the app, go to the `SettingsPage`, and click through to the
    `PickLanguagePage`, where we can change the language of the app. Once a new language
    is chosen, we automatically navigate back to the `SettingsPage`, where we’ll get
    a prompt in the current language of the app (*Figure 12**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: Prompt in English](img/B20941_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Prompt in English'
  prefs: []
  type: TYPE_NORMAL
- en: 'After confirmation, the language will be updated, and we’ll see an alert in
    the new language (*Figure 12**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Alert in French](img/B20941_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Alert in French'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we can switch cultures from within our ViewModels and retrieve
    localized string values for the currently set culture is already very exciting!
    But how do we handle the localization in our Views if we want them to update to
    the newly selected culture as well? Let’s have a look!
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `SettingsPage.xml` and add the following XML namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This namespace points to the `Localization` namespace of the `Localization`
    project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `Text` property of the **Select Language** button to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we saw in the `LocalizedResourcesProvider`’s implementation, the indexer
    takes a provided key and fetches the corresponding localized string using the
    configured `ResourceManager`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s also update the text of the `LocalizedResourcesProvider`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And while we’re at it, let’s also update the page’s title as well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take a look at the `Text` property of the label that shows the current selected
    language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these changes in place, run the app again. Go to the `SettingsPage` and
    select a different language. After confirming to switch the language of the app,
    you should not only see the alert in the updated language appearing but also see
    that the labels on the `SettingsPage` instantly update (*Figure 12**.7*)!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: The Settings page before (left) and after (right) switching
    to French](img/B20941_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: The Settings page before (left) and after (right) switching to
    French'
  prefs: []
  type: TYPE_NORMAL
- en: The magic happens because our bindings target the indexer of the `LocalizedResourcesProvider`
    class. Thus, any trigger of the `PropertyChanged` event (with `Item` as the property
    name) will prompt a re-evaluation of these bindings. Triggering the `PropertyChanged`
    event is done because the `LocalizationManager` calls the `UpdateCulture` method
    on its `_resourceProvider` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the selected culture isn’t persisted across app launches. To be
    exact: the selected culture does get stored, but it is not being restored when
    the application starts. We can easily add that functionality by updating the constructor
    of the `App` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: By calling the `RestorePreviousCulture` on the injected `ILocalizationManager`
    interface, the previously set culture is being restored. It’s done in the constructor
    of the `App` class so that it is applied early on in the application’s life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I think this is a beautiful and very MVVM-friendly solution to localization;
    well, except for the rather complex data-binding statements we have to put in
    place. In the next section, we’ll see how we can improve on that.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom Translate markup extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We previously set up a localization solution for our app. While it works effectively,
    the data-binding statements were a bit verbose and would have to be repeated for
    each string. Building on that foundation, in this section, we’ll introduce a streamlined
    approach: a custom markup extension designed specifically for translations.'
  prefs: []
  type: TYPE_NORMAL
- en: But before we proceed, let’s briefly revisit what markup extensions are. **Markup
    extensions** provide a way to compute or retrieve property values at runtime rather
    than just setting them to static values. This functionality makes them particularly
    handy for tasks such as resource lookups, data binding, or, in our case, simplifying
    translation retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that we’re not changing how we leverage data binding
    to bind to our resources. Instead, we’re just making the XAML code easier to write
    and read. The actual data-binding process stays the same. This is essentially
    what the `Translate` markup extension will look like in XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is synonymous with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Translate` markup extension is a wrapper around a conventional data-binding
    statement. Let’s take a look at the `TranslateExtension` class in the `Localization.Maui`
    project. This class implements the generic `IMarkupExtension` interface, and as
    a result, it needs to implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-generic `ProvideValue` method will be called at runtime and must return
    the value we want to be using in our XAML. In this case, we want to return a `Binding`.
    Here’s how it’s implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-generic `ProvideValue` method calls its generic version, which returns
    a `Binding`. The class has a property named `Key`, which represents the key used
    to fetch the localized value. This `Key` property can be assigned in the markup
    extension, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: public Binding ProvideValue(
  prefs: []
  type: TYPE_NORMAL
- en: IServiceProvider serviceProvider)
  prefs: []
  type: TYPE_NORMAL
- en: => new Binding
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Mode = BindingMode.OneWay,
  prefs: []
  type: TYPE_NORMAL
- en: Path = $"[{Key}]",
  prefs: []
  type: TYPE_NORMAL
- en: Source = LocalizedResourcesProvider.Instance
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '{x:Static localization:LocalizedResourcesProvider.Instance}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: xmlns:mauiloc="clr-namespace:Localization.Maui;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assembly=Localization.Maui"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Title="{mauiloc:Translate SettingsTitle}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Text="{mauiloc:Translate ChooseLanguage}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Text="{mauiloc:Translate About}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <Tab Title="{mauiloc:Translate Tab1Title}">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Tab>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Tab Title="{mauiloc:Translate Tab2Title}">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Tab>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Task<ApiResponse<RecipeOverviewItemsDto>>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GetRecipes([Header("Accept-Language")] string
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Header attribute, but I think this approach is a lot cleaner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: readonly ILocalizationManager _localizationManager;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public RecipeApiGateway(IRecipeApi api,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ILocalizationManager localizationManager)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _api = api;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _localizationManager = localizationManager;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public Task<Result<LoadRecipesResponse>>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LoadRecipes(int pageSize, int page)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: => InvokeAndMap(_api.GetRecipes(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _localizationManager.GetUserCulture().Name,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pageSize, page), MapRecipesOverview);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: app.MapGet("/recipes", (int pageSize, int pageIndex,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[FromHeader(Name = "Accept-Language")] string'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language) =>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //use language to retrieve recipes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new RecipeService()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .LoadRecipes(pageSize, pageIndex);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .WithName("GetRecipes")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .WithOpenApi();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'public class CultureChangedMessage :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ValueChangedMessage<CultureInfo>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'public CultureChangedMessage(CultureInfo value) :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: base(value)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{ }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private void SwitchLanguage(string newLanguage)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CurrentLanguage = newLanguage;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var newCulture = new CultureInfo(newLanguage);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _localizationManager
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .UpdateUserCulture(newCulture);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WeakReferenceMessenger.Default.Send(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new CultureChangedMessage(newCulture));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: WeakReferenceMessenger.Default
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .Register<CultureChangedMessage>(this, (r, m) =>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recipes.Clear();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (r as RecipesOverviewViewModel).LoadRecipes(7, 0);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
