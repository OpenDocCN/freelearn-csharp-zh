<html><head></head><body>
<div class="chapter" title="Chapter&#xA0;13.&#xA0;Troubleshooting Functional Code">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch13"/>
 Chapter 13. Troubleshooting Functional Code</h1>
</div>
</div>
</div>
<p>In this chapter, I touch on an important aspect of the functional-first programming approach that kicks in when the F# code is in the process of being developed. It so happens that the troubleshooting of the functional-first code differs from the troubleshooting of, say, imperative code. The goal of this chapter is to share with you some of my observations collected while authoring idiomatic F# code. It should leave you equipped with some considerations and a few techniques for effective bug squashing.</p>
<p>In this chapter, we will look into the following topics:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Understanding reasons for idiomatic F# having a low defect rate</li>
<li class="listitem">Using REPL and explorative programming style</li>
<li class="listitem">Addressing some compile-time problems</li>
<li class="listitem">Addressing run-time problems</li>
</ul>
</div>
<div class="section" title="Why idiomatic F# admits less defects">
<div class="titlepage">
<div>
<div>
<h1 class="title" id="toc_1"><a id="ch13lvl1sec75"/>
 Why idiomatic F# admits less defects</h1>
</div>
</div>
</div>
<p>Without going back to the side-by-side comparison of functional-first and other paradigms available for F# programmer to employ, I will reiterate the (mostly anecdotal) point that an idiomatic F# code admits fewer defects than equivalent implementations based on object-oriented or imperative paradigms.</p>
<p>The previous twelve chapters have contributed significantly to this judgment. But let me briefly revisit some considerations in order to conclude that:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">This decrease in the defect rate is not something taken for granted. This artifact is what you gain in exchange for the pain of mind-bending while acquiring functional thinking habits and the following rigor in applying them</li>
<li class="listitem">The use of F# by itself is not a remedy from the defects; there is still enough space for bugs to sneak into the code, although in significantly lower amounts</li>
<li class="listitem">Typical F# bugs are quite specific and often may be anticipated and avoided</li>
</ul>
</div>
<div class="section" title="Reduced bug rate">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch13lvl2sec140"/>
 Reduced bug rate</h2>
</div>
</div>
</div>
<p>This observation is very important and stems from a few factors:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">The language's succinctness contributes to the reduced bug rate literally: fewer lines of code carry fewer chances for bugs to sneak in and stay unnoticed</li>
<li class="listitem">Strict static typing and type inference simply do not allow oversights that are typical for dynamic languages, when the misplacement of types may lead to bugs that are hard to detect and eliminate later on</li>
<li class="listitem">Raised level of abstraction, library higher-order functions, and immutability. All of these contribute to eliminating many bugs that come from the unpredictable execution order of stateful code, more "moving parts" involved, and needless re-implementation of core library facilities</li>
</ul>
</div>
</div>
<div class="section" title="Prevalence of F# compile-time errors over run-time bugs">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch13lvl2sec141"/>
 Prevalence of F# compile-time errors over run-time bugs</h2>
</div>
</div>
</div>
<p>The syntactic correctness of a program written using a conventional programming language usually does not prompt any assumptions about the outcome of its execution. Generally speaking, these two factors are not correlated.</p>
<p>It seems that this is not the case for the implementations following the F# functional-first approach. There is plenty of anecdotal evidence on the Internet in F# and non-F# functional programming context stating that</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>"if it compiles it works"</em>
</span>
</p>
</blockquote>
</div>
<p>For example, this <span class="strong">
<strong>Haskell wiki post</strong>
</span>
 (<a class="ulink" href="https://wiki.haskell.org/Why_Haskell_just_works">https://wiki.haskell.org/Why_Haskell_just_works</a>
 ) states a similar observation in relation to programs written in the allied Haskell programming language.</p>
<p>Actually, strict static typing and type inference may catch many random defects at compile-time, shielding programmers from the costly process of observing a problem at run-time and then often performing lengthy and skill-demanding activities known as <span class="emphasis">
<em>debugging</em>
</span>
 in order to nail down the genuine cause of the problem at the source code level.</p>
<p>Another extremely important factor is to implement the algorithm by sticking to a handful of idiomatic patterns supported by core libraries instead of manipulating lower-level language constructs. To give you a better idea of what I'm talking about here, try to answer this question: Which approach carries more chances for implementation mistakes, folding a sequence with <code class="literal">Seq.fold</code>
 or materializing the sequence into the array and traversing elements using indexing while aggregating the result in a mutable value? The right answer easily translates into what has been mentioned on many occasions throughout the book: the positive effect of "minimizing the amount of moving parts" in a functional paradigm.</p>
<p>Still, your fold should be the rightly one for the overall correctness of the implementation from an algorithmic standpoint. And F# offers just another bug-squashing facility. This facility allows the developer to perform fast, easy, and frequent quick checks along the course of implementation with the help of so-called <span class="strong">
<strong>REPL</strong>
</span>
 covered in the next section.</p>
</div>
</div>
</div>


<div class="section" title="Using REPL and the explorative programming style">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch13lvl1sec76"/>
 Using REPL and the explorative programming style</h1>
</div>
</div>
</div>
<p>
<span class="strong">
<strong>REPL</strong>
</span>
 stands for <span class="strong">
<strong>Read-Evaluate-Print Loop</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
 ) and represents a manner of program development that quite deviates from what old-style C# programmers were used to, namely <span class="emphasis">
<em>edit source code - build the compiled program version - run and debug loop</em>
</span>
 . From its very early days, F# has introduced <span class="strong">
<strong>interactive development manner</strong>
</span>
 (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/fsharp-interactive/index">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/fsharp-interactive/index</a>
 ). However, more broadly, it equips the F# developer with just another programming style collectively referred to as <span class="strong">
<strong>exploratory programming</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Exploratory_programming">https://en.wikipedia.org/wiki/Exploratory_programming</a>
 ). F# offers a tool known as <span class="strong">
<strong>F# Interactive</strong>
</span>
 (32-bit <code class="literal">fsi.exe</code>
 or 64-bit-capable <code class="literal">fsiAnyCPU.exe</code>
 ) both as a standalone, or as a part of Visual Studio reachable from any F# Project. It allows you to evaluate any F# expression presented in the form of a standalone F# script or just a selected F# program fragment in a dynamically built run-time environment.</p>
<p>F# Interactive is a tool of immense versatility. Its use cases span a quick check of just implemented one-liner function behavior to running F#-implemented microservices in the production environment. Yes, I'm not kidding; the quality of the F# Interactive compiler is pretty much the same as that of normal build compiler. At one time, the whole Jet.com microservices architecture was implemented as a set of F# scripts, each executed by a dedicated <code class="literal">fsi</code>
 process.</p>
<p>The habit of doing quick checks while developing any F# code by evaluating this or that fragment in <code class="literal">fsi</code>
 may significantly help in achieving practically bug-free F# implementations. I highly recommend that you acquire and follow F# explorative programming style in your day after day practice.</p>
</div>


<div class="section" title="Addressing some compile-time problems">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch13lvl1sec77"/>
 Addressing some compile-time problems</h1>
</div>
</div>
</div>
<p>Although REPL can help explore and tweak correct F# code, it keeps compiler errors intact, as evaluating a code snippet includes compilation by the F# compiler embedded into <code class="literal">fsi</code>
 . And I must admit that some compile-time errors may puzzle an inexperienced F# developer. Here, I will analyze several kinds of such errors and provide advice on how to get rid of them. Before I do this, you should keep in mind that because an initial defect usually gets ingested by type inference as correct code, the reported compilation error is in line with that convoluted type inference determination. That is, type inference often masks the authentic cause of an error. We will go over some occasions of this layout soon.</p>
<div class="section" title="The if-then return value">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch13lvl2sec142"/>
 The if-then return value</h2>
</div>
</div>
</div>
<p>One of the easiest-to-grasp occurrences of the similar convoluted determination takes place for the result type of F# <code class="literal">if...then...</code>
 expressions. Usually, it seems counterintuitive that this result cannot be anything but <code class="literal">unit</code>
 . Let's look at why this happens.</p>
<p>In the following snippet, I chose the specific (<code class="literal">&lt;</code>
 ) comparison operator within the implementation just to keep things simple (<code class="literal">Ch13_1.fsx</code>
 ):</p>
<pre class="programlisting">let f a b = 
    if a &lt; b then 
        a 
    else 
        b 
</pre>
<p>Here, the inferred signature of function <code class="literal">f</code>
 representing the result of evaluating the F# expression <code class="literal">if-then-else</code>
 is <code class="literal">f: 'a -&gt; 'a -&gt; 'a</code>
 (requires comparison), which makes perfect sense (it should not take much effort to recognize a generic implementation of the <code class="literal">min</code>
 function in the preceding code).</p>
<p>Now let's look at what happens if I omit the <code class="literal">else</code>
 part (<code class="literal">Ch13_1.fsx</code>
 ):</p>
<pre class="programlisting">let f' a b = 
    if a &lt; b then 
        a 
</pre>
<p>Now the inferred signature of <code class="literal">f'</code>
 is <code class="literal">f': unit-&gt;unit-&gt;unit</code>
 ; in other words, both arguments and the result must be of type <code class="literal">unit</code>
 . What gives? The reasoning behind the seemingly counterintuitive type inference outcome is, in fact, to continue making perfect sense. Let's think what value the function <code class="literal">f'</code>
 must return when the condition <code class="literal">a &lt; b</code>
 is <code class="literal">false</code>
 ? The compiler, in the absence of explicit directions, decides that it must be <code class="literal">unit</code>
 . But wait a minute; shouldn't both branches of the <code class="literal">if-then-else</code>
 expression be of the same type? This condition can be only fulfilled if argument <code class="literal">a</code>
 is of type <code class="literal">unit</code>
 , which means argument <code class="literal">b</code>
 must be of type <code class="literal">unit</code>
 as well.</p>
<p>Fine; but what would happen if I try to push type inference into certain ways, for example, forcefully attempting <code class="literal">a</code>
 to be of generic type <code class="literal">'a (Ch13_1.fsx)</code>
 :</p>
<pre class="programlisting">let f'' (a:'a) b = 
    if a &lt; b then 
        a 
</pre>
<p>Or, what if we try pushing <code class="literal">a</code>
 in the direction of being less generic by forcing it to be of a concrete type, for example, <code class="literal">int (Ch13_1.fsx)</code>
 :</p>
<pre class="programlisting">let f''' (a:int) b = 
    if a &lt; b then 
        a 
</pre>
<p>Turns out both attempts are futile, as consideration about the <code class="literal">unit</code>
 return type of the omitted <code class="literal">else</code>
 branch is still valid. In the first case, the compiler will just make a nasty warning pointing that</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>This construct causes code to be less generic than indicated by the type annotations. The type variable <code class="literal">'a</code>
 has been constrained to be type <code class="literal">'unit'</code>
 .</em>
</span>
</p>
</blockquote>
</div>
<p>In the second case, from a compiler standpoint, there's a plain and simple error</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>This expression was expected to have type unit but here has type <code class="literal">int</code>
 .</em>
</span>
</p>
</blockquote>
</div>
<p>So, how should we handle the <code class="literal">if...then...</code>
 expressions? The moral is that this short form of conditional statement may be used only in cases where a side-effect is needed. Good examples would be logging some diagnostics or changing a mutable value. For cases where a genuine non-<code class="literal">unit</code>
 result has to be returned, the full-blown <code class="literal">if-then-else</code>
 expression must be evaluated with both branches returning values of the same type.</p>
</div>
<div class="section" title="Value restriction">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch13lvl2sec143"/>
 Value restriction</h2>
</div>
</div>
</div>
<p>This compile problem usually makes intermediate level F# developers who have grasped and proudly put to use F# features such as <span class="emphasis">
<em>partial application</em>
</span>
 and <span class="emphasis">
<em>automatic generalization</em>
</span>
 stumble. Imagine that you came out with a powerful data processing algorithm and are implementing it, enjoying the power and beauty of idiomatic F# code in the process. At some moment, you realize that you need a function that takes a list of lists and finds out whether all element lists are empty or not. Not a problem for a seasoned functional programmer like you, right? So you coin something like this (<code class="literal">Ch13_2.fsx</code>
 ):</p>
<pre class="programlisting">let allEmpty  = List.forall ((=) []) 
</pre>
<p>Surprise! It does not compile with the compiler warning:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>Value restriction. The value <code class="literal">'allEmpty'</code>
 has been inferred to have generic type <code class="literal">val allEmpty : ('_a list list -&gt; bool) when '_a:equality</code>
 Either make the arguments to <code class="literal">'allEmpty'</code>
 explicit or, if you do not intend for it to be generic, add a type annotation.</em>
</span>
</p>
</blockquote>
</div>
<p>And you (I should admit I did this on multiple occasions in the past) first stare at this mess in disbelief as the F# compiler has accurately inferred your intent but somehow dislikes it. Then you Google "f# value restriction" and get referred to <span class="strong">
<strong>MSDN Automatic Generalization</strong>
</span>
 (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/automatic-generalization">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/automatic-generalization</a>
 ), where you are told that:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>The compiler performs automatic generalization only on complete function definitions that have explicit arguments, and on simple immutable values.</em>
</span>
</p>
</blockquote>
</div>
<p>This is followed by practical recipes of working around a sudden problem. You try this advice and get the problem fixed, but you are left with the aftertaste of some black magic.</p>
<p>For me, the eye-opener was reading through this excellent blog post: <span class="strong">
<strong>Finer Points of F# Value Restriction</strong>
</span>
 (<a class="ulink" href="https://blogs.msdn.microsoft.com/mulambda/2010/05/01/finer-points-of-f-value-restriction/">https://blogs.msdn.microsoft.com/mulambda/2010/05/01/finer-points-of-f-value-restriction/</a>
 ). I will demonstrate the hidden dangers of generalization applied to mutable values that may create a motive for you to read this blog post and understand the rationale behind the F# compiler behavior.</p>
<p>Let's look at a seemingly innocuous code fragment here (<code class="literal">Ch13_2.fsx</code>
 ):</p>
<pre class="programlisting">let gr&lt;'a&gt; : 'a list ref = ref [] 
gr := ["a"] 
let x: string list = !gr 
printfn "%A" x 
</pre>
<p>Guess what would be the printed <code class="literal">x</code>
 value upon this fragment execution? That would be <code class="literal">["a"]</code>
 , right?</p>
<p>Wrong; <code class="literal">[]</code>
 is what happens! The cause of this is that <code class="literal">gr</code>
 , despite appearing as a value of type <code class="literal">'a list ref</code>
 , is, in fact, a type function. Used on the left-hand side of the <code class="literal">:=</code>
 operator, it just brings a fresh unbound reference instance. Used on the right-hand side of operator <code class="literal">!</code>
 , it brings just another fresh reference instance that refers to an empty list, <code class="literal">[]</code>
 . In order to achieve the intuitively expected behavior, we need to bind <code class="literal">gr</code>
 applied to the type argument string to the concrete typed variable <code class="literal">cr</code>
 , and then the latter, being a normal reference, will behave as expected (<code class="literal">Ch13_2.fsx</code>
 ):</p>
<pre class="programlisting">let cr = gr&lt;string&gt; 
cr := ["a"] 
let y = !cr 
printfn "%A" y 
</pre>
<p>Now the printed value is <code class="literal">["a"]</code>
 indeed. Imposing a value restriction error in all cases where the situation deviates from the safest use case compiler protects developers from the surprise code behavior of the kind demonstrated earlier. Getting back to my initial sample, the possible remedial action can be any of the following (<code class="literal">Ch13_2.fsx</code>
 ):</p>
<pre class="programlisting">let allEmpty xs = List.forall ((=) []) xs // remedy 1 
let allEmpty : int list list -&gt; bool  = List.forall ((=) []) 
// remedy 2 
let allEmpty = fun x -&gt; List.forall ((=) []) x // remedy 3 
</pre>
<div class="section" title="Imperfect pattern matching">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_3"><a id="ch13lvl3sec34"/>
 Imperfect pattern matching</h3>
</div>
</div>
</div>
<p>Many seemingly counterintuitive F# compile-time errors and warnings belong to the field of pattern matching. For example, take a look the following naive detection of the integer argument sign:</p>
<pre class="programlisting">let positive = function 
| x when x &gt; 0 -&gt; true 
| x when x &lt;= 0 -&gt; false 
</pre>
<p>Despite seeming completeness, this produces the compiler's warning:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>incomplete pattern matches on this expression</em>
</span>
</p>
</blockquote>
</div>
<p>Turns out that the F# compiler, if presented with the <code class="literal">when</code>
 guards, assumes that this construction designates an incomplete match case by definition. This is why regardless of the fact that the given set of cases is semantically complete, the compiler considers the function definition incomplete. Simply removing the excessive last <code class="literal">when</code>
 guard immediately fixes the problem (<code class="literal">Ch13_3.fsx</code>
 ):</p>
<pre class="programlisting">let positive' = function 
| x when x &gt; 0 -&gt; true 
| _ -&gt; false 
</pre>
<p>Another common related problem is unreachable matching rules. Most of the time, unreachable matching rules get into play when the programmer mistakenly uses a variable instead of a literal in the sequence of rules, creating a premature catch-all case. In such cases, the compiler uses benign warnings, although almost always, the run-time results are messed-up. Therefore, perhaps denoting these occasions as errors would be a better design choice. A couple of years ago I wrote a <span class="strong">
<strong>blog post</strong>
</span>
 (<a class="ulink" href="https://infsharpmajor.wordpress.com/2011/10/13/union-matching-challenge/">https://infsharpmajor.wordpress.com/2011/10/13/union-matching-challenge/</a>
 ) on this matter, which I reproduce here as the illustration of the problem in the following snippet (<code class="literal">Ch13_3.fsx</code>
 ):</p>
<pre class="programlisting">type TickTack = Tick | Tack 
 
let ticker x = 
    match x with 
    | Tick -&gt; printfn "Tick" 
    | Tock -&gt; printfn "Tock" 
    | Tack -&gt; printfn "Tack" 
ticker Tick 
ticker Tack 
</pre>
<p>This may trick you into expecting the <code class="literal">Tick</code>
 output followed by <code class="literal">Tack</code>
 , but in fact, the <code class="literal">Tick</code>
 output is to be followed by <code class="literal">Tock</code>
 !</p>
<p>The F# compiler issues two warnings for the preceding fragment. The first warning prompts you that typo <code class="literal">Tock</code>
 is taken as a variable and not a literal, like literals of type <code class="literal">TickTack</code>
 in two other cases:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>Uppercase variable identifiers should not generally be used in patterns, and may indicate a misspelt pattern name</em>
</span>
</p>
</blockquote>
</div>
<p>The second warning:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>This rule will never be matched</em>
</span>
</p>
</blockquote>
</div>
<p>directly indicates the outcome caused by the typo.</p>
<p>The moral here is that the F# developer should be attentive to warnings. Treating rule unreachability by the compiler as an error would be more adequate perhaps.</p>
</div>
</div>
</div>


<div class="section" title="Addressing run-time problems">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch13lvl1sec78"/>
 Addressing run-time problems</h1>
</div>
</div>
</div>
<p>The mantra "<span class="emphasis">
<em>if it compiles, it works</em>
</span>
 " helps followers score amazingly well in time-to-market ratings for enterprise software development.</p>
<p>Taking Jet.com as an example of building green field e-commerce platform implementation, it has really condensed the path from zero to <span class="strong">
<strong>minimum viable product</strong>
</span>
 (<span class="strong">
<strong>MVP</strong>
</span>
 ) in less than a year. Release of the platform to the production mode took place in a bit more than a year from the reception.</p>
<p>Does this mean following a functional-first approach is a software development silver bullet? Surely not on an absolute scale, although on a relative scale, the improvements are just great.</p>
<p>Why is the success not exhaustive? The thing is that the practice requires transition from gory ideas to mundane implementation issues. No matter how accurate our implementations are, there are always dark corners exist where unexpected problems may lurk.</p>
<p>Let me demonstrate this with a sample taken from F# enterprise development practice at Jet.com. Jet represents an innovative e-commerce platform, bringing together many business areas, such as Internet ordering, retail selling, warehousing, finance, accounting, transportation, you name it. Each of these areas usually carries its own unique metadata classifications; so, in order to run them side by side, one of the most common operations within the implementation is mapping. And the generally accepted practice of using unique non-clashing identifications is based on GUIDs or <span class="strong">
<strong>Global Unique Identifiers</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Globally_unique_identifier">https://en.wikipedia.org/wiki/Globally_unique_identifier</a>
 ).</p>
<p>Realistically assuming that quite frequently, enterprise software deals with dictionaries and caches using GUIDs as access keys, let's look at how good the core .NET library <code class="literal">System.Guid</code>
 implementation for the purpose would be.</p>
<p>Here goes a quite simplistic explorative implementation using a dictionary that has instances of the <code class="literal">System.Guid</code>
 type as keys. I created a simple <code class="literal">dictionary</code>
 based on the standard F# core library implementation having type <code class="literal">IDictionary&lt;Guid,int&gt;</code>
 . I populated it with the size number of pairs (<code class="literal">Guid,int</code>
 ), just for the sake of simplicity. Now, I will imitate a big <code class="literal">trials</code>
 number of random accesses to the dictionary using array <code class="literal">keys</code>
 as a level of indirection and measuring the performance. The following snippet shows the composition of the required code pieces (<code class="literal">Ch13_4.fsx</code>
 ):</p>
<pre class="programlisting">open System 
open System.Collections.Generic 
let size = 1000 
let keys = Array.zeroCreate&lt;Guid&gt; size 
let mutable dictionary : IDictionary&lt;Guid,int&gt; = 
    Unchecked.defaultof&lt;IDictionary&lt;Guid,int&gt;&gt; 
let generate () = 
    for i in 0..(size-1) do 
        keys.[i] &lt;- Guid.NewGuid() 
    dictionary &lt;- seq { for i in 0..(size-1) -&gt; (keys.[i],i) } |&gt; dict 
generate() 
let trials = 10000000 
let rg = Random() 
let mutable result = 0 
for i in 0..trials-1 do 
    result &lt;- dictionary.Item(keys.[rg.Next(size-1)]) 
</pre>
<p>Running this snippet through FSI with timing turned on yields the performance indicators shown in the following screenshot (only the valuable output is shown for brevity):</p>
<div class="mediaobject"><img src="Image00066.jpg" alt="Addressing run-time problems"/>
<div class="caption">
<p>Using native System.Guid to access a dictionary</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>10 million accesses for 6.445 seconds translates into a bit higher than 1.5 million accesses per second. Not too fast. Let's take it for the baseline. Also, a worrying sign is a number of garbage collections that took place: 287 per 10000 accesses is not light.</p>
<p>Without digging dipper into the causes of the observed code behavior here, let me just show the results of the findings performed for Jet.com in an attempt to improve the watermark. I will introduce a simple change instead of using the genuine <code class="literal">System.Guid</code>
 type that is a quite complicated Windows system data structure as a dictionary key, I will use the representation of the GUID value as a hexadecimal string that is leftover when the canonical presentation is stripped of dashes. For example, the <code class="literal">f4d1734c-1e9e-4a25-b8d9-b7d96f48e0f</code>
 GUID will be represented as a <code class="literal">f4d1734c1e9e4a25b8d9b7d96f48e0f</code>
 string. This will require minimal changes to the previous snippet (<code class="literal">Ch13_4.fsx</code>
 ):</p>
<pre class="programlisting">let keys' = Array.zeroCreate&lt;string&gt; size 
let mutable dictionary' : IDictionary&lt;string,int&gt; = 
    Unchecked.defaultof&lt;IDictionary&lt;string,int&gt;&gt; 
let generate' () = 
    for i in 0..(size-1) do 
        keys'.[i] &lt;- keys.[i].ToString("N") 
    dictionary' &lt;- seq { for i in 0..(size-1) -&gt; (keys'.[i],i) } |&gt; dict 
generate'() 
for i in 0..trials-1 do 
    result &lt;- dictionary'.Item(keys'.[rg.Next(size-1)]) 
</pre>
<p>Here, I will just create a new <code class="literal">keys'</code>
 indirection layer made from corresponding parts of <code class="literal">keys</code>
 via a simple data conversion. Turning to FSI with this change brings a big surprise reflected in the following screenshot:</p>
<div class="mediaobject"><img src="Image00067.jpg" alt="Addressing run-time problems"/>
<div class="caption">
<p>Switching from System.Guid to string in order to access a dictionary</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Compared to the baseline, the new access rate constitutes 16.4 millions accesses per second almost 11 times better! Also, garbage collection experiences a five-fold improvement.</p>
<p>Now remember that mappings based on <code class="literal">System.Guid</code>
 are ubiquitous for the platform and you can imagine the amount of impact from the above simple change to the overall platform performance.</p>
</div>


<div class="section" title="Summary">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch13lvl1sec79"/>
 Summary</h1>
</div>
</div>
</div>
<p>This chapter should leave you prepared for the defect type displacement taking place in the functional-first development in comparison to other development paradigms. A decreased rate of run-time errors typical to F# code shortens the time to market for developed systems and releases development resources for performance optimizations if they are deemed necessary.</p>
<p>We have reached the end of the book, where I equipped you with a whole slew of patterns of idiomatic F# use. The key assumption that the book makes is that such use requires from developers that come from other programming paradigms a certain shift in thinking habits, a distinct angle of seeing problems, and correspondent patterns and techniques populating the functional programmer tool belt. At this point you should be able to approach thinking through any problem by decomposing it into a handful of known building blocks and then composing the solution with appropriate functions and combinators. You also were shown the benefits of using standard F# algebraic data types over crafting custom .NET classes. Rely on patterns that you have acquired here in your functional designs; retain, recall, and reuse them in your day-to-day practices.</p>
<p>I hope that this book may guide you onto a path to the field of idiomatic functional programming. Good luck getting there!</p>
</div>
</body></html>