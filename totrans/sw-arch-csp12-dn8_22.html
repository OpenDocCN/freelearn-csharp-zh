<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer383">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">22</span></h1>
<h1 class="chapterTitle" id="_idParaDest-473"><span class="koboSpan" id="kobo.2.1">Case Study Extension: Developing .NET Microservices for Kubernetes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In this chapter, we bridge the insights from </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.5.1">, where we explored the practical implementation of .NET microservices, with the foundational knowledge of Kubernetes presented in </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 20, Kubernetes</span></em><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">Our focus here is on preparing .NET code for seamless integration with Kubernetes, encompassing the complete development cycle—from coding to debugging, and even troubleshooting post-deployment challenges.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.8.1">We will guide you through the process of setting up a development workstation optimized for Kubernetes, learn the intricacies of packaging code with Docker, and understand how to organize your codebase for flawless execution across varied environments, such as Docker Desktop, local minikube installations, and production or staging Kubernetes clusters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">Also, this chapter delves into the nuances of remote debugging, providing you with the necessary skills to efficiently troubleshoot and debug your application. </span><span class="koboSpan" id="kobo.9.2">Here, you will learn how to prepare each developer workstation, how to package the code with Docker, and how to organize the code so that it can immediately run both on the developer Docker Desktop, on the developer’s local Minikube installation, and on the production/staging Kubernetes clusters, without modifications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">By the end of the chapter, you will have mastered remote debugging techniques for applications in production or staging environments, enabling swift issue resolution and system reliability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">More specifically, you will learn about the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">The tools needed for .NET Kubernetes development</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Organizing the development process</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Running your application in Minikube</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Remote debugging of a Kubernetes application</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.16.1">All concepts will be explained with the help of a previous example taken from </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 21</span></em><span class="koboSpan" id="kobo.18.1">,</span><em class="italic"><span class="koboSpan" id="kobo.19.1"> Case Study</span></em><span class="koboSpan" id="kobo.20.1">, which we will adapt for Kubernetes execution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.21.1">You’ll adapt the </span><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.23.1"> microservice from </span><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 21</span></em><span class="koboSpan" id="kobo.25.1">,</span><em class="italic"><span class="koboSpan" id="kobo.26.1"> Case Study</span></em><span class="koboSpan" id="kobo.27.1">, seeing firsthand how a real-world application transitions to Kubernetes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.28.1">To fully leverage this chapter, fortify your understanding of Docker and Kubernetes as laid out in </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Chapter 11</span></em><span class="koboSpan" id="kobo.30.1">,</span><em class="italic"><span class="koboSpan" id="kobo.31.1"> Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.32.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.33.1">Chapter 20</span></em><span class="koboSpan" id="kobo.34.1">,</span><em class="italic"><span class="koboSpan" id="kobo.35.1"> Kubernetes</span></em><span class="koboSpan" id="kobo.36.1">, which form the foundation for the advanced practices discussed herein.</span></p>
<h1 class="heading-1" id="_idParaDest-474"><span class="koboSpan" id="kobo.37.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.38.1">This chapter requires Visual Studio 2022 free Community Edition or better, with all the database tools installed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.39.1">You will also need these:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.40.1">WSL</span></strong><span class="koboSpan" id="kobo.41.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.42.1">Windows Subsystem for Linux</span></strong><span class="koboSpan" id="kobo.43.1">) and </span><em class="italic"><span class="koboSpan" id="kobo.44.1">Docker Desktop for Windows</span></em><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">Detailed instructions on how to install both of them are given in the </span><em class="italic"><span class="koboSpan" id="kobo.46.1">Technical requirements</span></em><span class="koboSpan" id="kobo.47.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.48.1">Chapter 11, Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.49.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.50.1">A Minikube installation that specifies Docker as a virtualization tool. </span><span class="koboSpan" id="kobo.50.2">Minikube installation is described in the </span><em class="italic"><span class="koboSpan" id="kobo.51.1">Using Minikube</span></em><span class="koboSpan" id="kobo.52.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.53.1">Chapter 20</span></em><span class="koboSpan" id="kobo.54.1">, </span><em class="italic"><span class="koboSpan" id="kobo.55.1">Kubernetes</span></em><span class="koboSpan" id="kobo.56.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.57.1">A SQL Server database that allows TCP/IP connections. </span><span class="koboSpan" id="kobo.57.2">You can’t use </span><em class="italic"><span class="koboSpan" id="kobo.58.1">SQL Server Express LocalDB</span></em><span class="koboSpan" id="kobo.59.1">, which comes with Visual Studio installation, since it doesn’t allow TCP/IP connections. </span><span class="koboSpan" id="kobo.59.2">So you need either a full SQL Express installation or an Azure SQL Server database. </span><span class="koboSpan" id="kobo.59.3">More details on how to fulfill this requirement will be given in the </span><em class="italic"><span class="koboSpan" id="kobo.60.1">Tools needed for .NET Kubernetes development</span></em><span class="koboSpan" id="kobo.61.1"> section of this chapter.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.62.1">All the code of this chapter can be found in the GitHub repository associated with this book: </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.63.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.64.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-475"><span class="koboSpan" id="kobo.65.1">The Tools needed for .NET Kubernetes development</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.66.1">Each single microservice can be unit-tested and debugged independently from the remainder of its application, with the technique you learned </span><em class="italic"><span class="koboSpan" id="kobo.67.1">Chapter 9</span></em><span class="koboSpan" id="kobo.68.1">,</span><em class="italic"><span class="koboSpan" id="kobo.69.1"> Testing Your Enterprise Application</span></em><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">You don’t need to package it inside a Docker image to do this.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.71.1">However, debugging and performing</span><a id="_idIndexMarker1728"/><span class="koboSpan" id="kobo.72.1"> integration tests on the whole application or parts of it requires that all involved microservices interact and are packaged as in the final application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.73.1">You can use a staging environment to beta-test your application. </span><span class="koboSpan" id="kobo.73.2">Prior to staging deployment, ensure your application’s stability in the development environment to prevent time-consuming troubleshooting, because the staging environment doesn’t have all the facilities that are available in a development environment. </span><span class="koboSpan" id="kobo.73.3">Otherwise, troubleshooting all frequent bugs and crashes discovered in the staging environment might imply an unacceptable time cost.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.74.1">Therefore, it is preferable to reach good application stability before deploying the application in a staging environment. </span><span class="koboSpan" id="kobo.74.2">Moreover, for easier and more efficient debug-fix cycles, it is desirable that all microservices run on each single developer machine. </span><span class="koboSpan" id="kobo.74.3">That’s why each developer workstation must be equipped with both Docker and Minikube.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.75.1">Furthermore, the developer machine must be able to simulate all communications between microservices and between services and other storage media, like databases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.76.1">It is likely that, Minikube can run and simulate all communications that occur in an actual Kubernetes cluster, including when it runs on a single development machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.77.1">We can also let all involved Docker images communicate among them before loading them on Minikube because Docker Desktop allows the creation of virtual networks that are accessible by the local Docker images.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.78.1">Finally, both Docker and Minikube virtual networks automatically include the development machine that hosts them, so we can place storage services like disk volumes and databases on the development machine itself.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.79.1"><img alt="" role="presentation" src="../Images/B19820_22_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.80.1">Figure 22.1: Minikube and Docker network structure</span></p>
<p class="normal"><span class="koboSpan" id="kobo.81.1">However, the sophisticated virtual </span><a id="_idIndexMarker1729"/><span class="koboSpan" id="kobo.82.1">network facilities of both Docker and Kubernetes are not enough to ensure an efficient development and debugging environment, and further tools are needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.83.1">Below are all the issues we need to</span><a id="_idIndexMarker1730"/><span class="koboSpan" id="kobo.84.1"> fix to configure an efficacious development-debugging environment and how to solve them:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.85.1">As a default, Visual Studio installs </span><em class="italic"><span class="koboSpan" id="kobo.86.1">SQL Server Express LocalDB</span></em><span class="koboSpan" id="kobo.87.1"> instead of </span><em class="italic"><span class="koboSpan" id="kobo.88.1">SQL Server Express</span></em><span class="koboSpan" id="kobo.89.1">, and SQL Server Express LocalDB is not able to communicate via actual or virtual networks. </span><span class="koboSpan" id="kobo.89.2">Therefore, we need either an SQL Server Express installation or an external database.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.90.1">Since Kubernetes nodes have just virtual addresses that are handled by the Kubernetes engine itself, a Visual Studio debugger can be attached to a running microservice just through the REST API of the Kubernetes engine. </span><span class="koboSpan" id="kobo.90.2">At the time of writing, the best tool available for Visual Studio is </span><em class="italic"><span class="koboSpan" id="kobo.91.1">Bridge to Kubernetes, </span></em><span class="koboSpan" id="kobo.92.1">which, in turn, uses </span><em class="italic"><span class="koboSpan" id="kobo.93.1">kubectl</span></em><span class="koboSpan" id="kobo.94.1"> to interact with the API of any Kubernetes cluster, Minikube included. </span><span class="koboSpan" id="kobo.94.2">Unluckily, we can’t use the Kubectl installation that runs on the virtual machine that hosts Minikube as we did in </span><em class="italic"><span class="koboSpan" id="kobo.95.1">Chapter 20</span></em><span class="koboSpan" id="kobo.96.1">,</span><em class="italic"><span class="koboSpan" id="kobo.97.1"> Kubernetes</span></em><span class="koboSpan" id="kobo.98.1">, but we need an installation that runs directly in the development machine.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.99.1">We describe how to install </span><a id="_idIndexMarker1731"/><span class="koboSpan" id="kobo.100.1">and configure all tools mentioned in the above points in two dedicated subsections.</span></p>
<h2 class="heading-2" id="_idParaDest-476"><span class="koboSpan" id="kobo.101.1">Installing and configuring SQL Server Express</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.102.1">If you have access to an SQL Server instance </span><a id="_idIndexMarker1732"/><span class="koboSpan" id="kobo.103.1">running in your development </span><a id="_idIndexMarker1733"/><span class="koboSpan" id="kobo.104.1">machine, you can use that one. </span><span class="koboSpan" id="kobo.104.2">Otherwise, you can choose between creating an SQL Server database in Azure following the instructions contained</span><em class="italic"> </em><span class="koboSpan" id="kobo.105.1">in</span><em class="italic"><span class="koboSpan" id="kobo.106.1"> Chapter 12</span></em><span class="koboSpan" id="kobo.107.1">,</span><em class="italic"><span class="koboSpan" id="kobo.108.1"> Choosing Your Data Storage in the Cloud</span></em><span class="koboSpan" id="kobo.109.1">, or installing a local instance of SQL Server Express:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.110.1">Begin by downloading the SQL Server installer from </span><a href="https://www.microsoft.com/en-US/download/details.aspx?id=104781"><span class="url"><span class="koboSpan" id="kobo.111.1">https://www.microsoft.com/en-US/download/details.aspx?id=104781</span></span></a><span class="koboSpan" id="kobo.112.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.113.1">You can freely choose between SQL Server Express and SQL Server Express Advanced, but please select a complete installation that includes both </span><strong class="screenText"><span class="koboSpan" id="kobo.114.1">SQL Server Management Studio</span></strong><span class="koboSpan" id="kobo.115.1"> and the</span><strong class="screenText"><span class="koboSpan" id="kobo.116.1"> SQL Server Management console</span></strong><span class="koboSpan" id="kobo.117.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.118.1">Select to install SQL Server as the default instance on your machine (the default in the installation procedure).
    </span><p class="normal"><span class="koboSpan" id="kobo.119.1">Immediately after the installation, you must run SQL Server Management Console (just write this name in the Windows search box) to enable TCP/IP-based connections. </span><span class="koboSpan" id="kobo.119.2">In order to configure SQL Server properly, follow all the steps below.</span></p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4"><span class="koboSpan" id="kobo.120.1">Once in the SQL Server Management Console, expand the </span><strong class="screenText"><span class="koboSpan" id="kobo.121.1">SQL Server Network Configuration</span></strong><span class="koboSpan" id="kobo.122.1"> node.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.123.1">Select </span><strong class="screenText"><span class="koboSpan" id="kobo.124.1">Protocols for &lt;your instance name&gt;</span></strong><span class="koboSpan" id="kobo.125.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.126.1">On the right detail pane, you should see all the available communication protocols.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.127.1">Right-click on </span><strong class="screenText"><span class="koboSpan" id="kobo.128.1">TCP</span></strong><span class="koboSpan" id="kobo.129.1">/</span><strong class="screenText"><span class="koboSpan" id="kobo.130.1">IP</span></strong><span class="koboSpan" id="kobo.131.1"> and select </span><strong class="screenText"><span class="koboSpan" id="kobo.132.1">Enable</span></strong><span class="koboSpan" id="kobo.133.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.134.1">Now, TCP/IP is enabled but on a dynamic port. </span><span class="koboSpan" id="kobo.134.2">In order to impose a fixed port, right-click on the same TCP/IP node and select </span><strong class="screenText"><span class="koboSpan" id="kobo.135.1">Properties</span></strong><span class="koboSpan" id="kobo.136.1">.</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.137.1"><img alt="" role="presentation" src="../Images/B19820_22_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.138.1">Figure 22.2: Forcing a static IP address</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9"><span class="koboSpan" id="kobo.139.1">Select the </span><strong class="screenText"><span class="koboSpan" id="kobo.140.1">IP Addresses</span></strong><span class="koboSpan" id="kobo.141.1"> tab.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.142.1">You should see several IP addresses. </span><span class="koboSpan" id="kobo.142.2">These are all IP addresses that are associated with your </span><a id="_idIndexMarker1734"/><span class="koboSpan" id="kobo.143.1">computer, and each of them executes</span><a id="_idIndexMarker1735"/><span class="koboSpan" id="kobo.144.1"> the next step.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.145.1">Remove the </span><strong class="screenText"><span class="koboSpan" id="kobo.146.1">0</span></strong><span class="koboSpan" id="kobo.147.1"> that is in </span><strong class="screenText"><span class="koboSpan" id="kobo.148.1">TCP Dynamic Port</span></strong><span class="koboSpan" id="kobo.149.1"> and keep this field empty, and then write </span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">1433</span></code><span class="koboSpan" id="kobo.151.1"> in the </span><strong class="screenText"><span class="koboSpan" id="kobo.152.1">TCP Port</span></strong><span class="koboSpan" id="kobo.153.1"> field.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.154.1">Once finished, click on the </span><strong class="screenText"><span class="koboSpan" id="kobo.155.1">OK</span></strong><span class="koboSpan" id="kobo.156.1"> button.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.157.1">Now, you need to restart the SQL Server service. </span><span class="koboSpan" id="kobo.157.2">Select </span><strong class="screenText"><span class="koboSpan" id="kobo.158.1">SQL Server Services</span></strong><span class="koboSpan" id="kobo.159.1"> in the left pane.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.160.1">Finally, in the right detail pane, right-click on </span><strong class="screenText"><span class="koboSpan" id="kobo.161.1">SQL Server &lt;your instance name&gt;</span></strong><span class="koboSpan" id="kobo.162.1"> and select </span><strong class="screenText"><span class="koboSpan" id="kobo.163.1">Restart</span></strong><span class="koboSpan" id="kobo.164.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.165.1">Once installed, the SQL Server only has Windows authentication enabled. </span><span class="koboSpan" id="kobo.165.2">In order to use the instance on a non-Windows network, you must enable username-based authentication and define at least one administrative user. </span><span class="koboSpan" id="kobo.165.3">This is a necessary step because </span><a id="_idIndexMarker1736"/><span class="koboSpan" id="kobo.166.1">Windows authentication will not work on Docker networks and Kubernetes.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.167.1">You can do this in SQL</span><a id="_idIndexMarker1737"/><span class="koboSpan" id="kobo.168.1"> Server Management Studio. </span><span class="koboSpan" id="kobo.168.2">Once SQL Server Management Studio opens, it prompts you for an instance to connect with and for authentication information. </span><span class="koboSpan" id="kobo.168.3">The instance name of the database you just installed should be something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">&lt;computer name&gt;\SQLEXPRESS</span></code><span class="koboSpan" id="kobo.170.1">; select it and also select </span><strong class="screenText"><span class="koboSpan" id="kobo.171.1">Windows Authentication</span></strong><span class="koboSpan" id="kobo.172.1">, as shown below:</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.173.1"><img alt="" role="presentation" src="../Images/B19820_22_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.174.1">Figure 22.3: Connecting with SQL Server Management Studio</span></p>
<p class="normal"><span class="koboSpan" id="kobo.175.1">Once connected with the database, you can enable username-based authentication as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.176.1">Right-click on your server icon in Object Explorer and choose </span><strong class="screenText"><span class="koboSpan" id="kobo.177.1">Properties</span></strong><span class="koboSpan" id="kobo.178.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.179.1">In the window that opens, select </span><strong class="screenText"><span class="koboSpan" id="kobo.180.1">Security</span></strong><span class="koboSpan" id="kobo.181.1"> in the left pane.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.182.1">Select </span><strong class="screenText"><span class="koboSpan" id="kobo.183.1">SQL Server and Windows Authentication mode</span></strong><span class="koboSpan" id="kobo.184.1">, as shown in the screenshot below:</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.185.1"><img alt="" role="presentation" src="../Images/B19820_22_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.186.1">Figure 22.4: Enabling SQL Server authentication</span></p>
<p class="normal"><span class="koboSpan" id="kobo.187.1">In order to make your changes </span><a id="_idIndexMarker1738"/><span class="koboSpan" id="kobo.188.1">effective, you must restart SQL Server. </span><span class="koboSpan" id="kobo.188.2">You </span><a id="_idIndexMarker1739"/><span class="koboSpan" id="kobo.189.1">can do it by right-clicking on your server icon in Object Explorer and by selecting </span><strong class="screenText"><span class="koboSpan" id="kobo.190.1">Restart</span></strong><span class="koboSpan" id="kobo.191.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.192.1">Now, you need to define at least one user by following the steps below:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.193.1">Expand the </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">Security</span></code><span class="koboSpan" id="kobo.195.1"> folder </span><a id="_idIndexMarker1740"/><span class="koboSpan" id="kobo.196.1">under your server icon in Object Explorer.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.197.1">Right-click on the </span><strong class="screenText"><span class="koboSpan" id="kobo.198.1">Logins</span></strong><span class="koboSpan" id="kobo.199.1"> folder and </span><a id="_idIndexMarker1741"/><span class="koboSpan" id="kobo.200.1">select </span><strong class="screenText"><span class="koboSpan" id="kobo.201.1">New Login</span></strong><span class="koboSpan" id="kobo.202.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.203.1">In the window that opens, insert a username.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.204.1">Select </span><strong class="screenText"><span class="koboSpan" id="kobo.205.1">SQL Server authentication</span></strong><span class="koboSpan" id="kobo.206.1">, insert a password, and confirm it by retyping the same password in the </span><strong class="screenText"><span class="koboSpan" id="kobo.207.1">Confirm password</span></strong><span class="koboSpan" id="kobo.208.1"> field, as shown in the screenshot below:</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.209.1"><img alt="" role="presentation" src="../Images/B19820_22_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.210.1">Figure 22.5: Defining user name and password</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5"><span class="koboSpan" id="kobo.211.1">Finally, right-click on </span><strong class="screenText"><span class="koboSpan" id="kobo.212.1">Server Roles</span></strong><span class="koboSpan" id="kobo.213.1"> and</span><a id="_idIndexMarker1742"/><span class="koboSpan" id="kobo.214.1"> enable the </span><strong class="screenText"><span class="koboSpan" id="kobo.215.1">sysadmin</span></strong><span class="koboSpan" id="kobo.216.1"> role to give all rights to the new user.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.217.1">And there you have it! </span><span class="koboSpan" id="kobo.217.2">Now, your</span><a id="_idIndexMarker1743"/><span class="koboSpan" id="kobo.218.1"> SQL Server instance can be used by both Docker and Minikube.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.219.1">The next subsection explains how to configure Visual Studio for debugging applications running on Minikube or any other Kubernetes cluster.</span></p>
<h2 class="heading-2" id="_idParaDest-477"><span class="koboSpan" id="kobo.220.1">Enabling Kubernetes application debugging with Bridge to Kubernetes</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.221.1">Since microservices running on Kubernetes have no fixed IP address and ports attached to them, only virtual addresses that are solved at runtime by Kubernetes, we can’t attach the Visual Studio debugger directly to any running microservice. </span><span class="koboSpan" id="kobo.221.2">That’s why we need software like Bridge to Kubernetes, which interacts with the Kubernetes API to enable debugging.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.222.1">Bridge to Kubernetes is a Visual Studio extension that’s easy to install, but it requires Kubectl to be installed on your development machine, which presents a challenge, as there is no direct Windows installer for Kubectl. </span><span class="koboSpan" id="kobo.222.2">In this subsection, we’ll guide you through the process of installing both Bridge to Kubernetes and Kubectl, overcoming the lack of a direct Windows installer for the latter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.223.1">Bridge to Kubernetes enables Kubernetes application debugging by interacting with the Kubernetes API via Kubectl. </span><span class="koboSpan" id="kobo.223.2">However, it is not a debugger driver or a debugger extension. </span><span class="koboSpan" id="kobo.223.3">It does a completely different job; it asks you to select a service running in a Kubernetes cluster and reroute all communication with this service to a locally running Visual Studio POD replica instead of the actual cluster POD.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.224.1"><img alt="" role="presentation" src="../Images/B19820_22_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.225.1">Figure 22.6: How Bridge to Kubernetes works</span></p>
<p class="normal"><span class="koboSpan" id="kobo.226.1">Therefore, the developer debugs a</span><a id="_idIndexMarker1744"/><span class="koboSpan" id="kobo.227.1"> local copy of the POD code but in exactly the same dynamic Kubernetes environment as the original POD. </span><span class="koboSpan" id="kobo.227.2">This way, you have all the facilities </span><a id="_idIndexMarker1745"/><span class="koboSpan" id="kobo.228.1">offered by a usual local debugging session, but while you are debugging it, your code interacts with the actual Kubernetes cluster you need to fix.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.229.1">Bridge to Kubernetes doesn’t work just with Minikube; it works with any Kubernetes cluster. </span><span class="koboSpan" id="kobo.229.2">Thus, you can use it for debugging the whole application on your development machine, and also for debugging the staging application or the production application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.230.1">Since you debug just the local code and not the deployed code, you are not forced to compile an application in debug mode in order to debug it. </span><span class="koboSpan" id="kobo.230.2">You can deploy the application with all compilation optimizations you want without caring about possible debugging needs; it is enough to have local copies of the PODs you would like to debug compiled in debug mode.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.231.1">You will learn how to use Bridge to Kubernetes in practice in the </span><em class="italic"><span class="koboSpan" id="kobo.232.1">Remote debugging of a Kubernetes application</span></em><span class="koboSpan" id="kobo.233.1"> section. </span><span class="koboSpan" id="kobo.233.2">The remainder of this section will explain all the steps needed to install Bridge to Kubernetes on a development machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.234.1">First of all, you need to install Kubectl. </span><span class="koboSpan" id="kobo.234.2">The simplest way to do it is by using the Chocolatey package manager.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.235.1">Chocolatey is a package manager like NuGet. </span><span class="koboSpan" id="kobo.235.2">Similarly, it consists of a public repository containing all packages and a client you must install on your machine, in order to interact with the public repository.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.236.1">If you don’t have Chocolatey already installed, you can install it from a PowerShell prompt, as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.237.1">Search </span><strong class="screenText"><span class="koboSpan" id="kobo.238.1">PowerShell</span></strong><span class="koboSpan" id="kobo.239.1"> in the Windows search box.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.240.1">Right-click on the PowerShell link and select to execute it as an administrator.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.241.1">Finally, execute the PowerShell command </span><a id="_idIndexMarker1746"/><span class="koboSpan" id="kobo.242.1">suggested on the official Chocolatey page: </span><a href="https://chocolatey.org/install#individual"><span class="url"><span class="koboSpan" id="kobo.243.1">https://chocolatey.org/install#individual</span></span></a><span class="koboSpan" id="kobo.244.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.245.1">The PowerShell command to</span><a id="_idIndexMarker1747"/><span class="koboSpan" id="kobo.246.1"> execute is repeated below for your convenience:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.247.1">Set-ExecutionPolicy</span></span><span class="koboSpan" id="kobo.248.1"> Bypass </span><span class="hljs-literal"><span class="koboSpan" id="kobo.249.1">-Scope</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.250.1">Process</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.251.1">-Force</span></span><span class="koboSpan" id="kobo.252.1">; [</span><span class="hljs-type"><span class="koboSpan" id="kobo.253.1">System.Net.ServicePointManager</span></span><span class="koboSpan" id="kobo.254.1">]::SecurityProtocol = [</span><span class="hljs-type"><span class="koboSpan" id="kobo.255.1">System.Net.ServicePointManager</span></span><span class="koboSpan" id="kobo.256.1">]::SecurityProtocol </span><span class="hljs-operator"><span class="koboSpan" id="kobo.257.1">-bor</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.258.1">3072</span></span><span class="koboSpan" id="kobo.259.1">; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.260.1">iex</span></span><span class="koboSpan" id="kobo.261.1"> ((</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.262.1">New-Object</span></span><span class="koboSpan" id="kobo.263.1"> System.Net.WebClient).DownloadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.264.1">'https://community.chocolatey.org/install.ps1'</span></span><span class="koboSpan" id="kobo.265.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.266.1">Once installation is complete, run </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">choco -?</span></code><span class="koboSpan" id="kobo.268.1"> to verify that the installation was successful and that the Chocolatey user interface works properly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.269.1">With Chocolatey installed, installing </span><a id="_idIndexMarker1748"/><span class="koboSpan" id="kobo.270.1">Kubectl is super easy; just open a Windows Command Prompt as an administrator and type this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.271.1">choco install kubernetes-cli
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.272.1">You can check whether everything works properly by typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">kubectl version –client</span></code><span class="koboSpan" id="kobo.274.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.275.1">Kubectl should be configured to access a specific cluster, but when you start Minikube with </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">minikube start</span></code><span class="koboSpan" id="kobo.277.1">, Minikube automatically configures it to access the local Minikube cluster, so you don’t need to worry about Kubectl configuration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.278.1">Now, you are ready to install Bridge to Kubernetes, as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.279.1">Open Visual Studio and select </span><strong class="screenText"><span class="koboSpan" id="kobo.280.1">Extensions -&gt; Manage Extensions</span></strong><span class="koboSpan" id="kobo.281.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.282.1">Search </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">Bridge to Kubernetes</span></code><span class="koboSpan" id="kobo.284.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.285.1">Select it and install it.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.286.1">And there you have it! </span><span class="koboSpan" id="kobo.286.2">Now, your development machine is ready for .NET Kubernetes development. </span><span class="koboSpan" id="kobo.286.3">The next section</span><a id="_idIndexMarker1749"/><span class="koboSpan" id="kobo.287.1"> details the development process and explains</span><a id="_idIndexMarker1750"/><span class="koboSpan" id="kobo.288.1"> how to modify an existing project to run with both the local Docker installation and any Kubernetes cluster.</span></p>
<h1 class="heading-1" id="_idParaDest-478"><span class="koboSpan" id="kobo.289.1">Organizing the development process</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.290.1">Since Visual Studio and other IDEs offer </span><a id="_idIndexMarker1751"/><span class="koboSpan" id="kobo.291.1">good support for Docker and a good integration with Docker Desktop, the best option for most of the development time is working with just Dockerized images without running them inside of Minicube.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.292.1">In fact, as we will see shortly, once we have added Docker support to our projects, it is enough to click the Run Visual Studio button to start all our Dockerized microservices and to enable them to communicate through a Docker network. </span><span class="koboSpan" id="kobo.292.2">Conversely, running our application in Minikube requires several manual steps, and it takes some time to load the Docker images on Minikube and to create all the necessary Kubernetes objects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.293.1">Doing this in Visual Studio is super easy. </span><span class="koboSpan" id="kobo.293.2">It is enough to add Docker support for all microservice projects in your solution and to select the option of launching several projects simultaneously when the solution is run. </span><span class="koboSpan" id="kobo.293.3">Then, Visual Studio will automatically perform all the necessary tasks when your solution is run, namely:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.294.1">Compile and link all code.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.295.1">Build all microservice Docker images.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.296.1">Insert the Docker images into the Docker Desktop local repository.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.297.1">Launch all Docker images simultaneously.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.298.1">Attach the debugger to all launched Docker images.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.299.1">You just need to take care of microservice communication by defining a virtual network with Docker Desktop.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.300.1">We will explain all the details of the development process with a simple example in the next subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-479"><span class="koboSpan" id="kobo.301.1">gRPC worker microservices revisited</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.302.1">In the code associated with </span><em class="italic"><span class="koboSpan" id="kobo.303.1">Chapter 14</span></em><span class="koboSpan" id="kobo.304.1">,</span><em class="italic"><span class="koboSpan" id="kobo.305.1"> Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.306.1">, and described in </span><em class="italic"><span class="koboSpan" id="kobo.307.1">Chapter 21</span></em><span class="koboSpan" id="kobo.308.1">,</span><em class="italic"><span class="koboSpan" id="kobo.309.1"> Case study,</span></em><span class="koboSpan" id="kobo.310.1"> there is </span><a id="_idIndexMarker1752"/><span class="koboSpan" id="kobo.311.1">a solution called </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.313.1">. </span><span class="koboSpan" id="kobo.313.2">The solution is composed of two microservices. </span><span class="koboSpan" id="kobo.313.3">The first microservice simulates purchases by generating random data, while the second one uses this data to compute statistics that it stores in a database. </span><span class="koboSpan" id="kobo.313.4">The whole code is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">ch15-&gt;GrpcMicroService</span></code><span class="koboSpan" id="kobo.315.1"> folder of the GitHub repository associated with the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.316.1">Let’s make a copy of the whole </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.318.1"> folder and call it </span><code class="inlineCode"><span class="koboSpan" id="kobo.319.1">GrpcMicroServiceDocker</span></code><span class="koboSpan" id="kobo.320.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.321.1">The steps below describe all </span><a id="_idIndexMarker1753"/><span class="koboSpan" id="kobo.322.1">the modifications that need to be made to Docker to enable all microservices.</span></p>
<h3 class="heading-3" id="_idParaDest-480"><span class="koboSpan" id="kobo.323.1">Adding Docker support to GrpcMicroServiceDocker</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.324.1">Open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">GrpcMicroServiceDocker</span></code><span class="koboSpan" id="kobo.326.1"> solution in</span><a id="_idIndexMarker1754"/><span class="koboSpan" id="kobo.327.1"> Visual Studio. </span><span class="koboSpan" id="kobo.327.2">The solution</span><a id="_idIndexMarker1755"/><span class="koboSpan" id="kobo.328.1"> contains two microservices, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">FakeSource</span></code><span class="koboSpan" id="kobo.330.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">GrpcMicroservice</span></code><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">The last project is just the data layer of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">GrpcMicroservice</span></code><span class="koboSpan" id="kobo.334.1"> project.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.335.1"><img alt="" role="presentation" src="../Images/B19820_22_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.336.1">Figure 22.7: GrpcMicroServiceDocker solution</span></p>
<p class="normal"><span class="koboSpan" id="kobo.337.1">The solution is already configured to launch the two microservices when it is run. </span><span class="koboSpan" id="kobo.337.2">In other cases, you might need to configure multiple project launches by right-clicking on the solution node and selecting </span><strong class="screenText"><span class="koboSpan" id="kobo.338.1">Set Startup Projects….</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.339.1">Adding Docker support to both microservices is super easy. </span><span class="koboSpan" id="kobo.339.2">Right-click on each microservice project within Visual Studio. </span><span class="koboSpan" id="kobo.339.3">Navigate to </span><strong class="screenText"><span class="koboSpan" id="kobo.340.1">Add</span></strong><span class="koboSpan" id="kobo.341.1">, and then select </span><strong class="screenText"><span class="koboSpan" id="kobo.342.1">Docker Support</span></strong><span class="koboSpan" id="kobo.343.1">. </span><span class="koboSpan" id="kobo.343.2">If prompted, choose the operating system for your Docker environment. </span><span class="koboSpan" id="kobo.343.3">If you are using Minikube, you must select </span><strong class="screenText"><span class="koboSpan" id="kobo.344.1">Linux</span></strong><span class="koboSpan" id="kobo.345.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.346.1">All the necessary Docker files are </span><a id="_idIndexMarker1756"/><span class="koboSpan" id="kobo.347.1">automatically created and configured by Visual Studio. </span><span class="koboSpan" id="kobo.347.2">And that’s it!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.348.1">Now, we need to move the</span><a id="_idIndexMarker1757"/><span class="koboSpan" id="kobo.349.1"> database to the newly installed SQL Server instance.</span></p>
<h3 class="heading-3" id="_idParaDest-481"><span class="koboSpan" id="kobo.350.1">Moving GrpcMicroServiceDocker to SQL Server Express</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.351.1">You need to change all connection</span><a id="_idIndexMarker1758"/><span class="koboSpan" id="kobo.352.1"> strings and configure the string that will be used at runtime so that it can be used from inside a Docker image.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.353.1">First of all, let’s change the connection string that is inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">GrpcMicroServiceStore-&gt; LibraryDesignTimeDbContextFactory.cs</span></code><span class="koboSpan" id="kobo.355.1">. </span><span class="koboSpan" id="kobo.355.2">The new string should be something like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.356.1">@"Server=&lt;your machine name&gt;\&lt;your instance name&gt;;Database=grpcmicroservice;Trusted_Connection=True;Trust Server Certificate=True;MultipleActiveResultSets=true"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.357.1">where the instance name should be </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">SQLEXPRESS</span></code><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">You can take the above connection string directly from Visual Studio, as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.360.1">Open the </span><strong class="screenText"><span class="koboSpan" id="kobo.361.1">SQL Server Object Explorer</span></strong><span class="koboSpan" id="kobo.362.1"> window.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.363.1">Right-click on the </span><strong class="screenText"><span class="koboSpan" id="kobo.364.1">SQL Server</span></strong><span class="koboSpan" id="kobo.365.1"> node and select </span><strong class="screenText"><span class="koboSpan" id="kobo.366.1">Add SQL Server</span></strong><span class="koboSpan" id="kobo.367.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.368.1">In the window that opens, Visual Studio should enumerate all available SQL Server instances. </span><span class="koboSpan" id="kobo.368.2">Choose the newly installed SQL Server instance.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.369.1">Select </span><strong class="screenText"><span class="koboSpan" id="kobo.370.1">Windows authentication</span></strong><span class="koboSpan" id="kobo.371.1"> and connect.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.372.1">A new server icon should appear below the </span><strong class="screenText"><span class="koboSpan" id="kobo.373.1">SQL Server</span></strong><span class="koboSpan" id="kobo.374.1"> node. </span><span class="koboSpan" id="kobo.374.2">Select it.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.375.1">In the </span><strong class="screenText"><span class="koboSpan" id="kobo.376.1">Visual Studio Properties</span></strong><span class="koboSpan" id="kobo.377.1"> tab, you should see all database connection properties. </span><span class="koboSpan" id="kobo.377.2">Take the value of </span><strong class="screenText"><span class="koboSpan" id="kobo.378.1">General-&gt; Connection string</span></strong><span class="koboSpan" id="kobo.379.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.380.1">Now, you have to run all migrations to recreate the database in the new SQL Server instance. </span><span class="koboSpan" id="kobo.380.2">As usual, right-click on the library project and define it as a startup project. </span><span class="koboSpan" id="kobo.380.3">Then, in the Visual Studio Package Manager Console </span><strong class="screenText"><span class="koboSpan" id="kobo.381.1">Default Project</span></strong><span class="koboSpan" id="kobo.382.1">, select </span><code class="inlineCode"><span class="koboSpan" id="kobo.383.1">GrpcMicroServiceStore</span></code><span class="koboSpan" id="kobo.384.1"> and issue the </span><code class="inlineCode"><span class="koboSpan" id="kobo.385.1">Update-Database</span></code><span class="koboSpan" id="kobo.386.1"> command.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.387.1">After the new database has been created, restore the two microservices as simultaneous startup projects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.388.1">Finally, update the runtime connection string in </span><code class="inlineCode"><span class="koboSpan" id="kobo.389.1">GrpcMicroService -&gt; appsettings.json</span></code><span class="koboSpan" id="kobo.390.1">. </span><span class="koboSpan" id="kobo.390.2">If the newly</span><a id="_idIndexMarker1759"/><span class="koboSpan" id="kobo.391.1"> installed SQL Server instance has been defined as the default instance on your machine, the connection string below should work:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.392.1">Server=host. </span><span class="koboSpan" id="kobo.392.2">Docker.</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.393.1">internal</span></span><span class="koboSpan" id="kobo.394.1">;Database=grpcmicroservice;User Id=&lt;your user name&gt;;Password=&lt;your user password&gt;;Trust Server Certificate=True;MultipleActiveResultSets=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.395.1">true</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.396.1">"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.397.1">where </span><code class="inlineCode"><span class="koboSpan" id="kobo.398.1">host. </span><span class="koboSpan" id="kobo.398.2">Docker.internal</span></code><span class="koboSpan" id="kobo.399.1"> is the URL used by Docker Desktop images to communicate with the host machine. </span><span class="koboSpan" id="kobo.399.2">If your SQL Server is not the machine’s default instance, you must replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">host.docker.internal</span></code><span class="koboSpan" id="kobo.401.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">host.docker.internal\&lt;your instance name&gt;</span></code><span class="koboSpan" id="kobo.403.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.404.1">If, instead, you are using an external database, you can use its standard connection string with no modifications.</span></p>
<h3 class="heading-3" id="_idParaDest-482"><span class="koboSpan" id="kobo.405.1">Enabling communication among microservices with a Docker virtual network</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.406.1">Creating a Docker virtual network in </span><a id="_idIndexMarker1760"/><span class="koboSpan" id="kobo.407.1">Docker Desktop is easy; just open a Windows console and run the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.408.1">docker network create test-net,
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.409.1">where </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">test-net</span></code><span class="koboSpan" id="kobo.411.1"> is the virtual network name. </span><span class="koboSpan" id="kobo.411.2">Once the network has been defined when we create a container instance from an image, we can specify that the launched container must be connected to our network and its hostname, with something like:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.412.1">docker run --rm --net test-net --name grpcmicroservice &lt;microservice image name&gt;,
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.413.1">Here, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">rm</span></code><span class="koboSpan" id="kobo.415.1"> option specifies that the container must be destroyed when it stops running, </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">--net test-net</span></code><span class="koboSpan" id="kobo.417.1"> specifies the network where to connect the created container, and -</span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">-name grpcmicroservice</span></code><span class="koboSpan" id="kobo.419.1"> is the name of the created container that will also act as its hostname in the network.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.420.1">We need to add to our </span><code class="inlineCode"><span class="koboSpan" id="kobo.421.1">test-net</span></code><span class="koboSpan" id="kobo.422.1"> just the containers that must act as servers—in our case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.423.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.424.1"> microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.425.1">Since Visual Studio automatically issues all necessary </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">run</span></code><span class="koboSpan" id="kobo.427.1"> Docker commands when the solution is launched, we need just to specify the command options to add to Visual Studio’s original command. </span><span class="koboSpan" id="kobo.427.2">They must be specified in each microservice project file with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">DockerfileRunArguments</span></code><span class="koboSpan" id="kobo.429.1"> parameter. </span><span class="koboSpan" id="kobo.429.2">Below is how to modify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.431.1"> microservice project file, which is the only microservice acting as a server:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag"><span class="koboSpan" id="kobo.432.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.433.1">PropertyGroup</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.434.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.435.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.436.1">TargetFramework</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.437.1">&gt;</span></span><span class="koboSpan" id="kobo.438.1">net8.0</span><span class="hljs-tag"><span class="koboSpan" id="kobo.439.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.440.1">TargetFramework</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.441.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.442.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.443.1">Nullable</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.444.1">&gt;</span></span><span class="koboSpan" id="kobo.445.1">enable</span><span class="hljs-tag"><span class="koboSpan" id="kobo.446.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.447.1">Nullable</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.448.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.449.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.450.1">UserSecretsId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.451.1">&gt;</span></span><span class="koboSpan" id="kobo.452.1">b4f03ff2-033c-4d5e-a33b-65f26786b052</span><span class="hljs-tag"><span class="koboSpan" id="kobo.453.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.454.1">UserSecretsId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.455.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.456.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.457.1">DockerDefaultTargetOS</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.458.1">&gt;</span></span><span class="koboSpan" id="kobo.459.1">Linux</span><span class="hljs-tag"><span class="koboSpan" id="kobo.460.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.461.1">DockerDefaultTargetOS</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.462.1">&gt;</span></span>
<span class="code-highlight"><strong class="hljs-tag-slc"><span class="koboSpan" id="kobo.463.1">&lt;</span></strong><strong class="hljs-name-slc"><span class="koboSpan" id="kobo.464.1">DockerfileRunArguments</span></strong><strong class="hljs-tag-slc"><span class="koboSpan" id="kobo.465.1">&gt;</span></strong></span>
<span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.466.1">--rm --net test-net --name grpcmicroservice</span></strong></span>
<span class="code-highlight"><strong class="hljs-tag-slc"><span class="koboSpan" id="kobo.467.1">&lt;/</span></strong><strong class="hljs-name-slc"><span class="koboSpan" id="kobo.468.1">DockerfileRunArguments</span></strong><strong class="hljs-tag-slc"><span class="koboSpan" id="kobo.469.1">&gt;</span></strong></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.470.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.471.1">PropertyGroup</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.472.1">&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.473.1">No modification is required to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">FakeSource</span></code><span class="koboSpan" id="kobo.475.1"> project, since it must not act as a server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.476.1">Now, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">grpcmicroservice</span></code><span class="koboSpan" id="kobo.478.1"> hostname</span><a id="_idIndexMarker1761"/><span class="koboSpan" id="kobo.479.1"> must be used by </span><code class="inlineCode"><span class="koboSpan" id="kobo.480.1">FakeSource</span></code><span class="koboSpan" id="kobo.481.1"> to communicate with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.482.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.483.1"> microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.484.1">Therefore, we must replace the URL in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">FakeSource-&gt;Worker.cs</span></code><span class="koboSpan" id="kobo.486.1"> file with </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">http://grpcmicroservice:8080</span></code><span class="koboSpan" id="kobo.488.1">, as shown in the code snippet below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.489.1">…
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.490.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.491.1">var</span></span><span class="koboSpan" id="kobo.492.1"> channel = GrpcChannel.ForAddress(</span><span class="hljs-string"><span class="koboSpan" id="kobo.493.1">"http://grpcmicroservice:8080"</span></span><span class="koboSpan" id="kobo.494.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.495.1">var</span></span><span class="koboSpan" id="kobo.496.1"> client = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.497.1">new</span></span><span class="koboSpan" id="kobo.498.1"> Counter.CounterClient(channel);
…
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.499.1">where we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">8080</span></code><span class="koboSpan" id="kobo.501.1"> default Kestrel </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">http</span></code><span class="koboSpan" id="kobo.503.1"> port to communicate with the microservice. </span><span class="koboSpan" id="kobo.503.2">Therefore, we need to the Kestrel options in </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">GrpcMicroService -&gt;Program.cs</span></code><span class="koboSpan" id="kobo.505.1"> that force Kestrel to listen to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">5000</span></code><span class="koboSpan" id="kobo.507.1"> port by replacing the code below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.508.1">builder.WebHost.ConfigureKestrel(options =&gt;
{
    options.ListenLocalhost(</span><span class="hljs-number"><span class="koboSpan" id="kobo.509.1">5000</span></span><span class="koboSpan" id="kobo.510.1">, o =&gt;
        o.Protocols = Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols.Http2);
});
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.511.1">Now, we are ready to run our project. </span><span class="koboSpan" id="kobo.511.2">To be sure that both microservices are started with Docker, please select </span><a id="_idIndexMarker1762"/><span class="koboSpan" id="kobo.512.1">each of them as a single startup project, and then select </span><strong class="screenText"><span class="koboSpan" id="kobo.513.1">Docker</span></strong><span class="koboSpan" id="kobo.514.1"> in the select box next to the run solution Visual Studio button, as shown in the image below:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.515.1"><img alt="" role="presentation" src="../Images/B19820_22_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.516.1">Figure 22.8: Selecting Docker execution</span></p>
<p class="normal"><span class="koboSpan" id="kobo.517.1">After that, you can restore the simultaneous launch of both microservices. </span><span class="koboSpan" id="kobo.517.2">Visual Studio will launch both of them with Docker.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.518.1">Now, we can launch the solution. </span><span class="koboSpan" id="kobo.518.2">In order to verify that the server is properly receiving purchase information, place a breakpoint in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">GrpcMicroService-&gt;HostedServices-&gt; ProcessPurchases.cs</span></code><span class="koboSpan" id="kobo.520.1"> file inside of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">if</span></code><span class="koboSpan" id="kobo.522.1"> block below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.523.1">if</span></span><span class="koboSpan" id="kobo.524.1"> (toProcess.Count &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.525.1">0</span></span><span class="koboSpan" id="kobo.526.1">)
{
	…
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.527.1">In fact, </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.529.1"> enters that block only if it finds something in the input queue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.530.1">You can also inspect the content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">dbo.Purchases</span></code><span class="koboSpan" id="kobo.532.1"> database table to verify that it is filled with statistics on purchases. </span><span class="koboSpan" id="kobo.532.2">You can do it from within </span><strong class="screenText"><span class="koboSpan" id="kobo.533.1">SQL Server Object Explorer</span></strong><span class="koboSpan" id="kobo.534.1"> by right-clicking on the table and choosing </span><strong class="screenText"><span class="koboSpan" id="kobo.535.1">View Data</span></strong><span class="koboSpan" id="kobo.536.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.537.1">Having understood how to test our application with a Docker network, we must now understand when and how to test it with Minikube also.</span></p>
<h2 class="heading-2" id="_idParaDest-483"><span class="koboSpan" id="kobo.538.1">When to test the application with Minikube</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.539.1">Most of the debug-fix cycle involved in the</span><a id="_idIndexMarker1763"/><span class="koboSpan" id="kobo.540.1"> application development can be done with the Docker virtual network.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.541.1">Docker networks usually work well without creating issues. </span><span class="koboSpan" id="kobo.541.2">So, if you experience communication problems, they are probably due to misspelled service URLs. </span><span class="koboSpan" id="kobo.541.3">Therefore, please double-check the URLs in all calls to the microservice that does not receive communications.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.542.1">From time to time, we need to test an application with Minikube for the following reasons:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.543.1">Both ReplicaSets and StatefulSets can be tested with Docker and Visual Studio, but we are limited to a </span><a id="_idIndexMarker1764"/><span class="koboSpan" id="kobo.544.1">single POD for each of them.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.545.1">We must also test the </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">.yaml</span></code><span class="koboSpan" id="kobo.547.1"> Kubernetes configuration file, which might contain more complex objects like ingresses, permanent storage, secrets, and other complex configurations.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.548.1">You might need to integrate your microservices with other modules developed by other teams.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.549.1">Therefore, each developer should spend most of their time testing a few microservices that strongly interact among them with the Docker virtual network, but from time to time, they should try a wider integration with Minikube. </span><span class="koboSpan" id="kobo.549.2">This can be done before committing their code at the end of the working day, or just before closing a development iteration of the agile application development process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.550.1">Having learned when and how to test the application with Minikube, we must learn how to load and run our application on Minikube.</span></p>
<h1 class="heading-1" id="_idParaDest-484"><span class="koboSpan" id="kobo.551.1">Running your application in Minikube</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.552.1">When Visual Studio runs your microservices with Docker, it creates special images that also contain information needed by the</span><a id="_idIndexMarker1765"/><span class="koboSpan" id="kobo.553.1"> Visual Studio debugger and have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.554.1">dev</span></code><span class="koboSpan" id="kobo.555.1"> version name. </span><span class="koboSpan" id="kobo.555.2">These special images can be run just from Visual Studio, and if you try to launch them manually, you will get an error. </span><span class="koboSpan" id="kobo.555.3">For the same reason, you can’t use them in Minikube.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.556.1">Therefore, the first step for running your microservice in Minikube is to create different “standard” images. </span><span class="koboSpan" id="kobo.556.2">You can do this by right-clicking both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.557.1">FakeSource</span></code><span class="koboSpan" id="kobo.558.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.559.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.560.1"> Docker files in Visual Studio Solution Explorer and by selecting </span><strong class="screenText"><span class="koboSpan" id="kobo.561.1">Build Docker Image</span></strong><span class="koboSpan" id="kobo.562.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.563.1">This way, you will create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.564.1">grpcmicroservice</span></code><span class="koboSpan" id="kobo.565.1"> and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">fakesource</span></code><span class="koboSpan" id="kobo.567.1"> image, both with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.568.1">latest</span></code><span class="koboSpan" id="kobo.569.1"> version name, as shown in the image below:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.570.1"><img alt="" role="presentation" src="../Images/B19820_22_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.571.1">Figure 22.9: Creating Minikube-ready Docker images</span></p>
<p class="normal"><span class="koboSpan" id="kobo.572.1">As a next step, you must start</span><a id="_idIndexMarker1766"/><span class="koboSpan" id="kobo.573.1"> Minikube:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.574.1">minikube start
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.575.1">Now, you must load your Docker images inside of the Minikube images cache with the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.576.1">minikube image load fakesource:latest
minikube image load grpcmicroservice:latest
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.577.1">You can verify that your images have been correctly loaded by listing all the images loaded in Minikube:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.578.1">minikube image ls
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.579.1">Now, we need to define a .</span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">yaml</span></code><span class="koboSpan" id="kobo.581.1"> Kubernetes configuration file with two deployments and a service that forwards communications to </span><code class="inlineCode"><span class="koboSpan" id="kobo.582.1">grpcmicroservice</span></code><span class="koboSpan" id="kobo.583.1">, which is the only microservice acting as a server. </span><span class="koboSpan" id="kobo.583.2">Let’s call it </span><code class="inlineCode"><span class="koboSpan" id="kobo.584.1">minikubedeploy.yaml</span></code><span class="koboSpan" id="kobo.585.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.586.1">The definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">grpcmicroservice</span></code><span class="koboSpan" id="kobo.588.1"> deployment is straightforward:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.589.1">apiVersion</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.590.1">:</span></span><span class="koboSpan" id="kobo.591.1"> apps/v1
kind</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.592.1">:</span></span><span class="koboSpan" id="kobo.593.1"> Deployment
metadata</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.594.1">:</span></span><span class="koboSpan" id="kobo.595.1">
  name</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.596.1">:</span></span><span class="koboSpan" id="kobo.597.1"> grpcmicroservice
  labels</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.598.1">:</span></span><span class="koboSpan" id="kobo.599.1">
    app</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.600.1">:</span></span><span class="koboSpan" id="kobo.601.1"> statistics
spec</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.602.1">:</span></span><span class="koboSpan" id="kobo.603.1">
  selector</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.604.1">:</span></span><span class="koboSpan" id="kobo.605.1">
    matchLabels</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.606.1">:</span></span><span class="koboSpan" id="kobo.607.1">
      app</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.608.1">:</span></span><span class="koboSpan" id="kobo.609.1"> statistics
      role</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.610.1">:</span></span><span class="koboSpan" id="kobo.611.1"> worker
  replicas</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.612.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.613.1">1</span></span><span class="koboSpan" id="kobo.614.1">
  template</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.615.1">:</span></span><span class="koboSpan" id="kobo.616.1">
    metadata</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.617.1">:</span></span><span class="koboSpan" id="kobo.618.1">
      labels</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.619.1">:</span></span><span class="koboSpan" id="kobo.620.1">
        app</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.621.1">:</span></span><span class="koboSpan" id="kobo.622.1"> statistics
        role</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.623.1">:</span></span><span class="koboSpan" id="kobo.624.1"> worker
    spec</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.625.1">:</span></span><span class="koboSpan" id="kobo.626.1">
      containers</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.627.1">:</span></span><span class="koboSpan" id="kobo.628.1">
      - name</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.629.1">:</span></span><span class="koboSpan" id="kobo.630.1"> grpcmicroservice
        image</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.631.1">:</span></span><span class="koboSpan" id="kobo.632.1"> grpcmicroservice</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.633.1">:</span></span><span class="koboSpan" id="kobo.634.1">latest
        imagePullPolicy</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.635.1">:</span></span><span class="koboSpan" id="kobo.636.1"> Never
        resources</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.637.1">:</span></span><span class="koboSpan" id="kobo.638.1">
          requests</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.639.1">:</span></span><span class="koboSpan" id="kobo.640.1">
            cpu</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.641.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.642.1">10</span></span><span class="koboSpan" id="kobo.643.1">m
            memory</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.644.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.645.1">10</span></span><span class="koboSpan" id="kobo.646.1">Mi
        env</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.647.1">:</span></span><span class="koboSpan" id="kobo.648.1">
        - name</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.649.1">:</span></span><span class="koboSpan" id="kobo.650.1"> ASPNETCORE_HTTP_PORTS
          value</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.651.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.652.1">"8080"</span></span><span class="koboSpan" id="kobo.653.1">
        ports</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.654.1">:</span></span><span class="koboSpan" id="kobo.655.1">
        - containerPort</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.656.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.657.1">8080</span></span><span class="koboSpan" id="kobo.658.1">
          name</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.659.1">:</span></span><span class="koboSpan" id="kobo.660.1"> http
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.661.1">The code above requires just one replica, but you can experiment with two or three replicas. </span><span class="koboSpan" id="kobo.661.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.662.1">ASPNETCORE_HTTP_PORTS</span></code><span class="koboSpan" id="kobo.663.1"> environment variable is a standard ASP.NET setting that informs Kestrel on the </span><a id="_idIndexMarker1767"/><span class="koboSpan" id="kobo.664.1">HTTP port where to listen.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.665.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">imagePullPolicy: Never</span></code><span class="koboSpan" id="kobo.667.1"> setting specifies the image caching policy within the Kubernetes cluster. </span><span class="koboSpan" id="kobo.667.2">It prevents Minikube from trying to download a fresher version of the image from the original source into its cache. </span><span class="koboSpan" id="kobo.667.3">We need this setting, since there is no “original source” containing our image because we uploaded the image directly to the Minikube cache with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.668.1">minikube image load</span></code><span class="koboSpan" id="kobo.669.1"> command. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.670.1">You must always specify this setting when images are not available in a shared image repository but are uploaded directly to the Minikube cache from the Docker Desktop local repository. </span><span class="koboSpan" id="kobo.670.2">Shared images, instead, do not need to be uploaded manually in the Minikube cache but can be simply referenced with their full URL in the Kubernetes </span><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">.yaml</span></code><span class="koboSpan" id="kobo.672.1"> file.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.673.1">All other settings are quite standard.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.674.1">The definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">fakesource</span></code><span class="koboSpan" id="kobo.676.1"> deployment is completely analogous but doesn’t contain information about </span><a id="_idIndexMarker1768"/><span class="koboSpan" id="kobo.677.1">the container ports, since this microservice doesn’t act as a server:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.678.1">apiVersion: apps/v1
kind: Deployment
metadata:
  name: fakesource
  labels:
    app: sale
spec:
  selector:
    matchLabels:
      app: sales
      role: source
  replicas: </span><span class="hljs-number"><span class="koboSpan" id="kobo.679.1">1</span></span><span class="koboSpan" id="kobo.680.1">
  template:
    metadata:
      labels:
        app: sales
        role: source
    spec:
      containers:
      - name: fakesource
        image: fakesource:latest
        imagePullPolicy: Never
        resources:
          requests:
            cpu: </span><span class="hljs-number"><span class="koboSpan" id="kobo.681.1">10</span></span><span class="koboSpan" id="kobo.682.1">m
            memory: </span><span class="hljs-number"><span class="koboSpan" id="kobo.683.1">10</span></span><span class="koboSpan" id="kobo.684.1">Mi
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.685.1">The definition of the service that forwards communications to </span><code class="inlineCode"><span class="koboSpan" id="kobo.686.1">grpcmicroservice</span></code><span class="koboSpan" id="kobo.687.1"> is quite standard:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.688.1">apiVersion: v1
kind: Service
metadata:
  name: grpcmicroservice
  labels:
    app: contract
    role: worker
spec:
  ports:
  - port: </span><span class="hljs-number"><span class="koboSpan" id="kobo.689.1">8080</span></span><span class="koboSpan" id="kobo.690.1">
    name: http
    protocol: TCP
    targetPort: </span><span class="hljs-number"><span class="koboSpan" id="kobo.691.1">8080</span></span><span class="koboSpan" id="kobo.692.1">
  selector:
    app: statistics
    role: worker
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.693.1">You must pay attention only to the port numbers that must be coherent in all settings and to the service name, since they will be used in the URLs of all communication to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">grpcmicroservice</span></code><span class="koboSpan" id="kobo.695.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.696.1">If the service names match the hostnames in the Docker virtual network, the URLs will work both in Kubernetes and the Docker virtual network. </span><span class="koboSpan" id="kobo.696.2">So, you don’t need to modify any </span><a id="_idIndexMarker1769"/><span class="koboSpan" id="kobo.697.1">code or configuration to adapt the code that runs in the Docker virtual network to Minikube or any other Kubernetes clusters.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.698.1">The whole </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">minkubedeploy.yaml</span></code><span class="koboSpan" id="kobo.700.1"> file is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.701.1">ch22</span></code><span class="koboSpan" id="kobo.702.1"> folder of the GitHub repository associated with the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.703.1">Now, let’s open a Windows prompt in the folder that contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">minkubedeploy.yaml</span></code><span class="koboSpan" id="kobo.705.1"> file, issuing the command below that will load the application configuration in the Minikube cluster:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.706.1">kubectl create -f minkubedeploy.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.707.1">Then, issue the </span><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">kubectl get deployment</span></code><span class="koboSpan" id="kobo.709.1"> command to verify that all deployments have been correctly defined and are running.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.710.1">You can verify that the application is properly running by inspecting the data in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">dbo.Purchases</span></code><span class="koboSpan" id="kobo.712.1"> database table, by right-clicking on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">dbo.Purchases</span></code><span class="koboSpan" id="kobo.714.1"> table in </span><strong class="screenText"><span class="koboSpan" id="kobo.715.1">SQL Server Object Explorer</span></strong><em class="italic"> </em><span class="koboSpan" id="kobo.716.1">and choosing </span><strong class="screenText"><span class="koboSpan" id="kobo.717.1">View Data</span></strong><span class="koboSpan" id="kobo.718.1">:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.719.1"><img alt="" role="presentation" src="../Images/B19820_22_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.720.1">Figure 22.10: dbo.Purchases table</span></p>
<p class="normal"><span class="koboSpan" id="kobo.721.1">Each time you click the table refresh button, you should see new rows added to the database table. </span><span class="koboSpan" id="kobo.721.2">If new rows do not appear after several refreshes, your microservice is probably experiencing some </span><a id="_idIndexMarker1770"/><span class="koboSpan" id="kobo.722.1">communication problem, or some exception was thrown before data was computed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.723.1">You can discover what the problem is just by debugging the application. </span><span class="koboSpan" id="kobo.723.2">The next section explains how to verify in detail what is happening in the application, with the help of Bridge to Kubernetes. </span><span class="koboSpan" id="kobo.723.3">Please do not delete all Kubernetes objects created with </span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">minkubedeploy.yaml</span></code><span class="koboSpan" id="kobo.725.1"> because we need the running application to attach Bridge to Kubernetes.</span></p>
<h1 class="heading-1" id="_idParaDest-485"><span class="koboSpan" id="kobo.726.1">Remote debugging a Kubernetes application</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.727.1">As a final step, we will debug </span><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.729.1"> with</span><a id="_idIndexMarker1771"/><span class="koboSpan" id="kobo.730.1"> Bridge to Kubernetes. </span><span class="koboSpan" id="kobo.730.2">Let’s set </span><code class="inlineCode"><span class="koboSpan" id="kobo.731.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.732.1"> as a starting project and change the project start from </span><strong class="screenText"><span class="koboSpan" id="kobo.733.1">Docker</span></strong><span class="koboSpan" id="kobo.734.1"> to </span><strong class="screenText"><span class="koboSpan" id="kobo.735.1">Bridge</span></strong> <strong class="screenText"><span class="koboSpan" id="kobo.736.1">to Kubernetes</span></strong><span class="koboSpan" id="kobo.737.1">, as shown in the image below:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.738.1"><img alt="" role="presentation" src="../Images/B19820_22_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.739.1">Figure 22.11: Debugging GrpcMicroService with Bridge to Kubernetes</span></p>
<p class="normal"><span class="koboSpan" id="kobo.740.1">Let’s place a breakpoint in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.741.1">GrpcMicroService-&gt;HostedServices-&gt; ProcessPurchases.cs</span></code><span class="koboSpan" id="kobo.742.1"> file inside of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.743.1">if</span></code><span class="koboSpan" id="kobo.744.1"> block, as shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.745.1">if</span></span><span class="koboSpan" id="kobo.746.1"> (toProcess.Count &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.747.1">0</span></span><span class="koboSpan" id="kobo.748.1">)
{
	…
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.749.1">Then, start debugging. </span><span class="koboSpan" id="kobo.749.2">As soon as </span><a id="_idIndexMarker1772"/><span class="koboSpan" id="kobo.750.1">you click the </span><strong class="screenText"><span class="koboSpan" id="kobo.751.1">run</span></strong><span class="koboSpan" id="kobo.752.1"> button, a window appears that prompts you to configure Bridge to Kubernetes:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.753.1"><img alt="" role="presentation" src="../Images/B19820_22_12.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.754.1">Figure 22.12: Configuring Bridge to Kubernetes</span></p>
<p class="normal"><span class="koboSpan" id="kobo.755.1">If the window above doesn’t open, or you can’t see any Minikube node, </span><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">Kubectl</span></code><span class="koboSpan" id="kobo.757.1"> is probably not working or configured for Minikube. </span><span class="koboSpan" id="kobo.757.2">Try issuing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.758.1">Kubectl</span></code><span class="koboSpan" id="kobo.759.1"> command like </span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">kubectl get all</span></code><span class="koboSpan" id="kobo.761.1">. </span><span class="koboSpan" id="kobo.761.2">If you face any issues, try stopping and restarting Minikube with </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">minikube stop</span></code><span class="koboSpan" id="kobo.763.1">, followed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">minikube start</span></code><span class="koboSpan" id="kobo.765.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.766.1">Bridge to Kubernetes prompts us to select a namespace—in our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.767.1">default</span></code><span class="koboSpan" id="kobo.768.1">—and then choose a specific service within that namespace—in our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.769.1">grpmicroservice</span></code><span class="koboSpan" id="kobo.770.1">. </span><span class="koboSpan" id="kobo.770.2">All communications to that service will be forwarded to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.771.1">GrpcMicroService</span></code><span class="koboSpan" id="kobo.772.1"> code running on our development machine. </span><span class="koboSpan" id="kobo.772.2">Let’s set up the configuration window, as shown in the screenshot above. </span><span class="koboSpan" id="kobo.772.3">As soon as you submit your Bridge to Kubernetes configuration, debugging will automatically </span><a id="_idIndexMarker1773"/><span class="koboSpan" id="kobo.773.1">start. </span><span class="koboSpan" id="kobo.773.2">In a short time, the breakpoint will be hit, and our local copy of the microservice will start interacting with the remainder of the code that is running in Minikube!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.774.1">After you finish debugging, please restore the project start to </span><strong class="screenText"><span class="koboSpan" id="kobo.775.1">Docker</span></strong><span class="koboSpan" id="kobo.776.1">, and restore the simultaneous start of both microservices so that you can continue working with the Docker virtual network.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.777.1">After having finished working with Minikube, you need to remove all objects created by </span><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">minkubedeploy.yaml</span></code><span class="koboSpan" id="kobo.779.1"> with the command below:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.780.1">kubectl delete -f minkubedeploy.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.781.1">It is important to free up resources as soon as you don’t need them anymore; otherwise, they will continue wasting CPU time and memory, and if you constantly add more and more applications, sooner or later, you will experience performance problems on your development machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.782.1">If you want to free up Minikube disk space, you can also remove the microservices images previously loaded in the Minikube cache with the commands below:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.783.1">minikube image rm fakesource:latest
minikube image rm grpcmicroservice:latest
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.784.1">Finally, you need to stop Minikube with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.785.1">minikube stop
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-486"><span class="koboSpan" id="kobo.786.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.787.1">In this chapter, we explained how to prepare a developer workstation for .NET Kubernetes development and how to organize code testing and bug-fix cycles.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.788.1">We also explained how to define a Docker virtual network to ensure microservices communication during development and name conventions for hostnames and Kubernetes services, enabling the same code to run both on the Docker virtual network, Minikube, and any other Kubernetes cluster.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.789.1">Finally, we explained all the steps needed to run an application in Minikube and how to test it with Bridge to Kubernetes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.790.1">We’ve now reached the end of our journey through this book, and what a journey it has been!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.791.1">Packed with numerous new and challenging ideas, this book is sure to be your good friend on your journey as a software architect. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.792.1">These learnings will not only empower you to craft innovative solutions but also support your growth in the dynamic world of software projects. </span><span class="koboSpan" id="kobo.792.2">We sincerely hope you’ve enjoyed the adventure as much as we have creating this latest edition for you.</span></p>
<h1 class="heading-1" id="_idParaDest-487"><span class="koboSpan" id="kobo.793.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.794.1">Why can’t the SQL Server installation that comes with Visual Studio be used for Kubernetes development?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.795.1">What is Bridge to Kubernetes?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.796.1">Is it true that Bridge to Kubernetes works just with Minikube?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.797.1">How do you load the Minikube images cache?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.798.1">How do we define Minikube as the Kubectl default cluster?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-488"><span class="koboSpan" id="kobo.799.1">Further reading</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.800.1">Most of the references in this chapter are the same as those previously listed in </span><em class="italic"><span class="koboSpan" id="kobo.801.1">Chapter 11</span></em><span class="koboSpan" id="kobo.802.1">, </span><em class="italic"><span class="koboSpan" id="kobo.803.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.804.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.805.1">Chapter 14</span></em><span class="koboSpan" id="kobo.806.1">, </span><em class="italic"><span class="koboSpan" id="kobo.807.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.808.1">. </span><span class="koboSpan" id="kobo.808.2">Here, it is worth adding the link to the official documentation about Bridge to Kubernetes: </span><a href="https://learn.microsoft.com/en-us/visualstudio/bridge/    "><span class="url"><span class="koboSpan" id="kobo.809.1">https://learn.microsoft.com/en-us/visualstudio/bridge/</span></span></a></p>
<p class="normal"><a href="https://learn.microsoft.com/en-us/visualstudio/bridge/    "/></p>
<p class="normal"><a href="https://learn.microsoft.com/en-us/visualstudio/bridge/    "/></p>
<p class="normal"><a href="https://learn.microsoft.com/en-us/visualstudio/bridge/    "/></p>
<h1 class="heading-1"><span class="koboSpan" id="kobo.810.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.811.1">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8"><span class="url"><span class="koboSpan" id="kobo.812.1">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.813.1"><img alt="" role="presentation" src="../Images/QR_Code175081751210902046.png"/></span></p>
</div>
</body></html>