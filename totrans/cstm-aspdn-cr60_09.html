<html><head></head><body>
		<div><h1 id="_idParaDest-80"><em class="italic"><a id="_idTextAnchor143"/>Chapter 9</em>: Working with Endpoint Routing</h1>
			<p>In this chapter, we will talk about the new endpoint routing in <strong class="bold">ASP.NET</strong> <strong class="bold">Core</strong>. We will learn what endpoint routing is, how it works, where it is used, and how you are able to create your own routes to your own endpoints.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Exploring endpoint routing</li>
				<li>Creating custom endpoints</li>
				<li>Creating a more complex endpoint</li>
			</ul>
			<p>The topics in this chapter refer to the routing layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_9.1_B17996.jpg" alt="Figure 9.1 – The ASP.NET Core architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-81">T<a id="_idTextAnchor144"/>echnical requirements<a id="_idTextAnchor145"/></h1>
			<p>For this series, we just need to set up a small, empty web application:</p>
			<pre>dotnet new mvc -n RoutingSample -o RoutingSample </pre>
			<p>That's it! Open the application with Visual Studio Code:</p>
			<pre>cd RoutingSample
code .</pre>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09</a>.</p>
			<h1 id="_idParaDest-82">E<a id="_idTextAnchor146"/><a id="_idTextAnchor147"/>xploring endpoint routing</h1>
			<p>To learn about <strong class="bold">endpoint routing</strong>, you need to learn what an <em class="italic">endpoint</em> is and what <em class="italic">routing</em> is.</p>
			<p><strong class="bold">Endpoints</strong> are <a id="_idIndexMarker132"/>part of an app that get executed when a route maps the incoming request to it. Let's analyze this definition in a little more detail.</p>
			<p>A client usually <a id="_idIndexMarker133"/>requests a resource from a server. In most cases, the client is a browser. The resource is defined by a URL, which points to a specific target. In most cases, the target is a web page. It could also be a mobile app that requests specific data from a JSON web API. What data the app requests is defined in the URL.</p>
			<p>This means that the incoming request is also defined by the URL. The executing endpoint, on the other hand, is mapped to a specific route. A route is a URL or a pattern for a URL. ASP.NET Core developers are already familiar with such a route pattern:</p>
			<pre>app.UseRouting();
app.UseAuthorization();
app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
});</pre>
			<p>If the route or the route pattern matches the URL of the incoming request, the request gets mapped to that endpoint. In this case, the request gets mapped to the MVC endpoint. </p>
			<p>ASP.NET Core can map to the following endpoints:</p>
			<ul>
				<li>Controllers (for example, MVC or web APIs)</li>
				<li>Razor Pages</li>
				<li>SignalR (and Blazor Server)</li>
				<li>gRPC services</li>
				<li>Health checks</li>
			</ul>
			<p>Most of the <a id="_idIndexMarker134"/>endpoints have really simple route patterns. Only the MVC and web API endpoints use the more complex patterns. The route definitions of Razor pages are based on the folder and file structure of the actual pages.</p>
			<p>Before endpoints were introduced in ASP.NET Core 2.2, routing was only a thing in MVC and web APIs. The implicit routing in <strong class="bold">Razor Pages</strong> was built-in there, and SignalR wasn't really ready. Blazor and gRPC <a id="_idIndexMarker135"/>weren't a thing back then, and the health checks were initially implemented as a middleware component.</p>
			<p>Endpoint routing was introduced to separate routing from the actual endpoints. This makes the framework much more flexible, and it means that new endpoints don't need to implement their own kind of routing. This way, the endpoints can use the existing flexible routing technology to get mapped to a specific route.</p>
			<p>Next, we'll see how you can create your own custom endpoints.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor148"/>Creating custom endpoints</h1>
			<p>The easiest way to <a id="_idIndexMarker136"/>create an endpoint is by using the lambda-based endpoints:</p>
			<pre>app.Map("/map", async context =&gt;
{
    await context.Response.WriteAsync("OK");
});</pre>
			<p>This maps the <code>/map</code> route to a simple endpoint that writes the word <code>"OK"</code> to the response stream.</p>
			<p class="callout-heading">A Note regarding Prior .NET 6.0 Versions</p>
			<p class="callout">Prior to .NET 6.0, you would map custom endpoints on the <code>endpoints</code> object inside the lambda that gets passed to the <code>UseEndpoints</code> method in the <code>Startup.cs</code> file. With .NET 6.0 and the<a id="_idIndexMarker137"/> new <code>app</code> object in the <code>Program.cs</code> file.</p>
			<p>You might <a id="_idIndexMarker138"/>need to add the <code>Microsoft.AspNetCore.Http</code> namespace to the <code>using</code> statements.</p>
			<p>You can also map specific HTTP methods (such as <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>) to an endpoint. The following code shows how to map the <code>GET</code> and <code>POST</code> methods:</p>
			<pre>app.MapGet("/mapget", async context =&gt;
{
    await context.Response.WriteAsync("Map GET");
});
app.MapPost("/mappost", async context =&gt;
{
    await context.Response.WriteAsync("Map POST");
});</pre>
			<p>We can also map two or more HTTP methods to an endpoint:</p>
			<pre>app.MapMethods(
    "/mapmethods", 
    new[] { "DELETE", "PUT" }, 
    async context =&gt;
{
    await context.Response.WriteAsync("Map Methods");
});</pre>
			<p>These endpoints look like the lambda-based terminating middleware components that we saw in <a href="B17996_08_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing Custom Middleware</em>. These are middleware components that terminate the pipeline and return a result, such as HTML-based views, JSON structured data, or similar. Endpoint routing is a more flexible way to create an output, and it <a id="_idIndexMarker139"/>should be used in all versions from ASP.NET Core 3.0 onward.</p>
			<p>In <a href="B17996_08_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing Custom Middleware</em>, we saw that we can branch pipelines like this:</p>
			<pre>app.Map("/map", mapped =&gt;
{
    // some more Middlewares
});</pre>
			<p>This also creates a route, but this will only listen to URLs that start with <code>/map</code>. If you would prefer to have a routing engine that handles patterns such as <code>/map/{id:int?}</code> to also match <code>/map/456</code> and not <code>/map/abc</code>, you should use the new routing, as demonstrated earlier in this section.</p>
			<p>Those lambda-based endpoints are useful for simple scenarios. However, because they are defined in <code>Program.cs</code>, things will quickly become messy if you start to implement more complex scenarios using this kind of lambda-based approach.</p>
			<p>So, we should try to find a more structured way to create custom endp<a id="_idTextAnchor149"/>oints.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor150"/>Creating a more complex endpoint</h1>
			<p>In this section, we will <a id="_idIndexMarker140"/>create a more complex endpoint, step by step. Let's do this by writing a really simple health check endpoint, similar to what you might need if you were to run your application inside a <strong class="bold">Kubernetes</strong> cluster, or just to tell others about your health status:</p>
			<ol>
				<li>Microsoft advices starting with the definition of the API to add the endpoint from the developer's point of view. We do the same here. This means that we will add a <code>MapSomething</code> method first, without an actual implementation. This will be an extension method on the <code>IEndpointRouteBuilder</code> object. We are going to call it <code>MapMyHealthChecks</code>:<pre>// the new endpoint
app.MapMyHealthChecks("/myhealth");
  
app.MapControllerRoute(
    name: "default",
    pattern: 
        "{controller=Home}/{action=Index}/{id?}");</pre><p>The new endpoint should be added in the same way as the prebuilt endpoints, so as not to confuse the developer who needs to use it.</p><p>Now that we know how the method should look, let's implement it.</p></li>
				<li>Create<a id="_idIndexMarker141"/> a new static class called <code>MapMyHealthChecksExtensions</code> and place an extension method inside the <code>MapMyHealthChecks</code> object that extends <code>IEndpointRouteBuilder</code> and returns an <code>IEndpointConventionBuilder</code> object. I placed it in the <code>MapMyHealthChecksExtensions.cs</code> file:<pre>namespace RoutingSample;
public static class MapMyHealthChecksExtensions
{
    public static IEndpointConventionBuilder 
      MapMyHealthChecks (
        this IEndpointRouteBuilder endpoints, 
        string pattern = "/myhealth")
    {
        // ...
    }
}</pre><p>This is just the skeleton. Let's start with the actual endpoint first before using it.</p></li>
				<li>The actual <a id="_idIndexMarker142"/>endpoint will be written as a <em class="italic">terminating</em> middleware component – that is, a middleware component that doesn't call the next one (see <a href="B17996_08_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing Custom Middleware</em>) and creates an output to the response stream:<pre>namespace RoutingSample;
public class MyHealthChecksMiddleware
{
    private readonly ILogger&lt;MyHealthChecksMiddleware&gt; 
      _logger;
    public MyHealthChecksMiddleware (
        RequestDelegate next, 
        ILogger&lt;MyHealthChecksMiddleware&gt; logger)
    {
        _logger = logger;
    }
    public async Task Invoke(HttpContext context)
    {
        // add some checks here... 
        context.Response.StatusCode = 200;
        context.Response.ContentType = "text/plain";
        await context.Response.WriteAsync("OK");
    }
}</pre><p>The actual<a id="_idIndexMarker143"/> work is done in the <code>Invoke</code> method. Currently, this doesn't really do more than respond with <code>OK</code> in plaintext and the <code>200</code> HTTP status, which is fine if you just want to show that your application is running. Feel free to extend the method with actual checks, such as checking for the availability of a database or related services, for example. Then, you would need to change the HTTP status and the output related to the result of your checks.</p><p>Let's use this terminating middleware.</p></li>
				<li>Let's go back to the skeleton of the <code>MapMyHealthChecks</code> method. We now need to create our own pipeline, which we map to a given route. Place the following lines in that method:<pre>var pipeline = endpoints
    .CreateApplicationBuilder()
    .UseMiddleware&lt;MyHealthChecksMiddleware&gt;()
    .Build();
return endpoints.Map(pattern, pipeline)
    .WithDisplayName("My custom health checks");</pre></li>
				<li>This approach allows you to add some more middleware just for this new pipeline. The <code>WithDisplayName</code> extension method sets the configured display name to the endpoint.</li>
				<li>That's it! Press <em class="italic">F5</em> in your IDE <a id="_idIndexMarker144"/>to start the application and call <code>https://localhost:7111/myhealth</code> in your browser. You should see <strong class="bold">OK</strong> in your browser:</li>
			</ol>
			<div><div><img src="img/Figure_9.2_B17996.jpg" alt="Figure 9.2 – A screenshot of the endpoint routing output"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – A screenshot of the endpoint rout<a id="_idTextAnchor151"/>ing output</p>
			<p>Please note the port number might vary. You can also convert an alread<a id="_idTextAnchor152"/>y existing terminating middleware component to a routed endpoint to benefit from much more flexible routing. And that's it for thi<a id="_idTextAnchor153"/><a id="_idTextAnchor154"/>s chapter!</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor155"/>Summary</h1>
			<p>ASP.NET Core knows many ways in which to work with a request and to provide information to the requesting client. Endpoint routing is a way to provide resources based on the requested URL and the requested method. </p>
			<p>In this chapter, you learned how to use a terminating middleware component as an endpoint that gets mapped to the new routing engine to be more flexible, matching the routes by which you want to serve the information to the requesting client.</p>
			<p>Every web application needs to know its users to allow or restrict access to specific areas of the application or to specific data. In the next chapter, we show how to configure authentication to recognize your users.</p>
		</div>
	</body></html>