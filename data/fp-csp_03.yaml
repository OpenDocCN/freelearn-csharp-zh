- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Pure Functions and Side Effects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数和副作用
- en: Welcome to [*Chapter 3*](B21069_03.xhtml#_idTextAnchor095)! Here, we’ll dive
    deep into the world of pure functions in C#. This chapter is all about helping
    you understand the concept of pure functions, their practical application, and
    how to use them effectively in your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第3章*](B21069_03.xhtml#_idTextAnchor095)！在这里，我们将深入探讨C#中纯函数的世界。这一章全部关于帮助你理解纯函数的概念、它们的实际应用以及如何在代码中有效地使用它们。
- en: 'Here’s a quick breakdown of what to expect:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速概述，让你了解可以期待什么：
- en: Understanding pure functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解纯函数
- en: Side effects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用
- en: Strategies to minimize side effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化副作用的方法
- en: Marking pure functions with the `Pure` attribute
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Pure`属性标记纯函数
- en: As you move through the content, keep an eye out for actionable insights and
    data-driven recommendations. Approach this chapter with an eagerness to learn;
    by the end, you’ll have a solid foundation to write efficient and clean C# programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在你浏览内容的过程中，注意可操作见解和基于数据的推荐。以学习的热情来阅读这一章；到结束时，你将有一个坚实的基础来编写高效且干净的C#程序。
- en: As I recommended in the previous chapter, I propose that you check your level
    of knowledge and look at the following three tasks. If you have any doubts about
    how to solve them, it is better to read this chapter right now. And if you are
    100% sure that you can solve them with your eyes closed, maybe it will be more
    beneficial to proceed with the less familiar topics for now. Let’s jump right
    in!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一章中建议的，我建议你检查你的知识水平，看看以下三个任务。如果你对如何解决它们有任何疑问，最好是现在就阅读这一章。如果你百分之百确信你可以闭着眼睛解决它们，那么现在先处理不太熟悉的话题可能更有益。让我们直接进入正题！
- en: Task 1 – Refactoring to a pure function
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 1 – 重构为纯函数
- en: 'Steve’s tower defense game calculates damage based on a global difficulty modifier.
    Refactor this function to make it pure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫的塔防游戏根据全局难度修改器计算伤害。重构这个函数以使其成为纯函数：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Task 2 – Isolating side effects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 2 – 隔离副作用
- en: 'The game loads enemy data from a file, processes it, and updates the game state.
    Refactor this function to isolate its side effects:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏从文件中加载敌人数据，处理它，并更新游戏状态。重构这个函数以隔离其副作用：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Task 3 – Using a Pure attribute
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 3 – 使用`Pure`属性
- en: 'Refactor the following method by making it a pure function and marking it with
    the `Pure` attribute:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其改为纯函数并标记为`Pure`属性来重构以下方法：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If these tasks are easy, you might want to consider reading topics that are
    new to you first. If you have any questions or are not sure about the correct
    answers, don’t worry – next, we’ll dive into the concept of pure functions and
    side effects while using the characters from the previous chapter – Julia and
    Steve.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些任务很容易，你可能想先阅读一些你不太熟悉的话题。如果你有任何问题或不确定正确答案，不用担心——接下来，我们将深入探讨纯函数和副作用的概念，同时使用上一章中的角色——朱莉娅和史蒂夫。
- en: A week later, Julia called Steve and said that if he wanted to continue learning
    functional programming, he needed to understand the logic of pure functions and
    side effects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一周后，朱莉娅给史蒂夫打电话说，如果他想要继续学习函数式编程，他需要理解纯函数和副作用的逻辑。
- en: 'Julia: *Pure functions are functions that have deterministic output and no
    observable side effects – in other words, no actions happen outside the given
    scope of a function. This makes them predictable and easy to test, as well as
    key attributes for efficient software development. In C# code, we do this through
    the use of immutability and keywords such as* `readonly`*,* `const`*, and* `static`*.
    Also, there is a special attribute for marking* *pure functions.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*纯函数是没有可观察副作用且具有确定输出值的函数——换句话说，没有在函数给定作用域之外发生的动作。这使得它们可预测且易于测试，同时也是高效软件开发的关键属性。在C#代码中，我们通过使用不可变性和诸如`readonly`、`const`和`static`等关键字来实现这一点。此外，还有一个特殊的属性用于标记*纯函数*。*
- en: 'Steve: *Wow! This is all very exciting, but I don’t understand any of it. Could
    you give me something to read* *about it?*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*哇！这一切都非常令人兴奋，但我什么都不懂。你能给我一些关于它的阅读材料吗？*
- en: Julia gave him articles and Steve began to read.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅给了他文章，史蒂夫开始阅读。
- en: Understanding pure functions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解纯函数
- en: 'Pure functions are important in functional programming. They have two main
    features:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数在函数式编程中非常重要。它们有两个主要特性：
- en: '**Deterministic output**: For any given input, a pure function will always
    yield the same output, making its behavior extremely predictable. This characteristic
    simplifies the process of testing and debugging since the output of the function
    is always consistent given the same set of inputs.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性输出**：对于任何给定的输入，纯净函数总是会生成相同的输出，这使得其行为极其可预测。这一特性简化了测试和调试的过程，因为给定相同的输入集，函数的输出始终是一致的。'
- en: '**No observable side effects**: A pure function does not influence or is influenced
    by an external state. This means it doesn’t modify any external variables or data
    structures, or even carry out I/O operations. The function’s sole effect is the
    computation it performs and the result it delivers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无可见的副作用**：纯净函数不会影响或被外部状态影响。这意味着它不会修改任何外部变量或数据结构，甚至不会执行I/O操作。函数的唯一效果是它执行的计算和它提供的输出。'
- en: These two properties make pure functions similar to mathematical functions.
    A mathematical function, *f(x) = y*, produces a result, *y*, that relies solely
    on the input, *x*, and doesn’t alter or is altered by anything outside of the
    function. In programming, a pure function can be seen as a self-contained unit
    that transforms input into output without any interference from or to the external
    world.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特性使得纯净函数类似于数学函数。一个数学函数，*f(x) = y*，产生一个结果，*y*，它仅依赖于输入，*x*，并且不会被函数外部的东西所改变或影响。在编程中，纯净函数可以被看作是一个自包含的单元，它将输入转换为输出，而不受外部世界的干扰。
- en: By adhering to these properties, pure functions facilitate the creation of code
    that is more robust, maintainable, and less prone to bugs. Let’s examine these
    benefits and practical examples of pure functions further.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些特性，纯净函数有助于创建更健壮、可维护且更不易出错的代码。让我们进一步探讨这些优点和纯净函数的实际应用案例。
- en: Examples of pure functions
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数的示例
- en: 'Consider a function that determines how many books need to be printed to reach
    a target:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个确定需要打印多少本书才能达到目标数量的函数：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function always gives the same result with the same inputs and doesn’t
    change anything outside of it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数总是以相同的输入给出相同的结果，并且不会改变它之外的东西。
- en: 'Another example can be filtering out books of a particular genre:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可以是过滤出特定类型的书籍：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function is also pure. If you give it the same list of books, it will always
    return the same list of titles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数也是纯净的。如果你给它相同的书籍列表，它总是会返回相同的标题列表。
- en: The benefits of pure functions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数的优点
- en: 'Pure functions offer several significant advantages:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数提供几个显著的优势：
- en: '**Predictability and ease of testing**: Due to their deterministic nature,
    pure functions are highly predictable, making it easy to write unit tests. You
    always know what output to expect for a specific input, and there’s no need to
    mock or set up external dependencies for testing.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性和易于测试**：由于它们的确定性，纯净函数高度可预测，这使得编写单元测试变得容易。对于特定的输入，你总是知道预期的输出，而且不需要模拟或设置外部依赖项进行测试。'
- en: '**Code reusability and modularity**: Pure functions, when designed to focus
    on a specific task in line with the single-responsibility principle, become highly
    reusable. As they don’t depend on external states, you can move these functions
    without worrying about breaking the code or enhancing its modularity.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重用性和模块化**：当纯净函数按照单一职责原则设计，专注于特定任务时，它们变得高度可重用。由于它们不依赖于外部状态，你可以移动这些函数，而不用担心破坏代码或增强其模块化。'
- en: '**Ease of debugging and maintenance**: Without shared state or side effects,
    debugging pure functions is just a breeze. If there’s an issue, it’s usually within
    the function itself, making it easy to spot and fix. The isolation of pure functions
    also facilitates maintenance and updates as you can change a function without
    affecting other parts of your code.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于调试和维护**：没有共享状态或副作用，调试纯净函数非常简单。如果有问题，通常在函数内部，这使得它容易发现和修复。纯净函数的隔离也促进了维护和更新，因为你可以更改一个函数，而不会影响代码的其他部分。'
- en: Comparisons of pure functions and non-pure functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数与非纯函数的比较
- en: 'When analyzing pure functions alongside non-pure functions, the strengths and
    weaknesses of each become evident. To illustrate, let’s examine Konstatos’ tower
    defense mobile game as an example. In this game, different units take different
    amounts of damage from towers based on their defense against each type of tower.
    Each unit class can have a dictionary that contains these damage changes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析纯函数和非纯函数时，每个函数的优缺点都变得明显。为了说明这一点，让我们以 Konstatos 的塔防手机游戏为例。在这款游戏中，不同的单位根据对每种塔的防御能力，从塔楼受到不同数量的伤害。每个单位类可以有一个包含这些伤害变化的字典：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To figure out the damage a tower does to a unit, the unit class has a function
    that looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定塔对单位造成的伤害，单位类有一个看起来像这样的函数：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At first, you might think this function is pure. But because it uses the `_damageModifiers`
    variable, which can change, the output can also change, even if the input stays
    the same. This means the function depends on something outside of it, which isn’t
    good for pure functions. This can lead to mistakes and makes testing and fixing
    problems harder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你可能会认为这个函数是纯的。但因为它使用了可能会改变的后缀 `_damageModifiers` 变量，所以输出也可能改变，即使输入保持不变。这意味着函数依赖于它之外的东西，这对纯函数来说并不好。这可能导致错误，并使测试和修复问题变得更加困难。
- en: 'Here’s how we can make the function pure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使函数变得纯的方法：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, by giving `damageModifiers` directly to the function, it doesn’t depend
    on anything outside of it. This means that if you give it the same input, you’ll
    always get the same output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过直接将 `damageModifiers` 传递给函数，它不依赖于它之外的东西。这意味着如果你给它相同的输入，你总是会得到相同的输出。
- en: You might be wondering if it makes sense to give a dictionary to a function
    when the function can already see it. That’s a fair point. But doing it this way
    means the function doesn’t secretly rely on something other than its parameters,
    which makes our code cleaner and easier to work with.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道当函数本身已经可以看到它时，将字典传递给函数是否有意义。这是一个合理的观点。但这样做意味着函数不会秘密依赖于其参数之外的东西，这使得我们的代码更干净，更容易处理。
- en: Understanding the distinctions between these two types of functions and prioritizing
    the use of pure functions can enhance your code’s quality. As you delve deeper
    into functional programming in C#, this understanding will prove invaluable. Up
    next, we’ll discuss side effects in functional programming.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这两种函数之间的区别，并优先使用纯函数可以提高代码的质量。随着你更深入地学习 C# 中的函数式编程，这种理解将非常有价值。接下来，我们将讨论函数式编程中的副作用。
- en: Side effects
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用
- en: While working on his tower defense game, Steve noticed some unexpected behavior.
    Units were taking inconsistent damage from towers. After some investigation, he
    realized the damage calculation function relied on a global variable that could
    change unpredictably - a classic side effect.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发他的塔防游戏时，Steve 注意到了一些意外的行为。单位从塔楼受到的伤害不一致。经过一番调查，他意识到伤害计算函数依赖于一个可能会不可预测地改变的全球变量——这是一个典型的副作用。
- en: Side effects in programming refer to any application state changes that occur
    outside the function being executed. These changes could include modifying a global
    or static variable, changing the original value of function parameters, performing
    I/O operations, or even throwing an exception. Side effects make the behavior
    of a function dependent on the context, reducing predictability and potentially
    increasing bugs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的副作用指的是在执行函数之外发生的任何应用程序状态变化。这些变化可能包括修改全局或静态变量、改变函数参数的原始值、执行 I/O 操作，甚至抛出异常。副作用使函数的行为依赖于上下文，降低了可预测性，并可能增加错误。
- en: Common sources of side effects
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见副作用来源
- en: When writing code, it’s good to know where side effects might come from. Side
    effects can make code unpredictable. Let’s break down some common sources.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，了解副作用可能来自哪里是很好的。副作用会使代码变得不可预测。让我们分析一些常见的来源。
- en: Global variables
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'Problem: Using global variables can lead to unexpected changes. If a function
    changes a global variable, it can affect other parts of your program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：使用全局变量可能导致意外的变化。如果一个函数改变了全局变量，它可能会影响程序的其他部分：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`UpdateUserScore` changes the `UserScores` dictionary. Since this dictionary
    is accessible everywhere, other functions might also change it. This makes our
    function unpredictable.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateUserScore` 改变了 `UserScores` 字典。由于这个字典可以在任何地方访问，其他函数也可能改变它。这使得我们的函数变得不可预测。'
- en: 'Solution: Instead of global variables, it’s better to use function arguments
    or put the state inside objects. For example, here, as we did before, it is better
    to pass the dictionary as a parameter to eliminate the problem.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：与全局变量相比，最好使用函数参数或将状态放在对象内部。例如，在这里，正如我们之前所做的那样，将字典作为参数传递以消除问题更好。
- en: The out and ref parameters
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`out`和`ref`参数'
- en: 'Problem: Using `out` and `ref` in C# can change the original data that’s given
    to a function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：在C#中使用`out`和`ref`可以改变传递给函数的原始数据：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `UpgradeTower` method not only updates the `Damage` and `Hitpoints` values
    but also changes the reference so that it no longer points to the original `Tower`
    object. Of course, it is almost impossible to see code like this in real life;
    usually, it isn’t so straightforward and is hidden inside other methods. This
    code is a simplified and slightly ugly version of real code to show you the idea
    behind using `ref` parameters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpgradeTower`方法不仅更新了`Damage`和`Hitpoints`值，而且还改变了引用，使其不再指向原始的`Tower`对象。当然，在现实生活中几乎不可能看到这样的代码；通常，它并不那么直接，而是隐藏在其他方法中。这段代码是一个简化且有些丑陋的真实代码版本，以展示使用`ref`参数背后的理念。'
- en: 'Solution: Instead of changing the data, it’s a good idea to return a new value.
    Here, we could rename the method to `GetLeveledUpTower` and make it return a new
    tower.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：而不是改变数据，返回一个新的值是一个好主意。在这里，我们可以将方法重命名为`GetLeveledUpTower`并使其返回一个新的塔。
- en: I/O operations
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I/O操作
- en: 'Problem: Doing things such as saving to a file or a database will change data
    outside your function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：像保存到文件或数据库这样的操作会改变函数之外的数据：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `SaveGameProgressToFile` function saves game progress data to a file. This
    kind of action can fail if, for example, there’s no space left on the disk. So,
    it’s a side effect because it relies on something outside our function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaveGameProgressToFile`函数将游戏进度数据保存到文件。如果，例如，磁盘空间不足，这种动作可能会失败。因此，它是一个副作用，因为它依赖于我们函数之外的东西。'
- en: 'Solution: It’s helpful to keep logic separate from actions such as saving data.
    This makes the code clearer and easier to understand.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：将逻辑与像保存数据这样的动作分开是有帮助的。这使得代码更清晰，更容易理解。
- en: Exception handling
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'Problem: Consider a function that calculates the damage dealt by a tower:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：考虑一个计算塔造成的伤害的函数：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `CalculateDamage` function throws an exception if the tower or unit is `null`.
    Throwing an exception changes the regular flow of our program. If not handled,
    it can terminate the application or lead to unexpected behavior.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculateDamage`函数如果塔或单位是`null`，则会抛出异常。抛出异常会改变我们程序的正常流程。如果没有处理，它可能会终止应用程序或导致意外行为。'
- en: 'Solution: The best way to go here is to use the `Either` monad. However, before
    we discuss it, you can use a nullable type called `double?`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：在这里，最好的做法是使用`Either`单子。然而，在我们讨论它之前，你可以使用一个名为`double?`的可空类型：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this `CalculateDamage` method, if the tower or unit is `null`, the method
    returns `null`; otherwise, it calculates the damage and returns it. This way,
    we avoid the side effect of breaking the flow with exceptions for common scenarios.
    However, the code that uses this method must be also modified so that it can handle
    the situation when `null` is returned.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`CalculateDamage`方法，如果塔或单位是`null`，则方法返回`null`；否则，它计算伤害并返回。这样，我们避免了在常见场景中通过异常中断流程的副作用。然而，使用此方法的代码也必须修改，以便它可以处理返回`null`的情况。
- en: Knowing how exceptions can be a source of side effects helps in making design
    choices that keep our C# code clearer and more predictable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 了解异常可以是副作用的一个来源，有助于做出使我们的C#代码更清晰和更可预测的设计选择。
- en: Consequences of side effects
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副作用的后果
- en: 'The presence of side effects in your code can lead to various issues:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中存在副作用可能会导致各种问题：
- en: '**Decreased predictability**: Functions with side effects are less predictable
    because their output can change based on the external state. This decreased predictability
    makes it harder to understand what a function does just by looking at it.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性降低**：具有副作用的函数的可预测性较低，因为它们的输出可能会根据外部状态而改变。这种可预测性的降低使得仅通过查看函数本身更难理解其功能。'
- en: '**Increased difficulty in testing and debugging**: Functions with side effects
    are harder to test since they require the correct external state to produce the
    expected result. Debugging is also more complex because an issue in the function
    could be due to an external state change.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试和调试难度增加**：具有副作用的功能更难测试，因为它们需要正确的外部状态来产生预期的结果。调试也更加复杂，因为函数中的问题可能是由于外部状态的变化。'
- en: '**Concurrency issues**: Concurrency problems can arise when multiple threads
    access and modify shared state simultaneously, leading to unexpected results.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发问题**：当多个线程同时访问和修改共享状态时，可能会出现并发问题，导致意外结果。'
- en: Although it might not look instantly bad, with time, these consequences tend
    to snowball, making your project very expensive to develop and support.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能并不立即有问题，但随着时间的推移，这些后果往往会累积，使得你的项目开发和维护成本非常高。
- en: Strategies to minimize side effects
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少副作用的方法
- en: While side effects in real-world applications are unavoidable, the key is to
    control and isolate them to make your code more manageable and predictable. This
    section focuses on strategies to minimize side effects by using `readonly`, `const`,
    `static`, and immutability in C#.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现实世界中的应用程序中的副作用不可避免，但关键是要控制和隔离它们，以便使代码更易于管理和预测。本节重点介绍通过在 C# 中使用 `readonly`、`const`、`static`
    和不可变性来最小化副作用的方法。
- en: Favor immutability
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先考虑不可变性
- en: 'Immutability is a powerful way to minimize side effects. Immutable objects
    are objects whose state can’t be changed after they’re created. In C#, strings
    are a prime example of immutability. Every operation on a string results in a
    new string, and the original string remains unchanged. This principle can be expanded
    to other data types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性是减少副作用的一种强大方式。不可变对象是在创建后其状态不能被改变的对象。在 C# 中，字符串就是一个不可变性的典型例子。对字符串的每一次操作都会产生一个新的字符串，而原始字符串保持不变。这个原则可以扩展到其他数据类型：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code snippet, `originalBook` is created as an instance of `Book` with
    a specific title and author and `updatedBook` is a new instance of `Book` that
    was created using the `with` expression. The `with` expression is used to create
    a new record with some properties modified from an existing record. Here, it creates
    a new `Book` value with the same `Title` value as `originalBook` but with `Author`
    set to `"Robert` `C. Martin"`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`originalBook` 被创建为一个具有特定标题和作者的 `Book` 实例，而 `updatedBook` 是使用 `with`
    表达式创建的新 `Book` 实例。`with` 表达式用于创建一个新的记录，其某些属性是从现有记录修改而来的。在这里，它创建了一个新的 `Book` 值，其
    `Title` 值与 `originalBook` 相同，但 `Author` 被设置为 `"Robert C. Martin"`。
- en: This approach maintains immutability because `originalBook` remains unchanged,
    and any “modification” results in a new instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法保持了不可变性，因为 `originalBook` 保持不变，任何“修改”都会导致一个新的实例。
- en: Use readonly and const
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `readonly` 和 `const`
- en: '`readonly` and `const` are two keywords in C# that can make your fields and
    variables unchangeable, thereby reducing the potential for side effects.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 和 `const` 是 C# 中的两个关键字，可以使字段和变量不可变，从而减少副作用的可能性。'
- en: '`const` variables are implicitly static and should be used when the value is
    known at compile time and will never change:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 变量是隐式静态的，应该在值的编译时已知且永远不会改变时使用：'
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the other hand, `readonly` variables can be either instance-level or static,
    and their values can be set at runtime (for instance, inside constructors), but
    not changed afterward:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`readonly` 变量可以是实例级别的或静态的，它们的值可以在运行时设置（例如，在构造函数内部），但之后不能更改：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Use functional programming principles
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数式编程原则
- en: Functional programming principles are designed to help minimize side effects.
    Besides pure functions and immutability, principles such as expressions over statements,
    the use of higher-order functions, and function composition can also aid in this
    mission. While we are already acquainted with the former, higher-order functions
    and function composition will be discussed in later chapters. So, let’s just keep
    moving – applying these principles can greatly enhance the predictability and
    maintainability of your code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程原则旨在帮助最小化副作用。除了纯函数和不可变性之外，如表达式代替语句、使用高阶函数和函数组合等原则也可以帮助实现这一目标。虽然我们已经熟悉了前者，但高阶函数和函数组合将在后面的章节中讨论。所以，让我们继续前进——应用这些原则可以大大提高代码的可预测性和可维护性。
- en: Encapsulate side effects
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装副作用
- en: 'When side effects are unavoidable, it’s crucial to isolate them. For instance,
    if a function must write to a file, that should be its sole responsibility. All
    other logic should be separated into pure functions as much as possible. This
    way, the side effects are contained, and the rest of your code remains unaffected:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当副作用不可避免时，隔离它们至关重要。例如，如果一个函数必须写入文件，那么这应该是它的唯一责任。所有其他逻辑应尽可能分离到纯函数中。这样，副作用就被包含在内，而其余的代码不受影响：
- en: '![](img/B21069_03_001.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21069_03_001.jpg)'
- en: The idea here is to isolate side effects, making them predictable, visible,
    and manageable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是隔离副作用，使它们可预测、可见和管理。
- en: Strategies to minimize side effects are key to building reliable, efficient,
    and maintainable software. By implementing these strategies, we inch closer to
    the functional programming paradigm, harnessing its strengths and benefits.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化副作用策略对于构建可靠、高效和可维护的软件至关重要。通过实施这些策略，我们逐渐接近函数式编程范式，利用其优势和好处。
- en: Next, we’ll discuss how to use the `Pure` attribute to mark pure functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何使用`Pure`属性来标记纯函数。
- en: Marking pure functions with the Pure attribute
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Pure`属性标记纯函数
- en: Understanding the role of pure functions and side effects in our code is crucial
    for effective functional programming in C#. But how do we communicate our intent
    that a function should be pure? This is where the `Pure` attribute comes into
    play.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 理解纯函数和副作用在我们代码中的作用对于在C#中进行有效的函数式编程至关重要。但我们是怎样传达一个函数应该是纯的意图的呢？这就是`Pure`属性发挥作用的地方。
- en: Understanding the Pure attribute in C#
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C#中的Pure属性
- en: In C#, the `Pure` attribute is defined in the `System.Diagnostics.Contracts`
    namespace and serves as a declarative tag to indicate that a method is pure. A
    pure method is one that, given the same inputs, will always return the same output
    and does not produce any observable side effects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`Pure`属性定义在`System.Diagnostics.Contracts`命名空间中，并作为声明性标签来指示一个方法是纯的。一个纯方法是指，给定相同的输入，它将始终返回相同的输出，并且不会产生任何可观察的副作用。
- en: 'It’s important to note that the `Pure` attribute is primarily intended for
    use in code contracts and static checking tools. The runtime and compiler don’t
    enforce the purity of a method, and this attribute does not change the method’s
    behavior in any way:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`Pure`属性主要用于在代码合约和静态检查工具中使用。运行时和编译器不强制执行方法的纯度，并且这个属性不会以任何方式改变方法的行为：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we have a function that calculates the royalty amount for a
    book based on its price and the royalty percentage. It’s a pure function since
    it always returns the same output for the same input and doesn’t have any observable
    side effects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个函数，它根据书籍的价格和版税百分比计算版税金额。它是一个纯函数，因为它总是对相同的输入返回相同的输出，并且没有可观察的副作用。
- en: The benefits of marking functions as pure
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记函数为纯的益处
- en: 'Marking functions as pure using the `Pure` attribute brings several benefits:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Pure`属性标记函数带来了一些好处：
- en: '**Clarity and intention**: By marking a function as pure, you communicate your
    intention to other developers that this function should remain side-effect-free'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰性和意图**：通过将函数标记为纯的，你向其他开发者传达了你的意图，即这个函数应该保持无副作用。'
- en: '`Pure` attribute to help identify potential issues in your code'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pure`属性帮助识别代码中的潜在问题'
- en: '**Optimization opportunities**: While the C# compiler doesn’t currently take
    advantage of this, in some languages and scenarios, knowing that a function is
    pure can enable additional compiler optimizations'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化机会**：虽然C#编译器目前没有利用这一点，但在某些语言和场景中，知道一个函数是纯的可以启用额外的编译器优化。'
- en: Caveats and considerations when using the Pure attribute
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纯属性时的注意事项
- en: 'When marking functions as pure, keep the following points in mind:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当标记函数为纯时，请记住以下几点：
- en: '`Pure` attribute does not enforce purity. You can mark a method as pure, and
    it can still have side effects. The attribute is more of a communication and analysis
    tool.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pure`属性不强制执行纯度。你可以将方法标记为纯的，它仍然可以有副作用。这个属性更多的是一种通信和分析工具。'
- en: '`Pure` attribute cannot be used with void methods.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pure`属性不能与void方法一起使用。'
- en: '`Pure` attribute has no impact on the method’s runtime behavior. It’s mainly
    used by certain static analysis tools, such as code contracts.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pure`属性对方法的运行时行为没有影响。它主要被某些静态分析工具使用，例如代码合约。'
- en: By marking your functions with the `Pure` attribute, you make a promise about
    your function’s behavior, helping others (and tools) understand your code better.
    However, it’s crucial to remember that the attribute is a tool, not a panacea.
    The responsibility for ensuring a function’s purity still lies primarily with
    the developer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将函数标记为`Pure`属性，你对自己的函数行为做出了承诺，帮助他人（和工具）更好地理解你的代码。然而，记住属性只是一个工具，而不是万能的。确保函数纯度的责任仍然主要在于开发者。
- en: Exercises
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: To test Steve’s understanding, Julia presented him with three coding challenges
    related to pure functions and side effects. “These exercises will help solidify
    the concepts,” she explained. “Give them a try and let me know if you have any
    questions.”
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试史蒂夫的理解，朱莉娅向他提出了三个与纯函数和副作用相关的编码挑战。“这些练习将有助于巩固这些概念，”她解释道。“试一试，如果有什么问题，请告诉我。”
- en: Exercise 1
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Steve’s tower defense game calculates damage based on a global difficulty modifier.
    Refactor this function to make it pure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫的塔防游戏根据全局难度修改器计算伤害。重构此函数以使其成为纯函数：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Exercise 2
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'Steve’s game loads enemy data from a file, processes it, and updates the game
    state. Refactor this function to isolate its side effects:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫的游戏从文件中加载敌人数据，处理它，并更新游戏状态。重构此函数以隔离其副作用：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Exercise 3
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Refactor the following method by making it a pure function and marking it with
    the `Pure` attribute:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其转换为纯函数并标记为`Pure`属性来重构以下方法：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These exercises should help solidify your understanding of the concepts we’ve
    covered. Keep practicing, keep experimenting, and remember – every line of code
    you write is a step forward on your journey to mastering functional programming
    in C#.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习应该有助于巩固我们对所涵盖概念的理解。继续练习，继续实验，并记住——你写的每一行代码都是你在掌握C#函数式编程旅程上迈出的一步。
- en: Solutions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解答
- en: Here are the solutions to the exercises in this chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章练习的解答。
- en: Exercise 1
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'A pure function should not depend on or modify any state outside its scope.
    So, instead of relying on the global `difficultyModifier` value, we should pass
    it as a parameter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个纯函数不应该依赖于或修改其作用域之外的状态。因此，我们不应该依赖于全局的`difficultyModifier`值，而应该将其作为参数传递：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Exercise 2
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'To isolate side effects, we’ll separate the pure logic from the I/O operations
    and state mutations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隔离副作用，我们将纯逻辑与I/O操作和状态变更分开：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Exercise 3
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'This one is a bit tricky because the function is already pure. All we need
    to do is add the `Pure` attribute to communicate that intention to other developers
    and analysis tools:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点棘手，因为函数已经是纯函数了。我们只需要添加`Pure`属性来向其他开发者和分析工具传达这种意图：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These solutions adhere to the principles of functional programming, ensuring
    minimized side effects and clarity of code behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解答遵循函数式编程的原则，确保最小化副作用并使代码行为清晰。
- en: With that, let’s cover some dos and don’ts for utilizing pure functions and
    minimizing side effects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来谈谈使用纯函数和最小化副作用的一些应该做和不应该做的事情。
- en: 'These are the dos:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是应该做的事情：
- en: Strive to write more pure functions as they’re predictable and straightforward
    to understand and test
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 努力编写更多的纯函数，因为它们是可预测的，易于理解和测试
- en: Isolate side effects – that is, keep them separate from pure code
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离副作用——也就是说，将它们与纯代码分开
- en: Use `readonly`, `const`, and `static` modifiers to promote immutability and
    reduce side effects
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`readonly`、`const`和`static`修饰符来提高不可变性并减少副作用
- en: Use the `Pure` attribute to communicate intent, aiding in code analysis and
    maintainability
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Pure`属性来传达意图，有助于代码分析和维护
- en: 'These are the don’ts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是不应该做的事情：
- en: Overuse global state as it leads to high coupling and increases the risk of
    side effects.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用全局状态，因为它会导致高耦合并增加副作用的风险。
- en: Modify inputs inside a function. This alteration can lead to unexpected behavior.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部修改输入。这种改变可能导致意外行为。
- en: Forget that the `Pure` attribute doesn’t enforce purity. It’s a promise that
    the developer needs to fulfill.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记`Pure`属性并不强制执行纯度。它是对开发者需要履行的承诺。
- en: Ignore the context. Sometimes, a non-pure function can provide a better solution.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略上下文。有时，一个非纯函数可以提供更好的解决方案。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Diving into the world of functional programming in C# has been a stimulating
    journey, and we’re only just getting started. In this chapter, we explored the
    pivotal concepts of pure functions and side effects and their respective roles
    in writing cleaner, more predictable, and maintainable code. Let’s reinforce the
    knowledge we’ve gained and map out the course moving forward.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 深入C#函数式编程的世界是一次令人兴奋的旅程，而我们才刚刚开始。在本章中，我们探讨了纯函数和副作用的关键概念以及它们在编写更干净、更可预测和可维护的代码中的相应角色。让我们巩固我们所学的知识，并规划未来的课程。
- en: Pure functions stand as a beacon of certainty in the unpredictable universe
    of software. They have a clear-cut contract – the same input always yields the
    same output, and they remain uninvolved with the state outside their scope. This
    simplicity makes them predictable, easy to test, and more amenable to parallelization
    and optimization.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数在软件这个不可预测的宇宙中像一座灯塔一样屹立着。它们有一个明确的契约——相同的输入总是产生相同的输出，并且它们不涉及它们作用域之外的状态。这种简单性使它们可预测、易于测试，并且更易于并行化和优化。
- en: However, the real world is filled with side effects – reading and writing to
    a database, calling an API, modifying a global variable – the list goes on. Side
    effects are inevitable, but when uncontrolled, they can unleash chaos, making
    the code hard to reason about and test. To mitigate this problem in functional
    programming, we must wrap pure functions with impure code, thus protecting them
    from having side effects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实世界充满了副作用——读写数据库、调用API、修改全局变量——这个列表可以一直继续下去。副作用是不可避免的，但如果没有得到控制，它们可能会引发混乱，使得代码难以推理和测试。为了在函数式编程中减轻这个问题，我们必须用不纯的代码包裹纯函数，从而保护它们免受副作用的影响。
- en: In the next chapter, we will talk about a new type of function – honest functions.
    We’ll talk about what are they, how to use them in C#, and what danger nullable
    references can bring.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一种新的函数类型——诚实函数。我们将讨论它们是什么，如何在C#中使用它们，以及可空引用可能带来的危险。
