- en: '*Chapter 7*: Task Parallel Library (TPL) and Dataflow'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Task Parallel Library** (**TPL**) **dataflow library** contains building
    blocks to orchestrate asynchronous workflows in .NET. This chapter will introduce
    the TPL Dataflow library, describe the types of **dataflow blocks** in the library,
    and illustrate some common patterns for using dataflow blocks through hands-on
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: The dataflow library can be useful when processing large amounts of data in
    multiple stages or when your application receives data in a continuous stream.
    The dataflow blocks provide a fantastic way of implementing the **producer/consumer
    design pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this, we will create a sample project that implements this pattern
    and examine other real-world uses of the dataflow library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to know that the TPL Dataflow library isn’t distributed as part
    of the .NET runtime or SDK. It’s available as a NuGet package from Microsoft.
    We will add it to our sample projects with **NuGet Package Explorer** (**NPE**)
    in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the TPL Dataflow library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the producer/consumer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a data pipeline with multiple blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating data from multiple data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the purpose of each type of
    dataflow block and be able to add the dataflow library to your projects, where
    appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: You will also know when dataflow blocks do not provide an advantage over simpler
    parallel programming alternatives, such as `Parallel.ForEach`.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To complete the WPF sample, you will need to install the .NET desktop development
    workload for Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: The code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by discussing the TPL Dataflow library and why it can be a
    great way to implement parallel programming in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the TPL Dataflow library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TPL Dataflow library has been available for as long as TPL itself. It was
    released in 2010 after `System.Threading.Tasks.Dataflow` namespace. The dataflow
    library is intended to build on the basics of parallel programming that are provided
    in TPL, expanding to address data flow scenarios (hence the name of the library).
    The dataflow library is made up of foundational classes called **blocks**. Each
    data flow block is responsible for a particular action or step in the overall
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataflow library consists of three basic types of blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ISourceBlock<TOutput>` interface. Source blocks can have their data read from
    the workflow you define.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ITargetBlock<TInput>` interface and is a data receiver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPropagatorBlock<TInput, TOutput>` interface. Applications can read data from
    these blocks and write to them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you connect multiple dataflow blocks to create a workflow, the resulting
    system is referred to as a `ISourceBlock<TOutput>.LinkTo` method. This is where
    propagator blocks can fit in the middle of a pipeline. They can act as both the
    source and target of a link in the workflow. If a message from a source block
    can be processed by more than one target, you can add filtering to examine the
    properties of the object provided by the source to determine which target or propagator
    block should receive the object.
  prefs: []
  type: TYPE_NORMAL
- en: The objects that are passed between dataflow blocks are commonly referred to
    as **messages**. You can think of a dataflow pipeline as a **network** or messaging
    system. The units of data that flow through the network are the messages. Each
    block is responsible for reading, writing, or transforming each message in some
    way.
  prefs: []
  type: TYPE_NORMAL
- en: To send a message to a target block, you can use the `Post` method to send it
    synchronously or the `SendAsync` method to send it asynchronously. In source blocks,
    messages can be received with the `Receive`, `TryReceive`, and `ReceiveAsync`
    methods. The `Receive` and `TryReceive` methods are both synchronous. The `Choose`
    method will monitor multiple source blocks for data and return a message from
    the first source to provide data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To offer a message from a source block to a target block, the source can call
    the `OfferData` method of a target. The `OfferData` method returns a `DataflowMessageStatus`
    enum that has several possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Accepted`: The message was accepted and will be processed by the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Declined`: The message was declined by the target. The source block still
    owns the message and cannot process its next message until the current message
    has been accepted by another target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DecliningPermanently`: The message was declined, and the target is no longer
    available for processing. All subsequent messages will be declined by the current
    target. Source blocks will unlink from a target that returns this status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Postponed`: Accepting the message has been postponed. It may be accepted by
    the target at a later time. In this case, the source can wait or attempt to pass
    the message to an alternative target block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotAvailable`: The message was no longer available when the target tried to
    accept it. This can occur when the target attempts to accept a message after it
    had been postponed, but the source block has already passed the message to a different
    target block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataflow blocks support the concept of `Complete` method and a `Completion`
    property. The `Complete` method is called to request completion on a block, while
    the `Completion` property returns a `Task`, known as the block’s `IDataflowBlock`
    interface, which is inherited by both `ISourceBlock` and `ITargetBlock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completion task can be used to determine if a block has encountered an
    error or has been canceled. Let’s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to handle errors encountered by a dataflow block is to call
    `Wait` on the `Completion` property of the block and handle the `AggregateException`
    exception type in the `try`/`catch` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to do the same thing without using the blocking `Wait` call, you
    can `await` the completion task and handle the `Exception` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another alternative is to use the `ContinueWith` method on the completion task.
    Inside the continuation block, you can check the status of the task to determine
    if it is `Faulted` or `Canceled`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will see more comprehensive examples of dataflow block use when we create
    a sample project using the producer/consumer pattern in the next section. Before
    we examine the types of dataflow blocks, let’s discuss why Microsoft created the
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Why use the TPL Dataflow library?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TPL dataflow library was created by Microsoft as a means of orchestrating
    asynchronous data processing workflows. Data flows into the first dataflow block
    in the pipeline from a data source. The source can be a database, a local or network
    folder, a camera, or just about any other type of input device that .NET can access.
    One or more blocks can be part of the pipeline, with each being responsible for
    a single operation. The following diagram illustrates two abstractions of dataflow
    pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Dataflow pipeline examples ](img/Figure_7.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Dataflow pipeline examples
  prefs: []
  type: TYPE_NORMAL
- en: One real-world example you can consider is using a webcam to capture image frames.
    In a two-step flow, as shown in *Example 1*, consider the webcam as **Data Input**.
    **Dataflow Block 1** could perform some image processing to optimize the image
    appearance, while **Dataflow Block 2** will call an **Azure Cognitive Services**
    API to identify objects in each image. **Result** would contain a new .NET class
    for each input image containing the image binary data and properties that contain
    the identified objects within each image.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn about the types of blocks available in the dataflow library.
  prefs: []
  type: TYPE_NORMAL
- en: Types of dataflow blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are nine predefined blocks in the dataflow library. These can be divided
    into three different categories. The first category is **buffering blocks**.
  prefs: []
  type: TYPE_NORMAL
- en: Buffering blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of `BufferBlock<T>`, `BroadcastBlock<T>`, and `WriteOnceBlock<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: BufferBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`BufferBlock<T>` is an asynchronous queuing mechanism that implements a `BufferBlock`
    can have multiple data sources and multiple targets configured. However, each
    message in a `BufferBlock` can only be delivered to one target block. The message
    is removed from the queue after it has been successfully delivered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet pushes customer names into a `BufferBlock` and subsequently
    reads the first five names out to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: BroadcastBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`BroadcastBlock<T>` is used similarly to `BufferBlock`, but it is intended
    to provide only the most recently posted message available to consumers. It can
    also be used to send the same value to many consumers. The message that’s posted
    to a `BroadcastBlock` is not removed after it has been received by a consumer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet will read the same alert message each time the `Receive`
    method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: WriteOnceBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the name suggests, `WriteOnceBlock<T>` can only be written to once. After
    the first message has been received, all calls to `Post` or `SendAsync` will be
    ignored by the block. No exceptions will be thrown. The data is simply discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is similar to our `BufferBlock` snippet. However, because
    we’re now using a `WriteOnceBlock`, only the first customer’s name will be accepted
    by the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Execution blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ActionBlock<TInput>` is a `TransformBlock<TInput, TOuput>` and `TransformManyBlock<TInput,
    TOutput>` are both **propagator** blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: ActionBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ActionBlock` is a block that accepts either `Action<T>` or `Func<TInput, Task>`
    as its constructor. An action on an input message is considered complete when
    the action returns or the task of `Func` completes. You can use an action for
    synchronous delegates or `Func` for async operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this snippet, we will output customer names to the console with `Console.WriteLine`,
    which is provided in an `Action`, to the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: TransformBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`TransformBlock<TInput, TOutput>` is similar to `ActionBlock`. However, as
    a propagator block, it returns an output value for each message that’s received.
    The two possible delegate signatures that can be provided to the `TransformBlock`
    constructor are `Func<TInput, TOutput>` for synchronous operations and `Func<TInput,
    Task<TOutput>>` for asynchronous operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses a `TransformBlock` that will convert a customer
    name into all capitals before the first five output values are retrieved to be
    displayed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: TransformManyBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`TransformManyBlock<TInput, TOutput>` is similar to `TransformBlock` except
    that the block can return one or more values for every input value that’s received.
    The possible delegate signatures for `TransformManyBlock` are `Func<TInput, IEnumerable<TOutput>>`
    and `Func<TInput, Task<IEnumerable<TOutput>>>` for synchronous and asynchronous
    operations, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this snippet, we will pass one customer name to `TransformManyBlock`, which
    will return an enumerable containing the individual characters in the customer’s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Grouping blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`BatchBlock<T>` is a propagator block, while `JoinBlock<T1, T2>` and `BatchedJoinBlock<T1,
    T2>` are both source blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: BatchBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`BatchBlock` accepts batches of data and produces arrays of output data. When
    creating a `BatchBlock`, you specify the input batch size. `BatchBlock` has a
    `Greedy` property in the `dataflowBlockOptions` optional constructor parameter
    that specifies the **greedy mode**:'
  prefs: []
  type: TYPE_NORMAL
- en: When `Greedy` is `true`, which is its default value, the block continues processing
    every input value as it is received and outputs an array as the batch size is
    reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `Greedy` is `false`, incoming messages can be paused while an array of
    the batch size is being created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Greedy` mode usually performs better, but if you are coordinating input from
    multiple sources, you may need to use **non-greedy mode**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `BatchBlock` separates student names into classes with a maximum
    size of 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: JoinBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`JoinBlock` has two signatures: `JoinBlock<T1, T2>` and `JoinBlock<T1, T2,
    T3>`. `JoinBlock<T1, T2>` has `Target1` and `Target2` properties to accept inputs
    and returns a `Tuple<T1, T2>` as each pair of targets is filled. `JoinBlock<T1,
    T2, T3>` has `Target1`, `Target2`, and `Target3` properties and returns a `Tuple<T1,
    T2, T3>` as each set of targets is completed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`JoinBlock` also has greedy and non-greedy modes, with greedy mode being the
    default behavior. When you switch to non-greedy mode, all input is postponed to
    targets that have already received input until a complete output set is populated
    and sent as output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create a `JoinBlock` to combine a person’s first name,
    last name, and age into the output tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: BatchedJoinBlock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `BatchedJoinBlock` is like a `JoinBlock` except the tuple in the output contains
    `IList` items of the size of the batch specified in the constructor: `Tuple(IList(T1),
    IList(T2))` or `Tuple(IList(T1), IList(T2), IList(T3))`. The batching concept
    is the same as it is for `BatchBlock`.'
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, try to build on the `JoinBlock` example to add more people to
    the list, divide them into batches of four, and output the name of the oldest
    person in each batch.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored examples of all of the available dataflow blocks,
    let’s get into some real-world dataflow examples. In the next section, we will
    use some dataflow blocks to create a producer/consumer implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the producer/consumer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The blocks in the TPL Dataflow library provide a fantastic platform for implementing
    the **producer/consumer pattern**. If you are not familiar with this design pattern,
    it involves two operations and a queue of work. The **producer** is the first
    operation. It is responsible for filling the queue with data or units of work.
    The **consumer** is responsible for taking items from the queue and acting on
    them in some way. There can be one or more producers and one or more consumers
    in the system. You can change the number of producers or consumers, depending
    on which part of the process is the bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Scenario Example
  prefs: []
  type: TYPE_NORMAL
- en: To relate the producer/consumer pattern to a *real-world scenario*, think about
    preparing gifts for a holiday gathering. You and a partner are working together
    to prepare the gifts. You are fetching and staging the gifts to be wrapped. You
    are the *producer*. Your partner is taking items from your queue and wrapping
    each gift. They are the *consumer*. If the queue starts to get backed up, you
    can find another friend (or consumer) to help with the wrapping and increase the
    overall throughput. If, on the other hand, you are taking too much time to find
    each gift to be wrapped, you can add another producer to help find them and fill
    the queue. This will keep the consumers busy and increase the efficiency of the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In our .NET producer/consumer example, we are going to build a simple WPF application
    that fetches blog posts from multiple RSS feeds and displays them in a single
    `ListView` control. Each row in the list will include the blog post’s date, categories,
    and an HTML summary of the post’s content. The producers in the application will
    fetch posts from an RSS feed and add a `SyndicationItem` to the queue for each
    blog post. We will get posts from three blogs and create a producer for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'The consumers will take a `SyndicationItem` from the queue and use an `ActionBlock`
    delegate to create a `BlogPost` object for each `SyndicationItem`. We will create
    three consumers to keep up with the items that have been queued by our three producers.
    When the process completes, the list of `BlogPost` objects will be set as `ItemSource`
    for `ListView`. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new WPF project with .NET 6\. Name the project `ProducerConsumerRssFeeds`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **NuGet Package Manager** for the solution, search for **Syndication**
    on the **Install** tab, and add the **System.ServiceModel.Syndication** package
    to the project. This package will make it simple to fetch data from any RSS feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class to the project named `BlogPost`. This will be our model object
    for each blog post to be displayed in `ListView`. Add the following properties
    to the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it’s time to create a service class to fetch the blog posts for a given
    RSS feed URL. Add a new class named `RssFeedService` to the project and add a
    method named `GetFeedItems` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The static `SyndicationFeed.Load` method uses `XmlReader` to fetch the XML from
    the provided `feedUrl` and transform it into `IEnumerable<SyndicationItem>` to
    return from the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new class named `FeedAggregator`. This class will contain the
    producer/consumer logic that calls `GetFeedItems` for each blog and transforms
    the feed data for each blog post so that it can be displayed in the UI. The three
    blogs that we are aggregating are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The .NET blog
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows blog
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Microsoft 365 blog
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first step with `FeedAggregator` is creating a producer method named `ProduceFeedItems`
    and a parent method named `QuseueAllFeeds` that will start three instances of
    the producer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We are using `BufferBlock<SyndicationItem>` as our queue. Every producer calls
    `GetFeedItems` and adds each `SyndicationItem` that’s returned to `BufferBlock`.
    The `QueueAllFeeds` method uses `Task.WhenAll` to wait for all of the producers
    to finish adding items to the queue. Then, it signals to `BufferBlock` that all
    the producers are done by calling `itemQueue.Complete()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create our consumer method. This method, named `ConsumeFeedItem`,
    will be responsible for taking a `SyndicationItem` provided by `BufferBlock` and
    converting it into a `BlogPost` object. Each `BlogPost` will be added to `ConcurrentBag<BlogPost>`.
    We’re using a thread-safe collection here because there will be multiple consumers
    adding output to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it’s time to tie the producer/consumer logic together. Create a method
    named `GetAllMicrosoftBlogPosts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method starts by creating a `ConcurrentBag<BlogPost>` to aggregate the
    final list of posts for the UI. Then, it creates the `itemQueue` object with a
    `BoundedCapacity` of `10`. This bounded capacity means that no more than 10 items
    can be enqueued at any time. Once the queue reaches 10, all the producers must
    wait for the consumers to dequeue some items. This can slow the performance of
    the process, but it prevents potential out-of-memory issues in production code.
    Our sample is not in any danger of running out of memory when processing posts
    from three blogs, but you can see how to use `BoundedCapacity` when it is needed
    in your applications. You can create the queue with no `BoundedCapacity` like
    this:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next part of the method creates three consumers that use `ActionBlock<SyndicationItem>`
    with `ConsumeFeedItem` as the provided delegate. Each consumer is linked to the
    queue with the `LinkTo` method. Setting `BoundedCapacity` of the consumers to
    `1` tells the producers to move on to the next consumer if the current one is
    already busy processing an item.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the links have been established, we can start the producers by calling
    `QueueAllFeeds`. Then, we must `await` the producers and the `Completion` object
    of each consumer `ActionBlock`. By linking the completion of the producers and
    consumers, we don’t need to explicitly `await` the `Completion` object of the
    consumers:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create some UI controls to display the information to our
    users. Open the `MainWindow.xaml` file and replace the existing `Grid` with the
    following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Explaining the details of WPF, XAML, and data binding are outside the scope
    of this book. If you would like to learn more about WPF, check out *Mastering
    Windows Presentation Foundation*, by Sheridan Yeun: [https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416](https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416).
    What this markup does is create a new `ListView` control with a `DataTemplate`
    to define the structure of each list item in the control. For each item, we are
    defining either a `TextBlock` or `TextBox` to hold the values for each `BlogPost`
    object in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we must do is call the `GetAllMicrosoftBlogPosts` method and
    populate the UI. Open `MainWindow.xaml.cs` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After `MainWindow` has loaded, the items that have been returned from `GetAllMicrosoftBlogPosts`
    are set as `mainListView.ItemsSource`. This will allow the data to bind to the
    elements in `DataTemplate`, which we defined in the XAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the project and see how things look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Running the ProducerConsumerRssFeeds WPF application for the
    first time ](img/Figure_7.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Running the ProducerConsumerRssFeeds WPF application for the first
    time
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the list displays 10 blog post summaries from each of the Microsoft
    blogs. This is the default maximum number of items that can be returned by Microsoft’s
    blogs.
  prefs: []
  type: TYPE_NORMAL
- en: You can try experimenting by increasing or decreasing the number of producers
    and consumers in the project. Does adding more consumers speed up the process?
    Try adding some of your favorite blogs’ feeds to the list of producers and see
    what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the content summary that’s returned by the RSS feeds
    contains HTML, and we are just rendering it as plain text in a `TextBox` control.
    If you would like to use a `RichTextBox` that renders the HTML properly, take
    a look at this sample project on CodeProject that uses a WPF `RichTextBox`: [https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox](https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create another example that uses different types
    of dataflow blocks to create a data pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data pipeline with multiple blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the biggest advantages of using dataflow blocks is the ability to link
    them and create a complete workflow or data pipeline. In the previous section,
    we saw how this linking worked between producer and consumer blocks. In this section,
    we will create a console application with a pipeline of five dataflow blocks all
    linked together to complete a series of tasks. We will leverage `TransformBlock`,
    `TransformManyBlock`, and `ActionBlock` to take an RSS feed and output a list
    of categories that are unique across all blog posts in the feed. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new .NET 6 console application in Visual Studio named `OutputBlogCategories`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **System.ComponentModel.Syndication** NuGet package that we used in
    the previous example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the same `RssFeedService` class from the previous example. You can right-click
    on the project in `RssFeedService` and copy/paste the same code we used in the
    previous example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class named `FeedCategoryTransformer` to the project and create a
    method named `GetCategoriesForFeed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Over the next few steps, we will create the implementation for the `GetCategoriesForFeed`
    method. First, create a `TransformBlock` named `downloadFeed` that accepts `url`
    as a string and returns `IEnumerable<SyndicationItem>` from the `GetFeedItems`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a `TransformBlock` that accepts `IEnumerable<SyndicationItem>`
    and returns `List<SyndicationCategory>`. This block will fetch the complete list
    of categories from every blog post and return them as a single list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create another `TransformBlock`. This block will accept `List<SyndicationCategory>`
    from the previous block, remove all duplicates, and return the filtered `List<SyndicationCategory>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the LINQ Distinct extension method on a complex object such as `SyndicationCategory`,
    a custom comparer that implements `IEqualityComparer<T>` is required. You can
    get the complete source for `CategoryComparer` from this chapter’s GitHub repository:
    [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `TransformManyBlock` named `createCategoryString`. This block
    will accept the de-duplicated `List<SyndicationCategory>` and return a string
    for each `Name` property of the categories. So, the block is invoked once for
    the entire list, but it will, in turn, invoke the next block in the flow once
    for every item in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final block is an `ActionBlock` named `printCategoryInCaps`. This block
    will output each category name to the console in all caps using `ToUpper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the dataflow blocks have been configured, it’s time to link them.
    Create a `DataflowLinkOptions` that will propagate the completion of each block.
    Then, use the `LinkTo` method to link each block in the chain to the next one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last few steps of creating the `GetCategoriesForFeed` method involve sending
    `url` to the first block, marking it as `Complete`, and waiting for the last block
    in the chain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open `Program.cs` and update the code so that it calls `GetCategoriesForFeed`,
    providing the URL for the Windows blog RSS feed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program and examine the list of categories in the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Displaying a deduplicated list of categories from the Windows
    blog feed ](img/Figure_7.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Displaying a deduplicated list of categories from the Windows blog
    feed
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to create a data pipeline with a series of dataflow
    blocks, we will look at an example of combining data from multiple sources with
    a `JoinBlock`.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating data from multiple data sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `JoinBlock` can be configured to receive different data types from two or
    three data sources. As each set of data types is completed, the block is completed
    with a `Tuple` containing all three object types to be acted upon. In this example,
    we will create a `JoinBlock` that accepts a `string` and `int` pair and passes
    `Tuple(string, int)` along to an `ActionBlock`, which outputs their values to
    the console. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new console application in Visual Studio
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class named `DataJoiner` to the project and add a static method to
    the class named `JoinData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to create two `BufferBlock` objects, a `JoinBlock<string,
    int>`, and an `ActionBlock<Tuple<string, int>>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting the block to non-greedy mode means it will wait for an item of each
    type before executing the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the links between the blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, push some data to the two `BufferBlock` objects, wait for a second, and
    then mark them both as complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to `Program.cs` to run the example code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run the application and examine the output. You will see that `ActionBlock`
    outputs a `string` and `integer` pair for each set of values provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Running the JoinBlockExample console application ](img/Figure_7.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Running the JoinBlockExample console application
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to using the `JoinBlock` dataflow block. Try making some
    changes on your own, such as changing the `Greedy` option or the order in which
    data is added to each `BufferBlock`. How does that impact the output?
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish up this chapter, let’s review everything we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned all about the various blocks in the TPL Dataflow
    library. We started by learning a little about each block type and providing a
    brief code snippet for each. Next, we created a practical example that implemented
    the producer/consumer pattern to fetch blog data from three different Microsoft
    blogs. We also examined `TransformBlock`, `TransformManyBlock`, and `JoinBlock`
    more closely in .NET console applications. You should now feel confident in your
    ability to use some of the dataflow blocks in your applications to automate some
    complex data workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like some additional reading about the TPL Dataflow library, you
    can download *Introduction to TPL Dataflow* from the Microsoft Download Center:
    [https://www.microsoft.com/en-us/download/details.aspx?id=14782](https://www.microsoft.com/en-us/download/details.aspx?id=14782).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 8*](B18552_08_ePub.xhtml#_idTextAnchor130), we
    will take a closer look at the collections in the `System.Collections.Concurrent`
    namespace. We will also discover some practical uses of PLINQ in modern .NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What type of data flow block aggregates data from two or three data sources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of block is a `BufferBlock`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of block is populated by a producer in the producer/consumer pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method links the completion of two blocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method is called to signal that our code is done adding data to a source
    block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the async equivalent of calling `Post()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the async equivalent of calling `Receive()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
