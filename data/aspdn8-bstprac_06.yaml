- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Best Practices with Web User Interfaces
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 用户界面的最佳实践
- en: When creating a **user interface** (**UI**) with ASP.NET 8, it can be intimidating
    since most developers are so used to working with C#. There are a lot of factors
    to consider when creating a web application, such as avoiding duplication, recognizing
    similar interfaces for reusable components, creating a structured website, and
    making it easier for search engines to index the site—a process known as **search
    engine** **optimization** (**SEO**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ASP.NET 8 创建 **用户界面**（**UI**）时，可能会让人感到害怕，因为大多数开发者都习惯了使用 C#。在创建 Web 应用程序时需要考虑许多因素，例如避免重复、识别可重用组件的类似界面、创建结构化的网站，以及使搜索引擎更容易索引网站——这个过程称为
    **搜索引擎优化**（**SEO**）。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using a task runner
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务运行器
- en: Applying standards to UIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标准应用于 UI
- en: Introducing Buck’s coffee shop project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Buck’s 咖啡店项目
- en: In the first section, we’ll examine why a task runner is so important to developers,
    how to set it up and run it automatically, and how to bundle and minify scripts.
    Then, in the next section, we’ll review a number of common standards with ASP.NET
    8 sites, including centralizing links, keeping controllers and Razor Pages small,
    why `ViewComponent` classes are better than the `HTMLHelper` class or partials,
    replacing HTML helpers with tag helpers, and why creating SEO-friendly URLs are
    important.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将探讨为什么任务运行器对开发者来说如此重要，如何设置和自动运行它，以及如何打包和压缩脚本。然后，在下一部分，我们将回顾与 ASP.NET
    8 网站相关的许多常见标准，包括集中链接、保持控制器和 Razor 页面小巧、为什么 `ViewComponent` 类比 `HTMLHelper` 类或部分更好，用标签助手替换
    HTML 助手，以及为什么创建对搜索引擎友好的 URL 很重要。
- en: Finally, we’ll create a new project called *Buck’s Coffee Shop*, applying everything
    we’ve covered.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个名为 *Buck’s Coffee Shop* 的新项目，应用我们所学的一切。
- en: By the end of this chapter, we’ll know how to include client-side resources
    into a task runner, implement common practices for UIs, understand how to build
    additional functionality into an existing web application using the Task Runner
    tool, consolidate links using extension methods, and extend HTML by creating our
    own HTML Tags.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解如何将客户端资源包含到任务运行器中，实施 UI 的常见实践，理解如何使用任务运行器工具将附加功能构建到现有的 Web 应用程序中，使用扩展方法合并链接，并通过创建我们自己的
    HTML 标签来扩展 HTML。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Even with a simple web UI, the Visual Studio family of products creates an
    easy way to build web applications using IntelliSense. We recommend using your
    favorite editor to view the GitHub repository. We recommend the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一个简单的 Web UI，Visual Studio 家族的产品也提供了一个使用 IntelliSense 轻松构建 Web 应用程序的方法。我们建议使用您最喜欢的编辑器查看
    GitHub 仓库。我们推荐以下选项：
- en: Visual Studio (latest version)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio（最新版本）
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: JetBrains Rider
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains Rider
- en: The editor we’ll be using is Visual Studio 2022 Enterprise, but any version
    (Community or Professional) will work with the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的编辑器是 Visual Studio 2022 Enterprise，但任何版本（社区版或专业版）都可以与代码一起使用。
- en: The code for [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137) is located in Packt
    Publishing’s GitHub repository, found at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B19493_06.xhtml#_idTextAnchor137) 的代码位于 Packt Publishing 的 GitHub
    仓库中，可在 [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices)
    找到。'
- en: Using a task runner
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务运行器
- en: In this section, we’ll explain what a task runner is, what its responsibilities
    are, how to automatically execute it when building the solution, and provide some
    examples of how to use it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释什么是任务运行器，它的职责是什么，如何在构建解决方案时自动执行它，并提供一些使用示例。
- en: As developers, we are always looking for better ways to quickly automate tasks.
    With JavaScript frameworks, this task is essential, especially when building the
    solution in a **Continuous Integration/Continuous Delivery** (**CI/CD**) pipeline.
    The consistent repetition of certain tasks becomes monotonous and takes away from
    development time. Why not have a computer process the work?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们总是在寻找更快地自动化任务的方法。在使用 JavaScript 框架时，这项任务至关重要，尤其是在构建 **持续集成/持续交付**（**CI/CD**）管道中的解决方案时。某些任务的持续重复变得单调乏味，并占用了开发时间。为什么不让计算机处理这项工作呢？
- en: As developers, the need to include a task runner section in this chapter is
    meant to show developers how to automate tasks to make client-side endeavors more
    efficient. In recent years, I’ve experienced developers who’ve never used a task
    runner for client-side tasks or even know what it is. A task runner is a tremendous
    benefit to all developers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，在这一章中包含任务运行器部分的目的在于向开发者展示如何自动化任务，以使客户端工作更加高效。近年来，我遇到了一些从未使用过任务运行器进行客户端任务甚至不知道它是什么的开发者。任务运行器对所有开发者来说都是一个巨大的好处。
- en: What is a task runner?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是任务运行器？
- en: As JavaScript became popular, developers wanted a way to build their JavaScript
    as well as build their solutions. In addition to using JavaScript, TypeScript
    was created to give JavaScript more of a strong-typed feel and required a compilation
    step as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript的流行，开发者想要一种方法来构建他们的JavaScript以及构建他们的解决方案。除了使用JavaScript之外，TypeScript被创建出来，以给JavaScript带来更强的类型感，并且也需要一个编译步骤。
- en: Along with “compiling” TypeScript, most websites require additional tasks such
    as minifying and bundling JavaScript and optimizing. There was a need for a tool
    to make the developer’s experience seamless when working with C# and JavaScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“编译”TypeScript 之外，大多数网站还需要额外的任务，如压缩和打包 JavaScript 以及优化。当与 C# 和 JavaScript
    一起工作时，需要一个工具来使开发者的体验无缝。
- en: This is why the Task Runner tool was created and integrated into Visual Studio.
    Its primary responsibility is to automate tasks using either Grunt or Gulp with
    build scripts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么创建并集成到 Visual Studio 中的 Task Runner 工具的原因。其主要责任是使用 Grunt 或 Gulp 以及构建脚本来自动化任务。
- en: Gulp and Grunt are also task runners, but each one has a different file format
    in JavaScript when defining tasks. While we can use either Grunt or Gulp scripts
    in the Visual Studio Task Runner, we’ll be using the Gulp format.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 和 Grunt 也是任务运行器，但在定义任务时，每个都有不同的 JavaScript 文件格式。虽然我们可以在 Visual Studio 任务运行器中使用
    Grunt 或 Gulp 脚本，但我们将使用 Gulp 格式。
- en: The Task Runner in Visual Studio is what I would consider a “mini-pipeline for
    the client side.” A task runner is a great introduction for developers learning
    to create a CI/CD pipeline for an application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 中的任务运行器是我认为的“客户端的迷你管道”。任务运行器是开发者学习为应用程序创建 CI/CD 管道的一个很好的入门。
- en: Setting up the Task Runner
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置任务运行器
- en: The Task Runner relies heavily on Node.js for running scripts. By default, Node.js
    should already be installed through Visual Studio.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 任务运行器在运行脚本时严重依赖于 Node.js。默认情况下，Node.js 应该已经通过 Visual Studio 安装。
- en: 'To find out whether Node.js is installed on your machine, do the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的机器上是否已安装 Node.js，请执行以下操作：
- en: Select **Package Manager Console** from **View |** **Other Windows**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **视图** | **其他窗口** 中选择 **包管理器控制台**。
- en: When a prompt appears, type `npm --version`. If it displays a version number,
    we can proceed with the next step. If not, a repair of Visual Studio through the
    Visual Studio Installer may be required.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现提示时，输入 `npm --version`。如果显示版本号，我们可以进行下一步。如果没有显示，可能需要通过 Visual Studio 安装程序修复
    Visual Studio。
- en: Type `npm install -g gulp --save-dev`. The `-g` option is to install Gulp globally,
    and `--save-dev` is there to save the dependency in the `package.json` file. With
    that said, there should be a `package.json` file added to the solution.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `npm install -g gulp --save-dev`。`-g` 选项是为了全局安装 Gulp，而 `--save-dev` 是为了将依赖项保存到
    `package.json` 文件中。因此，解决方案中应该添加一个 `package.json` 文件。
- en: Add a new JavaScript file to the root of the project, called `gulpfile.js`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中添加一个新的 JavaScript 文件，命名为 `gulpfile.js`。
- en: Depending on whether we’re using Grunt or Gulp, the Task Runner requires a specific
    file. In the examples (as I mentioned before), we’ll be using the Gulp format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们是否使用 Grunt 或 Gulp，任务运行器需要特定的文件。在示例（如我之前提到的）中，我们将使用 Gulp 格式。
- en: Structure of a gulpfile
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gulpfile 的结构
- en: When creating a gulpfile, it should be named `gulpfile.js`. The file should
    be placed into the root of the solution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 gulpfile 时，应命名为 `gulpfile.js`。文件应放置在解决方案的根目录中。
- en: 'The structure of a gulpfile contains the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: gulpfile 的结构包括以下内容：
- en: '**Defined packages**—These are the modules used throughout the gulpfile.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义的包**—这些是在 gulpfile 中使用的模块。'
- en: '**Processing and cleanup tasks**—Each task will contain a process task along
    with a cleanup task.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理和清理任务**—每个任务将包含一个处理任务和一个清理任务。'
- en: '**Export groupings**—This provides a list of tasks to execute in a specific
    order. Usually, cleanup procedures are used first, followed by regular processing
    tasks.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出分组**—这提供了一个特定顺序中要执行的任务的列表。通常，首先使用清理程序，然后是常规处理任务。'
- en: 'Gulp requires a `gulpfile.js` file to be located in the root of the solution.
    The standard layout of a gulpfile is usually segmented using the following structure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 需要一个 `gulpfile.js` 文件位于解决方案的根目录。`gulpfile` 的标准布局通常使用以下结构进行分段：
- en: '`npm` installs.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` 安装。'
- en: '`gulpfile.js` file, there should be two tasks: a processing task and a cleanup
    task. The processing task is meant to achieve what we want to automate, whereas
    the cleanup task is meant to delete created or processed files.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `gulpfile.js` 文件中，应该有两个任务：一个处理任务和一个清理任务。处理任务旨在实现我们想要自动化的内容，而清理任务旨在删除创建或处理过的文件。
- en: '**Global default and cleanup tasks**—Segment the processing and cleanup tasks
    into logical groupings when building the scripts.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局默认和清理任务**—在构建脚本时将处理和清理任务分段到逻辑分组中。'
- en: 'Since we already have our file, we’ll create a simple task for our solution.
    Copy the following JavaScript code into the new `gulpfile.js` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有我们的文件，我们将为我们的解决方案创建一个简单的任务。将以下 JavaScript 代码复制到新的 `gulpfile.js` 文件中：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since this is a build script, we’ll be using the `series()` function from the
    Gulp package, which defines sequential processes. This is represented through
    the first line. The second line creates a `const` instance representing the Gulp
    package, making the Gulp functions available to us.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个构建脚本，我们将使用 Gulp 包中的 `series()` 函数，它定义了顺序过程。这通过第一行表示。第二行创建了一个代表 Gulp 包的
    `const` 实例，使我们能够使用 Gulp 函数。
- en: Our simple task for the Task Runner is the world-famous “Hello World!” task
    defined through the `testTask` function while passing in the `done` function,
    which Gulp handles for us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 Task Runner 定义的简单任务是全世界闻名的“Hello World！”任务，通过 `testTask` 函数定义，并传递 `done`
    函数，Gulp 为我们处理。
- en: Finally, we attach a `build` property to our exports that defines a series of
    tasks from the preceding code. The `series` function is defined in the Gulp package.
    The name following the `exports` namespace can be named anything which appears
    in the Task Runner. If the build task isn’t displaying in the Task Runner, click
    the `gulpfile.js` file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将一个 `build` 属性附加到我们的导出中，它定义了一系列来自前面代码的任务。`series` 函数定义在 Gulp 包中。`exports`
    命名空间之后的名称可以是 Task Runner 中出现的任何名称。如果构建任务在 Task Runner 中没有显示，请点击 `gulpfile.js`
    文件。
- en: 'When right-clicking on the **build** option (or double-click), the build will
    execute showing the results, as displayed in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 **build** 选项上右键单击（或双击），构建将执行并显示结果，如下面的截图所示：
- en: '![Figure 6.1 – Results from our first Task Runner process](img/Figure_6.01_B19493.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 我们第一次 Task Runner 流程的结果](img/Figure_6.01_B19493.jpg)'
- en: Figure 6.1 – Results from our first Task Runner process
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 我们第一次 Task Runner 流程的结果
- en: In the next section, we’ll learn how to run our gulpfile automatically when
    we build our solution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在构建我们的解决方案时自动运行我们的 gulpfile。
- en: Running automatically
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动运行
- en: 'To assist in automatically running our `gulpfile.js` file, we have the ability
    to bind certain tasks to events when building the solution. Right-click on the
    task in the Task Runner to select the appropriate action for the builds, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助自动运行我们的 `gulpfile.js` 文件，我们可以在构建解决方案时将某些任务绑定到事件。在 Task Runner 中右键单击任务以选择构建的适当操作，如下所示：
- en: '**Before Build**—Execute a task before compiling the solution'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Before Build**—在编译解决方案之前执行任务'
- en: '**After Build**—Execute a task after the solution compiled'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**After Build**—在解决方案编译后执行任务'
- en: '**Clean Build**—Execute a task on a “Clean Solution” or “Clean <Project>” action'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clean Build**—在执行“Clean Solution”或“Clean <Project>”操作时执行任务'
- en: '**Project Open**—Execute a task after the project opens'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Project Open**—在项目开启后执行任务'
- en: 'When we select `gulpfile.js` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择 `gulpfile.js` 文件时：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we build the application, the Task Runner executes the build task and,
    if successful, it proceeds to compile the application, as shown in the following
    screenshot. If not, the Task Runner will display an error message in the results
    pane:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建应用程序时，Task Runner 将执行构建任务，如果成功，它将继续编译应用程序，如下面的截图所示。如果不成功，Task Runner 将在结果窗格中显示错误消息：
- en: '![Figure 6.2 – A successful build of client-side tasks and solution](img/Figure_6.02_B19493.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 客户端任务和解决方案的成功构建](img/Figure_6.02_B19493.jpg)'
- en: Figure 6.2 – A successful build of client-side tasks and solution
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 客户端任务和解决方案的成功构建
- en: While this provides a basic foundation for our application, we need to define
    our client-side directory structure so that when adding resources such as images,
    scripts, and styles, our tasks know where to find the resources.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这为我们应用程序提供了一个基本的基础，但我们需要定义我们的客户端目录结构，以便在添加资源（如图片、脚本和样式）时，我们的任务知道在哪里找到这些资源。
- en: In the next section, we’ll look at how to set up the structure for our client-side
    workflow.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何设置客户端工作流程的结构。
- en: Creating a workflow structure
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工作流程结构
- en: Before we write scripts for our `gulpfile.js` file, we need to define a simple
    workflow for our Task Runner. Generally, our gulpfile contains, at the very least,
    a JavaScript and CSS bundler and minifier. It doesn’t matter which one is executed
    first, but they could even be candidates for a collection of parallel tasks. While
    Visual Studio created our server-side application, the client-side structure requires
    a little more attention in regard to where to place files throughout our application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为`gulpfile.js`文件编写脚本之前，我们需要为我们的任务运行器定义一个简单的工作流程。通常，我们的gulpfile至少包含一个JavaScript和CSS打包器和压缩器。哪个先执行并不重要，但它们甚至可以是并行任务集合的候选者。虽然Visual
    Studio为我们创建了服务器端应用程序，但客户端结构需要更多的关注，以确定在整个应用程序中放置文件的位置。
- en: In every ASP.NET 8 application, we have a `wwwroot` folder that contains our
    client-side scripts, styles, and static content (such as images). This is considered
    the root path to our application for our static content, so if we have a website
    called [https://www.mywebsite.com/](https://www.mywebsite.com/), the wwwroot folder
    will be our root. For example, if we want to access our CSS folder, we’d access
    it via `https://www.mywebsite.com/css/`. While every resource (such as scripts
    and styles) has its own way of processing and creating production-ready output
    files, there needs to be a workflow on how each task in our Task Runner will perform.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个ASP.NET 8应用程序中，我们都有一个包含客户端脚本、样式和静态内容（如图片）的`wwwroot`文件夹。这被认为是我们的静态内容根路径，因此如果我们有一个名为[https://www.mywebsite.com/](https://www.mywebsite.com/)的网站，wwwroot文件夹将是我们的根。例如，如果我们想访问我们的CSS文件夹，我们将通过`https://www.mywebsite.com/css/`来访问它。虽然每个资源（如脚本和样式）都有其自己的处理方式和创建生产级输出文件的方式，但需要在我们的任务运行器中有一个工作流程来指导每个任务如何执行。
- en: 'The current directory structure looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当前目录结构如下：
- en: '![Figure 6.3 – A common ASP.NET 8 structure](img/Figure_6.03_B19493.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 常见的ASP.NET 8结构](img/Figure_6.03_B19493.jpg)'
- en: Figure 6.3 – A common ASP.NET 8 structure
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 常见的ASP.NET 8结构
- en: The preceding structure is meant for a production-level application. The `css`
    directory doesn’t contain any SASS or LESS files for processing, and the `js`
    directory has only simple JavaScript files. We need additional directories for
    our workflow to function properly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构是为生产级应用程序设计的。`css`目录不包含任何用于处理的SASS或LESS文件，`js`目录只包含简单的JavaScript文件。我们需要额外的目录来确保我们的工作流程正常工作。
- en: For our application, we’ll be using TypeScript and SASS. SASS is a preprocessor
    for CSS files and requires a directory for our source files (with an extension
    of `.scss`). TypeScript also requires transpilation into JavaScript files, so
    we’ll create a `scss` directory for our SASS files and a `src` directory for our
    TypeScript files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用TypeScript和SASS。SASS是CSS文件的预处理器，需要一个用于源文件的目录（扩展名为`.scss`）。TypeScript还需要转换为JavaScript文件，因此我们将为SASS文件创建一个`scss`目录，为TypeScript文件创建一个`src`目录。
- en: Create a `src` folder and a `scss` folder under the `wwwroot` folder. These
    folders will contain the source code for our application. The `src` folder will
    contain all TypeScript files for the application, whereas the `scss` folder will
    contain all of the styles ready for compilation into production-ready CSS files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wwwroot`文件夹下创建一个`src`文件夹和一个`scss`文件夹。这些文件夹将包含我们应用程序的源代码。`src`文件夹将包含应用程序的所有TypeScript文件，而`scss`文件夹将包含所有准备编译成生产级CSS文件的样式。
- en: 'The following steps show a common workflow for a task runner:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了任务运行器的一个常见工作流程：
- en: 'TypeScript files:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeScript文件：
- en: Transpile the TypeScript files in the `src` folder into JavaScript files. The
    output files will reside in the `src` folder. The output files are JavaScript
    files.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`src`文件夹中的TypeScript文件转换为JavaScript文件。输出文件将位于`src`文件夹中。输出文件是JavaScript文件。
- en: 'JavaScript files:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript文件：
- en: Use a bundler to process the `.js` files. The bundler should automatically know
    how to include all files based on the JavaScript module pattern.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用打包器处理`.js`文件。打包器应该自动知道如何根据JavaScript模块模式包含所有文件。
- en: Use a minifier to process the bundled JavaScript files. The output files are
    copied from the `src` folder over to the `js` folders. These files are also renamed
    to have a `.min.js` suffix added to them to identify them as minified files.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用压缩器处理捆绑的 JavaScript 文件。输出文件从 `src` 文件夹复制到 `js` 文件夹。这些文件也被重命名，以添加 `.min.js`
    后缀来标识它们为压缩文件。
- en: 'Styles:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式：
- en: Use a “styler compiler” such as LESS or SASS. We’ll be using SASS to precompile
    our styles. These files will reside in the `scss` folder. Once compiled, the folder
    will contain `.css` files and be inevitably moved to the `css` folder.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“样式编译器”例如 LESS 或 SASS。我们将使用 SASS 来预编译我们的样式。这些文件将位于 `scss` 文件夹中。一旦编译完成，文件夹将包含
    `.css` 文件，并不可避免地移动到 `css` 文件夹。
- en: The workflow structure of our application implies the `js` and `css` folders
    are production-level folders while making our `src` and `scss` folders specific
    to developer modifications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的工作流程结构意味着 `js` 和 `css` 文件夹是生产级别的文件夹，而我们的 `src` 和 `scss` 文件夹是针对开发者修改的特定文件夹。
- en: Defining our workflow paths
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们的工作流程路径
- en: 'Since we created our workflow structure, we need to tell Gulp where our source
    and destination folders reside in our application. The `path` module contains
    a `resolve` function to concatenate folder names as we go, as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了工作流程结构，我们需要告诉 Gulp 在我们的应用程序中源文件夹和目标文件夹的位置。`path` 模块包含一个 `resolve` 函数，用于在执行过程中连接文件夹名称，如下所示：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`__dirname` is a reserved word and is based on the current directory (in our
    case, this is the root of our application). `basePath` is used to operate solely
    in the `wwwroot` folder and below and won’t interfere with our ASP.NET 8 application.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dirname` 是一个保留字，基于当前目录（在我们的情况下，这是应用程序的根目录）。`basePath` 用于仅在 `wwwroot` 文件夹及其以下操作，并且不会干扰我们的
    ASP.NET 8 应用程序。'
- en: Transpiling TypeScript
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转译 TypeScript
- en: Our first order of business is to transpile our TypeScript files into JavaScript
    files. Transpiling is the process of converting TypeScript into JavaScript. With
    most of our TypeScript projects, we almost always have a `tsconfig.json` configuration
    file, and this will reside in the root of the `wwwroot` folder. However, we need
    a special package for reading the configuration file specifically for Gulp.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是转译我们的 TypeScript 文件为 JavaScript 文件。转译是将 TypeScript 转换为 JavaScript 的过程。对于我们的大多数
    TypeScript 项目，我们几乎总是有一个 `tsconfig.json` 配置文件，它将位于 `wwwroot` 文件夹的根目录。然而，我们需要一个特殊的包来专门读取
    Gulp 的配置文件。
- en: 'To include the package, proceed as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含该包，请按以下步骤操作：
- en: In the `npm install -g gulp-cli`. It should then be added to your `package.json`
    file.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `npm install -g gulp-cli`。然后应将其添加到您的 `package.json` 文件中。
- en: In the `npm install gulp@4` to install Gulp as a project dependency.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `npm install gulp@4` 中安装 Gulp 作为项目依赖项。
- en: One last time in the `npm install gulp-typescript typescript gulp-clean --save-dev`
    to install TypeScript, the `gulp-typescript`, and the ability to remove files
    (`gulp-clean`).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一次在 `npm install gulp-typescript typescript gulp-clean --save-dev` 中安装 TypeScript、`gulp-typescript`
    以及删除文件的能力 (`gulp-clean`)。
- en: 'Define the module at the top of the `gulpfile.js` file, like so:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `gulpfile.js` 文件顶部定义模块，如下所示：
- en: '[PRE3]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Load the configuration using the `createProject` function referencing the path
    to the `tsconfig.json` file, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `createProject` 函数通过引用 `tsconfig.json` 文件的路由来加载配置，如下所示：
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the TypeScript source folder, like so:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 TypeScript 源文件夹，如下所示：
- en: '[PRE5]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll keep track of paths through a source object. Our `srcPaths` object will
    contain a `js` path pointing to our source code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过一个源对象来跟踪路径。我们的 `srcPaths` 对象将包含一个指向源代码的 `js` 路径：
- en: '[PRE6]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We need to create process (`ts_transpile`) and cleanup (`ts_cleanup`) functions
    for our TypeScript. Here’s the code to achieve that:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为 TypeScript 创建处理 (`ts_transpile`) 和清理 (`ts_cleanup`) 函数。以下代码实现了这一点：
- en: '[PRE7]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ts_transpile` function uses the `tsProject` configuration to locate the
    source files (through the `include` property near the end of the `tsconfig.json`
    file) and convert all of the TypeScript files into JavaScript files in the same
    directory.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ts_transpile` 函数使用 `tsProject` 配置来定位源文件（通过 `tsconfig.json` 文件末尾附近的 `include`
    属性）并将所有 TypeScript 文件转换为同一目录中的 JavaScript 文件。'
- en: Our `ts_clean` function will simply remove all JavaScript (*NOT* TypeScript)
    files from every directory.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `ts_clean` 函数将简单地从每个目录中删除所有 JavaScript (*不是 TypeScript*) 文件。
- en: 'Once we have our TypeScript tasks defined, we simply add them to our build
    process at the bottom of our `gulpfile.js` file, like so:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们定义了 TypeScript 任务，我们只需将它们添加到我们的 `gulpfile.js` 文件底部的构建过程中，如下所示：
- en: '[PRE8]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we delete all of the JavaScript files with `ts_clean`, then perform the
    transpiling with `ts_transpile`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `ts_clean` 删除所有 JavaScript 文件，然后执行 `ts_transpile` 进行转换。
- en: 'As shown in the example, our workflow structure locates all of the TypeScript
    files and transpiles them into JavaScript files:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如示例所示，我们的工作流程结构定位所有 TypeScript 文件并将它们转换为 JavaScript 文件：
- en: '![Figure 6.4 – TypeScript files in src folders converted to JavaScript](img/Figure_6.04_B19493.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – src 文件夹中的 TypeScript 文件转换为 JavaScript](img/Figure_6.04_B19493.jpg)'
- en: Figure 6.4 – TypeScript files in src folders converted to JavaScript
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – src 文件夹中的 TypeScript 文件转换为 JavaScript
- en: Since our TypeScript is now transpiled down to JavaScript, we can focus on bundling
    and minifying the files.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 TypeScript 现在已转换为 JavaScript，我们可以专注于打包和压缩文件。
- en: Bundling and minifying
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包和压缩
- en: By nature, JavaScript takes a while to load in the browser. To make matters
    worse, if a JavaScript file is formatted for readability, the file takes even
    longer to load, therefore making it slower to download. A minification process
    is necessary to shorten the loading process as much as possible to give the user
    a better experience.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，JavaScript 在浏览器中加载需要一段时间。更糟糕的是，如果 JavaScript 文件格式化为可读性，文件加载时间会更长，因此下载速度会变慢。需要一个压缩过程尽可能缩短加载过程，以给用户更好的体验。
- en: Bundling is the concept of taking an application’s scripts and styles and combining
    them into one script or style instead of loading multiple files.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打包是将应用程序的脚本和样式合并为一个脚本或样式的过程，而不是加载多个文件。
- en: Since spaces and tabs take up…well, space, minifying the scripts and styles
    is the process of shrinking client-side files down to a smaller size for faster
    delivery to the browser.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空格和制表符占用空间，压缩脚本和样式是将客户端文件缩小到更小尺寸的过程，以便更快地发送到浏览器。
- en: 'To bundle our scripts, we need a module called Browserify for our Gulp script.
    Let’s start adding the bundling functionality to the `gulpfile.js` file. Here
    are the steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要打包我们的脚本，我们需要一个名为 Browserify 的模块来处理我们的 Gulp 脚本。让我们开始向 `gulpfile.js` 文件添加打包功能。以下是步骤：
- en: In the `npm install -g browserify gulp-rename vinyl-source-stream vinyl-buffer
    vinyl-transform gulp-uglify-es`. We should see these modules added to the `package.json`
    file.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `npm install -g browserify gulp-rename vinyl-source-stream vinyl-buffer vinyl-transform
    gulp-uglify-es` 中。我们应该看到这些模块被添加到 `package.json` 文件中。
- en: 'Once these are installed in the `package.json` file, we need to include another
    `srcPath` object containing all of the files we want bundled/minified:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这些安装到 `package.json` 文件中，我们需要包含另一个 `srcPath` 对象，其中包含我们想要打包/压缩的所有文件：
- en: '[PRE9]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll call the property `jsBundles`. Since every TypeScript file was transpiled
    into a JavaScript file, we have to identify which files to load. A good practice
    to follow is to name the file the same as the actual page. The good news is the
    Browserify module will follow the imports in each file and include it in the bundling.
    As we add more TypeScript to the project, add the primary script to the list for
    automatic compilation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性命名为 `jsBundles`。由于每个 TypeScript 文件都已转换为 JavaScript 文件，我们必须确定要加载哪些文件。一个良好的做法是将文件名与实际页面名称相同。好消息是
    Browserify 模块将遵循每个文件的导入并将它们包含在打包中。随着我们向项目中添加更多的 TypeScript，将主要脚本添加到列表中以便自动编译。
- en: 'Create a new variable where the scripts will reside for the web application:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为网络应用程序中的脚本创建一个新的变量：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll call the variable `destPaths`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量命名为 `destPaths`。
- en: 'Next, we create our processing and cleanup for bundling and minifying the scripts:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建打包和压缩脚本的预处理和清理：
- en: '[PRE11]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `js_bundle_min` function shown in the preceding snippet, we loop through
    all of the files we want bundled. We create a `browserify` object with options
    set and start the bundling process per file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码片段中显示的 `js_bundle_min` 函数中，我们遍历所有要打包的文件。我们创建一个带有设置选项的 `browserify` 对象并按文件启动打包过程。
- en: The first process is getting the base name of the file we’re currently processing.
    Once we have the filename, we can rename the base from `site` to `site.min` and
    then add a `.js` extension to the end of the file. We then buffer the file and
    perform an `uglify` operation on it, meaning we minify it. After it’s bundled
    and minified, we write the file out to the destination folder, which is `wwwroot/js`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个过程是获取当前处理文件的基准名称。一旦我们有了文件名，我们可以将基准名称从 `site` 改为 `site.min`，然后在文件末尾添加 `.js`
    扩展名。然后我们缓冲文件并对它执行 `uglify` 操作，这意味着我们压缩它。在打包和压缩完成后，我们将文件写入目标文件夹，即 `wwwroot/js`。
- en: The `js_clean` function removes all of the `.js` files from the `wwwroot/js`
    folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`js_clean` 函数会从 `wwwroot/js` 文件夹中删除所有的 `.js` 文件。'
- en: 'Finally, we can add the `js_bundle_min` and `js_clean` functions to our build
    exports at the bottom of the file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在文件的底部将 `js_bundle_min` 和 `js_clean` 函数添加到我们的构建导出中：
- en: '[PRE12]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once the gulpfile is saved, double-click on the build, and the files should
    appear in the `wwwroot/js` folder. If we double-click the JavaScript file, we’ll
    see it’s been bundled and minified.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 gulpfile 后，双击构建，文件应该会出现在 `wwwroot/js` 文件夹中。如果我们双击 JavaScript 文件，我们会看到它已经被打包和压缩。
- en: Implementing additional tasks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现附加任务
- en: 'While bundling and minifying scripts is a big deal, there are other tasks we
    can add to a task runner. Such tasks can include the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然打包和压缩脚本是一个大问题，但我们还可以向任务运行器添加其他任务。这些任务可能包括以下内容：
- en: SCSS/LESS precompiling
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCSS/LESS 预编译
- en: Image optimization
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片优化
- en: Release notes
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布说明
- en: Copying `dist` folders from `node_modules` to a `lib` folder on build
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时从 `node_modules` 复制 `dist` 文件夹到 `lib` 文件夹
- en: These are just a few of the simple tasks available when preparing the web application.
    For additional tasks, refer to the source code for [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)
    on GitHub in the `TaskRunner` project at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是准备网络应用程序时可用的一些简单任务。对于更多任务，请参考 GitHub 上 `TaskRunner` 项目的源代码中的 [*第 6 章*](B19493_06.xhtml#_idTextAnchor137)，项目地址为
    [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices)。
- en: In this section, we reviewed what a task runner is and what it can do for developers
    and showed how to automatically execute it when building the solution. We also
    demonstrated the power of the Task Runner by creating a workflow structure and
    defining our workflow paths, how to transpile TypeScript, and how to minify and
    bundle scripts. As we can see, this simplifies the developer experience by automating
    client-side tasks and building the solution using one build.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了任务运行器的定义及其对开发者的帮助，并展示了如何在构建解决方案时自动执行它。我们还通过创建工作流程结构和定义我们的工作流程路径、如何转换
    TypeScript、如何压缩和打包脚本来展示了任务运行器的强大功能。正如我们所看到的，这通过自动化客户端任务和使用单一构建来简化了开发者的体验。
- en: In the next section, we’ll examine more UI standards and what is considered
    common knowledge when it comes to ASP.NET 8 web applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨更多的 UI 标准，以及当涉及到 ASP.NET 8 网络应用程序时，哪些被认为是常识。
- en: Applying standards to UIs
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将标准应用于 UI
- en: ASP.NET’s web page model has evolved over the years. With Web Forms, it was
    `ViewState` and components. With MVC, it had partials and HTML Helpers. Now, ASP.NET
    8 provides more advanced techniques using `ViewComponent` classes and `TagHelper`
    classes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 的网页模型在多年中不断发展。在 Web Forms 中，它是 `ViewState` 和组件。在 MVC 中，它有部分和 HTML 辅助器。现在，ASP.NET
    8 提供了使用 `ViewComponent` 类和 `TagHelper` 类的更高级技术。
- en: For this section, we’ll examine how ASP.NET 8 uses its language-specific features
    to build quicker and more flexible UIs. We’ll see how to consolidate links across
    a site, why it’s important to keep controllers/pages small, how `ViewComponent`
    classes are better than partials and `HTMLHelper` classes, and look at how to
    create SEO-friendly routes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将检查 ASP.NET 8 如何使用其特定于语言的特性来构建更快、更灵活的 UI。我们将看到如何在整个网站上合并链接，为什么保持控制器/页面小很重要，`ViewComponent`
    类比部分和 `HTMLHelper` 类更好，以及如何创建 SEO 友好的路由。
- en: Centralizing your site links
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中您的网站链接
- en: If we have a large site with hundreds of links, developers understand what it
    means when a page is renamed, moved, or (gasp) deleted. It’s definitely a time-consuming
    effort to change every link on a large site. While `TagHelper` classes are…well,
    helpful, one common practice is to use `UrlHelper` classes to consolidate the
    links.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个拥有数百个链接的大型网站，开发者会明白当一个页面被重命名、移动或（天哪）删除意味着什么。在大型网站上更改每个链接肯定是一个耗时的工作。虽然
    `TagHelper` 类是有帮助的，但一个常见的做法是使用 `UrlHelper` 类来合并链接。
- en: 'Let’s examine a website with the following ASP.NET 8 `TagHelper` class shown
    here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下 ASP.NET 8 `TagHelper` 类的网站：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Imagine all of these on secondary pages pointing to the main page, `Index.cshtml`,
    and we receive a request to change the name of the page to `Index2`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下所有这些在二级页面中指向主页面 `Index.cshtml`，并且我们收到一个请求要更改页面的名称为 `Index2`。
- en: 'With extension methods, we can create custom site-specific `UrlHelper` class
    URLs for each page, as shown in the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展方法，我们可以为每个页面创建自定义的特定站点的`UrlHelper`类URL，如下例所示：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Extension methods require three things: a static class, a static method, and
    the method’s first parameter in the signature must have `this` declared.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法需要三个东西：一个静态类、一个静态方法，并且方法签名中的第一个参数必须声明`this`。
- en: What is an extension method?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是扩展方法？
- en: For more details on using extension methods, navigate to [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用扩展方法的更多详细信息，请导航至[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)。
- en: 'We can apply this technique to Razor Pages as well using the `PageLink` method,
    as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`PageLink`方法将此技术应用于Razor页面，如下所示：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only difference between the two methods is the extension method attaches
    to an `IurlHelper` class instead of a `UrlHelper` class and, for Razor Pages,
    we use the `.PageLink` method instead.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法之间的唯一区别是扩展方法附加到`IurlHelper`类而不是`UrlHelper`类，对于Razor页面，我们使用`.PageLink`方法。
- en: 'If using the `TagHelper` anchor with the `asp-page` attribute, this approach
    limits our flexibility because we are defining a page in multiple places. By adding
    an extension method to the `UrlHelper` class, we can simplify it by using the
    HTML `href` attribute, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用带有`asp-page`属性的`TagHelper`锚点，这种方法限制了我们的灵活性，因为我们正在多个地方定义一个页面。通过向`UrlHelper`类添加扩展方法，我们可以通过使用HTML的`href`属性来简化它，如下所示：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With `UrlHelper` extension methods, all of the links across the site are easier
    to integrate and more efficient to update.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UrlHelper`扩展方法，整个网站的所有链接都更容易集成且更新效率更高。
- en: Keeping controllers/pages small
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持控制器/页面的小型化
- en: When ASP.NET MVC was introduced, controllers were often the dumping ground for
    most code, making calls to the database, creating models, and validating the model.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当ASP.NET MVC被引入时，控制器通常是大多数代码的垃圾场，包括对数据库的调用、创建模型和验证模型。
- en: MVC controllers (and now Razor Pages) should be “traffic cops,” directing the
    logic to certain parts of the application based on the page’s function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: MVC控制器（以及现在的Razor页面）应该是“交通警察”，根据页面的功能将逻辑引导到应用程序的特定部分。
- en: 'While the following list is far from complete, certain aspects can be offloaded
    to other parts of ASP.NET 8 to put controllers and pages on a diet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下列表远非完整，但某些方面可以卸载到ASP.NET 8的其他部分，以使控制器和页面更加精简：
- en: '`[Required]` and `[Email]`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Required]`和`[Email]`。'
- en: '`DbContext` instance and use Entity Framework. If Entity Framework isn’t a
    viable solution, offload the database processing to `Service` classes (see [*Chapter
    5*](B19493_05.xhtml#_idTextAnchor114) on Entity Framework Core).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DbContext`实例和使用Entity Framework。如果Entity Framework不是一个可行的解决方案，请将数据库处理卸载到`Service`类中（参见[*第5章*](B19493_05.xhtml#_idTextAnchor114)关于Entity
    Framework Core）。'
- en: '**Secondary processes**—If the application contains code to send emails, process
    records, or build an object, refactor the process out to its own class and inject
    it into the controller/Razor page, making it cleaner and easier to test.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要过程**——如果应用程序包含发送电子邮件、处理记录或构建对象的代码，请将其重构到自己的类中，并将其注入到控制器/Razor页面中，使其更加整洁且易于测试。'
- en: Large methods in controllers or Razor Pages can complicate matters further when
    trying to test or debug code. Smaller code, in this instance, is the better approach.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器或Razor页面中，大型方法在尝试测试或调试代码时可能会使问题更加复杂。在这种情况下，较小的代码是更好的方法。
- en: Using ViewComponents
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视图组件
- en: When HTML Helpers and Partial views were introduced with MVC, the ability to
    pass an object into a small section and have it create a snippet of HTML for the
    View was a great feature for developers. However, there were a few downsides to
    using these two features.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当MVC引入HTML辅助器和部分视图时，将对象传递到一个小部分并创建用于视图的HTML片段的能力对开发者来说是一个伟大的功能。然而，使用这两个功能有一些缺点。
- en: The downside of using HTML Helpers was the ability to create new HTML snippets
    through code and render that back to the View. If the HTML changed, it would require
    updating and recompiling of the code violating **separation of concerns** (**SoC**)
    (“You’ve got your C# in my HTML”). There wasn’t any HTML associated with the Helper;
    it had to be created using code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTML 助手的缺点是能够通过代码创建新的 HTML 片段并将其渲染回视图。如果 HTML 发生变化，则需要更新和重新编译代码，违反了**关注点分离**（**SoC**）（“你的
    C# 在我的 HTML 中”）。没有与助手关联的 HTML；它必须使用代码创建。
- en: Swinging the pendulum the other way, Partials introduced the ability to have
    HTML with no code with the ability to pass objects into the partial. The issue
    with this approach was the ability to place `if`…`then` statements inside the
    HTML. When an `if`…`then` statement was introduced in HTML, this was considered
    a code smell (which is code looking like it doesn’t belong or looks suspicious)
    and was meant to be a business rule. HTML should be declarative—almost template-like
    with no branching involved.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，部分组件引入了在部分中拥有无代码 HTML 的能力，并且可以将对象传递到部分中。这种方法的缺点是能够在 HTML 中放置 `if`…`then`
    语句。当在 HTML 中引入 `if`…`then` 语句时，这被视为代码异味（看起来不属于或看起来可疑的代码），并且意味着是业务规则。HTML 应该是声明性的——几乎像模板一样，不涉及分支。
- en: 'With ASP.NET Core, `ViewComponent` classes were introduced and, while not meant
    to replace `HTMLHelper` classes or Partials, fulfilled a larger need for building
    modular web applications. Considered to be “mini-controllers,” `ViewComponent`
    classes provide ASP.NET developers with a better approach for the following reasons:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，引入了 `ViewComponent` 类，虽然它们不是为了取代 `HTMLHelper` 类或部分组件，但满足了构建模块化
    Web 应用程序更大的需求。被视为“迷你控制器”的 `ViewComponent` 类为 ASP.NET 开发者提供了以下原因的更好方法：
- en: '**SoC**—With an HTML and C# combination, this allows a better way of writing
    modular components.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SoC**——通过 HTML 和 C# 的组合，这允许以更好的方式编写模块化组件。'
- en: '`ViewComponent` classes only render a chunk of the view instead of the entire
    response. This makes the component independently render faster.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewComponent` 类仅渲染视图的一部分而不是整个响应。这使得组件可以独立快速渲染。'
- en: '`ViewComponent` classes are isolated by nature, making them extremely easy
    to test. Create a new `ViewComponent` class, pass in arguments, and test to see
    if it returned what was expected.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewComponent` 类在本质上被隔离，这使得它们非常容易测试。创建一个新的 `ViewComponent` 类，传递参数，并测试它是否返回了预期的结果。'
- en: '`ViewComponent` classes give us the best of both worlds, rendering HTML while
    using C# for applying business rules in a single component.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewComponent` 类为我们提供了两全其美的解决方案，在单个组件中渲染 HTML 的同时使用 C# 应用业务规则。'
- en: Additional ViewComponent material
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的 `ViewComponent` 材料内容
- en: For more details on the `ViewComponent` class, navigate to [https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components](https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `ViewComponent` 类的更多详细信息，请访问 [https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components](https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components)。
- en: Using Tag Helpers instead of HTML Helpers
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标签助手而不是 HTML 助手
- en: While HTML Helpers provide the ability to create small snippets of HTML (just
    don’t go overboard), the `TagHelper` class take it a step further.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 HTML 助手提供了创建小段 HTML 的能力（但不要过度使用），但 `TagHelper` 类更进一步。
- en: The difference between Tag Helpers and HTML Helpers is `TagHelper` classes allow
    us to build our own tag elements through code and `HTMLHelper` classes are directly
    called as methods in the HTML.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 标签助手和 HTML 助手之间的区别在于 `TagHelper` 类允许我们通过代码构建自己的标签元素，而 `HTMLHelper` 类则直接在 HTML
    中作为方法调用。
- en: For example, if we were building a hotel application, some `TagHelper` classes
    would include `<calendar>`, `<availability>`, and `<room-gallery>` tags. These
    would look like brand new tags in HTML, but ASP.NET would render them on the server
    and create HTML based on the data model fed to them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在构建一个酒店应用程序，一些 `TagHelper` 类将包括 `<calendar>`、`<availability>` 和 `<room-gallery>`
    标签。这些在 HTML 中看起来像全新的标签，但 ASP.NET 会将它们在服务器上渲染，并根据提供的数据模型创建 HTML。
- en: Tag Helpers are an extremely powerful feature for developers wanting to create
    their own custom library of domain-specific HTML tags.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 标签助手（Tag Helpers）是开发者创建自定义领域特定 HTML 标签库的极有力功能。
- en: Creating SEO-friendly URLs
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SEO 友好的 URL
- en: Site architecture is important when building websites. If it’s a public-facing
    website, the site should be easy to crawl with simple URLs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建网站时，网站架构很重要。如果是一个面向公众的网站，网站应该易于爬取，并且具有简单的 URL。
- en: 'To look at this another way, examine the following two URLs:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，检查以下两个URL：
- en: '`https://www.mysite.com/Blog/my-first-blog-post`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.mysite.com/Blog/my-first-blog-post`'
- en: '`https://www.mysite.com/?blogpost=E1FCFB35-87C7-442F-9516-7C8585E8CD49`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.mysite.com/?blogpost=E1FCFB35-87C7-442F-9516-7C8585E8CD49`'
- en: If we found these links and we were talking with someone on the phone, which
    one would we tell them to follow?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到了这些链接，并且正在与某人通电话，我们会告诉他们跟随哪一个？
- en: 'Creating friendly URLs provides the following benefits:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建友好的URL提供了以下好处：
- en: '**Easier to identify the page**—We know the first URL is someone’s first blog
    post. The second URL is…well, we don’t know what kind of page it is.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易识别页面**—我们知道第一个URL是某人的第一篇博客文章。第二个URL是……嗯，我们不知道它是什么类型的页面。'
- en: '**Easy to repeat**—It’s easier to say the first URL over the phone as opposed
    to the GUID.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于重复**—在电话中说第一个URL比说GUID更容易。'
- en: '**Better SEO**—If we have the opportunity, it’s always good to help search
    engines identify what kind of page created.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的SEO**—如果我们有机会，总是好的，帮助搜索引擎识别创建的页面类型。'
- en: Best practices of Google’s URL structure
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌URL结构的最佳实践
- en: For better naming of URLs and what Google recommends, navigate to [https://developers.google.com/search/docs/crawling-indexing/url-structure](https://developers.google.com/search/docs/crawling-indexing/url-structure).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地命名URL以及谷歌推荐的做法，请导航至[https://developers.google.com/search/docs/crawling-indexing/url-structure](https://developers.google.com/search/docs/crawling-indexing/url-structure)。
- en: Creating these SEO-friendly URLs requires a site-wide link strategy using mapping
    methods such as `.MapRoute()` and, if using Razor Pages, naming pages related
    to the content.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些SEO友好的URL需要使用映射方法，如`.MapRoute()`，以及如果使用Razor Pages，命名与内容相关的页面。
- en: In this section, we learned how to catalog our links using extension methods,
    how controllers and pages should be made as small as possible, how `ViewComponent`
    classes can improve the efforts of writing modular code, why `TagHelper` classes
    can propel HTML to new heights, and why creating SEO-friendly URLs is so important.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用扩展方法对链接进行分类，如何尽可能使控制器和页面保持小，`ViewComponent`类如何提高编写模块化代码的效率，为什么`TagHelper`类可以将HTML提升到新的高度，以及为什么创建SEO友好的URL如此重要。
- en: In the last section, we’ll apply our knowledge of implementing these concepts
    into an application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将应用我们对实现这些概念的知识到应用程序中。
- en: Introducing Buck’s coffee shop project
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍巴克咖啡店项目
- en: We covered a lot in the last section, with various concepts explained. It’s
    one thing to explain `ViewComponent` and `TagHelper` classes, but where do we
    apply these concepts on a website?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们涵盖了大量的内容，解释了各种概念。解释`ViewComponent`和`TagHelper`类是一回事，但我们在网站上如何应用这些概念呢？
- en: In this section, we’ll apply those concepts to a brand-new project. Our friend
    wanted a new website for his coffee shop, so we used the ASP.NET 8 Web Application
    template as a starting point for the site.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将将这些概念应用到全新的项目中。我们的朋友想要他的咖啡店有一个新网站，所以我们使用ASP.NET 8 Web应用程序模板作为网站的起点。
- en: Setting up Buck’s website
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置巴克网站
- en: Since we have a new website, we want to create the client-side pipeline so that
    we can focus on the site’s functionality.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个新的网站，我们想要创建客户端管道，这样我们就可以专注于网站的功能。
- en: This sounds like a job for…the Task Runner.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是任务运行器的工作。
- en: While we’ve included the transpiling of TypeScript and bundling/minifying JavaScript
    in the project, we can add additional tasks to make our lives even easier.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在项目中包含了TypeScript的转译和JavaScript的打包/压缩，但我们还可以添加额外的任务来使我们的生活更加轻松。
- en: 'One easy task is to bundle and minify our styles using SASS, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的任务是将我们的样式使用SASS打包和压缩，如下所示：
- en: In the `npm install --save-dev sass gulp-sass`. These modules should be added
    to the `package.json` file.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`npm install --save-dev sass gulp-sass`中。这些模块应该添加到`package.json`文件中。
- en: 'Once these are installed in the `package.json` file, we include the module
    as required at the top of our `gulpfile.js` file, like so:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这些被安装到`package.json`文件中，我们就在`gulpfile.js`文件的开头按需包含模块，如下所示：
- en: '[PRE17]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a variable containing the path to the SCSS files:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含SCSS文件路径的变量：
- en: '[PRE18]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the style file to the `srcPaths` object (in the `sassSrc` property):'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将样式文件添加到`srcPaths`对象（在`sassSrc`属性中）：
- en: '[PRE19]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the style path to the `destPaths` object (with the `cssFolder` property):'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将样式路径添加到`destPaths`对象（使用`cssFolder`属性）：
- en: '[PRE20]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the processing and cleaning functions:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理和清理函数：
- en: '[PRE21]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, add the functions to the build process:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将函数添加到构建过程中：
- en: '[PRE22]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What about those JavaScript libraries? They’re in the dreaded `node_modules`
    folder. Most JavaScript libraries have a `dist` folder for distribution. This
    was the case when we installed the Bootstrap and Font Awesome libraries. Why not
    copy that into our `/lib` folder for our local purposes?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 那些JavaScript库呢？它们位于令人讨厌的`node_modules`文件夹中。大多数JavaScript库都有一个`dist`文件夹用于分发。当我们安装Bootstrap和Font
    Awesome库时就是这种情况。为什么不为我们的本地用途将它们复制到我们的`/lib`文件夹中呢？
- en: 'Create a variable in the `gulpfile.js` file containing the path to the `node_modules`
    folder. This should be in the root of the solution:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gulpfile.js`文件中创建一个变量，包含到`node_modules`文件夹的路径。这应该在解决方案的根目录：
- en: '[PRE23]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new variable containing the destination of where to place our `dist`
    packages (our `/``lib` folder):'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新变量，包含放置我们的`dist`包的目的地（我们的`/lib`文件夹）：
- en: '[PRE24]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define the copy details in a property called `lib`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`lib`的属性中定义复制细节：
- en: '[PRE25]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the processing and cleaning functions:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理和清理函数：
- en: '[PRE26]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, add our library copy to the build process:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将我们的库复制添加到构建过程中：
- en: '[PRE27]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This gives us the ability to automatically receive the latest versions of packages
    for our application. When updating our `package.json` file, we’ll benefit from
    the latest versions in `node_modules` delivered right to our `/``lib` folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够自动接收应用程序的最新版本包。当更新我们的`package.json`文件时，我们将从`node_modules`中的最新版本中受益，直接送到我们的`/lib`文件夹。
- en: Updating the links
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新链接
- en: 'Since we have a new application, we’ll create `Url` Helpers to help catalog
    the site. Based on the template, we have two links: `Home` and `Privacy`. Let’s
    create those `Url` Helpers, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个新的应用程序，我们将创建`Url`助手来帮助编目网站。根据模板，我们有两条链接：`Home`和`Privacy`。让我们创建这些`Url`助手，如下所示：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This makes our HTML easier to read. Instead of the Anchor Tag Helpers, we can
    substitute them with a Url Helper. Here is the result of replacing the Privacy
    Anchor Tag Helper:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的HTML更容易阅读。我们可以用Url Helper替换锚点标签助手。以下是替换隐私锚点标签助手的示例：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While this is one instance on this page, we can already see the dividends of
    our efforts. Notice the navigation bar?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是页面上的一个实例，但我们已经看到了我们努力的回报。注意导航栏吗？
- en: 'In the navigation bar, there’s another location where we can remove the hardcoded
    URL and use a strongly typed `UrlHelper` class, as illustrated here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航栏中，还有一个位置我们可以移除硬编码的URL并使用强类型的`UrlHelper`类，如下所示：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There are `Privacy` and `Home` links we replaced.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们替换了`Privacy`和`Home`链接。
- en: 'The technique also works with controllers or Razor Pages. If we need to redirect
    to another page, there is a `UrlHelper` class available to us by default, as shown
    here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也适用于控制器或Razor页面。如果我们需要重定向到另一个页面，默认情况下有一个`UrlHelper`类可供我们使用，如下所示：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It removes the need for hardcoded URLs, providing a more efficient way of referencing
    links across a large website.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了硬编码URL的需求，为在大型网站上引用链接提供了一种更有效的方法。
- en: Creating an OffCanvas Tag Helper
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建OffCanvas标签助手
- en: Since responsive websites are important, we need to have an `OffCanvas` menu
    for when users see the site with a mobile device.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于响应式网站很重要，我们需要有一个`OffCanvas`菜单，以便用户在用移动设备查看网站时使用。
- en: '`OffCanvas` menus are activated on mobile devices when clicking on a hamburger
    menu (shown as three lines on top of each other). `OffCanvas` menus are hidden
    from the main content on a web page, hence the name. They’re only necessary to
    hide navigational items until they’re actually needed.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当在移动设备上点击汉堡菜单（显示为重叠的三条线）时，`OffCanvas`菜单被激活。`OffCanvas`菜单在网页的主内容中隐藏，因此得名。它们只有在实际需要时才隐藏导航项。
- en: We’re creating an `OffCanvas` menu for Buck’s website. However, we want to use
    this on multiple sites, so there is a requirement to create a reusable component.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为Buck的网站创建一个`OffCanvas`菜单。然而，我们希望将其用于多个网站，因此需要创建一个可重用的组件。
- en: Bootstrap has an `OffCanvas` component and, while it’s simple HTML, we can turn
    this into a reusable component with Tag Helpers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap有一个`OffCanvas`组件，虽然它是简单的HTML，但我们可以通过标签助手将其转换为可重用的组件。
- en: 'First, we need the structure of a Tag Helper. Here’s the code we need to execute:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要标签助手的结构。以下是我们需要执行的代码：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At the beginning of the code, we need to identify which HTML Tag we want to
    use for our Tag Helper. In this case, it’s a simple `offcanvas` tag. Since HTML
    tags, attributes, and CSS classes are all lowercase by default, every reference
    to the `OffCanvas` class should contain a lowercase string of the tag.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开始部分，我们需要确定我们想要为我们的标签助手使用哪个HTML标签。在这种情况下，它是一个简单的`offcanvas`标签。由于HTML标签、属性和CSS类默认都是小写，所以对`OffCanvas`类的每个引用都应该包含一个标签的小写字符串。
- en: We want to include an ID and a tab index based on the examples, so we need two
    properties called `Id` and `TabIndex`, with `[HtmlAttributeName]` data annotations
    applied to each property.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望根据示例包含一个ID和一个tab index，因此我们需要两个属性，分别称为`Id`和`TabIndex`，每个属性都应用了`[HtmlAttributeName]`数据注解。
- en: The primary method is the `ProcessAsync` (or `Process`) method. We immediately
    grab any children inside the `offcanvas` tag and process the child tags, which
    we’ll get to later in this section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 主要方法是`ProcessAsync`（或`Process`）方法。我们立即获取`offcanvas`标签内的任何子元素并处理子标签，我们将在本节稍后讨论。
- en: We set `tagname` to `DIV`, set `classname` to `offcanvas`, set the attributes,
    and finally, set `innerHTML` to the child data retrieved from the beginning of
    the `ProcessAsync` method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`tagname`设置为`DIV`，将`classname`设置为`offcanvas`，设置属性，最后将`innerHTML`设置为从`ProcessAsync`方法开始检索的子数据。
- en: 'According to the Bootstrap `OffCanvas` documentation, we need a header and
    a body. We can easily duplicate this code to create a `header` and `body` tag
    for `offcanvasTagHelper`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Bootstrap `OffCanvas`文档，我们需要一个标题和一个主体。我们可以轻松地复制此代码来为`offcanvasTagHelper`创建一个`header`和`body`标签：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `HTMLTargetElement` data annotation is a little bit different. We called
    this tag `header`. Won’t this interfere with the regular HTML header tag? Not
    so long as we include `ParentTag` as a second parameter, saying this element is
    only valid within an `offcanvas` element.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTMLTargetElement`数据注解有一点不同。我们称这个标签为`header`。这不会与常规的HTML标题标签冲突吗？只要我们将`ParentTag`作为第二个参数包含进来，说明这个元素只在一个`offcanvas`元素内有效。'
- en: In this `Process` method, we create a header and button and append the HTML
    to the output’s content at the bottom. This content is sent back to the parent
    `offcanvasTagHelper` instance as the child data.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`Process`方法中，我们创建一个标题和按钮，并将HTML内容附加到输出内容的底部。这个内容作为子数据发送回父`offcanvasTagHelper`实例。
- en: 'We only need to create the body with `OffCanvasBodyTagHelper`, as shown in
    the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要使用`OffCanvasBodyTagHelper`创建主体，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will contain the same `HTMLTargetElement` data annotation as our header,
    but we’ll call this the `body` tag. Again, it won’t interfere with the standard
    body HTML tag since we’re inside an `<offcanvas>` element. We get the child data
    (which should be a lot of HTML), we set the class and the `TagName` property,
    and finally set the content to what was inside the body tag.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含与我们的标题相同的`HTMLTargetElement`数据注解，但我们将称之为`body`标签。同样，由于我们处于`<offcanvas>`元素内部，它不会与标准的body
    HTML标签冲突。我们获取子数据（应该是大量的HTML），设置类和`TagName`属性，最后将内容设置为body标签内的内容。
- en: 'One last thing required for our tag helper to work is to include all `TagHelper`
    instances in the project through the `_ViewImports.cshtml` file, like so:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了让我们的标签助手工作，我们需要通过`_ViewImports.cshtml`文件将项目中的所有`TagHelper`实例包含进来，如下所示：
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can add a button to our HTML to trigger `offcanvas`, like so:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在HTML中添加一个按钮来触发`offcanvas`，如下所示：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now create a simple `offcanvas` component in our HTML, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的HTML中创建一个简单的`offcanvas`组件，如下所示：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once this is rendered, it will produce the Bootstrap result of an `OffCanvas`
    component with valid HTML.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦渲染完成，它将生成一个有效的`OffCanvas`组件的Bootstrap结果。
- en: This powerful technique can be applied to create a simplified HTML language
    for any domain where even non-developers can understand web pages.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种强大的技术可以应用于创建任何领域的简化HTML语言，即使非开发者也能理解网页。
- en: In this section, we took a sample website and optimized our client-side scripts
    and styles, centralized our links by creating URL Helper extension methods, and
    finally, built an `OffCanvas` Tag Helper to showcase how we can create our own
    HTML library of powerful elements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们选取了一个示例网站并优化了我们的客户端脚本和样式，通过创建URL Helper扩展方法集中了我们的链接，并最终构建了一个`OffCanvas`
    Tag Helper来展示我们如何创建自己的HTML库中的强大元素。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began with how important a task runner is for client-side
    tasks and how to set up a task runner, then understood the structure of a gulpfile
    and how to create a workflow structure. Once we had our task runner working, we
    put it to work by focusing on transpiling TypeScript into JavaScript and bundling
    and minifying it into something for a production website.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先讨论了任务运行器对于客户端任务的重要性以及如何设置任务运行器，然后了解了gulpfile的结构以及如何创建工作流程结构。一旦我们的任务运行器开始工作，我们就将其用于将TypeScript转换为JavaScript，并将其捆绑和压缩成适合生产网站的内容。
- en: We proceeded with looking at what’s considered a standard in the industry when
    it comes to UIs in ASP.NET 8\. We learned about how to save time by centralizing
    all links in one place, why it’s important to keep controllers and Razor Pages
    small, and the key reasons why `ViewComponent` classes should be used. We learned
    why `TagHelper` classes are better than `HTMLHelper` classes and why a site should
    use SEO-friendly URLs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续探讨在ASP.NET 8中UI的标准是什么。我们学习了如何通过集中所有链接在一个地方来节省时间，为什么保持控制器和Razor Pages小很重要，以及为什么应该使用`ViewComponent`类的关键原因。我们还学习了为什么`TagHelper`类比`HTMLHelper`类更好，以及为什么网站应该使用SEO友好的URL。
- en: To finalize this chapter, we looked at an example website and had a task runner
    bundle and minify our styles along with updating libraries automatically on build.
    We also applied URL Helper extension methods to the site, making it easier to
    change site-wide links. Finally, we took a Bootstrap `offcanvas` HTML component
    and converted it into a reusable `TagHelper` class to showcase the power of Tag
    Helpers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，我们查看了一个示例网站，并使用任务运行器捆绑和压缩样式，同时在构建过程中自动更新库。我们还应用了URL Helper扩展方法到网站上，使其更容易更改网站范围内的链接。最后，我们将Bootstrap的`offcanvas`
    HTML组件转换成了一个可重用的`TagHelper`类，以展示Tag Helper的强大功能。
- en: In the next chapter, we’ll look at the different types of testing and what are
    the best ways to unit test our code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨不同的测试类型以及测试我们代码的最佳方法。
