- en: Chapter 8. Open Source Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to review the current state of open source programming
    with Microsoft technologies and tools. This is something that has been referred
    to by many technology evangelists as the open source ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the initial movements in this area and explore how they have
    evolved over time, summarizing the most important initiatives that any developer
    can access at this moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, we'll revise some of the most popular implementations, either on the
    side of tools (IDEs) or APIs and languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at programming with open source solutions, such as Node.js, how it's
    is supported within Visual Studio and how easy it is to create a project that
    uses Node with this environment, as well as how other IDE choices are available,
    such as Visual Studio Code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Later, we''ll go through perhaps the two most important and adopted open source
    initiatives in Microsoft: the Roslyn project, a set of APIs and services that
    provide extended support for the development experience; and TypeScript, the new
    language created by C# author Anders Hejlsberg, which allows programmers to use
    advanced JavaScript features today, with excellent support of IDEs and total backwards
    compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historical open source movements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft began to pave the way in open source as far back as 2003, when the
    first moves were made in order to adopt GPL Licensing on some products, the most
    noticeable being the effort to standardize the .NET Framework platform in general
    and the C# Language in particular.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, it was soon approved as a standard by ECMA (ECMA-334) and ISO (ISO/IEC
    23270:2006).
  prefs: []
  type: TYPE_NORMAL
- en: Later on, the Mono Project (Xamarin) ([https://en.wikipedia.org/wiki/Mono_(software)](https://en.wikipedia.org/wiki/Mono_(software))),
    which is now part of Microsoft, provided versions of .NET capable of running in
    Linux and MacOS. This was probably the first serious attempt to make C# universal.
    The Mono licensing model was clearly open ([http://www.mono-project.com/docs/faq/licensing/](http://www.mono-project.com/docs/faq/licensing/)),
    although their IDE was not (Xamarin Studio).
  prefs: []
  type: TYPE_NORMAL
- en: However, the acquisition of Xamarin by Microsoft brought even better news to
    developers, since now, clients of Visual Studio Community Edition could find Xamarin
    tools and libraries embedded in the IDE with all the value of building Android,
    iOS, and Windows Phone solutions seamlessly. Likewise, there's a free release
    of the product called Xamarin Studio Community Edition.
  prefs: []
  type: TYPE_NORMAL
- en: Other projects and initiatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, what's been discussed so far was only part of the landscape. From 2005,
    they started to contribute to well-known open source initiatives, such as Linux
    and Hadoop, in order to use internally open source products and tools and publish
    some results.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the best-known projects were the .NET Foundation initiative and WinJS,
    a library to use JavaScript that allows access to the Windows APIs and that appeared
    aligned with the Windows 8 suite of operating systems, permitting developers to
    build applications made with HTML5, CSS3, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Azure has been another important division where Microsoft started to show its
    interest in open source. To previous movements supporting Linux and MacOS directly
    in Azure, we have to add the recent announcement of SQL Server running in Linux
    ([http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux](http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux)),
    and the availability of PowerShell for Mac OS and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest announcements, officially confirmed in November''s Connect() event,
    only deepen that philosophy: Microsoft becomes a Platinum Partner of the Linux
    Foundation, one in three virtual machines running in Azure is a Linux "distro",
    and the inclusion of Bash in Windows 10 allows the native installation of several
    Linux "distros" in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, Google has become a member of the .NET Foundation and it's
    actively collaborating in the standardization of C#. Microsoft is as of this moment,
    the company with the highest amount of "open source" projects contributing in
    Github.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the recent collaboration with Samsung and the Tizen initiative only
    extends the number of collaborations with the open source world.
  prefs: []
  type: TYPE_NORMAL
- en: Open source code for the programmer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What about the programmer? As we mentioned, to the announcement of the free
    Visual Studio Community Edition in 2013 followed the declaration that this tool
    is going to be free in later editions along with the opening of Xamarin Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open source code for the programmer](img/image00565.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This change was proposed in the spring of 2015 with the publication of Visual
    Studio Code, (free and available for Windows, Linux, and MacOS). It's a development
    tool that joins the capabilities of an editor with the debugging features of an
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'How was Visual Studio Code coded so that it would work on the three platforms?
    Three projects? Not quite. It was done thanks to the other big movement that started
    in 2010, which we introduced in [Chapter 04](part0028.xhtml#aid-QMFO2 "Chapter 4. Comparing
    Approaches for Programming") *Comparing Approaches to Programming* and that I''ll
    cover later in this chapter: TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Other languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open source projects also appear with other tools and languages such as Node.js,
    now used as another type of project from Visual Studio (any version), Python,
    PHP, or Apache/Cordova. All these technologies are now part of the installable/programmable
    projects available from the IDE. This goes for GitHub as well, whose engineers
    collaborate to integrate it better with Visual Studio and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Node.js, you have to install the templates for Visual Studio
    (a one-time, pretty straightforward operation), and you will be shown several
    templates when you select in to build a new project, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Other languages](img/image00566.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you work with one of these projects, you'll discover that common tools on
    other platforms are, by default, available here as well, such as Grunt, Bower,
    NPM. Gulp, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Just for the sake of completeness, let's perform a basic demo of Node.js with
    these templates and see how it works. If you select **Basic Node.js Express Application**,
    a whole application will be generated from the templates, including the files
    required to launch a working instance of Node.js and a simple web page that uses
    Node as the localhost web server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For detailed information on Node, you can check another title in this "Mastering"
    series, with detailed documentation, explanations and demos: "Mastering Node.js",
    by Sandro Pasquali ([https://www.packtpub.com/web-development/mastering-nodejs](https://www.packtpub.com/web-development/mastering-nodejs)).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the project uses the Express library, which works seamlessly with
    Node. The view engine is also the most common one in these projects (it's called
    Jade, and you can change it at any time or use one of the alternatives available).
  prefs: []
  type: TYPE_NORMAL
- en: 'When reviewing the files generated, you''ll notice a number of libraries that
    have been downloaded and updated in our project. This is the result of the IDE''s
    interaction with the `package.json` configuration file, which establishes the
    libraries that the application depends on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This file instructs the IDE to download all libraries required and all the dependencies
    these libraries rely upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'At launch, two windows will open. On the one hand, Console will open, and on
    the other hand, an instance of the default browser will open. In the console,
    Node.js is listening on two ports: the debugging port [`5858`] and the Express
    port [`1337`], which take care of web requests, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Other languages](img/image00567.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding figure, two requests have been made at runtime:
    the rendered page (which Jade generates from the basic source code in the `index.jade`
    file) and the style sheet, which was referenced in the `layout.jade` file that
    serves as the master page in this demo. Both worked fine (`200` status).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the resulting page from mixing these two .`jade` files (the
    actual master or the main page) is shown in the selected browser (note that you
    can select more than one browser to create a multi-browser debugging session):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Other languages](img/image00568.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Independently of the aspects of Node.js programming and its tools, you''ll
    observe that the tool''s support is very complete, so we can even mix projects
    that use different technologies in a single solution, and we don''t depend on
    an installation of IIS for debugging purposes anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Other languages](img/image00569.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Other remarkable areas where the community is very active in the Microsoft
    Open Source ecosystem are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core (now in version 1.1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Edge, where users can vote for new features under consideration and
    use the JavaScript internal engine (Chakra) for their own purposes (just like
    with Chrome's V8 engine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about, and collaborate on, these projects at [https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backdropfilter](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backdropfilter),
    as shown in the previous figure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '.NET Core is the latest member in the .NET family, which enables the building
    of applications that work on any platform: Windows, Linux, or MacOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Roslyn and TypeScript projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, many, many more
  prefs: []
  type: TYPE_NORMAL
- en: The Roslyn project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Also called .NET Compiler Platform and headed by Anders Hejlsberg, Roslyn is
    a set of tools and services that help the developer control, manage, and extend
    the capabilities of any source code editor or IDE and take care of the code in
    a number of ways, including edition, parsing, analyzing, and compilation. It is
    part of the .NET Foundation initiative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Roslyn project](img/image00570.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Actually, all the magic behind the editors (Intellisense, code snippets, code
    suggestions, refactoring, and so on) is managed by Roslyn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, using Roslyn, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create custom, specific code examination tools, which can be incorporated in
    the editors in Visual Studio 2015 and other compatible tools. Along with this,
    you can expand the live code examination engine with your own guidelines. This
    implies that you can write diagnostics and code fixes (known as analyzers) and
    code refactoring rules for your APIs or your particular programming needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, the Visual Studio Editor will identify code issues as you write,
    squiggling the code that requires consideration and proposing the best possible
    fixes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can instrument code generation, produce IL code (remember the demos we saw
    in previous chapters), and perform everyday, code-related jobs inside your .NET
    applications thanks to the compiler APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, extensions are possible by building personalized plugins that can execute
    outside Visual Studio and also configure MSBuild and exploit the C# compiler to
    perform code-related jobs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create REPLs (read-evaluate-print loops) with your own IDE, which is able to
    examine and execute C# code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences from traditional compilers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, compilers behave as black boxes or like a function in the source code,
    where the code to be compiled is the argument, there's something going on in the
    middle, and an output is generated at the other end. The process entails an inner,
    deep understanding of the code they are dealing with, but such information is
    not available to developers. Besides, this information is dismissed after the
    translated output is produced.
  prefs: []
  type: TYPE_NORMAL
- en: The mission of Roslyn is to open the black box and allow developers to not only
    know what's going on behind the scenes, but—ultimately—also have the capability
    to create their own tools and code checkers and extend the traditional possibilities
    created by old compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official documentation for Roslyn ([https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)),
    explains the main changes of this approach by comparing the classical compiler
    pipeline with the set of services proposed by Roslyn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Differences from traditional compilers](img/image00571.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As the figure shows, every part of the pipeline has been replaced with APIs
    that allow you to write code that can be parsed, create **Syntax Tree API**, and
    generate a whole symbol map out of it, performing the required **Binding and Flow
    Analysis APIs** in order to finally use the **Emit API** to generate the resulting
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way Roslyn handles these phases is by creating object models for each of
    them. A deep study on the capabilities and opportunities offered by this set of
    services and tools is beyond the scope of this book, but I would like to present
    an introductory view of these possibilities, along with some demo code so that
    it''s possible to start building you own utensils: projects that read code and
    help identify potential issues and how to fix them.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Roslyn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some requirements that apply before you start using Roslyn from Visual
    Studio. The first one is to have the Git extension installed: you can find it—as
    with many others—in the **Extensions and Updates** tool in the **Tools** menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, create a new project in Visual Studio, select the C# Language,
    and under the **Extensibility** item, choose **Download the .NET Compiler Platform
    SDK**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Roslyn](img/image00572.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An `index.html` web page will appear, containing a button linked to downloads
    for syntax tree visualizers, templates for analyzers, and so on. Note that if
    you have more than one edition of Visual Studio installed, you will be notified
    by the `.vsix` installer about which products you want the extensions to be installed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several options appear as available in different contexts now. On the one hand,
    if you go to the **Tools/Options** menu and check the **Text Editors** item, you
    can find new options to control the way this language is managed within Visual
    Studio Editors on the C# side: options to format code for Intellisense, and so
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, after reloading Visual Studio, if you go back to Extension
    and Updates, you will find that new types of projects are available now, including
    **Stand-Alone Code Analysis Tool**, **Analyzer With Code Fix (NuGet + VSIX)**,
    **Code Refactoring (VSIX)**, and **VSIX Project**, this last one being specific
    to installations of plugins and the like. You should get an offer like the one
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Roslyn](img/image00573.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with a simple class and see what we can do with the options. So,
    I create a new project (a Console one is just fine) and get rid of the using declarations
    included by default.
  prefs: []
  type: TYPE_NORMAL
- en: Even with the default initial code we have, Roslyn will read and convert it
    into a Syntax Tree representation, where everything (every word, whitespace, curly
    brace, and so on) has a place in the tree and can be managed accordingly. This
    tree can be examined using the new window available in **View** | **Other Windows**
    | **Syntax Visualizer** installed by the previous process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we click on the source code (that is, in the middle of the `class`
    word), the window will show the result of the code analysis (we show the legend
    as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Roslyn](img/image00574.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice that the tree starts with something called **CompilationUnit**,
    with the main **NamespaceDeclaration** node hanging from it. Therefore, every
    single element in the source code is now recognizable and manageable.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to see this tree in a more visual manner, we can right-click on the
    **CompilationUnit** contextual menu and select the **View Directed Syntax Graph**
    option, which will show a `.dgml` file in the editor with a colored tree in which
    every color in the legend represents one element in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When passing the mouse over one element, its properties are shown in a tooltip
    (also, right-clicking on a single node shows a contextual menu of possible options):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Roslyn](img/image00575.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The blue nodes characterize the high-level nodes of the C# grammar that can
    be divided into smaller units. The green ones are called *syntax tokens* and are,
    somehow, like the atoms or basic units of the syntax tree (they cannot be divided
    into anything smaller).
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the nodes (white and gray nodes) are the so-called *trivia* nodes,
    and they're not relevant to compilation as they are the parts of the source text
    considered *largely insignificant for normal understanding of the code, such as
    whitespace, comments, and preprocessor directives*, according to the official
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, there is another very useful online tool (open source) called Source
    Visualizer, which is available at [http://source.roslyn.io/](http://source.roslyn.io/)
    and shows how Roslyn is coded, along with its source code.
  prefs: []
  type: TYPE_NORMAL
- en: You're allowed to navigate through the whole tree of elements found in the Roslyn
    project and check them out, reviewing how they are coded to serve as an inspiration
    for your own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we click on the left tree in the search for the CSharp compiler,
    we can see how it is coded and all the details linked to it, as the following
    screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Roslyn](img/image00576.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A first look at Microsoft Code Analysis Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along the course of this book, and probably long before, you may have noticed
    the large amount of options available within the source code editors in order
    to facilitate usual operations, notify errors before compilations, and suggest
    changes among other things (remember, for example, when talking about the implementation
    of the `IDispose` interface, how the IDE suggested several possible implementations
    for us).
  prefs: []
  type: TYPE_NORMAL
- en: From Visual Studio 2015 onwards, these features are just some of the many tools
    powered by Roslyn. One of the most popular among them is the set of services linked
    to Code Analyzers.
  prefs: []
  type: TYPE_NORMAL
- en: Code Analyzers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: They're not anything new since they have been at our disposal for years within
    Visual Studio. However, as part of the work with Roslyn, these features—and many
    others—were rewritten in order to permit the use of extra functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are usually divided into three main categories: Code Analyzers, Code Visualizers,
    and Code Refactors. The three can work together to perform more complex tasks
    and help the developer in a variety or ways: programmers often need to work with
    some code they didn''t write, or they simply want to know something about the
    quality of someone else''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first category (Code Analyzers) takes care of the generated tree that we
    saw in the basic demo earlier. These analyzers split the code into pieces, use
    some type of taxonomy to identify every unit, and place the resulting set in a
    fashion that can be managed later on by other tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code Visualizers are responsible for presenting code in a readable manner. They
    can also provide us with tips about quality and mistakes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code Refactors are small fragments of code that—when applied to a previously
    recognized block—are able to suggest changes and even apply those changes, directly
    substituting the original code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An entire open source sample for you to check: ScriptCS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's an open source project that can give you an idea about some of these
    possibilities. It's called ScriptCS. Remember, we mentioned that with Roslyn,
    you can build a tool similar to the REPL (read-evaluate-print-loop) available
    for Node.js, Ruby, and Python, for example. I mean a tool that can examine and
    execute C# code.
  prefs: []
  type: TYPE_NORMAL
- en: To test it, just go to the ScriptCS website ([http://scriptcs.net/](http://scriptcs.net/))
    and download the project. It's a Visual Studio solution made up of several projects
    that shed some light about the possibilities this technology offers.
  prefs: []
  type: TYPE_NORMAL
- en: Once compiled, if you launch the program, you'll see a console application,
    which suggests that you write some code to analyze and execute. The tool will
    use the compiler, and it works in a manner very similar to the Console tool in
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aspect will be like what is shown in the following screenshot. Note that
    I write three separate sentences, and only after writing the one that produces
    an output, we get the results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An entire open source sample for you to check: ScriptCS](img/image00577.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, Roslyn services are creating a class behind the scenes for us and
    are inserting that code within, later calling the compiler, executing the code,
    and redirecting the output to the Console window, where we see the results.
  prefs: []
  type: TYPE_NORMAL
- en: It becomes useful when we just want to check out a simple piece of code without
    building a whole project.
  prefs: []
  type: TYPE_NORMAL
- en: A basic project using Microsoft.CodeAnalysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start working with these tools, creating a simple Console application
    and installing Microsoft.CodeAnalysis tools directly from NuGet Package Manager
    Console.
  prefs: []
  type: TYPE_NORMAL
- en: We can type `Install-Package Microsoft.CodeAnalysis`, and we'll see the installation
    process in which all the required dependencies are downloaded, with the last message
    shown saying something like `Successfully installed 'Microsoft.CodeAnalysis 1.3.2'
    to [TheNameOfYourProject]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main method, we are going to load a C# file in order to analyze its
    contents. With this purpose, we have created a `Person.cs` file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Later on, we''re defining a new entry point, `InitialParser.cs`, which is going
    to take care of the analysis. We''ll establish this class as the entry point of
    the application, and in its main method, we start by reading the file to be checked,
    using the same class as earlier (CSharpSyntaxTree)—only, this time, we load the
    file contents early in order to pass them to the `ParseText` static method of
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Observe that `ParseText` returns a `SyntaxTree` object. This is fundamental
    for analysis since it allows you to iterate over the whole tree in order to inspect
    how the Tree Object Model was implemented when it was applied to our `Person`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to have a clear view of why certain objects are selected to recover
    the code's properties, remember that the Syntax Tree Viewer that we discussed
    earlier achieves many of the actions that we are going to perform here, and it
    offers the corresponding name of the element as we move from one point in the
    code to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you click on the code right inside the `class` keyword, the
    Syntax Tree Visualizer will move exactly to that point in the tree, indicating
    the name associated with the Object Model, as the next screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic project using Microsoft.CodeAnalysis](img/image00578.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have a very nice tool to suggest which classes and classes' members
    we should identify in the API in order to obtain references to the elements that
    compose the Syntax Tree.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to obtain the name of the first class defined in the code (there's
    only one, but the syntax tree will show as many as there were), first, we need
    to access the root of the tree. We do that by calling `GetRoot()` in the tree
    object previously obtained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the root element, a look at the methods used throws some light
    on the possibilities we have. Here are some of these methods, just to name a few:'
  prefs: []
  type: TYPE_NORMAL
- en: We can go down or up, looking for descendants in search of ancestors since we
    have access to the whole list of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can find a given node or check the contents of any node in search for something
    special
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can read a node's text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can even insert or remove any of them (refer to the following screenshot):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A basic project using Microsoft.CodeAnalysis](img/image00579.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Given that all collections provided by the APIs are generic collections, we
    can ask for nodes of a concrete type using the `OfType<element>` syntax. That''s
    what we do next in order to get the `ClassDeclarationSyntax` object of our `Person`
    class, so we print it to the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go on and obtain the method''s names in the class using the objects
    already declared. So, in this case, we''ll ask for all the `MethodDeclarationSyntax`
    objects available after the `DescendantNodes()` call and go through them, printing
    their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can go for the properties, knowing that the syntax tree categorizes
    them as `PropertyDeclarationSyntax` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic project using Microsoft.CodeAnalysis](img/image00580.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is one of the recommended procedures to iterate over the syntax tree and
    recover information about its members, although in this case, we're just reading
    data and presenting the results.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach to code refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the previous ideas and APIs, let's look at how to program those diagnosing
    and refactoring features that Visual Studio offers. That's the main reason for
    Extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember something about the building and parsing behavior of Visual Studio.
    Many of these features are disabled by default. The whole set of analysis'' capabilities
    is found—for any project—in the `Project/Properties/Code Analysis` tab and is
    presented with two main options:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable **Code Analysis** on **Build**, which, internally, defines the `CODE_ANALYSIS`
    constant and forces the active set of features to be run against the current code
    before each compilation. Also, note that you can configure the behavior, changing
    the severity of any issue to be `Warning`, `Error`, `Info`, `Hidden`, or `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select one the available rule sets, which the IDE offers. By default, **Microsoft
    Managed Recommended Rules** is active, but there are many others to choose and
    you can even activate/deactivate every single rule in those sets. The following
    screenshot shows these options:![The first approach to code refactoring](img/image00581.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That said, we're going to create one of these projects that appeared after the
    installation of the SDK that we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: What we'll do is select the type of project named Analyzer with code Fix (VSIX)
    and look at how it is programmed and what the principal units of code are. Then,
    we'll cover debugging since it works in a peculiar way with respect to any other
    debugging scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the new project, you''ll notice the presence of three individual
    projects in the solution: the analyzer itself, another one for testing purposes,
    and finally, the one with the `.vsix` extension, which serves as the deploying
    mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on the first one. To honor its name, there are two classes implied:
    one for analysis (`DiganosticAnalyzer.cs`) and another in charge of code fixing
    (`CodeFixProvider.cs`). It''s important to recognize these roles and keep the
    code like this, even when we want to extend the default functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t matter that the project''s purpose is a bit simple: it searches
    for a class definition that contains a lowercase letter and marks it as a target
    for `CodeFixProvider` to advise about this situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this first task of finding the code, the `Analyzer2Analyzer` class,
    which inherits from `DiagnosticAnalyzer` performs the following actions (we explain
    them one by one since it''s not obvious at first):'
  prefs: []
  type: TYPE_NORMAL
- en: First, the class is decorated with the `[DiagnosticAnalyzer]` attribute, indicating
    that the language to be used will be CSharp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, at the class level, it declares some strings of type `LocalizableString`.
    The reason is that this could work in different versions of Visual Studio with
    different locales. This is why the arguments these strings are assigned to are
    read from a resource file (created for this purpose). Take a look at the `Resources.resx`
    file's contents to check how the strings are saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates a `DiagnosticDescriptor` instance (the rule to be checked), which
    will be in charge of creating a `Description` instance of a given diagnostic.
    It takes a few arguments to describe the issue to look for, and one of them is
    Severity, which, by default, is just a warning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It overrides the read-only `SupportedDiagnostics` property to return a new instance
    of an `InmutableArray` array based on the previous rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It overrides the `Initialize` method, which receives a context object of type
    `SymbolAnalysisContext`, which is in charge of registering the corresponding action
    we want to perform on the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this demo, it calls the `RegisterSymbolAction` method to register two things:
    the method to be used in the analysis and the category to which such analysis
    belongs. (Actually, it passes `AnalyzeSymbol` as the name of the method).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, note that the `RegisterSymbolAction` method will be called as many times
    as required in order to iterate on all instances of symbols that might meet the
    condition to be tested.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it declares the `AnalyzeSymbol` method that receives the context, looks
    at the symbol to be checked, and if it meets the diagnosis (in this demo, if it
    has any lowercase letter in its name), it creates a `Diagnostic` object and indicates
    the context to call `ReportDiagnostic`, which activates whatever action is programmed
    for this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we can see, although there are not many lines, it''s not a simple code.
    That''s why we need to understand how the internals of Roslyn work in order to
    follow the right actions involved in the context to check for a certain issue.
    The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although the counterpart (CodeFixer) has some more lines of code, you will be
    able to read the rest of the code—and understand how it operates—by taking a look
    at `Analyzer2CodeFixProvider` included in the `CodeFixProvider.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: The two important methods here are the override to `RegisterCodeFixesAsync`,
    which receives `CodeFixContext` (required to launch the `fixing` action) and the
    `fixing` action represented in the demo by the `MakeUppercaseAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: When this method is called, it returns a `Task<Solution>` object and receives
    all the required information to perform the task, plus a `CancellationToken` object
    to allow the user to ignore the fix suggestion offered in the contextual dialog
    box. Of course, it's responsible for changing the code if the user accepts the
    modification.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and testing the demo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test these demos, a new instance of Visual Studio is launched, which will
    have the Analyzer registered and active when loaded. For this case, I launched
    the project, and in the new instance of the IDE, I opened the previous project
    to understand how it recognizes names of identifiers with lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: So, proceed in this manner, and open our previous `Person.cs` file (or any other
    similar file for that matter) to check this diagnosis in action. You will see
    a red squiggling underline on the declaration of the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you place your cursor underneath the word `Person`, a tooltip will show
    up, advising you of a potential problem (in this case, there''s no problem at
    all):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging and testing the demo](img/image00582.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Up until this point, we were dealing with the first class analyzed (the `Analyzer2Analyzer`
    class). But now, we''re offered a double option: the yellow bulb, with a contextual
    menu and the **Show potential fixes** link. Both take to the same window, showing
    the potential fixes in all places where this fix could be applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note how these fixes are marked with color. In this case, the color is
    green, indicating that fixes will not provoke another diagnosis issue, but if
    it does, we will be notified accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging and testing the demo](img/image00583.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also have the option of **Preview changes**, which, in turn, presents another
    (scrollable) window in order to examine in detail what would happen to our code
    if we accept the suggestion (shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging and testing the demo](img/image00584.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To deploy the project, you can follow two different approaches: use the `NuGet`
    package generated (you will see it in the `Bin/Debug` folder after compilation
    as usual) or use the `.vsix` binaries generated by the compiler, which are also
    available in the same subdirectory, only in the Vsix project this time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first case, you should follow the indications in the `Readme.txt` file
    (what follows is a citation of the previously mentioned file):'
  prefs: []
  type: TYPE_NORMAL
- en: 'To try out the NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a local NuGet feed by following the instructions here: [http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds](http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `.nupkg` file into that folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the target project in Visual Studio 2015.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project node in Solution Explorer and choose **Manage NuGet
    Packages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the NuGet feed you created on the left-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your analyzer from the list and click on **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to automatically deploy the `.nupkg` file to the local feed folder
    when you build this project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on this project in Solution Explorer and choose **Unload Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on this project and click on **Edit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the **AfterBuild** target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Exec** task, change the value inside **Command** after the `–OutputDirectory`
    path to point to your local NuGet feed folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other choice is to launch the `.vsix` file (the extension will be recognized
    by the system). This will install the package in Visual Studio after asking for
    conformity, just like any other package that you might have previously installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to this point, we have introduced Roslyn and its capabilities. Now, we''re
    going to visit the other big open source project, which is getting more hype due
    to its importance in many web projects, including Angular, Ionic, and many others:
    TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We revert here to the study of TypeScript that we started in [Chapter 04](part0028.xhtml#aid-QMFO2
    "Chapter 4. Comparing Approaches for Programming") *Comparing Approaches to Programming*,
    and that served as an introduction to the language, the tools to use, its integration
    with Visual Studio and a basic coverage of its possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: In that chapter, I promised to review the characteristics of the language since
    it is the other big Microsoft project related to open source since its inception,
    and it's just gaining momentum and increasing adoption all over the world. TypeScript
    is, in the words of its own creator, *a JavaScript that scales*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, if you want to deep dive into the language and its possibilities, take
    a look at the excellent "Mastering TypeScript" by Nathan Rozentals, available
    at [https://www.packtpub.com/web-development/mastering-typescript](https://www.packtpub.com/web-development/mastering-typescript).
  prefs: []
  type: TYPE_NORMAL
- en: Let's remind ourselves that the project started around 2010 as a response to
    the growing popularity of JavaScript—not only in the browsers, but also on the
    servers. This means writing applications with not just hundreds of thousands,
    but sometimes millions of lines of code. The language itself lacks some features
    that we're accustomed to in large-scale application developments.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, until ECMAScript 2015, we didn't have classes or modules
    or any static type system. This static type system is exactly what empowers tools
    such as V. Studio, Eclipse, JetBrains, and others to enable those features that
    we're used to in the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to that static type system, TypeScript offers developers experiences
    parallel to those we would have using the C# language, and that includes debugging,
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: As for debugging, TypeScript does not present any extra configuration or difficulties.
    Since it transpiles to plain JavaScript, all typical resources for JavaScript
    are usable here as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially useful when using the embedded debugger of Visual Studio
    because you can set breakpoints in the TypeScript code as well (not only in JavaScript)
    and debug, as always, watching values at runtime and inspecting elements involved
    in the process.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the previous code that we used in [Chapter 4](part0028.xhtml#aid-QMFO2
    "Chapter 4. Comparing Approaches for Programming"), *Comparing Approaches for
    Programming*, we can mark a breakpoint in the `sorted.map` call and watch the
    values of every element in the array, check the value of this, have access to
    the `Globals` definition, and—in general—witness all the goodness we would expect
    in a complete, extended, debugging session.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that you have to use Internet Explorer (the default browser for
    Visual Studio).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use Edge as the default browser if you attach the Visual Studio
    debugger to the process in this manner using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the execution and go to the **Visual Studio Debugger** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the **Attach to Process** option, and in the dialog box, select the **Attach
    to** option to mark Script code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the list of processes, select the **MicrosoftEdgeCP.exe** process
    in the list and mark a breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you reload the page, the execution will stop at the breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, you can use Chrome to debug TypeScript code inside as well!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging TypeScript with Chrome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just open the previous code using Chrome as the navigator of your choice. Then,
    press *F12*, and you will get access to the **Sources** tab. From there, select
    the `app.ts` file and mark any line with a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you reload the page, you will discover how the code stops in the TypeScript
    line you marked, and all variables and objects implied in the execution are perfectly
    available. The next screenshot illustrates this excellent feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging TypeScript with Chrome](img/image00585.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Firefox doesn't support the `insertAdjacentElement` method. You should
    use `appendChild` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces and strong typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's think of a more complex object similar to a C# object, containing a field,
    methods with more than one signature (overloaded), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can declare a `Calculator` interface with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The notion of state is provided with an optional increment field (the same syntax
    as in C#), and four methods are defined. The first two are standard declarations,
    but the other two deserve a review.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add` method is overloaded. We have two definitions: one that gets a number
    and another with no arguments (both return void). When using an object that implements
    the `Calculator` interface, we''ll discover that the editor recognizes overloading
    just as we would expect from a similar object programmed in C# (refer to the next
    figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interfaces and strong typing](img/image00586.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the `new` method is the way we define a constructor inside an interface.
    This constructor receives a string but returns `Element`. `Element` is, in turn,
    defined as an interface that represents an object in a document ([https://developer.mozilla.org/en-US/docs/Web/API/Element](https://developer.mozilla.org/en-US/docs/Web/API/Element)).
    It's something that belongs to the DOM (Document Object Model); so, with TypeScript,
    we can manage almost any DOM component, just like we could in plain old JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most evolved languages allow the concept of namespace. A namespace permits the
    developer to create areas of code that are totally separated from each other,
    avoiding the collision of member's names and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript includes this concept using the `module` keyword. A module is a fragment
    of JavaScript whose members are private to the module. That is, they're not available
    outside the module unless we declare them in an explicit manner. This is something
    we do using the export keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a module is declared using a simple, intuitive syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, the module''s exported members are accessible using the dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Module declarations also admit several levels of indentation to clearly separate
    different areas of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify access to nested modules, we can also define an alias with the
    `import` keyword, which is especially useful when areas tend to grow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Declarations, scope, and Intellisense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must not assume that objects created by the "context" (the browser or the
    user agent) are accessed in TypeScript by default. For example, the document object
    that a navigator creates to represent the DOM is not strictly part of the language.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's very easy to make these members accessible simply by declaring
    them using the **declare** keyword. Also, for this case, the TypeScript compiler
    automatically supplies a declaration because by default, it includes a `'lib.d.ts'`
    file, which provides interface declarations for the built-in JavaScript library
    as well as the Document Object Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the official documentation says, if you want additional help for other libraries,
    all you have to do is declare them, and the corresponding `.ts` library will be
    used. Imagine that we want to change the title of the document; according to the
    earlier code, we should write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need support for jQuery, to mention a popular library, all we have to
    do is declare it in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From this point, any reference to the `$` symbol will offer the expected Intellisense
    in the editor provided that the description file for this library has been referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Scope and encapsulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other important concepts in relation to the scope and visibility of members
    are the namespace and module declarations. A namespace allows the programmer to
    declare private members to a named module, making them invisible for the code
    not being included inside; so, they're similar to the concept of namespace that
    we've already seen and that is typical in .NET programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to expose any member of a namespace, the exports keyword allows
    such definition so that we can have a partially exposed namespace with private
    members. For instance, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we check this code inside Visual Studio, we'll see an advice from the compiler
    as we pass over the last sentence, indicating that property `insideStr` doesn't
    exist inside the `MyNS` module (which really means that from a namespace perspective,
    this member is not declared accessible or maybe it doesn't exist).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, no advice is given in reference to the exposed greeter method,
    since the exports clause was used in its declaration (for other OOP languages,
    we would say that the greeter member is public).
  prefs: []
  type: TYPE_NORMAL
- en: '![Scope and encapsulation](img/image00587.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Classes and class inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen, classes are a key part of TypeScript, and their declaration syntax
    is almost identical to the C# declarations we all know.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we can declare private members, customized constructors, methods,
    access properties, and even static members so that they can be accessed using
    the name of the class instead of a variable instance. Take a look at this code
    written by Anders Hejlsberg in an online demo and published by Channel 9 ([https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript](https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript),
    in case you want to follow all the details and comments that this author provides):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there's a color declaration using the `private` keyword, a customized
    constructor, a read-only property (get `distanceP`), and a static declaration
    (`origin`) to establish the initial point of drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, there is a variant of the { get; set; } construction of C# in the
    class' constructor, which allows you to simplify declarations and assign an initial
    value to the constructor's arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this syntax, we can write a simplified variation of the previous class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, in order to properly implement OOP, we also need inheritance. Inheritance
    is achieved using the `extends` keyword in the declaration of a class. So, we
    can define a new, inherited version of the previous class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The previous code uses another specific keyword here, `super`, in order to refer
    to the parent class. There's much more to the language, and we recommend the detailed
    documentation found at GitHub ([https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md))
    for more details and code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Greeter class discussed in the initial demo, the `start()` and `stop()`
    methods didn''t have any return value. You can express a return value for a function
    in exactly the same way as we do with parameters: appending a colon (`:`) at the
    end, thus allowing us to express the whole signature of any function. So, for
    the typical `add` function, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'One the most common practices in the language is to use interfaces to declare
    user-defined object types. Once declared, the interface will be checked against
    any member proclaiming its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `age` is declared with the same syntax as what we used with
    C# for optional values, except that no default value is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can declare a type and assign it a value in the same sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we declare a function using the lambda expression as one of the argument''s
    syntaxes, the compiler infers that the type of the argument is a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it is displayed in the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions](img/image00588.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'An interface may allow you also to declare method overloading. Take a look
    at this declaration and note the double definition for the `doSomething` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A variant of the previous declaration allows us to declare overloading and
    include a data field for the `doSomething` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, we can refer `Thing3` using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see how the three different references to the overloaded forms
    of `doSomething` are considered valid by the compiler. We even have the possibility
    of declaring constructors and indexers (much like in C#):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possibility is based on TypeScript''s ability of defining an interface
    to enforce the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I want you to check the definition of any member, remember that right-clicking
    and selecting "**Go to Definition**" will open the corresponding `lib.d.ts` file
    and show the original definition of any member; for example, the `clientX` member
    of the `event` object will show the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions](img/image00589.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the same way, we can import declarations from other libraries and use this
    technique to check those implementations: this includes jQuery, Bootstrap, and
    so on. The site Definitely Typed ([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped))
    holds hundreds of these definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, there is still another way to declare overloaded functions: you can
    declare several signature methods and finish the block with a real function definition
    and implementation. This is done in order to avoid TypeScript from showing errors
    at compile time, although the final implementation in JavaScript will only consist
    of one function given that JavaScript doesn''t have types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, the previous definitions are taken as overloaded versions of the
    last definition, such as what is shown in the next piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Arrays and interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use the concept of interface to declare conditions, types, and behaviors
    related to array elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this code in which we enforce type and behavior for an array
    of mountains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `Mountain` interface makes sure that every element belonging to the `mountains`
    array actually implements the `Mountain` definition so that it can be compared
    later, which is something you can check if you include this code in an HTML script
    section. In the Console output, the "Denali" mountain is correctly sorted to be
    the highest by the `sort` method of the array.
  prefs: []
  type: TYPE_NORMAL
- en: More TypeScript in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, let''s take a look at some more TypeScript in action, starting with some
    other simple code. After creating an empty solution in Visual Studio and adding
    a JavaScript file (a `.js` extension), here, I''m using a code pattern offered
    in several demos on the official site in order to illustrate some changes these
    tools can offer. So, I type the following (a short function to sort an array and
    return the results):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we pass the mouse over the `arg` argument, the editor is unable to tell
    anything about the type of argument (with only this code, it is impossible to
    know anything else). If we write `sortByName` a couple of lines after the function,
    the editor recognizes the name, but it can''t add any more information about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More TypeScript in action](img/image00590.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's add a new file of the same name and copy the contents of the previous
    file inside, only changing the extension to `.ts` (TypeScript). Even with exactly
    the same content, the editor's behavior changes.
  prefs: []
  type: TYPE_NORMAL
- en: First, when you now pass the cursor over the argument, it says that it's of
    type `any`. This happens when you pass over the s`ortByName` declaration outside
    the function as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it can get even better. Since the function expects you to operate
    with an array of a type that has a `name` and `age` property, we can declare that
    object as an interface which includes both properties, such as a `Person` interface
    (or any other interface that complies with this requirement). Now, we can explicitly
    define that `arg` is an array of type `Person`, indicating it in the argument
    declaration after a colon, so we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And here, the magic starts to happen. When I pass the cursor over the argument,
    it now indicates the type it should receive, but also, if I hover over the `arg.slice(0)`
    code fragment, it gives me a detailed explanation of what it expects to receive,
    and when I move my cursor down, I see that there's a red squiggle under the `localCompare`
    method call, signifying that such a method doesn't exist on type string (because
    it recognizes that name is of the type defined previously).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see both hints in the following (compound) screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More TypeScript in action](img/image00591.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, there's a bunch of extra information available just by making a few changes
    in the code in order to instruct TypeScript about the types we're dealing with.
    We see this if we try to rewrite the `name.local…` call in the search for help.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do this, and retype the sentence, when we press the dot symbol next to
    `return.name`, we''ll be given a list of possible values that the `name` property
    admits, including the correct form of writing the sentence that was misspelled,
    as shown in the next screenshot. We also see extra information about the parameters
    that `localeCompare` should receive and the number of overloads that it defines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More TypeScript in action](img/image00592.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Actually, since TypeScript supports advanced features, you can use them right
    now with total backward compatibility: for instance, we can change the function
    argument we pass to the sort method into a lambda expression, just as if we were
    using ECMAScript 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the entire example. We'll define an array of hardware appliances
    along with their prices and identification numbers. The target is to sort the
    array by name and dynamically generate an output in a page, showing the names
    and prices in the sorted array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code we''ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, the `Entity` declaration guarantees that the later array definition of
    type `Entity[]` is recognized by the editor. At the time of putting everything
    together, the `window.onload` event uses a lambda expression with no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of this expression, a sorted array is produced from the original
    definition, and then the new `map` method included in JavaScript 5 is called,
    allowing us to pass a callback function to be executed for every element in the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we use a lambda expression to define the callback function, where `e`
    will represent—sequentially—the elements of the array (`entities`). We will have
    Intellisense in the edition even when using the properties of `e` so that we ensure
    that all members end up correctly spelled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution shows the list of elements, ordered by name, including the `name`
    and `price` fields, just as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More TypeScript in action](img/image00593.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The DOM connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The "DOM connection" we mentioned earlier is very helpful in a variety of cases.
    Imagine that we want an alert dialog indicating the X coordinate of the mouse
    when the cursor moves over the window. We could program something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass the mouse over the `e` argument (representing the event object),
    we''ll be shown a tooltip containing the event definition as well. And if we write
    `e.` (dot)…, Intellisense will again show up knowing exactly what can be done
    with that object. (Refer to the following figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DOM connection](img/image00594.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Where does this extra Intellisense come from? We have the ability to check this
    feature in the same manner as we would in other languages in Visual Studio. Just
    mark `onmousemove` or the `e` object, and in the contextual menu, select **Go
    to Definition** or **Peek definition**.
  prefs: []
  type: TYPE_NORMAL
- en: The IDE opens a new window pointing to the definition extracted from a file
    called `Lib.d.ts` and shows every detail. As mentioned previously, this file is
    the declaration file for the entire DOM and all the JavaScript's standard runtime
    libraries (it contains about 8,000 lines of code declarations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, anyone can write these declaration files and upload them to the DefinitelyTyped
    site, since its completely open source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DOM connection](img/image00595.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let''s summarize some of the most important points discussed up until this
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: We count on a formalization of the JavaScript types that allow excellent edition
    tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We find type inference and structural typing since the very beginning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It all works with existing JavaScript, with no modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the code is compiled, everything goes away, and the resulting code is nothing
    but plain JavaScript of the version of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through some of the most important projects that Microsoft
    promotes as part of its Open Source ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: First, we reviewed the evolution of "open source" projects since the initial
    movements and revised some of the new tools and technologies under the open source
    initiatives, including how to program with Node.js from Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we moved on to the Roslyn set of tools and services and explored how to
    install the tools, identify the Syntax Object Model, and program a basic analyzer
    with code refactoring capabilities and understand how to debug it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we took a tour of the main language features of TypeScript, studying
    some of the most meaningful and proper definitions of the language and checking
    the excellent support we get in the code editor thanks to its static type system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover the concept of Software Architecture, from
    high-level abstract concepts to low-level implementation. I will outline a step-by-step
    guide on designing a .NET application from the ground up.
  prefs: []
  type: TYPE_NORMAL
