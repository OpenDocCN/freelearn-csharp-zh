# 优化您的艺术资产

艺术是一个著名的具有主观性的学科，由个人意见和偏好主导。很难说一件艺术品是否比另一件更好，以及为什么更好。很多时候，我们的意见无法达成完全一致。支持游戏艺术性的艺术资产背后的技术方面也可能非常主观。可以实施多种解决方案来提高性能，但这些通常会导致为了速度而牺牲质量。如果我们试图达到最佳性能，那么在决定对艺术资产进行任何更改时，我们必须咨询团队成员，因为这主要是一个平衡行为，这本身也可以是一种艺术形式。

无论我们是在尝试最小化运行时内存占用、保持尽可能小的可执行文件大小、最大化加载速度，还是保持帧率的稳定性，都有许多选项可以探索。一些方法显然总是理想的，但大多数方法在采用之前需要更多的关注和预先思考，因为它们可能会导致质量下降或增加其他子系统出现瓶颈的可能性。

在本章中，我们将探讨如何提高以下资产类型的性能：

+   音频文件

+   纹理文件

+   网格和动画文件

+   资产包和资源

在每种情况下，我们将研究 Unity 在应用构建时间和运行时如何存储、加载和处理这些资产。我们还将检查在性能问题发生时的选项，以及我们可以采取哪些措施来避免可能产生性能瓶颈的行为。

# 音频

作为一种框架，Unity 可以用来构建任何东西，从只需要少量音效和一条背景音乐的简单应用，到需要数百万行对话、音乐轨道和环境音效的庞大角色扮演游戏。无论应用的实际范围如何，音频文件在构建完成后通常都是应用大小的一个重要组成部分（有时也称为其 *磁盘占用*）。此外，许多开发者惊讶地发现，运行时音频处理可以变成 CPU 和内存消耗的一个重大来源。

音频在游戏行业的两个层面都常常被忽视：开发者往往直到最后一刻才投入资源，而用户很少关注它。当音频处理得当的时候，没有人会注意到，但我们都知道糟糕的音频是什么样的——它立刻就能辨认出来，令人不快，并且肯定会引起不必要的注意。这使得在性能的名义上牺牲过多的音频清晰度变得至关重要。

音频瓶颈可能来自各种来源。过度的压缩、过多的音频处理、过多的活跃音频组件、不高效的内存存储方法以及访问速度都会导致内存和 CPU 性能下降。

幸运的是，只需一点努力和理解，你就可以学会避免这些问题。在接下来的章节中，我们将学习一些有用的技巧，以帮助我们避免用户体验灾难。我们将学习如何在不同音频加载选项中进行选择，如何为我们的游戏选择正确的音频格式，以及一些其他相关的性能调整。

# 导入音频文件

当我们在项目窗口中选择导入的音频文件时，检查器窗口将显示多个导入设置。这些设置决定了从加载行为、压缩行为、质量、采样率，以及（在 Unity 的后续版本中）是否支持环绕声音频（多声道音频，通过球谐函数组合轨道以创建更真实的音频体验）等各个方面。

许多音频导入选项可以根据平台进行配置，使我们能够在不同的目标平台之间自定义行为。

# 加载音频文件

以下是如何加载音频文件的三种设置：

+   预加载音频数据

+   在后台加载

+   加载类型

![图片](img/37aa4295-17e2-481c-97b0-0d03f5de0d70.png)

在检查器中查看导入文件时，我们所看到的内容。

我们的音频文件最初是以二进制数据文件的形式打包的，这些文件与应用程序捆绑在一起，位于设备的硬盘上（尽管在某些情况下它们是从互联网上的某个地方下载的）。**加载**音频数据简单地说就是将其拉入主内存（RAM），以便它可以稍后由音频解码器处理，解码器然后将数据转换为音频信号，传递到我们的耳机或扬声器。然而，加载的方式将根据前三个设置而有很大差异，如下所示：

+   第一个设置，**预加载音频数据**，决定了音频数据是否会在场景初始化期间或稍后自动加载。

+   当音频数据的加载发生时，第二个设置，**在后台加载**，决定了这项活动是否会在完成之前阻塞主线程，或者异步地在后台加载。

+   最后，**加载类型**设置定义了将哪种类型的数据拉入内存，以及每次拉入多少数据。

如果使用不当，这三个设置都可能对性能产生严重影响。

音频文件的典型用途是将它分配给`AudioSource`组件的`AudioClip`属性，这将把它包裹在一个`AudioClip`对象中。然后我们可以通过`AudioSource.Play()`或`AudioSource.PlayOneShot()`触发播放。以这种方式分配的每个音频剪辑都会在场景初始化期间加载到内存中，因为场景包含对这些文件的直接引用，它必须在需要之前解决这些引用。这是在启用预加载音频数据时的默认行为。

禁用“预加载音频数据”会告诉 Unity 引擎在场景初始化期间跳过音频文件资产的加载，将加载活动推迟到第一次需要的时候——即调用`Play()`或`PlayOneShot()`时。禁用此选项将加快场景初始化速度，但这也意味着我们第一次播放文件时，CPU 需要立即访问磁盘，检索文件，将其加载到内存中，解压缩它，然后播放。这是一个同步操作，并且将在完成之前阻塞主线程。我们可以通过一个简单的测试来证明这一点：

```cs
public class PreloadAudioDataTest : MonoBehaviour {
  [SerializeField] AudioSource _source;

  void Update() {
    if (Input.GetKeyDown(KeyCode.Space)) {
        using (new CustomTimer("Time to play audio file", 1)) {
        _source.Play();
    }
  }
}
```

如果我们在场景中添加一个`AudioSource`对象，将其分配给一个大型音频文件，并将其分配给`PreloadAudioDataTest`组件的`_source`字段，我们可以按空格键并查看`Play()`函数完成所需的时间。对这个代码进行一个简单的测试，使用一个 10-MB 的音频文件并启用预加载音频数据，将显示调用几乎是瞬间的；然而，禁用预加载音频数据，应用对文件所做的更改，并重复测试将显示它需要更长的时间（在配备 Intel i5 3570K 的桌面 PC 上大约为 700 毫秒）。这完全超出了我们单帧的预算，因此为了负责任地使用这个切换，我们需要在事先将大部分音频资产加载到内存中。

这可以通过调用`AudioClip.LoadAudioData()`（可以通过`AudioSource`组件的`clip`属性获取）来实现。然而，这项活动仍然会阻塞主线程，所需的时间与上一个例子中加载它的时间相同，因此无论我们选择提前加载还是不加载，加载我们的音频文件仍然会导致帧率下降。数据也可以通过`AudioClip.UnloadAudioData()`卸载。

这就是“在后台加载”选项的作用所在。这个选项将音频加载改为异步任务，这意味着加载不会阻塞主线程。启用此选项后，对`AudioClip.LoadAudioData()`的实际调用将立即完成，但请注意，文件将在单独的线程上加载完成后才能播放。我们可以通过`AudioClip.loadState`属性来双重检查`AudioClip`组件当前的加载状态。如果启用“在后台加载”，并且我们在没有先加载数据的情况下调用`AudioSource.Play()`，Unity 仍然需要在播放之前将文件加载到内存中，因此当我们调用`AudioSource.Play()`和音频文件开始播放之间会有延迟。如果我们试图在文件完全加载之前访问声音文件，这可能会引入令人不快的操作，导致它与其他任务（如动画）不同步。

现代游戏通常在关卡中实现方便的停止点以执行加载或卸载音频数据等任务——例如，楼层之间的电梯或发生最小动作的长走廊。涉及通过这些方法进行自定义加载和卸载音频数据解决方案需要根据特定游戏量身定制，具体取决于何时需要音频文件、需要多长时间、场景如何组合以及玩家如何穿越它们。 

这可能需要大量的特殊情况更改、测试和资产管理调整，因此建议您将此方法保存为*终极选项*，在所有其他技术未能达到预期效果时，在生产后期使用。

最后，还有加载类型选项，它决定了音频数据加载时的方式。有三个选项可供选择：

+   加载时解压缩

+   内存中压缩

+   流式传输

以下列表中详细解释了这三个选项：

+   加载时解压缩：此设置在磁盘上压缩文件以节省空间，并在首次加载时将其解压缩到内存中。这是加载音频文件的标准方法，在大多数情况下应使用。解压缩文件需要一些时间，这会导致加载时产生一些额外的开销，但减少了播放音频文件时所需的工作量。

+   压缩内存中：此设置在加载时直接将压缩文件从磁盘复制到内存中。它仅在运行时播放音频文件时进行解压缩。当音频剪辑播放时，这会牺牲运行时的 CPU 资源，但可以提高加载速度并减少音频剪辑处于休眠状态时的运行内存消耗。因此，此选项最适合经常使用的非常大的音频文件，或者如果我们对内存消耗有极大的瓶颈，并且愿意牺牲一些 CPU 周期来播放音频剪辑。

+   流式传输：最后，这个设置（也称为*缓冲*）将在运行时动态加载、解码和播放文件，通过逐渐将文件推入一个只有一小部分文件在内存中存在的小缓冲区。这种方法对特定音频剪辑使用的内存最少，但运行时 CPU 使用量最大。由于每个文件的播放实例都需要生成其缓冲区，因此这个设置带来了不幸的缺点，即需要多次引用音频剪辑，导致内存中存在多个相同的音频剪辑副本，这些副本都必须单独处理，从而在使用不当的情况下产生运行时 CPU 成本。因此，此选项最好保留用于单实例音频剪辑，这些音频剪辑经常播放，并且永远不会需要与其他实例或甚至与其他流式传输音频剪辑重叠——例如，此设置最好用于在场景大部分生命周期内需要播放的背景音乐和环境音效。

因此，让我们回顾一下。默认情况下，启用预加载音频数据，禁用后台加载，以及加载类型为“加载时解压缩”，会导致场景加载时间较长，但确保我们在需要时场景中引用的每个音频剪辑都立即准备好。当需要音频剪辑时，不会有加载延迟，并且音频剪辑将在我们调用`Play()`时立即播放。

为了提高场景加载时间，一个良好的折衷方案是对于之后才需要的音频剪辑启用“在后台加载”，但不应为此类在场景初始化后不久就需要音频剪辑的情况使用。然后我们可以通过手动调用`AudioClip.LoadAudioData()`和`AudioClip.UnloadAudioData()`来控制音频数据的加载时间。我们应该愿意在单个场景中使用所有这些方法以达到最佳性能。

# 编码格式和质量级别

Unity 支持三种通用的音频剪辑编码格式，这些格式由我们在检查器窗口中查看音频剪辑属性时的“压缩格式”选项确定：

+   压缩（此选项的实际文本可能因平台而异）

+   PCM

+   ADPCM

我们导入 Unity 引擎的音频文件可以是许多流行的音频文件格式之一，如 Ogg Vorbis、MPEG-3（MP3）和 Wave，但实际打包到可执行文件中的编码将被转换为不同的格式。

使用压缩设置的压缩算法将取决于目标平台。独立应用程序和其他非移动平台将文件转换为 Ogg Vorbis 格式，而移动平台使用 MP3。

有些平台始终使用特定的压缩类型，例如 PS Vita 的 HEVAG、Xbox One 的 XMA 和 WebGL 的 AAC。

统计数据在“检查器”窗口中提供，位于“压缩格式”选项之后，为您提供了压缩节省磁盘空间的大致想法。请注意，第一个值显示原始文件大小，第二个值显示磁盘上的大小。音频文件在加载后运行时将消耗多少内存将由所选压缩格式的效率决定——例如，Ogg Vorbis 压缩通常可以解压缩到其压缩大小的约十倍，而 ADPCM 可以解压缩到其压缩大小的约四倍。

检查器窗口中显示的音频文件成本节省仅适用于当前选定的平台和最近使用的设置。请确保在“文件”|“构建设置”中将编辑器切换到正确的平台，并在更改后点击“应用”，以查看当前配置的实际成本节省（或成本膨胀）。这对于 WebGL 应用程序尤为重要，因为 AAC 格式通常会导致音频文件大小大幅膨胀。

所使用的编码/压缩格式对音频文件在运行时的质量、文件大小和内存消耗有显著影响，只有压缩设置允许我们在不影响文件采样率的情况下调整质量。同时，PCM 和 ADPCM 设置不提供这种便利，我们只能接受这些压缩格式决定的文件大小——也就是说，除非我们愿意为了文件大小而降低音频质量，减少采样率。

在下表中，您可以快速了解每种格式的区别和使用场景：

| **格式** | **无损** | **大小** | **质量** | **用途** |
| --- | --- | --- | --- | --- |
| **PCM** | 是 | 大 | 高 | 非常短的声音效果，需要很高的清晰度，任何压缩都会扭曲体验。 |
| **ADPCM** | 否 | 非常小 | 差 | 压缩会产生相当多的噪声，因此它用于具有大量混乱的短声音效果，例如爆炸、碰撞和冲击声。 |
| **压缩** | 否 | 小/中 | 可变 | 这会消耗更多的 CPU 解码资源，因此在大多数情况下应使用。此选项允许我们自定义压缩算法的结果质量级别，以调整质量与文件大小的平衡。 |

请记住，在运行时应用于文件的任何额外音频效果在*编辑模式*中都不会通过编辑器播放，因此任何更改都应该通过*播放模式*中的应用程序彻底测试。 

现在我们对音频文件格式、加载方法和压缩模式有了更好的理解，让我们探讨一些可以通过调整音频行为来提高性能的方法。

# 音频性能提升

在本节中，我们将探讨一些其他的小但重要的增强功能，您可以将它们添加到游戏的声音架构中，以改善整体玩家体验。我们将了解为什么在场景中减少音频源很重要，在什么情况下我们应该优先选择单声道声音而不是立体声音响，我们应该在什么情况下优先选择流式传输而不是预加载，以及更多。

# 最小化活动音频源数量

由于每个正在播放的音频源都会消耗特定的 CPU 资源，因此我们可以通过在场景中禁用冗余音频源来节省 CPU 循环。一种方法是通过一个中介发送音频播放请求，该中介以这种方式控制我们的音频源，从而对可以同时播放的音频剪辑实例数设置一个硬上限。

几乎在 Unity Asset Store 中可用的所有音频管理资源都实现了某种形式的音频节流功能（通常称为 *音频池化*），这有很好的理由：这是在最小化过度音频播放的同时，以最低的质量成本进行权衡的最佳方案——例如，同时播放 20 个脚步声听起来不会与同时播放 10 个有太大区别，并且不太可能因为声音太大而分散注意力。因此，出于这个原因，并且因为这些工具通常提供许多更细微的性能增强功能，建议您使用现有的解决方案，而不是自己开发，因为需要考虑的复杂性很多，包括音频文件类型、立体声/3D 音频、分层、压缩、过滤器、跨平台能力、高效内存管理等等。

当涉及到环境音效时，它们仍然需要放置在场景中的特定位置，以便利用对数音量效果，这给它带来一种伪 3D 效果，因此音频池化系统可能不是理想的解决方案。限制环境音效的播放最佳方法是通过减少音频源的总数。最佳方法是移除其中一些，或将它们减少到一个更大、更响亮的音频源。自然地，这种方法会影响用户体验的质量，因为看起来声音似乎来自单个源而不是多个源；因此，应谨慎使用。

# 为 3D 声音启用强制单声道

在立体声音频文件上启用“强制单声道”设置会将两个音频通道的数据混合到一个通道中，从而有效地节省 50%的文件总磁盘和内存空间使用量。对于一些立体声音效，其中立体声效果通常用于创造特定的音频体验，启用此选项通常不是一个好主意；然而，我们可以为一些 3D 位置音频剪辑启用此选项，在这些剪辑中，两个通道实际上是相同的。这些音频源类型将允许音频源和玩家之间的方向决定音频文件如何播放到左右耳朵，在这种情况下播放立体声效果通常是没有意义的。

如果不需要立体声效果，将 2D 声音（无论距离/方向如何，都以全音量播放到玩家的耳朵中的声音）强制转换为单声道可能也有意义。

# 重采样到更低频率

将导入的音频文件重采样到更低频率将减小文件大小和运行时内存占用。这可以通过将音频文件的采样率设置设置为“覆盖采样率”来实现，此时我们可以通过采样率选项配置采样率。一些文件需要高采样率才能听起来合理，例如高音调文件和大多数音乐文件；然而，在大多数情况下，较低的设置可以减小文件大小，而不会引起明显的质量下降。大多数使用 22,050 赫兹的采样率用于涉及人类语音和古典音乐的源；一些音效可能能够以更低的频率值逃脱。然而，每个音效都会以独特的方式受到此设置的影响，因此在最终决定采样率之前，花一些时间进行一些测试是明智的。

# 考虑所有压缩格式

如前所述，压缩、PCM 和 ADPCM 压缩格式各自都有其优势和劣势。根据不同文件的需要，使用不同的编码格式可以在内存占用、磁盘占用、CPU 使用率和音频质量方面做出一些妥协。我们应该愿意在同一个应用程序中使用所有这些格式，并制定一个适用于我们使用的音频文件类型的系统，这样我们就不需要单独处理每个文件；否则，我们需要进行大量的测试以确保每个文件的音频质量没有下降。

# 谨慎对待流媒体

流式加载类型的优点是运行时内存成本低，因为分配了一个小的缓冲区，文件就像数据队列一样连续通过它。这看起来相当吸引人，但应该仅将磁盘上的流式文件限制在大型单实例文件上，因为它需要运行时硬盘访问，这是我们可用的最慢的数据访问形式之一（仅次于通过网络拉取文件）。使用流式选项，分层或过渡的音乐片段可能会遇到严重的故障，这时考虑使用不同的加载类型并手动控制加载/卸载将是明智的。

我们还应该避免同时流式传输多个文件，因为这很可能会在磁盘上造成大量的缓存未命中，从而中断游戏玩法。这就是为什么这个选项主要用于背景音乐/环境声音效果，因为我们一次只需要一个。

# 通过混音组应用过滤器效果以减少重复

可以使用过滤器效果来修改通过音频源播放的声音效果，并且可以通过`FilterEffect`组件实现。每个单独的过滤器效果都会消耗一定量的内存和 CPU，这是一种在保持音频播放大量多样性的同时实现磁盘空间节省的好方法，因为一个文件可以通过不同的过滤器集进行调整，从而生成完全不同的声音效果。

由于额外的开销，在场景中过度使用过滤器效果可能会导致性能严重下降。更好的方法是利用 Unity 的音频混音实用工具（窗口 | 音频 | 音频混音）来生成多个音频源可以引用的常用过滤器效果模板，以最小化内存开销。

在[`learn.unity.com/tutorial/audio-mixing`](https://learn.unity.com/tutorial/audio-mixing)的官方教程中，对音频混音的主题进行了详尽的介绍。

# 负责任地使用远程内容流式传输

通过 Unity，可以动态加载游戏内容，这可以是一种有效的方法来减少应用程序的磁盘占用，因为需要捆绑到可执行文件中的数据文件更少。这也提供了一种使用网络服务来确定在运行时向用户展示什么内容的方法。在 Unity 2017 及以后的版本中，可以通过`UnityWebRequest`类实现资产流式传输。

`UnityWebRequest`类使用了新的 HLAPI 和 LLAPI 网络层。这个类提供了各种工具来下载和访问主要是文本文件的内容。基于多媒体的请求应通过`UnityWebRequestMultimedia`辅助类进行。因此，如果请求`AudioClip`，我们应该调用`UnityWebRequestMultimedia.GetAudioClip()`来创建请求，并在下载完成后使用`DownloadHandlerAudioClip.GetContent()`来检索它。

这个 API 的新版本旨在在存储和提供我们请求的数据方面更加高效，因此通过`DownloadHandlerAudioClip.GetContent()`多次重新获取`AudioClip`不会导致额外的分配。相反，它只会返回对最初下载的`AudioClip`的引用。

# 考虑使用音频模块文件作为背景音乐

音频模块文件，也称为**跟踪模块**，是一种在不损失明显质量的情况下节省大量空间的绝佳方式。Unity 支持以下文件扩展名：`.it`、`.s3m`、`.xm`和`.mod`。与常见的音频格式不同，这些格式像位流一样被读取，必须在运行时解码以生成特定的声音，而跟踪模块包含大量的小型、高质量样本，并像乐谱一样组织整个曲目，定义每个样本何时、何地、如何响亮、以何种音高以及使用何种特殊效果播放。这可以在保持高质量采样的同时提供显著的尺寸节省，因此，如果我们有机会使用音乐文件的跟踪模块版本，那么探索它是值得的。

# 纹理文件

在游戏开发中，*纹理*和*精灵*这两个术语经常被混淆，所以值得明确区分：纹理只是一个图像文件，一个包含颜色数据的大列表，告诉解释程序图像的每个像素应该是什么颜色，而精灵可以看作是网格的 2D 等价物——它定义了图像将在游戏场景中如何以及在哪里出现。通常，精灵只是一个单一的*四边形*（一对三角形组合成一个矩形网格），它以平面的方式渲染到当前相机上。

同样还有一些被称为精灵图集的东西，它们是包含在更大的纹理文件中的大量单个图像集合，通常用于包含 2D 角色的动画。这些文件可以通过工具如 Unity 的精灵图集工具分割开来，以形成角色动画帧的单独纹理。

当然，你可以在 3D 环境中渲染 2D 精灵；然而，本质上，精灵仍然是一个 2D 元素，就像扑克牌即使用来搭建纸牌屋也仍然是平面的卡片一样。

网格和精灵都使用纹理在表面渲染图像。纹理图像文件通常在 Adobe Photoshop 或 GIMP 等工具中生成，然后以与音频文件相同的方式导入到我们的项目中。在运行时，这些文件被加载到内存中，推送到 GPU 的 VRAM 中，并在给定的绘制调用期间由着色器渲染到目标精灵或网格上。

# 纹理压缩格式

与音频文件类似，Unity 将以默认设置列表导入纹理文件，这些设置通常使事情保持简单，并在一般情况下表现良好，但有许多导入设置可供选择，允许我们通过一些自定义调整来提高纹理的质量和性能。当然，如果我们盲目地做出更改而不完全理解内部过程，那么做出更改同样可能导致质量和性能的降低。

第一个选项是文件的纹理类型。此设置将确定其他可用的选项，尤其是在高级下拉菜单下。并非所有导入选项都适用于所有类型，因此最好根据纹理的预期用途配置此选项，无论是设置为正常贴图、精灵、光照贴图等，因为这将揭示适合该类型的选项：

![图片](img/6d0b6b2d-afb7-4ade-9d9b-380415c75309.png)

与音频文件类似，我们可以导入多种常见的纹理文件格式（如`.jpg`和`.png`），但应用程序中实际嵌入的压缩格式可能是许多不同的纹理压缩格式之一，这些格式非常适合给定平台的 GPU。这些格式代表了组织纹理颜色信息的不同方式，包括以下内容：

+   用于表示每个通道的不同位数（使用的位数越多，可以表示的颜色就越多）

+   每个通道不同的位数（例如，红色通道可能比绿色通道使用更多的位数）

+   所有通道使用的总位数不同（位数越多，自然意味着更大的纹理和更多的磁盘和内存消耗）

+   是否包含 alpha 通道

+   也许最重要的是，数据打包的不同方式，这可以允许 GPU（或如果选择了错误的打包类型，则可能非常低效）进行高效的内存访问！

修改压缩的简单方法是使用压缩纹理导入选项来选择以下选项之一：

+   无

+   低质量

+   正常质量

+   高质量

选择“无”表示不会应用压缩。在这种情况下，最终的纹理仍然会从导入的文件类型转换为格式，但它将选择一种不尝试压缩的格式，因此我们应该看到在牺牲大纹理文件的情况下，质量损失很小或没有。其他三个设置将选择一个压缩格式，这同样会根据平台而变化，Unity 将尝试选择与选项匹配的压缩格式。例如，选择“低质量”意味着 Unity 将选择一个大大减少纹理大小的压缩格式，但会产生一些压缩伪影，而选择“高质量”将消耗更多内存，具有更大的纹理大小和最少的伪影。再次强调，这是 Unity 自动做出的选择。

Unity 为每个平台以及这些压缩设置选择的精确格式可以在[`docs.unity3d.com/Manual/class-TextureImporterOverride.html`](https://docs.unity3d.com/Manual/class-TextureImporterOverride.html)找到。

Unity 选择的精确压缩格式可以被覆盖，尽管由于实际上每个平台都有自己的最佳自定义格式，因此可用的选项因平台而异。如果我们点击默认选项卡（位于最大尺寸选项上方）旁边的特定平台选项卡之一，我们将暴露特定平台的设置，并可以选择 Unity 要使用的确切压缩格式。

此外，还有 Crunch Compression 设置，它将在 DXT 压缩格式之上应用额外的有损压缩级别。此选项仅在其他压缩设置导致 DXT 压缩级别时才会显示。此设置可以在牺牲可能显眼的压缩伪影的情况下节省更多空间，具体取决于压缩质量设置。

纹理的几个导入设置相当普通，例如确定文件是否包含 alpha 通道，如何在其边缘包裹纹理，过滤方法，以及文件的最大可能分辨率（一个全局限制，以防止我们意外地将纹理放大超过其原始大小，在某些平台上）。然而，在这些导入设置中还有一些其他有趣的选择，我们将在适当的部分中介绍。

# 纹理性能提升

让我们探讨一下我们可以对我们的纹理文件进行的更改，这些更改可能会根据情况以及我们导入的文件内容来提高性能。在每种情况下，我们将探讨需要进行的更改以及它们产生的总体影响，无论是正面还是负面对内存或 CPU 的影响，纹理质量的增加或减少，以及我们可以在什么条件下使用这些技术。

# 减少纹理文件大小

给定纹理文件越大，将消耗更多的 GPU 内存带宽，在需要时推动纹理。如果每秒推送到内存中的总量超过显卡的总内存带宽，那么我们将遇到瓶颈，因为 GPU 必须等待所有纹理上传完毕，才能开始下一个渲染过程。较小的纹理比较大的纹理更容易通过管道，因此我们需要在高质量和性能之间找到一个良好的平衡点。

一个简单的测试来确定我们是否在内存带宽上受到瓶颈的方法是降低我们游戏最大和最丰富的纹理文件分辨率并重新启动场景。如果帧率突然提高，那么应用程序很可能是受纹理吞吐量限制。如果帧率没有提高或提高很少，那么我们可能还有一些内存带宽可以利用，或者渲染管道中的其他地方存在瓶颈，阻止我们看到任何进一步的改进。

# 智能使用 mipmap

如果玩家永远无法看到这些细节，那么就没有必要用高细节纹理渲染小而远的物体，如岩石和树木。当然，他们可能会看到一些轻微的改进，但性能成本可能不值得细节的微小增加。mipmap 的发明是为了解决这个问题（以及帮助消除大约在同一时间困扰视频游戏的走样问题），通过预先生成相同纹理的较低分辨率的替代品，并将它们保存在相同的内存空间中。在运行时，GPU 根据表面在透视视图中的大小选择适当的 mipmap 级别（基本上是基于当对象被渲染时的 texel 到像素的比率）。

通过启用生成 Mipmap 设置，Unity 自动处理这些纹理的较低分辨率副本的生成。这些替代品是在编辑器中使用高质量的重采样和过滤方法生成的，而不是在运行时。还有其他几种可用于 mipmap 生成的选项，这些选项会影响生成的级别质量，因此可能需要一些调整才能获得高质量的 mipmap 集。我们需要决定花费在这些值上的时间是否值得，因为 mipmap 的整个目的就是有意降低质量，首先是为了节省性能。

以下图像显示了如何将 1024 x 1024 的图像 mipmap 到多个较低分辨率的图像的重复：

![图片](img/436083f8-d2a6-418c-88d0-90545e3bfd0b.png)

这些图像将被打包在一起以节省空间，本质上创建了一个最终纹理文件，该文件将比原始图像大 33%。这将消耗一些磁盘空间和 GPU 内存带宽来上传。

自从 Unity 2018.2 以来，还有另一种加载 mipmap 的方法：流式传输。正如音频案例中一样，mipmap 流式传输用于减少内存需求，以保持内存中多个 mipmap 纹理，同时不牺牲质量。实际上，如果我们启用 mipmap 流式传输，那么 Unity 将尝试根据场景中摄像机的位置动态地从磁盘加载纹理的正确分辨率。这可以根据场景（以及玩家的位置）节省高达 30%的纹理内存。

然而，这也有代价。首先，米级贴图的流式传输比生成慢；因此，如果你有瞬间的相机切换或者快速移动，你可能会开始注意到纹理质量的变化，因为米级贴图正在加载。这可以通过使用米级贴图流式传输 API 来缓解，以便在目标位置预加载米级贴图。

其次，目前可能并非所有平台都支持米级贴图流式传输。如果你想确保你的平台支持米级贴图流式传输，你可以检查`SystemInfo.supportsMipStreaming`属性。

如果你想了解更多关于纹理流的信息，你可以查看手册中的详细页面[`docs.unity3d.com/Manual/TextureStreaming-API.html`](https://docs.unity3d.com/Manual/TextureStreaming-API.html)。

你可以通过将场景窗口的绘制模式设置为米级贴图，在某些点上看到应用程序正在使用哪些米级贴图级别。如果纹理比根据玩家当前视图应该的大小更大（额外的细节被浪费了），则会用红色突出显示纹理；而用蓝色突出显示则意味着它们太小（玩家正在观察一个低质量的纹理，具有较差的像素比）。

记住，只有当我们有需要在相机不同距离处渲染的纹理时，米级贴图才有用。如果我们有始终在主相机以相同距离渲染的纹理，这样米级贴图的替代品永远不会被使用，那么启用米级贴图只是浪费空间。同样，如果我们恰好有一个始终解析到相同的米级贴图级别，因为玩家的相机永远不会太近或太远以切换级别，那么简单地降低原始纹理的分辨率会更明智。

这种情况的良好例子包括任何用于 2D 游戏的纹理文件，UI 系统使用的纹理，或者用于 Skybox 或远背景的纹理，因为这些纹理在设计上总是与相机保持相同的距离，所以米级贴图基本上是没有意义的。其他好的例子包括仅出现在玩家附近的物体，如以玩家为中心的粒子效果、角色、仅出现在玩家附近的物体，以及只有玩家可以持有/携带的物体。

# 外部管理分辨率降低

Unity 致力于使事物尽可能易于使用，并为我们提供了将来自外部工具的项目文件放置到我们的项目工作空间的能力，例如`.PSD`和`.TIFF`文件，这些文件通常很大，并且被分割成多个层级的图像。Unity 会自动从文件内容生成一个纹理文件，以便其余的引擎可以使用，这可以非常方便，因为我们只需要通过源控制维护文件的单一副本，当艺术家进行更改时，Unity 的副本会自动更新。

问题在于，Unity 从这些文件自动生成和压缩纹理引入的锯齿可能不如我们使用的纹理编辑工具为我们生成的效果。Unity 功能丰富，首先和最重要的是作为一个游戏开发平台，这意味着它在与其他软件开发人员全职工作的领域可能难以竞争。Unity 可能通过缩小图像为我们引入了锯齿伪影，因此我们可能发现自己通过导入比必要的更高分辨率的图像文件来绕过它，只是为了保持预期的质量水平；然而，如果我们首先通过外部应用程序缩小图像，我们可能遭受的锯齿伪影会少得多。在这些情况下，我们可能以较低的分辨率达到可接受的质量水平，同时消耗更少的总磁盘和内存空间。

我们可以养成在 Unity 项目中避免使用`.PSD`和`.TIFF`文件的习惯（将它们存储在其他地方并将缩放后的版本导入 Unity），或者只是偶尔进行一些测试以确保我们没有使用比必要的更高分辨率的文件浪费文件大小、内存和 GPU 内存带宽。这可能会在项目文件管理上给我们带来一些不便，但如果我们愿意花时间比较不同的缩放版本，这可能会为某些纹理节省一些显著的存储空间。

# 调整各向异性过滤级别

各向异性过滤是一种在纹理以非常斜角（浅角度）查看时提高纹理图像质量的功能。以下截图显示了应用和不应用各向异性过滤的绘制道路线条的经典示例：

![图片](img/6be0a82d-eefa-46a4-a0f1-cf73ecf345a8.png)

在任何情况下，靠近摄像机的绘制线条看起来相当清晰，但随着它们远离摄像机，情况会发生变化。没有各向异性过滤，远处的绘制线条会越来越模糊和扭曲，而应用了各向异性过滤的线条则保持清晰和清晰。

可以通过 Aniso Level 设置在每个纹理的基础上手动修改应用于纹理的各向异性过滤强度，以及通过 Edit | Project | Quality 设置中的 Anisotropic Textures 选项全局启用/禁用。

与 mipmap 类似，这种效果可能会很昂贵，有时甚至是不必要的。如果我们确定场景中的某些纹理永远不会以斜角（例如远处的背景对象、UI 元素和横幅粒子效果纹理）被查看，那么我们可以安全地禁用这些纹理的各向异性过滤以节省运行时开销。我们还可以考虑根据每个纹理调整各向异性过滤效果的强度，以找到质量和性能之间的最佳平衡点。

# 考虑使用纹理集

Atlasing 是将许多较小的、孤立的纹理组合成一个单独的大纹理文件的技术，以最小化所需的材质数量和绘制调用次数。这实际上是一种利用动态批处理的方法。从概念上讲，这种技术与你在第三章“批处理的好处”中学到的最小化材质使用的方法非常相似。

每种独特的材质都需要额外的绘制调用，但每种材质仅支持一个主纹理。当然，它们也可以支持多个次级纹理，例如法线贴图和发射贴图。然而，通过将多个主纹理组合成一个单独的大纹理文件，我们可以最小化渲染共享此纹理的对象所需的绘制调用次数：

![图片](img/26f35ace-e607-4955-94a9-15fd539ae6e8.png)

需要额外的工作来修改网格或精灵对象使用的 UV 坐标，以便仅采样它所需的大纹理文件的部分，但好处是显而易见的：减少绘制调用会导致 CPU 工作负载的减少，如果我们的应用程序在 CPU 上成为瓶颈，则帧率会提高。假设合并的纹理文件分辨率等同于所有组合图像的分辨率，将不会损失质量，内存消耗也将基本相同。请注意，图集化不会减少内存带宽消耗，因为推送到 GPU 的数据量也将是相同的。它只是恰好被捆绑在一个更大的纹理文件中。

只有当所有给定的纹理都需要相同的着色器时，Atlasing 才是一个选项。如果某些纹理需要通过着色器应用独特的图形效果，那么它们必须被隔离到它们自己的材质中，并在单独的组中进行图集化。

在 Unity 中开发移动游戏时，Atlasing 成为了一种常见的策略，尤其是在包含大量 2D 图形的游戏中。当在 Unity 中开发移动游戏时，由于绘制调用通常是这些平台上的最常见瓶颈，Atlasing 变得实际上至关重要。然而，我们并不希望手动生成这些图集文件。如果我们能够继续单独编辑我们的纹理并自动化将它们组合成更大文件的任务，生活将会简单得多。

Unity Asset Store 中的许多与 GUI 相关的工具都提供了自动纹理图集功能。互联网上散布着一些可以处理这项工作的独立程序，Unity 还可以以资产的形式生成精灵图集。这些可以通过访问“资产”|“创建”|“精灵图集”来创建。

查看 Unity 文档以了解更多关于这个有用功能的信息，请访问[`docs.unity3d.com/Manual/class-SpriteAtlas.html`](https://docs.unity3d.com/Manual/class-SpriteAtlas.html)。

注意，精灵图集功能实际上取代了 Unity 旧版本中的精灵打包工具。

地图纹理化也不必应用于 2D 图形和 UI 元素。如果我们碰巧在创建大量低分辨率纹理，我们可以将这项技术应用于 3D 网格。具有简单纹理分辨率或平面着色、低多边形艺术风格的 3D 游戏是这种方式进行地图纹理化的理想候选者。

然而，由于动态分批处理仅影响非动画网格（即`MeshRenderer`，但不包括`SkinnedMeshRenderer`），将动画角色的纹理文件组合到图集中是没有必要的。由于它们是动画的，GPU 需要将每个对象的骨骼乘以当前动画状态的变化。这意味着每个角色都需要进行独特的计算，并且无论我们尝试让它们共享材质，它们都会导致额外的绘制调用。

因此，将纹理组合用于动画角色应该仅作为方便和节省空间的措施；例如，在平面着色、低多边形艺术风格的游戏中，如果一切使用的是公共调色板，我们可以通过使用单个纹理来为整个游戏世界、物体和角色节省空间。

地图纹理化的缺点主要在于开发时间和工作流程成本。为了利用地图纹理化，需要对现有项目进行大量努力进行彻底的改造，这仅仅是为了确定是否值得付出这些努力，就可能是一项繁重的工作。此外，我们还需要注意生成对于目标平台来说过大的纹理文件。

一些设备（特别是移动设备）对可以拉入 GPU 最低内存缓存的纹理大小有相对较低的限制。如果图集纹理文件过大，则必须将其拆分为较小的纹理，以便适应目标内存空间。如果设备的 GPU 在每次绘制调用时都需要来自图集不同部分的纹理，那么我们不仅会引发大量的缓存未命中，还可能发现我们阻塞了内存带宽，因为纹理不断地从 VRAM 和低级缓存中拉取。

如果将图集保留为单独的纹理，我们可能就不会遇到这个问题。相同的纹理交换将会发生，但代价是额外的绘制调用，将导致交换的文件更小。在这个阶段，我们最好的选择可能是降低图集的分辨率或生成多个较小的图集，以便更好地控制它们如何动态分批处理。

纹理合成显然不是完美的解决方案，如果我们不确定它是否会带来性能上的好处，那么我们应该小心不要在其实施上浪费太多时间。非常一般地说，具有非常简单的 2D 艺术风格的移动游戏可能不需要使用纹理合成；然而，试图与高质量资产竞争或使用任何类型的 3D 图形的移动游戏可能应该从开发初期就开始整合纹理合成，因为项目很可能很快就会达到纹理吞吐量限制。他们甚至可能需要针对每个平台和每个设备进行许多优化，以便达到广泛的受众。

同时，我们应该考虑只有在我们的绘制调用次数超过合理的硬件预期时才将纹理合成应用于高质量桌面游戏，因为我们希望许多纹理保持高分辨率以获得最佳质量。低质量桌面游戏可能可以承担避免纹理合成的费用，因为绘制调用不太可能是最大的瓶颈。

当然，无论产品是什么，如果我们因为过多的绘制调用而受到 CPU 的限制，并且已经用尽了多种替代技术，那么在大多数情况下，纹理合成是一种非常有效的性能提升方法。

# 调整非方形纹理的压缩率

纹理文件通常以平方、2 的幂格式存储，这意味着它们的高度和宽度长度相等，其大小是 2 的幂——例如，一些典型的尺寸是 256 x 256 像素、512 x 512 和 1024 x 1024，等等。

提供矩形 2 的幂纹理（如 256 x 512）或非 2 的幂格式（如 192 x 192）是可能的，但创建这样的纹理是不推荐的。一些 GPU 需要平方纹理格式，因此 Unity 将通过自动扩展纹理以包括额外的空空间来适应 GPU 期望的格式，这将导致额外的内存带宽成本，将实际上未使用且无用的数据推送到 GPU。其他 GPU 可能支持非 2 的幂纹理，但这可能比平方纹理的采样速度慢。

因此，第一个建议是完全避免非方形和/或非 2 的幂纹理。如果图像可以放置在平方、2 的幂纹理中，并且不会因为挤压/拉伸而导致太多质量下降，那么我们应该只应用这些更改，以保持 CPU 和 GPU 的满意。作为第二个选项，我们可以通过 Unity 中的纹理文件`非 2 的幂`导入设置来定制这种缩放行为，尽管这是一个自动化的过程，它可能不会给我们带来预期的图形质量。

# 稀疏纹理

稀疏纹理，也称为**大纹理**或**瓦片纹理**，提供了一种在运行时从磁盘有效流式传输纹理数据的方法。相对而言，如果 CPU 的操作速度以秒为单位，那么磁盘的操作速度将以天为单位。因此，常见的建议是在游戏过程中应尽可能避免硬盘访问，因为任何此类技术都可能造成比可用更多的硬盘访问，导致我们的应用程序陷入停滞。

然而，如果我们聪明地提前开始传输纹理部分的数据，稀疏纹理提供了一些有趣的性能节省技术。稀疏纹理是通过将许多纹理组合成一个巨大的纹理文件来准备的，这个文件如果作为一个单独的纹理文件加载到图形内存中将会太大。这与图集的概念类似，但包含纹理的文件非常大——例如，32,768 x 32,768 像素——并且会包含相当多的颜色细节，如每像素 32 位（这将导致一个消耗 4 GB 磁盘空间的纹理文件）。想法是通过手动选择纹理的小部分来动态地从磁盘加载，在游戏需要它们之前的一瞬间从磁盘拉取它们，从而节省大量的运行时内存和内存带宽。这种技术的成本主要是文件大小要求以及可能持续的磁盘访问。这种技术的其他成本可以克服，但通常需要大量的场景准备工作。

游戏世界需要以这种方式创建，以最大限度地减少纹理交换的数量。为了避免非常明显的**纹理闪烁**问题，纹理子部分必须从磁盘拉入 RAM，留出足够的时间，这样 GPU 不需要等待就可以开始传输到 VRAM（与它通常不需要等待预先加载到 RAM 中的普通纹理文件的方式非常相似）。这通过在纹理文件的设计中保持给定场景的常见元素在纹理的相同区域，以及通过在游戏过程中的关键时刻触发新的纹理子部分加载，并确保新瓦片的磁盘访问可以快速定位，而不会出现极端的缓存缺失来实现。如果处理得当，稀疏纹理可以在场景质量和内存节省方面带来令人印象深刻的效益。

这是在游戏行业中的一个高度专业化的技术，尚未得到广泛应用，部分原因是因为它需要专门的硬件和平台支持，部分原因是因为很难做得很好。Unity 关于稀疏纹理的文档随着时间的推移有所改进，并提供了一个示例场景，展示了其效果，可以在[`docs.unity3d.com/Manual/SparseTextures.html`](http://docs.unity3d.com/Manual/SparseTextures.html)找到。

对于认为自己足够高级可以尝试稀疏纹理的 Unity 开发者来说，花时间进行一些研究以检查稀疏纹理是否适合他们的项目可能是值得的，因为它承诺可以节省一些显著的性能。

# 程序材质

程序材质，也称为**材质**，是一种在运行时通过结合小而高质量的纹理样本和自定义数学公式来程序生成纹理的方法。程序材质的目标是在初始化期间通过数学运算而不是静态颜色数据生成纹理，以牺牲额外的运行时内存和 CPU 处理能力，从而大大减少应用程序的磁盘占用。

纹理文件有时是游戏项目最大的磁盘空间消费者，而且下载时间对完成下载速度和让人们尝试我们的游戏（即使它是免费的）有巨大的负面影响是众所周知的事实。程序材质允许我们牺牲一些初始化和运行时处理能力以换取更快的下载速度。这对于试图通过图形保真度竞争的移动游戏来说非常重要。

对于 Unity 2019 来说，程序材质不再是 Unity 的一部分。相反，它们作为单独的插件提供。您可以在官方页面了解更多关于材质的信息：[`www.substance3d.com/integrations/substance-in-unity`](https://www.substance3d.com/integrations/substance-in-unity)。

# 异步纹理上传

我们尚未介绍的最后一种纹理导入选项是读写启用选项。默认情况下，此选项是禁用的，这是好事，因为它允许纹理利用异步纹理上传功能，该功能有两个好处：纹理将从磁盘异步上传到 RAM，并且当 GPU 需要纹理数据时，传输发生在渲染线程上，而不是主线程上。只要缓冲区包含新数据，纹理就会被推送到循环缓冲区，持续不断地将数据推送到 GPU。如果没有新数据，则它将提前退出进程并等待新的纹理数据请求。

最终，这减少了为每一帧准备渲染状态所花费的时间，并允许将更多的 CPU 资源用于游戏逻辑、物理引擎等。当然，仍然会在主线程上花费一些时间来准备渲染状态，但将纹理上传任务移动到单独的线程可以为主线程节省大量的 CPU 时间。

然而，启用对纹理的读写访问实际上是在告诉 Unity 我们可能在任何时间读取和编辑此纹理。这意味着 GPU 每次都需要新鲜访问它，因此它将禁用该纹理的异步纹理上传；所有上传都必须在主线程上执行。我们可能希望为诸如在画布上模拟绘画颜色或将来自互联网的图像数据写入预制的纹理等操作启用此选项，但缺点是 GPU 必须始终等待对纹理的任何更改被应用后才能上传，因为它无法预测这些更改何时发生。

此外，异步纹理上传仅适用于我们明确导入到项目中且在构建时存在的纹理，因为该功能仅在纹理被打包到特殊的可流式传输资源中时才有效。因此，通过`LoadImage(byte[])`生成的任何纹理、从外部位置导入/下载的纹理资产，或通过`Resources.Load()`从*资源*文件夹中加载的纹理（它们都隐式调用`LoadImage(byte[])`）将不会被转换为可流式传输内容，因此将无法使用异步纹理上传。

可以调整最大允许时间的上限，以便将其用于异步纹理上传，以及 Unity 应使用的总循环缓冲区大小，以推送我们想要上传的纹理。这些设置可以在“编辑”|“项目设置”|“质量”|“其他”中进行调整，分别命名为异步上传时间片和异步上传缓冲区大小。我们应该将异步上传时间片值设置为 Unity 在渲染线程上花费在异步纹理上传上的最大毫秒数。将异步上传缓冲区大小值设置为可能需要的最大纹理文件大小，如果同一帧需要多个新纹理，则额外添加一些缓冲区。纹理数据被复制的循环缓冲区将根据需要扩展，但这通常成本较高。由于我们可能已经提前知道需要循环缓冲区的大小，我们可以将其设置为最大预期大小，以避免在需要调整缓冲区大小时出现潜在的帧率下降。我们现在继续讨论下一个主题——网格和动画文件类型。

# 网格和动画文件

网格和动画文件类型基本上是顶点和骨骼蒙皮数据的大型数组，我们可以应用各种技术来最小化文件大小，同时保持相似，如果不是完全相同的外观。还有方法可以通过批处理技术降低渲染大量此类对象的成本。让我们看看我们可以应用于此类文件的一系列性能提升技术。

# 减少多边形数量

减少多边形数量是获得性能的最明显方法，应始终考虑。事实上，由于我们不能使用皮肤网格渲染器批量处理对象，这是减少动画对象 CPU 和 GPU 运行时开销的好方法之一。

减少多边形数量简单直接，并且为艺术家清理网格所需的时间提供了 CPU 和内存成本节约。在这个时代，物体的许多细节几乎完全基于详细的纹理和复杂的着色，因此我们通常可以在现代网格上移除大量顶点，而大多数用户都无法察觉到差异。

# 调整网格压缩

Unity 为导入的网格文件提供了四种不同的网格压缩设置：关闭、低、中、高。提高此设置会将浮点数据转换为固定值，降低顶点位置/法线方向精度，简化顶点颜色信息等。这将对包含许多相邻小部件的网格产生明显影响，例如栅栏或格栅。如果我们是生成网格的，可以通过调用`MeshRenderer`组件的`Optimize()`方法（当然，这需要一些时间来完成）来实现相同类型的压缩。

在“编辑 | 项目设置 | 玩家 | 其他设置”中还可以找到两个全局设置，它们会影响网格数据的导入方式。具体如下：

+   顶点压缩：我们可以使用此选项配置在启用网格压缩时导入网格文件将优化的数据类型，如果我们想要精确的法线数据（用于照明），但不太关心位置数据，则可以在此配置。不幸的是，这是一个全局设置，将影响所有导入的网格（尽管由于它是玩家设置，因此可以按平台进行配置）。

+   优化网格数据：启用“优化网格数据”将移除网格中不需要的任何数据。所以，如果网格包含切线信息，但着色器从不要求它，那么 Unity 在构建时将忽略它。

在每种情况下，这些好处都是以增加加载网格所需额外时间为代价来减少应用程序的磁盘占用，因为必须在需要之前花费额外时间解压缩数据。

3D 网格构建/动画工具通常提供自己的内置自动化网格优化方式，形式为估计整体形状并将网格简化为更少的多边形。这可能导致质量显著下降，如果使用，应进行彻底测试。

# 正确使用读写权限

读写启用标志允许在运行时通过脚本或由 Unity 自动进行更改，类似于它用于纹理文件的方式。内部来说，这意味着它将保留原始网格数据在内存中，直到我们想要复制它并动态地对其进行更改。禁用此选项将允许 Unity 在确定要使用的最终网格后从内存中丢弃原始网格数据，因为它知道它将不会更改。

如果我们在整个游戏中只使用网格的均匀缩放版本，那么禁用此选项将节省运行时内存，因为我们不再需要原始网格数据来制作网格的进一步缩放副本（顺便说一句，这就是 Unity 在动态批处理时按比例因子组织对象的方式）。因此，Unity 可以提前丢弃这些不需要的数据，因为我们不会在下次应用程序启动之前再次需要它。

然而，如果网格在运行时经常以不同的比例重新出现，那么 Unity 需要将此数据保留在内存中，以便它可以更快地重新计算新的网格；因此，启用读写启用标志将是明智的。禁用它将要求 Unity 每次网格重新引入时不仅要重新加载网格数据，还要同时创建缩放后的副本，这可能导致性能中断。

Unity 试图在初始化时检测此设置的正确行为，但当网格在运行时以动态方式实例化和缩放时，我们必须通过启用此设置来强制处理。这将提高对象的实例化速度，但会消耗一些内存开销，因为原始网格数据会保留直到需要时。

注意，这种潜在的开销成本也适用于使用生成碰撞器选项时。

# 考虑烘焙动画

使用烘焙动画需要通过我们使用的 3D 绑定和动画工具对资产进行更改，因为 Unity 本身不提供此类工具。动画通常以关键帧信息的形式存储，它使用这些信息来跟踪特定的网格位置，并在运行时使用皮肤数据（骨骼形状、分配、动画曲线等）在它们之间进行插值。烘焙动画意味着有效地在每个帧中采样并将每个顶点的每个位置硬编码到网格/动画文件中，无需插值和皮肤数据。

使用烘焙动画有时可以比混合/蒙皮动画为某些对象带来更小的文件大小和内存开销，因为蒙皮数据可能需要占用出人意料大的空间来存储。这最有可能发生在相对简单的对象或具有简短动画的对象上，因为我们实际上会用硬编码的顶点位置序列替换程序数据。因此，如果网格的多边形数量足够低，以至于存储大量顶点信息比蒙皮数据更便宜，那么我们可能会通过这种简单的更改看到一些显著的节省。

此外，烘焙样本的频率通常可以通过导出应用程序进行自定义。应该测试不同的采样率，以找到动画的关键时刻仍然能够通过简化估计凸显出来的良好值。

# 合并网格

强制将网格合并成一个大型的单个网格可以是一个方便的选项，以减少绘制调用，尤其是如果网格太大而无法进行动态批处理，并且与其他静态批处理组配合不佳时。这本质上等同于静态批处理，但它是由人工执行的，因此如果静态批处理可以为我们处理这个过程，有时这会是一种浪费的努力。

请注意，如果网格的任何单个顶点在场景中可见，则整个对象将作为一个整体一起渲染。如果网格大部分时间只部分可见，这可能会导致大量的处理浪费。这种技术还带来一个缺点，即它会生成一个新的整个网格资产文件，我们必须将其存入我们的场景中，这意味着我们对原始网格所做的任何更改都不会反映在合并后的网格中。这导致每次需要更改时都需要大量的繁琐工作流程，因此如果静态批处理是一个选项，应该使用它而不是这种方法。

在线有一些工具可以将网格文件合并在一起，用于 Unity。它们只需通过资产商店或 Google 搜索即可获得。

# 资产包和资源

在第二章“脚本策略”中，我们提到了资源和序列化的话题，应该相当清楚，资源系统在原型设计和项目早期阶段都可以带来很大的好处，并且可以在范围有限的游戏中相对有效地使用。

然而，专业的 Unity 项目应该更倾向于使用资产包系统。这有几个原因。首先，在构建方面，资源系统并不非常可扩展。所有资源都合并成一个单一的巨大序列化文件二进制数据块，其中包含一个索引列表，指示各种资产在该文件中的位置。这可能会很难管理，并且随着我们向列表中添加更多数据，构建时间可能会很长。

其次，资源系统从序列化文件获取数据的能力以*Nlog(N)*的方式扩展，这应该让我们对增加*N*的值非常谨慎。第三，资源系统使得我们的应用程序按设备提供不同的资产数据变得难以操作，而资产包通常使这个问题变得微不足道。最后，资产包可以用来为应用程序提供小型的、定期的自定义内容更新，而资源系统则需要更新以完全替换整个应用程序才能达到相同的效果。

资产包与资源共享了许多共同的功能，例如从文件中加载、异步加载数据以及卸载不再需要的我们不再需要的数据。然而，它们还提供了更多的功能，如内容流、内容更新、内容生成和共享。所有这些都可以极大地提高我们应用程序的性能。我们可以提供具有更小磁盘足迹的应用程序，让用户在游戏前或游戏中下载额外的内容，在运行时流式传输资产以最小化应用程序的初始加载时间，并且可以在每个平台上为应用程序提供更优化的资产，而无需推送完整的应用程序以覆盖用户。

当然，资产包也有其缺点。它们比资源更复杂，设置和维护起来更复杂，理解起来也更复杂，因为它们使用了一个比资源系统更复杂的系统来访问资产数据。充分利用其功能（如流式传输和内容更新）需要大量的额外 QA 测试，以确保服务器正确地提供内容，并且游戏能够读取和更新其内容以匹配。因此，只有在我们的团队能够支持它们所需的额外工作量时，才最好使用资产包。

本书中不涉及资产包系统的教程，但网上和 Unity 文档中有很多有用的指南。

查看 Unity 教程[`learn.unity.com/tutorial/assets-resources-and-assetbundles`](https://learn.unity.com/tutorial/assets-resources-and-assetbundles)，了解更多关于资产包系统信息。

如果您需要进一步的说服，那么 2017 年 4 月的一篇 Unity 博客文章应该有助于揭示资产包系统如何在运行时更有效地使用内存，这是资源系统无法通过内存池提供的。您可以在[`blogs.unity3d.com/2017/04/12/asset-bundles-vs-resources-a-memory-showdown/`](https://blogs.unity3d.com/2017/04/12/asset-bundles-vs-resources-a-memory-showdown/)找到这篇博客。

# 摘要

我们可以通过调整导入的资产来探索许多不同的机会，从而提高我们应用程序的性能。从另一个角度来看，也有许多方法可以通过资产管理不善来破坏我们应用程序的性能。几乎每一个导入配置的机会都是在一项性能指标或工作流程任务与另一项之间的权衡。通常这意味着通过压缩来节省磁盘占用空间，但运行时需要 CPU 来解压缩数据，或者更快地访问数据，同时降低最终展示的质量水平。因此，我们必须保持警惕，只为合适的资产选择合适的技巧，出于合适的原因。

这就结束了我们通过艺术资产操作来提高性能的探索。在下一章中，我们将探讨如何提高我们对 Unity 物理引擎的使用。
