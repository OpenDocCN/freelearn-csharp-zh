- en: Controlling and Choosing Positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Player control of a 2D GameObject (and limiting the movement within a rectangle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player control of a 3D GameObject (and limiting the movement within a rectangle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing destinations – finding a random spawn point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing destinations – finding the nearest spawn point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing destinations – respawning to the most recently passed checkpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving objects by clicking on them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing projectiles in the direction of movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many **GameObjects** in games move! Movement can be controlled by the player,
    by the (simulated) laws of physics in the environment, or by the **Non-Player
    Character** (**NPC**) logic; for example, objects that follow a path of a waypoint,
    or seek (move toward) or flee (away) from the current position of a character.
    Unity provides several controllers for first and third-person characters, and
    for vehicles such as cars and airplanes. **GameObject** movement can also be controlled
    through the state machines of the Unity **Mecanim** animation system.
  prefs: []
  type: TYPE_NORMAL
- en: However, there may be times when you wish to tweak the Player character controllers
    from Unity, or write your own. You might wish to write directional logic—simple
    or sophisticated **Artificial Intelligence** (**AI**) to control the game's NPC
    and enemy characters. Such AI might involve your computer program making objects
    orient and move toward or away from characters or other game objects.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter (and the chapter that follows) presents a range of such directional
    recipes, from which many games can benefit in terms of a richer and more exciting
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides sophisticated classes and components, including the `Vector3`
    class and rigid body physics for modeling realistic movements, forces, and collisions
    in games. We make use of these game engine features to implement some sophisticated
    NPC and enemy character movements in the recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For 3D games (and to some extent, 2D games as well), a fundamental class of
    object is the `Vector3` class objects that store and manipulate (x, y, z) values
    representing locations in a 3D space. If we draw an imaginary arrow from the origin
    (0, 0, 0) to a point on the space, then the direction and length of this arrow
    (vector) can represent a velocity or force (that is, a certain amount of magnitude
    in a certain direction).
  prefs: []
  type: TYPE_NORMAL
- en: If we ignore all the character controller components, colliders, and the physics
    system in Unity, we can write code that teleports objects directly to a particular
    (x,  y,  z) location in our scene. Sometimes, this is just what we want to do;
    for example, we may wish to spawn an object at a location. However, in most cases,
    if we want objects to move in more physically realistic ways, then we either apply
    a force to the object's **RigidBody**, or change its velocity component. Or, if
    it has a **Character Controller** component, then we can send it a `Move()` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important concepts in the NPC object movement and creation (instantiation)
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spawn points**: Specific locations in the scene where objects are to be created,
    or moved to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checkpoints**: Locations (or colliders) that, once passed through, change
    what happens later in the game (for example, extra time, or if a Player''s character
    gets killed, they respawn to the last crossed checkpoint, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waypoints**: A sequence of locations to define a path for NPCs or, perhaps,
    the Player''s character, to follow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will introduce a few recipes and demonstrate a selection
    of approaches to character control, spawn points, and checkpoints. In the next
    chapter, we'll look at waypoints for AI controlled characters.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the Unity 2D character controllers at [http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers](http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers).
  prefs: []
  type: TYPE_NORMAL
- en: You can learn about the Unity 3D character component and control at [http://docs.unity3d.com/Manual/class-CharacterController.html](http://docs.unity3d.com/Manual/class-CharacterController.html)
    and [http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character](http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character).
  prefs: []
  type: TYPE_NORMAL
- en: 'Every game needs textures. Here are some of the sources of free textures that
    are suitable for many games:'
  prefs: []
  type: TYPE_NORMAL
- en: CG Textures are available at [http://www.cgtextures.com/](http://www.cgtextures.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naldz Graphics blog,  available at [http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player control of a 2D GameObject (and limiting the movement within a rectangle)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the rest of the recipes in this chapter are demonstrated in 3D projects,
    basic character movement in 2D and also limiting the movement to a bounding rectangle,
    are core skills for many 2D games, and so this first recipe illustrates how to
    achieve these features for a 2D game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since in [Chapter 3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml), *Inventory
    UIs*, we already created a basic 2D game, we''ll adapt this game to restrict the
    movement to a bounding rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76b6b50a-1659-4d5c-8de2-db2777b28ce4.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds on a simple 2D game called the Simple2DGame_SpaceGirl mini
    game from the first recipe of [Chapter 3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml),
    *Inventory UIs*. Start with a copy of this game, or use the provided completed
    recipe project as the basis for this recipe. You can download the completed project
    from [https://github.com/dr-matt-smith/unity-cookbook-2018-ch03](https://github.com/dr-matt-smith/unity-cookbook-2018-ch03).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a 2D sprite controlled by the user with a movement that is limited
    to within a rectangle, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new, empty **GameObject** named `corner_max`, and position it somewhere
    above and to the right of the **GameObject** called `player_spaceGirl`. With this
    **GameObject** selected in the Hierarchy view, choose the large yellow oblong
    icon, highlighted in the Inspector panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/accf458a-21c9-4fda-864c-145266b43739.png)'
  prefs: []
  type: TYPE_IMG
- en: Duplicate the corner_max **GameObject** by naming the clone as `corner_min`,
    and position this clone somewhere below and to the left of the player-spaceGirl **GameObject**.
    The coordinates of these two **GameObjects** will determine the maximum and minimum
    bounds of movement, permitted for the player's character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the C# Script called `PlayerMove` to declare some new variables at the
    beginning of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the C# Script called `PlayerMove` so that the `Awake()` method now gets
    a reference to the `SpriteRenderer`, and uses this object to help set up the maximum
    and minimum X and Y movement limits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the C# Script called `PlayerMove` to declare a new method called `KeepWithinMinMaxRectangle()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the C# Script called `PlayerMove` so that, after having updated the
    velocity in the `FixedUpdate()` method, a call will be made to the `KeepWithinMinMaxRectangle()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the player-spaceGirl **GameObject** in the **Hierarchy** view, drag the
    corner_max and corner_min **GameObjects** over the public variables called corner_max
    and corner_min in the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before running the scene in the **Scene** panel, try repositioning the corner_max
    and corner_min **GameObjects**. When you run the scene, the positions of these
    two **GameObjects** (max and min, and X and Y) will be used as the limits of movement
    for the Player's player-spaceGirl character.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You added the empty **GameObjects** called corner_max and corner_min to the
    scene. The X and Y coordinates of these **GameObjects** will be used to determine
    the bounds of movement that we will permit for the character called player-spaceGirl.
    Since these are the empty **GameObjects**, they will not be seen by the player
    when in play-mode. However, we can see and move them in the **Scene** panel, and
    having added the yellow oblong icons, we can see their positions and names very
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: Upon using the `Awake()` method on the `PlayerMoveWithLimits` object, inside
    the player-spaceGirl **GameObject**, the maximum and minimum X and Y values of
    the **GameObjects** called corner_max and corner_min are recorded. Each time the
    physics system is called via the `FixedUpdate()` method, the velocity of the player-spaceGirl
    character is updated to the value set in the `Update()` method,which is based
    on the horizontal and vertical keyboard/joystick inputs. However, the final action
    of the `FixedUpdate()` method is to call the `KeepWithinMinMaxRectangle()` method,
    which uses the `Math.Clamp(...)` function to move the character back inside the
    X and Y limits. This happens so that the player's character is not permitted to
    move outside the area defined by the corner_max and corner_min **GameObjects**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have kept to a good rule of thumb:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Always listen for **input** in `Update()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Always apply **physics** in `FixedUpdate()`."
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about why we should not check for inputs in `FixedUpdate()` in the
    Unity Answers thread (which is also the source for the preceding quote from user
    Tanoshimi) at [https://answers.unity.com/questions/1279847/getaxis-being-missed-in-fixedupdate-work-around.html](https://answers.unity.com/questions/1279847/getaxis-being-missed-in-fixedupdate-work-around.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss out on.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a gizmo yellow rectangle to visually show bounding a rectangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As developers, it is useful to *see* elements like bounding rectangles when
    run-testing our game. Let''s make the rectangular bounds of the movement visually
    explicit in yellow lines in the Scene panel by having a yellow "gizmo" rectangle
    drawn. Add the following method to the C# script class called `PlayerMove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `OnDrawGizmos()` method tests that the references to the corner_max and
    corner_min **GameObjects** are not null, and then sets the positions of the four
    **Vector3** objects, representing the four corners defined by the rectangle, with
    corner_max and corner_min at the opposite corners. It then sets the **Gizmo**
    color to yellow, and draws lines, connecting the four corners in the **Scene**
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the following recipe for more information about limiting Player controlled
    character movements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player control of a 3D GameObject (and limiting the movement within a rectangle)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of the 3D recipes in this chapter are built on this basic project, which
    constructs a scene with a textured terrain, a **Main Camera**, and a red cube
    that can be moved around by the user with the four directional arrow keys. The
    bounds of movement of the cube are constrained using the same technique as in
    the previous 2D recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbef8f32-06f6-4e98-9af4-6cbb47191e8b.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a basic 3D cube controlled game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new, empty 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project has been created, import the single **Terrain Texture** named
    SandAlbedo by choosing menu: Assets | Import Package | Environments. Deselect
    everything, and then locate and tick the asset by going to `Assets/Environment/TerrainAssets/SurfaceTextures/
    SandAlbedo.psd`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could have just added the Environment Asset Package when creating the project,
    but this would have imported hundreds of files, and we only needed this one. Starting
    a project in Unity and then selectively importing just what we need is the best
    approach to take if you want to keep the project's `Asset` folders to small sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new terrain by choosing menu: Create | 3D Object | Terrain. With this
    new terrain **GameObject** selected in Hierarchy, in its Inspector properties,
    set the size to 30 x 20, and its position to (-15, 0, -10):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transform position for the terrains relates to their corner and not their
    center.
  prefs: []
  type: TYPE_NORMAL
- en: Since the **Transform** position of the terrains relates to the corner of the
    object, we center such objects at (0, 0, 0) by setting the X coordinate equal
    to ( *-1width/2*), and the Z-coordinate equal to (*-1length/2*). In other words,
    we slide the object by half its width and half its height to ensure that its center
    is just where we want it.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the width is 30 and the length is 20, hence we get -15 for X (*-1
    * 30/2*), and -10 for Z (*-1 * 20/2*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ece021ed-d3b8-40d2-8ac5-7edd13f44a9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Texture paint this terrain with your texture called SandAlbedo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position: (0, 20, -15)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotation: (60, 0, 0)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the Aspect Ratio of the **Game Panel** from Free Aspect to 4:3\. You
    will now see the whole of the Terrain in the **Game Panel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty **GameObject** named corner_max, and position it at (14,
    0, 9). With this **GameObject** selected in the Hierarchy, choose the large, yellow
    oblong icon, highlighted in the Inspector panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the corner_max **GameObject**, naming the clone as corner_min, and
    position this clone at (-14, 0, -9). The coordinates of these two **GameObjects**
    will determine the maximum and minimum bounds of the movement permitted for the
    player's character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new cube called **GameObject **by choosing menu: Create | 3D Object
    | Cube. Name this `Cube-player`, and set its position to (0, 0.5, 0), and size
    as (1, 1, 1).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a rigid body component to the Cube-player **GameObject** (Physics | RigidBody),
    and uncheck the **RigidBody** property Use Gravity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a red **Material** named `m_red`, and apply this Material to Cube-player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# Script class called `PlayerControl`, and add an instance object
    as a component to **GameObject **Cube-player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the Cube-player **GameObject** selected in Hierarchy, drag the **GameObjects**
    called corner_max and corner_min over the public variables called corner_max and
    corner_min in the Inspector panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the scene, the positions of the corner_max and corner_min **GameObjects**
    will define the bounds of movement for the Player's Cube-player character.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scene contains a positioned terrain so that its center is (0, 0, 0). The
    red cube is controlled by the user's arrow keys through the `PlayerControl` script.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the previous 2D recipe, a reference to the (3D) RigidBody component
    is stored when the `Awake()` method executes, and the maximum and minimum X and
    Z values are retrieved from the two corner **GameObjects**, and are stored in
    the `x_min`, `x_max`, `z_min`, and `z_max` variables. Note that for this basic
    3D game, we won't allow any Y-movement, although such movement (and bounding limits
    by adding a third max-height corner **GameObject**) can be easily added by extending
    the code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `KeyboardMovement()` method reads the horizontal and vertical input values
    (which the Unity default settings read from the four directional arrow keys).
    Based on these left-right and up-down values, the velocity of the cube is updated.
    The amount it will move depends on the speed variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `KeepWithinMinMaxRectangle()` method uses the `Math.Clamp(...)` function
    to move the character back inside the X and Z limits so that the player's character
    is not permitted to move outside the area defined by the corner_max and corner_min **GameObjects**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss out on.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a gizmo yellow rectangle to visually show bounding a rectangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As developers, it is useful to *see* elements like bounding rectangles when
    test-running our game. Let''s make the rectangular bounds of the movement visually
    explicit in yellow lines in the **Scene** panel by having a yellow "gizmo" rectangle
    drawn. Add the following method to the C# Script class called `PlayerMove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `OnDrawGizmos()` method tests that the references to the corner_max and
    corner_min **GameObjects** are not null, and then sets the positions of the four
    Vector3 objects, representing the four corners defined by the rectangle, with
    the corner_max and corner_min **GameObjects** at the opposite corners. It then
    sets the **Gizmo** color to yellow, and draws lines, connecting the four corners
    in the **Scene** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing destinations – finding a random spawn point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many games make use of spawn points and waypoints. This recipe demonstrates
    choosing a random spawn point, and then the instantiation of an object at that
    chosen point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds upon the previous recipe. So, make a copy of this project,
    open it, and then follow the steps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find a random spawn point, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Scene panel, create a sphere (by navigating to Create | 3D Object | Sphere)
    sized as (1, 1, 1) at (2, 2, 2) position, and apply the m_red **Material**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new **Prefab** (by going to Create | Prefab)
    named `Prefab-ball`, and drag your sphere into it (and then delete the sphere
    from the Hierarchy panel).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Scene panel, create a new capsule (by navigating to Create | 3D Object
    | Capsule) named `Capsule-spawnPoint` at (3, 0.5, 3), and give it a tag of Respawn
    (this is one of the default tags that Unity provides):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For testing, we'll leave these Respawn points visible. For the final game, we'll
    then uncheck the Mesh Rendered of each Respawn **GameObject** so that they are
    not visible to the Player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e33a140-8ca0-4924-8995-611f9309024a.png)'
  prefs: []
  type: TYPE_IMG
- en: Make several copies of your Capsule-spawnPoint by moving them to different locations
    on the terrain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# Script class called SpawnBall, and add an instance object as a
    component to the Cube-player **GameObject**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C# Script class called `SpawnPointManager` and add an instance object
    as a component to the Cube-player **GameObject**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that Cube-player is selected in the Inspector for the SpawnBall scripted
    component. Then, drag Prefab-ball over the public variable projectile called Prefab
    Ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run your game. Every second, a red ball should be spawned and disappear
    after half a second. The location each ball is spawned at should be random.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Capsule-spawnPoint` objects represent candidate locations, where we might
    wish to create an instance of our ball **Prefab**. When our `SpawnPointManager`
    object, inside the Cube-player **GameObject**, receives the `Start()` message,
    the respawned **GameObject** array is set to the array, which is returned from
    the call to `FindGameObjectsWithTag("Respawn")`. This creates an array of all
    the objects in the scene with the Respawn tag—that is, all our `Capsule-spawnPoint`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: When our `SpawnBall` object GameObject Cube-player receives the `Start()` message,
    it sets the `spawnPointManager` variable to be a reference to its sibling `SpawnPointManager`
    script component. Next, we use the `InvokeRepeating(...)` method to schedule the `CreateSphere()` method
    to be called every 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: The `SpawnBall` method `CreateSphere()` assigns the `spawnPoint` variable to
    the **GameObject** returned by a call to the `RandomSpawnpoint(...)` method of
    our `spawnPointManager`. Then, it creates a new instance of `prefab_ball` (via
    the public variable) at the same position as the spawnPoint **GameObject**.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same techniques and code can be used for selecting spawn points or waypoints.
    Refer to the *NPC NavMeshAgent control to follow waypoints in sequence* recipe
    in the next chapter ([Navigation Meshes and Agents](https://cdp.packtpub.com/unity_2017_cookbook/wp-admin/post.php?post=604&action=edit))
    for more information about waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing destinations – finding the nearest spawn point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than just choosing a random spawn point or waypoint, sometimes, we want
    to select the one closest to some object (such as the player's **GameObject**).
    In this recipe, we will modify the previous one to find the nearest spawn point
    to the player's cube, and use that location to spawn a new red ball prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds upon the previous recipe. So, make a copy of this project,
    open it, and then follow the steps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find the nearest spawn point, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the C# Script class called `SpawnPointManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to change the first line in the C# class called `SpawnBall` so
    that the `spawnPoint` variable is set by a call to our new method called `NearestSpawnpoint(...)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, run your game. Every second, a red ball should be spawned, and disappear
    after half a second. Use the arrow keys to move the player's red cube around the
    terrain. Each time a new ball is spawned, it should be at the spawn point closest
    to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `NearestSpawnpoint(...)` method, we set nearestSpawnpoint to the first
    (array index `0`) **GameObject** in the array as our default. We then loop through
    the rest of the array (array index `1` up to `spawnPoints.Length`). For each **GameObject**
    in the array, we test to see if its distance is less than the shortest distance
    so far, and if it is, then we update the shortest distance, and also set `nearestSpawnpoint`
    to the current element. When the array has been searched, we return the **GameObject**
    that the `nearestSpawnpoint` variable refers to.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss out on.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding errors due to an empty array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make our code a little more robust so that it can cope with the issue
    of an empty `spawnPoints` array, that is, when there are no objects tagged as `Respawn`
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cope with the no objects tagged as `Respawn`, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Improve our `Start()` method in the C# Script class called `SpawnPointManager` so
    that an *error* is logged if the array of the objects tagged as `Respawn` is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Improve the `RandomSpawnPoint()` and `NearestSpawnpoint()` methods in the C#
    Script class called `SpawnPointManager` so that they still return a **GameObject**,
    even if the array is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Improve the `CreateSphere()` method in the C# class called `SpawnBall` so that
    we only attempt to instantiate a new **GameObject** if the `RandomSpawnPoint()`
    and `NearestSpawnpoint()` methods have returned a non-null object reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same techniques and code can be used for selecting spawn points or waypoints.
    Refer to the *NPC* *NavMeshAgent control to follow waypoints in sequence* recipe
    in the next chapter ([Navigation Meshes and Agents](https://cdp.packtpub.com/unity_2017_cookbook/wp-admin/post.php?post=604&action=edit))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing destinations – respawning to the most recently passed checkpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A checkpoint usually represents a certain distance through the game (or perhaps
    a track) in which an agent (user or NPC) has succeeded reaching. Reaching (or
    passing) checkpoints often results in bonus awards, such as extra time, points,
    ammo, and so on. Also, if a player has multiple lives, then often a player will
    only be respawned back as far as the most recently passed checkpoint, rather than
    right to the beginning of the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe demonstrates a simple approach to the checkpoints, whereby once
    the player''s character has passed a checkpoint, if they die, they are moved back
    to the most recently passed checkpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7e329b9-214a-46bd-9088-ad03fec4a8fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To have the respawn position change upon losing a life depending on the checkpoints
    passed, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the Cube-player **GameObject** to the (12, 0.5, 0) position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Cube-player in the Inspector panel and add a **Character Controller**
    component by clicking on Add Component | Physics | Character Controller (this
    is to enable the **OnTriggerEnter** collision messages to be received).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cube named Cube-checkpoint-1 at (5, 0, 0), scaled to (1, 1, 20).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Cube-checkpoint-1 selected, check the Is Trigger property of its Box Collider
    component in the Inspector panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a CheckPoint tag, and assign this tag to Cube-checkpoint-1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate Cube-checkpoint-1 and name the clone `Cube-checkpoint-2`, and position
    it at (-5, 0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sphere named `Sphere-Death` at (7, 0.5, 0). Assign the m_red material
    to this sphere to make it red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Sphere-Death selected, check the Is Trigger property of its Sphere Collider
    component in the Inspector panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Death` tag, and assign this tag to Sphere-Death.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate Sphere-Death, and position this clone at (0, 0.5, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate Sphere-Death a second time, and position this second clone at (-10,
    0.5, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the following C# Script class called `CheckPoints` to the
    Cube-player **GameObject**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run the scene. If the cube runs into a red sphere before crossing a checkpoint,
    it will be respawned back to its starting position. Once the red cube has passed
    a checkpoint, if a red sphere is hit, then the cube will be moved back to the
    location of the most recent checkpoint that it passed through.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C# script class called `CheckPoint` has one variable called `respawnPosition`,
    which is a **Vector3** that refers to the position the player's cube is to be
    moved to (respawned) if it collides with a `Death` tagged object. The default
    setting for this is the position of the player's cube when the scene begins, so
    in the `Start()` method, we set it to the player's position.
  prefs: []
  type: TYPE_NORMAL
- en: Each time an object tagged called `Checkpoint` is collided with, the value of
    `respawnPosition` is updated to the current position of the player's red cube
    at this point in time (that is, where it is when it touches the stretched cube
    tagged object called CheckPoint). The next time the object tagged `Death` is hit,
    the cube will be respawned back to where it last touched the object tagged called
    CheckPoint.
  prefs: []
  type: TYPE_NORMAL
- en: Moving objects by clicking on them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want to allow the user to interact with objects through mouse
    pointer clicks. In this recipe, we will allow the user to move an object in a
    random direction by clicking on it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe. The result of following this recipe
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b8fb3a4-1972-4e56-8bfb-ff6d1c820c6e.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To move objects by clicking on them, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the Cube-player **GameObject**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Main Camera position to (0, 3, -5), and its rotation to (25, 0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# Script class called `ClickMove`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Create a Cube **GameObject** and add an instance object of the script class
    `ClickMove` as a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see that a **RigidBody** component is automatically added to the
    new cube, since the script class has the directive `RequireComponent(typeof(Rigidbody))`.
    This only works if the directive is in the code before the script class is added
    to a **GameObject**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make four more duplicates of the cube, and arrange the six objects into a pyramid
    by setting their positions to be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the scene. Each time you use the mouse pointer to click on a cube, the clicked
    cube will have a random directional force applied to it. So, with a few clicks,
    you can knock down the pyramid!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The public float variable multiplier allows you to change the maximum magnitude
    of the force by changing the value in the `ClickMove` scripted component of each
    cube.
  prefs: []
  type: TYPE_NORMAL
- en: The `ClickMove` script class has a private variable called `rigidBody` set as
    a reference to the RigidBody component in the `Awake()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the cube receives a `MouseDown()` message (such as when it has been
    clicked with the user's mouse pointer), this method creates a random directional
    **Vector3**, and applies this as a force to the object's `rigidBody` reference.
  prefs: []
  type: TYPE_NORMAL
- en: The `RandomDirectionComponent()` method returns a random value between `-multiplier`
    and `+multiplier`.
  prefs: []
  type: TYPE_NORMAL
- en: Firing projectiles in the direction of movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common use of force is to apply a force to a newly instantiated object,
    making it a projectile travelling in the direction the Player''s **GameObject**
    is facing. That''s what we''ll create in this recipe. The result of following
    this recipe should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1129371-8dba-467f-9351-7130a8e38c2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fire projectiles in the direction of movement, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sphere **GameObject** (by navigating to Create | 3D Object | Sphere).
    Set its size as (0.5, 0.5, 0.5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a RigidBody component to the Sphere (go to Physics | RigidBody).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new blue **Material** named `m_blue` (go to Create
    | Material).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the `m_blue` **Material** to your sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new **Prefab** named `prefab_projectile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the sphere from the Hierarchy panel over your prefab_projectile (it should
    turn blue).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now delete the Sphere from the Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that Cube-player is located at (0, 0.5, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new cube named `Cube-launcher`. Disable its Box Collider component,
    and set its transform as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position (0, 1, 0.3)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotation (330, 0, 0)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale (0.1, 0.1, 0.5)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Hierarchy, make Cube-launcher a child of Cube-player by dragging Cube-launcher
    onto Cube-player. This means that both objects will move together when the user
    presses the arrow keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# Script class called `FireProjectile` and add an instance object
    as a component to Cube-launcher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With Cube-launcher selected in the Inspector, from the Project panel, drag prefab_projectile
    into the public variable Projectile Prefab in the Fire Projectile (Script) component
    in the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene. You can move around the terrain with the arrow keys, and each
    time you click the mouse button, you should see a blue sphere projectile launched
    in the direction that the player's cube is facing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a blue sphere as a **Prefab** (containing a RigidBody). You then
    created a scaled and rotated cube for the projectile launcher Cube-launcher, and
    childed this object to Cube-player.
  prefs: []
  type: TYPE_NORMAL
- en: The `FireProjectile` script class contains a constant `FIRE_DELAY`—this is the
    minimum time between the firing of new projectiles, set to `0.25` seconds. There
    is also a second constant called `PROJECTILE_LIFE`—this is how long each projectile
    will "live" until it is automatically destroyed, otherwise, the scene and memory
    would fill up quickly with lots of old projectiles!
  prefs: []
  type: TYPE_NORMAL
- en: There are also two public variables. One is for the reference to the sphere
    prefab, and the second is for the initial speed of newly instantiated prefabs.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a private variable called `nextFireTime`—this is used to decide
    whether or not enough time has passed to allow a new projectile to be fired.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method tests the current time against the value of `nextFireTime`.
    If enough time has passed, then it will invoke the `CheckFireKey()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckFireKey()` method tests to see if the Fire1 button has been clicked.
    This is usually mapped to the left mouse button, but can be mapped to other input
    events through the Project Settings (navingate to Edit | Project Settings | Input).
    If the `Fire1` event is detected, then the next fire time is reset to be `FIRE_DELAY`
    seconds in the future, and a new projectile is created by invoking the `CreateProjectile()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateProjectile()` method gets the current position and rotation of the
    parent **GameObject**. Remember that the instance object of this class has been
    added to Cube-launcher, so our scripted object can use the position and rotation
    of this launcher as the initial settings for each new projectile. A new instance
    of `projectilePrefab` is created with these position and rotation settings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a Vector3 called `projectileVelocity` is created by multiplying the `projectileSpeed`
    variable with the standard forward vector (0, 0, 1). In Unity, for 3D objects,
    the Z-axis is generally the direction in which the object is facing.
  prefs: []
  type: TYPE_NORMAL
- en: The special method `TransformDirection(...)` is used to turn the local-space
    forward direction into a world-space direction so that we have a Vector representing
    a forward motion relative to the Cube-launcher object.
  prefs: []
  type: TYPE_NORMAL
- en: This world-space directional vector is then used to add a force to the projectile's
    RigidBody.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a reference is made to the parent **GameObject** of the projectile,
    and the `Destroy(...)` method is used so that the projectile will be destroyed
    after `1.5` seconds—the value of `PROJECTILE_LIFE`.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about `Transform.TransformDirection()` at [https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html](https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html).
  prefs: []
  type: TYPE_NORMAL
