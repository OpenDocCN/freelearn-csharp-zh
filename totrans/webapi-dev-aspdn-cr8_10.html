<html><head></head><body>
<div id="_idContainer084">
<h1 class="chapter-number" id="_idParaDest-211"><a id="_idTextAnchor404"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-212"><a id="_idTextAnchor405"/><span class="koboSpan" id="kobo.2.1">Testing in ASP.NET Core (Part 2 â€“ Integration Testing)</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we learned how to write unit tests for a ASP.NET Core web API application. </span><span class="koboSpan" id="kobo.5.2">Unit tests are used to test code units in isolation. </span><span class="koboSpan" id="kobo.5.3">However, a code unit often depends on other components, such as the database, external services, and so on. </span><span class="koboSpan" id="kobo.5.4">To test the code thoroughly, we need to test the code units in the context of the application. </span><span class="koboSpan" id="kobo.5.5">In other words, we need to test how the code units interact with other parts of the application. </span><span class="koboSpan" id="kobo.5.6">This type of testing is called </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">integration testing.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will mainly focus on integration testing. </span><span class="koboSpan" id="kobo.7.2">We will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Writing </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">integration tests</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Testing with authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and authorization</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">code coverage</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">By the end of this chapter, you should be able to write integration tests for a ASP.NET Core web </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">API application.</span></span></p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor406"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">The code examples in this chapter can be found at </span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8</span></a><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">You can use VS Code or VS 2022 to open </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">the solutions.</span></span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor407"/><span class="koboSpan" id="kobo.22.1">Writing integration tests</span></h1>
<p><span class="koboSpan" id="kobo.23.1">In the unit tests, we create</span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.24.1"> the instances of the controllers directly. </span><span class="koboSpan" id="kobo.24.2">This approach does not consider some features of ASP.NET Core, such as routing, model binding, and validation and so on. </span><span class="koboSpan" id="kobo.24.3">To test the application thoroughly, we need to write integration tests. </span><span class="koboSpan" id="kobo.24.4">In this section, we </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.25.1">will write integration tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Unlike unit tests, which</span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.28.1"> focus on isolated units, integration tests focus on the interactions between components. </span><span class="koboSpan" id="kobo.28.2">These integration tests may involve different layers, such as the database, the file system, the network, the HTTP request/response pipeline and so on. </span><span class="koboSpan" id="kobo.28.3">Integration tests ensure that the components of the application work together as expected. </span><span class="koboSpan" id="kobo.28.4">So, normally, integration tests use actual dependencies instead of mocks. </span><span class="koboSpan" id="kobo.28.5">Also, integration tests are slower than unit tests because they involve more components. </span><span class="koboSpan" id="kobo.28.6">Considering the cost of integration tests, we do not need to write too many integration tests. </span><span class="koboSpan" id="kobo.28.7">Instead, we should focus on the critical parts of the application. </span><span class="koboSpan" id="kobo.28.8">Most of the time, we can use unit tests to cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">other parts.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">You can find the sample code of this section in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">IntegrationTestsDemo</span></strong><span class="koboSpan" id="kobo.32.1"> folder. </span><span class="koboSpan" id="kobo.32.2">The code is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">InvoiceApp</span></strong><span class="koboSpan" id="kobo.34.1"> project we created in </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.35.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">You can use VS 2022 or VS Code to open the solution. </span><span class="koboSpan" id="kobo.36.3">We will use the term </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">System Under Test</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.39.1">SUT</span></strong><span class="koboSpan" id="kobo.40.1">) to</span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.41.1"> refer to the ASP.NET Core web API application we </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">are testi</span><a id="_idTextAnchor408"/><span class="koboSpan" id="kobo.43.1">ng.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor409"/><span class="koboSpan" id="kobo.44.1">Setting up the integration test project</span></h2>
<p><span class="koboSpan" id="kobo.45.1">We can </span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.46.1">continue to </span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.47.1">use </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">xUnit</span></strong><span class="koboSpan" id="kobo.49.1"> as the test framework for integration tests. </span><span class="koboSpan" id="kobo.49.2">A good practice is to create a separate integration test project from the unit test project. </span><span class="koboSpan" id="kobo.49.3">This approach allows us to run the unit tests and integration tests separately and also makes it easier to use different configurations for the two types </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">of tests.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">If you are using VS 2022, you can create a new xUnit project by right-clicking on the solution and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Add</span></strong><span class="koboSpan" id="kobo.53.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">New Project</span></strong><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">Then select </span><strong class="bold"><span class="koboSpan" id="kobo.56.1">xUnit Test Project</span></strong><span class="koboSpan" id="kobo.57.1"> from the list of project templates. </span><span class="koboSpan" id="kobo.57.2">You can name the project </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">InvoiceApp.IntegrationTests</span></strong><span class="koboSpan" id="kobo.59.1"> and click </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">Create</span></strong><span class="koboSpan" id="kobo.61.1"> to create the project. </span><span class="koboSpan" id="kobo.61.2">After you create the project, add a project reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">InvoiceApp.WebApi</span></strong><span class="koboSpan" id="kobo.63.1"> project to allow the integration test project to access the classes in the web API project (see </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.64.1">Chapter 9</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.65.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">If you are using </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">.NET CLI</span></strong><span class="koboSpan" id="kobo.68.1">, you can</span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.69.1"> create a new xUnit test project by running the following commands in </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.71.1">
dotnet new xunit -n InvoiceApp.IntegrationTestsdotnet sln InvoiceApp.sln add InvoiceApp.IntegrationTests/InvoiceApp.IntegrationTests.csproj
dotnet add InvoiceApp.IntegrationTests/InvoiceApp.IntegrationTests.csproj reference InvoiceApp.WebApi/InvoiceApp.WebApi.csproj</span></pre>
<p><span class="koboSpan" id="kobo.72.1">ASP.NET Core </span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.73.1">provides a built-in test web host that we can use to host the SUT to handle the HTTP requests. </span><span class="koboSpan" id="kobo.73.2">The benefit of using a test web host is that we can use a different configuration for the test environment, and it also saves the network traffic because the HTTP requests are handled in the same process. </span><span class="koboSpan" id="kobo.73.3">So, the tests using a test web host are faster than those using a real web host. </span><span class="koboSpan" id="kobo.73.4">To use the test web host, we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">Microsoft.AspNetCore.Mvc.Testing</span></strong><span class="koboSpan" id="kobo.75.1"> NuGet package to the integration test project. </span><span class="koboSpan" id="kobo.75.2">You can add the package in VS 2022 by right-clicking on the project and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">Manage NuGet Packages</span></strong><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">Then search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">Microsoft.AspNetCore.Mvc.Testing</span></strong><span class="koboSpan" id="kobo.79.1"> and install </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the package.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">You can also use the following command to add </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">the package:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.83.1">
dotnet add InvoiceApp.IntegrationTests/InvoiceApp.IntegrationTests.csproj package Microsoft.AspNetCore.Mvc.Testing</span></pre> <p><span class="koboSpan" id="kobo.84.1">The default </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">UnitTest1.cs</span></strong><span class="koboSpan" id="kobo.86.1"> file can </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">be removed.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Feel free to </span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.89.1">install </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.91.1"> if you want to use it in the tests, as we demonstrated in the </span><em class="italic"><span class="koboSpan" id="kobo.92.1">Using FluentAssertions to verify the test results</span></em><span class="koboSpan" id="kobo.93.1"> section in </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.94.1">Chapter 9</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.95.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Now we can start to write </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">integratio</span><a id="_idTextAnchor410"/><span class="koboSpan" id="kobo.98.1">n tests.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor411"/><span class="koboSpan" id="kobo.99.1">Writing basic integration tests with WebApplicationFactory</span></h2>
<p><span class="koboSpan" id="kobo.100.1">Let'sstart</span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.101.1"> with a simple integration test to check whether the SUT can correctly handle the HTTP requests. </span><span class="koboSpan" id="kobo.101.2">The sample application has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">WeatherForecastController.cs</span></strong><span class="koboSpan" id="kobo.103.1"> controller that is provided by the ASP.NET Core project template. </span><span class="koboSpan" id="kobo.103.2">It returns a list of weather forecasts. </span><span class="koboSpan" id="kobo.103.3">We can write an integration test to check whether the controller returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">expected result.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Create a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">WeatherForecastApiTests</span></strong><span class="koboSpan" id="kobo.107.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">InvoiceApp.IntegrationTests</span></strong><span class="koboSpan" id="kobo.109.1"> project. </span><span class="koboSpan" id="kobo.109.2">Then add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.111.1">
public class WeatherForecastApiTests(WebApplicationFactory&lt;Program&gt; factory)    : IClassFixture&lt;WebApplicationFactory&lt;Program&gt;&gt;
{
}</span></pre>
<p><span class="koboSpan" id="kobo.112.1">In the </span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.113.1">test class, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">WebApplicationFactory&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.115.1"> type to create a test web host and use it as the class fixture. </span><span class="koboSpan" id="kobo.115.2">The instance of this class fixture will be shared across the tests in the class. </span><span class="koboSpan" id="kobo.115.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">WebApplicationFactory&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.117.1"> type is provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Microsoft.AspNetCore.Mvc.Testing</span></strong><span class="koboSpan" id="kobo.119.1"> package. </span><span class="koboSpan" id="kobo.119.2">It is a generic type that allows us to create a test web host for the specified application entry point. </span><span class="koboSpan" id="kobo.119.3">In this case, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Program</span></strong><span class="koboSpan" id="kobo.121.1"> class defined in the web API project as the entry point. </span><span class="koboSpan" id="kobo.121.2">But you will see an error that says </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">CS0122'Program' is inaccessible due to its protection level</span></strong><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Program</span></strong><span class="koboSpan" id="kobo.125.1"> class is defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">internal</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.127.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">To solve this issue, there are </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">two ways:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.130.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">InvoiceApp.WebApi.csproj</span></strong><span class="koboSpan" id="kobo.132.1"> file and add the following line to </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">the file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.134.1">
&lt;ItemGroup&gt;Â Â Â Â Â &lt;InternalsVisibleTo Include="MyTestProject" /&gt;&lt;/ItemGroup&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.135.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">MyTestProject</span></strong><span class="koboSpan" id="kobo.137.1"> with the name of your test project, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">InvoiceApp.IntegrationTests</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">This approach allows the test project to access the</span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.140.1"> internal members of the web </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">API project.</span></span></p></li> <li><span class="koboSpan" id="kobo.142.1">Alternatively, you can change the access modifier of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">Program</span></strong><span class="koboSpan" id="kobo.144.1"> class to </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">public</span></strong><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">Add the following code to the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.148.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.149.1">
public partial class Program { }</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.150.1">You can use either approach to solve the issue. </span><span class="koboSpan" id="kobo.150.2">After that, we can write the test method, </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
[Fact]public async Task GetWeatherForecast_ReturnsSuccessAndCorrectContentType()
{
Â Â Â Â // Arrange
Â Â Â Â var client = factory.CreateClient();
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/WeatherForecast");
Â Â Â Â // Assert
Â Â Â Â response.EnsureSuccessStatusCode(); // Status Code 200-299
Â Â Â Â Assert.Equal("application/json; charset=utf-8", response.Content.Headers.ContentType.ToString());
Â Â Â Â // Deserialize the response
Â Â Â Â var responseContent = await response.Content.ReadAsStringAsync();
Â Â Â Â var weatherForecast = JsonSerializer.Deserialize&lt;List&lt;WeatherForecast&gt;&gt;(responseContent, new JsonSerializerOptions
Â Â Â Â {
Â Â Â Â Â Â Â Â PropertyNameCaseInsensitive = true
Â Â Â Â });
Â Â Â Â weatherForecast.Should().NotBeNull();
Â Â Â Â weatherForecast.Should().HaveCount(5);
}</span></pre>
<p><span class="koboSpan" id="kobo.153.1">In the test </span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.154.1">method, we first create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">HttpClient</span></strong><span class="koboSpan" id="kobo.156.1"> class using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">WebApplicationFactory&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.158.1"> instance. </span><span class="koboSpan" id="kobo.158.2">Then we send an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">GET</span></strong><span class="koboSpan" id="kobo.160.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">/WeatherForecast</span></strong><span class="koboSpan" id="kobo.162.1"> endpoint. </span><span class="koboSpan" id="kobo.162.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">EnsureSuccessStatusCode</span></strong><span class="koboSpan" id="kobo.164.1"> method ensures that the response has a status code in the </span><em class="italic"><span class="koboSpan" id="kobo.165.1">200-299</span></em><span class="koboSpan" id="kobo.166.1"> range. </span><span class="koboSpan" id="kobo.166.2">Then we check whether the content type of the response is </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">application/json; charset=utf-8</span></strong><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">Finally, we deserialize the response content to a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">WeatherForecast</span></strong><span class="koboSpan" id="kobo.170.1"> objects and check whether the list contains </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">five items.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Because this controller does not have any dependencies, the test is simple. </span><span class="koboSpan" id="kobo.172.2">What if the controller has dependencies, such as a database context, other services, or other external dependencies? </span><span class="koboSpan" id="kobo.172.3">We will see how to handle these scenarios in the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">followi</span><a id="_idTextAnchor412"/><span class="koboSpan" id="kobo.174.1">ng sections.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor413"/><span class="koboSpan" id="kobo.175.1">Testing with a database context</span></h2>
<p><span class="koboSpan" id="kobo.176.1">In the </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.177.1">sample application, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">ContactController</span></strong><span class="koboSpan" id="kobo.179.1"> class has dependencies, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">IContactRepository</span></strong><span class="koboSpan" id="kobo.181.1"> interface. </span><span class="koboSpan" id="kobo.181.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">ContactRepository</span></strong><span class="koboSpan" id="kobo.183.1"> class implements this interface and uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">InvoiceContext</span></strong><span class="koboSpan" id="kobo.185.1"> class to access the database. </span><span class="koboSpan" id="kobo.185.2">So, if we want to test whether the SUT can correctly handle the HTTP requests, we need to create a test database and configure the test web host to use the test database. </span><span class="koboSpan" id="kobo.185.3">Similar to the unit tests, we can use a separate database for </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">WebApplicationFactory&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.189.1"> type provides a way to configure the test web host. </span><span class="koboSpan" id="kobo.189.2">We can override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">ConfigureWebHost</span></strong><span class="koboSpan" id="kobo.191.1"> method to configure the test web host. </span><span class="koboSpan" id="kobo.191.2">For example, we can replace the default database context with a test database context. </span><span class="koboSpan" id="kobo.191.3">Let us create a new </span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.192.1">text fixture class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">CustomIntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.194.1"> and add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
public class CustomIntegrationTestsFixture : WebApplicationFactory&lt;Program&gt;{
Â Â Â Â private const string ConnectionString = @"Server=(localdb)\mssqllocaldb;Database=InvoiceIntegrationTestDb;Trusted_Connection=True";
Â Â Â Â protected override void ConfigureWebHost(IWebHostBuilder builder)
Â Â Â Â {
Â Â Â Â Â Â Â Â // Set up a test database
Â Â Â Â Â Â Â Â builder.ConfigureServices(services =&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â var descriptor = services.SingleOrDefault(d =&gt; d.ServiceType == typeof(DbContextOptions&lt;InvoiceDbContext&gt;));
Â Â Â Â Â Â Â Â Â Â Â Â services.Remove(descriptor);
Â Â Â Â Â Â Â Â Â Â Â Â services.AddDbContext&lt;InvoiceDbContext&gt;(options =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.UseSqlServer(ConnectionString);
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â });
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.197.1">In the preceding code, we override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">ConfigureWebHost()</span></strong><span class="koboSpan" id="kobo.199.1"> method to configure the test web host for the SUT. </span><span class="koboSpan" id="kobo.199.2">When the test web host is created, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">Program</span></strong><span class="koboSpan" id="kobo.201.1"> class will execute first, which means the default database context defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Program</span></strong><span class="koboSpan" id="kobo.203.1"> class will be created. </span><span class="koboSpan" id="kobo.203.2">Then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">ConfigureWebHost()</span></strong><span class="koboSpan" id="kobo.205.1"> method defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">CustomIntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.207.1"> class will be executed. </span><span class="koboSpan" id="kobo.207.2">So we need to find the default database context using </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">services.SingleOrDefault(d =&gt; d.ServiceType == typeof(DbContextOptions&lt;InvoiceDbContext&gt;))</span></strong><span class="koboSpan" id="kobo.209.1"> and then remove it from the </span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.210.1">service collection. </span><span class="koboSpan" id="kobo.210.2">Then we add a new database context that uses the test database. </span><span class="koboSpan" id="kobo.210.3">This approach allows us to use a separate database for integration tests. </span><span class="koboSpan" id="kobo.210.4">We also need to create the test database and seed some test data when we initialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">test fixture.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">You can also add more customizations to the test web host in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">ConfigureWebHost()</span></strong><span class="koboSpan" id="kobo.214.1"> method. </span><span class="koboSpan" id="kobo.214.2">For example, you can configure the test web host to use a different configuration file, </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
builder.ConfigureAppConfiguration((context, config) =&gt;{
Â Â Â Â config.AddJsonFile("appsettings.IntegrationTest.json");
});</span></pre>
<p><span class="koboSpan" id="kobo.217.1">The default environment for the test web host of the SUT is </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Development</span></strong><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">If you want to use a different environment, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">UseEnvironment()</span></strong><span class="koboSpan" id="kobo.221.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
builder.UseEnvironment("IntegrationTest");</span></pre> <p><span class="koboSpan" id="kobo.224.1">Next, we need a way to create the test database and seed some test data. </span><span class="koboSpan" id="kobo.224.2">Create a static class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">Utilities</span></strong><span class="koboSpan" id="kobo.226.1"> and add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
public static class Utilities{
Â Â Â Â public static void InitializeDatabase(InvoiceDbContext context)
Â Â Â Â {
Â Â Â Â Â Â Â Â context.Database.EnsureDeleted();
Â Â Â Â Â Â Â Â context.Database.EnsureCreated();
Â Â Â Â Â Â Â Â SeedDatabase(context);
Â Â Â Â }
Â Â Â Â public static void Cleanup(InvoiceDbContext context)
Â Â Â Â {
Â Â Â Â Â Â Â Â context.Contacts.ExecuteDelete();
Â Â Â Â Â Â Â Â context.Invoices.ExecuteDelete();
Â Â Â Â Â Â Â Â context.SaveChanges();
Â Â Â Â Â Â Â Â SeedDatabase(context);
Â Â Â Â }
Â Â Â Â private static void SeedDatabase(InvoiceDbContext context)
Â Â Â Â {
Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.229.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Utilities</span></strong><span class="koboSpan" id="kobo.231.1"> class </span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.232.1">contains a few static methods that help us manage the test database. </span><span class="koboSpan" id="kobo.232.2">We need to initialize the test database before we run the tests and clean up the test database after we run the tests that change the data in </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">When should we initialize the test database? </span><span class="koboSpan" id="kobo.234.2">We learned that the instance of the class fixture is created before the test class is initialized and is shared among all test methods in the test class. </span><span class="koboSpan" id="kobo.234.3">So, we can initialize the test database in the class fixture. </span><span class="koboSpan" id="kobo.234.4">Update the following code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">ConfigureWebHost()</span></strong><span class="koboSpan" id="kobo.236.1"> method of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">CustomIntegrationTestsFixture</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.239.1">
builder.ConfigureServices(services =&gt;{
Â Â Â Â var descriptor = services.SingleOrDefault(d =&gt; d.ServiceType == typeof(DbContextOptions&lt;InvoiceDbContext&gt;));
Â Â Â Â services.Remove(descriptor);
Â Â Â Â services.AddDbContext&lt;InvoiceDbContext&gt;(options =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â options.UseSqlServer(ConnectionString);
Â Â Â Â });
Â Â Â Â using var scope = services.BuildServiceProvider().CreateScope();
Â Â Â Â var scopeServices = scope.ServiceProvider;
Â Â Â Â var dbContext = scopeServices.GetRequiredService&lt;InvoiceDbContext&gt;();
Â Â Â Â Utilities.InitializeDatabase(dbContext);
});</span></pre>
<p><span class="koboSpan" id="kobo.240.1">When the</span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.241.1"> test web host of SUT is created, we replace the default database context with a test database context, and also initialize the test database, so that all the test methods in the test class can use the same </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">test database.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Next, we can create a new test class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">InvoicesApiTests</span></strong><span class="koboSpan" id="kobo.245.1">, which is used to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">/api/invoices</span></strong><span class="koboSpan" id="kobo.247.1"> endpoint. </span><span class="koboSpan" id="kobo.247.2">Add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.249.1">
public class InvoicesApiTests(CustomIntegrationTestsFixture factory) : IClassFixture&lt;CustomIntegrationTestsFixture&gt;{
}</span></pre>
<p><span class="koboSpan" id="kobo.250.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">InvoicesApiTests</span></strong><span class="koboSpan" id="kobo.252.1"> test class will be initialized with an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">CustomIntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.254.1"> class. </span><span class="koboSpan" id="kobo.254.2">Then we can create some test methods to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">/api/invoices</span></strong><span class="koboSpan" id="kobo.256.1"> endpoint. </span><span class="koboSpan" id="kobo.256.2">A test method to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">GET /api/invoices</span></strong><span class="koboSpan" id="kobo.258.1"> endpoint</span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.259.1"> might look </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
[Fact]public async Task GetInvoices_ReturnsSuccessAndCorrectContentType()
{
Â Â Â Â // Arrange
Â Â Â Â var client = _factory.CreateClient();
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/api/invoice");
Â Â Â Â // Assert
Â Â Â Â response.EnsureSuccessStatusCode(); // Status Code 200-299
Â Â Â Â response.Content.Headers.ContentType.Should().NotBeNull();
Â Â Â Â response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
Â Â Â Â // Deserialize the response
Â Â Â Â var responseContent = await response.Content.ReadAsStringAsync();
Â Â Â Â var invoices = JsonSerializer.Deserialize&lt;List&lt;Invoice&gt;&gt;(responseContent, new JsonSerializerOptions
Â Â Â Â {
Â Â Â Â Â Â Â Â PropertyNameCaseInsensitive = true
Â Â Â Â });
Â Â Â Â invoices.Should().NotBeNull();
Â Â Â Â invoices.Should().HaveCount(2);
}</span></pre>
<p><span class="koboSpan" id="kobo.262.1">As this request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">GET /api/invoices</span></strong><span class="koboSpan" id="kobo.264.1"> endpoint does not change the database, the test method </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">is straightforward.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Next, </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.267.1">let's see how to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">POST /api/invoices</span></strong><span class="koboSpan" id="kobo.269.1"> endpoint, which changes the database. </span><span class="koboSpan" id="kobo.269.2">A test method to test this endpoint might look </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
[Fact]public async Task PostInvoice_ReturnsSuccessAndCorrectContentType()
{
Â Â Â Â // Arrange
Â Â Â Â var client = factory.CreateClient();
Â Â Â Â var invoice = new Invoice
Â Â Â Â {
Â Â Â Â Â Â Â Â DueDate = DateTimeOffset.Now.AddDays(30),
Â Â Â Â Â Â Â Â ContactId = Guid.Parse("8a9de219-2dde-4f2a-9ebd-b1f8df9fef03"),
Â Â Â Â Â Â Â Â Status = InvoiceStatus.Draft,
Â Â Â Â Â Â Â Â InvoiceItems = new List&lt;InvoiceItem&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â // Omitted for brevityÂ Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â var json = JsonSerializer.Serialize(invoice);
Â Â Â Â var data = new StringContent(json, Encoding.UTF8, "application/json");
Â Â Â Â // Act
Â Â Â Â var response = await client.PostAsync("/api/invoice", data);
Â Â Â Â // Assert
Â Â Â Â response.EnsureSuccessStatusCode(); // Status Code 200-299
Â Â Â Â response.Content.Headers.ContentType.Should().NotBeNull();
Â Â Â Â response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
Â Â Â Â // Deserialize the response
Â Â Â Â var responseContent = await response.Content.ReadAsStringAsync();
Â Â Â Â var invoiceResponse = JsonSerializer.Deserialize&lt;Invoice&gt;(responseContent, new JsonSerializerOptions
Â Â Â Â {
Â Â Â Â Â Â Â Â PropertyNameCaseInsensitive = true
Â Â Â Â });
Â Â Â Â invoiceResponse.Should().NotBeNull();
Â Â Â Â invoiceResponse!.Id.Should().NotBeEmpty();
Â Â Â Â invoiceResponse.Amount.Should().Be(500);
Â Â Â Â invoiceResponse.Status.Should().Be(invoice.Status);
Â Â Â Â invoiceResponse.ContactId.Should().Be(invoice.ContactId);
Â Â Â Â // Clean up the database
Â Â Â Â var scope = factory.Services.CreateScope();
Â Â Â Â var scopedServices = scope.ServiceProvider;
Â Â Â Â var db = scopedServices.GetRequiredService&lt;InvoiceDbContext&gt;();
Â Â Â Â Utilities.Cleanup(db);
}</span></pre>
<p><span class="koboSpan" id="kobo.272.1">As this </span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.273.1">request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">POST /api/invoices</span></strong><span class="koboSpan" id="kobo.275.1"> endpoint changes the database, we need to clean up the database after we run the test. </span><span class="koboSpan" id="kobo.275.2">To get the current instance of the database context, we need to create a new scope and get the database context from the scope. </span><span class="koboSpan" id="kobo.275.3">Then we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Cleanup</span></strong><span class="koboSpan" id="kobo.277.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">Utilities</span></strong><span class="koboSpan" id="kobo.279.1"> class to clean up </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">A test for the sad path of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">POST /api/invoices</span></strong><span class="koboSpan" id="kobo.283.1"> endpoint might look </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
[Fact]public async Task PostInvoice_WhenContactIdDoesNotExist_ReturnsBadRequest()
{
Â Â Â Â // Arrange
Â Â Â Â var client = factory.CreateClient();
Â Â Â Â var invoice = new Invoice
Â Â Â Â {
Â Â Â Â Â Â Â Â DueDate = DateTimeOffset.Now.AddDays(30),
Â Â Â Â Â Â Â Â ContactId = Guid.NewGuid(),
Â Â Â Â Â Â Â Â Status = InvoiceStatus.Draft,
Â Â Â Â Â Â Â Â InvoiceItems = new List&lt;InvoiceItem&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â var json = JsonSerializer.Serialize(invoice);
Â Â Â Â var data = new StringContent(json, Encoding.UTF8, "application/json");
Â Â Â Â // Act
Â Â Â Â var response = await client.PostAsync("/api/invoice", data);
Â Â Â Â // Assert
Â Â Â Â response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
}</span></pre>
<p><span class="koboSpan" id="kobo.286.1">You can try</span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.287.1"> to add more integration tests per your needs. </span><span class="koboSpan" id="kobo.287.2">Note that we need to manage the test database carefully. </span><span class="koboSpan" id="kobo.287.3">If you have multiple test classes that change the database, you may need to follow the same pattern (using a lock or collection fixture) as that in the unit tests we introduced in the </span><em class="italic"><span class="koboSpan" id="kobo.288.1">Creating a test fixture</span></em><span class="koboSpan" id="kobo.289.1"> section in </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.290.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.291.1">, to ensure the test database is clean before each test class runs and clean up the test database after each test </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">class runs.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">For example, if we have another </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">ContactsApiTests</span></strong><span class="koboSpan" id="kobo.295.1"> class that also uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">CustomIntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.297.1">, xUnit will run </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">InvoicesApiTests</span></strong><span class="koboSpan" id="kobo.299.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">ContactsApiTests</span></strong><span class="koboSpan" id="kobo.301.1"> in parallel. </span><span class="koboSpan" id="kobo.301.2">This may cause issues because both test classes try to initialize the test database at the same time. </span><span class="koboSpan" id="kobo.301.3">To avoid this issue, we can run these test classes in one collection to ensure that they </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">run sequentially.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">We can </span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.304.1">demonstrate this by creating a test collection named </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">CustomIntegrationTests</span></strong><span class="koboSpan" id="kobo.306.1"> and adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">CollectionDefinition</span></strong><span class="koboSpan" id="kobo.308.1"> attribute to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">CustomIntegrationTestsCollection</span></strong><span class="koboSpan" id="kobo.310.1"> class. </span><span class="koboSpan" id="kobo.310.2">This attribute will enable us to define the collection and its associated tests, as </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
[CollectionDefinition("CustomIntegrationTests")]public class CustomIntegrationTestsCollection : ICollectionFixture&lt;CustomIntegrationTestsFixture&gt;
{
}</span></pre>
<p><span class="koboSpan" id="kobo.313.1">Then we can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">Collection</span></strong><span class="koboSpan" id="kobo.315.1"> attribute to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">InvoicesApiTestsWithCollection</span></strong><span class="koboSpan" id="kobo.317.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">ContactsApiTestsWithCollection</span></strong><span class="koboSpan" id="kobo.319.1"> classes. </span><span class="koboSpan" id="kobo.319.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">InvoicesApiTestsWithCollection</span></strong><span class="koboSpan" id="kobo.321.1"> class might look </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
[Collection("CustomIntegrationTests")]public class InvoicesApiTestsWithCollection(CustomIntegrationTestsFixture factory) : IDisposable
{
Â Â Â Â // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.324.1">You can find the complete source code in the sample repo. </span><span class="koboSpan" id="kobo.324.2">Note that the normal integration test class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">InvoicesApiTests</span></strong><span class="koboSpan" id="kobo.326.1">, does not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Collection</span></strong><span class="koboSpan" id="kobo.328.1"> attribute, so </span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.329.1">xUnit will run it in parallel with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">CustomIntegrationTests</span></strong><span class="koboSpan" id="kobo.331.1"> collection. </span><span class="koboSpan" id="kobo.331.2">To avoid conflicts, we can skip the test methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">InvoicesApiTests</span></strong><span class="koboSpan" id="kobo.333.1"> class, as </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.335.1">
[Fact(Skip = "This test is skipped to avoid conflicts with the test collection")]public async Task GetInvoices_ReturnsSuccessAndCorrectContentType()
{
Â Â Â Â // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.336.1">When you run the tests in the sample repo, please add or comment out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Skip</span></strong><span class="koboSpan" id="kobo.338.1"> att</span><a id="_idTextAnchor414"/><span class="koboSpan" id="kobo.339.1">ributes per </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">your needs.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor415"/><span class="koboSpan" id="kobo.341.1">Testing with mock services</span></h2>
<p><span class="koboSpan" id="kobo.342.1">As we</span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.343.1"> explained in </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.344.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.345.1">, unit tests should focus on isolated units of code. </span><span class="koboSpan" id="kobo.345.2">So, unit tests often use mock or stub services to isolate the code under test from other services. </span><span class="koboSpan" id="kobo.345.3">Integration tests, on the other hand, should test the integration between different components. </span><span class="koboSpan" id="kobo.345.4">So, technically, integration tests should use real services instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">mock services.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">However, in some cases, using mock dependencies in integration tests can be helpful. </span><span class="koboSpan" id="kobo.347.2">For example, in the sample invoice application, we need to call a third-party service to send emails. </span><span class="koboSpan" id="kobo.347.3">If we use the real email service in the integration tests, it may have the </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">following issues:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.349.1">The actual email service may not be available in the test environment. </span><span class="koboSpan" id="kobo.349.2">For example, the email service may be hosted in a different environment, and the test environment may not be able to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">email service.</span></span></li>
<li><span class="koboSpan" id="kobo.351.1">The email service may have rate limits, strict network policies, or other restrictions that may cause issues in the integration tests or slow down the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">test execution.</span></span></li>
<li><span class="koboSpan" id="kobo.353.1">The email service may cause unnecessary costs in the test environment, especially if the service has usage-based pricing or requires a paid subscription. </span><span class="koboSpan" id="kobo.353.2">If we run the integration tests frequently, it may incur </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">high costs.</span></span></li>
<li><span class="koboSpan" id="kobo.355.1">The test may impact production and cause issues for </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">real users.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.357.1">In this </span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.358.1">case, using a mock email service in the integration can help us avoid these issues so that we can run the tests faster and more efficiently, avoid impacting production, and </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">save costs.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Let's see how to use a mock email service in the integration tests. </span><span class="koboSpan" id="kobo.360.2">The service we use to send email is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">IEmailSender</span></strong><span class="koboSpan" id="kobo.362.1"> interface. </span><span class="koboSpan" id="kobo.362.2">We can inject a mock service that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">IEmailSender</span></strong><span class="koboSpan" id="kobo.364.1"> interface in the integration tests. </span><span class="koboSpan" id="kobo.364.2">Create a new test method in the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">test class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
[Theory][InlineData("7e096984-5919-492c-8d4f-ce93f25eaed5")]
[InlineData("b1ca459c-6874-4f2b-bc9d-f3a45a9120e4")]
public async Task SendInvoiceAsync_ReturnsSuccessAndCorrectContentType(string invoiceId)
{
Â Â Â Â // Arrange
Â Â Â Â var mockEmailSender = new Mock&lt;IEmailSender&gt;();
Â Â Â Â mockEmailSender.Setup(x =&gt; x.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))
Â Â Â Â Â Â Â Â .Returns(Task.CompletedTask).Verifiable();
Â Â Â Â var client = factory.WithWebHostBuilder(builder =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â builder.ConfigureTestServices(services =&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â var emailSender = services.SingleOrDefault(x =&gt; x.ServiceType == typeof(IEmailSender));
Â Â Â Â Â Â Â Â Â Â Â Â services.Remove(emailSender);
Â Â Â Â Â Â Â Â Â Â Â Â services.AddScoped&lt;IEmailSender&gt;(_ =&gt; mockEmailSender.Object);
Â Â Â Â Â Â Â Â });
Â Â Â Â }).CreateClient();
Â Â Â Â // Act
Â Â Â Â var response = await client.PostAsync($"/api/invoice/{invoiceId}/send", null);
Â Â Â Â // Assert
Â Â Â Â response.EnsureSuccessStatusCode(); // Status Code 200-299
Â Â Â Â mockEmailSender.Verify(x =&gt; x.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()), Times.Once);
Â Â Â Â var scope = factory.Services.CreateScope();
Â Â Â Â var scopedServices = scope.ServiceProvider;
Â Â Â Â var db = scopedServices.GetRequiredService&lt;InvoiceDbContext&gt;();
Â Â Â Â var invoice = await db.Invoices.FindAsync(Guid.Parse(invoiceId));
Â Â Â Â invoice!.Status.Should().Be(InvoiceStatus.AwaitPayment);
}</span></pre>
<p><span class="koboSpan" id="kobo.367.1">In the preceding code, we created a mock email sender service using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">Moq</span></strong><span class="koboSpan" id="kobo.369.1"> library. </span><span class="koboSpan" id="kobo.369.2">The test web host of SUT provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">WithWebHostBuilder()</span></strong><span class="koboSpan" id="kobo.371.1"> method to configure the web host builder. </span><span class="koboSpan" id="kobo.371.2">In this method, we can configure the service collection of the web host using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">ConfigureTestServices()</span></strong><span class="koboSpan" id="kobo.373.1"> method. </span><span class="koboSpan" id="kobo.373.2">Similar to the mock database context we introduced in the </span><em class="italic"><span class="koboSpan" id="kobo.374.1">Testing with a database context</span></em><span class="koboSpan" id="kobo.375.1"> section, we find the registered </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">IEmailSender</span></strong><span class="koboSpan" id="kobo.377.1"> service and remove it from the service collection, then add the mock service to the service collection. </span><span class="koboSpan" id="kobo.377.2">Finally, we create the HTTP client and send the request to the API endpoint. </span><span class="koboSpan" id="kobo.377.3">If the mock service is used correctly, the test </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">should pass.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">In summary, whether</span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.380.1"> to use mock services in integration tests or not should be decided on a case-by-case basis and depends on the specific requirements and objectives of the tests. </span><span class="koboSpan" id="kobo.380.2">Mocks can be useful in certain scenarios, but they should not be overused, otherwise, the integration tests may not be able to reflect the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">real-world scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">If your web API project runs in a microservice architecture, you may need to call other microservices in the integration tests. </span><span class="koboSpan" id="kobo.382.2">In this case, you can use the same approach to mock the HTTP client and the HTTP responses. </span><span class="koboSpan" id="kobo.382.3">The integration tests may be more complicated. </span><span class="koboSpan" id="kobo.382.4">We will stop here and explore more when we discuss the microservice archite</span><a id="_idTextAnchor416"/><span class="koboSpan" id="kobo.383.1">cture in the </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">next chapter.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor417"/><span class="koboSpan" id="kobo.385.1">Testing with authentication and authorization</span></h1>
<p><span class="koboSpan" id="kobo.386.1">A common</span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.387.1"> scenario in web APIs is that some API endpoints require authentication and authorization. </span><span class="koboSpan" id="kobo.387.2">We introduced how to implement authentication and authorization in </span><a href="B18971_08.xhtml#_idTextAnchor307"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.388.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.389.1">. </span><span class="koboSpan" id="kobo.389.2">In this section, we will discuss how to test the API endpoints that require authen</span><a id="_idTextAnchor418"/><span class="koboSpan" id="kobo.390.1">tication </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">and authorization.</span></span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor419"/><span class="koboSpan" id="kobo.392.1">Preparing the sample application</span></h2>
<p><span class="koboSpan" id="kobo.393.1">To demonstrate</span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.394.1"> testing with authentication and authorization, we will use the sample application we created in </span><a href="B18971_08.xhtml#_idTextAnchor307"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.395.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">You can find the source code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">chapter10\AuthTestsDemo\start\</span></strong><span class="koboSpan" id="kobo.398.1"> folder of the sample repo. </span><span class="koboSpan" id="kobo.398.2">This sample application uses claims-based authentication and authorization. </span><span class="koboSpan" id="kobo.398.3">You can recap the implementation details in </span><a href="B18971_08.xhtml#_idTextAnchor307"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.399.1">Chapter 8</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.400.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.403.1">, there are several methods that require authentication and authorization. </span><span class="koboSpan" id="kobo.403.2">(Forgive the naming â€“ we just use the default template of ASP.NET Core </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">web APIs.)</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Create a new </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.406.1">integration test project as described in the </span><em class="italic"><span class="koboSpan" id="kobo.407.1">Setting up the integration test project</span></em><span class="koboSpan" id="kobo.408.1"> section. </span><span class="koboSpan" id="kobo.408.2">You need to ensure that the integration test project has the following NuGet </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">packages installed:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Microsoft.AspNetCore.Mvc.Testing</span></strong><span class="koboSpan" id="kobo.411.1">: This is the test web host </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">of SUT</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">xUnit</span></strong><span class="koboSpan" id="kobo.414.1">: This is the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">test framework</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">Moq</span></strong><span class="koboSpan" id="kobo.417.1">: This is the </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">mocking library</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.420.1">: This is the assertion </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">library (optional)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.422.1">If you want to run the tests in VS 2022, you also need to install </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">xunit.runner.visualstudio</span></strong><span class="koboSpan" id="kobo.424.1">, the test runner for </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">VS 2022.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">Also add the reference to the sample application project. </span><span class="koboSpan" id="kobo.426.2">For simplicity, we will only focus on the integration tests for authentication and authorization. </span><span class="koboSpan" id="kobo.426.3">So, this demo does not involve the database context and </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">Another thing you need to do is make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Program</span></strong><span class="koboSpan" id="kobo.430.1"> class public. </span><span class="koboSpan" id="kobo.430.2">Just add the following code at the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
public partial class Program { }</span></pre> <p><span class="koboSpan" id="kobo.434.1">Next, we can start to write the integration tests for the API endpoints that require auth</span><a id="_idTextAnchor420"/><span class="koboSpan" id="kobo.435.1">entication </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">and authorization.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor421"/><span class="koboSpan" id="kobo.437.1">Creating a test fixture</span></h2>
<p><span class="koboSpan" id="kobo.438.1">As we</span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.439.1"> explained in the </span><em class="italic"><span class="koboSpan" id="kobo.440.1">Creating a test fixture</span></em><span class="koboSpan" id="kobo.441.1"> section in </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.442.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.443.1">, we can create a test fixture to share the common code among the tests. </span><span class="koboSpan" id="kobo.443.2">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">IntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.445.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.447.1">
public class IntegrationTestsFixture : WebApplicationFactory&lt;Program&gt;{
Â Â Â Â protected override void ConfigureWebHost(IWebHostBuilder builder)
Â Â Â Â {
Â Â Â Â Â Â Â Â // This is where you can set up your test server with the services you need
Â Â Â Â Â Â Â Â base.ConfigureWebHost(builder);
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.448.1">This is a </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.449.1">simple test fixture that inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">WebApplicationFactory&lt;Program&gt;</span></strong><span class="koboSpan" id="kobo.451.1"> class. </span><span class="koboSpan" id="kobo.451.2">Because we do not need to set up any services in this demo, there is no custom code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">ConfigureWebHost</span></strong><span class="koboSpan" id="kobo.453.1"> method. </span><span class="koboSpan" id="kobo.453.2">If you need to set up services</span><a id="_idTextAnchor422"/><span class="koboSpan" id="kobo.454.1">, you can do it in </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">this method.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor423"/><span class="koboSpan" id="kobo.456.1">Creating the test class</span></h2>
<p><span class="koboSpan" id="kobo.457.1">Next, we</span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.458.1"> can create the test class. </span><span class="koboSpan" id="kobo.458.2">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">AuthTests</span></strong><span class="koboSpan" id="kobo.460.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
public class AuthTests(IntegrationTestsFixture fixture) : IClassFixture&lt;IntegrationTestsFixture&gt;{
}</span></pre>
<p><span class="koboSpan" id="kobo.463.1">This is similar to the test class we created in the </span><em class="italic"><span class="koboSpan" id="kobo.464.1">Using the test fixture</span></em><span class="koboSpan" id="kobo.465.1"> section in </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.466.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">It inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">IClassFixture&lt;IntegrationTestsFixture&gt;</span></strong><span class="koboSpan" id="kobo.469.1"> interface and has </span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.470.1">a constructor that accepts an </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">IntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.472.1"> instance. </span><span class="koboSpan" id="kobo.472.2">So, the test class can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">IntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.474.1"> instance to access the test web host of SUT. </span><span class="koboSpan" id="kobo.474.2">So far, there is n</span><a id="_idTextAnchor424"/><span class="koboSpan" id="kobo.475.1">o special code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">test class.</span></span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor425"/><span class="koboSpan" id="kobo.477.1">Testing the anonymous API endpoints</span></h2>
<p><span class="koboSpan" id="kobo.478.1">Next, let us</span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.479.1"> test the API endpoints that do not require authentication and authorization. </span><span class="koboSpan" id="kobo.479.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.481.1"> class, copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Get()</span></strong><span class="koboSpan" id="kobo.483.1"> method and paste it below the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">Get()</span></strong><span class="koboSpan" id="kobo.485.1"> method. </span><span class="koboSpan" id="kobo.485.2">Rename the new method </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">GetAnonymous()</span></strong><span class="koboSpan" id="kobo.487.1"> and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">AllowAnonymous</span></strong><span class="koboSpan" id="kobo.489.1"> attribute. </span><span class="koboSpan" id="kobo.489.2">The new method should look like the </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
[AllowAnonymous][HttpGet("anonymous")]
public IEnumerable&lt;WeatherForecast&gt; GetAnonymous()
{
Â Â Â Â // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.492.1">Now, we have a new API endpoint that does not require authentication and authorization. </span><span class="koboSpan" id="kobo.492.2">Create a new test method in the </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">test class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
[Fact]public async Task GetAnonymousWeatherForecast_ShouldReturnOk()
{
Â Â Â Â // Arrange
Â Â Â Â var client = fixture.CreateClient();
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/weatherforecast/anonymous");
Â Â Â Â // Assert
Â Â Â Â response.EnsureSuccessStatusCode(); // Status Code 200-299
Â Â Â Â response.Content.Headers.ContentType.Should().NotBeNull();
Â Â Â Â response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
Â Â Â Â // Deserialize the response
Â Â Â Â var responseContent = await response.Content.ReadAsStringAsync();
Â Â Â Â var weatherForecasts = JsonSerializer.Deserialize&lt;List&lt;WeatherForecast&gt;&gt;(responseContent, new JsonSerializerOptions
Â Â Â Â {
Â Â Â Â Â Â Â Â PropertyNameCaseInsensitive = true
Â Â Â Â });
Â Â Â Â weatherForecasts.Should().NotBeNull();
Â Â Â Â weatherForecasts.Should().HaveCount(5);
}</span></pre>
<p><span class="koboSpan" id="kobo.495.1">There </span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.496.1">are not many differences between this test method and the test method we created in the </span><em class="italic"><span class="koboSpan" id="kobo.497.1">Using the test fixture</span></em><span class="koboSpan" id="kobo.498.1"> section in </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.499.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">When we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">CreateClient()</span></strong><span class="koboSpan" id="kobo.502.1"> method, there is no special code to set up </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">HttpClient</span></strong><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">So, the test method can send the request to the API endpoint without any authentication and authorization. </span><span class="koboSpan" id="kobo.504.3">Because this endpoint allows anon</span><a id="_idTextAnchor426"/><span class="koboSpan" id="kobo.505.1">ymous access, the test </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">should pass.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor427"/><span class="koboSpan" id="kobo.507.1">Testing the authorized API endpoints</span></h2>
<p><span class="koboSpan" id="kobo.508.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.510.1"> class has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">Authorize</span></strong><span class="koboSpan" id="kobo.512.1"> attribute. </span><span class="koboSpan" id="kobo.512.2">So, the API endpoints</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.513.1"> that do not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">AllowAnonymous</span></strong><span class="koboSpan" id="kobo.515.1"> attribute require authentication and authorization. </span><span class="koboSpan" id="kobo.515.2">Let's test the sad path for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">Get()</span></strong><span class="koboSpan" id="kobo.517.1"> method. </span><span class="koboSpan" id="kobo.517.2">Create a new test method in the </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">test class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
[Fact]public async Task GetWeatherForecast_ShouldReturnUnauthorized_WhenNotAuthorized()
{
Â Â Â Â // Arrange
Â Â Â Â var client = fixture.CreateClient();
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/weatherforecast");
Â Â Â Â // Assert
Â Â Â Â response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
}</span></pre>
<p><span class="koboSpan" id="kobo.520.1">This test method is similar to the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">GetAnonymousWeatherForecast_ShouldReturnOk()</span></strong><span class="koboSpan" id="kobo.522.1"> method, but we expect the status code to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">401 Unauthorized</span></strong><span class="koboSpan" id="kobo.524.1"> because the API endpoint requires authentication and authorization. </span><span class="koboSpan" id="kobo.524.2">This test should pass </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">Next, we need to set up the authentication and authorization in the test. </span><span class="koboSpan" id="kobo.526.2">There are several ways to </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">do this:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.528.1">In the test, call the authentication endpoint to get the access token. </span><span class="koboSpan" id="kobo.528.2">Then add the access token to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">Authorization</span></strong><span class="koboSpan" id="kobo.530.1"> header of the HTTP request. </span><span class="koboSpan" id="kobo.530.2">However, this approach is not recommended because it needs additional effort to maintain the credentials, such as the username, password, client ID, client secret, and so on. </span><span class="koboSpan" id="kobo.530.3">Also, the tests may not be able to access the authentication endpoint in the test environment. </span><span class="koboSpan" id="kobo.530.4">If the tests depend on the authentication endpoint, it increases the complexity of </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">the tests.</span></span></li>
<li><span class="koboSpan" id="kobo.532.1">Create a</span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.533.1"> helper method to generate the access token. </span><span class="koboSpan" id="kobo.533.2">Then add the access token to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Authorization</span></strong><span class="koboSpan" id="kobo.535.1"> header of the HTTP request. </span><span class="koboSpan" id="kobo.535.2">This approach does not need to call the authentication endpoint in the test. </span><span class="koboSpan" id="kobo.535.3">However, it means that we need to know how to generate the access token. </span><span class="koboSpan" id="kobo.535.4">If the authentication logic is provided by a third-party provider, we may not be able to make the same implementation in the test. </span><span class="koboSpan" id="kobo.535.5">So, it is only available if we have full control of the </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">authentication logic.</span></span></li>
<li><span class="koboSpan" id="kobo.537.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">WebApplicationFactory</span></strong><span class="koboSpan" id="kobo.539.1"> to set up the authentication and authorization and create a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">AuthenticationHandler</span></strong><span class="koboSpan" id="kobo.541.1"> to simulate the authentication and authorization process. </span><span class="koboSpan" id="kobo.541.2">This approach is more practical because it does not need to call the authentication endpoint in the test. </span><span class="koboSpan" id="kobo.541.3">Also, it does not need to duplicate the authentication logic in the </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">test project.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.543.1">As we have the source code of the sample application, which includes the authentication logic, we can demonstrate how to use the second approach, and then we will sh</span><a id="_idTextAnchor428"/><span class="koboSpan" id="kobo.544.1">ow you how to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">third approach.</span></span></p>
<h3><span class="koboSpan" id="kobo.546.1">Generating the access token in the test</span></h3>
<p><span class="koboSpan" id="kobo.547.1">The code we use to </span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.548.1">generate the access token is from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">AccountController</span></strong><span class="koboSpan" id="kobo.550.1"> class, which is the authentication endpoint. </span><span class="koboSpan" id="kobo.550.2">We can find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">GenerateToken</span></strong><span class="koboSpan" id="kobo.552.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">AccountController</span></strong><span class="koboSpan" id="kobo.554.1"> class. </span><span class="koboSpan" id="kobo.554.2">This method is invoked when the user successfully logs in. </span><span class="koboSpan" id="kobo.554.3">Create a new method in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">IntegrationTestsFixture</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
public string? </span><span class="koboSpan" id="kobo.557.2">GenerateToken(string userName){
Â Â Â Â using var scope = Services.CreateScope();
Â Â Â Â var configuration = scope.ServiceProvider.GetRequiredService&lt;IConfiguration&gt;();
Â Â Â Â var secret = configuration["JwtConfig:Secret"];
Â Â Â Â var issuer = configuration["JwtConfig:ValidIssuer"];
Â Â Â Â var audience = configuration["JwtConfig:ValidAudiences"];
Â Â Â Â // Omitted for brevity
Â Â Â Â var securityToken = tokenHandler.CreateToken(tokenDescriptor);
Â Â Â Â var token = tokenHandler.WriteToken(securityToken);
Â Â Â Â return token;
}</span></pre>
<p><span class="koboSpan" id="kobo.558.1">In the </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.559.1">preceding method, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">IConfiguration</span></strong><span class="koboSpan" id="kobo.561.1"> service to get the secret, issuer, and audience from the configuration. </span><span class="koboSpan" id="kobo.561.2">Then we copy the code from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">GenerateToken()</span></strong><span class="koboSpan" id="kobo.563.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">AccountController</span></strong><span class="koboSpan" id="kobo.565.1"> class to generate the access token. </span><span class="koboSpan" id="kobo.565.2">Note that the configuration comes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.567.1"> file in the main web API project. </span><span class="koboSpan" id="kobo.567.2">As we did not change the configuration of the test web host, the configuration is the same as that in the main web API project. </span><span class="koboSpan" id="kobo.567.3">But if you need to use a different configuration for the tests, please add proper code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">ConfigureWebHost</span></strong><span class="koboSpan" id="kobo.569.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">IntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.571.1"> class to apply any changes, as we introduced in the </span><em class="italic"><span class="koboSpan" id="kobo.572.1">Creating a test </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.573.1">fixture</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.574.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">Next, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">GenerateToken</span></strong><span class="koboSpan" id="kobo.577.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">AuthTest</span></strong><span class="koboSpan" id="kobo.579.1"> class. </span><span class="koboSpan" id="kobo.579.2">Create a new test method in the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">test class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
[Fact]public async Task GetWeatherForecast_ShouldReturnOk_WhenAuthorized()
{
Â Â Â Â // Arrange
Â Â Â Â var token = fixture.GenerateToken("TestUser");
Â Â Â Â var client = fixture.CreateClient();
Â Â Â Â client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/weatherforecast");
Â Â Â Â // Assert
Â Â Â Â response.EnsureSuccessStatusCode(); // Status Code 200-299
Â Â Â Â // Omited for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.582.1">In this </span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.583.1">test method, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">GenerateToken()</span></strong><span class="koboSpan" id="kobo.585.1"> method to generate an access token, and then add the access token to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">Authorization</span></strong><span class="koboSpan" id="kobo.587.1"> header of the HTTP request. </span><span class="koboSpan" id="kobo.587.2">Because the logic we use to generate the token is the same as the authen</span><a id="_idTextAnchor429"/><span class="koboSpan" id="kobo.588.1">tication endpoint, the test </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">should pass.</span></span></p>
<h3><span class="koboSpan" id="kobo.590.1">Using a custom authentication handler</span></h3>
<p><span class="koboSpan" id="kobo.591.1">Another </span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.592.1">way to test the authorized API endpoints is to use a custom authentication handler. </span><span class="koboSpan" id="kobo.592.2">A custom authentication handler can simulate the authentication and authorization process. </span><span class="koboSpan" id="kobo.592.3">So, we can use it to test the authorized API endpoints without calling the authentication endpoint. </span><span class="koboSpan" id="kobo.592.4">This is the recommended approach to test the authorized API endpoints because it does not need any other dependencies, nor does it need to duplicate the authentication logic in the </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">test project.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">In the actual authentication process, we need to generate a JWT token that includes the claims of the authenticated user and add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">Authorization</span></strong><span class="koboSpan" id="kobo.596.1"> header of the HTTP request. </span><span class="koboSpan" id="kobo.596.2">If we use a custom authentication handler, we can skip the process of generating the JWT token, but we still need to find a way to define the claims that we need and pass them to the custom authentication handler. </span><span class="koboSpan" id="kobo.596.3">We can simply add the claims in the request headers and then read the values in the custom authentication handler to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">ClaimsPrincipal</span></strong><span class="koboSpan" id="kobo.598.1"> object. </span><span class="koboSpan" id="kobo.598.2">Let us demonstrate how to </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.600.1">To use a</span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.601.1"> custom authentication handler, first create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">TestAuthHandler</span></strong><span class="koboSpan" id="kobo.603.1">, which inherits from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">AuthenticationHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
public class TestAuthHandler : AuthenticationHandler&lt;AuthenticationSchemeOptions&gt;{
Â Â Â Â public const string AuthenticationScheme = "TestScheme";
Â Â Â Â public const string UserNameHeader = "UserName";
Â Â Â Â public const string CountryHeader = "Country";
Â Â Â Â public const string AccessNumberHeader = "AccessNumber";
Â Â Â Â public const string DrivingLicenseNumberHeader = "DrivingLicenseNumber";
Â Â Â Â public TestAuthHandler(IOptionsMonitor&lt;AuthenticationSchemeOptions&gt; options, ILoggerFactory logger,
Â Â Â Â Â Â Â Â UrlEncoder encoder, ISystemClock clock) : base(options, logger, encoder, clock)
Â Â Â Â {
Â Â Â Â }
Â Â Â Â protected override Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
Â Â Â Â {
Â Â Â Â Â Â Â Â return Task.FromResult(result);
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.607.1">In the preceding code, we define the authentication scheme name as </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">TestScheme</span></strong><span class="koboSpan" id="kobo.609.1">, which is an alternative name to the actual scheme name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Bearer</span></strong><span class="koboSpan" id="kobo.611.1">. </span><span class="koboSpan" id="kobo.611.2">You can find the definition in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">Program</span></strong><span class="koboSpan" id="kobo.613.1"> class. </span><span class="koboSpan" id="kobo.613.2">Also, we define a few names for HTTP headers, which we will use to pass the claims to the custom authentication handler. </span><span class="koboSpan" id="kobo.613.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">HandleAuthenticateAsync()</span></strong><span class="koboSpan" id="kobo.615.1"> method is the method that we need to override to implement the authentication logic. </span><span class="koboSpan" id="kobo.615.2">We will implement it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">following code.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">The idea is</span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.618.1"> that when we create the request in the test, we simply add the claims to the request headers. </span><span class="koboSpan" id="kobo.618.2">So that the custom authentication handler can read the values from the request headers, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">HandleAuthenticateAsync()</span></strong><span class="koboSpan" id="kobo.620.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">
protected override Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync(){
Â Â Â Â var claims = new List&lt;Claim&gt;();
Â Â Â Â if (Context.Request.Headers.TryGetValue(UserNameHeader, out var userName))
Â Â Â Â {
Â Â Â Â Â Â Â Â claims.Add(new Claim(ClaimTypes.Name, userName[0]));
Â Â Â Â }
Â Â Â Â if (Context.Request.Headers.TryGetValue(CountryHeader, out var country))
Â Â Â Â {
Â Â Â Â Â Â Â Â claims.Add(new Claim(ClaimTypes.Country, country[0]));
Â Â Â Â }
Â Â Â Â if (Context.Request.Headers.TryGetValue(AccessNumberHeader, out var accessNumber))
Â Â Â Â {
Â Â Â Â Â Â Â Â claims.Add(new Claim(AppClaimTypes.AccessNumber, accessNumber[0]));
Â Â Â Â }
Â Â Â Â if (Context.Request.Headers.TryGetValue(DrivingLicenseNumberHeader, out var drivingLicenseNumber))
Â Â Â Â {
Â Â Â Â Â Â Â Â claims.Add(new Claim(AppClaimTypes.DrivingLicenseNumber, drivingLicenseNumber[0]));
Â Â Â Â }
Â Â Â Â // You can add more claims here if you want
Â Â Â Â var identity = new ClaimsIdentity(claims, AuthenticationScheme);
Â Â Â Â var principal = new ClaimsPrincipal(identity);
Â Â Â Â var ticket = new AuthenticationTicket(principal, AuthenticationScheme);
Â Â Â Â var result = AuthenticateResult.Success(ticket);
Â Â Â Â return Task.FromResult(result);
}</span></pre>
<p><span class="koboSpan" id="kobo.623.1">Instead of getting claims from the JWT token, we get the claims from the request headers. </span><span class="koboSpan" id="kobo.623.2">If the values exist, we add them to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">ClaimsIdentity</span></strong><span class="koboSpan" id="kobo.625.1"> object. </span><span class="koboSpan" id="kobo.625.2">Then we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">ClaimsPrincipal</span></strong><span class="koboSpan" id="kobo.627.1"> object and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">AuthenticationTicket</span></strong><span class="koboSpan" id="kobo.629.1"> object. </span><span class="koboSpan" id="kobo.629.2">Finally, we return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">AuthenticateResult</span></strong><span class="koboSpan" id="kobo.631.1"> object with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">Success</span></strong><span class="koboSpan" id="kobo.633.1"> status. </span><span class="koboSpan" id="kobo.633.2">This method simulates the authentication process, which avoids the need to generate the JWT token, but it still creates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">ClaimsPrincipal</span></strong><span class="koboSpan" id="kobo.635.1"> object that we need to test the authorized </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">API endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">Next, we</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.638.1"> can test the authorized API endpoints by using the custom authentication handler. </span><span class="koboSpan" id="kobo.638.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.640.1"> class, we can find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">GetDrivingLicense</span></strong><span class="koboSpan" id="kobo.642.1"> method, which is an authorized API endpoint that needs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">DrivingLicenseNumber</span></strong><span class="koboSpan" id="kobo.644.1"> claim. </span><span class="koboSpan" id="kobo.644.2">We can create a new test method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">AuthTest</span></strong><span class="koboSpan" id="kobo.646.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
[Fact]public async Task GetDrivingLicense_ShouldReturnOk_WhenAuthorizedWithTestAuthHandler()
{
Â Â Â Â // Arrange
Â Â Â Â var client = fixture.WithWebHostBuilder(builder =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â builder.ConfigureTestServices(services =&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â services.AddAuthentication(options =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultAuthenticateScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultChallengeScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .AddScheme&lt;AuthenticationSchemeOptions, TestAuthHandler&gt;(TestAuthHandler.AuthenticationScheme,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options =&gt; { });
Â Â Â Â Â Â Â Â });
Â Â Â Â }).CreateClient();
Â Â Â Â client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(TestAuthHandler.AuthenticationScheme);
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.UserNameHeader, "Test User");
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.CountryHeader, "New Zealand");
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.AccessNumberHeader, "123456");
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.DrivingLicenseNumberHeader, "12345678");
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/weatherforecast/driving-license");
Â Â Â Â // Assert
Â Â Â Â response.EnsureSuccessStatusCode(); // Status Code 200-299
Â Â Â Â response.Content.Headers.ContentType.Should().NotBeNull();
Â Â Â Â response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
}</span></pre>
<p><span class="koboSpan" id="kobo.649.1">In this</span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.650.1"> test method, we specify the test web host of SUT with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">WithWebHostBuilder</span></strong><span class="koboSpan" id="kobo.652.1"> method and then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">AddAuthentication</span></strong><span class="koboSpan" id="kobo.654.1"> method to specify the authentication scheme. </span><span class="koboSpan" id="kobo.654.2">Then we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">AddScheme</span></strong><span class="koboSpan" id="kobo.656.1"> method to apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">TestAuthHandler</span></strong><span class="koboSpan" id="kobo.658.1"> authentication handler to the authentication service. </span><span class="koboSpan" id="kobo.658.2">With this customized test web host, we can create a new HTTP client. </span><span class="koboSpan" id="kobo.658.3">Before we send the request using this HTTP client, we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Authorization</span></strong><span class="koboSpan" id="kobo.660.1"> header that specifies the authentication scheme. </span><span class="koboSpan" id="kobo.660.2">We also add the claims to the request headers for simplicity, so that the custom authentication handler can read the values from the request headers and create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">ClaimsPrincipal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.662.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">Then we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">GetAsync</span></strong><span class="koboSpan" id="kobo.665.1"> method to send the HTTP request to the API endpoint. </span><span class="koboSpan" id="kobo.665.2">Finally, we can verify the response status code and the response content type to ensure the request </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">was successful.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">The preceding test method is for a happy path. </span><span class="koboSpan" id="kobo.667.2">To test the unauthorized scenario, we can create a new test method that does not add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">DrivingLicenseNumberHeader</span></strong><span class="koboSpan" id="kobo.669.1"> header to the request, and verify that the response status code is </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">401 Unauthorized</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.672.1">
[Fact]public async Task GetDrivingLicense_ShouldReturnForbidden_WhenRequiredClaimsNotProvidedWithTestAuthHandler()
{
Â Â Â Â // Arrange
Â Â Â Â var client = fixture.WithWebHostBuilder(builder =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â builder.ConfigureTestServices(services =&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â services.AddAuthentication(options =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultAuthenticateScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultChallengeScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .AddScheme&lt;AuthenticationSchemeOptions, TestAuthHandler&gt;(TestAuthHandler.AuthenticationScheme,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options =&gt; { });
Â Â Â Â Â Â Â Â });
Â Â Â Â }).CreateClient();
Â Â Â Â client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(TestAuthHandler.AuthenticationScheme);
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.UserNameHeader, "Test User");
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.CountryHeader, "New Zealand");
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.AccessNumberHeader, "123456");
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/weatherforecast/driving-license");
Â Â Â Â // Assert
Â Â Â Â response.StatusCode.Should().Be(HttpStatusCode.Forbidden);
}</span></pre>
<p><span class="koboSpan" id="kobo.673.1">In the preceding test method, we do not add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">DrivingLicenseNumberHeader</span></strong><span class="koboSpan" id="kobo.675.1"> header to the request. </span><span class="koboSpan" id="kobo.675.2">So, the custom authentication handler cannot find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">DrivingLicenseNumber</span></strong><span class="koboSpan" id="kobo.677.1"> claim, and it will return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">Forbidden</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.679.1">status code.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">Now, we</span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.681.1"> found that there is some duplicated code in the preceding test methods. </span><span class="koboSpan" id="kobo.681.2">If we need to set up the test web host and create the HTTP client for each test method, we can move the code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">IntegrationTestsFixture</span></strong><span class="koboSpan" id="kobo.683.1"> class. </span><span class="koboSpan" id="kobo.683.2">Create a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">CreateClientWithAuth</span></strong><span class="koboSpan" id="kobo.685.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">IntegrationTestsFixture</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.687.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.688.1">
public HttpClient CreateClientWithAuth(string userName, string country, string accessNumber, string drivingLicenseNumber){
Â Â Â Â var client = WithWebHostBuilder(builder =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â builder.ConfigureTestServices(services =&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â services.AddAuthentication(options =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultAuthenticateScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultChallengeScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .AddScheme&lt;AuthenticationSchemeOptions, TestAuthHandler&gt;(TestAuthHandler.AuthenticationScheme,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options =&gt; { });
Â Â Â Â Â Â Â Â });
Â Â Â Â }).CreateClient();
Â Â Â Â client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(TestAuthHandler.AuthenticationScheme);
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.UserNameHeader, userName);
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.CountryHeader, country);
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.AccessNumberHeader, accessNumber);
Â Â Â Â client.DefaultRequestHeaders.Add(TestAuthHandler.DrivingLicenseNumberHeader, drivingLicenseNumber);
Â Â Â Â return client;
}</span></pre>
<p><span class="koboSpan" id="kobo.689.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">CreateClientWithAuth()</span></strong><span class="koboSpan" id="kobo.691.1"> method accepts the claims as parameters and then creates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">HttpClient</span></strong><span class="koboSpan" id="kobo.693.1"> with the customized test web host. </span><span class="koboSpan" id="kobo.693.2">In this way, we can easily control the claims for each test method. </span><span class="koboSpan" id="kobo.693.3">Then we can update the test methods to use this</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.694.1"> method. </span><span class="koboSpan" id="kobo.694.2">For example, the test methods for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">GetCountry</span></strong><span class="koboSpan" id="kobo.696.1"> endpoint can be updated </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
[Fact]public async Task GetCountry_ShouldReturnOk_WhenAuthorizedWithTestAuthHandler()
{
Â Â Â Â // Arrange
Â Â Â Â var client = fixture.CreateClientWithAuth("Test User", "New Zealand", "123456", "12345678");
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/weatherforecast/country");
Â Â Â Â // Assert
Â Â Â Â response.EnsureSuccessStatusCode(); // Status Code 200-299
Â Â Â Â response.Content.Headers.ContentType.Should().NotBeNull();
Â Â Â Â response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
}
[Fact]
public async Task GetCountry_ShouldReturnForbidden_WhenRequiredClaimsNotProvidedWithTestAuthHandler()
{
Â Â Â Â // Arrange
Â Â Â Â // As we don't provide the country claim, the request will be forbidden
Â Â Â Â var client = fixture.CreateClientWithAuth("Test User", "", "123456", "12345678");
Â Â Â Â // Act
Â Â Â Â var response = await client.GetAsync("/weatherforecast/country");
Â Â Â Â // Assert
Â Â Â Â response.StatusCode.Should().Be(HttpStatusCode.Forbidden);
}</span></pre>
<p><span class="koboSpan" id="kobo.699.1">Now </span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.700.1">we can verify that the test methods are still working </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">as expected.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.702.1"><img alt="Figure 10.1 â€“ The test methods pass as expected in VS 2022" src="image/B18971_10_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.703.1">Figure 10.1 â€“ The test methods pass as expected in VS 2022</span></p>
<p><span class="koboSpan" id="kobo.704.1">Note that you can also customize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">AuthenticationSchemeOptions</span></strong><span class="koboSpan" id="kobo.706.1"> class if you need to. </span><span class="koboSpan" id="kobo.706.2">For example, you can define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">TestAuthHandlerOptions</span></strong><span class="koboSpan" id="kobo.708.1"> class that inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">AuthenticationSchemeOptions</span></strong><span class="koboSpan" id="kobo.710.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.712.1">
public class TestAuthHandlerOptions : AuthenticationSchemeOptions{
Â Â Â Â public string UserName { get; set; } = string.Empty;
}</span></pre>
<p><span class="koboSpan" id="kobo.713.1">You can then configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">TestAuthHandlerOptions</span></strong><span class="koboSpan" id="kobo.715.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">ConfigureTestServices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.717.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.718.1">
var client = fixture.WithWebHostBuilder(builder =&gt;{
Â Â Â Â builder.ConfigureTestServices(services =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â services.Configure&lt;TestAuthHandlerOptions&gt;(options =&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â options.UserName = "Test User";
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â services.AddAuthentication(options =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultAuthenticateScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultChallengeScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options.DefaultScheme = TestAuthHandler.AuthenticationScheme;
Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â .AddScheme&lt;TestAuthHandlerOptions, TestAuthHandler&gt;(TestAuthHandler.AuthenticationScheme,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â options =&gt; { });
Â Â Â Â });
}).CreateClient();</span></pre>
<p><span class="koboSpan" id="kobo.719.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">TestAuthHandler</span></strong><span class="koboSpan" id="kobo.721.1"> class </span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.722.1">should now be updated </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.724.1">
public class TestAuthHandler : AuthenticationHandler&lt;TestAuthHandlerOptions&gt;{
Â Â Â Â public readonly string _userName;
Â Â Â Â public TestAuthHandler(IOptionsMonitor&lt;TestAuthHandlerOptions&gt; options, ILoggerFactory logger,
Â Â Â Â UrlEncoder encoder, ISystemClock clock) : base(options, logger, encoder, clock)
Â Â Â Â {
Â Â Â Â Â Â Â Â // Get the user name from the options
Â Â Â Â Â Â Â Â _userName = options.CurrentValue.UserName;
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.725.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">TestAuthHandler</span></strong><span class="koboSpan" id="kobo.727.1"> class can now get the username from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">TestAuthHandlerOptions</span></strong><span class="koboSpan" id="kobo.729.1"> class. </span><span class="koboSpan" id="kobo.729.2">You can also define other properties in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">TestAuthHandlerOptions</span></strong><span class="koboSpan" id="kobo.731.1"> class, and then use them in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">TestAuthHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.733.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">If your</span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.735.1"> project does not use claim-based authorization, you can also define a custom authorization handler to implement the authorization logic. </span><span class="koboSpan" id="kobo.735.2">Please check the official document for more </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">information: </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/"><span class="No-Break"><span class="koboSpan" id="kobo.737.1">https://learn.microsof</span><span id="_idTextAnchor430"/><span class="koboSpan" id="kobo.738.1">t.com/en-us/aspnet/core/security/authentication/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.739.1">.</span></span></p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor431"/><span class="koboSpan" id="kobo.740.1">Code coverage</span></h1>
<p><span class="koboSpan" id="kobo.741.1">Now we have covered the unit tests and integration tests in ASP.NET Core. </span><span class="koboSpan" id="kobo.741.2">In this section, we will </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.742.1">discuss </span><strong class="bold"><span class="koboSpan" id="kobo.743.1">code coverage</span></strong><span class="koboSpan" id="kobo.744.1">, which is a metric that measures the extent to which the source code of the application is covered by the test suite </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">during testing.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">Code coverage is a very important metric for software quality. </span><span class="koboSpan" id="kobo.746.2">If the code coverage is low, it means that there are many parts of the code that are not covered by the tests. </span><span class="koboSpan" id="kobo.746.3">In this case, we are not confident that the code is working as expected. </span><span class="koboSpan" id="kobo.746.4">Also, when we make changes or refactor the code, we are not sure whether the changes will break the </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">existing code.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">Code coverage </span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.749.1">provides insights into which parts of the code are covered (or not covered) by the tests. </span><span class="koboSpan" id="kobo.749.2">It can help us identify areas that may require additional testing and ensure that the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">tested thoroughly.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">Code coverage plays a vital role in assessing the effectiveness and reliability of the testing process. </span><span class="koboSpan" id="kobo.751.2">By analyzing code coverage, we can gain confidence in the quality of the code and identify potential areas of weakness or untested code. </span><span class="koboSpan" id="kobo.751.3">Adequate code coverage is essential to improve the quality of the code and reduce the risks of bugs </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">and defects.</span></span></p>
<p><span class="koboSpan" id="kobo.753.1">It is important to note that code coverage is not the sole indicator of code quality. </span><span class="koboSpan" id="kobo.753.2">While high code coverage is desirable, achieving 100% code coverage does not guarantee that the code is bug-free. </span><span class="koboSpan" id="kobo.753.3">Code coverage should be accompanied by other factors such as effective test design, code reviews, static analysis, manual testing, and so on. </span><span class="koboSpan" id="kobo.753.4">Additionally, factors such as code design, architecture, and development practices also play a role in the quality of the code. </span><span class="koboSpan" id="kobo.753.5">We need to find a balance between code coverage and </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">other factors.</span></span></p>
<p><span class="koboSpan" id="kobo.755.1">To analyze the code coverage, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">two steps:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.757.1">Collecting test data</span></strong><span class="koboSpan" id="kobo.758.1">: The data collector can monitor the test execution and collect the code coverage data during test runs. </span><span class="koboSpan" id="kobo.758.2">It can report code coverage data in different formats, such as XML </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">or JSON.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.760.1">Generating the report</span></strong><span class="koboSpan" id="kobo.761.1">: The report generator can read the collected data and generate the code coverage report, often in </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">HTML format.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.763.1">Let us see how to use the data collector and report generator. </span><span class="koboSpan" id="kobo.763.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">InvoiceApp</span></strong><span class="koboSpan" id="kobo.765.1"> project as an example. </span><span class="koboSpan" id="kobo.765.2">You can find the sample project in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">chapte</span><a id="_idTextAnchor432"/><span class="koboSpan" id="kobo.767.1">r10\IntegrationTestsDemo\IntegrationTest-v1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.768.1"> folder.</span></span></p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor433"/><span class="koboSpan" id="kobo.769.1">Using data collectors</span></h2>
<p><span class="koboSpan" id="kobo.770.1">To use </span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.771.1">data collectors, we can use </span><strong class="bold"><span class="koboSpan" id="kobo.772.1">Coverlet</span></strong><span class="koboSpan" id="kobo.773.1">. </span><span class="koboSpan" id="kobo.773.2">Coverlet is</span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.774.1"> a cross-platform code coverage framework for .NET, with support for line, branch, and method coverage. </span><span class="koboSpan" id="kobo.774.2">It can be used either as a .NET Core global tool or a NuGet package. </span><span class="koboSpan" id="kobo.774.3">For more information, please check the Coverlet repo on</span><a id="_idIndexMarker1074"/> <span class="No-Break"><span class="koboSpan" id="kobo.775.1">GitHub: </span></span><a href="https://github.com/coverlet-coverage/coverlet"><span class="No-Break"><span class="koboSpan" id="kobo.776.1">https://github.com/coverlet-coverage/coverlet</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.777.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">The xUnit project template already includes the Coverlet package. </span><span class="koboSpan" id="kobo.778.2">If your test project does not include the Coverlet package, you can install it by running the following command in the Package </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">Manager Console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.780.1">
dotnet add package coverlet.collector</span></pre> <p><span class="koboSpan" id="kobo.781.1">To get coverage data, navigate to the test project folder, and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.783.1">
dotnet test --collect:"XPlat Code Coverage"</span></pre> <p><span class="koboSpan" id="kobo.784.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">--collect:"XPlat Code Coverage"</span></strong><span class="koboSpan" id="kobo.786.1"> option tells the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">dotnet test</span></strong><span class="koboSpan" id="kobo.788.1"> command to</span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.789.1"> collect the code coverage data. </span><span class="koboSpan" id="kobo.789.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">XPlat Code Coverage</span></strong><span class="koboSpan" id="kobo.791.1"> parameter is a friendly name for the collector. </span><span class="koboSpan" id="kobo.791.2">You can use any name you like but note that it is case insensitive. </span><span class="koboSpan" id="kobo.791.3">The code coverage data will be saved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">TestResults</span></strong><span class="koboSpan" id="kobo.793.1"> folder. </span><span class="koboSpan" id="kobo.793.2">You can find the code coverage data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">coverage.cobertura.xml</span></strong><span class="koboSpan" id="kobo.795.1"> file. </span><span class="koboSpan" id="kobo.795.2">The folder structure </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">/TestResults/{GUID}/coverage.cobertura.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">Here is a sample of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">coverage.cobertura.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.801.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.802.1">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;coverage line-rate="0.1125" branch-rate="0.1875" version="1.9" timestamp="1685100267" lines-covered="108" lines-valid="960" branches-covered="6" branches-valid="32"&gt;
Â Â &lt;sources&gt;
Â Â Â Â &lt;source&gt;C:\dev\web-api-with-asp-net\example_code\chapter9\IntegrationTestsDemo\IntegrationTest-v1\InvoiceApp\InvoiceApp.WebApi\&lt;/source&gt;
Â Â &lt;/sources&gt;
Â Â &lt;packages&gt;
Â Â Â Â &lt;package name="InvoiceApp.WebApi" line-rate="0.1125" branch-rate="0.1875" complexity="109"&gt;
Â Â Â Â Â Â &lt;classes&gt;
Â Â Â Â Â Â ...
</span><span class="koboSpan" id="kobo.802.2">Â Â Â Â Â Â Â Â &lt;class name="InvoiceApp.WebApi.Services.EmailService" filename="Services\EmailService.cs" line-rate="1" branch-rate="1" complexity="2"&gt;
Â Â Â Â Â Â Â Â Â Â &lt;methods&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;method name="GenerateInvoiceEmail" signature="(InvoiceApp.WebApi.Models.Invoice)" line-rate="1" branch-rate="1" complexity="1"&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;lines&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="19" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="20" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="21" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;!-- ... </span><span class="koboSpan" id="kobo.802.3">--&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="37" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="38" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;/lines&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;/method&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;method name=".ctor" signature="(Microsoft.Extensions.Logging.ILogger`1&amp;lt;InvoiceApp.WebApi.Interfaces.IEmailService&amp;gt;,InvoiceApp.WebApi.Interfaces.IEmailSender)" line-rate="1" branch-rate="1" complexity="1"&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;lines&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="12" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="13" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="14" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="15" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="16" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;/lines&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;/method&gt;
Â Â Â Â Â Â Â Â Â Â &lt;/methods&gt;
Â Â Â Â Â Â Â Â Â Â &lt;lines&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="19" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="20" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="21" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;!-- ... </span><span class="koboSpan" id="kobo.802.4">--&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="37" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="38" hits="1" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="12" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="13" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="14" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="15" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â Â Â &lt;line number="16" hits="3" branch="False" /&gt;
Â Â Â Â Â Â Â Â Â Â &lt;/lines&gt;
Â Â Â Â Â Â Â Â &lt;/class&gt;
Â Â Â Â Â Â Â Â ...
</span><span class="koboSpan" id="kobo.802.5">Â Â Â Â Â Â &lt;/classes&gt;
Â Â Â Â &lt;/package&gt;
Â Â &lt;/packages&gt;
&lt;/coverage&gt;</span></pre>
<p><span class="koboSpan" id="kobo.803.1">In this code, we can</span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.804.1"> see the </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">following information:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">line-rate</span></strong><span class="koboSpan" id="kobo.807.1">: This is the percentage of lines covered </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">by tests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">branch-rate</span></strong><span class="koboSpan" id="kobo.810.1">: This is the percentage of branches covered </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">by tests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">lines-covered</span></strong><span class="koboSpan" id="kobo.813.1">: This is the number of lines covered </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">by tests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">lines-valid</span></strong><span class="koboSpan" id="kobo.816.1">: This is the number of lines in the </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">source code</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">branches-covered</span></strong><span class="koboSpan" id="kobo.819.1">: This is the number of branches covered </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">by tests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">branches-valid</span></strong><span class="koboSpan" id="kobo.822.1">: This is the number of branches in the </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">source code</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.824.1">You can also use Coverlet as a .NET global tool. </span><span class="koboSpan" id="kobo.824.2">To do this, you can run the following command to install Coverlet as a .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">global tool:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.826.1">
dotnet tool install --global coverlet.console</span></pre> <p><span class="koboSpan" id="kobo.827.1">Then you can use it </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.829.1">
coverlet /path/to/InvoiceApp.UnitTests.dll --target "dotnet" --targetargs "test /path/to/test-project --no-build"</span></pre> <p><span class="koboSpan" id="kobo.830.1">Please </span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.831.1">update the paths in the preceding command to match your project structure. </span><span class="koboSpan" id="kobo.831.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">--no-build</span></strong><span class="koboSpan" id="kobo.833.1"> option is used to skip building the test project, which is useful if you have already built the </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">test project.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">Now we have the code coverage data. </span><span class="koboSpan" id="kobo.835.2">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">coverage.cobertura.xml</span></strong><span class="koboSpan" id="kobo.837.1"> file is not human-readable. </span><span class="koboSpan" id="kobo.837.2">So, we must generate a human-read</span><a id="_idTextAnchor434"/><span class="koboSpan" id="kobo.838.1">able report, which we will introduce in the </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">next section.</span></span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor435"/><span class="koboSpan" id="kobo.840.1">Generating a code coverage report</span></h2>
<p><span class="koboSpan" id="kobo.841.1">To better </span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.842.1">understand the coverage data, we can generate a code coverage report. </span><span class="koboSpan" id="kobo.842.2">To do this, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">ReportGenerator</span></strong><span class="koboSpan" id="kobo.844.1"> NuGet package. </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">ReportGenerator</span></strong><span class="koboSpan" id="kobo.846.1"> is a</span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.847.1"> tool that can convert coverage data generated by Coverlet into human-readable reports. </span><span class="koboSpan" id="kobo.847.2">It also supports other coverage</span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.848.1"> formats, such </span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.849.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.850.1">OpenCover</span></strong><span class="koboSpan" id="kobo.851.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.852.1">dotCover</span></strong><span class="koboSpan" id="kobo.853.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.854.1">NCover</span></strong><span class="koboSpan" id="kobo.855.1">, and</span><a id="_idIndexMarker1082"/> <span class="No-Break"><span class="koboSpan" id="kobo.856.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.857.1">To install ReportGenerator, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.859.1">
dotnet tool install -g dotnet-reportgenerator-globaltool</span></pre> <p><span class="koboSpan" id="kobo.860.1">Then we can run the following command to generate a code </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">coverage report:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.862.1">
reportgenerator "-reports:/path/to/coverage.cobertura.xml" "-targetdir:coveragereport" "-reporttypes:Html;HtmlSummary"</span></pre> <p><span class="koboSpan" id="kobo.863.1">Please update the paths in the preceding command to match your </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">project structure.</span></span></p>
<p><span class="koboSpan" id="kobo.865.1">If the command runs successfully, you will see the generated HTML report in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">coveragereport</span></strong><span class="koboSpan" id="kobo.867.1"> folder. </span><span class="koboSpan" id="kobo.867.2">You can open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">index.html</span></strong><span class="koboSpan" id="kobo.869.1"> file in the browser to view the report. </span><span class="koboSpan" id="kobo.869.2">The report looks </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.871.1"><img alt="Figure 10.2 â€“ Code coverage report" src="image/B18971_10_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.872.1">Figure 10.2 â€“ Overview of the code coverage report</span></p>
<p><span class="koboSpan" id="kobo.873.1">You can </span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.874.1">check each class to see the code coverage details, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.875.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.876.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.878.1"><img alt="Figure 10.3 â€“ Code coverage details" src="image/B18971_10_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.879.1">Figure 10.3 â€“ Overview of the code coverage details</span></p>
<p><span class="koboSpan" id="kobo.880.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.881.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.882.1">.4</span></em><span class="koboSpan" id="kobo.883.1">, we </span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.884.1">can see that some lines are not covered </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">by tests:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.886.1"><img alt="Figure 10.4 â€“ Lines not covered by tests highlighted in red" src="image/B18971_10_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.887.1">Figure 10.4 â€“ Overview of the lines not covered by tests highlighted in red</span></p>
<p><span class="koboSpan" id="kobo.888.1">Sadly, the</span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.889.1"> code coverage in our sample project is awful. </span><span class="koboSpan" id="kobo.889.2">But luckily, it is just a sample project. </span><span class="koboSpan" id="kobo.889.3">In real-world projects, we should try our best to improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">code coverage!</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">In this section, we have learned how to use Coverlet and ReportGenerator to generate code coverage data and reports. </span><span class="koboSpan" id="kobo.891.2">Code coverage is an essential aspect of effective software testing. </span><span class="koboSpan" id="kobo.891.3">By leveraging these reports, developers and quality assurance teams can gain insights into the quality of their tests and the quality of their code, which can ultimately enhance the reliability and stability </span><a id="_idTextAnchor436"/><span class="koboSpan" id="kobo.892.1">of the application and also help us confidently </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">refactor code.</span></span></p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor437"/><span class="koboSpan" id="kobo.894.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.895.1">In this chapter, we discussed how to write integration tests for ASP.NET Core web API applications. </span><span class="koboSpan" id="kobo.895.2">We learned how to create a test fixture to set up the test web host, and how to use the test fixture in the test class. </span><span class="koboSpan" id="kobo.895.3">We also learned how to test authorized endpoints and generate code coverage data </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">and reports.</span></span></p>
<p><span class="koboSpan" id="kobo.897.1">As a good developer, it is important to write tests for your code. </span><span class="koboSpan" id="kobo.897.2">Writing tests is not only a beneficial practice but also a beneficial habit to form. </span><span class="koboSpan" id="kobo.897.3">You may find that you spend more time writing tests than writing features, but the effort is worth it. </span><span class="koboSpan" id="kobo.897.4">To ensure your ASP.NET web API applications are functioning correctly, make sure to write both unit tests and integration tests. </span><span class="koboSpan" id="kobo.897.5">Doing so will help to ensure your code is reliable </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">and secure.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">In the next chapter, we will explore another aspect of web APIs: gRPC, which is a high-performance, open-source, universal </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">RPC framework.</span></span></p>
</div>
</body></html>