- en: Acting with Commands
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令执行操作
- en: In the previous chapter, we went through the implementation process for a simple
    domain model. This model has one entity, and several value objects and domain
    services. The model represents just one area of our system, and we deliberately
    kept everything else out of scope. We discussed how the domain model project needs
    to be isolated from anything else, and how domain services can be part of the
    model although their implementation can be done in the application layer. Now,
    we are going to learn about putting our domain model in action. Hitherto, we have
    not been referencing the domain model from anywhere, which makes it rather useless.
    To start using the model in our application, we need to be able to call the model.
    In addition, we need to be able to persist all changes that happen in the model,
    so we do not lose the system state.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了一个简单领域模型的实现过程。该模型有一个实体，以及几个值对象和领域服务。该模型仅代表我们系统的一个领域，我们故意将其他所有内容排除在范围之外。我们讨论了领域模型项目需要如何与其他内容隔离，以及领域服务虽然可以在应用层实现，但也可以成为模型的一部分。现在，我们将学习如何将我们的领域模型付诸实践。到目前为止，我们还没有在任何地方引用领域模型，这使得它相当无用。为了开始在应用中使用模型，我们需要能够调用模型。此外，我们还需要能够持久化模型中发生的所有更改，以防止我们丢失系统状态。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Application layer—the outer edge of the onion architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层——洋葱架构的外层边缘
- en: Calling the domain model from the web API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Web API调用领域模型
- en: Persisting the domain model changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化领域模型更改
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In addition to the technical requirements from [Chapter 5](034423e8-8080-4073-bd08-b98a129384a4.xhtml), *Implementing
    the Model*, you need to install Docker, because we will be using containers to
    run necessary infrastructure components, such as databases. Docker is supported
    on all popular platforms, including Windows, macOS, and Linux. Please refer to
    the Docker installation documentation ([https://docs.docker.com/install/](https://docs.docker.com/install/))
    if you need to know more about how to install it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[第5章](034423e8-8080-4073-bd08-b98a129384a4.xhtml)中关于*实现模型*的技术要求之外，您还需要安装Docker，因为我们将使用容器来运行必要的基础设施组件，例如数据库。Docker支持所有流行的平台，包括Windows、macOS和Linux。如果您需要了解更多关于如何安装Docker的信息，请参阅Docker安装文档([https://docs.docker.com/install/](https://docs.docker.com/install/))。
- en: Outside the domain model
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域模型之外
- en: We strive to keep our domain model intact from anything that is related to infrastructure,
    persistence, execution, and communication. This makes the domain model pure and
    keeps it focused on the business. However, we still need to create the whole system
    around it, keeping the domain model as the system core.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们努力保持领域模型不受与基础设施、持久化、执行和通信相关内容的干扰。这使得领域模型纯净，并使其专注于业务。然而，我们仍然需要创建围绕它的整个系统，保持领域模型作为系统核心。
- en: The whole world of runtime surrounds our domain model, and in this section,
    we are going to dissect all necessary components that are required to build a
    proper system and look at how these components need to be bound together, with
    each other and with the domain model.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时环境的整个世界围绕着我们的领域模型，在本节中，我们将剖析构建一个适当系统所需的所有必要组件，并查看这些组件需要如何相互绑定，以及如何与领域模型绑定在一起。
- en: Exposing the web API
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公开Web API
- en: Our system needs to have some visibility to users, and therefore, at some point,
    we will need to build a user interface. This topic is covered as we move on further,
    but right now we need to be able to expose our application in a way that the future
    UI can be built on top of it. We expect our system to have more than one UI potentially.
    Think about a **single-page web application** (**SPA**) and a mobile app. As a
    backend for both types of frontends, we need to build a web API. I would avoid
    the term REST API since it is much more than a simple web API and we aren't going
    to explore this topic in depth. Instead, we will concentrate on making some calls
    to our domain model via HTTP, to do something useful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统需要向用户提供一些可见性，因此，在某个时候，我们将需要构建一个用户界面。这个主题将在我们继续前进时进行讨论，但现在是时候能够以某种方式公开我们的应用，以便未来的UI可以建立在它之上。我们预计我们的系统将拥有多个UI。考虑一个**单页Web应用**（SPA）和移动应用。作为这两种类型前端的后端，我们需要构建一个Web
    API。我会避免使用REST API这个术语，因为它远不止是一个简单的Web API，我们也不会深入探讨这个主题。相反，我们将专注于通过HTTP调用我们的领域模型，以执行一些有用的操作。
- en: Let's start by creating an ASP.NET Web API controller, where we will put handlers
    for some of the HTTP endpoints. To do this, we need to add a class to our `Marketplace`
    project, because right now we will not be working inside the domain model, but
    outside it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 ASP.NET Web API 控制器，我们将在这里放置一些 HTTP 端点处理器。为了做到这一点，我们需要在我们的 `Marketplace`
    项目中添加一个类，因为现在我们不会在领域模型内部工作，而是在模型外部工作。
- en: Before we add a controller, let's create a project folder called `Api`, to put
    all controllers and related services in one place. We will add different types
    of components to the application project later on, so it is better to keep things
    tidy from the beginning.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加控制器之前，让我们创建一个名为 `Api` 的项目文件夹，将所有控制器和相关服务放在一个地方。稍后我们将在应用程序项目中添加不同类型的组件，因此最好从一开始就保持整洁。
- en: Public API contracts
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共 API 契约
- en: To serve HTTP requests, we need more than just a controller. The controller
    needs to accept strongly typed requests, and the collection of those requests
    will be our public API and the models for those requests will be our contracts.
    Let's prepare a place where we'll put these models and create a folder called
    `Contracts`, in the application project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要服务 HTTP 请求，我们需要的不仅仅是控制器。控制器需要接受强类型请求，这些请求的集合将是我们公共 API 以及这些请求的模型。让我们准备一个放置这些模型的地方，并在应用程序项目中创建一个名为
    `Contracts` 的文件夹。
- en: Contracts are **data-transfer objects** (**DTOs**) and **plain-old** **C# objects**
    (**POCOs**). It means that they have no logic, they only contain primitive types
    and do not require any tricks to be serialized and deserialized. Practically,
    you can add complex types to your DTOs just because some complex types are used
    in many contracts. An example of such a type could be the `Address` type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 契约是 **数据传输对象**（**DTOs**）和 **普通的** **C# 对象**（**POCOs**）。这意味着它们没有逻辑，它们只包含原始类型，并且不需要任何技巧来进行序列化和反序列化。实际上，你可以在你的
    DTO 中添加复杂类型，仅仅是因为某些复杂类型在许多契约中使用。这种类型的例子可以是 `Address` 类型。
- en: 'Imagine we have the following contract class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下契约类的示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is very convenient to use the complex type instead of listing all properties
    for two addresses separately. After we add a new type called `Address`, our contract
    will be much more compact:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复杂类型而不是分别列出两个地址的所有属性，非常方便。在我们添加一个名为 `Address` 的新类型之后，我们的契约将变得更加紧凑：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be aware that complex types add compatibility issues since when you change the
    type, all contracts that use it will also change and this change will be implicit.
    Since you have no internal consumers of this contract, you will not be able to
    see whether the clients that use this contract will be affected. Such information
    can only be obtained by tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，复杂类型会增加兼容性问题，因为当你更改类型时，所有使用该类型的契约也将更改，并且这种更改将是隐式的。由于你没有内部消费者使用此契约，你将无法看到使用此契约的客户端是否会受到影响。此类信息只能通过测试获得。
- en: Speaking about changes, remember that everything you publish outside of your
    development machine is considered public. The public API is something that anyone
    who has appropriate permissions can use. Effectively, this means that you are
    not in control of who is using your API anymore. Therefore, any change in the
    published API can potentially break other parts of the system or other systems.
    Changes in public contracts need to be crafted with care since there are both
    non-breaking changes and breaking changes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 说到更改，请记住，你发布在开发机器之外的所有内容都被认为是公共的。公共 API 是任何具有适当权限的人都可以使用的东西。实际上，这意味着你不再控制谁在使用你的
    API。因此，发布 API 的任何更改都可能潜在地破坏系统或其他系统的其他部分。公共契约的更改需要谨慎处理，因为既有非破坏性更改，也有破坏性更改。
- en: 'Some changes in POCO types are considered non-breaking, such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: POCO 类型的一些更改被认为是非破坏性的，例如以下更改：
- en: Changing property type so any value of the type that was used before can be
    serialized to the new type. For example, we can change a property from being an
    integer to string, and it will be compatible.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变属性类型，以便任何之前使用的类型值都可以序列化到新类型。例如，我们可以将属性从整数更改为字符串，并且它将是兼容的。
- en: Adding a new property is also considered a non-breaking change. This is because
    when we try to deserialize an XML or JSON object that does not have this new property
    because the sender hasn't updated their contracts yet, most popular serializers
    will accept it and will use a default value if the value is not supplied.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新属性也被视为一种非破坏性更改。这是因为当我们尝试反序列化一个没有这个新属性的 XML 或 JSON 对象时（因为发送者尚未更新他们的合约），大多数流行的序列化器都会接受它，并且如果未提供值，将使用默认值。
- en: Our software evolves, and of course, it is not always possible to make non-breaking
    changes. This means that we should be prepared to make breaking changes. We already
    discussed how the public API is something that is shared by default as soon as
    it is made public. Therefore, we need to ensure that when we make a breaking change,
    everyone who is using the old API will not get exceptions and will be able to
    work as before, at least for some time. This is done by **API versioning**. You
    probably have encountered different API versions for popular services such as
    GitHub or Twitter. For example, while I am writing this, the Twitter API documentation
    tells me to use this call to get the timeline of the tweet: `GET https://api.twitter.com/1.1/statuses/home_timeline.json`.
    As you can see, they have `1.1` as part of the URI, and it is their current stable
    API version. We could assume that they also have other versions and some of those
    older versions might still be operational and in use. So, in our API, we will
    also use versioned contracts although we don't expect many changes in the beginning.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们软件在不断发展，当然，我们并不总是能够做出非破坏性更改。这意味着我们应该准备好做出破坏性更改。我们已经讨论了公共 API 是一旦公开就默认共享的东西。因此，我们需要确保当我们做出破坏性更改时，所有使用旧
    API 的人都不会遇到异常，并且能够像以前一样工作，至少在一段时间内。这是通过**API 版本控制**来实现的。你可能已经遇到了像 GitHub 或 Twitter
    这样的流行服务的不同 API 版本。例如，当我写这篇文章的时候，Twitter API 文档告诉我使用这个调用来获取推文的时序：`GET https://api.twitter.com/1.1/statuses/home_timeline.json`。正如你所看到的，它们在
    URI 中有`1.1`，这是它们当前的稳定 API 版本。我们可以假设它们还有其他版本，其中一些较旧的版本可能仍在运行和使用。因此，在我们的 API 中，我们也将使用版本化的合约，尽管我们最初并不期望有很多变化。
- en: 'We already know what operations we can do with our domain, so we can add some
    contracts to call these operations from the outside world. Let''s create a file
    where we put our first contracts. We already have the `Contracts` folder, so we
    can create a new C# class file called `ClassifiedAds.cs` in this folder. After
    the file is in place, we can add our first contract there:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们可以对我们的领域执行哪些操作，因此我们可以添加一些合约来从外部世界调用这些操作。让我们创建一个文件，我们将在这里放置我们的第一个合约。我们已经有了一个`Contracts`文件夹，所以我们可以在这个文件夹中创建一个新的
    C# 类文件，命名为`ClassifiedAds.cs`。文件就位后，我们可以在那里添加我们的第一个合约：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we use nested static classes, `ClassifiedAds` and `V1`, as a replacement
    for namespaces, so we can have more versions in one file when necessary. This
    method allows us to use static members import to keep code more concise.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用嵌套的静态类`ClassifiedAds`和`V1`作为命名空间的替代，这样在必要时我们可以在一个文件中拥有更多版本。这种方法允许我们使用静态成员导入来使代码更加简洁。
- en: What we have here is a *command*. I first mentioned *commands* in [Chapter 1](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml), *Why
    Domain-Driven Design?*, when we discussed CQRS. Commands allow users and other
    systems to execute actions in our domain model. When a command is successfully
    processed, the domain model state changes and new domain events are emitted. Now,
    when we have one command implemented in code, we need to accept this command coming
    from the outside world, and we'll use an HTTP endpoint for this.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一个**命令**。我第一次在[第 1 章](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml)，“为什么是领域驱动设计？”，当我们讨论
    CQRS 时提到了**命令**。命令允许用户和其他系统在我们的领域模型中执行操作。当一个命令成功处理时，领域模型状态会发生变化，并发出新的领域事件。现在，当我们有一个命令在代码中实现时，我们需要接受来自外部世界的这个命令，我们将使用
    HTTP 端点来实现这一点。
- en: HTTP endpoints
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 端点
- en: 'Since the most obvious communication method for APIs nowadays is using synchronous
    HTTP calls, we will start with this. We will be using the ASP.NET Web API. Therefore,
    we need to add a controller that will accept our commands. Let''s add a file called
    `ClassifiedAdsCommandsApi.cs` to the `Api` folder of our executable project, make
    the class inherit from `Controller`, and add one `Post` method to handle the command
    that we added in the previous section:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在API最明显的通信方法是使用同步HTTP调用，我们将从这里开始。我们将使用ASP.NET Web API。因此，我们需要添加一个控制器来接受我们的命令。让我们在可执行项目的`Api`文件夹中添加一个名为`ClassifiedAdsCommandsApi.cs`的文件，让这个类继承自`Controller`，并添加一个`Post`方法来处理我们在上一节中添加的命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are not doing anything there yet. Instead, we are creating a web API that
    will accept commands from the outside world. We will add code that handles these
    commands later. Remember, this is our adapter for the HTTP infrastructure, which
    finds its place in the outermost layer of the onion architecture. That's we call
    this layer** the edge** because there is nothing outside of it, which we can consider
    a part of our app. The application can have multiple ways to communicate with
    the outside world, so if we added some other edge, such as messaging, we would
    expect for this new communication adapter to process the same commands.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还没有做任何事情。相反，我们正在创建一个可以接受外部世界命令的web API。我们稍后会添加处理这些命令的代码。记住，这是我们针对HTTP基础设施的适配器，它在洋葱架构的最外层找到其位置。这就是我们称这个层为**边缘**的原因，因为它的外面没有任何我们可以认为是应用一部分的东西。应用可以通过多种方式与外部世界通信，所以如果我们添加了其他边缘，比如消息传递，我们期望这个新的通信适配器能够处理相同的命令。
- en: 'Now, we need to add more code to the application startup to make the web API
    work. There are a few things we need to do to the `Program` class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向应用程序启动代码中添加更多代码以使web API工作。我们需要对`Program`类做一些事情：
- en: Build the configuration.
  id: totrans-37
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建配置。
- en: Configure the web host.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置web宿主。
- en: Execute the web host.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行web宿主。
- en: 'To do these operations, we need the `Program` class to look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这些操作，我们需要让`Program`类看起来像这样：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is not much going on here. We ensure that our current directory is where
    the executable is located because this is where we also can find the configuration
    file. We then read the configuration, and from the configuration, we create the
    web host and start it. Right now, we have no configuration file and therefore
    no configuration, but we will be adding some later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里目前没有太多的事情发生。我们确保当前目录是可执行文件所在的位置，因为这也是我们可以找到配置文件的地方。然后我们读取配置，从配置中创建并启动web宿主。目前我们没有配置文件，因此没有配置，但稍后我们会添加一些。
- en: 'Now, we are using the `Startup` class to configure services, and it needs some
    attention as well. In the `Startup` class, we need to configure the web API so
    it can use our controller. In addition, we need an easy way to interact with the
    API without having any user interface yet. One nice and easy way is to use Swagger
    ([https://swagger.io/](https://swagger.io/)) integration with the Web API. Before
    we can start using it, we need to add a Swagger Web API integration NuGet package, `Swashbuckle.AspNetCore`.
    With the new `.csproj` file format, the easiest way to do add the integration
    is probably by adding the package reference directly to the project file. Here,
    you can see the new content for the `Marketplace.csproj` file, and the changes
    are highlighted:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在使用`Startup`类来配置服务，它也需要一些关注。在`Startup`类中，我们需要配置web API以便它可以使用我们的控制器。此外，我们需要一种简单的方法来与API交互，而无需任何用户界面。一种既好又简单的方法是使用与Web
    API集成的Swagger ([https://swagger.io/](https://swagger.io/))。在我们开始使用它之前，我们需要添加一个Swagger
    Web API集成NuGet包，`Swashbuckle.AspNetCore`。使用新的`.csproj`文件格式，添加集成的最简单方法可能是直接将包引用添加到项目文件中。在这里，您可以看到`Marketplace.csproj`文件的新内容，并且更改被突出显示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Swashbuckle.AspNetCore` package might have a different version at the moment
    you are reading this book. Use the latest available version.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swashbuckle.AspNetCore` 包在您阅读这本书的时候可能版本不同。请使用最新可用的版本。'
- en: When you save the project file, your IDE will install the package and add the
    reference to your project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您保存项目文件时，您的IDE将安装包并将引用添加到您的项目中。
- en: 'Now, we can change the `Startup` class, so it registers web API internals,
    our controller, and all necessary Swagger generation. Also, we add an embedded
    version of the Swagger UI so we can test our API directly from the browser, without
    any additional software:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更改`Startup`类，以便它注册Web API内部组件、我们的控制器以及所有必要的Swagger生成。我们还添加了一个嵌入式的Swagger
    UI，这样我们就可以直接从浏览器测试我们的API，而无需任何额外的软件：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With everything in place now, we are ready to start the application for the
    first time. After pressing *F5*, you should see the following at the console:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切就绪，我们准备第一次启动应用程序。按下*F5*后，您应该在控制台看到以下内容：
- en: '![](img/3323e3c0-cb60-4cda-8bb5-71846121e722.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3323e3c0-cb60-4cda-8bb5-71846121e722.png)'
- en: The application finally runs
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序最终运行
- en: 'Now, let''s open the Swagger UI by going to `http://localhost:5000/swagger` in
    the browser. We should see one operation (POST), and when we expand it, the following
    should appear:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在浏览器中打开Swagger UI，访问`http://localhost:5000/swagger`。我们应该看到一个操作（POST），当我们展开它时，以下内容应该出现：
- en: '![](img/0cb25b4e-48ce-4930-9a4d-8d82bcfcd8ff.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0cb25b4e-48ce-4930-9a4d-8d82bcfcd8ff.png)'
- en: Swagger user interface for testing the API
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger用户界面用于测试API
- en: You can click on the Try it out button and send some requests to the API, but
    it won't do anything because we always return the `200 OK` response.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以点击“尝试一下”按钮并向API发送一些请求，但它不会做任何事情，因为我们总是返回`200 OK`响应。
- en: We completed all the necessary steps to expose a primitive web API endpoint,
    and have the bootstrap code to support it. We also created one API contract that
    represents the command to create a classified ad. It is time to make this command
    work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所有必要的步骤来暴露一个原始的Web API端点，并提供了支持它的引导代码。我们还创建了一个API合约，它代表创建分类广告的命令。现在是时候让这个命令生效了。
- en: Application layer
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层
- en: The edge—in our case, it is a simple web API—accepts requests from the outside
    world. The main job for our edge component is to accept some request, sent as
    a JSON document, XML document, message via RabbitMQ, or any other communication
    channel and serialization type; convert it to a command; and then ensure this
    command gets handled.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘部分——在我们的案例中，是一个简单的Web API——接受来自外部世界的请求。我们边缘组件的主要任务是接受一些请求，这些请求以JSON文档、XML文档、通过RabbitMQ的消息或任何其他通信渠道和序列化类型发送；将其转换为命令；然后确保这个命令得到处理。
- en: The edge can, of course, work directly with the domain model, but this would
    mean we accept the fact that we will always be working with one edge type only,
    with one communication protocol. Also, edge components are usually heavily dependent
    on the communication infrastructure—while this is fine for integration tests,
    creating unit tests for such components might be challenging.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘部分当然可以直接与领域模型工作，但这意味着我们接受这样一个事实，我们总是只与一种边缘类型一起工作，使用一种通信协议。此外，边缘组件通常对通信基础设施有很强的依赖性——虽然这对于集成测试来说是可行的，但为这样的组件编写单元测试可能会具有挑战性。
- en: To isolate the communication infrastructure from the actual request handling,
    we can introduce the application layer. In this layer, we need a component that
    will accept commands from the edge and use our domain model to handle these commands.
    Such a component is called** application service**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将通信基础设施与实际请求处理隔离开来，我们可以引入应用层。在这个层中，我们需要一个组件来接受来自边缘的命令并使用我们的领域模型来处理这些命令。这样的组件被称为**应用服务**。
- en: If you refer to [Chapter 4](bea6a7db-f270-4c0b-a3c3-bedb4182cafb.xhtml), *Designing
    the Model*, and look at the picture of the onion architecture, you will find application
    services between the infrastructure and the domain model. Application services
    have no dependency on the transport that is used to send commands from the outside.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您参考[第4章](bea6a7db-f270-4c0b-a3c3-bedb4182cafb.xhtml)，*设计模型*，并查看洋葱架构的图片，您将在基础设施和领域模型之间找到应用服务。应用服务对用于从外部发送命令的传输没有依赖性。
- en: 'However, the services need to have a way to load and store entities, because
    a typical operation of an application service would be to execute a command like
    this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，服务需要有一种方式来加载和存储实体，因为应用程序服务的典型操作将执行如下命令：
- en: '![](img/b62dfcda-7863-4220-bcbc-248f4aa5ff68.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b62dfcda-7863-4220-bcbc-248f4aa5ff68.png)'
- en: Typical interaction flow
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 典型交互流程
- en: There are a couple of exceptions in this flow. When the application service
    receives a command that requires creating a new entity, it won't load anything
    from the entity storage, since there is nothing to load yet. It will create the
    entity and save it to the entity store. Also, when handling a command requires
    deleting an entity, the application service will load the entity, but not necessarily
    save it back. It might just delete this entity from the store instead, but this
    very much depends on a model. For example, if the business requires keeping all
    the data, we might just mark the entity as deleted and then persist changes to
    the entity store.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流程中存在一些异常。当应用程序服务接收到需要创建新实体的命令时，它不会从实体存储中加载任何内容，因为还没有可以加载的内容。它将创建实体并将其保存到实体存储中。同样，当处理命令需要删除实体时，应用程序服务将加载实体，但不一定将其保存回去。它可能只是从存储中删除这个实体，但这在很大程度上取决于模型。例如，如果业务要求保留所有数据，我们可能只是将实体标记为已删除，然后将更改持久化到实体存储中。
- en: 'Let''s add a new application service class to our project and write some code.
    First, we need a new file in the `Api` folder of our executable web API project.
    Some might argue that application services aren''t part of the API, but for now,
    we have only one edge and there is no real reason to separate them. The new filename
    would be `ClassifiedAdApplicationService.cs`, and it has the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中添加一个新的应用程序服务类并编写一些代码。首先，我们需要在我们的可执行Web API项目的`Api`文件夹中创建一个新的文件。有些人可能会争论应用程序服务不是API的一部分，但到目前为止，我们只有一个边缘，并且没有真正的原因将它们分开。新文件的名称将是`ClassifiedAdApplicationService.cs`，它具有以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we need to call the application service from our API. We need to add the
    application serves as a dependency to our controller, and in the startup, we will
    register the dependency in the ASP.NET Core service locator. First, we do the
    registration. Since our application service class has no dependencies yet, we
    can use a singleton, so we add one line to the `ConfigureServices` method of the
    `Startup` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从我们的API中调用应用程序服务。我们需要将应用程序服务作为依赖项添加到我们的控制器中，并在启动时，我们将依赖项注册到ASP.NET Core服务定位器中。首先，我们进行注册。由于我们的应用程序服务类还没有依赖项，我们可以使用单例，因此我们在`Startup`类的`ConfigureServices`方法中添加一行：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When this is done, we can add the `ClassifiedAdsApplicationService` class as
    a dependency to the `ClassifiedAdsCommandsApi` controller and call the `Handle`
    method from our `Post` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一切完成之后，我们可以将`ClassifiedAdsApplicationService`类作为依赖项添加到`ClassifiedAdsCommandsApi`控制器中，并从我们的`Post`方法中调用`Handle`方法：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the next section, we will dive into command handling, including saving entities
    to an entity store and retrieving them. We will add more commands and handlers
    for those commands too.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨命令处理，包括将实体保存到实体存储和检索它们。我们还将为这些命令添加更多的命令和处理器。
- en: Handling commands
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理命令
- en: In the previous section, we created a simple web API and learned that the API
    is the *edge* of our application. The edge talks with the outside world and accepts
    requests via HTTP or another communication protocol. To execute these requests,
    we need an *application service* that works as an intermediary between edge components
    and the domain model. The application service is also responsible for persisting
    entities.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个简单的Web API并了解到API是应用程序的*边缘*。边缘与外部世界进行通信，并通过HTTP或其他通信协议接受请求。为了执行这些请求，我们需要一个作为边缘组件和领域模型之间中介的*应用程序服务*。应用程序服务还负责持久化实体。
- en: Going forward, we will learn more about handling commands and persistence. Also,
    we will discuss handling exceptions and checking whether incoming requests are
    valid.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 今后，我们将学习更多关于处理命令和持久化的知识。我们还将讨论处理异常和检查传入请求是否有效。
- en: The command handler pattern
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令处理器模式
- en: 'There are several ways to handle commands in CQRS. One established pattern
    is to use command handlers. It is not specific to CQRS but it is being widely
    used because it is a very good fit. The command handler is a class that has one
    method to handle a single command type. For example, we might have a command handler
    such as this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在CQRS中处理命令有几种方法。一个已建立的模式是使用命令处理器。这并不特定于CQRS，但它被广泛使用，因为它非常合适。命令处理器是一个类，它有一个方法来处理单个命令类型。例如，我们可能有一个这样的命令处理器：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Two interfaces are used by the command handler earlier. The interfaces look
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理器之前使用了两个接口。接口看起来像这样：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Bear in mind that the `IEntityStore` interface is simplified and not all persistence
    methods can be represented by such an interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`IEntityStore`接口是简化的，并不是所有持久化方法都可以通过这样的接口表示。
- en: Make no mistake, I am not trying to seed the idea of generic repositories in
    your head. In fact, the entity store is not the exact math of the repository pattern.
    When the purpose of repositories is to mimic a collection of objects and hide
    the persistence, the entity store is a complete opposite. It does not represent
    a collection. It does exactly what it tells you about - persist one single object
    and retrieves it back. And while generic repositories are often considered as
    an anti-pattern, I wouldn't apply the same for the entity store interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要误解，我并不是试图在你的脑海中播种通用仓库的想法。实际上，实体存储并不是仓库模式的精确数学。当仓库的目的是模拟一组对象并隐藏持久性时，实体存储是完全相反的。它不表示一个集合。它确实做了它告诉你的——持久化一个单一的对象并检索它。而且，尽管通用仓库通常被认为是一个反模式，但我不会对实体存储接口应用同样的规则。
- en: 'We then can use this command handler in the API:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在API中使用这个命令处理程序：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can see here that we reference the command handler via the `IHandleCommand`
    interface. It gives us some freedom in choosing the implementation we want to
    use. To start with, we can register the implementation we already have:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里我们通过`IHandleCommand`接口引用了命令处理程序。这给了我们一些选择我们想要使用的实现方式的自由。首先，我们可以注册我们已有的实现：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we register the `RavenDbEntityStore` class, which implements `IEntityStore`.
    We aren't going to look at the actual implementation here, but since `RavenDb`
    is the document database, such a class could be trivial to implement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注册了`RavenDbEntityStore`类，它实现了`IEntityStore`。我们不会在这里查看实际的实现，但既然`RavenDb`是文档数据库，这样的类可能很容易实现。
- en: 'What we have done so far is very straightforward, but since we are using the
    `IHandleCommand<T>` interface in our API, we can do something more interesting.
    For example, we can create a generic command handler that retries failures:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的是非常直接的，但由于我们在API中使用`IHandleCommand<T>`接口，我们可以做一些更有趣的事情。例如，我们可以创建一个通用的命令处理程序，它会重试失败：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We just need to change the service registration to look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将服务注册更改如下：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we wrap the actual command handler inside the generic retry handler. Since
    they both implement the same interface, we can build a pipeline using a composition
    of these classes. We can continue adding more elements to the chain, such as using
    a circuit breaker or a logger.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将实际的命令处理程序包裹在通用的重试处理程序中。由于它们都实现了相同的接口，我们可以通过这些类的组合来构建一个管道。我们可以继续向链中添加更多元素，例如使用断路器或记录器。
- en: We can add more properties to the command class (remember the weak schema),
    but the only handler that we might want to change because of this would be the
    actual command handler. All transient handlers will remain unchanged because we
    are using the command type, which is a complex type, as a parameter, so the interface
    definition itself doesn't change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向命令类添加更多属性（记住弱模式），但可能需要更改的唯一处理程序就是实际的命令处理程序。所有瞬态处理程序都将保持不变，因为我们使用的是命令类型，这是一个复杂类型，作为参数，所以接口定义本身并没有改变。
- en: 'The command handler pattern is compelling, and it adheres to the **Single Responsibility
    Principle** (**SRP**). At the same time, each HTTP method in our API would require
    a separate command handler as a dependency. It is not a big deal if we have two
    or three methods, but we might have a little more than that. We might predict
    that we will have more than 10 methods in our classified ad web API, and an adequate
    number of command handlers, just by looking at the result of our EventStorming
    session. Command handlers need the entity store as a dependency, and since all
    web API controllers are instantiated per scope, all command handlers will be instantiated
    and injected as well, with all their dependencies. It is possible to mitigate
    the instantiation of a vast dependency tree by using factory delegates instead
    of dependencies per request, so each method would be able to instantiate its handler:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理器模式很有吸引力，并且遵循 **单一职责原则**（**SRP**）。同时，我们 API 中的每个 HTTP 方法都需要一个单独的命令处理器作为依赖项。如果我们有两个或三个方法，这并不是什么大问题，但我们可能会有更多。仅通过查看我们的
    EventStorming 会话的结果，我们可能预测我们的分类广告 Web API 将会有超过 10 个方法，以及足够的命令处理器。命令处理器需要实体存储作为依赖项，并且由于所有
    Web API 控制器都是按范围实例化的，因此所有命令处理器也将被实例化和注入，包括它们的所有依赖项。通过使用工厂委托而不是每个请求的依赖项来减轻庞大依赖树的实例化，这样每个方法就能实例化其处理器：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach would require more advanced registration since we aren't using
    the actual type, but a delegate. Another solution might be to use `Lazy<IHandleCommand<T>>`
    as a dependency. Again, it will require more complex registration. The registration
    challenge might be resolved by using another dependency-injection container, such
    as Autofac, which supports automatic factory delegates and `Lazy<T>` out of the
    box.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法需要更高级的注册，因为我们不是使用实际类型，而是一个委托。另一个解决方案可能是使用 `Lazy<IHandleCommand<T>>` 作为依赖项。同样，这也需要更复杂的注册。注册挑战可能通过使用另一个依赖注入容器来解决，例如支持自动工厂委托和
    `Lazy<T>` 的 Autofac。
- en: In this book, we will not be using the command handler pattern, but instead,
    we will implement command handling using the application service. We already started
    to implement a simple service in this section and will continue in the next section.
    The command handler detour exists to bring a better overview of useful patterns
    since no pattern is good enough for all use cases.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会使用命令处理器模式，而是将使用应用服务来实现命令处理。我们已经在本节中开始实现一个简单的服务，将在下一节中继续。命令处理器绕行存在是为了更好地概述有用的模式，因为没有任何模式适合所有用例。
- en: Application service
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用服务
- en: 'In fact, how our application service will look and behave is very similar to
    a bunch of command handlers. A *classic* application service exposes some methods
    with multiple parameters, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们的应用服务将看起来和表现得很像一组命令处理器。一个 *经典* 的应用服务会公开一些带有多个参数的方法，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using this kind of declaration is perfectly fine, except it doesn't play that
    well with the composition. It is not easy to add such an application service to
    a pipeline, where we have logging, retry policies, and so on. To make a pipeline,
    we need all our handlers to have compatible parameters, but these methods of `IPaymentApplicationService`
    just don't allow us to go that way. Every other call in the pipeline must have
    the same set of parameters, and as soon as we want to add one more parameter to
    any method, we are doomed to make numerous changes in multiple classes that form
    our pipeline. This is not something we'd like to do.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种声明方式是完全可以接受的，但它与组合不太兼容。将此类应用服务添加到具有日志记录、重试策略等的管道中并不容易。要构建管道，我们需要所有处理器具有兼容的参数，但
    `IPaymentApplicationService` 的这些方法根本不允许我们这样做。管道中的每个其他调用都必须具有相同的参数集，而且一旦我们想要向任何方法添加一个参数，我们就注定要在构成管道的多个类中进行大量更改。这不是我们愿意做的事情。
- en: 'Alternatively, we can have one application service class that implements multiple
    `IHandle<T>` interfaces. This would work, but each command will then require a
    separate bootstrapping code, although we are adding the same elements to our pipeline:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以有一个实现多个 `IHandle<T>` 接口的应用服务类。这可以工作，但每个命令将需要单独的引导代码，尽管我们在管道中添加的是相同的元素：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, we can generalize our application service to handle any type
    of command, and use the C# 7 advanced pattern-matching feature again (like we
    did with event handling). In this case, the application service signature would
    look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将我们的应用程序服务泛化以处理任何类型的命令，并再次使用C# 7的高级模式匹配功能（就像我们在事件处理中做的那样）。在这种情况下，应用程序服务的签名将如下所示：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All our previous filters for the pipeline, such as the retry filter or the
    logging filter, can implement this simple interface. Since those classes don''t
    need to get a hold of the command''s content, everything will work just fine.
    Our classified ad service would then look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前用于管道的所有过滤器，如重试过滤器或日志过滤器，都可以实现这个简单的接口。由于那些类不需要获取命令的内容，所以一切都会正常工作。我们的分类广告服务将看起来像这样：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By implementing our application service like this, we will have a single dependency
    to handle for all of our API calls, and we keep the door open to compose a more
    complex command processing pipeline, just as we were able to do with individual
    command handlers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式实现我们的应用程序服务，我们将有一个单一的依赖关系来处理所有的API调用，并且我们保持开放的大门来构建一个更复杂的命令处理管道，就像我们能够对单个命令处理器做到的那样。
- en: Of course, the tradeoff here is that we have one class that handles several
    commands and some might see it as an SRP violation. At the same time, the level
    of cohesion for this class is high, and we will see more of it later in this chapter
    when we will adequately handle several commands and make calls to our application
    service from the edge.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里的权衡是我们有一个处理多个命令的类，有些人可能会认为它违反了SRP原则。同时，这个类的内聚度很高，我们将在本章的后面看到更多关于它如何适当地处理多个命令并从边缘调用我们的应用程序服务的内容。
- en: Let's now add more commands and extend our application service and the HTTP
    edge accordingly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在添加更多命令并相应地扩展我们的应用程序服务和HTTP边缘。
- en: 'First, we need to get back to our entity and check what actions we can command
    it to perform. These actions are as following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要回到我们的实体并检查我们可以命令它执行哪些操作。这些操作如下：
- en: Set the title.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置标题。
- en: Update the text.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新文本。
- en: Update the price.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新价格。
- en: Request to publish.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求发布。
- en: We can add four commands to execute these actions, since we could expect, based
    on our EventStorming sessions, that this is what our users would like to do.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加四个命令来执行这些操作，因为我们根据我们的EventStorming会议可以预期，这是我们用户想要做的。
- en: 'The expanded commands list would look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展后的命令列表将如下所示：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each command needs to have the ID of the entity it is going to operate on. Other
    properties are command-specific.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都需要有它将要操作的实体的ID。其他属性是命令特定的。
- en: 'Second, we can extend our edge to accept these commands as HTTP requests. The
    code for the new API version is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们可以扩展我们的边缘以接受这些命令作为HTTP请求。新API版本的代码如下：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might already see some candidates for creating a useful abstraction or routine.
    You can probably also predict some issues with this code when it will run in production.
    The preceding edge code also violates an important principle that the API client
    needs to only sends valid commands to the command handler. In our code, there
    is nothing that does such checks. Don't worry; we will get back to the API code
    and solve some of those issues. For now, let's concentrate on the essential bits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了一些创建有用抽象或例程的候选者。你也许也可以预测一些当这段代码在生产环境中运行时可能出现的问题。前面的边缘代码也违反了一个重要的原则，即API客户端需要只向命令处理器发送有效的命令。在我们的代码中，没有任何东西进行这样的检查。不用担心；我们将回到API代码并解决这些问题。现在，让我们集中精力在关键部分。
- en: 'As you can see, our application service is expected to handle five commands.
    We need to take care that it does that. The new code for our application service
    would be the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的应用程序服务预计将处理五个命令。我们需要确保它这样做。我们应用程序服务的新代码如下：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we again use the `IEntityStore` abstraction. This interface is very simple:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们再次使用`IEntityStore`抽象。这个接口非常简单：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will be implementing this interface for different persistence types.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为不同的持久化类型实现这个接口。
- en: As you can see, handling the `Create` command looks different from handling
    all other commands. This is natural since when we create a new entity, we need
    to ensure it does not exist yet. When we handle operations on the existing entity,
    it works the other way around. In this case, we need to ensure that the entity
    exists, otherwise, we cannot perform the operation and must throw an exception.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理`Create`命令与处理所有其他命令看起来不同。这是自然的，因为当我们创建一个新的实体时，我们需要确保它尚未存在。当我们处理现有实体的操作时，情况正好相反。在这种情况下，我们需要确保实体存在，否则，我们无法执行操作并必须抛出异常。
- en: Another thing worth mentioning is that the application service is responsible
    for translating primitive types, such as string or decimal, to value objects.
    The edge always uses serializable types that have no dependencies on the domain
    model. The application service, however, operates with domain concerns; it needs
    to tell our domain model what to do, and since our domain model prefers to receive
    data as value objects, the application service is then responsible for the conversion.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提及的是，应用服务负责将原始类型，如字符串或十进制数，转换为值对象。边缘始终使用可序列化的类型，这些类型不依赖于领域模型。然而，应用服务操作与领域相关；它需要告诉我们的领域模型要做什么，由于我们的领域模型更喜欢以值对象的形式接收数据，因此应用服务负责转换。
- en: 'The code for handling commands for an existing entity looks very similar to handling
    updates for existing entities. In fact, only the line where we call the entity
    method is different. Therefore, we can significantly simplify the `Handle` method
    by using a straightforward generalization and replace the `switch` pattern-matching
    operator with the switch expression:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 处理现有实体命令的代码看起来与处理现有实体更新非常相似。实际上，只有调用实体方法的行有所不同。因此，我们可以通过直接的一般化来显著简化`Handle`方法，并用switch表达式替换`switch`模式匹配运算符：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: From the application service code, it becomes clear that the application service
    itself plays the vital role of an intermediary between the application edge and
    the domain model. An edge could be anything that communicates with the outside
    world. We used the HTTP API as an example, but it could also be a messaging interface
    or something entirely different. The important requirement for the edge would
    be the ability to accept commands, check them, and engage the application service
    to handle those commands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用服务代码中可以看出，应用服务本身在应用边缘和领域模型之间扮演着至关重要的中介角色。边缘可以是任何与外界通信的东西。我们以HTTP API为例，但它也可以是消息接口或完全不同的东西。对于边缘来说，重要的要求是能够接受命令、检查它们并让应用服务处理这些命令。
- en: When we handle a command, no matter whether we use multiple command handlers
    or single application service, the sequence of operations is usually very similar.
    A command handler needs to fetch a persisted entity from the entity store, call
    the domain model to do the work, and then persist changes. In our example, we
    only called one method of the entity, but this is not always the case. We will
    look deeper into this when we discuss the consistency and transactional boundaries
    in the next chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理一个命令时，无论我们使用多个命令处理器还是单个应用服务，操作序列通常非常相似。命令处理器需要从实体存储中检索持久化的实体，调用领域模型来完成工作，然后持久化更改。在我们的例子中，我们只调用了一个实体方法，但这种情况并不总是如此。我们将在下一章讨论一致性和事务边界时进一步探讨这一点。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how the intent of our users can be represented
    as commands that those users send to our system. We learned how these commands
    can be handled, looked at several examples of the command handler pattern, and
    then got to the application service.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将用户的意图表示为用户发送给我们的系统的命令。我们学习了如何处理这些命令，查看了一些命令处理器模式的示例，然后转向应用服务。
- en: We looked at API versioning; although it is not directly related to the book
    topic, the practice is too important to ignore. We will touch upon the versioning
    topic in [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event Sourcing*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了API版本控制；尽管它与本书的主题没有直接关系，但这一实践的重要性不容忽视。我们将在第10章[事件溯源](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)中简要提及版本控制话题。
- en: Our application service grew throughout this chapter, and we used one of the
    latest features of C#, a gift from the functional world, called **advanced pattern
    matching**. We used this feature to simplify the application service interface,
    which ended up having just a single method. By doing this, we also enabled using
    a composition, yet another functional-style approach, to chain command handling
    with operational concerns, such as logging and retries. We will also look at how
    this can help us check the validity of commands.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的应用程序服务得到了扩展，我们使用了C#的最新特性之一，来自函数式世界的礼物，称为**高级模式匹配**。我们利用这个特性简化了应用程序服务接口，最终只保留了一个方法。通过这种方式，我们还启用了使用组合，另一种函数式风格的途径，将命令处理与操作关注点（如日志记录和重试）链式连接。我们还将探讨这如何帮助我们检查命令的有效性。
- en: In the next chapter, we will take a closer look at entity persistence. We will
    learn what types of consistency we need to deal with and how important it is to
    understand the consistency boundaries.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨实体持久化。我们将学习需要处理哪些类型的致性以及理解致性边界的重要性。
