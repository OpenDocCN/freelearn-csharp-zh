- en: Mastering Practical Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WPF offers a wide range of animation possibilities, from the simple to the really
    quite complex. In this chapter, we will thoroughly explore the WPF property animation
    system, yet focus primarily on those parts that can be suitably applied to real-world
    business applications. We'll investigate how to control running animations in
    real time and predominantly concentrate on XAML-based syntax. We'll then see how
    we can build animations right into our application framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In WPF, animations are created by repeatedly altering individual property values
    at regular intervals. Animations are comprised of a number of components: we need
    a timing system, an animation object that is responsible for updating the values
    of a particular type of object and a suitable property to animate.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to animate a property, it must be a Dependency Property
    of a `DependencyObject` and its type must implement the `IAnimatable` interface.
    As most UI controls extend the `DependencyObject` class, this enables us to animate
    the properties of most controls.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, an animation object for the relevant type of property must exist.
    In WPF, the animation objects also double up as the timing system, as they extend
    the `Timeline` class. Before investigating the various animation objects, let's
    first examine the timing system.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating timelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animations require some kind of timing mechanism that is responsible for updating
    the relevant property values at the right time. In WPF, this timing mechanism
    is catered for by the abstract `Timeline` class, which in short, represents a
    period of time. All of the available animation classes extend this class and add
    their own animation functionality.
  prefs: []
  type: TYPE_NORMAL
- en: When a `Timeline` class is used for animations, an internal copy is made and
    frozen, so that it is immutable. Additionally, a `Clock` object is created to
    preserve the runtime timing state of the `Timeline` object and is responsible
    for the actual timing of the animated property updates. The `Timeline` object
    itself does little other than define the relevant period of time.
  prefs: []
  type: TYPE_NORMAL
- en: The `Clock` object will be automatically created for us when we define a `Storyboard`
    object, or call one of the `Animatable.BeginAnimation` methods. Note that we do
    not typically need to concern ourselves with these `Clock` objects directly, but
    it can be helpful to know about them in order to understand the bigger picture.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different types of `Timeline` objects, from the `AnimationTimeline`
    class to the `TimelineGroup` and `ParallelTimeline` classes. However, for animation
    purposes, we predominantly utilize the `Storyboard` class, which extends the `ParallelTimeline`
    and the `TimelineGroup` classes and adds animation-targeting properties and methods
    for controlling the timeline. Let's first investigate the main properties of the
    base `Timeline` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Duration` property specifies the time that is represented by the associated
    `Timeline` object. However, a timeline can have repetitions, so a more accurate
    description of the `Duration` property might be that it specifies the time of
    a single iteration of the associated `Timeline` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The duration property is of type `Duration`, which contains a `TimeSpan` property
    that contains the actual time that specifies the value of the duration. However,
    WPF includes a type converter that enables us to specify this `TimeSpan` value
    in XAML in the following formats, where the square brackets highlight optional
    segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, the `Duration` structure also accepts other values in addition to the
    `TimeSpan` duration. There is a value of `Automatic`, which is the default value
    for component timelines that contain other timelines. In these cases, this value
    simply means that the parent timeline's duration will be as long as the longest
    duration of its children timelines. There is little purpose for us to explicitly
    use this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one further value that is very useful to us. The `Duration`
    structure also defines a `Forever` property that represents an infinite period
    of time. We can use this value to make an animation continue indefinitely, or
    more accurately, as long as its related View is being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A `Timeline` object will stop playing when it reaches the end of its duration.
    If it has any child timelines associated with it, then they will also stop playing
    at this point. However, the natural duration of a timeline can be extended or
    shortened using other properties, as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some timelines, such as the `ParallelTimeline` and `Storyboard` classes, are
    able to contain other timelines and can affect their durations by setting their
    own values for the `Duration` property, which will override those set by the child
    timelines. Let''s alter an earlier animation example from [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job* to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this preceding example, we have a `Rectangle` object with its dimensions
    initially set to zero. The `Storyboard` object contains two separate animation
    objects that will animate its dimensions from zero to three hundred pixels. The
    animation object that will animate the rectangle's width has a duration of two
    and a half seconds, while the animation object that will animate the height has
    a duration of five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: However, the containing `Storyboard` object has a duration of two and a half
    seconds and so this will stop the timelines of the two child animation objects
    after two and a half seconds, regardless of their declared durations. The result
    of this will be that after the animation is complete, our `Rectangle` object will
    appear as a rectangle, instead of a square with equal height and width values.
  prefs: []
  type: TYPE_NORMAL
- en: If we had changed the duration of the storyboard to match that of the longer
    child animation, or changed that animation duration to match that of the shorter
    child animation, then our animated shape would end as a square, rather than as
    a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to adjust the assigned duration of an animation element is to set
    its `AutoReverse` property. In effect, setting this property to `True` will usually
    double the length of time that is specified by the `Duration` property, as the
    timeline will play in reverse after it has completed its normal forwards iteration.
    Let''s alter the storyboard from the previous example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, both child timelines will have the same overall duration, as the first,
    previously shorter, timeline has effectively been doubled in length. However,
    this will result in the first timeline animating the width of the rectangle to
    three hundred pixels and then back to zero, so it will be invisible when the animations
    have completed. Also note that we had to set the parent storyboard duration to
    five seconds in order to see the difference in the child timelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note again that properties set on timelines that contain other timelines will
    affect the values of those properties on the child timelines. As such, setting
    the `AutoReverse` property to `True` on the parent timeline (the `Storyboard`
    object) will double the total length of time that the child animations will run
    for; in our case, using the following example, the rectangle will now be animated
    for ten seconds in total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `RepeatBehavior` property is of type `RepeatBehavior` and can also affect
    the overall duration of a timeline. Unlike the `AutoReverse` property, it can
    also shorten the overall duration as well as lengthen it. Using the `RepeatBehavior`
    property, we can specify the value in a number of ways using different behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most simple is to provide a count of how many times we would like to multiply
    the original duration of the timeline. A pre-existing XAML type converter enables
    us to set the repeat count in XAML by specifying an `x` after the count, as can
    be seen in the following example. Note that we can also specify numbers with decimal
    places here, including values less than one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the normal duration would be five seconds, but the `AutoReverse`
    property is set to `True` and so that duration is doubled. However, the `RepeatBehavior`
    property is set to `2x` and this will multiply the doubled ten seconds to twenty
    seconds. This multiplier value of two will be stored in the `Count` property of
    the `RepeatBehavior` structure.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to using the count option is to simply set the duration that
    we would like the animation to last for. The same XAML syntax that is used to
    set the `Duration` property can also be used to set the `RepeatBehavior` property.
    Similarly, the `RepeatBehavior` structure also defines a `Forever` property that
    represents an infinite period of time and we can use this value to make an animation
    continue indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'One further property that can affect the duration of an animation is the `SpeedRatio`
    property. This value is multiplied by the other related duration properties and
    so can both speed up and slow down the associated timeline. Let''s update our
    example again to help to explain this property now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, the normal duration here would be five seconds and the `AutoReverse`
    property is set to `True`, so the duration is doubled. However, the `SpeedRatio`
    property is set to `0.5` and so the doubled duration is again doubled to twenty
    seconds. Note that a `SpeedRatio` value of `0.5` represents half the normal speed
    and therefore twice the normal duration.
  prefs: []
  type: TYPE_NORMAL
- en: The second child timeline also sets the `SpeedRatio` property, but it is set
    to `2` and so its speed is doubled and its duration halved. As its specified duration
    is twice that of its sibling timeline and its speed is now twice as fast, this
    has the effect of re-synchronizing the two child animations, so that the two dimensions
    now grow together, as a square, rather than as a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more speed-related properties that we can use to fine-tune our
    animations: the `AccelerationRatio` and `DecelerationRatio` properties. These
    properties adjust the proportion of time that the related animation takes to speed
    up and slow down respectively. While this effect can be subtle at times, it can
    also give our animations that professional touch when used correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Acceptable values for both of these properties exist between zero and one.
    If both properties are used together, then the total sum of their values must
    still remain between zero and one. Failure to adhere to this rule will result
    in the following exception being thrown at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Entering values outside the acceptable range on either of these properties
    individually will also result in an error, although doing this will cause a compilation
    error instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example that highlights the difference between the different
    values of these two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a number of `Rectangle` objects in a `StackPanel` control,
    each with its own associated `DoubleAnimation` element, that increases its width
    from zero to three hundred pixels over one and a half seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we've used the `Storyboard.TargetName` and `Storyboard.TargetProperty`
    properties to target the rectangles from a single `EventTrigger` to reduce the
    amount of code in the preceding example. We'll cover these Attached Properties
    in detail shortly, but for now, we'll just say that they are used to specify the
    target element and property to animate.
  prefs: []
  type: TYPE_NORMAL
- en: Each animation targets a different rectangle and has different values set for
    the `AccelerationRatio` and `DecelerationRatio` properties. The top rectangle's
    animation has its `AccelerationRatio` property set to `1.0` and the animation
    for the bottom rectangle has its `DecelerationRatio` property set to `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The animations for the rectangles in between have varying values. The higher
    the rectangle, the higher the values for the `AccelerationRatio` property and
    the lower the values for the `DecelerationRatio` property and the lower the rectangle,
    the lower the values of the `AccelerationRatio` property and the higher the values
    for the `DecelerationRatio` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this example is run, we can clearly see the differences between the various
    ratio values. At one point near the start of each iteration, we can see that the
    top rectangles that are animated with higher `AccelerationRatio` values have not
    grown in size as much as the lower rectangles that are animated with higher `DecelerationRatio`
    values; however, all rectangles reach 300 pixels at approximately the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f33a30c5-755c-4809-bba8-e632617ebdf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Another useful property in the `Timeline` class is the `BeginTime` property.
    As the name suggests, it sets the time to begin the animation; it can be thought
    of as a delay time that delays the start of its animation with relation to parent
    and sibling timelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value of this property is zero seconds and when it is set with
    a positive value, the delay occurs just once at the start of the timeline and
    is not affected by other properties that may be set on it. It is often used to
    delay the start of one or more animations until another animation has completed.
    Let''s adjust our earlier example again to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a single pixel high rectangle with a width that grows
    outward until it is three hundred pixels wide and then grows vertically until
    it is three hundred pixels high. At that point, its dimensions equally reduce
    in size until the shape shrinks to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: This is achieved by delaying the last three animations while the width-increasing
    animation runs and then delaying the last two animations while the height-increasing
    animation runs. The `BeginTime` properties of the last two animations are set
    to the same value, so that they both start and run in synchronization with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: The last really useful timeline property is the `FillBehavior` property, which
    specifies what should happen to the data bound property value when the timeline
    reaches the end of its total duration, or its fill period. This property is of
    type `FillBehavior` and has just two values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set this property to a value of `HoldEnd`, the data bound property value
    will remain at the final value that was reached just before the animation ended.
    Conversely, if we set this property to a value of `Stop`, which is the default
    value, the data bound property value will revert to the value that the property
    originally had before the animation started. Let''s illustrate this with a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the difference between the two `FillBehavior` enumeration instances
    is clearly demonstrated. We have two rectangles of identical size that have identical
    timelines set up to animate their `Opacity` property values, with the exception
    of their `FillBehavior` property values.
  prefs: []
  type: TYPE_NORMAL
- en: Both rectangles fade from being opaque to being invisible in the same amount
    of time, but once the two timelines are complete, the rectangle with the `FillBehavior`
    property set to `Stop` immediately becomes visible again, as it was prior to the
    start of the animation, while the other with the `FillBehavior` property set to
    `HoldEnd` remains invisible, as it was at the end of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: While this covers the main properties that are exposed by the `Timeline` class
    directly, there are a few more properties that are declared by many of the animation
    classes that extend the `Timeline` class and are essential to fully understand.
    They are the `From`, `By` and `To` properties, which specify the start and end
    points of the animations.
  prefs: []
  type: TYPE_NORMAL
- en: Because the animation classes generate property values, there are different
    types of animation classes for different property types. For example, the animation
    class that generates `Point` values is called the `PointAnimation` class and all
    of the normal animation classes follow the same naming pattern, using the name
    of the related type in the form of `<TypeName>Animation`, for example `ColorAnimation`.
  prefs: []
  type: TYPE_NORMAL
- en: The normal animation classes, often referred to as the `From`, `By` and `To`
    animations, usually require two values to be specified, although one of these
    can sometimes be implicitly provided. The relevant property will then be animated
    along a path of automatically interpolated values between the two specified values.
  prefs: []
  type: TYPE_NORMAL
- en: It is most common to provide a starting value using the `From` property and
    an ending value using the `To` property. However, we can also specify a single
    starting, ending, or offset value and the second value will be taken from the
    current value of the animated property. We can set the offset value using the
    `By` property and this represents the exact amount the property value will change
    over the duration.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying values for these different properties can have dramatically different
    effects on the resulting animations. Using the `From` property alone will start
    the animation at the desired value and will animate the property until it reaches
    the property's base value.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `To` property alone will start animating the property from its current
    value and end at the specified value. Using only the `By` property will animate
    the property from its current value until the sum of that value with the specified
    offset amount has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: Combinations of the three properties can be used to target just the right range
    of property values. Setting the `From` and `By` properties will start the animations
    from the value specified by the `From` property and animate the property until
    the offset specified by the `By` property has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `From` and `To` properties together will start the animations from
    the value specified by the `From` property and animate the property until the
    value specified by the `To` property. As the `By` and `To` properties both specify
    the ending value of the animation, the value specified by the `By` property will
    be ignored if they are both set on an animation element.
  prefs: []
  type: TYPE_NORMAL
- en: While these more common animations use one or two of the `From`, `By`, and `To`
    properties together to specify the range of values of the related property to
    be animated, there is another way to specify the target values. Let's now take
    a look at key-frame animations.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing key-frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Key-frame animations enable us to do a number of things that we cannot do with
    the `From`, `By`, and `To` animations. Unlike those animations, with key-frame
    animations, we are able to specify more than two target values and animate objects
    in discrete steps that cannot normally be animated. As such, there are more `<TypeName>AnimationUsingKeyFrames`
    classes than `<TypeName>Animation` classes, for example: `RectAnimationUsingKeyFrames`, `SizeAnimationUsingKeyFrames`.
  prefs: []
  type: TYPE_NORMAL
- en: Each `<TypeName>AnimationUsingKeyFrames` class has a `KeyFrames` property that
    we populate with key-frames to specify various values that must be passed during
    the animation. Each key-frame has a `KeyTime` and a `Value` property to specify
    the value and the relative time that it should be reached.
  prefs: []
  type: TYPE_NORMAL
- en: If no key-frame is declared with a key time of zero seconds, the animation will
    start from the relevant property's current value. The animation will order the
    key-frames by the values of their `KeyTime` property, rather than the order that
    they were declared in, and will create transitions between the various values
    according to their interpolation methods, which we'll find out about momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `KeyTime` property is of type `KeyTime` and this enables us to
    set it using types of values, other than `TimeSpan` values. We are also able to
    specify percentage values, which determine the percentage of the specified animation
    duration that each key-frame will be allotted. Note that we need to use cumulative
    values, so that the final key-frame key time value will always be `100%`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, there are a number of special values that we can use. When we
    want an animation with a constant velocity, regardless of the specified values,
    we can specify the `Paced` value for each of the key-frames. This takes the change
    between each key-frame's value into consideration before spacing them across the
    duration of the parent timeline and creating a smooth, even transition.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to this method, we can also specify the `Uniform` value for each
    key-frame, which basically spaces the key-frames out evenly across the duration
    of the parent animation. To do this, it simply counts the number of key-frames
    and divides that number by the total duration length, so that each key-frame will
    last for the same amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: There are different kinds of key-frames for different `<TypeName>AnimationUsingKeyFrames`
    classes and there are also different kinds of interpolation methods used. The
    naming convention of these key-frames follows the format, `<InterpolationMethod><TypeName>KeyFrame`,
    for example: `LinearDoubleKeyFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: There are three kinds of interpolation methods. The first is `Discrete`, which
    performs no interpolation and simply jumps from one value to another. This method
    is useful for setting `bool` or `object` values.
  prefs: []
  type: TYPE_NORMAL
- en: The next method is `Linear`, which performs a linear interpolation between the
    key-frame's value and the previous key-frame's value. This means that the animation
    will appear smooth, but speed up and slow down if your key-frame times are not
    evenly spaced out.
  prefs: []
  type: TYPE_NORMAL
- en: The last and most complicated interpolation method is `Spline`, but it also
    provides the user with the most control over the animation timing. It adds a further
    property named `KeySpline`, which enables us to specify two control points on
    a Bezier curve that extends from `0.0,0.0` to `1.0,1.0`. The first control point
    affects the first half of the curve, while the second point affects the second
    half.
  prefs: []
  type: TYPE_NORMAL
- en: Using these two control points, we can adjust the speed of the animation over
    its duration. As an example, using the first control point set to `0.0,1.0` and
    the second set to `1.0,0.0` will cause maximum distortion to the original linear
    curve and result in an animation that will quickly accelerate, before slowing
    almost to a stop in the middle and then dramatically speeding up again at the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: With these two points, we can have full control over the speed of value change
    between each pair of key-frame values. This type of interpolation is most useful
    when attempting to create animations that are more realistic looking. Note that
    we are free to mix and match key-frames with different interpolation methods within
    each key-frame animation.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's say that we wanted to animate a `Point` element. In this
    case we'd need to use the `PointAnimationUsingKeyFrames` class and would then
    have a choice of key-frame classes that represent the different interpolation
    methods. With this example, we could use any combination of the `DiscretePointKeyFrame`,
    `LinearPointKeyFrame`, and `SplinePointKeyFrame` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, as the `KeyFrames` property is set as the `name` input parameter
    in the `ContentPropertyAttribute` attribute that forms part of the declared class
    signature in each of the `<TypeName>AnimationUsingKeyFrames` classes, we do not
    need to explicitly declare this property in XAML and can declare the various key-frames
    directly inside these elements as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we declare an `Ellipse` shape with its `Fill` property set
    to an instance of the `RadialGradientBrush` class. The brush has a yellow center
    and is orange around the edges. Note that these brushes have a property named
    `GradientOrigin` that specifies the center point of the gradient and defaults
    to the point `0.5,0.5`. In this example, we animate this property, which has a
    similar effect to moving a light source around a 3D ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8f14b19-6725-462a-83a9-1c62ec016528.png)'
  prefs: []
  type: TYPE_IMG
- en: We use an `EventTrigger` with the `Loaded` event to start our animation and
    set the `RepeatBehavior` property to `Forever` on the associated storyboard. As
    mentioned, we set the `TargetProperty` property to the `GradientOrigin` property
    of the brush that is set as the `Fill` property.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the storyboard, we declare a `PointAnimationUsingKeyFrames` element and
    directly inside it, we declare a number of various `<InterpolationMethod><Type>KeyFrame`
    objects. As mentioned, we do not need to explicitly declare the `KeyFrames` property
    in order to declare these key-frame elements within it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `DiscretePointKeyFrame` element that is used here is entirely
    optional and would not change anything if removed. This is because the point `0.5,0.5` is
    both the starting value of the animation and default value of the gradient brush
    and also the ending value of the animation. Furthermore, if we omit a zero time
    key-frame, one will be implicitly added for us with this value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a `LinearPointKeyFrame` element, that will animate the gradient
    origin from the point `0.5,0.5` to the point `1.0,1.0` in a linear, even fashion.
    Following that, we have a `SplinePointKeyFrame` element that will animate the
    gradient origin from the previous point to the point `1.0,0.0`. Note the `KeySpline`
    property that adjusts the speed of the animation as it progresses.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we use another `LinearPointKeyFrame` element to smoothly and evenly
    transition to the point `0.0,0.0` over one second. Finally, we use a second `SplinePointKeyFrame`
    element to animate the gradient origin back to the center of the circle and its
    starting position, taking the last three seconds of the total duration.
  prefs: []
  type: TYPE_NORMAL
- en: When this example is run, we can clearly see it animating the gradient origin
    point evenly during the periods of the two `LinearPointKeyFrame` elements and
    changing the speed during the periods of the two `SplinePointKeyFrame` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Telling stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the various animation classes that extend the `Timeline` class can be
    used to animate control properties directly in code, in order to declare and trigger
    animations using XAML alone, we need to use the `Storyboard` class. This is what
    is known as a container timeline, as it extends the abstract `TimelineGroup` class
    that enables it to contain child timelines.
  prefs: []
  type: TYPE_NORMAL
- en: Another container timeline class that the `Storyboard` class extends is the
    `ParallelTimeline` class and these classes enable us to group child timelines
    and to set properties on them as a group. When creating more complex animations,
    if all we need to do is to delay the start of a group of child timelines, we should
    use the `ParallelTimeline` class rather than the `Storyboard` class, as it is
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite our earlier `BeginTime` example to use a `ParallelTimeline`
    element to delay the start of our last two timelines. Let''s see what that might
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As the `Storyboard` class is a `Timeline` object, it also has the same properties
    as the various animation objects. One additional property that it inherits from
    the `ParallelTimeline` class is the `SlipBehavior` property. This property is
    only really useful when we want to synchronize an animation timeline with the
    playback of a `MediaTimeline` element, but it's worth knowing about.
  prefs: []
  type: TYPE_NORMAL
- en: This property is of the enumeration type `SlipBehavior` and it only has two
    members. A value of `Grow` specifies that we do not need our animation timelines
    to be synchronized with our media timeline(s) and is the default value of this
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, a value of `Slip` indicates that we want our animation timelines
    to slip, either forwards or backwards, whenever necessary in order to keep them
    in sync with the playing media. If the media takes time to load when using this
    setting, then the animation timelines within the storyboard will wait until the
    media is ready and continue at that point.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the properties that have been inherited from the various base
    classes, the `Storyboard` class also declares three important Attached Properties
    that are essential for targeting animations to individual UI elements and/or their
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `Storyboard.Target` Attached Property specifies the UI control that should
    be animated, although setting this property alone is not enough, as it does not
    specify the target property. This property is of type `object`, although it can
    only be used with objects of type `DependencyObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use this property, we need to specify a binding path that references
    the target UI control. If the target element extends the `FrameworkElement` or
    `FrameworkContentElement` classes, then one way would be to name the target element
    and to use an `ElementName` binding to reference it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Most UI elements extend one of these two classes that declare the `Name` property.
    However, if we provide a name for the target control, then there is a simpler
    way to target it. Instead of using the `Storyboard.Target` property, we could
    use the `Storyboard.TargetName` Attached Property to specify the target element
    using just their declared name, without any binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We do not always need to specify this property value, as on occasion, the target
    element can be worked out implicitly. If the relevant storyboard was started with
    a `BeginStoryboard` element, the UI element that declared it will be targeted.
    Additionally, if the relevant storyboard is a child of another timeline, then
    the target of the parent timeline will be inherited.
  prefs: []
  type: TYPE_NORMAL
- en: The most important property that the `Storyboard` class declares is the `TargetProperty`
    Attached Property. We use this property to specify which property we want to animate
    on the target element. Note that in order for this to work, the target property
    must be a Dependency Property.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, we may want to target objects that do not extend either of the
    framework classes mentioned earlier; in WPF, we are also able to target freezable
    classes that extend the `Freezable` class. In order to target one of these classes
    in XAML, we need to specify the name of the object using the `x:Name` directive
    instead, as they have no `Name` property.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, WPF classes that declare their own `Name` property actually
    map the name value through to the `x:Name` directive, which is part of the XAML
    specification. In these cases, we are free to use either of these to register
    a name for an element, but we must not set both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that unnamed elements can still be referenced by our animations, although
    they need to be indirectly referenced. Instead of referencing them directly, we
    need to specify the name of the parent property or freezable object and then chain
    properties in the `TargetProperty` Attached Property until we reach the desired
    element. We used this method in the last example of the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we reference the `Fill` property, which is of type `RadialGradientBrush`,
    and then we chain to the `GradientOrigin` property of the brush from there. Note
    that if we had used an instance of the `SolidColorBrush` class here instead, this
    reference would fail, because there is no `GradientOrigin` property in that brush.
    However, while the animation would fail to work, this would not cause any errors
    to be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling storyboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start a storyboard in XAML, we need to use a `BeginStoryboard` element.
    This class extends the `TriggerAction` class and if you remember, that is the
    type that we need to use in the `TriggerActionCollection` of the `EventTrigger`
    class and the `TriggerBase.EnterActions` and `TriggerBase.ExitActions` properties.
  prefs: []
  type: TYPE_NORMAL
- en: We specify the storyboard to use with the `BeginStoryboard` element by setting
    it to the `Storyboard` property in code. When using XAML, the `Storyboard` property
    is implicitly set to the storyboard that is declared within the `BeginStoryboard`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: The `BeginStoryboard` action is responsible for connecting the animation timelines
    with the animation targets and their targeted properties and is also responsible
    for starting the various animation timelines within its storyboard. It does this
    by calling the `Begin` method of the associated `Storyboard` object, once its
    parent's trigger condition has been met.
  prefs: []
  type: TYPE_NORMAL
- en: If an already running storyboard is asked to begin again, either indirectly,
    using a `BeginStoryboard` action, or directly, using the `Begin` method, what
    happens will depend upon the value set by the `HandoffBehavior` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'This property is of the enumeration type `HandoffBehavior` and has two values.
    The default value is `SnapshotAndReplace` and this will renew the internal clocks
    and essentially have the effect of replacing one copy of the timeline with another.
    The other value is more interesting: the `Compose` value will retain the original
    clocks when restarting the animation and append the new animation after the current
    one, performing some interpolation between them, resulting in a smoother join.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem with this method is that the retained clocks will continue to use
    system resources and this can end in memory problems if not handled correctly.
    However, this method produces much smoother and more natural and fluid animations
    that can be worth the extra resources. This is best demonstrated with a small
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have two rectangles, each with its own animation. The only
    difference between them is that the `BeginStoryboard` element that starts the
    animation for the right rectangle has a `HandoffBehavior` of `Compose`, while
    the other uses the default value of `SnapshotAndReplace`.
  prefs: []
  type: TYPE_NORMAL
- en: When the example is run, each rectangle will move upwards when the mouse cursor
    is placed over it and move back downwards when the cursor is moved away from it.
    If we keep the mouse cursor within the bounds of each rectangle, moving it up
    to the top of the screen with the rectangle and then move the cursor away to let
    the rectangle fall, the two animations will appear identical.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we move the mouse cursor from side to side across the two rectangles,
    we will start to see a difference between the two animations. We'll see that as
    the cursor enters the bounds of each rectangle, they each start their upwards
    movement. But once the cursor leaves the rectangle bounds, we see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: The rectangle on the left, with the default value of `SnapshotAndReplace`, will
    stop moving up and immediately begin its downwards animation, while the other
    rectangle will continue to move upwards for a short time before commencing its
    downwards animation. This results in a much smoother, more natural looking transition
    between the two animations.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between these two handoff behaviors though, is most clearly demonstrated
    by simply placing the mouse cursor on one of the rectangles and leaving it there.
    Doing this to the rectangle on the left will cause the rectangle to move upwards
    until the mouse cursor is no longer within its bounds and then it will immediately
    begin to move downwards again.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the mouse cursor will then be within the bounds of the rectangle
    again, it will begin the upwards animation once more. This will cause the rectangle
    to move away from the mouse cursor again and so we will end with a repetitive
    loop of this behavior and it will result in what looks like a quick shaking, or
    stuttering, of the rectangle just above the position of the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the rectangle on the right, with the `HandoffBehavior` of
    `Compose`, will move upwards until the mouse cursor is no longer within its bounds,
    but will then continue to move upwards for a short time before starting to move
    downwards again. Once more, this creates a far smoother animation and will result
    in the rectangle bouncing gently above the mouse cursor, in sharp contrast to
    the other, stuttering rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: There are several related `TriggerAction` derived classes that are suffixed
    with the word `Storyboard` and enable us to control various aspects of the related
    `Storyboard` element. By specifying the `Name` property value of the `BeginStoryboard`
    element in the `BeginStoryboardName` property of the other actions, we are able
    to further control the running storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `PauseStoryboard` element to pause a running storyboard and the
    `ResumeStoryboard` to resume a paused storyboard. The `PauseStoryboard` element
    does nothing if the related storyboard is not running and, similarly, the `ResumeStoryboard`
    action does nothing if the related storyboard is not already paused. Therefore,
    a storyboard cannot be started with a `ResumeStoryboard` trigger action.
  prefs: []
  type: TYPE_NORMAL
- en: The `StopStoryboard` action will stop a running storyboard, but does nothing
    if the related storyboard is not already running. Finally, there is a `RemoveStoryboard`
    trigger action that will remove a storyboard when its parent's trigger condition
    has been met. As storyboards consume resources, we should remove them when they
    are no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we use an `EventTrigger` with the `Loaded` event to start a
    timeline that has its `RepeatBehavior` property set to `Forever`, then we should
    use another `EventTrigger` element with a `RemoveStoryboard` action in the `Unloaded`
    event to remove the storyboard. This is somewhat analogous to calling the `Dispose`
    method on an `IDisposable` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it is essential to remove a storyboard that was started by a `BeginStoryboard`
    action with its `HandoffBehavior` property set to `Compose`, as it could end with
    many internal clocks being instantiated, but not disposed of. Removing the storyboard
    will also result in the internally used clocks being disposed of. Let''s see a
    practical example of how we might use these elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This example has two textboxes, with the lower one existing solely to enable
    us to remove focus from the first one. The first textbox is data bound to a `Name`
    property in our View Model. Let''s imagine that we have some validation code that
    will update a property named `IsValid` when the `Name` property is changed. We''ll
    cover validation in depth in [Chapter 9](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml),
    *Implementing Responsive Data Validation*, but for now, let''s keep it simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply verify that the `Name` property has a value that has three or
    more characters in it. The basic idea in this example is that we have an animation
    that highlights the fact that a particular form field requires a valid value.
  prefs: []
  type: TYPE_NORMAL
- en: It could be a shaking, or growing and shrinking of the form field, or the animation
    of an adjacent element, but in our case, we have used a `DropShadowEffect` element
    to create a glowing effect around it.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Triggers` collection of our style, we have declared a number of triggers.
    The first one is a `DataTrigger` and it data binds to the `IsValid` property in
    the View Model and uses the `BeginStoryboard` trigger action element named `GlowStoryboard`
    to make the glowing effect around the textbox grow and shrink when the property
    value is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: While animations are great at attracting the eye, they can also be quite distracting.
    Skipping over the `MultiDataTrigger` momentarily, our animation will therefore
    be paused when the textbox is focused, so that the user can enter the details
    without distraction. We achieve this by declaring a `PauseStoryboard` action in
    the trigger with the condition that the `IsFocused` property is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `EnterActions` collection of the trigger ensures that the `PauseStoryboard`
    action is run as the `IsFocused` property is set to `true`. Declaring the `ResumeStoryboard`
    action in the `ExitActions` collection of the trigger ensures that it will be
    run as the `IsFocused` property is set to `false`, or in other words, when the
    control loses focus.
  prefs: []
  type: TYPE_NORMAL
- en: When the user has entered a value, our View Model validates whether the provided
    value is indeed valid and, if so, it sets the `IsValid` property to `true`. In
    our example, we just verify that the entered string contains three or more characters
    in order for it to be valid. Setting the `UpdateSourceTrigger` property to `PropertyChanged`
    on the binding ensures this validation occurs on each keystroke.
  prefs: []
  type: TYPE_NORMAL
- en: Our example uses a `DataTrigger` to data bind to this property and when it is
    `true`, it triggers the `StopStoryboard` action, which stops the storyboard from
    running any further. As the `FillBehavior` property of our storyboard is not explicitly
    set, it will default to the `Stop` value and the animated property value will
    return to the original value that it had prior to being animated.
  prefs: []
  type: TYPE_NORMAL
- en: '*However, what should happen if the user entered three or more characters and
    then deleted them?* The data trigger would trigger the `StopStoryboard` action
    and the storyboard would be stopped. As they deleted the characters and the `IsValid`
    property would be set to `false` and the condition of the first `DataTrigger`
    would then trigger the initial `BeginStoryboard` action to start the storyboard
    again.'
  prefs: []
  type: TYPE_NORMAL
- en: But this would occur while the focus was still on the textbox and while the
    animation on the effect should not be running. It is for this reason that we declared
    the `MultiDataTrigger` element that we skipped over earlier. In this trigger,
    we have two conditions. One is that the `IsFocused` property should be `true`
    and for this alone, we could have used a `MultiTrigger` instead.
  prefs: []
  type: TYPE_NORMAL
- en: However, the other condition requires that we data bind to the `IsValid` property
    from the View Model and for that, we need to use the `MultiDataTrigger` element.
    So, this trigger will run its `PauseStoryboard` action when the textbox is focused
    and as soon as the data bound value becomes invalid, or in other words, as the
    user deletes the third character.
  prefs: []
  type: TYPE_NORMAL
- en: The triggers are evaluated from top to bottom in the declared order in the XAML
    and as the user deletes the third character, the first trigger begins the animation.
    The `MultiDataTrigger` has to be declared after the first trigger, so that the
    storyboard will be started before it pauses it. In this case, the glow effect
    will start again once the user has moved focus from the first textbox as required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this example demonstrates how we can use a `RemoveStoryboard` trigger
    action to remove the storyboard when it is no longer needed, freeing up its resources.
    The usual way to do this is by utilizing an `EventTrigger` in the `Unloaded` event
    of the relevant control.
  prefs: []
  type: TYPE_NORMAL
- en: While these are the only trigger action elements that control the running state
    of their associated storyboard elements, there are a further three actions that
    can control other aspects of, or set other properties of the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetStoryboardSpeedRatio` trigger action can set the `SpeedRatio` of the
    associated storyboard. We specify the desired ratio in its `SpeedRatio` property
    and this value will be applied when the action's related trigger condition is
    met. Note that this element can only work on a storyboard that has already been
    started, although it can work at any time after this point.
  prefs: []
  type: TYPE_NORMAL
- en: The `SkipStoryboardToFill` trigger action will move the current position of
    a storyboard to its fill period, if it has one. Remember that the `FillBehavior`
    property determines what should happen during the fill period. If the storyboard
    has child timelines, then their positions will also be forwarded to their fill
    periods at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, there is a `SeekStoryboard` trigger action, which enables
    us to move the current position of storyboard to a location, relative to the position
    specified by the `Origin` property, which has a begin time of zero seconds by
    default. When declaring the `SeekStoryboard` action, we specify the desired seek
    position in the `Offset` property and optionally set the `Origin` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `Offset` property is of type `TimeSpan` and we can use the time notation
    highlighted earlier to specify its value in XAML. The `Origin` property is of
    type `TimeSeekOrigin` and we can specify one of two values.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the default value of `BeginTime`, which places the origin at the
    start of the timeline, while the second is `Duration`, which places it at the
    end of a single iteration of the timeline's natural duration. Note that the various
    speed ratio values are not taken into consideration when seeking through a timeline's
    duration.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our look at the range of trigger actions that we can use to control
    our storyboards. Each of these trigger actions have corresponding methods in the
    `Storyboard` class that they call when their related trigger conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: Easing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When declaring animations with WPF, we are able to utilize a powerful capability
    that helps us to define more specialized animations. While we normally provide
    a start and end value for our animations and let WPF interpolate the intermediate
    values, there is a way that we can affect this interpolation process.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of mathematical functions that provide complex animation
    paths and are known as easing functions. For example, these can accurately replicate
    the movement of a spring, or the bounce of a ball.
  prefs: []
  type: TYPE_NORMAL
- en: We can simply declare the appropriate easing function within the `EasingFunction`
    property of the animation. Each easing function extends the `EasingFunctionBase`
    class and has its own specific properties. For example, the `BounceEase` element
    provides `Bounces` and `Bounciness` properties, while the `ElasticEase` class
    declare the `Oscillations` and `Springiness` properties.
  prefs: []
  type: TYPE_NORMAL
- en: All easing functions inherit the `EasingMode` property from the base class.
    This property is of the enumeration type `EasingMode` and gives us three options.
    The `EaseIn` option follows the normal mathematical formula associated with each
    easing function. The `EaseOut` option uses the inverse of the mathematical formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EaseInOut` option uses the standard formula for the first half and the
    inverse formula for the second half. While not strictly true, this can be somewhat
    thought of as `EaseIn` affects the start of the animation, `EaseOut` affects the
    end of the animation, and `EaseInOut` affects both the start and the end of the
    animation. Let''s see an example of a bouncing ball animation to demonstrate this
    ability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a `Canvas` panel that contains two shapes: an ellipse and a line.
    The line is simply to give the impression of the ground. The `Ellipse` element
    defines some basic appearance properties and then an `EventTrigger` element that
    starts our eased animation when the shape object is loaded. We have an outer `Storyboard`
    element that is set to repeat forever and contains two inner storyboards.'
  prefs: []
  type: TYPE_NORMAL
- en: The first of these inner storyboards targets the `Canvas.Top` Attached Property
    using the `Storyboard.TargetProperty`, while the second targets its `Canvas.Left`
    Attached Property. Note that we do not need to specify the `Storyboard.Target` property
    value here, as the storyboard resides within the target element, which will be
    implicitly set as the target for us. Also, remember that we need to wrap the Attached
    Property name with its class name in brackets for this to work.
  prefs: []
  type: TYPE_NORMAL
- en: The first storyboard is responsible for the vertical movement of our ball and
    so this is the animation that we want to use the `BounceEase` function with. In
    order to utilize this functionality, we simply declare the `BounceEase` object
    within the `DoubleAnimation.EasingFunction` property and set the desired property
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The `Bounces` property determines how many times the ball should bounce, or
    rebound off the lower extent of the animation. Note that this does not include
    the final half-bounce that this easing function will perform. The `Bounciness`
    property specifies how bouncy the ball is. Strangely, the higher this value is,
    the less bouncy the ball will be. Also note that this value must be positive.
  prefs: []
  type: TYPE_NORMAL
- en: As physics determines that the horizontal velocity of the ball should remain
    constant for the most part, we do not need to apply an easing function to the
    second animation. Instead, we have added a small value for its `DecelerationRatio`
    property, which nicely simulates the sideways friction on the ball.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen, it is very easy to take advantage of these mathematical formulae
    to greatly increase the movement of our animations. While there is not enough
    space in this book for us to cover all of these easing functions, it is well worth
    investigating them yourselves. Let''s take a look at another example, to see how
    we can simulate the movement of a spring using the `ElasticEase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a thin `Rectangle` element that simulates the movement
    of a coiled spring using an `ElasticEase` function. The `Oscillations` property
    specifies the number of times that the rectangle will grow and shrink over the
    lifetime of the animation effect and the `Springiness` property determines the
    stiffness of the spring, where larger values equal more springiness.
  prefs: []
  type: TYPE_NORMAL
- en: While the two demonstrated easing functions are rather specialized and unsuitable
    to use in many cases, the vast majority of the remaining functions are all variations
    on standard circular, or exponential curves, or curves that use the formula *f(t)
    = t^n*, where *n* is either determined by the exact easing function used, or by
    the `Power` property of the `PowerEase` function.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `QuadraticEase` function uses the formula *f(t) = t²*, the
    `CubicEase` function uses the formula *f(t) = t³*, the `QuarticEase` function
    uses the formula *f(t) = t⁴*, the `QuinticEase` function uses the formula *f(t)
    = t⁵*, while the `PowerEase` function uses the formula *f(t) = t^n*, where *n*
    is determined by its `Power` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these variations of the standard acceleration/deceleration curve,
    there is one final useful easing function named `BackEase`. This has the effect
    of overshooting its starting or ending `From` or `To` values, dependent upon the
    value of the `EasingMode` property, and then reversing back to it. This is one
    of the more usable easing functions, so let''s see an example of a `TextBox` element
    sliding on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we start with a `Canvas` object that has its `ClipToBounds`
    property set to `true`. This ensures that elements that are outside the bounds
    of the canvas will not be visible. Inside the canvas, we have declared a `TextBox`
    control that is initially placed totally outside the bounds of the canvas and
    so it will be invisible.
  prefs: []
  type: TYPE_NORMAL
- en: When the control is loaded, the `EventTrigger` element will start the animation
    that targets the `Canvas.Left` Attached Property. Note that the duration on the
    storyboard is one second longer than the duration on the animation and so the
    storyboard will wait for one second after the animation has completed before restarting.
    This gives us time to appreciate the effect of the applied easing function.
  prefs: []
  type: TYPE_NORMAL
- en: The animation will slide the textbox to its ending position from its initial
    off-screen position. By using the `BackEase` function, the textbox will slightly
    slide past its ending position and then reverse back into it. The amount past
    its ending position that it will slide to is determined by the value of its `Amplitude`
    property, with higher values extending the overshoot distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we have only discussed using these easing functions with `From`, `By` and
    `To` animations so far, it is also possible to use them with key-frame animations
    as well. There are a number of classes that follow the `Easing<Type>KeyFrame`
    naming convention, such as the `EasingColorKeyFrame` class. These classes have
    an `EasingFunction` property that enables us to specify which function to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we animate the size of the text in a `TextBlock` element using
    a number of key-frames. This creates the kind of transition effect that we might
    see on lines of text in Microsoft PowerPoint presentations and could be suitable
    to use in an application that presents textual information to the user.
  prefs: []
  type: TYPE_NORMAL
- en: We start by targeting the `FontSize` property and specifying a total duration
    of two and a half seconds. Our first key-frame simply sets our starting font size
    at zero seconds and so we can use a `DiscreteDoubleKeyFrame` for that. The second
    key-frame is an `EasingDoubleKeyFrame` element with a `BounceEase` easing function
    and a duration, or key time, of one second.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we have another `EasingDoubleKeyFrame` element that lasts for
    one second, but this one uses an `ElasticEase` function. Finally, we finish with
    one further `EasingDoubleKeyFrame` element with a `BackEase` easing function and
    a duration of half a second. Note that we have used small values for the `Bounces`
    and `Oscillations` properties, to keep the animation more usable.
  prefs: []
  type: TYPE_NORMAL
- en: Using these easing functions with key-frames enable us to chain any number of
    them together to create more complicated animated effects. However, it is easy
    to go overboard and create effects that are too much, as can be seen by increasing
    the values set for the `Bounces` and `Oscillations` properties in this example.
    In reality, even the modest values used here could be considered to be too much
    for practical use.
  prefs: []
  type: TYPE_NORMAL
- en: Animating along a path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one further method of animating property values in WPF. Using `PathFigure`
    and `PathSegment` objects, we can construct a `PathGeometry` object and then animate
    a property value according to the `X`, `Y` and/or rotation angle values of the
    path.
  prefs: []
  type: TYPE_NORMAL
- en: As this method is primarily used for animating objects along a complex path
    and therefore not aimed at typical business applications, we will cover only the
    basics of this functionality here. As with the other kinds of animation classes,
    there are different path animation types that manipulate different CLR types.
    Path animation classes follow the naming convention `<Type>AnimationUsingPath`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `<Type>AnimationUsingPath` class has a `PathGeometry` property that we
    can use to specify a path to animate along, using an object of type `PathGeometry`.
    In order to take advantage of the ability to animate the path `X` and `Y` values
    in addition to the rotation angle, we need to use a `MatrixTransform` element.
    Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we animate a `TextBlock` element around a circular path using
    a `MatrixAnimationUsingPath` element. The circular path is defined by a single
    `ArcSegment` element within a single `PathFigure` element. We set the `PathFigure.StartPoint`
    property value to almost match the `ArcSegment.Point` value so that the two ends
    of the ellipse meet.
  prefs: []
  type: TYPE_NORMAL
- en: In order to animate the rotation of the text element from the `MatrixAnimationUsingPath`
    element, we need to set its `DoesRotateWithTangent` property to `true`. If this
    property was set to `false`, or simply omitted, then the text element would still
    be animated in a circular motion, but it would no longer rotate in line with the
    tangent of the circular path, instead remaining upright.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `MatrixAnimationUsingPath` class, we can also use either
    of the `DoubleAnimationUsingPath` or `PointAnimationUsingPath` classes to animate
    objects on a path. However, rather than providing examples for these alternative
    methods, let's now move on to find out how we can include every day animations
    in our application framework.
  prefs: []
  type: TYPE_NORMAL
- en: Creating everyday animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After covering the wide range of animations that WPF provides, we can see that
    many of them were designed to enable us to perform animations that emulate real-world
    situations, rather than to animate form fields in a standard business application.
    As such, some of the techniques discussed in this chapter are inappropriate for
    use in our application framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this does not mean that we cannot create animations to use in our
    everyday applications. As long as we remember that less is more when it comes
    to animations in business applications, we can certainly build simple animations
    into our application framework. One of the best ways to encapsulate these basic
    animations in our framework is to write one or more custom-animated panels. Let''s
    look at a simple example of an animated `StackPanel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As with all custom panels, we just need to provide the implementation for the
    `MeasureOverride` and `ArrangeOverride` methods. However, in our case, we want
    to recreate the functionality of the original `StackPanel` control and so we have
    also declared an `Orientation` Dependency Property of type `System.Windows.Controls.Orientation`,
    with a default value of `Vertical`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeasureOverride` method, we iterate through each of the panel's children,
    calling their `Measure` method, passing in the `availableSize` input parameter.
    Note that this sets their `DesiredSize` property, which will be set to a size
    of `0,0` until this point.
  prefs: []
  type: TYPE_NORMAL
- en: After calling the `Measure` method on each child, we are able to use their `DesiredSize`
    property values to calculate the total size required to properly display the rendered
    items, depending on the value of the `Orientation` property.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Orientation` property is set to `Vertical`, we use the `Math.Max` method
    to ensure that we keep account of the size of the widest element and if it is
    set to `Horizontal`, then we use it to find the height of the tallest element.
    Once each child has been measured and the overall required size of the panel has
    been calculated, we return this size value from the `MeasureOverride` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ArrangeOverride` method, we again iterate through the collection of
    children, but this time we call the `Arrange` method on each child, positioning
    each just outside the bounds of the panel, which will be the starting point of
    their animations.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Orientation` property is set to `Horizontal`, we position the children
    one child’s width to the left of the origin point and set their height to the
    height of the panel. If the `Orientation` property is set to `Vertical`, we position
    them one child’s height above the origin point and set their width to the width
    of the panel.
  prefs: []
  type: TYPE_NORMAL
- en: This has the effect of stretching each item across the height or width of the
    panel, depending upon the value of the `Orientation` property, as neatly aligned
    items with uniform dimensions look tidier and more professional than items with
    uneven edges. In this way, we can build these kinds of decisions right into our
    framework controls.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we calculate the desired end position of each child after animation with
    the `endPosition` variable and then call the `AnimatePosition` method, passing
    in the child, the end position and the duration of the animation. We end the method
    by returning the unchanged `finalSize` input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the `AnimatePosition` method, we call the `GetTranslateTransform` method
    to get the `TranslateTransform` object that we will use to move each child across
    the panel. If the `Orientation` property is set to `Vertical`, we animate the
    `TranslateTransform.YProperty` property to the value of the `endPosition.Y` property,
    otherwise we animate the `TranslateTransform.XProperty` property to the value
    of the `endPosition.X` property.
  prefs: []
  type: TYPE_NORMAL
- en: In order to animate these property values, we use the `BeginAnimation` method
    on the `UIElement` object with the property to be added. There are two overloads
    of this method, but we are using one that accepts the key of the Dependency Property
    to animate and the animation object. The other overload enables us to specify
    the `HandoffBehavior` to use with the animation.
  prefs: []
  type: TYPE_NORMAL
- en: For our animation, we are using a `DoubleAnimation`, with a constructor that
    accepts the `To` value and the duration of the animation, although there are several
    other overloads that we could have used, had we needed to specify further properties,
    such as the `From` and `FillBehavior` values.
  prefs: []
  type: TYPE_NORMAL
- en: In order to animate the movement of the items in the panel, we need to ensure
    that they have a `TranslateTransform` element applied to the `RenderTransform`
    property of the container item of each child. Remember that different `ItemsControl`
    classes will use different container items, for example, a `ListBox` control will
    use `ListBoxItem` container elements.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if an item does not already have a `TranslateTransform` element applied,
    we must add one. Once each element has a `TranslateTransform` element, we can
    use its `X` and `Y` properties to move the item.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GetTranslateTransform` method, we simply return the existing `TranslateTransform`
    element from the `RenderTransform` property of each child if one exists, or call
    the `AddTranslateTransform` method to return a new one otherwise. In the `AddTranslateTransform`
    method, we just initialize a new `TranslateTransform` element and set it to the
    `RenderTransform` property of the `child` input parameter, before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve now created a basic animated panel and with just around seventy lines
    of code. The developers that use our application framework can now animate the
    entry of items in any `ItemsControl`, or any of its derived collection controls,
    by simply specifying it in a `ItemsPanelTemplate` as the `ItemsPanel` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, our panel currently only provides one type of animation, albeit in
    two possible directions, and only works as new items are added. Animating objects'
    exit is somewhat trickier, because they are normally removed immediately from
    the panel's `Children` collection when the `Remove` method is called on the data
    bound collection.
  prefs: []
  type: TYPE_NORMAL
- en: In order to accomplish working exit animations, we'll need to implement a number
    of things. We'll need to update our data Model classes to provide them with new
    properties to identify which stage of the animation that they're currently in
    and new events to raise when the current status changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need an `IAnimatable` interface and an `Animatable` class that provides
    the implementation for each data Model. Let''s first see the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is already an `Animatable` class and an `IAnimatable` interface
    defined in the `System.Windows.Media.Animation` namespace. While it can be unwise
    to create classes and interfaces with the same names as existing ones, for the
    limited purposes of this book, we will use these names and be mindful to prevent
    conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s move on, to see the implementation of our `Animatable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This class needs little explanation, other than to note that the `OnTransitionStatusChanged`
    and `OnRemovalStatusChanged` events get raised when the values of the `TransitionStatus`
    and `RemovalStatus` properties are changed respectively and that the class passes
    itself in as the `sender` input parameter in each case. Let''s see the three new
    enumeration classes that are used in our `Animatable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to implement this interface in each data Model class that we want
    to animate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing that we need to do is to stop the `Remove` method from actually
    removing each item when called. We''ll need to update our `BaseCollection<T>`
    class, or add a new `BaseAnimatableCollection<T>` class, so that it triggers the
    animation instead of removing the item directly. Here is a cut down example showing
    one way that we might do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that this is a basic example that could be improved in many ways,
    such as adding checks for `null`, enabling addition, removal and insertion capabilities
    that do not trigger animations and adding other useful properties.
  prefs: []
  type: TYPE_NORMAL
- en: In this class, we start by specifying that the generic `T` type parameter must
    implement the `IAnimatable` interface. As with our other base collection classes,
    we ensure that all added and inserted items call a new `Add` method that attaches
    our animation related handlers. We show an example of this in the constructor,
    but skip the other constructor declarations to save space.
  prefs: []
  type: TYPE_NORMAL
- en: We then declare an `IsAnimatable` property that we can use to make this collection
    work without animation. This property is used in the overridden (or `new`) `Count`
    property, to ensure that items that are due to be removed are not included in
    the count of the collection's children.
  prefs: []
  type: TYPE_NORMAL
- en: In the new `Add` method, we attach a reference of our `Item_OnRemovalStatusChanged`
    handler to the `OnRemovalStatusChanged` event of the `Animatable` object of the
    item being added. We then set the `AdditionStatus` property of the `Animatable`
    object to the `ReadyToAnimate` member to signal that the object is ready to begin
    its entrance animation.
  prefs: []
  type: TYPE_NORMAL
- en: As this base collection is extending another base class, we need to remember
    to call its `Add` method, passing in the item, so that it can attach its own handler
    for the item's `PropertyChanged` event. The other `Add` overloads enable multiple
    items to be added to the collection, but both internally call the first `Add`
    method. The `Insert` method does the same as the first `Add` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `ClearItems` method iterates through each item in the collection, detaching
    the reference to the `Item_OnRemovalStatusChanged` handler from each before calling
    the `ClearItems` method of the base class. As it is, this method could be reserved
    for removing all items from the collection without animation, but it would be
    easy to call the `Remove` method with each item to include animations.
  prefs: []
  type: TYPE_NORMAL
- en: The `Remove` method in this class enables us to animate the exit of each item;
    it doesn't actually remove the item from the collection, but instead sets the
    `RemovalStatus` property of the item's `Animatable` object to the `ReadyToAnimate`
    member to signal that the object is ready to begin its exit animation. It then
    returns true from the method to signify successful removal of the item.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get to the `Item_OnRemovalStatusChanged` event handler, which is
    the next major part in enabling exit animations. In it, we cast the `sender` input
    parameter to an instance of our `Animatable` class. Remember that it passes itself
    as the `sender` parameter when raising the event.
  prefs: []
  type: TYPE_NORMAL
- en: We then check whether the `RemovalStatus` property of the `Animatable` instance
    is set to the `ReadyToRemove` member, or both its `RemovalStatus` property is
    set to `ReadyToAnimate` and the collection is not animatable. If either condition
    is true, we finally call the `Remove` method of the base class to actually remove
    the item from the collection and set the `RemovalStatus` property to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, when the collection is set to be not animatable and the `Remove`
    method is called, the item is immediately removed and the `Animatable` object's
    `RemovalStatus` property is set to the `None` member in the `Item_OnRemovalStatusChanged`
    handler. If you remember, the `OnRemovalStatusChanged` event gets raised when
    the `RemovalStatus` property value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we''re still missing part of this puzzle. *What sets the* `Animatable`
    *object''s* `RemovalStatus` *property to the* `ReadyToRemove` *member to remove
    each item?* We will need to update our animated panel to accomplish this task,
    and to do this, it will need to maintain a collection of the elements that need
    to be removed and signal the collection to remove them once their exit animations
    complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `Storyboard.Completed` event to notify us when the animation
    is complete and then signal to remove the item at that point, by setting the `Animatable`
    object''s `RemovalStatus` property to the `ReadyToRemove` member. Let''s take
    a look at the required changes to our animated panel. First, we need to add the
    following using declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to replace the call to the `AnimatePosition` method from the
    original `ArrangeOverride` method with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to add the following additional methods after the `ArrangeOverride`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's examine this new code. First, we have the `BeginAnimations` method, in
    which we cast the container control to a `FrameworkElement`, so that we can access
    its `DataContext` property. Our data object is accessed from this property and
    we cast it to an `IAnimatable` instance, so that we can access the `Animatable`
    object via its `Animatable` property.
  prefs: []
  type: TYPE_NORMAL
- en: We then remove our `Item_OnRemovalStatusChanged` event handler from the `OnRemovalStatusChanged`
    event before re-attaching it, to ensure that only a single handler is attached,
    regardless of how many times each child passes through this method.
  prefs: []
  type: TYPE_NORMAL
- en: If the `AdditionStatus` property is set to `DoNotAnimate`, we arrange the item
    at its end position immediately and without animation, while if it is set to `ReadyToAnimate`,
    we call the `AnimateEntry` method and then set the `AdditionStatus` property to
    `Added`. Finally, if the `RemovalStatus` property is set to `ReadyToAnimate`,
    we call the `AnimateExit` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Item_OnRemovalStatusChanged` event handler, we call the panel's `InvalidateArrange`
    method if the `RemovalStatus` property is set to `ReadyToAnimate`. This is another
    essential part of the exit animation strategy and it requests the layout system
    to call the `ArrangeOverride` method, thereby triggering the starting of the exit
    animation(s).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the `OnRemovalStatusChanged` event gets raised when the value
    of the `RemovalStatus` property is changed. Also recall that the `RemovalStatus` property
    is set to the `ReadyToAnimate` member in the `Remove` method of the `BaseAnimatableCollection<T>`
    class. That raises the event and this event handler starts the animations in response.
  prefs: []
  type: TYPE_NORMAL
- en: The `AnimateEntry` method simply calls the original, unchanged `AnimatePosition`
    method from our first animated panel attempt. The `AnimateExit` method takes an
    additional `startPosition` input parameter, which represents the current position
    of each item within the panel.
  prefs: []
  type: TYPE_NORMAL
- en: We start by setting the `Panel.SetZIndex` Attached Property to a value of `100`
    for each child, to ensure that their animated departure is rendered above, or
    over the top of, the remaining items. We then calculate the end position of the
    animation using the start position and the size of the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call an overload of the `AnimatePosition` method, passing in our child,
    start and end positions, animation duration and an event handler as parameters.
    After the child item's position animation has been started, the child is added
    to the `elementsToBeRemoved` collection.
  prefs: []
  type: TYPE_NORMAL
- en: In the `AnimatePosition` method, we first check that our start and end positions
    are different, before creating and starting our `DoubleAnimation` objects. If
    the `X` values are different and the event handler input parameter is not `null`,
    then we attach it to the `Completed` event of the `xAnimation` object before starting
    its animation.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Y` values are different and the event handler input parameter is not
    `null` and the event handler was not already attached to the `xAnimation` object,
    then we attach it to the `Completed` event of the `yAnimation` object before starting
    its animation. Note that we only need to attach one handler to this event, because
    we only have one object to remove from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we set the `AccelerationRatio` property to `1.0` in this overload,
    so that the item accelerates off screen. However, in a business application framework,
    we would want to keep our animation properties in sync and so, we would probably
    set the `AccelerationRatio` property to `1.0` on the animation objects in the
    original `AnimatePosition` method as well.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece of the puzzle is the `RemovalAnimation_Completed` event handling
    method. This method gets called when the exit animation has completed and iterates
    through the `elementsToBeRemoved` collection. If any element to remove implements
    the `IAnimatable` interface, its `Animatable` object's `RemovalStatus` property
    is set to the `ReadyToRemove` member.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, this raises the `OnRemovalStatusChanged` event, which is handled
    by the `Item_OnRemovalStatusChanged` event handler in the `BaseAnimatableCollection`
    class. In that method, the `Animatable` object's `RemovalStatus` property is checked
    for the `ReadyToRemove` member and if found, the owning item is actually removed
    from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: And so, to summarize; the `Remove` method of the animation collection is called,
    but instead of removing the item, it sets a property on it, which raises an event
    that is handled by the animated panel; the panel then starts the exit animation
    and when completed, it raises an event that is handled by the collection class
    and results in the item actually being removed from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: While this animated panel is entirely usable as it is, there are many ways that
    it could be further improved. One important thing that we could do would be to
    extract all of the properties and animation code from this class and put them
    into a base `AnimatedPanel` class. In this way, we could reuse this class when
    creating other types of animated panel, such as an `AnimatedWrapPanel`.
  prefs: []
  type: TYPE_NORMAL
- en: We could then further extend the base class by exposing additional animation
    properties, so that users of our panel could have more control over the animations
    that it provides. For example, we could declare `VerticalContentAlignment` and
    `HorizontalContentAlignment` properties to dictate how our panel items should
    be aligned in the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we could add `EntryAnimationDirection` and `ExitAnimationDirection`
    properties to specify which direction to animate our panel items as they are added
    and removed from the panel. We could also enable different types of animation,
    such as fading or spinning, by animating the `Opacity` property, or the `Angle`
    property of a `RotationTransform` element.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we could add `EntryAnimationDuration` and `ExitAnimationDuration`
    properties to specify the length of time that each animation should take, rather
    than hardcoding values directly into our panel. There really is no limit to what
    functionality that we can provide with our application framework panels, other
    than the limitations dictated by the end users' computer hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've investigated the variety of animation possibilities that
    WPF provides us with, primarily focusing on XAML and the more usable options.
    We've discovered the finer details of timelines and also explored how we can incorporate
    animation into our application framework, so that its users can easily leverage
    the power of animations without having to know anything about them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at a number of ways that we can improve the
    overall look and feel of our applications, from providing consistent application
    styles and icons to examining a number of techniques for creating rich graphics.
  prefs: []
  type: TYPE_NORMAL
