- en: Validating Application Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on real-world projects, there may be scenarios where different
    kinds of users access your application and enter information in to it. In the
    event that any aspect of the scenario was not handled properly, or any input data
    was not properly parsed, this can cause your application to crash or result in
    the corruption of your application data. Even though you validate all the input
    data used and accessed within your application when deployed in production, input
    data can interact with other external applications, which can place your application
    in jeopardy.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is to understand the importance of validating input
    data in your application. Different validation techniques are available in the
    .NET Framework to validate JSON data and XML data.
  prefs: []
  type: TYPE_NORMAL
- en: In upcoming sections, we will focus on why it is important to validate input
    data, how we can manage data integrity, how to use framework-provided parsing
    statements and regular expressions, and how to validate JSON and XML data. After
    reading this chapter, you will be able to create application logic to validate
    incoming data and also handle scenarios where exceptions might occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of validating input data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing and converting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON and XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercises in this chapter can be implemented using Visual Studio 2012 or above
    with .NET Framework 2.0 or above. However, any new C# features from C# 7.0 and
    above require you to have Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a license for any of the products, you can download the community
    version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter
    11](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter%2011).
  prefs: []
  type: TYPE_NORMAL
- en: The importance of validating input data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and running an application in isolation mode makes your application
    run without any issues. However, when working on a real project, your application
    will be executing in an environment where many external interfaces may interact.
    In such scenarios, is your application capable of handling such communications?
    Can it handle all kinds of data from these external applications? There will be
    many users who will try to use your system; some may use it properly, and others
    may try to break your system. Can your application tolerate such interactions?
  prefs: []
  type: TYPE_NORMAL
- en: There may be problems with both types of user. Those who use your system properly
    may make mistakes by entering incorrect data or may forget to provide the requisite
    data. In the event your application has logic based on the user's date of birth
    and the user enters some text data, your application might throw an exception
    and crash.
  prefs: []
  type: TYPE_NORMAL
- en: In a scenario where users try to break your application by providing data that
    doesn't match any of the types that your application expects, this may crash your
    application and a significant amount of time may be devoted to recovering it.
  prefs: []
  type: TYPE_NORMAL
- en: Any of these aforementioned actions can cause temporary damage to your application
    or may constitute a major issue. When it corrupts your database, recovering your
    application may entail more time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application using .NET Framework involves the provision of some
    built-in features that can be utilized to validate some of the input data, be
    it from internal or external users or external applications. Framework allows
    you to add attributes over each property that can validate data for you. These
    are available when you use ASP.NET or the Entity Framework, and so on. As you
    learned in previous chapters, you can define custom attributes and perform validation
    on the data entered by users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see a variety of data integrity scenarios that
    are important to understand while working on data validations in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Data integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on any application, it is very important to design it in such
    a way that it handles all scenarios, or at least provides user-friendly messages
    to users on what went wrong. We have already learned about exception handling
    in [Chapter 7](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml), *Implementing Exception
    Handling*, which can be handy in such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: While working on a database or distributed applications, data integrity plays
    a vital role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data integrity applies differently in different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you are creating an application and storing user information
    in a table, one of the principles you may adopt might be to not maintain duplicate
    users in the table so that they are uniquely identifiable. This is termed **entity
    integrity**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a scenario where you are collecting demographic information, you may allow
    certain values, or ranges of values, in specific fields. This is termed **domain
    integrity**. In other words, you are making sure that the data entered in each
    record/entity is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be a scenario where you have to enter data into multiple tables with
    a parent-child relationship. In such cases, your application should maintain these
    relationships while saving information to the database. This is called **referential
    integrity**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, in a business scenario, in order to achieve the desired
    outcome based on a business process, your application may enforce certain constraints.
    This is called **user-defined** integrity, or **business-defined** integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many real-world examples. These include any eCommerce applications
    or any banking applications. How critical is it to validate and control input
    and program flow? In a banking application, what would happen in the event of
    a power outage? In an eCommerce application, how would a shopping cart be maintained
    between multiple sessions, when the user closes their browser, or in the event
    that a clean-up job kicks in?
  prefs: []
  type: TYPE_NORMAL
- en: Many of these data integrity options are available in the latest databases and
    frameworks, which enable us to utilize these options to validate and control the
    flow of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the ways to validate data is to use the data annotations assembly, which
    is available in .NET Framework 3.5 and above. Data annotations talk about adding
    more information about an attribute or property in a class. You can use data annotations
    by referring to the `System.ComponentModel.DataAnnotations` namespace. These data
    annotations fall into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Validation attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these attributes is used for a specific purpose: validation attributes
    enforce the validation of data; display attributes are used as display labels
    on the user interface, and modeling attributes represent the recommended use of
    the relevant attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following class, we will reference `System.ComponentModel.DataAnnotations`
    and use validating attributes, display attributes, and modeling attributes on
    the three available properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the name property, we have a required field attribute and string length restrictions
    as validation attributes. The data type set to text is a data modeling attribute
    that tells the system that the name attribute only accepts text values. On the
    `DOB` property, we have a display attribute. However, display properties can be
    used in either ASP.NET applications or WPF applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create an instance of the `Student` class and try to validate its data.
    Data annotations help us to define `ValidationContext`; when an object is validated,
    `ValidationResult` will be returned, which consists of all properties and their
    respective error messages. While defining properties in the `Student` class, we
    added attributes with messages. When `ValidationContext` returns results, it returns
    each of these properties with their respective attributes and messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a `ValidationContext` instance, we use the constructor that
    takes three parameters. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of an object that we want to validate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object that implements the `IServiceProvider` interface, which means that
    you need to create an instance using the `GetService` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary of a key/value pair to consume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, while trying to validate an object, we passed `true` as the last parameter,
    which represents the validation of all properties of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the program, you should see the following output. The student''s
    name should have a minimum of five characters and the email address should be
    in a valid format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at the different features available in C#
    to validate our data.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing and converting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entity integrity and domain integrity involve allowing valid values into our
    application for further processing. Valid values include manipulating or managing
    input provided by a user, rendering it as data that is acceptable to the application.
    This process may including parsing specific types of data to the type our application
    accepts, converting data types, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`Parse` and `TryParse` are two statements available across multiple data types
    within the .NET Framework, for example if you are writing a console application
    and you want to accept parameters as command-line arguments. In a console application,
    command-line parameters are always of the string type. So, how do you parse these
    arguments from the string type to another required type?'
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we know that our first parameter is a Boolean value,
    but is passed as a string. When we are certain of the value passed, we can use
    the parse method to convert the string to a Boolean. `Parse` compares to with
    static string values and returns either `true` or `false`. When invalid data is
    passed, an exception is thrown—`Input string is in an invalid format`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example. Define two methods that each take a parameter
    of the string type. We want to parse it into Boolean and integer values. Parsing
    a Boolean is as simple as using the parse method of a Boolean type. However, for
    the integer type, there are two approaches. One is to use parse, as we did when
    parsing a Boolean, and the other is `TryParse`. When we are not sure if the string
    parameter provided is an integer or not, then we can use the `TryParse` method,
    which will then give us a `bool` result on which we can set up our logic. In the
    following example, we are showing both ways. This will allow us to handle exceptions
    and provide the user with a meaningful message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our sample class is ready, let''s invoke it using our `main` method.
    Here, we have a `switch` statement to check the length of the arguments passed
    to the `main` method. If it is `1`, call the `processbool` method; if it is `2`,
    call both methods, otherwise, a message is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke this method, because we are trying to read command-line arguments
    in our program, these need to be passed at runtime or from the Properties window,
    which will then be read at runtime. Parameters are passed from the Properties
    window as follows. Right-click on Project, select Properties, and then navigate
    to the Debug tab, where you can set these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ac4b314-42ab-4fc9-9202-4a269dc90c2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you run the program, as you pass `1` or `2` arguments, the respective
    case statements get executed and the output will be presented on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the last output, `TryParse` statements are processed, but `Parse`
    will throw an error as follows. Because `Parse` expects a proper string to be
    passed, when a non-string value is passed, or when your statement doesn''t correspond
    to the value passed, it throws an error. However, if we handle this statement
    using `try..catch`, we won''t see any issues. Otherwise, your program will break
    and an exception dialog will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/999810a0-4c08-41ad-b311-f3e7a2a5b81f.png)'
  prefs: []
  type: TYPE_IMG
- en: Another way to validate your input is to use the conversion method. `Convert`
    is a method defined in .NET Framework that casts a base type to another base type.
    Unlike `Parse`, `Convert` accepts an object of a type and converts it into another
    type. `Parse` accepts only string input. Also, when a `null` value is passed,
    `Convert` returns the minimum value of the target type. The `Convert` class has
    a few static methods that support conversion to and from different types in .NET
    Framework. Types supported by the `Convert` method are `Boolean`, `Char`, `SByte`,
    `Byte`, `Int16`, `Int32`, `Int64`, `UInt16`, `UInt32`, `UInt64`, `Single`, `Double`,
    `Decimal`, `DateTime`, and `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you apply the `Convert` method, you can expect any of the following output.
    The system either successfully converts the source type to the target type or
    throws one of the following exceptions: `FormatException`, `InvalidCastException`,
    or `ArgumentNull`. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we tried to convert different types. The important
    thing to note is that you can get any output while converting, and so you have
    to handle it accordingly in your application code. Also, while converting decimal
    or float values to integers, precise information is lost. However, no exception
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: With same-type conversions, there won't be any exceptions or conversions. `FormatException`
    is thrown when you try to convert a string to any other type. `String` to `Boolean`,
    `String` to `Char`, or `String` to `DateTime` may throw this exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`InvalidCastException` occurs when a conversion between specific types is not
    valid, as in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Conversions from `Char` to `Boolean`, `Single`, `Double`, `Decimal`, or `DateTime`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversions from `Boolean`, `Single`, `Double`, `Decimal`, or `DateTime` to
    `Char`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversions from `DateTime` to any other type except `String`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversions from any other type, except `String`, to `DateTime`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OverflowException` is thrown in the event of loss of data, for example, when
    converting a huge decimal to an integer, as shown in our example. In our example,
    we are converting a double value to an `int` value. The `int` type variable in
    C# has a minimum and maximum value. If the number passed is outside this range,
    an overflow exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about validating input data, it is important to have an understanding
    of regular expressions, which is a powerful way to process text. It employs a
    pattern-matching technique to identify a pattern of text in input texts and validates
    it to the required format. For example, if our application wants to validate an
    email, regular expressions can be used to identify whether the email address provided
    is in a valid format. it checks for `.com`, `@`, and other patterns and returns
    if it matches a required pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Text.RegularExpressions.Regex` acts as a regular expression engine
    in .NET Framework. To use this engine, we need to pass two parameters, the first
    a pattern to match and the second text where this pattern matching happens.'
  prefs: []
  type: TYPE_NORMAL
- en: The regex class comes up with four different methods – `IsMatch`, `Match`, `Matches`,
    and `Replace`. The `IsMatch` method is used to identify a pattern in the input
    text. The `Match` or `Matches` methods are used to get all occurrences of text
    that match a pattern. The `Replace` method replaces text that matches a regular
    expression pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s jump into some examples to understand regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `ReplacePatternTest` method identifies `FirstName` and `LastName` from an
    array of strings and replaces them with an empty string. In the `MatchPatternText`
    method, we identify how many times `Madhav` exists in the string; in the third
    method, we use a pattern to identify a chapter word. The `^c\w+` pattern represents
    the beginning of the word, `c` represents a word starting with *c*, `\w` represents
    any characters, and `+` represents matches with the preceding token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the first two lines of the output from the `ReplacePatternTest`
    method, where we replaced `Madhav` with an empty string. The second output set
    identifies a pattern and displays it. The third set is where we identify a chapter
    word in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: JSON and XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the extensive use of internet and cloud applications, JSON and XML are
    becoming more important in terms of data transfer between applications. Using
    JSON and XML also increases the number of data-related issues, unless the data
    is validated.
  prefs: []
  type: TYPE_NORMAL
- en: Schema validation can be used to validate an XML file, which will help us to
    identify whether XML is inline with data types defined. However, to validate the
    actual data, you may still be using the methods we discussed in this chapter.
    Visual Studio helps you to create a schema file. The `Xsd.exe <XML file>` command
    will create a schema file. Here is an example XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This XML file has a `Students` root element, in which information is held in
    relation to multiple students. Each `student` element has child elements that
    hold values including `FirstName`, `LastName`, `School`, and `DOB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Visual Studio allows us to create a schema for this XML. Open the XML file
    in Visual Studio and select the XML menu item. The Create Schema option will become
    available. Selecting this will create a `.xsd` schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e289b05-02e1-4ff8-a351-ca8b86cc67aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The content of the `Sample.xsd` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, names are defined as a string, as are dates. So when you access
    this date element, we may need to convert it in order to use it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will jump to some sample code and observe how to validate an XML file
    using a schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we passed a valid XML file, we did not encounter any issues validating it.
    However, when you try to remove any elements from it, such as removing the school
    from the XML file, then you encounter an error message. Try it yourself when you
    practice this lab so as to understand validation in greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When executed, this method either writes a message on the console to the effect
    that validation is complete, or it may throw an exception in the event of an error
    in the XML.
  prefs: []
  type: TYPE_NORMAL
- en: Another format we discussed is JSON. .NET Framework provides us with JSON serializers,
    which can be used to validate JSON. This is like creating a C# class, using a
    JSON serializer to convert a C# object to JSON, and then deserializing back to
    the C# object. It is similar to the .NET Framework serialization concept. However,
    not every JSON has a schema to serialize or deserialize. In this case, we will
    work on validating the JSON format. In the following example, we create a class
    serializer to convert a JSON object and then deserialize it back to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are creating a class called `Authors` with three properties: `AuthorName`,
    `Skills`, and `DOB`. We will use this object to serialize and deserialize this
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section, we created a new method where we used the `Newtonsoft.Json`
    namespace to convert the `Authors` object to JSON. You can get `NewtonSoft.Json`
    using NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will convert JSON to the `Authors` object using the `JSON.Deserialize`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Following is the program that invokes both these methods. Initially, we invoke
    the `GetJSON` method to get the `Json` string, and then use this string to convert
    it to an `Authors` object using the `GetObject` method. In the second line, we
    modify the string result that we got in the first line, and try to deserialize
    it. This operation will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, we are trying to modify the `.json` results by concatenating
    text called `Test`. This is what happens when you modify the `.json` object and
    try to deserialize it to an `Authors` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows the `JSON` object that we converted from the `Authors`
    object, followed by the `Author` object that we deserialized from the `JSON` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the exception that the program throws when we modify `JSON` and try
    to deserialize it to an `Authors` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6e9c06d-4dc9-48a4-b810-3e0b0db40c46.png)'
  prefs: []
  type: TYPE_IMG
- en: This is an example where we try to validate a `JSON` object. If it gets modified
    during transmission, this can be identified during the deserialization process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the importance of validating input data; different
    ways of validating input data in our application, including the `Parse` and `Convert`
    methods; and how we can use regular expressions and the data annotations namespace.
    We also looked briefly at how we can validate XML and JSON input.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore ways to secure our data, such as emails,
    passwords, and API keys, using encryption techniques available in .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Parse` method always takes the __ type as input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any valid .NET type
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When converting `DateTime` to `Double`, which exception is thrown?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No exception is thrown; instead, it gets converted successfully.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A Format exception is thrown.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An Overflow exception is thrown.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An Invalid cast exception is thrown.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Information about members of an object can be provided using the ___________
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DataContract`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DataAnnotations`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`System.Reflection`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`System.XML`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**An** **Invalid cast exception is thrown**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DataAnnotations`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
