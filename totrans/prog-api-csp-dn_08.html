<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-105">
    <a id="_idTextAnchor105">
    </a>
    
     8
    
   </h1>
   <h1 id="_idParaDest-106">
    <a id="_idTextAnchor106">
    </a>
    
     Advanced Topics
    
   </h1>
   <p>
    
     In this chapter, we will examine a few advanced topics not covered elsewhere in the book.
    
    
     This includes Implementing an Advanced API using a more complex data structure, Storage Tables, and the very exciting new (at the time of this writing)
    
    
     
      Aspire feature.
     
    
   </p>
   <p>
    
     In this chapter, we will cover the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Implementing an
     
     
      
       advanced API
      
     
    </li>
    <li>
     
      Updating
     
     
      
       the database
      
     
    </li>
    <li>
     
      
       Supporting implementation
      
     
    </li>
    <li>
     
      Creating Azure
     
     
      
       Storage Tables
      
     
    </li>
    <li>
     
      
       Aspire dashboard
      
     
    </li>
    <li>
     
      Adding Aspire to
     
     
      
       existing projects
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-107">
    <a id="_idTextAnchor107">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     For this chapter, you’ll need
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      
       Visual Studio.
      
     
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       Azure.Data.Tables
      
     </strong>
     
      
       NuGet package.
      
     
    </li>
    <li>
     
      An Azure account (you can get a free starter account
     
     
      
       at
      
     
     <a href="https://azure.microsoft.com/en-us/">
      
       
        https://azure.microsoft.com/en-us/
       
      
     </a>
     
      
       ).
      
     
     <p class="list-inset">
      
       Aspire comes with Visual Studio 2022 (version 17.10 or higher) and requires .
      
      
       
        NET 8.
       
      
     </p>
    </li>
    <li>
     
      You will need to install Docker Desktop (which is free and can be obtained
     
     
      
       at
      
     
     <a href="https://www.docker.com/Products/docker-desktop/">
      
       
        https://www.docker.com/Products/docker-desktop/
       
      
     </a>
     
      
       ).
      
     
    </li>
   </ul>
   <p>
    
     The code files for this chapter can be found in the GitHub repository
    
    
     
      here:
     
    
    <a href="https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter08">
     
      
       https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter08
      
     
    </a>
   </p>
   <h1 id="_idParaDest-108">
    <a id="_idTextAnchor108">
    </a>
    
     Implementing an advanced API
    
   </h1>
   <p>
    
     Until now, we’ve been working with a very simple database, and implementing pretty straightforward APIs.
    
    
     From time to time, however, your client will ask for something more difficult
    
    <a id="_idIndexMarker216">
    </a>
    
     or complex.
    
    
     Let’s take a look at one
    
    
     
      such requirement.
     
    
   </p>
   <p>
    
     The client has asked for the ability to see a car with all its options.
    
    
     We’ll provide that in JSON for easy display on the web, phone, and so on.
    
    
     The JSON will look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
{
    "id": 2,
    "name": "buick skylark 320",
    "mpg": null,
    "cylinders": null,
    "displacement": null,
    "horsepower": null,
    "weight": null,
    "acceleration": null,
    "modelYear": null,
    "origin": null,
    "is_Deleted": null,
    "options": [
        {
            "optionId": 1,
            "optionName": "Winter Package",
            "optionPrice": 3700
        },
        {
            "optionId": 2,
            "optionName": "Mats",
            "optionPrice": 250
        },
        {
            "optionId": 3,
            "optionName": "Summer Package",
            "optionPrice": 2250
        }
    ]
}</pre>
   <p>
    
     To implement
    
    <a id="_idIndexMarker217">
    </a>
    
     this, we’ll need to add a table to the
    
    
     
      database:
     
    
    
     <strong class="source-inline">
      
       Options
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor109">
    </a>
    
     Updating the database
    
   </h2>
   <p>
    
     We need
    
    <a id="_idIndexMarker218">
    </a>
    
     to track various features (options) the user may select, such as a sunroof, the winter package, and so on.
    
    
     To do this, we will create a new table,
    
    <strong class="source-inline">
     
      Options
     
    </strong>
    
     , which will have
    
    
     
      four columns:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       car_id
      
     </strong>
     
      : The ID of the car to which this option will
     
     
      
       be added
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       option_id
      
     </strong>
     
      : The ID of
     
     
      
       the option
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       option_name
      
     </strong>
     
      : The name of
     
     
      
       the feature
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       option_price
      
     </strong>
     
      : The MSRP for
     
     
      
       this feature
      
     
    </li>
   </ul>
   <p>
    
     Here is a sample of the
    
    
     <strong class="source-inline">
      
       Options
      
     </strong>
    
    
     
      table:
     
    
   </p>
   <div><div><img alt="Figure 8.1 – Sample rows from the Options table" src="img/B21998_08_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.1 – Sample rows from the Options table
    
   </p>
   <p>
    
     You’ll want to create at least 10 rows using arbitrary values.
    
    
     Note that there is no table with the
    
    <a id="_idIndexMarker219">
    </a>
    
     option names and values.
    
    
     This is a simple mostly non-relational database, though you are free to add
    
    
     
      such tables.
     
    
   </p>
   <p>
    
     With this table, we can create our one relationship; that is between the
    
    <strong class="source-inline">
     
      car
     
    </strong>
    
     table and the
    
    <strong class="source-inline">
     
      Options
     
    </strong>
    
     table.
    
    
     Add
    
    <strong class="source-inline">
     
      car_id
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      car
     
    </strong>
    
     table, and create our
    
    <strong class="source-inline">
     
      Select
     
    </strong>
    
     statement with a join to the
    
    
     
      options table:
     
    
   </p>
   <pre class="source-code">
select top(10) * from car c join options o on o.car_id = c.id</pre>
   <p>
    
     The result looks like the
    
    <strong class="source-inline">
     
      car
     
    </strong>
    
     table, but has the options for each car appended to the end, as shown in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .2
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 8.2 – Joined tables" src="img/B21998_08_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.2 – Joined tables
    
   </p>
   <p>
    
     Note that
    
    <a id="_idIndexMarker220">
    </a>
    
     your table will look a bit different as I’ve cut out the middle to make it fit
    
    
     
      the page.
     
    
   </p>
   <p>
    
     You can see that the option values are appended to the
    
    <strong class="source-inline">
     
      car
     
    </strong>
    
     rows.
    
    
     This is just what
    
    
     
      we need.
     
    
   </p>
   <p>
    
     For most applications, this would be sufficient, however, our client has asked for the JSON structure shown in the code under the
    
    <em class="italic">
     
      Implementing an advanced
     
    </em>
    
     <em class="italic">
      
       API
      
     </em>
    
    
     
      heading.
     
    
   </p>
   <p>
    
     This will be a
    
    
     
      bit tricky.
     
    
   </p>
   <h2 id="_idParaDest-110">
    <a id="_idTextAnchor110">
    </a>
    
     Creating the classes
    
   </h2>
   <p>
    
     We need a class to represent the entire row, with the car and the options together.
    
    
     Each instance
    
    <a id="_idIndexMarker221">
    </a>
    
     of the class will represent one full row in the table, as shown in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     .
    
    
     Let’s call that
    
    
     
      class
     
    
    
     <strong class="source-inline">
      
       carFlat
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
  public class CarFlat : Car
  {
      public int? car_id { get; set; }
      public int? option_id { get; set; }
      public string? option_name { get; set; }
      public float option_price { get; set; }
  }</pre>
   <p>
    
     Notice that
    
    <strong class="source-inline">
     
      CarFlat
     
    </strong>
    
     inherits from
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     , picking up all the properties of
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     and adding the properties of
    
    <strong class="source-inline">
     
      Options
     
    </strong>
    
     (along
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       car_id
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In my programming, I typically use Pascal case (initial cap)
    
    
     
      for properties.
     
    
   </p>
   <p>
    
     Now, we need
    
    <a id="_idIndexMarker222">
    </a>
    
     a class to represent the row without the options (representing the car) but each car will have a collection of options.
    
    
     Let’s call
    
    <a id="_idIndexMarker223">
    </a>
    
     that class
    
    <strong class="source-inline">
     
      carDto
     
    </strong>
    
     as it will be our
    
    <strong class="bold">
     
      data transfer object
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DTO
     
    </strong>
    
     ) for
    
    
     
      the car.
     
    
   </p>
   <p>
    
     We will be passing options around, so let’s create an
    
    <strong class="source-inline">
     
      OptionsDto
     
    </strong>
    
     class
    
    
     
      as well.
     
    
   </p>
   <p>
    
     Here’s what they
    
    
     
      look like:
     
    
   </p>
   <pre class="source-code">
    public class CarDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Mpg { get; set; }
        public string Cylinders { get; set; }
        public string Displacement { get; set; }
        public string Horsepower { get; set; }
        public string Weight { get; set; }
        public string Acceleration { get; set; }
        public string ModelYear { get; set; }
        public string Origin { get; set; }
        public string Is_Deleted { get; set; }
        public List&lt;OptionsDto&gt; Options { get; set; }
    }</pre>
   <p>
    
     The important thing to note here is that
    
    <strong class="source-inline">
     
      CarDto
     
    </strong>
    
     has a property that is the list of all this car’s options; notice that the final property is a list of
    
    <strong class="source-inline">
     
      OptionsDtos
     
    </strong>
    
     .
    
    
     Let’s look at that
    
    
     
      class now:
     
    
   </p>
   <p>
    
     Here
    
    
     
      is
     
    
    
     <strong class="source-inline">
      
       OptionsDto
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
    public class OptionsDto
    {
        public int OptionId { get; set; }
        public string OptionName { get; set; }
        public float OptionPrice { get; set; }
    }</pre>
   <p>
    
     Notice the
    
    <a id="_idIndexMarker224">
    </a>
    
     capitalization and absence of underscores in
    
    
     
      the DTO.
     
    
   </p>
   <p>
    
     We need a way to link the DTO to the
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     object.
    
    
     That is what profiles
    
    
     
      are for.
     
    
   </p>
   <h3>
    
     The profile
    
   </h3>
   <p>
    
     We’ll need a profile to map the various classes to one another.
    
    
     The DTO is used to transfer
    
    <a id="_idIndexMarker225">
    </a>
    
     the object (hence the name) but it must be mapped to the original object.
    
    
     Thus, we want to map
    
    <strong class="source-inline">
     
      Car.Dto
     
    </strong>
    
     to the
    
    
     <strong class="source-inline">
      
       Car
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <p>
    
     This is the trickiest part, and mapping is what makes this
    
    
     
      all work.
     
    
   </p>
   <p>
    
     The first map is pretty straightforward, mapping the
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     
      to
     
    
    
     <strong class="source-inline">
      
       CarDto
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
CreateMap&lt;CarDto, Car&gt;()
    .ForMember(car =&gt; car.id, opt =&gt; opt.MapFrom(carDto =&gt; carDto.Id))
    .ForMember(car =&gt; car.name, opt =&gt; opt.MapFrom(carDto =&gt; carDto.
    Name))
    .ForMember(car =&gt; car.mpg, opt =&gt; opt.MapFrom(carDto =&gt; carDto.
    Mpg))
    .ForMember(car =&gt; car.cylinders, opt =&gt; opt.MapFrom(carDto =&gt; 
    carDto.Cylinders))
    .ForMember(car =&gt; car.displacement, opt =&gt; opt.MapFrom(carDto =&gt; 
    carDto.Displacement))
    .ForMember(car =&gt; car.horsepower, opt =&gt; opt.MapFrom(carDto =&gt; 
    carDto.Horsepower))
    .ForMember(car =&gt; car.weight, opt =&gt; opt.MapFrom(carDto =&gt; carDto.
    Weight))
    .ForMember(car =&gt; car.acceleration, opt =&gt; opt.MapFrom(carDto =&gt; 
    carDto.Acceleration))
    .ForMember(car =&gt; car.model_year, opt =&gt; opt.MapFrom(carDto =&gt; 
    carDto.ModelYear))
    .ForMember(car =&gt; car.origin, opt =&gt; opt.MapFrom(carDto =&gt; carDto.
    Origin))
    .ReverseMap();</pre>
   <p>
    
     We start by identifying the types in the map, and then for each member, we map using Lambda
    
    <a id="_idIndexMarker226">
    </a>
    
     expressions.
    
    
     Note the last line,
    
    <strong class="source-inline">
     
      .ReerseMap
     
    </strong>
    
     – this saves us the trouble of re-writing the entire map going the
    
    
     
      other way.
     
    
   </p>
   <p>
    
     Next comes the heart of the program, mapping
    
    <strong class="source-inline">
     
      CarFlat
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      CarDto
     
    </strong>
    
     and mapping
    
    <strong class="source-inline">
     
      OptionsDto
     
    </strong>
    
     
      to
     
    
    
     <strong class="source-inline">
      
       CarFlat
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
CreateMap&lt;List&lt;CarFlat&gt;, CarDto&gt;()
     .ForPath(dest =&gt; dest.Id, opt =&gt; opt.MapFrom(src =&gt; src.First().
     id))
     .ForPath(dest =&gt; dest.Name, opt =&gt; opt.MapFrom(src =&gt; src.
     First().name))
     .ForMember(dest =&gt; dest.Options, opt =&gt; opt.MapFrom(src =&gt; src));
CreateMap&lt;OptionsDto, CarFlat&gt;()
     .ForMember(dest =&gt; dest.option_id, opt =&gt; opt.MapFrom(src =&gt; src.
     OptionId))
     .ForMember(dest =&gt; dest.option_name, opt =&gt; opt.MapFrom(src =&gt; 
     src.OptionName))
     .ForMember(dest =&gt; dest.option_price, opt =&gt; opt.MapFrom(src =&gt; 
     src.OptionPrice))</pre>
   <p>
    
     The magic
    
    <a id="_idIndexMarker227">
    </a>
    
     is performed by AutoMapper.
    
    
     If you have not installed AutoMapper yet, this is a good time to do so.
    
    
     AutoMapper will make this job infinitely easier.
    
    
     AutoMapper simplifies the mapping process between different object models, reducing the need for manual transformations.
    
    
     All we need to do is tell AutoMapper to map from one class to another, as
    
    
     
      shown next.
     
    
   </p>
   <h1 id="_idParaDest-111">
    <a id="_idTextAnchor111">
    </a>
    
     Supporting implementation
    
   </h1>
   <p>
    
     With the
    
    <a id="_idIndexMarker228">
    </a>
    
     profile written, we’ll go back to the controller.
    
    
     Here, we’re going to map
    
    <strong class="source-inline">
     
      CarDto
     
    </strong>
    
     to the car.
    
    
     Notice the next to last line of
    
    
     
      this code:
     
    
   </p>
   <pre class="source-code">
       [HttpGet("{id}")]
       public async Task&lt;ActionResult&lt;CarDto&gt;&gt; Get(int id)
       {
           var car = await _carService.Get(id);
           if (car == null)
           {
               return NotFound();
           }
           <strong class="bold">var carDto = _mapper.Map&lt;CarDto&gt;(car);</strong>
           return carDto;
       }</pre>
   <p>
    
     Nothing new or special here, but note that at the bottom of the method, we use a mapper to turn our car into a DTO, which is what we return to the
    
    
     
      client application.
     
    
   </p>
   <p>
    
     The only logic in
    
    <strong class="source-inline">
     
      CarService
     
    </strong>
    
     is to ensure we have a valid
    
    
     
      car ID:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;List&lt;CarFlat&gt;&gt; Get(int id)
 {
     if (id == 0)
     {
         throw new Exception("Invalid Id");
     }
     return await _carRepository.Get(id);
 }</pre>
   <p>
    
     This brings
    
    <a id="_idIndexMarker229">
    </a>
    
     us to
    
    
     
      the repository:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;List&lt;CarFlat?&gt;&gt; Get(int id)
 {
     var query = "select * from car c left join options o on o.car_id 
     = c.id where c.id = @id";
     using var db = databaseConnectionFactory.GetConnection();
     return (await db.QueryAsync&lt;CarFlat&gt;(query, new {id})).ToList();
 }</pre>
   <p>
    
     The method is surprisingly simple.
    
    
     We set up and execute the query.
    
    
     Notice that we are using
    
    <strong class="source-inline">
     
      QueryAsync
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      ToList
     
    </strong>
    
     as if we were getting all the cars.
    
    
     Actually, what we are getting is a list of the options for a single car, as shown in the
    
    
     
      next listing:
     
    
   </p>
   <pre class="source-code">
{
    "id": 2,
    "name": "buick skylark 320",
    "mpg": null,
    "cylinders": null,
    "displacement": null,
    "horsepower": null,
    "weight": null,
    "acceleration": null,
    "modelYear": null,
    "origin": null,
    "is_Deleted": null,
    "options": [
        {
            "optionId": 1,
            "optionName": "Winter Package",
            "optionPrice": 3700
        },
        {
            "optionId": 2,
            "optionName": "Mats",
            "optionPrice": 250
        },
        {
            "optionId": 3,
            "optionName": "Summer Package",
            "optionPrice": 2250
        }
    ]
}</pre>
   <p>
    
     Beautiful!
    
    
     This should look familiar, as it is what we specified at the beginning of the chapter.
    
    
     Each car has its options as a sub-set in the JSON.
    
    
     This will make it much easier to display
    
    <a id="_idIndexMarker230">
    </a>
    
     the cars with their options (e.g., on a web page).
    
    
     Tuck this in your pocket; you don’t use it often, but when you need to make this kind of display, the technique is powerful but
    
    
     
      not obvious.
     
    
   </p>
   <p>
    
     In this next section, we will introduce Azure Storage Tables, a powerful yet simple way to
    
    
     
      store data.
     
    
   </p>
   <h1 id="_idParaDest-112">
    <a id="_idTextAnchor112">
    </a>
    
     Azure Storage Tables
    
   </h1>
   <p>
    <strong class="bold">
     
      Storage Tables
     
    </strong>
    
     are a great way to persist relatively simple data structures.
    
    
     Creating and using storage tables is quick
    
    
     
      and easy.
     
    
   </p>
   <p>
    
     Azure offers
    
    <a id="_idIndexMarker231">
    </a>
    
     a number of ways to store your data.
    
    
     The most popular are SQL Server, Cosmos, and storage tables.
    
    
     Storage tables are the most limited, but they are also the simplest generally speaking, and the fastest to create.
    
    
     They are very popular for keeping track of simple information.
    
    
     For example, you might use storage tables to record each time you send a message or each time something anomalous happens.
    
    
     For these examples, you would enter one row per incident, as described in the
    
    
     
      following section.
     
    
   </p>
   <h1 id="_idParaDest-113">
    <a id="_idTextAnchor113">
    </a>
    
     Exploring the essentials
    
   </h1>
   <p>
    
     Storage
    
    <a id="_idIndexMarker232">
    </a>
    
     tables are not inherently relational.
    
    
     While you can index, it isn’t simple, and it isn’t particularly powerful.
    
    
     The reason behind all this is to keep storage tables simple.
    
    
     This makes them ideal for keeping lists, logging, creating progress entries, and
    
    
     
      so forth.
     
    
   </p>
   <p>
    
     We will create a storage table that tracks exceptions thrown during the execution of our program.
    
    
     The table we create will look like this
    
    
     
      on Azure:
     
    
   </p>
   <div><div><img alt="Figure 8.3 – The left portion of a storage table" src="img/B21998_08_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.3 – The left portion of a storage table
    
   </p>
   <p>
    
     Due to space concerns, I’m not showing the entire table here.
    
    
     There are columns for the exception type, the time of the exception, the message, and
    
    
     
      so forth.
     
    
   </p>
   <p>
    
     To keep
    
    <a id="_idIndexMarker233">
    </a>
    
     things as simple as possible, and to focus 100% on Table Storage, we’ll create a console application that simply throws exceptions and stores them in the table.
    
    
     To get started, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new project and select
     
     <strong class="bold">
      
       Console App
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .4
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.4 – Selecting console app" src="img/B21998_08_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.4 – Selecting console app
    
   </p>
   <ol>
    <li value="2">
     
      Click
     
     <strong class="bold">
      
       Next
      
     </strong>
     
      and fill in your project name (I used
     
     <strong class="source-inline">
      
       TableStorageConsoleApp
      
     </strong>
     
      ), its location on your local disk, and the name of the solution (typically the same as your project).
     
     
      Click
     
     <strong class="bold">
      
       Next
      
     </strong>
     
      and select
     
     <strong class="bold">
      
       .NET 8
      
     </strong>
     
      (or later) and, most important, check
     
     <strong class="bold">
      
       Do not use top-level statements
      
     </strong>
     
      , as shown in the
     
     
      
       following figure:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.5 – Additional information" src="img/B21998_08_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.5 – Additional information
    
   </p>
   <ol>
    <li value="3">
     
      Click
     
     <strong class="bold">
      
       Create
      
     </strong>
     
      and your console app will be created, complete with a main entry point and a single line of code, writing the canonical “Hello, World” greeting.
     
     
      You can delete
     
     
      
       that line.
      
     
    </li>
   </ol>
   <p>
    
     To keep
    
    <a id="_idIndexMarker234">
    </a>
    
     things simple, we’ll have
    
    <strong class="source-inline">
     
      Main
     
    </strong>
    
     call
    
    <strong class="source-inline">
     
      ThrowException
     
    </strong>
    
     , a method we’ll write that will throw a random exception every two seconds.
    
    
     Thus,
    
    <strong class="source-inline">
     
      Main
     
    </strong>
    
     is
    
    
     
      very simple:
     
    
   </p>
   <pre class="source-code">
public class Program
 {
     static void Main(string[] args)
     {
         Console.WriteLine("Loading...");
         for(; ; )
         {
             ThrowException();
         }
     }</pre>
   <p>
    
     You can see that
    
    <strong class="source-inline">
     
      ThrowException
     
    </strong>
    
     is enclosed in a forever loop and will continue until you close the program.
    
    
     Putting in a more sophisticated way to stop it is, as they say, left as an exercise for
    
    
     
      the reader.
     
    
   </p>
   <p>
    
     The job of
    
    <strong class="source-inline">
     
      ThrowException
     
    </strong>
    
     is, as said earlier, to throw exceptions randomly.
    
    
     For this, I need nothing more than a
    
    <strong class="source-inline">
     
      random
     
    </strong>
    
     generator and a
    
    <strong class="source-inline">
     
      switch
     
    </strong>
    
     statement.
    
    
     We begin by
    
    <a id="_idIndexMarker235">
    </a>
    
     enclosing the random generation of exceptions within a
    
    
     
      try statement:
     
    
   </p>
   <pre class="source-code">
try
{
    Random rand = new Random();
    var random = rand.Next(0, 10);
    switch (random)
    {
        case 0:
            throw new ArgumentException("Argument Exception");
        case 1:
            throw new ArgumentNullException("Argument Null 
            Exception");
        case 2:
            throw new ArgumentOutOfRangeException("Argument Out Of 
            Range Exception");
        case 3:
            throw new DivideByZeroException("Divide By Zero 
            Exception");
        case 4:
            throw new FileNotFoundException("File Not Found 
            Exception");
        case 5:
            throw new FormatException("Format Exception");
        case 6:
            throw new IndexOutOfRangeException("Index Out Of Range 
            Exception");
        case 7:
            throw new InvalidOperationException("Invalid Operation 
            Exception");
        case 8:
            throw new KeyNotFoundException("Key Not Found Exception");
        case 9:
            throw new NotImplementedException("Not Implemented 
            Exception");
        case 10:
            throw new NotSupportedException("Not Supported 
            Exception");
        default:
            throw new Exception("Generic Exception - you should never 
            see this");
    }
}</pre>
   <p>
    
     With that, we can
    
    <a id="_idIndexMarker236">
    </a>
    
     catch each exception and write it to
    
    
     
      our table:
     
    
   </p>
   <pre class="source-code">
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
    TableModel entity = new TableModel
    {
        PartitionKey = ex.GetType().Name,
        RowKey = $"TableStorageConsoleApp-{DateTime.UtcNow.
        ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")}",
        Message = ex.Message,
        Timestamp = DateTimeOffset.UtcNow
    };
    TableServiceClient tableServiceClient = new 
    TableServiceClient("DefaultEndpointsProtocol=
    https;AccountName=&lt;your account name&gt;;AccountKey=
    &lt;your account key&gt;;EndpointSuffix=core.windows.net");
    var storageTableService = new 
    StorageTableService(tableServiceClient);
    storageTableService.UpsertEntityAsync(entity).Wait();
    Thread.Sleep(2000);
}</pre>
   <p>
    
     There’s quite
    
    <a id="_idIndexMarker237">
    </a>
    
     a bit to see here.
    
    
     We begin by creating
    
    <strong class="source-inline">
     
      TableModel
     
    </strong>
    
     .
    
    
     We’ll create that data structure in just
    
    
     
      a moment.
     
    
   </p>
   <p>
    
     Within that model, we’ll have
    
    <strong class="source-inline">
     
      PartitionKey
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      RowKey
     
    </strong>
    
     .
    
    
     These are critical to
    
    <strong class="source-inline">
     
      TableStorage
     
    </strong>
    
     .
    
    
     Together, they make the unique identifier for each row in
    
    
     
      the table.
     
    
   </p>
   <p>
    
     All of the entries with the same
    
    <strong class="source-inline">
     
      PartitionKey
     
    </strong>
    
     are clustered, and in that cluster are all their
    
    <strong class="source-inline">
     
      RowKeys
     
    </strong>
    
     .
    
    
     This makes retrieval infinitely faster.
    
    
     Rather than having to scan through all the
    
    <strong class="source-inline">
     
      RowKeys
     
    </strong>
    
     , retrieval can be achieved by jumping to the right
    
    <strong class="source-inline">
     
      PartitionKey
     
    </strong>
    
     and searching
    
    
     
      from there.
     
    
   </p>
   <p>
    
     We also store the exception’s message and the current time as
    
    
     
      a timestamp.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      TableServiceClient
     
    </strong>
    
     is supplied by the NuGet package (see requirements at the beginning of this chapter).
    
    
     The address you’ll initialize with is supplied by Azure as shown later in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     We then call
    
    <strong class="source-inline">
     
      UpsertEntityAsync
     
    </strong>
    
     , passing in the entity we created earlier, and go to sleep
    
    <a id="_idIndexMarker238">
    </a>
    
     for two seconds (the amount of time you sleep is entirely up
    
    
     
      to you).
     
    
   </p>
   <p>
    
     Please note that you will need your own
    
    <strong class="source-inline">
     
      AccountKey
     
    </strong>
    
     and preferably your
    
    
     
      own
     
    
    
     <strong class="source-inline">
      
       accountName
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-114">
    <a id="_idTextAnchor114">
    </a>
    
     TableModel
    
   </h2>
   <p>
    
     I promised
    
    <a id="_idIndexMarker239">
    </a>
    
     earlier to show you the
    
    <strong class="source-inline">
     
      TableModel
     
    </strong>
    
     .
    
    
     It is quite
    
    <a id="_idIndexMarker240">
    </a>
    
     simple, just enough to capture the
    
    
     
      essential information:
     
    
   </p>
   <pre class="source-code">
public class TableModel : ITableEntity
 {
     required public string PartitionKey { get; set; }
     required public string RowKey { get; set; }
     public DateTimeOffset? Timestamp { get; set; }
     public string? Message { get; set; }
     public ETag ETag { get; set; } = ETag.All;
 }</pre>
   <p>
    
     Note that
    
    <strong class="source-inline">
     
      ETag
     
    </strong>
    
     must be in every table model.
    
    
     This is used for optimistic concurrency during updates.
    
    
     We won’t be doing updates and don’t care about this except that it must
    
    
     
      be there.
     
    
   </p>
   <h2 id="_idParaDest-115">
    <a id="_idTextAnchor115">
    </a>
    
     StorageTableService
    
   </h2>
   <p>
    
     The heart
    
    <a id="_idIndexMarker241">
    </a>
    
     of the application is
    
    <strong class="source-inline">
     
      StorageTableService
     
    </strong>
    
     .
    
    
     Here is
    
    <a id="_idIndexMarker242">
    </a>
    
     where
    
    <strong class="source-inline">
     
      UpsertEntityAsync
     
    </strong>
    
     lives, which does the work of interacting with
    
    
     
      our table:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;Response&gt; UpsertEntityAsync(TableModel entity)
{
     var response = await _tableCreationTask;
     var table = _tableServiceClient.GetTableClient(response.Value.
     Name);
     return await table.UpsertEntityAsync(entity);
}</pre>
   <p>
    
     To get started, we declare two member variables at the top of
    
    
     
      the class:
     
    
   </p>
   <pre class="source-code">
private readonly TableServiceClient _tableServiceClient;
private readonly Task&lt;Response&lt;TableItem&gt;&gt; _tableCreationTask;</pre>
   <p>
    
     Notice that the second member is of type
    
    <strong class="source-inline">
     
      Task&lt;Response&lt;TableItem&gt;
     
    </strong>
    
     .
    
    
     Both
    
    <strong class="source-inline">
     
      Response
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      TableItem
     
    </strong>
    
     are supplied by the Azure NuGet package.
    
    
     The constructor takes
    
    <strong class="source-inline">
     
      TableServiceClient
     
    </strong>
    
     (also supplied in the same
    
    
     
      NuGet package).
     
    
   </p>
   <pre class="source-code">
public StorageTableService(TableServiceClient tableServiceClient)
{
     _tableServiceClient = tableServiceClient;
     _tableCreationTask = _tableServiceClient.
     CreateTableIfNotExistsAsync("ExceptionsTable");
}</pre>
   <p>
    
     It is here that we create the table if it doesn’t exist and name it
    
    <strong class="source-inline">
     
      ExceptionsTable
     
    </strong>
    
     (feel free to name yours whatever
    
    
     
      you like).
     
    
   </p>
   <p>
    
     All
    
    <a id="_idIndexMarker243">
    </a>
    
     the
    
    <strong class="source-inline">
     
      Upsert
     
    </strong>
    
     method needs to do is call
    
    <strong class="source-inline">
     
      tableCreationTask
     
    </strong>
    
     and wait to get back
    
    <strong class="source-inline">
     
      Response&lt;TableItem&gt;
     
    </strong>
    
     .
    
    
     With that
    
    <a id="_idIndexMarker244">
    </a>
    
     in hand, it is ready to call
    
    <strong class="source-inline">
     
      GetTableClient
     
    </strong>
    
     on
    
    <strong class="source-inline">
     
      TableServiceClient
     
    </strong>
    
     , passing in the name of the table.
    
    
     Finally, we call
    
    <strong class="source-inline">
     
      UpsertEntityAsync
     
    </strong>
    
     on the table passing
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       TableModel
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Please make sure you understand the previous paragraph as it is the heart of working
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       StorageTables
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-116">
    <a id="_idTextAnchor116">
    </a>
    
     Populating the table in Azure
    
   </h2>
   <p>
    
     With
    
    <a id="_idIndexMarker245">
    </a>
    
     what we’ve written, populating the table in Azure is automatic.
    
    
     Run the program; your output should look something like
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .6
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 8.6 – Generated exceptions" src="img/B21998_08_06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.6 – Generated exceptions
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     You’ll need an Azure account for this part.
    
    
     As noted earlier, you can get a free starter account at the
    
    
     
      link provided.
     
    
   </p>
   <p>
    
     Now, let’s go to Azure and see what
    
    
     
      we’ve got:
     
    
   </p>
   <ol>
    <li>
     
      Log in to your account and click on
     
     <strong class="bold">
      
       Home
      
     </strong>
     
      and then on
     
     <strong class="bold">
      
       Storage browser
      
     </strong>
     
      , as shown in the
     
     
      
       following figure:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.7 – Storage browser" src="img/B21998_08_07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.7 – Storage browser
    
   </p>
   <ol>
    <li value="2">
     
      From
     
     <a id="_idIndexMarker246">
     </a>
     
      there, click on your
     
     <strong class="source-inline">
      
       TableStorage
      
     </strong>
     
      account.
     
     
      That will bring up a dashboard.
     
     
      Click on
     
     <strong class="bold">
      
       Tables
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .8
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.8 – Selecting tables" src="img/B21998_08_08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.8 – Selecting tables
    
   </p>
   <ol>
    <li value="3">
     
      You should be brought to a page where your tables should be listed as links.
     
     
      Click on the table we created.
     
     
      The entries that match what we saw in the application will pop up, as shown (in part) in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .9
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.9 – The table on Azure" src="img/B21998_08_09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.9 – The table on Azure
    
   </p>
   <p>
    
     Notice
    
    <a id="_idIndexMarker247">
    </a>
    
     that the entries are not in the order in which they were created.
    
    
     Rather, they are clustered by
    
    <strong class="source-inline">
     
      PartitionKey
     
    </strong>
    
     , as
    
    
     
      described earlier.
     
    
   </p>
   <p>
    
     Shockingly, that’s all there is
    
    
     
      to it.
     
    
   </p>
   <h1 id="_idParaDest-117">
    <a id="_idTextAnchor117">
    </a>
    
     Introducing Microsoft Aspire
    
   </h1>
   <p>
    
     Microsoft has
    
    <a id="_idIndexMarker248">
    </a>
    
     introduced Aspire, which it describes as
    
    <em class="italic">
     
      opinionated, cloud ready stack for building observable, Production-ready, distributed applications.
     
    </em>
    
     
      Say what?
     
    
   </p>
   <p>
    
     In this case,
    
    <em class="italic">
     
      opinionated
     
    </em>
    
     means that there are conventions and templates to make life easier.
    
    
     With this and all things, you can customize, but the more you follow the conventions, the easier it is to write, and perhaps more important, to read
    
    
     
      your code.
     
    
   </p>
   <p>
    <em class="italic">
     
      Cloud-ready stack
     
    </em>
    
     indicates that you will be working locally but on code that can easily be moved to the cloud (read Azure).
    
    <em class="italic">
     
      Production-ready
     
    </em>
    
     indicates that what you build will be non-trivial and ready to roll out, and
    
    <em class="italic">
     
      distributed
     
    </em>
    
     means that you will be creating micro-services hosted in containers, in our
    
    
     
      case, Docker.
     
    
   </p>
   <p>
    
     Aspire provides
    
    <a id="_idIndexMarker249">
    </a>
    
     you with a number of services that you could write yourself, but no longer have to.
    
    
     Instead, you get fully tested code
    
    <em class="italic">
     
      automagically
     
    </em>
    
     that provides, among other things, storage, messaging, and web services, and that can also provide interoperability with databases, caching,
    
    
     
      and more.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     You can use Aspire with Visual Studio Code or even the .NET CLI, but we’ll stick with
    
    
     
      Visual Studio.
     
    
   </p>
   <h2 id="_idParaDest-118">
    <a id="_idTextAnchor118">
    </a>
    
     Sample program
    
   </h2>
   <p>
    
     Aspire is
    
    <a id="_idIndexMarker250">
    </a>
    
     very powerful, but it can be tricky to get all the pieces in place.
    
    
     We
    
    <em class="italic">
     
      could
     
    </em>
    
     write our own sample program, but that would be silly since Microsoft supplies one that you can create with just a few keystrokes in Visual Studio.
    
    
     To get started, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new project and select
     
     <strong class="bold">
      
       .NET Aspire Starter Application
      
     </strong>
     
      .
     
     
      Be sure to choose the one for C#, as shown in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .10
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.10 - Choosing Aspire" src="img/B21998_08_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.10 - Choosing Aspire
    
   </p>
   <ol>
    <li value="2">
     
      Enter a
     
     <a id="_idIndexMarker251">
     </a>
     
      project name (I’ll use
     
     <strong class="source-inline">
      
       AspirePackt
      
     </strong>
     
      ) and leave the rest of the values as
     
     
      
       their defaults.
      
     
    </li>
    <li>
     
      On the next page, make sure you select
     
     <strong class="bold">
      
       .NET 8
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Use Redis for caching
      
     </strong>
     
      , and while you always should create unit tests, we’ll skip that for now (in a “real” application, you want those unit tests), as shown in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .11
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.11 – Selecting the frameworks" src="img/B21998_08_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.11 – Selecting the frameworks
    
   </p>
   <p>
    
     Here’s what we’re going to see: a sample weather app that supports caching.
    
    
     It will get the weather through an API, using random,
    
    
     
      demonstration values.
     
    
   </p>
   <ol>
    <li>
     
      Start the app up and the first thing that will happen is that the .NET Aspire dashboard will open in your browser, as partly shown in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .12
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.12 – Aspire dashboard" src="img/B21998_08_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.12 – Aspire dashboard
    
   </p>
   <p>
    
     This was
    
    <a id="_idIndexMarker252">
    </a>
    
     all created for you in the sample program, which also created a Blazor application that will be used to display the data retrieved by
    
    
     
      the API.
     
    
   </p>
   <p>
    
     Notice that the third line’s project in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    <em class="italic">
     
      .13
     
    </em>
    
     is
    
    <strong class="source-inline">
     
      webfrontend
     
    </strong>
    
     .
    
    
     Click on the URL and you are brought to the iconic
    
    <strong class="bold">
     
      Hello, world!
     
    </strong>
    
     page.
    
    
     On the left are three buttons, as shown in the
    
    
     
      following figure:
     
    
   </p>
   <div><div><img alt="Figure 8.13 – The running application" src="img/B21998_08_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.13 – The running application
    
   </p>
   <p>
    
     Now click
    
    <a id="_idIndexMarker253">
    </a>
    
     on the
    
    <strong class="bold">
     
      Weather
     
    </strong>
    
     option and
    
    <em class="italic">
     
      voilà
     
    </em>
    
     !
    
    
     The API is hit, and the weather data is displayed, as shown in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .14
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 8.14 – The displayed weather from the API" src="img/B21998_08_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.14 – The displayed weather from the API
    
   </p>
   <p>
    
     If you refresh the screen a few times, you’ll see that it is instantly responsive as it is using the cache.
    
    
     After about 10 seconds, it will generate
    
    
     
      new data.
     
    
   </p>
   <h2 id="_idParaDest-119">
    <a id="_idTextAnchor119">
    </a>
    
     Exploring the Aspire dashboard
    
   </h2>
   <p>
    
     Going back to
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    <em class="italic">
     
      .12
     
    </em>
    
     , we see a number of useful features.
    
    
     Click on
    
    <strong class="bold">
     
      Resources
     
    </strong>
    
     , for example, to see a list of information for all the .NET projects in your application.
    
    
     These
    
    <a id="_idIndexMarker254">
    </a>
    
     include the app state, endpoints, and
    
    
     
      environment variables.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Console
     
    </strong>
    
     displays (surprise!) the console output from
    
    
     
      each project.
     
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Structured
     
    </strong>
    
     option displays logs as tables.
    
    
     You can filter and search (either free-form or filtered).
    
    
     You can expand the details for each entry by clicking on the
    
    <strong class="bold">
     
      View
     
    </strong>
    
     button on the
    
    
     
      far right.
     
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Traces
     
    </strong>
    
     button displays the request paths throughout your application.
    
    
     Locate a request for
    
    <strong class="bold">
     
      Weather
     
    </strong>
    
     and select
    
    <strong class="bold">
     
      View
     
    </strong>
    
     .
    
    
     The dashboard will display the request
    
    
     
      in stages.
     
    
   </p>
   <p>
    
     Click on
    
    <strong class="bold">
     
      ApiService | View
     
    </strong>
    
     and you’ll see the time it took to hit the API.
    
    
     Click on
    
    <strong class="bold">
     
      View
     
    </strong>
    
     on the right and the resources are displayed in detail.
    
    
     Scroll down to see
    
    
     
      more details.
     
    
   </p>
   <p>
    
     Finally, the
    
    <strong class="bold">
     
      Metrics
     
    </strong>
    
     button will display instruments and meters, as they are available for
    
    
     
      your application.
     
    
   </p>
   <h1 id="_idParaDest-120">
    <a id="_idTextAnchor120">
    </a>
    
     What have you learned, Dorothy?
    
   </h1>
   <p>
    
     As you can see, the sample application consists of a number of projects.
    
    
     The first, perhaps most
    
    <a id="_idIndexMarker255">
    </a>
    
     essential is the app host, which acts as the orchestrator.
    
    
     It will automatically set
    
    <strong class="source-inline">
     
      IsAspireHost
     
    </strong>
    
     in the project file
    
    
     
      to true.
     
    
   </p>
   <p>
    
     Pour through the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file and you’ll see what you’d expect as an API developer, along with Aspire in
    
    <strong class="source-inline">
     
      APIService
     
    </strong>
    
     (and a couple of things added
    
    
     
      for Blazor).
     
    
   </p>
   <p>
    
     Note that the first line creates
    
    <strong class="source-inline">
     
      DistributedApplication
     
    </strong>
    
     
      using Docker.
     
    
   </p>
   <p>
    
     A critical line in this file is
    
    <strong class="source-inline">
     
      AspirePackt.ApiService
     
    </strong>
    
     , which configures the service discovery and communication among the projects in your solution.
    
    
     The name (
    
    <strong class="source-inline">
     
      apiservice
     
    </strong>
    
     ) identifies the project and is used by projects that want to communicate
    
    
     
      with it.
     
    
   </p>
   <p>
    
     Another important and universal project is
    
    <strong class="source-inline">
     
      ServiceDefaults
     
    </strong>
    
     , which is a shared project that manages configurations so that they can be used across projects.
    
    
     This allows the application to have all the services share service discovery, telemetry,
    
    
     
      and more.
     
    
   </p>
   <h1 id="_idParaDest-121">
    <a id="_idTextAnchor121">
    </a>
    
     Adding Aspire to an existing app
    
   </h1>
   <p>
    
     We all love green-field projects, but the reality is that most of the time we’re working with
    
    <a id="_idIndexMarker256">
    </a>
    
     existing code.
    
    
     Aspire would not be very interesting if it only worked from scratch, but fortunately, you can add Aspire to
    
    
     
      existing applications.
     
    
   </p>
   <p>
    
     We could add Aspire to our car application, but once again, Microsoft assists, providing a reasonably complex application for us to work with.
    
    
     To get started, clone their application by using the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite</pre>
   <p>
    
     This sample consists of
    
    
     
      three projects:
     
    
   </p>
   <ul>
    <li>
     
      Data Entities is a class library that defines the
     
     
      <strong class="source-inline">
       
        Product
       
      </strong>
     
     
      
       class
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Products
      
     </strong>
     
      is a web API that returns a list of all the Products in the
     
     
      
       store’s catalog
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      is a Blazor web app that displays the products on
     
     
      
       a website
      
     
    </li>
   </ul>
   <p>
    
     Note that we will not be focusing on Blazor.
    
    
     We will use it only as far as it is part of
    
    
     
      this example
     
    
   </p>
   <h2 id="_idParaDest-122">
    <a id="_idTextAnchor122">
    </a>
    
     Getting oriented with our new project
    
   </h2>
   <p>
    
     Let’s take
    
    <a id="_idIndexMarker257">
    </a>
    
     a look at what the new project (out of the box) looks like.
    
    
     To do so, follow these steps to create our “existing” project that we will add
    
    
     
      Aspire to:
     
    
   </p>
   <ol>
    <li>
     
      Open
     
     <a href="http://eShopLite.sln">
      
       eShopLite.sln
      
     </a>
     
      .
     
     
      Right-click on the solution and select
     
     <strong class="bold">
      
       Configure
      
     </strong>
     
      <strong class="bold">
       
        Startup Projects
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Choose multiple startup projects and in the
     
     <strong class="bold">
      
       Action
      
     </strong>
     
      column, select
     
     <strong class="bold">
      
       S
      
     </strong>
     <strong class="bold">
      
       tart
      
     </strong>
     
      for
     
     <strong class="bold">
      
       Products and Store
      
     </strong>
     
      , as shown in the
     
     
      
       following figure:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.15 – Setting the startup projects" src="img/B21998_08_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.15 – Setting the startup projects
    
   </p>
   <ol>
    <li value="3">
     
      Fire it up
     
     <a id="_idIndexMarker258">
     </a>
     
      by pressing
     
     <em class="italic">
      
       F5
      
     </em>
     
      and note that two browser pages open.
     
     
      One page has the raw JSON and the second page is a simple browser application that lets you view that data (click on
     
     <strong class="bold">
      
       Products
      
     </strong>
     
      ), as shown in part in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .15
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.16 – The raw JSON" src="img/B21998_08_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.16 – The raw JSON
    
   </p>
   <p>
    
     At the top
    
    <a id="_idIndexMarker259">
    </a>
    
     of the JSON is a checkbox for pretty print.
    
    
     That will take this raw JSON and make it more readable, as shown in the
    
    
     
      following figure:
     
    
   </p>
   <div><div><img alt="Figure 8.17 – Pretty print" src="img/B21998_08_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.17 – Pretty print
    
   </p>
   <p>
    
     Blazor will give you a web-based view of that same data, as shown in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .18
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 8.18 – The browser display of the products" src="img/B21998_08_18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.18 – The browser display of the products
    
   </p>
   <p>
    
     Now that
    
    <a id="_idIndexMarker260">
    </a>
    
     we have a working application, let’s refactor it to add Aspire.
    
    
     We’ll do
    
    
     
      that next.
     
    
   </p>
   <h2 id="_idParaDest-123">
    <a id="_idTextAnchor123">
    </a>
    
     Adding Aspire
    
   </h2>
   <p>
    
     Now that
    
    <a id="_idIndexMarker261">
    </a>
    
     we have a working API solution, let’s add Aspire.
    
    
     To do so, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Right-click on one of the projects (I’ll use
     
     <strong class="bold">
      
       Store
      
     </strong>
     
      ) and select
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      |
     
     <strong class="bold">
      
       .Net Aspire Orchestrator Support
      
     </strong>
     
      .
     
     
      That brings up the
     
     
      
       dialog box.
      
     
    </li>
    <li>
     
      Click
     
     <strong class="bold">
      
       OK
      
     </strong>
     
      and two new projects are added to
     
     
      
       your solution:
      
     
     <ul>
      <li>
       
        <strong class="source-inline">
         
          eShopLiteAppHost
         
        </strong>
       
      </li>
      <li>
       
        <strong class="source-inline">
         
          eShopLite.ServiceDefaults
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <p>
    
     Spend a few minutes exploring these projects.
    
    
     The first,
    
    <strong class="source-inline">
     
      eShopLiteAppHost
     
    </strong>
    
     , is an orchestrator project whose job is to connect (and configure) the various projects and services of your application.
    
    
     It is automatically set as the startup project.
    
    <strong class="source-inline">
     
      eShopServiceDefaults
     
    </strong>
    
     holds configurations that will be used across projects, especially service discovery and telemetry (more about
    
    
     
      these shortly).
     
    
   </p>
   <ol>
    <li>
     
      Next, open
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      in
     
     <strong class="source-inline">
      
       AppHost
      
     </strong>
     
      , where you will see
     
     
      
       this code:
      
     
     <pre class="source-code">
builder.AddProject&lt;Projects.Store&gt;("store");</pre>
     <p class="list-inset">
      
       This registers the store project in the orchestrator.
      
      
       We now need to register the
      
      
       <strong class="source-inline">
        
         Products
        
       </strong>
      
      
       
        project.
       
      
     </p>
    </li>
    <li>
     
      Right-click
     
     <a id="_idIndexMarker262">
     </a>
     
      on it and select
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      |
     
     <strong class="bold">
      
       .NET Aspire Orchestrator Support
      
     </strong>
     
      .
     
     
      You’ll get a dialog saying the orchestrator already exists; just
     
     
      
       click
      
     
     
      <strong class="bold">
       
        OK
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Go back to
     
     <strong class="source-inline">
      
       AppHost
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      and you can see that another line has been added, as you
     
     
      
       might expect:
      
     
     <pre class="source-code">
builder.AddProject&lt;Projects.Products&gt;("Products");</pre>
    </li>
   </ol>
   <p>
    
     Now comes the fun part.
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     needs to be able to find
    
    <strong class="source-inline">
     
      Products
     
    </strong>
    
     ’ backend address.
    
    
     Rather than doing this by hand, we turn that responsibility over to
    
    
     
      the orchestrator.
     
    
   </p>
   <h3>
    
     Discovery
    
   </h3>
   <p>
    
     While both
    
    <a id="_idIndexMarker263">
    </a>
    
     projects are registered with the orchestrator,
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     needs to be able to discover the
    
    <strong class="source-inline">
     
      Products
     
    </strong>
    
     ’ backend address.
    
    
     To enable discovery, return to
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     and add a reference to the
    
    <strong class="source-inline">
     
      Products
     
    </strong>
    
     project.
    
    
     Your
    
    <strong class="source-inline">
     
      program.cs
     
    </strong>
    
     file should now look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
var Products = builder.AddProject&lt;Projects.Products&gt;("Products");
builder.AddProject&lt;Projects.Store&gt;("store")
       .WithExternalHttpEndpoints()
       .WithReference(Products);
builder.Build().Run();</pre>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     If you want to deploy this application, you’ll need to call
    
    <strong class="source-inline">
     
      WithExternalHttpEndpoints
     
    </strong>
    
     to make sure it is public to the
    
    
     
      outside world.
     
    
   </p>
   <p>
    
     Almost done.
    
    
     We need
    
    <a id="_idIndexMarker264">
    </a>
    
     to update
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     in the
    
    
     <strong class="source-inline">
      
       Store
      
     </strong>
    
    
     
      project:
     
    
   </p>
   <pre class="source-code">
{
  "DetailedErrors": true,
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ProductEndpoint": "http://Products",
  "ProductEndpointHttps": "https://Products"
}</pre>
   <p>
    
     The addresses for both endpoints now use the
    
    <strong class="source-inline">
     
      Products
     
    </strong>
    
     name.
    
    
     Note that these names are used to discover the address of the
    
    
     <strong class="source-inline">
      
       Products
      
     </strong>
    
    
     
      project.
     
    
   </p>
   <p>
    
     Press
    
    <em class="italic">
     
      F5
     
    </em>
    
     to run it.
    
    
     You’ve added Aspire, with all its features and dashboard, to your existing
    
    
     
      API project.
     
    
   </p>
   <h1 id="_idParaDest-124">
    <a id="_idTextAnchor124">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, you learned about three very powerful, advanced techniques.
    
    
     First, we looked at creating more complex APIs that return hierarchical data.
    
    
     We did this by adding and presenting options for each
    
    
     
      car type.
     
    
   </p>
   <p>
    
     Next, we looked at Azure Storage Tables, a lightweight way to store data on Azure, side-stepping the complexity of Entity Framework
    
    
     
      and Cosmos.
     
    
   </p>
   <p>
    
     Finally, we went on to look at Microsoft’s Aspire dashboard, a very powerful and useful tool for working
    
    
     
      with APIs.
     
    
   </p>
   <p>
    
     In the next chapter, we’ll look at the critical issue of authentication and authorization, without which you cannot create an
    
    
     
      enterprise API.
     
    
   </p>
   <h1 id="_idParaDest-125">
    <a id="_idTextAnchor125">
    </a>
    
     You try it
    
   </h1>
   <p>
    
     Creating an Aspire dashboard is pretty straightforward out of the box, but creating hierarchical data is not.
    
    
     To take on a challenge, create a program that displays a few states and with them their principal cities.
    
    
     The result might look something
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
{
    "statePostalCode": MA,
    "name": "Massachusetts",
    "capital": Boston,
    "cities": [
        {
            "city" : "Worchester",
            "longitude": "100.01.93",
            "latitude": -907-45-33
        },
        {
            "city": Acton,
            "longitude": "100.01.107",
            "latitude": -10-398-405
        },
    ]
}</pre>
   <p>
    
     Feel free to make up the longitude and latitude, or look it up online.
    
    
     You’ll want at least two to three cities and two to three states.
    
    
     Once you have your structure, save it as a flat file in an Azure
    
    
     
      Storage Table.
     
    
   </p>
  </div>
 </body></html>