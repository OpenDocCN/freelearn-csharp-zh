- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Localization with MVVM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MVVM进行本地化
- en: So, we’ve built this fantastic *Recipes!* app, and we’re quite pleased with
    its design and features. However, as it stands, the app is entirely in English.
    What about culinary enthusiasts from different parts of the world? The answer
    is localization, specifically focusing on translating all aspects of our app to
    make it accessible and user-friendly to a global audience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经构建了这个出色的*食谱*应用，我们对它的设计和功能感到非常满意。然而，目前这个应用完全是英文的。那么，来自世界各地的烹饪爱好者怎么办呢？答案是本地化，具体来说，就是将我们应用的所有方面都翻译出来，使其对全球用户更加易于访问和友好。
- en: 'In this chapter, we’ll tackle localization through the lens of MVVM. We’ll
    be looking at translating the hardcoded `copy` labels that are baked into the
    app, but also at effectively fetching language-specific data from the API. To
    accomplish this, we’ll delve into the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从MVVM的角度探讨本地化。我们将探讨如何将硬编码的`copy`标签从应用中翻译出来，同时也会探讨如何有效地从API中获取特定语言的数据。为了实现这一点，我们将深入研究以下主题：
- en: Working with cultures, resource files, and localization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文化、资源文件和本地化一起工作
- en: Looking at a localization solution for MVVM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看MVVM的本地化解决方案
- en: Using a custom `Translate` markup extension
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义的`Translate`标记扩展
- en: Fetching localized data from APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API中获取本地化数据
- en: As we dive into this chapter, remember that our journey through localization
    also showcases thoughtful app design with MVVM principles. By the end, not only
    will we have the tools and knowledge to extend the reach of our app to a diverse,
    global audience through the UI, but we’ll also see how the right design choices
    ensure that every layer of our app, down to the data we present, is coherent and
    organized.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入本章内容时，请记住，我们对本地化的探索也展示了具有MVVM原则的深思熟虑的应用设计。到结束时，我们不仅将拥有工具和知识来通过UI将我们应用的触角扩展到多元化的全球受众，我们还将看到正确的设计选择如何确保我们应用的每一层，包括我们展示的数据，都是协调和有序的。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As always, for hands-on experience and to keep pace with the content, head over
    to our GitHub repository at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12).
    Begin with the code in the `Start` folder, and, for a comprehensive view, you
    can always refer to the `Finish` folder, which houses the polished, end-of-chapter
    code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，为了获得实际经验并跟上内容，请访问我们的GitHub仓库[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12)。从`Start`文件夹中的代码开始，如果您需要一个全面的视角，您始终可以参考包含完善、章节末尾代码的`Finish`文件夹。
- en: Working with cultures, resource files, and localization
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文化、资源文件和本地化一起工作
- en: Before we jump into the actual coding bits and look at how we can integrate
    localization in MVVM, let’s make sure we’re all on the same page about what we
    mean by *culture* in the .NET MAUI context. Culture, in this case, refers to the
    settings that determine the language to be used and the display format for items
    such as dates, times, currency, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实际编码并探讨如何在MVVM中集成本地化之前，让我们确保我们对.NET MAUI上下文中的“文化”一词有相同的理解。在这种情况下，“文化”指的是确定要使用的语言以及日期、时间、货币等项目显示格式的设置。
- en: Let’s start with how to retrieve the user’s culture in .NET MAUI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何在.NET MAUI中检索用户的“文化”开始。
- en: Getting the user’s culture
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户的“文化”
- en: The `CultureInfo` class is part of the `System.Globalization` namespace in .NET
    and serves as a central point for obtaining culture-specific information, such
    as language, country, date formats, number formats, and more. It also contains
    `CurrentCulture` and `CurrentUICulture` properties that can be used to get or
    set the user’s current culture and “UI culture.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`CultureInfo`类是.NET中`System.Globalization`命名空间的一部分，它作为获取特定文化信息（如语言、国家、日期格式、数字格式等）的中心点。它还包含`CurrentCulture`和`CurrentUICulture`属性，可以用来获取或设置用户的当前文化以及“UI文化。”'
- en: CurrentCulture versus CurrentUICulture
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CurrentCulture与CurrentUICulture
- en: '`CurrentCulture` defines how data types such as dates, numbers, and currencies
    should be formatted in the application. This ensures that the look and feel of
    the data aligns with the user’s cultural context. On the other hand, `CurrentUICulture`
    dictates the language used for the UI elements and text resources. `CurrentCulture`
    determines *how things look* (formatting), while `CurrentUICulture` controls *which
    language is being* *used* (localization).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentCulture`定义了数据类型（如日期、数字和货币）在应用程序中的格式化方式。这确保了数据的视觉和感觉与用户的文化背景相一致。另一方面，`CurrentUICulture`决定了UI元素和文本资源使用的语言。`CurrentCulture`决定*事物看起来如何*（格式化），而`CurrentUICulture`控制*使用哪种语言*（本地化）。'
- en: 'The user’s current culture settings can be easily obtained with the following
    lines of code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用户当前的文化设置可以通过以下代码行轻松获取：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will get the device’s culture settings, which the user has set up in their
    system settings. Let’s see how we can set a different culture.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取设备的文化设置，这是用户在其系统设置中设置的。让我们看看我们如何设置不同的文化。
- en: Setting a different culture
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置不同的文化
- en: 'Setting a particular culture is as easy as assigning it to the relevant properties
    on the `CultureInfo` class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设置特定的文化就像将其分配给`CultureInfo`类上的相关属性一样简单：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `DefaultThreadCurrentCulture` and `DefaultThreadCurrentUICulture` properties
    are used to set the default culture settings for all threads in a .NET application,
    including background threads that you may spin up for various tasks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultThreadCurrentCulture`和`DefaultThreadCurrentUICulture`属性用于设置.NET应用程序中所有线程的默认文化设置，包括你可能为各种任务启动的后台线程。'
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity and to keep our focus on the overall process of localization,
    throughout this chapter we won’t be making a distinction between `CurrentCulture`
    and `CurrentUICulture` unless explicitly mentioned. When we talk about updating
    the culture settings, we’ll be updating both `CurrentCulture` and `CurrentUICulture`,
    as well as their `DefaultThread` counterparts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化并保持我们对本地化整体过程的关注，在本章中，除非明确提及，否则我们不会在`CurrentCulture`和`CurrentUICulture`之间做出区分。当我们谈论更新文化设置时，我们将更新`CurrentCulture`和`CurrentUICulture`，以及它们的`DefaultThread`对应物。
- en: 'If we want, we can allow users to select a culture from a list of supported
    cultures and save it for future sessions. Here’s a simplified example using `Microsoft.Maui.Storage.Preferences`
    to store the chosen culture:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想，我们可以允许用户从支持的文化的列表中选择一个文化，并将其保存以供未来的会话使用。以下是一个使用`Microsoft.Maui.Storage.Preferences`存储所选文化的简化示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Retrieving and assigning the previously stored selected culture can be done
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 获取并分配之前存储的选定文化可以这样做：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Preferences`’s `Get` method accepts a second parameter that serves as
    a default value to return when no existing value for the given key exists. The
    string value that we retrieved can now be used to instantiate a new `CultureInfo`
    object, which we can then use to set the application’s culture. Take a look:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Preferences`的`Get`方法接受第二个参数，用作当给定键不存在现有值时返回的默认值。我们现在可以使用的字符串值来实例化一个新的`CultureInfo`对象，然后我们可以使用它来设置应用程序的文化。看看这个例子：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As mentioned earlier, the `CurrentCulture` property defines how particular data
    types are being displayed. So, let’s have a quick look at what we mean by that.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`CurrentCulture`属性定义了特定数据类型是如何显示的。那么，让我们快速看看我们指的是什么。
- en: Displaying formatted data
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示格式化数据
- en: Culture settings have a direct impact on how data types such as dates and numbers
    are formatted when they are displayed in the UI. When you set `CultureInfo.CurrentCulture`,
    it will also influence the formatting in data-binding scenarios. This means that
    `DateTime` values, for instance, will be displayed according to the format rules
    of the set culture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文化设置对数据类型（如日期和数字）在UI中显示时的格式化有直接影响。当你设置`CultureInfo.CurrentCulture`时，它也会影响数据绑定场景中的格式化。这意味着例如`DateTime`值将根据设置文化的格式规则显示。
- en: 'Let’s say we have a `DateTime` property in our ViewModel:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在ViewModel中有一个`DateTime`属性：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And we are binding this property to a `Label` in XAML:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此属性绑定到XAML中的`Label`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because we are not specifying how the data should be formatted, the `ToString`
    method will be called on the `DateTime` object, and that result will be shown
    on the screen. The `ToString` method will take the current culture settings into
    account. As a result, if the culture is set to US English (`en-US`), the date
    will be formatted as `7/3/2020 12:00:00 AM`, whereas if the culture is set to
    French (`fr-FR`), the date will appear as `03/07/2020 00:00:00`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有指定数据应该如何格式化，`ToString` 方法将被调用在 `DateTime` 对象上，并且该结果将显示在屏幕上。`ToString`
    方法将考虑当前的文化设置。因此，如果文化设置为美国英语（`en-US`），日期将格式化为 `7/3/2020 12:00:00 AM`，而如果文化设置为法语（`fr-FR`），日期将显示为
    `03/07/2020 00:00:00`。
- en: 'The `StringFormat` property in XAML binding expressions allows us to define
    custom formatting for data types such as `DateTime`. What’s great is that `StringFormat`
    will also respect the current culture settings, so it’s a fantastic way to combine
    customization with localization. For instance, we could use `StringFormat` in
    XAML to specify how you’d like that date to appear:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: XAML 绑定表达式中的 `StringFormat` 属性允许我们为 `DateTime` 等数据类型定义自定义格式化。最棒的是，`StringFormat`
    也会尊重当前的文化设置，因此这是一种将定制与本地化结合的绝佳方式。例如，我们可以在 XAML 中使用 `StringFormat` 来指定日期的显示方式：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, `StringFormat` is set to display the full month name, the day,
    and the full year. In US English, it will be displayed as `July 3, 2020`, whereas
    when the app’s culture is set to French, the date will automatically adjust to
    `juillet 3, 2020`. The format specified in `StringFormat` remains consistent,
    but the actual string values for the day and month adapt to the set culture.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`StringFormat` 被设置为显示完整的月份名称、日期和完整的年份。在美国英语中，它将显示为 `July 3, 2020`，而当应用程序的文化设置为法语时，日期将自动调整为
    `juillet 3, 2020`。`StringFormat` 中指定的格式保持一致，但日期和月份的实际字符串值将适应设置的文化。
- en: The same principles apply to number formatting. Different cultures have various
    ways of representing numbers, particularly when it comes to separating thousands
    and decimal points. By being mindful of the culture settings, we ensure that our
    application displays numbers in a format that is both familiar and understandable
    to the user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则适用于数字格式化。不同的文化有不同的数字表示方式，尤其是在分隔千位和小数点时。通过注意文化设置，我们确保我们的应用程序以用户熟悉且易于理解的方式显示数字。
- en: In contrast to the `CurrentCulture` property, the `CurrentUICulture` property
    determines the language that is being used in the app. So, let’s have a look at
    how this can be managed through resource files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `CurrentCulture` 属性相反，`CurrentUICulture` 属性确定应用程序中使用的语言。因此，让我们看看如何通过资源文件来管理这一点。
- en: What are Resources Files?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源文件是什么？
- en: 'Resources Files are a core feature of the .NET ecosystem, used to facilitate
    localization across a wide array of application types. Typically named with a
    `.resx` extension, these XML-based files allow you to define key-value pairs where
    the key represents a specific piece of text or asset in your application, and
    the value represents its localized equivalent. Visual Studio even provides an
    editor for `.resx` files, allowing developers to easily define keys and their
    value (*Figure 12**.1*):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件是 .NET 生态系统的一个核心功能，用于在广泛的应用程序类型之间促进本地化。通常以 `.resx` 扩展名命名，这些基于 XML 的文件允许你定义键值对，其中键代表应用程序中的特定文本或资产，值代表其本地化等效项。Visual
    Studio 还提供了 `.resx` 文件的编辑器，允许开发者轻松定义键及其值（*图 12**.1*）：
- en: '![Figure 12.1: Visual Studio .resx designer](img/B20941_12_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1：Visual Studio .resx 设计器](img/B20941_12_01.jpg)'
- en: 'Figure 12.1: Visual Studio .resx designer'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：Visual Studio .resx 设计器
- en: What’s particularly handy is that a strongly typed class is automatically generated
    when you create a `.resx` file. This class allows us to access localized resources
    programmatically in a type-safe manner, eliminating the need to manually look
    up resource keys in your code. The name of this autogenerated class is derived
    from the name of the `resx` file itself. For example, if the resource file is
    named `AppResources.resx`, the generated class will be named `AppResources`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 特别方便的是，当你创建 `.resx` 文件时，会自动生成一个强类型类。这个类允许我们以类型安全的方式以编程方式访问本地化资源，从而消除了在代码中手动查找资源键的需要。这个自动生成的类的名称是从
    `resx` 文件本身的名称派生出来的。例如，如果资源文件命名为 `AppResources.resx`，则生成的类将命名为 `AppResources`。
- en: By suffixing the name of the file, we can specify which culture a specific resource
    file belongs to – for example, `AppResources.resx` for the default culture of
    the app (let’s say English), `AppResources.fr-FR.resx` for French, `AppResources.es-ES.resx`
    for Spanish, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给文件名添加后缀，我们可以指定特定资源文件属于哪种文化——例如，`AppResources.resx`是应用程序的默认文化（比如说英语），`AppResources.fr-FR.resx`是法语，`AppResources.es-ES.resx`是西班牙语，等等。
- en: '.NET MAUI will look in the `.resx` file that corresponds with the set culture
    for the requested value. Fetching a localized string can be done as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI将查找与请求的值对应的设置文化对应的`.resx`文件。获取本地化字符串可以像这里所示那样进行：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the current UI culture is set to French (`fr-FR`), .NET MAUI will automatically
    look for `AddAsFavorite` in the `AppResources.fr-FR.resx` file. If there is no
    resource file matching the current UI culture, the default file (the one without
    a suffix) will be used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前UI文化设置为法语（`fr-FR`），.NET MAUI将自动在`AppResources.fr-FR.resx`文件中查找`AddAsFavorite`。如果不存在与当前UI文化匹配的资源文件，将使用默认文件（不带后缀的文件）。
- en: 'Alternatively, retrieving a value for the `AddAsFavorite` key can also be done
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，检索`AddAsFavorite`键的值也可以这样做：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A static property will be generated in the `AppResources` class for every key
    in the `.resx` file. These properties utilize `ResourceManager`’s `GetString`
    method to retrieve the corresponding value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`.resx`文件中的每个键，`AppResources`类将生成一个静态属性。这些属性使用`ResourceManager`的`GetString`方法检索相应的值。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to note that the generated class will only be based on the default
    resource file. This means that only properties will be generated for the keys
    in the default file. So, it is very important to have the same keys in each of
    the different culture-specific files! Resolving a value for a key that is not
    present in the resource file of the current UI culture will result in an exception!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，生成的类将仅基于默认资源文件。这意味着只为默认文件中的键生成属性。因此，在各个不同文化特定的文件中保持相同的键非常重要！如果当前UI文化的资源文件中不存在键的值，将导致异常！
- en: 'Let’s add some resource files to our solution:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的解决方案中添加一些资源文件：
- en: Right-click the `Resources` folder in the `Recipes.Mobile` project and select
    `Strings`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Recipes.Mobile`项目中的`Resources`文件夹，然后选择`Strings`。
- en: Right-click this folder and select **Add** | **New Item…**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击此文件夹，然后选择**添加** | **新建项…**。
- en: 'In the `resources`, select the `AppResources.resx` as the name (*Figure 12**.2*):'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources`中，选择`AppResources.resx`作为名称（*图12**.2*）：
- en: '![Figure 12.2: Creating a new Resources File](img/B20941_12_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：创建新的资源文件](img/B20941_12_02.jpg)'
- en: 'Figure 12.2: Creating a new Resources File'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：创建新的资源文件
- en: 'Double-check the newly created file’s properties in the **Properties** window.
    The **Build Action** property should be set to **Embedded resource**, and the
    **Custom Tool** property should be set to **ResXFileCodeGenerator**, as *Figure*
    *12**.3* shows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**窗口中双检查新创建的文件属性。**构建操作**属性应设置为**嵌入资源**，**自定义工具**属性应设置为**ResXFileCodeGenerator**，如图*12**.3*所示：
- en: '![Figure 12.3: Properties of the AppResources.resx file](img/B20941_12_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：AppResources.resx文件的属性](img/B20941_12_03.jpg)'
- en: 'Figure 12.3: Properties of the AppResources.resx file'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：AppResources.resx文件的属性
- en: Add a second `AppResources.fr-FR.resx`. Note that only the default resource
    file has its **Custom Tool** property set to **ResXFileCodeGenerator**. Other
    resource files will not have this property set, but their **Build Action** property
    does have to be set to **Embedded resource** as well.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个`AppResources.fr-FR.resx`。请注意，只有默认资源文件的**自定义工具**属性设置为**ResXFileCodeGenerator**。其他资源文件将不会设置此属性，但它们的**构建操作**属性也必须设置为**嵌入资源**。
- en: In the `Chapter 12``/Resources` folder, you will find an `AppResources.resx`
    file and an `AppResources.fr-FR.resx` file containing the English and French resources
    respectively. Copy them over to the `Strings` folder in Visual Studio and override
    the files you just created.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter 12/Resources`文件夹中，你会找到一个`AppResources.resx`文件和一个`AppResources.fr-FR.resx`文件，分别包含英语和法语资源。将它们复制到Visual
    Studio中的`Strings`文件夹，并覆盖你刚刚创建的文件。
- en: With this in place, let’s have a look at how we can get those values on the
    screen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们看看如何将这些值显示在屏幕上。
- en: Getting localized resources on the screen
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在屏幕上获取本地化资源
- en: 'In its simplest form, we can use the `x:Static` markup extension. This markup
    extension is used to reference static fields or properties from a specified class.
    As mentioned earlier, the generated `AppResources` class has a static property
    for each of the keys in the `x:Static` markup extension to reference the localized
    values. Let’s see how we can add this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单形式中，我们可以使用 `x:Static` 标记扩展。此标记扩展用于从指定的类中引用静态字段或属性。如前所述，生成的 `AppResources`
    类为 `x:Static` 标记扩展中的每个键都有一个静态属性来引用本地化值。让我们看看我们如何添加它：
- en: 'Add the following code to the `CreateMauiApp` method of the `MauiProgram` class:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `MauiProgram` 类的 `CreateMauiApp` 方法中：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will force the app’s culture to French.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将强制应用的文化设置为法语。
- en: 'Go to `AppShell.xaml` and add an XML namespace pointing to the namespace of
    the `AppResources` class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `AppShell.xaml` 并添加一个指向 `AppResources` 类命名空间的 XML 命名空间：
- en: 'Next, update the `Title` property of the first `Tab` element to the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新第一个 `Tab` 元素的 `Title` 属性为以下内容：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By leveraging the `x:Static` markup extension, we are pointing to the static
    `Tab1Title` property of the `AppResources` class.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过利用 `x:Static` 标记扩展，我们正在指向 `AppResources` 类的静态 `Tab1Title` 属性。
- en: 'The `Title` property of the second `Tab` element should point to the `Tab2Title`
    property as shown here:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个 `Tab` 元素的 `Title` 属性应指向 `Tab2Title` 属性，如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And finally, for this first example, head over to `RecipeDetailPage` and find
    the `MultiBinding` on the label that shows the `LastUpdated` and `Author` properties.
    The `x:Static` markup extension can also be used on the `StringFormat` property
    on a binding statement, as shown here:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于这个第一个例子，前往 `RecipeDetailPage` 并找到显示 `LastUpdated` 和 `Author` 属性的标签上的 `MultiBinding`。`x:Static`
    标记扩展也可以用于绑定语句上的 `StringFormat` 属性，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It’s worth mentioning that `ModifiedDateAuthorFormat` contains a `D` format
    specifier that represents a long date pattern. As a result, the notation of the
    date will be different depending on the selected culture. For example, when `CurrentCulture`
    is set to French (`fr-FR`), July 3, 2020, will be shown as `vendredi 3` `juillet
    2020`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，`ModifiedDateAuthorFormat` 包含一个表示长日期模式的 `D` 格式说明符。因此，日期的表示将根据所选文化而有所不同。例如，当
    `CurrentCulture` 设置为法语 (`fr-FR`) 时，2020 年 7 月 3 日将显示为 `vendredi 3` `juillet 2020`。
- en: 'If we now run the app, we should immediately see that the titles of the two
    main tabs are now in French, as *Figure* *12**.4* shows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用，我们应该立即看到两个主要标签的标题现在已变为法语，如图 *12**.4* 所示：
- en: '![Figure 12.4: Localized tab titles](img/B20941_12_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4：本地化标签标题](img/B20941_12_04.jpg)'
- en: 'Figure 12.4: Localized tab titles'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：本地化标签标题
- en: 'When navigating to `RecipeDetailPage`, the label showing the `LastUpdated`
    and `Author` properties is now also translated. Now, go ahead and change the culture
    in the `CreateMauiApp` method to `nl-BE`. Run the app, and you should see the
    localized labels in English. That’s because there is no resource file for this
    culture, so the default one is used. Do note that the date is being formatted
    according to the Dutch (Belgium) notation: `vrijdag 3` `juli 2020`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航到 `RecipeDetailPage` 时，显示 `LastUpdated` 和 `Author` 属性的标签现在也已翻译。现在，前往 `CreateMauiApp`
    方法并更改文化为 `nl-BE`。运行应用，你应该会看到英文的本地化标签。这是因为没有为这种文化提供资源文件，所以使用默认的。请注意，日期是根据荷兰（比利时）的格式进行格式化的：`vrijdag
    3` `juli 2020`。
- en: 'As said, this approach is the simplest form of getting the localized resources
    on the screen. This is a perfectly valid approach, but it’s not very MVVM-friendly,
    and it has its limitations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这种方法是获取屏幕上本地化资源的最简单形式。这是一个完全有效的方法，但它不是非常 MVVM 友好，并且有其局限性：
- en: The biggest limitation is that `x:Static` doesn’t react to changes. If you change
    the value of the static property at runtime, the UI will not update to reflect
    the new value. This makes it unsuitable for scenarios where the localized text
    might change dynamically, such as when a user switches languages in-app. Only
    when navigating to a new page will the `x:Static` markup extension load the required
    values for the newly selected culture. When navigating (back) to pages that are
    in memory, the values of the previous culture will still be there.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的限制是 `x:Static` 无法响应变化。如果在运行时更改静态属性的值，UI 不会更新以反映新值。这使得它不适合本地化文本可能动态变化的情况，例如当用户在应用内切换语言时。只有当导航到新页面时，`x:Static`
    标记扩展才会加载新选择的文化所需值。当导航（返回）到内存中的页面时，前一个文化的值仍然存在。
- en: There is no way to access these resources from within our ViewModels. This can
    be an issue if we want to show dialogs or alerts from a ViewModel.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法从我们的ViewModel中访问这些资源。如果我们想从ViewModel中显示对话框或警报，这可能会成为一个问题。
- en: 'So far, we’ve laid down the essential groundwork for understanding localization
    in .NET MAUI, including the role of resource files, the `CultureInfo` class, and
    the `x:Static` markup extension. While the methods and concepts we’ve discussed
    so far form the essential backbone of localization in .NET MAUI, our next section
    will explore how to seamlessly integrate them into MVVM. Ultimately, our goal
    is to make use of data binding to connect our UI to localized values. This enables
    dynamic updates: if the user switches languages or cultures during runtime, the
    displayed text will automatically reflect these changes.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为理解.NET MAUI中的本地化奠定了基本的基础，包括资源文件的作用、`CultureInfo`类和`x:Static`标记扩展。虽然我们迄今为止讨论的方法和概念构成了.NET
    MAUI本地化的基本骨架，但我们的下一节将探讨如何无缝地将它们集成到MVVM中。最终，我们的目标是利用数据绑定将我们的UI连接到本地化值。这实现了动态更新：如果用户在运行时切换语言或文化，显示的文本将自动反映这些更改。
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The properties on a binding statement such as `StringFormat`, `FallbackValue`,
    and `TargetNullValue` aren’t bindable properties. This means that the only way
    to assign values from a resource file to these properties is by leveraging the
    `x:Static` markup extension, with its limitations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定语句上的属性，如`StringFormat`、`FallbackValue`和`TargetNullValue`，不是可绑定属性。这意味着将这些属性从资源文件中赋值的唯一方法是通过利用`x:Static`标记扩展，尽管它有其局限性。
- en: Looking at a localization solution for MVVM
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看MVVM的本地化解决方案
- en: In this section, we’ll look at a solution that’s not just functional but also
    fits well with the MVVM architectural pattern. Whether you need to localize text
    within your ViewModels or dynamically update language in your UI, this approach
    has you covered. It’s a solution that I’ve personally implemented in numerous
    projects over the years. While I’ve made some refinements along the way, the core
    concept has stood the test of time and proven its effectiveness in real-world
    applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个不仅功能性强，而且与MVVM架构模式相得益彰的解决方案。无论您需要在本地的ViewModel中本地化文本，还是动态更新UI中的语言，这种方法都能满足您的需求。这是我多年来在众多项目中亲自实施过的解决方案。虽然我在过程中做了一些改进，但核心概念经受住了时间的考验，并在实际应用中证明了其有效性。
- en: Warning – culture settings are thread-specific
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 – 文化设置是线程特定的
- en: When allowing the user to switch cultures inside the app, we should be wary
    of the fact that when updating `CultureInfo` inside `async` operations, those
    changes will not automatically propagate to the parent thread. A localization
    strategy needs to be designed with this in mind to avoid inconsistencies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当允许用户在应用程序内切换文化时，我们应该警惕这样一个事实：在`async`操作中更新`CultureInfo`时，这些更改不会自动传播到父线程。需要设计一个考虑到这一点的本地化策略，以避免不一致性。
- en: 'In the code accompanying this chapter, two new projects have been added: `Localization`
    and `Localization.Maui`. The primary objective of the `Localization` project is
    to provide a framework-agnostic approach to manage and access localization settings
    and resources. By encapsulating this localization logic within its own project,
    we facilitate easy code sharing across different projects, paving the way for
    potential packaging and reuse in other projects.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的代码中，新增了两个项目：`Localization`和`Localization.Maui`。`Localization`项目的主要目标是提供一个与框架无关的方法来管理和访问本地化设置和资源。通过将本地化逻辑封装在其自己的项目中，我们促进了不同项目之间的代码共享，为在其他项目中打包和重用铺平了道路。
- en: On the other hand, the `Localization.Maui` project is tailored specifically
    for .NET MAUI. It houses the code responsible for storing and retrieving localization
    information. Putting this logic separately from the rest of our *Recipes!* app
    code allows us to ensure that it remains modular and reusable for other .NET MAUI
    applications. Let’s discuss the `Localization` project first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Localization.Maui`项目专门针对.NET MAUI进行定制。它包含了存储和检索本地化信息的代码。将此逻辑与其他*Recipes!*应用程序代码分开，使我们能够确保它保持模块化和可重用性，适用于其他.NET
    MAUI应用程序。让我们首先讨论`Localization`项目。
- en: The Localization project
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化项目
- en: 'Let’s take a look at the `ILocalizationManager` interface in the `Localization`
    project:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`Localization`项目中的`ILocalizationManager`接口：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ILocalizationManager` interface defines three methods for managing localization
    settings:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILocalizationManager`接口定义了三种用于管理本地化设置的方法：'
- en: '`RestorePreviousCulture` is a method that can be used to restore the previous
    culture used by the user. The `defaultCulture` parameter can be used to specify
    a fallback culture in case there is no previous culture set.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RestorePreviousCulture`是一个可以用来恢复用户之前使用的文化的函数。可以使用`defaultCulture`参数指定一个回退文化，以防没有设置之前的文化。'
- en: '`UpdateUserCulture` updates and stores the culture settings for the current
    user. The `cultureInfo` parameter specifies the new culture to use.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateUserCulture`更新并存储当前用户的语言设置。`cultureInfo`参数指定了要使用的新文化。'
- en: The `GetUserCulture` method retrieves the stored culture settings. The `defaultCulture`
    parameter can be used to specify a fallback culture in case there is no culture
    set.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetUserCulture`方法检索存储的文化设置。可以使用`defaultCulture`参数指定一个回退文化，以防没有设置文化。'
- en: The primary intent behind this interface is to abstract tasks related to the
    persistence and retrieval of user-specified cultures. In the context of a .NET
    MAUI-specific implementation, we might, for instance, opt to save the most recently
    chosen `CultureInfo` within `Preferences`, ensuring it’s available the next time
    the app launches so that it can be restored. We’ll delve deeper into this specific
    approach shortly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口的主要目的是抽象与用户指定文化的持久化和检索相关的任务。在.NET MAUI特定实现的背景下，例如，我们可能会选择将最近选择的`CultureInfo`保存在`Preferences`中，以确保在下次应用启动时可用，以便可以恢复。我们将在稍后深入了解这一特定方法。
- en: 'The second interface in the `Localization` project is the `ILocalizedResourcesProvider`
    interface. Let’s see what this looks like:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Localization`项目中的第二个接口是`ILocalizedResourcesProvider`接口。让我们看看它是什么样子：'
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At its core, this interface facilitates the retrieval of localized string values
    that align with the user’s chosen `CultureInfo`. It provides a read-only indexer
    to fetch the localized string corresponding to a specified key. Additionally,
    the `UpdateCulture` method lets you modify the current `CultureInfo`, ensuring
    that subsequent localized string retrievals reflect the updated cultural context.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，此接口促进了与用户选择的`CultureInfo`相匹配的本地化字符串值的检索。它提供了一个只读索引器来获取与指定键对应的本地化字符串。此外，`UpdateCulture`方法允许您修改当前的`CultureInfo`，确保后续的本地化字符串检索反映了更新的文化上下文。
- en: 'Next, we’ll explore the `Localization` project’s concrete implementation of
    the `ILocalizedResourceProvider` interface – namely, `LocalizedResourcesProvider`.
    Let’s start by looking at its constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索`Localization`项目中`ILocalizedResourceProvider`接口的具体实现——即`LocalizedResourcesProvider`。让我们首先看看它的构造函数：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The constructor takes a single parameter, `resourceManager`. This is the `ResourceManager`
    that needs to be used to retrieve the localized values. The `currentCulture` field
    is initialized with a default value, being the current UI culture. Within the
    constructor, the current instance is assigned to the static `Instance` property.
    This allows us to access this `LocalizedResourcesProvider` implementation through
    a static property, which will be handy in data-binding scenarios, as we’ll see
    later on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个参数，`resourceManager`。这是需要用来检索本地化值的`ResourceManager`。`currentCulture`字段使用默认值初始化，即当前的UI文化。在构造函数中，当前实例被分配给静态的`Instance`属性。这允许我们通过静态属性访问此`LocalizedResourcesProvider`实现，这在数据绑定场景中将会很有用，正如我们稍后将会看到的。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Assigning the current instance of `LocalizedResourcesProvider` to the static
    `Instance` property means there can only be one `LocalizedResourcesProvider` implementation
    throughout the app. While this is a limitation to be wary of, it should not pose
    a significant problem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前`LocalizedResourcesProvider`实例分配给静态的`Instance`属性意味着在整个应用中只能有一个`LocalizedResourcesProvider`实现。虽然这是一个需要注意的限制，但它不应造成重大问题。
- en: 'The indexer of this class allows us to get the localized string value for a
    given key. Here’s how this is implemented:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的索引器允许我们获取给定键的本地化字符串值。以下是其实施方式：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the key exists within our resources, the method fetches the corresponding
    localized string using the `currentCulture`. However, if the provided key doesn’t
    match any resource key, the key itself is returned as a fallback. It’s crucial
    to observe that we’re passing the `currentCulture` explicitly when calling `GetString`.
    This ensures that the `resourceManager` fetches values specific to the provided
    `currentCulture`, rather than defaulting to the `CultureInfo` of the currently
    executing thread. This design choice addresses potential challenges arising from
    culture settings being thread-specific.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当键存在于我们的资源中时，该方法使用 `currentCulture` 获取相应的本地化字符串。然而，如果提供的键不匹配任何资源键，则键本身将作为后备返回。重要的是要注意，我们在调用
    `GetString` 时明确传递了 `currentCulture`。这确保了 `resourceManager` 获取特定于提供的 `currentCulture`
    的值，而不是默认使用当前执行线程的 `CultureInfo`。这种设计选择解决了由文化设置线程特定性引起的问题。
- en: 'Now, let’s look at the `UpdateCulture` method within the `LocalizedResourcesProvider`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `LocalizedResourcesProvider` 中的 `UpdateCulture` 方法：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method updates the `currentCulture` field. As a result, any subsequent
    calls to the class’s indexer will retrieve the localized string value for the
    given key, based on the updated `currentCulture`. Additionally, the method calls
    the `OnPropertyChanged` method, sending `Item` as its argument. In scenarios involving
    data binding, this prompts a re-evaluation of all bindings linked to the indexer.
    Consequently, any values that are data-bound to this indexer will refresh, returning
    the localized strings of the updated `CultureInfo`. Let’s transition our focus
    to the `Localization.Maui` project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法更新 `currentCulture` 字段。因此，任何后续对该类索引器的调用都将根据更新的 `currentCulture` 获取给定键的本地化字符串值。此外，该方法调用
    `OnPropertyChanged` 方法，将 `Item` 作为其参数。在涉及数据绑定的场景中，这会提示重新评估所有与索引器链接的绑定。因此，任何绑定到此索引器的值都将刷新，返回更新后的
    `CultureInfo` 的本地化字符串。让我们将注意力转向 `Localization.Maui` 项目。
- en: The Localization.Maui project
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The Localization.Maui project
- en: 'The `LocalizationManager` class in the `Localization.Maui` project is an implementation
    of the `ILocaliazationManager`. It has a dependency on `ILocalizedResourcesProvider`,
    as you can see here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Localization.Maui` 项目中的 `LocalizationManager` 类是 `ILocaliazationManager` 的一个实现。它依赖于
    `ILocalizedResourcesProvider`，正如你在这里看到的：'
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By having this reference, we can, later on, call its `UpdateCulture` method,
    keeping the updated culture in sync with the `ILocalizedResourcesProvider`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有这个引用，我们可以在以后调用它的 `UpdateCulture` 方法，保持更新后的文化与 `ILocalizedResourcesProvider`
    保持同步。
- en: 'The `LocalizationManager` class should also store the selected `CultureInfo`
    so that it can be retrieved on subsequent app launches and restore the previous
    `CultureInfo`. The following code block shows how the `UpdateUserCulture` uses
    the `Preferences` API to store the given `CultureInfo`, assigns the updated value
    to the `currentCulture` field, updates the static properties on the `CultureInfo`
    object, and calls the `ILocalizedResourcesProvider`’s `UpdateCulture` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalizationManager` 类也应该存储选定的 `CultureInfo`，以便在后续的应用程序启动时检索并恢复之前的 `CultureInfo`。以下代码块展示了
    `UpdateUserCulture` 如何使用 `Preferences` API 存储给定的 `CultureInfo`，将更新后的值分配给 `currentCulture`
    字段，更新 `CultureInfo` 对象上的静态属性，并调用 `ILocalizedResourcesProvider` 的 `UpdateCulture`
    方法：'
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how the updates on the `CultureInfo` object are dispatched to the main
    thread. Remember the note about `CultureInfo` being bound to the current thread?
    We want to ensure that the main thread’s `CultureInfo` is updated to maintain
    consistency. Failing to apply these changes to the main thread could result in
    data binding using the outdated or previous `CultureInfo`. This misalignment can
    lead to inaccuracies when formatting data, such as displaying `DateTime` objects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到对 `CultureInfo` 对象的更新是如何派发到主线程的。还记得关于 `CultureInfo` 与当前线程绑定的说明吗？我们想要确保主线程的
    `CultureInfo` 被更新以保持一致性。未能将这些更改应用到主线程可能会导致使用过时或之前的 `CultureInfo` 进行数据绑定。这种不匹配可能导致在格式化数据时出现不准确，例如显示
    `DateTime` 对象。
- en: 'The `GetUserCulture` method first checks if its `currentCulture` field is set.
    If it is, that value is returned directly. If not, the method tries to retrieve
    the culture based on the `UserCulture` key from `Preferences`. If no value is
    found there, it either resorts to the provided `defaultCulture` parameter or,
    in its absence, the current system culture. Once determined, this culture is assigned
    to the `currentCulture` field, which is then returned. Take a look:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetUserCulture` 方法首先检查其 `currentCulture` 字段是否已设置。如果是，则直接返回该值。如果不是，该方法尝试根据
    `Preferences` 中的 `UserCulture` 键检索文化。如果没有找到值，它将回退到提供的 `defaultCulture` 参数，或者在没有提供的情况下，使用当前系统文化。一旦确定，此文化将被分配给
    `currentCulture` 字段，然后返回。请看以下内容：'
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, the `RestorePreviousCulture` method uses the `GetUserCutlure` method
    to retrieve the previously used culture and passes this on to the `SetCulture`
    method, as you can see here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`RestorePreviousCulture` 方法使用 `GetUserCulture` 方法检索之前使用的文化，并将其传递给 `SetCulture`
    方法，正如您在这里所看到的：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method can be used when the app starts to set the current culture to the
    culture that the user selected previously.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，可以使用此方法将当前文化设置为用户之前选择的文化。
- en: 'Now that we’re familiar with the roles and workings of these classes, let’s
    integrate them into the *Recipes!* app. This will enable us to handle localization
    in a manner that complements the MVVM architectural pattern. Here’s a step-by-step
    guide:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了这些类的角色和工作原理，让我们将它们集成到 *Recipes!* 应用程序中。这将使我们能够以补充 MVVM 架构模式的方式处理本地化。以下是一个分步指南：
- en: 'Go to `MauiProgram.cs` and add the following line of code to the `CreateMauiApp`
    method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 并在 `CreateMauiApp` 方法中添加以下代码行：
- en: '[PRE23]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This registers an instance of `LocalizationManager` to the DI container.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此操作将 `LocalizationManager` 的一个实例注册到依赖注入容器中。
- en: 'Create an instance of `LocalizedResourcesProvider`. Pass the `ResourceManager`
    of `AppResources` to its constructor, allowing `LocalizedResourceProvider` to
    access the resources defined in the `AppResources` files:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `LocalizedResourcesProvider` 的实例。将 `AppResources` 的 `ResourceManager` 传递给其构造函数，允许
    `LocalizedResourceProvider` 访问在 `AppResources` 文件中定义的资源：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s register this `LocalizedResourcesProvider` as `Singleton` to the DI container,
    as shown here:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将此 `LocalizedResourcesProvider` 注册为 `Singleton` 到依赖注入容器中，如下所示：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By doing this, we’re ensuring a single instance of the `LocalizedResourcesProvider`
    class is used throughout the app. Any time this instance is resolved through DI,
    it’s guaranteed to be the same as that referred to by the `LocalizedResourcesProvider`’s
    static `Instance` property. This is essential for accessing localized resources
    consistently across the application.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这样做，我们确保在整个应用程序中只使用 `LocalizedResourcesProvider` 类的单个实例。每次通过依赖注入解析此实例时，它都保证与
    `LocalizedResourcesProvider` 的静态 `Instance` 属性所引用的是同一个实例。这对于在应用程序中一致地访问本地化资源至关重要。
- en: This sets the foundation for a solid localization solution that is ready to
    be used in our app. Let’s see how we can integrate the `LocalizedResourcesProvider`
    and `LocalizationManager` in our app.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这为构建一个稳固的本地化解决方案奠定了基础，该解决方案可以用于我们的应用程序。让我们看看我们如何在应用程序中集成 `LocalizedResourcesProvider`
    和 `LocalizationManager`。
- en: Using the LocalizedResourcesProvider and LocalizationManager
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 LocalizedResourcesProvider 和 LocalizationManager
- en: 'Let’s take a look at how we can use the `LocalizedResourcesProvider` and `LocalizationManager`
    to access localized resources from within a ViewModel. On the `SettingsPage`,
    the user can select a new language through the `PickLanguagePage`. When selecting
    a language, a prompt should ask, in the current language, whether the user wants
    to switch. After switching, an alert in the updated language should confirm the
    update. Here’s how we can do this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用 `LocalizedResourcesProvider` 和 `LocalizationManager` 从 ViewModel
    内部访问本地化资源。在 `SettingsPage` 上，用户可以通过 `PickLanguagePage` 选择新的语言。在选择语言时，应提示用户是否想要切换，当前语言下的提示。切换后，应以更新后的语言显示一个确认更新的警报。以下是我们可以这样做的方法：
- en: 'First, let’s add the following two fields to `SettingsViewModel`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向 `SettingsViewModel` 添加以下两个字段：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The DI container will automatically inject these additional dependencies into
    the constructor.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 依赖注入容器将自动将这些额外的依赖项注入到构造函数中。
- en: 'Next, we can update the `ConfirmSwitchLanguage` method to this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以更新 `ConfirmSwitchLanguage` 方法如下：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See how we use the `_resources` field to fetch localized strings, which are
    then passed to the `IDialogService`’s `AskYesNo` method. The keys exactly match
    the keys present in the `AppResources` files.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看我们如何使用 `_resources` 字段来检索本地化字符串，然后将其传递给 `IDialogService` 的 `AskYesNo` 方法。键与
    `AppResources` 文件中存在的键完全匹配。
- en: 'Likewise, we can also update the `NotifySwitch` method, as shown here:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们也可以更新 `NotifySwitch` 方法，如下所示：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lastly, we need to add the following line of code to the `SwitchLanguage` method:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在 `SwitchLanguage` 方法中添加以下代码行：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method is called when the user has confirmed switching to the new language.
    By calling the `_localizationManager`’s `UpdateUserCulture`, we’ll be persisting
    the selected culture, updating the `CultureInfo` properties, and notifying the
    `ILocalizedResourcesProvider` about the updated culture. As a result, subsequential
    calls to the `_resources` field will retrieve the localized values for the updated
    `CultureInfo`.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户确认切换到新语言时，将调用此方法。通过调用 `_localizationManager` 的 `UpdateUserCulture`，我们将持久化所选文化，更新
    `CultureInfo` 属性，并通知 `ILocalizedResourcesProvider` 关于更新的文化。因此，后续对 `_resources`
    字段的调用将检索更新后的 `CultureInfo` 的本地化值。
- en: 'We can now run the app, go to the `SettingsPage`, and click through to the
    `PickLanguagePage`, where we can change the language of the app. Once a new language
    is chosen, we automatically navigate back to the `SettingsPage`, where we’ll get
    a prompt in the current language of the app (*Figure 12**.5*):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行应用程序，转到 `SettingsPage`，然后点击到 `PickLanguagePage`，在那里我们可以更改应用程序的语言。一旦选择了新语言，我们将自动导航回
    `SettingsPage`，在那里我们将以应用程序的当前语言收到提示（*图 12.5*）：
- en: '![Figure 12.5: Prompt in English](img/B20941_12_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5：英语提示](img/B20941_12_05.jpg)'
- en: 'Figure 12.5: Prompt in English'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：英语提示
- en: 'After confirmation, the language will be updated, and we’ll see an alert in
    the new language (*Figure 12**.6*):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 确认后，语言将更新，我们将看到新语言中的警报（*图 12.6*）：
- en: '![Figure 12.6: Alert in French](img/B20941_12_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6：法语警报](img/B20941_12_06.jpg)'
- en: 'Figure 12.6: Alert in French'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：法语警报
- en: The fact that we can switch cultures from within our ViewModels and retrieve
    localized string values for the currently set culture is already very exciting!
    But how do we handle the localization in our Views if we want them to update to
    the newly selected culture as well? Let’s have a look!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的 ViewModels 中切换文化，并检索当前设置文化的本地化字符串值，这已经非常令人兴奋了！但如果我们想让它们也更新到新选定的文化，我们如何在视图中处理本地化？让我们看看！
- en: 'Go to `SettingsPage.xml` and add the following XML namespace:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `SettingsPage.xml` 并添加以下 XML 命名空间：
- en: '[PRE30]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This namespace points to the `Localization` namespace of the `Localization`
    project.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命名空间指向 `Localization` 项目的 `Localization` 命名空间。
- en: 'Update the `Text` property of the **Select Language** button to the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **选择语言** 按钮的 `Text` 属性更新为以下内容：
- en: '[PRE31]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we saw in the `LocalizedResourcesProvider`’s implementation, the indexer
    takes a provided key and fetches the corresponding localized string using the
    configured `ResourceManager`.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们在 `LocalizedResourcesProvider` 的实现中看到的，索引器接受提供的键，并使用配置的 `ResourceManager`
    获取相应的本地化字符串。
- en: 'Let’s also update the text of the `LocalizedResourcesProvider`, as shown here:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们同样更新 `LocalizedResourcesProvider` 的文本，如下所示：
- en: '[PRE32]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And while we’re at it, let’s also update the page’s title as well:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，让我们也更新页面的标题：
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Take a look at the `Text` property of the label that shows the current selected
    language:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下显示当前选中语言的标签的 `Text` 属性：
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With these changes in place, run the app again. Go to the `SettingsPage` and
    select a different language. After confirming to switch the language of the app,
    you should not only see the alert in the updated language appearing but also see
    that the labels on the `SettingsPage` instantly update (*Figure 12**.7*)!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这些更改后，再次运行应用程序。转到 `SettingsPage` 并选择不同的语言。在确认切换应用程序的语言后，您不仅应该看到更新的语言中的警报出现，而且应该看到
    `SettingsPage` 上的标签立即更新（*图 12.7*）！
- en: '![Figure 12.7: The Settings page before (left) and after (right) switching
    to French](img/B20941_12_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7：切换到法语之前（左）和之后（右）的设置页面](img/B20941_12_07.jpg)'
- en: 'Figure 12.7: The Settings page before (left) and after (right) switching to
    French'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：切换到法语之前（左）和之后（右）的设置页面
- en: The magic happens because our bindings target the indexer of the `LocalizedResourcesProvider`
    class. Thus, any trigger of the `PropertyChanged` event (with `Item` as the property
    name) will prompt a re-evaluation of these bindings. Triggering the `PropertyChanged`
    event is done because the `LocalizationManager` calls the `UpdateCulture` method
    on its `_resourceProvider` field.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 奇迹发生是因为我们的绑定针对的是`LocalizedResourcesProvider`类的索引器。因此，任何触发`PropertyChanged`事件（`Item`作为属性名）都会促使这些绑定重新评估。触发`PropertyChanged`事件是因为`LocalizationManager`在其`_resourceProvider`字段上调用`UpdateCulture`方法。
- en: 'Currently, the selected culture isn’t persisted across app launches. To be
    exact: the selected culture does get stored, but it is not being restored when
    the application starts. We can easily add that functionality by updating the constructor
    of the `App` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所选的文化没有在应用程序启动之间持久化。更准确地说：所选的文化确实被存储了，但在应用程序启动时并没有被恢复。我们可以很容易地通过更新`App`类的构造函数来添加这个功能：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: By calling the `RestorePreviousCulture` on the injected `ILocalizationManager`
    interface, the previously set culture is being restored. It’s done in the constructor
    of the `App` class so that it is applied early on in the application’s life cycle.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在注入的`ILocalizationManager`接口上调用`RestorePreviousCulture`，正在恢复之前设置的 culture。这是在`App`类的构造函数中完成的，以便在应用程序的生命周期早期应用。
- en: Personally, I think this is a beautiful and very MVVM-friendly solution to localization;
    well, except for the rather complex data-binding statements we have to put in
    place. In the next section, we’ll see how we can improve on that.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 个人认为，这是一个美丽且非常MVVM友好的本地化解决方案；好吧，除了我们必须放置的相当复杂的数据绑定语句。在下一节中，我们将看到如何改进这一点。
- en: Using a custom Translate markup extension
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义的Translate标记扩展
- en: 'We previously set up a localization solution for our app. While it works effectively,
    the data-binding statements were a bit verbose and would have to be repeated for
    each string. Building on that foundation, in this section, we’ll introduce a streamlined
    approach: a custom markup extension designed specifically for translations.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前为我们的应用程序设置了一个本地化解决方案。虽然它非常有效，但数据绑定语句有点冗长，并且必须为每个字符串重复。在这个基础上，在本节中，我们将介绍一种简化的方法：一个专门为翻译设计的自定义标记扩展。
- en: But before we proceed, let’s briefly revisit what markup extensions are. **Markup
    extensions** provide a way to compute or retrieve property values at runtime rather
    than just setting them to static values. This functionality makes them particularly
    handy for tasks such as resource lookups, data binding, or, in our case, simplifying
    translation retrieval.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们简要回顾一下标记扩展是什么。**标记扩展**提供了一种在运行时计算或检索属性值的方法，而不是仅仅将它们设置为静态值。这种功能使它们在诸如资源查找、数据绑定或在我们的情况下简化翻译检索等任务中特别有用。
- en: 'It’s important to note that we’re not changing how we leverage data binding
    to bind to our resources. Instead, we’re just making the XAML code easier to write
    and read. The actual data-binding process stays the same. This is essentially
    what the `Translate` markup extension will look like in XAML:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们并没有改变我们利用数据绑定绑定到资源的方式。相反，我们只是使XAML代码更容易编写和阅读。实际的数据绑定过程保持不变。这就是`Translate`标记扩展在XAML中的基本样子：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is synonymous with the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容同义：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Translate` markup extension is a wrapper around a conventional data-binding
    statement. Let’s take a look at the `TranslateExtension` class in the `Localization.Maui`
    project. This class implements the generic `IMarkupExtension` interface, and as
    a result, it needs to implement the following methods:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Translate`标记扩展是一个常规数据绑定语句的包装器。让我们看看`Localization.Maui`项目中的`TranslateExtension`类。这个类实现了泛型的`IMarkupExtension`接口，因此它需要实现以下方法：'
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The non-generic `ProvideValue` method will be called at runtime and must return
    the value we want to be using in our XAML. In this case, we want to return a `Binding`.
    Here’s how it’s implemented:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型的`ProvideValue`方法将在运行时被调用，并且必须返回我们想要在XAML中使用的值。在这种情况下，我们想要返回一个`Binding`。以下是它的实现方式：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The non-generic `ProvideValue` method calls its generic version, which returns
    a `Binding`. The class has a property named `Key`, which represents the key used
    to fetch the localized value. This `Key` property can be assigned in the markup
    extension, as shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型的`ProvideValue`方法调用其泛型版本，该版本返回一个`Binding`。该类有一个名为`Key`的属性，它表示用于获取本地化值的键。这个`Key`属性可以在标记扩展中分配，如下所示：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: public Binding ProvideValue(
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: public Binding ProvideValue(
- en: IServiceProvider serviceProvider)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: IServiceProvider serviceProvider)
- en: => new Binding
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: => new Binding
- en: '{'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Mode = BindingMode.OneWay,
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Mode = BindingMode.OneWay,
- en: Path = $"[{Key}]",
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Path = $"[{Key}]",
- en: Source = LocalizedResourcesProvider.Instance
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Source = LocalizedResourcesProvider.Instance
- en: '};'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '{x:Static localization:LocalizedResourcesProvider.Instance}'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '{x:Static localization:LocalizedResourcesProvider.Instance}'
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: xmlns:mauiloc="clr-namespace:Localization.Maui;
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:mauiloc="clr-namespace:Localization.Maui;
- en: assembly=Localization.Maui"
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assembly=Localization.Maui"
- en: '[PRE43]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '...'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: Title="{mauiloc:Translate SettingsTitle}"
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Title="{mauiloc:Translate SettingsTitle}"
- en: '...'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: Text="{mauiloc:Translate ChooseLanguage}"
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text="{mauiloc:Translate ChooseLanguage}"
- en: '...'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: Text="{mauiloc:Translate About}"
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text="{mauiloc:Translate About}"
- en: '...'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <Tab Title="{mauiloc:Translate Tab1Title}">
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Tab Title="{mauiloc:Translate Tab1Title}">
- en: '...'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: </Tab>
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </Tab>
- en: <Tab Title="{mauiloc:Translate Tab2Title}">
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Tab Title="{mauiloc:Translate Tab2Title}">
- en: '...'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: </Tab>
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </Tab>
- en: '[PRE45]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Task<ApiResponse<RecipeOverviewItemsDto>>
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Task<ApiResponse<RecipeOverviewItemsDto>>
- en: GetRecipes([Header("Accept-Language")] string
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GetRecipes([Header("Accept-Language")] string
- en: Header attribute, but I think this approach is a lot cleaner.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Header 属性，但我认为这种方法更简洁。
- en: '[PRE46]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: readonly ILocalizationManager _localizationManager;
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: readonly ILocalizationManager _localizationManager;
- en: '...'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: public RecipeApiGateway(IRecipeApi api,
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public RecipeApiGateway(IRecipeApi api,
- en: ILocalizationManager localizationManager)
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ILocalizationManager localizationManager)
- en: '{'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: _api = api;
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _api = api;
- en: _localizationManager = localizationManager;
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _localizationManager = localizationManager;
- en: '}'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE47]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: public Task<Result<LoadRecipesResponse>>
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public Task<Result<LoadRecipesResponse>>
- en: LoadRecipes(int pageSize, int page)
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LoadRecipes(int pageSize, int page)
- en: => InvokeAndMap(_api.GetRecipes(
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: => InvokeAndMap(_api.GetRecipes(
- en: _localizationManager.GetUserCulture().Name,
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _localizationManager.GetUserCulture().Name,
- en: pageSize, page), MapRecipesOverview);
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pageSize, page), MapRecipesOverview);
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: app.MapGet("/recipes", (int pageSize, int pageIndex,
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.MapGet("/recipes", (int pageSize, int pageIndex,
- en: '[FromHeader(Name = "Accept-Language")] string'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[FromHeader(Name = "Accept-Language")] string'
- en: language) =>
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: language) =>
- en: '{'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: //use language to retrieve recipes
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: //使用语言来检索菜谱
- en: return new RecipeService()
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new RecipeService()
- en: .LoadRecipes(pageSize, pageIndex);
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .LoadRecipes(pageSize, pageIndex);
- en: '})'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: .WithName("GetRecipes")
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .WithName("GetRecipes")
- en: .WithOpenApi();
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .WithOpenApi();
- en: '[PRE49]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'public class CultureChangedMessage :'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'public class CultureChangedMessage :'
- en: ValueChangedMessage<CultureInfo>
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ValueChangedMessage<CultureInfo>
- en: '{'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: 'public CultureChangedMessage(CultureInfo value) :'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'public CultureChangedMessage(CultureInfo value) :'
- en: base(value)
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: base(value)
- en: '{ }'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{ }'
- en: '}'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE50]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: private void SwitchLanguage(string newLanguage)
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private void SwitchLanguage(string newLanguage)
- en: '{'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: CurrentLanguage = newLanguage;
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CurrentLanguage = newLanguage;
- en: var newCulture = new CultureInfo(newLanguage);
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var newCulture = new CultureInfo(newLanguage);
- en: _localizationManager
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _localizationManager
- en: .UpdateUserCulture(newCulture);
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .UpdateUserCulture(newCulture);
- en: WeakReferenceMessenger.Default.Send(
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WeakReferenceMessenger.Default.Send(
- en: new CultureChangedMessage(newCulture));
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: new CultureChangedMessage(newCulture));
- en: '}'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE51]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: WeakReferenceMessenger.Default
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WeakReferenceMessenger.Default
- en: .Register<CultureChangedMessage>(this, (r, m) =>
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .Register<CultureChangedMessage>(this, (r, m) =>
- en: '{'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: Recipes.Clear();
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Recipes.Clear();
- en: (r as RecipesOverviewViewModel).LoadRecipes(7, 0);
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (r as RecipesOverviewViewModel).LoadRecipes(7, 0);
- en: '});'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE52]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
