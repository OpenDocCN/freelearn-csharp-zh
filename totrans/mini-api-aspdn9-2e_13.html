<html><head></head><body>
  <div id="_idContainer083">
   <h1 class="chapter-number" id="_idParaDest-153">
    <a id="_idTextAnchor183">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     13
    </span>
   </h1>
   <h1 id="_idParaDest-154">
    <a id="_idTextAnchor184">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Best Practices for Minimal API Resiliency
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Like any software system, minimal APIs can be built in many ways.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     By carefully choosing and applying different patterns and following some set practices, an application can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      greatly enhanced.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     There are several good reasons to build patterns into the design of your minimal API, the first being readability.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Since most of us are part of a team and may have other developers to delegate or hand over code, making it as accessible as possible is paramount.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     By ensuring that your endpoints are tidy, that code is as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.6.1">
      self-documenting
     </span>
    </em>
    <span class="koboSpan" id="kobo.7.1">
     as possible, and that the naming conventions are consistent, it will be relatively straightforward for another developer to support the maintenance of an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      API project.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     Next is scalability.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     If the volume of requests grows, so will the need to optimize an application.
    </span>
    <span class="koboSpan" id="kobo.9.3">
     Consistency and good design make meeting demands simple.
    </span>
    <span class="koboSpan" id="kobo.9.4">
     Whether adding a load balancer to manage traffic flow or changing the data storage method, it is essential to design APIs in such a way that modifications to the system—whether adding or removing components—do not break functionality across the application.away parts of the system does not break functionality across
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      the application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     Finally, security is equally important.
    </span>
    <span class="koboSpan" id="kobo.11.2">
     By following best security practices such as encryption at rest and in transit, password hashing and salting, and scoped access, sensitive data can be managed securely, reducing the risk of a breach and the ensuing legal challenges that present themselves as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      a result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.13.1">
     Ultimately, achieving these goals depends on applying practices that concern the way a code base is structured for readability, the way unexpected and fatal scenarios are dealt with in error handling, and the considerations applied from a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      cybersecurity perspective.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.15.1">
     Let’s realize some of these benefits in your minimal API projects by exploring some design practices and coding conventions that can improve the quality of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      your code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.17.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.18.1">
      main topics
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.19.1">
      :
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      Code organization
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       and structure
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       Error handling
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       Security considerations
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.24.1">
     Let’s get
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      into it!
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-155">
    <a id="_idTextAnchor185">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     Visual Studio 2022 or the latest version of Visual Studio code is recommended to run the code from this chapter.
    </span>
    <span class="koboSpan" id="kobo.27.2">
     The code examples for this chapter are available in the GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      at:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.29.1">
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     One of the examples uses code from
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.32.1">
      Chapters 9
     </span>
    </em>
    <span class="koboSpan" id="kobo.33.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.34.1">
      12
     </span>
    </em>
    <span class="koboSpan" id="kobo.35.1">
     , both of which have a dependency on Entity Framework Core.
    </span>
    <span class="koboSpan" id="kobo.35.2">
     It is recommended that you complete those chapters before
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      this one.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-156">
    <a id="_idTextAnchor186">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     Code organization and structure
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     Perhaps the most important thing to understand about organizing and structuring code in any system is that there is no one correct way to do it.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     While there are some widely accepted structural patterns, this can be quite a personal topic, as a structure must serve the maintainer.
    </span>
    <span class="koboSpan" id="kobo.38.3">
     However, as
    </span>
    <a id="_idIndexMarker505">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     we have previously confirmed, most minimal API systems in a commercial or open-source setting will have multiple maintainers, so a consistent structure will make it as easy as possible for developers to collaborate on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      code base.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     We will explore two examples of ways that a project can be organized, both sharing one key theme –
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      modularity.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.43.1">
      Modularity
     </span>
    </strong>
    <span class="koboSpan" id="kobo.44.1">
     is the practice of
    </span>
    <a id="_idIndexMarker506">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     organizing and structuring your code into smaller, self-contained, and reusable units or modules.
    </span>
    <span class="koboSpan" id="kobo.45.2">
     Let’s break down some of the benefits of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      this practice:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.47.1">
       Separation of concerns
      </span>
     </strong>
     <span class="koboSpan" id="kobo.48.1">
      : By grouping
     </span>
     <a id="_idIndexMarker507">
     </a>
     <span class="koboSpan" id="kobo.49.1">
      together code containing similar functionality, we create contexts within the
     </span>
     <a id="_idIndexMarker508">
     </a>
     <span class="koboSpan" id="kobo.50.1">
      code base that mirror the business domains they serve.
     </span>
     <span class="koboSpan" id="kobo.50.2">
      For example, code that is solely based on the context of managing users is separate from code that is solely based on managing products.
     </span>
     <span class="koboSpan" id="kobo.50.3">
      Establishing clear boundaries between these contexts ensures that dependencies
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.51.1">
       are minimized.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.52.1">
       Reusability
      </span>
     </strong>
     <span class="koboSpan" id="kobo.53.1">
      : Adopting a modular design allows you to create components such as the ones we explored in this book – for example, services and middleware.
     </span>
     <span class="koboSpan" id="kobo.53.2">
      In a system where separation
     </span>
     <a id="_idIndexMarker509">
     </a>
     <span class="koboSpan" id="kobo.54.1">
      of concerns is the aim, having reusable components can help bridge contexts as necessary in a way that reduces the creation
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.55.1">
       of dependencies.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.56.1">
       Ease of maintenance
      </span>
     </strong>
     <span class="koboSpan" id="kobo.57.1">
      : Modules can be developed and tested independently of each other, making parallel development between multiple developers easier.
     </span>
     <span class="koboSpan" id="kobo.57.2">
      Modularization also supports the open-closed principle, which states, “
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.58.1">
       Software entities (classes, modules, functions, etc.) should be open for extension, but closed
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.59.1">
        for modification.
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.60.1">
       ”
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.61.1">
     This means that, in an ideal world, whenever we want to extend our minimal API with new functionality, we
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.62.1">
      do
     </span>
    </em>
    <span class="koboSpan" id="kobo.63.1">
     not need to change the existing code base to enable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      the change.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     Effective organization of code is often dominated by architectural design patterns.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     While this is certainly important, simply reorganizing the folder structure of a project goes a long way to making code readable and simpler
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      to maintain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     Let’s explore some example
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.68.1">
      folder structures.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-157">
    <a id="_idTextAnchor187">
    </a>
    <span class="koboSpan" id="kobo.69.1">
     Exploring folder structures
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     Most of the time, simple consideration of the way a project’s folders are arranged within a project can significantly improve the readability and maintainability of a minimal API.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     We’re looking for a
    </span>
    <a id="_idIndexMarker510">
    </a>
    <span class="koboSpan" id="kobo.71.1">
     consistent system to lay out classes and interfaces.
    </span>
    <span class="koboSpan" id="kobo.71.2">
     Let’s look at some specific folder structures that we can apply to our projects to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      achieve this.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-158">
    <a id="_idTextAnchor188">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     Feature-based modular structure
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     In this structure, the
    </span>
    <a id="_idIndexMarker511">
    </a>
    <span class="koboSpan" id="kobo.75.1">
     minimal API project is organized by features, with
    </span>
    <a id="_idIndexMarker512">
    </a>
    <span class="koboSpan" id="kobo.76.1">
     each feature having its own folder, containing everything related to that feature, regardless of what kind of component is used.
    </span>
    <span class="koboSpan" id="kobo.76.2">
     Here’s an
    </span>
    <a id="_idIndexMarker513">
    </a>
    <span class="koboSpan" id="kobo.77.1">
     example of such
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      a structure:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.79.1">
/src
  /MyMinimalApiProject
    /Modules
      /Users
        UserEndpoints.cs
        UserService.cs
        UserRepository.cs
        User.cs
        UserDto.cs
        UserValidator.cs
      /Products
        ProductEndpoints.cs
        ProductService.cs
        ProductRepository.cs
        Product.cs
        ProductDto.cs
        ProductValidator.cs
    /Middleware
      ErrorHandlingMiddleware.cs
      AuthenticationMiddleware.cs
    /Configuration
      SwaggerConfig.cs
      DependencyInjectionConfig.cs
    /Utils
      DateTimeHelper.cs
      LoggingHelper.cs
    Program.cs
    appsettings.json</span></pre>
   <p>
    <span class="koboSpan" id="kobo.80.1">
     In this structure, the developer is expected to adopt a feature-based mindset.
    </span>
    <span class="koboSpan" id="kobo.80.2">
     For example, if you want to add an endpoint relating to user management, you would head to a folder based on users rather than one dedicated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      to endpoints.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     As mentioned earlier in the
    </span>
    <a id="_idIndexMarker514">
    </a>
    <span class="koboSpan" id="kobo.83.1">
     chapter, folder structures can be a personal and somewhat polarizing topic.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     Some may not prefer to mix component
    </span>
    <a id="_idIndexMarker515">
    </a>
    <span class="koboSpan" id="kobo.84.1">
     types under the banner of a feature set, while others enjoy the domain-based nature of this structure and are less concerned with what kind of component acts within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.85.1">
      each domain.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-159">
    <a id="_idTextAnchor189">
    </a>
    <span class="koboSpan" id="kobo.86.1">
     Layered modular structure
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.87.1">
     This structure is the one I prefer personally because I tend to think about the type of component before I think about the feature or business domain.
    </span>
    <span class="koboSpan" id="kobo.87.2">
     In a layered modular structure, the project is first
    </span>
    <a id="_idIndexMarker516">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     grouped by components (e.g., endpoints and
    </span>
    <a id="_idIndexMarker517">
    </a>
    <span class="koboSpan" id="kobo.89.1">
     services) and then further broken down into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      business modules/features.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     If you are like me and tend to think about the kind of class or file that I am looking to create or edit before I think about the domain in which it lives, this folder structure will work better for you.
    </span>
    <span class="koboSpan" id="kobo.91.2">
     However, it’s important to note that while this kind of structure prioritizes component types when creating folders, there is still a dedicated
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.92.1">
      Domain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.93.1">
     folder that exists to hold entity
    </span>
    <a id="_idIndexMarker518">
    </a>
    <span class="koboSpan" id="kobo.94.1">
     models and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.95.1">
      Data Transfer Objects
     </span>
    </strong>
    <span class="koboSpan" id="kobo.96.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.97.1">
      DTO
     </span>
    </strong>
    <span class="koboSpan" id="kobo.98.1">
     s), which describe the business domain.
    </span>
    <span class="koboSpan" id="kobo.98.2">
     Here is an example of a layered modular file structure in a minimal
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.99.1">
      API project:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.100.1">
/src
  /MyMinimalApiProject
    /Endpoints
      /Users
        UserEndpoints.cs
        UserValidator.cs
      /Products
        ProductEndpoints.cs
        ProductValidator.cs
    /Services
      /Users
        UserService.cs
      /Products
        ProductService.cs
    /Repositories
      /Users
        UserRepository.cs
      /Products
        ProductRepository.cs
    /Domain
      /Entities
        User.cs
        Product.cs
      /DTOs
        UserDto.cs
        ProductDto.cs
    /Middleware
      ErrorHandlingMiddleware.cs
      AuthenticationMiddleware.cs
    /Configuration
      SwaggerConfig.cs
      DependencyInjectionConfig.cs
    /Utils
      DateTimeHelper.cs
      LoggingHelper.cs
    Program.cs
    appsettings.json</span></pre>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     Now that we’ve explored some simple examples of how folders can be structured within a minimal API project, let’s look at
    </span>
    <a id="_idIndexMarker519">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     some repeatable patterns that can be adopted when structuring a project’s code.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     These patterns are
    </span>
    <a id="_idIndexMarker520">
    </a>
    <span class="koboSpan" id="kobo.103.1">
     referred to as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.104.1">
      design patterns
     </span>
    </em>
    <span class="koboSpan" id="kobo.105.1">
     , and like folder structure, there is debate around which patterns constitute
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.106.1">
      best practice.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-160">
    <a id="_idTextAnchor190">
    </a>
    <span class="koboSpan" id="kobo.107.1">
     Design patterns
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.108.1">
     This book is not designed to tell you which patterns are the best; rather, it is designed to give you some guidance on how
    </span>
    <a id="_idIndexMarker521">
    </a>
    <span class="koboSpan" id="kobo.109.1">
     you can structure your code consistently to create a consistent API system.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     Here are some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      example
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker522">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      patterns.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-161">
    <a id="_idTextAnchor191">
    </a>
    <span class="koboSpan" id="kobo.112.1">
     The factory pattern
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.114.1">
      factory pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.115.1">
     is designed to
    </span>
    <a id="_idIndexMarker523">
    </a>
    <span class="koboSpan" id="kobo.116.1">
     create objects without specifying the exact class of object that will be created.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     Earlier, I mentioned the open/closed principle, and factory patterns help minimal APIs adhere to this principle by closing the code for modification while making it open
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      for extension.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.118.1">
     Let’s consider an example use
    </span>
    <a id="_idIndexMarker524">
    </a>
    <span class="koboSpan" id="kobo.119.1">
     case in which you want to create logs in different locations.
    </span>
    <span class="koboSpan" id="kobo.119.2">
     One location is via a database, and another is in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      text file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     In the future, you may want to add more log sources, such as a Webhook or third-party API.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     A factory could help you retrieve the correct logger for your use case while making it simple to add new loggers without changing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.122.1">
      old ones.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.123.1">
     Let’s look at an example of how we can improve logging by implementing a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.124.1">
      factory pattern:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.125.1">
      First, create an interface called
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.126.1">
       ILogger
      </span>
     </strong>
     <span class="koboSpan" id="kobo.127.1">
      , which will be implemented by all loggers, regardless of the specific log they execute when saving a log to their respective source.
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.128.1">
       ILogger
      </span>
     </strong>
     <span class="koboSpan" id="kobo.129.1">
      is an
     </span>
     <a id="_idIndexMarker525">
     </a>
     <span class="koboSpan" id="kobo.130.1">
      interface that will represent an object that implements logic for the purposes of writing logs to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.131.1">
       different sources:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.132.1">
public interface ILogger
{
    void Log(string message);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.133.1">
      Next, create two classes that each implement
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.134.1">
       ILogger
      </span>
     </strong>
     <span class="koboSpan" id="kobo.135.1">
      .
     </span>
     <span class="koboSpan" id="kobo.135.2">
      One of the classes,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.136.1">
       FileLogger
      </span>
     </strong>
     <span class="koboSpan" id="kobo.137.1">
      , will be
     </span>
     <a id="_idIndexMarker526">
     </a>
     <span class="koboSpan" id="kobo.138.1">
      used to log to a file, and another,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.139.1">
       DatabaseLogger
      </span>
     </strong>
     <span class="koboSpan" id="kobo.140.1">
      ,  will log to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.141.1">
       a database:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.142.1">
public class FileLogger : ILogger
{
    public void Log(string message)
    {
        // Logic to log to a file
    }
}
public class DatabaseLogger : ILogger
{
    public void Log(string message)
    {
        // Logic to log to a database
    }
}</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.143.1">
       These classes may have different names, but they are both an
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.144.1">
        ILogger
       </span>
      </strong>
      <span class="koboSpan" id="kobo.145.1">
       object meaning that they must
      </span>
      <a id="_idIndexMarker527">
      </a>
      <span class="koboSpan" id="kobo.146.1">
       implement the
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.147.1">
         Log()
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.148.1">
        method.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.149.1">
      Furthermore, we can
     </span>
     <a id="_idIndexMarker528">
     </a>
     <span class="koboSpan" id="kobo.150.1">
      create a function that returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.151.1">
       ILogger
      </span>
     </strong>
     <span class="koboSpan" id="kobo.152.1">
      , as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.153.1">
       shown here:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.154.1">
public static class LoggerFactory
{
    public static ILogger CreateLogger(
        string loggerType
    )
    {
        return loggerType switch
        {
            "File" =&gt; new FileLogger(),
            "Database" =&gt; new DatabaseLogger(),
            _ =&gt; throw new ArgumentException(
            "Invalid logger type")
        };
    }
}</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.155.1">
     In this example, we created a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      LoggerFactory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     class with a function that returns the relevant logger class, depending on the contents of a string that was entered by the caller.
    </span>
    <span class="koboSpan" id="kobo.157.2">
     If the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      loggerType
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     parameter is not valid, an exception is thrown, allowing the error to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      be handled.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.161.1">
     The main benefit to this is that to add another logger, we simply create a new class that implements
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      ILogger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     before adding a new entry to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.164.1">
      switch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     statement in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      CreateLogger()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     .
    </span>
    <span class="koboSpan" id="kobo.167.2">
     We haven’t had to
    </span>
    <a id="_idIndexMarker529">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     introduce any breaking changes to extend the types of loggers that are supported in
    </span>
    <a id="_idIndexMarker530">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.169.1">
      the API.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-162">
    <a id="_idTextAnchor192">
    </a>
    <span class="koboSpan" id="kobo.170.1">
     The repository pattern
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     This pattern creates an
    </span>
    <a id="_idIndexMarker531">
    </a>
    <span class="koboSpan" id="kobo.172.1">
     abstraction layer for data access logic, providing a more general API to access data from a database for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.173.1">
      minimal API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.174.1">
     Earlier in the book, we explored
    </span>
    <a id="_idIndexMarker532">
    </a>
    <span class="koboSpan" id="kobo.175.1">
     Entity Framework Core to access data from a database.
    </span>
    <span class="koboSpan" id="kobo.175.2">
     Simply by using Entity Framework Core, your code already uses a repository pattern because it provides an implementation of the repository pattern that utilizes the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.176.1">
      built-in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.177.1">
       DBContext
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     However, it is still worth implementing a custom repository pattern to handle data so that you further generalize the solution, meaning that Entity Framework Core could be swapped out of the minimal API application without affecting the overall data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      access logic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.181.1">
     To create a repository pattern on top of Entity Framework Core, we can simply create a class for each entity in the database.
    </span>
    <span class="koboSpan" id="kobo.181.2">
     Each repository class receives the Entity Framework context via dependency injection, and then the generic
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.182.1">
      Create, Read, Update, Delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.183.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.184.1">
      CRUD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.185.1">
     ) operations for this entity
    </span>
    <a id="_idIndexMarker533">
    </a>
    <span class="koboSpan" id="kobo.186.1">
     can be added.
    </span>
    <span class="koboSpan" id="kobo.186.2">
     Following this, each repository can be also registered for dependency injection for use elsewhere in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      an application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     In the following example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      EmployeeRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     reflects the available data operations available for an employee entity.
    </span>
    <span class="koboSpan" id="kobo.190.2">
     As described, the Entity Framework context is injected as the data access layer to be used within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.191.1">
      the repository:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.192.1">
public class EmployeeRepository : IEmployeeRepository
{
    private readonly MyCompanyContext _context;
    public EmployeeRepository(MyCompanyContext context)
    {
        _context = context;
    }
    public async Task&lt;Employee&gt; GetByIdAsync(int id)
    {
        return await _context.Employees.FindAsync(id);
    }
    public async Task&lt;IEnumerable&lt;Employee&gt;&gt; GetAllAsync()
    {
        return await _context.Employees.ToListAsync();
    }
    public async Task AddAsync(Employee employee)
    {
        await _context.Employees.AddAsync(employee);
        await _context.SaveChangesAsync();
    }
    public async Task UpdateAsync(Employee employee)
    {
        _context.Employees.Update(employee);
        await _context.SaveChangesAsync();
    }
    public async Task DeleteAsync(int id)
    {
        var employee = await
            _context.Employees.FindAsync(id);
        if (employee != null)
        {
            _context.Employees.Remove(employee);
            await _context.SaveChangesAsync();
        }
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.193.1">
     Going forward, if a decision is made to replace Entity Framework Core, the only thing that needs to change is the repository.
    </span>
    <span class="koboSpan" id="kobo.193.2">
     The consumers of the repository would not be affected because the
    </span>
    <a id="_idIndexMarker534">
    </a>
    <span class="koboSpan" id="kobo.194.1">
     methods and functions they call within the repository
    </span>
    <a id="_idIndexMarker535">
    </a>
    <span class="koboSpan" id="kobo.195.1">
     would maintain their original signatures, despite their underlying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      logic changing.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-163">
    <a id="_idTextAnchor193">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     The strategy pattern
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.199.1">
      Strategy pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.200.1">
     allows us to define a family of algorithms, each one represented by a class.
    </span>
    <span class="koboSpan" id="kobo.200.2">
     This pattern is very
    </span>
    <a id="_idIndexMarker536">
    </a>
    <span class="koboSpan" id="kobo.201.1">
     powerful in situations where there are multiple ways of
    </span>
    <a id="_idIndexMarker537">
    </a>
    <span class="koboSpan" id="kobo.202.1">
     executing an operation, as you can seamlessly switch between them in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.203.1">
      dynamic fashion.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.204.1">
     Let’s look at an example involving a minimal API endpoint that calculates how much annual leave an employee has.
    </span>
    <span class="koboSpan" id="kobo.204.2">
     In this example, there are different ways to calculate leave based on various factors, such as which country the employee is in, whether they are in their probationary period, and how many years they have served at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.205.1">
      the company.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.206.1">
     Here is an example outline of the logic to calculate leave (not related to any specific labor laws in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      any country!):
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.208.1">
      If the employee is in their probationary period, the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.209.1">
       following applies:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.210.1">
        The minimum amount of leave awarded is
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.211.1">
         10 days
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.212.1">
        If the employee is based in the United Kingdom, they get an extra
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.213.1">
         three days
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.214.1">
      If the employee is not on probation, the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.215.1">
       following applies:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.216.1">
        The minimum amount of leave awarded is
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.217.1">
         16 days
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.218.1">
        If the employee is based in the United Kingdom, they get an extra
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.219.1">
         three days
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.220.1">
        For each year of service, an extra day
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.221.1">
         is awarded
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.222.1">
     There are a lot of factors in play here, but to start with, we can narrow down the operations required to calculate leave based on whether the employee is or is not on probation.
    </span>
    <span class="koboSpan" id="kobo.222.2">
     This means we have
    </span>
    <a id="_idIndexMarker538">
    </a>
    <span class="koboSpan" id="kobo.223.1">
     two strategies to calculate leave, which we can switch to automatically.
    </span>
    <span class="koboSpan" id="kobo.223.2">
     How do we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.224.1">
      achieve this?
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.225.1">
      First, we create
     </span>
     <a id="_idIndexMarker539">
     </a>
     <span class="koboSpan" id="kobo.226.1">
      an interface to represent a strategy.
     </span>
     <span class="koboSpan" id="kobo.226.2">
      It stipulates that we require a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.227.1">
       CalculateLeaveAllowance()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.228.1">
      function taking a parameter of type
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.229.1">
       Employee
      </span>
     </strong>
     <span class="koboSpan" id="kobo.230.1">
      and returning
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.231.1">
       an integer:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.232.1">
public interface IAnnualLeaveStrategy
{
    int CalculateLeaveAllowance(
        Models.Employee employee
    );
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.233.1">
      Then, we’ll create
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.234.1">
       ProbationaryAnnualLeaveStrategy
      </span>
     </strong>
     <span class="koboSpan" id="kobo.235.1">
      , which implements the interface.
     </span>
     <span class="koboSpan" id="kobo.235.2">
      Within this class,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.236.1">
       CalculateLeaveAllowance
      </span>
     </strong>
     <span class="koboSpan" id="kobo.237.1">
      will encapsulate the logic to calculate the total leave available for a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.238.1">
       probationary employee:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.239.1">
public class ProbationaryAnnualLeaveStrategy
    : IAnnualLeaveStrategy
{
    public int CalculateLeaveAllowance(
        Models.Employee employee
    )
    {
        var leaveTotal = 10;
        if(employee.Country == "United Kingdom")
        {
            leaveTotal += 3;
        }
        return leaveTotal;
    }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.240.1">
      Then, the same can
     </span>
     <a id="_idIndexMarker540">
     </a>
     <span class="koboSpan" id="kobo.241.1">
      be done for an employee who is not
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.242.1">
       on
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker541">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.243.1">
       probation:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.244.1">
public class PostProbationaryAnnualLeaveStrategy
    : IAnnualLeaveStrategy
{
    public int CalculateLeaveAllowance(
        Models.Employee employee
    )
    {
        var leaveTotal = 16;
        if(employee.Country == "United Kingdom")
        {
            leaveTotal += 3;
        }
    leaveTotal += employee.YearsOfService;
        return leaveTotal;
    }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.245.1">
      The two strategies should be registered for dependency injection
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.246.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.247.1">
        Program.cs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.248.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.249.1">
            builder.Services
              .AddScoped&lt;
                ProbationaryAnnualLeaveStrategy
              &gt;();
            builder.Services
              .AddScoped&lt;
                PostProbationaryAnnualLeaveStrategy
              &gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.250.1">
      Finally, an endpoint
     </span>
     <a id="_idIndexMarker542">
     </a>
     <span class="koboSpan" id="kobo.251.1">
      can be created to calculate the annual leave for a given
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.252.1">
       Employee
      </span>
     </strong>
     <span class="koboSpan" id="kobo.253.1">
      ID.
     </span>
     <span class="koboSpan" id="kobo.253.2">
      Within the endpoint, we create the strategy based on whether or not the employee is on probation.
     </span>
     <span class="koboSpan" id="kobo.253.3">
      We then retrieve
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.254.1">
       Employee
      </span>
     </strong>
     <span class="koboSpan" id="kobo.255.1">
      using the ID sent by the client and call the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.256.1">
       CalculateLeaveAllowance()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.257.1">
      function to get the result.
     </span>
     <span class="koboSpan" id="kobo.257.2">
      This way, the appropriate strategy is automatically
     </span>
     <a id="_idIndexMarker543">
     </a>
     <span class="koboSpan" id="kobo.258.1">
      used to execute the correct logic, based on the data that was sent by the client in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.259.1">
       the request:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.260.1">
app.MapGet(
    "/calculate-employee-leave-allowance/
        {employeeId}",
    async (int employeeId,
        bool employeeOnProbation,
        [FromServices]
        EmployeeService employeeService) =&gt;
{
    IAnnualLeaveStrategy annualLeaveStrategy =
        employeeOnProbation
          ? </span><span class="koboSpan" id="kobo.260.2">new ProbationaryAnnualLeaveStrategy()
          : new PostProbationaryAnnualLeaveStrategy();
    var employee = await
        employeeService.GetEmployeeById(employeeId);
    return annualLeaveStrategy
        .CalculateLeaveAllowance(employee);
});</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     By separating logic into individual
    </span>
    <a id="_idIndexMarker544">
    </a>
    <span class="koboSpan" id="kobo.262.1">
     strategies, the Strategy pattern allows minimal APIs to conform to the open/closed
    </span>
    <a id="_idIndexMarker545">
    </a>
    <span class="koboSpan" id="kobo.263.1">
     principle.
    </span>
    <span class="koboSpan" id="kobo.263.2">
     It does that by allowing us to extend the code base with new functionality, rather than alter the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.264.1">
      existing code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.265.1">
     It also offers self-containment, meaning that ways of performing similar tasks do not cross-contaminate each other, which reduces the potential
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.266.1">
      for bugs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.267.1">
     Design patterns alone do not make a resilient system.
    </span>
    <span class="koboSpan" id="kobo.267.2">
     Resiliency is achieved through a good understanding of where and how
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      errors occur.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.269.1">
     Years of service property required
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.270.1">
     The example in this section will work with the original
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     object used in
    </span>
    <a href="B20968_09.xhtml#_idTextAnchor143">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.273.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.274.1">
     if you add an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.275.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     property, called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      YearsOfService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     .
    </span>
    <span class="koboSpan" id="kobo.278.2">
     We assume that you will have done this before attempting to follow this strategy
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.279.1">
      pattern example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     With that in mind, let’s move on to explore good practices around error handling in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.281.1">
      minimal APIs.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-164">
    <a id="_idTextAnchor194">
    </a>
    <span class="koboSpan" id="kobo.282.1">
     Error Handling
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     When it comes to the topic of error
    </span>
    <a id="_idIndexMarker546">
    </a>
    <span class="koboSpan" id="kobo.284.1">
     handling and resilience, the first is the method and the second is the outcome.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     By
    </span>
    <a id="_idIndexMarker547">
    </a>
    <span class="koboSpan" id="kobo.285.1">
     implementing effective error handling, we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.286.1">
      achieve resilience.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.287.1">
     So, while using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.288.1">
      try/catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.289.1">
     across the code base is important, a standardized manner of handling errors at the top level is still critical.
    </span>
    <span class="koboSpan" id="kobo.289.2">
     For a minimal API, middleware is an effective way to handle errors from the top level.
    </span>
    <span class="koboSpan" id="kobo.289.3">
     Let’s explore
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      an example.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.291.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.292.1">
     This section assumes that you read
    </span>
    <a href="B20968_05.xhtml#_idTextAnchor094">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.293.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.294.1">
     or that you already have an in-depth understanding of how to write middleware
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.295.1">
      in ASP.NET.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.296.1">
     Implementing middleware ensures that we have a global solution to error handling in a minimal API.
    </span>
    <span class="koboSpan" id="kobo.296.2">
     Think of it as a giant
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.297.1">
      try/catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.298.1">
     that wraps around all of your minimal
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.299.1">
      API’s endpoints.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.300.1">
     As we explored middleware extensively in
    </span>
    <a href="B20968_05.xhtml#_idTextAnchor094">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.301.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.302.1">
     , we do not need to go through the specifics of how middleware is built, so we shall dive straight into an example of an error-handling middleware class, as shown in the upcoming
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.303.1">
      code blocks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.304.1">
     First, we create a class for the middleware, along with a constructor and an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.305.1">
      InvokeAsync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.306.1">
     method that can be used to initiate the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.307.1">
      middleware’s logic:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.308.1">
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger&lt;ErrorHandlingMiddleware&gt;
        _logger;
    public ErrorHandlingMiddleware(
        RequestDelegate next,
        ILogger&lt;ErrorHandlingMiddleware&gt; logger
    )
    {
        _next = next;
        _logger = logger;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex, "An unhandled exception occurred."
</span><span class="koboSpan" id="kobo.308.2">            );
            await HandleExceptionAsync(context, ex);
        }
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.309.1">
     Following this, we can add a method
    </span>
    <a id="_idIndexMarker548">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     that takes in the current
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.311.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     to handle any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      detected errors:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.314.1">
    private static Task HandleExceptionAsync(
        HttpContext context, Exception exception)
    {
    If (context.Response.HasStarted) return;
    context.Response.ContentType = "application/json";
    context.Response.StatusCode =
        (int)HttpStatusCode.InternalServerError;
        var response = new
        {
            message =
                "An unexpected error occurred. </span><span class="koboSpan" id="kobo.314.2">Please try
                again later.",
            details = exception.Message
        };
        return context.Response.WriteAsJsonAsync(response);
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.315.1">
     It is worth noting that this middleware example for error handling could easily replace the similar error handling example in
    </span>
    <a href="B20968_05.xhtml#_idTextAnchor094">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.316.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.318.1">
     This middleware will catch an exception thrown higher up in the request pipeline, ensuring that the error is returned
    </span>
    <a id="_idIndexMarker549">
    </a>
    <span class="koboSpan" id="kobo.319.1">
     to the requesting client via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     .
    </span>
    <span class="koboSpan" id="kobo.321.2">
     This ensures a consistent error response to the client regardless of the endpoint that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      was called.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.323.1">
     As you will be aware from earlier in the book, middleware, such as services for dependency injection, must be registered in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.324.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.325.1">
     .
    </span>
    <span class="koboSpan" id="kobo.325.2">
     Register this middleware class as the first piece of middleware to be registered, and then create an example endpoint that throws
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.326.1">
      an exception:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.327.1">
app.UseMiddleware&lt;ErrorHandlingMiddleware&gt;();
app.MapGet(
    "/error",
    () =&gt; {
        throw new InvalidOperationException(
            "This is a test exception");
    });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.328.1">
     You should find that not
    </span>
    <a id="_idIndexMarker550">
    </a>
    <span class="koboSpan" id="kobo.329.1">
     only the message from the exception is returned but also a generic message, consistently, like the one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.330.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.331.1">
{
    "message": "An unexpected error occurred. </span><span class="koboSpan" id="kobo.331.2">Please try
        again later.",
    "details": "This is a test exception"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.332.1">
     Another practice that should be consistent when developing any API is that of secure development.
    </span>
    <span class="koboSpan" id="kobo.332.2">
     Let’s explore some good security practices that you can apply when authorizing requests to your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      minimal API.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-165">
    <a id="_idTextAnchor195">
    </a>
    <span class="koboSpan" id="kobo.334.1">
     Security considerations
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     There are two critical areas of security within a minimal API – authentication and authorization.
    </span>
    <span class="koboSpan" id="kobo.335.2">
     Regardless
    </span>
    <a id="_idIndexMarker551">
    </a>
    <span class="koboSpan" id="kobo.336.1">
     of their differences, the attitude toward their implementation should be largely the same –
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.337.1">
      don’t roll
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.338.1">
       your own
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.340.1">
     This mantra serves as a warning that a proven
    </span>
    <a id="_idIndexMarker552">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     security framework will usually be safer than one you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      devise yourself.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.343.1">
     Let’s first look at the difference between authentication and authorization, as well as how you can achieve a good degree of
    </span>
    <a id="_idIndexMarker553">
    </a>
    <span class="koboSpan" id="kobo.344.1">
     security using the well-known technology
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.345.1">
      JSON Web
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.346.1">
       Tokens
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.348.1">
       JWTs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      ).
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-166">
    <a id="_idTextAnchor196">
    </a>
    <span class="koboSpan" id="kobo.350.1">
     Authentication
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.351.1">
      Authentication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.352.1">
     verifies the identity of users or systems accessing your API.
    </span>
    <span class="koboSpan" id="kobo.352.2">
     It allows you to allow only legitimate requests to
    </span>
    <a id="_idIndexMarker554">
    </a>
    <span class="koboSpan" id="kobo.353.1">
     enter
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      a system.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.355.1">
     JWTs are widely used for their stateless
    </span>
    <a id="_idIndexMarker555">
    </a>
    <span class="koboSpan" id="kobo.356.1">
     authentication capabilities in minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.356.2">
     Users authenticate once and receive a token, which is included in subsequent requests to access
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      protected resources.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-167">
    <a id="_idTextAnchor197">
    </a>
    <span class="koboSpan" id="kobo.358.1">
     Authorization
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.359.1">
      Authorization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.360.1">
     is a means of checking
    </span>
    <a id="_idIndexMarker556">
    </a>
    <span class="koboSpan" id="kobo.361.1">
     to see whether an authenticated user is accessing resources within their specific permissions.
    </span>
    <span class="koboSpan" id="kobo.361.2">
     In JWT, these permissions
    </span>
    <a id="_idIndexMarker557">
    </a>
    <span class="koboSpan" id="kobo.362.1">
     are known
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.364.1">
       claims
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.366.1">
     A claim can be the name of a
    </span>
    <a id="_idIndexMarker558">
    </a>
    <span class="koboSpan" id="kobo.367.1">
     resource or type of user, or it can be a role.
    </span>
    <span class="koboSpan" id="kobo.367.2">
     Either way, JWT has built-in functionality to define and validate claims against specific endpoints in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      minimal API:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.369.1">
      To get started with this authorization framework, we first need to add the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.370.1">
       Microsoft.AspNetCore.Authentication.JwtBearer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.371.1">
      NuGet package.
     </span>
     <span class="koboSpan" id="kobo.371.2">
      Do this via the NuGet Package Manager Console, accessible via
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.372.1">
       Tools
      </span>
     </strong>
     <span class="koboSpan" id="kobo.373.1">
      |
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.374.1">
       NuGet Package Manager
      </span>
     </strong>
     <span class="koboSpan" id="kobo.375.1">
      |
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.376.1">
       Package
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.377.1">
        Manager Console
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.378.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.379.1">dotnet add package Microsoft</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.380.1">    .AspNetCore.Authentication.JwtBearer</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.381.1">
      We then need to ensure that
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.382.1">
       Program.cs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.383.1">
      has the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.384.1">
       relevant namespaces:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.385.1">
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using Microsoft.AspNetCore.Authorization;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.386.1">
      JWT can be implemented
     </span>
     <a id="_idIndexMarker559">
     </a>
     <span class="koboSpan" id="kobo.387.1">
      as a middleware, so it should
     </span>
     <a id="_idIndexMarker560">
     </a>
     <span class="koboSpan" id="kobo.388.1">
      first be set up
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.389.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.390.1">
        Program.cs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.391.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.392.1">
builder.AddAuthorization();
builder.Services.AddAuthentication(
    JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt;
    {
        options.TokenValidationParameters =
            new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = "https://yourdomain.com",
            ValidAudience = "https://yourdomain.com",
            IssuerSigningKey =
                new SymmetricSecurityKey(
                    Encoding.UTF8.GetBytes(
                        "A_Not_Very_Secret_Key_1234567
                            890"
                    )
                )
        };
    });
var app = builder.Build();
app.UseAuthentication();
app.UseAuthorization();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.393.1">
      This registration specifies how your
     </span>
     <a id="_idIndexMarker561">
     </a>
     <span class="koboSpan" id="kobo.394.1">
      tokens are validated.
     </span>
     <span class="koboSpan" id="kobo.394.2">
      Next, we need to provide a means of generating a token.
     </span>
     <span class="koboSpan" id="kobo.394.3">
      We can do this by creating
     </span>
     <a id="_idIndexMarker562">
     </a>
     <span class="koboSpan" id="kobo.395.1">
      a dedicated
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.396.1">
       API endpoint:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.397.1">
    app.MapGet("/generate-token", () =&gt;
    {
        var tokenHandler =
            new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(
            " A_Not_Very_Secret_Key_1234567890"
        );
        var tokenDescriptor =
            new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
    new Claim(ClaimTypes.Name, "TestUser"),
    new Claim(ClaimTypes.Role, "Admin")
}),
            Expires = DateTime.UtcNow.AddHours(1),
            Issuer = "https://yourdomain.com",
            Audience = "https://yourdomain.com",
            SigningCredentials =
                new SigningCredentials(
                    new SymmetricSecurityKey(key),
                        SecurityAlgorithms
                            .HmacSha256Signature
                )
        };
        var token =
            tokenHandler.CreateToken(tokenDescriptor);
        var tokenString =
            tokenHandler.WriteToken(token);
        return Results.Ok(tokenString);
    });</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.398.1">
      Finally, now that we have a
     </span>
     <a id="_idIndexMarker563">
     </a>
     <span class="koboSpan" id="kobo.399.1">
      means of creating a JWT token, we can
     </span>
     <a id="_idIndexMarker564">
     </a>
     <span class="koboSpan" id="kobo.400.1">
      create an endpoint that requires it.
     </span>
     <span class="koboSpan" id="kobo.400.2">
      Let’s again create a simple
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.401.1">
       GET
      </span>
     </strong>
     <span class="koboSpan" id="kobo.402.1">
      endpoint, but this time, we add an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.403.1">
       [Authorize]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.404.1">
      attribute and chain
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.405.1">
       RequireAuthorization()
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.406.1">
       to it:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.407.1">
app.MapGet(
    "/secure",
    [Authorize] () =&gt; "This is a secure endpoint")
    .RequireAuthorization();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.408.1">
      To test this, we can make a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.409.1">
       GET
      </span>
     </strong>
     <span class="koboSpan" id="kobo.410.1">
      request to this endpoint and add the returned JWT token as a bearer token.
     </span>
     <span class="koboSpan" id="kobo.410.2">
      With an example JWT token, the header would look something
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.411.1">
       like this:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.412.1">"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1bmlxdWVfbmFtZSI6IlRlc3RVc2VyIiwicm9sZSI6IkFkbWluIiwibmJmIjoxNjQyNzE2MzY0LCJleHAiOjE2NDI3MTk5NjQsImlhdCI6MTY0MjcxNjM2NCwiaXNzIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsImF1ZCI6Imh0dHBzOi8veW91cmRvbWFpbi5jb20ifQ.-Ym30PjdvWl5eYdltZd0yA5XQ1ikf5D4KrDlmHMIj0s"</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.413.1">
       ASP.NET core will then authenticate the request, based on the validation parameters you specified when you registered the
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.414.1">
        JWT middleware.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.415.1">
      Taking this further, if we
     </span>
     <a id="_idIndexMarker565">
     </a>
     <span class="koboSpan" id="kobo.416.1">
      wanted to create a more restricted
     </span>
     <a id="_idIndexMarker566">
     </a>
     <span class="koboSpan" id="kobo.417.1">
      endpoint, which can only be accessed by users with the role claim,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.418.1">
       Admin
      </span>
     </strong>
     <span class="koboSpan" id="kobo.419.1">
      , we can add a parameter to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.420.1">
       [
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.421.1">
        Authorize]
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.422.1">
       attribute:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.423.1">
app.MapGet(
    "/admin",
    [Authorize(Roles = "Admin")] () =&gt;
{
    return Results.Ok("Welcome, Admin!");
});</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.424.1">
     Using JWT tokens, our minimal APIs are provided with protection against unauthorized activity.
    </span>
    <span class="koboSpan" id="kobo.424.2">
     However, this alone will not guarantee that authorized use is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.425.1">
      not abused.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.426.1">
     In truth, it is impossible to guarantee this, but an extra step you can take to ensure that a minimal API is not abused is to limit the number of requests that can be made during a specified period.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     This
    </span>
    <a id="_idIndexMarker567">
    </a>
    <span class="koboSpan" id="kobo.427.1">
     practice is called
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.428.1">
       rate limiting
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.429.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-168">
    <a id="_idTextAnchor198">
    </a>
    <span class="koboSpan" id="kobo.430.1">
     Rate limiting
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.431.1">
     By controlling the number of requests a client can make to your minimal API within a specific timeframe, rate limiting
    </span>
    <a id="_idIndexMarker568">
    </a>
    <span class="koboSpan" id="kobo.432.1">
     can help prevent a system from being overwhelmed by too many requests, whether the requests are legitimate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.433.1">
      or not.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.434.1">
     Let’s explore a simple example of rate limiting in an ASP.NET core
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.435.1">
      minimal API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.436.1">
     First, add the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.437.1">
      AspNetCoreRateLimit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.438.1">
     package from NuGet via the Package Manager Console.
    </span>
    <span class="koboSpan" id="kobo.438.2">
     You can open this in Visual Studio by clicking
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.439.1">
      Tools
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.441.1">
      Manage NuGet Packages
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.443.1">
      Package Manager Console
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     .
    </span>
    <span class="koboSpan" id="kobo.444.2">
     This will open the console, in which you can type
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.445.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.446.1">
dotnet add package AspNetCoreRateLimit</span></pre>
   <p>
    <span class="koboSpan" id="kobo.447.1">
     Then, add rate limiting (along with memory caching)
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.448.1">
      via
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.449.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.451.1">
using AspNetCoreRateLimit;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddMemoryCache();
builder.Services.Configure&lt;IpRateLimitOptions&gt;(options =&gt;
{
    options.GeneralRules = new List&lt;RateLimitRule&gt;
    {
        new RateLimitRule
        {
            Endpoint = "*",
            Limit = 10,
            Period = "1m"
        }
    };
});
builder.Services
    .AddSingleton&lt;IRateLimitConfiguration,
        RateLimitConfiguration&gt;();
builder.Services.AddInMemoryRateLimiting();
var app = builder.Build();
app.UseIpRateLimiting();
app.MapGet("/", () =&gt; "Hello, World!");
app.Run();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.452.1">
     This configuration will limit all endpoints to a maximum of 100 requests per minute, per IP address.
    </span>
    <span class="koboSpan" id="kobo.452.2">
     If the limit is
    </span>
    <a id="_idIndexMarker569">
    </a>
    <span class="koboSpan" id="kobo.453.1">
     exceeded, the client will receive a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.454.1">
      429 Too Many
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.455.1">
       Requests
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.456.1">
      response.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.457.1">
     To try this example out, change the maximum number of requests per minute to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.458.1">
      2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.459.1">
     and see what the results
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.460.1">
      look like.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.461.1">
     AspNetCoreRateLimit versus Microsoft.AspNetCore.RateLimiting
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.462.1">
     There is another option for rate limiting besides
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.463.1">
      AspNetCoreRateLimit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.464.1">
     , shown in the preceding example.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.465.1">
      Microsoft.AspNetCore.RateLimiting
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     can also be used to manage the rate of allowed requests.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      AspNetCoreRateLimit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     is a third-party library, while
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      Microsoft.AspNetCore.RateLimiting
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     is built-in middleware.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     For configuration,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      AspNetCoreRateLimit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     uses JSON or programmatic configuration, whereas
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.473.1">
      Microsoft.AspNetCore.RateLimiting
     </span>
    </strong>
    <span class="koboSpan" id="kobo.474.1">
     uses programmatic configuration
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.475.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.476.1">
       RateLimiterOptions
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.477.1">
      .
     </span>
    </span>
   </p>
   <p class="callout">
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.478.1">
      AspNetCoreRateLimit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.479.1">
     offers more flexibility with different strategies and distributed rate limiting, while
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.480.1">
      Microsoft.AspNetCore.RateLimiting
     </span>
    </strong>
    <span class="koboSpan" id="kobo.481.1">
     focuses on built-in algorithms and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.482.1">
      endpoint-specific policies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.483.1">
     We’ve only scratched the surface of the practices that can be implemented to improve resilience in minimal
    </span>
    <a id="_idIndexMarker570">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     APIs, but the examples we have explored are a good starting point to improve their design.
    </span>
    <span class="koboSpan" id="kobo.484.2">
     Let’s recap the practices that we’ve seen in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.485.1">
      this chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-169">
    <a id="_idTextAnchor199">
    </a>
    <span class="koboSpan" id="kobo.486.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.487.1">
     We started by observing the justification for implementing effective design practices – namely, for an increase in resiliency from a maintained scalability and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.488.1">
      security perspective.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.489.1">
     We then looked at folder structures, with personal preferences discussed and a couple of folder structure examples outlined for use in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.490.1">
      fresh project.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.491.1">
     We then explored three design patterns in the form of factory, repository, and strategy, providing a solid foundation to arrange minimal API code in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.492.1">
      scalable manner.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.493.1">
     Then, we briefly reviewed an example of how middleware can act as a “global catch,” standardizing the way error responses are returned to a client, before finally exploring some simple ways of authenticating requests and limiting the rate at which they can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.494.1">
      be processed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.495.1">
     We’re moving closer to the end of the book, which means we will need to learn how to manage a minimal API that is deployed and active in a user base.
    </span>
    <span class="koboSpan" id="kobo.495.2">
     With that in mind, the next chapter will cover the things we need to consider most when making our minimal API available to the wider world – testing, deployment,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.496.1">
      and documentation.
     </span>
    </span>
   </p>
  </div>
 </body></html>