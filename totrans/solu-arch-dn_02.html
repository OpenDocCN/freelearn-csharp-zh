<html><head></head><body>
		<div><h1 id="_idParaDest-14"><em class="italic"><a id="_idTextAnchor013"/>Chapter 1</em>: Principles of the Software Development Life Cycle</h1>
			<p>In the modern digital workplace, the role of the .NET solution architect is becoming crucial in the software development life cycle. Having a technology leader and a solution creator who can design and build robust and efficient solutions is a key factor to delivering successful products.</p>
			<p>This book will highlight the fundamentals that you need to know, as a .NET professional developer, to become an effective solution architect in this growing and rapidly changing field.</p>
			<p>Understanding the concept and principles of the <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>) is a great starting point toward planning a software product. This chapter aims to explain the notion of SDLC, its phases, and modern methodologies.</p>
			<p>In this chapter, we will cover the following topics: </p>
			<ul>
				<li>Understanding what the SDLC is</li>
				<li>Exploring the different SDLC stages</li>
				<li>Getting familiar with the popular SDLC models</li>
			</ul>
			<p>By the end of this chapter, you will be able to describe the SDLC stages and explain the difference between the popular SDLC models, such as <strong class="bold">Scrum</strong>, <strong class="bold">Spiral</strong>, and <strong class="bold">DevOps</strong>. </p>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Understanding the software development life cycle</h1>
			<p>In today's digital world, every company is looking to deliver a good quality software product in a short period, which means the efficiency and the speed of the development team are game changers. To achieve this goal, companies must apply a set of well-defined activities<a id="_idIndexMarker000"/> and structured stages that define the <strong class="bold">software development life cycle</strong>, also known as the <strong class="bold">SDLC</strong>. </p>
			<p>The SDLC is<a id="_idIndexMarker001"/> a methodology of work and best practices that aim to ease the process of software development and make it more efficient, ensuring the final product is delivered on time within the project budget and is totally in line with the expectations of the client.</p>
			<p>There are different variations and models of the SDLC, such as the <strong class="bold">Waterfall model</strong>, the <strong class="bold">Spiral model</strong>, and the <strong class="bold">Agile model</strong>. They are<a id="_idIndexMarker002"/> popular and widely used<a id="_idIndexMarker003"/> by most software development organizations. Selecting the right model <a id="_idIndexMarker004"/>depends mainly on the size of the project and other factors. In the following sections, we are going to explore these models in detail to help you decide which model is right for your team and the project.</p>
			<p>Here are the <a id="_idIndexMarker005"/>six stages that are defined in the SDLC process:</p>
			<div><div><img src="img/Figure_1.1_B17366.jpg" alt="Figure 1.1: The six stages of the SDLC"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1: The six stages of the SDLC</p>
			<p>We have just looked at an overview of the software development life cycle and its importance. In the next section, we will explore the different stages of the SDLC process.</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Exploring the different SDLC stages</h1>
			<p><em class="italic">What are the main activities in the SDLC?</em> No matter which model you choose to follow to implement<a id="_idIndexMarker006"/> your product, there are six different stages that are considered as common stages in most of the existing models. However, depending on the model, those stages can be executed sequentially or in parallel. By executing this series of stages, it is expected that you will be able to avoid typical and costly pitfalls and achieve the following goals:</p>
			<ul>
				<li>Lower costs</li>
				<li>Improved overall quality</li>
				<li>Shortened production time</li>
				<li>Excellent customer satisfaction</li>
			</ul>
			<p>Let's explore these stages since understanding them is very important to the solution architect, who will be involved with all of them. On the other hand, knowing those stages is necessary to organize and facilitate the development of the product, as well as to make the entire development process more transparent. We'll understand each of them in the following sections.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Planning and requirement analysis</h2>
			<p><a id="_idIndexMarker007"/>Since the requirements analysis is the first stage, it is the most important and fundamental stage in SDLC. This stage starts by identifying the client's stakeholders, and then conducting several meetings and workshops to define the expectations and gather the requirements.</p>
			<p>This stage is performed by the business analyst, the project manager, and the senior technical members of the team. They conduct meetings and workshops with the client to gather all the functional and non-functional requirements, such as the purpose of building the product, what problems it will solve, how it will improve the efficiency of the work, what it will include in terms of functionalities and services, who the target audience or the end user is, identifying the user journeys, detailed use cases and test cases, hardware requirements, backup strategies, and failover processes. </p>
			<p><strong class="bold">Planning</strong> is the<a id="_idIndexMarker008"/> process of creating a detailed but high-level plan for how and when each module or task in the project will be developed. The aim is to identify the tasks and their dependencies, along with the expected output of each task. This should be aligned with the client's expectations, as defined in the requirement analysis.</p>
			<p>After this stage, everyone <a id="_idIndexMarker009"/>in the team should have a clear view of the scope of the project, including its budget, resources, and deadline, as well as possible risks and quality assurance needs. This will be shared with the client to align them with the execution of the project and to give them better transparency.</p>
			<p>Let's take a look at the different techniques and activities that we usually use when executing the requirements analysis phases:</p>
			<ul>
				<li><strong class="bold">Use cases</strong>: This is an <a id="_idIndexMarker010"/>effective technique that<a id="_idIndexMarker011"/> is widely used to capture user requirements. It allows us to identify the possible flow of each feature to be implemented in the system, along with how it will interact with the end users. You may be wondering, <em class="italic">how many use cases should I write?</em> This might sound difficult at first, but the simple answer to this question is to make sure that you write down as many use cases as possible, to make sure you cover all possible actions and functionalities that should be included in the system.<p>The following are the common sections of a use case:</p><p>a. Use Case Name</p><p>b. Summary Description</p><p>c. Actors</p><p>d. Pre-Conditions</p><p>e. Post-Conditions</p><p>f. Level</p><p>g. Stakeholders</p></li>
				<li><strong class="bold">Business Process Modeling Notation</strong> (<strong class="bold">BPMN</strong>): This is used globally to create graphs that describe and <a id="_idIndexMarker012"/>document a business sequence using symbols and elements. This technique is<a id="_idIndexMarker013"/> recommended if you are implementing business automation processes or the product contains business workflows such as approval cycles.<p>Here are the basic<a id="_idIndexMarker014"/> shapes of BPMN diagrams in <strong class="bold">Visio</strong>:</p></li>
			</ul>
			<div><div><img src="img/Figure_1.2_B17366.jpg" alt="Figure 1.2: Basic shapes of BPMN diagrams"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2: Basic shapes of BPMN diagrams</p>
			<ul>
				<li><strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>): UML is <a id="_idIndexMarker015"/>used to create flowcharts and diagrams to visualize and <a id="_idIndexMarker016"/>document <a id="_idIndexMarker017"/>software components, such as classes and interfaces. UML is a good design practice and a very useful technique for creating object-oriented software; it helps software developers model and communicate any complex architectural software design:</li>
			</ul>
			<div><div><img src="img/Figure_1.3_B17366.jpg" alt="Figure 1.3: Sample class diagram"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3: Sample class diagram</p>
			<ul>
				<li><strong class="bold">Flowchart technique</strong>: This is <a id="_idIndexMarker018"/>another graphical representation that's used to describe the different steps of a<a id="_idIndexMarker019"/> sequential and logical process flow. In<a id="_idIndexMarker020"/> the following diagram, we have a sample flowchart for a checkout process. The green box is the starting point for when the user attempts to add items to the checkout cart before settling the payment and receiving confirmation at the end. The red box represents the end of the process; that is, its completion:</li>
			</ul>
			<div><div><img src="img/Figure_1.4_B17366.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4: Sample flowchart diagram</p>
			<ul>
				<li><strong class="bold">Data flow diagram</strong> (<strong class="bold">DFD</strong>): A diagram is worth a thousand words. You can use a DFD to visually represent <a id="_idIndexMarker021"/>the way <a id="_idIndexMarker022"/>data flows through a process or service in the system. This diagram is used to identify and describe the input data and how it is moving through the system to reach its storage location and form the output data. Here is a sample DFD diagram describing the flow of the data in a purchase order process:</li>
			</ul>
			<div><div><img src="img/Figure_1.5_B17366.jpg" alt="Figure 1.5: Sample data flow diagram"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5: Sample data flow diagram</p>
			<ul>
				<li><strong class="bold">Role Activity Diagrams</strong> (<strong class="bold">RAD</strong>): This is <a id="_idIndexMarker023"/>a role-oriented representation of every possible action in the system. It is <a id="_idIndexMarker024"/>used to easily describe and visualize the different roles that are involved in executing each process or service in the system. The following is a sample role activity diagram describing an ATM transaction and <a id="_idIndexMarker025"/>showing the steps that are accomplished by each key role: </li>
			</ul>
			<div><div><img src="img/Figure_1.6_B17366.jpg" alt="Figure 1.6: Sample role activity diagram"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6: Sample role activity diagram</p>
			<ul>
				<li><strong class="bold">Gantt charts</strong>: These are <a id="_idIndexMarker026"/>used in project <a id="_idIndexMarker027"/>management to assist with planning and scheduling projects of all sizes. They provide a visual representation of tasks, their delivery dates, and the order and dependencies of each task.<p>This makes the execution plan more simplified and transparent for the client. The following is a sample Gantt chart representing a project plan. The tasks are grouped based on a specific context and linked through the predecessor column, along with the <a id="_idIndexMarker028"/>start date and end date:</p></li>
			</ul>
			<div><div><img src="img/Figure_1.7_B17366.jpg" alt="Figure 1.7: Sample Gantt chart plan"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7: Sample Gantt chart plan</p>
			<ul>
				<li><strong class="bold">Gap analysis</strong>: This is a<a id="_idIndexMarker029"/> technique that helps <a id="_idIndexMarker030"/>compare the current actual results of the system with what was expected by the client in the early stages of the project. It helps denote any missing strategic capability or feature in the system. It should also recommend ways you can make improvements that will help the client meet their initial targets. The following is a sample template that can be used to conduct a gap analysis exercise:</li>
			</ul>
			<div><div><img src="img/Figure_1.8_B17366.jpg" alt="Figure 1.8: Sample gap analysis template"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8: Sample gap analysis template</p>
			<ul>
				<li><strong class="bold">Building prototypes</strong>: Building a<a id="_idIndexMarker031"/> mock-up, or a <strong class="bold">Minimum Viable Product</strong> (<strong class="bold">MVP</strong>) model, of the product will <a id="_idIndexMarker032"/>give the end users an idea of what the final version of the product will look like once all the features have been implemented. Using <a id="_idIndexMarker033"/>this technique, you can identify any feasibility challenges that you may face when you actually implement the product.</li>
			</ul>
			<p>While performing your analysis, consider grouping the requirements into the following three categories:</p>
			<ul>
				<li><strong class="bold">Functional requirements</strong>: These represent all the detailed features and functionalities of the system. They<a id="_idIndexMarker034"/> are very important for both the <a id="_idIndexMarker035"/>development team, to find out what to implement, and the client's stakeholders, to help them align on the final results of the product.</li>
				<li><strong class="bold">Operational requirements</strong>: These <a id="_idIndexMarker036"/>define the scenarios and the<a id="_idIndexMarker037"/> performance measures, along with the associated requirements, that are needed for the product to operate properly in accordance with the client's expectations. This includes the following:<p>a. Establishing critical and desired user performance</p><p>b. Defining constraints</p><p>c. Establishing the infrastructure needed</p><p>d. Establishing measures of effectiveness</p></li>
				<li><strong class="bold">Technical requirements</strong>: These <a id="_idIndexMarker038"/>describe the technical<a id="_idIndexMarker039"/> part that must be fulfilled to easily and successfully deploy the product and make it functional with good performance, as per the client's expectations. This includes the technology that will be used, the technical architecture, the hardware, third-party integration, testing, and deployment plans.</li>
			</ul>
			<p>Here are a couple of <a id="_idIndexMarker040"/>things that should be considered during this stage:</p>
			<ul>
				<li>One of the main challenges in the requirements gathering phase is that each member of the client's stakeholders is seeing the product from his/her point of view. For the success of the project, consider listening and capturing all users' perspectives and document them in user stories or use cases. This will help you identify the full picture of what the product will look like and what it will provide as features.</li>
				<li>In the first meeting with the client, try to identify the different stakeholders and discuss the scope of work to make it clear for all parties. After that, you will have to meet with all the stakeholders to collect the detailed requirements. During these workshops, make sure you keep all your discussions within the scope set forth. This is important to keep the requirements aligned with the business needs and to avoid adding functionalities that the product was never expected to provide.</li>
			</ul>
			<p>So far, we've explored the different activities and techniques we can use for planning and conducting the requirement analysis workshop, which is essential for the success of the project. In the next section, we will learn how to document requirements. </p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Defining requirements</h2>
			<p>The next step after<a id="_idIndexMarker041"/> completing the requirements analysis workshop is to document all the information that was gathered in the previous step to define the product requirements. Usually, the output result of this activity is the <strong class="bold">Software Requirement Specification</strong> (<strong class="bold">SRS</strong>) document, which consists of all the <a id="_idIndexMarker042"/>detailed requirements to be designed and developed during all the phases of the project, from the beginning to its end, until the desired product is delivered. This SRS becomes the <em class="italic">requirements contract</em> that will be used to develop the product. It will address all the business needs of your client.</p>
			<p>Once the SRS document has been finalized and reviewed by all the parties involved in this project, make sure you send it back to the key stakeholders, or the representatives of the key stakeholders, to sign it. The purpose of signing the SRS is to agree that the requirements that are <a id="_idIndexMarker043"/>presented and defined in the document are clear and reflect the business needs, as discussed in the analysis workshop. This formal commitment, which is expressed by all parties involved, will play a crucial role in the project life cycle to ensure that the project will not struggle from <strong class="bold">scope creep</strong> during its implementation.</p>
			<p class="callout-heading">Important Note:</p>
			<p class="callout">In project management, scope creep (or requirement creep) refers to a situation where the client is continuously requesting changes and adding new features to the product, even after project kickoff. As a result, the project's scope will continue to grow, which will affect the delivery time and the final cost of the product. This should not occur and to prevent it, you must make sure that all the business needs (that is, the scope of the project) are very detailed and properly defined, and that the client has officially committed to the scope of work.</p>
			<p>A basic outline for <a id="_idIndexMarker044"/>an SRS document may look like this:</p>
			<ol>
				<li>Introduction<p>1.1 Purpose</p><p>1.2 Intended Audience</p><p>1.3 Intended Use</p><p>1.4 Scope</p><p>1.5 Definitions and Acronyms</p></li>
				<li>Overall Description<p>2.1 User Needs</p><p>2.2 Design and Implementation Constraints</p><p>2.3 Assumptions and Dependencies</p></li>
				<li>System Features <p>3.1 Functional Requirements</p></li>
				<li>External <a id="_idIndexMarker045"/>Interface Requirements<p>4.1 User Interfaces</p><p>4.2 Software Interfaces</p><p>4.3 Hardware Interfaces</p></li>
				<li>Non-Functional Requirements<p>5.1 Performance Requirements</p><p>5.2 Security <a id="_idIndexMarker046"/>Requirements</p><p>5.3 Software Quality Attributes</p></li>
			</ol>
			<p>Feel free to use this outline and modify it as per your needs, but keep in mind that this document should describe the functionality the product needs to fulfill, along with the technical specifications. Therefore, it should be simple, easy to read, and understand by the project stakeholders. In the next section, we are going to learn about the architecture design phase.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Architectural design</h2>
			<p><em class="italic">How will we build the product?</em> This a<a id="_idIndexMarker047"/> crucial question to answer, especially if you're building a complex or large-scale product that will be used by a wide range of users. </p>
			<p>To answer this question, we need to start the <strong class="bold">architectural design phase</strong>, which consists of converting the software specifications that were defined and documented in the previous stages into an abstract <a id="_idIndexMarker048"/>design specification plan called the <strong class="bold">architectural design</strong>. </p>
			<p>The starting point of this phase is to go through the SRS document and understand every single detail in the requirements. This will help you create the best architecture design, which will ensure you deliver a high-quality product. It is the responsibility of the technical team to document their design in a <strong class="bold">Design Document Specification</strong> (<strong class="bold">DDS</strong>) document. The <a id="_idIndexMarker049"/>intended audience of this document is the designers, software developers, and QA testers.</p>
			<p>The purpose of this <a id="_idIndexMarker050"/>document is to present a comprehensive <a id="_idIndexMarker051"/>architectural overview and depict all the technical details of the system components. More specifically, it should present the following:</p>
			<ul>
				<li>The system architecture, components, classes, their attributes, and methods</li>
				<li>The database's design, including the definition of the tables and fields, along with the relationships between tables</li>
				<li>The graphical interface design</li>
				<li>Hardware or software environment</li>
				<li>End user environment</li>
				<li>Security requirements</li>
				<li>Performance requirements and capacity limitations</li>
			</ul>
			<p>This DDS is reviewed by all the key technical stakeholders. Based on various factors such as design modularity, performance, security, capacity limitations, risks, budget, and time constraints, the best design approach is selected to build the product.</p>
			<p>A basic outline for a DDS document may look like this:</p>
			<ol>
				<li value="1">Introduction<p>1.1 Purpose</p><p>1.2 Scope</p><p>1.3 Design<a id="_idIndexMarker052"/> Goals</p><p>        1.3.1 Maintainability</p><p>        1.3.2 Optimized Performance</p><p>        1.3.3 Designed Friendly</p></li>
				<li>System <a id="_idIndexMarker053"/>Overview<p>2.1 Algorithms</p><p>2.2 Technologies Used</p><p>2.3 Architecture Diagrams</p><p>2.4 Database Design</p></li>
				<li>Design Considerations<p>3.1 Assumptions and Dependencies</p><p>3.2 General Constraints</p><p>3.3 Goals and Guidelines</p><p>3.4 Development Methods</p></li>
				<li>Architectural <a id="_idIndexMarker054"/>Strategies<p>4.1 Strategy-1 name or description</p><p>4.2 Strategy-2 name or description</p><p>4.3 ...</p></li>
				<li>System Architecture<p>5.1 Component-1 name or description</p><p>5.2 Component-2 name or description</p><p>5.3 ...</p></li>
				<li>Policies and Tactics<p>6.1 Policy/tactic-1 name or description</p><p>6.2 Policy/tactic-2 name or description</p><p>6.3 ...</p></li>
				<li>Detailed<a id="_idIndexMarker055"/> System Design<p>7.1 Module-1 name or description</p><p>7.2 Module-2 <a id="_idIndexMarker056"/>name or description</p><p>7.3 ...</p></li>
				<li>Traceability</li>
				<li>Glossary</li>
				<li>Appendix</li>
			</ol>
			<p>You can use this outline to describe your architecture and prepare the DDS document. The more you make it clear and detailed, the more you make it easy for the developers and testers during the implementation and testing phases. Next, we will explore the development phase.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Software development</h2>
			<p>In this stage of SDLC, the <a id="_idIndexMarker057"/>software developers start actually developing the product. The technology that's used and the programming language, including all the technical standards, should be aligned with what was agreed on in the DDS document. Keep in mind that the development activities can be accomplished very smoothly when the design specifications are detailed and organized in a proper manner.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Testing</h2>
			<p><em class="italic">Did we get what we want?</em> Testing the<a id="_idIndexMarker058"/> product is a must before launching it to the end users. This stage starts alongside the development stage, where the developers are responsible for testing what they are developing. At this time, it is just basic testing and not enough to say that the product is ready to go live.</p>
			<p>Therefore, an official testing cycle should be conducted once the development activities of a specific module or the entire set of features have been completed. During this phase, several types of testing should be conducted, every single functionality should be tested thoroughly, and the identified defects should be reported to the developers to get them fixed.</p>
			<p>The quality assurance <a id="_idIndexMarker059"/>team can use the test cases that have been documented in the SRS, or they can refer to the use cases to test the product. It is recommended to run the test cases every time the developers release a new version of the product until it reaches a stable version. This is to make sure all the defects that were reported in the previous cycles have been closed.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Deployment and maintenance</h2>
			<p>Software developers tend to invest the <a id="_idIndexMarker060"/>majority of their time in the design and development activities of the product, which is good. Despite its importance, I have learned from several projects that this is not enough. Setting a strategic plan for deployment and maintenance is a key factor for the success of the product. </p>
			<p>The focus at this stage is to make the product available for end users so that they can start using it. To do so, the product should be deployed to the production environment. </p>
			<p>First, it is recommended that you deploy the product in a testing or staging environment. This is where the <strong class="bold">User Acceptance Testing</strong> (<strong class="bold">UAT</strong>) activities<a id="_idIndexMarker061"/> should be performed. All the issues will be solved and deployed back to this environment. Once the product reaches a stable version that is accepted by the client and meets all the specifications that were approved in the previous phases, the product can be moved to the production environment.</p>
			<p class="callout-heading">Important Note:</p>
			<p class="callout">User acceptance testing is the final round of testing. It is performed by the client to verify that every single functionality provided by the software works, and to confirm that all the requirements have been covered. This will ensure that the software behaves exactly as the users expect and that they can easily use it without any errors or crashes occurring. At the end of the UAT, the client should accept the software or request some improvements before moving the software to the production environment.</p>
			<p>The maintenance phase starts immediately after the product is fully operational in the production environment and signed off by the client. This is a crucial step from the client's point of view because it ensures that their product continues to perform as designed after its deployment. </p>
			<h3>Types of maintenance</h3>
			<p>There are four types of software maintenance:</p>
			<ul>
				<li><strong class="bold">Corrective maintenance</strong>: This is used <a id="_idIndexMarker062"/>mainly to rectify some errors and faults that are observed while the <a id="_idIndexMarker063"/>system is in use or to improve the performance of the system.</li>
				<li><strong class="bold">Adaptive maintenance</strong>: This <a id="_idIndexMarker064"/>may be needed when the client requests to run the software on a <a id="_idIndexMarker065"/>new environment such as new hardware or a new operating system. Sometimes, clients request to move their products from an on-premises environment to <strong class="bold">Azure Cloud</strong>. Moreover, it can cover integrating the product with third-party software.</li>
				<li><strong class="bold">Perfective maintenance</strong>: This type<a id="_idIndexMarker066"/> of maintenance<a id="_idIndexMarker067"/> focuses on implementing new features in the product. These features can be requested by the client to accommodate new business cases, or they can be reported by users who have already started interacting with the product and noticed some missing functionalities that can help facilitate their work and improve the overall experience.</li>
				<li><strong class="bold">Preventive maintenance</strong>: This is<a id="_idIndexMarker068"/> commonly used to detect and correct errors that may cause software failure in the future. It <a id="_idIndexMarker069"/>helps reduce the risk of the issues that aren't significant at this moment but may cause serious problems in the future; for example, assuming the clients are expecting to have an increased number of users who will start using their product after 2 months, but this load cannot be accommodated by the current environment's specs. In this case, planning and updating the software environment in advance to serve the load that will be caused by the new users is considered preventive maintenance.</li>
			</ul>
			<p>Let's take a look at the <a id="_idIndexMarker070"/>following table to understand when and why we should apply these maintenance types:</p>
			<div><div><img src="img/Figure_1.9_B17366.jpg" alt="Figure 1.9: Software maintenance types "/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9: Software maintenance types </p>
			<p>In the next section, we are going to explore the difference between software maintenance and warranty.</p>
			<h3>Maintenance versus warranty</h3>
			<p>People may get confused about maintenance and warranty. A software warranty<a id="_idIndexMarker071"/> is a formal and legal guarantee that the product will perform properly, as per the specifications, for a certain period. It is a promise to fix any errors or malfunctions in the system at no cost during the warranty period.</p>
			<p>The maintenance agreement is sold to the client for long-term and ongoing maintenance activities such as upgrades, updates, or product enhancements. </p>
			<p>We have just explained the different stages of the SDLC and highlighted the expected output of each stage. In the next section, we are going to provide an overview of the popular SDLC models. </p>
			<p>In this section, we explored all the SDLC phases, from planning and requirements analysis to deploying and sign-off. In the next section, we will get to know the most popular SDLC models.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Getting familiar with the popular SDLC models</h1>
			<p>Every product requires a suitable<a id="_idIndexMarker072"/> approach to developing it. Usually, this decision is made based on multiple factors, such as if the requirements are well-documented, the requirements are not ambiguous, the project is short, and so on. In this section, we will highlight some of the most popular models that are used in software development. </p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>The Waterfall model</h2>
			<p>The <strong class="bold">Waterfall model</strong> is a <a id="_idIndexMarker073"/>straightforward and sequential approach to building a software product. Each stage of the development cycle should be completed before you move <a id="_idIndexMarker074"/>on to the next stage and usually, the output of each stage is considered to be the input for the next stage. </p>
			<p>Here is a representation of the different stages of this model:</p>
			<div><div><img src="img/Figure_1.10_B17366.jpg" alt="Figure 1.10: Waterfall stages"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10: Waterfall stages</p>
			<p>Some of the advantages<a id="_idIndexMarker075"/> of the Waterfall model are as follows:</p>
			<ul>
				<li>Stages are clearly defined and easy to understand</li>
				<li>Stages are well-documented</li>
				<li>Works well for smaller projects where the requirements are well-defined</li>
			</ul>
			<p>Some of the disadvantages<a id="_idIndexMarker076"/> of this model are as follows:</p>
			<ul>
				<li>The working version of the product will be delivered at a late stage of the development cycle.</li>
				<li>Not a good model for complex and ongoing projects since the stakeholders won't be able to give their feedback at the early stages of the development process.</li>
				<li>Not a good model <a id="_idIndexMarker077"/>when there is a high risk of requirements changing. </li>
			</ul>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>The Agile model</h2>
			<p>The <strong class="bold">Agile model</strong>, an <a id="_idIndexMarker078"/>example of which is Scrum, is one of the most well-known <a id="_idIndexMarker079"/>development methodologies and is widely adopted by many IT organizations. It is also applied to non-tech projects.</p>
			<p>The approach of this model is to break the product into cycles or iterations. Each iteration lasts for about 2-4 weeks (usually, it shouldn't be a long time). At each iteration, the development team should deliver a complete working version of the software. The idea is to take the use cases and split them into iterations so that you get a functioning part of the product at the end of the iteration. In this way, the development team is producing ongoing and incremental releases that have been well tested.</p>
			<p>This approach helps teams identify and address issues early on. It also involves the stakeholders throughout the development process to get their feedback.</p>
			<p>The following diagram is a quick representation of the Agile stages:</p>
			<div><div><img src="img/Figure_1.11_B17366.jpg" alt="Figure 1.11: Agile stages"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11: Agile stages</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>The Spiral model</h2>
			<p>The <strong class="bold">Spiral model</strong> is a <a id="_idIndexMarker080"/>combination of the Iterative model and the Waterfall sequential<a id="_idIndexMarker081"/> model. Usually used for large projects, it provides support for risk handling at the early stages of each iteration. With this model, the project passes through four phases:</p>
			<ul>
				<li>Identifying objectives by gathering the business requirements</li>
				<li>Performing risk analysis</li>
				<li>Reviewing and evaluating</li>
				<li>Developing and testing</li>
			</ul>
			<p>Here is a diagram depicting the Spiral model:</p>
			<div><div><img src="img/Figure_1.12_B17366.jpg" alt="Figure 1.12: Spiral model"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12: Spiral model</p>
			<p>With each iteration, you can build a prototype of the new feature and functionalities that will be delivered in this iteration. </p>
			<p>These phases are repeated in a <em class="italic">spiral</em> until the entire product is delivered, allowing for multiple rounds of refinement.</p>
			<p>The advantages of the <a id="_idIndexMarker082"/>Spiral model are as follows:</p>
			<ul>
				<li>This model provides an early indication of the existence of risks.</li>
				<li>Critical high-risk functionalities are developed first.</li>
				<li>Stakeholders are closely tied to the entire development life cycle phases.</li>
				<li>Users can see the system in action at early stages with the use of prototypes.</li>
				<li>Stakeholders can incorporate early and continuous feedback.</li>
			</ul>
			<p>The disadvantages of the<a id="_idIndexMarker083"/> Spiral model are as follows:</p>
			<ul>
				<li>This model is costly<a id="_idIndexMarker084"/> and is not recommended for small projects that have low risks in most cases.</li>
				<li>Managing the process is somewhat complex.</li>
				<li>Risk assessment expertise is required to run this model.</li>
			</ul>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>The DevOps model</h2>
			<p>In a <strong class="bold">DevOps model</strong>, the <a id="_idIndexMarker085"/>developers and operations teams work together. You may be<a id="_idIndexMarker086"/> wondering, <em class="italic">well, what does this mean?</em></p>
			<p>Using the traditional models that we talked about earlier, companies were splitting up their resources into teams that handled specific responsibilities:</p>
			<ul>
				<li>A development team to architect and build the product.</li>
				<li>An operations team to prepare the environment and host the product.</li>
				<li>A test team to prepare the test cases and conduct thorough QA testing and to report back to the development team.</li>
			</ul>
			<p>With the DevOps methodology, the developers and operations teams are requested to collaborate closely – as one team – in all the stages of the SDLC process. A successful DevOps model ensures continuous feedback, accelerates the deployment, improves the development process, and automates manual processes. </p>
			<p>Here is a representation showing the different steps in the DevOps model:</p>
			<div><div><img src="img/Figure_1.13_B17366.jpg" alt="Figure 1.13: DevOps model"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13: DevOps model</p>
			<p>The advantages of the<a id="_idIndexMarker087"/> DevOps model are as follows:</p>
			<ul>
				<li>Fast delivery of features</li>
				<li>Better responsiveness<a id="_idIndexMarker088"/> to problems</li>
				<li>Efficient operations</li>
				<li>Reduced bottlenecks</li>
				<li>Better communication and collaboration</li>
				<li>More productive team members, with more time to innovate</li>
			</ul>
			<p>The disadvantages <a id="_idIndexMarker089"/>of the DevOps model are as follows:</p>
			<ul>
				<li>DevOps requires culture change and new methods of communication, which is a big challenge in a traditional environment.</li>
				<li>There is a need to upgrade the infrastructure to optimize the process, which can be expensive for some companies.</li>
				<li>Fast development can lead to critical security shortfalls.</li>
			</ul>
			<p>Now, let's learn how to choose the right model.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Choosing the right model</h2>
			<p>When selecting the <a id="_idIndexMarker090"/>right SDLC model to build a particular product, it's important to remember that each model offers a unique process that may help you overcome the challenges that you will encounter during the development cycle. One model would never fit every project or every client's needs, which is why you should understand these popular models and know when to apply them. </p>
			<p>Finding the right model depends heavily on the factors the project will be executed with, such as your current infrastructure, the culture adopted by your team, and how the client would like the project to be managed. Certain projects may run best with a Waterfall approach, while others would benefit from the flexibility of the Agile model.</p>
			<p>Let's take a look at the following table, which highlights the main factors when it comes to choosing the right model for your product:</p>
			<div><div><img src="img/Figure_1.14_B17366.jpg" alt="Figure 1.14: How to choose the right SDLC model"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14: How to choose the right SDLC model</p>
			<p>In this section, you explored the<a id="_idIndexMarker091"/> most popular SDLC models. Each one offers a unique methodology that can help you overcome different challenges you may encounter in your career. You also learned how to choose the right model for your product. </p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Summary</h1>
			<p>In this chapter, you learned about the definition and the importance of the SDLC, as well as how it can help the organization deliver products in an efficient way. Then, you learned about the different stages of the SDLC, the most popular models, along with their advantages and disadvantages, and how to choose the right model for your team.</p>
			<p>In the next chapter, you will learn about the different team roles, along with their responsibilities, and how they fit into the SDLC process and the team structure.</p>
		</div>
		<div></div>
	</body></html>