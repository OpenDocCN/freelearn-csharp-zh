<html><head></head><body>
  <div><h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-107" class="chapterTitle">Win and Lose Conditions</h1>
    <p class="normal">Now that we have a basic gameplay experience, it’s time to make the game end with the outcomes of winning or losing. One common way to implement this is through separated components with the responsibility of overseeing a set of objects to detect certain situations that need to happen, such as the player life becoming 0 or all of the waves being cleared. We will implement this through the concept of <strong class="keyWord">managers</strong>, components that will manage and monitor several objects. </p>
    <p class="normal">In this chapter, we will examine the following manager concepts: </p>
    <ul>
      <li class="bulletList">Creating object managers</li>
      <li class="bulletList">Creating game modes</li>
      <li class="bulletList">Improving our code with events</li>
    </ul>
    <p class="normal">With this knowledge, you will be able to not only create the victory and lose conditions of the game, but also do this in a properly structured way using design patterns such as <strong class="keyWord">Singleton</strong> and <strong class="keyWord">Event Listeners</strong>. These skills are not only useful for creating the winning and losing code of the game but any code in general. First, let’s begin by creating managers to represent concepts such as score or game rules.</p>
    <h1 id="_idParaDest-108" class="heading-1">Creating object managers</h1>
    <p class="normal">Not every object in <a id="_idIndexMarker404"/>your Scene should be something that can be seen, heard, or collided with. Some objects can also exist with a conceptual meaning, not something tangible. For example, imagine you need to keep a count of the number of enemies: where do you save that? You also need someplace to save the current score of the player, and you may be thinking it could be on the player itself, but what happens if the player dies and respawns? </p>
    <p class="normal">The data would be lost! In such scenarios, the concept of a <strong class="keyWord">manager</strong> can be a useful way of solving this in our first games, so let’s explore it.</p>
    <p class="normal">In this section, we are going to see the following object manager concepts:</p>
    <ul>
      <li class="bulletList">Sharing variables with the Singleton design pattern</li>
      <li class="bulletList">Sharing variables in Visual Scripting</li>
      <li class="bulletList">Creating managers</li>
    </ul>
    <p class="normal">We will start by discussing what the Singleton design pattern is and how it helps us simplify the communication of objects. With it, we will create manager objects that allow us to <a id="_idIndexMarker405"/>centralize information about a group of objects, among other things. Let’s start by discussing the Singleton design pattern.</p>
    <h2 id="_idParaDest-109" class="heading-2">Sharing variables with the Singleton design pattern</h2>
    <p class="normal">Design<a id="_idIndexMarker406"/> patterns are usually described as <a id="_idIndexMarker407"/>common solutions to common problems. There are several coding design decisions you will have to make while you code your game, but luckily, the ways to tackle the most common situations are well known and documented. In this section, we are going to discuss one of the most common design patterns, the <strong class="keyWord">Singleton</strong>, a convenient one to implement in simple projects.</p>
    <p class="normal">A Singleton pattern is used when we need a single instance of an object, meaning that there shouldn’t be more than one instance of a class and that we want to be easily accessible (not necessarily, but useful in our scenario). We have plenty of cases in our game where this can be applied, for example, <code class="inlineCode">ScoreManager</code>, a component that will hold the current score. In this case, we will never have more than one score, so we can take advantage of the benefits of the Singleton manager here.</p>
    <p class="normal">One benefit is being sure that we won’t have duplicated scores, which makes our code less error prone. Also, so far, we have needed to create public references and drag objects via the editor to connect two objects, or look for them using <code class="inlineCode">GetComponent</code>; with this pattern, however, we will have global access to our Singleton component, meaning you can just write the name of the component in your script and you will access it. In the end, there’s just one <code class="inlineCode">ScoreManager</code> component, so specifying which one via the editor is redundant. This is similar to <code class="inlineCode">Time.deltaTime</code>, the class responsible for managing time—we have just one time.</p>
    <div><p class="normal">If you are an advanced programmer, you may be thinking about code testing and dependency injection now, and you are right, but remember, we are trying to write simple code so far, so we will stick to this simple solution. </p>
    </div>
    <p class="normal">Let’s create a <strong class="screenText">Score Manager</strong> object, responsible for handling the score, to show an example of a Singleton by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an empty GameObject (<strong class="screenText">GameObject | Create Empty</strong>) and call it <code class="inlineCode">ScoreManager</code>; usually, managers are put in empty objects, separated from the rest of the scene’s objects.</li>
      <li class="numberedList">Add a script called <code class="inlineCode">ScoreManager</code> to this object with an <code class="inlineCode">int</code> field called <code class="inlineCode">amount</code> that will hold the current score.</li>
      <li class="numberedList">Add a field of the <code class="inlineCode">ScoreManager</code> type called <code class="inlineCode">instance</code>, but add the <code class="inlineCode">static</code> keyword to it; this will make the variable global, meaning it can be accessed anywhere<a id="_idIndexMarker408"/> by just writing its<a id="_idIndexMarker409"/> name:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.1: A static field that can be accessed anywhere in the code</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In <code class="inlineCode">Awake</code>, check whether the <code class="inlineCode">instance</code> field is not <code class="inlineCode">null</code>, and in that case, set this <code class="inlineCode">ScoreManager</code> instance as the instance reference using the <code class="inlineCode">this</code> reference. </li>
      <li class="numberedList">In the <code class="inlineCode">else</code> clause of the <code class="inlineCode">null</code> checking <code class="inlineCode">if</code> statement, print a message indicating that there’s a second <code class="inlineCode">ScoreManager</code> instance that must be destroyed:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.2: Checking whether there’s only one Singleton instance</p>
    <p class="normal">The idea is to save the reference to the only <code class="inlineCode">ScoreManager</code> instance in the instance static field, but if by mistake the user creates two objects with the <code class="inlineCode">ScoreManager</code> component, this <code class="inlineCode">if</code> statement will detect it and inform the user of the error, asking them to take action. In this scenario, the first <code class="inlineCode">ScoreManager</code> instance to execute <code class="inlineCode">Awake</code> will find that<a id="_idIndexMarker410"/> there’s <a id="_idIndexMarker411"/>no instance set (the field is <code class="inlineCode">null</code>) so it will set itself as the current instance, while the second <code class="inlineCode">ScoreManager</code> instance will find the instance is already set and will print the message.</p>
    <div><p class="normal">Remember that <code class="inlineCode">instance</code> is a static field, shared between all classes, unlike regular reference fields, where each component will have its own reference, so in this case, we have two <code class="inlineCode">ScoreManager</code> instances added to the scene, and they will share the same instance field.</p>
    </div>
    <p class="normal">To improve the example a little bit, it would be ideal to have a simple way to find the second <code class="inlineCode">ScoreManager</code> in the game. It will be hidden somewhere in the Hierarchy and it may be difficult to find, but we fix this by doing the following: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Replace <code class="inlineCode">print</code> with <code class="inlineCode">Debug.Log</code>. <code class="inlineCode">Debug.Log</code> is similar to <code class="inlineCode">print</code> but has a second argument that expects an object to be highlighted when the message is clicked in the console. In this case, we will pass the <code class="inlineCode">gameObject</code> reference to allow the console to highlight the duplicated object:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.3: Printing messages in the console with Debug.Log</p>
    <p class="normal">After clicking the log message, the GameObject containing the duplicated <code class="inlineCode">ScoreManager</code> will be highlighted in the Hierarchy:</p>
    <figure class="mediaobject"><img src="img/B18585_08_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.4: The highlighted object after clicking the message</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Finally, a little improvement can be made here by replacing <code class="inlineCode">Debug.Log</code> with <code class="inlineCode">Debug.LogError</code>, which will also print the message but with an error icon. In a real game, you will have lots of messages in the console, and highlighting the errors<a id="_idIndexMarker412"/> over<a id="_idIndexMarker413"/> the information messages will help us to identify them quickly:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.5: Using LogError to print an error message</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Try the code and observe the error message in the console:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.6: An error message in the console</p>
    <p class="normal">The next step would be to use this Singleton somewhere, so in this case, we will make the enemies give points when they are killed by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a script to the <code class="inlineCode">Enemy</code> Prefab<a id="_idIndexMarker414"/> called <code class="inlineCode">ScoreOnDeath</code> with an <code class="inlineCode">int</code> field called <code class="inlineCode">amount</code>, which will indicate the number of points the enemy will give when killed. Remember to set the value to something other than <code class="inlineCode">0</code> in the editor for the Prefab.</li>
      <li class="numberedList">Create the <code class="inlineCode">OnDestroy</code> event function, which will be automatically called by Unity <a id="_idIndexMarker415"/>when this object is<a id="_idIndexMarker416"/> destroyed, in our case, the enemy:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.7: The OnDestroy event function</p>
    <div><p class="normal">Consider that the <code class="inlineCode">OnDestroy</code> function is also called when we change scenes or the game is quitting, so in this scenario, we might get points when changing scenes, which is not correct. So far, this is not a problem in our case, but later in this chapter, we will see a way to prevent this.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Access the Singleton reference in the <code class="inlineCode">OnDestroy</code> function by writing <code class="inlineCode">ScoreManager.instance</code>, and add the <code class="inlineCode">amount</code> field of our script to the <code class="inlineCode">amount</code> field of the Singleton to increase the score when an enemy is killed:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.8: Full ScoreOnDeath component class contents</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Select the <code class="inlineCode">ScoreManager</code> in the Hierarchy, hit <strong class="screenText">Play</strong>, and kill some enemies to see the score rise with every kill. Remember to set the <code class="inlineCode">amount</code> field of the <code class="inlineCode">ScoreOnDeath</code> component of the Prefab.</li>
    </ol>
    <p class="normal">As you can see, the Singleton simplified a lot the way to access <code class="inlineCode">ScoreManager</code> and have security measures to prevent duplicates of itself, which will help us to reduce errors in our code. Something to take into account is that now you will be tempted to just make everything<a id="_idIndexMarker417"/> a<a id="_idIndexMarker418"/> Singleton, such as the player’s life or player’s bullets and just to make your life easier when creating gameplay mechanics such as power-ups. </p>
    <p class="normal">While that will totally work, remember that your game will change, and I mean change a lot; any real project will experience constant change. Maybe today, the game has just one player, but maybe in the future, you want to add a second player or an AI companion, and you want the power-ups to affect them too, so if you abuse the Singleton pattern, you will have trouble handling those scenarios and many more. Maybe a future player companion will try to get the health pickup but the main player will be healed instead!</p>
    <p class="normal">The point here is to try to use the pattern as few times as you can, in case you don’t have any other way to solve the problem. To be honest, there are always ways to solve problems without Singleton, but they are a little bit more difficult to implement for beginners, so I prefer to simplify your life a little bit to keep you motivated. With enough practice, you will reach a point where you will be ready to improve your coding standards.</p>
    <p class="normal">Now, let’s discuss how to achieve this in Visual Scripting, which deserves its own section given that it will be a little bit different. You may consider skipping the following section if you are <a id="_idIndexMarker419"/>not<a id="_idIndexMarker420"/> interested in the Visual Scripting side of these scripts.</p>
    <h2 id="_idParaDest-110" class="heading-2">Sharing variables with Visual Scripting</h2>
    <p class="normal">Visual <a id="_idIndexMarker421"/>Scripting has a mechanism<a id="_idIndexMarker422"/> that replaces Singleton as a holder of variables to be shared between objects: the <strong class="keyWord">scene variables</strong>. If you<a id="_idIndexMarker423"/> check the left panel in the <strong class="screenText">Script Graph</strong> editor (the window where we edit the nodes of a script) under the <code class="inlineCode">Blackboard</code> panel (the panel that shows the variables of our object), you will notice it will have many tabs: <strong class="screenText">Graph</strong>, <strong class="screenText">Object</strong>, <strong class="screenText">Scene</strong>, <strong class="screenText">App</strong> and <strong class="screenText">Saved</strong>. If you don’t see <code class="inlineCode">Blackboard</code> panel, click the third button from left to right at the top-left part of the window, the button at the right of the <strong class="screenText">i </strong>(information) button:</p>
    <figure class="mediaobject"><img src="img/B18585_08_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.9: Blackboard (variables) editor in Script Graph</p>
    <p class="normal">So far, when we created a variable in the <strong class="screenText">Variables</strong> component of any object, we were actually<a id="_idIndexMarker424"/> creating <strong class="keyWord">Object Variables</strong>: variables that belongs to an object and are shared between all Visual Scripts in that one, but that’s not the only scope a variable can have. Here’s a list of the remaining scopes:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Graph</strong>: Variables that<a id="_idIndexMarker425"/> can only be accessed by our current graph. No other script can read or write that variable. This is useful to save internal state, like private variables in C#.</li>
      <li class="bulletList"><strong class="keyWord">Scene</strong>: Variables that can be accessed by all objects in the current scene. When we change the scene, those variables are lost.</li>
      <li class="bulletList"><strong class="keyWord">App</strong>: Variables that can be accessed in any part of the game at any time. This is useful to move values from one scene to the other. For example, you can increase the score in one level and keep increasing it in the next, instead of restarting the score from 0.</li>
      <li class="bulletList"><strong class="keyWord">Saved</strong>: Variables whose values are kept between game runs. You can save persistent data such as the <strong class="screenText">Player Level</strong> or <strong class="screenText">Inventory</strong> to continue the quest, or simpler things such as the sound volume as set by the user in the <strong class="screenText">Options</strong> menu (if you created one).</li>
    </ul>
    <p class="normal">In this case, the <strong class="screenText">Scene</strong> scope is the one we want, as the score we intend to increase will be accessed by<a id="_idIndexMarker426"/> several objects in the scene (more on <a id="_idIndexMarker427"/>that later) and we don’t want it to persist if we reset the level to play again; it will need to be set again to 0 in each run of the level and game.</p>
    <p class="normal">To create scene variables, you can simply select the <strong class="screenText">Scene</strong> tab in the <strong class="screenText">Blackboard</strong> pane of the <strong class="screenText">Script Graph</strong> editor, while you are editing any <strong class="screenText">Script Graph</strong>, or you can also use the <strong class="screenText">Scene Variables</strong> GameObject that was created automatically when you started editing any graph. That object is the one that really holds the variables and must not be deleted. You will notice it will have a <strong class="screenText">Variables</strong> component as we have used before, but it will also have the <strong class="screenText">Scene</strong> <strong class="screenText">Variables</strong> component, indicating those variables are scene variables.</p>
    <p class="normal">In the following screenshot, you can see how we have simply added the <strong class="screenText">Score</strong> variable to the <strong class="screenText">Scene Variables </strong>tab to make it accessible in any of our Script Graphs.</p>
    <figure class="mediaobject"><img src="img/B18585_08_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.10: Adding scene variables to our game</p>
    <p class="normal">Finally, for the score-increasing behavior, we can add the following graph to our enemy. Remember, as usual, to<a id="_idIndexMarker428"/> have the C# or the Visual Scripting <a id="_idIndexMarker429"/>version of the scripts, not both.</p>
    <figure class="mediaobject"><img src="img/B18585_08_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.11: Adding score when this object is destroyed</p>
    <p class="normal">At first, this script seems pretty similar to our C# version; we add our <code class="inlineCode">scoreToAdd</code> variable of our object (<strong class="screenText">Object</strong> scope) and then we add it to the whole scene’s <code class="inlineCode">score</code> variable, as specified in the node. The main difference you can see is that here we are using the <strong class="screenText">OnDisable </strong>event instead of <strong class="screenText">OnDestroy</strong>. Actually, <strong class="screenText">OnDestroy</strong> is the correct one, but in the current version of Visual Scripting there is a bug that prevents it from working properly, so I replaced it for now. The problem with <strong class="screenText">OnDisable</strong> is that it executes whenever the object is disabled, and while the object is disabled before it is destroyed, it can also be disabled in other circumstances (for <a id="_idIndexMarker430"/>example, using <strong class="keyWord">Object Pooling</strong>, a way to recycle objects instead of destroying and instancing them constantly), but so far it is enough for us. Please consider trying first with <strong class="screenText">OnDestroy</strong> when you try this graph to see if it runs properly in your Unity or Visual Scripting package version.</p>
    <p class="normal">Something to highlight is the usage of the <strong class="screenText">Has Variable</strong> node to check if the <strong class="screenText">score variable</strong> exists. This is done because <strong class="screenText">OnDisable</strong> can be executed either at the moment of the enemy being destroyed, or when the scene changes, which we will do later this chapter with the lose/win screens. If we try to get a scene variable at that moment, we risk getting an error ourselves if the <strong class="screenText">Scene Variables</strong> object is destroyed before the <strong class="screenText">GameMode</strong> object, given the change of scene involves destroying every object in the scene first.</p>
    <p class="normal">As you may<a id="_idIndexMarker431"/> noticed <a id="_idIndexMarker432"/>by now, even if Visual Scripting is mostly extremely similar to C#, one has concepts to solve certain scenarios that the other doesn’t. Now that we know how to share variables, let’s finish some other managers that we will need later in the game.</p>
    <h2 id="_idParaDest-111" class="heading-2">Creating managers</h2>
    <p class="normal">Sometimes, we need a place<a id="_idIndexMarker433"/> to put together information about a group of similar objects, for example, <code class="inlineCode">EnemyManager</code>, to check the number of enemies and potentially access an array of them to iterate over them and do something, or maybe <code class="inlineCode">MissionManager</code>, to have access to all of the active missions in our game. Again, these cases can be considered Singletons, single objects that won’t be repeated (in our current game design), so let’s create the ones we will need in our game, that is, <code class="inlineCode">EnemyManager</code> and <code class="inlineCode">WaveManager</code>.</p>
    <p class="normal">In our game, <code class="inlineCode">EnemyManager</code> and <code class="inlineCode">WaveManager</code> will just be used as places to save an array of references to the existing enemies and waves in our game, just as a way to know their current amount. There are ways to search all objects of a certain type to calculate their count, but those functions are expensive and not recommended for use unless you really know what you are doing. So, having a Singleton with a separate updated list of references to the target object type will require more code but will perform better. Also, as the game features increase, these managers will have more functionality and helper functions to interact with those objects.</p>
    <p class="normal">Let’s start with the enemies manager by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a script <a id="_idIndexMarker434"/>called <code class="inlineCode">Enemy</code> to the <strong class="screenText">Enemy</strong> Prefab; this will be the script that will connect this object with <code class="inlineCode">EnemyManager</code> in a moment.</li>
      <li class="numberedList">Create an empty <code class="inlineCode">GameObject</code> called <code class="inlineCode">EnemyManager</code> and add a script to it called <code class="inlineCode">EnemiesManager</code>.</li>
      <li class="numberedList">Create a <code class="inlineCode">public</code> static field of the <code class="inlineCode">EnemiesManager</code> type called <code class="inlineCode">instance</code> inside the script and add the Singleton repetition check in <code class="inlineCode">Awake</code> as we did in <code class="inlineCode">ScoreManager</code>.</li>
      <li class="numberedList">Create a public field of the <code class="inlineCode">List&lt;Enemy&gt;</code> type called <code class="inlineCode">enemies</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.12: List of Enemy components</p>
    <p class="normal">A list in C# represents a dynamic array, an array capable of adding and removing objects. You will see that you can add and remove elements to this list in the editor, but keep the list empty; we will add enemies another way. Take into account that <code class="inlineCode">List</code> is in the <code class="inlineCode">System.Collections.Generic</code> namespace; you will find the <code class="inlineCode">using</code> sentence at the beginning of our script. Also, consider that you can make the list private and expose it to the code via a getter instead of making it a public field; but as usual, we will make our code as simple as possible for now: </p>
    <figure class="mediaobject"><img src="img/B18585_08_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.13: Using needed to use the List class</p>
    <div><p class="normal">Consider that <code class="inlineCode">List</code> is a class type, so it must be instantiated, but as this type has exposing support in the editor, Unity will automatically instantiate it. You must use the <code class="inlineCode">new</code> keyword to instantiate it in cases where you want a non-editor-exposed list, such as a private one or a list in a regular non-component C# class.</p>
      <p class="normal">The C# list internally is implemented as an array. If you need a linked list, use the <code class="inlineCode">LinkedList</code> collection type instead.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">In the <code class="inlineCode">Start</code> function of the <code class="inlineCode">Enemy</code> script, access the <code class="inlineCode">EnemyManager</code> Singleton and using the <code class="inlineCode">Add</code> function of the enemies list, add this object to the list. This will “register” this<a id="_idIndexMarker435"/> enemy as active in the manager, so other objects can access the manager and check for the current enemies. The <code class="inlineCode">Start</code> function is called after all of the <code class="inlineCode">Awake</code> function calls, and this is important because we need to be sure that the <code class="inlineCode">Awake</code> function of the manager is executed prior to the <code class="inlineCode">Start</code> function of the enemy to ensure that there is a manager set as the instance.</li>
    </ol>
    <div><p class="normal">The problem we solved with the <code class="inlineCode">Start</code> function is called a race condition, that is, when two pieces of code are not guaranteed to be executed in the same order, whereas <code class="inlineCode">Awake</code> execution order can change due to different reasons. There are plenty of situations in code that this will happen, so pay attention to the possible race conditions in your code. Also, you might consider using more advanced solutions such as <code class="inlineCode">lazy initialization</code> here, which can give you better stability, but again, for the sake of simplicity and exploring the Unity API, we will use the <code class="inlineCode">Start</code> function approach for now.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">In the <code class="inlineCode">OnDestroy</code> function, remove the enemy from the list to keep the list updated with just the active ones:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.14: The enemy script to register ourselves as an active enemy</p>
    <p class="normal">With this, now we<a id="_idIndexMarker436"/> have a centralized place to access all of the active enemies in a simple but efficient way. I challenge you to do the same with the waves, using <code class="inlineCode">WaveManager</code>, which will have the collection of all active waves to later check whether all waves finished their work to consider the game as won. Take some time to solve this; you will find the solution in the following screenshots, starting with <code class="inlineCode">WavesManager</code>:</p>
    <figure class="mediaobject"><img src="img/B18585_08_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.15: The full WavesManager script</p>
    <p class="normal">You will also<a id="_idIndexMarker437"/> need the <code class="inlineCode">WaveSpawner</code> script:</p>
    <figure class="mediaobject"><img src="img/B18585_08_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.16: The modified WaveSpawner script to support WavesManager</p>
    <p class="normal">As you can see, <code class="inlineCode">WaveManager</code> is created the same way <code class="inlineCode">EnemyManager</code> was, just a Singleton with a list <a id="_idIndexMarker438"/>of <code class="inlineCode">WaveSpawner</code> references, but <code class="inlineCode">WaveSpawner</code> is different. We execute the <code class="inlineCode">Add</code> function of the list in the <code class="inlineCode">Start</code> event of <code class="inlineCode">WaveSpawner</code> to register the wave as an active one, but the <code class="inlineCode">Remove</code> function needs more work. </p>
    <p class="normal">The idea is to deregister the wave from the active waves list when the spawner finishes its work. Before this modification, we used <code class="inlineCode">Invoke</code> to call the <code class="inlineCode">CancelInvoke</code> function after a while to stop the spawning, but now we need to do more after the end time. </p>
    <p class="normal">Instead of calling <code class="inlineCode">CancelInvoke</code> after the specified wave end time, we will call a custom function called <code class="inlineCode">EndSpawner</code>, which will call <code class="inlineCode">CancelInvoke</code> to stop the spawner, <code class="inlineCode">Invoke Repeating</code>, but also will call the remove-from-<code class="inlineCode">WavesManager</code>-list function to make sure the removing-from-the-list function is called exactly when <code class="inlineCode">WaveSpawner</code> finishes its work. </p>
    <p class="normal">Regarding the Visual Scripting version, we can add two lists of GameObject type to the scene variables to hold the references to the existing waves and enemies so we can keep track of them. Just search <code class="inlineCode">"List of GameObject"</code> in the search bar of the variable type selector and you will find it. In this case, the lists contain only GameObjects given that the Visual Scripting versions of <strong class="screenText">WaveSpawner</strong> and enemy scripts are not types we can reference like C# ones. If you did both C# and Visual Scripting versions of these you will see you can reference the C# versions, but we are not going to mix C# and Visual Scripting as it is out of the scope of the book, so ignore them. Anyway, given how the <strong class="screenText">Variables</strong> system of Visual Scripting works, we can still access variables inside if needed using the <strong class="screenText">GetVariable</strong> node—remember <a id="_idIndexMarker439"/>the variables are not in the Visual Scripts but in the <strong class="screenText">Variables</strong> node:</p>
    <figure class="mediaobject"><img src="img/B18585_08_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.17: Adding lists to the Scene variables</p>
    <p class="normal">Then, we can add the following to the <strong class="screenText">WaveSpawner</strong> graph:</p>
    <figure class="mediaobject"><img src="img/B18585_08_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.18: Adding elements to List</p>
    <p class="normal">We used the <strong class="screenText">Add List Item</strong> node to add our GameObject to the <strong class="screenText">waves</strong> variable. We did this as the first thing<a id="_idIndexMarker440"/> to do in the <strong class="screenText">On Start</strong> event node before anything. And to remove that wave from the active ones you will need to make the following change:</p>
    <figure class="mediaobject"><img src="img/B18585_08_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.19: Removing elements from the List</p>
    <p class="normal">We remove this <a id="_idIndexMarker441"/>spawner from the list using the <strong class="screenText">Exit</strong> flow output pin of the <strong class="screenText">For Loop</strong>, which is executed when the <code class="inlineCode">for</code> loop finishes iterating.</p>
    <p class="normal">Finally, regarding <strong class="screenText">Enemy</strong>, you will need to create a new <strong class="screenText">Enemy Script</strong> graph that will look similar:</p>
    <figure class="mediaobject"><img src="img/B18585_08_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.20: Enemy Adding and removing itself from the Lists</p>
    <p class="normal">As you can see, we <a id="_idIndexMarker442"/>simply add the enemy on <strong class="screenText">OnStart </strong>and remove it in <strong class="screenText">OnDisable</strong>. Remember to try first using <strong class="screenText">OnDestroy</strong> instead of <strong class="screenText">OnDisable</strong> due to the bug we mentioned previously. You can check these changes by playing the game while having the <strong class="screenText">Scene Variables</strong> GameObject selected and seeing how its value changes. Also remember the need to use the <strong class="screenText">Has Variable</strong> node in case we are changing scenes.</p>
    <p class="normal">Using Object managers, we now have centralized information about a group of objects, and we can add all sorts of object group logic here. We created the <code class="inlineCode">EnemiesManager</code>, <code class="inlineCode">WavesManager</code>, and <code class="inlineCode">ScoreManager</code> as centralized places to store several game systems’ information, such as the enemies and waves present in the scene, and the score as well. We also saw the Visual Scripting version, centralizing that data in the Scene Variables object, so all Visual Scripts can read that data. But aside from having this information for updating the UI (which we will do in the next chapter), we can use this information to detect whether the <a id="_idIndexMarker443"/>victory and lose conditions of our game are met, creating a <strong class="keyWord">Game Mode</strong> object to detect that.</p>
    <h1 id="_idParaDest-112" class="heading-1">Creating Game Modes</h1>
    <p class="normal">We have created <a id="_idIndexMarker444"/>objects to simulate lots of gameplay aspects of our game, but the game needs to end sometime, whether we win or lose. As always, the question is where to put this logic, and that leads us to further questions. The main questions would be, will we always win or lose the game the same way? Will we have a special level with different criteria than “kill all of the waves,” such as a timed survival? Only you know the answer to those questions, but if right now the answer is no, it doesn’t mean that it won’t change later, so it is advisable to prepare our code to adapt seamlessly to changes. </p>
    <div><p class="normal">To be honest, preparing code to adapt seamlessly to changes is almost impossible; there’s no way to have code that takes into account every possible case, and we will always need to rewrite some code sooner or later. We will try to make the code as adaptable as possible to changes; always doing that doesn’t consume lots of developing time and it’s sometimes preferable to write simple code fast than complex code slow that might not be necessary, and so we suggest you balance your time budget wisely.</p>
    </div>
    <p class="normal">To do this, we will separate the Victory and Lose conditions’ logic in its own object, which I like to call the “Game Mode” (not necessarily an industry standard). This will be a component that will oversee the game, checking conditions that need to be met in order to consider the game over. It will be like the referee of our game. The Game Mode will constantly check the information in the object managers and maybe other sources of information to detect the needed conditions. Having this object separated from other objects allows us to create different levels with different Game Modes; just use another Game Mode script in that level and that’s all.</p>
    <p class="normal">In our case, we will have a single Game Mode for now, which will check whether the number of waves and enemies becomes 0, meaning that we have killed all of the possible enemies and the game is won. Also, it will check whether the life of the player reaches 0, considering the game as lost in that situation. Let’s create it by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an empty <code class="inlineCode">GameMode</code> object and add a <code class="inlineCode">WavesGameMode</code> script to it. As you can see, we gave the script a descriptive name considering that we can add other Game Modes.</li>
      <li class="numberedList">In its <code class="inlineCode">Update</code> function, check whether the number of enemies and waves has reached <code class="inlineCode">0</code> by using the <code class="inlineCode">Enemy</code> and <code class="inlineCode">Wave</code> managers; in that case, just <code class="inlineCode">print</code> a message in the console for now. All lists have a <code class="inlineCode">Count</code> property, which will tell you the number of elements stored inside.</li>
      <li class="numberedList">Add a <code class="inlineCode">public</code> field of the <code class="inlineCode">Life</code> type called <code class="inlineCode">PlayerLife</code> and drag the player to that one; the idea is to also detect the lose condition here.</li>
      <li class="numberedList">In <code class="inlineCode">Update</code>, add another check to detect whether the life amount of the <code class="inlineCode">playerLife</code> reference<a id="_idIndexMarker445"/> reached <code class="inlineCode">0</code>, and in that case, <code class="inlineCode">print</code> a lose message in the console:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.21: Win and lose condition checks in WavesGameMode</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Play the game and test both cases, whether the player life reaches 0 or whether you have killed all enemies and waves.</li>
    </ol>
    <p class="normal">Now, it is time to replace the messages with something more interesting. For now, we will just change the current scene to a <strong class="keyWord">Win Scene</strong> or <strong class="keyWord">Lose Scene</strong>, which will only have a UI with a win or lose message and a button to play again. In the future, you can add a Main Menu scene and have an option to get back to it. Let’s implement this by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new scene (<strong class="screenText">File | New Scene</strong>) and save it, calling it <code class="inlineCode">WinScreen</code>.</li>
      <li class="numberedList">Add something to indicate that this is the win screen, such as simply a sphere with the camera pointing to it. This way we know when we changed to the win screen.</li>
      <li class="numberedList">Select the scene in the <strong class="screenText">Project View</strong> and press <em class="italic">Ctrl</em> + <em class="italic">D</em> (<em class="italic">Cmd</em> + <em class="italic">D</em> on Mac) to duplicate the scene. Rename it <code class="inlineCode">LoseScreen</code>.</li>
      <li class="numberedList">Double-click <a id="_idIndexMarker446"/>the <code class="inlineCode">LoseScreen</code> scene to open it and change the sphere to something different, maybe a cube.</li>
      <li class="numberedList">Go to <strong class="screenText">File | Build Settings</strong> to open the <strong class="screenText">Scenes in Build</strong> list inside this window. </li>
    </ol>
    <p class="normal">The idea is that Unity needs you to explicitly declare all scenes that must be included in the game. You might have test scenes or scenes that you don’t want to release yet, so that’s why we need to do this. In our case, our game will have <code class="inlineCode">WinScreen</code>, <code class="inlineCode">LoseScreen</code>, and the scene we have created so far with the game scenario, which I called <code class="inlineCode">Game</code>, so just drag those scenes from the <strong class="screenText">Project View</strong> to the list of the <strong class="screenText">Build Settings</strong> window; we will need this to make the Game Mode script change between scenes properly. Also, consider that the first scene in this list will be the first scene to be opened when we play the game in its final version (known as the build), so you may want to rearrange the list according to that:</p>
    <figure class="mediaobject"><img src="img/B18585_08_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.22: Registering the scenes to be included in the build of the game</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">In <code class="inlineCode">WavesGameMode</code>, add a <code class="inlineCode">using</code> statement for the <code class="inlineCode">UnityEngine.SceneManagement</code> namespace to enable the scene changing functions in this script.</li>
      <li class="numberedList">Replace the console <code class="inlineCode">print</code> messages with calls to the <code class="inlineCode">SceneManager.LoadScene</code> function, which will receive a string with the name of the scene to load; in this case, it would be <code class="inlineCode">WinScreen</code> and <code class="inlineCode">LoseScreen</code>. You<a id="_idIndexMarker447"/> just need the scene name, not the entire path to the file. </li>
    </ol>
    <p class="normal">If you want to chain different levels, you can create a <code class="inlineCode">public</code> string field to allow you to specify via editor which scenes to load. Remember to have the scenes added to the <strong class="screenText">Build Settings</strong>, if not, you will receive an error message in the console when you try to change the scenes:</p>
    <figure class="mediaobject"><img src="img/B18585_08_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.23: Changing scenes with SceneManager </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Play the <a id="_idIndexMarker448"/>game and check whether the scenes change properly.</li>
    </ol>
    <div><p class="normal">Right now, we picked the simplest way to show whether we lost or won, but in the future, you may want something gentler than a sudden change of scene, such as maybe waiting a few moments with <code class="inlineCode">Invoke</code> to delay that change or directly show the winning message inside the game without changing scenes. Bear this in mind when testing the game with people and checking whether they understood what happened when they were playing—game feedback is important to keep the player aware of what is happening and is not an easy task to tackle.</p>
    </div>
    <p class="normal">Regarding the Visual Scripting version, we added a new Script Graph to a separated object. Let’s examine it piece by piece to see it clearly. Let’s start with the win condition:</p>
    <figure class="mediaobject"><img src="img/B18585_08_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.24: Win condition in Visual Scripting</p>
    <p class="normal">Here, we are getting <a id="_idIndexMarker449"/>the <strong class="screenText">Enemies</strong> list from the scene context (<strong class="screenText">GetVariable</strong> node), and knowing that it contains a List, we are using the <strong class="screenText">Count Items</strong> node to check how many enemies remain in this list. Remember we have a script that adds the enemy to the list when it’s spawned and removes it when it is destroyed. We do the same for the waves, so combine the conditions with an <strong class="screenText">And</strong> node and connect it with an <strong class="screenText">If</strong> to then do something (more on that in a moment). </p>
    <p class="normal">Now let’s examine the Lose condition:</p>
    <figure class="mediaobject"><img src="img/B18585_08_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.25: Lose condition in Visual Scripting</p>
    <p class="normal">As the player’s<a id="_idIndexMarker450"/> life is not in the scene context (and shouldn’t be), and the player is a different GameObject from the one called <code class="inlineCode">GameMode</code> (the one we created specifically for this script), we need a variable of type GameObject called <strong class="screenText">player</strong> to reference it. </p>
    <p class="normal">As you can see, we dragged our player to it in the <strong class="screenText">Variables</strong> component. Finally, we used a <strong class="screenText">GetVariable</strong> to access our player reference in the graph, and then another <strong class="screenText">GetVariable</strong> to extract the life from it. We accomplished that by connecting the player reference to the <strong class="screenText">GetVariable</strong> node of the life variable. Then we repeated this for the player’s base.</p>
    <p class="normal">Finally, we load the scenes by doing the following:</p>
    <figure class="mediaobject"><img src="img/B18585_08_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.26: Loading scenes in Visual Scripting</p>
    <p class="normal">As you can <a id="_idIndexMarker451"/>see, we use the <strong class="screenText">SceneManager LoadScene (SceneName)</strong> node to load the scenes. Notice how we load scenes with the postfix <code class="inlineCode">_VisualScripting</code> given we have two versions of the scenes in our GitHub, the C# version and the Visual Scripting version.</p>
    <p class="normal">Now we have a fully functional simple game, with mechanics and win and lose conditions, and while this is enough to start developing other aspects of our game, I want to discuss some<a id="_idIndexMarker452"/> issues with our current manager approach and how to solve them with events.</p>
    <h1 id="_idParaDest-113" class="heading-1">Improving our code with events</h1>
    <p class="normal">So far, we used Unity<a id="_idIndexMarker453"/> event functions to detect situations that can happen in the game such as <code class="inlineCode">Awake</code> and <code class="inlineCode">Update</code>. There are other similar functions that Unity uses to allow components to communicate with each other, as in the case of <code class="inlineCode">OnTriggerEnter</code>, which is a way for the Rigidbody to inform other components in the GameObject that a collision has happened. In our case, we are using <code class="inlineCode">if</code> statements inside the <code class="inlineCode">Update</code> method to detect changes on other components, such as <code class="inlineCode">GameMode</code> checking whether the number of enemies has reached 0. But we can improve this if we are informed by the Enemy manager when something has changed, and just do the check at that moment, such as with the Rigidbody telling us when collisions occur instead of checking for collisions every frame. </p>
    <p class="normal">Also, sometimes, we rely on Unity events to execute logic, such as the score being given in the <code class="inlineCode">OnDestroy</code> event, which informs us when the object is destroyed, but due to the nature of the event, it can be called in situations we don’t want to add to the score, such as when the scene is changed, or the game is closed. Objects are destroyed in those cases, but not because the player killed the enemy, leading to the score increasing when it shouldn’t. In this case, it would be great to have an event that tells us that life reached 0 to execute this logic, instead of relying on the general-purpose <code class="inlineCode">OnDestroy</code> event.</p>
    <p class="normal">The idea of events is to improve the model of communication between our objects, with the assurance that at the exact moment something happens, the relevant parts in that situation are notified to react accordingly. Unity has lots of events, but we can create ones specific to our gameplay logic. Let’s start by applying this in the score scenario we discussed earlier; the idea is to make the <code class="inlineCode">Life</code> component have an event to communicate to the other components that the object was destroyed because life reached 0. </p>
    <p class="normal">There are several ways to implement this, and we will use a little bit of a different approach than the <strong class="screenText">Awake</strong> and <strong class="screenText">Update</strong> methods; we will use the <code class="inlineCode">UnityEvent</code> field type. This is a field type capable of holding references to functions to be executed when we want to, like C# delegates, but with other benefits, such as better Unity editor integration. </p>
    <p class="normal">To implement this, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In the <code class="inlineCode">Life</code> component, create a <code class="inlineCode">public</code> field of the <code class="inlineCode">UnityEvent</code> type called <code class="inlineCode">onDeath</code>. This field will represent an event where other classes can subscribe to it to be made aware when <code class="inlineCode">Life</code> reaches 0:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.27: Creating a custom event field</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">If you save the script and go to the editor, you can see the event in the Inspector. Unity<a id="_idIndexMarker454"/> events support being subscribed to methods in the editor so we can connect two objects together. We will use this in the UI scripting chapter, so let’s just ignore this for now:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.28: UnityEvents showing up in the Inspector</p>
    <div><p class="normal">You can use the generic delegate action or a custom delegate to create events instead of using <code class="inlineCode">UnityEvent</code>, and aside from certain performance aspects, the only noticeable difference is that <code class="inlineCode">UnityEvent</code> will show up in the editor, as demonstrated in <em class="italic">step 2</em>.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">When life reaches <code class="inlineCode">0</code>, call the <code class="inlineCode">Invoke</code> function of the event. This way, we will be telling any script interested in the event that it has happened:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.29: Executing the event</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In <code class="inlineCode">ScoreOnDeath</code>, rename <a id="_idIndexMarker455"/>the <code class="inlineCode">OnDestroy</code> function to <code class="inlineCode">GivePoints</code> or whatever name you prefer; the idea here is to stop giving points in the <code class="inlineCode">OnDestroy</code> event.</li>
      <li class="numberedList">In the <code class="inlineCode">Awake</code> function of the <code class="inlineCode">ScoreOnDeath</code> script, get the <code class="inlineCode">Life</code> component using <code class="inlineCode">GetComponent</code> and save it in a local variable.</li>
      <li class="numberedList">Call the <code class="inlineCode">AddListener</code> function of the <code class="inlineCode">onDeath</code> field of the <code class="inlineCode">Life</code> reference and pass the <code class="inlineCode">GivePoints</code> function as the first argument. This is known as <strong class="keyWord">subscribing</strong> our <code class="inlineCode">listener</code> method <code class="inlineCode">GivePoints</code> to<a id="_idIndexMarker456"/> the event <code class="inlineCode">onDeath</code>. The idea is to tell <code class="inlineCode">Life</code> to execute <code class="inlineCode">GivePoints</code> when the <code class="inlineCode">onDeath</code> event is invoked. This way, <code class="inlineCode">Life</code> informs us about that situation. Remember that you don’t need to call <code class="inlineCode">GivePoints</code>, but just pass the function as a field:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.30: Subscribing to the OnDeath event to give points in that scenario</p>
    <div><p class="normal">Consider calling <code class="inlineCode">RemoveListener</code> in <code class="inlineCode">OnDestroy</code>; as usual, it is convenient to unsubscribe listeners when possible to prevent any memory leak (reference preventing the GC to deallocate memory). In this scenario, it is not entirely necessary because both the <code class="inlineCode">Life</code> and <code class="inlineCode">ScoreOnDeath</code> components will be destroyed at the same time, but try to get used to this as a good practice. </p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Save, select <code class="inlineCode">ScoreManager</code> in the editor, and hit <strong class="screenText">Play</strong> to test this. Try deleting an enemy<a id="_idIndexMarker457"/> from the Hierarchy while in <strong class="screenText">Play</strong> mode to check that the score doesn’t rise because the enemy was destroyed for a reason other than their life becoming 0; you must destroy an enemy by shooting at them to see the score increase.</li>
    </ol>
    <p class="normal">Now that <code class="inlineCode">Life</code> has an <code class="inlineCode">onDeath</code> event, we can also replace the player’s <code class="inlineCode">Life</code> check from the <code class="inlineCode">WavesGameMode</code> to use the event by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an <code class="inlineCode">OnPlayerDied</code> function on the <code class="inlineCode">WavesGameMode</code> script and move the loading of the <code class="inlineCode">LoseScreen</code> scene from <code class="inlineCode">Update</code> to this function. You will be removing the <code class="inlineCode">if</code> that checks the life from the <code class="inlineCode">Update</code> method, given that the event version will replace it.</li>
      <li class="numberedList">In <code class="inlineCode">Awake</code>, add this new function to the <code class="inlineCode">onDeath</code> event of the player’s <code class="inlineCode">Life</code> component reference, called <code class="inlineCode">playerLife</code> in our script:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.31: Checking the lose condition with events</p>
    <p class="normal">As you can see, creating custom events allows you to detect more specific situations other than the <a id="_idIndexMarker458"/>defaults in Unity, and keeps your code clean, without needing to constantly ask conditions in the <code class="inlineCode">Update</code> function, which is not necessarily bad, but the event approach generates clearer code. </p>
    <p class="normal">Remember that we can lose our game also by the player’s base <code class="inlineCode">Life</code> reaching 0, so let’s create a cube that represents the object that enemies will attack to reduce the base <code class="inlineCode">Life</code>. Taking this into account, I challenge you to add this second lose condition (player’s base life reaching 0) to our script. When you finish, you can check the solution in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B18585_08_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.32: Complete WavesGameMode lose condition</p>
    <p class="normal">As you can see, we just repeated the <code class="inlineCode">life</code> event subscription, remember to create an object to <a id="_idIndexMarker459"/>represent the player’s base damage point, add a <code class="inlineCode">Life</code> script to it, and drag that one as the player base <code class="inlineCode">Life</code> reference of the Waves Game Mode. Something interesting here is that we subscribed the same function called <code class="inlineCode">OnPlayerOrBaseDied</code> to both player <code class="inlineCode">Life</code> and base <code class="inlineCode">Life</code> <code class="inlineCode">onDeath</code> events, given that we want the same result in both situations.</p>
    <p class="normal">Now, let’s keep illustrating this concept by applying it to the managers to prevent the Game Mode from checking conditions every frame: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a <code class="inlineCode">UnityEvent</code> field to <code class="inlineCode">EnemyManager</code> called <code class="inlineCode">onChanged</code>. This event will be executed whenever an enemy is added or removed from the list.</li>
      <li class="numberedList">Create two functions, <code class="inlineCode">AddEnemy</code> and <code class="inlineCode">RemoveEnemy</code>, both receiving a parameter of the <code class="inlineCode">Enemy</code> type. The idea is that instead of <code class="inlineCode">Enemy</code> adding and removing itself from the list directly, it should use these functions.</li>
      <li class="numberedList">Inside these two functions, invoke the <code class="inlineCode">onChanged</code> event to inform others that the enemies list has been updated. The idea is that anyone who wants to add or remove enemies from the list needs to use these functions:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.33: Calling events when enemies are added or removed</p>
    <div><p class="normal">Here, we have the problem that nothing stops us from bypassing those two functions and using the list directly. You can solve that by making the list private and exposing it using the <code class="inlineCode">IReadOnlyList</code> interface. Remember that this way, the list won’t be visible in the editor for debugging purposes.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Change<a id="_idIndexMarker460"/> the <code class="inlineCode">Enemy</code> script to use these functions:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.34: Making the Enemy use the add and remove functions</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Repeat the same<a id="_idIndexMarker461"/> process for <code class="inlineCode">WaveManager</code> and <code class="inlineCode">WaveSpawner</code>, create an <code class="inlineCode">onChanged</code> event, and create the <code class="inlineCode">AddWave</code> and <code class="inlineCode">RemoveWave</code> functions and call them in <code class="inlineCode">WaveSpawner</code> instead of directly accessing the list. This way, we are sure the event is called when necessary as we did with <code class="inlineCode">EnemyManager</code>. Try to solve this step by yourself and then check the solution in the following screenshot, starting with <code class="inlineCode">WavesManager</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.35: WaveManager OnChanged event implementation</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Also, <code class="inlineCode">WavesSpawner</code> needed <a id="_idIndexMarker462"/>the following changes:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.36: Implementing the AddWave and RemoveWave functions</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">In <code class="inlineCode">WavesGameMode</code>, rename <code class="inlineCode">Update</code> to <code class="inlineCode">CheckWinCondition</code> and subscribe this function to the <code class="inlineCode">onChanged</code> event of <code class="inlineCode">EnemyManager</code> and the <code class="inlineCode">onChanged</code> event of <code class="inlineCode">WavesManager</code>. The idea <a id="_idIndexMarker463"/>is to check for the number of enemies and waves being changed only when necessary. Remember to do the subscription to the events in the <code class="inlineCode">Start</code> function due to the Singletons being initialized in <code class="inlineCode">Awake</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_08_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.37: Checking the win condition when the enemies or waves amount is changed</p>
    <p class="normal">Regarding the<a id="_idIndexMarker464"/> Visual Scripting version, let’s start checking the lose condition with events, checking first some changes needed in the <strong class="screenText">Life Script Graph</strong>:</p>
    <figure class="mediaobject"><img src="img/B18585_08_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.38: Triggering a Custom Event in our Life graph</p>
    <p class="normal">First, after destroying the object when life reaches 0, we use the <strong class="screenText">Trigger Custom Event</strong> node, specifying the name of our event is <code class="inlineCode">OnDeath</code>. This will tell anyone waiting for the execution of the <code class="inlineCode">OnDeath</code> event that we did. Remember, this is our <strong class="screenText">Life Script Graph</strong>. Be sure to call destroy after triggering the event—while most of the time the order doesn’t matter, given that the destroy action doesn’t actually happen until the end of the frame, sometimes it can cause issues, so better be safe here. In this case, Game Mode should listen to the <a id="_idIndexMarker465"/>player’s <code class="inlineCode">OnDeath</code> event, so let’s make the following change in our <strong class="screenText">Game Mode Graph</strong>:</p>
    <figure class="mediaobject"><img src="img/B18585_08_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.39: Listening to the OnDeath event of Player in Visual Scripting</p>
    <p class="normal">We used the <strong class="screenText">CustomEvent</strong> node connecting it to the player reference of our GameMode. This <a id="_idIndexMarker466"/>way we are specifying that if that player executes that event, we will execute the <strong class="screenText">Load Scene</strong> node. Remember that the player reference is crucial to specify from whom we want to execute the <code class="inlineCode">OnDeath</code> event, and remember that the <strong class="screenText">Life Visual Graph</strong> will also be present in the enemies and we are not interested in them here. Also, remember to remove the <code class="inlineCode">If</code> node and the condition nodes we used previously to detect this – the only <code class="inlineCode">If</code> our Game Mode will have is the one for the win condition. </p>
    <p class="normal">Essentially, we made any object with the <code class="inlineCode">Life</code> script have an <code class="inlineCode">OnDeath</code> event, and we made the GameMode listen to the <code class="inlineCode">OnDeath</code> event of the player specifically.</p>
    <p class="normal">We could also do events for enemies and waves, but that would complicate our graphs somewhat, given that we don’t have <code class="inlineCode">WaveManager</code> or <code class="inlineCode">EnemyManager</code> in the Visual Scripting versions. We could certainly create those to accomplish this, but sometimes the point of using Visual Scripting is to create simple logic, and these kinds of changes tend to make a graph grow quite a bit.</p>
    <p class="normal">Another possible solution is to make the enemy and wave directly inform the Game Mode. We could use <strong class="screenText">Trigger Custom Event</strong> in the enemies and waves, connecting that node to the Game Mode, to finally let the Game Mode have a <strong class="screenText">Custom Event</strong> node from which to listen. The issue is that that would violate the correct dependencies between our objects; lower-level objects such as enemies and waves shouldn’t communicate with higher-level objects such as Game Mode. Essentially, Game Mode was supposed to be an overseer. If we apply the solution described in this paragraph, we won’t be able to have an enemy in another scene or game without having a Game Mode. So, for simplicity and code decoupling purposes, let’s keep the other conditions as they are—the more complex logic such as this will be probably handled in C# in full production projects.</p>
    <p class="normal">Yes, using events<a id="_idIndexMarker467"/> means that we have to write more code than before, and in terms of functionality, we didn’t obtain anything new, but in bigger projects, managing conditions through <code class="inlineCode">Update</code> checks will lead to different kinds of problems as previously discussed, such as race conditions and performance issues. Having a scalable code base sometimes requires more code, and this is one of those cases. </p>
    <p class="normal">Before we finish, something to consider is that Unity events are not the only way to create this kind of event communication in Unity; you will find a similar approach called <strong class="keyWord">Action</strong>, the <a id="_idIndexMarker468"/>native C# version of events, which I recommend you look into if you want to see all of the options out there.</p>
    <h1 id="_idParaDest-114" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we finished an important part of the game: the ending, both by victory and by defeat. We discussed a simple but powerful way to separate the different layers of responsibilities by using managers created through Singletons, to guarantee that there isn’t more than one instance of every kind of manager and simplifying the connections between them through static access. Also, we visited the concept of events to streamline communication between objects to prevent problems and create more meaningful communication between objects.</p>
    <p class="normal">With this knowledge, you are now able not only to detect the victory and lose conditions of the game but can also do it in a better-structured way. These patterns can be useful to improve our game code in general, and I recommend you try to apply them in other relevant scenarios.</p>
    <p class="normal">In the next chapter, we are going to start <em class="italic">Part 3</em> of the book, where we are going to see different Unity systems to improve the graphics and audio aspects of our game, starting by seeing how we can create materials to modify aspects of our objects, and create shaders with Shader Graph.</p>
    <h1 class="heading-1">Join us on Discord!</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. </p>
    <p class="normal">Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. </p>
    <p class="normal">Scan the QR code or visit the link to join the community.</p>
    <p class="normal"><img src="img/Nicolas_QR_Code.png" alt=""/></p>
    <p class="normal"><a href="Chapter_8.xhtml">https://packt.link/handsonunity22</a></p>
  </div>
</body></html>