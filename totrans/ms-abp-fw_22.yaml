- en: '*Chapter 17*: Building Automated Tests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building automated tests is an essential `GetRegistrationOrNull` practice to
    create maintainable software solutions and is a fast and repeatable way of validating
    the software. ABP Framework and the ABP startup solution template are designed
    with testability in mind. We've already seen an example of writing a simple integration
    test with ABP Framework in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044),
    *Step-By-Step Application Development*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will understand the ABP test infrastructure and build unit
    and integration tests for your ABP-based solutions. You will learn about data
    seeding for tests, mocking the database, and testing different kinds of objects.
    You will also learn the basics of automated tests such as assertions, mocking
    and replacing services, and dealing with exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the main topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ABP test infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter are mostly based on the EventHub solution I introduced
    in [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130), *Understanding the
    Reference Solution*. Please refer to that chapter to learn how to download the
    source code of the EventHub solution.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ABP test infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ABP's startup solution template includes preconfigured test projects to build
    unit and integration tests for your solution. While you can write your tests without
    understanding the complete structure, I think it is worth exploring this so that
    you can understand how it works and customize it when you need it. We'll start
    by exploring the `test` projects.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the test projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `test` projects that get created when you
    create a new ABP solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Test projects in the ABP startup solution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.01_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.1 – Test projects in the ABP startup solution
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows the `test` projects for a solution named `ProductManagement`,
    with the MVC/Razor Pages UI and the `test` project list may be slightly different
    if you use a different UI or database provider, but the fundamental logic is the
    same. The following list explains the projects in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductManagement.HttpApi.Client.ConsoleTestApp`: A very simple console application
    to manually test the HTTP API endpoints of your application. So, this is not a
    part of our automated test infrastructure, and you can ignore it for this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductManagement.TestBase`: A project that is shared by the other test projects.
    It has references to the base test libraries and includes data seeding and some
    other base configuration code. It doesn''t contain any test class normally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductManagement.EntityFrameworkCore.Tests`: You can build tests for EF Core
    integration code in this project, such as your custom repositories. This project
    also configures a SQLite in-memory database for your tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductManagement.Domain.Tests`: Use this project to build tests for your
    domain layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductManagement.Application.Tests`: Use this project to build tests for
    your application layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductManagement.Web.Tests`: Use this project to build tests for your MVC/Razor
    Pages UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution uses some libraries as the test infrastructure, as explained in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the test libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ProductManagement.TestBase` project has reference to the following NuGet
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xunit`: xUnit is one of the most popular test frameworks for .NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shouldly`: A library to write the assertion code in an easy and readable format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSubstitute`: A library to mock objects in unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Volo.Abp.TestBase`: ABP''s package to easily create ABP-integrated test classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see how to use the basics of these libraries in the *Building unit tests*
    and *Building integration tests* sections. Before starting to write our tests,
    let's see how we can run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, I will show two ways of running the tests. The first way is
    to use an IDE that supports running test execution. I will use Visual Studio as
    an example. You can open the **Test Explorer** window from the **Test** | **Test
    Explorer** item on the main menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Test Explorer in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.02_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.2 – Test Explorer in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductManagement` application built in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044),
    *Step-By-Step Application Development*, and the source code can be found at [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio runs the tests one by one by default, and thus it takes a long
    time to run all the tests. You can click the down arrow icon near the cog icon
    in **Text Explorer** and select the **Run Tests In Parallel** option (see *Figure
    17.3*) to run the tests in parallel so that it takes significantly less time to
    run them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – Running tests in parallel in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.03_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.3 – Running tests in parallel in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework and the startup solution template have been designed to support
    running tests in parallel so that tests don't affect each other.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative way to run tests is to use the `dotnet test` command in the root
    directory of your solution. It automatically discovers and runs all the tests
    and reports the test result in the command-line terminal. This command exits with
    a `0` (success) return code if all the tests succeed; otherwise, if any test fails,
    it exits with a `1` return code. This command is especially useful if you build
    a **continuous integration** (**CI**) pipeline where you automatically run the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: You've learned the test structure of the ABP startup solution and have run the
    automated tests. Now, we can start to build our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Building unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see different types of unit tests. We will begin by
    testing a static class, then we will write tests for a class with no dependencies.
    We will continue with a class with dependent services and learn how to mock these
    dependencies to unit test that class. We will learn the basics of writing automated
    test code with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the simplest case—testing static classes.
  prefs: []
  type: TYPE_NORMAL
- en: Testing static classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A static class with no state and external dependencies is the easiest class
    to test. `EventUrlHelper` is a static class (in the `EventHub.Domain` project
    of the EventHub solution) and is used to convert an event''s title to a proper
    URL part. The following test class (in the `EventHub.Domain.Tests` project of
    the EventHub solution) tests the `EventUrlHelper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first rule is that the test class should be `public`. Otherwise, you can't
    see it in `[Fact]` attribute is defined by the `xUnit` library. Any public method
    with the `[Fact]` attribute is considered a test case and is automatically discovered
    by `Should_Convert_Url_To_Kebab_Case`, and only test the functionality related
    to `kebab-case`.
  prefs: []
  type: TYPE_NORMAL
- en: The test code in this example is very simple. We call the static `EventUrlHelper.ConvertTitleToUrlPart`
    method with a sample title value, then compare the result with the value we expect
    it to be. The `Assert` class is defined by `xUnit`, with many methods to define
    our expectations. The test case succeeds only if the given values are equal. Otherwise,
    we see a red icon for the test case in **Test Explorer** with an error message
    indicating what's wrong with the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can right-click on a specific test in **Test Explorer** to run it and see
    the result, as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 – Running a specific test in Test Explorer in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.04_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.4 – Running a specific test in Test Explorer in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common `xUnit` attribute is `[Theory]`, which provides parameters to
    a test method and tests it for each parameter set. Assuming that we want to run
    the test with different event URLs, we can rewrite the test method, as shown in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`xUnit` runs this test method for each `[InlineData]` set separately and passes
    the `title` and `url` parameters as the given data. If you look at **Test Explorer**
    again, you will see these three test cases there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – Using the [Theory] attribute for unit tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.05_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.5 – Using the [Theory] attribute for unit tests
  prefs: []
  type: TYPE_NORMAL
- en: I also used the `Shouldly` library for the assertion in this example. The `result.ShouldBe(url)`
    expression is simpler to write and read than the `Assert.Equal(url, result)` expression.
    The `Shouldly` library works with extension methods such as that, and I will use
    it in future examples.
  prefs: []
  type: TYPE_NORMAL
- en: Testing static classes (with no state and external dependencies) was easy. We've
    also learned some `xUnit` and `Shouldly` features. The next section continues
    with testing simple classes without a service dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Testing classes with no dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some classes, such as entities, may have no dependency on other services. Testing
    these classes is relatively easy since we don't need to prepare the dependencies
    to make the class work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test method tests the `Event` class''s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, I''ve passed a valid list of parameters so that it doesn''t
    throw an exception, and the test succeeds. The following example tests for an
    exception case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I intentionally passed the end time as 2 days earlier than the start time. I
    am expecting the constructor to throw a `BusinessException` exception by using
    the `Assert.Throws<T>` method. If the code block inside the `Throws` method throws
    an exception of type `BusinessException`, then the test passes; otherwise, the
    test will fail. I am also checking the error code with the `ShouldBe` extension
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a method that tests another method of the `Event` class. The following
    example creates a valid `Event` object, then changes its start and end times,
    and finally checks whether the times were changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This example fully implements the common **Arrange-Act-Assert** (**AAA**) test
    pattern, detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Arrange* part prepares the objects we need to work on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Act* part executes the actual code we want to test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Assert* part checks whether the expectations are met.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I suggest separating your test method's body with these comment lines to make
    what you are testing and asserting explicit. In this example, we used the `SetTime`
    method of the `Event` class to change the event times. The `SetTime` method also
    publishes a local event, so I checked it too in the *Assert* part.
  prefs: []
  type: TYPE_NORMAL
- en: As you see in the examples, if the class we want to test has no external dependencies,
    we can simply create an instance and execute the methods on it. In the next section,
    we will see how to deal with external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Testing classes with dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most services have dependencies on other services. We use the **dependency injection**
    (**DI**) system to take these dependencies into the service's constructor. The
    purpose of unit testing is to test a class as isolated from other classes because
    unit tests should generally have only one reason to fail. We should somehow exclude
    the dependencies while testing the target class. In this way, our test is affected
    by the changes in the target class but not affected by changes in other classes.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is a technique used in unit testing to replace a target class's dependencies
    with fake implementations so that the test isn't affected by the target class's
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: I will test the `IsPastEvent` method of the `EventRegistrationManager` class
    as an example. The `IsPastEvent` method gets an event.
  prefs: []
  type: TYPE_NORMAL
- en: '`EventRegistrationManager` is a domain service and takes three external services
    in its constructor, as shown in the following simplified code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We should pass instances of these three external services to be able to create
    an `EventRegistrationManager` object. The following code block shows how I''ve
    written a test method for the `IsPastEvent` method of that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The test code starts by creating a fake `IClock` object using the `Substitute.For<T>`
    utility method of the `NSubstitute` library. The `clock.Now.Returns(DateTime.Now)`
    statement configures the fake object so that it returns `DateTime.Now` whenever
    the `clock.Now` property is called. We do that since the `IsPastEvent` method
    will call the `clock.Now` property. That means we should know the internal implementation
    details of the unit-tested method to test it properly.
  prefs: []
  type: TYPE_NORMAL
- en: Since I know that the `IsPastEvent` method won't use the `IEventRegistrationRepository`
    and `IGuidGenerator` services, I can pass them as `null` in the constructor of
    the `EventRegistrationManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I've called the `IsPastEvent` method of the `EventRegistrationManager`
    class with an example event and checked the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a more complex example. This time, we are testing the `RegisterAsync`
    method of the `EventRegistrationManager` class. The code is illustrated in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, I've created an `Event` object and an `IdentityUser` object because the
    `RegisterAsync` method gets these parameters. Then, I've mocked the `EventRegistrationManager`
    dependencies. Since the `RegisterAsync` method uses all the dependencies, I had
    to mock them all. See how I configured the fake repository to return `false` when
    the `ExistsAsync` method is called. The `RegisterAsync` method uses the `ExistsAsync`
    method to check whether there is already a registration with the same event and
    user.
  prefs: []
  type: TYPE_NORMAL
- en: After executing the `RegisterAsync` method, I should somehow check whether the
    registration is complete. I can use the `Received` method of `NSubstitute` to
    check whether the repository's `InsertAsync` method is called with an `EventRegistration`
    object with the specified event and **user identifiers** (**UIDs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I''ve covered the basics of unit testing. Unit tests have
    two main advantages compared to integration tests, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: They run fast because only the tested class really works. All others are mocked
    and typically have no execution cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make it easier to investigate problems. If a class doesn't work properly,
    only the tests working on that class fail, so you can easily find the problem's
    source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, writing and maintaining unit tests is hard when your classes have dependencies.
    Unit tests also can't tell much about whether your class will properly work at
    runtime integrated with other services. That brings us to integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Building integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to build automated tests for your services
    as integrated into ABP Framework and other infrastructure components. We will
    start by understanding ABP integration, how the database is used in integration
    tests, and how to create initial test data. Then, we will write example tests
    for repositories, domain, and application services. Let's start with ABP integration.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ABP integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP provides the `Volo.Abp.TestBase` NuGet package, which includes the `AbpIntegratedTest<TStartupModule>`
    base class for our integration tests. We can inherit from that class to write
    tests as completely integrated to ABP Framework. The following example shows the
    main parts of such a test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, I''ve inherited from the `AbpIntegratedTest<MyTestModule>`
    class, where `MyTestModule` is my startup module class. `MyTestModule` should
    depend on `AbpTestBaseModule`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor of `SampleTestClass`, I've resolved an example service using
    the `GetRequiredService` method and assigned it to a class field. We could resolve
    a service from the DI system since all the infrastructure is available, just like
    at runtime. I don't need to care about the dependencies of the service. Finally,
    I called a method of the example service in my test method.
  prefs: []
  type: TYPE_NORMAL
- en: While writing integration tests is that simple, test projects in the startup
    template have a little more. Check the `EventHubTestBaseModule` class (in the
    `EventHub.TestBase` project of the EventHub solution). You will see that it is
    disabling background jobs and authorization, seeding some test data, and doing
    other configurations.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned the basics of integrating with ABP in our test classes. In the
    next section, you will learn how to deal with the database in tests.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The database is one of the most fundamental aspects when you are building integration
    tests. Assume that you are using SQL Server in your solution. Using a real SQL
    Server database has some fundamental problems; your tests affect each other since
    they will work on the same database. A test's change in the database may break
    subsequent tests. You may not run tests in parallel. Test execution speed will
    be slow since your application will communicate to SQL Server as an external process.
    No need to mention that SQL Server should be installed and available in your test
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core provides an in-memory database option, but it is very limited. For example,
    it has no transaction support and cannot execute SQL commands. So, I don't suggest
    using it at all.
  prefs: []
  type: TYPE_NORMAL
- en: The ABP startup template has been configured to use SQLite in-memory database
    for EF Core (it also uses an in-memory database for MongoDB using the `Mongo2Go`
    library). SQLite is a real relational database management system and will be sufficient
    for most of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Check the `EventHubEntityFrameworkCoreTestModule` class (in the `EventHub.EntityFrameworkCore.Tests`
    project of the EventHub solution) to see the SQLite setup. It creates a separate
    in-memory SQLite database for each test case, creates tables inside the database,
    and seeds the test data. In this way, every test method starts with the same initial
    state and doesn't affect other tests. We will see seeding the test data in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding the test data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing tests against an empty database is not so practical. Assume that you
    want to query events in the database or want to test whether the event registration
    code works. You first need to insert some entities into the database. It can be
    tedious to prepare the database for each test. Instead, we can create some initial
    entities in the database that are available for each test.
  prefs: []
  type: TYPE_NORMAL
- en: The ABP startup solution template uses ABP's data seeding system to fill some
    initial data into the database. See the `EventHubTestDataSeedContributor` class
    (in the `EventHub.TestBase` project of the EventHub solution). It creates some
    users, organizations, and events in the database, so we can directly write tests
    assuming that the initial data exists.
  prefs: []
  type: TYPE_NORMAL
- en: We've talked about ABP's integration test infrastructure, mocking and seeding
    the database. Now, we can write some integration tests, starting from the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Testing repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see the `EventRegistrationRepository_Tests` class (in the `EventHub.Domain.Tests`
    project of the EventHub solution) as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This class inherits the `EventHubDomainTestBase` class, which is indirectly
    inherited from the `AbpIntegratedTest<T>` class we've explored in the *Understanding
    the ABP integration* section. So, in the constructor, we could resolve the `IEventRegistrationRepository`
    and `EventHubTestData` services from the DI system. You can investigate the `EventHubTestData`
    class yourself (in the `EventHub.TestBase` project of the EventHub solution).
    It basically stores the `Id` values of the entities that are initially seeded
    into the database to reach them in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the first test method of the `EventRegistrationRepository_Tests`
    class. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This test simply executes the `ExistsAsync` method and checks the result to
    be `false`. It should return `false` because we know the user `John` has not registered
    to the given event. We know that because we''ve written the initial data in the
    database (see the *Seeding the test data* section). Let''s write another test,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This time, we are creating the registration record in the database, so we expect
    the same `ExistsAsync` call to return `true`. In this way, we can prepare the
    database for a particular test to get the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP''s repositories provide the `GetQueryableAsync` method, so we can directly
    use `queryable` in tests):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This method queries the same registration using the `Where` and `FirstOrDefaultAsync`
    LINQ extension methods. If you try to run this test, you will see it throws an
    exception (of type `ObjectDisposedException`) because the `GetQueryableAsync`
    method requires an active `WithUnitOfWorkAsync` method to execute code in a UoW,
    so we can fix the test code as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see the source code of the `WithUnitOfWorkAsync` method. It just uses
    `IUnitOfWorkManager` to create a UoW scope.
  prefs: []
  type: TYPE_NORMAL
- en: We've created some test methods for repositories. You can test any service (that
    was registered to the DI system) in the same way. I will show some example tests
    for domain and application services in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Testing domain services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing domain services is similar to testing repositories since you should
    also care about the UoW for domain services. The following code block shows an
    example test case from the `EventManager_Tests` class (in the `EventHub.Domain.Tests`
    project of the EventHub solution):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The test's purpose is to increase the capacity of an event using the `EventManager`
    domain service and see whether it works. It uses the `WithUnitOfWorkAsync` method
    to call the `SetCapacityAsync` method because the `SetCapacityAsync` method internally
    executes the `CountAsync` LINQ extension method and requires an active UoW. If
    you don't want to check the domain service's internals in every case, I suggest
    always starting a UoW while using domain services or repositories in your tests.
    After the UoW, I've re-queried the same event from the database to check whether
    the capacity has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: You can explore the `EventManager_Tests` class and other test classes inside
    the `EventHub.Domain.Tests` project for all details and more complex test cases.
    In the next section, I will show testing application services.
  prefs: []
  type: TYPE_NORMAL
- en: Testing application services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will examine one more test, written for the `EventRegistrationAppService`
    class (defined in the `EventHub.Application` project of the EventHub solution).
    `EventRegistrationAppService_Tests` (defined in the `EventHub.Application.Tests`
    project of the EventHub solution) is the test class that contains tests for that
    application service. You can explore the class inside the solution. Here, I will
    show it partially to explain how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the test method for registering an event by the current user.
    You can see this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line sets the current user to the admin user, which is needed because
    the `EventRegistrationAppService.RegisterAsync` method works for the current user.
    Let''s see how the `Login` method was implemented, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It configures the `_currentUser` object to return the given `userId` value
    when we use its `Id` property. As you may guess, `_currentUser` is a mock (fake)
    object of type `ICurrentUser`. The mock object is configured in the `AfterAddApplication`
    method, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method overrides the `AfterAddApplication` method of the `AbpIntegratedTest<T>`
    base class. We can override this method to make a last touch to the DI configuration
    before the initialization phase completes. Here, I've created a mock object using
    the `NSubstitute` library and added the object as a singleton service (remember
    that the last registered class/object is used for a service). In this way, I can
    change its value, and all the services using `ICurrentUser` are affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the current user, the test method calls the `EventRegistrationAppService.RegisterAsync`
    method as you normally do. Finally, I checked the database to see whether a registration
    record was saved. The `GetRegistrationOrNull` method''s implementation is shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I've used `WithUnitOfWorkAsync` here again because the `FirstOrDefaultAsync`
    method requires an active UoW.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen in the examples, writing integration tests is easy and mostly
    straightforward with ABP Framework. We rarely need to mock services and deal with
    the dependencies of the service we are targeting for the test.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests run slower than unit tests, but they allow you to test the
    integration between components and additionally test database queries in a way
    you can't with unit tests. I suggest going balanced and pragmatic—build both unit
    and integration tests for your solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preparing tests is an essential practice for building any kind of software solution.
    As we've seen in this chapter, ABP provides the fundamental infrastructure to
    help you write tests for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored unit and integration testing with ABP Framework with examples.
    I've selected examples from the EventHub solution. That solution also contains
    more complex tests, and I suggest you explore them.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be writing automated tests to cover your server-side code.
    You've seen how the ABP startup solution is structured and how the database was
    mocked. You've learned how to deal with exceptions, UoWs, data seeding, object
    mocking, and other common test patterns.
  prefs: []
  type: TYPE_NORMAL
- en: This was the last chapter of the book. If you've read so far and followed the
    examples, you've learned the fundamentals, features, and best practices of using
    ABP Framework. You are more than ready to build your ABP based solutions to realize
    your software ideas.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to this book on your development journey, and also check ABP Framework's
    documentation on [https://docs.abp.io](https://docs.abp.io) whenever you need
    more details and up-to-date information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, feel free to create issues on ABP Framework''s GitHub repository if
    you have any problem: [https://github.com/abpframework/abp](https://github.com/abpframework/abp).
    I will continue to be one of the active contributors of this great project and
    try to answer your questions.'
  prefs: []
  type: TYPE_NORMAL
- en: I am Halil İbrahim Kalkan, author of Mastering ABP Framework. I really hope
    you enjoyed reading this book and found it useful for increasing your productivity
    and efficiency in ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: It would really help me (and other potential readers!) if you could leave a
    review on Amazon sharing your thoughts on Mastering ABP Framework here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the link below or scan the QR code to leave your review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/r/1801079242](https://packt.link/r/1801079242)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your review will help me to understand what’s worked well in this book, and
    what could be improved upon for future editions, so it really is appreciated.
  prefs: []
  type: TYPE_NORMAL
- en: Best Wishes,
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Author_signature.jpg)![](img/Author_photo.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Halil İbrahim Kalkan
  prefs: []
  type: TYPE_NORMAL
