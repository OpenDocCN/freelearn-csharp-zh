- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: 'From Prototype to Executable: Generating and Debugging Your Game'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从原型到可执行文件：生成和调试你的游戏
- en: So, we have reached a point where the game is in good enough shape to test it
    with real people, a point where theoretical design meets practical application.
    The problem is that we can’t pretend people will install Unity, open a project,
    and hit **Play**. They want to receive a nice executable file to double-click
    and play right away. In this chapter, in the first section, we are going to discuss
    how we can convert our project into an easy-to-share executable format, and then
    in the second section, we will see how to apply the profiling and debugging techniques
    learned in the previous chapter, but this time, on the build. After reading this
    chapter, you will be able to detect potential performance bottlenecks and tackle
    the most common ones, leading to an increase in your game’s frame rate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经达到了一个阶段，游戏的状态足够好，可以用来测试真实用户，这是一个理论设计遇到实际应用的时刻。问题是，我们不能假装人们会安装Unity，打开一个项目，然后点击**Play**。他们希望得到一个可以直接双击并立即播放的漂亮的可执行文件。在本章的第一节中，我们将讨论如何将我们的项目转换成一个易于分享的可执行格式，然后在第二节中，我们将看到如何应用上一章学到的性能分析和调试技术，但这次是在构建过程中。阅读完本章后，你将能够检测潜在的性能瓶颈并解决最常见的瓶颈，从而提高你游戏的帧率。
- en: 'In this chapter, we will examine the following build concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下构建概念：
- en: Building a project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建项目
- en: Debugging the build
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建调试
- en: Let’s start by seeing how we can build the project to get a shareable executable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何构建项目以获得一个可分享的可执行文件。
- en: Building a project
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建项目
- en: In software development (including video games), the process of taking the source
    files of our project and converting them into an executable format is called a
    **build**. The generated executable files are optimized to achieve the maximum
    performance possible given the configuration of the project. We can’t judge performance
    while editing the game due to the changing nature of a project. It would be time-consuming
    to prepare the assets in their final form while editing the game.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发（包括视频游戏）中，将我们项目的源文件转换为可执行格式的过程被称为**构建**。生成的可执行文件针对项目的配置进行了优化，以实现可能的最大性能。由于项目的不断变化，我们在编辑游戏时无法判断性能。在编辑游戏的同时准备最终形式的资产将非常耗时。
- en: Also, the generated files are in a difficult-to-read format. They won’t have
    the textures, audio, and source code files just there for the user to look at.
    They will be formatted in custom file structures, so in a way, they’re protected
    from users stealing them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，生成的文件格式难以阅读。它们不会包含纹理、音频和源代码文件，供用户查看。它们将以自定义的文件结构格式化，因此从某种意义上说，它们被保护免受用户窃取。
- en: Actually, there are several tools to extract source files from video games,
    especially from a widely used engine such as Unity. You can extract assets such
    as textures and 3D models, and there are even programs that extract those assets
    directly from the VRAM, so we cannot guarantee that the assets won’t be used outside
    the game. In the end, users have the data of those assets on their disks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有几个工具可以从视频游戏中提取源文件，尤其是从广泛使用的引擎，如Unity中提取。你可以提取如纹理和3D模型这样的资产，甚至有程序可以直接从VRAM中提取这些资产，所以我们不能保证这些资产不会被用于游戏之外。最终，用户将拥有这些资产的磁盘数据。
- en: 'The build process is pretty simple when you target desktop platforms such as
    Windows, Mac, or Linux, but there are a few settings we need to keep in mind before
    building. The first configuration we are going to see is the scenes list. We have
    already discussed this, but it’s a good moment to remember that it is important
    to set the first element of this list to the scene that will be loaded first.
    Remember, you can do this by going to **File** | **Build Settings** and dragging
    your desired starter scene to the top of the list. In our case, we defined the
    game scene as the first scene, but in a real game, it would be ideal to create
    a **Main Menu** scene using the UI and some graphics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你针对桌面平台，如Windows、Mac或Linux时，构建过程相当简单，但在构建之前，我们需要注意一些设置。我们将首先看到的第一项配置是场景列表。我们已经讨论过这个问题，但这是一个很好的时刻来记住，设置列表的第一个元素为第一个要加载的场景是很重要的。记住，你可以通过转到**文件**
    | **构建设置**并将你希望作为启动场景的所需场景拖到列表顶部来完成此操作。在我们的例子中，我们将游戏场景定义为第一个场景，但在实际游戏中，使用UI和一些图形创建一个**主菜单**场景将是理想的：
- en: '![A picture containing text, font, screenshot, white  Description automatically
    generated](img/B21361_19_01_PE.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、截图、白色的图片，描述自动生成](img/B21361_19_01_PE.png)'
- en: 'Figure 19.1: The Scenes In Build list order'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1：构建列表中的场景顺序
- en: 'Another setting you can change here is the target platform, which is the target
    operating system that the build will be created for. Usually, this is set as the
    same operating system you are developing on, but in case you are, as an example,
    developing on a Mac, and you want to build for Windows, just set the **Target
    Platform** setting to **Windows**. That way, the result will be an .`exe` file
    (a Windows executable file) instead of an .`app` file (the Mac executable file).
    You may see Android and iOS as other target platforms, but making mobile games
    requires other considerations that we are not going to discuss in this book:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在此处更改的另一个设置是目标平台，即构建将为其创建的目标操作系统。通常，这设置为与您正在开发的相同操作系统，但如果您，例如，在Mac上开发，并希望为Windows构建，只需将**目标平台**设置更改为**Windows**。这样，结果将是一个`.exe`文件（Windows可执行文件）而不是`.app`文件（Mac可执行文件）。您可能还会看到Android和iOS作为其他目标平台，但制作移动游戏需要考虑其他因素，这些因素我们将在本书中不讨论：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_19_02_PE.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成，中等置信度](img/B21361_19_02_PE.png)'
- en: 'Figure 19.2: Target Platform'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2：目标平台
- en: 'In the same window, you can click the **Player Settings** button at the bottom
    left, or just open the **Edit** | **Project Settings** window and click on the
    **Player** category to access the rest of the **Build Settings**. Unity calls
    the generated executable the `Player`. Here, we have a set of configurations that
    will affect how the build or player behaves, and here is a list of the basic ones:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一窗口中，您可以点击左下角的**玩家设置**按钮，或者直接打开**编辑** | **项目设置**窗口，点击**玩家**类别以访问其余的**构建设置**。Unity将生成的可执行文件称为`Player`。在此处，我们有一组配置，将影响构建或玩家的行为，以下是基本配置列表：
- en: '**Company Name**: This is the name of the company that developed the game,
    which is used by Unity to create certain file paths and will be included in the
    executable information.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公司名称**：这是开发游戏的公司的名称，Unity将使用它来创建某些文件路径，并将包含在可执行文件信息中。'
- en: '**Product Name**: This is the name of the game in the window title bar and
    executable file.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品名称**：这是窗口标题栏和可执行文件中的游戏名称。'
- en: '**Default Icon**: Here, you can select a texture to act as the executable icon.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认图标**：在此处，您可以选择一个纹理作为可执行文件图标。'
- en: '**Default Cursor**: You can set a texture to replace the regular system cursor.
    If you do that, remember to set the **Cursor Hotspot** property to the pixel of
    the image you want the cursor to click on.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认光标**：您可以设置一个纹理来替换常规系统光标。如果您这样做，请记住将**光标热点**属性设置为图像中您想要光标点击的像素。'
- en: '**Resolution and Presentation**: These are settings for how our game’s resolution
    is going to be handled.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率和显示设置**：这些设置决定了我们的游戏分辨率如何处理。'
- en: '**Resolution and Presentation** | **Fullscreen Mode**: You can select whether
    your game will start **Windowed** or in different modes of **Fullscreen**. You
    can change that later via scripting if necessary.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率和显示设置** | **全屏模式**：您可以选择游戏是启动为**窗口模式**还是不同的**全屏**模式。如果需要，您可以通过脚本更改此设置。'
- en: '**Resolution and Presentation** | **Default is Native Resolution**: When this
    option is checked and **Fullscreen Mode** is set to use any **Fullscreen** option,
    the resolution currently used by the system will be the one used by Unity. You
    can uncheck this and set your desired resolution.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率和显示设置** | **默认为原生分辨率**：当此选项被勾选且**全屏模式**设置为使用任何**全屏**选项时，系统当前使用的分辨率将被Unity使用。您可以取消勾选此选项并设置您想要的分辨率。'
- en: '**Splash Image**:These are the settings for the splash image that the game
    will show after loading for the first time.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动画面**：这些是游戏首次加载后显示的启动画面的设置。'
- en: '**Splash Image** | **Show Splash Screen**: This will enable a Unity splash
    screen that will display logos as an introduction to the game. If you have the
    Unity Pro license, you can uncheck this to create your custom splash screen, if
    you want. Also, when Unity 6 is released, the splash screen will be able to be
    disabled even when using the Free license.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动画面** | **显示启动画面**：这将启用Unity启动画面，显示标志作为游戏的介绍。如果您拥有Unity Pro许可证，您可以取消勾选此选项以创建自定义的启动画面。此外，当Unity
    6发布时，即使使用免费许可证，也可以禁用启动画面。'
- en: '**Splash Image** | **Logos List**: Here, you can add a set of images that Unity
    will display when launching the game. If you are using a free version of Unity,
    you are forced to have the Unity logo displayed in this list.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动画面** | **标志列表**：在这里，您可以添加一组Unity在启动游戏时将显示的图片。如果您使用的是Unity的免费版本，您将被迫在这个列表中显示Unity标志。'
- en: '**Splash Image | Draw Mode**: You can set this to **All Sequential** to show
    each logo, one after the other, or to **Unity Logo Below** to show your custom
    introductory logos with the Unity logo always present below yours:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动画面 | 绘制模式**：您可以将其设置为**全部顺序**以逐个显示每个标志，或者设置为**Unity标志在下方**以显示您的自定义介绍标志，而Unity标志始终位于您的标志下方：'
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_19_03_PE.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由中等置信度自动生成](img/B21361_19_03_PE.png)'
- en: 'Figure 19.3: Player settings'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3：玩家设置
- en: 'For more information on the player settings, check the following link: [https://docs.unity3d.com/2023.1/Documentation/Manual/class-PlayerSettings.html](https://docs.unity3d.com/2023.1/Documentation/Manual/class-PlayerSettings.html)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有关玩家设置的更多信息，请查看以下链接：[https://docs.unity3d.com/2023.1/Documentation/Manual/class-PlayerSettings.html](https://docs.unity3d.com/2023.1/Documentation/Manual/class-PlayerSettings.html)
- en: 'After configuring these settings as you wish, the next step is to do the actual
    build, which can be accomplished by hitting the **Build** button in the **File**
    | **Build Settings** window. This will ask you to set where you want the build
    files to be created. I recommend you create an empty folder on your desktop to
    have easy access to the result. Be patient—this process can take a while depending
    on the size of the project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在您希望配置这些设置后，下一步是进行实际构建，这可以通过在**文件** | **构建设置**窗口中点击**构建**按钮来完成。这将要求您设置构建文件要创建的位置。我建议您在桌面上创建一个空文件夹，以便轻松访问结果。请耐心等待——这个过程可能需要一段时间，具体取决于项目的大小：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_19_04_PE.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由中等置信度自动生成](img/B21361_19_04_PE.png)'
- en: 'Figure 19.4: Building the game'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4：构建游戏
- en: Something that can fail here is having non-build-compatible scripts—scripts
    that are intended to be executed only in the Editor (mostly Editor extensions).
    We haven’t created any of those, so if you have an error message in the console
    after building, similar to the following screenshot, that can happen because of
    some script in an Asset Store package. In that case, just delete the files that
    are shown in the console before the **Build Error** message. If, by any chance,
    there is one of your scripts there, be sure you don’t have any `using UnityEditor;`
    lines in any of your scripts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会失败的是存在不兼容构建的脚本——这些脚本仅打算在编辑器中执行（主要是编辑器扩展）。我们还没有创建任何这样的脚本，所以如果您在构建后控制台中有错误消息，类似于以下截图，那可能是因为Asset
    Store包中的某个脚本。在这种情况下，只需删除在**构建错误**消息之前控制台中显示的文件。如果其中包含您的脚本，请确保您的任何脚本中都没有`using
    UnityEditor;`行。
- en: 'That would try to use the Editor namespace, the one that is not included in
    the build compilation to save space on the disk:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试使用编辑器命名空间，即不包括在构建编译中以便在磁盘上节省空间的命名空间：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_19_05_PE.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由中等置信度自动生成](img/B21361_19_05_PE.png)'
- en: 'Figure 19.5: Build errors'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.5：构建错误
- en: 'And that’s the minimum you need to know in order to configure the build. You
    have generated your game! Remember to test your builds on different devices, especially
    when working on mobile platforms; sometimes the game might work differently on
    different platforms, and sometimes even not run at all on some hardware due to
    incompatibilities. These incompatibilities can be highly dependent on the specific
    hardware and must be researched on a case-by-case basis. Something to take into
    account is that every file that was created in the folder that you specified when
    building must be shared, not only the executable file. The data folder contains
    all assets and is important to include when sharing the game in the case of Windows
    builds. For Linux and Mac builds, there is just one file generated (`x86/x86_64`
    for Linux and `app packages` for Mac):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置构建，你需要知道的最少信息就是这些。你已经生成了你的游戏！记得在不同设备上测试你的构建，尤其是在移动平台开发时；有时游戏在不同平台上可能会有不同的表现，甚至在某些硬件上由于不兼容而完全无法运行。这些不兼容性可能高度依赖于特定硬件，并且必须逐个案例进行研究。需要注意的是，在构建时你指定的文件夹中创建的每个文件都必须共享，而不仅仅是可执行文件。数据文件夹包含所有资源，在Windows构建共享游戏时非常重要。对于Linux和Mac构建，只生成一个文件（Linux为`x86/x86_64`，Mac为`app
    packages`）：
- en: '![A picture containing text, font, screenshot  Description automatically generated](img/B21361_19_06_PE.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、屏幕截图的图片，描述自动生成](img/B21361_19_06_PE.png)'
- en: 'Figure 19.6: A Windows-generated folder'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.6：Windows生成的文件夹
- en: Now that we have the build, you can test it by double-clicking the executable
    file. We can now discuss how we use the same debugging and profiling tools we
    used in the Editor to debug our build.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了构建，你可以通过双击可执行文件来测试它。我们现在可以讨论如何使用在编辑器中使用的相同的调试和性能分析工具来调试我们的构建。
- en: Debugging the build
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试构建
- en: In an ideal world, the Editor and the build would behave the same, but sadly,
    that isn’t true. The Editor is prepared to work in a fast-iteration mode. Code
    and assets have minimum processing prior to being used to make changes often and
    fast, so we can test our game easily. When the game is built, a series of optimizations
    and differences from the Editor project will be applied to ensure the best performance
    we can get, but those differences can cause certain parts of the game to behave
    differently, making the profiling data of the player differ from the Editor. That’s
    why we are going to explore how we can debug and profile the game we have built.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，编辑器和构建的行为应该是相同的，但遗憾的是，事实并非如此。编辑器已经准备好在快速迭代模式下工作。代码和资源在使用前进行最小处理，以便频繁快速地做出更改，这样我们就可以轻松测试我们的游戏。当游戏构建时，会应用一系列优化和与编辑器项目的差异，以确保我们能够获得最佳性能，但这些差异可能会导致游戏某些部分的行为不同，使得玩家的性能数据与编辑器不同。这就是为什么我们要探讨如何调试和性能分析我们所构建的游戏。
- en: 'In this section, we will examine the following build debugging concepts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下构建调试概念：
- en: Debugging code
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试代码
- en: Profiling performance
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Let’s start by discussing how to debug the code of a build.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何调试构建的代码。
- en: Debugging code
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试代码
- en: As player code is compiled differently, we can get errors in the build that
    didn’t happen in the Editor, and we need to debug it somehow. We have two main
    ways to debug—by printing messages and through breakpoints. So, let’s start with
    the first one, messages. If you ran your executable file, you may have noticed
    that there’s no console available. It’s just the **Game View** in fullscreen,
    which makes sense; we don’t want to distract the user with annoying testing messages.
    Luckily, the messages are still being printed, but in a file, so we can just go
    to that file and look for them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家代码的编译方式不同，构建中可能会出现编辑器中没有出现的错误，我们需要以某种方式调试它。我们有两种主要的调试方式——通过打印消息和通过断点。所以，让我们从第一种方式开始，消息。如果你运行了你的可执行文件，你可能已经注意到没有可用的控制台。它只是全屏的**游戏视图**，这是有道理的；我们不希望用令人烦恼的测试消息分散用户的注意力。幸运的是，消息仍然被打印出来，但它们在一个文件中，所以我们可以直接去那个文件查找它们。
- en: 'The location varies according to the operating system. In this list, you can
    find the possible locations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 位置根据操作系统而变化。在这个列表中，你可以找到可能的地址：
- en: '**Linux**: `~/.config/unity3d/CompanyName/ProductName/Player.log`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux**: `~/.config/unity3d/CompanyName/ProductName/Player.log`'
- en: '**Mac**: `~/Library/Logs/Company Name/Product Name/Player.log`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mac**: `~/Library/Logs/Company Name/Product Name/Player.log`'
- en: '**Windows**: `C:\Users\username\AppData\LocalLow\CompanyName\ProductName\Player.log`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**: `C:\Users\username\AppData\LocalLow\CompanyName\ProductName\Player.log`'
- en: In these paths, you must change `CompanyName` and `ProductName` to the values
    of the properties in the `Player` settings we set before, which are called the
    same, **Company Name** and **Product Name**, respectively. In Windows, you must
    replace `username` with the name of the Windows account you are executing the
    game in. Consider that the folders might be hidden, so enable the option to show
    hidden files in your operating system. Inside that folder, you will find a file
    called `Player`; you can open it with any text editor and look at the messages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些路径中，你必须将 `CompanyName` 和 `ProductName` 替换为我们之前在 `Player` 设置中设置的属性的值，这些属性分别称为
    **公司名称** 和 **产品名称**。在 Windows 中，你必须将 `username` 替换为你正在执行游戏的 Windows 账户名称。请注意，文件夹可能被隐藏，所以请启用操作系统中的显示隐藏文件选项。在那个文件夹中，你会找到一个名为
    `Player` 的文件；你可以用任何文本编辑器打开它并查看消息。
- en: 'Aside from downloading any custom package from the Asset Store, there is a
    way to see the messages of the console directly in the game, at least the error
    messages: by creating a development build. This is a special build that allows
    extended debugging and profiling capabilities in exchange for not fully optimizing
    the code as the final build does, but it will be enough for general debugging.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从 Asset Store 下载任何自定义包之外，还有一种方法可以直接在游戏中查看控制台消息，至少是错误信息：通过创建开发构建。这是一种特殊的构建，它允许在交换不进行最终构建那样的完全优化代码的情况下，提供扩展的调试和性能分析功能，但这对一般调试来说已经足够了。
- en: 'You can create this kind of build just by checking the **Development Build**
    checkbox in the **File** | **Build Settings** window:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 **文件** | **构建设置** 窗口中勾选 **开发构建** 复选框来创建这种类型的构建：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_19_07_PE.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![带有中等置信度的计算机截图](img/B21361_19_07_PE.png)'
- en: 'Figure 19.7: The Development Build checkbox'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.7：开发构建复选框
- en: Remember that just the error messages will be displayed here, so a little trick
    you can do is replace `print` and `Debug.Log` function calls with `Debug.LogError`,
    which will also print the message in the console but with a red icon. Consider
    that using `Debug.LogError` to show non-error messages is not a good practice,
    so limit the usage of this kind of message for temporal debugging. For permanent
    logging, use the log file or find a custom debugging console for runtime in the
    Asset Store.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这里只显示错误信息，所以你可以使用的一个小技巧是将 `print` 和 `Debug.Log` 函数调用替换为 `Debug.LogError`，这样也会在控制台打印消息，但会显示红色图标。请注意，使用
    `Debug.LogError` 来显示非错误信息并不是一个好的做法，所以请限制这类消息的使用，仅用于临时调试。对于永久记录，请使用日志文件或在 Asset
    Store 中寻找运行时的自定义调试控制台。
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_19_08_PE.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成的图片](img/B21361_19_08_PE.png)'
- en: 'Figure 19.8: Debugging error messages'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.8：调试错误信息
- en: 'Something interesting regarding **development builds** is that, unlike regular
    builds, the error messages are displayed directly in the build, allowing you to
    properly debug your project. Remember that development builds can be slower due
    to these capabilities as they are intended for debugging and allowing profilers
    to work, but the final performance will be better on release builds. In the next
    screenshot, you can see the error displayed in the runtime:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于开发构建的一个有趣之处是，与常规构建不同，错误信息会直接显示在构建中，允许你正确地调试你的项目。请记住，由于这些功能，开发构建可能会更慢，因为它们旨在用于调试并允许性能分析器工作，但最终发布构建的性能会更好。在下一张截图中，你可以看到运行时显示的错误：
- en: '![A picture containing screenshot, design  Description automatically generated](img/B21361_19_09_PE.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、设计描述自动生成的图片](img/B21361_19_09_PE.png)'
- en: 'Figure 19.9: Error messages in a development build'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.9：开发构建中的错误信息
- en: You will notice that, aside from showing the error message, there’s an **Open
    Log File** button on the right, allowing you to see the log file. This is a text
    file containing detailed info regarding all the messages and logs that happened
    in this run of the game to pinpoint the issue. Essentially, it is the same info
    the **Console** panel shows in the Editor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，除了显示错误信息之外，在右侧还有一个 **打开日志文件** 按钮，允许你查看日志文件。这是一个文本文件，包含有关游戏中发生的所有消息和日志的详细信息，以便定位问题。本质上，这是与编辑器中
    **控制台** 面板显示的相同信息。
- en: Remember that for **development builds** to work, you need to build the game
    again; luckily, the first build is the one that takes the most time, and the next
    will be faster. This time, you can just click the **Build and Run** button to
    do the build in the folder in which you did the previous build.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为了使**开发构建**工作，你需要再次构建游戏；幸运的是，第一次构建是最耗时的，接下来的构建会更快。这次，你只需点击**构建并运行**按钮，在之前构建的文件夹中进行构建。
- en: Also, you can use regular breakpoints in the same way as we explained in *Chapter
    5*, *Unleashing the Power of C# and Visual Scripting*. By attaching the IDE to
    the player, it will show up in the list of targets. But for that to work, you
    must not only check **Development Build** in the **Build** window but also **Script
    Debugging**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以像我们在*第5章*，*释放C#和视觉脚本的力量*中解释的那样，使用常规断点。通过将IDE连接到播放器，它将出现在目标列表中。但为了使其工作，你必须在**构建**窗口中不仅勾选**开发构建**，还要勾选**脚本调试**。
- en: 'Here, you have an additional option shown when that is checked that allows
    you to pause the entire game until a debugger is attached, the one called **Wait
    For Managed Debugger**. This is useful in case you want to test something that
    happens immediately at the beginning that doesn’t allow you enough time to attach
    the debugger:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当勾选时，你会看到一个额外的选项，允许你暂停整个游戏，直到附加调试器，这个选项叫做**等待托管调试器**。当你想要测试一开始立即发生的事情，但给你附调试器的时间不够时，这很有用：
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21361_19_10_PE.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、数字的图片，自动生成描述](img/B21361_19_10_PE.png)'
- en: 'Figure 19.10: Enabling script debugging'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.10：启用脚本调试
- en: We have another way to see the messages, but that will require the Profiler
    to work, so let’s use this as an excuse to also discuss how to profile the editor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一种查看消息的方法，但这需要性能分析器工作，所以让我们以此为借口也讨论一下如何对编辑器进行性能分析。
- en: Profiling performance
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析
- en: We are going to use the same tools as we saw in the previous chapter, but to
    profile the player this time. Luckily, the difference is minimal. As we did in
    the previous section, you need to build the player in **Development** mode, checking
    the **Development Build** checkbox in the **Build** window, and then the Profiler
    should automatically detect it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与上一章中看到相同的工具，但这次是为了分析播放器。幸运的是，差异很小。正如我们在上一节中所做的那样，你需要以**开发**模式构建播放器，在**构建**窗口中勾选**开发构建**复选框，然后性能分析器应该会自动检测到它。
- en: 'Let’s start using the Profiler on the build by doing the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下步骤开始使用性能分析器对构建进行分析：
- en: Play the game through the build.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构建运行游戏。
- en: Switch to Unity using *Alt* + *Tab* (*Cmd* + *Tab* on Mac).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Alt* + *Tab*（Mac上的*Cmd* + *Tab*）切换到Unity。
- en: Open the Profiler.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开性能分析器。
- en: 'Click the menu that says **Play Mode** and select the item that contains **Player**
    in it. Because I have used Mac, it says **OSXPlayer**; and the name will vary
    according to the build platform (for example, a Windows build will say **WindowsPlayer**):'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击名为**播放模式**的菜单，并选择包含**播放器**的项。因为我使用了Mac，它说**OSXPlayer**；并且名称将根据构建平台而变化（例如，Windows构建将显示为**WindowsPlayer**）：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_19_11_PE.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，中等置信度自动生成描述](img/B21361_19_11_PE.png)'
- en: 'Figure 19.11: Profiling the player'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.11：分析播放器
- en: Notice that when you click a frame, the game won’t stop like in the Editor.
    If you want to focus your attention on the frames at a specific moment, you can
    click the record button (the red circle) to make the Profiler stop capturing data,
    so you can analyze the frames captured so far.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你点击一个帧时，游戏不会像在编辑器中那样停止。如果你想专注于特定时刻的帧，你可以点击记录按钮（红色圆圈），这样性能分析器就会停止捕获数据，你可以分析到目前为止捕获的帧。
- en: 'Also, you can see that when the Profiler is attached to the player, the console
    will also be attached, so you can see the logs directly in Unity. Consider that
    this version requires Unity to be opened, and we cannot expect our friends who
    are testing our game to have it. You might need to click on the **Player** button
    that appears on the **Console** and check **Player Logging** for this to work:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以看到当性能分析器附加到播放器时，控制台也会附加，因此你可以在Unity中直接查看日志。请注意，这个版本需要打开Unity，我们无法期望测试我们游戏的朋友也有它。你可能需要点击**控制台**上出现的**播放器**按钮，并勾选**播放器日志**才能使其工作：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_19_12_PE.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  自动生成的描述](img/B21361_19_12_PE.png)'
- en: 'Figure 19.12: Enabling Player Logging after attaching the Profiler'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.12：在附加Profiler后启用玩家日志记录
- en: 'The **Frame Debugger** is also enabled to work with the player. You need to
    click the **Editor** button in the **Frame Debugger** and again, you will see
    the player in the list of possible debugging targets; after selecting it, hit
    **Enable** as usual. Consider that the preview of the **Draw Calls** won’t be
    seen in the **Game View** but in the build itself. If you are running the game
    in fullscreen mode, you might need to switch back and forth between Unity and
    the build:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧调试器**也已被启用以与玩家协同工作。您需要在**帧调试器**中点击**编辑器**按钮，然后再次点击，您将在可能的调试目标列表中看到玩家；选择它后，按常规点击**启用**。请注意，**绘制调用**的预览将不会在**游戏视图**中显示，而是在构建本身中显示。如果您正在全屏模式下运行游戏，您可能需要在Unity和构建之间来回切换：'
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_19_13_PE.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  使用中等置信度自动生成的描述](img/B21361_19_13_PE.png)'
- en: 'Figure 19.13: Debugging the frames of our game’s Player'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.13：调试我们游戏玩家的帧
- en: 'You may also run the game in **Windowed** mode, setting the **Fullscreen Mode**
    property in the player settings to **Windowed**, and establishing a default resolution
    that is smaller than your desktop resolution. This allows both Unity and the player
    to be visible to see the profilers and the game at the same time:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以以**窗口模式**运行游戏，将玩家设置中的**全屏模式**属性设置为**窗口模式**，并设置一个小于您桌面分辨率的默认分辨率。这允许Unity和玩家同时可见，以便同时看到分析器和游戏：
- en: '![A picture containing text, font, number, line  Description automatically
    generated](img/B21361_19_14_PE.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、数字、行的图片  自动生成的描述](img/B21361_19_14_PE.png)'
- en: 'Figure 19.14: Enabling Windowed mode'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.14：启用窗口模式
- en: 'Finally, the **Memory Profiler** also supports profiling the player, and as
    you might guess, you can just select the player in the list that is displayed
    when you click the **Editor** button in the top bar of the window and then click
    **Capture**:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**内存分析器**也支持分析玩家，正如您所猜测的，您只需在点击窗口顶部栏中的**编辑器**按钮时显示的列表中选择玩家，然后点击**捕获**：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_19_15_PE.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  自动生成的描述](img/B21361_19_15_PE.png)'
- en: 'Figure 19.15: Taking memory snapshots of the player'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.15：获取玩家的内存快照
- en: And that is it. As you can see, Unity Profilers are designed to be easily integrated
    with the player. If you start to take data from them, you will see the difference
    compared to editor profiling, especially in the **Memory Profiler**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如您所见，Unity分析器被设计成易于与玩家集成。如果您开始从它们那里获取数据，您将看到与编辑器分析相比的差异，尤其是在**内存分析器**中。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create an executable version of the game
    and properly configure it so we can share it with not only our friends but potentially
    the world! We also discussed how to profile our build; remember that doing that
    will give us more accurate data than profiling the editor, so we can better improve
    the performance of our game.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建游戏的可执行版本，并正确配置它，以便我们可以与我们的朋友以及可能的世界分享！我们还讨论了如何分析我们的构建；请记住，这样做将比分析编辑器提供更准确的数据，因此我们可以更好地提高我们游戏的表现力。
- en: Now that we have finished our game, let’s get a glimpse of how your next project
    could easily be an augmented reality application in Unity by exploring the AR
    Foundation package in the next chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的游戏，让我们通过在下一章中探索AR Foundation包来一窥您的下一个项目如何轻松地成为一个Unity增强现实应用程序。
- en: Learn more on Discord
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家和作者本人一起阅读此书。提出问题，为其他读者提供解决方案，通过Ask Me Anything会议与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![二维码  图片](img/QR_Code1498477041053909218.png)'
