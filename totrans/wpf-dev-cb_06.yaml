- en: Using Styles, Templates, and Triggers
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `Style` of a control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `Style` of a control based on another `Style`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying `Style` to a control automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing the template of any control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a property trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a data trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi data trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an event trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing a user interface for an application, you need to ensure the consistency
    of the look and feel of the controls across the application. For example, if you
    are using buttons, they should look the sameâ€”similar colors, the same margins,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Styles** are objects that hold the `Setter` properties to provide a bunch
    of settings to elements and controls. Style also provides control templates, which
    are used to customize the control template to have a distinctive look and feel.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Win32/WinForms model, the look and the behavior of the controls were
    tightly bundled; but in WPF world a control template is created in XAML using
    designer-oriented tools, and this applies styles to produce a similar look. You
    can also inherit a style from a different style.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss styles, templates, triggers, and their relationships
    with the controls to which they are applied.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the style of a control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Styles provide you with a convenient way to group a set of properties and triggers
    within a single object and apply it to the elements. You can do this selectively
    to a set of controls, or you can apply it to all the controls automatically, based
    on the control type.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll begin with the default style of a button and set its various
    style properties to give it a new look. We will then apply it selectively to set
    the style of multiple button controls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started by creating a new project called `CH06.ControlStyleDemo`.
    Make sure you create the project based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will get started by creating two buttons inside the application
    window. Then we will create a style for the button and apply it to both of the
    controls. Follow these steps to try it on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Solution Explorer, open the `MainWindow.xaml` and replace the existing
    `Grid` panel by a `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Orientation` property of the `StackPanel` to `Vertical`, so that we
    can stack the child controls vertically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add a few buttons inside it and assign a content. Here''s our markup of
    the `StackPanel` with two buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application. You will see the following UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a831b4ec-c8eb-4cb0-9690-a04ea022b8c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Close the application and return to the `MainWindow.xaml` page. Inside the `Window`
    tag, add `<Window.Resources></Window.Resources>` to add the button style inside
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following style inside the resources to define a style called `ButtonBaseStyle`,
    for our button controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now apply the defined style to both of the buttons by adding the attribute
    `Style="{StaticResource ButtonBaseStyle}"`. Here''s the code, for your reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, build the project, and run the application again. You will
    see that the buttons are now shaped properly with some padding between the text
    and the edge. Also, the font size has increased, as defined in the style. Here''s
    how it looks now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3afa50e2-997c-4287-b784-8483fad8c59f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add a few additional `Setter` properties to the style. We will now define
    a `4px` margin, a hand cursor, and a border, as shared here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete style that we have built up to this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the project and run the application again. You will now see
    a better UI with proper styling of the button controls, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c38304d6-8ff2-4878-be6e-e6f248512a51.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a `Style` object, you set a bunch of `Setter` objects to it
    to define various properties to change the look and feel of the control. This
    may include the height, width, positions, alignments, colors, fonts, control template,
    triggers, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The `FrameworkElement` class exposes a `Style` property that can be filled by
    a `Style` object. Styles are always built as resources, as you see them inside
    the `<Window.Resources>` tag in our example. It contains an `x:Key` property,
    which defines the name/key of the style. By using this `Key`, you can perform
    a binding from any other resources/controls within the scope. The `TargetType`
    property of a `Style` object is typically set, which makes the `Style` applicable
    to that type, which can be any type, even a type of a custom control.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the applied style works on `Button` objects. Trying to apply
    the same to some other element type will cause a runtime exception.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can omit defining the `TargetType` of a `Style`, but, for that to work,
    you must define the property with a fully qualified name. For example, the preceding
    `Style` can be written as shown here to get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As this makes the property name redundant, to define a qualified name people
    prefer to use the first one with a `TargetType` defined. Then, what is the use
    of the second type of declaration? Yes, the question is valid. With this type
    of styling, by specifying the fully qualified name of the property, you can define
    a style targeting various types of controls where the said properties are available.
  prefs: []
  type: TYPE_NORMAL
- en: A point to note is that if you explicitly define a property to a control, it
    will override the property value defined in the `Style`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Style of a control based on another Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Styles support inheritance. That means, you can derive a `Style` from another
    `Style`. This can be done using the `BasedOn` property, which must point to another
    `Style` to inherit from. In this recipe, we will learn how to create a `Style`
    of a button control based on another `Style` of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started by creating a project named `CH06.StyleInheritanceDemo`. To
    do this, open your Visual Studio instance and create a project based on the WPF
    application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a base style for a button control and then derive
    it to create different button styles:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file and create a `<Window.Resources></Window.Resources>`
    section inside the `Window` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, inside the window resources, add the following style definition, which
    we discussed in the previous recipe of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the default `Grid` to have the following `StackPanel` with four button
    controls, having the same style that we have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Build the project and run it. You will see the following UI has the same style
    applied to all the button controls:![](img/105afbf0-14bf-43ed-97fe-0dadbbe09bf0.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To demonstrate the `Style` inheritance, let's create another `Style`, based
    on the base `Style`. Give it a new `Key` name, `RedButtonStyle`, set the `TargetType`
    to `Button`, and add a new attribute `BasedOn="{StaticResource ButtonBaseStyle}"`
    to create the inheritance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some additional `Setter` values to the newly created style to define its
    border, background, and foreground color. Here''s the markup for the `RedButtonStyle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change the `Style` property of the `redButton` to point itself to `RedButtonStyle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application once again, which will have the following UI, where
    the second button will have a reddish background color and a white font color:![](img/2f2c67be-14ba-49e3-8600-0e05f817195e.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add two more styles, based on the `ButtonBaseStyle`, and name them as `GreenButtonStyle`
    and `BlueButtonStyle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set their `BorderBrush`, `Foreground`, and `Background` properties to have
    a greenish and bluish color, respectively. To do this, copy the following styles
    inside the `<Window.Resources>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply the preceding styles, modify the `Style` property of the `greenButton`
    and the `blueButton` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the code snippet for the entire `StackPanel`, which will now have four
    buttons. Among which the first button is following the base style, whereas the
    other three buttons are following the new red, green, and blue button styles,
    respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Time to build the project and run the application. Now, when the application
    launches, it will have the following UI, but with unique styles. As mentioned
    earlier, the colors of the buttons will be as per the values we set to the different
    styles:![](img/47fe7d6e-c20f-43fb-8278-1573b5f5f37d.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An inherited style can have additional `Setter` properties to set, or it can
    provide a different value for a property that has been set by the base `Style`.
    In the preceding example, the `RedButtonStyle`, `GreenButtonStyle`, and `BlueButtonStyle`
    inherit from the first (`ButtonBaseStyle`), and add `BorderBrush`, `Foreground`,
    and `Background` setter properties to it.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Style to a control automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two recipes, we learned about creating styles and applying them
    to controls by using the `x:Key` name. It's not always feasible to manually assign
    the style to a set of huge controls within the same application. For this reason,
    we need to apply it automatically to all the elements within the scope of a specific
    window or the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we may want all buttons within the same app to have the same look
    and feel. This makes creating new buttons easier, as the developer/designer doesn't
    have to know what style to apply. If the auto styling is configured, it will make
    the work far smoother.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this can be done with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start this recipe, open your Visual Studio instance and create a new WPF
    application project called `CH06.StyleUsageDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create styles for button controls and apply them to controls
    within the same window, followed by applying them across the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` and replace the existing `Grid` with the following
    `StackPanel`, containing four button controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `<Window.Resources></Window.Resources>` section inside the `Window`
    tag and add the following style inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Inside the Solution Explorer, right-click on the project. Follow the path Add
    | Window... from the context menu entry to open the Add New Item dialog window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name as `SecondaryWindow` and click Add. This will create `SecondaryWindow.xaml`
    and `SecondaryWindow.xaml.cs` files inside the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `SecondaryWindow.xaml` file and replace `Grid` with the same `StackPanel`
    to create the UI, having four buttons inside it. Here''s the markup that you need
    to copy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, navigate to the `App.xaml` file and remove the `StartupUri="MainWindow.xaml"`
    attribute, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ebc7729-9eec-4a4a-830b-cf81e8a38ba4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now go to its code-behind file, that is, the `App.xaml.cs`, and insert the
    following code block inside the class implementation to create instances of both
    the `MainWindow` and the `SecondaryWindow` to show on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, compile your project, and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, you will have two windows on the screen.
    One window (`MainWindow`) will have the styles applied to the button controls,
    whereas the other window (`SecondaryWindow`) will have the default look and feel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/629afc7a-0e57-4d87-b182-1759c55bbf38.png)'
  prefs: []
  type: TYPE_IMG
- en: Now close the application and navigate to the `MainWindow.xaml` file. Copy the
    style that we have there and delete/comment the entire `Window.Resources` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open the `App.xaml` file and paste the copied content inside the `Application.Resources`
    tag, as shared here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build and run the application. You will now see that the styles are
    applied to both windows. Here''s a screenshot of the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/356c2a3a-0980-44bc-9058-9bedc498ec85.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The automatic styling works when you create a style without specifying an `x:Key`
    value. Any element that does not set its style explicitly obtains it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we had the buttons in both the windows (`MainWindow`
    and `SecondaryWindow`), and no `Style` was manually applied to any one of them,
    but still the controls in the `MainWindow` got the style of Red Button, as the
    `Style` within that window was created without specifying any key (`<Style TargetType="{x:Type
    Button}">`).
  prefs: []
  type: TYPE_NORMAL
- en: For `SecondaryWindow`, we had no `Style` element defined, and, thus, it applied
    the default style of the button.
  prefs: []
  type: TYPE_NORMAL
- en: When we moved the `Style` definition to the `Application.Resources` tag in `App.xaml`,
    it registered the `Style` to the application level. Now, when you run the application,
    both the windows will receive the style from the application resource, and all
    controls of type `Button` will apply that style automatically.
  prefs: []
  type: TYPE_NORMAL
- en: If an element wishes to revert to its default style, it can set its `Style`
    property to `null`. This is generally written as `{x:Null}` in XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the template of any control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WPF allows you to customize the template of any control. Using Visual Studio,
    you can easily edit any template to meet your requirements. In this recipe, we
    will discuss how to edit the template of a `ProgressBar` control.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started with creating a project called `CH06.ControlTemplateDemo`.
    Make sure you select the right WPF application template while creating the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to edit the progress bar template:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file and replace the default `Grid` control with
    a vertical `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two `ProgressBar` controls inside the `StackPanel` and set their `Height`,
    `Width`, and `Value` properties, as shared here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application, you will see the application window contains two
    progress bar controls. Both the controls will have the default style applied to
    them. Here''s a screenshot of the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/50edd9c8-90a4-457c-9983-177c164513f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will create a custom template for the `ProgressBar` control and apply
    it to the second progress bar. To do this, add the following markup inside the
    `Window` tag to define the template under the `Window.Resources`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you set the proper `TargetType` and assign an `x:Key` name to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now apply the template to the second control by adding the `Template="{StaticResource
    ProgressBarTemplate}"` attribute value. After doing this, the XAML will look as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application once again. You will see the second control has
    our custom template applied to it, and it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/859213cc-daa4-42ce-8b5c-5d2dff6f8c44.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you assign the `Template="{StaticResource ProgressBarTemplate}"` to the
    control, it applies the template to the associated control. The progress bar control
    contains two major parts defined in its template, and they are, `PART_Track` and
    `PART_Indicator`. The first one is used to define the base track of the control,
    whereas the second one defines the progress indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our template, we assigned a `LinearGradientBrush` as the `PART_Indicator`
    rectangle''s `Fill` color to design the progress indication in a bar format. `GradientStop`
    is used to define the `Offset` of the selected color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the application runs, because of its repeat behavior (`SpreadMethod="Repeat"`)
    of `LinearGradientBrush`, the stacked bars will spread across the control based
    on the value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not easy to remember the default template body of the controls. It is also
    not possible to remember each control part, defined as `PART_Name`. Visual Studio
    provides an effortless way to modify the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, right-click on the control and follow the context menu entry Edit
    Template | Edit a Copy..., as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e587592f-4a69-4706-81b1-89a93f545af7.png)'
  prefs: []
  type: TYPE_IMG
- en: This will open up a dialog window to specify the file where you want to create
    the style. If you select Application, it will be created under the `Application.Resources`
    tag and will be accessible throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose This document, it will get created under the `Window.Resources`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3dfa9257-3301-46b2-90cc-f71476f168bd.png)'
  prefs: []
  type: TYPE_IMG
- en: From this screen, you also have an option of whether to create an implicit or
    explicit style. Select Apply to all to create an **implicit style**, and all controls
    of that type will get the same style within that scope. In another case, give
    it a **Key** name. Once you click OK, it will create the default template in the
    same XAML. You can customize it based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Never remove any `PART` controls of a template, which is defined by `PART_`,
    as the controls internally need them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a property trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A trigger enables you to change property values when certain conditions are
    satisfied. It can also enable you to take actions based on property values by
    allowing you to dynamically change the appearance and/or the behavior of your
    control without writing additional codes in the code-behind classes.
  prefs: []
  type: TYPE_NORMAL
- en: The most common trigger is the **property trigger**, which can be simply defined
    in XAML with a `<Trigger>` element. It triggers when a specific property on the
    owner control changes to match a specified value.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn about property triggers with a suitable example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio instance and create a new WPF application project called
    `CH06.PropertyTriggerDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with the property trigger, we will use a `Label` control in this example
    and trigger the system to change its various properties on mouse hover. Follow
    these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` page and add the following `Label` control inside
    the grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `Window` tag, create a `Window.Resources` tag to hold the style of
    the `Label` control. Create a `Style` inside the resources and set its `TargetType`
    to `Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following trigger inside the style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete style containing the trigger for the `Label` control,
    which will change the mentioned properties on mouse hover:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, build the project and run it. You will see a Hover over the text label
    on the application window. Mouse hover on the text to see the effect on the screen,
    as shown here:![](img/51bb599a-dbed-474a-ab85-9df9b79004f4.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The style of the `Label` creates a `Trigger` that fires on mouse hover by checking
    the `IsMouseOver="True"` property value. When the condition satisfies, it sets
    the `Setter` properties as defined under it.
  prefs: []
  type: TYPE_NORMAL
- en: When the condition becomes `false`, the setters are logically removed, reverting
    the properties to their original values. This means that it is not required to
    provide an *opposite* trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multi trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not mandatory to use a trigger to perform only an action based on a single
    condition. Sometimes you need to create it with a composition of multiple conditions
    that activate the entire trigger, if all the conditions are met. This is what
    the **multi trigger** does. Let's see how to create a multi trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio IDE and create a new WPF application called `CH06.MultiTriggerDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following steps, we will build a simple application that will create
    and execute a multi trigger based on some conditions and change the `Foreground`
    and `Background` properties of the `TextBox` controls:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the default `Grid` panel with a vertical `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two `TextBox` controls inside the panel and set their `Text` property to
    represent some text. Here''s the XAML that we will be using in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, under the window resources (`Window.Resources`), create a `Style` that
    targets a `TextBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a style trigger with `MultiTrigger`, based on one or more conditions,
    and apply the setters, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s execute the application and focus on the `TextBox` controls to see the
    behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/947b0dfb-f63f-4b20-8d98-487926bd17db.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is almost like the **Property Trigger**, but here it is used to set an
    action on multiple property changes, and will execute it when all the conditions
    within the `MulitTrigger.Conditions` are satisfied. The `MultiTrigger` object
    hosts a collection of these `Condition` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Here, in this example, we have `MultiTrigger` associated with `TextBox` controls.
    When the control is enabled and gets keyboard focus, it changes its `Foreground`
    and `Background` properties. When either of them is `false`, it returns the property
    values to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name says, the **data trigger** applies property values to perform a
    set of actions on the `Data` that has been bound to the `UIElement`. This is represented
    by the `<DataTrigger>` element.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a trigger that acts on the underlying
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started with creating a new WPF project. Open the Visual Studio and
    create a project called `CH06.DataTriggerDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these simple steps to create a data trigger that will act to change
    the `Background` and `Content` property of a `Label`, based on the radio button
    selection:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Solution Explorer, open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s divide the `Grid` panel into two columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now insert a `Label` of `150` x `100` dimension at column `0` (zero) and set
    its `Foreground` property to `White`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a vertical `StackPanel` at Column `1` and add three radio buttons inside
    it. Make sure you set their names and the `GroupName`. The `x:Name` property is
    used to define the name of the controls and the `GroupName="colors"` is used to
    define a single group for the radios. Here''s the complete XAML markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Window.Resources` tag of the window, create a `Style` that targets
    `Label` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the following trigger inside the `Style`. The `<Style.Triggers>` contains
    three `DataTrigger` bound to the checkbox controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As the trigger is ready, let''s build the project and run it. Change the radio
    button selection and observe how it works, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/66d2c691-74a0-4542-bbd2-cc555473c59f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you click on the first radio button (`rdoRed`), it triggers the first data
    trigger, as it satisfies the `IsChecked` property of `rdoRed` control and modifies
    the `Setter` propertiesâ€”`Content` and `Background`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when you change the selection to the second or third radios, the
    respective `DataTrigger` will fire and update the `Label` control, according to
    the `Setter` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multi data trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **multi data trigger** is the same as the **data trigger**, with the only
    difference being that you can set property values based on multiple conditions
    defined in the `MultiDataTrigger.Conditions`. Property values are defined in the
    `MultiDataTrigger.Setters`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about the multi data trigger usages in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with the multi data trigger, let's start by creating a project
    called `CH06.MultiDataTriggerDemo`. Make sure you select the proper project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a UI with two checkboxes and a button, and then
    apply a multi data trigger to enable/disable the button, based on the check state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by replacing the `Grid` with a `StackPanel`, having two checkbox
    (`chkLicense` and `chkTerms`) controls and one button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, modify the `Button` to expose its style, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following button style inside it, which contains a `MultiDataTrigger`
    to enable/disable the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application, which will have two checkboxes and a button on the
    screen. Change the selections of the checkbox controls to see the behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/96eee90e-16da-4ed0-9c5a-869aa7e2ef1d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A multi data trigger works based on the conditions set to it, which acts on
    the underlying data. In our example, we have a `MultiDataTrigger` with two conditions.
  prefs: []
  type: TYPE_NORMAL
- en: According to the conditions, if both the checkbox controls are checked, it will
    trigger and enable the button by setting the `IsEnabled` property to `True`. When
    any of the preceding conditions are not satisfied, it will automatically set the
    `IsEnabled` property to the previous value, which is `False` in our case.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we have seen property triggers and data triggers, which work based
    on comparing a property to a value. In this recipe, we will learn about **event
    triggers** which fire when a routed event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside your Visual Studio IDE, create a new project called `CH06.EventTriggerDemo`,
    based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a simple event trigger on a `TextBlock` control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` and add the following `TextBlock` inside the `Grid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following style, containing `EventTrigger`, to the `TextBlock.Style`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the application and run it. Hover your mouse on top of the text and you
    will see that the font size of the text gradually increases, and the visibility
    becomes `100%`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0c94dd95-d8b6-4a53-a751-5dab07f5d1ff.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event triggers are generally used to perform actions when the **Routed Events**
    of the associated `FrameworkElement` raises. This is mainly used in animations
    to control the look and feel when a certain UI event is raised.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, when you hover over the mouse cursor on the `TextBlock` control,
    the `MouseEnter` event fires and that triggers `EventTrigger`, which we have defined
    in the XAML. It then animates the text to have a bigger font size and a higher
    opacity to give a bigger, better visible content.
  prefs: []
  type: TYPE_NORMAL
- en: When the `MouseLeave` event fires, it reduces the size of the font and brings
    the control opacity to `20%`. More about the `Storyboard` animations will be discussed
    in *Chapter 8,* *Working with Animations*.
  prefs: []
  type: TYPE_NORMAL
