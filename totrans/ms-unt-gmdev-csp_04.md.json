["```cs\npublic class PlayerController : MonoBehaviour\n{\n    private Animator playerAnimator;\n    private RigidBody rigidBody;\n    private void Start()\n    {\n        playerAnimator = GetComponent<Animator>();\n        rigidBody = GetComponent<RigidBody>();\n    }\n    private void Update()\n    {\n        // Logic for handling animations\n        playerAnimator.SetBool(\"IsRunning\",playerInput.IsRunning());\n        // Logic for handling player input\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            rigidBody.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);\n        }\n        // Logic for handling player movement\n    }\n}\n```", "```cs\npublic class PlayerAnimation : MonoBehaviour\n{\n    private Animator animator;\n    private void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n    public void UpdateAnimation(bool isRunning)\n    {\n        animator.SetBool(\"IsRunning\", isRunning);\n    }\n}\n```", "```cs\npublic class PlayerMovement : MonoBehaviour\n{\n    public void Move(float horizontalInput)\n    {\n        // Logic for moving the player based on input\n    }\n     public void Jump()\n    {\n        // Logic for jumping the player based on input\n    }\n}\npublic class PlayerInput : MonoBehaviour\n{\n    public float HorizontalInput()\n    {\n        return Input.GetAxisRaw(\"Horizontal\");\n    }\n    public bool IsJumping()\n    {\n        // Logic for determining if the player is jumping\n        return Input.GetKeyDown(KeyCode.Space);\n    }\n    public bool IsRunning()\n    {\n        // Logic for determining if the player is running\n        return Input.GetKey(KeyCode.LeftShift);\n    }\n}\n```", "```cs\npublic class PlayerController : MonoBehaviour\n{\n    private PlayerAnimation playerAnimation;\n    private PlayerInput playerInput;\n    private PlayerMovement playerMovement;\n    private void Start()\n    {\n        playerAnimation = GetComponent<PlayerAnimation>();\n        playerInput = GetComponent<PlayerInput>();\n        playerMovement = GetComponent<PlayerMovement>();\n    }\n    private void Update()\n    {\n        playerMovement.Move(playerInput.HorizontalInput());\n        if (playerAnimation != null)\n        {\n            playerAnimation.UpdateAnimation(playerInput.IsRunning());\n        }\n        if (playerInput.IsJumping())\n        {\n            playerMovement.Jump();\n        }\n    }\n}\n```", "```cs\npublic abstract class PowerUp\n{\n    public abstract void Activate(); // Common activation logic\n    public abstract void Deactivate(); // Common deactivation logic\n}\n```", "```cs\npublic class DoubleJumpPowerUp : PowerUp\n{\n    public override void Activate()\n    {\n        // Specific activation logic for double jump\n    }\n    public override void Deactivate()\n    {\n        // Specific deactivation logic for double jump\n    }\n}\n```", "```cs\npublic class TemporaryInvincibilityPowerUp : PowerUp\n{\n    public override void Activate()\n    {\n        // Specific activation logic for temporary invincibility\n    }\n    public override void Deactivate()\n    {\n        // Specific deactivation logic for temporary invincibility\n    }\n}\n```", "```cs\npublic class PowerUpManager : MonoBehaviour\n{\n    private void Start()\n    {\n        // Example of using the power-up system\n        PowerUp doubleJump = new DoubleJumpPowerUp();\n        AddPowerUp(doubleJump);\n        PowerUp invincibility = new TemporaryInvincibilityPowerUp();\n        AddPowerUp(invincibility);\n    }\n    private void AddPowerUp(PowerUp powerUp)\n    {\n        powerUp.Activate();\n        // Logic for adding power-up to the game\n    }\n    private void RemovePowerUp(PowerUp powerUp)\n    {\n        powerUp.Deactivate();\n        // Logic for removing power-up from the game\n    }\n}\n```", "```cs\npublic class Enemy : MonoBehaviour\n{\n    public virtual void Move()\n    {// Basic movement logic for all enemies\n    }\n    public virtual void Attack()\n    {// Basic attack logic for all enemies\n    }\n}\n```", "```cs\npublic class GroundEnemy : Enemy\n{\n    public override void Move()\n    {// Specific movement logic for ground enemies\n    }\n    public override void Attack()\n    {// Specific attack logic for ground enemies\n    }\n}\n```", "```cs\npublic class FlyingEnemy : Enemy\n{\n    public override void Move()\n    {// Specific movement logic for flying enemies\n    }\n    public override void Attack()\n    {// Specific attack logic for flying enemies\n    }\n}\n```", "```cs\npublic class EnemyManager : MonoBehaviour\n{\n    void Start()\n    {\n        // Creating instances of GroundEnemy and FlyingEnemy\n        Enemy groundEnemy = new GroundEnemy();\n        Enemy flyingEnemy = new FlyingEnemy();\n        // Using LSP, treating both enemies as base class\n        groundEnemy.Move();\n        groundEnemy.Attack();\n        flyingEnemy.Move();\n        flyingEnemy.Attack();\n    }\n}\n```", "```cs\npublic interface INPC\n{\n    void Wander();\n    void Talk();\n    void Trade();\n}\npublic class FriendlyNPC : INPC\n{\n    public void Wander() { /* Implementation */ }\n    public void Talk() { /* Implementation */ }\n    public void Trade() { /* Implementation */ }\n}\npublic class AggressiveNPC : INPC\n{\n    // Unnecessary implementations for Wander and Trade\n    public void Wander() { /* Unnecessary Implementation */ }\n    public void Talk() { /* Implementation */ }\n    public void Trade() { /* Unnecessary Implementation */ }\n}\n```", "```cs\npublic interface IWanderable\n{\n    void Wander();\n}\npublic interface ITalkable\n{\n    void Talk();\n}\npublic interface ITradable\n{\n    void Trade();\n}\npublic class FriendlyNPC : IWanderable, ITalkable, ITradable\n{\n    public void Wander() { /* Implementation */ }\n    public void Talk() { /* Implementation */ }\n    public void Trade() { /* Implementation */ }\n}\npublic class AggressiveNPC : ITalkable\n{\n    public void Talk() { /* Implementation */ }\n}\n```", "```cs\npublic class WeaponManager\n{\n    private Pistol pistol;\n    private Rifle rifle;\n    public WeaponManager()\n    {\n        pistol = new Pistol();\n        rifle = new Rifle();\n    }\n    public void UseWeapons()\n    {\n        pistol.Fire();\n        rifle.Fire();\n    }\n}\npublic class Pistol\n{\n    public void Fire() { /* Implementation */ }\n}\npublic class Rifle\n{\n    public void Fire() { /* Implementation */ }\n}\n```", "```cs\npublic interface IWeapon\n{\n    void Fire();\n}\npublic class WeaponManager\n{\n    private readonly List<IWeapon> weapons;\n    public WeaponManager(List<IWeapon> weapons)\n    {\n        this.weapons = weapons;\n    }\n    public void UseWeapons()\n    {\n        foreach (var weapon in weapons)\n        {\n            weapon.Fire();\n        }\n    }\n}\npublic class Pistol : IWeapon\n{\n    public void Fire() { /* Implementation */ }\n}\npublic class Rifle : IWeapon\n{\n    public void Fire() { /* Implementation */ }\n}\n```", "```cs\npublic class GameManager : MonoBehaviour\n{\n    // Static reference to the instance\n    private static GameManager _instance;\n    // Public property to access the instance\n    public static GameManager Instance\n    {\n        get\n        {\n            if (_instance == null)\n            {\n                // If the instance is null, create a new instance\n                _instance = new GameObject(\"GameManager\").AddComponent<GameManager>();\n            }\n            return _instance;\n        }\n    }\n    // Other GameManager properties and methods\n    public void StartGame()\n    {\n        Debug.Log(\"Game Started!\");\n    }\n}\n```", "```cs\npublic class PlayerController : MonoBehaviour\n{\n    private void Start()\n    {\n        // Accessing the GameManager instance\n        GameManager.Instance.StartGame();\n    }\n}\n```", "```cs\n // Flyweight interface for weapons\npublic interface IWeapon\n{\n    void Fire();\n}\n```", "```cs\n// Concrete flyweight class for shared weapon properties\npublic class Weapon : IWeapon\n{\n     private string name;\n     private int damage;\n     private string sound;\n     public Weapon(string name, int damage, string sound)\n     {\n         this.name = name;\n         this.damage = damage;\n         this.sound = sound;\n     }\n     public void Fire()\n     {\n          Debug.Log($\"{name} fired - Damage: {damage} - Sound: {sound}\");\n     }\n}\n```", "```cs\n// Flyweight factory class to manage and reuse flyweight objects\npublic class WeaponFactory\n{\n    private Dictionary<string, IWeapon> weapons;\n    public WeaponFactory()\n    {\n        weapons = new Dictionary<string, IWeapon>();\n    }\n    public IWeapon GetWeapon(string key)\n    {\n        if (!weapons.ContainsKey(key))\n        {\n            switch (key)\n            {\n                case \"pistol\":\n                    weapons[key] = new Weapon(\"Pistol\", 30, \"Bang!\");\n                    break;\n                case \"shotgun\":\n                    weapons[key] = new Weapon(\"Shotgun\", 50, \"Boom!\");\n                    break;\n                case \"rifle\":\n                    weapons[key] = new Weapon(\"Rifle\", 40, \"Pew Pew!\");\n                    break;\n                default:\n                    throw new ArgumentException(\"Invalid weapon key\");\n            }\n        }\n        return weapons[key];\n    }\n}\n```", "```cs\npublic class GameClient : MonoBehaviour\n{\n    void Start()\n    {\n        WeaponFactory weaponFactory = new WeaponFactory();\n        // Using flyweight objects\n        IWeapon pistol = weaponFactory.GetWeapon(\"pistol\");\n        pistol.Fire();\n        IWeapon shotgun = weaponFactory.GetWeapon(\"shotgun\");\n        shotgun.Fire();\n        IWeapon rifle = weaponFactory.GetWeapon(\"rifle\");\n        rifle.Fire();\n        // Reusing flyweight objects\n        IWeapon anotherPistol = weaponFactory.GetWeapon(\"pistol\");\n        anotherPistol.Fire();\n    }\n}\n```", "```cs\n// Observer interface\npublic interface IHealthObserver\n{\n    void OnHealthChanged(int health);\n}\n// Subject interface\npublic interface IHealthSubject\n{\n    event Action<int> OnHealthChanged;\n}\n```", "```cs\npublic class HealthManager : MonoBehaviour, IHealthSubject\n{\n    private int currentHealth;\n    public int MaxHealth { get; private set; } = 100;\n    // Event to notify observers when health changes\n    public event Action<int> OnHealthChanged;\n    private void Start()\n    {\n        currentHealth = MaxHealth;\n    }\n    // Method to damage the character\n    public void TakeDamage(int damage)\n    {\n        currentHealth -= damage;\n        currentHealth = Mathf.Clamp(currentHealth, 0, MaxHealth);\n        // Notify observers about the health change\n        OnHealthChanged?.Invoke(currentHealth);\n        // Check for death condition\n        if (currentHealth == 0)\n        {\n            Debug.Log(\"Character has died!\");\n            // Additional logic for character death...\n        }\n    }\n}\n```", "```cs\npublic class UIObserver : MonoBehaviour, IHealthObserver\n{\n    public void OnHealthChanged(int health)\n    {\n        // Update UI elements based on the received health value\n        Debug.Log($\"Health UI Updated: {health}\");\n        // Additional UI update logic...\n    }\n}\n```", "```cs\npublic class GameplayObserver : MonoBehaviour, IHealthObserver\n{\n    public void OnHealthChanged(int health)\n    {\n        // Update gameplay mechanics based on the received health value\n        Debug.Log($\"Gameplay Updated: {health}\");\n        // Additional gameplay update logic...\n    }\n}\n```", "```cs\npublic class GameExample : MonoBehaviour\n{\n    private void Start()\n    {\n        HealthManager healthManager = new HealthManager();\n        UIObserver uiObserver = new UIObserver();\n        GameplayObserver gameplayObserver = new GameplayObserver();\n        // Register observers with the HealthManager\n        healthManager.OnHealthChanged += uiObserver.OnHealthChanged;\n        healthManager.OnHealthChanged += gameplayObserver.OnHealthChanged;\n        // Simulate damage to the character\n        healthManager.TakeDamage(20);\n    }\n}\n```", "```cs\npublic class PlayerController : MonoBehaviour\n{\n    public void HandlePlayerInput()\n    {\n        // ... (code for handling input)\n        if (isMoving)\n        {\n            // ... (code for player movement)\n        }\n        if (isShooting)\n        {\n            // ... (code for shooting logic)\n        }\n        // ... (more complex logic)\n        if (isJumping)\n        {\n            // ... (code for jumping)\n        }\n        // ... (more code)\n        if (isDucking)\n        {\n            // ... (code for ducking)\n        }\n        // ... (more code)\n        if (isInteracting)\n        {\n            // ... (code for interacting with objects)\n        }\n        // ... (even more code)\n    }\n}\n```", "```cs\npublic class PlayerController : MonoBehaviour\n{\n    public void HandlePlayerInput()\n    {\n        HandleMovement();\n        HandleShooting();\n        HandleJumping();\n        HandleDucking();\n        HandleInteracting();\n    }\n    private void HandleMovement()\n    {\n        // ... (code for player movement)\n    }\n    private void HandleShooting()\n    {\n        // ... (code for shooting logic)\n    }\n    private void HandleJumping()\n    {\n        // ... (code for jumping)\n    }\n    private void HandleDucking()\n    {\n        // ... (code for ducking)\n    }\n    private void HandleInteracting()\n    {\n        // ... (code for interacting with objects)\n    }\n}\n```", "```cs\npublic class EnemyAI : MonoBehaviour\n{\n    public void AttackPlayer()\n    {\n        // ... (code for attacking player)\n    }\n    public void AttackAlly()\n    {\n        // ... (same code for attacking ally)\n    }\n    public void AttackBoss()\n    {\n        // ... (same code for attacking boss)\n    }\n}\n```", "```cs\npublic class EnemyAI : MonoBehaviour\n{\n    public void Attack(Entity target)\n    {\n        // ... (common code for attacking)\n    }\n    // Usage examples:\n    // enemyAI.Attack(player);\n    // enemyAI.Attack(ally);\n    // enemyAI.Attack(boss);\n}\n```"]