# 第二章. 项目 A – 收集游戏继续

本章从上一章继续，通过使用 Unity 构建一个收集游戏。在这个游戏中，玩家以第一人称模式在环境中漫步，在全局计时器耗尽之前寻找并收集场景中的所有硬币。如果所有硬币在计时器耗尽之前被收集，则游戏胜利。然而，如果计时器在所有硬币被收集之前耗尽，则游戏失败。到目前为止创建的项目包括一个完整的环境，有地板、道具和水，还包括一个第一人称控制器和一个基本的硬币对象，形状和形式看起来正确，但仍然不能被收集。

本章通过创建一个可收集的硬币对象并添加一个计时器系统来确定总游戏时间是否已过时来完成项目。本质上，本章是关于定义一个逻辑和规则系统来管理游戏。为了实现这一点，我们需要用 C#进行编码，因此本章需要基本的编程知识。这本书是关于 Unity 和用该引擎开发游戏的。然而，作为主题的编程基础超出了本书的范围。所以我会假设你已经对编程有了一定的了解，但之前没有在 Unity 中编码过。总的来说，本章将演示以下主题：

+   材质创建

+   预制体

+   使用 C#进行编码

+   编写脚本文件

+   使用粒子系统

+   构建和编译游戏

# 创建硬币材质

上一章通过从非均匀缩放的圆柱原形创建一个基本的硬币对象来结束。这个对象是通过从应用程序菜单中选择**GameObject** | **3D Object** | **Cylinder**来创建的。见*图 2.1*。作为一个概念，硬币对象代表了我们游戏逻辑中的一个基本或基本单位，因为玩家角色应该在计时器耗尽之前积极地在关卡中寻找可以收集的硬币。这意味着硬币不仅仅是*外观*；它在游戏中的目的不仅仅是视觉上的吸引力，而是具有功能性。硬币是否被玩家收集对游戏结果的影响极大。因此，目前的硬币对象在两个方面存在不足。首先，它看起来单调且灰色——它并没有真正突出并吸引玩家的注意力。其次，硬币实际上还不能被收集。当然，玩家可以走进硬币，但没有任何适当的反应发生。

![创建硬币材质](img/figure_02_01.jpg)

图 2.1：到目前为止的硬币对象

### 注意

如本章和下一章所讨论的，完成的`CollectionGame`项目可以在本书配套文件中的`Chapter02/CollectionGame`文件夹中找到。

在本节中，我们将专注于使用**材质**来改进硬币的外观。材质定义了一个算法（或指令集），指定了硬币应该如何渲染。材质不仅说明硬币在颜色方面的外观，还定义了表面是光滑还是闪亮的，与粗糙和漫反射相对。这一点很重要，这也是为什么纹理和材质指的是不同的事物。纹理只是一个加载到内存中的图像文件，可以通过其 UV 映射将其包裹在 3D 对象上。相比之下，材质定义了如何将一个或多个纹理组合在一起并应用于对象以塑造其外观。要在 Unity 中创建新的材质资产，请在**项目**面板的空白区域右键单击，然后从上下文菜单中选择**创建** | **材质**。参见*图 2.2*。您也可以从应用程序菜单中选择**资产** | **创建** | **材质**。

![创建硬币材质](img/figure_02_02.jpg)

图 2.2：创建材质

### 注意

有时，一种材料被称为**着色器**。如果需要，您可以使用**着色器语言**创建自定义材料，或者您可以使用 Unity 插件，例如**Shader Forge**。

创建新的材质后，从项目面板中为其分配一个合适的名称。由于我目标是金色外观，我将材质命名为`mat_GoldCoin`。在资产名称前加上`mat`前缀有助于我仅从资产名称中知道它是一个材质资产。只需在文本编辑字段中键入新名称即可命名材质。您还可以双击材质名称，在任何时候稍后编辑名称。参见*图 2.3*：

![创建硬币材质](img/figure_02_03.jpg)

图 2.3：命名材质资产

接下来，如果尚未选择，请选择**项目**面板中的材质资产，其属性将立即在**对象检查器**中显示。列出了许多属性！此外，材质预览显示在**对象检查器**的底部，根据其当前设置显示材质的外观，如果将其应用于 3D 对象（如球体），则会显示。您从**检查器**更改材质设置时，预览面板会自动更新以反映您的更改，提供关于材质外观的即时反馈。参见以下截图：

![创建硬币材质](img/figure_02_04.jpg)

图 2.4：从对象检查器更改材质属性

现在我们为硬币创建一个金色材质。在创建任何材质时，首先要选择的设置是**着色器**类型，因为此设置会影响您可用的所有其他参数。**着色器**类型确定将用于着色对象的算法。有众多不同的选择，但大多数材质类型可以使用**标准**或**标准（镜面设置）**来近似。对于金币，我们可以将**着色器**保留为**标准**。参见以下截图：

![创建硬币材质](img/figure_02_05.jpg)

图 2.5：设置材质着色器类型

目前，预览面板显示的材料为一种暗灰色，这远非我们所需要的。为了定义金色，我们必须指定**阿尔贝托**。为此，点击**阿尔贝托**颜色槽以显示**颜色**选择器，并从**颜色**选择器对话框中选择金色。材料预览会根据变化进行更新。参见图下所示截图：

![创建硬币材料](img/figure_02_06.jpg)

图 2.6：为阿尔贝托通道选择金色

硬币材料看起来比之前好，但它仍然应该代表一个金属表面，这种表面通常是闪亮的且具有反射性的。为了给我们的材料添加这种特性，在**对象检查器**中点击并拖动**金属**滑块到右侧，将其值设置为`1`。这表示该材料代表一个完全金属表面，而不是像布料或头发这样的漫反射表面。同样，预览面板将更新以反映变化。参见*图 2.7*：

![创建硬币材料](img/figure_02_07.jpg)

图 2.7：创建金属材质

现在我们已经创建了一个金色材料，并且在预览面板中看起来不错。如果需要，您可以更改用于预览的对象类型。默认情况下，Unity 将创建的材料分配给球体，但允许使用其他原始对象，包括立方体、圆柱体和环面。这有助于您在不同条件下预览材料。您可以通过点击预览面板正上方的几何按钮来更改对象，以循环浏览它们。参见*图 2.8*：

![创建硬币材料](img/figure_02_08.jpg)

图 2.8：在对象上预览材料

当您的材料准备就绪时，您可以直接通过拖放将其分配到场景中的网格上。让我们将硬币材料分配给硬币。将材料从**项目**面板拖放到场景中的硬币对象上。放下材料后，硬币的外观将发生变化。参见*图 2.9*：

![创建硬币材料](img/figure_02_09.jpg)

图 2.9：将材料分配给硬币

您可以通过选择**场景**中的`Coin`对象并从**对象检查器**中查看其**网格渲染器**组件来确认材料分配是否成功，甚至可以识别出分配了哪种材料。**网格渲染器**组件负责确保当相机正在查看时，网格对象在场景中实际上是可见的。**网格渲染器**组件包含一个**材料**字段。该字段列出了当前分配给对象的全部材料。通过点击**材料**字段中的材料名称，Unity 会自动在**项目**面板中选择该材料，这使得查找材料变得快速且简单。参见*图 2.10*，**网格渲染器**组件列出了分配给对象的全部材料：

![创建硬币材料](img/figure_02_10.jpg)

图 2.10：网格渲染器组件列出了分配给对象的全部材质

### 注意

网格对象可能具有多个材质，不同材质分配给不同的面。为了获得最佳的游戏性能，尽量在对象上使用尽可能少的独特材质。如果可能的话，请努力在多个对象之间共享材质。这样做可以显著提高游戏性能。有关优化渲染性能的更多信息，请参阅在线文档[`docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html`](http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)。

就这样！你现在已经拥有了一个完整且功能齐全的金色材质，用于收藏硬币。看起来不错。然而，我们还没有完成硬币的制作。硬币的外观是正确的，但它的行为却不正确。具体来说，当被触摸时，它不会消失，而且我们还没有记录玩家总共收集了多少硬币。因此，我们需要编写脚本。

# Unity 中的 C#脚本编写

定义游戏逻辑、规则和行为通常需要脚本编写。具体来说，要将静态且无生命的场景中的对象转换成具有某种行为的环境，开发者需要编写行为代码。这需要有人定义在特定条件下事物应该如何行动和反应。收集硬币的游戏也不例外。特别是，它需要三个主要功能：

+   要知道玩家何时收集到硬币

+   要跟踪游戏过程中收集了多少硬币

+   确定计时器是否已过期

Unity 没有包含处理此场景的默认功能。因此，我们必须编写一些代码来实现它。Unity 支持两种语言，即 UnityScript（有时称为 JavaScript）和 C#。这两种语言都是强大且有用的语言，但本书使用 C#，因为从现在开始，对 JavaScript 的支持最终将被放弃。让我们按顺序开始编写这三个功能。要创建一个新的脚本文件，请在**项目**面板的空白区域右键单击，并在上下文菜单中选择**创建** | **C#脚本**。或者，您可以从应用程序菜单导航到**资产** | **创建** | **C#脚本**。参见*图 2.11*：

![Unity 中的 C#脚本编写](img/figure_02_11.jpg)

图 2.11：创建一个新的 C#脚本

文件创建后，您需要给它赋予一个描述性的名称。我会叫它`Coin.cs`。在 Unity 中，每个脚本文件代表一个具有匹配名称的单个、离散的类。因此，`Coin.cs`文件编码了`Coin`类。`Coin`类将封装`Coin`对象的行为，并最终被附加到场景中的`Coin`对象上。参见*图 2.12*：

![Unity 中的 C#脚本编写](img/figure_02_12.jpg)

图 2.12：命名脚本文件

双击**对象检查器**中的`Coin.cs`文件以打开它，在**MonoDevelop**中进行编辑，这是一个随 Unity 一起提供的第三方 IDE 应用程序。此程序允许您编辑和为您的游戏编写代码。一旦在 MonoDevelop 中打开，源文件将显示出来，如图*代码示例 2.1*所示：

```cs
using UnityEngine;
using System.Collections;

public class Coin : MonoBehaviour
{

  // Use this for initialization
  void Start () {}

  // Update is called once per frame
  void Update () {}
}
```

### 小贴士

**下载示例代码**

您可以从[`www.packtpub.com`](http://www.packtpub.com)的账户下载本书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。

您可以通过以下步骤下载代码文件：

+   使用您的电子邮件地址和密码登录或注册我们的网站。

+   将鼠标指针悬停在顶部的**支持**选项卡上。

+   点击**代码下载与勘误表**。

+   在**搜索**框中输入书籍名称。

+   选择您想要下载代码文件的书籍。

+   从下拉菜单中选择您购买此书的来源。

+   点击**代码下载**。

文件下载完成后，请确保使用最新版本的以下软件解压缩或提取文件夹：

+   Windows 上的 WinRAR / 7-Zip

+   Mac 上的 Zipeg / iZip / UnRarX

+   Linux 上的 7-Zip / PeaZip

默认情况下，所有新创建的类都从`MonoBehavior`派生，它定义了一组所有组件共享的通用功能。`Coin`类有两个自动生成的函数，即`Start`和`Update`。这些函数是由 Unity 自动调用的事件。`Start`在`GameObject`（脚本附加到的对象）在**场景**中创建时立即调用一次。`Update`在附加脚本的每个对象上每帧调用一次。`Start`对于初始化代码很有用，而`Update`对于创建随时间变化的行为很有用，例如运动和变化。现在，在继续之前，让我们将新创建的脚本文件附加到**场景**中的`Coin`对象。为此，从**项目**面板拖动并放下`Coin.cs`脚本文件到`Coin`对象上。当您这样做时，对象将添加一个新的**Coin**组件。这意味着脚本被实例化并存在于对象上。参见*图 2.13*，将脚本文件附加到对象：

![Unity 中的 C#脚本](img/figure_02_13.jpg)

图 2.13：将脚本文件附加到对象

当脚本附加到对象上时，它作为组件存在于对象上。脚本文件通常可以添加到多个对象上，甚至可以添加到同一个对象上多次。每个组件代表类的独立且唯一的实例化。当以这种方式附加脚本时，Unity 会自动调用其事件，如`Start`和`Update`。你可以通过在`Start`函数中包含一个`Debug.Log`语句来确认你的脚本是否正常工作。这会在**场景**中创建**GameObject**时将调试消息打印到**控制台**窗口。请考虑*代码示例 2.2*，它实现了这一点：

```cs
using UnityEngine;
using System.Collections;

public class Coin : MonoBehaviour
 {
  // Use this for initialization
  void Start () {
    Debug.Log ("Object Created");
  }

  // Update is called once per frame
  void Update () {

  }
}
```

如果你按工具栏上的播放按钮（*Ctrl* + *P*）运行你的游戏，并将前面的脚本附加到对象上，你将在**控制台**窗口中看到消息，**对象已创建**——每次创建类的实例时都会打印一次。请参见*图 2.14*：

![Unity 中的 C#脚本](img/figure_02_14.jpg)

图 2.14：向控制台窗口打印消息

干得好！我们现在已经为`Coin`类创建了一个基本的脚本并将其附加到硬币上。接下来，让我们定义其功能，以便在收集硬币时跟踪它们。

# 计数硬币

如果游戏中只有一个硬币，那么收集硬币的游戏就不会是真正的游戏。核心思想是，一个关卡应该有多个硬币，玩家应该在计时器到期前收集所有硬币。现在，为了知道是否已经收集了所有硬币，我们需要知道场景中总共有多少个硬币。毕竟，如果我们不知道有多少硬币，那么我们就无法知道是否已经收集了所有硬币。因此，我们在脚本编写中的第一个任务是配置`Coin`类，以便我们可以在任何时刻轻松地知道场景中硬币的总数。请考虑*代码示例 2.3*，它将`Coin`类适配以实现这一点：

```cs
//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Coin : MonoBehaviour 
{
  //-------------------------
  //Keeps track of total coin count in scene
  public static int CoinCount = 0;
  //-------------------------
  // Use this for initialization
  void Start () 
{
    //Object created, increment coin count
    ++Coin.CoinCount;
  }
  //-------------------------
  //Called when object is destroyed
  void OnDestroy()
  {
    //Decrement coin count
    --Coin.CoinCount;

    //Check remaining coins
    if(Coin.CoinCount <= 0)
    {
      //We have won
    }
  }
  //-------------------------
}
//-------------------------
```

## 代码示例 2.3

以下要点总结了代码示例：

+   `Coin`类维护一个静态成员变量`CoinCount`，由于它是静态的，因此跨所有类的实例共享。这个变量统计场景中硬币的总数，每个实例都可以访问它。

+   当对象在**场景**中创建时，`Start`函数会针对每个`Coin`实例调用一次。对于场景开始时存在的硬币，`Start`事件在场景启动时被调用。这个函数会将`CoinCount`变量增加一，从而统计所有硬币。

+   当对象被销毁时，`OnDestroy`函数会针对每个实例调用一次。这会减少`CoinCount`变量的值，减少每个被销毁的硬币的数量。

总的来说，*代码示例 2.3*维护一个`CoinCount`变量。简而言之，这个变量允许我们始终跟踪硬币的总数。我们可以轻松查询它以确定剩余多少硬币。这是好的，但这只是完成收集硬币功能的第一步。

# 收集硬币

之前，我们开发了一个计数变量，告诉我们场景中有多少硬币。然而，无论计数如何，玩家在游戏过程中仍然无法收集硬币。现在让我们解决这个问题。首先，我们需要考虑碰撞。仔细思考后，我们知道只要玩家走进硬币，硬币就被认为是收集到了，也就是说，当玩家和硬币相交或碰撞时，硬币就被收集了。

为了确定何时发生此类碰撞，我们必须近似玩家和硬币的体积，以确定两个体积在空间中何时重叠。在 Unity 中，这是通过碰撞器实现的。碰撞器是附加到网格的特殊物理对象。它们告诉我们两个网格何时相交。`FPSController`对象（第一人称控制器）已经通过其**角色控制器**组件附加了一个碰撞器。这近似了一个普通人的物理身体。这可以通过在**场景**中选择`FPSController`并检查围绕主相机的绿色线框笼来确认。它是胶囊形状的。参见*图 2.15*，**角色控制器**具有一个碰撞器来近似玩家身体：

![收集硬币](img/figure_02_15.jpg)

图 2.15：角色控制器具有碰撞器来近似玩家身体

`FPSController`组件包含一个**角色控制器**组件，默认配置了**半径**、**高度**和**中心**设置，这些设置定义了场景中角色的物理范围。参见*图 2.16*，`FPSController`组件包含**角色控制器**。这些设置可以保持不变，适用于我们的游戏：

![收集硬币](img/figure_02_16.jpg)

图 2.16：FPSController 具有角色控制器

相比之下，`Coin`对象仅具有一个**胶囊碰撞器**组件，这是在我们之前创建**圆柱**原语时自动添加的，以模拟硬币。这近似了场景中硬币的物理体积，而不添加任何特定于角色和运动的额外功能，如**角色控制器**组件中找到的。这是可以的，因为硬币是一个**静态**对象，而不是像`FPSController`那样的移动和动态对象。参见*图 2.17*，**圆柱**原语具有**胶囊碰撞器**组件：

![收集硬币](img/figure_02_17.jpg)

图 2.17：圆柱原语具有胶囊碰撞器组件

对于这个项目，我将坚持使用**胶囊碰撞器**组件为`Coin`对象。但是，如果您想将附加的碰撞器更改为不同的形状，例如盒子或球体，您可以通过首先删除硬币上的任何现有碰撞器组件来实现这一点——点击**对象检查器**中组件的齿轮图标，然后在上下文菜单中选择**移除组件**。参见*图 2.18*：

![收集硬币](img/figure_02_18.jpg)

图 2.18：从物体中移除组件

然后，你可以通过从应用程序菜单中选择**组件** | **物理**，然后选择一个合适形状的碰撞体，将新的碰撞体组件添加到选定的对象中。参见*图 2.19*：

![收集金币](img/figure_02_19.jpg)

图 2.19：向选定的对象添加组件

不论使用哪种碰撞体类型，都存在一个小问题。如果你现在玩游戏并尝试穿过金币，它会阻挡你的路径。金币作为一个固体、物理对象，`FPSController`无法通过。然而，对于我们的目的来说，金币不应该这样表现。它应该是一个可收集的对象。我们的想法是，当我们穿过它时，金币被收集并消失。我们可以通过选择`Coin`对象，并在**对象检查器**中的**胶囊碰撞体**组件中启用**Is Trigger**复选框来轻松解决这个问题。**Is Trigger**设置几乎适用于所有碰撞体类型。它允许我们检测与其他碰撞体的碰撞和交点，同时允许它们通过。参见*图 2.20*：

![收集金币](img/figure_02_20.jpg)

图 2.20：Is Trigger 设置允许对象通过碰撞体

如果你现在玩游戏，`FPSController`将轻松地穿过场景中的所有金币对象。这是一个好的开始。然而，金币在被触摸时并没有真正消失；它们仍然没有被收集。为了实现这一点，我们需要在`Coin.cs`文件中添加更多的脚本。具体来说，我们将添加一个`OnTriggerEnter`函数。当像玩家这样的对象进入碰撞体时，这个函数会自动被调用。目前，我们将添加一个`Debug.Log`语句，在玩家进入碰撞体时打印一个调试信息，仅用于测试目的。参见*代码示例 2.4*：

```cs
//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Coin : MonoBehaviour 
{
  //-------------------------
  public static int CoinCount = 0;
  //-------------------------
  // Use this for initialization
  void Start () {
    //Object created, increment coin count
    ++Coin.CoinCount;
  }
  //-------------------------
  void OnTriggerEnter(Collider Col)
  {
    Debug.Log ("Entered Collider");
  }
  //-------------------------
  //Called when object is destroyed
  void OnDestroy()
  {
    //Decrement coin count
    --Coin.CoinCount;

    //Check remaining coins
    if(Coin.CoinCount <= 0)
    {
      //We have won
    }
  }
  //-------------------------
}
//-------------------------
```

### 注意

关于`OnTriggerEnter`函数的更多信息，可以在以下在线 Unity 文档中找到：

[`docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html`](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html)

通过工具栏上的播放按钮测试*代码示例 2.4*。当你遇到代币时，`OnTriggerEnter`函数将被执行并显示消息。然而，问题仍然存在，即最初是什么对象触发了这个函数。确实，有东西与代币发生了碰撞，但具体是什么？是玩家、敌人、下落的砖块，还是其他东西？为了检查这一点，我们将使用**标签**。**标签**功能允许你使用特定的标签或标签标记场景中的特定对象，使得这些对象在代码中容易被识别，以便我们可以快速检查是玩家而不是其他对象与代币发生了碰撞。毕竟，只有玩家才能收集代币。因此，首先，我们将玩家对象标记为名为**Player**的标签。为此，在场景中选择`FPSController`对象，然后点击**对象检查器**中的**标签**下拉框。从这里，选择**Player**标签。这标志着`FPSController`为`Player`对象。参见*图 2.21*：

![收集代币](img/figure_02_21.jpg)

图 2.21：将 FPSController 标记为 Player

由于`FPSController`现在被标记为**Player**，我们可以细化`Coin.cs`文件，如*代码示例 2.5*所示。这处理了代币收集，使得代币在触摸时消失并减少代币计数。

```cs
//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Coin : MonoBehaviour 
{
  //-------------------------
  public static int CoinCount = 0;
  //-------------------------
  // Use this for initialization
  void Start () {
    //Object created, increment coin count
    ++Coin.CoinCount;
  }
  //-------------------------
  void OnTriggerEnter(Collider Col)
  {
    //If player collected coin, then destroy object
    if(Col.CompareTag("Player"))
      Destroy(gameObject);
  }
  //-------------------------
  //Called when object is destroyed
  void OnDestroy()
  {
    //Decrement coin count
    --Coin.CoinCount;

    //Check remaining coins
    if(Coin.CoinCount <= 0)
    {
      //We have won
    }
  }
  //-------------------------
}
//-------------------------
```

## 代码示例 2.5

以下要点总结了代码示例：

+   Unity 每次`FPSController`与`Coin`碰撞器相交时都会自动调用一次`OnTriggerEnter`。

+   当调用`OnTriggerEnter`时，`Col`参数包含有关此次进入碰撞器的对象的信息。

+   使用`CompareTag`函数来确定碰撞的对象是否是`Player`而不是其他对象。

+   调用`Destroy`函数是为了销毁`Coin`对象本身，该对象在内部通过继承的成员变量`gameObject`表示。

    当调用`Destroy`函数时，会自动触发`OnDestroy`事件，该事件会减少`Coin`的数量。

优秀的工作！你刚刚创建了你第一个工作的代币。现在玩家可以跑向代币，收集它，并将其从场景中移除。这是一个很好的开始，但场景应该包含不止一个代币。我们可以通过多次复制现有的代币并将每个副本重新定位到不同的位置来解决这个问题。然而，还有更好的方法，我们将在下面看到。

# 代币和预制体

现在已经创建了基本的硬币功能，但场景需要不止一个硬币。简单地复制一个硬币并将副本散布开来存在的问题是，如果我们稍后对其中一个硬币进行更改并需要将此更改传播到所有其他硬币，我们需要删除之前的副本并手动用较新和修正的副本替换它们。为了避免这种繁琐的重复，我们可以使用预制件。预制件允许您将场景中的对象转换为**项目**面板中的`Assets`。这可以在场景中按需实例化，就像它是一个网格资产一样。优点是，对资产所做的更改将自动应用于所有实例，即使在多个场景中也是如此。

这样做使得与自定义资产的工作更加容易，所以现在就预制硬币吧。为此，在场景中选择`Coin`对象，然后将其拖放到**项目**面板中。当这样做时，将创建一个新的`prefab`。场景中的对象将自动更新为`prefab`的实例。这意味着如果从`项目`面板中删除了资产，实例将变得无效。参见*图 2.22*：

![硬币和预制件](img/figure_02_22.jpg)

图 2.22：创建硬币预制件

在创建`prefab`之后，您可以通过将`prefab`从**项目**面板拖放到**场景**中，轻松地将更多硬币实例添加到关卡中。每个实例都与原始`prefab`资产相关联，这意味着对资产所做的所有更改将立即应用于所有实例。考虑到这一点，现在请继续添加尽可能多的`Coin`预制件到关卡中，以适应您的硬币收集游戏。参考以下图示进行布局：

![硬币和预制件](img/figure_02_23.jpg)

图 2.23：将硬币预制件添加到关卡中

一个自然而然出现的问题是，您如何将预制件转换回不再与`prefab`资产连接的独立`GameObject`。如果您希望某些对象基于`prefab`但略有偏差，这样做是有用的。为了实现这一点，在**场景**中选择一个`prefab`实例，然后从应用程序菜单导航到**GameObject** | **分解预制件实例**。参见*图 2.24*：

![硬币和预制件](img/figure_02_24.jpg)

图 2.24：分解预制件实例

### 注意

如果您将`prefab`实例添加到**场景**中并对它进行了您喜欢的更改，并希望将这些更改向上游分发回`prefab`资产，那么请选择该对象并选择**GameObject** | **应用到预制件**。

# 计时器和倒计时

您现在应该有一个包含几何和硬币对象的游戏关卡。多亏了我们新添加的 `Coin.cs` 脚本，硬币现在既可计数也可收集。即便如此，关卡对玩家来说仍然几乎没有挑战，因为没有赢得或输掉关卡的方法。具体来说，玩家没有要实现的目标。这就是为什么游戏中的时间限制很重要：它定义了胜利和失败条件。也就是说，在计时器到期之前收集所有硬币会导致胜利条件，而未能实现这一点则会导致失败条件。让我们开始为关卡创建计时器倒计时。为此，通过选择 **GameObject** | **Create Empty** 创建一个新的空游戏对象，并将其重命名为 `LevelTimer`。参见 *图 2.25*：

![计时器和倒计时](img/figure_02_25.jpg)

图 2.25：重命名计时器对象

### 注意

请记住，空的游戏对象玩家是看不到的，因为它们没有网格渲染器组件。它们特别有用于创建不直接对应于物理和可见实体的功能和行为，例如计时器、管理器和游戏逻辑控制器。

接下来，创建一个名为 `Timer.cs` 的新脚本文件，并将其添加到 **场景** 中的 `LevelTimer` 对象中。通过这样做，计时器功能将存在于场景中。但是，请确保计时器脚本只添加到一个对象中，并且不超过一个。否则，场景中实际上会有多个相互竞争的计时器。您可以通过使用 **层次结构** 面板来搜索场景以找到指定类型的所有组件。为此，点击 **层次结构** 搜索框并输入 `t:Timer`。然后按键盘上的 *Enter* 键确认搜索。这将搜索场景中所有附加了计时器类型组件的对象，并将结果显示在 **层次结构** 面板中。具体来说，**层次结构** 面板被过滤以仅显示匹配的对象。搜索字符串中的 `t` 前缀表示按类型进行搜索操作。参见 *图 2.26*：

![计时器和倒计时](img/figure_02_26.jpg)

图 2.26：搜索具有匹配类型组件的对象

您可以通过单击搜索字段右侧的小交叉图标轻松取消搜索，并将 **层次结构** 面板恢复到原始状态。这个按钮可能很难找到。参见 *图 2.27*：

![计时器和倒计时](img/figure_02_27.jpg)

图 2.27：取消类型搜索

如果要使计时器脚本有用，则必须编写计时器脚本。`Timer.cs` 文件的完整源代码在以下 *代码示例 2.6* 中给出。如果您以前从未在 Unity 中编写过脚本，这段源代码非常重要。它展示了许多关键特性。请参阅注释以获得更全面的解释。

```cs
//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Timer : MonoBehaviour
{
  //-------------------------
  //Maximum time to complete level (in seconds)
  public float MaxTime = 60f;
  //-------------------------
  //Countdown
  [SerializeField]
  private float CountDown = 0;
  //-------------------------
  // Use this for initialization
  void Start () 
  {
    CountDown = MaxTime;
  }
  //-------------------------
  // Update is called once per frame
  void Update () 
  {
    //Reduce time
    CountDown -= Time.deltaTime;

    //Restart level if time runs out
    if(CountDown <= 0)
    {
      //Reset coin count
      Coin.CoinCount=0;
      Application.LoadLevel(Application.loadedLevel);
    }
  }
  //-------------------------
}
//-------------------------
```

## 代码示例 2.6

以下要点总结了代码示例：

+   在 Unity 中，声明为`public`（例如`public float MaxTime`）的类变量在编辑器的**对象检查器**中显示为可编辑字段。然而，这仅适用于支持的多种数据类型，但这是一个非常有用的功能。这意味着开发者可以直接从**检查器**中监控和设置类的`public`变量，而不必每次需要更改时都修改和重新编译代码。相比之下，`private`变量默认情况下被隐藏在**检查器**中。但是，如果需要，可以使用`SerializeField`属性强制它们可见。带有此属性的前缀的`private`变量，例如`CountDown`变量，将在**对象检查器**中显示，就像一个`public`变量一样，尽管变量的作用域仍然是`private`。

+   `Update`函数是 Unity 原生事件，支持所有从`MonoBehaviour`派生的类。`Update`函数会自动在每一帧调用一次场景中所有活动的`GameObjects`。这意味着所有活动的游戏对象都会收到帧更改事件的通知。简而言之，`Update`因此每秒被调用多次；游戏 FPS 是每秒调用次数的一般指标。实际上，每秒的调用次数会因实际情况而有所不同。无论如何，`Update`特别适用于在一段时间内动画化、更新和改变对象。对于`CountDown`类，跟踪时间流逝，每秒更新是有用的。关于`Update`函数的更多信息可以在 Unity 在线文档中找到，网址为[`docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html`](http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html)。

    ### 注意

    除了每帧调用的`Update`函数之外，Unity 还支持两个其他相关函数，即`FixedUpdate`和`LateUpdate`。`FixedUpdate`在编写**物理**代码时使用，我们将在后面看到，并且每帧调用固定次数。`LateUpdate`每帧为每个活动对象调用一次，但`LateUpdate`调用总是在每个对象收到`Update`事件之后发生。因此，它发生在`Update`周期之后，使其成为延迟更新。这种延迟更新的原因将在本书后面的章节中看到。

    关于`FixedUpdate`的更多信息可以在 Unity 在线文档中找到，网址为[`docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html`](http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html)。关于`LateUpdate`函数的更多信息可以在 Unity 在线文档中找到，网址为[`docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html`](http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html)。

+   在编写脚本时，静态的`Time.deltaTime`变量始终可用，并由 Unity 自动更新。它始终描述了自上一帧结束以来经过的时间（以秒为单位）。例如，如果你的游戏帧率为 2 FPS（一个非常低的帧率！）那么`deltaTime`将是`0.5`。这是因为，在每一秒中，会有两个帧，因此每个帧将是半秒。`deltaTime`很有用，因为，如果随着时间的推移而累加，它就会告诉你自游戏开始以来总共经过了多少时间。因此，`deltaTime`浮点变量在`Update`函数中被大量使用，以便从倒计时总数中减去经过的时间。有关`deltaTime`的更多信息，可以在在线文档中找到，网址为[`docs.unity3d.com/ScriptReference/Time-deltaTime.html`](http://docs.unity3d.com/ScriptReference/Time-deltaTime.html)。

+   静态的`Application.LoadLevel`函数可以在代码的任何地方调用，以在运行时更改活动场景。因此，这个函数对于将玩家从一个关卡移动到另一个关卡非常有用。它会导致 Unity 终止活动场景，销毁其所有内容，并加载一个新的场景。它也可以通过重新加载活动关卡来重新启动活动场景。`Application.LoadLevel`对于具有明确定义且彼此分离的关卡，并且有明确开始和结束的游戏最为合适。然而，它并不适合大型开放世界游戏，在这些游戏中，广阔的环境似乎没有中断或断开。有关`Application.LoadLevel`的更多信息，可以在 Unity 在线文档中找到，网址为[`docs.unity3d.com/ScriptReference/Application.LoadLevel.html`](http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html)。

在创建计时器脚本后，选择场景中的`LevelTimer`对象。从**对象检查器**中，你可以设置玩家完成关卡允许的最大时间（以秒为单位）。参见*图 2.28*。我已经将总时间设置为`60`秒。这意味着所有金币必须在关卡开始后的`60`秒内完成。如果计时器到期，关卡将重新启动。

![代码示例 2.6](img/figure_02_28.jpg)

图 2.28：设置关卡总时间

伟大的工作！你现在应该有一个带有工作倒计时的完成关卡。你可以收集金币，计时器可以到期。总的来说，游戏正在成形。然而，还有一个进一步的问题，我们将在下一部分解决。

# 庆祝和烟花！

硬币收集游戏几乎完成了。可以收集硬币，计时器到期，但胜利条件本身并没有真正处理。也就是说，在时间到期前收集到所有硬币时，实际上并没有发生任何事情来向玩家显示他们已经获胜。倒计时仍在继续，甚至重新开始关卡，好像根本未满足胜利条件。现在让我们解决这个问题。具体来说，当发生胜利场景时，我们应该删除计时器对象以防止进一步的倒计时并显示视觉反馈以表明关卡已完成。在这种情况下，我将添加一些烟花！所以，让我们先创建烟花。您可以从 Unity 5 的 **粒子系统** 包中轻松添加这些。导航到 `Standard Assets` | `ParticleSystems` | `Prefabs` 文件夹。然后，将 `Fireworks` 粒子系统拖放到 **场景** 中。如果您想要的话，还可以添加第二个或第三个。

![庆祝和烟花！](img/figure_02_29.jpg)

图 2.29：添加两个烟花预制体

默认情况下，所有烟花粒子系统将在关卡开始时播放。您可以通过在工具栏上按播放来测试这一点。这不是我们想要的行为。我们只想在满足胜利条件时播放烟花。要禁用在关卡启动时的播放，请在 **场景** 中选择 **粒子系统** 对象，并在 **对象检查器** 中禁用 **播放唤醒** 复选框，该复选框位于 **粒子系统** 组件中。参见 *图 2.30*，禁用 **播放唤醒**：

![庆祝和烟花！](img/figure_02_30.jpg)

图 2.30：禁用播放唤醒

禁用 **播放唤醒** 防止粒子系统在关卡启动时自动播放。这很好，但如果它们要播放，必须在正确的时间手动启动它们。我们可以通过代码来实现这一点。然而，在求助于编码解决方案之前，我们首先将所有烟花对象标记为适当的标签。这样做的原因是，在代码中，我们将想要在场景中搜索所有烟花对象并在需要时触发它们播放。为了将烟花对象与其他所有对象隔离开来，我们将使用标签。因此，让我们创建一个新的 **Fireworks** 标签并将它们仅分配给 **场景** 中的烟花对象。标签是在本章早期配置玩家角色以进行硬币碰撞时创建的。参见 *图 2.31*：

![庆祝和烟花！](img/figure_02_31.jpg)

图 2.31：标记烟花对象

通过标记烟花对象，我们现在可以细化 `Coin.cs` 脚本类以处理场景的胜利条件，如 *代码示例 2.7* 所示。注释如下：

```cs
//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Coin : MonoBehaviour
{
  //-------------------------
  public static int CoinCount = 0;
  //-------------------------
  // Use this for initialization
  void Awake () 
  {
    //Object created, increment coin count
    ++Coin.CoinCount;
  }
  //-------------------------
  void OnTriggerEnter(Collider Col)
  {
    //If player collected coin, then destroy object
    if(Col.CompareTag("Player"))
      Destroy(gameObject);
  }
  //-------------------------
  void OnDestroy()
  {
    --Coin.CoinCount;

    //Check remaining coins
    if(Coin.CoinCount <= 0)
    {
      //Game is won. Collected all coins
      //Destroy Timer and launch fireworks
      GameObject Timer = GameObject.Find("LevelTimer");
      Destroy(Timer);

      GameObject[] FireworkSystems =         GameObject.FindGameObjectsWithTag("Fireworks");
      foreach(GameObject GO in FireworkSystems)
      GO.GetComponent<ParticleSystem>().Play();
    }
  }
  //-------------------------
}
//-------------------------
```

## 代码示例 2.7

以下要点总结了代码示例：

+   `OnDestroy` 函数至关重要。它发生在收集到硬币时，并包含一个 `if` 语句以确定何时收集到所有硬币（即胜利场景）。

+   当发生胜利场景时，会调用`GameObject.Find`函数来在整个场景层次结构中搜索任何名为`LevelTimer`的活动对象。如果找到，该对象将被删除。这会导致删除计时器并防止在关卡胜利后进行进一步的倒计时。如果场景包含多个同名对象，则只返回第一个对象。这是场景应该只包含一个计时器的一个原因。

    ### 注意

    尽可能避免使用`GameObject.Find`函数。它在性能上很慢。相反，使用`FindGameObjectsWithTag`。这里只使用它来演示其存在和目的。有时，你需要使用它来找到单个、无特定标签的杂项对象。

+   除了删除`LevelTimer`对象外，`OnDestroy`函数还会在场景中找到所有烟花对象并启动它们。它使用`GameObject.FindGameObjectsWithTag`函数找到所有匹配标签的对象。此函数返回所有带有**Fireworks**标签的对象数组，并通过调用`Play`函数为每个对象启动`ParticleSystem`。

    ### 注意

    如前所述，Unity 中的每个`GameObject`实际上是由一组附加的相关组件组成的。一个对象是其组件的总和。例如，一个标准立方体（使用**GameObject** | **3D Object** | **Cube**）由**Transform**组件、**Mesh Filter**组件、**Mesh Renderer**组件和**Box Collider**组件组成。这些组件共同构成了立方体，并决定了它的行为。

    可以在脚本中调用`GetComponent`函数来检索对任何指定组件的引用，从而直接访问其公共属性。前述代码中的`OnDestroy`函数使用`GetComponent`来检索附加到对象上的`ParticleSystem`组件的引用。`GetComponent`是一个高度有用且重要的函数。有关`GetComponent`的更多信息，可以在 Unity 在线文档中找到，链接为[`docs.unity3d.com/ScriptReference/GameObject.GetComponent.html`](http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)。

# 游戏测试

你现在已经在 Unity 中完成了你的第一个游戏！是时候对其进行测试运行，然后最终构建它了。在 Unity 中进行测试首先是通过工具栏上的播放按钮来播放游戏，以查看游戏是否按预期从玩家的角度工作。除了播放之外，你还可以从**对象检查器**中启用调试模式，在运行时密切关注所有`public`和`private`变量，确保没有变量被分配了意外的值。要激活**调试**模式，点击**对象检查器**右上角的菜单图标，然后从出现的上下文菜单中选择**调试**选项。参见*图 2.32*：

![游戏测试](img/figure_02_32.jpg)

图 2.32：从对象检查器激活调试模式

在激活**Debug**模式后，**对象检查器**中一些变量和组件的外观可能会改变。通常，您将获得更详细和准确的变量视图，您还将能够看到大多数`private`变量。参见*图 2.33*以查看**Debug**模式下的**Transform**组件：

![Play 测试](img/figure_02_33.jpg)

图 2.33：在调试模式下查看变换组件

另一个在运行时非常有用的调试工具是**Stats**面板。您可以通过点击工具栏中的**Stats**按钮从**Game**标签页访问它。参见*图 2.34*：

![Play 测试](img/figure_02_34.jpg)

图 2.34：从 Game 标签页访问 Stats 面板

**Stats**面板仅在游戏模式下有用。在此模式下，它详细说明了游戏的关键性能统计信息，例如帧率（FPS）和内存使用情况。这使您能够诊断或确定是否有任何问题可能影响您的游戏。FPS 代表您的游戏每秒可以平均维持的总帧数（滴答或周期）。没有正确、错误或神奇的 FPS，但较高的值比较低的值好。较高的值代表更好的性能，因为它意味着您的游戏可以在一秒内维持更多的周期。如果您的 FPS 低于 20 或 15，那么您的游戏可能会出现卡顿或延迟，因为每个周期的性能权重意味着它需要更长的时间来处理。许多变量可以影响 FPS，有些是游戏内部的，有些是游戏外部的。内部因素包括场景中的灯光数量、网格的顶点密度、指令数量和代码的复杂性。一些外部因素包括您计算机硬件的质量、同时运行的其他应用程序和进程的数量、硬盘空间的大小等。

简而言之，如果您的 FPS（每秒帧数）低，那么这表明需要关注的问题。该问题的解决方案取决于上下文，您需要运用判断力，例如，您的网格是否过于复杂？它们是否有太多的顶点？您的纹理是否太大？是否有太多的声音在播放？参见*图 2.35*以查看正在运行的收集硬币游戏。完成的游戏可以在书籍配套文件中的`Chapter02/End`文件夹中找到。

![Play 测试](img/figure_02_35.jpg)

图 2.35：测试收集硬币游戏

# 构建

因此，现在是时候构建游戏了！也就是说，将游戏编译并打包成独立和可执行的形式，玩家可以在不使用 Unity 编辑器的情况下运行和播放。通常，在开发游戏时，您会在设计阶段而不是开发结束时决定您的目标平台（如 Windows、iOS、Android 等）。经常有人说 Unity 是一个“一次开发，到处部署”的工具。这个口号可能会让人联想到一个不幸的图像，即游戏制作完成后，它将在 Unity 支持的所有平台上像在桌面平台上一样轻松地工作。

不幸的是，事情并不那么简单；在桌面系统上运行良好的游戏不一定在移动设备上表现同样出色，反之亦然。这主要归因于它们之间在目标硬件和行业标准方面的巨大差异。由于这些差异，我将在此处将我们的注意力集中在 Windows 和 Mac 桌面平台上，忽略移动设备、游戏机和其他平台。要为桌面平台创建构建，请从**文件**菜单中选择**文件** | **构建设置**：

![Building](img/figure_02_36.jpg)

图 2.36：访问项目的构建设置

**构建设置**对话框显示，其界面由三个主要区域组成。**构建中的场景**列表是包含在构建中的所有场景的完整列表，无论玩家是否会在游戏中访问它们。它代表了游戏中可能访问到的所有场景的总体。简而言之，如果您需要在您的游戏中添加或需要场景，那么它需要在这个列表中。最初，列表是空的。请参阅*图 2.37*：

![Building](img/figure_02_37.jpg)

图 2.37：构建设置对话框

您可以通过简单地从**项目**面板拖放场景资产到**构建中的场景**列表中轻松地将场景添加到列表中。对于金币收集游戏，我会将`Level_01`场景拖放到列表中。随着场景的增加，Unity 会根据它们在列表中的顺序自动为它们分配一个数字。**0**代表列表中最顶部的项目，1 代表下一个项目，以此类推。这个数字对于**0**项目来说很重要。最顶部的场景（场景 0）始终是起始场景。也就是说，当构建运行时，Unity 会自动从场景 0 开始执行。因此，场景 0 通常将是您的启动或介绍场景。请参阅*图 2.38*，向**构建设置**对话框添加一个级别：

![Building](img/figure_02_38.jpg)

图 2.38：向构建设置对话框添加一个级别

接下来，请确保从**构建设置**对话框左下角的**平台**列表中选择您的目标平台。对于桌面平台，选择**PC、Mac & Linux 独立**，这应该是默认选中的。然后，从选项中设置**目标平台**下拉列表为**Windows**、**Linux**或**Mac OS X**，具体取决于您的系统。请参阅*图 2.39*：

![构建](img/figure_02_39.jpg)

图 2.39：选择目标构建平台

如果您之前已经为多个平台测试过您的游戏或尝试过其他平台，如**Android**和**iOS**，当您选择**独立**选项时，**切换平台**按钮（位于**构建设置**对话框的左下角）可能会变得可用。如果是这样，点击**切换** **平台**按钮以向 Unity 确认您打算为所选平台进行构建。点击此按钮后，Unity 可能需要几分钟来配置您的资产以适应所选平台：

![构建](img/figure_02_40.jpg)

图 2.40：切换平台

在第一次构建之前，您可能希望查看**玩家设置**选项以微调重要的构建参数，例如游戏分辨率、质量设置、可执行图标和信息，以及其他设置。要访问**玩家设置**，您可以直接从**构建**对话框中点击**玩家设置**按钮。这将在**对象检查器**中显示**玩家设置**。相同的设置也可以通过应用程序菜单访问，方法是导航到**编辑** | **项目设置** | **玩家**。参见*图 2.4*：

![构建](img/figure_02_41.jpg)

图 2.41：访问玩家设置选项

从**玩家设置**选项中，设置**公司名称**和**产品名称**，因为这些信息将被嵌入并存储在构建的可执行文件中。您还可以指定可执行文件的图标图像以及默认鼠标光标（如果需要的话）。然而，对于集合游戏，后两个设置将被留空。参见*图 2.42*：

![构建](img/figure_02_42.jpg)

图 2.42：设置出版商名称和产品名称

**分辨率和显示**选项卡特别重要，因为它指定了游戏屏幕大小以及是否在应用程序启动时显示默认的启动画面（**分辨率**对话框）。从此选项卡，确保已启用**默认全屏**选项，这意味着游戏将以系统屏幕的完整尺寸运行，而不是一个较小且可移动的窗口。此外，启用**显示分辨率对话框**下拉列表。参见*图 2.43*。当此选项启用时，您的应用程序将在启动时显示一个选项屏幕，允许用户选择目标分辨率和屏幕大小以及自定义控制。对于最终构建版本，您可能希望禁用此选项，而是在游戏中通过您自己的定制选项屏幕提供相同的设置。然而，对于测试构建，**分辨率**对话框可以非常有帮助。它让您能够轻松地在不同尺寸下测试您的构建。

![构建](img/figure_02_43.jpg)

图 2.43：启用分辨率对话框

现在你可以准备进行第一次编译构建了。因此，从**构建设置**对话框中点击**构建**按钮，或者从应用程序菜单中选择**文件** | **构建 & 运行**。当你这样做时，Unity 会弹出一个**保存**对话框，询问你指定计算机上构建的目标位置。选择一个位置并选择**保存**，构建过程将完成。偶尔，这个过程可能会生成错误，这些错误会在**控制台**窗口中以红色打印出来。例如，当你保存到只读驱动器、硬盘空间不足或没有在计算机上必要的管理员权限时，可能会发生这种情况。然而，一般来说，如果你的游戏在编辑器中运行正常，构建过程就会成功。参见*图 2.44*：

![Building](img/figure_02_44.jpg)

图 2.44：构建和运行游戏

构建完成后，Unity 会在你的目标位置生成新的文件。对于 Windows，它生成一个可执行文件和数据文件夹。参见*图 2.45*。这两个都是必需的，并且相互依赖。也就是说，如果你想分发你的游戏并让其他人玩而不需要安装 Unity，那么你需要发送给用户可执行文件以及相关的数据文件夹及其所有内容。

![Building](img/figure_02_45.jpg)

图 2.45：Unity 构建了几个文件

运行你的游戏时，如果从**玩家设置**中启用了**显示分辨率** **对话框**选项，将显示**分辨率**对话框。从这里，用户可以选择游戏分辨率、质量和输出监视器，并配置玩家控制：

![Building](img/figure_02_46.jpg)

图 2.46：从分辨率对话框准备运行你的游戏

点击播放按钮后，你的游戏将默认在全屏模式下运行。恭喜！你的游戏现在已经完成并构建好了，你可以发送给你的朋友和家人进行游戏测试！参见*图 2.47*：

![Building](img/figure_02_47.jpg)

图 2.47：全屏模式运行硬币收集游戏

但等等！当你玩完游戏后，如何退出游戏？游戏中没有退出按钮或主菜单选项。对于 Windows，你只需按键盘上的*Alt* + *F4*。对于 Mac，按*cmd* + *Q*，而对于 Ubuntu，则是*Ctrl* + *Q*。

# 摘要

优秀的作品！到达这个阶段，你已经完成了收集硬币游戏以及你在 Unity 中的第一个游戏。在实现这一点后，你看到了 Unity 的广泛功能，包括关卡编辑和设计、预制体、粒子系统、网格、组件、脚本文件和构建设置。这已经很多了！当然，对于所有这些领域还有很多可以说的和探索的，但无论如何，我们已经将它们整合在一起制作了一个游戏。接下来，我们将着手制作一个完全不同的游戏，在这个过程中，我们将看到相同功能的创造性重用以及全新功能的引入。简而言之，我们将从入门级 Unity 开发的领域过渡到中级。
