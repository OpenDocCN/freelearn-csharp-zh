- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Building Interactive VR Experiences
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建交互式VR体验
- en: In this chapter, we delve into the world of more complex VR applications, empowering
    you to craft immersive and interactive experiences for a wide range of use cases.
    You will learn how to use the powerful Unity engine to create interactive VR apps
    without code and with C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入到更复杂的VR应用领域，让您能够为各种用例创建沉浸式和交互式体验。您将学习如何使用强大的Unity引擎来创建无代码的交互式VR应用和C#。
- en: The beauty of this chapter lies in its practical approach. You’ll acquire hands-on
    skills to construct a VR environment that mirrors the responsiveness and realism
    of our natural world. Though some background in C# could be advantageous, it is
    by no means a prerequisite. Our tutorial is designed to be beginner-friendly,
    allowing anyone with an interest in XR applications to follow along comfortably.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的美丽之处在于其实用性。您将获得实际操作技能，以构建一个反映我们自然世界响应性和真实性的VR环境。尽管一些C#的背景知识可能有益，但这绝对不是先决条件。我们的教程旨在面向初学者，让任何对XR应用感兴趣的人都能舒适地跟随。
- en: 'This chapter is split into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下主题：
- en: Building interactive VR experiences without code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无代码构建交互式VR体验
- en: Building interactive VR experience with C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#构建交互式VR体验
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we embark on this exciting journey, let’s ensure you meet the needed
    technical requirements to power through this chapter. Besides having the most
    recent version of Unity installed, you also need to have either *Windows*/*Linux*/*Mac*
    or *Android Build Support* enabled, depending on whether your VR device is running
    standalone or in PC-based VR mode. If you are unsure whether your PC or laptop
    meets the hardware requirements of Unity, have a look at this page: [https://docs.unity3d.com/Manual/system-requirements.html](https://docs.unity3d.com/Manual/system-requirements.html).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这段激动人心的旅程之前，让我们确保您满足完成本章所需的技术要求。除了安装最新的Unity版本外，您还需要根据您的VR设备是独立运行还是基于PC的VR模式，启用*Windows*/*Linux*/*Mac*或*Android
    Build Support*。如果您不确定您的PC或笔记本电脑是否满足Unity的硬件要求，请查看此页面：[https://docs.unity3d.com/Manual/system-requirements.html](https://docs.unity3d.com/Manual/system-requirements.html)。
- en: Building interactive VR experiences without code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无代码构建交互式VR体验
- en: After exploring the demo scene in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009),
    let’s build interactive VR experiences ourselves, starting with a virtual car
    exhibition. In the experience we are going to build, the user should be able to
    walk around the ground via continuous movement (walking with the joystick) and
    via teleportation (only to teleportation anchors).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了[*第3章*](B20869_03.xhtml#_idTextAnchor009)中的演示场景后，让我们自己构建交互式VR体验，从虚拟车展开始。在我们将要构建的体验中，用户应该能够通过连续移动（使用摇杆行走）和传送（仅限于传送锚点）在地面周围走动。
- en: To kick off our experience, create a new project by following the *Setting up
    a VR project in Unity and the XR Interaction Toolkit* section in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009).
    If you have followed the steps in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009),
    you can just open the existing project for this chapter and go through the following
    steps.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的体验，请按照[*第3章*](B20869_03.xhtml#_idTextAnchor009)中的“在Unity和XR交互工具包中设置VR项目”部分创建一个新的项目。如果您已经按照[*第3章*](B20869_03.xhtml#_idTextAnchor009)中的步骤操作，您可以直接打开本章的现有项目并按照以下步骤进行。
- en: Once your project is loaded, begin by creating a new empty scene. This can be
    done by navigating to `CarExhibition`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的项目加载完成，首先创建一个新的空场景。这可以通过导航到`CarExhibition`来完成。
- en: By double clicking on it, you’re now inside the newly created scene that contains
    only a **Main Camera** and a **Directional Light**. You can delete the **Main
    Camera**, as it is not needed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双击它，您现在已进入新创建的场景，该场景仅包含一个**主相机**和一个**方向光**。您可以删除**主相机**，因为它不是必需的。
- en: Before we delve into the VR Setup, we must first set the stage for our interaction.
    In this case, this means creating a dedicated area to house our two car exhibits.
    For the sake of simplicity, we’ll be fashioning our exhibition ground from a simple
    cube primitive. Achieve this by right-clicking in the Scene Hierarchy and selecting
    `20`, `0.1`, `20`). Now, rename the cube `ground`. This will form the foundation
    of our car exhibition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入VR设置之前，我们必须首先为我们的交互设置舞台。在这种情况下，这意味着创建一个专门区域来容纳我们的两个汽车展览。为了简化，我们将从简单的立方体原形制作展览场地。通过在场景层次结构中右键单击并选择`20`,
    `0.1`, `20`)来实现。现在，将立方体重命名为`ground`。这将形成我们汽车展览的基础。
- en: The next section details how we can import cars from the Asset Store.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分详细说明了如何从Asset Store导入汽车。
- en: Importing cars from the Asset Store
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Asset Store导入汽车
- en: 'Animating cars in our scene requires the prerequisite step of importing them.
    Let’s walk through the process of importing the `simple cars pack` from the Unity
    Asset Store:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中动画化汽车需要先导入它们。让我们一步步来导入Unity Asset Store中的`simple cars pack`：
- en: 'Go to the Unity Asset Store ([https://assetstore.unity.com/](https://assetstore.unity.com/)).
    Search for the `simple cars pack` or, for a more direct route, access the package
    page via this link: [https://assetstore.unity.com/packages/3d/vehicles/land/simple-cars-pack-97669](https://assetstore.unity.com/packages/3d/vehicles/land/simple-cars-pack-97669).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Unity Asset Store ([https://assetstore.unity.com/](https://assetstore.unity.com/))。搜索`simple
    cars pack`，或者，为了更直接的方式，通过此链接访问包页面：[https://assetstore.unity.com/packages/3d/vehicles/land/simple-cars-pack-97669](https://assetstore.unity.com/packages/3d/vehicles/land/simple-cars-pack-97669)。
- en: After adding the package to your assets, find the **Open in Unity** button and
    click on it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将包添加到你的资产后，找到**在Unity中打开**按钮并点击它。
- en: This action should prompt the Unity application to open, presenting you with
    the option to import the package. Please proceed with the **Import** operation.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此操作应提示Unity应用程序打开，并为你提供导入包的选项。请继续进行**导入**操作。
- en: Once the import is successful, journey to the package’s directory in the project
    window. The path you’re looking for is **Assets** | **Simple Vehicle Pack** |
    **Prefabs**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入成功后，前往项目窗口中包的目录。你正在寻找的路径是**Assets** | **Simple Vehicle Pack** | **Prefabs**。
- en: Unleash the taxi into the scene at coordinates (`-6`,`0`,`0`) and adjust its
    scale to (`2`,`2`,`2`).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出租车放置在坐标(`-6`,`0`,`0`)处，并调整其缩放到(`2`,`2`,`2`)。
- en: 'Occasionally, you might encounter a peculiar magenta hue on the object. This
    typically implies that the associated materials are missing or incompatible with
    the current rendering pipeline. To rectify this issue, go through the following
    steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会在物体上遇到一种奇特的洋红色调。这通常意味着相关的材料缺失或不兼容当前的渲染管线。为了解决这个问题，请按照以下步骤操作：
- en: '*URP Installation*: Before proceeding, ensure you have the URP installed, as
    it’s not included by default in the VR Template project. If it’s not installed,
    go to **Window** | **Package Manager**. Then, search for the URP and install it.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*URP安装*：在继续之前，请确保你已经安装了URP，因为它默认不包括在VR模板项目中。如果没有安装，请转到**窗口** | **包管理器**。然后，搜索URP并安装它。'
- en: Head to `Assets` | `Simple Vehicle Pack` | `Materials` | `Cars_1`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Assets` | `Simple Vehicle Pack` | `Materials` | `Cars_1`。
- en: With the `Cars_1` material selected, alter the **Shader** drop-down menu in
    the **Inspector** window to **URP |** **Lit**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`Cars_1`材质后，在**检查器**窗口的**着色器**下拉菜单中选择**URP |** **Lit**。
- en: Then, click on the small torus symbol next to `cars_albedo` to the `cars_metallic`
    to the **Metallic Map**, and **cars_AO** to the **Occlusion Map**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击`cars_albedo`旁边的较小圆环符号到`cars_metallic`，再到**金属贴图**，以及将`cars_AO`到**遮挡贴图**。
- en: This should restore the car’s normal appearance.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该恢复汽车的正常外观。
- en: Repeat this process for `Bus_1`, `Bus_2`, and `Cars_2` materials, ensuring the
    corresponding `bus_albedo`, `bus_albedo_2`, `bus_metallic`, `bus _AO`, and `cars_albedo_2`
    textures are assigned to the relevant maps.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Bus_1`、`Bus_2`和`Cars_2`材料，重复此过程，确保相应的`bus_albedo`、`bus_albedo_2`、`bus_metallic`、`bus_AO`和`cars_albedo_2`纹理分配到相关贴图。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may have noticed that making manual adjustments can be quite time-consuming.
    Fortunately, Unity offers a more streamlined solution for such scenarios. The
    **Render Pipeline Converter** is designed to handle bulk conversions of assets
    and shaders to the URP format. Here’s how to use it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，手动调整可能相当耗时。幸运的是，Unity为这种场景提供了一个更简化的解决方案。**渲染管线转换器**旨在处理大量资产和着色器的批量转换为URP格式。以下是使用方法：
- en: 1\. Go to **Window** | **Rendering** | **Render** **Pipeline Converter**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 前往**窗口** | **渲染** | **渲染管线转换器**。
- en: 2\. In the opened window, select the materials or shaders you want to convert.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在打开的窗口中，选择您想要转换的材质或着色器。
- en: 3\. Click **Convert**. The tool will then attempt to automatically adjust your
    selected materials or shaders for compatibility with URP.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 点击**转换**。工具将尝试自动调整您选择的材质或着色器以与URP兼容。
- en: Do keep in mind that while this is convenient for bulk operations, you might
    still need to verify each material to ensure it is converted correctly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然这对于批量操作来说很方便，但您可能仍然需要验证每个材质，以确保其正确转换。
- en: With this task completed, revisit the `Assets` | `Simple Vehicle Pack` | `Prefabs`
    and let your creativity run wild by placing all the vehicles from the asset into
    our scene. Please note that in addition to the Taxi, we’re particularly interested
    in the `Police_car`, positioned at (`6`,`0`,`0`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务后，请回到`Assets` | `Simple Vehicle Pack` | `Prefabs`，并发挥您的创造力，将所有车辆资产放入我们的场景中。请注意，除了出租车外，我们特别感兴趣的是位于(`6`,`0`,`0`)的`Police_car`。
- en: Now that our cars have arrived at the scene, we’re ready to add the player and
    button prefabs in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将汽车运送到场景中，我们准备在下一节添加玩家和按钮预制体。
- en: Adding the player, teleport anchors, and button to the scene
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将玩家、传送锚点和按钮添加到场景中
- en: Before we begin implementing our game logic into the VR experience, we must
    first add some additional GameObjects and prefabs to our scenes that are just
    as important for its functionality as the cars themselves. Let’s start with adding
    the player.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将游戏逻辑实现到VR体验之前，我们必须首先向场景中添加一些额外的GameObject和预制体，它们的功能与汽车本身一样重要。让我们从添加玩家开始。
- en: Adding the player
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加玩家
- en: 'Let’s imagine our scene as a stage and ourselves as the directors. In our toolbox,
    we’ve got this lovely XR Interaction setup prefab, a sort of puppet we can animate
    around our virtual stage. We highly recommend using the XR Interaction Toolkit
    version *2.5.1* by following the *Installing the XR Interaction Toolkit and Samples*
    section in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009). While the toolkit
    is consistently updated, newer versions might come with different prefabs. Let’s
    add and configure this prefab using the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们的场景就像一个舞台，而我们自己是导演。在我们的工具箱中，我们有这个可爱的XR交互设置预制体，这是一种我们可以在虚拟舞台上进行动画的木偶。我们强烈建议您按照[*第3章*](B20869_03.xhtml#_idTextAnchor009)中的[*安装XR交互工具包和示例*]部分，使用建议的XR交互工具包版本*2.5.1*。虽然工具包会持续更新，但新版本可能包含不同的预制体。让我们按照以下步骤添加和配置此预制体：
- en: The XR Interaction setup prefab is easy to find; it’s nestled in the `Assets`
    | `Samples` | `XR Interaction Toolkit` folder. Search for the version you have,
    maybe it’s *2.5.1*, as recommended, or something newer. Then, dig through **Starter
    Assets** till you find **Prefabs**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XR交互设置预制体很容易找到；它位于`Assets` | `Samples` | `XR Interaction Toolkit`文件夹中。搜索您拥有的版本，可能是建议的*2.5.1*，或者可能是更新的版本。然后，在**起始资产**中查找**预制体**。
- en: Get the `Prefabs` folder and drag it right on the scene. Adjust it as needed
    to sit right at the center, at coordinates (`0`,`0`,`0`).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`Prefabs`文件夹，并将其直接拖放到场景中。根据需要调整，使其正好位于中心，坐标为(`0`,`0`,`0`)。
- en: Successfully, we’ve integrated a player into our scene. Now, let’s enhance the
    experience by setting up teleport anchors at various points of interest within
    our environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 成功地将玩家集成到我们的场景中。现在，让我们通过在环境中的各个兴趣点设置传送锚点来增强体验。
- en: Setting up two teleport anchors
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置两个传送锚点
- en: 'For those new to VR, a great way to prevent motion sickness is to restrict
    movement to teleportation. The XR Interaction Toolkit provides us with three teleportation
    prefab options: **Teleport Anchor**, **Snapping Teleport Anchor**, and **Teleportation
    Area**. Think of **Snapping Teleport Anchor** as a specific point on our stage
    where the teleportation ray snaps to. In contrast, with **Teleport Anchor**, the
    teleportation ray will glide without snapping. However, both anchors essentially
    serve the same purpose: they’re designated spots where users can teleport. On
    the other hand, **Teleportation** **Areas** are expansive zones allowing user
    teleportation within their boundaries.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始接触VR的用户来说，防止运动病的一个好方法是将移动限制在传送。XR交互工具包为我们提供了三个传送预制体选项：**传送锚点**、**吸附传送锚点**和**传送区域**。将**吸附传送锚点**想象成我们舞台上的一个特定点，传送射线会吸附到这个点上。相比之下，使用**传送锚点**时，传送射线会滑动而不会吸附。然而，这两个锚点本质上都服务于相同的目的：它们是用户可以传送的指定地点。另一方面，**传送区域**是广阔的区域，允许用户在其边界内进行传送。
- en: 'For this particular scene, we will be using two snapping teleport anchors to
    ensure users teleport only to specific locations. Here’s how we can set them up:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的场景，我们将使用两个吸附传送锚点来确保用户只能传送到特定位置。以下是设置它们的方法：
- en: In our project window, navigate to `Assets` | `Samples` | `XR Interaction Toolkit`
    | `2.5.1` | `Starter Assets` | `DemoSceneAssets` | `Prefabs` | `Teleport`. Within
    this location, you’ll come across the just-described **Teleport** **Anchor**,
    **Snapping Teleport Anchor**, and **Teleportation Area**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目窗口中，导航到`资产` | `示例` | `XR交互工具包` | `2.5.1` | `起始资产` | `演示场景资产` | `预制体` |
    `传送`。在这个位置，你会遇到刚才描述的**传送** **锚点**、**吸附传送锚点**和**传送区域**。
- en: Drag the snapping teleport anchor from the `Teleport` folder and drop it into
    the `Taxi Teleport Anchor`. Position it at coordinates (`-2`, `0`, `0`) and scale
    it to (`2`, `1`, `2`).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将吸附传送锚点从“传送”文件夹中拖出，并将其放入“Taxi 传送锚点”。将其放置在坐标(`-2`, `0`, `0`)，并调整其大小为(`2`, `1`,
    `2`)。
- en: 'Drag and drop another snapping teleport anchor into the `Police_car Teleport
    Anchor`. Position it at (`2`, `0`, `0`) and scale it to the same size as the previous
    anchor: (`2`, `1`, `2`).'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个吸附传送锚点拖放到“Police_car 传送锚点”中。将其放置在(`2`, `0`, `0`)，并调整其大小与之前的锚点相同：(`2`, `1`,
    `2`)。
- en: Once set up, your scene should resemble what’s illustrated in *Figure 5**.1*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，你的场景应该看起来像图5.1.*所展示的那样。
- en: "![Figure 5.1 – \uFEFFThe taxi and the police car with their teleport anchors](img/B20869_05_01.jpg)"
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 出租车和警车及其传送锚点](img/B20869_05_01.jpg)'
- en: Figure 5.1 – The taxi and the police car with their teleport anchors
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 出租车和警车及其传送锚点
- en: Next, we’ll enhance the `Taxi Teleport Anchor` by adding a push button directly
    onto it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在`Taxi 传送锚点`上直接添加一个按钮来增强`Taxi 传送锚点`。
- en: Adding a push button for the taxi animation
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加出租车动画的按钮
- en: 'To make our push button for the taxi animation stand out and be easily accessible,
    we’re going to place it on a pedestal created using a cylinder. This cylinder
    will serve as the button’s dedicated stand:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使出租车动画的按钮突出并易于访问，我们将将其放置在一个使用圆柱体创建的底座上。这个圆柱体将作为按钮的专用支架：
- en: To create this pedestal, right-click in the `Taxi Button Stand`. Adjust its
    size to dimensions (`0.2`, `0.5`, `0.2`) and position it at (`-2.7`, `0.55`, `0`).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建这个底座，在“出租车按钮支架”上右键点击。调整其大小为尺寸(`0.2`, `0.5`, `0.2`)，并将其放置在(`-2.7`, `0.55`,
    `0`)的位置。
- en: To find the `Assets` | `Samples` | `XR Interaction Toolkit` | `2.5.1` | `Starter
    Assets` | `DemoSceneAssets` | `Prefabs` | `Interactables`. Once you've found it,
    drag and drop it onto the `Taxi Button Stand` in the `5`, `5`, `5`) and adjust
    its y-coordinate to `1.075` so it sits correctly on the pedestal.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到`资产` | `示例` | `XR交互工具包` | `2.5.1` | `起始资产` | `演示场景资产` | `预制体` | `交互式对象`。一旦找到，将其拖放到`5`,
    `5`, `5`)的“出租车按钮支架”上，并调整其y坐标到`1.075`，使其正确地放置在底座上。
- en: Refer to *Figure 5**.2* to ensure that your scene looks as expected with the
    newly added push button. In the subsequent section, we’ll focus on setting up
    text buttons for the police car animations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图5.1.2*，确保新添加的按钮使场景看起来符合预期。在下一节中，我们将专注于设置用于警车动画的文本按钮。
- en: "![Figure 5.2 – \uFEFFThe taxi button stand we just added to the scene](img/B20869_05_02.jpg)"
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 我们刚刚添加到场景中的出租车按钮支架](img/B20869_05_02.jpg)'
- en: Figure 5.2 – The taxi button stand we just added to the scene
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 我们刚刚添加到场景中的出租车按钮支架
- en: Adding text buttons for police car animations
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为警车动画添加文本按钮
- en: For our police car, we’ll create a canvas that holds two buttons, enabling users
    to either shrink or enlarge the police car.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的警车，我们将创建一个包含两个按钮的画布，使用户能够缩小或放大警车。
- en: Setting up the canvas
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置画布
- en: 'Begin by creating a canvas: right-click in the hierarchy and select **XR**
    | **UI** **Canvas**.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个画布：在层次结构中右键单击并选择**XR** | **UI Canvas**。
- en: Adjust its size dimensions. The correct size for our purpose is (`0.001`, `0.001`,
    `0`), making it a square. This scaling is essential for optimal viewing in the
    VR environment.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整其尺寸。我们用于此目的的正确尺寸是（`0.001`, `0.001`, `0`），使其成为一个正方形。这种缩放对于在VR环境中的最佳观看至关重要。
- en: Position the canvas at coordinates (`3`,`1`,`-1`) and rotate it (`0`, `90`,
    `0`) towards the player’s direction.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布定位在坐标（`3`,`1`,`-1`）并绕玩家方向旋转（`0`, `90`, `0`）。
- en: If you’re facing difficulties altering the UI Canvas properties, head to the
    Inspector window of the canvas component. Here, change the **Render Mode** from
    **Screen Space – Overlay** to **World Space**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你遇到困难，无法更改UI Canvas属性，请转到画布组件的检查器窗口。在这里，将**Render Mode**从**Screen Space –
    Overlay**更改为**World Space**。
- en: Adjusting the Canvas components
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整画布组件
- en: With the canvas selected in the **Scene Hierarchy**, open the **Inspector**
    window. Click on **Add Component** to attach new components to the canvas.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景层次结构**中选择画布，打开**检查器**窗口。单击**添加组件**以将新组件附加到画布上。
- en: First, add a `5`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加一个`5`。
- en: Choose **Middle Center** for **Child Alignment**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Child Alignment**选择为**Middle Center**。
- en: Check **Child Force Expand** for both width and height.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于宽度和高度都检查**Child Force Expand**。
- en: For visual appeal, add an **Image** component to the canvas. In the **Image**
    component’s settings, set the source image to **UISprite** and choose a background
    color that complements your scene.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了视觉效果，向画布添加一个**Image**组件。在**Image**组件的设置中，将源图像设置为**UISprite**，并选择一个与场景相协调的背景颜色。
- en: Adding the buttons
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加按钮
- en: Navigate to `Assets` | `Samples` | `XR Interaction Toolkit``2.5.1` | `Starter
    Assets` | `Prefabs` | `DemoSceneAssets` | `Prefabs` | `UI`. Here, you should find
    the **TextButton** prefab.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Assets` | `Samples` | `XR Interaction Toolkit` `2.5.1` | `Starter Assets`
    | `Prefabs` | `DemoSceneAssets` | `Prefabs` | `UI`。在这里，你应该找到**TextButton**预制体。
- en: Drag and drop this prefab onto the **Canvas** twice. This will automatically
    place two **TextButton** prefabs as child objects beneath the **Canvas**. Due
    to the **Vertical Layout Group**, they’ll be aligned neatly.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此预制体拖放到**画布**上两次。这将自动在**画布**下方放置两个**TextButton**预制体作为子对象。由于**Vertical Layout
    Group**，它们将整齐对齐。
- en: Scale them to (`0.4`, `0.4`, `0`) and rename the first button as `Scale Big
    Button` and the second one as `Scale` `Small Button`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们缩放到（`0.4`, `0.4`, `0`），并将第一个按钮重命名为`Scale Big Button`，第二个按钮重命名为`Scale Small
    Button`。
- en: Labeling the buttons
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标记按钮
- en: Modify the child text object of each button by unfolding them twice. With the
    `Text` GameObject selected, head to the Inspector window and search for the text
    component. Label one button as `Scale Big` and the other as `Scale Small`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过展开两次修改每个按钮的子文本对象。选择`Text` GameObject后，转到检查器窗口并搜索文本组件。将一个按钮标记为`Scale Big`，另一个标记为`Scale
    Small`。
- en: By following these steps, you’ll have a neatly organized UI ready for your police
    car animations, as shown in *Figure 5**.3*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，你将有一个整齐组织的UI，准备好你的警车动画，如图*图5.3*所示。
- en: "![Figure 5.3 – \uFEFFThe text buttons for the police car animations](img/B20869_05_03.jpg)"
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 警车动画的文本按钮](img/B20869_05_03.jpg)'
- en: Figure 5.3 – The text buttons for the police car animations
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 警车动画的文本按钮
- en: Now our stage is set, it’s ready for the show and should look like *Figure 5**.4*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经布置好舞台，准备表演，应该看起来像*图5.4*。
- en: "![Figure 5.4 – \uFEFFThe current status of the CarExhibition scene](img/B20869_05_04.jpg)"
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – CarExhibition场景的当前状态](img/B20869_05_04.jpg)'
- en: Figure 5.4 – The current status of the CarExhibition scene
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – CarExhibition场景的当前状态
- en: Up next, we’re going to learn about the puppet strings, or in other words, the
    button events we can manipulate in Unity.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解提线木偶，或者说，在Unity中我们可以操作的按钮事件。
- en: Interactable events that can be triggered
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可交互事件
- en: 'Interactable events, particularly those found in the **XR Simple Interactable**
    component, play a pivotal role in enhancing user experience. Such events, often
    tied to push buttons, facilitate diverse interactions within VR environments.
    There are many different options for interactable events. Imagine you are in a
    virtual reality car exhibition where you can interact with push buttons next to
    each car. Here’s how these events might apply in this scenario:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可交互事件，尤其是在**XR Simple Interactable**组件中找到的事件，在增强用户体验方面发挥着关键作用。这些事件通常与推按钮相关联，在VR环境中促进多样化的交互。有众多不同的可交互事件选项。想象你在一个虚拟现实汽车展览中，你可以与每辆车旁边的推按钮进行交互。以下是如何将这些事件应用于此场景的示例：
- en: '**First Hover Entered**: You approach a car and point at its information button
    for the first time. This event triggers a subtle glow around the button indicating
    it is selected.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**First Hover Entered**: 你第一次接近一辆车并指向其信息按钮。此事件触发按钮周围微妙的发光，表明它已被选中。'
- en: '**Hover Entered**: Each time you point at the button, the event renews the
    glow, showing that the button is currently the focus of your attention.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hover Entered**: 每次你指向按钮时，事件会更新光泽，显示按钮目前是您注意力的焦点。'
- en: '**Hover Exited**: As soon as your hand or pointer moves away from the button,
    the glow dissipates, indicating that the button is no longer selected.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hover Exited**: 当你的手或指针从按钮移开时，光泽消散，表明按钮不再被选中。'
- en: '**Last Hover Exited**: The final time you move away from the button, the glow
    dissipates, and it seems as though the button subtly moves back to its original
    position, indicating that it’s no longer in focus.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Last Hover Exited**: 最后一次你从按钮移开时，光泽消散，按钮似乎微妙地回到了原始位置，表明它不再在焦点上。'
- en: '**First Select Entered**: The first time you press the information button,
    this event is triggered. It might cause the car’s information panel to appear
    with a smooth animation.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**First Select Entered**: 第一次你按下信息按钮时，此事件被触发。它可能会使汽车的信息面板以平滑的动画出现。'
- en: '**Select Entered**: Each time you press the button, the car’s information panel
    appears, whether it’s the first press or not.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Select Entered**: 每次你按下按钮，无论是否是第一次按下，汽车的信息面板都会出现。'
- en: '**Select Exited**: When you release the button, the panel begins to fade, indicating
    the end of the interaction.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Select Exited**: 当你释放按钮时，面板开始淡出，表明交互结束。'
- en: '**Last Select Exited**: The final time you release the button, it seems as
    though the panel not only fades but also shrinks back into the button, signifying
    the interaction’s conclusion.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Last Select Exited**: 最后一次你释放按钮时，面板不仅淡出，还似乎缩回到按钮中，标志着交互的结束。'
- en: '**Activated**: This event could be tied to a button in the car that starts
    the engine. Upon pressing, you hear the car’s engine roar to life.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Activated**: 此事件可能与汽车上的一个按钮相关联，该按钮可以启动引擎。按下后，你会听到汽车引擎轰鸣着启动。'
- en: '**Deactivated**: When you press the button to turn off the car’s engine, this
    event is triggered. You hear the engine wind down to a stop.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deactivated**: 当你按下按钮关闭汽车的引擎时，此事件被触发。你会听到引擎逐渐减速至停止。'
- en: This sequence of events provides a natural, intuitive interaction flow for the
    user, enhancing the immersive feel of the VR car exhibition.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列事件为用户提供了一种自然直观的交互流程，增强了VR汽车展览的沉浸感。
- en: In the next section, we’ll delve into how to choreograph these interactions
    and bring animations to life without writing a single line of code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨如何编排这些交互并使动画生动起来，而无需编写任何代码。
- en: Understanding animations and animator systems
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解动画和动画师系统
- en: Unity’s **animation system** functions like a mechanism for manipulating GameObjects
    by controlling their movement, rotation, size, color, and so on. It works by defining
    keyframes, which are specific states at certain times, and constructing an animation
    clip from these keyframes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**动画系统**通过控制GameObject的运动、旋转、大小、颜色等来操纵GameObject，就像一个机制。它通过定义关键帧（特定时间点的特定状态）来工作，并从这些关键帧中构建动画剪辑。
- en: Consider the example of a virtual door. An animation clip can illustrate the
    door’s movement from closed to open, and another clip can depict the door returning
    to its closed position.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑虚拟门的例子。一个动画剪辑可以展示门从关闭到打开的运动，另一个剪辑可以描绘门返回到关闭位置。
- en: To ensure smooth transitions between these clips, Unity’s **Animator Controller**
    is used. This is a control system that directs the timing and sequence of the
    animation clips, transitioning between them based on specific conditions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这些剪辑之间的平滑过渡，使用Unity的**动画控制器**。这是一个控制系统，它指导动画剪辑的时间安排和顺序，根据特定条件在它们之间进行切换。
- en: For the door example, the Animator Controller would manage the clips for opening
    and closing the door and transitioning between them at the right moment, possibly
    based on user input.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于门示例，动画控制器将管理开门、关门以及在这些状态之间切换的剪辑，可能基于用户输入在正确的时间进行。
- en: 'Here are other examples that can be crafted using Unity’s animation system:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用Unity的动画系统可以制作的其它示例：
- en: '**Object movement**: For an object moving across the screen, the animation
    system can create the movement, but additional scripting may be required to control
    it based on user interaction'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象移动**：对于在屏幕上移动的对象，动画系统可以创建移动，但可能需要额外的脚本根据用户交互来控制它。'
- en: '**Object rotation**: A constantly spinning gear can be animated, but player-based
    control of the spin requires code'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象旋转**：可以动画化一个持续旋转的齿轮，但玩家控制的旋转则需要代码。'
- en: '**Object scaling**: Scaling animation can depict an object’s growth, but linking
    this to other factors, such as energy level, requires scripting'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象缩放**：缩放动画可以描绘对象的生长，但将其与其他因素（如能量水平）关联起来则需要编写脚本。'
- en: '**Color change**: An animation can be made for a changing light color, but
    synchronizing it with game conditions requires coding'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色变化**：可以为变化的光颜色制作动画，但与游戏条件同步则需要编码。'
- en: '**Camera movement**: Camera movement between characters can be created using
    keyframes, but complex interactions with player movement might need additional
    code'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摄像机移动**：可以使用关键帧在角色之间创建摄像机移动，但与玩家移动的复杂交互可能需要额外的代码。'
- en: '**Blend shapes**: Facial expressions can be controlled using blend shapes,
    but they may need to be scripted to correspond to specific game dialogues'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合形状**：可以使用混合形状来控制面部表情，但可能需要编写脚本来使其与特定的游戏对话相匹配。'
- en: '**UI animations**: A graphical UI element, such as a flashing button, can be
    animated, but stopping the animation when certain conditions are met (e.g., a
    race begins) requires a script'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI动画**：可以动画化图形UI元素，如闪烁的按钮，但当满足某些条件（例如，比赛开始）时停止动画则需要脚本。'
- en: As seen in these examples, the animation system in Unity provides a powerful
    tool for bringing objects and scenes to life. However, adding scripts or coding
    to these animations unlocks a higher level of refinement and interactivity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如这些示例所示，Unity中的动画系统为使对象和场景生动提供了强大的工具。然而，向这些动画添加脚本或编码可以解锁更高层次的精炼和交互性。
- en: In general, coding enables us to create animations in Unity that can respond
    to various inputs and game states, making them more dynamic. Coding also provides
    precise control over the animation, allowing for complex logic and customized
    interactions that cannot be achieved with Unity’s animation system alone.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编码使我们能够在Unity中创建可以响应各种输入和游戏状态的动画，使它们更加动态。编码还提供了对动画的精确控制，允许实现仅使用Unity的动画系统无法实现的复杂逻辑和定制交互。
- en: While Unity’s animation system may not have the same level of complexity and
    fine control that coding offers, it still holds a significant place as a primary
    tool for creating interactions within Unity. The visual interface and intuitive
    controls allow for a rapid and user-friendly way to animate GameObjects, even
    without delving into scripts. This makes it accessible to both novice and experienced
    developers, enabling them to add life and movement to their game scenes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity的动画系统可能没有编码提供的相同复杂性和精细控制，但它仍然在Unity内创建交互的主要工具中占据着重要的位置。直观的视觉界面和直观的控制允许快速且用户友好的方式来动画化GameObject，即使不深入脚本。这使得它既适合新手也适合经验丰富的开发者，使他们能够为游戏场景添加生命和动作。
- en: In the next section of this chapter, we will only be using the animation system,
    demonstrating how powerful and useful it can be on its own. Through hands-on examples,
    you’ll see how it’s possible to achieve engaging and interactive animations without
    relying on coding and how this tool can become a vital part of your XR development
    toolkit.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们只将使用动画系统，展示它单独使用时的强大和实用性。通过实际示例，您将看到如何在不依赖编码的情况下实现引人入胜和交互式的动画，以及这个工具如何成为您XR开发工具包的重要组成部分。
- en: Animating a 360-degree car rotation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画360度汽车旋转。
- en: 'Let’s dive into the world of animation. Think of a spinning top: it goes round
    and round, and we want our taxi to do the same when we push a button. The twist
    is that when we let go of the button, the taxi should stop spinning. Sound fun?
    Here’s how we’ll make it happen using the magic of Unity’s animation system and
    UnityEvents without writing a line of code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入动画的世界。想象一个旋转的陀螺：它一圈又一圈地旋转，当我们按下按钮时，我们希望我们的出租车也能这样做。转折在于，当我们松开按钮时，出租车应该停止旋转。听起来很有趣吗？我们将如何利用Unity动画系统和UnityEvents的魔力来实现这一点，而无需编写一行代码。
- en: 'First things first, we need to choreograph this spin for our taxi. Imagine
    it as a pirouette, a 360-degree turn on the taxi’s y-axis. Go through the following
    steps to bring this dance to life:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的出租车编排这个旋转。想象它就像一个旋转，在出租车y轴上的360度旋转。按照以下步骤将这个舞蹈变成现实：
- en: Right-click in the `Assets` folder and select **Create** | **Folder**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets`文件夹中右键单击并选择**Create** | **Folder**。
- en: Select the taxi object in your scene and go to `RotateCar`, and save it in our
    newly minted `Animations` folder.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的场景中选择出租车对象，转到`RotateCar`，并将其保存在我们新创建的`Animations`文件夹中。
- en: Define a 360-degree rotation for the y-axis by selecting **Transform** | **Rotation**
    and modifying your keyframes as shown in *Figure 5**.5*.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**Transform** | **Rotation**并修改你的关键帧，为y轴定义360度旋转，如*图5.5*所示。
- en: "![Figure 5.5 – \uFEFFThe modified Keyframes to define a 360-degree rotation\
    \ for the y-axis](img/B20869_05_05.jpg)"
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 定义y轴360度旋转的修改后的关键帧](img/B20869_05_05.jpg)'
- en: Figure 5.5 – The modified Keyframes to define a 360-degree rotation for the
    y-axis
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 定义y轴360度旋转的修改后的关键帧
- en: Set the initial keyframes at `0:00` with `0` as the rotation; this is our taxi’s
    starting pose. Then, leap to `0:10` and give the `355`-degree spin. Why not 360?
    That would be like turning on a dime, too abrupt for our gentle spin.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0:00`处设置初始关键帧，旋转为`0`；这是我们的出租车起始姿势。然后，跳到`0:10`并给予`355`度的旋转。为什么不旋转360度？那就像转动一枚硬币，对我们温柔的旋转来说太突然了。
- en: Click on the `RotateCar` animation clip in the project window to view its settings
    in the Inspector. In the Inspector, give the **Loop Time** box a check to tell
    our taxi to keep repeating its spin.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中单击`RotateCar`动画剪辑以在检查器中查看其设置。在检查器中，勾选**Loop Time**框，让我们的出租车持续重复其旋转。
- en: Attach an `RotateCar` animation clip into the **Controller** field of the **Animator**
    component.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RotateCar`动画剪辑附加到**Animator**组件的**Controller**字段。
- en: 'This will start our Taxi’s twirl right when we step into our virtual world.
    But remember, we want the spin to start only when we push the button. It’s time
    to make that happen:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的出租车旋转在我们进入虚拟世界时立即开始。但记住，我们希望旋转只在按下按钮时开始。是时候让它发生：
- en: First, we need to open the Animator Controller. Select the **Animator Controller**
    for our Taxi and double-click it to open the Animator Controller window.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要打开Animator Controller。选择我们的出租车**Animator Controller**，双击以打开Animator Controller窗口。
- en: Like a blank canvas, right-click in the `Idle`; it’s the calm before the Taxi’s
    spinning storm.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像一张空白画布，在`Idle`上右键单击；这是出租车旋转风暴前的平静。
- en: Next, right-click on the `Idle` state and set it as the **Layer Default State**.
    This tells the Animator Controller to start in this state, doing nothing when
    the scene begins.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Idle`状态上右键单击，将其设置为**Layer Default State**。这告诉Animator Controller从该状态开始，当场景开始时什么都不做。
- en: 'We then make a bridge from the `Idle` state to the `RotateCar` state: the state
    that initiates our taxi’s spin. To do this, right-click on `Idle`, choose `RotateCar`.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从`Idle`状态到`RotateCar`状态建立一座桥梁：这个状态启动我们的出租车旋转。为此，在`Idle`上右键单击，选择`RotateCar`。
- en: Now let’s navigate to the `Rotate`. This parameter will initiate the transition
    from the `Idle` state to the `RotateCar` state.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们导航到`Rotate`。这个参数将启动从`Idle`状态到`RotateCar`状态的过渡。
- en: Click on the arrow representing the transition from `Idle` to `RotateCar`. In
    the `Rotate` parameter that we just created, as shown in *Figure 5**.6*.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击表示从`Idle`到`RotateCar`过渡的箭头。在刚刚创建的`Rotate`参数中，如*图5.6*所示。
- en: "![Figure 5.6 – \uFEFFThe Inspector window showing the newly added condition:\
    \ the Rotate trigger](img/B20869_05_06.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 显示新添加条件的检查器窗口：旋转触发器](img/B20869_05_06.jpg)'
- en: 'Figure 5.6 – The Inspector window showing the newly added condition: the Rotate
    trigger'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 显示新添加条件的检查器窗口：旋转触发器
- en: Next, we need to halt our taxi’s spin once the button is released. Right-click
    on the `RotateCar` state, choose `Idle` state.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在按钮释放时停止出租车的旋转。在`RotateCar`状态上右键单击，选择`Idle`状态。
- en: Go back to the `StopRotation`. This will initiate the transition from the `RotateCar`
    state back to `Idle`. Your parameters should now match what’s shown in *Figure
    5**.7*.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`StopRotation`。这将启动从`RotateCar`状态回到`Idle`状态的过渡。现在，你的参数应该与*图 5.7*中显示的相匹配。
- en: "![Figure 5.7 – \uFEFFThe Parameters tab of the Animator window showing both\
    \ newly added parameters](img/B20869_05_07.jpg)"
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 动画器窗口的参数选项卡，显示了新添加的参数](img/B20869_05_07.jpg)'
- en: Figure 5.7 – The Parameters tab of the Animator window showing both newly added
    parameters
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 动画器窗口的参数选项卡，显示了新添加的参数
- en: Click on the transition arrow that goes from the `RotateCar` to the `Idle` state
    this time. Under `StopRotation` parameter as we did with the `Rotate` parameter
    earlier. Your **Animator** window should now resemble *Figure 5**.8*.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击从`RotateCar`到`Idle`状态的转换箭头。在`StopRotation`参数下，就像我们之前对`Rotate`参数所做的那样。现在，你的**Animator**窗口应该类似于*图
    5.8*。
- en: "![Figure 5.8 – \uFEFFThe Animator window showing the current states and their\
    \ transitions](img/B20869_05_08.jpg)"
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 动画器窗口显示当前状态及其转换](img/B20869_05_08.jpg)'
- en: Figure 5.8 – The Animator window showing the current states and their transitions
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 显示当前状态及其转换的动画器窗口
- en: Select the `Animator.SetTrigger()`. Think of it as the cue for our Taxi to start
    or stop its dance. When the button is pressed (`Rotate`, and when the button is
    released (`StopRotation`. If set up correctly, your events will mirror those in
    *Figure 5**.9*.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Animator.SetTrigger()`。将其视为我们的出租车开始或停止舞蹈的提示。当按钮被按下时（`Rotate`），当按钮被释放时（`StopRotation`）。如果设置正确，你的事件将反映在*图
    5.9*中。
- en: "![Figure 5.9 – \uFEFFThe Select Entered and Select Excited events](img/B20869_05_09.jpg)"
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 选择进入和选择兴奋事件](img/B20869_05_09.jpg)'
- en: Figure 5.9 – The Select Entered and Select Excited events
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 选择进入和选择兴奋事件
- en: 'Well done! Your taxi is now set to dance to your button’s beats, spinning a
    full circle each time you press it. Don’t forget to try it out: give that button
    a good press and watch the taxi perform its 360-degree spin.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你的出租车现在可以随着按钮的节奏跳舞了，每次按下按钮都会旋转一整圈。别忘了试试：用力按下按钮，看看出租车如何完成360度的旋转。
- en: In the next section, we’ll delve into the magic of 2D text buttons on a canvas,
    learning how they can change a police car’s size to make it shrink or grow at
    the press of a button.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解画布上2D文本按钮的魔法，学习它们如何通过按按钮来改变警车的大小，使其缩小或放大。
- en: Scaling a police car
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放警车
- en: 'Imagine the compelling possibilities of incorporating two additional interactive
    features in our VR auto show: one button to miniaturize the car and another to
    magnify it. Similar to our earlier interactions, we will employ a set of procedures,
    but this time with 2D buttons on a canvas. First, we create two animation clips
    that capture the essence of the car’s transformation as it scales up and down.
    Next, we create an Animator Controller: a crucial component that defines and manages
    the animation states. Lastly, we assign the corresponding trigger events to the
    button.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在我们的VR汽车展览中加入两个额外交互功能的迷人可能性：一个按钮可以缩小汽车，另一个按钮可以放大它。类似于我们之前的交互，我们将使用一系列程序，但这次是在画布上的2D按钮上。首先，我们创建两个动画剪辑，捕捉汽车缩放上下时的本质变化。接下来，我们创建一个动画控制器：这是一个关键组件，用于定义和管理动画状态。最后，我们将相应的触发事件分配给按钮。
- en: 'Let’s bring this magic to life with the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤将这个魔法变为现实：
- en: Select the police car in the hierarchy. Open the Animation window (`ScaleCar`
    and store it in the `Animations` folder.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择警车。打开动画窗口（`ScaleCar`）并将其存储在`Animations`文件夹中。
- en: Now, let’s choreograph the transformation. On the timeline in the Animation
    window, mark the beginning (`0:00`) and the end (`1:00`) with keyframes (the diamond
    icon). At the beginning, the scale of the car (`0`. At the end, the scale should
    be at its largest size; let’s go with `3`. This gives us an animation that sees
    the car scaling from minuscule to massive.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编排这个变换。在动画窗口的时间轴上，用关键帧（菱形图标）标记开始（`0:00`）和结束（`1:00`）。开始时，汽车的缩放比例（`0`）。结束时，缩放比例应该是最大尺寸；让我们使用
    `3`。这样我们就得到了一个动画，展示了汽车从微小到巨大的缩放过程。
- en: We don’t want our car continuously growing and shrinking. So, in the Inspector,
    uncheck the **Loop** **Time** box.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望我们的汽车持续地缩小和放大。所以，在检查器中取消选择**Loop** **Time**框。
- en: Our police car needs an `ScaleCar`animation clip into the **Controller** field
    of the **Animator Component**.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的警车需要一个`ScaleCar`动画剪辑放入**Animator Component**的**Controller**字段中。
- en: We’ve got the growing part down, now let’s work on the shrinking. Create a second
    animation clip named `ShrinkCar`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经掌握了增长的部分，现在让我们来处理缩小部分。创建一个名为`ShrinkCar`的第二个动画片段。
- en: Similar to *step 2*, mark the beginning and the end with keyframes. This time,
    at the beginning, the scale of the car should be at its largest size (`3`). At
    the end, the scale should be at its smallest size (`0`). We’ve now reversed the
    transformation, creating an animation that shrinks the car from massive to minuscule.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与*步骤2*类似，用关键帧标记开始和结束。这次，在开始时，汽车的缩放比例应该是其最大尺寸（`3`）。在结束时，缩放比例应该是其最小尺寸（`0`）。我们现在已经反转了变形，创建了一个从巨大到微小缩小的动画。
- en: By now, we’ve successfully created two animation clips and an Animator Controller.
    If we were to play the scene, the police car would scale up once thanks to the
    unchecked loop checkbox and the absence of the downscaling animation in our Animation
    Controller. We’re one step closer to our transforming car. Ready for the next
    part? Let’s dive in.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功创建了两个动画片段和一个动画控制器。如果我们播放场景，由于未勾选“未检查循环”复选框以及我们的动画控制器中没有缩小动画，警车会因循环而放大一次。我们离我们的变形车又近了一步。准备好下一部分了吗？让我们深入探讨。
- en: 'Now, it’s time to make our police car dance to our tune. We want it to change
    sizes when we wish and be idle when we don’t. That’s where the Animator Controller
    comes in. It’s our maestro, dictating when the car grows, shrinks, or takes a
    breather. Here’s how we bring this to life:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们让我们的警车按照我们的曲调跳舞的时候了。我们希望它在需要时改变大小，在我们不需要时处于空闲状态。这就是动画控制器发挥作用的地方。它是我们的指挥家，决定汽车何时增长、缩小或休息。以下是我们将它实现的方法：
- en: First, we need to open the Animator Controller. Locate the one assigned to the
    police car in the project window and double-click to open it.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要打开动画控制器。在项目窗口中找到分配给警车的动画控制器，并双击打开它。
- en: Remember our shrinking dance? Drag and drop the `ShrinkCar` animation clip into
    the **Animator Controller** window. It now has both the growing and shrinking
    routines.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得我们的缩小舞蹈吗？将`ShrinkCar`动画片段拖放到**动画控制器**窗口中。它现在既有增长也有缩小的程序。
- en: Now, we need a state of rest, a breather in between our dance routines. Right-click
    in the `Idle`. It’s like the calm before the storm.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个休息状态，在舞蹈序列之间的喘息。在`Idle`上右键单击。就像暴风雨前的平静。
- en: We don’t want our car to start dancing right away when the curtain rises. So,
    set the `Idle` state as the default state. This ensures that when the scene begins,
    our car stands still, awaiting its cue.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望汽车在帷幕升起时立即开始跳舞。因此，将`Idle`状态设置为默认状态。这确保了当场景开始时，我们的汽车静止不动，等待其提示。
- en: Our maestro is ready to conduct. Right-click on the `Idle` state and choose
    `ScaleCar` and another time to the `ShrinkCar` states. Now, we’ve set the stage
    for our car to transition from standing idle to growing big and shrinking small.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的指挥家已经准备好指挥了。在`Idle`状态上右键单击，选择`ScaleCar`，然后再次选择`ShrinkCar`状态。现在，我们已经为我们的汽车从静止不动过渡到变大和变小做好了准备。
- en: But what cues the transitions? We need to set trigger parameters for this. In
    the `ScaleBig` and `ScaleSmall`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，是什么触发了过渡？我们需要为此设置触发参数。在`ScaleBig`和`ScaleSmall`中。
- en: Select the transition arrows. Under `ScaleBig` cues the transition from `Idle`
    to `ScaleCar`, while `ScaleSmall` cues the transition from `Idle` to `ShrinkCar`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择过渡箭头。在`ScaleBig`中触发从`Idle`到`ScaleCar`的过渡，而`ScaleSmall`触发从`Idle`到`ShrinkCar`的过渡。
- en: The dance is never one-way. Our car needs to move smoothly from growing to shrinking
    and vice versa. So, create transitions from `ShrinkCar` to `ScaleCar``ScaleBig`
    trigger for the lower and the `ScaleSmall` trigger for the upper transition arrow,
    as shown in *Figure 5**.10*.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 舞蹈永远不会是单向的。我们的汽车需要从增长到缩小，反之亦然，平滑地移动。因此，从`ShrinkCar`到`ScaleCar`创建过渡，为下方的过渡箭头设置`ScaleBig`触发器，为上方的过渡箭头设置`ScaleSmall`触发器，如图*图5.10*所示。
- en: "![Figure 5.10 – \uFEFFThe Animator Controller of the police car](img/B20869_05_10.jpg)"
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 警车的动画控制器](img/B20869_05_10.jpg)'
- en: Figure 5.10 – The Animator Controller of the police car
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 警车的动画控制器
- en: Voila! Our police car is now ready to twirl to our commands. Try out the scene
    and watch as it gracefully grows and shrinks at your will by testing or deploying
    the scene onto your VR headset, as described in the *Deploying and testing VR
    experiences onto different VR platforms or simulators* section in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009).
    It’s a delightful sight, isn’t it?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们的警车现在可以按照我们的指令旋转了。尝试这个场景，并观察它如何在你意愿下优雅地放大和缩小，方法是将场景测试或部署到你的VR头盔上，如[*第3章*](B20869_03.xhtml#_idTextAnchor009)中“将VR体验部署和测试到不同的VR平台或模拟器”部分所述。这不是一件令人愉快的事情吗？
- en: Building interactive VR experiences with C#
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#构建交互式VR体验
- en: So far, we have added interactions to our scene just by using Unity’s Animation
    system without writing a single line of code. In the next sections, you will learn
    how you can use scripting with C# to add even more complex breaths of air into
    your GameObjects and scene.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是通过使用Unity的动画系统，没有写一行代码，就为我们的场景添加了交互。在接下来的章节中，你将学习如何使用C#脚本为你的GameObject和场景添加更复杂的交互。
- en: 'The first question we are going to answer is this: when do we need to write
    C# code for our animations and interactions?'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要回答的第一个问题是：我们何时需要为动画和交互编写C#代码？
- en: Understanding when to use C# for animations and interactions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解何时使用C#进行动画和交互
- en: It’s important to understand that Unity’s animation and animator systems and
    the use of C# scripting are not mutually exclusive. They are often used together,
    with the animator controlling predefined animations and C# adding interactivity
    based on user input or other game events.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Unity的动画和动画师系统以及C#脚本的使用不是相互排斥的非常重要。它们经常一起使用，其中动画师控制预定义的动画，而C#根据用户输入或其他游戏事件添加交互性。
- en: 'In the previous section, we rotated and scaled cars based using Unity’s animation
    and animator systems. These systems are primarily used to create predefined animations.
    We can divide this process into the following three steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用Unity的动画和动画师系统旋转和缩放了汽车。这些系统主要用于创建预定义的动画。我们可以将这个过程分为以下三个步骤：
- en: '**Initialization event**: First, an event must occur to start the animation.
    This can be a button press, game event, collision, or any other trigger. In our
    example, to scale and rotate the cars, we used a physical push button and a 2D
    UI button. Unity’s built-in animation and animator systems are largely designed
    around the idea of predefined animations that are triggered under specific conditions.
    These conditions are typically defined within the Animator Controller itself and
    are usually based on parameters that you set up ahead of time, such as a boolean
    to track if a character is jumping or a trigger that gets activated when a button
    is pressed. This means that, with the built-in system, we do not have the ability
    to trigger animations based on virtually any event or condition in our game and
    have to work with the available events.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化事件**：首先，必须发生一个事件来启动动画。这可以是一个按钮按下、游戏事件、碰撞或其他触发器。在我们的例子中，为了缩放和旋转汽车，我们使用了一个物理按钮和一个2D
    UI按钮。Unity内置的动画和动画师系统主要是围绕预定义的动画在特定条件下触发的理念设计的。这些条件通常在Animator Controller本身中定义，并且通常基于你事先设置的参数，例如一个布尔值来跟踪角色是否在跳跃，或者当按钮被按下时激活的触发器。这意味着，使用内置系统，我们没有能力根据游戏中的任何事件或条件触发动画，而必须与可用的事件一起工作。'
- en: '**Animation**: Using Unity’s animation system, we define what changes during
    the animation (position, rotation, scale, etc.) by creating keyframes. For instance,
    we changed the rotation and scale of the cars with keyframes.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画**：使用Unity的动画系统，我们通过创建关键帧来定义动画期间发生的变化（位置、旋转、缩放等）。例如，我们使用关键帧改变了汽车的旋转和缩放。'
- en: '`ShrinkCar` state to a `ScaleCar` state.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ShrinkCar`状态转换为`ScaleCar`状态。
- en: This system is perfect for creating animations that are predefined and occur
    under specific conditions; for instance, character animations (walking, running,
    jumping) or environmental animations (door opening, elevator moving).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统非常适合创建预定义的动画，这些动画在特定条件下发生；例如，角色动画（行走、跑步、跳跃）或环境动画（门打开、电梯移动）。
- en: 'While Unity’s built-in system excels at predefined animations, C# comes into
    play when animations need to respond dynamically to user input or other game events.
    Here, we follow similar steps as before:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity的内置系统在预定义动画方面表现出色，但当动画需要动态响应用户输入或其他游戏事件时，C#就派上用场。在这里，我们遵循与之前类似的步骤：
- en: '**Initialization event**: The event that starts an animation can be anything,
    such as button presses, user input, or changes in the game state. The biggest
    difference with Unity’s built-in system is that with C# scripts, you have much
    greater flexibility and control over the initialization events for your animations.
    For instance, you can respond to complex sequences of input, such as a fighting
    game action combo. You can base animations on game logic or game state, such as
    an enemy’s health level or the player’s current score. You can trigger animations
    based on collisions, entering/exiting certain zones, or other physics events.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化事件**：启动动画的事件可以是任何东西，例如按钮点击、用户输入或游戏状态的变化。与Unity内置系统最大的不同之处在于，使用C#脚本，你对动画的初始化事件有更大的灵活性和控制力。例如，你可以响应复杂的输入序列，如格斗游戏动作连招。你可以基于游戏逻辑或游戏状态来创建动画，例如敌人的健康水平或玩家的当前得分。你可以根据碰撞、进入/退出特定区域或其他物理事件来触发动画。'
- en: '**AI Decisions**: You can initiate animations based on the decisions made by
    an AI system. In a multiplayer game, you can trigger animations based on network
    events, such as another player’s actions.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**AI决策**：你可以根据AI系统做出的决策来启动动画。在多人游戏中，你可以根据网络事件（如其他玩家的动作）触发动画。'
- en: '**Animation**: Animations can be created in two ways:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画**：动画可以通过两种方式创建：'
- en: You can use the animation system to create keyframes as before and then use
    C# to control the playback of these animations (for example, play, pause, stop,
    or alter speed).
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用动画系统创建关键帧，就像之前一样，然后使用C#来控制这些动画的播放（例如，播放、暂停、停止或改变速度）。
- en: Alternatively, you can use C# to modify the properties of GameObjects directly,
    creating animations programmatically.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以使用C#直接修改GameObject的属性，以编程方式创建动画。
- en: '**State control**: With C#, you gain more direct control over when and how
    animations and transitions occur. You can create conditions based on any aspect
    of your game’s state, not just parameters in the Animator Controller. For example,
    you could change an NPC’s animation based on the player’s health or inventory.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**状态控制**：使用C#，你可以更直接地控制动画和过渡何时以及如何发生。你可以根据游戏状态的任何方面创建条件，而不仅仅是动画控制器中的参数。例如，你可以根据玩家的健康或库存更改NPC的动画。'
- en: 'Using C# for animations is ideal when the animation needs to respond in complex
    ways to the game state or user input. This is especially the case in the following
    scenarios:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画需要以复杂的方式对游戏状态或用户输入做出响应时，使用C#进行动画是理想的。这在以下场景中尤其如此：
- en: '**Real-time user input**: You often use C# to animate GameObjects in response
    to real-time user input. For example, in a flight simulator, you might animate
    the plane’s control surfaces (such as the ailerons, elevators, and rudder) based
    on the player’s joystick input. Since the exact position of these surfaces depends
    on the player’s input, it’s not something that can be predetermined with keyframes.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时用户输入**：你通常使用C#来根据实时用户输入动画GameObject。例如，在飞行模拟器中，你可能根据玩家的操纵杆输入来动画化飞机的控制面（如副翼、升降舵和方向舵）。由于这些表面的确切位置取决于玩家的输入，这不是可以通过关键帧预先确定的事情。'
- en: '**Physics-based animations**: If your animation needs to incorporate or respond
    to physics, it often makes sense to animate it programmatically. For example,
    in a pool game, the balls move and spin based on physics calculations rather than
    predefined paths.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于物理的动画**：如果你的动画需要包含或响应物理效果，通常通过编程方式动画化是合理的。例如，在台球游戏中，球体的移动和旋转是基于物理计算而不是预定义路径。'
- en: '**Procedurally generated content**: When the content of your game is procedurally
    generated, you often need to animate things programmatically because the exact
    nature of the animations can’t be predetermined. For instance, in a rogue-like
    dungeon crawler, the layout of the dungeon and the placement of enemies are generated
    on the fly, so any animations related to these elements would also need to be
    generated at runtime.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序生成内容**：当你的游戏内容是程序生成时，通常需要通过编程方式动画化事物，因为动画的确切性质无法预先确定。例如，在类似《暗黑破坏神》的地下城探险游戏中，地下城的布局和敌人的位置是即时生成的，因此与这些元素相关的任何动画也必须在运行时生成。'
- en: '**Complex AI behavior**: When creating complex AI behavior, you might use C#
    to animate GameObjects based on the AI’s decision-making processes. For instance,
    an enemy character might have an idle animation, a walk animation, and an attack
    animation, and you can use C# to decide which one to play based on the AI’s current
    state and the player’s position.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂AI行为**：在创建复杂AI行为时，你可能使用C#来根据AI的决策过程来动画化GameObject。例如，一个敌人角色可能有一个空闲动画、一个行走动画和一个攻击动画，你可以使用C#来决定根据AI的当前状态和玩家的位置播放哪一个。'
- en: Now that we have understood the scenarios in which it is useful to use C# for
    animations and interactions, let’s put our new knowledge to use by scaling a car
    using a slider in the following section. This would fall under the “real-time
    user input” category. When we want to scale a car using a slider, it’s the user
    input (moving the slider) that’s driving the animation (the scaling of the car).
    This kind of interaction can’t be predefined with keyframes because the exact
    scale of the car depends on the player’s input at any given moment. But before
    we add these to our scene, we first need to understand the very basics of the
    C# language, which are explained in the following section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在哪些场景下使用C#进行动画和交互是有用的，让我们在下一节通过使用滑块缩放汽车来应用我们的新知识。这属于“实时用户输入”类别。当我们想使用滑块缩放汽车时，是用户输入（移动滑块）在驱动动画（汽车的缩放）。这种交互不能通过关键帧预先定义，因为汽车的精确缩放取决于玩家在任何给定时刻的输入。但在我们将这些添加到场景之前，我们首先需要了解C#语言的基础知识，这些知识将在下一节中解释。
- en: Understanding scripting with C# in Unity
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unity中使用C#进行脚本编写理解
- en: Creating scripts for VR development in Unity involves using C#. As a high-level
    language, it simplifies many computing complexities, making it user-friendly compared
    to languages such as C++.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中进行VR开发的脚本创建涉及使用C#。作为一种高级语言，它简化了许多计算复杂性，与C++等语言相比，它更加用户友好。
- en: Through its strong, static typing, C# helps you spot programming errors before
    running a game in Unity, which is incredibly helpful for developers. Additionally,
    it’s good at managing memory use, as it minimizes the risk of **memory leaks**—a
    situation where a game eats up an increasing amount of memory, potentially causing
    crashes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其强大且静态的类型系统，C#可以帮助你在Unity中运行游戏之前发现编程错误，这对开发者来说非常有帮助。此外，它擅长管理内存使用，因为它最小化了**内存泄漏**的风险——一种游戏消耗越来越多的内存，可能引起崩溃的情况。
- en: C# is supported by Microsoft, which ensures you get reliable help, plenty of
    tools to work with, and access to a big community of other developers. And, importantly,
    just like Unity, C# works across many platforms.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: C#由微软支持，这确保了你能够获得可靠的帮助、大量的工具以及访问一个庞大的开发者社区。而且，重要的是，就像Unity一样，C#支持多个平台。
- en: When using C# in Unity, your coding is mostly event-based. This means you override
    certain Unity functions that get triggered at specific times, such as the `Start()`
    or `Update()` functions of a game.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Unity中使用C#时，你的编码主要是基于事件的。这意味着你覆盖了某些在特定时间被触发的Unity函数，例如游戏的`Start()`或`Update()`函数。
- en: 'Now, when it comes to using C# for VR development in Unity, there are three
    key object-oriented programming concepts you’ll need to understand: variables,
    functions, and classes. Let’s get to know these a bit better.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当谈到在Unity中使用C#进行VR开发时，有三个关键的对象导向编程概念你需要理解：变量、函数和类。让我们更深入地了解这些概念。
- en: Variables
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: '**Variables** are like storage boxes that your script uses to hold data. Every
    variable has a type, which tells you what kind of data it can hold. For example,
    if you’re using the XR Interaction Toolkit, you might have variables to store
    things such as the position of a VR controller, the state of an object in the
    virtual world, and so on. Let''s see an example of how we can use variables in
    the context of a C# script for Unity with the following code snippet:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**就像是你的脚本用来存储数据的存储盒。每个变量都有一个类型，它告诉你它可以存储什么类型的数据。例如，如果你正在使用XR交互工具包，你可能会有变量来存储诸如VR控制器位置、虚拟世界中的对象状态等数据。让我们看看以下代码片段中我们如何使用变量在Unity的C#脚本中的例子：'
- en: '[PRE0]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `grabInteractable` is an `XRGrabInteractable` object
    that represents a VR object that can be interacted with. `isGrabbed` is a private
    Boolean variable tracking whether the object is currently grabbed or not.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`grabInteractable`是一个`XRGrabInteractable`对象，它代表了一个可以与之交互的VR对象。`isGrabbed`是一个私有的布尔变量，用于跟踪对象是否当前被抓住。
- en: Functions
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: Think of **functions** (or methods) in C# as cooking recipes. Just like a recipe
    provides step-by-step instructions to cook a specific dish, a function in C# consists
    of a set of instructions that performs a specific task. You can reuse these recipes
    multiple times, either within the same script or across different scripts.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将C#中的**函数**（或方法）想象成烹饪食谱。就像食谱提供一步步的指导来烹饪一道特定的菜肴一样，C#中的函数由一组执行特定任务的指令组成。你可以多次重用这些食谱，无论是在同一脚本中还是在不同的脚本中。
- en: 'In Unity, there are some special functions, such as unique cooking recipes,
    that are triggered at specific times during the life cycle of a script. Here is
    an overview of them:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，有一些特殊函数，如独特的烹饪食谱，在脚本的生命周期中的特定时间被触发。以下是它们的概述：
- en: '`Awake()`: This is like an alarm clock for your script. This function rings
    when the script first wakes up (or loads). Often, it’s used to set up variables
    or the state of the game.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Awake()`: 这就像是你脚本的闹钟。当脚本首次唤醒（或加载）时，这个函数会响起。通常，它用于设置变量或游戏的状态。'
- en: '`Start()`: This is the runner on their mark, ready to start the race. This
    function gets called right before the first frame of the game is displayed. It’s
    also used to set things up, but unlike `Awake()`, it won’t run if the script isn’t
    enabled.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start()`: 这就像是在起跑线上准备起跑的运动员。在游戏的第一帧显示之前，这个函数会被调用。它也用于设置事物，但与 `Awake()` 不同，如果脚本未启用，则不会运行。'
- en: '`Update()`: This function is the heart of your game, beating once per frame.
    It’s usually used for tasks that need to happen regularly, such as moving objects
    around, checking for user input, and so on.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()`: 这个函数是游戏的心脏，每帧跳动一次。它通常用于需要定期执行的任务，例如移动对象、检查用户输入等。'
- en: '`FixedUpdate()`: This is like `Update()`, but it runs at a consistent pace,
    no matter the frame rate. It’s typically used for physics-related tasks.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedUpdate()`: 这就像 `Update()`，但它以恒定的速度运行，不受帧率的影响。它通常用于与物理相关的任务。'
- en: '`LateUpdate()`: This is the function that tidies up after everyone else. It
    runs after all `Update()` functions have done their thing, doing any tasks that
    need to happen after everything else.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LateUpdate()`: 这是一个在其他人之后整理的函数。它在所有 `Update()` 函数执行完毕后运行，执行所有其他任务。'
- en: '`OnEnable()`: This method is a special Unity method that gets called whenever
    the object this script is attached to becomes active in the game.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnEnable()`: 这是一个特殊的Unity方法，当脚本附加的对象在游戏中变为活动状态时会被调用。'
- en: 'Now, when it comes to VR interactions, Unity’s XR Interaction Toolkit provides
    its own set of special functions that react to VR actions. Here are a few important
    ones you’ll want to know about:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当涉及到VR交互时，Unity的XR交互工具包提供了一组自己的特殊函数，这些函数会对VR动作做出反应。以下是一些你想要了解的重要函数：
- en: '`OnSelectEntered()`: This function is called when you select an interactable
    object in VR. Imagine it as the moment when you point at a virtual object with
    your VR controller.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnSelectEntered()`: 当你在VR中选择一个可交互对象时，会调用这个函数。想象一下，当你用VR控制器指向一个虚拟对象的那一刻。'
- en: '`OnSelectExited()`: This function is the moment when you stop selecting an
    interactable object. Think of it as letting go of the object you were pointing
    at.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnSelectExited()`: 这个函数是在你停止选择一个可交互对象的那一刻。想象一下，就像是你放开了你指向的对象。'
- en: '`OnActivate()`: This is when you activate an interactable object. It’s a bit
    like pressing a button while you’re already holding the object.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActivate()`: 这是在你激活一个可交互对象时发生的。这有点像在你已经拿着对象的同时按下按钮。'
- en: '`OnDeactivate()`: This is when you deactivate the object. It’s like letting
    go of the button you just pressed.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDeactivate()`: 这是在你停用对象时发生的。这就像是你放开了你刚刚按下的按钮。'
- en: '`OnHoverEntered()`: This function gets called when you start hovering over
    an interactable object. This could be used to make the object light up, for instance.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHoverEntered()`: 当你开始悬停在可交互对象上时，会调用这个函数。这可以用来使对象发光，例如。'
- en: '`OnHoverExited()`: This function is when you stop hovering over an object.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHoverExited()`: 这个函数是在你停止悬停在某个对象上时触发的。'
- en: These functions can be combined in different ways to create all sorts of interactions
    in the virtual world. It’s like stacking building blocks together to create something
    more complex.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以通过不同的方式组合起来，以在虚拟世界中创建各种交互。这就像堆叠积木来创建更复杂的东西。
- en: Classes
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类
- en: '`MonoBehaviour`, `ScriptableObject`, or others to illustrate the characteristics
    of classes in C#. Let’s go through an example class called `XRGrab`, which inherits
    from the base class, `MonoBehaviour`. The first section of this class consists
    of the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MonoBehaviour`、`ScriptableObject`或其他类来展示C#中类的特性。让我们通过一个名为`XRGrab`的示例类来了解，它继承自基类`MonoBehaviour`。这个类的第一部分包括以下内容：
- en: '[PRE1]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, the `XRGrab` class consists of two fields. `public
    XRGrabInteractable grabInteractable` is a reference to an `XRGrabInteractable`
    object. This script is typically attached to a GameObject that you want to make
    interactable in a VR or AR setting; for example, an object the user should be
    able to grab. `isGrabbed` is a boolean variable that keeps track of whether the
    interactable object is currently grabbed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`XRGrab`类包含两个字段。`public XRGrabInteractable grabInteractable`是对`XRGrabInteractable`对象的引用。这个脚本通常附加到你想要在VR或AR环境中使其可交互的GameObject上；例如，用户应该能够抓取的对象。`isGrabbed`是一个布尔变量，用于跟踪可交互对象是否当前被抓取。
- en: 'The next section of our class consists of methods. The first method of our
    class is called `OnEnable()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类的下一部分是方法。我们类中的第一个方法是`OnEnable()`：
- en: '[PRE2]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `OnEnable()` method adds `Grabbed()` and `Released()` methods as listeners
    to the `onSelectEntered` and `onSelectExited` events of the `grabInteractable`
    object. This means when the user interacts with the object in the VR/AR world
    by selecting it, the `Grabbed()` method will be called, and when the user stops
    interacting with it and hence deselects it, the `Released()` method will be called.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnEnable()`方法将`Grabbed()`和`Released()`方法作为监听器添加到`grabInteractable`对象的`onSelectEntered`和`onSelectExited`事件。这意味着当用户通过选择在VR/AR世界中与对象交互时，将调用`Grabbed()`方法，而当用户停止与它交互并取消选择时，将调用`Released()`方法。'
- en: 'Let’s have a look at what both of these methods might look like:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两个方法可能的样子：
- en: 'Here''s the `Grabbed()` method:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面是`Grabbed()`方法：
- en: '[PRE3]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Grabbed()` method sets `isGrabbed` to true, indicating that the object
    has been grabbed.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Grabbed()`方法将`isGrabbed`设置为true，表示对象已被抓取。'
- en: 'Here''s the `Released()` method:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面是`Released()`方法：
- en: '[PRE7]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Released()` method sets `isGrabbed` to false, indicating that the object
    has been released.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Released()`方法将`isGrabbed`设置为false，表示对象已被释放。'
- en: As you can see, scripting in Unity using C# involves defining variables to hold
    data, implementing functions to manipulate that data or implement gameplay, and
    organizing these variables and functions into classes that represent objects or
    concepts in your game. The Unity engine then uses these scripts to drive the behavior
    of GameObjects within your scenes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在Unity中使用C#进行脚本编写涉及定义变量来存储数据，实现函数来操作这些数据或实现游戏玩法，并将这些变量和函数组织成代表游戏中对象或概念的类。然后Unity引擎使用这些脚本来驱动场景中GameObject的行为。
- en: 'In the realm of C#, class names typically follow the **PascalCase convention**,
    where each word begins with an uppercase letter and underscores are absent. You
    have the freedom to select any name that pleases you, as long as it complies with
    the general naming conventions of C#. Here are the naming guidelines:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#的领域里，类名通常遵循**PascalCase**约定，即每个单词以大写字母开头，且没有下划线。你可以自由选择任何你喜欢的名字，只要它符合C#的一般命名约定。以下是命名指南：
- en: Names should commence with an uppercase letter instead of an underscore or a
    digit.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称应该以大写字母开头，而不是下划线或数字。
- en: Names can incorporate letters and digits but not underscores.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称可以包含字母和数字，但不能包含下划线。
- en: Spaces or special characters should not be part of the name.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格或特殊字符不应成为名称的一部分。
- en: Lastly, the name must not be a reserved word in C#. Words such as “class”, “int”,
    “void”, and so on are reserved and cannot be employed as a name. This is because
    they have specific meanings in C#, as they are part of its syntax. The compiler
    expects them to be used in specific ways, so using them as identifiers would cause
    confusion and lead to compilation errors.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，名称不能是C#中的保留词。例如，“class”、“int”、“void”等都是保留的，不能用作名称。这是因为它们在C#中有特定的含义，作为其语法的一部分。编译器期望它们以特定的方式使用，因此将它们用作标识符会导致混淆并导致编译错误。
- en: And that’s a gentle introduction to scripting in Unity for VR development. Don’t
    worry if it still sounds a bit complex; like with any language, practice makes
    perfect, and this is exactly what you are going to do in the next section!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Unity中用于VR开发的脚本编写的温和介绍。如果它听起来仍然有点复杂，请不要担心；就像任何语言一样，熟能生巧，这正是您将在下一节中要做的！
- en: Scaling a bus using a slider and C#
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用滑块和C#缩放公交车
- en: 'We are about to embark on an exciting task: enriching our car exhibition experience
    by adding a dynamic scaling feature to a bus. Previously, we used fixed animations
    to scale a police car. However, this time, we will scale a bus in real time based
    on user interaction with a slider.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将开始一项令人兴奋的任务：通过向公交车添加动态缩放功能来丰富我们的汽车展览体验。之前，我们使用固定动画来缩放警车。然而，这次，我们将根据用户与滑块的交互实时缩放公交车。
- en: 'With these steps, we will achieve our objective. So, let’s dive in:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将实现我们的目标。所以，让我们开始吧：
- en: First, we need to bring the bus into our scene. Go to `Assets` | `Simple Vehicle
    Pack` | `Prefabs`, drag and drop `Bus_2` into the scene. Position it at coordinates
    (`0,0,-6`), with a `-90` degree rotation on the y-axis.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将公交车带入我们的场景。转到`Assets` | `Simple Vehicle Pack` | `Prefabs`，将`Bus_2`拖放到场景中。将其定位在坐标(`0,0,-6`)，y轴上有一个`-90`度的旋转。
- en: Next, we require a slider and a descriptive text that indicates that the bus
    can be scaled using the slider. To accomplish this, we first need to create a
    canvas. Right-click in the hierarchy and select `0.01,0.01,0`), position it at
    (`0,1.5,-5`), and rotate it to (`0,180,0`). Now it is facing the player’s direction.
    Note that you must set the `Bus Scale Canvas` for clarity.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个滑块和一个描述性文本，表明可以通过滑块调整公交车的大小。为了完成这个任务，我们首先需要创建一个画布。在层次结构中右键单击，选择`0.01,0.01,0`），将其定位在(`0,1.5,-5`)，并旋转到(`0,180,0`)。现在它面向玩家的方向。请注意，您必须设置`Bus
    Scale Canvas`以提高清晰度。
- en: 'One thing is missing before adding UI elements to the canvas: the **Vertical
    Layout Group** component. Let’s add this in the Inspector and change the **Child
    Alignment** property to the **Upper Center**. This ensures that both the slider
    and text will be vertically aligned at the upper center of the canvas.'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在向画布添加UI元素之前，还缺少一件事情：**垂直布局组**组件。让我们在检查器中添加这个组件，并将**子对齐**属性更改为**上居中**。这确保了滑块和文本都将垂直对齐在画布的上居中位置。
- en: Next, we can add the slider. Right-click on the `0` and the `5`, allowing the
    bus to be scaled between these values. Let’s rename the slider to `Bus Scale Slider`
    for distinction.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加滑块。在`0`和`5`上右键单击，允许公交车在这两个值之间缩放。让我们将滑块重命名为`Bus Scale Slider`以区分。
- en: For enhanced user experience, we will also place a text above the slider. Add
    a `Slider` GameObject by right-clicking on `Bus Scale Slider`, select `Bus` `Scale
    Text`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增强用户体验，我们还将滑块上方放置一个文本。通过在`Bus Scale Slider`上右键单击，选择`Bus` `Scale Text`来添加一个`Slider`游戏对象。
- en: We have now set up the slider, which serves as our initialization event, as
    shown in *Figure 5**.11*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了滑块，它作为我们的初始化事件，如*图5**.11*所示。
- en: "![Figure 5.11 – \uFEFFThe bus scale slider](img/B20869_05_11.jpg)"
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11 – 公交缩放滑块](img/B20869_05_11.jpg)'
- en: Figure 5.11 – The bus scale slider
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 公交缩放滑块
- en: Following this, we will link this with the scaling animation and state control
    via a single C# script. The idea is to bind the slider’s value to the bus’s scale.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将通过单个C#脚本将缩放动画和状态控制链接起来。想法是将滑块的值绑定到公交车的缩放。
- en: 'Before proceeding with scripting, it’s advisable to maintain organization by
    creating a new folder:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行脚本编写之前，建议通过创建一个新的文件夹来保持组织：
- en: Right-click in the `Assets` folder, choose `Scripts`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets`文件夹中右键单击，选择`Scripts`。
- en: Inside this new folder, create a new C# script and rename it `BusScaler`. This
    script will be our primary tool in bringing dynamic scaling to life.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新文件夹内，创建一个新的C#脚本并将其重命名为`BusScaler`。这个脚本将是我们将动态缩放变为现实的主要工具。
- en: Now double-click on the script. This will open it in the IDE that is installed
    on your computer. This is the code we are going to develop.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在双击脚本。这将打开您计算机上安装的IDE。这是我们将要开发的代码。
- en: Writing the animation script
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写动画脚本
- en: 'The following explanations guide you on how the main components of the `BusScaler`
    script interact with each other:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明指导您了解`BusScaler`脚本的主要组件如何相互交互：
- en: 'Start with the following two lines of code to define your namespaces:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下两行代码开始，定义您的命名空间：
- en: '[PRE12]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first step of any C# script in Unity is to include `using` keyword is used
    to include namespaces in the script. `UnityEngine` contains all the classes needed
    for creating games in Unity, while `UnityEngine.UI` contains classes for creating
    and manipulating UI elements.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何Unity中的C#脚本的第一步是使用`using`关键字来包含命名空间。`UnityEngine`包含创建Unity游戏所需的所有类，而`UnityEngine.UI`包含创建和操作UI元素的类。
- en: 'The class declaration follows next. In our script, let''s declare a new class
    named `BusScaler` with the following code sequence:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类声明接下来。在我们的脚本中，让我们声明一个新的类`BusScaler`，以下代码序列：
- en: '[PRE14]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class inherits from `MonoBehaviour`, which is the base class for all Unity
    scripts.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此类从`MonoBehaviour`继承，它是所有Unity脚本的基础类。
- en: 'Next, declare the variables of the `BusScaler` class with the following code
    sequence:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明`BusScaler`类的变量，以下代码序列：
- en: '[PRE15]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `public` keyword means these variables can be accessed from other scripts
    and can also be set from Unity’s `bus` variable will hold the bus object in the
    scene and the `slider` variable will hold the slider UI object in the scene.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`public`关键字表示这些变量可以从其他脚本访问，也可以从Unity的`bus`变量中设置，它将在场景中持有公共汽车对象，而`slider`变量将在场景中持有滑块UI对象。'
- en: 'Next, let''s override the `Awake()` function to set up initial settings and
    references before the game starts. This includes setting the initial scale of
    the bus to `1` on the x-, y-, and z-axes. We do this with the following code snippet:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们重写`Awake()`函数，在游戏开始之前设置初始设置和引用。这包括将公共汽车的初始比例在x、y和z轴上设置为`1`。我们使用以下代码片段来完成：
- en: '[PRE17]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our final step is to override the `Update()` function. Type or paste in the
    following lines of code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一步是重写`Update()`函数。输入或粘贴以下代码行：
- en: '[PRE21]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code retrieves the value of the slider (which ranges between its minimum
    and maximum values set in Unity’s Inspector) and sets the scale of the bus to
    this value on the x-, y-, and z-axes. This means if the slider’s value is `0.5`,
    the bus will be half its original size.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码检索滑块的值（该值在Unity的Inspector中设置的滑块最小值和最大值之间），并将公共汽车在x、y和z轴上的比例设置为该值。这意味着如果滑块的值为`0.5`，公共汽车将变为原来大小的一半。
- en: Testing our animation
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们的动画
- en: 'Now that our C# script is finished, there are only a few steps left to complete
    until we can test our animation:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了C#脚本，只剩下几个步骤就可以完成测试我们的动画：
- en: In our C# script, the class `BusScaler` is derived from `MonoBehaviour`. To
    utilize this script, it needs to be associated with a GameObject within the Unity
    editor. To do this, right-click in the hierarchy and select `Bus` `Scaler Controller`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的C#脚本中，`BusScaler`类从`MonoBehaviour`派生。为了使用此脚本，它需要在Unity编辑器中的GameObject中关联。为此，在层次结构中右键单击并选择`Bus`
    `Scaler Controller`。
- en: Next, you can drag your script and drop it into the **Inspector** panel of this
    new GameObject. This action will attach your script as a component.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以将你的脚本拖放到新GameObject的**Inspector**面板中。这个动作将把你的脚本附加为一个组件。
- en: Upon doing this, you’ll notice that the public fields `bus` and `slider` become
    visible in the script component within the Unity editor. These fields need to
    be populated with the actual `bus` GameObject and the slider object this script
    will interact with. To do this, simply drag and drop these objects into the corresponding
    field, as shown in *Figure 5**.12*.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，你会在Unity编辑器中的脚本组件中注意到公共字段`bus`和`slider`变得可见。这些字段需要填充实际的`bus` GameObject和此脚本将要与之交互的滑块对象。为此，只需将这些对象拖放到相应的字段中，如图*图5**.12*所示。
- en: "![Figure 5.12 – \uFEFFThe Inspector window of the Bus Scaler Controller with\
    \ the bus and slider objects placed into their corresponding fields in the Bus\
    \ Scaler script](img/B20869_05_12.jpg)"
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12 – 公共汽车缩放器控制器的Inspector窗口，其中公共汽车和滑块对象已放入公共汽车缩放器脚本中的相应字段](img/B20869_05_12.jpg)'
- en: Figure 5.12 – The Inspector window of the Bus Scaler Controller with the bus
    and slider objects placed into their corresponding fields in the Bus Scaler script
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 将公共汽车缩放器脚本中的公共汽车和滑块对象放入相应字段的公共汽车缩放器控制器的Inspector窗口
- en: 'The final step before you can test your interactive slider is to place a teleport
    anchor in front of it. This can be done by going back to our toolbox and navigating
    to `Assets` | `Samples` | `XR` `Interaction Toolkit`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你可以测试你的交互式滑块之前，最后的步骤是在它前面放置一个传送锚点。这可以通过回到我们的工具箱，导航到`Assets` | `Samples` | `XR`
    `Interaction Toolkit`来完成：
- en: Here, you’ll find the `Bus` `Teleport Anchor`.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以找到`Bus` `Teleport Anchor`。
- en: Position this anchor at coordinates (`0`,`0`,`-2.5`) and adjust its size to
    (`2`,`1`,`2`). With this setup, the user can now teleport to a position in front
    of the slider, enabling them to scale the bus interactively, as shown in *Figure
    5**.13*.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此锚点放置在坐标（`0`,`0`,`-2.5`）处，并调整其大小为（`2`,`1`,`2`）。使用这种设置，用户现在可以传送到滑块前方的一个位置，使他们能够交互式地缩放公交车，如图
    *图 5.13* 所示。
- en: "![Figure 5.13 – \uFEFFHow the bus is scaled when the user interacts with the\
    \ slider in VR](img/B20869_05_13.jpg)"
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 用户在 VR 中与滑块交互时公交车如何缩放](img/B20869_05_13.jpg)'
- en: Figure 5.13 – How the bus is scaled when the user interacts with the slider
    in VR
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 用户在 VR 中与滑块交互时公交车如何缩放
- en: Hurray, you have successfully completed all the steps needed for this animation.
    Now, it is time to explore your interactive VR scene once more. For this, follow
    the steps described in the *Deploying and testing VR experiences onto different
    VR platforms or simulators* section of [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼，你已经成功完成了制作此动画所需的所有步骤。现在，是时候再次探索你的交互式 VR 场景了。为此，请遵循[*第 3 章*](B20869_03.xhtml#_idTextAnchor009)中“将
    VR 体验部署和测试到不同的 VR 平台或模拟器”部分所描述的步骤。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to add interactivity into your VR scenes
    in Unity, using both code-dependent and code-free methods. By now, having successfully
    navigated through the steps provided in this chapter, you should have brought
    your Unity scene to life and acquired a solid understanding of and established
    a comfort level in deciding when to opt for Unity’s animator system and when to
    leverage the power of C# for your interactive scene creation needs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Unity 中为 VR 场景添加交互性，使用代码依赖和无代码方法。到目前为止，通过成功完成本章提供的步骤，你应该已经让你的 Unity
    场景变得生动，并获得了对何时选择 Unity 的动画系统以及何时利用 C# 的力量来满足你的交互场景创建需求的理解和舒适度。
- en: We’ve delved into the intricacies of triggering button events and utilizing
    the animator system, thereby equipping you with the skills to create simple yet
    effective interactions in your VR landscape without having to write a line of
    code. For more intricate interaction designs, you should now feel very familiar
    with the essential functions of C# in Unity and be familiar with the robust functionalities
    provided by the XR Interaction Toolkit.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了触发按钮事件和利用动画系统，从而为你提供了在 VR 场景中创建简单而有效的交互技能，而不必编写一行代码。对于更复杂的交互设计，你现在应该非常熟悉
    Unity 中 C# 的基本功能，并且熟悉 XR Interaction Toolkit 提供的强大功能。
- en: Be it industrial applications or academic projects, these skills and techniques
    should empower you to create immersive VR scenes in Unity using the XR Interaction
    Toolkit and its demo scene. You should feel ready to apply what you've learned
    to your unique use cases.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是工业应用还是学术项目，这些技能和技术应该能够让你利用 XR Interaction Toolkit 和其演示场景在 Unity 中创建沉浸式 VR
    场景。你应该准备好将所学知识应用到你的独特用例中。
- en: But our journey does not end here. In the forthcoming chapter, we’ll broaden
    our horizon by venturing into the creation of interactive AR and MR experiences
    in Unity. This will ensure that you are comprehensively equipped to add interactions
    across the spectrum of XR scenes. Let’s continue our exciting exploration into
    the world of immersive technology.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的旅程并未结束。在接下来的章节中，我们将通过探索在 Unity 中创建交互式 AR 和 MR 体验来拓宽我们的视野。这将确保你能够全面地添加 XR
    场景中的交互。让我们继续我们激动人心的探索，进入沉浸式技术的世界。
