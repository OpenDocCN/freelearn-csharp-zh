<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Screen Effects with Unity Render Textures</h1>
                
            
            <article>
                
<p class="calibre3">In this chapter, you will learn the following recipes:</p>
<ul class="calibre11">
<li class="calibre12">Setting up the screen effects script system</li>
<li class="calibre12">Using brightness, saturation, and contrast with screen effects</li>
<li class="calibre12">Using basic Photoshop-like Blend modes with screen effects</li>
<li class="calibre12">Using the Overlay Blend mode with screen effects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            <article>
                
<p class="calibre3">One of the most impressive aspects of learning to write shaders is the process of creating your own screen effects, also known as post effects. With these screen effects, we can create stunning real-time images with Bloom, Motion Blur, HDR effects, and so on. Most modern games on the market today make heavy use of these screen effects for their depth of field effects, Bloom effects, and even color correction effects.</p>
<p class="calibre3">In <a href="part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 1</a>, <em class="calibre14">Post Processing Stack</em>, we discussed how to use this with Unity's built-in Post Processing Stack, but in this chapter, you will learn how to build up the script system yourself. This system will give you the control to create many kinds of screen effects. We will cover <kbd class="calibre13"><span>RenderTexture</span></kbd>, what the depth buffer is, and how to create effects that give you Photoshop-like control over the final rendered image of your game. By utilizing screen effects for your games, you not only round out your shader writing knowledge, but you will also have the power to create your own incredible real-time renders with Unity from scratch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up the screen effects script system</h1>
                
            
            <article>
                
<p class="calibre3">The process of creating screen effects is one in which we grab a full-screen image (or texture), use a shader to process its pixels on the GPU, and then send it back to Unity's renderer to apply it to the whole rendered image of the game. This allows us to perform per-pixel operations on the rendered image of the game in real time, giving us a more global artistic control.</p>
<p class="calibre3">Imagine if you had to go through and adjust each material on each object in your game to just adjust the contrast of the final look of your game. While not impossible, this would take a bit of labor to perform. By utilizing a screen effect, we can adjust the screen's final look as a whole, thereby giving us more Photoshop-like control over our game's final appearance.</p>
<p class="calibre3">In order to get a screen effect system up and running, we have to set up a single script to act as the courier of the game's current rendered image, or what Unity calls the <kbd class="calibre13">RenderTexture</kbd>. By utilizing this script to pass the <kbd class="calibre13">RenderTexture</kbd> to a shader, we can create a flexible system for establishing screen effects. For our first screen effect, we are going to create a very simple grayscale effect and make our game look black and white. Let's take a look at how this is done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">In order to get our screen effects system up and running, we need to create a few assets for our current Unity project. By doing this, we will set ourselves up for the steps in the following sections:</p>
<ol class="calibre15">
<li value="1" class="calibre12">In the current project, create a new scene to work in.</li>
<li value="2" class="calibre12">Create a simple sphere in the scene and assign it a new material (I called mine <kbd class="calibre13">RedMat</kbd>). This new material can be anything, but for our example, we will make a simple red material using the Standard Shader.</li>
<li value="3" class="calibre12">Finally, create a new directional light and save the scene.</li>
<li value="4" class="calibre12">We need to create a new C# script and call it<span> </span><kbd class="calibre13">TestRenderImage.cs</kbd>. For organization purposes, create a folder called <kbd class="calibre13">Scripts</kbd> from the <span>Project</span> tab to put it in.</li>
</ol>
<p class="calibre3">With all of our assets ready, you should have a simple scene setup, which looks similar to the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00182.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">In order to make our grayscale screen effect work, we need a script and shader. So, we will complete these two new items here and fill them in with the appropriate code to produce our first screen effect. Our first task is to complete the C# script. This will get the whole system running. After this, we will complete the shader and see the results of our screen effect. Let's complete our script and shader with the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Open the <kbd class="calibre13">TestRenderImage.cs</kbd> C# script and begin by entering a few variables that we will need to store important objects and data. Enter the following code at the very top of the <kbd class="calibre13">TestRenderImage</kbd> class:</li>
</ol>
<pre class="calibre62">#region Variables<br class="title-page-name"/>public Shader curShader;<br class="title-page-name"/>public float greyscaleAmount = 1.0f;<br class="title-page-name"/>private Material screenMat;<br class="title-page-name"/>#endregion</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">In order for us to edit the screen effect in real time, when the Unity editor isn't playing, we need to enter the following line of code just above the declaration of the <kbd class="calibre13">TestRenderImage</kbd> class:</li>
</ol>
<pre class="calibre62">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">[ExecuteInEditMode]</strong><br class="title-page-name"/>public class TestRenderImage : MonoBehaviour {</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">As our screen effect is using a shader to perform the pixel operations on our screen image, we have to create a material to run the shader. Without this, we can't access the properties of the shader. For this, we will create a C# property to check for a material, and create one if it doesn't find one. Enter the following code just after the declaration of the variables from <em class="calibre2">step 1</em>:</li>
</ol>
<pre class="calibre62">#region Properties<br class="title-page-name"/>Material ScreenMat<br class="title-page-name"/>{<br class="title-page-name"/>    get<br class="title-page-name"/>    {<br class="title-page-name"/>        if (screenMat == null)<br class="title-page-name"/>        {<br class="title-page-name"/>            screenMat = new Material(curShader);<br class="title-page-name"/>            screenMat.hideFlags = HideFlags.HideAndDontSave;<br class="title-page-name"/>        }<br class="title-page-name"/>        return screenMat;<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/>#endregion</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">We now want to set up some checks in our script to see if the current target platform that we are building the Unity game on actually supports image effects. If it doesn't find anything at the start of this script, then the script will disable itself:</li>
</ol>
<pre class="calibre62">void Start()<br class="title-page-name"/>{<br class="title-page-name"/>    if (!SystemInfo.supportsImageEffects)<br class="title-page-name"/>    {<br class="title-page-name"/>        enabled = false;<br class="title-page-name"/>        return;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    if (!curShader &amp;&amp; !curShader.isSupported)<br class="title-page-name"/>    {<br class="title-page-name"/>        enabled = false;<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">To actually grab the rendered image from the Unity renderer, we need to make use of the following built-in function that Unity provides us, called <kbd class="calibre13">OnRenderImage()</kbd>. Enter the following code so that we can have access to the current <kbd class="calibre13"><span>RenderTexture</span></kbd>:</li>
</ol>
<pre class="calibre62">void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)<br class="title-page-name"/>{<br class="title-page-name"/>    if (curShader != null)<br class="title-page-name"/>    {<br class="title-page-name"/>        ScreenMat.SetFloat("_Luminosity", greyscaleAmount);<br class="title-page-name"/><br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture, ScreenMat);<br class="title-page-name"/>    }<br class="title-page-name"/>    else<br class="title-page-name"/>    {<br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Our screen effect has a variable called <kbd class="calibre13">grayScaleAmount</kbd> with which we can control how much grayscale we want for our final screen effect. So, in this case, we need to make the value go from <kbd class="calibre13">0</kbd> to <kbd class="calibre13">1</kbd>, where <kbd class="calibre13">0</kbd> is no grayscale effect and <kbd class="calibre13">1</kbd> is a full grayscale effect. We will perform this operation in the <kbd class="calibre13">Update()</kbd> function, which will be called every frame while the game is running:</li>
</ol>
<pre class="calibre62">void Update ()<br class="title-page-name"/>{<br class="title-page-name"/>    greyscaleAmount = Mathf.Clamp(greyscaleAmount, 0.0f, 1.0f);<br class="title-page-name"/>}</pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Finally, we complete our script by doing a little bit of clean-up on objects we created when the script started:</li>
</ol>
<pre class="calibre62">void OnDisable()<br class="title-page-name"/>{<br class="title-page-name"/>  if(screenMat)<br class="title-page-name"/>  {<br class="title-page-name"/>    DestroyImmediate(screenMat);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">At this point, we can now apply this script to the camera, if it compiled without errors, in Unity. Let's apply the <kbd class="calibre13">TestRenderImage.cs</kbd> script to our main camera in our scene. You should see the <kbd class="calibre13">grayScaleAmount</kbd> value and a field for a shader, but the script throws an error to the console window. It says that it is missing an instance to an object and so won't process appropriately. If you recall from <em class="calibre2">step 4</em>, we are doing some checks to see whether we have a shader and if the current platform supports the shader. As we haven't given the screen effect script a shader to work with, then the <kbd class="calibre13">curShader</kbd> variable is just null, which throws an error. Let's continue with our screen effects system by completing the shader.</li>
<li value="9" class="calibre12">Create a new shader called <kbd class="calibre13">ScreenGrayscale</kbd>. To begin our shader, we will populate our <kbd class="calibre13">Properties</kbd> with some variables so that we can send data to this shader:</li>
</ol>
<pre class="calibre62">Properties <br class="title-page-name"/>{<br class="title-page-name"/> _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/> _Luminosity("Luminosity", Range(0.0, 1)) = 1.0<br class="title-page-name"/>}</pre>
<ol start="10" class="calibre15">
<li value="10" class="calibre12">Our shader is now going to utilize pure CG shader code instead of utilizing Unity's built-in Surface Shader code. This will make our screen effect more optimized as we need to work only with the pixels of the <kbd class="calibre13"><span>RenderTexture</span>.</kbd> So, we will delete everything inside of the <kbd class="calibre13">Pass</kbd> that was there before and create a new <kbd class="calibre13">Pass</kbd> block in our shader and fill it with some new <kbd class="calibre13">#pragma</kbd> statements that we haven't seen before:</li>
</ol>
<pre class="calibre62">SubShader <br class="title-page-name"/>{<br class="title-page-name"/>  Pass<br class="title-page-name"/>  {<br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    #pragma vertex vert_img<br class="title-page-name"/>    #pragma fragment frag<br class="title-page-name"/>    #pragma fragmentoption ARB_precision_hint_fastest<br class="title-page-name"/>    #include "UnityCG.cginc"</pre>
<ol start="11" class="calibre15">
<li value="11" class="calibre12">In order to access the data being sent to the shader from the Unity editor, we need to create the corresponding variables in our <kbd class="calibre13">CGPROGRAM</kbd>:</li>
</ol>
<pre class="calibre62">uniform sampler2D _MainTex;<br class="title-page-name"/>fixed _Luminosity;</pre>
<ol start="12" class="calibre15">
<li value="12" class="calibre12">Finally, all we need to do is set up our pixel function, in this case called <kbd class="calibre13">frag()</kbd>. This is where the meat of the screen effect is. This function will process each pixel of the <kbd class="calibre13"><span>RenderTexture</span></kbd> and return a new image to our <kbd class="calibre13">TestRenderImage.cs</kbd> script:</li>
</ol>
<pre class="calibre62">fixed4 frag(v2f_img i) : COLOR<br class="title-page-name"/>{<br class="title-page-name"/>  //Get the colors from the RenderTexture and the uv's<br class="title-page-name"/>  //from the v2f_img struct<br class="title-page-name"/>  fixed4 renderTex = tex2D(_MainTex, i.uv);<br class="title-page-name"/>        <br class="title-page-name"/>  //Apply the Luminosity values to our render texture<br class="title-page-name"/>  float luminosity = 0.299 * renderTex.r + 0.587 * renderTex.g + 0.114 * renderTex.b;<br class="title-page-name"/>  fixed4 finalColor = lerp(renderTex, luminosity, _Luminosity);<br class="title-page-name"/>        <br class="title-page-name"/>  renderTex.rgb = finalColor;<br class="title-page-name"/><br class="title-page-name"/>  return renderTex;<br class="title-page-name"/>}</pre>
<ol start="13" class="calibre15">
<li value="13" class="calibre12">Lastly, change the <kbd class="calibre13">FallBack</kbd> line to the following:</li>
</ol>
<pre class="calibre62">FallBack off</pre>
<ol start="14" class="calibre15">
<li value="14" class="calibre12">The final shader should look as follows:</li>
</ol>
<pre class="calibre62">Shader "CookbookShaders/Chapter09/Grayscale" <br class="title-page-name"/>{<br class="title-page-name"/>  Properties <br class="title-page-name"/>  {<br class="title-page-name"/>    _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>    _Luminosity("Luminosity", Range(0.0, 1)) = 1.0<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  SubShader <br class="title-page-name"/>  {<br class="title-page-name"/>    Pass<br class="title-page-name"/>    {<br class="title-page-name"/>      CGPROGRAM<br class="title-page-name"/>      #pragma vertex vert_img<br class="title-page-name"/>      #pragma fragment frag<br class="title-page-name"/>      #pragma fragmentoption ARB_precision_hint_fastest<br class="title-page-name"/>      #include "UnityCG.cginc"<br class="title-page-name"/><br class="title-page-name"/>      uniform sampler2D _MainTex;<br class="title-page-name"/>      fixed _Luminosity;<br class="title-page-name"/><br class="title-page-name"/>      fixed4 frag(v2f_img i) : COLOR<br class="title-page-name"/>      {<br class="title-page-name"/>        //Get the colors from the RenderTexture and the uv's<br class="title-page-name"/>        //from the v2f_img struct<br class="title-page-name"/>        fixed4 renderTex = tex2D(_MainTex, i.uv);<br class="title-page-name"/>        <br class="title-page-name"/>        //Apply the Luminosity values to our render texture<br class="title-page-name"/>        float luminosity = 0.299 * renderTex.r + 0.587 * renderTex.g + 0.114 * renderTex.b;<br class="title-page-name"/>        fixed4 finalColor = lerp(renderTex, luminosity, _Luminosity);<br class="title-page-name"/><br class="title-page-name"/>        renderTex.rgb = finalColor;<br class="title-page-name"/>        <br class="title-page-name"/>        return renderTex;<br class="title-page-name"/>      }<br class="title-page-name"/>    <br class="title-page-name"/>    ENDCG<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  FallBack off<br class="title-page-name"/>}</pre>
<p class="calibre3">Once the shader is complete, return to Unity and let it compile to see if any errors occurred. If not, assign the new shader to the <kbd class="calibre13">TestRenderImage.cs</kbd> script and change the value of the grayscale amount variable. You should see the game view go from a colored version of the game to a grayscale version of the game:</p>
<div class="cdpaligncenter"><img src="../images/00183.jpeg" class="calibre25"/></div>
<p class="calibre3">The following screenshot demonstrates this Screen Effect:</p>
<div class="cdpaligncenter"><img src="../images/00184.jpeg" class="calibre133"/></div>
<p class="calibre3">With this complete, we now have an easy way to test out new screen effect shaders without having to write our whole screen effect system over and over again. Let's dive in a little deeper and learn about what's going on with the <kbd class="calibre13">RenderTexture</kbd> and how it is processed throughout its existence.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">To get a screen effect up and running inside of Unity, we need to create a script and shader. The script drives the real-time update in the editor and is also responsible for capturing the <kbd class="calibre13"><span>RenderTexture</span></kbd> from the main camera and passing it to the shader. Once the <kbd class="calibre13"><span>RenderTexture</span></kbd> gets to the shader, we can use the shader to perform per-pixel operations.</p>
<p class="calibre3">At the start of the script, we perform a few checks to make sure that the current selected build platform actually supports screen effects and the shader itself. There are instances where a current platform will not support screen effects or the shader that we are using. So, the checks that we do in the <kbd class="calibre13">Start()</kbd> function ensure we don't get any errors if the platform doesn't support the screen system.</p>
<p class="calibre3">Once the script passes these checks, we initiate the screen effects system by calling the built-in <kbd class="calibre13">OnRenderImage()</kbd> function. This function is responsible for grabbing the <kbd class="calibre13">renderTexture</kbd>, giving it to the shader using the <kbd class="calibre13">Graphics.Blit()</kbd> function, and returning the processed image to the Unity renderer. You can find more information on these two functions at the following URLs:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">OnRenderImage</kbd>: <span><a href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html" class="calibre10">http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html</a><br class="title-page-name"/></span></li>
<li class="calibre12"><kbd class="calibre13">Graphics.Blit</kbd>:<strong class="calibre1"> </strong><span><a href="http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html" class="calibre10">http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html</a><br class="title-page-name"/></span></li>
</ul>
<p class="calibre3">Once the current <kbd class="calibre13"><span>RenderTexture</span></kbd> reaches the shader, the shader takes it, processes it through the <kbd class="calibre13">frag()</kbd> function, and returns the final color for each pixel.</p>
<p class="calibre3">You can see how powerful this becomes as it gives us Photoshop-like control over the final rendered image of our game. These screen effects work sequentially like Photoshop layers on top of what the camera sees. When you place these screen effects one after the other, they will be processed in that order. These are just the bare bones steps to get a screen effect working, but it is the core of how the screen effects system works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have our simple screen effect system up and running, let's take a look at some of the other useful information we can obtain from Unity's renderer:</p>
<div class="cdpaligncenter"><img src="../images/00185.gif" class="calibre25"/></div>
<p class="calibre3">We can actually get the depth of everything in our current game by turning on Unity's built-in <span class="calibre6">Depth</span> mode. Once this is turned on, we can use the depth information for a ton of different effects. Let's take a look at how this is done:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Duplicate the sphere we created twice and create a plane underneath:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00186.jpeg" class="calibre25"/></div>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Create a new shader by duplicating the <kbd class="calibre13">ScreenGreyscale</kbd> code by selecting it and pressing <em class="calibre2">Ctrl </em>+ <em class="calibre2">D</em>. Once duplicated, rename the script to <kbd class="calibre13">SceneDepth</kbd>. Then double-click on this shader to open it in your script editor.</li>
<li value="3" class="calibre12">We will create the main texture (<kbd class="calibre13">_MainTex</kbd>) property and a property to control the power of the scene depth effect. Enter the following code in your shader:</li>
</ol>
<pre class="calibre62">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>  <strong class="calibre1">_DepthPower("Depth Power", Range(0, 1)) = 1</strong><br class="title-page-name"/>}</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Now we need to create the corresponding variables in our <kbd class="calibre13">CGPROGRAM</kbd>. We are going to add one more variable called <kbd class="calibre13">_CameraDepthTexture</kbd>. This is a built-in variable that Unity has provided us with through the use of the <kbd class="calibre13">UnityCG.cginclude</kbd> file. It gives us the depth information from the camera:</li>
</ol>
<pre class="calibre62">Pass<br class="title-page-name"/>{<br class="title-page-name"/>  CGPROGRAM<br class="title-page-name"/>  #pragma vertex vert_img<br class="title-page-name"/>  #pragma fragment frag<br class="title-page-name"/>  #pragma fragmentoption ARB_precision_hint_fastest<br class="title-page-name"/>  #include "UnityCG.cginc"<br class="title-page-name"/><br class="title-page-name"/>  uniform sampler2D _MainTex;<br class="title-page-name"/><strong class="calibre1">  fixed _DepthPower;</strong><br class="title-page-name"/><strong class="calibre1">  sampler2D _CameraDepthTexture;</strong></pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">We will complete our depth shader by utilizing a couple of built-in functions that Unity provides us with, the <kbd class="calibre13">UNITY_SAMPLE_DEPTH()</kbd> and <kbd class="calibre13">linear01Depth()</kbd> functions. The first function actually gets the depth information from our <kbd class="calibre13">_CameraDepthTexture</kbd> and produces a single float value for each pixel. The <kbd class="calibre13">Linear01Depth()</kbd> function then makes sure that the values are within the <kbd class="calibre13">0</kbd>-<kbd class="calibre13">1</kbd> range by taking this final depth value to a power we can control, where the mid-value in the <kbd class="calibre13">0</kbd>-<kbd class="calibre13">1</kbd> range sits in the scene based off of the camera position:</li>
</ol>
<pre class="calibre62">fixed4 frag(v2f_img i) : COLOR<br class="title-page-name"/>{<br class="title-page-name"/>  //Get the colors from the RenderTexture and the uv's<br class="title-page-name"/>  //from the v2f_img struct<br class="title-page-name"/>  float depth = UNITY_SAMPLE_DEPTH(tex2D(_CameraDepthTexture, i.uv.xy));<br class="title-page-name"/>  depth = pow(Linear01Depth(depth), _DepthPower);<br class="title-page-name"/><br class="title-page-name"/>  return depth;<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">With our shader complete, let's turn our attention to the Unity editor and create a new script to work with. Select our <kbd class="calibre13">TestRenderImage</kbd> script and duplicate it. Name this new script <kbd class="calibre13">RenderDepth</kbd> and open it up in your script editor.</li>
</ol>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Update the script to have the same class name as we renamed it to in the previous step (<kbd class="calibre13">RenderDepth</kbd>):</li>
</ol>
<pre class="calibre62">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>[ExecuteInEditMode]<br class="title-page-name"/>public class <strong class="calibre1">RenderDepth</strong> : MonoBehaviour {</pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">We need to add the <kbd class="calibre13">depthPower</kbd> variable to the script so that we can let users change the value in the editor:</li>
</ol>
<pre class="calibre62">#region Variables<br class="title-page-name"/>public Shader curShader;<br class="title-page-name"/><strong class="calibre1">public float depthPower = 0.2f;</strong><br class="title-page-name"/>private Material screenMat;<br class="title-page-name"/>#endregion</pre>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">Our <kbd class="calibre13">OnRenderImage()</kbd> function then needs to be updated so that it is passing the right value to our shader:</li>
</ol>
<pre class="calibre62">void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)<br class="title-page-name"/>{<br class="title-page-name"/>    if (curShader != null)<br class="title-page-name"/>    {<br class="title-page-name"/>        <strong class="calibre1">ScreenMat.SetFloat("_DepthPower", depthPower);</strong><br class="title-page-name"/><br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture, ScreenMat);<br class="title-page-name"/>    }<br class="title-page-name"/>    else<br class="title-page-name"/>    {<br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ol start="10" class="calibre15">
<li value="10" class="calibre12">To complete our depth screen effect, we need to tell Unity to turn on the depth rendering in the current camera. This is done by simply setting the main camera's <kbd class="calibre13">depthTextureMode</kbd>:</li>
</ol>
<pre class="calibre62">void Update ()<br class="title-page-name"/>{<br class="title-page-name"/>    Camera.main.depthTextureMode = DepthTextureMode.Depth;<br class="title-page-name"/>    depthPower = Mathf.Clamp(depthPower, 0, 1);<br class="title-page-name"/>}</pre>
<p class="calibre3">With all the code set up, save your script and shader and return to Unity to let them both compile. Afterward, select the <span class="calibre6">Main Camera</span>, right-click on the <span class="calibre6">TextRenderImage</span> component, and select <span class="calibre6">Remove Component</span>. Afterward, attach this new component to the object and drag and drop our new shader inside. If no errors are encountered, you should see a result similar to the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00187.jpeg" class="calibre25"/></div>
<p class="calibre3">Here's an example of what we can get if we tweak the values even more:</p>
<div class="cdpaligncenter"><img src="../images/00188.gif" class="calibre134"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using brightness, saturation, and contrast with screen effects</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have our screen effects system up and running, we can explore how to create more involved pixel operations to perform some of the more common screen effects found in games today.</p>
<p class="calibre3">Using a screen effect to adjust the overall final colors of your game is crucial in giving artists global control over the final look of the game. Techniques such as color adjustment sliders allow users to adjust the intensity of the reds, blues, and greens of the final rendered game. This concept is also used with techniques such as putting a certain tone of color over the whole screen, as seen in something like a sepia film effect.</p>
<p class="calibre3">For this particular recipe, we are going to cover some of the more core color adjustment operations we can perform on an image. These are brightness, saturation, and contrast. Learning how to code these color adjustments gives us a nice base from which we can learn the art of screen effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">We will need to create a couple of new assets. We can utilize the same scene as our test scene, but we will need a new script and shader:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new scene by going to <span>File</span> | <span>New Scene</span>.</li>
<li value="2" class="calibre12">Add a couple of new objects to the scene, set up some different colored diffuse materials, and randomly assign them to the new objects in the scene. This will give us a good range of colors to test with our new screen effect:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00189.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have completed our scene setup and created our new script and shader, we can begin to fill in the code necessary to achieve the brightness, saturation, and contrast screen effects. We will be focusing on just the pixel operation and variable setup for our script and shader, since getting a screen effect system up and running is described in the <em class="calibre14">Setting up the screen effects script system</em> recipe in this chapter:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new shader by duplicating the <kbd class="calibre13">ScreenGreyscale</kbd> code by selecting it from the <span>Project</span> tab under the <kbd class="calibre13">Chapter 9 </kbd>| <kbd class="calibre13">Shaders</kbd> folder and pressing <em class="calibre2">Ctrl</em> + <em class="calibre2">D</em>. Once duplicated, rename the script to <kbd class="calibre13">ScreenBSC</kbd>. Then double-click on this shader to open it in your script editor.</li>
<li value="2" class="calibre12">Editing the shader first makes more sense so that we know what kind of variables we will need for our C# script. Let's begin by entering the appropriate properties for our brightness, saturation, and contrast effect. Remember that we need to keep the <kbd class="calibre13">_MainTex</kbd> property in our shader as this is the property that the <kbd class="calibre13">RenderTexture</kbd> targets when creating screen effects:</li>
</ol>
<pre class="calibre62">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>  _Brightness("Brightness", Range(0.0, 1)) = 1.0<br class="title-page-name"/>  _Saturation("Saturation", Range(0.0, 1)) = 1.0<br class="title-page-name"/>  _Contrast("Contrast", Range(0.0, 1)) = 1.0<br class="title-page-name"/>}</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">As usual, in order for us to access the data coming in from our properties in our <kbd class="calibre13">CGPROGRAM</kbd>, we need to create the corresponding variables in the <kbd class="calibre13">CGPROGRAM</kbd>, replacing the previous ones:</li>
</ol>
<pre class="calibre62">Pass<br class="title-page-name"/>{<br class="title-page-name"/>  CGPROGRAM<br class="title-page-name"/>  #pragma vertex vert_img<br class="title-page-name"/>  #pragma fragment frag<br class="title-page-name"/>  #pragma fragmentoption ARB_precision_hint_fastest<br class="title-page-name"/>  #include "UnityCG.cginc"<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  uniform sampler2D _MainTex;</strong><br class="title-page-name"/><strong class="calibre1">  fixed _Brightness;</strong><br class="title-page-name"/><strong class="calibre1">  fixed _Saturation;</strong><br class="title-page-name"/><strong class="calibre1">  fixed _Contrast;</strong></pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Now, we need to create the operations that will perform the brightness, saturation, and contrast effects. Enter the following new function in our shader, just above the <kbd class="calibre13">frag()</kbd> function:</li>
</ol>
<pre class="calibre62">float3 ContrastSaturationBrightness(float3 color, float brt, float sat, float con)<br class="title-page-name"/>{<br class="title-page-name"/>  // Increase or decrease these values to <br class="title-page-name"/>  //adjust r, g and b color channels separately<br class="title-page-name"/>  float AvgLumR = 0.5;<br class="title-page-name"/>  float AvgLumG = 0.5;<br class="title-page-name"/>  float AvgLumB = 0.5;<br class="title-page-name"/>        <br class="title-page-name"/>//Luminance coefficients for getting lumoinance from the image<br class="title-page-name"/>  float3 LuminanceCoeff = float3(0.2125, 0.7154, 0.0721);<br class="title-page-name"/>        <br class="title-page-name"/>  //Operation for brightness<br class="title-page-name"/>  float3 AvgLumin = float3(AvgLumR, AvgLumG, AvgLumB);<br class="title-page-name"/>  float3 brtColor = color * brt;<br class="title-page-name"/>  float intensityf = dot(brtColor, LuminanceCoeff);<br class="title-page-name"/>  float3 intensity = float3(intensityf, intensityf, intensityf);<br class="title-page-name"/>        <br class="title-page-name"/>  //Operation for Saturation<br class="title-page-name"/>  float3 satColor = lerp(intensity, brtColor, sat);<br class="title-page-name"/>        <br class="title-page-name"/>  //Operation for Contrast<br class="title-page-name"/>  float3 conColor = lerp(AvgLumin, satColor, con);<br class="title-page-name"/>  return conColor;<br class="title-page-name"/>}</pre>
<div class="packt_tip"><span class="calibre27">Don't worry if it doesn't make sense just yet; all the code will be explained in </span><span class="calibre27">the <em class="calibre21">How it works</em> section of this recipe.</span></div>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Finally, we just need to update our <kbd class="calibre13">frag()</kbd> function to actually use the <kbd class="calibre13">ContrastSaturationBrightness()</kbd> function. This will process all the pixels of our <kbd class="calibre13">RenderTexture</kbd> and pass it back to our script:</li>
</ol>
<pre class="calibre62">fixed4 frag(v2f_img i) : COLOR<br class="title-page-name"/>{<br class="title-page-name"/>  //Get the colors from the RenderTexture and the uv's<br class="title-page-name"/>  //from the v2f_img struct<br class="title-page-name"/>  fixed4 renderTex = tex2D(_MainTex, i.uv);<br class="title-page-name"/>        <br class="title-page-name"/>  //Apply the Brughtness, saturation, contrast operations<br class="title-page-name"/>  renderTex.rgb = ContrastSaturationBrightness(renderTex.rgb, <br class="title-page-name"/>                        _Brightness, <br class="title-page-name"/>                        _Saturation, <br class="title-page-name"/>                        _Contrast);<br class="title-page-name"/>        <br class="title-page-name"/>  return renderTex;<br class="title-page-name"/>}</pre>
<p class="calibre3">With the code entered in the shader, return to the Unity editor to let the new shader compile. If there are no errors, we can return to our code editor to work on our script. Let's begin by creating a couple of new lines of code that will send the proper data to our shader:</p>
<ol start="1" class="calibre15">
<li value="1" class="calibre12">Now that the shader is finished, let's work on the script needed to make the effect show up. From the <span>Project</span> tab, go to the <kbd class="calibre13">Chapter 9 </kbd>| <kbd class="calibre13">Scripts</kbd> folder. Once there, select the <kbd class="calibre13">TestRenderImage</kbd> script and duplicate it by pressing <em class="calibre2">Ctrl</em> + <em class="calibre2">D</em>. Rename the newly created script to <kbd class="calibre13">RenderBSC</kbd>. Once renamed, double-click on it to enter your IDE of choice.</li>
</ol>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">To modify our script, we need to rename the class to match our filename, <kbd class="calibre13">RenderBSC</kbd>:</li>
</ol>
<pre class="calibre62">[ExecuteInEditMode]<br class="title-page-name"/>public class <strong class="calibre1">RenderBSC</strong> : MonoBehaviour {</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Afterward, we need to add the proper variables that will drive the values of our screen effect. In this case, we will need a slider for brightness, a slider for saturation, and a slider for contrast:</li>
</ol>
<pre class="calibre62">#region Variables<br class="title-page-name"/>public Shader curShader;<br class="title-page-name"/>public float brightness = 1.0f;<br class="title-page-name"/>public float saturation = 1.0f;<br class="title-page-name"/>public float contrast = 1.0f;<br class="title-page-name"/>private Material screenMat;<br class="title-page-name"/>#endregion</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">With our variables set up, we now need to tell the script to send the values of the variables we created to the shader. We do this in the <kbd class="calibre13">OnRenderImage()</kbd> function:</li>
</ol>
<pre class="calibre62">void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)<br class="title-page-name"/>{<br class="title-page-name"/>    if (curShader != null)<br class="title-page-name"/>    {<br class="title-page-name"/>        ScreenMat.SetFloat("_Brightness", brightness);<br class="title-page-name"/>        ScreenMat.SetFloat("_Saturation", saturation);<br class="title-page-name"/>        ScreenMat.SetFloat("_Contrast", contrast);<br class="title-page-name"/><br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture, ScreenMat);<br class="title-page-name"/>    }<br class="title-page-name"/>    else<br class="title-page-name"/>    {<br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Finally, all we need to do is clamp the values of the variables within a range that is reasonable. These clamp values are entirely preferential, so you can use whichever values you see fit:</li>
</ol>
<pre class="calibre62">void Update()<br class="title-page-name"/>{<br class="title-page-name"/>    brightness = Mathf.Clamp(brightness, 0.0f, 2.0f);<br class="title-page-name"/>    saturation = Mathf.Clamp(saturation, 0.0f, 2.0f);<br class="title-page-name"/>    contrast = Mathf.Clamp(contrast, 0.0f, 3.0f);<br class="title-page-name"/>}</pre>
<p class="calibre3">With the script completed and shader finished, we simply assign our script to our <span class="calibre6">Main Camera</span> and our shader to the script, and you should see the effects of brightness, saturation, and contrast by manipulating the property values:</p>
<div class="cdpaligncenter"><img src="../images/00190.jpeg" class="calibre25"/></div>
<p class="calibre3">The following screenshot shows a result you can achieve with this screen effect:</p>
<div class="cdpaligncenter"><img src="../images/00191.jpeg" class="calibre135"/></div>
<p class="calibre3">The following <span class="calibre6">screenshot</span> shows another example of what can be done by adjusting the colors of the render image:</p>
<div class="cdpaligncenter"><img src="../images/00192.gif" class="calibre136"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">Since we now know how the basic screen effects system works, let's just cover the per-pixel operations we created in the <kbd class="calibre13">ContrastSaturationBrightness()</kbd> function.</p>
<p class="calibre3">The function starts by taking a few arguments. The first and most important is the current <kbd class="calibre13"><span>RenderTexture</span></kbd>. The other arguments simply adjust the overall effect of the screen effect and are represented by sliders in the screen effect's <span class="calibre6">Inspector</span> tab. Once the function receives the <kbd class="calibre13"><span>RenderTexture</span></kbd> and the adjustment values, it declares a few constant values that we use to modify and compare against the original <kbd class="calibre13"><span>RenderTexture</span></kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">luminanceCoeff</kbd> variable stores the values that will give us the overall brightness of the current image. These coefficients are based on the CIE color matching functions and are pretty standard throughout the industry. We can find the overall brightness of the image by getting the dot product of the current image dotted with these luminance coefficients. Once we have the brightness, we simply use a couple of <kbd class="calibre13">lerp</kbd> functions to blend the grayscale version of the brightness operation and the original image, multiplied by the brightness value being passed into the function.</p>
<p class="calibre3">Screen effects such as this are crucial to achieving high-quality graphics for your games as they let you tweak the final look of your game without you having to edit each material in your current game scene.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using basic Photoshop-like Blend modes with screen effects</h1>
                
            
            <article>
                
<p class="calibre3">The screen effects aren't just limited to adjusting the colors of a rendered image from our game. We can also use them to combine other images with our <kbd class="calibre13">RenderTexture</kbd>. This technique is no different than creating a new layer in Photoshop and choosing a <span class="calibre6">Blend</span> mode to blend two images together or, in our case, a texture with a <kbd class="calibre13">RenderTexture</kbd>. This becomes a very powerful technique as it gives the artists in a production environment a way to simulate their blending modes in the game rather than just in Photoshop.</p>
<p class="calibre3">For this particular recipe, we are going to take a look at some of the more common blend modes, such as <span class="calibre6">Multiply</span>, <span class="calibre6">Add</span>, and <span class="calibre6">Overlay</span>. You will see how simple it is to have the power of Photoshop <span class="calibre6">Blend</span> modes in your game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">To begin, we have to get our assets ready. So let's follow the next few steps to get our screen effects system up and running for our new <span class="calibre6">Blend</span> mode screen effect:</p>
<ol class="calibre15">
<li value="1" class="calibre12">We will need another texture to perform our <span>Blend</span> mode effect. In this recipe, we will use a grunge-type texture. This will make the effect very obvious when we are testing it out.</li>
</ol>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">The following screenshot is the grunge map used in the making of this effect. Finding a texture with enough detail and a nice range of grayscale values will make for a nice texture to test our new effect:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00193.jpeg" class="calibre137"/></div>
<div class="packt_tip">The preceding texture is available in the example code for this book in <kbd class="calibre37">Chapter 9 </kbd>| <kbd class="calibre37">Textures</kbd> folder.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">The first <span class="calibre6">Blend</span> mode that we will implement is the <span class="calibre6">Multiply</span> blend mode as seen in Photoshop. Let's begin by modifying the code in our shader first:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new shader by duplicating the <kbd class="calibre13">ScreenGreyscale</kbd> code by selecting it from the<span> </span><span>Project</span><span> </span>tab under the <kbd class="calibre13">Chapter 9 </kbd>| <kbd class="calibre13">Shaders</kbd><span> </span>folder and pressing <em class="calibre2">Ctrl </em>+ <em class="calibre2">D.</em> Once duplicated, rename the script to <kbd class="calibre13">ScreenBlendMode</kbd>. Then, double-click on this shader to open it in your script editor.</li>
</ol>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">We need to add some new properties so that we have a texture to blend with and a slider for an opacity value. Enter the following code in your new shader:</li>
</ol>
<pre class="calibre62">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>  _BlendTex ("Blend Texture", 2D) = "white"{}<br class="title-page-name"/>  _Opacity ("Blend Opacity", Range(0,1)) = 1<br class="title-page-name"/>}</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Enter the corresponding variables in our <kbd class="calibre13">CGPROGRAM</kbd> so that we can access the data from our <kbd class="calibre13">Properties</kbd> block, replacing the previously created variables:</li>
</ol>
<pre class="calibre62">Pass<br class="title-page-name"/>{<br class="title-page-name"/>  CGPROGRAM<br class="title-page-name"/>  #pragma vertex vert_img<br class="title-page-name"/>  #pragma fragment frag<br class="title-page-name"/>  #pragma fragmentoption ARB_precision_hint_fastest<br class="title-page-name"/>  #include "UnityCG.cginc"<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  uniform sampler2D _MainTex;</strong><br class="title-page-name"/><strong class="calibre1">  uniform sampler2D _BlendTex;</strong><br class="title-page-name"/><strong class="calibre1">  fixed _Opacity;</strong></pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">We modify our <kbd class="calibre13">frag()</kbd> function so that it performs the multiply operation on our two textures:</li>
</ol>
<pre class="calibre62">fixed4 frag(v2f_img i) : COLOR<br class="title-page-name"/>{<br class="title-page-name"/>  //Get the colors from the RenderTexture and the uv's<br class="title-page-name"/>  //from the v2f_img struct<br class="title-page-name"/>  fixed4 renderTex = tex2D(_MainTex, i.uv);<br class="title-page-name"/>  fixed4 blendTex = tex2D(_BlendTex, i.uv);<br class="title-page-name"/>        <br class="title-page-name"/>  //Perform a multiply Blend mode<br class="title-page-name"/>  fixed4 blendedMultiply = renderTex * blendTex;<br class="title-page-name"/>        <br class="title-page-name"/>  //Adjust amount of Blend Mode with a lerp<br class="title-page-name"/>  renderTex = lerp(renderTex, blendedMultiply, _Opacity);<br class="title-page-name"/>        <br class="title-page-name"/>  return renderTex;<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Save the shader and return to the Unity editor to let the new shader code compile and check for errors. If no errors occurred, then we can move on to creating our script file.</li>
</ol>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Now that the shader is finished, let's work on the script needed to make the effect show up. From the <span>Project</span> tab, go to the <kbd class="calibre13">Chapter 09 </kbd>| <kbd class="calibre13">Scripts</kbd> folder. Once there, select the <kbd class="calibre13">TestRenderImage</kbd> script and duplicate it by pressing <em class="calibre2">Ctrl</em> + <em class="calibre2">D</em>. Rename the newly created script to <kbd class="calibre13">RenderBlendMode</kbd>. Once renamed, double-click on it to enter your IDE of choice.</li>
<li value="7" class="calibre12">Our first step in modifying our script is to rename the class to match our filename, <kbd class="calibre13">RenderBlendMode</kbd>:</li>
</ol>
<pre class="calibre62">[ExecuteInEditMode]<br class="title-page-name"/>public class RenderBlendMode : MonoBehaviour {</pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">In our script file, we need to create the corresponding variables. We will need a texture so that we can assign one to the shader and a slider to adjust the final amount of the Blend mode we want to use:</li>
</ol>
<pre class="calibre62">#region Variables<br class="title-page-name"/>public Shader curShader;<br class="title-page-name"/>public Texture2D blendTexture;<br class="title-page-name"/>public float blendOpacity = 1.0f;<br class="title-page-name"/>private Material screenMat;<br class="title-page-name"/>#endregion</pre>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">We then need to send our variable data to the shader through the <kbd class="calibre13">OnRenderImage()</kbd> function:</li>
</ol>
<pre class="calibre62">void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)<br class="title-page-name"/>{<br class="title-page-name"/>    if (curShader != null)<br class="title-page-name"/>    {<br class="title-page-name"/>        ScreenMat.SetTexture("_BlendTex", blendTexture);<br class="title-page-name"/>        ScreenMat.SetFloat("_Opacity", blendOpacity);<br class="title-page-name"/><br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture, ScreenMat);<br class="title-page-name"/>    }<br class="title-page-name"/>    else<br class="title-page-name"/>    {<br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ol start="10" class="calibre15">
<li value="10" class="calibre12">To complete the script, we simply fill in our <kbd class="calibre13">Update()</kbd> function so that we can clamp the value of the <kbd class="calibre13">blendOpacity</kbd> variable between a value of <kbd class="calibre13">0.0</kbd> and <kbd class="calibre13">1.0</kbd>:</li>
</ol>
<pre class="calibre62">void Update()<br class="title-page-name"/>{<br class="title-page-name"/>    blendOpacity = Mathf.Clamp(blendOpacity, 0.0f, 1.0f);<br class="title-page-name"/>}</pre>
<ol start="11" class="calibre15">
<li value="11" class="calibre12">With this complete, we assign the screen effect script to our <span>Main Camera</span> (remove the previous <kbd class="calibre13"><span>Render BSC</span></kbd> script if it is attached) and add our screen effect shader to our script so that it has a shader to use for the per-pixel operations. In order for the effect to be fully functional, the script and shader look for a texture. You can assign any texture to the <span>Texture</span> field in the <span>Inspector</span> for the screen effect script. Once this texture is in place, you will see the effect of multiplying this texture over the game's rendered screenshot:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00194.jpeg" class="calibre25"/></div>
<ol start="12" class="calibre15">
<li value="12" class="calibre12">The following screenshot demonstrates the screen effect with a smaller <kbd class="calibre13">Blend Opacity</kbd> option:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00195.jpeg" class="calibre138"/></div>
<p class="calibre3">With our first blend mode set up, we can begin to add a couple of simpler blend modes to get a better understanding of how easy it is to add more effects and really fine-tune the final result in your game. However, first let's break down what is happening here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">Now we are starting to gain a ton of power and flexibility in our screen effects programming. I am sure that you are now starting to understand how much you can do with this simple system in Unity. We can literally replicate the effects of Photoshop layer blending modes in our game to give artists the flexibility they need to achieve high-quality graphics in a short amount of time.</p>
<p class="calibre3">With this particular recipe, we look at how to multiply two images together, add two images together, and perform a screen blending mode, using just a little bit of mathematics. When working with Blend modes, you have to think on a per-pixel level. For instance, when we are using the multiply blend mode, we literally take each pixel from the original <kbd class="calibre13"><span>RenderTexture</span></kbd> and multiply it by each pixel of the Blend texture. The same goes for the add Blend mode. It is just a simple mathematical operation of adding each pixel from the source texture, or <kbd class="calibre13"><span>RenderTexture</span></kbd>, to the Blend texture.</p>
<p class="calibre3">The screen Blend mode is definitely a bit more involved, but it is actually doing the same thing. It takes each image, <kbd class="calibre13"><span>RenderTexture</span></kbd>, and Blend texture, inverts them, then multiplies them together, and inverts them again to achieve the final look. Just as Photoshop blends its textures together using blend modes, we can do the same with screen effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            <article>
                
<p class="calibre3">Let's continue this recipe by adding a couple more blend modes to our screen effect:</p>
<ol class="calibre15">
<li value="1" class="calibre12">In the screen effect shader, let's add the following code to our <kbd class="calibre13">frag()</kbd> function and change the value we are returning to our script. We will also need to comment out the multiply blend so that we don't return that as well:</li>
</ol>
<pre class="calibre62">fixed4 frag(v2f_img i) : COLOR<br class="title-page-name"/>{<br class="title-page-name"/>  //Get the colors from the RenderTexture and the uv's<br class="title-page-name"/>  //from the v2f_img struct<br class="title-page-name"/>  fixed4 renderTex = tex2D(_MainTex, i.uv);<br class="title-page-name"/>  fixed4 blendTex = tex2D(_BlendTex, i.uv);<br class="title-page-name"/>        <br class="title-page-name"/>  //Perform a multiply Blend mode<br class="title-page-name"/><strong class="calibre1">  //fixed4 blendedMultiply = renderTex * blendTex;</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  //Perform an additive Blend mode</strong><br class="title-page-name"/><strong class="calibre1">  fixed4 blendedAdd = renderTex + blendTex;</strong><br class="title-page-name"/>        <br class="title-page-name"/>  //Adjust amount of Blend Mode with a lerp<br class="title-page-name"/>  renderTex = lerp(renderTex, <strong class="calibre1">blendedAdd</strong>, _Opacity);<br class="title-page-name"/>        <br class="title-page-name"/>  return renderTex;<br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Save the shader file in your IDE of choice and <kbd class="calibre13">MonoDevelop</kbd> and return to the Unity editor to let the shader compile. If no errors occurred, you should see a result similar to the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00196.jpeg" class="calibre25"/></div>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">This is a simple add blending mode with a figure of <kbd class="calibre13">0.5</kbd> set for the <kbd class="calibre13">Blend Opacity</kbd>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00197.jpeg" class="calibre139"/></div>
<div class="packt_tip1"> As you can see, this has the opposite effect of multiply because we are adding the two images together.</div>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Finally, let's add one more blend mode called a screen blend. This one is a little bit more involved, from a mathematical standpoint, but still simple to implement. Enter the following code in the <kbd class="calibre13">frag()</kbd> function of our shader:</li>
</ol>
<pre class="calibre18">    fixed4 frag(v2f_img i) : COLOR<br class="title-page-name"/>    {<br class="title-page-name"/>      //Get the colors from the RenderTexture and the uv's<br class="title-page-name"/>      //from the v2f_img struct<br class="title-page-name"/>      fixed4 renderTex = tex2D(_MainTex, i.uv);<br class="title-page-name"/>      fixed4 blendTex = tex2D(_BlendTex, i.uv);<br class="title-page-name"/>        <br class="title-page-name"/>      //Perform a multiply Blend mode<br class="title-page-name"/>      //fixed4 blendedMultiply = renderTex * blendTex;<br class="title-page-name"/><br class="title-page-name"/>      //Perform an additive Blend mode<br class="title-page-name"/><strong class="calibre1">      //fixed4 blendedAdd = renderTex + blendTex;</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">      //Perform screen blending mode</strong><br class="title-page-name"/><strong class="calibre1">      fixed4 blendedScreen = (1.0 - ((1.0 - renderTex) * (1.0 - blendTex)));</strong><br class="title-page-name"/>        <br class="title-page-name"/>      //Adjust amount of Blend Mode with a lerp<br class="title-page-name"/>      renderTex = lerp(renderTex, <strong class="calibre1">blendedScreen</strong>, _Opacity);<br class="title-page-name"/>        <br class="title-page-name"/>      return renderTex;<br class="title-page-name"/>    }<br class="title-page-name"/>    </pre>
<p class="calibre3">The following screenshot demonstrates the results of using a screen type Blend mode to blend two images together in a screen effect:</p>
<div class="cdpaligncenter"><img src="../images/00198.jpeg" class="calibre25"/></div>
<p class="calibre3">Here's a screenshot displaying the effect:</p>
<div class="cdpaligncenter"><img src="../images/00199.jpeg" class="calibre140"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the Overlay Blend mode with screen effects</h1>
                
            
            <article>
                
<p class="calibre3">For our final recipe, we are going to take a look at another type of blend mode, the Overlay Blend mode. This blend mode actually makes use of some conditional statements that determine the final color of each pixel in each channel. So, the process of using this type of blend mode requires a bit more coding to work. Let's take a look at how this is done in the next few recipes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">To begin our Overlay Screen effect, we will need to get the code of our shader up and running without errors. We can then modify our script file to feed the correct data to the shader:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new shader by duplicating the<span> </span><kbd class="calibre13">ScreenGreyscale</kbd><span> </span>code and selecting it from the<span> </span><span>Project</span><span> </span>tab under the <kbd class="calibre13">Chapter 9 </kbd>| <kbd class="calibre13">Shaders</kbd><span> </span>folder and pressing <em class="calibre2">Ctrl</em> + <em class="calibre2">D</em>. Once duplicated, rename the script to <kbd class="calibre13">ScreenOverlay</kbd>. Then, double-click on this shader to open it in your script editor.</li>
<li value="2" class="calibre12">We first need to set up the properties in our <kbd class="calibre13">Properties</kbd> block. We will use the same properties from the previous few recipes in this chapter:</li>
</ol>
<pre class="calibre62">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>  _BlendTex ("Blend Texture", 2D) = "white"{}<br class="title-page-name"/>  _Opacity ("Blend Opacity", Range(0,1)) = 1<br class="title-page-name"/>}</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">We then need to create the corresponding variables in our <kbd class="calibre13">CGPROGRAM</kbd>, removing the previously created ones:</li>
</ol>
<pre class="calibre62">Pass<br class="title-page-name"/>{<br class="title-page-name"/>  CGPROGRAM<br class="title-page-name"/>  #pragma vertex vert_img<br class="title-page-name"/>  #pragma fragment frag<br class="title-page-name"/>  #pragma fragmentoption ARB_precision_hint_fastest<br class="title-page-name"/>  #include "UnityCG.cginc"<br class="title-page-name"/>      <br class="title-page-name"/>  uniform sampler2D _MainTex;<br class="title-page-name"/>  uniform sampler2D _BlendTex;<br class="title-page-name"/>  fixed _Opacity;</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">In order for the Overlay Blend effect to work, we will have to process each pixel from each channel individually. To do this in a shader, we have to write a custom function that will take in a single channel, for instance, the red channel, and perform the overlay operation. Enter the following code in the shader just below the variable declarations:</li>
</ol>
<pre class="calibre62">fixed OverlayBlendMode(fixed basePixel, fixed blendPixel)<br class="title-page-name"/>{<br class="title-page-name"/>  if(basePixel &lt; 0.5)<br class="title-page-name"/>  {<br class="title-page-name"/>    return (2.0 * basePixel * blendPixel);<br class="title-page-name"/>  }<br class="title-page-name"/>  else<br class="title-page-name"/>  {<br class="title-page-name"/>    return (1.0 - 2.0 * (1.0 - basePixel) * (1.0 - blendPixel));<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">We need to update our <kbd class="calibre13">frag()</kbd> function to process each channel of our textures in order to perform the blending:</li>
</ol>
<pre class="calibre62">fixed4 frag(v2f_img i) : COLOR<br class="title-page-name"/>{<br class="title-page-name"/>  //Get the colors from the RenderTexture and the uv's<br class="title-page-name"/>  //from the v2f_img struct<br class="title-page-name"/>  fixed4 renderTex = tex2D(_MainTex, i.uv);<br class="title-page-name"/>  fixed4 blendTex = tex2D(_BlendTex, i.uv);<br class="title-page-name"/>        <br class="title-page-name"/>  fixed4 blendedImage = renderTex;<br class="title-page-name"/>        <br class="title-page-name"/>  blendedImage.r = OverlayBlendMode(renderTex.r, blendTex.r);<br class="title-page-name"/>  blendedImage.g = OverlayBlendMode(renderTex.g, blendTex.g);<br class="title-page-name"/>  blendedImage.b = OverlayBlendMode(renderTex.b, blendTex.b);<br class="title-page-name"/>        <br class="title-page-name"/>  //Adjust amount of Blend Mode with a lerp<br class="title-page-name"/>  renderTex = lerp(renderTex, blendedImage, _Opacity);<br class="title-page-name"/>        <br class="title-page-name"/>  return renderTex;<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">With the code completed in the shader, our effect should be working. Save the shader and return to the Unity editor to let the shader compile. Our script is already set up; select the <span>Main Camera</span> object. From the <span>Project</span> tab, drag and drop the <span>ScreenOverlay</span> shader onto the <kbd class="calibre13">Cur Shader</kbd> property from the <span>Render Blend Mode</span> component in the <span>Inspector</span> tab. Once the shader compiles, you should see a result similar to the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00200.jpeg" class="calibre25"/></div>
<p class="calibre3">Here's a screenshot using a <span class="calibre6">Blend Opacity</span> of <kbd class="calibre13">0.5</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00201.jpeg" class="calibre141"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">Our overlay blend mode is definitely a lot more involved, but if you really break down the function, you will notice that it is simply a multiply blend mode and screen blend mode. In this case, we are doing a conditional check to apply one or the other blend mode to a pixel.</p>
<p class="calibre3">With this particular screen effect, when the overlay function receives a pixel, it checks to see whether it is less than <kbd class="calibre13">0.5</kbd>. If it is, then we apply a modified multiply blend mode to that pixel; if it's not, then we apply a modified screen blend mode to the pixel. We do this for each pixel for each channel, giving us the final RGB pixel values for our screen effect.</p>
<p class="calibre3">As you can see, there are many things that can be done with screen effects. It really just depends on the platform and amount of memory you have allocated for screen effects. Usually, this is determined throughout the course of a game project, so have fun and get creative with your screen effects.</p>


            </article>

            
        </section>
    </body></html>