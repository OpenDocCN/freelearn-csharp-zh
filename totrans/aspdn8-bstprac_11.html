<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-232"><a id="_idTextAnchor244"/>11</h1>
<h1 id="_idParaDest-233"><a id="_idTextAnchor245"/>Appendix</h1>
<p>When writing code, every language has its nuances and standards. .NET is no different when it comes to general guidelines. One example is that placing a bracket at the end of a method signature is better than placing the bracket on the next line or placing a return immediately on the same line as an <code>if</code> statement. This is more of a personal preference. Programming guidelines give developers a way to stay between guardrails while writing code. These programming guidelines are used throughout the industry as standard practices.</p>
<p>In the appendix, we’re going to cover the following main topics:</p>
<ul>
<li>Programming guidelines</li>
<li>Project structure</li>
</ul>
<p>The guidelines discussed in the following sections are commonly used in the industry. They give developers direction and provide guardrails as to how one should structure and write code not only for themselves, but also for other developers and peers in the future (including our future selves).</p>
<p>In the first section, we’ll review some programming guidelines such as the DRY, YAGNI, and KISS principles, along with separation of concerns, the concept of SOLID, and how refactoring is a process and not a one-time quick fix. We’ll finish the appendix by looking at recommended ways of organizing .NET projects and folder structures, and where code resides based on their function.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor246"/>Technical requirements</h1>
<p>The only technical requirement for the appendix is access to your editor since we’ll be covering general programming guidelines. While we will have snippets of code along the way, they don’t justify their own code repository. They’re only meant to solidify the understanding of the concepts.</p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor247"/>Programming guidelines</h1>
<p>Throughout the book, I recommend <a id="_idIndexMarker664"/>various intermediate and advanced techniques of writing code pertaining to a particular topic or technology. While these techniques are meant to give developers a balance between requirements and technologies, there is also a need to provide common programming guidelines to follow certain patterns, making it easier for colleagues and peers to understand a code base. Successful developers think about these guidelines while writing and maintaining code.</p>
<p>In this section, we’ll review the DRY, YAGNI, KISS, and SOLID principles along with understanding separation of concerns, and how refactoring is a process.</p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor248"/>DRY</h2>
<p>The first acronym <a id="_idIndexMarker665"/>we’ll review is probably one of the simplest<a id="_idIndexMarker666"/> guidelines to follow. The <strong class="bold">DRY</strong> principle stands for <strong class="bold">don’t </strong><strong class="bold">repeat yourself</strong>.</p>
<p>If you have multiple methods performing the same task in different locations of your application, it may be time to refactor and consolidate the code.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor249"/>YAGNI</h2>
<p>Our next <a id="_idIndexMarker667"/>common acronym is <strong class="bold">YAGNI</strong> (pronounced<a id="_idIndexMarker668"/> yag-nee), which stands for <strong class="bold">you aren’t gonna </strong><strong class="bold">need it</strong>.</p>
<p>Also referred to as “building the bridge to nowhere,” the concept behind this acronym is to let developers know they should only write code when there is a requirement for it. They shouldn’t add code for a possible future enhancement that may not come to fruition.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor250"/>KISS</h2>
<p>Since this next<a id="_idIndexMarker669"/> acronym has so many meanings, we’ll try to<a id="_idIndexMarker670"/> keep it simple (hence the name). <strong class="bold">KISS</strong> stands for <strong class="bold">keep it </strong><strong class="bold">simple, stupid</strong>.</p>
<pre class="source-code">
Albert Einstein mentioned "Make everything as simple as possible, but not simpler," and Steve Jobs of Apple always said, "Simplify."</pre> <p>Keep your units of code simple enough to understand. This can include the following:</p>
<ul>
<li><strong class="bold">Smaller methods</strong> – The smaller the method, the easier it is to read and understand</li>
<li><strong class="bold">Language enhancements</strong> – Based on .NET’s C# language improvements over the years, there may be a better (and shorter) way to write code</li>
<li><strong class="bold">Reducing complexity</strong> – When reducing complexity, systems become more testable <a id="_idIndexMarker671"/>and can be a possible candidate for automated<a id="_idIndexMarker672"/> testing</li>
</ul>
<p>The goal is to build more value by creating a better code base for peers and colleagues.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor251"/>Separation of concerns</h2>
<p>When you started <a id="_idIndexMarker673"/>writing your own application, running it and seeing it execute on the screen for the first time was a huge achievement.</p>
<p>Over time, the application required a database. Then it required email capabilities. Then logging. Then authentication. The requirements grew and so on and so on.</p>
<p>The separation of concerns concept pertains to how you logically partition an application into distinct layers. For example, if an application requires an email module, it would be a separate project in the solution called <code>MyApplication.EmailModule</code>. This email module would provide the following benefits to the application:</p>
<ul>
<li><code>EmailModule</code> could be reused in another application if necessary.</li>
<li><code>EmailModule</code> doesn’t require any outside dependencies; it’s self-contained.</li>
<li><code>EmailModule</code>, unit testing (and possibly integration testing) becomes easier.</li>
<li><code>EmailModule</code> as opposed to the entire application. When focusing on one particular section, it doesn’t require the knowledge of the entire application. The knowledge of the project is all that’s required.</li>
</ul>
<p>One of the concepts heard in the industry is “Big Ball of Mud.” This concept pertains to all of the application code contained in one project, which is an unmaintainable code base. This is a similar concept to a “monolith,” where the application is hard to maintain because of its size. Consequently, concepts in the application aren’t broken out into modular units of work. If everything in the application is coupled together…everywhere, the system is brittle. If a developer modifies code in one location, it may fix the current issue but it will introduce errors in other locations, causing a ripple effect throughout the entire code base.</p>
<p>Separation of <a id="_idIndexMarker674"/>concerns is something that experienced developers should share with their peers through code reviews to improve software on a larger scale and provide healthy discussions on the topic.</p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor252"/>Refactoring as a process</h2>
<p>While refactoring is a<a id="_idIndexMarker675"/> fundamental concept for developers, there are various levels of effort involved in refactoring a code base.</p>
<p>One simple example could be the renaming of a method. Once a developer renames a method, the developer has to change all of the references to that method in the code base. A more advanced example is the refactoring of a business rules engine to create more flexibility. While both are refactoring, one is easier than the other.</p>
<p>Refactoring should be a process. One process I’ve used over the years is as follows:</p>
<ul>
<li><strong class="bold">Get it functional</strong> – Write functional code that works</li>
<li><strong class="bold">Get it tested</strong> – Create tests to confirm the code behaves as expected</li>
<li><strong class="bold">Get it refactored</strong> – Refactor and optimize the code</li>
</ul>
<p>The code you write should (usually) have tests (see the “100% Test Coverage” myth in <a href="B19493_07.xhtml#_idTextAnchor163"><em class="italic">Chapter 7</em></a>).</p>
<p>With that said, if you’re going to refactor code, <em class="italic">it will be beneficial to have tests in place</em> to confirm your refactoring efforts aren’t in vain. Once you have tests in place, you are free to refactor and modify as much code as needed to achieve your intended goal.</p>
<p>The business rules engine was an example in my career where the code was functional and a lot of tests were in place (~700 passed). However, the team ran into an issue where the code required a more flexible approach and it had to be refactored. Two team members took three days to refactor the code. Once they finished the refactoring, they ran the final unit tests and found only two failed unit tests. The two failed unit tests were because they didn’t rename a method name properly. Imagine this refactoring without the tests.</p>
<p>Refactoring can be as complex or as simple as the code base allows. Always keep in mind that refactoring is a multi-step process and requires tests to confirm the refactored <a id="_idIndexMarker676"/>code works as expected.</p>
<p class="callout-heading">Book recommendation</p>
<p class="callout">One book I would highly recommend is <em class="italic">Refactoring with C#, Matt Eland, Packt Publishing</em>, available at <a href="https://www.packtpub.com/">https://www.packtpub.com/</a>.</p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor253"/>SOLID principles</h2>
<p><strong class="bold">SOLID</strong> principles <a id="_idIndexMarker677"/>provide even deeper guidelines for <a id="_idIndexMarker678"/>writing code. SOLID is an acronym and was created back in 2000 by Robert C. Martin.</p>
<p>Over the years, the SOLID principles have become a standard for writing quality software, and give developers a way to gauge their code based on whether it meets each principle’s criteria. Developers may disagree with what constitutes SOLID code, but again, these discussions should be had with peers or in a team meeting.</p>
<h3>Single responsibility principle</h3>
<p>The <strong class="bold">single responsibility principle</strong> (<strong class="bold">SRP</strong>) dictates<a id="_idIndexMarker679"/> that <a id="_idIndexMarker680"/>a class should have one and only one reason to change.</p>
<p>The following code violates the SRP:</p>
<pre class="source-code">
public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
    public bool IsValid()
    {
        // Validate the user data here
        if (string.IsNullOrEmpty(Name) || string.IsNullOrEmpty(Email))
        {
            return false;
        }
        return true;
    }
    public void Save()
    {
        // Save user data to database here
    }
}</pre> <p>The <code>User</code> class<a id="_idIndexMarker681"/> has<a id="_idIndexMarker682"/> two properties: <code>Name</code> and <code>Email</code>. However, we have extra methods performing other responsibilities: an <code>IsValid()</code> method and a <code>Save()</code> method. Our <code>User</code> class is doing more than it should. We should create two new classes: one called <code>UserValidation</code> for validation, and one called <code>UserService</code> or <code>UserRepository</code> for database operations.</p>
<p>We created two additional classes but provided better software composition. If we add a new property to the <code>User</code> class and it requires validation, the developer only needs to make a change in one place: the <code>UserValidation</code> class.</p>
<h3>Open/closed</h3>
<p>The <strong class="bold">open/closed principle</strong> describes<a id="_idIndexMarker683"/> how software <a id="_idIndexMarker684"/>components should be open for extension but closed for modification.</p>
<p>Most violations of the open/closed principle are usually indicated by long branching statements (such<a id="_idTextAnchor254"/> as long <code>if..then</code> or <code>switch</code> statements).</p>
<p>The following code provides an example:</p>
<pre class="source-code">
public class ComicBook
{
    public string Title { get; set; } = string.Empty;
    public string Issue { get; set; } = string.Empty;
    public decimal Grading { get; set; }
    public string GetGradeName() =&gt;
        Grading switch
        {
            10.0m =&gt; "Gem Mint", 
            9.9m =&gt; "Mint", 
            9.8m =&gt; "NM/M", 
            &gt;= 9.6m =&gt; "NM+", 
            &gt;= 9.4m =&gt; "NM", 
            &gt;= 9.2m =&gt; "NM-", 
            &gt;= 9.0m =&gt; "VF/NM", 
            &gt;= 8.5m =&gt; "VF+", 
            &gt;= 8.0m =&gt; "VF", 
            &gt;= 7.5m =&gt; "VF-", 
            &gt;= 7.0m =&gt; "FN/VF", 
            &gt;= 6.5m =&gt; "FN+", 
            &gt;= 6.0m =&gt; "FN", 
            &gt;= 5.5m =&gt; "FN-", 
            &gt;= 5.0m =&gt; "VG/FN", 
            &gt;= 4.5m =&gt; "VG+", 
            &gt;= 4.0m =&gt; "VG", 
            &gt;= 3.5m =&gt; "VG-", 
            &gt;= 3.0m =&gt; "G/VG", 
            &gt;= 2.0m =&gt; "G", 
            &gt;= 1.8m =&gt; "G-", 
            &gt;= 1.5m =&gt; "Fa/G", 
            &gt;= 1.0m =&gt; "Fa", 
            _ =&gt; "Poor"
        };
}</pre> <p>In this <code>ComicBook</code> class, we have three properties called <code>Title</code>, <code>Issue</code>, and <code>Grading</code>. One of the requirements for our class is to return the grading name based on the <code>Grading</code> property. This <a id="_idIndexMarker685"/>violates the open/closed <a id="_idIndexMarker686"/>principle.</p>
<p>Why? Even though we already have the complete list of grades, the <code>GetGradeName()</code> method and add a new grade and name.</p>
<p>A better implementation to support the open/closed principle is as follows:</p>
<pre class="source-code">
public class Grade
{
    public decimal Value { get; }
    public string Name { get; }
    private Grade(decimal value, string name)
    {
        Value = value;
        Name = name;
    }
    public static Grade FromDecimal(decimal value) =&gt;
        value switch
        {
            10.0m =&gt; new Grade(value, "Gem Mint"),
            9.9m =&gt; new Grade(value, "Mint"),
            9.8m =&gt; new Grade(value, "NM/M"),
            &gt;= 9.6m =&gt; new Grade(value, "NM+"),
            &gt;= 9.4m =&gt; new Grade(value, "NM"),
            &gt;= 9.2m =&gt; new Grade(value, "NM-"),
            &gt;= 9.0m =&gt; new Grade(value, "VF/NM"),
            &gt;= 8.5m =&gt; new Grade(value, "VF+"),
            &gt;= 8.0m =&gt; new Grade(value, "VF"),
            &gt;= 7.5m =&gt; new Grade(value, "VF-"),
            &gt;= 7.0m =&gt; new Grade(value, "FN/VF"),
            &gt;= 6.5m =&gt; new Grade(value, "FN+"),
            &gt;= 6.0m =&gt; new Grade(value, "FN"),
            &gt;= 5.5m =&gt; new Grade(value, "FN-"),
            &gt;= 5.0m =&gt; new Grade(value, "VG/FN"),
            &gt;= 4.5m =&gt; new Grade(value, "VG+"),
            &gt;= 4.0m =&gt; new Grade(value, "VG"),
            &gt;= 3.5m =&gt; new Grade(value, "VG-"),
            &gt;= 3.0m =&gt; new Grade(value, "G/VG"),
            &gt;= 2.0m =&gt; new Grade(value, "G"),
            &gt;= 1.8m =&gt; new Grade(value, "G-"),
            &gt;= 1.5m =&gt; new Grade(value, "Fa/G"),
            &gt;= 1.0m =&gt; new Grade(value, "Fa"),
            _ =&gt; new Grade(value, "Poor")
        };
}
public class ComicBook
{
    public string Title { get; set; } = string.Empty;
    public string Issue { get; set; } = string.Empty;
    public Grade Grading { get; set; }
}</pre> <p>While it looks like we simply moved the <code>switch</code> statement, we did something else. We created a <code>Grade</code> class.</p>
<p>With a <code>Grade</code> class created, we can assign any type of grade to the <code>ComicBook</code> class. If a new grade type is created, we can easily add it to our list without modifying the <code>ComicBook</code> class. We also implemented a factory pattern in our code.</p>
<p>Before, we <a id="_idIndexMarker688"/>were<a id="_idIndexMarker689"/> comparing a string based on a decimal value. Now, if additional properties are required for a grade, we can extend our <code>Grade</code> class to include more information.</p>
<p>Open for extension, closed to modification.</p>
<h3>Liskov substitution</h3>
<p>The <strong class="bold">Liskov substitution principle</strong> explains<a id="_idIndexMarker690"/> that any<a id="_idIndexMarker691"/> derived type can be replaced with its base types. The concept behind the Liskov substitution is based on inherited types and/or interfaces.</p>
<p>To continue with our comic book example, the following code shows a simple <code>BasePublisher</code> class:</p>
<pre class="source-code">
public class MyNewPublisher : BasePublisher
{
    public MyNewPublisher(): base(nameof(MyNewPublisher)) { }
}
public class BasePublisher
{
    public string Name { get; set; }
    protected BasePublisher(string name)
    {
        Name = name;
    }
    public Address GetAddress()
    {
        return Address.Empty;
    }
}
public class Address
{
    public static Address Empty =&gt; new();
    public string Address1 { get; set; } = string.Empty;
    public string Address2 { get; set; } = string.Empty;
    public string City { get; set; } = string.Empty;
    public string State { get; set; } = string.Empty;
    public string ZipCode { get; set; } = string.Empty;
}</pre> <p>The <code>BasePublisher</code> class contains the name and address of a publisher. When we create a new publisher (such as the preceding <code>MyNewPublisher</code> class), we’ll have access to everything available in the base class.</p>
<p>The ability <a id="_idIndexMarker692"/>to<a id="_idIndexMarker693"/> replace a <code>BasePublisher</code> class with a <code>MyNewPublisher</code> class would be an example of the Liskov substitution principle.</p>
<h3>Interface segregation</h3>
<p>The <strong class="bold">interface segregation principle</strong> explains<a id="_idIndexMarker694"/> that clients<a id="_idIndexMarker695"/> shouldn’t be forced to implement unnecessary methods they won’t use.</p>
<p>With every interface created in an application, each method and property defined should be implemented in a concrete class. The defined interfaces should not go to waste in an implementation.</p>
<p>For example, let’s say we have an interface for our <code>ComicBook</code> class. The interface and implementation code are listed as follows:</p>
<pre class="source-code">
public interface IComicBook
{
    string Title { get; set; }
    string Issue { get; set; }
    string Publisher { get; set; }
    void SaveToDatabase();
}
public class ComicBook : IComicBook
{
    public string Title { get; set; }
    public string Issue { get; set; }
    public string Publisher { get; set; }
    public void SaveToDatabase()
    {
        throw new NotImplementedException();
    }
}</pre> <p>Everything in our <code>ComicBook</code> class is justified except for the <code>SaveToDatabase()</code> method. Creating a new <code>ComicBook</code> instance suggests we’ll be using the database every time. This violates the interface segregation principle.</p>
<p>A better implementation would be splitting the database access out into an <code>IComicBookWriter</code> with <a id="_idIndexMarker696"/>a <code>SaveToDatabase()</code> method, as <a id="_idIndexMarker697"/>shown in the following code:</p>
<pre class="source-code">
public interface IComicBook
{
    string Title { get; set; }
    string Issue { get; set; }
    string Publisher { get; set; }
}
public interface IComicBookWriter
{
    void SaveToDatabase();
}
public class ComicBook : IComicBook, IComicBookWriter
{
    public string Title { get; set; }
    public string Issue { get; set; }
    public string Publisher { get; set; }
    public void SaveToDatabase()
    {
        // Implementation
    }
}</pre> <p>The example code shows how inheriting from the <code>IComicBookWriter</code> gives the <code>ComicBook</code> class a way to persist the data.</p>
<p>The goal of the<a id="_idIndexMarker698"/> interface segregation principle <a id="_idIndexMarker699"/>is to avoid including methods in an interface that you won’t use.</p>
<p>This example is also a violation of the SRP since this class is also accessing the database.</p>
<h3>Dependency inversion</h3>
<p>The <strong class="bold">dependency inversion principle</strong> explains that we should depend on abstractions<a id="_idIndexMarker700"/> and not on concrete<a id="_idIndexMarker701"/> implementations. With .NET, dependency injection is available out of the box. With dependency injection automatically available, this satisfies half of our dependency inversion principle.</p>
<p>While we can dependency-inject concrete classes into constructors, a better implementation would be to create an interface for the concrete implementation. Using interfaces encourages loose coupling throughout our code base.</p>
<p>For example, back in <a href="B19493_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a> with Entity Framework, we created a simple interface for our <code>DbContext</code>s for this very reason. Instead of registering a concrete implementation of a <code>DbContext</code>, we could use its interface instead.</p>
<p>We registered our abstraction (interface) to support our dependency inversion principle.</p>
<p>In this section, the terms DRY, YAGNI, and KISS, along with what separation of concerns means and how refactoring is a process and not a single task. We finished the section by learning each SOLID practice, namely the single responsibility, open/closed, Liskov substitution, interface <a id="_idIndexMarker702"/>segregation, and <a id="_idIndexMarker703"/>dependency inversion principles.</p>
<p>In the next section, we’ll learn about folder organization based on project types.</p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor255"/>Project structure</h1>
<p>As mentioned in <a href="B19493_07.xhtml#_idTextAnchor163"><em class="italic">Chapter 7</em></a>, on testing, folder structures can reveal an application’s intent and<a id="_idIndexMarker704"/> provide documentation as well.</p>
<p>In this section, we’ll learn about folder structures with ASP.NET web applications. We’ll also learn where to place code based on intent, such as where to place API code or Entity Framework code.</p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor256"/>Understanding the project landscape</h2>
<p>Every project<a id="_idIndexMarker705"/> has its own structure based on its type. For example, a <strong class="bold">Razor Page</strong> project layout is<a id="_idIndexMarker706"/> different from a <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) project or <a id="_idIndexMarker707"/>an API project.</p>
<p>Let’s examine what folders are in these common projects.</p>
<p>First, the following is an example of an ASP.NET Razor Page project:</p>
<div><div><img alt="Figure 11.1 – Common folder structure of a Razor Page project" src="img/B19493_11_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Common folder structure of a Razor Page project</p>
<p>Next is an <a id="_idIndexMarker708"/>example of an ASP.NET MVC project:</p>
<div><div><img alt="Figure 11.2 - Common folder structure of an MVC project" src="img/B19493_11_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 - Common folder structure of an MVC project</p>
<p>As we move<a id="_idIndexMarker709"/> through each project, we’ll explain what each folder does and its purpose in the application.</p>
<h3>wwwroot folder</h3>
<p>In either of the <a id="_idIndexMarker710"/>preceding project types, the <code>wwwroot</code> folder <a id="_idIndexMarker711"/>contains all of our static content used on the website. Any folder added to this directory is static content and visible to the browser.</p>
<p>One example is an images folder. If we added an images folder to the <code>wwwroot</code> folder, the URL to that images folder would look like the following:</p>
<pre class="source-code">
https://localhost:xxx/images/funnyimage.jpg</pre> <p>For JavaScript frameworks (such as Angular, React, etc.), a folder called <code>source</code> or <code>src</code> should be created under the <code>wwwroot</code> folder to hold your client-side source code. The JavaScript framework should be transpiled to another folder of your choosing, such as a <code>js</code> or <code>app</code> folder for public browser consumption. We touched on these folders in <a href="B19493_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a> when we <a id="_idIndexMarker712"/>were building our client-side tasks using<a id="_idIndexMarker713"/> a task runner.</p>
<h3>Pages folder</h3>
<p>In a Razor Page<a id="_idIndexMarker714"/> project, the <code>Pages</code> folder is where server-side<a id="_idIndexMarker715"/> pages are found. Every folder created is a path to a page.</p>
<p>For example, if we created a <code>Setup</code> folder and added an <code>Index.cshtml</code> file, the URL to execute and view that page would look like the following:</p>
<pre class="source-code">
https://localhost:xxx/setup/</pre> <p>Other folders created under the <code>Pages</code> directory would follow the same path, as shown in <em class="italic">Figure 11</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 11.3 – Folder structure for a MenuManager page" src="img/B19493_11_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Folder structure for a MenuManager page</p>
<p>Based on the directory structure in <em class="italic">Figure 11</em><em class="italic">.3</em>, the URL to <strong class="bold">MenuManager</strong> would be as follows:</p>
<pre class="source-code">
https://localhost:xxx/setup/menumanager/</pre> <p>The simpler the<a id="_idIndexMarker716"/> folder structure, the easier it is to locate a page<a id="_idIndexMarker717"/> and identify page functionality.</p>
<h3>Shared folder</h3>
<p>The <code>Shared</code> folder is <a id="_idIndexMarker718"/>used for common components such as<a id="_idIndexMarker719"/> layout pages, <code>ViewComponents</code>, partials, <code>EditorTemplates</code>, and <code>DisplayTemplates</code>. These shared components are accessible through web pages in the <code>Pages</code> folder (if it’s a Razor Pages project) or the <code>Views</code> folder (if it’s an MVC project).</p>
<h3>Controllers folder</h3>
<p>MVC projects <a id="_idIndexMarker720"/>always contain a <code>Controllers</code> folder <a id="_idIndexMarker721"/>and are the traffic cops of the web application.</p>
<p>The MVC web model uses a “convention over configuration” concept where the name of the controller is the path and the methods inside the controller class are the page names.</p>
<p>For example, in the aforementioned <code>Controllers</code> folder, we have a class called <code>HomeController</code>. If we look in <code>HomeController</code>, we’ll see a method called <code>Index()</code>:</p>
<pre class="source-code">
public class HomeController : Controller
{
    public IActionResult Index()
    {
        return View();
    }
}</pre> <p>The presence of a <code>HomeController</code> class tells us three things:</p>
<ul>
<li>We will have a <code>/Home</code> URL with an <code>Index()</code> method for a default page</li>
<li>A <code>Home</code> folder is located under the <code>/</code><code>Views</code> folder</li>
<li>Since there is an <code>Index()</code> method in <code>HomeController</code>, there should be an <code>Index.cshtml</code> in the <code>/</code><code>Views/Home</code> directory</li>
</ul>
<p>The <code>Index()</code> method tells us when the <code>https://localhost:xxx/Home</code> URL is called. It will <a id="_idIndexMarker722"/>automatically hit this <code>Index()</code> method <a id="_idIndexMarker723"/>and, by default, look for the Index view in the <code>/</code><code>Views/Home</code> directory.</p>
<h3>Feature folders</h3>
<p>One of the secrets <a id="_idIndexMarker724"/>of an MVC application is the ability to move<a id="_idIndexMarker725"/> controllers around to any folder inside the application. On initial startup, the ASP.NET framework locates all of the controllers available throughout the application and creates a routing table for incoming web requests. Based on this approach, developers in the community have created <strong class="bold">feature folders</strong>.</p>
<p>Feature folders are usually contained in a folder called <code>/Features</code> off the root with folders underneath to identify the feature implemented. While a <code>/Features</code> folder is the most common, developers have the ability to name the folder anything they want. They can also place controllers under any folder in the project. ASP.NET can locate all of the controllers on startup.</p>
<p>These folders usually contain a minimum of a controller, a ViewModel, and a View. They can also contain supporting classes related to the feature. The folder is named based on the feature being implemented.</p>
<p>For example, if there was an image viewing feature in your MVC application, it would look like <em class="italic">Figure 11</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 11.4 – Example of an ImageViewer feature folder" src="img/B19493_11_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Example of an ImageViewer feature folder</p>
<p>This folder structure provides the following benefits:</p>
<ul>
<li><strong class="bold">Focus</strong> – Each feature is<a id="_idIndexMarker726"/> isolated so team members can build the feature without causing merge issues</li>
<li><strong class="bold">Consolidation</strong> – Instead of moving from one folder to another throughout the entire project, features are confined to one folder, making the coding process more efficient</li>
<li><code>Features/AccountsReceiveable</code> folder</li>
</ul>
<p>In MVC, the View path can be modified to fit your needs. In this case, defining a custom path to your views provides even more flexible configurations for your application.</p>
<p>The <code>Features</code> folder technique is becoming a more viable option for creating scalable, feature-based web applications by offering vertical slicing. Vertical slicing is the process of writing code for <a id="_idIndexMarker727"/>an entire feature across all layers (presentation, domain, and<a id="_idIndexMarker728"/> data access). Feature folders simplify this process and convey isolated features in the application.</p>
<h3>Models folder</h3>
<p>The <code>Models</code> folder <a id="_idIndexMarker729"/>contains all of the models used for your <a id="_idIndexMarker730"/>Views. This is different from a ViewModel. The difference between Models and ViewModels is that ViewModels are passed into the View and can contain models to support the ViewModel.</p>
<p>An example of a ViewModel is shown in the following code snippet:</p>
<pre class="source-code">
public class HomeController : Controller
{
    public IActionResult Index()
    {
        return View(new IndexViewModel
        {
            Title = "Home Page",
            Product = new ProductDto
            {
                Name = "Sunglasses",
                Price = 9.99m
            }
        });
    }
}
public class IndexViewModel
{
    public string Title { get; set; }
    public ProductDto Product { get; set; }
}
public class ProductDto
{
    public string Name { get; set; }
    public decimal Price { get; set; }
}</pre> <p>A ViewModel is<a id="_idIndexMarker731"/> sent to the View (<code>IndexViewModel</code>) where <a id="_idIndexMarker732"/>a Model can be data supporting the ViewModel (<code>ProductDto</code>).</p>
<p>Two common practices include either creating a <code>ViewModels</code> directory under the <code>Models</code> folder, or a <code>ViewModels</code> directory in the root of your project.</p>
<h3>Views folder</h3>
<p>In an MVC<a id="_idIndexMarker733"/> project, the <code>Views</code> folder is the equivalent<a id="_idIndexMarker734"/> of the <code>Pages</code> folder in a Razor Pages project. It contains the same folder structure as a Razor Pages project.</p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor257"/>Creating project layers</h2>
<p>When creating a <a id="_idIndexMarker735"/>new web application, the default web project contains the bare essentials to run in a browser. But how do you segment the application so you don’t have a huge pile of unmanageable code?</p>
<p>A layer, or tier, is a segment of the application broken up into modules or projects designed to perform in a certain way. A presentation layer contains the user interface of how the user interacts with the website, while a data access layer retrieves data for the application.</p>
<p>Identifying project layers can be a bit of a daunting task, but the best way is to create application layers based on their functionality. Each project will have a consistent naming convention based on its function.</p>
<p>While the following are recommended project layers and names, architect and team suggestions may overrule these choices:</p>
<ul>
<li><code>&lt;ProjectName&gt;.Domain</code> or <code>&lt;ProjectName&gt;.Core</code>.</li>
<li><code>&lt;ProjectName&gt;.Web</code> or <code>&lt;ProjectName&gt;.UI</code>.</li>
<li><code>&lt;ProjectName&gt;.Data</code> or <code>&lt;ProjectName&gt;.Infrastructure</code>.</li>
<li><code>/api</code>) or contained in a separate project called <code>&lt;ProjectName&gt;.Api</code>.</li>
<li><code>Infrastructure</code> project, the amount of code in an infrastructure project can become overwhelming. A services project could provide an alternative to the <code>Infrastructure</code> project. Services could include a <code>MailService</code> or <code>&lt;Entity&gt;Service</code>. These projects are usually named <code>&lt;ProjectName&gt;.Services</code>.</li>
</ul>
<p>These code layers provide the best layout when organizing your project. Each project name describes the<a id="_idIndexMarker736"/> intent and gives developers a clear representation of the solution as a whole.</p>
<h1 id="_idParaDest-245"><a id="_idTextAnchor258"/>Summary</h1>
<p>In this appendix, we learned the DRY, YAGNI, and KISS principles, along with separation of concerns, the concept of SOLID, and how refactoring is a process and not a one-time quick fix.</p>
<p>We proceeded to look at how two common ASP.NET web applications were structured and what each folder represented. Once we understood a project’s folder structure, we examined where code would reside based on its intent, such as Entity Framework or service classes.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor259"/>Thank you!</h2>
<p>Best practices are considered to be what is correct, common, and accepted by others in the field. The best practices contained in this book are a combination of observations, experience, and feedback over the years from my peers, mentors, and the developer community.</p>
<p>I hope these best practices serve as a reference for your ASP.NET development career and that you can achieve the same level of excitement as I do when I experience a new programming technique or technology.</p>
<p>Thank you for your readership!</p>
<p>Code on, developers... code on!</p>
</div>
</body></html>