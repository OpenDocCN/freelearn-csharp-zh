<html><head></head><body>
		<div><h1 id="_idParaDest-96"><em class="italic"><a id="_idTextAnchor146"/>Chapter 5</em>: Exploring the ASP.NET Core and ABP Infrastructure</h1>
			<p>Both ASP.NET Core and ABP Framework provide many building blocks and features for modern application development. This chapter will explore the most basic building blocks so that you can understand how an application is configured and initialized.</p>
			<p>We will start with the ASP.NET Core <code>Startup</code> class to understand why we need a modular system and how ABP provides a modular way to configure and initialize an application. Then we will explore the ASP.NET Core dependency injection system and ABP's way of automating dependency injection registration with predefined rules. We will continue by looking at configuration and the options pattern to learn ASP.NET Core's way of configuring the options of ASP.NET Core and other libraries.</p>
			<p>Here are all the topics we'll cover in this chapter:</p>
			<ul>
				<li>Understanding modularity</li>
				<li>Using the dependency injection system</li>
				<li>Configuring an application</li>
				<li>Implementing the options pattern</li>
				<li>Logging</li>
			</ul>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor147"/>Technical requirements</h1>
			<p>If you want to follow and try the examples, you need to have installed an IDE/editor (such as Visual Studio) to build the ASP.NET Core projects.</p>
			<p>You can download the code examples from the following GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor148"/>Understanding modularity</h1>
			<p><strong class="bold">Modularity</strong> is a design technique for breaking down the functionalities of a large software into smaller parts and allowing each part to communicate with the others through standardized interfaces as needed. Modularity has the following main benefits:</p>
			<ul>
				<li>It reduces complexity when every module is designed to be isolated from the other modules, and inter-module communications are well defined and limited.</li>
				<li>It provides flexibility when you design modules to be loosely coupled. You can refactor or even replace a module in the future.</li>
				<li>It allows re-using modules across applications when you design them to be application-independent.</li>
			</ul>
			<p>Most enterprise software systems are designed to be modular. However, implementing modularity is not easy, and the plain ASP.NET Core doesn't help much. One of ABP Framework's main goals is to provide infrastructure and tooling to develop truly modular systems. We will cover modular application development in <a href="B17287_15_Epub_AM.xhtml#_idTextAnchor443"><em class="italic">Chapter 15</em></a><em class="italic">, Working with Modularity</em>, but this section introduces the basics of ABP modules.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor149"/>The Startup class</h2>
			<p>Before defining a module class, it is best to remember the <code>Startup</code> class in ASP.NET Core to understand the need for module classes. The following code block shows a <code>Startup</code> class in a simple ASP.NET Core application:</p>
			<pre>public class Startup
{
    public void ConfigureServices(IServiceCollection                 services)
    {
        services.AddMvc();
        services.AddTransient&lt;MyService&gt;();
    }
    public void Configure(
        IApplicationBuilder app, IWebHostEnvironment env)
    {
        app.UseRouting();
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        app.UseEndpoints(endpoints =&gt;
        {
            endpoints.MapControllers();
        });
    }
}</pre>
			<p>The <code>ConfigureServices</code> method is used to configure other services and register new services to the dependency injection system. The <code>Configure</code> method, on the other hand, is used to configure the <strong class="bold">ASP.NET Core request pipeline</strong> that processes the HTTP requests through middleware components.</p>
			<p>Once you have the <code>Startup</code> class, you typically register it in the <code>Program.cs</code> file while configuring the host builder so that it works on application startup:</p>
			<pre>public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }
    public static IHostBuilder CreateHostBuilder(string[]           args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder.UseStartup&lt;Startup&gt;();
            });
}</pre>
			<p>These code parts are already included in ASP.NET Core's startup templates, so you normally don't write them manually.</p>
			<p>The problem with the <code>Startup</code> class is that it is unique. That means you have only a single point to configure and initialize all your application services. However, in a modular application, you expect that every module configures and initializes the services related to that particular module. Also, it is typical that a module uses or depends on other modules, so the modules should be configured and initialized in the correct order. That is where ABP's module definition class comes into play.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor150"/>Defining a module class</h2>
			<p>An ABP module is a group of types (such as classes or interfaces) developed and shipped together. It is an assembly (a <em class="italic">project</em> in Visual Studio) with a module class derived from <code>AbpModule</code>. The module class is responsible for configuring and initializing that module and configures any dependent modules if necessary.</p>
			<p>Here is a simple module definition class for an SMS sending module:</p>
			<pre>using Microsoft.Extensions.DependencyInjection;
using Volo.Abp.Modularity;
namespace SmsSending
{
    public class SmsSendingModule : AbpModule 
    {
        public override void ConfigureServices(
            ServiceConfigurationContext context)
        {
            context.Services.AddTransient&lt;SmsService&gt;();
        }
    }
}</pre>
			<p>Every module can override the <code>ConfigureServices</code> method in order to register its services to the dependency injection system and configure the other modules. The module in this example registers <code>SmsService</code> to a dependency injection system with a transient lifetime. I've written this example to show the same registration code done in the <code>Startup</code> class in the previous section. However, most of the time, you don't need to register your services manually, thanks to ABP Framework's conventional registration system explained in the <em class="italic">Using the dependency injection system</em> section of this chapter.</p>
			<p>The <code>AbpModule</code> class defines the <code>OnApplicationInitialization</code> method that is executed after the service registration phase is complete and the application is ready to run. With this method, you can execute any operation you need to perform on application startup. For example, you can initialize a service:</p>
			<pre>public class SmsSendingModule : AbpModule 
{
    //...
    <a id="_idTextAnchor151"/>public override void OnApplicationInitialization(
        ApplicationInitializationContext context)
    {
        var service = context.ServiceProvider
            .GetRequiredService&lt;SmsService&gt;();
        service.Initialize();
    }
}</pre>
			<p>In this code block, we are using <code>context.ServiceProvider</code> to request a service from the dependency injection system and initialize the service. We can request services because the dependency injection system is ready at this point.</p>
			<p>You can also think of the <code>OnApplicationInitialization</code> method as the <code>Configure</code> method of the <code>Startup</code> class. So, you can build the ASP.NET Core request pipeline here. However, you typically configure the request pipeline in the startup module, as explained in the next section.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor152"/>Module dependencies and the startup module</h2>
			<p>A business application generally consists of more than one module, and ABP Framework allows you to declare dependencies between modules. An application should always have a <strong class="bold">startup module</strong>. The startup module can have dependencies on some modules, and these modules can have dependencies on some other modules, and so on.</p>
			<p>The following diagram shows a simple module dependency graph:</p>
			<div><div><img src="img/Figure_5.1_B17287.jpg" alt="Figure 5.1 – Example module dependency graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Example module dependency graph</p>
			<p>ABP respects module dependencies<a id="_idIndexMarker239"/> and initializes modules based on the dependency<a id="_idIndexMarker240"/> graph. If module A depends on module B, then module B is always initialized before module A. That allows module A to use, set, change, or override configurations and services defined by module B.</p>
			<p>For the example graph in <em class="italic">Figure 5.1</em>, the module initialization will be in the following order: G, F, E, D, B, C, A. You don't have to know the exact initialization order; only know that if your module depends on module <em class="italic">X</em>, then module <em class="italic">X </em> is initialized before your module.</p>
			<p>Defining a module dependency is declared with the <code>[DependsOn]</code> attribute of a module<a id="_idTextAnchor153"/>:</p>
			<pre>[DependsOn(typeof(ModuleB), typeof(ModuleC))]
public class ModuleA : AbpModule
{    
}</pre>
			<p>In the preceding code block, <code>ModuleA</code> depends on <code>ModuleB</code> and <code>ModuleC</code> by declaring the <code>[DependsOn]</code> attribute.</p>
			<p>For an ASP.NET Core application, the startup<a id="_idIndexMarker241"/> module (<code>ModuleA</code> in this example) is responsible for setting up<a id="_idIndexMarker242"/> the ASP.NET Core request pipeline:</p>
			<pre>[DependsOn(typeof(ModuleB), typeof(ModuleC))]
public class ModuleA : AbpModule
{
    //...
    public override void OnApplicationInitialization(
        ApplicationInitializationContext context)
    {
        var app = context.GetApplicationBuilder();
        var env = context.GetEnvironment();
        
        app.UseRouting();
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        app.UseEndpoints(endpoints =&gt;
        {
            endpoints.MapControllers();
        });
    }
}</pre>
			<p>With this code block, we've built the same ASP.NET Core request pipeline built previously in the <em class="italic">The Startup class</em> section. <code>context.GetApplicationBuilder()</code> and <code>context.GetEnvironment()</code> are just shortcuts to obtain the standard <code>IApplicationBuilder</code> and <code>IWebHostEnvironment</code> services from the dependency injection system.</p>
			<p>Then, we can use<a id="_idIndexMarker243"/> this module in the <code>Startup</code> class<a id="_idIndexMarker244"/> of ASP.NET Core to integrate ABP Framework with ASP.NET Core:</p>
			<pre>public class Startup
{
    public void ConfigureServices(IServiceCollection                 services)
    {
        services.AddApplication&lt;ModuleA&gt;();
    }
    public void Configure(IApplicationBuilder app)
    {
        app.InitializeApplication();
    }
}</pre>
			<p>The <code>services.AddApplication()</code> method is defined by ABP Framework to configure the modules. It basically execute<a id="_idTextAnchor154"/>s the <code>ConfigureServices</code> methods of all the modules by respecting the order of module dependencies. The  <code>app.InitializeApplication()</code> method is also defined by ABP Framework; similarly, it executes the <code>OnApplicationInitialization</code> methods of all the modules by respecting the order of module dependencies.</p>
			<p>The <code>ConfigureServices</code> and <code>OnApplicationInitialization</code> methods are the most commonly used methods in a module class; there are more methods explained in the next section.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor155"/>Module lifecycle methods</h2>
			<p>The <code>AbpModule</code> class defines useful methods that you can override to execute code on application startup and shutdown. We saw <code>ConfigureServices</code> and <code>OnApplicationInitialization</code> in the previous section; here is a list<a id="_idIndexMarker245"/> of all the lifecycle methods:</p>
			<ul>
				<li><code>PreConfigureServices</code>: This method is called before the <code>ConfigureServices</code> method. It allows you to write code to be executed before <code>ConfigureServices</code> of the depended-upon modules.</li>
				<li><code>ConfigureServices</code>: This is the main method to configure the module and register services, as explained in the previous section.</li>
				<li><code>PostConfigureServices</code>: This method is called after the <code>ConfigureServices</code> method of all the modules (including the modules depending on your module), so you may perform a final configuration.</li>
				<li><code>OnPreApplicationInitialization</code>: This method is called before the <code>OnApplicationInitialization</code> method. In this stage, you can resolve services from dependency injection.</li>
				<li><code>OnApplicationInitialization</code>: This method allows your module to configure the ASP.NET Core request pipeline and initialize your services, as explained in the previous section.</li>
				<li><code>OnPostApplicationInitialization</code>: This method is called in the initialization phase.</li>
				<li><code>OnApplicationShutdown</code>: You can implement your module's shutdown logic if necessary.</li>
			</ul>
			<p><code>Pre…</code> and <code>Post…</code> methods (such as <code>PreConfigureServices</code> and <code>PostConfigureServices</code>) have the same purpose as the original method. They are rarely used and provide a way to perform some configuration/initialization code that works before or after all other modules.</p>
			<p class="callout-heading">Asynchronous Lifecycle Methods</p>
			<p class="callout">The lifecycle methods explained in this section are synchronous. At the time of writing this book, the ABP Framework team<a id="_idIndexMarker246"/> was working to introduce asynchronous lifecycle methods with ABP Framework version 5.1. You can see <a href="https://github.com/abpframework/abp/pull/10928">https://github.com/abpframework/abp/pull/10928</a> for details.</p>
			<p>As explained before, a module class mainly contains code to register and configure services related to that module. In the next section, we will see how to register services with ABP Framework.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor156"/>Using the dependency injection system</h1>
			<p>Dependency injection<a id="_idIndexMarker247"/> is a technique for obtaining a class's dependencies. It separates creating a class from using that class.</p>
			<p>Assume that we have a <code>UserRegistrationService</code> class that uses <code>SmsService</code> to send a verification SMS, as shown<a id="_idIndexMarker248"/> in the following co<a id="_idTextAnchor157"/>de block:</p>
			<pre>public class UserRegistrationService
{
    private readonly SmsService _smsService;
    public UserRegistrationService(SmsService smsService)
    {
        _smsService = smsService;
    }
    public async Task RegisterAsync(
        string username,
        string password,
        string phoneNumber)
    {
        //...save user in the database
        await _smsService.SendAsync(
            phoneNumber,
            "Your verification code: 1234"
        );
    }
}</pre>
			<p>Here, <code>SmsService</code> has been obtained using the <code>SmsService</code>, in this example, is used in the <code>RegisterAsync</code> method to send a verification code after saving the user into the database.</p>
			<p>ASP.NET Core natively provides a dependency injection<a id="_idIndexMarker250"/> infrastructure, and ABP leverages this infrastructure rather than using a third-party dependency injection framework. Once you register all the services to the dependency injection system, any service can constructor-inject the dependent services without dealing with creating them (and their dependencies).</p>
			<p>The most important thing you should consider while designing your services is the service lifetime.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor158"/>Service lifetime</h2>
			<p>ASP.NET Core<a id="_idIndexMarker251"/> offers different lifetime options on service registration, so we should select a lifetime for every service. There are three lifetimes in ASP.NET Core:</p>
			<ul>
				<li><strong class="bold">Transient</strong>: Transient <a id="_idIndexMarker252"/>services are created whenever<a id="_idIndexMarker253"/> you inject them. Every time you request/inject the service, a new instance is created.</li>
				<li><strong class="bold">Scoped</strong>: Scoped services <a id="_idIndexMarker254"/>are created per scope. This is generally considered by request lifetime, as each HTTP request<a id="_idIndexMarker255"/> creates a new scope in ASP.NET Core. You share the same instance in the same scope and get a different instance in different scope.</li>
				<li><strong class="bold">Singleton</strong>: A<a id="_idIndexMarker256"/> singleton service<a id="_idIndexMarker257"/> has only a single instance in an application. All the requests and clients use the same instance. The object is created the first time you request it. Then the same object instance is reused in the subsequent requests.</li>
			</ul>
			<p>The following module registers two services, one as transient and the other as a singleton:</p>
			<pre>public class MyModule : AbpModule
{
    public override void ConfigureServices(
        ServiceConfigurationContext context)
    {
        context.Services.AddTransient&lt;ISmsService,                       SmsService&gt;();
        context.Services.AddSingleton&lt;OtherService&gt;();
    }
}</pre>
			<p><code>context.Services</code> is a type of <code>IServiceCollection</code>, and all the ASP.NET Core extension methods can be used to register and configure your services manually.</p>
			<p>In the first example, <code>AddTransient&lt;ISmsService, SmsService&gt;()</code>, I've registered the <code>SmsService</code> class with the <code>ISmsService</code> interface. In this way, whenever I inject <code>ISmsService</code>, the dependency injection system creates an <code>SmsService</code> object for me. For the second example, <code>AddSingleton&lt;OtherService&gt;()</code>, I've registered <code>OtherService</code> as a singleton with the class reference. To use this service, I should inject the <code>OtherService</code> class reference.</p>
			<p class="callout-heading">Scoped Dependencies and ASP.NET Core's Dependency Injection Documentation</p>
			<p class="callout">As mentioned, scoped services<a id="_idIndexMarker258"/> are created per HTTP request for an ASP.NET Core application by default. For non-ASP.NET Core applications, you may need to manage scopes yourself. Please refer to ASP.NET Core's documentation for all the details<a id="_idIndexMarker259"/> of the dependency injection system: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection</a>.</p>
			<p>When you use ABP Framework, you don't have to think so much about service registration, thanks to ABP Framework's conventional and declarative service registration system.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor159"/>Conventional service registrations</h2>
			<p>In ASP.NET Core, you should explicitly register all your services to <code>IServiceCollection</code>, as shown in the previous section. However, most of these registrations are just repetitive code and can be automated.</p>
			<p>ABP automatically registers services for dependency injection<a id="_idIndexMarker260"/> for the following types:</p>
			<ul>
				<li>MVC controllers</li>
				<li>Razor page models</li>
				<li>View components</li>
				<li>Razor components</li>
				<li>SignalR hubs</li>
				<li>Application services</li>
				<li>Domain services</li>
				<li>Repositories</li>
			</ul>
			<p>All these services are registered with the transient lifetime. So, you don't need<a id="_idIndexMarker261"/> to care about service registration for these kinds of classes. If you have another class type, you can use one of the dependency interfaces, or the <code>Dependency</code> attribute as explained in the next sections.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor160"/>Dependency interfaces</h2>
			<p>You can implement an <code>ITransientDependency</code>, <code>IScopedDependency</code>, or <code>ISingletonDependency</code> interface to register your service for dependency injection. For example, in this code block, we've registered the service as a singleton, so only one shared instance<a id="_idIndexMarker262"/> is created in the application's lifetime:</p>
			<pre>public class UserPermissionCache : ISingletonDependency
{ }</pre>
			<p>Dependency interfaces are easy and the suggested way for most cases, but they are limited compared to the <code>Dependency</code> attribute.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor161"/>The Dependency attribute</h2>
			<p>The <code>Dependency</code> attribute provides options<a id="_idIndexMarker263"/> for fine control of dependency registration with the following properties:</p>
			<ul>
				<li><code>Lifetime</code> (<code>enum</code>): The lifetime of the service: <code>Singleton</code>, <code>Transient</code>, or <code>Scoped</code></li>
				<li><code>TryRegister</code> (<code>bool</code>): Registers the service only if it's not already registered</li>
				<li><code>ReplaceServices</code> (<code>bool</code>): Replaces the previous registration if the service is already registered</li>
			</ul>
			<p>Here is an example of service registration using the <code>Dependency</code> attribute:</p>
			<pre>using Microsoft.Extensions.DependencyInjection;
using Volo.Abp.DependencyInjection;
namespace UserManagement
{
    [Dependency(ServiceLifetime.Transient, TryRegister =         true)]
    public class UserPermissionCache
    { }
}</pre>
			<p>Here, I used the <code>[Dependency]</code> attribute with a <code>Transient</code> lifetime and also with the <code>TryRegister</code> option to register the class to the dependency injection system.</p>
			<p class="callout-heading">Dependency Attribute versus Dependency Interfaces</p>
			<p class="callout">The <code>Dependency</code> attribute<a id="_idIndexMarker264"/> can be used alongside the dependency interfaces introduced in the previous section. The <code>Dependency</code> attribute has a higher priority than the dependency interfaces if it defines the <code>Lifetime</code> property.</p>
			<p>Registering a class to the dependency injection<a id="_idIndexMarker265"/> system makes it usable in an application. However, a class may be injected with different types of class or interface references, depending on what service types are exposed by that class.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor162"/>Exposing services</h2>
			<p>When a class doesn't implement an interface, it can only be injected<a id="_idIndexMarker266"/> by the class reference. The <code>UserPermissionCache</code> class in the previous section is used by directly injecting the class type. However, it is common to implement interfaces for services.</p>
			<p>Assume that we have an interface to abstract the SMS sending:</p>
			<pre>public interface ISmsService
{
    Task SendAsync(string phoneNumber, string message);
}</pre>
			<p>That is a pretty simple interface that only has a single method to send an SMS. Assume that you want to implement the <code>ISmsService</code> interface by using Azure:</p>
			<pre>public class AzureSmsService : ISmsService, ITransientDependency
{
    public async Task SendAsync(string phoneNumber, string message)
    {
        //TODO: ...
    }
}</pre>
			<p>The <code>AzureSmsService</code> class implements the <code>ISmsService</code> and <code>ITransientDependency</code> interfaces. The <code>ITransientDependency</code> interface is only for registering this service for dependency injection, as explained in the previous section.</p>
			<p>You typically want to use the <code>AzureSmsService</code> class by injecting the <code>ISmsService</code> interface. ABP is smart enough<a id="_idIndexMarker267"/> to understand your purpose and automatically registers the <code>AzureSmsService</code> class for the <code>ISmsService</code> interface. You can consume the <code>AzureSmsService</code> class either by injecting the <code>ISmsService</code> interface or the <code>AzureSmsService</code> class reference. Injecting the <code>AzureSmsService</code> class by the <code>ISmsService</code> interface is possible by its naming conventions: the <code>ISmsService</code> interface is the <em class="italic">default interface</em> for the <code>AzureSmsService</code> class because it ends with the <code>SmsService</code> suffix.</p>
			<p>Assume that we have a class that implements multiple interfaces as shown in the following code block:</p>
			<pre>public class PdfExporter: IExporter, IPdfExporter, ICanExport, ITransientDependency
{ }</pre>
			<p>The <code>PdfExporter</code> service can be used by injecting the <code>IPdfExporter</code> and <code>IExporter</code> interfaces or directly with the <code>PdfExporter</code> class reference. However, you can't inject it using the <code>ICanExport</code> interface because the name of <code>PdfExporter</code> doesn't end with <code>CanExport</code>.</p>
			<p>If you need to change the default<a id="_idIndexMarker268"/> behavior, you can use the <code>ExposeServices</code> attribute, as shown in the following code block:</p>
			<pre>[ExposeServices(typeof(IPdfExporter))]
public class PdfExporter: IExporter, IPdfExporter, ICanExport, ITransientDependency
{ }</pre>
			<p>Now, you can use the <code>PdfExporter</code> class only by injecting the <code>IPdfExporter</code> interface.</p>
			<p class="callout-heading">Question: Should I Define Interfaces for Each Service?</p>
			<p class="callout">One potential question you may ask is whether you should define interfaces for your services and inject them using interfaces. ABP doesn't force you to do anything here, and general interface best practices are applicable: define interfaces if you want to loosely couple your services, have multiple implementations of a service, mock in unit tests easily, physically separate interfaces from the implementations (say, we define application service interfaces in the <code>Application.Contracts</code> project and implement them in the <code>Application</code> project, or we define repository interfaces in the domain layer but implement them in the infrastructure layer), and so on.</p>
			<p>We've seen how to register and consume services. Some services or libraries have options, and you may need to configure them before using them. The next two sections explain the standard infrastructure and patterns to configure options provided by such services and libraries.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor163"/>Configuring an application</h1>
			<p>ASP.NET Core's <strong class="bold">configuration</strong> system provides a<a id="_idIndexMarker269"/> convenient way to read<a id="_idIndexMarker270"/> key-value-based configurations for applications. It is an extensible system and can read key-value pairs from various resources, such as JSON settings files, environment<a id="_idIndexMarker271"/> variables, command-line arguments, and Azure Key Vault.</p>
			<p class="callout-heading">ABP Framework versus ASP.NET Core's Configuration System</p>
			<p class="callout">ABP Framework<a id="_idIndexMarker272"/> doesn't add a specific feature to ASP.NET Core's configuration system. However, it is essential to understand it to work with ASP.NET Core and ABP Framework properly. I will cover the basics in this book. Please see ASP.NET Core's<a id="_idIndexMarker273"/> documentation for a complete reference: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration</a>.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor164"/>Setting the configuration values</h2>
			<p>The easiest way to set a configuration<a id="_idIndexMarker274"/> value is to use the <code>appsettings.json</code> file by default. Assume that we are building a service to send SMS using Azure, and we need the following configuration values:</p>
			<ul>
				<li><code>Sender</code>: The sender number shown to the target user</li>
				<li><code>ConnectionString</code>: The connection string of your Azure resouce</li>
			</ul>
			<p>We can define these settings in the configuration section of the <code>appsettings.json</code> file:</p>
			<pre>{
  ...
  "AzureSmsService": {
    "Sender": "+901112223344",
    "ConnectionString": "..."
  }
}</pre>
			<p>The configuration section name (<code>AzureSmsService</code> here) and key names are completely arbitrary. You can set any name as long as you use the same keys in your code.</p>
			<p>Once you've set values in the settings<a id="_idIndexMarker275"/> file, you can easily read them from your application code.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor165"/>Reading the configuration values</h2>
			<p>You can inject and use the <code>IConfiguration</code> service whenever you need to read configured values. For example, we can get<a id="_idIndexMarker276"/> the Azure configuration to send SMS in the <code>AzureSmsService</code> class:</p>
			<pre>using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Volo.Abp.DependencyInjection;
namespace SmsSending
{
    public class AzureSmsService : ISmsService,                     ITransientDependency
    {
        private readonly IConfiguration _configuration;
        public AzureSmsService(IConfiguration configuration)
        {
            _configuration = configuration;
        }
        
        public async Task SendAsync(
            string phoneNumber, string message)
        {
            string sender = _configuration["AzureSmsService:Sender"];
            string ConnectionString = _configuration["AzureSmsService:ConnectionString"];
            //TODO: Use Azure to send the SMS message
        }
    }
}</pre>
			<p>This class gets the configuration values from the <code>IConfiguration</code> service, and the<code>:</code> notation is used to access values in nested sections. In this example, <code>AzureSmsService:Sender</code> is used to get the <code>Sender</code> value inside the <code>AzureSmsService</code> section.</p>
			<p>The <code>IConfiguration</code> service<a id="_idIndexMarker277"/> is also usable in the <code>ConfigureServices</code> of your module:</p>
			<pre>public override void ConfigureServices(
    ServiceConfigurationContext context)
{
    IConfiguration configuration =                                   context.Services.GetConfiguration();
    string sender =                                                 configuration["AzureSmsService:Sender"];
}</pre>
			<p>This way, you can access the configured values even before the dependency injection registration phase is completed.</p>
			<p>The configuration system is a perfect way to configure and get key-value-style settings for your application. However, if you are building a reusable library, the options pattern can be a better way to define type-safe options for your library.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor166"/>Implementing the options pattern</h1>
			<p>With the <strong class="bold">options pattern</strong>, we use a plain class (sometimes called a <strong class="bold">POCO</strong> – <strong class="bold">Plain Old C# Object</strong>) to define a group of related<a id="_idIndexMarker278"/> options. Let's begin with how to define, configure, and use the configuration<a id="_idIndexMarker279"/> using the options pattern.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor167"/>Defining an options class</h2>
			<p>An options class is a simple<a id="_idIndexMarker280"/> plain C# class. We can define an options class for the Azure SMS service as shown in the following code block:</p>
			<pre>public class AzureSmsServiceOptions
{
    public string Sender { get; set; }
    public string ConnectionString { get; set; }
}</pre>
			<p>It is a convention to add the <code>Options</code> suffix to options classes. Once you define such a class, any module using this service can configure the options easily.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor168"/>Configuring the options</h2>
			<p>As mentioned in the <em class="italic">ABP modules</em> section, you can configure<a id="_idIndexMarker281"/> the services of the dependent modules in the <code>ConfigureServices</code> method of your module. We use the <code>IServiceCollection.Configure</code> extension method to set values for any options class. You can configure <code>AzureSmsServiceOptions</code> as shown in the following code block:</p>
			<pre>[DependsOn(typeof(SmsSendingModule))]
public class MyStartupModule : AbpModule
{
    public override void ConfigureServices(
        ServiceConfigurationContext context)
    {
        context.Services
            .Configure&lt;AzureSmsServiceOptions&gt;(options =&gt;
        {
            options.Sender = "+901112223344";
            options.ConnectionString = "...";
        });
    }
}</pre>
			<p>The <code>context.Services.Configure</code> method is a generic method that gets the options class<a id="_idIndexMarker282"/> as the generic parameter. It also takes a delegate (an action) to set the option values. In this example, we've configured <code>AzureSmsServiceOptions</code> by setting the <code>Sender</code> and <code>ConnectionString</code> properties in the specified lambda expression.</p>
			<p>The <code>AbpModule</code> base class provides a <code>Configure</code> method as a shortcut of the <code>context.Services.Configure</code> method, so you could re-write the code as follows:</p>
			<pre>public override void ConfigureServices(
    ServiceConfigurationContext context)
{
    Configure&lt;AzureSmsServiceOptions&gt;(options =&gt;
    {
        options.Sender = "+901112223344";
        options.ConnectionString = "...";
    });
}</pre>
			<p>We've just replaced the <code>context.Services.Configure&lt;…&gt;</code> call with the <code>Configure&lt;…&gt;</code> shortcut method.</p>
			<p>Configuring the options<a id="_idIndexMarker283"/> is simple. Now, we can see how to use the configured values.</p>
			<p class="callout-heading">Multiple Configure Actions</p>
			<p class="callout">You can configure the same options multiple times in an application. The same instance is sent to all delegates so that you can change the previously configured values. If multiple modules configure<a id="_idIndexMarker284"/> the same value, the last one wins. Remember that modules are initialized by the dependency order.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor169"/>Using the configured option values</h2>
			<p>ASP.NET Core provides an <code>IOptions&lt;T&gt;</code> interface to inject the options class to read the configured values. We can<a id="_idIndexMarker285"/> re-write the <code>AzureSmsService</code> class to use <code>AzureSmsServiceOptions</code> instead of the <code>IConfigur<a id="_idTextAnchor170"/>ation</code> service, as in the following code block:</p>
			<pre>public class AzureSmsService : ISmsService, ITransientDependency
{
    private readonly AzureSmsServiceOptions _options;
    public AzureSmsService(IOptions&lt;AzureSmsServiceOptions&gt;         options)
    {
        _options = options.Value;
    }
    
    public async Task SendAsync(string phoneNumber, string message)
    {
        string sender = _options.Sender;
        string ConnectionString = _options.ConnectionString;
        //TODO...
    }
}</pre>
			<p>Notice that we are injecting <code>IOptions&lt;AzureSmsServiceOptions&gt;</code> and using its <code>Value</code> property to obtain the <code>AzureSmsServiceOptions</code> instance. The <code>IOptions&lt;T&gt;</code> interface is defined by the <code>Microsoft.Extensions.Options</code> package and is the standard way to inject an options class. It internally executes all the <code>Configure</code> methods and provides<a id="_idIndexMarker286"/> a configured instance of the options class for you. If you directly inject the <code>AzureSmsServiceOptions</code> class by mistake, you get a dependency injection exception. So, always inject as <code>IOptions&lt;AzureSmsServiceOptions&gt;</code>.</p>
			<p>We've simply defined, configured, and used the options. What if we want to use the configuration system to set the options defined with the options pattern?</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor171"/>Setting the options via the configuration</h2>
			<p>The options pattern<a id="_idIndexMarker287"/> allows us to set the option values in any way. That means<a id="_idIndexMarker288"/> we can use the <code>IConfiguration</code> service to read the application configuration and set the option values. The following code block sets <code>AzureSmsServiceOptions</code> by getting the values from the configuration service:</p>
			<pre>[DependsOn(typeof(SmsSendingModule)<a id="_idTextAnchor172"/>)]
public class MyStartupModule : AbpModule
{
    public override void ConfigureServices(
        ServiceConfigurationContext context)
    {
        var configuration =                                            context.Services.GetConfiguration();        
        Configure&lt;AzureSmsServiceOptions&gt;(options =&gt;
        {
            options.Sender =                                                 configuration["AzureSmsService:Sender"];
            options.ConnectionString = configuration["AzureSmsService:ConnectionString"];
        });
    }
}</pre>
			<p>We are getting the <code>IConfiguration</code> interface using <code>context.Services.GetConfiguration()</code>, then using the configuration values to set the option values.</p>
			<p>However, since this usage<a id="_idIndexMarker289"/> is pretty common, there is a shortcut for it. We could<a id="_idIndexMarker290"/> re-write the code as shown in the following block:</p>
			<pre>public override void ConfigureServices(
    ServiceConfigurationContext context)
{
    var configuration = context.Services.GetConfiguration();    
    Configure&lt;AzureSmsServiceOptions&gt;(
        configuration.GetSection("AzureSmsService"));
}</pre>
			<p>With this usage, the <code>Configure</code> method gets a configuration section instead of a delegate action. It automatically matches the configuration keys with the properties of the options class by naming conventions. This code does not affect the options if the <code>AzureSmsService</code> section is not defined in the configuration.</p>
			<p>The options pattern gives more flexibility to the application<a id="_idIndexMarker291"/> developers; they may set these<a id="_idIndexMarker292"/> options from <code>IConfiguration</code> or any other source they like.</p>
			<p class="callout-heading">Tip: Set Options from the Configuration by Default</p>
			<p class="callout">If you are building a reusable module, it is a good practice to set your options from the configuration wherever possible. That is, you can write the preceding code into your module. In this way, an application developer can directly configure their module from the <code>appsettings.json</code> file.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor173"/>ASP.NET Core and ABP options</h2>
			<p>ASP.NET Core and ABP Framework<a id="_idIndexMarker293"/> intensively use the options pattern for their<a id="_idIndexMarker294"/> configuration options.</p>
			<p>The following example shows configuring an option in ABP Framework:</p>
			<pre>Configure&lt;AbpAuditingOptions&gt;(options =&gt;
{
    options.IgnoredTypes.Add(typeof(ProductDto));
});</pre>
			<p><code>AbpAuditingOptions</code> is defined by the audit logging system of ABP Framework. We are adding a type, <code>ProductDto</code>, to be ignored on audit logging.</p>
			<p>The next example shows configuring an option in ASP.NET Core:</p>
			<pre>Configure&lt;MvcOptions&gt;(options =&gt;
{
    options.RespectBrowserAcceptHeader = true;
});</pre>
			<p><code>MvcOptions</code> is defined by ASP.NET Core to customize the behavior of the ASP.NET Core MVC framework.</p>
			<p class="callout-heading">Complex Types in the Options Classes</p>
			<p class="callout">Notice that <code>AbpAuditingOptions.IgnoredTypes</code> is a list of <code>Type</code>, which is not a simple primitive type that you can define in an <code>appsettings.json</code> file. That is one of the benefits of the options pattern: you can define properties with complex types or even action callbacks.</p>
			<p>The configuration system and the options pattern provide a convenient way to configure and customize the behavior of the services being used. You can configure ASP.NET Core and ABP Framework<a id="_idIndexMarker295"/> and define configuration options<a id="_idIndexMarker296"/> for your own services.</p>
			<p>The next section explains logging, another fundamental system that you will frequently use in your application code.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor174"/>Logging</h1>
			<p><strong class="bold">Logging</strong> is a common aspect used in every application. ASP.NET Core provides a simple yet efficient<a id="_idIndexMarker297"/> logging system. It can be integrated with popular logging libraries such as NLog, Log4Net, and Serilog.</p>
			<p>Serilog is a widely used library that provides many options for the log target, including console, text files, and Elasticsearch. ABP startup templates come with the Serilog library pre-installed and configured. It writes logs into a log file in the <code>Logs</code> folder of the application. So, you can directly use the logging system in your services. If you need, you can configure Serilog to write logs to different targets. Please refer to Serilog's documentation to configure the Serilog options. Serilog is not a core dependency of ABP Framework. All the configuration is included in the startup template. So, if you like, you can easily change it with another provider.</p>
			<p>The <code>ILogger&lt;T&gt;</code> interface is used to write logs in ASP.NET Core, where <code>T</code> is typically your service type.</p>
			<p>Here is an example service that writes logs:</p>
			<pre>public class AzureSmsService : ISmsService,                     ITransientDependency
{
    private readonly ILogger&lt;AzureSmsService&gt; _logger;
    public AzureSmsService(ILogger&lt;AzureSmsService&gt; logger)
    {
        _logger = logger;
    }
    public async Task SendAsync(string phoneNumber, string           message)
    {
        _logger.LogInformation(
            $"Sending SMS to {phoneNumber}: {message}");
        //TODO...
    }
}</pre>
			<p>The <code>AzureSmsService</code> class injects the <code>ILogger&lt;AzureSmsService&gt;</code> service in its constructor and uses the <code>LogInformation</code> method to write information-level log text to the<a id="_idIndexMarker298"/> logging system.</p>
			<p>There are more methods on the <code>ILogger</code> interface to write logs with different severity levels, such as LogError and LogDebug. Please refer to ASP.NET Core's documentation for all details<a id="_idIndexMarker299"/> of the logging system: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging</a>.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor176"/>Summary</h1>
			<p>This chapter has covered the core building blocks of ASP.NET Core and ABP Framework.</p>
			<p>You've learned about using the <code>Startup</code> class, configuration system, and options pattern to configure ASP.NET Core and ABP Framework services on application startup and implement your own configuration options when you need them.</p>
			<p>ABP offers a modularity system that takes ASP.NET Core's initialization and configuration system one step further to create multiple modules where each module initializes its services and configures its dependencies. In this way, you can split your application into modules to better organize your code base or create modules that can be reused in different applications.</p>
			<p>The dependency injection system is the most fundamental infrastructure of an ASP.NET Core application. A service consumes others using the dependency injection system. I've introduced the essential aspects of the dependency injection system and explained how ABP simplifies registering your services.</p>
			<p>The next chapter focuses on data access infrastructure, which is an essential aspect of a business application. We will see how ABP Framework standardizes defining entities and using repositories to abstract and perform database operations while automating database connections and transaction management.</p>
		</div>
	</body></html>