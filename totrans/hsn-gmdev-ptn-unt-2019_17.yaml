- en: Facade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Facade pattern is considered a Structural pattern so, as with most patterns
    of this type, it primarily focuses on identifying simple ways of establishing
    relationships between objects. The Facade pattern is an easy pattern to grasp
    because its name perfectly implies its design. The primary intent of the Facade
    pattern is to offer a simplified front-facing interface that abstracts the intricate
    inner workings of complex systems. This approach is beneficial for game developers
    because games are mostly constructed on layers of complexity and interacting systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will be reviewing the basics of the Facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the Facade pattern to implement a save system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a hands-on chapter, so you will need to have a basic understanding of
    Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're unfamiliar with these concepts, please review them before starting
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2I30suS](http://bit.ly/2I30suS)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Facade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Facade pattern''s name is analogous to a facade in architecture—as the
    name implies, it''s an exterior face that hides a complex structure. But, contrary
    to architecture, in software development, the goal of a Facade is not to beautify,
    but instead to simplify. As we are going to see in the following diagram, the
    implementation of the Facade pattern is usually limited to a single class that
    acts as a simplified interface to a complex array of interdependent sub-systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd5961a2-1b26-4510-8034-d986cbc013ef.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, when a client calls the `SaveGame()` function of `SaveManager`, there's
    a series of calls made to various dependencies and sub-systems (namely `ScoreSystem`,
    `CloudManager`, and `UIManager`). All of this happens behind the scenes; the client
    is unaware of the number of the sub-systems being called to complete his request.
    So, to save the current game's status, the client only needs to know that there's
    a single function in the `SaveManager` class, and the Facade pattern implementation
    does the rest behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Facade pattern has some substantial benefits, but can also present some
    long-term drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **benefits** are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified interface to a complex body of code**: A solid Facade class will
    hide complexity and dependencies, while providing a simplified interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Localization of all your dependency calls**: The Facade allows you to localize
    and group your dependencies into a single class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier refactoring**: Having complexity and dependency issues between sub-systems
    isolated in Facade classes simplifies the refactoring process, because you can
    refactor them in isolation without affecting clients, as the interfaces stay consistent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some **drawbacks** to watch out for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It makes it easier to hide the mess**: Having an excess of Facade classes
    can make it easier for programmers to disguise lousy code by making their architecture
    look simple to use, while brushing potential long-term architectural issues under
    the carpet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Too many managers**: Manager classes are popular among Unity developers,
    and they often implement them by combining the Singleton and Facade patterns.
    This approach provokes an architecture that becomes an extensive collection of
    globally accessible managers. This type of design becomes very difficult to test
    and manage because the manager classes all become dependent on each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Facade establishes a new interface, whereas the Adapter recycles an old
    interface. It's important, when implementing patterns that might look and sound
    similar, to keep in mind that they're not necessarily identical in purpose.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to build a simple *save game* feature using a combination of the
    Facade and Singleton patterns. Our system has several steps that need to be executed
    in a specific sequence to complete the process of saving the player''s progress.
    Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Trigger **User Interface** (**UI**) feedback to indicate the game is saving
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the current player's data (health, score, ID)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the player's data to disk
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the save to the Cloud
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must respect the specific order of the preceding steps because we can't save
    to the disk before getting the current state of the player. But having to type
    each step manually in the right sequence every time we want to implement a save
    game event in our scripts can be time-consuming and error-prone. So, we are going
    to use the Facade pattern to establish a simple re-usable interface for our save
    game system.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are going to see, the Facade pattern is straightforward, so we will keep
    the following code example simple and straight to the point:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we are going to write the classes for each of our sub-system examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Player`: This class represents our player component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`ScoreManager`: This class is responsible for managing the scoring system;
    it will return the current player''s score:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`CloudManager`: This class is responsible for managing the cloud account of
    the current player, including uploading their local save data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`UIManager`: And finally, the UI manager is responsible for displaying the
    UI components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next important class is a container that will hold the properties of the
    current player that we want to save. Notice that it''s `Serializable`—this is
    because we are going to serialize an instance of this class when we save it to
    disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Up next is the actual class that will act as our Facade. To avoid having a
    code example that''s ten pages long, we are going to focus only on writing an
    elementary `SaveManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, this small example of a `SaveManager` class presents a core
    problem: saving a player''s progression has many steps and dependencies. Imagine
    if we had to write those steps by hand throughout our code every time we wanted
    to trigger a save game—this would be very difficult to maintain and debug.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the benefits of the Facade pattern in action in the following `Client`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can save the current player state from anywhere with just one line of
    code. This benefit is possible because our `SaveManager` is acting like a Facade
    and offering a simplified interface to a larger body of code. We have also localized
    the entire save game process so we can easily maintain it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have the Facade pattern in our toolkit. It fits in perfectly with the
    reality of managing a complex code base that has an extensive collection of sub-systems
    that are constantly interacting with each other and are codependent, as in most
    video games. If the Facade pattern is used wisely, and not as a crutch or a way
    to mask messy code, it can become a cornerstone of your architecture. But the
    most critical point to keep in mind is that when you have a feature that relies
    on a collection of sub-systems to operate, it's a good idea to localize those
    dependencies so you can easily debug, maintain, and refactor them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the Adapter pattern, a close cousin of
    the Facade pattern, but with a very different design and intent.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we wrote the first draft of a `SaveManager` class. As an exercise,
    try to write for yourself a complete save system for your game. It will be a valuable
    long-term investment if you design one that can be re-usable for multiple projects.
    From experience, I often witness game project's get into difficulty later on in
    their development cycle because they don't have a solid save and serialization
    system in place early on, so having one already prepared in your back pocket can
    very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Game Programming Patterns* by Robert Nystrom, available here:[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
