- en: Chapter 6. SQL Database Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter deals with access to databases built according to the principles
    of the relational model, which—generally speaking—we refer to as SQL databases
    due to the language used to manipulate their data. In the next chapter, we will
    take a look at the emerging noSQL database model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we will not go in depth about data access here. This will just be
    a quick review of the most common possibilities you have in order to access database
    systems build according to the relational model.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will quickly review the rules and foundations of the relational model
    (schemas, Normal Form Rules, and so on) before getting into SQL Server 2014, the
    **database management system** (**DBMS**) that I'll use in this chapter. Additionally,
    we'll go through the process of installing SQL Server 2014 Express Edition (totally
    free) along with some sample databases that will help us with the demos.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will also cover a not-so-common type of project that Visual
    Studio offers to deal with databases, the SQL Server Project Template, and explore
    how we can configure many aspects of the target database that our application
    uses straight from Visual Studio. We will even be able to save all this configuration
    in a `.dacpac` file, which can be later replicated in any other machine.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we'll cover the basic .NET Framework database engines recommended for
    data management. We'll start with a reminder of the initial engine that appeared
    with version 1.0 (ADO.NET), passing from there to the Entity Framework model (the
    most common and the one recommended by Microsoft), which is already in its version
    6.1 (although the new version aligns with the .NET Core wave, and it has been
    published under the name Entity Framework 1.1 recently).
  prefs: []
  type: TYPE_NORMAL
- en: We'll discover how to build an ORM data schema from one of the demo databases
    and how to query and manipulate data with EF and some of the new possibilities
    that these versions offer to the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, we''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A refresher view of the Database Relational Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL Server 2014 Database system, installation, and features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL Server Project template in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic data access from ADO.NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic data access with Entity Framework 6.0 using the Database-first *flavor*
    as used with an ASP.NET MVC application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relational model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until 1970, data access was diverse in nature and management. No standard
    or common approaches were available, and the term used to refer to what we now
    understand as databases was data banks, but their structures were quite different.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there were other models, such as the hierarchical model and the network
    model, but their specifications were somewhat informal.
  prefs: []
  type: TYPE_NORMAL
- en: In 1969 and the following years, an engineer at IBM (E.F. Codd) started publishing
    a series of papers in which he established the foundations of what we now understand
    as the relational model; especially, his paper, *The relational model for database
    management*, is now considered the RM manifesto. In this model, all data is represented
    in terms of tuples, and these tuples are grouped into relations. As a result,
    a database organized in terms of the relational model is called a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of relational tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the properties of relational tables:'
  prefs: []
  type: TYPE_NORMAL
- en: All data is offered in terms of collections of relations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each relation is described as a table. A table is composed of columns and rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Columns are attributes of the entity, modeled by the table's definition (in
    a customer table, you could have `customerID`, `e-mail`, `account`, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row (or tuple) represents a single entity (that is, in a customer table,
    `1234`, `thecustomer@site.com`, `1234`, `5678`, and so on, would denote a row
    with a single customer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every table has a set of attributes (one or more) that can be taken as a key,
    which uniquely identifies each entity (in the customer table, customer ID would
    specify only one customer, and this value should be unique in the table).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many types of keys offer several possibilities, but the two most important are
    the primary key and the foreign key. While the former identifies tuples uniquely,
    the latter sits at another table, allowing the establishment of relations between
    tables. It is in this way that we can query data that relates to two or more tables
    based on a common field (this field does not have to be named as the other with
    which we will match; it only has to be of the same data type).
  prefs: []
  type: TYPE_NORMAL
- en: The relational model is based on Relational Algebra (also described by E.F.
    Codd, who proposed this algebra as a basis for database query languages, and thus
    the relation with set theory). This algebra uses a set union, set difference,
    and Cartesian product from a set theory and adds additional constraints to these
    operators, such as `select`, `project`, and `join`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These operations have a direct correspondence in the SQL Language, which is
    used to manipulate data, and basically, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Select**: It recovers values for rows in a table (optionally, with a given
    criteria)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project**: It reads values for select attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Join**: It combines information from two or more tables (or only one, taken
    as a second table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intersect**: It shows rows present in two tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Union**: It shows rows from multiple tables and removes the duplicate rows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difference**: It recovers rows in one table that are not found in another
    table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product**: The cartesian product combines all rows from two or more tables
    and is normally used with filter clauses and foreign key relations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another important aspect of the relational model is that ensures data integrity
    by means of a set of rules. Mainly, there are five rules that have to be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of tuples and/or attributes doesn''t matter: If you have the ID before
    e-mail, it is the same as the e-mail before the ID).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every tuple is unique. For every tuple in a table, there is a combination of
    values that uniquely identifies it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every field contains only single values. Or, if you want, each of the table's
    cells should only hold one value. This is derived from the First Normal Form;
    we'll come to that later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All values within an attribute (think of it as a column) are from the same domain.
    That is, only values allowed by the attribute's definition are allowed, either
    number, characters, dates, and so on. Their practical implementation will depend
    on the type definitions permitted by the database engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers of tables must be unique in a single database, and the same goes
    for columns in tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principles and rules mentioned hereby are formalized by the Normal Form
    Rules (generally called **Normalization**). They establish a number of rules to
    reinforce data integrity. However, in practice, only the three first rules (1NF,
    2NF, and 3NF) are applied in everyday business and even the third one admits a
    *de-normalization* process in order to avoid unnecessary complexities in design
    on some occasions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a very succinct way, these are the requirements of the three normative Normal
    Forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1NF**: It eliminates duplicative columns from the same table. That is, create
    separate tables for each group of related data and identify each row with a primary
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2NF**: It eliminates subsets of data that apply to more than one row of a
    table, and creates a new table with them. Later, you can create foreign keys to
    maintain relationships between the tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3NF**: It deletes all columns that are not dependent upon the primary key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these normal forms, our data integrity is guaranteed in 99% of the cases,
    and we can exploit our bank of data using SQL in a very efficient way. Keep in
    mind that those keys that uniquely identify each table's rows allow the creation
    of indexes, which are additional files intended to speed up and ease data recovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of SQL Server (and other DBMS), two types of indexes are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clustered indexes**: They can be only one per table. They are extremely fast
    data structures that should be based on a short-length field(s) and preferably
    over a field(s) that don''t change, such as customer ID in the example we mentioned
    earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-clustered indexes**: We can define several per table and allow improvements
    in speed, especially in reading, joining, and filtering operations. It is recommended
    that the candidate fields be those that appear in `WHERE` and `JOIN` clauses,
    preferably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tools – SQL Server 2014
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I'm using SQL Server 2014 Express Edition, which is free to
    install and includes an optional installation of **SQL Server Management Studio**
    (**SSMS**), the visual tool that allows the user to manage all objects inside
    the DBMS, but you can also use the 2016 version, which holds identical (an extended)
    features.
  prefs: []
  type: TYPE_NORMAL
- en: You can find them at [https://www.microsoft.com/en-us/download/details.aspx?id=42299](https://www.microsoft.com/en-us/download/details.aspx?id=42299),
    and once they're installed, you'll see a new entry in your system's menu, including
    several tools related to this product. With SSMS ready, you should download and
    install some sample databases. I recommend Adventure Works 2014, which includes
    enough data to go ahead with the majority of typical situations you need to test
    in everyday programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a version available at [http://msftdbprodsamples.codeplex.com/Releases](http://msftdbprodsamples.codeplex.com/Releases).
    Once it''s installed, simply open SQL Server Management Studio, and you should
    end up with an available copy of this database, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The tools – SQL Server 2014](img/image00535.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will find a bunch of tables organized in schemas (prefixes that denote
    a common area of data management, such as **HumanResources**, **Person**, or **Production**).
    If you''re not new to SQL Server or you already know other DBMSes, you won''t
    find the usual utilities to create and edit queries or other SQL-related commands
    strange. They are available via contextual menus when selecting any member of
    the list presented in SQL Server Explorer. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The tools – SQL Server 2014](img/image00536.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All actions required for standard database management are available from SSMS,
    so we can always check for results, SQL commands, test execution plans, creating
    and designing existing or new databases, establishing security requirements, and
    creating any other object that your backend business logic needs, with the ability
    to test it immediately, as you can infer from the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Other helpful possibilities are also found in the editors, since—just like happens
    with Visual Studio—they offer Intellisense on the objects available at any time,
    editing SQL Server commands, code hints, syntax error suggestions, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmer''s experience is also enhanced with advanced debugging capabilities,
    which enable debugging within SSMS or even from Visual Studio itself, so you are
    allowed to enable the **Remote Debugging** options and use breakpoints and all
    the usual artifacts, as if you were in a C# code debugging session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The tools – SQL Server 2014](img/image00537.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, you can switch on the **Activity Monitor** window, which will
    show you a dashboard with different usage-related statistics for any SQL command
    launched from the SSMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The tools – SQL Server 2014](img/image00538.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The SQL language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, the well-established foundations of the Relational Model converged
    on the creation of a standard, first published by **American National Standards**
    **Institute** (**ANSI**) in 1986, and followed by **International Organization
    for Standardization** (**ISO**) in 1987.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, the standard has been revised periodically to enhance the language
    with new features. Thus, a revision in 2003 included the XML data types and auto
    generated values (including identity columns), and this XML support was extended
    in 2006 in order to cover the import/export of XML data and XQuery features.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as Wikipedia reminds us:'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the existence of such standards, most SQL code is not completely portable
    among different database systems without adjustments.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At least we have a common background that allows us—via these adjustments—to
    write portable code that executes in diverse RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version of SQL implemented in SQL Server is named **T-SQL** (**Transact-SQL**).
    As Wikipedia reminds:'
  prefs: []
  type: TYPE_NORMAL
- en: T-SQL expands on the SQL standard to include procedural programming, local variables,
    various support functions for string processing, date processing, mathematics,
    and so on.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Moreover, you can find changes in the `DELETE` and `UPDATE` statements.
  prefs: []
  type: TYPE_NORMAL
- en: With all these additional features Transact-SQL becomes a *Turing complete*
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that in computability theory, a system of data-manipulation rules (such
    as a computer''s instruction set, a programming language, or a cellular automaton)
    is said to be Turing complete or computationally universal if it can be used to
    simulate any single-taped Turing machine. Most of the widely accepted programming
    languages today, such as .NET languages, Java, C, among others, are said to be
    Turing complete. (Wikipedia: [https://en.wikipedia.org/wiki/Turing_completeness](https://en.wikipedia.org/wiki/Turing_completeness)).'
  prefs: []
  type: TYPE_NORMAL
- en: As we said, T-SQL is a very powerful language, allowing variable declarations,
    flow control, improvements to `DELETE` and `UPDATE` statements and `TRY/CATCH`
    exception handling, among many others. For a complete reference of the T-SQL language,
    go to *Transact-SQL Reference (Database Engine)* at [https://msdn.microsoft.com/en-us/library/bb510741.aspx](https://msdn.microsoft.com/en-us/library/bb510741.aspx),
    since the details of this languages deserve a book of its own.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server from Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL Server is available in different forms for a Visual Studio programmer. First,
    we have a type of project, named `SQL Server Database Project`, which you can
    choose as if it were another common programmable template.
  prefs: []
  type: TYPE_NORMAL
- en: Just select **New Project** and scroll down to SQL Server. Usually (it might
    depend on other templates already installed on your machine), you'll find this
    type of project, and once it's selected, a solution structure will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, you will find the Solution Explorer pretty empty, and a look at
    the **Add New** menu will show you the large amount of options that this type
    of project offers for database manipulation (refer to the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL Server from Visual Studio](img/image00539.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, a large amount of different database objects are available in
    this manner, including most of the internal objects managed by SQL Server, external
    files, security aspects, CLR integration, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: The first step would be to select the **Tools/Connect to Database** option in
    the menu in order to link our project to our already installed `AdventureWorks`
    database. You'll be offered the usual **Add Connection** dialog box, where you
    can select a database. At this point, a look at the Server Explorer will allow
    you to query data and other options.
  prefs: []
  type: TYPE_NORMAL
- en: Note that although Visual Studio doesn't offer as many options as if you were
    inside SSMS, the most useful selections for data management appear, including
    data visualization, so we don't have to open SSMS in many usual scenarios of development.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should find a user interface like the one shown in the next capture, when
    you open AdventureWorks2014 database in this manner (observe that the most important
    functionality for programmers is provided):'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL Server from Visual Studio](img/image00540.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you enable **Show all files** in the Solution Explorer, you'll discover that
    after compiling the applications, a number of files appear in the `bin` and `obj`
    directories, one of them with the `.dacpac` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'These files allow us a bunch of possibilities, as Jamie Thomson points out
    in the article *Dacpac braindump - What is a dacpac?*, available at the official
    SQL Blog ([http://sqlblog.com/blogs/jamie_thomson/archive/2014/01/18/dacpac-braindump.aspx](http://sqlblog.com/blogs/jamie_thomson/archive/2014/01/18/dacpac-braindump.aspx)):'
  prefs: []
  type: TYPE_NORMAL
- en: In that single file are a collection of definitions of objects that one could
    find in a SQL Server database such as tables, stored procedures, views plus some
    instance level objects such as logins too (the complete list of supported objects
    for SQL Server 2012 can be found at DAC Support For SQL Server Objects and Versions).
    The fact that a dacpac is a file means you can do anything you could do with any
    other file, store it, email it, share it on a file server etc… and this means
    that they are a great way of distributing the definition of many objects (perhaps
    even an entire database) in a single file. Or, as Microsoft puts it, a self-contained
    unit of SQL Server database deployment that enables data-tier developers and database
    administrators to package SQL Server objects into a portable artifact called a
    DAC package, also known as a DACPAC.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Another interesting feature of these projects can be discovered by navigating
    to **Import** | **Database** in the project''s menu. If you choose this, you''ll
    be offered a dialog box in which you can select three different types of data
    origins: local, network, and Azure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, if we select the local option, we''ll be shown a list of all the
    database instances available (it will depend on our machine''s configuration):'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL Server from Visual Studio](img/image00541.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you're finished with this option, the process of importing data will take
    place—it might take some time depending on the size, the network speed (for network
    connections), or the Internet bandwidth (for Azure connections).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the process ends, you''ll find a whole set of elements in your project,
    each of them representing the objects available in the database you connected
    with: tables, schemas, functions, stored procedures, users, logins, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, you''ll have a representation, element by element, of the whole
    database in your project. A look at the files shows you that their content depends
    on its nature: for stored procedure, you''ll be shown the SQL statements required
    to create and define it, but for a table, you''ll be shown the design editor and
    other editing options to change it from Visual Studio, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL Server from Visual Studio](img/image00542.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Any modification you might make in the design or the definitions of any object
    in this project will be stored when compiling the project into the `.dacpac` file
    and can be easily restored or created in a destination DBMS of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that a `.dacpac` file is just a ZIP file, so you can add that extension
    to the file and inspect its contents, expressed in the XML syntax, which are nothing
    but the contents of the project you have created. They''re only packaged in a
    special manner: they convey the Open Packaging Convention, a standard format created
    by Microsoft, to rally these files together in a much lighter fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This format is now used by a number of applications inside and outside the
    Microsoft world: AutoDesk, AutoCad, Siemens PLM, MathWorks, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: So, these types of projects are the perfect complement to a solution that manages
    databases, and you can include them as part of your deployment process. If you're
    done with your modifications, you can build the project like you would with any
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your project built, you can publish the results in an existing
    DBMS. To do this, you'll select the **Publish** option, and you'll be required
    to get the initial data from the **Publish Configuration** dialog box, such as
    the connection string, database name, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this publishing configuration can be saved and stored for later use. The
    three buttons related to profiles allow you to load already existing profiles,
    creating a profile from the current configuration and saving the profile with
    a different name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting options appear, such as editing the database connection string
    (for example, to replicate it in a different SQL Server instance), and even more
    detailed information can be established with the **Advanced** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL Server from Visual Studio](img/image00543.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **Advanced** button deserves a look, since every aspect of the final creation
    in the target will be covered in there. Many of the options relate to the way
    we want to convert our data in the target DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that you have three tabs, allowing the configuration of general aspects
    of the process, and this includes elements you would like to delete (**Drop**)
    and that you would like to disregard (**Ignore**). The next screenshot shows this
    dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL Server from Visual Studio](img/image00544.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When everything is fine, the process will start and you'll be able to see the
    destination of the objects created right from Visual Studio; or, you can open
    SSMS as usual and inspect the result directly.
  prefs: []
  type: TYPE_NORMAL
- en: Data access in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using Visual Studio, you can create applications that connect to any kind of
    data, covering practically any database product or service in any format and anywhere:
    either from a local machine, LAN server, or located in the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The IDE enables you to explore data sources or create object models to store
    and manipulate data in the memory, and—of course—establish data-binding techniques
    in the user interface, no matter what type of UI you want: Console, Windows Forms,
    Windows Presentation Foundation, websites created with ASP.NET, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides, Microsoft Azure provides SDKs for .NET, Java, Node.js, PHP, Python,
    Ruby, mobile apps, and tools in Visual Studio in order to connect to Azure Storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows you the variety of database connections available
    in recent versions of the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Microsoft Azure (SQL and NoSQL) |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| SQL Database (Azure) | Azure Storage (Blobs, Tables, Queues, Files) | SQL
    Data Warehouse (Azure) |'
  prefs: []
  type: TYPE_TB
- en: '| SQL Server Stretch Database (Azure) | StorSimple (Azure) | DocumentDB (Azure)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Azure Redis Cache |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| SQL |'
  prefs: []
  type: TYPE_TB
- en: '| SQL Server 2005* - 2016 | MySQL | Oracle |'
  prefs: []
  type: TYPE_TB
- en: '| Firebird | PostgreSQL | SQLite |'
  prefs: []
  type: TYPE_TB
- en: '| NoSQL |'
  prefs: []
  type: TYPE_TB
- en: '| MongoDB | Apache Cassandra | NDatabase |'
  prefs: []
  type: TYPE_TB
- en: '| OrientDB | RavenDB | VelocityDB |'
  prefs: []
  type: TYPE_TB
- en: You have more information about this topic at [https://msdn.microsoft.com/en-us/library/wzabh8c4(v=vs.140).aspx](https://msdn.microsoft.com/en-us/library/wzabh8c4(v=vs.140).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these direct possibilities, there are many other vendors that allow
    Visual Studio integration via NuGet packages. Some other options are at your disposal
    as well, when using the **Extensions and Updates**" option of the main **Tools**
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: .NET data access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET data access—and that includes the new **.NET Core**—is based on **ADO.NET**,
    which is composed of a set of classes that define interfaces to access any kind
    of data source, both relational and non-relational. The IDE includes a customary
    number of tools in order to help connect to databases and create **ORMs** (**Object
    Relational Models**) that map the objects in the database to objects in a .NET
    language world.
  prefs: []
  type: TYPE_NORMAL
- en: The IDE's options include data manipulation in the memory and presenting data
    to the user in several user interfaces and dialog boxes, both at development time
    and runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in order to be consumable in ADO.NET, a database must have either
    a custom ADO.NET data provider, or it must expose an available ODBC or OLE DB
    interface. ADO.NET data providers for SQL Server as well as ODBC and OLE DB are
    offered by default. However, you can find an exhaustive list of providers at [https://msdn.microsoft.com/en-us/data/dd363565](https://msdn.microsoft.com/en-us/data/dd363565),
    which includes—but is not limited to—Oracle, MySQL, Sybase, IBM, SQLLite, and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio has several tools and designers that work with ADO.NET to help
    you connect to databases, manipulate the data in the memory, and present the data
    to the user. The official schema of the ADO.NET architecture is exposed in this
    image of MSDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '![.NET data access](img/image00545.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have two sets of classes in this diagram: those of the .NET
    Framework data provider we use and those related to the DataSet object, which
    is an in-memory representation of part (or all) of the data tables, relations,
    and constraints included in the original database.'
  prefs: []
  type: TYPE_NORMAL
- en: Both sets of classes include data maintenance, although the dataset offers some
    extra functionalities, useful in many cases, such as batch updates and provider-agnostic
    data storage. With this functionality, some impossible things are available, such
    as linking two tables via relationships, independently of the possible diverse
    origin of those tables (say, an Oracle table, a SQL server table, and a Excel
    Spreadsheet). Reinforce these relations at execution time, establishing business
    logic that is quite complex to code otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Using ADO.NET basic objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new WPF project, which we will use to read some data from our
    database and present it in a data grid inside a WPF window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve created the basic project, let''s add a new dataset. To do this,
    just select **Add New** in project''s options, and you''ll be presented with a
    blank design surface, in which you can drag and drop any table of the list of
    tables you''ll see in the Solution Explorer pointing to the `AdventureWorks` database.
    After choosing the **Person** table, you can add **Code Map**, selecting that
    option in the Solution Explorer''s top icons. You''ll have two windows as a result:
    one showing the data structure and another with the code schema, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ADO.NET basic objects](img/image00546.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that a new set of nested files has been created in your solution,
    showing several files that hold the class definitions related to the connection
    and the relational mapping I mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ADO.NET basic objects](img/image00547.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A look at the contents of the C# files generated will show a large number of
    functionalities that provide the majority of resources we need for CRUD operations,
    Stored Procedures calls, connection management, searches, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the user interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can add a new `DataGrid` object to our empty window, to be later populated
    with the data we read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to get the data directly when the window shows up is adding
    a `Loaded` event declared in the XAML editor at the end of the `<window>` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration, in the C# code, has created a `window_load` event handler.
    Next, we can use the `PersonTableAdapter` object created when defining our model
    in very simple way to load and bind data to our DataGrid object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `PersonTableAdapter` code takes care of establishing a connection
    to the database, loading the data previously defined in its internal `SQLCommand`
    object and returning a `DataView` object suitable to be assigned to DataGrid for
    the automatic creation of columns (as many as the table has), as shown in the
    next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the user interface](img/image00548.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By the way, the black toolbar on top of the data grid's header is a debugging
    option offered by Visual Studio that shows/hides layout adorners, enables/disables
    selection, and—optionally—takes you to a new window, Visual Tree, where you can
    inspect all elements in the XAML user interface and check their dependencies and
    values at runtime, as indicated in the arrow pointing to **LastName** `Miller`
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the properties of the TableAdapter and DataSet objects,
    you'll discover a very rich set of objects prepared for all sorts of data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: This was just a simple demo to check how easy it is to read data using ADO.NET
    if you use the ORM objects created for us by Visual Studio. However, ADO.NET is
    not the technology most commonly used these days, since other options are preferred
    when accessing relational databases, especially Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The Entity Framework data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Entity Framework, in the words of Microsoft, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity Framework** (**EF**) is an object-relational mapping technology that
    enables .NET developers to work with relational data using domain-specific objects.
    It eliminates the need for most of the data-access code that developers usually
    need to write. Entity Framework is the Microsoft''s recommended ORM modeling technology
    for new .NET applications.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find a nice, although basic, introductory video about Entity Framework
    at [https://msdn.microsoft.com/en-us/data/ef.aspx](https://msdn.microsoft.com/en-us/data/ef.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the latest version is .NET Core 1.1, and it''s still
    in the adoption phase by the community, so we''re using version 6.0 here, which
    is totally stable and widely tested. In this version, you have three initial choices:
    starting with an existing database, starting with an empty model, or starting
    with already existing code.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, called Database First, a connection is established to the
    DBMS to read metadata from the server and create a visual model of the selected
    objects. From that model, a set of classes is generated, which includes a wide
    range of CRUD and search operations by default.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to this is the behavior of the **Model First** option, in which you
    start from scratch, design a model in the graphical editor, and the classes' generations
    process follows. Optionally, you can generate the real database in the RDBMS depending
    on the connection string. In either case, you can automatically update your model
    when the underlying database changes, and the related code will be automatically
    generated as well. Both database generation and object-layer code generation are
    highly customizable.
  prefs: []
  type: TYPE_NORMAL
- en: In the third option, **Code First**, you start from some existing code and a
    heuristic process takes place in order to infer the corresponding model from that
    code, the rest of the options being similar to the other two scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: For a deeper approach at Entity Framework, I recommend *Mastering Entity Framework*,
    *Rahul Rajat Singh*, Packt Publishing ([https://www.packtpub.com/application-development/mastering-entity-framework](https://www.packtpub.com/application-development/mastering-entity-framework)).
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of the next demo, I'm using the Database First approach in order
    to show the most common operations with Entity Framework but changing the project
    type to be an ASP.NET MVC application this time, where the code used for data
    access should be totally independent from the IU that consumes the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a new ASP.NET application by selecting that option in the
    available projects. We will be offered several types of project variations depending
    on the version and project architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Entity Framework data model](img/image00549.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I selected the **No Authentication** feature in **Change Authentication** in
    order to avoid the automatic creation of a database. When clicking on **OK**,
    a new project will be generated (using the techniques we saw in previous chapter),
    and we'll end up with a basic, but functional, project with no data access.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the `Models` folder should be empty. So, right-click on that
    folder, select **Add New**, and in the **Data** menu, choose **ADO.NET Entity
    Data Model**. I'll name mine `AWModel` and proceed. At this point, you have to
    select the type of designer to use, which determines the model's contents. I've
    selected **EF Designer from Database**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to select the connection. The last one used will be presented
    by default, and the dialog box will generate a connection string in RichTextBox
    at the bottom. In case AdventureWorks doesn't show up, manually select the connection
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it's time to pick up which tables you want to work with, along with other
    objects, such as views and stored procedures. All of them will be used to generate
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this demo, I selected one table with a few columns to facilitate code reading,
    so I opted for `HumanResources.Department` with just four fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Entity Framework data model](img/image00550.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A simple schema should appear in the **Design** window and its properties, detailed
    in a bottom window called **Mapping Details**, which specifies how the original
    data types and restrictions defined in the database are modeled into the C# language,
    to be managed by Entity Framework classes.
  prefs: []
  type: TYPE_NORMAL
- en: This is important, since it allows you to specify exactly how you want EF Generators
    to behave when creating the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: There's another important feature to remember here. More often that not, changes
    happen in the original database, and that includes column reformatting or changing
    datatypes, adding (or deleting) tables, changing relations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, the contextual **Update Model from Database** option comes
    in handy. The entire model will be reread, and the corresponding changes will
    be updated, both in the **Mapping Details** section and the generated code, which
    will be regenerated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Entity Framework data model](img/image00551.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we need to understand how to modify code generation. This is done by means
    of the T4 templates, which are text files with the `.tt` extension, which you'll
    find within the files generated in the process, linked to the model's files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason to include these files is double: they allow the user to decide
    the way the code is generated, and they facilitate the creation itself (remember
    that Visual Studio uses CodeDOM internally among other techniques to generate
    code).'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the classes generated and you'll learn how the `Department` class
    has been created, along with an `AdventureWorks2014Entities` class, which will
    be the starting point for data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Well, now we need controllers and views to present the user with the typical
    CRUD options for data manipulation. Once again, the IDE comes to help. Select
    **Add Controller**, and a dialog box will appear to select the type of controllers
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you'll need to compile the project first, since actual assemblies
    might be required for code generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, keep in mind that due to the natural integration with Entity
    Framework, an option covering all required controllers and views will be offered.
    So, in the **Add Scalffold** dialog box, select the **MVC 5 Controller with Views,
    using Entity Framework** option. This will generate all the required code to test
    the basic CRUD data options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Entity Framework data model](img/image00552.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will still be asked about the model to use (**Department**, in my case),
    and about the `DataContext` class (`AdventureWorks2014Entities`). When the assistant
    finishes, several new files will have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll have a new `DepartmentsController` controller, which includes the
    CRUD operations I mentioned earlier. In addition, a new `Departments` folder appears,
    showing five new views, corresponding to **Create**, **Delete**, **Details** (to
    view only one department), **Edit**, and **Index**, which shows the whole list
    of departments, along with some links that will allow you to access the rest of
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first lines of that controller class indicates the suggested way to operate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `DBContext` object will recover all the departments and convert them into
    `List<Department>`, which is the model the view expects (take a look at the `Index.cshtml`
    file in the **Views/Departments** area). When launching it, you'll need to reference
    the controller in the URL, since by default, the application is configured to
    present the Home controller and the `Index` action method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type `http://localhost:[portNumber]/Departments`, the routing pattern
    will take you to the `Index` method in the `Departments` controller, and the following
    list will show up (it doesn''t matter which browser you use, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Entity Framework data model](img/image00553.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If everything goes fine, you'll be able to change data using the **Edit** and
    **Delete** links that the view presents automatically, and a selection of the
    **Details** option will take you to a different view, showing just the selected
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the basics of data access in relational models.
    First, we examined the concepts behind the relational model itself, including
    its basic and fundamental principles, its architecture, and the properties of
    relational tables.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we went through the Microsoft tools offered to work with these models,
    such as SQL Server 2014 Express Edition, and **SQL Server Management Studio**
    (**SSMS**), revising their programmatic and operational offers in editing, debugging,
    analyzing execution, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: After a brief note on the T-SQL language, we covered a not-well-known type of
    project that Visual Studio proposed, SQL Server Projects, and saw how we can create
    and manage packages (`.dacpac` files) that help us manage and administer any database
    and reproduce its structure in another RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed some data access options from within Visual Studio, demonstrating
    how to access data using two technologies that are widely known and accepted,
    ADO.NET (using a Windows Presentation Foundation application) and Entity Framework,
    inside a ASP.NET MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will switch from the relational to the noSQL model,
    and we''ll study its advantages and disadvantages and work with the MongoDB noSQL
    database in both ways: from the tools offered by the product and also from Visual
    Studio.'
  prefs: []
  type: TYPE_NORMAL
