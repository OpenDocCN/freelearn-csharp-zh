<html><head></head><body>
		<div id="_idContainer468">
			<h1 id="_idParaDest-163"><em class="italic"><a id="_idTextAnchor165"/>Chapter 9</em>: The Data-Oriented Technology Stack in Unity</h1>
			<p>The Unity engine is a very developer-friendly engine. When developing game logic, Unity's <strong class="bold">GameObject-Components</strong> architecture can help developers develop functions quickly, and adding a new behavior to a GameObject in Unity just requires attaching the corresponding component to it. However, with today's games becoming more complex, this approach, while very developer-friendly, especially to those familiar with traditional <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) models, is not ideal for game performance and project maintainability. </p>
			<p>Therefore, Unity introduced the <strong class="bold">Data-Oriented Technology Stack</strong> (<strong class="bold">DOTS</strong>) to allow developers to write game code using an alternative programming philosophy that is data-oriented rather than object-oriented. It also introduces multithreading capabilities to optimize the performance of the game. </p>
			<p>The following key topics will be part of our learning path in this chapter:</p>
			<ul>
				<li>DOTS overview</li>
				<li><a id="_idTextAnchor166"/>Multithreading and the C# Job System in Unity</li>
				<li>Working with ECS in Unity</li>
				<li>Using C# and the Burst compiler</li>
			</ul>
			<p>By reading this chapter, you will learn what DOTS is and the difference between data-oriented design and traditional object-oriented design. You will also find out how to use Unity's <strong class="bold">C# Job System</strong> to implement multithreading to improve game performance, how to use Unity's <strong class="bold">Entity Component System</strong> (<strong class="bold">ECS</strong>) to write game logic code in a data-oriented way, and how to use the <strong class="bold">Burst compiler</strong> to optimize the generated native code for Unity games. </p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor167"/>Technical requirements</h1>
			<p>The example project for this chapter is already available on GitHub. You can find it here: <a href="https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers/tree/main/Chapter9-DOTS">https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers/tree/main/Chapter9-DOTS</a>.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor168"/>DOTS overview</h1>
			<p>DOTS is a <a id="_idIndexMarker782"/>new programming pattern in Unity and a topic that has been discussed a lot in the Unity developers community in recent years. </p>
			<div>
				<div id="_idContainer433" class="IMG---Figure">
					<img src="image/Figure_9.01_B17146.jpg" alt="Figure 9.1 – The Megacity demo based on DOTS&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The Megacity demo based on DOTS</p>
			<p>If you have previous .NET programming experience, you will be familiar with the <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) pattern. OOP is widely adopted in the software industry, and developing<a id="_idIndexMarker783"/> games with Unity was no exception until Unity introduced DOTS. There's no doubt that OOP is an old habit for many programmers. Therefore, before discussing why Unity introduced DOTS, we will first talk about the problems that may be encountered when using OOP in Unity development.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor169"/>Object-oriented design pattern versus DOTS</h2>
			<p>First of all, let's <a id="_idIndexMarker784"/>talk about the<a id="_idIndexMarker785"/> concepts of OOP. We can find some useful information on Wikipedia. These concepts include <strong class="bold">object/class</strong>, <strong class="bold">inheritance</strong>, <strong class="bold">interface</strong>, <strong class="bold">information hiding</strong>, and <strong class="bold">polymorphism</strong>. The following link<a id="_idIndexMarker786"/> provides detailed explanations: <a href="https://en.wikipedia.org/wiki/Object-oriented_design">https://en.wikipedia.org/wiki/Object-oriented_design</a>.</p>
			<p>If we focus on the object/class and inheritance, we will find that these two concepts are the biggest difference between OOP and DOTS.</p>
			<p>Let's start with an <strong class="bold">object/class</strong>. In a traditional OOP pattern, a class<a id="_idIndexMarker787"/> is a tightly coupled set of data and behavior <a id="_idIndexMarker788"/>that acts on that data. Here, we have an example:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class Monster : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    # <strong class="bold">region Data</strong></p>
			<p class="source-code">    private string _name;</p>
			<p class="source-code">    private float _hp;</p>
			<p class="source-code">    private Vector3 _position;</p>
			<p class="source-code">    private bool _isDead;</p>
			<p class="source-code">    #endregion</p>
			<p class="source-code">    #<strong class="bold">region Behavior</strong></p>
			<p class="source-code">    public void Attack(Monster target){}</p>
			<p class="source-code">    public void Move(float speed){}</p>
			<p class="source-code">    public void Die(){}</p>
			<p class="source-code">    #endregion</p>
			<p class="source-code">}</p>
			<p>As you can see in the code, we have a<a id="_idIndexMarker789"/> class called <strong class="source-inline">Monster</strong> and it has some data for its position, health, name, and whether or not it's dead. In addition, this class can also behave like a real object on its own data. Each <strong class="source-inline">Monster</strong> object can attack the target, move itself, or die.</p>
			<p>So far, everything is perfect; the objects in the program are like objects in the real world, as if they have a life of their own, which is also in line with human experience. Next, let's discuss the <strong class="bold">inheritance</strong> concept of<a id="_idIndexMarker790"/> OOP. We can extend the data and behavior of a class and reuse some of its code via inheritance.</p>
			<p>Suppose in this example we <a id="_idIndexMarker791"/>realize that not all monsters attack other monsters; some may attack humans. From a programming perspective, humans and monsters have a lot in common: position, health, and whether or not it's dead. But some monsters may not be killed, and humans cannot fly to move. In real life, we have a superset of monsters and humans, namely, creatures. Let's put the data that monsters and humans share in the <strong class="source-inline">Creature</strong> class so that they can both have this data, but we don't have to type them again, as shown:</p>
			<p class="source-code">public class Creature : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    #region <strong class="bold">Data</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">    private string _name;</p>
			<p class="source-code">    private float _hp;</p>
			<p class="source-code">    private Vector3 _position;</p>
			<p class="source-code">    private bool _isDead;</p>
			<p class="source-code">    </p>
			<p class="source-code">    #endregion</p>
			<p class="source-code">}</p>
			<p class="source-code">public class Monster : Creature</p>
			<p class="source-code">{</p>
			<p class="source-code">    # region <strong class="bold">Data</strong></p>
			<p class="source-code">    private bool _canFly;</p>
			<p class="source-code">    #endregion</p>
			<p class="source-code">    #region <strong class="bold">Behavior</strong></p>
			<p class="source-code">    public void Attack(Creature target){}</p>
			<p class="source-code">    public void Move(float speed){}</p>
			<p class="source-code">    public void Die(){}</p>
			<p class="source-code">    </p>
			<p class="source-code">    #endregion</p>
			<p class="source-code">}</p>
			<p>Basically, if we keep going with<a id="_idIndexMarker792"/> this idea, we will end up with some complex class diagrams where you have a bunch of different creatures, such as monsters, humans, animals, and plants. We haven't even considered performance and we have already found that OOP can give us a lot of trouble. </p>
			<p>Now, let's see how OOP also misuses the hardware. With the development of technology, processor hardware is getting faster and faster, but a point that is often overlooked is that if the data cannot be submitted from memory to the processor fast enough, then no matter how fast the processor is, it will not work as fast as expected. <strong class="bold"> Cache</strong>, which is located closer<a id="_idIndexMarker793"/> to the processor core, is smaller, faster memory. When the processor issues a memory access request, it will first check whether there is data in the cache. If it exists (this is also called a cache hit), the data is returned directly without accessing the main memory; if it does not exist, the corresponding data in the main memory must be loaded into the cache first and then returned to the processor. CPUs typically use a hierarchy with multiple cache levels; for example, in a two-level cache system, the <strong class="bold">L1 cache</strong> is <a id="_idIndexMarker794"/>close to the processor side, and the <strong class="bold">L2 cache</strong> is close to the <a id="_idIndexMarker795"/>memory side. </p>
			<p>CPU caches are designed around several assumptions. The reason why the caches are effective is mainly that the access to the memory when the program runs is characterized by locality. This locality<a id="_idIndexMarker796"/> includes both <strong class="bold">spatial locality</strong> and <strong class="bold">temporal locality</strong>. That is, the<a id="_idIndexMarker797"/> pieces of data we need to perform a series of related operations may be very close to each other in memory, or the data we just used for an operation may soon be used again for another operation. Taking advantage of this locality, caches can achieve extremely high hit rates. </p>
			<p>However, OOP often misuses<a id="_idIndexMarker798"/> the hardware. Let's still use the <strong class="source-inline">Monster</strong> class as an example. Assuming a <strong class="source-inline">Monster</strong> object will occupy 56 bytes of memory, we iterate over a list of monsters and call their <strong class="source-inline">Move()</strong> function to change the monster's position property.</p>
			<p>The pseudocode is as follows:</p>
			<p class="source-code">    public void Update()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (var i = 0; i &lt; _monsters.count; i++) </p>
			<p class="source-code">        { </p>
			<p class="source-code">            _monsters[i].Move(speed); </p>
			<p class="source-code">        }</p>
			<p class="source-code">}</p>
			<p>This code actually modifies a set of Vector3 data every frame, but how is this data allocated in memory? The following diagram shows how monster objects are allocated in memory when a 64-byte cache line is split up into 8-byte chunks:</p>
			<div>
				<div id="_idContainer434" class="IMG---Figure">
					<img src="image/Figure_9.02_B17146.jpg" alt="Figure 9.2 – The data layout in memory (OOP)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – The data layout in memory (OOP)</p>
			<p>From the diagram, we <a id="_idIndexMarker799"/>can see that the position data that will be modified at every frame is discontinuous in memory, which means that our game cannot effectively use high-speed memory, that is, the caches.</p>
			<p>Now, let's look at the new programming pattern in Unity, DOTS.</p>
			<p>Unlike OOP, DOTS' philosophy<a id="_idIndexMarker800"/> is to design for data rather than objects, focusing on prioritizing and organizing data to make its memory access as efficient as possible. Let's still use the <strong class="source-inline">Monster</strong> class as an example to see how its data is allocated in memory when using DOTS.</p>
			<div>
				<div id="_idContainer435" class="IMG---Figure">
					<img src="image/Figure_9.03_B17146.jpg" alt="Figure 9.3 – The data layout in memory (DOTS)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – The data layout in memory (DOTS)</p>
			<p>Do you remember? When moving a monster, we actually only need 12 bytes of position data for the monster, so the code only needs to load and process the position data of all the monsters to move them. Using DOTS allows us to pack all of this position data into an array and allocate memory more efficiently, as shown in the previous figure. Placing data in a contiguous array in memory improves data locality, which results in extremely high hit rates for caches, which improves code performance. </p>
			<p>So, how does Unity's DOTS<a id="_idIndexMarker801"/> make developers' code run more efficiently? Well, DOTS in Unity is not just a change of programming paradigm from object-oriented to data-oriented; it actually includes a series of new technology modules, namely the following:</p>
			<ul>
				<li>The C# Job System</li>
				<li>ECS</li>
				<li>The Burst compiler<strong class="bold"> </strong></li>
			</ul>
			<p>Each of them consists of one or more Unity packages. We can install the corresponding functions through Unity's Package Manager. Next, we will briefly introduce these three modules, respectively.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor170"/>C# Job System</h2>
			<p>By using the C# Job System, we <a id="_idIndexMarker802"/>can write efficient asynchronous code in Unity that takes full advantage of the hardware.</p>
			<div>
				<div id="_idContainer436" class="IMG---Figure">
					<img src="image/Figure_9.04_B17146.jpg" alt="Figure 9.4 – Tech demo using the C# Job System&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Tech demo using the C# Job System</p>
			<p>The preceding figure <a id="_idIndexMarker803"/>shows a demo project developed using Unity's C# Job System, showing thousands of "soldiers" attacking the enemy in the scene. You can find this project on GitHub: <a href="https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation">https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation</a>.</p>
			<p>We will discuss the C# Job System in detail in the <em class="italic">Multithreaded and C# Job System in Unity</em> section.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor171"/>ECS</h2>
			<p>The full name of <strong class="bold">ECS</strong> is <strong class="bold">Entity Component System</strong>. It is the core part of DOTS in Unity and is built around using<a id="_idIndexMarker804"/> data-oriented design, which is very different from the object-oriented design you may be used to. </p>
			<div>
				<div id="_idContainer437" class="IMG---Figure">
					<img src="image/Figure_9.05_B17146.jpg" alt="Figure 9.5 – The Megacity demo&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – The Megacity demo</p>
			<p>The preceding figure shows Unity's impressive tech demo using ECS called <strong class="bold">Megacity</strong>, which developers can download<a id="_idIndexMarker805"/> here: <a href="https://unity.com/megacity">https://unity.com/megacity</a>.</p>
			<div>
				<div id="_idContainer438" class="IMG---Figure">
					<img src="image/Figure_9.06_B17146.jpg" alt="Figure 9.6 – Megacity download page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Megacity download page</p>
			<p>We'll cover ECS in detail in the <em class="italic">Working with ECS in Unity</em> section.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor172"/>The Burst compiler</h2>
			<p>The Burst compiler<a id="_idIndexMarker806"/> in Unity is an advanced compiler technology. Unity projects made with DOTS can use Burst technology to improve their runtime performance. Burst works on a subset of C# called <strong class="bold">High-Performance C#</strong> (<strong class="bold">HPC#</strong>) and applies <a id="_idIndexMarker807"/>advanced optimization methods under the LLVM compiler framework to generate efficient binaries, which achieves efficient use of device energy.</p>
			<p>We will introduce how to use it in your project in a later section, <em class="italic">Using C# and the Burst compiler</em>.</p>
			<p>This section introduces DOTS-related knowledge, such as what technology modules DOTS contains, how its design philosophy differs from traditional OOP, and what problems it solves. However, DOTS is not a replacement for OOP; it just provides another efficient programming pattern for game developers in Unity. For example, you can still use the C# Job System to implement multithreaded programming in the traditional Unity GameObject-Components style, rather than maintaining thread pools yourself. Well, next, let's explore how to implement efficient multithreaded programming in Unity.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor173"/>Multithreading and the C# Job System in Unity</h1>
			<p>Asynchronous programming is very common when developing .NET projects. But unlike what many people who are familiar with .NET development think, Unity's support for asynchronous programming was not friendly at first.  </p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor174"/>Coroutines</h2>
			<p>Before <a id="_idIndexMarker808"/>Unity 2017, if a game developer wanted to handle asynchronous operations, a common scenario was waiting for a network response. The ideal solution was to use <strong class="bold">coroutines</strong> in Unity. </p>
			<p>We can start a coroutine in Unity as follows:</p>
			<p class="source-code">    void Start()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var url = "https://jiadongchen.com";</p>
			<p class="source-code">        <strong class="bold">StartCoroutine</strong>(DownloadFile(url));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private static <strong class="bold">IEnumerator</strong> DownloadFile(string url)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var request = UnityWebRequest.Get(url);</p>
			<p class="source-code">        request.timeout = 10;</p>
			<p class="source-code">        <strong class="bold">yield return</strong> request.SendWebRequest();</p>
			<p class="source-code">        if (request.error != null)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            Debug.LogErrorFormat("error: {0}, url is: {1}",</p>
			<p class="source-code">              request.error, url);</p>
			<p class="source-code">            request.Dispose();</p>
			<p class="source-code">            yield break;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if (request.isDone)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            Debug.Log(request.downloadHandler.text);</p>
			<p class="source-code">            request.Dispose();</p>
			<p class="source-code">            <strong class="bold">yield break</strong>;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>As you can see in the code, we use the <strong class="source-inline">StartCoroutine</strong> function to start a coroutine, and inside the <a id="_idIndexMarker809"/>coroutine, we can pause the execution by using <strong class="source-inline">yield</strong> statements. However, coroutines are still inherently single-threaded, just spread-out tasks across multiple frames, rather than multithreaded.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor175"/>async/await</h2>
			<p>Unity introduced the <strong class="source-inline">async/await</strong> operator<a id="_idIndexMarker810"/> in Unity 2017, allowing game developers to use <strong class="source-inline">async/await</strong> in their games to write asynchronous code, but it's still not like a normal .NET/C# program. This is because the Unity engine manages these threads by itself, and most of the logic runs on Unity's main thread, which includes not only the C# code as scripts but also the engine's C++ code. We can use the <strong class="bold">Unity Profiler</strong> tool<a id="_idIndexMarker811"/> to view the CPU timeline. As shown in the following screenshot, the Unity engine runs scripts in the main thread by default: </p>
			<div>
				<div id="_idContainer439" class="IMG---Figure">
					<img src="image/Figure_9.07_B17146.jpg" alt="Figure 9.7 – The Timeline of CPU&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – The Timeline of CPU</p>
			<p>There are 50 GameObjects in this scene, and each of them is attached with a <strong class="bold">MainThreadExample</strong> script. You can see that the <strong class="bold">Update</strong> functions in these 50 scripts are executed one by one.</p>
			<p>You can multithread different types of tasks; for example, doing some Vector3 math in a separate thread is no problem. But as long as the task needs to access the transform or GameObject outside Unity's main thread, the program will throw an exception. </p>
			<p>Let's look at an example. The purpose of the following code is to change the scale of the GameObject and use <strong class="source-inline">async/await</strong> to perform<a id="_idIndexMarker812"/> the operation in another thread:</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class AsyncExceptionTest : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    private <strong class="bold">async</strong> void Start()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        <strong class="bold">await</strong> ScaleObjectAsync();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private <strong class="bold">async</strong> Task&lt;Vector3&gt; ScaleObjectAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return <strong class="bold">await</strong> Task.Run(() =&gt; <strong class="bold">transform.localScale</strong> = new</p>
			<p class="source-code">          Vector3(2, 2, 2));</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Attach this script to a GameObject in the scene, then click the <strong class="bold">Play</strong> button in the Unity editor to run the script. The<a id="_idIndexMarker813"/> result of the operation is that the scale of the GameObject has not changed, and a <strong class="bold">UnityException: get_transform can only be called from the main thread</strong> exception is thrown, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer440" class="IMG---Figure">
					<img src="image/Figure_9.08_B17146.jpg" alt="Figure 9.8 – Exception&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – Exception</p>
			<p>So, you should take care of this and not access transforms or GameObjects from threads other than Unity's main thread.</p>
			<p>As we mentioned earlier, we can do math in a separate thread. So, in order to make the previous code work correctly, we can just calculate the scale value in different threads, access the <strong class="source-inline">Transform</strong> component, and modify the <strong class="source-inline">localScale</strong> property of it in Unity's main thread:</p>
			<p class="source-code">    private async Task ScaleObjectAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var newScale = Vector3.zero;</p>
			<p class="source-code">        <strong class="bold">await Task.Run(() =&gt; newScale = CalculateSize());</strong></p>
			<p class="source-code">        transform.localScale = newScale;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private Vector3 CalculateSize()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Debug.Log("Threads");</p>
			<p class="source-code">        return new Vector3(2, 2, 2);</p>
			<p class="source-code">    }</p>
			<p>This time, everything is<a id="_idIndexMarker814"/> going well and if we view the Unity Profiler again, we can find the timeline of these threads in the <strong class="bold">Scripting Threads</strong> section, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer441" class="IMG---Figure">
					<img src="image/Figure_9.09_B17146.jpg" alt="Figure 9.9 – Scripting threads&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Scripting threads</p>
			<p>However, as a developer, there are still many challenges with writing thread-safe and efficient code even in C#, such as the following:</p>
			<ul>
				<li>Thread-safe code is hard to write.</li>
				<li>Race conditions, where the result of a computation depends on the order in which two or more threads are scheduled. </li>
				<li>Inefficient context switching; is time-consuming when switching threads.</li>
			</ul>
			<p>The C# Job System in Unity is a solution that focuses on solving these challenges so that we can enjoy the benefits of multithreading to develop games. Next, let's explore how to use the C# Job System in our Unity projects.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor176"/>Working with the C# Job System</h2>
			<p>The <strong class="bold">Job System</strong> was <a id="_idIndexMarker815"/>originally the internal thread management system of the Unity engine, but with the growth of developers' demands for multithreaded programming in Unity, Unity introduced the C# Job System, which allows developers to write multithreaded parallel processing code painlessly in C# scripts to improve games' performance. Game developers do not need to implement complex thread pools themselves to keep each thread running properly. The C# Job System is integrated with Unity's native Job System, and C# script code and Unity engine's C++ code share threads. </p>
			<p>This form of cooperation<a id="_idIndexMarker816"/> allows game developers to write code in the way required by the Job System; the Unity engine handles multithreading for game developers and developers no longer have to worry about problems that may be encountered when writing multithreaded code, because the C# Job System will not create any managed threads, but instead use Unity's worker threads on multiple cores, giving them tasks, which are <a id="_idIndexMarker817"/>called <strong class="bold">jobs</strong> in Unity. </p>
			<h3>Installing the Jobs package</h3>
			<p>In order to install and <a id="_idIndexMarker818"/>enable the <strong class="bold">Job System</strong> in your project, you need to install the <strong class="bold">Jobs</strong> package first, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer442" class="IMG---Figure">
					<img src="image/Figure_9.10_B17146.jpg" alt="Figure 9.10 – The Jobs package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – The Jobs package</p>
			<p>However, the <strong class="bold">Jobs</strong> package is currently still in the preview state, as shown in the preceding screenshot, and the Unity Package Manager does not display packages in the preview state by default. So, if you can't find the <strong class="bold">Jobs</strong> package, then you need to follow these steps to allow showing the package in the preview state:</p>
			<ol>
				<li>Open the <strong class="bold">Project Settings</strong> window by clicking the <strong class="bold">Edit</strong> | <strong class="bold">Project Settings…</strong> item in the Unity editor toolbar, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer443" class="IMG---Figure">
					<img src="image/Figure_9.11_B17146.jpg" alt="Figure 9.11 – Opening the Project Settings window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – Opening the Project Settings window</p>
			<ol>
				<li value="2">Next, click<a id="_idIndexMarker819"/> the <strong class="bold">Package Manager</strong> item in the category list on the left to open the <strong class="bold">Package Manager</strong> settings panel. </li>
			</ol>
			<div>
				<div id="_idContainer444" class="IMG---Figure">
					<img src="image/Figure_9.12_B17146.jpg" alt="Figure 9.12 – Opening the Package Manager settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – Opening the Package Manager settings</p>
			<ol>
				<li value="3">In the following screenshot, you can see that the <strong class="bold">Enable Preview Packages</strong> option is not selected by default.  Let's check it to enable preview packages in the Unity Package Manager.</li>
			</ol>
			<p class="figure-caption">      </p>
			<div>
				<div id="_idContainer445" class="IMG---Figure">
					<img src="image/Figure_9.13_B17146.jpg" alt="Figure 9.13 – Enable Preview Packages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – Enable Preview Packages</p>
			<p>Once done, you should be <a id="_idIndexMarker820"/>able to find the <strong class="bold">Jobs</strong> package and install it into your project.</p>
			<p>Next, let's look at an example to understand how to use the Job System to improve the performance of a game.</p>
			<h3>How to use the C# Job System </h3>
			<p>In this example, we <a id="_idIndexMarker821"/>will first use Unity's traditional way, that is, the GameObject+Components way, to create 10,000 cartoon cars in a game scene, with each car containing a Movement component to move it.</p>
			<div>
				<div id="_idContainer446" class="IMG---Figure">
					<img src="image/Figure_9.14_B17146.jpg" alt="Figure 9.14 – The car models&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – The car models</p>
			<p>The car models used in this <a id="_idIndexMarker822"/>example are from the Unity Asset Store, and you can download them here: <a href="https://assetstore.unity.com/packages/3d/vehicles/land/mobile-toon-cars-free-99857">https://assetstore.unity.com/packages/3d/vehicles/land/mobile-toon-cars-free-99857</a>. Then, take the following steps:</p>
			<ol>
				<li value="1">Let's create our first C# script, named <strong class="source-inline">CarSpawner</strong>, to generate the cars in the scene. In this script, we can create 10,000 new car instances from the car prefab by pressing the spacebar. As you can see in the following code, inside the <strong class="source-inline">Update</strong> method, we use the <strong class="source-inline">Input.GetKeyDown(KeyCode.Space)</strong> method to check whether the spacebar is pressed. If the spacebar is pressed, the <strong class="source-inline">CreateCars</strong> method is called to create new car instances:<p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using UnityEngine;</p><p class="source-code">public class CarSpawner : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">[SerializeField] </p><p class="source-code">private List&lt;GameObject&gt; _carPrefabs;</p><p class="source-code">[SerializeField] </p><p class="source-code">private float _rightSide, _leftSide, _frontSide,</p><p class="source-code">  _backSide;</p><p class="source-code">    private void Update()</p><p class="source-code">    {</p><p class="source-code">        if(<strong class="bold">Input.GetKeyDown(KeyCode.Space</strong>))</p><p class="source-code">        {</p><p class="source-code">            CreateCars(10000);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    private void CreateCars(int count)</p><p class="source-code">    {</p><p class="source-code">        for(var i = 0; i &lt; count; i++)</p><p class="source-code">        {</p><p class="source-code">            var posX = Random.Range(_rightSide,</p><p class="source-code">              _leftSide);</p><p class="source-code">            var posZ = Random.Range(_frontSide,</p><p class="source-code">              _backSide);</p><p class="source-code">            var pos = new Vector3(posX, 0f, posZ);</p><p class="source-code">            var rot = Quaternion.Euler(0f, 0f, 0f);</p><p class="source-code">            int index = Random.Range(0,</p><p class="source-code">              _carPrefabs.Count);</p><p class="source-code">            var carPrefab = _carPrefabs[index];</p><p class="source-code">            var carInstance = <strong class="bold">Instantiate</strong>(carPrefab, pos,</p><p class="source-code">              rot);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, we also <a id="_idIndexMarker823"/>need another script that will be attached to each of the car objects to move them. As you can see, this <strong class="source-inline">Movement</strong> script is relatively simple; it moves the GameObject forward:<p class="source-code">using UnityEngine;</p><p class="source-code">public class Movement : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">[SerializeField] </p><p class="source-code">private float _speed;</p><p class="source-code">    private void Update()</p><p class="source-code">    {</p><p class="source-code">        transform.position += transform.forward *</p><p class="source-code">          _speed * Time.deltaTime;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Then, attach this <strong class="source-inline">Movement</strong> script to the car prefab. </li>
			</ol>
			<div>
				<div id="_idContainer447" class="IMG---Figure">
					<img src="image/Figure_9.15_B17146.jpg" alt="Figure 9.15 – The car Prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15 – The car Prefab</p>
			<ol>
				<li value="4">Click the <strong class="bold">Play</strong> button<a id="_idIndexMarker824"/> in the Unity editor to run the example and press the spacebar to generate 10,000 cars in the scene. As shown in the following screenshot, when there are 10,000 cars in the scene, the value of <strong class="bold">Frames per Second</strong> (<strong class="bold">FPS</strong>) is around <strong class="bold">12</strong>: </li>
			</ol>
			<div>
				<div id="_idContainer448" class="IMG---Figure">
					<img src="image/Figure_9.16_B17146.jpg" alt="Figure 9.16 – The FPS&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16 – The FPS</p>
			<ol>
				<li value="5">We can view the CPU usage timeline of this example. Press <em class="italic">Ctrl</em> + <em class="italic">7</em> or click the <strong class="bold">Window</strong> | <strong class="bold">Analysis</strong> | <strong class="bold">Profiler</strong> item in the Unity editor toolbar to open the <strong class="bold">Profiler</strong> window. Here, we can see that the <strong class="source-inline">Movement.Update</strong> for these 10,000 cars happens on the main thread while the job workers are idle. </li>
			</ol>
			<div>
				<div id="_idContainer449" class="IMG---Figure">
					<img src="image/Figure_9.17_B17146.jpg" alt="Figure 9.17 – The Timeline of CPU&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17 – The Timeline of CPU</p>
			<p>Obviously, when we see<a id="_idIndexMarker825"/> all the logic being executed on the main thread, as game developers we definitely want to be able to have some operations running on other threads. However, before we start writing some real code, we should cover a little bit about how to write jobified code in Unity.</p>
			<p>In Unity's Job System, each job can be seen as a method call. When writing a new job, you must follow these points:</p>
			<ul>
				<li>In order to ensure that the data is distributed contiguously in memory, and to reduce <strong class="bold">Garbage Collection</strong> (<strong class="bold">GC</strong>) pressure, a job must be a value type, which means it must be a struct, never a class. </li>
				<li>A new job struct needs to implement the <strong class="source-inline">IJob</strong> interface. There are many variants of the <strong class="source-inline">IJob</strong> interface, such as <strong class="source-inline">IJobParallelFor</strong>, <strong class="source-inline">IJobParallelForBatch</strong>, and <strong class="source-inline">IJobParallelForTransform</strong>. When implementing these interfaces, we need to implement the <strong class="source-inline">Execute</strong> method. It is worth noting that the parameters required by the <strong class="source-inline">Execute</strong> method are different when implementing different variants of the <strong class="source-inline">IJob</strong> interface, which allows us to handle different scenarios. For example, a new <strong class="source-inline">job</strong> implementing the <strong class="source-inline">IJobParallelForTransform</strong> interface can access transform data, such as position, rotation, and scale data, in parallel.</li>
			</ul>
			<p>The following code is for a <a id="_idIndexMarker826"/>sample job that implements the <strong class="source-inline">IJobParallelFor</strong> interface:</p>
			<p class="source-code">using Unity.Jobs;</p>
			<p class="source-code">public <strong class="bold">struct</strong> SampleJob : <strong class="bold">IJobParallelFor</strong></p>
			<p class="source-code">{</p>
			<p class="source-code">    public void <strong class="bold">Execute</strong>(int index)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        throw new System.NotImplementedException();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We have created a new job, but how do we make it work? Well, we have to schedule it. Usually, scheduling a job is very simple. The following code demonstrates how to schedule it:</p>
			<p class="source-code">SampleJob job = new SampleJob();</p>
			<p class="source-code">JobHandle handle = job.<strong class="bold">Schedule</strong>();</p>
			<p class="source-code">handle.Complete();</p>
			<p>We've covered some basics on how to create a new job and how to make it work. Now, let's use the Job System to rewrite the <strong class="source-inline">Movement</strong> script to distribute the operation of moving the cars to different threads to run:</p>
			<ol>
				<li value="1">First of all, let's create a job that moves cars. You can find the new <strong class="source-inline">MotionJob</strong> script below. <strong class="source-inline">MotionJob</strong> is a struct rather than a class and implements the <strong class="source-inline">IJobParallelForTransform</strong> interface, so this job can access the position data and modify it:<p class="source-code">using UnityEngine;</p><p class="source-code">using UnityEngine.Jobs;</p><p class="source-code">public <strong class="bold">struct</strong> MotionJob : <strong class="bold">IJobParallelForTransform</strong></p><p class="source-code">{</p><p class="source-code">    public float Speed, DeltaTime;</p><p class="source-code">    public Vector3 Direction;</p><p class="source-code">    public void <strong class="bold">Execute</strong>(int index, <strong class="bold">TransformAccess</strong></p><p class="source-code"><strong class="bold">     </strong> transform)</p><p class="source-code">    {</p><p class="source-code">        transform.position += Direction * Speed *</p><p class="source-code">          DeltaTime;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, we need <a id="_idIndexMarker827"/>another script called <strong class="source-inline">JobsManager</strong> to create the job, provide it with transform data (specifically in the script, we use the <strong class="source-inline">TransformAccessArray</strong> struct to provide this data), and schedule it. Also, this script is similar to the previous <strong class="source-inline">CarSpawner</strong> script. It checks whether the spacebar is pressed and creates 10,000 cars in the game scene if the spacebar is pressed. First, let's see how to create and schedule a job on Unity's Job worker thread. In the <strong class="source-inline">Update</strong> method, we create a new <strong class="source-inline">MotionJob</strong> object and pass data to it, such as <strong class="source-inline">deltaTime</strong>, <strong class="source-inline">speed</strong>, and <strong class="source-inline">direction</strong> to create a new job, then we call <strong class="source-inline">_motionJob.Schedule</strong> to distribute the job to different threads:<p class="source-code">using UnityEngine;</p><p class="source-code">using UnityEngine.Jobs;</p><p class="source-code">using Unity.Jobs;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">public class JobsManager : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">[SerializeField] </p><p class="source-code">private List&lt;GameObject&gt; _carPrefabs;</p><p class="source-code">[SerializeField] </p><p class="source-code">private float _rightSide, _leftSide, _frontSide,</p><p class="source-code">  _backSide, _speed;</p><p class="source-code">    private <strong class="bold">TransformAccessArray</strong> _transArrays;</p><p class="source-code">    private <strong class="bold">JobHandle</strong> _jobHandle;</p><p class="source-code">    private <strong class="bold">MotionJob</strong> _motionJob;</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        _transArrays = new</p><p class="source-code">          TransformAccessArray(10000);</p><p class="source-code">        _jobHandle = new JobHandle();</p><p class="source-code">    }</p><p class="source-code">    private void Update()</p><p class="source-code">    {</p><p class="source-code">        _jobHandle.Complete();</p><p class="source-code">        if(Input.GetKeyDown(KeyCode.Space))</p><p class="source-code">        {</p><p class="source-code">            CreateCars(10000);</p><p class="source-code">        }</p><p class="source-code">        // Create the Job</p><p class="source-code">        _motionJob = <strong class="bold">new MotionJob()</strong></p><p class="source-code">        {</p><p class="source-code">            DeltaTime = Time.deltaTime,</p><p class="source-code">            Speed = _speed,</p><p class="source-code">            Direction = Vector3.forward</p><p class="source-code">        };</p><p class="source-code">        // Provide the transform data and schedule the</p><p class="source-code">           Job.</p><p class="source-code">        <strong class="bold">_jobHandle = _motionJob.Schedule(_transArrays);</strong></p><p class="source-code">    }</p></li>
				<li>Next, let's see <a id="_idIndexMarker828"/>how to create cars in the code. Since we only need the position data for these cars this time, in the <strong class="source-inline">CreateCars</strong> method, we add the car's transform data to <strong class="source-inline">TransformAccessArray</strong> so that the job we just created can access <strong class="source-inline">TransformAccessArray</strong> to get that transform data. The <strong class="source-inline">CreateCars</strong> method is as follows:<p class="source-code">    private void CreateCars(int count)</p><p class="source-code">    {</p><p class="source-code">        _jobHandle.Complete();</p><p class="source-code">        _transArrays.capacity = _transArrays.length +</p><p class="source-code">          count;</p><p class="source-code">        for (var i = 0; i &lt; count; i++)</p><p class="source-code">        {</p><p class="source-code">            var posX = Random.Range(_rightSide,</p><p class="source-code">              _leftSide);</p><p class="source-code">            var posZ = Random.Range(_frontSide,</p><p class="source-code">              _backSide);</p><p class="source-code">            var pos = new Vector3(posX, 0f, posZ);</p><p class="source-code">            var rot = Quaternion.Euler(0f, 0f, 0f);</p><p class="source-code">            int index = Random.Range(0,</p><p class="source-code">              _carPrefabs.Count);</p><p class="source-code">            var carPrefab = _carPrefabs[index];</p><p class="source-code">            var carInstance = Instantiate(carPrefab,</p><p class="source-code">              pos, rot);</p><p class="source-code">            <strong class="bold">_transArrays.Add(carInstance.transform);</strong></p><p class="source-code">        }</p><p class="source-code">}</p></li>
				<li>This time, we no<a id="_idIndexMarker829"/> longer need to attach the Movement component to each car instance at runtime to move the car, so we need to remove the <strong class="bold">Movement </strong>component that was previously attached to the car prefab.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer450" class="IMG---Figure">
					<img src="image/Figure_9.18_B17146.jpg" alt="Figure 9.18 – Removing the Movement component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18 – Removing the Movement component</p>
			<ol>
				<li value="5">Click the <strong class="bold">Play</strong> button<a id="_idIndexMarker830"/> in the Unity editor to run the example and press the spacebar to generate 10,000 cars in the scene. As shown in the following screenshot, when there are 10,000 cars in the scene, this time the value of FPS is around <strong class="bold">19</strong>. In a scene with 10,000 cars in motion, the game's frame rate nearly doubled:</li>
			</ol>
			<p class="figure-caption">   </p>
			<div>
				<div id="_idContainer451" class="IMG---Figure">
					<img src="image/Figure_9.19_B17146.jpg" alt="Figure 9.19 – The FPS&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.19 – The FPS</p>
			<ol>
				<li value="6">Let's press <em class="italic">Ctrl</em> + <em class="italic">7</em> or click the <strong class="bold">Window</strong> | <strong class="bold">Analysis</strong> | <strong class="bold">Profiler</strong> item in the Unity editor toolbar to<a id="_idIndexMarker831"/> open the <strong class="bold">Profiler</strong> window to view the CPU usage timeline this time. Here, we can see that <strong class="bold">MotionJob</strong> is spread over multiple Job worker threads in Unity, instead of running on the main thread.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer452" class="IMG---Figure">
					<img src="image/Figure_9.20_B17146.jpg" alt="Figure 9.20 – Running on Job worker threads&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20 – Running on Job worker threads</p>
			<p>Through this example, we saw how to use the Job System in Unity to improve the running performance of the game.</p>
			<p>In this section, we discussed topics related to using asynchronous programming in Unity. Next, we will discuss another important topic in DOTS – namely, ECS.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor177"/>Working with ECS in Unity</h1>
			<p>Unity has<a id="_idIndexMarker832"/> always been centered around the concept of components; for example, we can add a Movement component to a GameObject so that the object can move. We can also add a Light component to the GameObject to make it emit light. We also add the AudioSource component, which can make the GameObject emit sound. In this case, the GameObject is a container to which game developers can attach different components to provide different behaviors. We can call this architecture a <strong class="bold">GameObject-Components</strong> relationship. In this architecture, we use the traditional OOP programming paradigm to write components, coupling data and behavior together. In the previous section, <em class="italic">Object-oriented design pattern versus DOTS</em>, we also discussed the impact of OOP on game performance. </p>
			<p>So, to address these issues, Unity introduced ECS, which allows developers to write data-oriented code in Unity. In ECS, data and behavior are separated, which can greatly improve memory usage efficiency and thus improve performance.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The so-called <strong class="bold">behavior</strong> here, specifically, is <strong class="bold">methods</strong>. </p>
			<p>As its name suggests, ECS consists <a id="_idIndexMarker833"/>of three parts, namely the following:</p>
			<ul>
				<li>Entity</li>
				<li>Component</li>
				<li>System</li>
			</ul>
			<p>We will introduce them respectively in the following sections.</p>
			<h3>Entity</h3>
			<p>When using ECS, we talk<a id="_idIndexMarker834"/> more about entities, not GameObjects. You might think that there is not much difference between an entity and a GameObject, because you might think of an entity as a container for components, just like a GameObject. However, this is not the case. An entity is just an integer ID. It is neither an object nor a container. Its function is to associate the data of its components together.</p>
			<h4>EntityManager and World</h4>
			<p>If you want to create new entities in your own C# code, Unity provides the <strong class="source-inline">EntityManager</strong> class<a id="_idIndexMarker835"/> to manage entities, which you can use to create entities, update entities, and destroy entities. ECS <a id="_idIndexMarker836"/>uses the <strong class="source-inline">World</strong> class to organize entities, and only one <strong class="source-inline">EntityManager</strong> instance can exist in a <strong class="source-inline">World</strong>. </p>
			<p>When we click the <strong class="bold">Play</strong> button in the Unity Editor to run the game, Unity will create a <strong class="source-inline">World</strong> by default, so we can get the <strong class="source-inline">EntityManager</strong> that exists in the default <strong class="source-inline">World</strong> with the following code:</p>
			<p class="source-code">var entityManager =</p>
			<p class="source-code">  World.DefaultGameObjectInjectionWorld.EntityManager;</p>
			<h4>Archetypes</h4>
			<p>ECS combines all entities with the same set of components in memory. ECS refers to this type of component set as<a id="_idIndexMarker837"/> an <strong class="bold">Archetype</strong>. Assuming that an entity has only two components, then those two components form a new Archetype. The following pseudocode demonstrates how to use <strong class="source-inline">EntityManager</strong> to create an Archetype that holds a set of components:</p>
			<p class="source-code">ComponentType[] types;</p>
			<p class="source-code">var archetype = entityManager.<strong class="bold">CreateArchetype</strong>(types);</p>
			<h4>NativeArray</h4>
			<p>Undoubtedly, we also need <a id="_idIndexMarker838"/>an array to hold the newly created entities. But in ECS, we will use a different container than a traditional array in .NET programming, namely, <strong class="source-inline">NativeArray</strong>. </p>
			<p><strong class="source-inline">NativeArray</strong> provides a C# wrapper for accessing native memory so that game developers can share data directly between managed and native memory. Therefore, operations on <strong class="source-inline">NativeArray</strong> do not generate GC of managed memory like common arrays in .NET and require elements to be value types, that is, structs. The following pseudocode shows how to create a new <strong class="source-inline">NativeArray</strong> and create new entities:</p>
			<p class="source-code">var entityArray = new <strong class="bold">NativeArray&lt;Entity&gt;(count,</strong></p>
			<p class="source-code"><strong class="bold">  Allocator.Temp)</strong>;</p>
			<p class="source-code">entityManager.<strong class="bold">CreateEntity</strong>(entityArchetype, entityArray);</p>
			<h3>Component</h3>
			<p>In ECS, there are also<a id="_idIndexMarker839"/> components, but the component in ECS is a different concept from the Movement "component" mentioned when talking about the GameObject-Components relationship previously. Before ECS was introduced, we usually thought of <strong class="source-inline">MonoBehaviour</strong> attached to GameObjects as components. <strong class="source-inline">MonoBehaviour</strong> contains data and behavior. ECS is different because entities and components do not have any behavioral logic; they only contain data, and logical operations will be handled by the system in ECS.</p>
			<p>A component <a id="_idIndexMarker840"/>must be a struct rather than a class and needs to implement one of the following interfaces:</p>
			<ul>
				<li><strong class="source-inline">IComponentData</strong></li>
				<li><strong class="source-inline">ISharedComponentData</strong></li>
				<li><strong class="source-inline">IBufferElementData</strong></li>
				<li><strong class="source-inline">ISystemStateComponentData</strong></li>
				<li><strong class="source-inline">ISharedSystemStateComponentData</strong></li>
			</ul>
			<p>The <strong class="source-inline">IComponentData</strong> interface is commonly used. The following uses it as an example to show how to create a new component in ECS:</p>
			<p class="source-code">using Unity.Entities;</p>
			<p class="source-code">public <strong class="bold">struct</strong> SampleComponent : <strong class="bold">IComponentData</strong></p>
			<p class="source-code">{</p>
			<p class="source-code">    public int Value;</p>
			<p class="source-code">}</p>
			<p>If you try to add this <strong class="source-inline">SampleComponent</strong> to a GameObject in the scene, you will find that you can't because it doesn't inherit from the <strong class="source-inline">MonoBehaviour</strong> class. But you can add the <strong class="source-inline">[GenerateAuthoringComponent]</strong> attribute to your component to mark it as an authoring component, as follows:</p>
			<p class="source-code">using Unity.Entities;</p>
			<p class="source-code"><strong class="bold">[GenerateAuthoringComponent]</strong></p>
			<p class="source-code">public struct SampleComponent : IComponentData</p>
			<p class="source-code">{</p>
			<p class="source-code">    public int Value;</p>
			<p class="source-code">}</p>
			<p>An authoring <a id="_idIndexMarker841"/>component can be added to a GameObject even if it does not inherit from MonoBehaviour.</p>
			<h3>System</h3>
			<p>We already know that when<a id="_idIndexMarker842"/> using ECS, data and behavior are decoupled. In ECS, all logic is handled by <strong class="bold">systems</strong>, which takes a group of entities and performs the requested behavior based on the data contained in the grouped entities. As we already know, using ECS can make our code access memory efficiently, and in fact, systems in ECS can also be combined with the C# Job System to efficiently utilize multithreading and further improve game performance.</p>
			<p>We can create a new system in ECS. The following code is an example:</p>
			<p class="source-code">using Unity.Entities;</p>
			<p class="source-code">public class SampleSystem : <strong class="bold">SystemBase</strong></p>
			<p class="source-code">{</p>
			<p class="source-code">    protected override void <strong class="bold">OnUpdate</strong>()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Entities.<strong class="bold">ForEach</strong>((ref SampleComponent sample) =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">            sample.Value = -1;</p>
			<p class="source-code">        }).</p>
			<p class="source-code">        <strong class="bold">ScheduleParallel</strong>();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, this new <strong class="source-inline">SampleSystem</strong> inherits the <strong class="source-inline">SystemBase</strong> class, and there is a <strong class="source-inline">ScheduleParallel</strong> Lambda function<strong class="bold"> </strong>after the <strong class="source-inline">Entites.ForEach</strong> loop in <strong class="source-inline">OnUpdate</strong> for scheduling work to Unity's Job worker threads using the C# Job System.</p>
			<p>Through these brief introductions, I believe you have a general understanding of ECS. Next, let's install ECS in our project.</p>
			<h3>Installing the Entities and Hybrid Renderer packages</h3>
			<p>In order to install and enable <a id="_idIndexMarker843"/>ECS in your project, you need to install the <strong class="bold">Entities</strong> package first, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer453" class="IMG---Figure">
					<img src="image/Figure_9.21_B17146.jpg" alt="Figure 9.21 – The Entities package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.21 – The Entities package</p>
			<p>As shown in the preceding screenshot, the <strong class="bold">Entities</strong> package is also in the preview state. Although we checked the <strong class="bold">Enable Preview Packages</strong> option in the previous subsection, the Package Manager still does not display this package. This is because starting from Unity 2020.1, this package is no longer hosted on Unity Registry, but hosted on GitHub, so we<a id="_idIndexMarker844"/> need to follow these steps to install it:</p>
			<ol>
				<li value="1">The Package Manager window can be opened by clicking the <strong class="bold">Window</strong> | <strong class="bold">Package Manager</strong> item in the Unity editor toolbar, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer454" class="IMG---Figure">
					<img src="image/Figure_9.22_B17146.jpg" alt="Figure 9.22 – Opening the Package Manager window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.22 – Opening the Package Manager window</p>
			<ol>
				<li value="2">Click the <strong class="bold">+</strong> button<a id="_idIndexMarker845"/> in the upper-left corner to add packages from other sources.</li>
			</ol>
			<div>
				<div id="_idContainer455" class="IMG---Figure">
					<img src="image/Figure_9.23_B17146.jpg" alt="Figure 9.23 – Adding packages from other sources&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.23 – Adding packages from other sources</p>
			<ol>
				<li value="3">Click <strong class="bold">Add package from git URL…</strong> to install the <strong class="bold">Entities</strong> package in your project. The name of the package is <strong class="source-inline">com.unity.entities</strong>, so we enter it and click the <strong class="bold">Add</strong> button.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer456" class="IMG---Figure">
					<img src="image/Figure_9.24_B17146.jpg" alt="Figure 9.24 – Adding the Entities package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.24 – Adding the Entities package</p>
			<ol>
				<li value="4">Then, wait for the <a id="_idIndexMarker846"/>package installation to complete. </li>
			</ol>
			<div>
				<div id="_idContainer457" class="IMG---Figure">
					<img src="image/Figure_9.25_B17146.jpg" alt="Figure 9.25 – Installing a Git package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.25 – Installing a Git package</p>
			<p>Once done, you should be <a id="_idIndexMarker847"/>able to find the <strong class="bold">Entities</strong> package installed in your project.</p>
			<p>Sometimes we also need another package, the <strong class="bold">Hybrid Renderer</strong> package. This package helps us render ECS entities. </p>
			<p>The process of<a id="_idIndexMarker848"/> installing the <strong class="bold">Hybrid Renderer</strong> package is the same as the process of installing the <strong class="bold">Entities</strong> package, except that we need to enter the name of this package after clicking <strong class="bold">Add package from git URL…</strong>, which is <strong class="source-inline">com.unity.rendering.hybrid</strong>.</p>
			<div>
				<div id="_idContainer458" class="IMG---Figure">
					<img src="image/Figure_9.26_B17146.jpg" alt="Figure 9.26 – Installing the Hybrid Renderer package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.26 – Installing the Hybrid Renderer package</p>
			<p>Wait for the package<a id="_idIndexMarker849"/> installation to complete, and then you'll find it's installed in your project.</p>
			<div>
				<div id="_idContainer459" class="IMG---Figure">
					<img src="image/Figure_9.27_B17146.jpg" alt="Figure 9.27 – The Hybrid Renderer package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.27 – The Hybrid Renderer package</p>
			<p>Next, we will use the previous example to understand how to use ECS to further improve the performance of a game based on the use of the C# Job System.</p>
			<h3>How to use ECS </h3>
			<p>In this <a id="_idIndexMarker850"/>example, we will create a new component, entities, and a new system and use the C# Job System to distribute work to Unity's Job worker threads. Let's get started!</p>
			<ol>
				<li value="1">First, we will create a component script just for the data. In this case, it's the speed of cars:<p class="source-code">using Unity.Entities;</p><p class="source-code">public struct CarSpeed : <strong class="bold">IComponentData</strong></p><p class="source-code">{</p><p class="source-code">    public float SpeedValue;</p><p class="source-code">}</p></li>
				<li>Next, we also need a normal script called <strong class="source-inline">CarsManager</strong> to access the <strong class="source-inline">EntityManager</strong> object in <strong class="source-inline">World</strong> to create archetypes and entities. Here, we'll add some <a id="_idIndexMarker851"/>premade components from ECS to these entities, such as <strong class="source-inline">Translation</strong>, which contains only entity location data, and <strong class="source-inline">RenderMesh</strong>, which contains entity graphics attribute data: <p class="source-code">using UnityEngine;</p><p class="source-code">using Unity.Collections;</p><p class="source-code">using Unity.Mathematics;</p><p class="source-code">using Unity.Entities;</p><p class="source-code">using Unity.Rendering;</p><p class="source-code">using Unity.Transforms;</p><p class="source-code">using Random = UnityEngine.Random;</p><p class="source-code">public class CarsManager : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">[SerializeField] </p><p class="source-code">private Mesh _mesh;</p><p class="source-code">[SerializeField] </p><p class="source-code">private Material _material;</p><p class="source-code">[SerializeField] </p><p class="source-code">private int _count = 10000;</p><p class="source-code">[SerializeField] </p><p class="source-code">private float _rightSide, _leftSide, _frontSide,</p><p class="source-code">  _backSide, _speed;</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        var entityManager =</p><p class="source-code">          World.DefaultGameObjectInjectionWorld</p><p class="source-code">          .EntityManager;</p><p class="source-code">        // Create entity achetype</p><p class="source-code">        var entityArchetype =</p><p class="source-code">          entityManager.CreateArchetype(</p><p class="source-code">            typeof(CarSpeed),</p><p class="source-code">            typeof(Translation),</p><p class="source-code">            typeof(LocalToWorld),</p><p class="source-code">            typeof(RenderMesh),</p><p class="source-code">            typeof(RenderBounds));</p><p class="source-code">        var entityArray = new</p><p class="source-code">          NativeArray&lt;Entity&gt;(_count, Allocator.Temp);</p><p class="source-code">        </p><p class="source-code">        // Create entities</p><p class="source-code">        entityManager.CreateEntity(entityArchetype,</p><p class="source-code">          entityArray);</p><p class="source-code">        for (int i = 0; i &lt; entityArray.Length; i++)</p><p class="source-code">        {</p><p class="source-code">          var entity = entityArray[i];</p><p class="source-code">          entityManager.SetComponentData(entity, new</p><p class="source-code">            CarSpeed { SpeedValue = 1f });</p><p class="source-code">          entityManager.SetComponentData(entity, new</p><p class="source-code">            Translation { Value = new</p><p class="source-code">            float3(Random.Range(_rightSide,</p><p class="source-code">            _leftSide),0,</p><p class="source-code">            Random.Range(_frontSide, _backSide)) });</p><p class="source-code">     entityManager.SetSharedComponentData(entity, new</p><p class="source-code">       RenderMesh</p><p class="source-code">            {</p><p class="source-code">                mesh = _mesh,</p><p class="source-code">                material = _material</p><p class="source-code">            });</p><p class="source-code">        }</p><p class="source-code">        entityArray.Dispose();</p><p class="source-code">        _information.CarCounts = _count;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Then, attach this <strong class="bold">CarsManager</strong> script to a GameObject in the scene and assign the appropriate properties, such as the car's mesh, and speed values. </li>
			</ol>
			<div>
				<div id="_idContainer460" class="IMG---Figure">
					<img src="image/Figure_9.28_B17146.jpg" alt="Figure 9.28 – The CarsManager object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.28 – The CarsManager object</p>
			<ol>
				<li value="4">At this point, we<a id="_idIndexMarker852"/> have set up the components and entities. The next thing to do is to create the system. The system is also where the game logic is handled. In this example, we'll use the system to move these cars. As you can see in the following code, instead of searching for components in the traditional <strong class="source-inline">Update</strong> method and then operating on each instance at runtime, with ECS, we just statically declare that we need to process all entities with <strong class="source-inline">Translation</strong> and <strong class="source-inline">CarSpeed</strong> components attached. To find all of these entities, we just need to find the archetypes that match a specific "components set," which is done by the system:<p class="source-code">using Unity.Entities;</p><p class="source-code">using Unity.Transforms;</p><p class="source-code">public class CarMotionSystem : <strong class="bold">SystemBase</strong></p><p class="source-code">{</p><p class="source-code">    protected override void OnUpdate()</p><p class="source-code">    {</p><p class="source-code">        var deltaTime = Time.DeltaTime;</p><p class="source-code">        Entities.ForEach((ref <strong class="bold">Translation</strong> translation,</p><p class="source-code">          ref <strong class="bold">CarSpeed</strong> carSpeed) =&gt;</p><p class="source-code">        {</p><p class="source-code">            translation.Value.z += carSpeed.SpeedValue</p><p class="source-code">              * deltaTime;</p><p class="source-code">        }).</p><p class="source-code">        <strong class="bold">ScheduleParallel</strong>();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Click the <strong class="bold">Play</strong> button <a id="_idIndexMarker853"/>in the Unity editor to run the example. As shown in the following screenshot, when there are 10,000 cars in the scene, this time the value of FPS is around <strong class="bold">260</strong>! In this scene with 10,000 moving cars, using ECS increased the game's frame rate by nearly 30 times compared to the original traditional implementation:</li>
			</ol>
			<div>
				<div id="_idContainer461" class="IMG---Figure">
					<img src="image/Figure_9.29_B17146.jpg" alt="Figure 9.29 – Using ECS to improve game performance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.29 – Using ECS to improve game performance</p>
			<ol>
				<li value="6">If we look at<a id="_idIndexMarker854"/> the <strong class="bold">Hierarchy</strong> panel of this game scene, we won't see any car objects in the list. This is because when using ECS, traditional GameObjects and traditional components are not created, but entities and components from ECS are used to organize data. </li>
			</ol>
			<div>
				<div id="_idContainer462" class="IMG---Figure">
					<img src="image/Figure_9.30_B17146.jpg" alt="Figure 9.30 – No GameObjects are created&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.30 – No GameObjects are created</p>
			<ol>
				<li value="7">In order to <a id="_idIndexMarker855"/>see the entities, components, and system used in the scene, we can use the <strong class="bold">Entity Debugger</strong> to view this information. By clicking the <strong class="bold">Window</strong> |<strong class="bold"> Analysis</strong> | <strong class="bold">Entity Debugger</strong> item from the toolbar in the Unity editor, we can open the <strong class="bold">Entity Debugger</strong> window. </li>
			</ol>
			<div>
				<div id="_idContainer463" class="IMG---Figure">
					<img src="image/Figure_9.31_B17146.jpg" alt="Figure 9.31 – Opening the Entity Debugger window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.31 – Opening the Entity Debugger window</p>
			<ol>
				<li value="8">We can see a <a id="_idIndexMarker856"/>list of entities as well as a list of systems in the Entity Debugger window. As shown in the following screenshot, there are 10,002 entities, including 10,000 car entities:</li>
			</ol>
			<div>
				<div id="_idContainer464" class="IMG---Figure">
					<img src="image/Figure_9.32_B17146.jpg" alt="Figure 9.32 – The Entity Debugger&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.32 – The Entity Debugger</p>
			<ol>
				<li value="9">If we select an entity in the entity list, the <strong class="bold">Inspector</strong> window for that entity will open, showing all components of this entity and data for those components. </li>
			</ol>
			<div>
				<div id="_idContainer465" class="IMG---Figure">
					<img src="image/Figure_9.33_B17146.jpg" alt="Figure 9.33 – Inspector window for an entity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.33 – Inspector window for an entity</p>
			<ol>
				<li value="10">Finally, let's view <a id="_idIndexMarker857"/>the CPU usage timeline in the <strong class="bold">Profiler</strong> window. If you forget how to open this window, just press <em class="italic">Ctrl</em> + <em class="italic">7</em> or click <strong class="bold">Window</strong> | <strong class="bold">Analysis</strong> |<strong class="bold"> Profiler</strong> in the Unity Editor toolbar. Here, we can see that the ECS work is distributed to multiple Job worker threads by the C# Job System as we expected:</li>
			</ol>
			<div>
				<div id="_idContainer466" class="IMG---Figure">
					<img src="image/Figure_9.34_B17146.jpg" alt="Figure 9.34 – ECS and Job System&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.34 – ECS and Job System</p>
			<p>Through the <a id="_idIndexMarker858"/>preceding steps, we changed the traditional GameObject-Components-style development method in Unity to the development method using ECS, adopting the data-oriented design method and using the C# Job System, making full use of multithreaded programming, and improving the running efficiency of the game.</p>
			<p>Next, let's discuss another technology in DOTS, the Burst compiler.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor178"/>Using C# and the Burst compiler</h1>
			<p>The <strong class="bold">Burst compiler</strong> in<a id="_idIndexMarker859"/> Unity is an advanced compiler technology that can be used to convert a subset of .NET code into highly optimized native code for Unity games. It should be noted that it is not a general-purpose compiler, but a compiler designed for Unity to make Unity games run faster.</p>
			<p>Burst works on a subset of C# called HPC#, so let's explore this subset of C# next.</p>
			<h3>High-Performance C# (HPC#)</h3>
			<p>HPC# is a subset of C#. The<a id="_idIndexMarker860"/> standard C# language uses the concepts of "objects on the heap" and uses the garbage collector to reclaim unused memory automatically. So, as developers, we cannot control how the data is allocated in memory. On the other hand, HPC# doesn't support reference types, namely, classes, to avoid allocation in the heap and disable the garbage collector. In addition to these, some functions, such as <strong class="source-inline">try-catch-finally</strong>, are not supported in HPC# as well.</p>
			<p>To summarize, we can use the following types in HPC#:</p>
			<ul>
				<li>Value types, such as int, float, bool, and char, enum types, and struct types</li>
				<li><strong class="source-inline">NativeArray</strong> in Unity</li>
			</ul>
			<h3>Enabling the Burst compiler</h3>
			<p>The Burst compiler<a id="_idIndexMarker861"/> is usually used with the C# Job System in Unity to optimize the code of a job. As we know, a job is a value type struct, so it is suitable for use with the Burst compiler. Enabling it in a job is very simple: just add the <strong class="source-inline">[BurstCompile]</strong> attribute to the job struct, as shown in the following code:</p>
			<p class="source-code">using Unity.Jobs;</p>
			<p class="source-code">using <strong class="bold">Unity.Burst;</strong></p>
			<p class="source-code"><strong class="bold">[BurstCompile]</strong></p>
			<p class="source-code">public struct SampleJobWithBurst : IJobParallelFor</p>
			<p class="source-code">{</p>
			<p class="source-code">    public void Execute(int index)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        throw new System.NotImplementedException();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If you also want to enable the Burst compiler in the Unity editor, you can find the settings for it at <strong class="bold">Jobs</strong> | <strong class="bold">Burst</strong> in the toolbar.</p>
			<div>
				<div id="_idContainer467" class="IMG---Figure">
					<img src="image/Figure_9.35_B17146.jpg" alt="Figure 9.35 – Settings of Burst&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.35 – Settings of Burst</p>
			<p>By reading this <a id="_idIndexMarker862"/>section, you should know what the Burst compiler and HPC# are. You should also know that the Burst compiler is often used with the C# Job System in Unity and how to enable it in job code to generate more efficient native binary code.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor179"/>Summary</h1>
			<p>This chapter first introduced what data-oriented design is and the difference between data-oriented design and traditional object-oriented design. Then, we explored DOTS in Unity and the three technology modules that make it up, namely, the C# Job System, ECS, and the Burst compiler.</p>
			<p>After that, we discussed in detail how to implement asynchronous programming in Unity and used an example to demonstrate how to use Unity's C# Job System to implement multithreading to improve game performance.</p>
			<p>We also introduced the concept of ECS, discussed the difference between ECS and the traditional GameObject-Components architecture in Unity, and demonstrated how to use ECS and the C# Job System to further improve game performance.</p>
			<p>Finally, we explored what the Burst compiler and HPC# are and how to enable them to generate highly optimized native code for your Unity games.</p>
			<p>By reading this chapter, you should now understand how to work with DOTS correctly in Unity. In the next chapter, we will discuss topics related to assets management and serialization In Unity.</p>
		</div>
	</body></html>