<html><head></head><body>
<div id="_idContainer137">
<h1 class="chapter-number" id="_idParaDest-306"><a id="_idTextAnchor585"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-307"><a id="_idTextAnchor586"/><span class="koboSpan" id="kobo.2.1">CI/CD for ASP.NET Core Using Azure Pipelines and GitHub Actions</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we have explored the fundamentals of building, testing, and running ASP.NET Core applications. </span><span class="koboSpan" id="kobo.3.2">We have also discussed how to access data from a database using </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Entity Framework Core</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">EF Core</span></strong><span class="koboSpan" id="kobo.7.1">) and</span><a id="_idIndexMarker1529"/><span class="koboSpan" id="kobo.8.1"> secure our applications using ASP.NET Core Identity. </span><span class="koboSpan" id="kobo.8.2">Additionally, we have discussed how to test our applications using unit tests and integration tests, as well as how to use RESTful APIs, gRPC, and GraphQL. </span><span class="koboSpan" id="kobo.8.3">Furthermore, we have learned how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.9.1">dotnet run</span></strong><span class="koboSpan" id="kobo.10.1"> command to run our applications locally. </span><span class="koboSpan" id="kobo.10.2">Now, it is time to take the next step in our ASP.NET Core journey and learn how to deploy our applications to </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">the cloud.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we will explore the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">continuous integration and continuous delivery/deployment</span></strong><span class="koboSpan" id="kobo.14.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.15.1">CI/CD</span></strong><span class="koboSpan" id="kobo.16.1">). </span><span class="koboSpan" id="kobo.16.2">This chapter will focus on two popular CI/CD tools and platforms: Azure Pipelines and </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">We will discuss the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Introduction </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">to CI/CD</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Containerizing ASP.NET Core applications </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">using Docker</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">CI/CD using </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Azure Pipelines</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.26.1">GitHub Actions</span></span><a id="_idTextAnchor587"/></li>
</ul>
<p><span class="koboSpan" id="kobo.27.1">Upon completion of this chapter, you will have a basic understanding of containerization concepts and the ability to build and deploy your ASP.NET Core applications to the cloud using either of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">these tools.</span></span></p>
<h1 id="_idParaDest-308"><a id="_idTextAnchor588"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">The code examples in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span><a id="_idTextAnchor589"/></p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor590"/><span class="koboSpan" id="kobo.34.1">Introduction to CI/CD</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Developers</span><a id="_idIndexMarker1530"/><span class="koboSpan" id="kobo.36.1"> work on code every day – they may create new features, fix bugs, or refactor existing code. </span><span class="koboSpan" id="kobo.36.2">In a team environment, multiple developers may be working on the same code base. </span><span class="koboSpan" id="kobo.36.3">A developer may create a new feature, while another developer may be fixing a bug. </span><span class="koboSpan" id="kobo.36.4">The code base is constantly changing, and it is important to ensure that the code changes made by different developers do not conflict with each other and do not break any existing functionalities. </span><span class="koboSpan" id="kobo.36.5">To avoid such issues, developers should integrate their code </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">changes frequently.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Additionally, when the application is ready to be deployed, it is important to consider the different environments it may be deployed to, such as development, staging, or production. </span><span class="koboSpan" id="kobo.38.2">Different environments may have different configurations, and the deployment process may be different for each environment. </span><span class="koboSpan" id="kobo.38.3">To ensure that the application is deployed correctly and consistently, it is ideal to automate the deployment process. </span><span class="koboSpan" id="kobo.38.4">This is where CI/CD </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">comes in.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">The acronym </span><em class="italic"><span class="koboSpan" id="kobo.41.1">CI/CD</span></em><span class="koboSpan" id="kobo.42.1"> can have different interpretations depending on the context. </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">CI</span></strong><span class="koboSpan" id="kobo.44.1">, a development practice that allows developers to integrate code changes regularly. </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">CD</span></strong><span class="koboSpan" id="kobo.46.1"> can refer to either </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">continuous delivery</span></strong><span class="koboSpan" id="kobo.48.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">continuous deployment</span></strong><span class="koboSpan" id="kobo.50.1">, which are often used interchangeably. </span><span class="koboSpan" id="kobo.50.2">It is not worth debating the exact definitions of these terms, as in most cases, </span><em class="italic"><span class="koboSpan" id="kobo.51.1">CD</span></em><span class="koboSpan" id="kobo.52.1"> means building, testing, and deploying the applications to the production environment (and, potentially, other environments) frequently </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">and automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">CI/CD pipelines are key components of </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">DevOps</span></strong><span class="koboSpan" id="kobo.56.1">, a combination of the words </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">development</span></strong><span class="koboSpan" id="kobo.58.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">operations</span></strong><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">DevOps has evolved over the years and is generally defined as a set of practices, tools, and processes that enable continuous delivery of value to end users. </span><span class="koboSpan" id="kobo.60.3">While DevOps is a vast topic, this chapter will focus on CI/CD </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">pipelines specifically.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">A typical </span><a id="_idIndexMarker1531"/><span class="koboSpan" id="kobo.63.1">CI/CD process is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.65.1"><img alt="Figure 14.1 – A typical CI/CD process" src="image/B18971_14_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">Figure 14.1 – A typical CI/CD process</span></p>
<p><span class="koboSpan" id="kobo.67.1">The steps in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.68.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.69.1">.1</span></em><span class="koboSpan" id="kobo.70.1"> are </span><a id="_idIndexMarker1532"/><span class="koboSpan" id="kobo.71.1">described </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.73.1">The developer creates a new feature or fixes a bug in the code base and then commits the changes to the shared code repository. </span><span class="koboSpan" id="kobo.73.2">If the team is using Git as its </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">version control system</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">VCS</span></strong><span class="koboSpan" id="kobo.77.1">), the </span><a id="_idIndexMarker1533"/><span class="koboSpan" id="kobo.78.1">developer will create a pull request to submit </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the changes.</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">The pull request will initiates the CI pipeline, which will build the application and execute tests. </span><span class="koboSpan" id="kobo.80.2">If the build or tests fail, the developer will be notified, allowing them to address the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">issue promptly.</span></span></li>
<li><span class="koboSpan" id="kobo.82.1">If the build and tests are successful and the pull request is approved by the team, the code changes will be merged into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">main</span></strong><span class="koboSpan" id="kobo.84.1"> branch. </span><span class="koboSpan" id="kobo.84.2">This ensures that the code is up to date and aligns with the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">team’s standards.</span></span></li>
<li><span class="koboSpan" id="kobo.86.1">The merge will trigger the CI pipeline to build the application and publish the artifacts (for example, binaries, configuration files, Docker images, and so on) to the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">artifact repository.</span></span></li>
<li><span class="koboSpan" id="kobo.88.1">The CD pipeline can be triggered manually or automatically. </span><span class="koboSpan" id="kobo.88.2">The CD pipeline then deploys the application to the target environment (for example, development, staging, or </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">production environment).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.90.1">The CI/CD process </span><a id="_idIndexMarker1534"/><span class="koboSpan" id="kobo.91.1">can be more complex than what is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.92.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.93.1">.1</span></em><span class="koboSpan" id="kobo.94.1">. </span><span class="koboSpan" id="kobo.94.2">For example, the CI pipeline may require static code analysis, code test coverage, and other quality checks. </span><span class="koboSpan" id="kobo.94.3">The CD pipeline may need to apply different configurations for different environments or have different deployment strategies, such as blue/green deployment or canary deployment. </span><span class="koboSpan" id="kobo.94.4">With the increasing complexity of CI/CD pipelines, DevOps engineers are in high demand as they possess the skills to implement these pipelines using the various tools and </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">platforms available.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Before we delve into the details of CI/CD, let us first introduce some concepts and terminologies that are commonly used </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">in CI</span><a id="_idTextAnchor591"/><span class="koboSpan" id="kobo.98.1">/CD.</span></span></p>
<h2 id="_idParaDest-310"><a id="_idTextAnchor592"/><span class="koboSpan" id="kobo.99.1">CI/CD concepts and terminologies</span></h2>
<p><span class="koboSpan" id="kobo.100.1">It is essential to</span><a id="_idIndexMarker1535"/><span class="koboSpan" id="kobo.101.1"> understand key concepts and terminologies commonly used in CI/CD. </span><span class="koboSpan" id="kobo.101.2">The following are some of the most common terms used </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">in CI/CD:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Pipeline</span></strong><span class="koboSpan" id="kobo.104.1">: A pipeline </span><a id="_idIndexMarker1536"/><span class="koboSpan" id="kobo.105.1">is an automated process used to build, test, and deploy applications. </span><span class="koboSpan" id="kobo.105.2">They can be triggered manually or automatically and can even be set up to be triggered by other pipelines. </span><span class="koboSpan" id="kobo.105.3">This helps streamline the development process, ensuring that applications are built, tested, and deployed quickly </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">and efficiently.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.107.1">Build</span></strong><span class="koboSpan" id="kobo.108.1">: A build </span><a id="_idIndexMarker1537"/><span class="koboSpan" id="kobo.109.1">is a process that involves compiling the source code and creating the necessary binaries or Docker images. </span><span class="koboSpan" id="kobo.109.2">This ensures that the code is ready </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">for deployment.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.111.1">Test</span></strong><span class="koboSpan" id="kobo.112.1">: A </span><a id="_idIndexMarker1538"/><span class="koboSpan" id="kobo.113.1">pipeline may include automated tests, such as unit tests, integration tests, performance tests, or </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">end-to-end</span></strong><span class="koboSpan" id="kobo.115.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.116.1">E2E</span></strong><span class="koboSpan" id="kobo.117.1">) tests. </span><span class="koboSpan" id="kobo.117.2">These tests can be incorporated </span><a id="_idIndexMarker1539"/><span class="koboSpan" id="kobo.118.1">into the pipeline to ensure that the code changes do not break any existing functionalities. </span><span class="koboSpan" id="kobo.118.2">This helps to ensure that the software remains stable </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">and reliable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.120.1">Artifact</span></strong><span class="koboSpan" id="kobo.121.1">: An artifact is</span><a id="_idIndexMarker1540"/><span class="koboSpan" id="kobo.122.1"> a file or collection of files – normally, the output of a build process. </span><span class="koboSpan" id="kobo.122.2">Examples of artifacts include binary files, a Docker image, or a ZIP file containing the binary files. </span><span class="koboSpan" id="kobo.122.3">These artifacts can then be used as inputs for the </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">deployment process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Containerization</span></strong><span class="koboSpan" id="kobo.125.1">: Containerization is a method of packaging an application and its</span><a id="_idIndexMarker1541"/><span class="koboSpan" id="kobo.126.1"> dependencies into a container image, which can be deployed and run in a consistent environment, regardless of the host operating system. </span><span class="koboSpan" id="kobo.126.2">One of the most popular containerization tools is Docker. </span><span class="koboSpan" id="kobo.126.3">Containerization offers numerous benefits, such as improved scalability, portability, and </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">resource utilization.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.128.1">VCS</span></strong><span class="koboSpan" id="kobo.129.1">: VCSs are </span><a id="_idIndexMarker1542"/><span class="koboSpan" id="kobo.130.1">an essential tool for software development, allowing developers to track and manage changes to source code. </span><span class="koboSpan" id="kobo.130.2">Git is one of the most widely used VCSs, providing developers with an effective way to manage their </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">code base.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.132.1">Deployment</span></strong><span class="koboSpan" id="kobo.133.1">: Deployment</span><a id="_idIndexMarker1543"/><span class="koboSpan" id="kobo.134.1"> is the process of deploying the application to the target environment. </span><span class="koboSpan" id="kobo.134.2">It involves configuring the application to meet the requirements of the environment, as well as ensuring that it is secure and ready </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">for use.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.136.1">Trigger</span></strong><span class="koboSpan" id="kobo.137.1">: A trigger </span><a id="_idIndexMarker1544"/><span class="koboSpan" id="kobo.138.1">is an event that tells the pipeline when to run. </span><span class="koboSpan" id="kobo.138.2">A trigger can be manual or automatic. </span><span class="koboSpan" id="kobo.138.3">For example, a pull request can trigger the CI pipeline to validate code changes by running tests. </span><span class="koboSpan" id="kobo.138.4">A merge to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">main</span></strong><span class="koboSpan" id="kobo.140.1"> branch can trigger the CI pipeline to build and publish artifacts. </span><span class="koboSpan" id="kobo.140.2">The successful CI pipeline can trigger the CD pipeline to deploy the application to non-production environments. </span><span class="koboSpan" id="kobo.140.3">However, the CD pipeline may need to be triggered manually to deploy the application to the production environment as a </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">safety measure.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.142.1">Gaining an understanding of the fundamental concepts and terminologies associated with CI/CD is essential for successful implementation. </span><span class="koboSpan" id="kobo.142.2">As many different tools and platforms can be used to implement CI/CD pipelines, we will discuss the details in the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">follo</span><a id="_idTextAnchor593"/><span class="koboSpan" id="kobo.144.1">wing sections.</span></span></p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor594"/><span class="koboSpan" id="kobo.145.1">Understanding the importance of CI/CD</span></h2>
<p><span class="koboSpan" id="kobo.146.1">CI/CD plays an</span><a id="_idIndexMarker1545"/><span class="koboSpan" id="kobo.147.1"> important role in DevOps. </span><span class="koboSpan" id="kobo.147.2">It helps the team respond to changes and deliver value to end users frequently, safely, and reliably. </span><span class="koboSpan" id="kobo.147.3">As CI/CD pipelines are automated, they can streamline the process of delivering software and reduce the time and effort needed to deploy applications to the production environment. </span><span class="koboSpan" id="kobo.147.4">Additionally, CI/CD helps maintain a stable and reliable code base. </span></p>
<p><span class="koboSpan" id="kobo.148.1">In order to successfully implement a CI/CD pipeline, the team must adhere to certain practices. </span><span class="koboSpan" id="kobo.148.2">Automated tests should be conducted to ensure that code changes do not break any existing functionalities. </span><span class="koboSpan" id="kobo.148.3">Additionally, a well-defined deployment strategy should be established, such as staging the application in a development environment before deploying it to the production environment. </span><span class="koboSpan" id="kobo.148.4">By following these practices, the team can reduce </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">time to market</span></strong><span class="koboSpan" id="kobo.150.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.151.1">TTM</span></strong><span class="koboSpan" id="kobo.152.1">) and</span><a id="_idIndexMarker1546"/><span class="koboSpan" id="kobo.153.1"> deliver the application to end users faster and </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">more frequently.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">CI/CD practices help </span><a id="_idIndexMarker1547"/><span class="koboSpan" id="kobo.156.1">development teams in the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">following ways:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.158.1">Faster feedback</span></strong><span class="koboSpan" id="kobo.159.1">: CI/CD pipelines can be triggered automatically when code changes are committed to the shared code repository. </span><span class="koboSpan" id="kobo.159.2">This provides developers with faster feedback on code changes, allowing them to address any issues early in the </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">development process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.161.1">Reduced manual effort and risk</span></strong><span class="koboSpan" id="kobo.162.1">: CI/CD pipelines automate the deployment process, reducing manual effort and risk. </span><span class="koboSpan" id="kobo.162.2">This decreases the time and effort needed for production deployment, eliminating manual and </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">error-prone processes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.164.1">Consistency</span></strong><span class="koboSpan" id="kobo.165.1">: Automated builds and deployments ensure consistency across different environments. </span><span class="koboSpan" id="kobo.165.2">This reduces the risk of deployment failures due to configuration issues or </span><em class="italic"><span class="koboSpan" id="kobo.166.1">it works on my </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.167.1">machine</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1"> problems.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.169.1">Enhanced quality</span></strong><span class="koboSpan" id="kobo.170.1">: Automated tests can be integrated into CI/CD pipelines, which helps to ensure that the code base remains stable and reliable. </span><span class="koboSpan" id="kobo.170.2">CI/CD pipelines can also run other quality checks, such as static code analysis and code test coverage, which leads to </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">higher-quality code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.172.1">Rapid delivery and agility</span></strong><span class="koboSpan" id="kobo.173.1">: CI/CD pipelines enable the team to release new features and bug fixes to end users faster and more frequently. </span><span class="koboSpan" id="kobo.173.2">This allows businesses to respond quickly to customer needs and </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">market changes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.175.1">With these</span><a id="_idIndexMarker1548"/><span class="koboSpan" id="kobo.176.1"> benefits in mind, it is clear that CI/CD is a must-have for any development team. </span><span class="koboSpan" id="kobo.176.2">No one would want to go back to the days of manual builds and deployments anymore, as it is time-consuming </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">and error-prone.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">We have now learned some concepts of CI/CD and why it is important. </span><span class="koboSpan" id="kobo.178.2">In the next section, we will discuss how to containerize ASP.NET Core applicat</span><a id="_idTextAnchor595"/><span class="koboSpan" id="kobo.179.1">ions </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">using Docker.</span></span></p>
<h1 id="_idParaDest-312"><a id="_idTextAnchor596"/><span class="koboSpan" id="kobo.181.1">Containerizing ASP.NET Core applications using Docker</span></h1>
<p><span class="koboSpan" id="kobo.182.1">Many years ago, when</span><a id="_idIndexMarker1549"/><span class="koboSpan" id="kobo.183.1"> we deployed applications to the production environment, we needed to ensure that the target environment had the correct version of the .NET Framework installed. </span><span class="koboSpan" id="kobo.183.2">Developers were struggling with the </span><em class="italic"><span class="koboSpan" id="kobo.184.1">it works on my machine</span></em><span class="koboSpan" id="kobo.185.1"> problem, as development environments may have had different configurations than the production environment, including software versions, operating systems, and hardware. </span><span class="koboSpan" id="kobo.185.2">This often led to deployment failures due to </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">configuration issues.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">The introduction of .NET Core, a cross-platform and open-source framework, has enabled us to deploy our applications on any platform, including Windows, Linux, and macOS. </span><span class="koboSpan" id="kobo.187.2">However, for successful deployment, we still need to ensure that the target environment has the correct runtime installed. </span><span class="koboSpan" id="kobo.187.3">This is where contain</span><a id="_idTextAnchor597"/><span class="koboSpan" id="kobo.188.1">erization </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">comes in.</span></span></p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor598"/><span class="koboSpan" id="kobo.190.1">What is containerization?</span></h2>
<p><span class="koboSpan" id="kobo.191.1">Containers</span><a id="_idIndexMarker1550"/><span class="koboSpan" id="kobo.192.1"> are lightweight, isolated, and portable environments that contain all the necessary dependencies for running an application. </span><span class="koboSpan" id="kobo.192.2">Unlike </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">virtual machines</span></strong><span class="koboSpan" id="kobo.194.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.195.1">VMs</span></strong><span class="koboSpan" id="kobo.196.1">), they</span><a id="_idIndexMarker1551"/><span class="koboSpan" id="kobo.197.1"> do not require a separate guest operating system as they share the host operating system kernel. </span><span class="koboSpan" id="kobo.197.2">This makes them more lightweight and portable than VMs, as they can run on any platform that supports the container runtime. </span><span class="koboSpan" id="kobo.197.3">Containers also provide isolation, ensuring that applications are not affected by changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">the environment.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Containerization is a powerful tool that enables us to package our applications and their dependencies into a single container image. </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">Docker</span></strong><span class="koboSpan" id="kobo.201.1"> is </span><a id="_idIndexMarker1552"/><span class="koboSpan" id="kobo.202.1">one of the most popular </span><a id="_idIndexMarker1553"/><span class="koboSpan" id="kobo.203.1">containerization solutions, offering support for Windows, Linux, and macOS for development purposes, as well as many variants of Linux, such as Ubuntu, Debian, and CentOS, for production environments. </span><span class="koboSpan" id="kobo.203.2">Additionally, Docker is compatible with cloud platforms, including </span><a id="_idIndexMarker1554"/><span class="koboSpan" id="kobo.204.1">Azure, </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.206.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.207.1">AWS</span></strong><span class="koboSpan" id="kobo.208.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Google Cloud Platform</span></strong><span class="koboSpan" id="kobo.210.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">GCP</span></strong><span class="koboSpan" id="kobo.212.1">). </span><span class="koboSpan" id="kobo.212.2">If we use Docker </span><a id="_idIndexMarker1555"/><span class="koboSpan" id="kobo.213.1">as the container runtime, then the container images are </span><a id="_idIndexMarker1556"/><span class="koboSpan" id="kobo.214.1">called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.215.1">Docker images</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Docker images are a convenient way to package an application and its dependencies. </span><span class="koboSpan" id="kobo.217.2">They contain all the components necessary to run an application, such as the application code (binaries), runtime or SDK, system tools, and configurations. </span><span class="koboSpan" id="kobo.217.3">Docker images are immutable, meaning they cannot be changed once they are created. </span><span class="koboSpan" id="kobo.217.4">To store these images, they are placed in a registry, such</span><a id="_idIndexMarker1557"/><span class="koboSpan" id="kobo.218.1"> as Docker Hub, </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Azure Container Registry</span></strong><span class="koboSpan" id="kobo.220.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.221.1">ACR</span></strong><span class="koboSpan" id="kobo.222.1">), or</span><a id="_idIndexMarker1558"/><span class="koboSpan" id="kobo.223.1"> AWS </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Elastic Container Registry</span></strong><span class="koboSpan" id="kobo.225.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.226.1">ECR</span></strong><span class="koboSpan" id="kobo.227.1">). </span><span class="koboSpan" id="kobo.227.2">Docker Hub is</span><a id="_idIndexMarker1559"/><span class="koboSpan" id="kobo.228.1"> a public registry that offers many pre-built images. </span><span class="koboSpan" id="kobo.228.2">Alternatively, a private registry can be created to store custom </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">Docker images.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Once a Docker image has been created, it can be used to create a Docker container. </span><span class="koboSpan" id="kobo.230.2">A Docker container is an isolated, in-memory instance of a Docker image, with its own filesystem, network, and memory. </span><span class="koboSpan" id="kobo.230.3">This makes creating a container much faster than booting up a VM and also allows for fast destruction and rebuilding of a container from the same image. </span><span class="koboSpan" id="kobo.230.4">In addition, multiple containers can be created from the same image, which is useful for scaling out applications. </span><span class="koboSpan" id="kobo.230.5">If any container fails, it can be destroyed and rebuilt from the same image in a matter of seconds, making containerization a </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">powerful tool.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">The files in a Docker image are stackable. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.233.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.234.1">.2</span></em><span class="koboSpan" id="kobo.235.1"> shows an example of a container filesystem that contains an ASP.NET Core app and </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">its dependencies:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.237.1"><img alt="Figure 14.2 – Docker container file system" src="image/B18971_14_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.238.1">Figure 14.2 – Docker container file system</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.239.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.240.1">.2</span></em><span class="koboSpan" id="kobo.241.1"> illustrates </span><a id="_idIndexMarker1560"/><span class="koboSpan" id="kobo.242.1">the layers of a Docker container. </span><span class="koboSpan" id="kobo.242.2">On top of the kernel layer is the base image layer, which is an empty container image created from Ubuntu. </span><span class="koboSpan" id="kobo.242.3">On top of the base image layer is the ASP.NET Core runtime layer, then the ASP.NET Core app layer. </span><span class="koboSpan" id="kobo.242.4">When a container is created, Docker adds a final writeable layer on top of the other layers. </span><span class="koboSpan" id="kobo.242.5">This writeable layer can be used to store temporary files, such as logs. </span><span class="koboSpan" id="kobo.242.6">However, as we mentioned earlier, Docker images are immutable, so any changes made to the writeable layer will be lost when the container is destroyed. </span><span class="koboSpan" id="kobo.242.7">This is why we should not store any persistent data in a container. </span><span class="koboSpan" id="kobo.242.8">Instead, we should store the data in a volume, which is a directory on the host machine that is mounted into </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">the container.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">This is a very simplified explanation of Docker images and containers. </span><span class="koboSpan" id="kobo.244.2">Next, let us install Docker and create a Docker image for </span><a id="_idTextAnchor599"/><span class="koboSpan" id="kobo.245.1">our ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">Core application.</span></span></p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor600"/><span class="koboSpan" id="kobo.247.1">Installing Docker</span></h2>
<p><span class="koboSpan" id="kobo.248.1">You can </span><a id="_idIndexMarker1561"/><span class="koboSpan" id="kobo.249.1">download Docker Desktop from the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">following links:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.251.1">Windows: </span></span><a href="https://docs.docker.com/desktop/install/windows-install/ "><span class="No-Break"><span class="koboSpan" id="kobo.252.1">https://docs.docker.com/desktop/install/windows-install/</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.253.1">Mac: </span></span><a href="https://docs.docker.com/desktop/install/mac-install/ "><span class="No-Break"><span class="koboSpan" id="kobo.254.1">https://docs.docker.com/desktop/install/mac-install/</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.255.1">Linux: </span></span><a href="https://docs.docker.com/desktop/install/linux-install/ "><span class="No-Break"><span class="koboSpan" id="kobo.256.1">https://docs.docker.com/desktop/install/linux-install/</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.257.1">Please follow the official documentation to install Docker on </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">your machine.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">If you use</span><a id="_idIndexMarker1562"/><span class="koboSpan" id="kobo.260.1"> Windows, please use the </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">Windows Subsystem for Linux 2</span></strong><span class="koboSpan" id="kobo.262.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.263.1">WSL 2</span></strong><span class="koboSpan" id="kobo.264.1">) backend </span><a id="_idIndexMarker1563"/><span class="koboSpan" id="kobo.265.1">instead of Hyper-V. </span><span class="koboSpan" id="kobo.265.2">WSL 2 is a compatibility layer that allows Linux binary executables to be run natively on Windows. </span><span class="koboSpan" id="kobo.265.3">Using WSL 2 as the backend for Docker Desktop on Windows provides better performance than the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">Hyper-V backend.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">To install WSL 2 on Windows, please follow the instructions at this link: </span><a href="https://learn.microsoft.com/en-us/windows/wsl/install"><span class="koboSpan" id="kobo.268.1">https://learn.microsoft.com/en-us/windows/wsl/install</span></a><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">By default, WSL 2 uses the Ubuntu distribution. </span><span class="koboSpan" id="kobo.269.3">You can also install other Linux distributions, such as Debian, CentOS, </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">or Fedora.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">After installing WSL 2, you can check the version of WSL by running the following command </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">in PowerShell:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.273.1">
wsl -l -v</span></pre> <p><span class="koboSpan" id="kobo.274.1">If you see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">VERSION</span></strong><span class="koboSpan" id="kobo.276.1"> field shows </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">2</span></strong><span class="koboSpan" id="kobo.278.1">, that means WSL 2 is installed correctly. </span><span class="koboSpan" id="kobo.278.2">Then, you can install Docker Desktop and choose WSL 2 as the backend. </span><span class="koboSpan" id="kobo.278.3">If you have multiple Linux distributions installed, you can choose the default distribution to use with Docker Desktop. </span><span class="koboSpan" id="kobo.278.4">Go to </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">Settings</span></strong><span class="koboSpan" id="kobo.280.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">Resources</span></strong><span class="koboSpan" id="kobo.282.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">WSL integration</span></strong><span class="koboSpan" id="kobo.284.1">, and choose the distribution you want to use with Docker Desktop, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.285.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.286.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.288.1"><img alt="Figure 14.3 – Choosing the default Linux distribution to use with Docker Desktop" src="image/B18971_14_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.289.1">Figure 14.3 – Choosing the default Linux distribution to use with Docker Desktop</span></p>
<p><span class="koboSpan" id="kobo.290.1">Here is the example output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">wsl -l -v</span></strong><span class="koboSpan" id="kobo.292.1"> command, which shows two Linux distros installed on this machine; the default distro </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Ubuntu-22.04</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
  NAME                   STATE           VERSION* Ubuntu-22.04           Running         2
  Ubuntu                 Stopped         2
  docker-desktop-data    Running         2
  docker-desktop         Running         2</span></pre>
<p><span class="koboSpan" id="kobo.297.1">Docker Desktop installs two internal </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">Linux distros:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">docker-desktop</span></strong><span class="koboSpan" id="kobo.300.1">: This is used to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">Docker engine</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">docker-desktop-data</span></strong><span class="koboSpan" id="kobo.303.1">: This is used to store containers </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">and images</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.305.1">Note that </span><a id="_idIndexMarker1564"/><span class="koboSpan" id="kobo.306.1">Docker may consume a lot of resources on your machine. </span><span class="koboSpan" id="kobo.306.2">If you feel that Docker slows down your machine or consumes too many resources, you can configure the resources allocated to WSL 2 following the instructions in this </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">link: </span></span><a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig"><span class="No-Break"><span class="koboSpan" id="kobo.308.1">https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.309.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">After installing Docker Desktop, we can now create a Docker image for our ASP.NET Core application. </span><span class="koboSpan" id="kobo.310.2">In the next section, we will discuss some commands t</span><a id="_idTextAnchor601"/><span class="koboSpan" id="kobo.311.1">hat are commonly used </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">in Docker.</span></span></p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor602"/><span class="koboSpan" id="kobo.313.1">Understanding Dockerfiles</span></h2>
<p><span class="koboSpan" id="kobo.314.1">To demonstrate</span><a id="_idIndexMarker1565"/><span class="koboSpan" id="kobo.315.1"> how to build and run Docker images, we will need a sample ASP.NET Core application. </span><span class="koboSpan" id="kobo.315.2">You can create a new ASP.NET Core web API project using the </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.317.1">
dotnet new webapi -o BasicWebApiDemo -controllers</span></pre> <p><span class="koboSpan" id="kobo.318.1">Alternatively, you can clone the sample code from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">/samples/chapter14/MyBasicWebApiDemo </span></strong><span class="koboSpan" id="kobo.320.1">folder in the book's </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Docker images can be built using a Dockerfile, a text file containing a list of instructions used to build the image. </span><span class="koboSpan" id="kobo.322.2">You can create a Dockerfile in the root directory of the ASP.NET Core project </span><a id="_idIndexMarker1566"/><span class="koboSpan" id="kobo.323.1">manually, or you can use VS 2022 to create it for you. </span><span class="koboSpan" id="kobo.323.2">To create a Dockerfile using VS 2022, right-click on the project in Solution Explorer, then select </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">Add</span></strong><span class="koboSpan" id="kobo.325.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Docker Support</span></strong><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">You will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">following dialog:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.329.1"><img alt="Figure 14.4 – Adding Docker support to an ASP.NET Core project in VS 2022" src="image/B18971_14_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.330.1">Figure 14.4 – Adding Docker support to an ASP.NET Core project in VS 2022</span></p>
<p><span class="koboSpan" id="kobo.331.1">There are two options here: </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">Linux</span></strong><span class="koboSpan" id="kobo.333.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">Windows</span></strong><span class="koboSpan" id="kobo.335.1">. </span><span class="koboSpan" id="kobo.335.2">It is recommended to use Linux for development purposes, as the Linux image is smaller than the Windows image. </span><span class="koboSpan" id="kobo.335.3">Docker was originally designed for Linux, so it is more mature on Linux than on Windows. </span><span class="koboSpan" id="kobo.335.4">Many cloud platforms, such as Azure, AWS, and GCP, support Linux containers. </span><span class="koboSpan" id="kobo.335.5">However, not all Windows servers support Windows containers. </span><span class="koboSpan" id="kobo.335.6">Unless you have strong reasons to host your application on a Windows server, you should choose </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.336.1">Linux</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1"> here.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Once you have selected the </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">Linux</span></strong><span class="koboSpan" id="kobo.340.1"> option, click </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">OK</span></strong><span class="koboSpan" id="kobo.342.1">. </span><span class="koboSpan" id="kobo.342.2">VS 2022 will then generate a Dockerfile for you. </span><span class="koboSpan" id="kobo.342.3">If you would prefer to create the Dockerfile manually, name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.344.1"> without any file extension. </span><span class="koboSpan" id="kobo.344.2">This allows us to build the Docker image using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">docker build</span></strong><span class="koboSpan" id="kobo.346.1"> command without needing to specify the Dockerfile name. </span><span class="koboSpan" id="kobo.346.2">The default Dockerfile created by VS 2022 will resemble </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
#See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
USER app
WORKDIR /app
EXPOSE 8080
EXPOSE 8081
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["BasicWebApiDemo.csproj", "."]
RUN dotnet restore "./BasicWebApiDemo.csproj"
COPY . </span><span class="koboSpan" id="kobo.348.2">.
</span><span class="koboSpan" id="kobo.348.3">WORKDIR "/src/."
</span><span class="koboSpan" id="kobo.348.4">RUN dotnet build "BasicWebApiDemo.csproj" -c $BUILD_CONFIGURATION -o /app/build
FROM build AS publish
RUN dotnet publish "BasicWebApiDemo.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
</span><span class="koboSpan" id="kobo.348.5">ENTRYPOINT ["dotnet", "BasicWebApiDemo.dll"]</span></pre>
<p><span class="koboSpan" id="kobo.349.1">Let us go through the Dockerfile line </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">by line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base</span></pre> <p><span class="koboSpan" id="kobo.352.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">FROM</span></strong><span class="koboSpan" id="kobo.354.1"> instruction specifies the base image to use. </span><span class="koboSpan" id="kobo.354.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">FROM</span></strong><span class="koboSpan" id="kobo.356.1"> instruction must be the first instruction in a Dockerfile. </span><span class="koboSpan" id="kobo.356.2">In this case, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">mcr.microsoft.com/dotnet/aspnet:8.0</span></strong><span class="koboSpan" id="kobo.358.1"> image, which is the ASP.NET Core runtime image. </span><span class="koboSpan" id="kobo.358.2">This image is provided by Microsoft. </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">mcr.microsoft.com</span></strong><span class="koboSpan" id="kobo.360.1"> is the domain name of </span><a id="_idIndexMarker1567"/><span class="koboSpan" id="kobo.361.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">Microsoft Artifact Registry</span></strong><span class="koboSpan" id="kobo.363.1"> (also known as </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">Microsoft Container Registry</span></strong><span class="koboSpan" id="kobo.365.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">MCR</span></strong><span class="koboSpan" id="kobo.367.1">), which is a public registry that contains </span><a id="_idIndexMarker1568"/><span class="koboSpan" id="kobo.368.1">many pre-built images, similar to Docker Hub. </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">AS base</span></strong><span class="koboSpan" id="kobo.370.1"> means we are giving this image a name, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">base</span></strong><span class="koboSpan" id="kobo.372.1">. </span><span class="koboSpan" id="kobo.372.2">This name can be used later in the Dockerfile to refer to </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">this image.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
USER app</span></pre> <p><span class="koboSpan" id="kobo.375.1">Next, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">USER</span></strong><span class="koboSpan" id="kobo.377.1"> instruction</span><a id="_idIndexMarker1569"/><span class="koboSpan" id="kobo.378.1"> specifies the username or </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">unique identifier</span></strong><span class="koboSpan" id="kobo.380.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.381.1">UID</span></strong><span class="koboSpan" id="kobo.382.1">) to use</span><a id="_idIndexMarker1570"/><span class="koboSpan" id="kobo.383.1"> when running the image. </span><span class="koboSpan" id="kobo.383.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">app</span></strong><span class="koboSpan" id="kobo.385.1"> user is created by the base image. </span><span class="koboSpan" id="kobo.385.2">This user is not a superuser, so it is more secure than the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">root user.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
WORKDIR /app</span></pre> <p><span class="koboSpan" id="kobo.388.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">WORKDIR</span></strong><span class="koboSpan" id="kobo.390.1"> instruction sets the working directory inside of the container for these instructions: </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">RUN</span></strong><span class="koboSpan" id="kobo.392.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">CMD</span></strong><span class="koboSpan" id="kobo.394.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">COPY</span></strong><span class="koboSpan" id="kobo.396.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">ADD</span></strong><span class="koboSpan" id="kobo.398.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">ENTRYPOINT</span></strong><span class="koboSpan" id="kobo.400.1">, and so on. </span><span class="koboSpan" id="kobo.400.2">This instruction is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">cd</span></strong><span class="koboSpan" id="kobo.402.1"> command in the terminal. </span><span class="koboSpan" id="kobo.402.2">It supports both absolute and relative paths. </span><span class="koboSpan" id="kobo.402.3">If the directory does not exist, it will be created. </span><span class="koboSpan" id="kobo.402.4">In this example, the working directory is set </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">/app</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
EXPOSE 8080EXPOSE 8081</span></pre>
<p><span class="koboSpan" id="kobo.407.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">EXPOSE</span></strong><span class="koboSpan" id="kobo.409.1"> instruction exposes the specified port(s) to the container when it is running. </span><span class="koboSpan" id="kobo.409.2">Note that this instruction does not actually publish the port to the host machine. </span><span class="koboSpan" id="kobo.409.3">It just means the container will listen on the specified port(s). </span><span class="koboSpan" id="kobo.409.4">By default, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">EXPOSE</span></strong><span class="koboSpan" id="kobo.411.1"> instruction exposes the port(s) on the TCP protocol. </span><span class="koboSpan" id="kobo.411.2">In this case, the container will listen on ports </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">8080</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.413.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">8081</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS buildARG BUILD_CONFIGURATION=Release
WORKDIR /src</span></pre>
<p><span class="koboSpan" id="kobo.417.1">In the preceding lines, we are using a different image, which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">mcr.microsoft.com/dotnet/sdk:8.0</span></strong><span class="koboSpan" id="kobo.419.1"> image, and naming it </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">build</span></strong><span class="koboSpan" id="kobo.421.1">. </span><span class="koboSpan" id="kobo.421.2">This image contains the .NET SDK, which is used to build the application. </span><span class="koboSpan" id="kobo.421.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">ARG</span></strong><span class="koboSpan" id="kobo.423.1"> instruction defines a variable that can be used later in the Dockerfile. </span><span class="koboSpan" id="kobo.423.2">In this case, we are defining a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">BUILD_CONFIGURATION</span></strong><span class="koboSpan" id="kobo.425.1"> and setting its default value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Release</span></strong><span class="koboSpan" id="kobo.427.1">. </span><span class="koboSpan" id="kobo.427.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">WORKDIR</span></strong><span class="koboSpan" id="kobo.429.1"> instruction sets the working directory </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">/src</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
COPY ["BasicWebApiDemo.csproj", "."]RUN dotnet restore "./BasicWebApiDemo.csproj"</span></pre>
<p><span class="koboSpan" id="kobo.434.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">COPY</span></strong><span class="koboSpan" id="kobo.436.1"> instruction</span><a id="_idIndexMarker1571"/><span class="koboSpan" id="kobo.437.1"> copies files or directories from the source (on the local machine) to the destination (the filesystem of the container). </span><span class="koboSpan" id="kobo.437.2">In this case, we are copying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">.csproj</span></strong><span class="koboSpan" id="kobo.439.1"> file to the current directory. </span><span class="koboSpan" id="kobo.439.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">RUN</span></strong><span class="koboSpan" id="kobo.441.1"> instruction executes the specified command on top of the current image and creates a new layer, then commits the results. </span><span class="koboSpan" id="kobo.441.2">The new layer will be used for the next step in the Dockerfile. </span><span class="koboSpan" id="kobo.441.3">In this case, we are running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">dotnet restore</span></strong><span class="koboSpan" id="kobo.443.1"> command to restore the </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">NuGet packages.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
COPY . </span><span class="koboSpan" id="kobo.445.2">.WORKDIR "/src/."
</span><span class="koboSpan" id="kobo.445.3">RUN dotnet build "BasicWebApiDemo.csproj" -c $BUILD_CONFIGURATION -o /app/build</span></pre>
<p><span class="koboSpan" id="kobo.446.1">In the preceding lines, we are copying all the files from the local machine to the current directory in the container. </span><span class="koboSpan" id="kobo.446.2">Then, we are setting the working directory to </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">/src</span></strong><span class="koboSpan" id="kobo.448.1">. </span><span class="koboSpan" id="kobo.448.2">Finally, we are running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">dotnet build</span></strong><span class="koboSpan" id="kobo.450.1"> command to build the application. </span><span class="koboSpan" id="kobo.450.2">Note that we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">BUILD_CONFIGURATION</span></strong><span class="koboSpan" id="kobo.452.1"> variable defined earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">the Dockerfile.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
FROM build AS publishRUN dotnet publish "BasicWebApiDemo.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false</span></pre>
<p><span class="koboSpan" id="kobo.455.1">Again, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">FROM</span></strong><span class="koboSpan" id="kobo.457.1"> instruction uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">build</span></strong><span class="koboSpan" id="kobo.459.1"> image we defined earlier and names it </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">publish</span></strong><span class="koboSpan" id="kobo.461.1">. </span><span class="koboSpan" id="kobo.461.2">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">RUN</span></strong><span class="koboSpan" id="kobo.463.1"> instruction runs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">dotnet publish</span></strong><span class="koboSpan" id="kobo.465.1"> command to publish the application. </span><span class="koboSpan" id="kobo.465.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">$BUILD_CONFIGURATION</span></strong><span class="koboSpan" id="kobo.467.1"> variable is used again. </span><span class="koboSpan" id="kobo.467.2">The published application will be placed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">app/publish</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1"> directory.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
FROM base AS finalWORKDIR /app
COPY --from=publish /app/publish .
</span><span class="koboSpan" id="kobo.471.2">ENTRYPOINT ["dotnet", "BasicWebApiDemo.dll"]</span></pre>
<p><span class="koboSpan" id="kobo.472.1">Next, we rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">base</span></strong><span class="koboSpan" id="kobo.474.1"> image as </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">final</span></strong><span class="koboSpan" id="kobo.476.1"> and set the working directory to </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">/app</span></strong><span class="koboSpan" id="kobo.478.1">. </span><span class="koboSpan" id="kobo.478.2">To run the application, we </span><a id="_idIndexMarker1572"/><span class="koboSpan" id="kobo.479.1">only need the runtime, so we do not need the SDK image. </span><span class="koboSpan" id="kobo.479.2">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">COPY</span></strong><span class="koboSpan" id="kobo.481.1"> instruction copies the published application from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">app/publish</span></strong><span class="koboSpan" id="kobo.483.1"> directory of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">publish</span></strong><span class="koboSpan" id="kobo.485.1"> image to the current directory. </span><span class="koboSpan" id="kobo.485.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">ENTRYPOINT</span></strong><span class="koboSpan" id="kobo.487.1"> instruction specifies the command to run when the container starts. </span><span class="koboSpan" id="kobo.487.2">In this case, we are running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">dotnet BasicWebApiDemo.dll</span></strong><span class="koboSpan" id="kobo.489.1"> command to start the ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">Core application.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">You can find more information about Dockerfile instructions in the official documentation provided by Docker: </span><a href="https://docs.docker.com/engine/reference/builder/"><span class="koboSpan" id="kobo.492.1">https://docs.docker.com/engine/reference/builder/</span></a><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">Next, let</span><a id="_idTextAnchor603"/><span class="koboSpan" id="kobo.494.1"> us move on to building a </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">Docker image.</span></span></p>
<h2 id="_idParaDest-316"><a id="_idTextAnchor604"/><span class="koboSpan" id="kobo.496.1">Building a Docker image</span></h2>
<p><span class="koboSpan" id="kobo.497.1">Docker </span><a id="_idIndexMarker1573"/><span class="koboSpan" id="kobo.498.1">provides a set of commands that can be used to build, run, and manage Docker images and containers. </span><span class="koboSpan" id="kobo.498.2">To build a Docker image, go to the root directory of the ASP.NET Core project we created earlier, then run the </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.500.1">
docker build -t basicwebapidemo .</span></pre> <p><span class="koboSpan" id="kobo.501.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">-t</span></strong><span class="koboSpan" id="kobo.503.1"> option is used to tag the image with a name. </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">.</span></strong><span class="koboSpan" id="kobo.505.1"> at the end means the current directory. </span><span class="koboSpan" id="kobo.505.2">Docker expects to find a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.507.1"> in the current directory. </span><span class="koboSpan" id="kobo.507.2">If you have renamed the Dockerfile or the Dockerfile is not located in the current directory, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">-f</span></strong><span class="koboSpan" id="kobo.509.1"> option to specify the Dockerfile name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">docker build -t basicwebapidemo -f </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">MyBasicWebApiDemo/MyDockerfile MyBasicWebApiDemo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">The output</span><a id="_idIndexMarker1574"/><span class="koboSpan" id="kobo.514.1"> shows that Docker is building the image layer by layer. </span><span class="koboSpan" id="kobo.514.2">Each instruction in the Dockerfile will create a layer in the image and add more content on top of the previous layer. </span><span class="koboSpan" id="kobo.514.3">The layers are cached, so if a layer has not changed, it will not be rebuilt for the next build. </span><span class="koboSpan" id="kobo.514.4">But if a layer has changed (for example, if we update the source code), then the layer that copies the source code will be rebuilt, and all the layers after that will be affected and need to be rebuilt </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">Now, let us review the default Dockerfile generated by VS 2022. </span><span class="koboSpan" id="kobo.516.2">Why does it copy all the files after running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">dotnet restore</span></strong><span class="koboSpan" id="kobo.518.1"> command? </span><span class="koboSpan" id="kobo.518.2">It is because if we only update the source code but the NuGet packages have not changed, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">dotnet restore</span></strong><span class="koboSpan" id="kobo.520.1"> command will not be executed again as the layer is cached. </span><span class="koboSpan" id="kobo.520.2">This can improve the build performance. </span><span class="koboSpan" id="kobo.520.3">However, if we update the NuGet packages, meaning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">.csproj</span></strong><span class="koboSpan" id="kobo.522.1"> file has </span><a id="_idIndexMarker1575"/><span class="koboSpan" id="kobo.523.1">changed, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">dotnet restore</span></strong><span class="koboSpan" id="kobo.525.1"> command will be </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">executed again.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">Here are some tips </span><a id="_idIndexMarker1576"/><span class="koboSpan" id="kobo.528.1">for </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">writing Dockerfiles:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.530.1">Consider the order of layers. </span><span class="koboSpan" id="kobo.530.2">Layers that are less likely to change should be placed before layers that are more likely </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">to change.</span></span></li>
<li><span class="koboSpan" id="kobo.532.1">Keep layers small as much as possible. </span><span class="koboSpan" id="kobo.532.2">Do not copy unnecessary files. </span><span class="koboSpan" id="kobo.532.3">You can configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">.dockerignore</span></strong><span class="koboSpan" id="kobo.534.1"> file to exclude files or directories from the build context. </span><span class="koboSpan" id="kobo.534.2">If you use VS 2022 to create the Dockerfile, it will generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">.dockerignore</span></strong><span class="koboSpan" id="kobo.536.1"> file for you. </span><span class="koboSpan" id="kobo.536.2">Alternatively, you can manually create a text file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">.dockerignore</span></strong><span class="koboSpan" id="kobo.538.1"> and then edit it. </span><span class="koboSpan" id="kobo.538.2">Here is a sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">dockerignore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.541.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.542.1">
# Exclude build results, Npm cache folder, and some other files**/bin/**/obj/**/.git**/.vs**/.vscode**/global.json**/Dockerfile**/.dockerignore**/node_modules</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.543.1">For more information about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">.dockerignore</span></strong><span class="koboSpan" id="kobo.545.1"> file, please refer to the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">here: </span></span><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file"><span class="No-Break"><span class="koboSpan" id="kobo.547.1">https://docs.docker.com/engine/reference/builder/#dockerignore-file</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.548.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.549.1">Keep as</span><a id="_idIndexMarker1577"/><span class="koboSpan" id="kobo.550.1"> few layers as possible. </span><span class="koboSpan" id="kobo.550.2">For example, to host an ASP.NET Core application, we can reduce the number of layers by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">mcr.microsoft.com/dotnet/aspnet</span></strong><span class="koboSpan" id="kobo.552.1"> image. </span><span class="koboSpan" id="kobo.552.2">This image contains the ASP.NET Core runtime already, eliminating the need to install the SDK in the container. </span><span class="koboSpan" id="kobo.552.3">You can also combine commands into a single </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">RUN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1"> instruction.</span></span></li>
<li><span class="koboSpan" id="kobo.555.1">Use multi-stage builds. </span><span class="koboSpan" id="kobo.555.2">Multi-stage builds allow us to use multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">FROM</span></strong><span class="koboSpan" id="kobo.557.1"> instructions in a Dockerfile. </span><span class="koboSpan" id="kobo.557.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">FROM</span></strong><span class="koboSpan" id="kobo.559.1"> instruction can be used to create a new image. </span><span class="koboSpan" id="kobo.559.2">The final image will only contain the layers from the last </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">FROM</span></strong><span class="koboSpan" id="kobo.561.1"> instruction. </span><span class="koboSpan" id="kobo.561.2">This can reduce the size of the final image. </span><span class="koboSpan" id="kobo.561.3">For example, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">mcr.microsoft.com/dotnet/sdk</span></strong><span class="koboSpan" id="kobo.563.1"> image to build the application and then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">mcr.microsoft.com/dotnet/aspnet</span></strong><span class="koboSpan" id="kobo.565.1"> image to run the application. </span><span class="koboSpan" id="kobo.565.2">This way, the final image will only contain the ASP.NET Core runtime, and it will not contain the SDK, which is not needed for running the application. </span><span class="koboSpan" id="kobo.565.3">To learn more about multi-stage builds, please refer to the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">here: </span></span><a href="https://docs.docker.com/develop/develop-images/multistage-build/"><span class="No-Break"><span class="koboSpan" id="kobo.567.1">https://docs.docker.com/develop/develop-images/multistage-build/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.568.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.569.1">For more information on optimizing Docker builds, please refer to the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">here: </span></span><a href="https://docs.docker.com/build/cache/"><span class="No-Break"><span class="koboSpan" id="kobo.571.1">https://docs.docker.com/build/cache/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.572.1">.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.573.1">We can use the following command to list all Docker images on </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">our machine:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.575.1">
docker images</span></pre> <p><span class="koboSpan" id="kobo.576.1">The output should be similar </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">to this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.578.1">
REPOSITORY      TAG     IMAGE ID       CREATED              SIZEbasicwebapidemo latest  b0d8d94d219c   About a minute ago   222MB</span></pre>
<p><span class="koboSpan" id="kobo.579.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">basicwebapidemo</span></strong><span class="koboSpan" id="kobo.581.1"> image is the one we just built. </span><span class="koboSpan" id="kobo.581.2">Each image has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">TAG</span></strong><span class="koboSpan" id="kobo.583.1"> value and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">IMAGE ID</span></strong><span class="koboSpan" id="kobo.585.1"> value. </span><span class="koboSpan" id="kobo.585.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">TAG</span></strong><span class="koboSpan" id="kobo.587.1"> value is a human-readable name for the image. </span><span class="koboSpan" id="kobo.587.2">By default, the tag is </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">latest</span></strong><span class="koboSpan" id="kobo.589.1">. </span><span class="koboSpan" id="kobo.589.2">We can specify a different tag when building the image. </span><span class="koboSpan" id="kobo.589.3">For example, we can use the following command to build the image with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">v1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1"> tag:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.592.1">
docker build -t basicwebapidemo:v1 .</span></pre> <p><span class="koboSpan" id="kobo.593.1">In the </span><a id="_idIndexMarker1578"/><span class="koboSpan" id="kobo.594.1">preceding command, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">-t</span></strong><span class="koboSpan" id="kobo.596.1"> option is used to tag the image with a name, which is separated from the tag with </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">a colon.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">To remove an image, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">docker rmi &lt;container name or ID&gt;</span></strong><span class="koboSpan" id="kobo.600.1"> command followed by the image name or </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">image ID:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.602.1">
docker rmi basicwebapidemo</span></pre> <p><span class="koboSpan" id="kobo.603.1">Note that if the image is used by a container, you will need to stop the container first before removing </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">the image.</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">We now have a Docker image for our ASP.NET Core application. </span><span class="koboSpan" id="kobo.605.2">All the necessary dependencies are included in </span><a id="_idTextAnchor605"/><span class="koboSpan" id="kobo.606.1">the image. </span><span class="koboSpan" id="kobo.606.2">Next, let us run the </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">Docker image.</span></span></p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor606"/><span class="koboSpan" id="kobo.608.1">Running a Docker container</span></h2>
<p><span class="koboSpan" id="kobo.609.1">To run a </span><a id="_idIndexMarker1579"/><span class="koboSpan" id="kobo.610.1">Docker image in the container, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">docker run</span></strong><span class="koboSpan" id="kobo.612.1"> command. </span><span class="koboSpan" id="kobo.612.2">The following command will run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">basicwebapidemo</span></strong><span class="koboSpan" id="kobo.614.1"> image we </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">just built:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.616.1">
docker run -d -p 80:8080 --name basicwebapidemo basicwebapidemo</span></pre> <p><span class="koboSpan" id="kobo.617.1">Let’s take a closer look </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">at this:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.619.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">-d</span></strong><span class="koboSpan" id="kobo.621.1"> option is used to run the container in detached mode, meaning the container will run in the background. </span><span class="koboSpan" id="kobo.621.2">You can omit this option and then the container will run in the foreground, which means if you exit the terminal, the container </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">will stop.</span></span></li>
<li><span class="koboSpan" id="kobo.623.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">-p</span></strong><span class="koboSpan" id="kobo.625.1"> option is used to publish a container’s port(s) to the host. </span><span class="koboSpan" id="kobo.625.2">In this case, we are publishing port 8080 of the container to port 80 of </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">the host.</span></span></li>
<li><span class="koboSpan" id="kobo.627.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">--name</span></strong><span class="koboSpan" id="kobo.629.1"> option is used to specify a name for the container. </span><span class="koboSpan" id="kobo.629.2">The last argument is the name of the image </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">to run.</span></span></li>
<li><span class="koboSpan" id="kobo.631.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">-it</span></strong><span class="koboSpan" id="kobo.633.1"> option to run the container in interactive mode. </span><span class="koboSpan" id="kobo.633.2">This option allows you to run a command in </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">the container.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.635.1">When we </span><a id="_idIndexMarker1580"/><span class="koboSpan" id="kobo.636.1">wrote the Dockerfile, we explained that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">EXPOSE</span></strong><span class="koboSpan" id="kobo.638.1"> instruction exposes ports 8080 and 8081 to the container only. </span><span class="koboSpan" id="kobo.638.2">To publish the internal container port to the host, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">-p</span></strong><span class="koboSpan" id="kobo.640.1"> option. </span><span class="koboSpan" id="kobo.640.2">The first port number is the port of the host machine, and the second port number is the internal container port. </span><span class="koboSpan" id="kobo.640.3">In this example, we are exposing the container port 8080 to the host port 80. </span><span class="koboSpan" id="kobo.640.4">This may confuse some people. </span><span class="koboSpan" id="kobo.640.5">So, please check the port numbers carefully. </span><span class="koboSpan" id="kobo.640.6">Also, sometimes the port number of the host machine may be occupied by another process. </span><span class="koboSpan" id="kobo.640.7">In this case, you will need to use a different </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">port number.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">The output should return the container ID, which is a UID for the container, such </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">as this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.644.1">
5529b0278e5a14452a7049a7c9922797b0c1171423970f99b4481c93cfdc6a38</span></pre> <p><span class="koboSpan" id="kobo.645.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">docker ps</span></strong><span class="koboSpan" id="kobo.647.1"> command to list all </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">running containers:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.649.1">
docker ps</span></pre> <p><span class="koboSpan" id="kobo.650.1">The output should be similar </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">to this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.652.1">
CONTAINER ID   IMAGE             COMMAND                  CREATED         STATUS         PORTS                                 NAMES403eb4952287   basicwebapidemo   "dotnet BasicWebApiD…"   5 minutes ago   Up 5 minutes   8081/tcp, 0.0.0.0:80-&gt;8080/tcp   basicwebapidemo</span></pre>
<p><span class="koboSpan" id="kobo.653.1">In the output, we can see that port 8080 of the container has been mapped to port 80 of </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">the host.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">To list all containers in all states, just add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">a</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1"> option:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.659.1">
docker ps -a</span></pre> <p><span class="koboSpan" id="kobo.660.1">You can check the status of containers. </span><span class="koboSpan" id="kobo.660.2">If the container is running, the status should </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">Up</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">We can use the following commands to </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">manage containers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.666.1">To pause a container: </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">docker pause &lt;container name </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">or ID&gt;</span></strong></span></li>
<li><span class="koboSpan" id="kobo.669.1">To restart a container: </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">docker restart &lt;container name </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">or ID&gt;</span></strong></span></li>
<li><span class="koboSpan" id="kobo.672.1">To stop a container: </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">docker stop &lt;container name </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">or ID&gt;</span></strong></span></li>
<li><span class="koboSpan" id="kobo.675.1">To remove a container: </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">docker rm &lt;container name </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">or ID&gt;</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.678.1">If the container</span><a id="_idIndexMarker1581"/><span class="koboSpan" id="kobo.679.1"> is running, you can test the endpoint by sending a request to this URL: </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">http://localhost/weatherforecast</span></strong><span class="koboSpan" id="kobo.681.1">. </span><span class="koboSpan" id="kobo.681.2">You will see the response from the ASP.NET Core application. </span><span class="koboSpan" id="kobo.681.3">If you change the port number of the host machine, you will need to use the correct port number in the URL. </span><span class="koboSpan" id="kobo.681.4">For example, if you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">-p 5000:8080</span></strong><span class="koboSpan" id="kobo.683.1">, then you will need to use </span><a href="http://localhost:5000/weatherforecast"><span class="koboSpan" id="kobo.684.1">http://localhost:5000/weatherforecast</span></a><span class="koboSpan" id="kobo.685.1"> to access </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">the endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">docker logs &lt;container name or ID&gt;</span></strong><span class="koboSpan" id="kobo.689.1"> command to show logs from </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">a container:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.691.1">
docker logs basicwebapidemo</span></pre> <p><span class="koboSpan" id="kobo.692.1">You will see logs such </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">as these:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.694.1">
info: Microsoft.Hosting.Lifetime[14]      Now listening on: http://[::]:8080
info: Microsoft.Hosting.Lifetime[0]
      Application started. </span><span class="koboSpan" id="kobo.694.2">Press Ctrl+C to shut down.
</span><span class="koboSpan" id="kobo.694.3">info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /app</span></pre>
<p><span class="koboSpan" id="kobo.695.1">To check the stats of a container, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">docker stats &lt;container name or </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">ID&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.698.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.699.1">
docker stats basicwebapidemo</span></pre> <p><span class="koboSpan" id="kobo.700.1">You will see the stats of the container </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.702.1">
CONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O   PIDS403eb4952287   basicwebapidemo   0.01%     24.24MiB / 15.49GiB   0.15%     23.8kB / 2.95kB   0B / 0B     25</span></pre>
<p><span class="koboSpan" id="kobo.703.1">You can send a request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">/weatherforecast</span></strong><span class="koboSpan" id="kobo.705.1"> endpoint to get the response from the ASP.NET Core application. </span><span class="koboSpan" id="kobo.705.2">Note that the container is running in the production environment, so the Swagger UI is not available. </span><span class="koboSpan" id="kobo.705.3">This is because in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">Program.cs</span></strong><span class="koboSpan" id="kobo.707.1"> file, we </span><a id="_idIndexMarker1582"/><span class="koboSpan" id="kobo.708.1">enabled the Swagger UI only in the development environment. </span><span class="koboSpan" id="kobo.708.2">To enable the Swagger UI, we can stop and delete the current container, then create a new one in development environment. </span><span class="koboSpan" id="kobo.708.3">Alternatively, you can create a new container with a different name. </span><span class="koboSpan" id="kobo.708.4">For example, you can stop the container by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.710.1">
docker stop basicwebapidemo</span></pre> <p><span class="koboSpan" id="kobo.711.1">Then remove the container by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.713.1">
docker rm basicwebapidemo</span></pre> <p><span class="koboSpan" id="kobo.714.1">Next, add an environment variable to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">docker run</span></strong><span class="koboSpan" id="kobo.716.1"> command to set the environment </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">to development:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.718.1">
docker run -d -p 80:8080 --name basicwebapidemo -e ASPNETCORE_ENVIRONMENT=Development basicwebapidemo</span></pre> <p><span class="koboSpan" id="kobo.719.1">Now, you can view the Swagger UI by navigating to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">/swagger</span></strong><span class="koboSpan" id="kobo.721.1"> endpoint in </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">So far, we have learned how to build and run Docker images. </span><span class="koboSpan" id="kobo.723.2">Docker has many other commands that can be used to manage Docker images and containers. </span><span class="koboSpan" id="kobo.723.3">To summarize, here are some of the most commonly used Docker commands from Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">official documents:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">docker build</span></strong><span class="koboSpan" id="kobo.726.1">: Build a </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">Docker image</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">docker run</span></strong><span class="koboSpan" id="kobo.729.1">: Run a </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">Docker image</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">docker images</span></strong><span class="koboSpan" id="kobo.732.1">: List </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">all images</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">docker ps</span></strong><span class="koboSpan" id="kobo.735.1">: List all </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">running containers</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">docker ps -a</span></strong><span class="koboSpan" id="kobo.738.1">: List all containers in </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">all states</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">docker logs</span></strong><span class="koboSpan" id="kobo.741.1">: Show logs from </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">a container</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">docker stats</span></strong><span class="koboSpan" id="kobo.744.1">: Show stats of </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">a container</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">docker pause</span></strong><span class="koboSpan" id="kobo.747.1">: Pause </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">a container</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">docker restart</span></strong><span class="koboSpan" id="kobo.750.1">: Restart </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">a container</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">docker stop</span></strong><span class="koboSpan" id="kobo.753.1">: Stop </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">a container</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">docker rm</span></strong><span class="koboSpan" id="kobo.756.1">: Remove </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">a container</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">docker rmi</span></strong><span class="koboSpan" id="kobo.759.1">: Remove </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">an image</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">docker exec</span></strong><span class="koboSpan" id="kobo.762.1">: Run a command in a </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">running container</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">docker inspect</span></strong><span class="koboSpan" id="kobo.765.1">: Display detailed information on one or more containers </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">or images</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">docker login</span></strong><span class="koboSpan" id="kobo.768.1">: Log in to a </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">Docker registry</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">docker logout</span></strong><span class="koboSpan" id="kobo.771.1">: Log out from a </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">Docker registry</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">docker pull</span></strong><span class="koboSpan" id="kobo.774.1">: Pull an image from </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">a registry</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">docker push</span></strong><span class="koboSpan" id="kobo.777.1">: Push an image to </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">a registry</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">docker tag</span></strong><span class="koboSpan" id="kobo.780.1">: Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">TARGET_IMAGE</span></strong><span class="koboSpan" id="kobo.782.1"> tag that refers </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">SOURCE_IMAGE</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">docker volume</span></strong><span class="koboSpan" id="kobo.786.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">Manage volumes</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">docker network</span></strong><span class="koboSpan" id="kobo.789.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">Manage networks</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">docker system</span></strong><span class="koboSpan" id="kobo.792.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">Manage Docker</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">docker version</span></strong><span class="koboSpan" id="kobo.795.1">: Show the Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">version information</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">docker info</span></strong><span class="koboSpan" id="kobo.798.1">: Show Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">system-wide information</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">docker port</span></strong><span class="koboSpan" id="kobo.801.1">: List port mappings or a specific mapping for </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">a container</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.803.1">You can</span><a id="_idIndexMarker1583"/><span class="koboSpan" id="kobo.804.1"> find more information about Docker commands</span><a id="_idIndexMarker1584"/> <span class="No-Break"><span class="koboSpan" id="kobo.805.1">here: </span></span><a href="https://docs.docker.com/engine/reference/commandline/cli/"><span class="No-Break"><span class="koboSpan" id="kobo.806.1">https://docs.docker.com/engine/reference/commandline/cli/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.807.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.808.1">We have now learned how to build a Docker image for our ASP.NET Core application and run it in a container. </span><span class="koboSpan" id="kobo.808.2">Even though the container is running on our local machine, there is not much difference from running it in a production environment. </span><span class="koboSpan" id="kobo.808.3">The container is isolated from</span><a id="_idIndexMarker1585"/><span class="koboSpan" id="kobo.809.1"> the host machine. </span><span class="koboSpan" id="kobo.809.2">The portable nature of containers makes it easy to deploy the application to </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">any environment.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">We can also use Docker commands to push the image to a registry, such as Docker Hub, ACR, and so on. </span><span class="koboSpan" id="kobo.811.2">However, manual deployment is error-prone and time-consuming. </span><span class="koboSpan" id="kobo.811.3">That is why we need a CI/CD pipeline to automate the </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">deployment process.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">In the next section, we will discuss how to deploy the containerized application </span><a id="_idTextAnchor607"/><span class="koboSpan" id="kobo.814.1">to the cloud using Azure DevOps and </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">Azure Pipelines.</span></span></p>
<h1 id="_idParaDest-318"><a id="_idTextAnchor608"/><span class="koboSpan" id="kobo.816.1">CI/CD using Azure DevOps and Azure Pipelines</span></h1>
<p><span class="koboSpan" id="kobo.817.1">Azure DevOps</span><a id="_idIndexMarker1586"/><span class="koboSpan" id="kobo.818.1"> is a cloud-based service that provides a set of tools for managing the software development process. </span><span class="koboSpan" id="kobo.818.2">It includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">following services:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.820.1">Azure Boards</span></strong><span class="koboSpan" id="kobo.821.1">: A </span><a id="_idIndexMarker1587"/><span class="koboSpan" id="kobo.822.1">service for managing work items, such as user stories, tasks, </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">and bugs.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.824.1">Azure Repos</span></strong><span class="koboSpan" id="kobo.825.1">: A</span><a id="_idIndexMarker1588"/><span class="koboSpan" id="kobo.826.1"> service for hosting code repositories. </span><span class="koboSpan" id="kobo.826.2">It supports Git</span><a id="_idIndexMarker1589"/><span class="koboSpan" id="kobo.827.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">Team Foundation Version Control</span></strong><span class="koboSpan" id="kobo.829.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.830.1">TFVC</span></strong><span class="koboSpan" id="kobo.831.1">). </span><span class="koboSpan" id="kobo.831.2">The repositories can be public </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">or private.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.833.1">Azure Pipelines</span></strong><span class="koboSpan" id="kobo.834.1">: A </span><a id="_idIndexMarker1590"/><span class="koboSpan" id="kobo.835.1">service for building, testing, and deploying applications with any language, platform, </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">and cloud.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.837.1">Azure Test Plans</span></strong><span class="koboSpan" id="kobo.838.1">: A</span><a id="_idIndexMarker1591"/><span class="koboSpan" id="kobo.839.1"> service for manual and exploratory </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">testing tools.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.841.1">Azure Artifacts</span></strong><span class="koboSpan" id="kobo.842.1">: A</span><a id="_idIndexMarker1592"/><span class="koboSpan" id="kobo.843.1"> service for creating, hosting, and sharing packages, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">Maven</span></strong><span class="koboSpan" id="kobo.845.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">npm</span></strong><span class="koboSpan" id="kobo.847.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">NuGet</span></strong><span class="koboSpan" id="kobo.849.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">Python</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.851.1"> packages.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.852.1">Azure DevOps is free for open-source projects and small teams. </span><span class="koboSpan" id="kobo.852.2">We will not cover all the features of Azure DevOps in this book. </span><span class="koboSpan" id="kobo.852.3">Let us focus on Azure Pipelines. </span><span class="koboSpan" id="kobo.852.4">In this section, we will discuss how to use Azure Pipelines to build and deploy our ASP.NET Core application to Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">App Service.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">We will need these resources before we can deploy the application </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">to Azure:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.856.1">Azure DevOps </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.857.1">account</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">: </span></span><a href="https://azure.microsoft.com/en-us/products/devops"><span class="No-Break"><span class="koboSpan" id="kobo.859.1">https://azure.microsoft.com/en-us/products/devops</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.860.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.861.1">Azure subscription</span></strong><span class="koboSpan" id="kobo.862.1">: </span><a href="https://azure.microsoft.com/en-us/free/"><span class="koboSpan" id="kobo.863.1">https://azure.microsoft.com/en-us/free/</span></a><span class="koboSpan" id="kobo.864.1">. </span><span class="koboSpan" id="kobo.864.2">You can sign up for a free account here. </span><span class="koboSpan" id="kobo.864.3">You will get some free credits to use </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">Azure services.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.866.1">GitHub repository</span></strong><span class="koboSpan" id="kobo.867.1">: You need a GitHub repository to host the source code. </span><span class="koboSpan" id="kobo.867.2">The pipeline will be t</span><a id="_idTextAnchor609"/><span class="koboSpan" id="kobo.868.1">riggered when code changes are committed to </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">the repository.</span></span></li>
</ul>
<h2 id="_idParaDest-319"><a id="_idTextAnchor610"/><span class="koboSpan" id="kobo.870.1">Preparing the source code</span></h2>
<p><span class="koboSpan" id="kobo.871.1">GitHub is one of the most popular source control solutions. </span><span class="koboSpan" id="kobo.871.2">It is free for public repositories. </span><span class="koboSpan" id="kobo.871.3">We suppose you already have a </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">GitHub account.</span></span></p>
<p><span class="koboSpan" id="kobo.873.1">Download</span><a id="_idIndexMarker1593"/><span class="koboSpan" id="kobo.874.1"> the example code from </span><a href="https://h/chapter14/MyBasicWebApiDemo"><span class="koboSpan" id="kobo.875.1">/chapter14/MyBasicWebApiDemo</span></a><span class="koboSpan" id="kobo.876.1">. </span><span class="koboSpan" id="kobo.876.2">This is a simple ASP.NET Core web API application with its unit tests and integration tests. </span><span class="koboSpan" id="kobo.876.3">Create a new repository on GitHub, then push the source code to the repository. </span><span class="koboSpan" id="kobo.876.4">The directory structure of the repository should look like </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
MyAzurePipelinesDemo    ├── src
    │   └──MyBasicWebApiDemo
    ├── tests
    │   ├──MyBasicWebApiDemo.UnitTests
    │   └──MyBasicWebApiDemo.IntegrationTests
    ├── MyBasicWebApiDemo.sln
    ├── README.md
    ├── LICENSE
    └── .gitignore</span></pre>
<p><span class="koboSpan" id="kobo.879.1">In the preceding directory structure, the main ASP.NET Core web API project is placed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">src</span></strong><span class="koboSpan" id="kobo.881.1"> folder, and the unit tests and integration tests are placed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">tests</span></strong><span class="koboSpan" id="kobo.883.1"> folder. </span><span class="koboSpan" id="kobo.883.2">This can better</span><a id="_idIndexMarker1594"/><span class="koboSpan" id="kobo.884.1"> organize the solution structure. </span><span class="koboSpan" id="kobo.884.2">But it is just a personal preference. </span><span class="koboSpan" id="kobo.884.3">You can also place the unit tests and integration tests in the same folder as the main project. </span><span class="koboSpan" id="kobo.884.4">If you use a different directory structure, please update the paths in the pipeline accordingly in the </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">following sections.</span></span></p>
<p><span class="koboSpan" id="kobo.886.1">We will use this repository for th</span><a id="_idTextAnchor611"/><span class="koboSpan" id="kobo.887.1">e pipeline. </span><span class="koboSpan" id="kobo.887.2">Next, let us create the required </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">Azure resources.</span></span></p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor612"/><span class="koboSpan" id="kobo.889.1">Creating Azure resources</span></h2>
<p><span class="koboSpan" id="kobo.890.1">In today’s technology</span><a id="_idIndexMarker1595"/><span class="koboSpan" id="kobo.891.1"> landscape, cloud computing has become the backbone of modern software development. </span><span class="koboSpan" id="kobo.891.2">Cloud computing provides many benefits, such as scalability, </span><strong class="bold"><span class="koboSpan" id="kobo.892.1">high availability</span></strong><span class="koboSpan" id="kobo.893.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.894.1">HA</span></strong><span class="koboSpan" id="kobo.895.1">), and </span><a id="_idIndexMarker1596"/><span class="koboSpan" id="kobo.896.1">cost efficiency. </span><span class="koboSpan" id="kobo.896.2">Among the various cloud providers, such as AWS, GCP, and Alibaba Cloud, Microsoft Azure stands out as a robust and versatile platform for hosting and orchestrating your applications. </span><span class="koboSpan" id="kobo.896.3">Azure provides many</span><a id="_idIndexMarker1597"/><span class="koboSpan" id="kobo.897.1"> services for hosting applications, such as Azure App Service, </span><strong class="bold"><span class="koboSpan" id="kobo.898.1">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.899.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.900.1">AKS</span></strong><span class="koboSpan" id="kobo.901.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.902.1">Azure Container Instances</span></strong><span class="koboSpan" id="kobo.903.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.904.1">ACI</span></strong><span class="koboSpan" id="kobo.905.1">), Azure VMs, and Azure Functions. </span><span class="koboSpan" id="kobo.905.2">In this book, we will use Azure as the cloud platform to</span><a id="_idIndexMarker1598"/><span class="koboSpan" id="kobo.906.1"> host our applications. </span><span class="koboSpan" id="kobo.906.2">For other cloud platforms, the concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">are similar.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">We will need the following </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">Azure resources:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.910.1">Azure Container Registry</span></strong><span class="koboSpan" id="kobo.911.1">: A </span><a id="_idIndexMarker1599"/><span class="koboSpan" id="kobo.912.1">private registry for storing Docker images. </span><span class="koboSpan" id="kobo.912.2">You can create a new Azure container registry in the Azure portal. </span><span class="koboSpan" id="kobo.912.3">Please refer to the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">here: </span></span><a href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal"><span class="No-Break"><span class="koboSpan" id="kobo.914.1">https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.915.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.916.1">Azure Web App for Containers</span></strong><span class="koboSpan" id="kobo.917.1">: A </span><a id="_idIndexMarker1600"/><span class="koboSpan" id="kobo.918.1">service for hosting containerized web applications. </span><span class="koboSpan" id="kobo.918.2">It provides a quick and easy way to build, deploy, and scale enterprise-grade web, mobile, and API apps on any platform. </span><span class="koboSpan" id="kobo.918.3">You can create a new Azure Web App for Containers instance in the Azure portal. </span><span class="koboSpan" id="kobo.918.4">Please refer to the official documentation here: </span><a href="https://learn.microsoft.com/en-us/azure/app-service/quickstart-custom-container?tabs=dotnet&amp;pivots=container-linux-azure-portal"><span class="koboSpan" id="kobo.919.1">https://learn.microsoft.com/en-us/azure/app-service/quickstart-custom-container?tabs=dotnet&amp;pivots=container-linux-azure-portal</span></a><span class="koboSpan" id="kobo.920.1">. </span><span class="koboSpan" id="kobo.920.2">Please select </span><strong class="bold"><span class="koboSpan" id="kobo.921.1">Docker Container</span></strong><span class="koboSpan" id="kobo.922.1"> for the </span><strong class="bold"><span class="koboSpan" id="kobo.923.1">Publish</span></strong><span class="koboSpan" id="kobo.924.1"> option, and select </span><strong class="bold"><span class="koboSpan" id="kobo.925.1">Linux</span></strong><span class="koboSpan" id="kobo.926.1"> for the </span><strong class="bold"><span class="koboSpan" id="kobo.927.1">Operating System</span></strong><span class="koboSpan" id="kobo.928.1"> option when creating the Web App for Containers instance because we are using Linux containers in </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">this chapter.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.930.1">Note that</span><a id="_idIndexMarker1601"/><span class="koboSpan" id="kobo.931.1"> you can also choose Azure App Service to host your application without containerization. </span><span class="koboSpan" id="kobo.931.2">Azure App Service supports many programming languages and frameworks, such as .NET, .NET Core, Java, Node.js, Python, and so on. </span><span class="koboSpan" id="kobo.931.3">It also supports containers. </span><span class="koboSpan" id="kobo.931.4">You can learn more about Azure App Service here: </span><a href="https://docs.microsoft.com/en-us/azure/app-service/overview"><span class="koboSpan" id="kobo.932.1">https://docs.microsoft.com/en-us/azure/app-service/overview</span></a><span class="koboSpan" id="kobo.933.1">. </span><span class="koboSpan" id="kobo.933.2">In this section, we will explore how to deploy applications in containers, so we will use Azure Web App for Containers in the </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">following example.</span></span></p>
<p><span class="koboSpan" id="kobo.935.1">To better manage these resources, it is recommended to create a resource group to group these resources together. </span><span class="koboSpan" id="kobo.935.2">You can create a new resource group in the Azure portal or create a new resource group when you create a new resource. </span><span class="koboSpan" id="kobo.935.3">Here is key information on the resources we need to prepare for </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">the pipelines:</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.937.1">Resource group</span></span></p>
<p class="list-inset"><span class="No-Break"><span class="koboSpan" id="kobo.938.1">name: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">devops-lab</span></strong></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.940.1">Container registry</span></span></p>
<p class="list-inset"><span class="No-Break"><span class="koboSpan" id="kobo.941.1">name: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">devopscrlab</span></strong></span></p>
<p><span class="koboSpan" id="kobo.943.1">Web App for </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">Containers instance:</span></span></p>
<p class="list-inset"><span class="No-Break"><span class="koboSpan" id="kobo.945.1">name: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">azure-pipeline-demo</span></strong></span></p>
<p><span class="koboSpan" id="kobo.947.1">You can use either the Azure portal or Azure CLI to create these resources. </span><span class="koboSpan" id="kobo.947.2">Defining the scripts to create the</span><a id="_idIndexMarker1602"/><span class="koboSpan" id="kobo.948.1"> resources in code is a good practice, which is called </span><strong class="bold"><span class="koboSpan" id="kobo.949.1">infrastructure as code</span></strong><span class="koboSpan" id="kobo.950.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.951.1">IaC</span></strong><span class="koboSpan" id="kobo.952.1">). </span><span class="koboSpan" id="kobo.952.2">However, we will not cover IaC here because it is out of the scope of this book. </span><span class="koboSpan" id="kobo.952.3">You can learn more about IaC </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">here: </span></span><a href="https://learn.microsoft.com/en-us/devops/deliver/what-is﻿-infrastructure-as-code"><span class="No-Break"><span class="koboSpan" id="kobo.954.1">https://learn.microsoft.com/en-us/devops/deliver/what-is</span><span id="_idTextAnchor613"/><span class="koboSpan" id="kobo.955.1">-infrastructure-as-code</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.956.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.957.1">Next, let us create an Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">DevOps project.</span></span></p>
<h2 id="_idParaDest-321"><a id="_idTextAnchor614"/><span class="koboSpan" id="kobo.959.1">Creating an Azure DevOps project</span></h2>
<p><span class="koboSpan" id="kobo.960.1">As the </span><a id="_idIndexMarker1603"/><span class="koboSpan" id="kobo.961.1">official documentation provides detailed instructions on how to create an Azure DevOps project, we will not cover the details here. </span><span class="koboSpan" id="kobo.961.2">Please refer to the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">here: </span></span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-sign-up?view=azure-devops"><span class="No-Break"><span class="koboSpan" id="kobo.963.1">https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-sign-up?view=azure-devops</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.964.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.965.1">You need to follow the official documentation to create an Azure DevOps account. </span><span class="koboSpan" id="kobo.965.2">You can sign up with a Microsoft account or a GitHub account. </span><span class="koboSpan" id="kobo.965.3">Once you create an Azure DevOps account, you can create a new organization. </span><span class="koboSpan" id="kobo.965.4">An organization is a container for projects and teams. </span><span class="koboSpan" id="kobo.965.5">You can create multiple organizations with one Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">DevOps account.</span></span></p>
<p><span class="koboSpan" id="kobo.967.1">Next, you can create a new project in Azure DevOps. </span><span class="koboSpan" id="kobo.967.2">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.968.1">New project</span></strong><span class="koboSpan" id="kobo.969.1"> button on the home page, then follow the instructions to create a new project </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.971.1"><img alt="Figure 14.5 – Creating a new project in Azure DevOps" src="image/B18971_14_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.972.1">Figure 14.5 – Creating a new project in Azure DevOps</span></p>
<p><span class="koboSpan" id="kobo.973.1">We will </span><a id="_idIndexMarker1604"/><span class="koboSpan" id="kobo.974.1">create these pipelines in the project in the </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">next sections:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.976.1">Pull request build pipeline</span></strong><span class="koboSpan" id="kobo.977.1">: A</span><a id="_idIndexMarker1605"/><span class="koboSpan" id="kobo.978.1"> pipeline for building the application and running tests when a pull request is created. </span><span class="koboSpan" id="kobo.978.2">This pipeline will be triggered when a pull request is created in the GitHub repository. </span><span class="koboSpan" id="kobo.978.3">If the build fails or the tests fail, the pull request cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">be merged.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.980.1">Docker build pipeline</span></strong><span class="koboSpan" id="kobo.981.1">: A </span><a id="_idIndexMarker1606"/><span class="koboSpan" id="kobo.982.1">pipeline for building the application into a Docker image and publishing the image to ACR. </span><span class="koboSpan" id="kobo.982.2">This pipeline will be triggered when a pull request is merged into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.984.1"> branch.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.985.1">Release pipeline</span></strong><span class="koboSpan" id="kobo.986.1">: A</span><a id="_idIndexMarker1607"/><span class="koboSpan" id="kobo.987.1"> pipeline for deploying the application to Azure Container Apps. </span><span class="koboSpan" id="kobo.987.2">This pipeline can be triggere</span><a id="_idTextAnchor615"/><span class="koboSpan" id="kobo.988.1">d when a new image is published to ACR, or it can be </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">triggered manually.</span></span></li>
</ul>
<h2 id="_idParaDest-322"><a id="_idTextAnchor616"/><span class="koboSpan" id="kobo.990.1">Creating a pull request pipeline</span></h2>
<p><span class="koboSpan" id="kobo.991.1">In this</span><a id="_idIndexMarker1608"/><span class="koboSpan" id="kobo.992.1"> section, we will create a pull request build pipeline. </span><span class="koboSpan" id="kobo.992.2">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">the steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.994.1">Navigate to the Azure DevOps portal, click the </span><strong class="bold"><span class="koboSpan" id="kobo.995.1">Pipelines</span></strong><span class="koboSpan" id="kobo.996.1"> tab on the left side, and then click the </span><strong class="bold"><span class="koboSpan" id="kobo.997.1">Create Pipeline</span></strong><span class="koboSpan" id="kobo.998.1"> button. </span><span class="koboSpan" id="kobo.998.2">You will see a page </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">like this:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.1000.1"><img alt="Figure 14.6 – Creating a new pipeline in Azure DevOps" src="image/B18971_14_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1001.1">Figure 14.6 – Creating a new pipeline in Azure DevOps</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1002.1">Azure DevOps Pipelines supports various sources, such as Azure Repos, GitHub, Bitbucket, and Subversion. </span><span class="koboSpan" id="kobo.1002.2">We already have a GitHub repository, so we will use GitHub as the source. </span><span class="koboSpan" id="kobo.1002.3">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1003.1">GitHub</span></strong><span class="koboSpan" id="kobo.1004.1"> button, then follow the instructions to authorize</span><a id="_idIndexMarker1609"/><span class="koboSpan" id="kobo.1005.1"> Azure DevOps to access your GitHub account. </span><span class="koboSpan" id="kobo.1005.2">Once you have authorized Azure DevOps to access your GitHub account, you will see a list of repositories in your GitHub account. </span><span class="koboSpan" id="kobo.1005.3">Select the repository we created earlier; you will be navigated to GitHub and see a page where you can install Azure Pipelines to the repository. </span><span class="koboSpan" id="kobo.1005.4">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1006.1">Approve and install</span></strong><span class="koboSpan" id="kobo.1007.1"> button to install Azure Pipelines to the repository. </span><span class="koboSpan" id="kobo.1007.2">Then, you will be navigated back to Azure DevOps. </span><span class="koboSpan" id="kobo.1007.3">You will see a page </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">like this:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer116">
<span class="koboSpan" id="kobo.1009.1"><img alt="Figure 14.7 – Configuring the pipeline" src="image/B18971_14_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1010.1">Figure 14.7 – Configuring the pipeline</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1011.1">Azure DevOps Pipelines can provide various templates for your project. </span><span class="koboSpan" id="kobo.1011.2">In this case, you can choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1012.1">ASP.NET</span></strong><span class="koboSpan" id="kobo.1013.1"> template to start with. </span><span class="koboSpan" id="kobo.1013.2">Azure DevOps Pipelines can automatically detect the source code and generate a basic pipeline for you. </span><span class="koboSpan" id="kobo.1013.3">The </span><a id="_idIndexMarker1610"/><span class="koboSpan" id="kobo.1014.1">default pipeline is a YAML file, which may look </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1016.1">
trigger:- mainpool:  vmImage: 'windows-latest'variables:  solution: '**/*.sln'  buildPlatform: 'Any CPU'  buildConfiguration: 'Release'steps:- task: NuGetToolInstaller@1- task: NuGetCommand@2  inputs:    restoreSolution: '$(solution)'- task: VSBuild@1  inputs:    solution: '$(solution)'    msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="$(build.artifactStagingDirectory)"'    platform: '$(buildPlatform)'    configuration: '$(buildConfiguration)'- task: VSTest@2  inputs:    platform: '$(buildPlatform)'    configuration: '$(buildConfiguration)'</span></pre></li> <li><span class="koboSpan" id="kobo.1017.1">The </span><a id="_idIndexMarker1611"/><span class="koboSpan" id="kobo.1018.1">default pipeline is targeting Windows. </span><span class="koboSpan" id="kobo.1018.2">We will run the application in a Linux container, so we need to make some changes to the pipeline. </span><span class="koboSpan" id="kobo.1018.3">Delete the default content and we will start </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">from scratch.</span></span></li>
<li><span class="koboSpan" id="kobo.1020.1">First, rename the pipeline to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">pr-build-pipeline</span></strong><span class="koboSpan" id="kobo.1022.1">. </span><span class="koboSpan" id="kobo.1022.2">You can rename the pipeline by clicking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">yml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1"> filename:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer117">
<span class="koboSpan" id="kobo.1026.1"><img alt="Figure 14.8 – Renaming the pipeline" src="image/B18971_14_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1027.1">Figure 14.8 – Renaming the pipeline</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1028.1">Then, we need to update the trigger to make the pipeline run when a pull request is opened or updated for one of the target branches. </span><span class="koboSpan" id="kobo.1028.2">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">pr</span></strong><span class="koboSpan" id="kobo.1030.1"> keyword to </span><a id="_idIndexMarker1612"/><span class="koboSpan" id="kobo.1031.1">indicate that the pipeline will be triggered by a pull request for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1"> branch:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1034.1">
pr:  branches:    include:    - main</span></pre></li> <li><span class="koboSpan" id="kobo.1035.1">Next, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">pool</span></strong><span class="koboSpan" id="kobo.1037.1"> to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">ubuntu-latest</span></strong><span class="koboSpan" id="kobo.1039.1"> image. </span><span class="koboSpan" id="kobo.1039.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">ubuntu-latest</span></strong><span class="koboSpan" id="kobo.1041.1"> image is a Linux image, which is smaller than a Windows image. </span><span class="koboSpan" id="kobo.1041.2">Also, the application is targeting Linux containers, so it is better to use a </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">Linux image:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1043.1">
pool:  vmImage: 'ubuntu-latest'</span></pre></li> <li><span class="koboSpan" id="kobo.1044.1">Next, create some variables for the solution path, build configuration, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">so on:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1046.1">
variables:  solution: '**/*.sln'  buildConfiguration: 'Release'</span></pre></li> <li><span class="koboSpan" id="kobo.1047.1">Then, we need to add some tasks. </span><span class="koboSpan" id="kobo.1047.2">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">steps:</span></strong><span class="koboSpan" id="kobo.1049.1"> section, then add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">following tasks:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
steps:- task: UseDotNet@2  displayName: 'use dotnet cli'  inputs:    packageType: 'sdk'    version: '8.0.x'    includePreviewVersions: true</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1052.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">UseDotNet@2</span></strong><span class="koboSpan" id="kobo.1054.1"> task is used to install the .NET SDK so that we can use the .NET CLI to execute commands. </span><span class="koboSpan" id="kobo.1054.2">In this case, we are installing the .NET 8.0 SDK. </span><span class="koboSpan" id="kobo.1054.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">includePreviewVersions</span></strong><span class="koboSpan" id="kobo.1056.1"> option is used to include preview versions of the .NET SDK. </span><span class="koboSpan" id="kobo.1056.2">We need to use the preview version because the .NET 8.0 SDK is still in </span><a id="_idIndexMarker1613"/><span class="koboSpan" id="kobo.1057.1">preview at the time of writing this book. </span><span class="koboSpan" id="kobo.1057.2">If you are reading this book after the .NET 8.0 SDK is released, you can remove the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">includePreviewVersions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1"> option.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1060.1">The online pipeline editor provides IntelliSense for the YAML file </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">like this:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer118">
<span class="koboSpan" id="kobo.1062.1"><img alt="Figure 14.9 – IntelliSense for YAML file" src="image/B18971_14_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1063.1">Figure 14.9 – IntelliSense for YAML file</span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.1064.1">You can click the </span><strong class="bold"><span class="koboSpan" id="kobo.1065.1">Settings</span></strong><span class="koboSpan" id="kobo.1066.1"> link above the task to configure the task in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">dialog box:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer119">
<span class="koboSpan" id="kobo.1068.1"><img alt="Figure 14.10 – Configuring the task in a dialog box" src="image/B18971_14_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1069.1">Figure 14.10 – Configuring the task in a dialog box</span></p>
<ol>
<li value="11"><span class="koboSpan" id="kobo.1070.1">Next, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">DotNetCoreCLI@2</span></strong><span class="koboSpan" id="kobo.1072.1"> task to build </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">the application:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1074.1">
- task: DotNetCoreCLI@2  displayName: 'dotnet build'  inputs:    command: 'build'    arguments: '--configuration $(buildConfiguration)    projects: '$(solution)'</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1075.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">DotNetCoreCLI@2</span></strong><span class="koboSpan" id="kobo.1077.1"> task is used to run dotnet CLI commands. </span><span class="koboSpan" id="kobo.1077.2">In this case, we are running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">dotnet build</span></strong><span class="koboSpan" id="kobo.1079.1"> command to build the application. </span><span class="koboSpan" id="kobo.1079.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">--configuration</span></strong><span class="koboSpan" id="kobo.1081.1"> option is used to specify the build configuration. </span><span class="koboSpan" id="kobo.1081.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">--runtime</span></strong><span class="koboSpan" id="kobo.1083.1"> option is used to specify the target runtime. </span><span class="koboSpan" id="kobo.1083.2">In this case, we are targeting the Linux runtime. </span><span class="koboSpan" id="kobo.1083.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">projects</span></strong><span class="koboSpan" id="kobo.1085.1"> option is used to specify the path to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">.csproj</span></strong><span class="koboSpan" id="kobo.1087.1"> file or solution file. </span><span class="koboSpan" id="kobo.1087.2">In this case, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">$(solution)</span></strong><span class="koboSpan" id="kobo.1089.1"> variable we </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">defined earlier.</span></span></p></li> <li><span class="koboSpan" id="kobo.1091.1">Next, add </span><a id="_idIndexMarker1614"/><span class="koboSpan" id="kobo.1092.1">tasks to run unit tests and </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">integration tests:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1094.1">
- task: DotNetCoreCLI@2  displayName: 'dotnet test - unit tests'  inputs:    command: 'test'    arguments: '--configuration $(buildConfiguration) --no-build --no-restore --logger trx --collect "Code coverage"'    projects: '**/*.UnitTests.csproj'- task: DotNetCoreCLI@2  displayName: 'dotnet test - integration tests'  inputs:    command: 'test'    arguments: '--configuration $(buildConfiguration) --no-build --no-restore --logger trx --collect "Code coverage"'    projects: '**/*.IntegrationTests.csproj'</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1095.1">In the preceding tasks, we are running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">dotnet test</span></strong><span class="koboSpan" id="kobo.1097.1"> command to run unit tests and integration tests. </span><span class="koboSpan" id="kobo.1097.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">--no-build</span></strong><span class="koboSpan" id="kobo.1099.1"> option is used to skip building the application. </span><span class="koboSpan" id="kobo.1099.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">--no-restore</span></strong><span class="koboSpan" id="kobo.1101.1"> option is used to skip restoring the NuGet packages because we have already restored the packages and built the application in the previous tasks. </span><span class="koboSpan" id="kobo.1101.2">The other options are used to specify the logger and collect </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">code coverage.</span></span></p></li> <li><span class="koboSpan" id="kobo.1103.1">Click</span><a id="_idIndexMarker1615"/><span class="koboSpan" id="kobo.1104.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.1105.1">Save and run</span></strong><span class="koboSpan" id="kobo.1106.1"> button to commit the changes and run the pipeline. </span><span class="koboSpan" id="kobo.1106.2">You will see the pipeline is running. </span><span class="koboSpan" id="kobo.1106.3">After a while, the pipeline will </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">be completed:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer120">
<span class="koboSpan" id="kobo.1108.1"><img alt="Figure 14.11 – The pipeline is successful" src="image/B18971_14_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1109.1">Figure 14.11 – The pipeline is successful</span></p>
<ol>
<li value="14"><span class="koboSpan" id="kobo.1110.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1111.1">Tests</span></strong><span class="koboSpan" id="kobo.1112.1"> tab and you will then see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">test results:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer121">
<span class="koboSpan" id="kobo.1114.1"><img alt="Figure 14.12 – The test results" src="image/B18971_14_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1115.1">Figure 14.12 – The test results</span></p>
<ol>
<li value="15"><span class="koboSpan" id="kobo.1116.1">You</span><a id="_idIndexMarker1616"/><span class="koboSpan" id="kobo.1117.1"> can also check the code coverage </span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">as follows:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer122">
<span class="koboSpan" id="kobo.1119.1"><img alt="Figure 14.13 – The code coverage" src="image/B18971_14_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1120.1">Figure 14.13 – The code coverage</span></p>
<ol>
<li value="16"><span class="koboSpan" id="kobo.1121.1">We just manually triggered the first run of the pipeline. </span><span class="koboSpan" id="kobo.1121.2">Next, let us create a pull request and see how the pipeline </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">is triggered.</span></span></li>
<li><span class="koboSpan" id="kobo.1123.1">Create a </span><a id="_idIndexMarker1617"/><span class="koboSpan" id="kobo.1124.1">new branch and make some changes to the source code. </span><span class="koboSpan" id="kobo.1124.2">For example, we can return 6 items instead of 5 items </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">WeatherForecastController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1128.1">
return Enumerable.Range(1, 6).Select(index =&gt; new WeatherForecast// Omitted for brevity</span></pre></li> <li><span class="koboSpan" id="kobo.1129.1">Then, commit the changes and push the changes to the remote repository. </span><span class="koboSpan" id="kobo.1129.2">You will find the pipeline runs for the new branch as well. </span><span class="koboSpan" id="kobo.1129.3">That is because YAML pipelines are enabled by default for all branches. </span><span class="koboSpan" id="kobo.1129.4">You can disable this feature by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">trigger none</span></strong><span class="koboSpan" id="kobo.1131.1"> option. </span><span class="koboSpan" id="kobo.1131.2">Add the following line to the beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">YAML file:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1133.1">trigger: none</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1134.1">Then, this pipeline will not be triggered automatically for new branches but will be triggered by </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">pull requests.</span></span></p></li> <li><span class="koboSpan" id="kobo.1136.1">Next, create a new pull request in the GitHub repository. </span><span class="koboSpan" id="kobo.1136.2">You will see the pipeline is triggered automatically and </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">then fails:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer123">
<span class="koboSpan" id="kobo.1138.1"><img alt="Figure 14.14 – The pipeline is triggered by the pull request but fails" src="image/B18971_14_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1139.1">Figure 14.14 – The pipeline is triggered by the pull request but fails</span></p>
<ol>
<li value="20"><span class="koboSpan" id="kobo.1140.1">In this case, we cannot merge the pull request because the build pipeline failed. </span><span class="koboSpan" id="kobo.1140.2">You can check the logs to see what is wrong with the pipeline. </span><span class="koboSpan" id="kobo.1140.3">In this case, the pipeline</span><a id="_idIndexMarker1618"/><span class="koboSpan" id="kobo.1141.1"> failed because the unit </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">tests failed:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer124">
<span class="koboSpan" id="kobo.1143.1"><img alt="Figure 14.15 – The unit tests failed" src="image/B18971_14_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1144.1">Figure 14.15 – The unit tests failed</span></p>
<ol>
<li value="21"><span class="koboSpan" id="kobo.1145.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1146.1">Tests</span></strong><span class="koboSpan" id="kobo.1147.1"> tab and you will then see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">test results:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer125">
<span class="koboSpan" id="kobo.1149.1"><img alt="Figure 14.16 – The unit tests results" src="image/B18971_14_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1150.1">Figure 14.16 – The unit tests results</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.1151.1">The details of the failed test case can help us to identify the problem. </span><span class="koboSpan" id="kobo.1151.2">Next, you can fix the error and push the changes to the remote repository. </span><span class="koboSpan" id="kobo.1151.3">Then, the pipeline will be triggered again. </span><span class="koboSpan" id="kobo.1151.4">If the pipeline is successful, you can merge the </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">pull request.</span></span></p>
<p><span class="koboSpan" id="kobo.1153.1">The pull request build pipeline is used to ensure that code changes do not break the application. </span><span class="koboSpan" id="kobo.1153.2">It is important to run the tests before merging the pull request. </span><span class="koboSpan" id="kobo.1153.3">Next, let us cre</span><a id="_idTextAnchor617"/><span class="koboSpan" id="kobo.1154.1">ate a CI build pipeline to build the Docker image and publish it </span><span class="No-Break"><span class="koboSpan" id="kobo.1155.1">to ACR.</span></span></p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor618"/><span class="koboSpan" id="kobo.1156.1">Publishing the Docker image to ACR</span></h2>
<p><span class="koboSpan" id="kobo.1157.1">In the </span><a id="_idIndexMarker1619"/><span class="koboSpan" id="kobo.1158.1">previous section, we created a pull request build pipeline to validate code changes in pull requests. </span><span class="koboSpan" id="kobo.1158.2">The pipeline will be triggered when a pull request is created or updated. </span><span class="koboSpan" id="kobo.1158.3">Once the pull request is merged to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">main</span></strong><span class="koboSpan" id="kobo.1160.1"> branch, we can automatically build the Docker image and publish it to ACR. </span><span class="koboSpan" id="kobo.1160.2">To do that, we will create a CI build pipeline following </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">these steps</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1162.1">Create a new pipeline following the same steps as we did in the previous section. </span><span class="koboSpan" id="kobo.1162.2">In the configure step, we can choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1163.1">Starter pipeline</span></strong><span class="koboSpan" id="kobo.1164.1"> template to start from scratch or choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1165.1">Existing Azure Pipelines YAML file</span></strong><span class="koboSpan" id="kobo.1166.1"> template and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">pr-build-pipeline.yml</span></strong><span class="koboSpan" id="kobo.1168.1"> file we created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">previous section:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer126">
<span class="koboSpan" id="kobo.1170.1"><img alt="Figure 14.17 – Choosing an existing YAML file to start with" src="image/B18971_14_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1171.1">Figure 14.17 – Choosing an existing YAML file to start with</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1172.1">A better way is to choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1173.1">Docker - Build and push an image to Azure Container Registry</span></strong><span class="koboSpan" id="kobo.1174.1"> template, which is exactly what we need. </span><span class="koboSpan" id="kobo.1174.2">You will be prompted to configure your Azure subscription, ACR, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1175.1">so on:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer127">
<span class="koboSpan" id="kobo.1176.1"><img alt="Figure 14.18 – Configuring ACR, Dockerfile, and image name" src="image/B18971_14_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1177.1">Figure 14.18 – Configuring ACR, Dockerfile, and image name</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1178.1">Azure Pipelines </span><a id="_idIndexMarker1620"/><span class="koboSpan" id="kobo.1179.1">will automatically detect the Dockerfile and generate a pipeline for you. </span><span class="koboSpan" id="kobo.1179.2">The default pipeline may look </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1181.1">
trigger:- mainresources:- repo: selfvariables:  # Container registry service connection established during pipeline creation  dockerRegistryServiceConnection: 'deb345e0-7bdd-4420-ba08-538785d525cd'  imageRepository: 'myazurepipelinesdemo'  containerRegistry: 'devopscrlab.azurecr.io'  dockerfilePath: '$(Build.SourcesDirectory)/src/MyBasicWebApiDemo/Dockerfile'  tag: '$(Build.BuildId)'  # Agent VM image name  vmImageName: 'ubuntu-latest'stages:- stage: Build  displayName: Build and push stage  jobs:  - job: Build    displayName: Build    pool:      vmImage: $(vmImageName)    steps:    - task: Docker@2      displayName: Build and push an image to container registry      inputs:        command: buildAndPush        repository: $(imageRepository)        dockerfile: $(dockerfilePath)        containerRegistry: $(dockerRegistryServiceConnection)        tags: |          $(tag)          latest</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1182.1">Azure Pipelines </span><a id="_idIndexMarker1621"/><span class="koboSpan" id="kobo.1183.1">has recognized the path of the Dockerfile in the preceding pipeline. </span><span class="koboSpan" id="kobo.1183.2">Additionally, several variables must be configured, such as the image name and container registry. </span><span class="koboSpan" id="kobo.1183.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">tag</span></strong><span class="koboSpan" id="kobo.1185.1"> variable is used to tag the image with the build ID. </span><span class="koboSpan" id="kobo.1185.2">Note that we added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">latest</span></strong><span class="koboSpan" id="kobo.1187.1"> tag to the image. </span><span class="koboSpan" id="kobo.1187.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">latest</span></strong><span class="koboSpan" id="kobo.1189.1"> tag is used to indicate the latest version of </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">the image.</span></span></p></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.1191.1">Azure Pipelines predefined variables</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1192.1">Azure Pipelines provides many predefined variables that can be used in a pipeline. </span><span class="koboSpan" id="kobo.1192.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">$(Build.SourcesDirectory)</span></strong><span class="koboSpan" id="kobo.1194.1"> variable is used to obtain the local path on the agent where the source code files have been downloaded. </span><span class="koboSpan" id="kobo.1194.2">You can find all the predefined variables </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">here: </span></span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&amp;tabs=yaml"><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&amp;tabs=yaml</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1197.1">.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.1198.1">The difference from a pull request build pipeline is that we have </span><strong class="bold"><span class="koboSpan" id="kobo.1199.1">stages</span></strong><span class="koboSpan" id="kobo.1200.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1201.1">jobs</span></strong><span class="koboSpan" id="kobo.1202.1"> in the pipeline. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1203.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1204.1">.19</span></em><span class="koboSpan" id="kobo.1205.1"> shows the structure of </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">a pipeline:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<span class="koboSpan" id="kobo.1207.1"><img alt="Figure 14.19 – The structure of a pipeline" src="image/B18971_14_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1208.1">Figure 14.19 – The structure of a pipeline</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.1209.1">The</span><a id="_idIndexMarker1622"/><span class="koboSpan" id="kobo.1210.1"> components in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1211.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1212.1">.19</span></em><span class="koboSpan" id="kobo.1213.1"> are explained </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1215.1">A trigger is used to specify when the pipeline should run. </span><span class="koboSpan" id="kobo.1215.2">It can be a schedule, a pull request, a commit to a specific branch, or a </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">manual trigger.</span></span></li>
<li><span class="koboSpan" id="kobo.1217.1">A pipeline contains one or more stages. </span><span class="koboSpan" id="kobo.1217.2">A stage is used to organize jobs. </span><span class="koboSpan" id="kobo.1217.3">In the pull request build pipeline, the stage is omitted. </span><span class="koboSpan" id="kobo.1217.4">You can have multiple stages in one pipeline for different purposes. </span><span class="koboSpan" id="kobo.1217.5">For example, you can have a build stage, a test stage, and a deploy stage. </span><span class="koboSpan" id="kobo.1217.6">The stage can be also used to set boundaries for security </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">and approvals.</span></span></li>
<li><span class="koboSpan" id="kobo.1219.1">Each stage contains one or more jobs. </span><span class="koboSpan" id="kobo.1219.2">A job is a container of steps. </span><span class="koboSpan" id="kobo.1219.3">A job can run on one agent or without an agent. </span><span class="koboSpan" id="kobo.1219.4">For example, you can have a job that runs on a Windows agent, and another job that runs on a </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">Linux agent.</span></span></li>
<li><span class="koboSpan" id="kobo.1221.1">Each job contains one or more steps. </span><span class="koboSpan" id="kobo.1221.2">A step is the smallest building block in a pipeline. </span><span class="koboSpan" id="kobo.1221.3">A step is normally a task or a script. </span><span class="koboSpan" id="kobo.1221.4">Azure Pipelines provides many built-in tasks, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">Docker@2</span></strong><span class="koboSpan" id="kobo.1223.1"> task we are using in this pipeline. </span><span class="koboSpan" id="kobo.1223.2">A built-in task is a predefined packaged script that performs an action. </span><span class="koboSpan" id="kobo.1223.3">You can also write your own custom tasks. </span><span class="koboSpan" id="kobo.1223.4">A task can be a command-line tool, a script, or a compiled program. </span><span class="koboSpan" id="kobo.1223.5">You can find all built-in tasks </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">here: </span></span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/?view=azure-pipelines"><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/?view=azure-pipelines</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">.</span></span></li>
</ul>
<p class="list-inset"><span class="koboSpan" id="kobo.1227.1">In the preceding pipeline, we have one stage, one job, and one step. </span><span class="koboSpan" id="kobo.1227.2">The step is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">Docker@2</span></strong><span class="koboSpan" id="kobo.1229.1"> task. </span><span class="koboSpan" id="kobo.1229.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">Docker@2</span></strong><span class="koboSpan" id="kobo.1231.1"> task is used to build and push a Docker image to a container registry. </span><span class="koboSpan" id="kobo.1231.2">Using this task simplifies the process of building and pushing a Docker image so that we do not need to write </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">docker build</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1233.1">commands manually.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1234.1">Rename</span><a id="_idIndexMarker1623"/><span class="koboSpan" id="kobo.1235.1"> this pipeline to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">docker-build-pipeline</span></strong><span class="koboSpan" id="kobo.1237.1">. </span><span class="koboSpan" id="kobo.1237.2">Similarly to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">pr-build-pipeline</span></strong><span class="koboSpan" id="kobo.1239.1">, we need to exclude the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">docker-build-pipeline</span></strong><span class="koboSpan" id="kobo.1241.1"> pipeline from running for new branches and pull requests. </span><span class="koboSpan" id="kobo.1241.2">Add the following line to the beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">YAML file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1243.1">
pr: none</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1244.1">So, when we create a new branch or a new pull request, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">docker-build-pipeline</span></strong><span class="koboSpan" id="kobo.1246.1"> will not be triggered automatically. </span><span class="koboSpan" id="kobo.1246.2">We will trigger the pipeline manually or by merging a </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">pull request.</span></span></p></li> <li><span class="koboSpan" id="kobo.1248.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1249.1">Save</span></strong><span class="koboSpan" id="kobo.1250.1"> button to commit the changes. </span><span class="koboSpan" id="kobo.1250.2">Next, we need to test if the pipeline can be triggered by merging a pull request. </span><span class="koboSpan" id="kobo.1250.3">Create a new branch and make some changes to the source code. </span><span class="koboSpan" id="kobo.1250.4">Then, create a pull request. </span><span class="koboSpan" id="kobo.1250.5">When you merge the pull request, you will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">docker-build-pipeline</span></strong><span class="koboSpan" id="kobo.1252.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">triggered automatically.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.1254.1">If everything is fine, you will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">docker-build-pipeline</span></strong><span class="koboSpan" id="kobo.1256.1"> pipeline is successful and the Docker image is published </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">to ACR:</span></span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer129">
<span class="koboSpan" id="kobo.1258.1"><img alt="Figure 14.20 – The Docker image is published to ACR" src="image/B18971_14_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1259.1">Figure 14.20 – The Docker image is published to ACR</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.1260.1">A CI pipeline</span><a id="_idIndexMarker1624"/><span class="koboSpan" id="kobo.1261.1"> is a good practice to ensure that code changes can be built successfully without breaking the application. </span><span class="koboSpan" id="kobo.1261.2">However, some changes may not need running tests or rebuilding the Docker image. </span><span class="koboSpan" id="kobo.1261.3">For example, if you only change the documentation, (for example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">README</span></strong><span class="koboSpan" id="kobo.1263.1"> file), you do not need to run the tests or rebuild the Docker image. </span><span class="koboSpan" id="kobo.1263.2">In this case, you have a </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">few options:</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1265.1">You can exclude some files from the pipeline. </span><span class="koboSpan" id="kobo.1265.2">For example, you can exclude the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">README.md</span></strong><span class="koboSpan" id="kobo.1267.1"> file from the pipeline. </span><span class="koboSpan" id="kobo.1267.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">paths</span></strong><span class="koboSpan" id="kobo.1269.1"> option to specify paths to include or exclude, </span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1271.1">
trigger:  branches:    include:    - main  paths:    exclude:    - README.md    - .gitignore    - .dockerignore    - *.yml</span></pre></li> <li><span class="koboSpan" id="kobo.1272.1">You can skip CI pipelines for some commits. </span><span class="koboSpan" id="kobo.1272.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">[skip ci]</span></strong><span class="koboSpan" id="kobo.1274.1"> in the commit message to skip CI pipelines. </span><span class="koboSpan" id="kobo.1274.2">For example, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">[skip ci] update README</span></strong><span class="koboSpan" id="kobo.1276.1"> in the commit message to skip CI pipelines for this commit. </span><span class="koboSpan" id="kobo.1276.2">Some variations include </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">[ci skip]</span></strong><span class="koboSpan" id="kobo.1278.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">[skip azurepipelines]</span></strong><span class="koboSpan" id="kobo.1280.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">[skip azpipelines]</span></strong><span class="koboSpan" id="kobo.1282.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">[skip azp]</span></strong><span class="koboSpan" id="kobo.1284.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">so on.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1286.1">You may </span><a id="_idIndexMarker1625"/><span class="koboSpan" id="kobo.1287.1">encounter some errors when creating pipelines. </span><span class="koboSpan" id="kobo.1287.2">Here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">troubleshooting tips:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1289.1">Check the logs carefully. </span><span class="koboSpan" id="kobo.1289.2">The logs can help you to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">the problem.</span></span></li>
<li><span class="koboSpan" id="kobo.1291.1">Check the variables. </span><span class="koboSpan" id="kobo.1291.2">Make sure the variables </span><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">are correct.</span></span></li>
<li><span class="koboSpan" id="kobo.1293.1">Check the permissions. </span><span class="koboSpan" id="kobo.1293.2">Make sure the service connection has the </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">correct permissions.</span></span></li>
<li><span class="koboSpan" id="kobo.1295.1">Check the YAML syntax. </span><span class="koboSpan" id="kobo.1295.2">Make sure the YAML file is valid. </span><span class="koboSpan" id="kobo.1295.3">YAML files use indentation to indicate the structure. </span><span class="koboSpan" id="kobo.1295.4">Make sure the indentation </span><span class="No-Break"><span class="koboSpan" id="kobo.1296.1">is correct.</span></span></li>
<li><span class="koboSpan" id="kobo.1297.1">Check the pipeline structure. </span><span class="koboSpan" id="kobo.1297.2">Make sure the pipeline structure is correct. </span><span class="koboSpan" id="kobo.1297.3">For example, make sure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">steps</span></strong><span class="koboSpan" id="kobo.1299.1"> section is under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">jobs</span></strong><span class="koboSpan" id="kobo.1301.1"> section and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">jobs</span></strong><span class="koboSpan" id="kobo.1303.1"> section is under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">stages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1305.1"> section.</span></span></li>
<li><span class="koboSpan" id="kobo.1306.1">Check the pipeline triggers. </span><span class="koboSpan" id="kobo.1306.2">Make sure the pipeline is triggered by the correct event. </span><span class="koboSpan" id="kobo.1306.3">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">branches</span></strong><span class="koboSpan" id="kobo.1308.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">paths</span></strong><span class="koboSpan" id="kobo.1310.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">include</span></strong><span class="koboSpan" id="kobo.1312.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">exclude</span></strong><span class="koboSpan" id="kobo.1314.1"> to specify branches and paths to trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">the pipeline.</span></span></li>
<li><span class="koboSpan" id="kobo.1316.1">Note that if you edit the pipeline YAML file in the online editor, you will commit the changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">main</span></strong><span class="koboSpan" id="kobo.1318.1"> branch directly. </span><span class="koboSpan" id="kobo.1318.2">Your local </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">feature</span></strong><span class="koboSpan" id="kobo.1320.1"> branch will not be updated automatically. </span><span class="koboSpan" id="kobo.1320.2">When you push a change to your feature branch, whether the pipeline should be triggered depends on the settings in the YAML file in your feature branch, not the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1321.1">main</span></strong><span class="koboSpan" id="kobo.1322.1"> branch. </span><span class="koboSpan" id="kobo.1322.2">So, make sure your feature branch keeps synchronized with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1324.1"> branch.</span></span></li>
<li><span class="koboSpan" id="kobo.1325.1">If you use VS to create the Dockerfile, double-check the paths in the Dockerfile. </span><span class="koboSpan" id="kobo.1325.2">Sometimes, VS cannot detect the correct paths if you use a custom </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">solution structure.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1327.1">We have now </span><a id="_idIndexMarker1626"/><span class="koboSpan" id="kobo.1328.1">pushed the Docker image to ACR. </span><span class="koboSpan" id="kobo.1328.2">Next, let's create a</span><a id="_idTextAnchor619"/><span class="koboSpan" id="kobo.1329.1"> release pipeline to deploy the application to Azure Web App </span><span class="No-Break"><span class="koboSpan" id="kobo.1330.1">for Containers.</span></span></p>
<h2 id="_idParaDest-324"><a id="_idTextAnchor620"/><span class="koboSpan" id="kobo.1331.1">Deploying the application to Azure Web App for Containers</span></h2>
<p><span class="koboSpan" id="kobo.1332.1">In the</span><a id="_idIndexMarker1627"/><span class="koboSpan" id="kobo.1333.1"> previous section, we created a CI build pipeline to build the Docker image and publish it to ACR. </span><span class="koboSpan" id="kobo.1333.2">In this section, we will create a release pipeline to pull the Docker image from ACR and deploy it to Azure Web App </span><span class="No-Break"><span class="koboSpan" id="kobo.1334.1">for Containers.</span></span></p>
<p><span class="koboSpan" id="kobo.1335.1">Follow the steps in the previous section to create a new pipeline. </span><span class="koboSpan" id="kobo.1335.2">When we configure the pipeline, choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1336.1">Starter pipeline</span></strong><span class="koboSpan" id="kobo.1337.1"> template because we will start from scratch. </span><span class="koboSpan" id="kobo.1337.2">The default starter pipeline has two scripts as examples. </span><span class="koboSpan" id="kobo.1337.3">Delete the scripts, and it should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1338.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1339.1">
trigger: nonepr: none
pool:
  vmImage: ubuntu-latest</span></pre>
<p><span class="koboSpan" id="kobo.1340.1">We can disable the triggers for the pipeline because we will manually run the pipeline when we need to deploy the application. </span><span class="koboSpan" id="kobo.1340.2">Rename the pipeline </span><span class="No-Break"><span class="koboSpan" id="kobo.1341.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">release-pipeline</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1344.1">Next, add some variables to </span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1">the pipeline:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1346.1">
variables:  containerRegistry: 'devopscrlab.azurecr.io'
  imageRepository: 'myazurepipelinesdemo'
  tag: 'latest'</span></pre>
<p><span class="koboSpan" id="kobo.1347.1">Next, we need to configure the username and password to authenticate the pipeline to pull the Docker image from ACR. </span><span class="koboSpan" id="kobo.1347.2">You can find the username and password of your ACR instance in the Azure portal. </span><span class="koboSpan" id="kobo.1347.3">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1348.1">Access keys</span></strong><span class="koboSpan" id="kobo.1349.1"> button on the left side, and you will then see the username </span><span class="No-Break"><span class="koboSpan" id="kobo.1350.1">and password.</span></span></p>
<p><span class="koboSpan" id="kobo.1351.1">As the</span><a id="_idIndexMarker1628"/><span class="koboSpan" id="kobo.1352.1"> password is a secret, we cannot use it in the YAML file directly, otherwise the password will be exposed in the GitHub repository. </span><span class="koboSpan" id="kobo.1352.2">Azure Pipelines provides a way to store secrets in the pipeline. </span><span class="koboSpan" id="kobo.1352.3">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1353.1">Variables</span></strong><span class="koboSpan" id="kobo.1354.1"> button in the top-right corner, then click the </span><strong class="bold"><span class="koboSpan" id="kobo.1355.1">New variable</span></strong><span class="koboSpan" id="kobo.1356.1"> button to add a </span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1">new variable:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.1358.1"><img alt="Figure 14.21 – Adding a new variable to store the password" src="image/B18971_14_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1359.1">Figure 14.21 – Adding a new variable to store the password</span></p>
<p><span class="koboSpan" id="kobo.1360.1">Check the </span><strong class="bold"><span class="koboSpan" id="kobo.1361.1">Keep this value secret</span></strong><span class="koboSpan" id="kobo.1362.1"> checkbox to make the variable secret. </span><span class="koboSpan" id="kobo.1362.2">Then, click the </span><strong class="bold"><span class="koboSpan" id="kobo.1363.1">Add</span></strong><span class="koboSpan" id="kobo.1364.1"> button to add the variable. </span><span class="koboSpan" id="kobo.1364.2">So, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">$(acrpassword)</span></strong><span class="koboSpan" id="kobo.1366.1"> variable to refer to </span><span class="No-Break"><span class="koboSpan" id="kobo.1367.1">the password.</span></span></p>
<p><span class="koboSpan" id="kobo.1368.1">Next, add a </span><a id="_idIndexMarker1629"/><span class="koboSpan" id="kobo.1369.1">task to set up the Azure App Service settings. </span><span class="koboSpan" id="kobo.1369.2">Choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1370.1">Azure App Service Settings</span></strong><span class="koboSpan" id="kobo.1371.1"> task from the task assistant. </span><span class="koboSpan" id="kobo.1371.2">We need to add the credentials to authenticate the Azure Web App to pull the Docker image from ACR. </span><span class="koboSpan" id="kobo.1371.3">Azure Pipelines will prompt you to configure the task. </span><span class="koboSpan" id="kobo.1371.4">Note that the </span><strong class="bold"><span class="koboSpan" id="kobo.1372.1">App settings</span></strong><span class="koboSpan" id="kobo.1373.1"> field is a JSON string. </span><span class="koboSpan" id="kobo.1373.2">The tasks should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1374.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1375.1">
- task: AzureAppServiceSettings@1  displayName: Update settings
  inputs:
    azureSubscription: '&lt;Your Azure subscription&gt;(&lt;guid&gt;)'
    appName: 'azure-pipeline-demo'
    resourceGroupName: 'devops-lab'
    appSettings: |
      [
        {
          "name": "DOCKER_REGISTRY_SERVER_URL",
          "value": "$(containerRegistry)",
          "slotSetting": false
        },
        {
          "name": "DOCKER_REGISTRY_SERVER_USERNAME",
          "value": "devopscrlab",
          "slotSetting": false
        },
        {
          "name": "DOCKER_REGISTRY_SERVER_PASSWORD",
          "value": "$(acrpassword)",
          "slotSetting": false
        }
      ]</span></pre>
<p><span class="koboSpan" id="kobo.1376.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">appSettings</span></strong><span class="koboSpan" id="kobo.1378.1"> field, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">$(acrpassword)</span></strong><span class="koboSpan" id="kobo.1380.1"> variable to refer to the password we </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">created earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.1382.1">Next, click</span><a id="_idIndexMarker1630"/><span class="koboSpan" id="kobo.1383.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.1384.1">Show assistant</span></strong><span class="koboSpan" id="kobo.1385.1"> button in the top-right corner to open the assistant. </span><span class="koboSpan" id="kobo.1385.2">The assistant helps us to use the built-in tasks easily. </span><span class="koboSpan" id="kobo.1385.3">Choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1386.1">Azure Web App for Containers</span></strong><span class="koboSpan" id="kobo.1387.1"> task that is used to deploy the Docker image from ACR to Azure Web App for Containers. </span><span class="koboSpan" id="kobo.1387.2">Azure Pipelines will prompt you to configure the task. </span><span class="koboSpan" id="kobo.1387.3">Configure the task </span><span class="No-Break"><span class="koboSpan" id="kobo.1388.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1389.1">
- task: AzureWebAppContainer@1  displayName: Deploy to Azure Web App for Container
  inputs:
    azureSubscription: '&lt;Your Azure subscription&gt;'
    appName: 'azure-pipeline-demo'
    containers: '$(containerRegistry)/$(imageRepository):$(tag)'
    containerCommand: 'dotnet MyBasicWebApiDemo.dll'</span></pre>
<p><span class="koboSpan" id="kobo.1390.1">Alternatively, you can use the </span><strong class="bold"><span class="koboSpan" id="kobo.1391.1">Azure App Service Deploy</span></strong><span class="koboSpan" id="kobo.1392.1"> task from the assistant. </span><span class="koboSpan" id="kobo.1392.2">This task is used to deploy the application to Azure Web App that supports either native deployment or container deployment. </span><span class="koboSpan" id="kobo.1392.3">You need to configure the Azure subscription, App Service type, and so on. </span><span class="koboSpan" id="kobo.1392.4">When you choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1393.1">Web App for Containers (Linux)</span></strong><span class="koboSpan" id="kobo.1394.1"> option for </span><strong class="bold"><span class="koboSpan" id="kobo.1395.1">App Service type</span></strong><span class="koboSpan" id="kobo.1396.1">, you will be prompted to configure the ACR name, Docker image name, tag, and so on. </span><span class="koboSpan" id="kobo.1396.2">The task should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1398.1">
- task: AzureRmWebAppDeployment@4  displayName: Deploy to Web App for Container
  inputs:
    ConnectionType: 'AzureRM'
    azureSubscription: '&lt;Your Azure subscription&gt;'
    appType: 'webAppContainer'
    WebAppName: 'azure-pipeline-demo'
    DockerNamespace: 'devopscrlab.azurecr.io'
    DockerRepository: 'myazurepipelinesdemo'
    DockerImageTag: 'latest'
    StartupCommand: 'dotnet MyBasicWebApiDemo.dll'</span></pre>
<p><span class="koboSpan" id="kobo.1399.1">Note that we also need to specify a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">StartupCommand</span></strong><span class="koboSpan" id="kobo.1401.1"> value. </span><span class="koboSpan" id="kobo.1401.2">In this case, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">dotnet MyBasicWebApiDemo.dll</span></strong><span class="koboSpan" id="kobo.1403.1"> to start </span><span class="No-Break"><span class="koboSpan" id="kobo.1404.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.1405.1">Now, we can manually trigger the pipeline to deploy the application. </span><span class="koboSpan" id="kobo.1405.2">If everything is fine, you will see the deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">is successful.</span></span></p>
<p><span class="koboSpan" id="kobo.1407.1">Check the </span><a id="_idIndexMarker1631"/><span class="koboSpan" id="kobo.1408.1">configuration of the Azure Web App. </span><span class="koboSpan" id="kobo.1408.2">You will see the </span><strong class="bold"><span class="koboSpan" id="kobo.1409.1">Application settings</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1410.1">are updated:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.1411.1"><img alt="Figure 14.22 – The application settings are updated" src="image/B18971_14_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1412.1">Figure 14.22 – The application settings are updated</span></p>
<p><span class="koboSpan" id="kobo.1413.1">Navigate to the Azure portal and check the details of the Azure Web App we created earlier. </span><span class="koboSpan" id="kobo.1413.2">You </span><a id="_idIndexMarker1632"/><span class="koboSpan" id="kobo.1414.1">can find the URL of the Azure Web App, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">azure-pipeline-demo.azurewebsites.net</span></strong><span class="koboSpan" id="kobo.1416.1">. </span><span class="koboSpan" id="kobo.1416.2">Open the URL in the browser and check the controller endpoint, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">https://azure-pipeline-demo.azurewebsites.net/WeatherForecast</span></strong><span class="koboSpan" id="kobo.1418.1">. </span><span class="koboSpan" id="kobo.1418.2">You will see the response from </span><span class="No-Break"><span class="koboSpan" id="kobo.1419.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.1420.1">So far, we have created </span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1">three pipelines:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1422.1">Pull request build pipeline</span></strong><span class="koboSpan" id="kobo.1423.1">: This</span><a id="_idIndexMarker1633"/><span class="koboSpan" id="kobo.1424.1"> pipeline is to validate the code changes in pull requests. </span><span class="koboSpan" id="kobo.1424.2">It will be triggered when a pull request is created or updated. </span><span class="koboSpan" id="kobo.1424.3">If the build fails or the tests fail, the pull request cannot be merged. </span><span class="koboSpan" id="kobo.1424.4">This pipeline does not produce </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">any artifacts.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1426.1">Docker build pipeline</span></strong><span class="koboSpan" id="kobo.1427.1">: This</span><a id="_idIndexMarker1634"/><span class="koboSpan" id="kobo.1428.1"> pipeline is to build the Docker image and publish it to ACR. </span><span class="koboSpan" id="kobo.1428.2">It will be triggered when a pull request is merged into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">main</span></strong><span class="koboSpan" id="kobo.1430.1"> branch. </span><span class="koboSpan" id="kobo.1430.2">This pipeline produces a Docker image as </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">the artifact.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1432.1">Release pipeline</span></strong><span class="koboSpan" id="kobo.1433.1">: This </span><a id="_idIndexMarker1635"/><span class="koboSpan" id="kobo.1434.1">pipeline is to pull the Docker image from ACR and deploy it to Azure Web App for Containers. </span><span class="koboSpan" id="kobo.1434.2">This pipeline can be triggered manually or automatically when a </span><a id="_idTextAnchor621"/><span class="koboSpan" id="kobo.1435.1">new Docker image is published to ACR. </span><span class="koboSpan" id="kobo.1435.2">This pipeline does not produce </span><span class="No-Break"><span class="koboSpan" id="kobo.1436.1">any artifacts.</span></span></li>
</ul>
<h2 id="_idParaDest-325"><a id="_idTextAnchor622"/><span class="koboSpan" id="kobo.1437.1">Configuring settings and secrets</span></h2>
<p><span class="koboSpan" id="kobo.1438.1">In the</span><a id="_idIndexMarker1636"/><span class="koboSpan" id="kobo.1439.1"> previous section, we created a release pipeline to deploy the application to Azure Web App for Containers. </span><span class="koboSpan" id="kobo.1439.2">We may also need to deploy the application to other environments, such as staging. </span><span class="koboSpan" id="kobo.1439.3">These different environments may have different settings, such as database connection strings, API keys, and so on. </span><span class="koboSpan" id="kobo.1439.4">So, how can we configure the settings for </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">different environments?</span></span></p>
<p><span class="koboSpan" id="kobo.1441.1">There are various ways to achieve this. </span><span class="koboSpan" id="kobo.1441.2">A simple way is to configure variables for different environments. </span><span class="koboSpan" id="kobo.1441.3">You can define variables in each pipeline directly. </span><span class="koboSpan" id="kobo.1441.4">Azure Pipelines also provides a </span><strong class="bold"><span class="koboSpan" id="kobo.1442.1">Library</span></strong><span class="koboSpan" id="kobo.1443.1"> to manage variables. </span><span class="koboSpan" id="kobo.1443.2">You can group variables into a variable group and then use the variable group in </span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1">the pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.1445.1">Storing </span><a id="_idIndexMarker1637"/><span class="koboSpan" id="kobo.1446.1">confidential information securely is essential to any organization. </span><span class="koboSpan" id="kobo.1446.2">To ensure the safety of your secrets, you can use a variety of key vaults, such as Azure Key Vault and AWS Secrets Manager. </span><span class="koboSpan" id="kobo.1446.3">Azure Pipelines offers a Key Vault task to fetch secrets from the vault. </span><span class="koboSpan" id="kobo.1446.4">With the Azure Key Vault task, you can easily retrieve secrets from the vault and use them in your pipeline. </span><span class="koboSpan" id="kobo.1446.5">To learn more about the Key Vault task, please </span><span class="No-Break"><span class="koboSpan" id="kobo.1447.1">visit </span></span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/release/key-vault-in-own-project"><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">https://learn.microsoft.com/en-us/azure/devops/pipelines/release/key-vault-in-own-project</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1449.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1450.1">This chapter is not intended to cover all the details of Azure Pipelines, but you should now have a basic understanding of Azure Pipelines. </span><span class="koboSpan" id="kobo.1450.2">Using CI/CD pipelines can help you to automate the build, test, and deployment process, which eliminates manual work and reduces the risk of human errors. </span><span class="koboSpan" id="kobo.1450.3">It is more and more important to use CI/CD pipelines in modern software development. </span><span class="koboSpan" id="kobo.1450.4">Every developer should learn how to </span><span class="No-Break"><span class="koboSpan" id="kobo.1451.1">use them.</span></span></p>
<p><span class="koboSpan" id="kobo.1452.1">In t</span><a id="_idTextAnchor623"/><span class="koboSpan" id="kobo.1453.1">he next section, we will explore GitHub Actions, which is another popular </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">CI/CD tool.</span></span></p>
<h1 id="_idParaDest-326"><a id="_idTextAnchor624"/><span class="koboSpan" id="kobo.1455.1">GitHub Actions</span></h1>
<p><span class="koboSpan" id="kobo.1456.1">In the</span><a id="_idIndexMarker1638"/><span class="koboSpan" id="kobo.1457.1"> previous section, we explored Azure Pipelines. </span><span class="koboSpan" id="kobo.1457.2">Next, let us explore GitHub Actions. </span><span class="koboSpan" id="kobo.1457.3">GitHub Actions is a CI/CD tool provided by GitHub. </span><span class="koboSpan" id="kobo.1457.4">It is quite similar to Azure Pipelines. </span><span class="koboSpan" id="kobo.1457.5">In this section, we will </span><a id="_idTextAnchor625"/><span class="koboSpan" id="kobo.1458.1">use GitHub Actions to build and test the application and push the Docker image </span><span class="No-Break"><span class="koboSpan" id="kobo.1459.1">to ACR.</span></span></p>
<h2 id="_idParaDest-327"><a id="_idTextAnchor626"/><span class="koboSpan" id="kobo.1460.1">Preparing the project</span></h2>
<p><span class="koboSpan" id="kobo.1461.1">To demonstrate </span><a id="_idIndexMarker1639"/><span class="koboSpan" id="kobo.1462.1">how to use GitHub Actions, we will use the same source code as we used in the previous section. </span><span class="koboSpan" id="kobo.1462.2">You can download the source code from the GitHub repository here: </span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/MyBasicWebApiDemo"><span class="koboSpan" id="kobo.1463.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/MyBasicWebApiDemo</span></a><span class="koboSpan" id="kobo.1464.1">. </span><span class="koboSpan" id="kobo.1464.2">Create a new GitHub repository and push the source code to the repository. </span><span class="koboSpan" id="kobo.1464.3">The directory structure of the source code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1465.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1466.1">
MyGitHubActionsDemo    ├── src
    │   └──MyBasicWebApiDemo
    ├── tests
    │   ├──MyBasicWebApiDemo.UnitTests
    │   └──MyBasicWebApiDemo.IntegrationTests
    ├── MyBasicWebApiDemo.sln
    ├── README.md
    ├── LICENSE
    └── .gitignore</span></pre>
<p><span class="koboSpan" id="kobo.1467.1">If you</span><a id="_idIndexMarker1640"/><span class="koboSpan" id="kobo.1468.1"> use a different directory structure, please update the paths in the pipeline accordingly in the followi</span><a id="_idTextAnchor627"/><span class="koboSpan" id="kobo.1469.1">ng sections. </span><span class="koboSpan" id="kobo.1469.2">We will use this repository to demonstrate how to configure </span><span class="No-Break"><span class="koboSpan" id="kobo.1470.1">GitHub Actions.</span></span></p>
<h2 id="_idParaDest-328"><a id="_idTextAnchor628"/><span class="koboSpan" id="kobo.1471.1">Creating GitHub Actions</span></h2>
<p><span class="koboSpan" id="kobo.1472.1">We will </span><a id="_idIndexMarker1641"/><span class="koboSpan" id="kobo.1473.1">reuse the Azure resources we created in the previous section. </span><span class="koboSpan" id="kobo.1473.2">If you have not created the Azure resources, please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1474.1">Creating Azure resources</span></em><span class="koboSpan" id="kobo.1475.1"> section to create </span><span class="No-Break"><span class="koboSpan" id="kobo.1476.1">the resources.</span></span></p>
<p><span class="koboSpan" id="kobo.1477.1">On the GitHub repository page, click the </span><strong class="bold"><span class="koboSpan" id="kobo.1478.1">Actions</span></strong><span class="koboSpan" id="kobo.1479.1"> tab, and you can see many templates for different programming languages </span><span class="No-Break"><span class="koboSpan" id="kobo.1480.1">and frameworks:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.1481.1"><img alt="Figure 14.23 – Choosing a template for GitHub Actions" src="image/B18971_14_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1482.1">Figure 14.23 – Choosing a template for GitHub Actions</span></p>
<p><span class="koboSpan" id="kobo.1483.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1484.1">Continuous integration</span></strong><span class="koboSpan" id="kobo.1485.1"> section, you can find the </span><strong class="bold"><span class="koboSpan" id="kobo.1486.1">.NET</span></strong><span class="koboSpan" id="kobo.1487.1"> template. </span><span class="koboSpan" id="kobo.1487.2">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1488.1">Configure</span></strong><span class="koboSpan" id="kobo.1489.1"> button</span><a id="_idIndexMarker1642"/><span class="koboSpan" id="kobo.1490.1"> to create a new workflow. </span><span class="koboSpan" id="kobo.1490.2">The workflow is a YAML file that defines the CI/CD pipeline. </span><span class="koboSpan" id="kobo.1490.3">The default workflow may look </span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1492.1">
# This workflow will build a .NET project# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net
name: .NET
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
    - name: Test
      run: dotnet test --no-build --verbosity normal</span></pre>
<p><span class="koboSpan" id="kobo.1493.1">The syntax of the workflow is quite similar to Azure Pipelines. </span><span class="koboSpan" id="kobo.1493.2">The workflow is triggered when a pull request is created or updated, or when a commit is pushed to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1"> branch.</span></span></p>
<p><span class="koboSpan" id="kobo.1496.1">On the </span><a id="_idIndexMarker1643"/><span class="koboSpan" id="kobo.1497.1">right side, you can find the </span><strong class="bold"><span class="koboSpan" id="kobo.1498.1">Marketplace</span></strong><span class="koboSpan" id="kobo.1499.1"> panel. </span><span class="koboSpan" id="kobo.1499.2">The Marketplace is similar to the assistants of Azure DevOps Pipelines and provides many built-in actions that you can use in </span><span class="No-Break"><span class="koboSpan" id="kobo.1500.1">your workflow:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer133">
<span class="koboSpan" id="kobo.1501.1"><img alt="Figure 14.24 – The Marketplace panel" src="image/B18971_14_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1502.1">Figure 14.24 – The Marketplace panel</span></p>
<p><span class="koboSpan" id="kobo.1503.1">The sample application uses .NET 8. </span><span class="koboSpan" id="kobo.1503.2">So, we need to update </span><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">dotnet-version</span></strong><span class="koboSpan" id="kobo.1505.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">8.0.x</span></strong><span class="koboSpan" id="kobo.1507.1">. </span><span class="koboSpan" id="kobo.1507.2">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1508.1">Commit changes</span></strong><span class="koboSpan" id="kobo.1509.1"> button in the top-right corner. </span><span class="koboSpan" id="kobo.1509.2">You will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">dotnet.yml</span></strong><span class="koboSpan" id="kobo.1511.1"> file is </span><a id="_idIndexMarker1644"/><span class="koboSpan" id="kobo.1512.1">committed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">/.github/workflows</span></strong><span class="koboSpan" id="kobo.1514.1"> directory. </span><span class="koboSpan" id="kobo.1514.2">Make a change to the source code or create a new branch and push the changes to the remote repository. </span><span class="koboSpan" id="kobo.1514.3">For example, you can change the controller to return six items instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.1515.1">five items:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1516.1">
public IEnumerable&lt;WeatherForecast&gt; Get(){
    return Enumerable.Range(1, 6).Select(index =&gt; new WeatherForecast
    // Omitted for brevity</span></pre>
<p><span class="koboSpan" id="kobo.1517.1">You can also create a pull request. </span><span class="koboSpan" id="kobo.1517.2">You will see the workflow is triggered automatically and the test </span><span class="No-Break"><span class="koboSpan" id="kobo.1518.1">is failed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<span class="koboSpan" id="kobo.1519.1"><img alt="Figure 14.25 – The workflow is triggered automatically and then fails" src="image/B18971_14_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1520.1">Figure 14.25 – The workflow is triggered automatically and then fails</span></p>
<p><span class="koboSpan" id="kobo.1521.1">Click the links in the logs to see details of the code that caused the test failure. </span><span class="koboSpan" id="kobo.1521.2">It is handy to review code changes in the pull request. </span><span class="koboSpan" id="kobo.1521.3">If everything is fine, you can merge the </span><span class="No-Break"><span class="koboSpan" id="kobo.1522.1">pull request.</span></span></p>
<p><span class="koboSpan" id="kobo.1523.1">To clarify that it </span><a id="_idIndexMarker1645"/><span class="koboSpan" id="kobo.1524.1">works for pull request builds, we can rename this file to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">pr-build.yml</span></strong><span class="koboSpan" id="kobo.1526.1"> and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">on</span></strong><span class="koboSpan" id="kobo.1528.1"> section to make the workflow run for </span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1">pull requests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1530.1">
on:  pull_request:
    branches: [ "main" ]</span></pre>
<p><span class="koboSpan" id="kobo.1531.1">Next, let us build a Docker image and push it </span><span class="No-Break"><span class="koboSpan" id="kobo.1532.1">to ACR.</span></span></p>
<h2 id="_idParaDest-329"><a id="_idTextAnchor629"/><span class="koboSpan" id="kobo.1533.1">Pushing a Docker image to ACR</span></h2>
<p><span class="koboSpan" id="kobo.1534.1">Create a </span><a id="_idIndexMarker1646"/><span class="koboSpan" id="kobo.1535.1">new YAML file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">docker-build.yml</span></strong><span class="koboSpan" id="kobo.1537.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">.github\workflows</span></strong><span class="koboSpan" id="kobo.1539.1"> folder. </span><span class="koboSpan" id="kobo.1539.2">Update the content of the file </span><span class="No-Break"><span class="koboSpan" id="kobo.1540.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1541.1">
name: Pull Request buildon:
  push:
    branches: [ "main" ]</span></pre>
<p><span class="koboSpan" id="kobo.1542.1">This workflow is triggered when a commit is pushed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1543.1">main</span></strong><span class="koboSpan" id="kobo.1544.1"> branch or a pull request is merged into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1545.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1546.1"> branch.</span></span></p>
<p><span class="koboSpan" id="kobo.1547.1">To authenticate the action to access ACR, we need to configure the username and password of ACR in GitHub secrets. </span><span class="koboSpan" id="kobo.1547.2">Find the username and password by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.1548.1">Access keys</span></strong><span class="koboSpan" id="kobo.1549.1"> menu of ACR in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1550.1">Azure portal.</span></span></p>
<p><span class="koboSpan" id="kobo.1551.1">Go to </span><strong class="bold"><span class="koboSpan" id="kobo.1552.1">Settings</span></strong><span class="koboSpan" id="kobo.1553.1"> in the GitHub repository and click </span><strong class="bold"><span class="koboSpan" id="kobo.1554.1">Secrets and variables</span></strong><span class="koboSpan" id="kobo.1555.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.1556.1">Security</span></strong><span class="koboSpan" id="kobo.1557.1"> category. </span><span class="koboSpan" id="kobo.1557.2">Then, click </span><strong class="bold"><span class="koboSpan" id="kobo.1558.1">Actions</span></strong><span class="koboSpan" id="kobo.1559.1">, and you will see the secrets and variables page. </span><span class="koboSpan" id="kobo.1559.2">There are two types of secrets: environment secrets and repository secrets. </span><span class="koboSpan" id="kobo.1559.3">You can store the username and password in repository secrets directly. </span><span class="koboSpan" id="kobo.1559.4">To demonstrate how to use environment secrets, we will use environment secrets in this example. </span><span class="koboSpan" id="kobo.1559.5">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1560.1">Manage environments</span></strong><span class="koboSpan" id="kobo.1561.1"> button to create a new environment named </span><strong class="bold"><span class="koboSpan" id="kobo.1562.1">Production</span></strong><span class="koboSpan" id="kobo.1563.1">. </span><span class="koboSpan" id="kobo.1563.2">Then, click the </span><strong class="bold"><span class="koboSpan" id="kobo.1564.1">Add secret</span></strong><span class="koboSpan" id="kobo.1565.1"> button to add a username </span><span class="No-Break"><span class="koboSpan" id="kobo.1566.1">and password:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1567.1">Name: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1568.1">REGISTRY_USERNAME</span></strong><span class="koboSpan" id="kobo.1569.1">. </span><span class="koboSpan" id="kobo.1569.2">Value: The username </span><span class="No-Break"><span class="koboSpan" id="kobo.1570.1">of ACR.</span></span></li>
<li><span class="koboSpan" id="kobo.1571.1">Name: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1572.1">REGISTRY_PASSWORD</span></strong><span class="koboSpan" id="kobo.1573.1">. </span><span class="koboSpan" id="kobo.1573.2">Value: The password </span><span class="No-Break"><span class="koboSpan" id="kobo.1574.1">of ACR.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1575.1">You can </span><a id="_idIndexMarker1647"/><span class="koboSpan" id="kobo.1576.1">change the environment secret names, but make sure you use the same names in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1577.1">following workflow.</span></span></p>
<p><span class="koboSpan" id="kobo.1578.1">Now, the environment secrets should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1579.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer135">
<span class="koboSpan" id="kobo.1580.1"><img alt="Figure 14.26 – The Actions secrets and variables page" src="image/B18971_14_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1581.1">Figure 14.26 – The Actions secrets and variables page</span></p>
<p><span class="koboSpan" id="kobo.1582.1">Add the following content to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1583.1">docker-build.yml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1584.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1585.1">
jobs:  docker_build_and_push:
    runs-on: ubuntu-latest
    environment: Production
    steps:
    - uses: actions/checkout@v3
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
    - name: Login to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: devopscrlab.azurecr.io
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
    - name: Push to Azure Container Registry
      run: |
        docker build -f ${{ github.workspace }}/src/MyBasicWebApiDemo/Dockerfile -t devopscrlab.azurecr.io/myazurepipelinesdemo:${{ github.run_id }} -t devopscrlab.azurecr.io/myazurepipelinesdemo:latest .
</span><span class="koboSpan" id="kobo.1585.2">        docker push devopscrlab.azurecr.io/myazurepipelinesdemo:${{ github.run_id }}
        docker push devopscrlab.azurecr.io/myazurepipelinesdemo:latest</span></pre>
<p><span class="koboSpan" id="kobo.1586.1">The </span><a id="_idIndexMarker1648"/><span class="koboSpan" id="kobo.1587.1">preceding is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1588.1">pr-build.yml</span></strong><span class="koboSpan" id="kobo.1589.1"> file, but we made </span><span class="No-Break"><span class="koboSpan" id="kobo.1590.1">some changes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1591.1">We added an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1592.1">environment</span></strong><span class="koboSpan" id="kobo.1593.1"> section to specify the environment so that we can refer to the environment </span><span class="No-Break"><span class="koboSpan" id="kobo.1594.1">secrets later.</span></span></li>
<li><span class="koboSpan" id="kobo.1595.1">We added a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">azure/docker-login@v1</span></strong><span class="koboSpan" id="kobo.1597.1"> step to log in to ACR. </span><span class="koboSpan" id="kobo.1597.2">In this step, we specified the login server, username, and password using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1598.1">environment secrets.</span></span></li>
<li><span class="koboSpan" id="kobo.1599.1">We</span><a id="_idIndexMarker1649"/><span class="koboSpan" id="kobo.1600.1"> added a new step to build the Docker image and push it to ACR. </span><span class="koboSpan" id="kobo.1600.2">In this step, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1601.1">github.run_id</span></strong><span class="koboSpan" id="kobo.1602.1"> variable to tag the image with the run ID. </span><span class="koboSpan" id="kobo.1602.2">We also tagged the image </span><span class="No-Break"><span class="koboSpan" id="kobo.1603.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1604.1">latest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1605.1">.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1606.1">GitHub Actions context</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1607.1">GitHub Actions supports many built-in context variables, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">github.run_id</span></strong><span class="koboSpan" id="kobo.1609.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">github.run_number</span></strong><span class="koboSpan" id="kobo.1611.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">github.sha</span></strong><span class="koboSpan" id="kobo.1613.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">github.ref</span></strong><span class="koboSpan" id="kobo.1615.1">, and so on. </span><span class="koboSpan" id="kobo.1615.2">You can find all the context variables </span><span class="No-Break"><span class="koboSpan" id="kobo.1616.1">here: </span></span><a href="https://docs.github.com/en/actions/learn-github-actions/contexts"><span class="No-Break"><span class="koboSpan" id="kobo.1617.1">https://docs.github.com/en/actions/learn-github-actions/contexts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1618.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1619.1">Commit the changes and push the changes to the remote repository. </span><span class="koboSpan" id="kobo.1619.2">Next time you merge a pull request, you will see the workflow is triggered automatically and the Docker image is pushed </span><span class="No-Break"><span class="koboSpan" id="kobo.1620.1">to ACR:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<span class="koboSpan" id="kobo.1621.1"><img alt="Figure 14.27 – The GitHub Actions workflow is triggered automatically" src="image/B18971_14_27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1622.1">Figure 14.27 – The GitHub Actions workflow is triggered automatically</span></p>
<p><span class="koboSpan" id="kobo.1623.1">As there are many similarities between Azure Pipelines and GitHub Actions, we will not cover all the details of GitHub Actions. </span><span class="koboSpan" id="kobo.1623.2">Maybe it is your turn to create a GitHub Actions workflow to deploy the Docker image to Azure Web App for Containers? </span><a id="_idTextAnchor630"/><span class="koboSpan" id="kobo.1624.1">You can find more information about GitHub Actions </span><span class="No-Break"><span class="koboSpan" id="kobo.1625.1">here: </span></span><a href="https://docs.github.com/en/actions"><span class="No-Break"><span class="koboSpan" id="kobo.1626.1">https://docs.github.com/en/actions</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1627.1">.</span></span></p>
<h1 id="_idParaDest-330"><a id="_idTextAnchor631"/><span class="koboSpan" id="kobo.1628.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1629.1">In this chapter, we explored the fundamentals of CI/CD. </span><span class="koboSpan" id="kobo.1629.2">We discussed how to use Docker to containerize ASP.NET web API applications, including how to create a Dockerfile, build a Docker image, and run a Docker container locally. </span><span class="koboSpan" id="kobo.1629.3">We then looked at Azure DevOps Pipelines, a powerful CI/CD platform from Microsoft, and how to create CI/CD pipelines in YAML files. </span><span class="koboSpan" id="kobo.1629.4">We covered configuring triggers, using built-in tasks, and using variables. </span><span class="koboSpan" id="kobo.1629.5">We created three pipelines for builds, Docker image builds, and releases. </span><span class="koboSpan" id="kobo.1629.6">We also briefly discussed GitHub Actions, another popular CI/CD tool, and created a GitHub Actions workflow to build and test the application, then build the Docker image and push it to ACR. </span><span class="koboSpan" id="kobo.1629.7">After reading this chapter, you should have a basic understanding of CI/CD and be able to use CI/CD pipelines to automate the build, test, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1630.1">deployment process.</span></span></p>
<p><span class="koboSpan" id="kobo.1631.1">In the next chapter, we will examine some common practices for building ASP.NET web APIs, including caching, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1633.1"> factory, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1634.1">so on.</span></span></p>
</div>
</body></html>