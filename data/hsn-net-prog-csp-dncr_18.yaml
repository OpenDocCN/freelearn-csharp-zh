- en: Authentication and Authorization on Networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络上的身份验证和授权
- en: In the previous chapter, we gave serious consideration to the transport layer
    solutions for ensuring secure connections. With that knowledge, we'll be spending
    this chapter exploring the kinds of host-to-host interactions that demand that
    transport-level security. We'll be taking a step back up the tiers of the network
    stack, into the application layer, to look at how authentication and authorization
    is handled in .NET Core. We'll look at the various standards supported by the
    authorization header of HTTP. Then, we'll look at some widely used and widely
    supported open source tools for authentication. Finally, we'll look at how to
    manage access control within a C# application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们认真考虑了确保安全连接的传输层解决方案。有了这些知识，我们将在本章中探讨需要传输层安全的主机到主机交互类型。我们将退回到网络堆栈的层级，进入应用层，看看.NET
    Core中是如何处理身份验证和授权的。我们将查看HTTP授权头支持的各种标准。然后，我们将查看一些广泛使用和广泛支持的开放源代码工具，用于身份验证。最后，我们将探讨如何在C#应用程序中管理访问控制。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The various authentication schemes supported by valid authorization header values
    in HTTP requests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求中有效授权头值支持的多种身份验证方案
- en: Understanding OAuth tokens and how they can be leveraged for user authentication
    and authorization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解OAuth令牌以及如何利用它们进行用户身份验证和授权
- en: Strategies and settings for implementing authorization schemes in a .NET Core
    application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET Core应用程序中实现授权方案的策略和设置
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, as in the previous chapters, you'll need your IDE or source
    code editor of choice, as well as the sample code for this chapter [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter
    14](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2014).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，就像在前几章中一样，你需要你的IDE或你选择的源代码编辑器，以及本章的示例代码 [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2014](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2014).
- en: Check out the following video to see the code in action: [http://bit.ly/2HY64XC](http://bit.ly/2HY64XC)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况： [http://bit.ly/2HY64XC](http://bit.ly/2HY64XC)
- en: We'll also be relying heavily on a REST client to initiate requests against
    our demo API, so make sure you've installed one. My two recommendations stand
    with either Postman, which can be found at: [https://www.getpostman.com/downloads/](https://www.getpostman.com/downloads/),
    or the Insomnia REST client, which can be found at: [https://insomnia.rest/.](https://insomnia.rest/)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将大量依赖REST客户端来对我们的演示API发起请求，所以请确保你已经安装了一个。我的两个推荐是Postman，可以在以下网址找到： [https://www.getpostman.com/downloads/](https://www.getpostman.com/downloads/)，或者Insomnia
    REST客户端，可以在以下网址找到： [https://insomnia.rest/](https://insomnia.rest/)
- en: The authorization header
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权头
- en: If you've ever used your browser tools to inspect an outbound request to a website
    you've logged on to, you will likely have noticed, in the request header segment
    of your network inspector, a header titled `Authorization`. This standard header
    in the HTTP protocol can be used to specify a variety of schemes used to authenticate
    and authorize a user to access content at the requested URL. If you're not familiar
    with it, though, you might be surprised at the sheer variety of options at your
    disposal for providing those basic functions in your software. So, let's look
    at what those authorization schemes are and how we can use them in our own projects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用浏览器工具检查过登录到网站的外出请求，你可能会在你的网络检查器的请求头部分注意到一个标题为“Authorization”的头。这个HTTP协议中的标准头可以用来指定用于在请求的URL上验证和授权用户访问内容的各种方案。如果你不熟悉它，你可能会对你的软件中提供这些基本功能所拥有的选项的多样性感到惊讶。所以，让我们看看这些授权方案是什么，以及我们如何在我们的项目中使用它们。
- en: Authorization versus authentication
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权与身份验证的比较
- en: The first thing we'll want to consider as we explore the `Authorization` header
    is the twofunctions of web security that it can enable. While it is explicitly
    titled an `Authorization` header, often times, in practice, it's actually a misnomer.
    In reality, it can be both an `Authorization` header andan `Authentication` header,
    and frequently it functions as both.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索`Authorization`头时，首先需要考虑的是它能够启用的网络安全中的两个功能。虽然它明确地被命名为`Authorization`头，但在实践中，这通常是一个误称。实际上，它既可以是一个`Authorization`头，也可以是一个`Authentication`头，并且通常它同时具备这两种功能。
- en: Now, if you're not quite clear on the distinction between these two operations,
    this may all sound like I'm just splitting hairs. However, they each provide fundamentally
    different, and fundamentally necessary, features for a robust system of access
    control. And when we're talking about the `Authorization` header, we are explicitly
    talking about controlling access to the resources of our software. So, what exactly
    are these operations, and how can they facilitate an access controlled architecture?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您对这两个操作之间的区别不太清楚，这听起来可能就像我在吹毛求疵。然而，它们各自提供了对健壮访问控制系统基本不同且基本必要的功能。当我们谈论`Authorization`头时，我们明确地是在谈论控制对软件资源的访问。那么，这些操作究竟是什么，它们如何促进受控访问架构的实现呢？
- en: Authentication
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Put simply, authentication is the process of verifying a user's claim about
    who they are. Your user is making a claim about their identity, and you want to
    make sure that the identity is authentic*.* This is typically done by having the
    user provide some information that only they could be reasonably expected to have.
    In access-controlled software, that information is typically a set of credentials,
    such as a username and password combination, but it could be any number of things,
    such as knowledge of previous addresses or familial ties.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，认证是验证用户对其身份声明的过程。您的用户正在对其身份做出声明，而您想要确保这个身份是真实的。这通常是通过让用户提供一些只有他们才能合理预期能够拥有的信息来完成的。在受控访问的软件中，这些信息通常是凭证集，例如用户名和密码组合，但它也可能是任何数量的事物，例如对以前地址的了解或家族关系。
- en: Authentication credentials could be anything that the user in question should
    reasonably be expected to know, and which no one else could reasonably be expected
    to know. Once these credentials are provided, the authenticity of the user's claim
    can be verified. So, authentication is about verifying a user'sidentity***.***
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 认证凭证可以是任何用户应该合理预期能够知道，而其他人则不太可能知道的信息。一旦提供了这些凭证，就可以验证用户声明的真实性。因此，认证是关于验证用户身份的***。***
- en: Authorization
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: On the other side of the access-control coin is authorization. This is about
    determining what a user should be allowed to do within a system, from modifying
    or adding information stored by a system to even accessing it in the first place.
    Just as the name suggests, authorization is a precaution of not allowing a user
    to perform an action until the system knows that the user is authorized to do
    so.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问控制硬币的另一面是授权。这是关于确定用户在系统中应该被允许做什么，从修改或添加系统存储的信息到最初访问它。正如其名所示，授权是一种预防措施，不允许用户执行操作，直到系统知道用户有权这样做。
- en: In almost all access-controlled systems, authorization is dependent on authentication.
    You can't determine if a user is authorized to perform an action until you can
    first authenticate that the user is who they claim to be. Authorization has the
    potential to be a substantially more complex step in the access-control process,
    though. The authentication step is fairly straightforward, with only two possible
    results. Either the user is who they claimed to be, in which case authentication
    succeeds, or they are not, in which case authentication fails. With authorization,
    though, the permissions that are returned for a given user could be determined
    by any number of underlying rules, procedures, or conditions. So, while authentication
    is about verifying a user's identity, authorization is about determining the actions
    a user is permitted to perform.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有受控访问系统中，授权依赖于认证。在你首先不能验证用户是他们所声称的人之前，你不能确定用户是否有权执行某个操作。尽管认证步骤相当直接，只有两种可能的结果：要么用户是他们所声称的人，在这种情况下认证成功，要么他们不是，在这种情况下认证失败。然而，在授权方面，为特定用户返回的权限可能由任何数量的底层规则、程序或条件决定。因此，虽然认证是关于验证用户的身份，但授权是关于确定用户被允许执行的操作。
- en: So, now that we understand the roles authentication and authorization play in
    access control, let's look at the HTTP mechanisms that enable those roles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们了解了认证和授权在访问控制中扮演的角色，让我们来看看使这些角色得以实现的HTTP机制。
- en: Authorization header values
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权头信息值
- en: When a user attempts to access a site that is access-controlled, they might
    be prompted to provide an `Authorization` header from the server. For a client
    to authorize themselves with the server, they must do so using an authorization
    mechanism the server is prepared to handle. If the server is only set up for basic
    authentication, but the client tries to pass a bearer token, the server won't
    be able to parse the `Authorization` header, and will return a 401-Unauthorized
    status code, regardless of the validity of the token sent by the client.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试访问受控访问的网站时，他们可能会被提示从服务器提供`Authorization`头信息。为了使客户端能够使用服务器准备处理的认证机制进行授权，他们必须这样做。如果服务器仅设置了基本认证，但客户端尝试传递一个携带令牌，服务器将无法解析`Authorization`头信息，并将返回401-未授权的状态码，无论客户端发送的令牌是否有效。
- en: The client (who, in this case, doesn't have prior knowledge of the valid authorization
    schemes supported by the server) must first be told exactly which authorization
    mechanism it should use to authenticate with the server. This is done with a `WWW-Authenticate` response
    header, which is applied to the initial response from the server. This header
    is used to indicate to the client exactly which `Authorization` protocol the server
    expects. So what exactly are the `Authorization` protocols defined by HTTP, and
    how do they work?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端（在这种情况下，不知道服务器支持的合法授权方案）必须首先被告知它应该使用哪种授权机制来与服务器进行认证。这是通过一个`WWW-Authenticate`响应头信息来完成的，该头信息应用于服务器的初始响应。此头信息用于向客户端指示服务器期望的`Authorization`协议。那么，HTTP定义的`Authorization`协议究竟是什么，它们是如何工作的呢？
- en: Basic authentication
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本认证
- en: This specific schema is our first example of the `Authorization` header being
    used for an authentication task. In an HTTP interaction, the **basic authentication**
    (**BA**) schema is used for simple transmission of a username and password from
    the client to the server for authentication and authorization. It's known as the
    Basic, because when it is requested by a server, the client simply passes along
    credentials with no additional session keys or cookies and no additional handshaking
    between services to set the header appropriately.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的方案是我们第一个例子，展示了`Authorization`头信息在认证任务中的应用。在HTTP交互中，**基本认证**（**BA**）方案用于从客户端简单传输用户名和密码到服务器进行认证和授权。它被称为基本认证，因为当服务器请求时，客户端只需传递凭据，无需额外的会话密钥或cookie，也不需要在服务之间进行额外的握手来适当地设置头信息。
- en: 'With BA, the server indicates the authentication scheme by passing back a `WWW-Authenticate`
    header with the following structure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有BA（基本认证），服务器通过返回一个具有以下结构的`WWW-Authenticate`头信息来指示认证方案：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `realm` and `charset` parameters are technically optional, but can
    provide useful guidance for the client with respect to how or why they must pass
    their credentials. Upon receiving this header, the client is responsible for delivering
    their credentials via the Authorization header in subsequent requests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`realm`和`charset`参数在技术上不是必需的，但可以为客户端提供有关如何或为什么他们必须传递其凭据的有用指导。在接收到此头后，客户端负责通过后续请求中的授权头传递其凭据。
- en: The user information URL segment
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户信息URL段
- en: We've actually seen the first method before, back in [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml)*,
    DNS and Resource Location*, in the *URLs, domain names, and device addresses *section*.* If
    a server supports the Basic authentication mechanism, clients can bypass the `Authorization`
    header altogether and simply transmit their credentials in the URL itself.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在[第2章](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml)*，DNS和资源定位*的*URL、域名和设备地址*部分中见过第一种方法。如果一个服务器支持基本认证机制，客户端可以完全绕过`Authorization`头，并在URL本身中直接传输其凭据。
- en: 'As you may remember, the first segment of a URL, after the schema specification,
    is actually an optional segment used for access credentials. So, let''s imagine
    we have a user that has valid access to a remote resource. For this example, let''s
    say their username is `aesop_rock`, and their password `A3h4s9f0cjeC`. Upon receiving
    the `WWW-Authenticate` method specifying Basic authentication, the client could
    simply redirect themselves to the access-controlled URL with the following credentials
    prefixed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，URL的第一个段，在方案指定之后，实际上是一个可选段，用于访问凭据。所以，让我们想象有一个用户有权访问远程资源。为了这个例子，让我们假设他们的用户名是`aesop_rock`，密码是`A3h4s9f0cjeC`。在接收到指定基本认证的`WWW-Authenticate`方法后，客户端可以简单地将自己重定向到以下带有凭据的前缀的受控访问URL：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While this format meets the standards for a valid URL, and will allow for basic
    authentication mechanisms without passing the authentication header, it should
    be avoided at all costs. Transmitting passwords in plain text as part of your
    destination URL poses a substantial security risk. For that reason, the use of
    this `username:password` format is considered deprecated, and often unsupported
    by modern web browsers. However, the high volume of services that continue to
    support this URI-based authentication technique makes it worth your effort to
    understand and consider. As a rule, though, you should never support access with
    this credential mechanism. Whenever possible, you should scrub URLs of any content
    in the user information segment that comes after the first colon before transmitting
    requests over the wire to prevent accidentally persisting plain-text records of
    user passwords.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种格式符合有效URL的标准，并且允许在不传递认证头的情况下使用基本认证机制，但应不惜一切代价避免使用。将密码作为目的地URL的一部分以纯文本形式传输会带来重大的安全风险。因此，使用此`username:password`格式被认为是过时的，并且通常不被现代网络浏览器支持。然而，大量继续支持基于URI的认证技术的服务使得理解并考虑它是值得的。然而，按照规则，您永远不应该支持这种凭据机制的访问。在可能的情况下，您应该在通过电线传输请求之前，从用户信息段中清除任何位于第一个冒号之后的内容，以防止意外持久化用户密码的纯文本记录。
- en: Basic authentication with header values
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有头值的基本认证
- en: 'When transmitting the credentials in the request header, however, a client
    would transmit all subsequent requests with the `Authorization` header, configured
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当在请求头中传输凭据时，客户端会使用以下配置的`Authorization`头传输所有后续请求：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the credentials are first formatted with a username and password separated
    by a single colon, just as in the URL format, then the `base64` character encoded.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，凭据首先以用户名和密码通过单个冒号分隔，就像在URL格式中一样，然后进行`base64`字符编码。
- en: For credentials that are passed using this Basic authentication format, the
    first colon is always parsed as the delimiter between the username and password
    fields. Because of this, the username in a Basic authenticated system can never
    contain a colon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用此基本认证格式传递的凭据，第一个冒号始终被解析为用户名和密码字段之间的分隔符。因此，在基本认证系统中，用户名中永远不能包含冒号。
- en: 'So, if we have our user from the previous example, with the username of `aesop_rock`
    and a password of `A3h4s9f0cjeC`, then we would first format the credentials as
    follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有之前例子中的用户，用户名为`aesop_rock`，密码为`A3h4s9f0cjeC`，那么我们首先会按照以下方式格式化凭据：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And then we would `base-64` encode the characters. Applying this to our `Authorization`
    header, we would have a header value that''s as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将字符进行`base-64`编码。将此应用于`Authorization`头，我们将有一个如下所示的头部值：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have a Basic authentication `Authorization` header that, when transmitted
    to the server, the server will be able to validate by decoding the value of the
    `base-64` encoded access credentials.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个基本的认证`Authorization`头，当传输到服务器时，服务器将能够通过解码`base-64`编码的访问凭证的值来验证。
- en: Encryption versus encoding
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密与编码
- en: It's important to note that when we modify our credentials, we are merely encoding
    them, and not actually encrypting them. The difference here is that a user can
    go from the `base-64` encoding to plain text and then back to the `base-64` encoding,
    all without access to any sort of cryptographic key to transition from one format
    to another. Encoding is simply a matter of character representation. It's almost
    like translating a basic noun from English to Spanish, and then back from Spanish
    to English. The meaning isn't obscured; it's just how the words are represented.
    Meanwhile, encryption is about deriving a new, secret value for an input string
    based on an additional, secret input, to obscure the meaning of the original message
    entirely.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当我们修改我们的凭证时，我们只是在编码它们，而不是真正地加密它们。这里的区别在于，用户可以从`base-64`编码转换为纯文本，然后再转换回`base-64`编码，这一切都不需要任何类型的加密密钥来从一个格式转换到另一个格式。编码仅仅是字符表示的问题。这就像将一个基本的名词从英语翻译成西班牙语，然后再从西班牙语翻译回英语一样。意义并没有被掩盖；只是单词的表示方式不同。与此同时，加密是根据额外的、秘密的输入推导出一个新的、秘密的输入字符串，以完全掩盖原始消息的意义。
- en: At this point, I'll just go ahead and point out the obvious—any interaction
    that involves an `Authorization` header must take place over a secured connection
    using HTTPS. Though it might not always be feasible, the simplest best practice
    for enforcing this more secure behavior is to simply not configure your application
    to listen for HTTP requests. We'll see in just a bit what other options we have
    for preventing privileged information from being transmitted, unencrypted, and
    unsecured over a network. For now, though, if you can avoid supporting HTTP altogether,
    I'd strongly recommend doing so.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只想指出一个显而易见的事实——任何涉及`Authorization`头的交互都必须通过使用HTTPS的安全连接进行。尽管这可能并不总是可行的，但强制执行这种更安全行为的简单最佳实践就是简单地不要配置您的应用程序来监听HTTP请求。我们很快就会看到我们还有哪些其他选项可以防止特权信息在网络上未加密、未安全地传输。现在，如果您能够完全避免支持HTTP，我强烈建议这样做。
- en: Bearer token authorization
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 携带令牌授权
- en: While Basic authentication simply provided a raw username and password credentials,
    the bearer authentication deals in what is known as **bearer ****tokens**. A bearer
    token is simply a security token that notifies the server that the user presenting
    the token (the bearer) has the credentials and permissions granted by the token.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本认证只是提供了一个原始的用户名和密码凭证，但携带认证处理的是所谓的**携带令牌**。携带令牌只是一个安全令牌，它通知服务器，展示该令牌的用户（携带者）拥有令牌所赋予的凭证和权限。
- en: Since, from the server's perspective, this token is used to authenticate a specific
    user, a bearer token can be thought of as simply a different kind of access credential.
    For this to be the case, though, the server must operate on the assumption that
    the bearer of a given security token wouldn't have it unless they were authorized
    to have it. For that reason, protecting the value of a given bearer token from
    eavesdropping or unauthorized access is just as important as protecting the value
    of a user password. Extra care should be taken to ensure that a token is never
    persisted on your server in an unsecured format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从服务器的角度来看，此令牌用于验证特定用户，因此可以认为携带令牌仅仅是一种不同类型的访问凭证。然而，为了使这种情况成立，服务器必须基于这样的假设：持有特定安全令牌的人除非被授权持有，否则不会拥有它。因此，保护特定携带令牌的价值免受窃听或未经授权的访问与保护用户密码的价值同样重要。应格外小心，确保令牌永远不会以未加密的格式保存在您的服务器上。
- en: Within the context of the `Authorization` header, the bearer authentication
    scheme is used specifically to support what are known as **OAuth tokens**. **Open
    Authentication** (**OAuth**) is a standard that was designed explicitly to support
    token-based authentication mechanisms for access-control of web-based resources.
    It's incredibly common across the internet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Authorization`头的上下文中，载体认证方案专门用于支持所谓的**OAuth令牌**。**开放认证**（**OAuth**）是一个旨在明确支持基于令牌的认证机制，用于基于Web资源的访问控制的标准。它在互联网上极其常见。
- en: OAuth basics
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth基础知识
- en: If you've ever logged on to a website with your Google account, Facebook, or
    Twitter, you've used OAuth before. It's an access control mechanism that's designed
    to allow a delegate service to authenticate and authorize a user for the access-controlled
    resource. So, when you enter a new website for the first time, and it allows you
    to access it with your Google account, that new website is delegating the responsibility
    of authenticating you to Google. Google requests your credentials and authenticates
    you, and you are implicitly notifying Google to provide the new website with a
    token which the new website will consider sufficient for *authorization*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用谷歌账户、Facebook或Twitter登录过网站，那么你之前已经使用过OAuth。它是一种访问控制机制，旨在允许代理服务对受控资源进行用户身份验证和授权。因此，当你第一次访问一个新网站时，如果它允许你使用谷歌账户访问，那么这个新网站就是在将验证你的责任委托给谷歌。谷歌请求你的凭证并验证你，你隐式地通知谷歌为新网站提供一个令牌，新网站将认为这个令牌足以进行*授权*。
- en: It's not entirely dissimilar to the **trusted certificate authority** (**CA**)
    system we learned about in [Chapter 13](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml),* Transport
    Layer Security*. In this context, Google would be analogous to a CA, and the users,
    or bearers of the token, are essentially the holders of the security certificate.
    So systems which support OAuth access are trusting the OAuth providers (Google,
    Facebook, and so on) as reliable sources for authentication.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第13章](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml)中学习的**受信任证书机构**（**CA**）系统并没有太大的不同，即**传输层安全性**。在这个背景下，谷歌可以类比为CA，而用户或令牌的持有者实际上是安全证书的持有者。因此，支持OAuth访问的系统是信任OAuth提供者（如谷歌、Facebook等）作为认证的可靠来源。
- en: Authorizing with bearer tokens
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用载体令牌进行授权
- en: 'When a bearer token is supported, the syntax for delivering the token in your
    `Authorization` header is almost identical to that of Basic authentication. The
    format for doing so is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当支持载体令牌时，在`Authorization`头中传递令牌的语法几乎与基本认证相同。这样做的方式如下：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The main difference here is that while the Basic authentication credentials
    were merely `base64` encoded, the token in a bearer authentication scheme can
    be cryptographically secured, providing some measure of protection if a client
    attempts to deliver the token over an unsecured transport mechanism. Moreover,
    Basic authentication credentials will only ever contain the user's access credentials,
    whereas bearer tokens can be far more robust in the information or context they
    contain.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于，虽然基本认证凭证只是`base64`编码，但在载体认证方案中的令牌可以经过加密保护，如果客户端尝试通过不安全的传输机制传递令牌，这提供了一定程度的保护。此外，基本认证凭证将仅包含用户的访问凭证，而载体令牌可以包含更多或更丰富的信息或上下文。
- en: While merely passing access credentials in a Basic authentication scheme is
    sufficient for authenticating a user, it leaves the task of determining any permissions
    that user might have up to the server. With a bearer token, though, the token
    might contain information for both, authentication of a user's identity as well
    as an assertion of the permissions granted to the user. In this way, the bearer
    authentication mechanism can be substantially more versatile, when implemented
    properly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在基本认证方案中仅传递访问凭证就足以验证用户身份，但它将确定该用户可能拥有的任何权限的任务留给了服务器。然而，使用载体令牌时，令牌可能包含有关用户身份验证以及授予用户的权限的信息。因此，如果正确实现，载体认证机制可以更加灵活。
- en: Digest authentication
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要认证
- en: With the Digest authentication scheme, the designers explicitly sought to provide
    a more secure authentication implementation than is provided by the unencrypted
    Basic authentication scheme. In actuality, though, it only ends up providing a
    set of security trade-offs, and is reliant on an outdated hashing algorithm for
    its encryption. It still has a number of advantages, though, and is worth considering
    for implementation in certain circumstances. To understand the advantages and
    disadvantages it introduces, and when you might want to use it, let's look at
    how it works.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用摘要认证方案，设计者明确寻求提供一种比未加密的基本认证方案更安全的认证实现。然而，实际上，它只提供了一套安全权衡，并且依赖于过时的哈希算法进行加密。尽管如此，它仍然具有许多优点，在某些情况下值得考虑实施。为了了解它引入的优点和缺点，以及何时可能想要使用它，让我们看看它是如何工作的。
- en: The Digest authentication WWW-Authenticate header
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要认证的WWW-Authenticate头
- en: When a user attempts to access a system that leverages Digest authentication,
    they are still prompted to use an `Authorization` header with the `WWW-Authenticate`
    response header. However, unlike the simple scheme specification returned with
    Basic and Bearer authentication schemes, the `WWW-Authenticate` header in a Digest
    authentication scheme contains a series of values the client will use to generate
    its authentication request.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试访问采用摘要认证的系统时，他们仍然会被提示使用带有`WWW-Authenticate`响应头的`Authorization`头。然而，与基本和载体认证方案返回的简单方案规范不同，摘要认证方案中的`WWW-Authenticate`头包含一系列客户端将用于生成其认证请求的值。
- en: These header values include the `realm` parameter that we saw as an optional
    parameter in Basic authentication schemes, and serves the same purpose, describing
    the authenticated space. There is also a required `nonce` value (nonce just means
    something that is only meant to be used once; in this case, for one authenticated
    session), which is used by the client to generate their digested credentials.
    This essentially serves as a shared secret or session key. In addition to these
    two required header parameters, there are several additional optional parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头值包括我们在基本认证方案中看到的作为可选参数的`realm`参数，它具有相同的作用，描述了认证空间。还有一个必需的`nonce`值（nonce的意思是只打算使用一次；在这种情况下，用于一个认证会话），客户端使用它来生成其摘要凭据。这本质上充当了一个共享密钥或会话密钥。除了这两个必需的头参数外，还有几个额外的可选参数。
- en: The first of these optional parameters is `qop`, or quality of protection—a
    specification which, if included, dictates an additional set of steps the user
    must take in building their authenticated response. The values specified by this
    optional field can ensure a higher degree of security for the credentials being
    transmitted by the client. When left unspecified by the server, the default operations
    used by the client are the least secure for transit. Interestingly, the **Remote
    Function Call** (**RFC**), which standardized Digest authentication (RFC 7616),
    specifies the `qop` field as being required, but its support and implementation
    vary for different application servers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可选参数中的第一个是`qop`，即保护质量——一个如果包含，则规定用户在构建其认证响应时必须采取的额外步骤的规范。此可选字段指定的值可以确保客户端传输的凭据具有更高的安全性。当服务器未指定时，客户端使用的默认操作对于传输来说是最不安全的。有趣的是，**远程过程调用**（**RFC**），该RFC标准化了摘要认证（RFC
    7616），指定`qop`字段为必需，但其支持和实现因不同的应用服务器而异。
- en: The server can also specify a `domain` field, which can include a space-separated
    list of URIs that define the protection space. When this field is provided, the
    client can use the value to determine all of the URIs for which the same authentication
    information will be considered valid. This is useful in a distributed system wherein
    one resource is responsible for authenticating, but the user must forward authentication
    information to a separate server to access its restricted content.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器还可以指定一个`domain`字段，该字段可以包含一个由空格分隔的URI列表，用于定义受保护空间。当提供此字段时，客户端可以使用该值来确定所有将被视为有效的相同认证信息的URI。这在分布式系统中非常有用，其中一种资源负责认证，但用户必须将认证信息转发到另一个服务器以访问其受限制的内容。
- en: The server can specify the specific hashing algorithm the client must use for
    its digested response with the `algorithm` parameter. When not specified, the
    algorithm is expected to default to MD5, which is known to be insecure in many
    contexts. Because of this, if you ever find yourself implementing the Digest authentication
    scheme, I would strongly encourage you to enforce a secure hashing algorithm using
    the `algorithm` parameter of your response header.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以使用`algorithm`参数指定客户端必须用于其摘要响应的特定哈希算法。如果没有指定，则预期算法默认为MD5，这在许多情况下被认为是不可靠的。因此，如果您在实现摘要认证方案时，我强烈建议您使用响应头中的`algorithm`参数强制执行安全的哈希算法。
- en: Additionally, the server can provide an `opaque` value, which is meant to be
    echoed exactly by the client. This is a useful mechanism by which a server can
    transmit state information from one resource to another through the authenticated
    client. So, for example, if server A is responsible for authenticating the client
    for access to resources on server B, then server A could transmit access details
    to server B, through the opaque field. When implemented properly, the client would
    simply echo whatever values are sent by server A in its subsequent requests to
    server B.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，服务器还可以提供一个`opaque`值，其目的是由客户端精确地回显。这是一个有用的机制，通过它服务器可以将状态信息从资源传输到另一个通过认证的客户端。例如，如果服务器A负责为访问服务器B上的资源对客户端进行认证，那么服务器A可以通过`opaque`字段将访问详情传输到服务器B。当正确实现时，客户端只需在其随后的请求中回显服务器A发送的任何值即可。
- en: Finally, there are entirely optional parameters for minor details of the authentication
    interaction, such as `charset`, which is used to specify the supported encoding
    schemes that the client may use. There is also a `userhash` parameter, which notifies
    the client that the server supports hashing the username in addition to the password
    component of their credentials.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些可选参数用于认证交互的细微细节，例如`charset`，它用于指定客户端可能使用的支持的编码方案。还有一个`userhash`参数，它通知客户端服务器支持对凭据的密码组件进行哈希处理，同时也可以对用户名进行哈希处理。
- en: 'Taken together, each of these required and optional parameters will produce
    a `WWW-Authenticate` header that looks like the following sample, as presented
    in the original RFC for Digest authentication:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 综合来看，每个必需的和可选的参数都将生成一个类似于以下示例的`WWW-Authenticate`头，正如原始RFC中摘要认证所展示的：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, to understand how these header values are used to create a digested credential,
    let's look at the client's role in this process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了了解这些头值是如何用来创建摘要凭据的，让我们看看客户端在这个过程中所扮演的角色。
- en: Digest authentication's authorization header
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要认证的授权头
- en: Once the client has received the `WWW-Authenticate` header from the server,
    they are responsible for building out their Digest response using the hashing
    algorithm that's specified (or the default MD5, if unspecified) by the server.
    To do so, they follow a series of procedures for one-way hashing their passwords
    using the hashing algorithm, and then hashing a combination of their username,
    the nonce value returned by the server, and their password.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端从服务器接收到`WWW-Authenticate`头，他们就有责任使用服务器指定的哈希算法（如果没有指定，则为默认的MD5）构建他们的摘要响应。为此，他们遵循一系列程序，使用哈希算法对密码进行单向哈希处理，然后对他们的用户名、服务器返回的nonce值和他们的密码的组合进行哈希处理。
- en: 'The user creates a hash value with their username, the realm, and their password,
    with each separated by a colon. Assuming the server specified `SHA-256`, this
    creates a value designated as `HA1`, as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 用户使用他们的用户名、域和密码创建一个哈希值，每个值之间用冒号分隔。假设服务器指定了`SHA-256`，这将创建一个称为`HA1`的值，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then they generate a secondary hash value, dubbed `HA2`, which is composed
    of the HTTP method, to access the restricted resource, and the designated URI,
    separated by a colon and hashed with the specified algorithm:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们生成一个二级哈希值，称为`HA2`，它由HTTP方法（用于访问受限制的资源）和指定的URI组成，用冒号分隔并用指定的算法进行哈希处理：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, both of these values are hashed again in combination with the `nonce`
    value sent over by the server to produce the `response` parameter of the `Authorization`
    header:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这两个值都会与服务器发送的`nonce`值一起再次进行哈希处理，以生成`Authorization`头中的`response`参数：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are variations of the specific inputs for each of these three values,
    depending on the `qop` value specified by the server, but overall the interactions
    are the same. Once all of this is done, the client returns an `Authorization`
    header to the server that includes the response value as well as its own array
    of optional parameters (and the echoed opaque parameter, if the server sent one
    in the first place) back to the server, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务器指定的`qop`值，这三个值的具体输入可能会有所不同，但总体交互是相同的。一旦完成所有这些操作，客户端就会向服务器返回一个包含响应值以及它自己的可选参数数组（以及如果服务器最初发送了的话，回声的透明参数）的`Authorization`头，如下所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The advantage to this is that the user never sends their password in plain text.
    The reason for this is that, since the server shouldknow the user password, it
    can reproduce the same hashing algorithms, using the same inputs, and confirm
    the result against the `response` parameter of the `Authorization` header.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是用户永远不会以明文形式发送他们的密码。原因是，由于服务器应该知道用户的密码，它可以使用相同的散列算法，使用相同的输入，并对照`Authorization`头中的`response`参数来确认结果。
- en: Of course, you can probably already see the risk inherent with such an implementation.
    For the server to reproduce the same `response` parameter, it must have access
    to the user password stored somewhere in plain text. Since this is universally
    a bad idea, more modern implementations will typically store the entirety of the
    HA1 value in a secured database the first time a user creates a new set of credentials.
    This technique still allows the server to produce the response calculation of
    `SHA256(HA1:nonce:HA2)` while eliminating the need for the plain-text inputs of
    HA1\. However, that also means that any time the realm value is changed, HA1 needs
    to be recalculated for each user on the system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能已经看到了这种实现固有的风险。为了服务器能够重现相同的`response`参数，它必须能够访问存储在某个地方的用户的明文密码。由于这通常是一个糟糕的想法，更现代的实现通常会首次用户创建一组新凭证时，将整个HA1值存储在安全的数据库中。这项技术仍然允许服务器产生`SHA256(HA1:nonce:HA2)`的响应计算，同时消除了对HA1的明文输入的需要。然而，这也意味着每次更改域值时，都需要为系统上的每个用户重新计算HA1。
- en: Furthermore, even storing the `HA1` value should be considered relatively insecure,
    since it's used to create a new response by the client and access to the database
    still compromises the underlying system. A malicious actor would still be able
    to generate a fraudulent request, even without the plain-text password of the
    victim. The biggest benefit to using the `HA1` is that, in the event of the server
    being compromised, it at least protects the user's raw password from exposure,
    minimizing risk to users in the event of a security breach.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使存储`HA1`值也应该被认为相对不安全，因为它被客户端用来创建新的响应并访问数据库仍然会危害底层系统。恶意行为者仍然能够生成一个欺诈请求，即使没有受害者的明文密码。使用`HA1`的最大好处是，在服务器被入侵的情况下，它至少可以保护用户的原始密码不被泄露，从而在安全漏洞事件中最大限度地减少对用户的风险。
- en: Although the Digest authentication scheme is intended to provide higher levels
    of security for the authentication step of system access, it introduces its own
    complications and security concerns. For this reason, it's much less used.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管摘要认证方案旨在为系统访问的认证步骤提供更高的安全性，但它引入了自己的复杂性和安全担忧。因此，它使用得较少。
- en: HTTP origin-bound access
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP源绑定访问
- en: While not a fully-realized standard, the **HTTP origin-bound access** (**HOBA**)
    authentication scheme represents an exciting paradigm shift in the design of access-control
    mechanisms. Each of the previous forms of authentication we've discussed all revolved
    around users providing credentials (usually in the form of a username and password)
    to gain access to a system. With HOBA, no credentials are ever transmitted. Instead,
    a client (usually a specific web browser) persists a digital signature, which
    is given to the server in a challenge-response scheme.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是一个完全实现的标准，但**HTTP源绑定访问**（**HOBA**）认证方案代表了访问控制机制设计中的一个令人兴奋的范式转变。我们之前讨论的所有先前形式的认证都是围绕用户提供凭证（通常是用户名和密码的形式）以获取系统访问权限。在HOBA中，永远不会传输凭证。相反，客户端（通常是特定的网络浏览器）会持续一个数字签名，该签名在挑战-响应方案中提供给服务器。
- en: Under the HOBA mechanism, the first time a client attempts to access a system,
    that specific client must register with the server. During this registration,
    once the client has been authenticated through traditional means, the client creates
    a **client public key** (**CPK**) and a private key registered to the specific
    origin/realm for the restricted resource. The CPK is then provided to the server,
    which assigns the CPK as the digital signature of the client. It's this CPK that
    is used to authenticate and authorize subsequent requests by the user to access
    restricted resources within the specified realm.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在HOBA机制下，当客户端第一次尝试访问系统时，该特定客户端必须向服务器注册。在注册过程中，一旦客户端通过传统方式被认证，客户端就会创建一个**客户端公钥**（**CPK**）和一个注册到特定源/域的私钥，用于受限制的资源。然后，CPK被提供给服务器，服务器将CPK分配为客户端的数字签名。正是这个CPK用于验证和授权用户随后的请求，以便访问指定域内的受限制资源。
- en: This provides the major security benefit of not having to store a record of
    the user credentials on the server, even in a securely hashed format. The downside
    to this practice, though, is that the CPK is typically stored in local storage
    by the browser on the client's machine. This means that any time a user accesses
    the server from a different machine (or indeed even a different web browser on
    the same machine) the client will have to register the new user-agent with the
    server again. Though, thankfully, the RFC draft, which defines the HOBA specification,
    explicitly allows for servers to register multiple CPKs to a single client account.
    As support for this authentication scheme grows and the specification is formally
    standardized, I would expect to see the other modes of authentication become very
    quickly deprecated in favor of HOBA.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了主要的安全优势，即无需在服务器上存储用户凭据的记录，即使是以安全散列格式存储。然而，这种做法的缺点是，CPK通常由浏览器在客户端机器的本地存储中存储。这意味着每次用户从不同的机器（或者甚至同一台机器上的不同网络浏览器）访问服务器时，客户端都必须再次将新的用户代理注册到服务器。幸运的是，RFC草案，该草案定义了HOBA规范，明确允许服务器将多个CPK注册到单个客户端账户。随着对这种身份验证方案的支持增长以及规范的正式标准化，我预计其他身份验证模式将很快被HOBA所取代。
- en: Authorization tokens
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权令牌
- en: One of the most commonly leveraged mechanisms for authorization is a bearer
    token. The most common mechanism for issuing these tokens is by using OAuth. However,
    while bearer tokens are typically referred to as OAuth tokens, in reality, they
    are merely provisioned by OAuth. The token itself can be defined by any standard,
    or no standard at all. Let's see how this relationship between token and token
    issuer can play out.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的授权机制之一是携带令牌。发行这些令牌最常见的方式是使用OAuth。然而，尽管携带令牌通常被称为OAuth令牌，但实际上，它们只是由OAuth提供的。令牌本身可以由任何标准定义，或者根本不定义标准。让我们看看这种令牌与令牌发行者之间的关系如何展开。
- en: OAuth token provisioning
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth令牌提供
- en: As I mentioned before, OAuth is a standard for providing clients with valid
    authentication tokens. The formal standard for how this is done is actually relatively
    brief and high level, and allows for a lot of flexibility in specific implementations.
    It was originally designed as a way to allow third-party applications to access
    a target application on a user's behalf.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，OAuth是提供客户端有效身份验证令牌的标准。这种做法的正式标准实际上相对简短且高度概括，允许在具体实现中具有很大的灵活性。它最初被设计为允许第三方应用程序代表用户访问目标应用程序。
- en: In the OAuth interaction scheme, a client must first register as a consumer
    of a resource server. In this context, a resource server is simply any server
    that contains access-restricted resources and relies on a delegate server to handle
    access control for it. During this registration process, the resource server grants
    the relevant permissions to the client to access the restricted resources in the
    future.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在OAuth交互方案中，客户端必须首先注册为资源服务器的消费者。在这个上下文中，资源服务器简单地是指任何包含受限制资源的服务器，并依赖于代理服务器来处理其访问控制。在注册过程中，资源服务器授予客户端未来访问受限制资源的相关权限。
- en: Once a client has been registered, whenever that client attempts to access the
    resource server in the future, it is prompted to acquire an **access token**.
    The client must then request an access token from an **authorization server**.
    An authorization server is a server that the resource server has registered as
    its delegate, and which implements the OAuth interaction standard. The client
    provides the authorization server any access credentials it was given by the resource
    server during the registration step.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端注册，每当该客户端尝试在未来访问资源服务器时，它都会被提示获取一个 **访问令牌**。然后，客户端必须从 **授权服务器** 请求访问令牌。授权服务器是资源服务器已注册为其代表的服务器，并实现了
    OAuth 交互标准。客户端提供在注册步骤中由资源服务器给予的任何访问凭证。
- en: 'Upon validating the access credentials, the authorization server returns an
    access token. The access token response of OAuth 2.0 forms the backbone of most
    users'' day-to-day interactions with the standard. Whenever a valid user successfully
    requests a token, they will get a response body with the following properties:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证访问凭证后，授权服务器返回一个访问令牌。OAuth 2.0 的访问令牌响应构成了大多数用户日常与标准交互的基础。每当一个有效用户成功请求令牌时，他们都会收到包含以下属性的响应体：
- en: '**access_token**: This property is required, for obvious reasons. It''s the
    value of the token string that will be returned to the resource server.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**access_token**：此属性是必需的，原因很明显。它是将被返回给资源服务器的令牌字符串的值。'
- en: '**token_type**: This indicates the specific token authorization mechanism the
    resource server will expect. In almost all cases, this will simply have a value
    of bearer.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**token_type**：这表示资源服务器将期望的具体令牌授权机制。在几乎所有情况下，此值将简单地是 bearer。'
- en: '**expires_in**:  This property, while not required, is strongly recommended.
    Access tokens should be short-lived, with the OAuth specification recommending
    a maximum lifespan of only 10 minutes for most tokens. This is a security precaution
    to reduce the risk of an exposed access token being used by a malicious actor.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expires_in**：虽然此属性不是必需的，但强烈建议使用。访问令牌应该是短暂的，OAuth 规范建议大多数令牌的最大生存期仅为 10 分钟。这是一个安全预防措施，以减少暴露的访问令牌被恶意行为者使用的风险。'
- en: '**refresh_token**: This property is only used if the access token has an expiration,
    and even then it''s optional. It specifies a refresh token that can be used by
    the client to request a new access token from the authorization server.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**refresh_token**：此属性仅在访问令牌有到期时间时使用，即使在这种情况下也是可选的。它指定了一个刷新令牌，客户端可以使用它从授权服务器请求新的访问令牌。'
- en: '**scope**: This field is used to notify a user if their set of granted permissions
    are less permissive than the set of permissions they initially requested. For
    example, if I request an access token with read, write, and update permissions,
    but the server restricts my access to only read permissions, this field would
    be used to specify the read permissions.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域**：此字段用于通知用户，如果他们所授予的权限集合比他们最初请求的权限集合更少，则使用。例如，如果我请求一个具有读取、写入和更新权限的访问令牌，但服务器只限制我的访问权限为只读，则此字段将用于指定读取权限。'
- en: Finally, the client sends a request to the resource server with the access token
    as its `Authorization` bearer token.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，客户端使用访问令牌作为其 `Authorization` 携带令牌向资源服务器发送请求。
- en: Token generation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令牌生成
- en: While OAuth specifies the interactions between a client and the corresponding
    resource and authorization servers, it says nothing about howthe `access_token`
    field is actually generated. Instead, that detail is left up to each server that
    implements or relies on OAuth. So, how are tokens generated and validated?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 OAuth 规定了客户端与相应资源及授权服务器之间的交互，但它并未说明 `access_token` 字段是如何实际生成的。相反，这一细节留给了每个实现或依赖
    OAuth 的服务器。那么，这些令牌是如何生成和验证的呢？
- en: Persisted tokens
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久令牌
- en: It's not uncommon for a token to be nothing more than a randomly generated string.
    In this token generation mechanism, there is a database shared by both the authorization
    server and the resource server, which contains all of the relevant user access
    credentials and permissions. On some predetermined schedule, tokens are randomly
    generated and then associated with each user in the database. Then, upon successful
    authentication, the authorization server looks up the current token for a given
    user and returns it as the access token. Upon authorization, the resource server
    then looks up the user in the database with that same token value and validates
    their access, and can look up any permissions they may have.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌仅仅是随机生成的字符串的情况并不少见。在这种令牌生成机制中，授权服务器和资源服务器共享一个数据库，其中包含所有相关的用户访问凭证和权限。在预定的时间表上，随机生成令牌并将其与数据库中的每个用户关联。然后，在成功认证后，授权服务器查找给定用户的当前令牌并将其作为访问令牌返回。在授权后，资源服务器随后查找数据库中具有相同令牌值的用户并验证其访问权限，并可以查找他们可能拥有的任何权限。
- en: The obvious downside to this approach is the need for a shared database and
    concurrency within that database across both the authentication and resource server.
    This approach doesn't lend itself especially well to cloud-deployed systems that
    might have dozens of concurrently running instances of the resource or authorization
    server, with multiple database instances. It's also not particularly well-suited
    to extremely high-volume applications, since the multiple database lookups can
    be extremely costly in terms of an application's responsiveness. If your system
    is relatively centralized and handles a reasonably small volume, though, it's
    certainly not a terrible choice for implementing your access token system. So,
    what's the alternative?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显缺点是需要共享数据库，并且在认证服务器和资源服务器之间在该数据库中存在并发性。这种方法并不特别适合可能同时运行数十个资源或授权服务器实例的云部署系统，这些实例具有多个数据库实例。它也不特别适合极高流量的应用程序，因为多次数据库查找可能会极大地影响应用程序的响应速度。然而，如果你的系统相对集中且处理量合理，那么在实现访问令牌系统时，这绝对不是一种糟糕的选择。那么，替代方案是什么呢？
- en: Self-encoded tokens
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自编码令牌
- en: Perhaps one of the most robust and useful token generation mechanisms is the
    self-encoded token. Self-encoded tokens are tokens whose bodies contain all of
    the information that's necessary for the resource server to authorize the bearer.
    So, when a user is authenticated to a system and granted a token by an authorization
    server, the resource server can simply inspect the body of the token to determine
    the success of the authorization request and any permissions or claims the user
    has. With the context contained entirely in the token, the resource server never
    has to access a shared database to validate the user or their permissions, thus
    saving on the orchestration of resources in a distributed environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最稳健且最有用的令牌生成机制之一是自编码令牌。自编码令牌是指其主体包含所有必要信息，以便资源服务器授权持有者的令牌。因此，当用户通过授权服务器认证并授予令牌后，资源服务器可以简单地检查令牌的主体以确定授权请求的成功以及用户拥有的任何权限或声明。由于上下文完全包含在令牌中，资源服务器无需访问共享数据库来验证用户或其权限，从而在分布式环境中节省了资源编排。
- en: Perhaps the most widely used, and widely supported, self-encoded token scheme
    is the **JSON Web Token** (**JWT**). A JWT implements the self-encoded token mechanism
    by providing a set of claims the bearer has as properties in an encoded JSON object.
    The structure of a JWT token consists of three separate components, which are
    concatenated together and separated by a period.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最广泛使用且广泛支持的自我编码令牌方案是**JSON Web Token**（JWT）。JWT通过在编码的JSON对象中提供一组作为属性声明的持有者声明来实现自编码令牌机制。JWT令牌的结构由三个独立的部分组成，这些部分连接在一起，并由句点分隔。
- en: The first of these components is a header, which is a `base-64` encoded string
    with well-known header parameters represented as a JSON object. This specifies
    the algorithm that's used for the signature (which we'll look at in just a moment)
    and the token type, which is typically just JWT.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件中的第一个是头部，它是一个`base-64`编码的字符串，其中包含作为JSON对象表示的已知头部参数。这指定了用于签名的算法（我们稍后将讨论）和令牌类型，通常是JWT。
- en: Next is the body, which is a `base-64` encoded JSON object containing the complete
    list of claims the bearer of the token has. There are a few required parameters
    in this object, such as sub (subject, or the name of the bearer) and iat (issued
    at). However, since the specification of the token body is done entirely at the
    discretion of the resource server, any number of claims can be added with any
    given values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是正文，它是一个`base-64`编码的JSON对象，包含令牌持有者拥有的完整声明列表。在这个对象中有一些必需的参数，例如sub（主题，或持有者的名称）和iat（发行时间）。然而，由于令牌正文的规范完全由资源服务器自行决定，因此可以添加任何数量的声明，并赋予任何给定的值。
- en: The final piece of a JWT is the verification signature. This is how your resource
    server will know the token came from its associated authorization server. The
    verify signature is an encrypted **hashed message authentication code** (**HMAC**),
    which is derived from the `base-64` encoded strings of the previous two sections
    combined with a secret key. If any part of the body of the token or the header
    of the token was modified, then the verification step of token authorization won't
    produce the same HMAC, and the resource server can find out whether the token
    was tampered with and is invalid. For this to work though, the resource server
    and authorization server must share the secret key between the two of them and
    use it to sign and subsequently verify any tokens passed between the two.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的最后一部分是验证签名。这是资源服务器如何知道令牌来自其关联的授权服务器的方式。验证签名是一个加密的**散列消息认证码**（**HMAC**），它是由前两个部分的`base-64`编码字符串以及一个密钥组合而成的。如果令牌的正文或头部的任何部分被修改，那么令牌授权的验证步骤将不会产生相同的HMAC，资源服务器可以找出令牌是否被篡改并且无效。然而，为了使这起作用，资源服务器和授权服务器必须在两者之间共享密钥，并使用它来签署和随后验证在两者之间传递的任何令牌。
- en: Whether the token has been determined to be valid or not, the first two components
    of the token are simply `base-64` encoded. As such, they can easily be decoded
    and read by any interested party. For this reason, it's important to never send
    private information in the body of a JWT in plain text. If confidential information
    or access credentials must be sent, they should be sent in a securely encrypted
    format, with a one-way hash when possible and secure reversible encryption otherwise.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论令牌是否被确定为有效，令牌的前两个组件仅仅是`base-64`编码的。因此，它们可以很容易地被任何感兴趣的一方解码和读取。出于这个原因，永远不要在JWT的正文以明文形式发送私人信息。如果必须发送机密信息或访问凭证，它们应该以安全加密格式发送，当可能时使用单向哈希，否则使用安全的可逆加密。
- en: Authorization in .NET Core
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的授权
- en: Now that we've explored the ins and outs of authorization on the application
    layer of the OSI stack, it's time to look at how we can leverage these features
    in our own applications. Thankfully, as was the case with enforcing SSL, enabling
    an authorization scheme on our web APIs is mostly a matter of configuration more
    than anything. For the purposes of this demo, we'll be creating an application
    which will serve as both our resource server and our authentication server. And
    as always, we'll be taking some shortcuts with respect to error-handling and robust
    application design, for simplicity's sake.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了OSI堆栈应用程序层授权的方方面面，是时候看看我们如何可以利用这些特性在我们的应用程序中。幸运的是，正如强制执行SSL一样，在我们的Web
    API上启用授权方案主要是配置问题，而不是其他。为了这个演示的目的，我们将创建一个应用程序，它将作为我们的资源服务器和认证服务器。而且，一如既往地，我们将为了简单起见在错误处理和健壮的应用程序设计方面采取一些捷径。
- en: The AuthorizeAttribute
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AuthorizeAttribute`'
- en: 'The first thing we''ll want to do is designate which resources we will need
    the authorization to access. We''ll deal with the actual process of authorizing
    a user later. To designate restricted resources, we apply `AuthorizeAttribute`.
    This attribute is designated as suitable for methods or classes. This means we
    can apply it directly to our application''s restricted endpoint or to the entire
    controller. So, let''s look at the impact of each approach. First, let''s create
    our application with the CLI command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要确定哪些资源需要授权访问。稍后我们将处理授权用户的实际过程。为了指定受限资源，我们应用`AuthorizeAttribute`。这个属性被指定为适用于方法或类。这意味着我们可以直接将其应用于我们应用程序的受限端点或整个控制器。因此，让我们看看每种方法的影响。首先，让我们使用CLI命令创建我们的应用程序：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we''ll navigate to the `ValuesController.cs` file, rename it `AuthController.cs`,
    and then modify it to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将导航到`ValuesController.cs`文件，将其重命名为`AuthController.cs`，然后修改如下：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We want to allow users to `POST` their credentials when they authenticate,
    but they''ll simply `GET` our top secret message. Here, I''ve created a simple
    `Credentials` class to serve as the message body of our `POST` request. This is
    just for the convenience of encapsulating both the `username` and `password` strings
    in a single container class. Now, let''s look at different approaches for applying
    the `Authorize` attribute. One approach would be to explicitly flag a given endpoint
    as needing authorization. In this case, this would be the `GetRestrictedResource()`
    method. So, we can apply the attribute above or below the `[HttpGet]` attribute
    and then that''s that! Lets, have a look at the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望允许用户在认证时`POST`他们的凭证，但他们将简单地`GET`我们的绝密信息。在这里，我创建了一个简单的`Credentials`类，作为我们`POST`请求的消息体。这只是为了方便将`username`和`password`字符串封装在单个容器类中。现在，让我们看看应用`Authorize`属性的不同方法。一种方法是将特定的端点显式标记为需要授权。在这种情况下，这将是我们`GetRestrictedResource()`方法。因此，我们可以在`[HttpGet]`属性之上或之下应用该属性，然后就这样！让我们看看以下代码：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, I''m sure you could imagine a scenario where a controller has dozens
    of endpoints, each of which requiring authorization. In that scenario, you could
    simply apply the `Authorize` attribute to the controller class itself, like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我相信你可以想象一个场景，其中控制器有数十个端点，每个端点都需要授权。在这种情况下，你可以简单地将`Authorize`属性应用于控制器类本身，如下所示：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By applying the attribute to the controller, it is automatically applied to
    every endpoint defined in that controller. Of course, in our current controller,
    we''ll need some way of designating our `AuthenticateUser()` method as not needing
    authorization (after all, how would a user become authorized if they must first
    be authorized?). To do this, we can override the `Authorize` attribute that''s applied
    at the controller level with the `AllowAnonymous` attribute applied at the method
    level:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将属性应用于控制器，它将自动应用于该控制器中定义的每个端点。当然，在我们的当前控制器中，我们需要某种方式来指定我们的`AuthenticateUser()`方法不需要授权（毕竟，如果用户必须首先被授权，他们如何成为授权用户呢？）。为此，我们可以用方法级别的`AllowAnonymous`属性覆盖控制器级别应用的`Authorize`属性：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This attribute will always override any `Authorize` attributes that would otherwise
    apply to the current method. For that reason, it's always important to make sure
    you are only ever applying the `AllowAnonymous` attribute where it is absolutely
    necessary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性将始终覆盖应用于当前方法的任何`Authorize`属性。因此，始终确保你只在绝对必要时应用`AllowAnonymous`属性是非常重要的。
- en: Authorization middleware
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权中间件
- en: Now that we've designated which of our resources require to use authorization
    to be accessed, it's time to see what that authorization step looks like in our
    code. For this application, we'll be taking advantage of JWT bearer token authentication.
    To leverage this, we will be going to our `Startup.cs` file and modifying the
    services we've configured to use the appropriate authentication scheme.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了哪些资源需要使用授权来访问，是时候看看在我们的代码中这个授权步骤看起来是什么样子了。对于这个应用程序，我们将利用JWT令牌认证。为了利用这一点，我们将进入我们的`Startup.cs`文件，并修改我们配置的服务以使用适当的认证方案。
- en: 'Thanks to its open source distribution and wide support, the `Microsoft.AspNetCore`
    and `Microsoft.IdentityModel` namespaces support JWT token libraries right out
    of the box. This will make defining our authentication behavior much easier. We''ll
    invoke the `AddAuthentication()` method on `IServicesCollection` and apply the
    default JWT bearer authentication scheme using the `JwtBeareDefaults` library
    class. Let''s have a look at the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其开源分布和广泛的支持，`Microsoft.AspNetCore`和`Microsoft.IdentityModel`命名空间直接支持JWT令牌库。这将使定义我们的认证行为变得更加容易。我们将在`IServicesCollection`上调用`AddAuthentication()`方法，并使用`JwtBeareDefaults`库类应用默认的JWT令牌认证方案。让我们看看以下代码：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This `AddAuthentication()` method is where you can define any custom access
    policies you want to apply to a given `Authorize` endpoint. For example, if you
    wanted to define a policy for a role-based authentication scheme, you could define
    a policy as requiring the `Manager` privileges by adding it as an option to your
    `AddAuthentication()` middleware:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`AddAuthentication()`方法是你可以在给定的`Authorize`端点上定义任何自定义访问策略的地方。例如，如果你想为基于角色的认证方案定义一个策略，你可以通过将其作为选项添加到`AddAuthentication()`中间件来定义一个需要`Manager`权限的策略：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, for any endpoints for which you wanted to restrict access to managers,
    simply define that access policy in the `Authorize` attribute, like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于任何你想要限制管理员访问的端点，只需在`Authorize`属性中定义该访问策略，如下所示：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This can be cumbersome when you have a wide variety of access policies and need
    many to be applied at once. In that case, you'll often find yourself writing your
    own extension methods to the `IServicesCollection` class, and invoking them directly.
    For this example, though, we've already got an extension method to customize our
    authorization, provided by the `Microsoft.AspNetCore.Authentication.JwtBearer`
    namespace.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有许多不同的访问策略并且需要一次性应用许多策略时，这可能会变得很麻烦。在这种情况下，你通常会发现自己正在编写自己的`IServicesCollection`类的扩展方法，并直接调用它们。然而，对于这个例子，我们已经有一个来自`Microsoft.AspNetCore.Authentication.JwtBearer`命名空间的扩展方法来定制我们的授权。
- en: Simply defining our authentication scheme to the JWT default means that any
    endpoint with an `Authorize` directive will invoke .NET's JWT validation code.
    We don't have to write anything else for our application to pull the token value
    out of the `Authorization` header, validate its signature against our own record
    of the private key, and then either approve the request and continue to the method,
    or reject it with a 401 response. This is all done by defining `JwtBearerDefaults.AuthenticationScheme`
    in our `AddAuthentication()` method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将我们的认证方案定义为JWT默认值，这意味着任何带有`Authorize`指令的端点都会调用.NET的JWT验证代码。我们不需要为我们的应用程序编写任何其他代码来从`Authorization`头中提取令牌值，将其签名与我们的私钥记录进行验证，然后批准请求继续到方法，或者以401响应拒绝它。所有这些操作都是通过在`AddAuthentication()`方法中定义`JwtBearerDefaults.AuthenticationScheme`来完成的。
- en: 'The only remaining step we have to take to enable our authentication is to
    define what should be considered a valid token. We''ll do that by using the `AddJwtBearer()`
    extension method. This method allows us to define an action delegate to configure
    the options we want our `Authentication` code to use when validating tokens. For
    this sample code, I''ve moved the definition of a signing key, token issuer, and
    token audience to a static utility class called `SecurityService`. This is just
    to make it easier to get the same values for our token validation options and
    our token generation code, which we''ll look at in just a moment. But if you''re
    curious, all that class is doing is returning consistent values for some key components
    of our token:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要采取的唯一剩余步骤是定义什么应该被视为有效的令牌。我们将通过使用`AddJwtBearer()`扩展方法来完成这项工作。此方法允许我们定义一个动作委托来配置我们希望我们的`Authentication`代码在验证令牌时使用的选项。对于这个示例代码，我已经将签名密钥、令牌发行者和令牌受众的定义移动到了一个名为`SecurityService`的静态实用工具类中。这样做只是为了使获取相同的值以供我们的令牌验证选项和令牌生成代码更容易，我们将在稍后查看这些代码。但如果你好奇，这个类所做的只是为我们的令牌的一些关键组件返回一致的价值：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, by using this class for our shared symmetric key, issuer, and audience
    generation, we can configure those aspects of our token as being necessary for
    authorizing a valid user. Simply apply them to the `TokenValidationParameters`
    class of `JwtBearerOptions`, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用这个类来生成我们的共享对称密钥、发行者和受众，我们可以配置令牌的这些方面，使其成为授权有效用户所必需的。只需将它们应用到`JwtBearerOptions`的`TokenValidationParameters`类中，如下所示：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this configuration, you can see that our application is responsible for
    determining the validity of a bearer token based on the claims it contains. But
    thanks to the extensions available in the JWT utility libraries, defining those
    parameters becomes very easy!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种配置，你可以看到我们的应用程序负责根据它包含的声明来确定携带令牌的有效性。但是，多亏了JWT实用工具库中可用的扩展，定义这些参数变得非常简单！
- en: 'Finally, as with any middleware configured in the `ConfigureServices` method,
    we''ll need to tell our application to leverage it by adding the following line
    to our `Configure` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像在`ConfigureServices`方法中配置的任何中间件一样，我们需要告诉我们的应用程序通过在`Configure`方法中添加以下行来利用它：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And now, if you run the application and attempt to access the `/auth/secret`
    endpoint, you''ll be given a 401 response, with the `WWW-Authenticate` message
    indicating the expected authentication scheme:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行应用程序并尝试访问`/auth/secret`端点，你会收到一个401响应，其中`WWW-Authenticate`消息指示预期的认证方案：
- en: '![](img/b565513a-6916-49b9-b58b-86b798ddb0cb.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b565513a-6916-49b9-b58b-86b798ddb0cb.png)'
- en: Now, all that's left is giving our users a token. Let's look at how to do that
    in our `AuthController` class using the JWT libraries for .NET.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的只是给我们的用户提供一个令牌。让我们看看如何在我们的`AuthController`类中使用JWT库来做到这一点。
- en: Generating a token
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成令牌
- en: 'With our `/auth/secret` endpoint safely locked away behind the authorize attribute,
    we need some way of authenticating and authorizing a user. For that, we''ll use
    the `AuthenticateUser()` method, which is configured with the `AllowAnonymous`
    attribute to enable anyone to attempt to log in. The first thing we''ll need is
    a list of users. For this, I''ve created a simple dictionary of `username:password`
    combinations in a `user_vault.json` file, which we can access with a static `UserVault`
    class. The `UserVault` class then exposes a simple method for checking whether
    a `username:password` combination exists in our user database. So, let''s let `user_vault.json`
    be defined as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`/auth/secret`端点安全地锁在`authorize`属性后面之后，我们需要一种方法来验证和授权用户。为此，我们将使用`AuthenticateUser()`方法，该方法配置了`AllowAnonymous`属性以允许任何人尝试登录。我们首先需要的是一个用户列表。为此，我创建了一个简单的`username:password`组合字典，存储在`user_vault.json`文件中，我们可以通过静态的`UserVault`类来访问它。然后，`UserVault`类公开了一个简单的方法来检查我们的用户数据库中是否存在`username:password`组合。所以，让我们让`user_vault.json`定义如下：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This gives us three valid users that we can test with. Our corresponding `UserVault`
    class allows us to check that by first being initialized with a static constructor:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了三个有效的用户，我们可以用它们进行测试。我们的`UserVault`类允许我们通过首先使用静态构造函数初始化来检查这一点：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, with an in-memory representation of our `user_vault.json` file, we can
    check against our private dictionary for any `username:password` pair with a `ContainsCredentials()`
    method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用我们`user_vault.json`文件的内存表示，我们可以通过`ContainsCredentials()`方法检查我们的私有字典中是否存在任何`username:password`对：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, now that we can check for a user''s presence in our user database, let''s
    go ahead and define the authentication for our application. The first thing we''ll
    need to do is build the key details that our authorization code will be expecting
    from any tokens we''ve issued. So, we''ll need to use the same security key that
    we''ve configured our authentication middleware to expect. We''ll also give the
    user a basic `Identity` using the `ClaimsIdentity` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们能够检查用户是否在我们的用户数据库中，让我们继续定义我们应用程序的认证。我们首先需要做的是构建我们的授权代码将期望从任何我们签发的令牌中获取的关键细节。因此，我们需要使用我们配置认证中间件期望的相同安全密钥。我们还将使用`ClaimsIdentity`类给用户一个基本的`Identity`：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `SigningCredentials` class in this code is a simple wrapper class that handles
    the details of hashing a given security key using the designated hash algorithm
    (in this case, HMAC SHA-256). This class is then used to generate the signature
    key component of the resulting JWT token. Once we've got that, we're ready to
    build our JWT token. To do that, we'll be using an instance of the `JwtSecurityTokenHandler`
    class. This is essentially a factory class that is used to produce well-formed
    JWT tokens with the configuration details passed to it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`SigningCredentials`类是一个简单的包装类，它处理使用指定的哈希算法（在这种情况下为HMAC SHA-256）对给定的安全密钥进行哈希处理的细节。然后，这个类被用来生成结果JWT令牌的签名密钥组件。一旦我们有了这个，我们就可以构建我们的JWT令牌。为此，我们将使用`JwtSecurityTokenHandler`类的实例。这本质上是一个工厂类，用于使用传递给它的配置详细信息生成格式良好的JWT令牌。
- en: Applying user claims
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用用户声明
- en: 'For the sake of demonstration, we''ll be applying a few arbitrary claims to
    our token, just so we can inspect the result and see how those claims are applied
    and displayed in a well-formed token. We''ve got a simple helper class for that
    which returns a list of basic `Claim` instances:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示的目的，我们将对我们的令牌应用一些任意的声明，这样我们就可以检查结果并看到这些声明是如何在格式良好的令牌中应用和显示的。为此，我们有一个简单的辅助类，它返回一个基本的`Claim`实例列表：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, now that we''ve got all of our claims defined, we can apply them to the `ClaimsIdentity`
    that we create for the user with the following line of code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经定义了所有的声明，我们可以将这些声明应用到我们为用户创建的`ClaimsIdentity`上，如下代码所示：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will give us the flexibility of restricting access to individual resources
    based on the permissions a user has on a case-by-case basis. The `User` property
    of `HttpContext` for any given request is an instance of a `ClaimsPrinciple`.
    Thus, we can inspect a user's claims through the `HttpContext.User.Claims` property.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够根据用户在特定情况下的权限来限制对单个资源的访问。对于任何给定的请求，`HttpContext`的`User`属性是一个`ClaimsPrinciple`的实例。因此，我们可以通过`HttpContext.User.Claims`属性检查用户的声明。
- en: 'When we secure an endpoint behind an authorize filter, any user claims specified
    by the authentication mechanism (in this case, JWT) will be applied to the `HttpContext.User.Claims`
    property. With that in mind, we can restrict access to our secret endpoint by
    inspecting our user''s `Claims` property and confirming that they contain the
    claims we''re looking for. Simply modify your  `GetRestrictedResource` method
    to examine the `Type` parameter of your user claims, and confirm that the user
    has at least one claim of the valid claim types returned by `GetClaims`, as shown
    here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用授权过滤器保护端点时，由认证机制（在这种情况下，JWT）指定的任何用户声明都将应用于`HttpContext.User.Claims`属性。考虑到这一点，我们可以通过检查用户的`Claims`属性并确认它们包含我们正在寻找的声明来限制对我们的秘密端点的访问。只需修改你的`GetRestrictedResource`方法，检查用户声明的`Type`参数，并确认用户至少有一个由`GetClaims`返回的有效声明类型，如下所示：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With that, our user is defined, their claims are specified, and our resource
    is restricted to users who have those claims. And since our signing credentials
    are configured to use the same symmetric key as the resource server, we''re ready
    to build out our token. This is easily done with the `JwtSecurityTokenHandler`,
    and `SecurityTokenDescriptor` classes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经定义了用户，指定了他们的声明，并将我们的资源限制为具有那些声明的用户。由于我们的签名凭证配置为使用与资源服务器相同的对称密钥，我们准备好构建我们的令牌。这可以通过`JwtSecurityTokenHandler`和`SecurityTokenDescriptor`类轻松完成：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, all that''s left to do is write the token to our output for our users
    to apply to their subsequent requests. If you want to implement a fully compliant
    OAuth server, your response body and exception handling would need to adhere to
    the standard defined by OAuth 2.0, with your token returned as a part of a larger
    response body. Since we''re just demonstrating the high-level workflow though,
    I''ll leave that additional research to you. Instead, our output will just be
    the raw JWT token. So, with everything we''ve just done to fill in the blanks,
    the shell of our authentication method should look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只剩下将令牌写入我们的输出，供用户在后续请求中应用。如果你想实现一个完全符合OAuth标准的服务器，你的响应体和异常处理需要遵循OAuth 2.0定义的标准，你的令牌作为更大响应体的一部分返回。由于我们只是在演示高级工作流程，我将这项额外的研究留给你。相反，我们的输出将只是原始的JWT令牌。所以，通过我们刚刚完成的所有操作来填补空白，我们的认证方法外壳应该看起来像这样：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we''re ready to put it all together. Run the application, post a request
    to the auth endpoint with any of the credentials in `user_vault.json` , and you
    should be greeted with a token:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将所有这些整合起来。运行应用程序，向认证端点发送一个请求，使用`user_vault.json`中的任何凭证，你应该会收到一个令牌：
- en: '![](img/e5ee7a7b-ee40-46af-8656-75a4fc31d624.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5ee7a7b-ee40-46af-8656-75a4fc31d624.png)'
- en: 'Next, make a request to the secret endpoint, supplying your newly retrieved
    token. To do this, go to the Authorization tab of Postman (or Insomnia) and set
    the Authorization Type in the drop-down list to the Bearer Token option. Then,
    paste in your newly acquired token into the input box, and send your request.
    If you followed all the steps here, you should get our secret message returned
    with a 200 status code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向秘密端点发送一个请求，提供你新检索到的令牌。为此，转到Postman（或Insomnia）的授权选项卡，并将下拉列表中的授权类型设置为Bearer
    Token选项。然后，将你新获得的令牌粘贴到输入框中，并发送请求。如果你遵循了这里的所有步骤，你应该会收到带有200状态码的秘密消息：
- en: '![](img/e54e94ad-ed86-4c89-bf03-f8ef20c82954.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e54e94ad-ed86-4c89-bf03-f8ef20c82954.png)'
- en: And just like that, you've implemented and applied a complete authentication
    and authorization scheme within .NET core, which it required a minimum amount
    of custom code on your part.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你已经在.NET core中实现了并应用了一个完整的认证和授权方案，这需要你最少量的自定义代码。
- en: Before we move on, however, I would like to firmly establish that the coding
    practices used here are for demonstration purposes only*. *My goal was simply
    to illustrate the conceptual flow and basic patterns for an authentication/authorization
    framework in .NET Core. If you find yourself implementing user access in any of
    your applications, you have a strong responsibility to ensure the security of
    their private access credentials, and that should never be taken lightly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，然而，我想明确指出，这里使用的编码实践仅用于演示目的**。**我的目标仅仅是展示.NET Core中认证/授权框架的概念流程和基本模式。如果你发现自己正在任何应用程序中实现用户访问，你有责任确保他们的私有访问凭证的安全，这一点绝不能轻视。
- en: With that said, we're now in a position to look at other ways we can improve
    the performance and versatility of our application layer network code. In the
    next chapter, we'll be taking a close look at caching strategies and patterns
    in .NET Core.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们现在可以探讨其他方法来提高我们应用层网络代码的性能和灵活性。在下一章中，我们将仔细研究.NET Core中的缓存策略和模式。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered every aspect of authentication and authorization
    at the application layer. First, we learned about the key but subtle distinction
    between authentication and authorization. We looked at the HTTP standard header
    that allows applications to perform both of those tasks to control access to restricted
    resources. Then, we learned about each of the valid authentication schemes supported
    by the standard `Authorization` header.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了应用层认证和授权的各个方面。首先，我们学习了认证和授权之间关键但细微的区别。我们研究了允许应用程序执行这两项任务以控制对受限资源访问的HTTP标准头。然后，我们学习了标准`Authorization`头支持的每个有效认证方案。
- en: We saw the security risks and ease of implementation that come along with basic
    authentication. We looked at how a bearer token authentication could alleviate
    some of the security risks associated with basic authentication without necessarily
    adding much more in the way of complexity. Finally, we learned about the complexities
    and nuances of the Digest authentication mechanism. Before moving on, we also
    took the time to consider how authorization might be handled in the future with
    something like the HOBA scheme.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了基本认证带来的安全风险和实现上的便捷。我们研究了载体令牌认证如何减轻与基本认证相关的某些安全风险，而无需增加太多复杂性。最后，我们学习了摘要认证机制的复杂性和细微差别。在继续之前，我们还花时间考虑了未来可能通过类似HOBA方案来处理授权的方式。
- en: Next, we took a deep dive into bearer tokens. We saw how the OAuth standard
    defines an interaction mechanism for accessing and provisioning tokens. Then,
    we looked at how those tokens can be generated and leveraged by a resource server.
    Finally, we tied this all together by learning how to implement these features
    in .NET Core. Now, we're ready to look at performance improvements and resiliency
    strategies through caching, which we'll be exploring in the next chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入探讨了载体令牌。我们了解了OAuth标准如何定义一个用于访问和提供令牌的交互机制。然后，我们研究了这些令牌如何由资源服务器生成和利用。最后，我们通过学习如何在.NET
    Core中实现这些功能，将所有这些内容串联起来。现在，我们准备通过缓存来查看性能改进和弹性策略，这些内容将在下一章中进行探讨。
- en: Questions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between authentication and authorization? How do they
    apply to access control for web-based resources?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证和授权之间有什么区别？它们是如何应用于基于Web资源的访问控制的？
- en: What are the valid authentication mechanisms for the authorize HTTP header?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于授权HTTP头，哪些是有效的认证机制？
- en: What is HOBA? What is the primary advantage it has over other authentication
    schemes?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HOBA是什么？它相对于其他认证方案的主要优势是什么？
- en: What is a bearer token? How is it used for authentication or authorization?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 载体令牌是什么？它是如何用于认证或授权的？
- en: What is OAuth? How does it relate to standard authorization techniques?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth是什么？它与标准授权技术有何关联？
- en: What is a self-encoded token?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是自编码令牌？
- en: What is a JWT? How is it used?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT是什么？它是如何使用的？
- en: Further reading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information about modern authentication techniques, I would strongly
    recommend reading *Mastering OAuth 2.0* by *Charles Bihis*. It's a relatively
    short read, but provides an extensive exploration of the standard. You can find
    it through Packt, here: [https://www.packtpub.com/application-development/mastering-oauth-2.](https://www.packtpub.com/application-development/mastering-oauth-2)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 关于现代认证技术，我强烈推荐阅读*Mastering OAuth 2.0*一书，作者是*Charles Bihis*。这是一本相对简短的读物，但提供了对标准的广泛探索。您可以通过Packt在这里找到它：[https://www.packtpub.com/application-development/mastering-oauth-2](https://www.packtpub.com/application-development/mastering-oauth-2)
- en: Alternatively, if you have designs to leverage an OAuth system within your own
    software and want a more hands-on approach to the subject, I would recommend the
    *OAuth 2.0 Cookbook* by *Adolfo Eloy Nascimento*. It's also available through
    Packt, here: [https://www.packtpub.com/virtualization-and-cloud/oauth-20-cookbook.](https://www.packtpub.com/virtualization-and-cloud/oauth-20-cookbook)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您打算在自己的软件中利用OAuth系统，并希望对这个主题有更实际的了解，我推荐阅读由**Adolfo Eloy Nascimento**所著的《*OAuth
    2.0 烹饪书*》。您也可以通过Packt购买，链接如下： [https://www.packtpub.com/virtualization-and-cloud/oauth-20-cookbook.](https://www.packtpub.com/virtualization-and-cloud/oauth-20-cookbook)
