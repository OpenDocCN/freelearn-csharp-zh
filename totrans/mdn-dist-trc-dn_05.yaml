- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Configuration and Control Plane
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和控制平面
- en: 'In the previous chapters, we learned how to enable auto-instrumentation with
    a few lines of code and leverage collected telemetry to debug issues and monitor
    performance. Auto-collected traces and metrics provide the basis for your observability
    solution, but they are rarely sufficient without an application context. In this
    chapter, we’ll learn how to customize telemetry collection – enrich, adjust, or
    control its volume. We will dive into the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何通过几行代码启用自动检测，并利用收集到的遥测数据来调试问题和监控性能。自动收集的跟踪信息和指标是您可观察性解决方案的基础，但它们通常不足以在没有应用程序上下文的情况下使用。在本章中，我们将学习如何自定义遥测收集——丰富、调整或控制其数量。我们将深入研究以下主题：
- en: Controlling costs with sampling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过采样控制成本
- en: Enriching and filtering telemetry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富和过滤遥测
- en: Customizing context propagation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义上下文传播
- en: Building a processing pipeline with the OpenTelemetry Collector
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry Collector 构建处理管道
- en: By the end of this chapter, you will be able to choose a sampling strategy and
    configure it in your system, efficiently enrich auto-generated traces with custom
    attributes, and propagate your context between services. We’ll see also how to
    suppress noisy spans and metrics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够选择采样策略并在你的系统中配置它，有效地使用自定义属性丰富自动生成的跟踪信息，并在服务之间传播你的上下文。我们还将了解如何抑制嘈杂的跨度（span）和指标。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter is available in the book’s repository on GitHub at
    [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5),
    which has the following structure:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上的书籍仓库中找到，网址为 [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5)，其结构如下：
- en: The `sampling` application contains sampling code snippets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sampling` 应用程序包含采样代码片段'
- en: The `memes` application is an improved version of the meme service from [*Chapter
    2*](B19423_02.xhtml#_idTextAnchor038), *Native Monitoring in .NET*, which contains
    enrichment and context propagation examples
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memes` 应用程序是来自 [*第2章*](B19423_02.xhtml#_idTextAnchor038)，*在 .NET 中进行原生监控*
    的 meme 服务的改进版本，其中包含丰富和上下文传播的示例'
- en: 'To run samples and perform analysis, we’ll need the following tools:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行示例和执行分析，我们需要以下工具：
- en: .NET SDK 7.0 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK 7.0 或更高版本
- en: Docker and `docker-compose`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 和 `docker-compose`
- en: Controlling costs with sampling
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过采样控制成本
- en: Tracing all operations gives us the ability to debug individual issues in the
    system, even very rare ones, but it could be impractical from a performance and
    telemetry storage perspective.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪所有操作使我们能够调试系统中的单个问题，即使是很少见的问题，但从性能和遥测存储的角度来看，这可能是不切实际的。
- en: The performance impact of optimized and succinct instrumentation is usually
    low, but telemetry ingestion, processing, storage, queries, and other observability
    experiences could be very costly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 优化和简洁的检测对性能的影响通常很低，但遥测摄入、处理、存储、查询和其他可观察性体验可能会非常昂贵。
- en: Observability vendors’ pricing models vary – some charge for the volume of ingested
    traces, others for the number of events, traces, or hosts reporting data. The
    ingestion cost usually includes retaining telemetry for 1 to 3 months. Data retrieval
    and scanning are also billed by some vendors. Essentially, costs associated with
    sending and retrieving telemetry grow along with telemetry volume.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性供应商的定价模式各不相同——一些按摄入的跟踪信息量收费，另一些按事件、跟踪信息或报告数据的宿主机数量收费。摄入成本通常包括保留遥测数据1到3个月。一些供应商还按数据检索和扫描收费。本质上，与发送和检索遥测相关的成本会随着遥测数据量的增加而增长。
- en: Realistically, we’re going to be interested in a very small fraction of traces
    – ones that record failures, long requests, and other rare cases. We may also
    query a subset of traces for analytics purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可能只对一小部分跟踪信息感兴趣——记录失败、长时间请求和其他罕见情况的信息。我们也可能为了分析目的查询跟踪信息的一个子集。
- en: So, collecting all traces comes at a relatively small performance hit and could
    be reasonable, but storing all of them on an observability backend is rarely justified.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，收集所有跟踪信息带来的性能影响相对较小，可能是合理的，但将所有这些信息存储在可观察性后端通常是不合理的。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might consider using traces as audit logs and then need every operation
    to be recorded. However, we need traces to debug and resolve incidents in production,
    which implies a fast query time, potentially short retention, and traces being
    accessible by every on-call person. Audit logs usually need a different privacy
    and retention policy. They also don’t necessarily require fast and random access.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会考虑将跟踪用作审计日志，并需要记录每个操作。然而，我们需要跟踪来调试和解决生产中的事件，这意味着需要快速查询时间，可能短的保留时间，并且跟踪对每个值班人员都可用。审计日志通常需要不同的隐私和保留策略。它们也不一定需要快速和随机的访问。
- en: '**Sampling** is a technique that allows recording a subset of traces, thus
    reducing storage costs. There are two main approaches to sampling: **head-based**
    and **tail-based**.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**采样**是一种允许记录跟踪子集的技术，从而降低存储成本。主要有两种采样方法：**基于头的**和**基于尾的**。'
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Both head-based and tail-based sampling rely on trace context propagation that
    needs to happen regardless of the sampling decision.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基于头的采样和基于尾的采样都依赖于跟踪上下文传播，无论采样决策如何都需要发生。
- en: Let’s take a closer look at different sampling approaches and see how and when
    to apply them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看不同的采样方法，并了解何时以及如何应用它们。
- en: Head-based sampling
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于头的采样
- en: With head-based sampling, the decision to record or not record a trace is done
    when the trace is started by the application process and is usually random (or
    based on information available beforehand). The assumption here is that under
    high-scale problems that need attention happen frequently enough to record at
    least some occurrences. In other words, problems that are never recorded are too
    rare and are likely less important. “Too rare” and “frequently enough” here totally
    depend on application requirements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于头的采样时，记录或不记录跟踪的决定是在应用程序进程启动跟踪时做出的，通常是随机的（或基于事先可用的信息）。这里的假设是，在需要关注的高规模问题发生频繁到足以记录至少一些发生的情况。换句话说，从未被记录的问题太罕见，可能不太重要。“太罕见”和“频繁到足以”在这里完全取决于应用程序需求。
- en: Head-based sampling algorithms try to be consistent so that we can capture all
    spans or none of them in any trace. It’s achieved by either following upstream
    sampling decisions or making independent, but consistent, decisions on each service.
    Let’s learn more about these approaches and also check how we can implement custom
    sampling solutions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基于头的采样算法试图保持一致性，以便我们可以在任何跟踪中捕获所有跨度或一个都不捕获。这是通过遵循上游采样决策或在每个服务上做出独立但一致的决策来实现的。让我们更深入地了解这些方法，并检查我们如何实现自定义采样解决方案。
- en: Parent-based sampling
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父级采样
- en: With the `traceparent`. For example, as we saw in [*Chapter 1*](B19423_01.xhtml#_idTextAnchor016),
    *Observability Needs of Modern Applications*, `traceparent` with `00-trace1-span1-01`
    indicates that upstream services recorded this span, and `00-trace2-span2-00`
    indicates that the span was not recorded. To enable this behavior in OpenTelemetry,
    you can use `ParentBasedSampler`. When all services follow the parent decision,
    the sampling probability (or percentage or recorded traces) configured on the
    first component applies to all downstream services.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`traceparent`。例如，正如我们在[*第一章*](B19423_01.xhtml#_idTextAnchor016)中看到的，“现代应用程序的可观察性需求”，`traceparent`中的`00-trace1-span1-01`表示上游服务记录了这个跨度，而`00-trace2-span2-00`表示这个跨度没有被记录。要在OpenTelemetry中启用此行为，你可以使用`ParentBasedSampler`。当所有服务遵循父决策时，在第一个组件上配置的采样概率（或百分比或记录的跟踪）适用于所有下游服务。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With using parent-based sampling, the component that makes decision needs to
    be fully trusted – if it starts to record all traces, it might overload your telemetry
    collection pipeline and could cause your observability backend costs to skyrocket.
    You would normally make sampling decisions on your API gateway or frontend and
    would never trust sampling decisions coming from an external client.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于父级的采样时，做出决策的组件需要完全信任——如果它开始记录所有跟踪，可能会超载你的遥测收集管道，并可能导致你的可观察性后端成本激增。你通常会在你的API网关或前端做出采样决策，并且永远不会信任来自外部客户端的采样决策。
- en: The root component still needs to make independent sampling decision. Even though
    this decision can be random and other services would follow, it’s a good idea
    to stick to OpenTelemetry (or your observability vendor) sampling algorithms and
    keep them consistent across the system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根本组件仍然需要做出独立的采样决策。即使这个决策可以是随机的，其他服务会跟随，但坚持使用OpenTelemetry（或你的可观察性供应商）的采样算法并在整个系统中保持一致性是个好主意。
- en: Probability sampling
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概率采样
- en: Another approach involves making a sampling decision on every service but doing
    it consistently, so `trace` that’s recorded on one service would be recorded on
    another if they have the same sampling rate configured.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在每个服务上做出采样决策，但保持一致性，因此在一个服务上记录的 `trace` 如果它们配置了相同的采样率，也会在另一个服务上记录。
- en: To achieve this, the `trace-id`. If the score is smaller than the probability,
    the span is recorded, otherwise, it’s dropped.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，使用 `trace-id`。如果分数小于概率，则跨度将被记录，否则将被丢弃。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Probability sampling reduces your costs by only recording a fraction of the
    traces. Unexpected loads or bursts of traffic result in prorated growth in the
    volume of recorded traces. OpenTelemetry for .NET does not support a fixed-rate
    sampler out of the box, but you can configure the collector to do it or your observability
    vendor may provide one.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 概率采样通过仅记录部分跟踪来降低成本。意外的负载或流量激增会导致记录的跟踪量按比例增长。OpenTelemetry for .NET 默认不支持固定速率采样器，但你可以配置收集器来执行此操作，或者你的可观察性供应商可能提供一种方法。
- en: 'Probability sampling is implemented in OpenTelemetry with `TraceIdRatioBasedSampler`
    and can be configured with the `SetSampler` method on `TracerProviderBuilder`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 概率采样在 OpenTelemetry 中通过 `TraceIdRatioBasedSampler` 实现，并且可以通过在 `TracerProviderBuilder`
    上的 `SetSampler` 方法进行配置：
- en: Program.cs
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs)'
- en: We set the probability to `0.1` in this example, which means that 10% of all
    traces will be recorded.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将概率设置为 `0.1`，这意味着 10% 的所有跟踪将被记录。
- en: 'And if we want to configure parent-based sampling on downstream components,
    we should set an instance of `ParentBasedSampler` instead, as shown in the following
    example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在下游组件上配置基于父级的采样，我们应该设置 `ParentBasedSampler` 的一个实例，如下面的示例所示：
- en: Program.cs
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs)'
- en: 'We need to provide a sampler that’s used when there is no parent trace context
    – in this example, we’re sampling out all the requests that come without `traceparent`.
    We could customize parent-based samplers further – set samplers to handle different
    cases: when the parent is remote or local, and whether the parent is recorded
    or not.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个采样器，用于在没有父级跟踪上下文的情况下使用 - 在这个例子中，我们正在采样所有不带 `traceparent` 的请求。我们可以进一步自定义基于父级的采样器
    - 设置采样器来处理不同的情况：当父级是远程或本地时，以及父级是否被记录。
- en: Consistent sampling
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一致采样
- en: Assuming all services have the same sampling probability configured, all spans
    in a trace will be recorded or dropped consistently – there will be no partial
    traces. However, using the same rate for all services is not always practical.
    You might want to configure higher sampling probability on a new service, or for
    one that has a small load. We can do it using a probability sampler by configuring
    it to different rates on different services.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有服务都配置了相同的采样概率，一个跟踪中的所有跨度将一致地被记录或丢弃 - 将不会有部分跟踪。然而，对所有服务使用相同的比率并不总是实用的。你可能希望为新服务或负载较小的服务配置更高的采样概率。我们可以通过在服务上配置不同的比率来实现这一点。
- en: 'As a result, we should expect that some tracers will be recorded partially.
    *Figure 5**.1* shows an example of a partial trace:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该预期一些跟踪器将被部分记录。*图 5**.1* 展示了一个部分跟踪的示例：
- en: '![Figure 5.1 – Services with different sampling probabilities](img/B19423_05_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 - 具有不同采样概率的服务](img/B19423_05_01.jpg)'
- en: Figure 5.1 – Services with different sampling probabilities
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 具有不同采样概率的服务
- en: Service A starts a trace – it generates trace-id and makes a sampling decision
    by calculating the score and comparing it to the sampling probability configured
    on the service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 服务 A 开始跟踪 - 它生成跟踪 ID 并通过计算分数并与服务上配置的采样概率进行比较来做出采样决策。
- en: Let’s say the score is `0.1` – it’s smaller than the probability (`0.2`), so
    the request is sampled in, and we should record the corresponding span and its
    local children. Then `0.01`. **Service B** calculates the score – it’s the same,
    so the decision is to not record the span or its local children. But then **Service
    B** calls **Service C**, which records corresponding spans.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设分数是 `0.1` – 它小于概率 (`0.2`)，因此请求被采样，我们应该记录相应的跨度及其本地子节点。然后是 `0.01`。**服务 B** 计算分数
    – 它是相同的，所以决定不记录跨度或其本地子节点。但随后 **服务 B** 调用 **服务 C**，它记录相应的跨度。
- en: As a result, for this trace, we’ll have spans from `trace-id` had a different
    score, for example, `0.005`, all services would record corresponding spans and
    we’d have a complete trace.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个跟踪，我们将有来自 `trace-id` 的跨度，具有不同的分数，例如，`0.005`，所有服务都会记录相应的跨度，我们将有一个完整的跟踪。
- en: Probability sampling relies on `trace-id` being random and that the same hash
    function is used to calculate the score for each span. This is the case if you
    use vanilla OpenTelemetry in the same language on all your services and don’t
    customize ID generation or configure vendor-specific samplers. If your `trace-id`
    is not random or if you have to use different sampling algorithms, we need a slightly
    different approach called **consistent sampling**. It’s experimental and not implemented
    in .NET at the moment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 概率采样依赖于 `trace-id` 是随机的，并且使用相同的哈希函数计算每个跨度的分数。如果你在所有服务上使用相同语言的纯 OpenTelemetry，并且没有自定义
    ID 生成或配置供应商特定的采样器，则这种情况成立。如果你的 `trace-id` 不是随机的，或者你必须使用不同的采样算法，我们需要一种稍微不同的方法，称为
    **一致性采样**。这是一个实验性的方法，目前在 .NET 中尚未实现。
- en: 'The approach relies on sampling score propagation: the component that starts
    the trace calculates the sampling score using any algorithm and propagates it
    to downstream services via `tracestate`. Downstream services don’t need to calculate
    the score again – they read it from `tracestate` and make a sampling decision
    by comparing this score to their configured probability.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法依赖于采样分数传播：启动跟踪的组件使用任何算法计算采样分数，并通过 `tracestate` 将其传播到下游服务。下游服务不需要再次计算分数 –
    它们从 `tracestate` 中读取它，并通过将此分数与其配置的概率进行比较来做出采样决策。
- en: Custom sampler
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义采样器
- en: 'You can implement your own samplers. For example, `DebugSampler` records all
    activities that have a `debug` flag in a `tracestate` header and uses the probability
    sampler for all other activities. With this sampler, you can force the trace to
    be recorded, by sending a request with valid `traceparent` and `tracestate: myapp=debug:1`
    headers, which can be useful when testing or reproducing problems:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以实现自己的采样器。例如，`DebugSampler` 记录所有在 `tracestate` 标头中具有 `debug` 标志的活动，并为所有其他活动使用概率采样器。使用此采样器，你可以通过发送带有有效
    `traceparent` 和 `tracestate: myapp=debug:1` 标头的请求来强制记录跟踪，这在测试或重现问题时可能很有用：'
- en: DebugSampler.cs
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DebugSampler.cs
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs)'
- en: The sampler implements a `ShouldSample` method, which takes `SamplingParameters`
    in and returns `SamplingResult`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器实现了一个 `ShouldSample` 方法，它接受 `SamplingParameters` 并返回 `SamplingResult`。
- en: Sampling parameters include parent trace context and additional details such
    as creation-time attributes, the `Activity` name, kind, `tracestate`, and links.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 采样参数包括父跟踪上下文和创建时间属性、`Activity` 名称、类型、`tracestate` 和链接。
- en: '`SamplingResult` is a struct that contains a `SamplingDecision` enum that takes
    one of three possible values:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`SamplingResult` 是一个包含 `SamplingDecision` 枚举的结构，该枚举可以取三个可能值之一：'
- en: '`Drop`: Create `Activity`, but don’t record it.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drop`：创建 `Activity`，但不记录它。'
- en: '`RecordAndSample`: Create `Activity`, record it, and set the sampling flag
    on trace context.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecordAndSample`：创建 `Activity`，记录它，并在跟踪上下文中设置采样标志。'
- en: '`RecordOnly`: Create `Activity` and record it, but don’t set a sampling flag
    on trace context. Built-in samplers never return a `RecordOnly` decision, but
    you can implement a custom sampler and return such a decision to a trace request
    locally without forcing downstream services to follow it (if they respect parent
    decisions).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecordOnly`：创建 `Activity` 并记录它，但不在跟踪上下文中设置采样标志。内置采样器永远不会返回 `RecordOnly` 决策，但你可以实现自定义采样器，并在本地返回此类决策给跟踪请求，而不强迫下游服务遵循它（如果它们尊重父决策）。'
- en: '`SamplingResult` also contains updated `tracestate` values and attributes –
    samplers can set them, and they will be used on the activity-to-be-created. We
    can configure this sampler in the same way as before, by calling the `SetSampler`
    method on the `TracerProviderBuilder` instance.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`SamplingResult`还包含更新的`tracestate`值和属性——采样器可以设置它们，它们将在即将创建的活动上使用。我们可以通过在`TracerProviderBuilder`实例上调用`SetSampler`方法以与之前相同的方式配置此采样器。'
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With OpenTelemetry, an activity is created for every sampling decision. But
    in .NET, it’s possible to prevent a sampled-out `Activity` from being created
    altogether.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenTelemetry，每个采样决策都会创建一个活动。但在.NET中，可以防止创建被采样的`Activity`。
- en: We’ll learn more about sampling in vanilla .NET in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098),
    *Tracing Your Code*, and will see some examples of how instrumentations can suppress
    activity creation later in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B19423_06.xhtml#_idTextAnchor098)“跟踪您的代码”中了解更多关于采样在vanilla .NET中的信息，并将在本章后面看到一些关于如何抑制活动创建的示例。
- en: Tail-based sampling
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于尾部的采样
- en: With tail-based sampling, the decision is made after the trace ends and could
    consider trace duration, presence of errors, or any other information available
    on spans. As you can imagine, we should first buffer all spans in the trace and
    then send all of them to the observability provider or drop all of them. Tail-based
    sampling must happen across different services and can only be done by an external
    component such as the OpenTelemetry Collector. The tail-sampling processor in
    the Collector is highly configurable and supports multiple sampling policies,
    including rate-limiting, latency, and status-code-based policies. You can combine
    multiple policies together. It’s not really possible to know when a trace ends,
    so the Collector starts buffering spans after the first span in that trace is
    received for a configurable time period and then makes a decision based on the
    available data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基于尾部的采样，决策是在跟踪结束后做出的，并可能考虑跟踪持续时间、错误的存在或任何其他在跨度上可用的信息。正如您所想象的，我们首先需要在跟踪中缓冲所有跨度，然后将它们全部发送到可观察性提供者或丢弃它们。基于尾部的采样必须在不同的服务之间发生，并且只能由外部组件，如OpenTelemetry
    Collector来完成。Collector中的尾部采样处理器高度可配置，并支持多种采样策略，包括基于速率限制、延迟和状态码的策略。您可以组合多个策略。实际上，很难知道跟踪何时结束，因此Collector在收到该跟踪的第一个跨度后，会根据可配置的时间段开始缓冲跨度，然后根据可用数据做出决策。
- en: The tail-based sampling processor in collector allows the creation of composite
    sampling strategies. For example, you can configure probability sampling on your
    .NET services to minimize performance impact and then apply rate limiting on the
    collector to control telemetry volume and observability backend costs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Collector中的基于尾部的采样处理器允许创建复合采样策略。例如，您可以在.NET服务上配置概率采样以最小化性能影响，然后对Collector应用速率限制以控制遥测量级和可观察性后端成本。
- en: You could also configure a higher sampling probability to collect more traces
    with bigger latency, errors, or specific attributes. Buffering is currently limited
    to a single instance of the Collector, so if spans from the same trace end up
    on different collectors, tail-based sampling may produce partial traces, but still
    would capture parts corresponding to failure or increased latency. Since tail-based
    sampling has to buffer spans, it is memory-consuming and requires additional compute
    resources, and works well for short traces. As usual, it makes sense to compare
    the costs of managing the Collector setup with the savings it brings.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以配置更高的采样概率，以收集更多带有更大延迟、错误或特定属性的跟踪。目前缓冲仅限于Collector的单个实例，因此如果来自同一跟踪的跨度最终落在不同的Collector上，基于尾部的采样可能会产生部分跟踪，但仍然会捕获对应于失败或增加延迟的部分。由于基于尾部的采样需要缓冲跨度，它消耗内存并需要额外的计算资源，因此适用于短跟踪。通常，比较管理Collector设置的代价与其带来的节省是有意义的。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With non-probabilistic sampling, usage analysis based on traces is skewed and
    could be misleading. Metrics collected inside the application independently of
    traces could still be your source of truth.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在非概率采样中，基于跟踪的使用分析是有偏的，可能是误导性的。独立于跟踪收集的应用程序内的度量可能仍然是您的真实来源。
- en: Depending on your needs, you may combine different approaches – for example,
    collect all data but keep it in a cold(ish) storage, only using a more expensive
    backend for a small subset of traces.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，您可以将不同的方法结合起来——例如，收集所有数据但将其保存在冷（较冷）存储中，仅使用更昂贵的后端存储一小部分跟踪。
- en: Now you’re ready to choose a sampling strategy and implement it in your system!
    Let’s move and explore how to enrich spans with additional context.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好选择一个采样策略并在你的系统中实施它了！让我们继续探索如何通过额外的上下文来丰富跨度。
- en: Enriching and filtering telemetry
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丰富和过滤遥测数据
- en: Traces and metrics coming from auto-instrumentation describe the technical side
    of an operation. While we can always add more spans with custom context (and we’ll
    learn how to do it in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098), *Tracing
    Your Code*), it could be more practical to add custom context to auto-collected
    telemetry.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 来自自动化的跟踪和指标描述了操作的技术方面。虽然我们总是可以添加更多带有自定义上下文的跨度（我们将在[*第6章*](B19423_06.xhtml#_idTextAnchor098)
    *跟踪你的代码*中学习如何做），但将自定义上下文添加到自动收集的遥测数据中可能更加实用。
- en: Application-specific context is necessary to track usage and contains essential
    information that helps to detect and investigate issues.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序特定的上下文对于跟踪使用情况是必要的，它包含有助于检测和调查问题的关键信息。
- en: For example, if we take our meme service, it would be very helpful to have the
    meme name and size on spans. With this, we’d be able to find the most popular
    memes, correlate meme upload and download requests, plan capacity, make cache
    optimizations, or reason about partitioning.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们以我们的梗图服务为例，在跨度上拥有梗图名称和大小将非常有帮助。有了这个，我们就能找到最受欢迎的梗图，关联梗图的上传和下载请求，规划容量，进行缓存优化，或者进行分区推理。
- en: 'The easiest way to add a meme name is via the `Activity.SetTag` method. For
    example, we can the following code on the `Meme` page:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 添加梗图名称最简单的方法是通过`Activity.SetTag`方法。例如，我们可以在`Meme`页面上添加以下代码：
- en: Meme.cshtml.cs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Meme.cshtml.cs
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs)'
- en: '`Activity.Current` here is created by ASP.NET Core. It was enabled with OpenTelemetry
    ASP.NET Core instrumentation – if tracing was disabled, `Activity.Current` would
    be `null` here, so we should always guard `Activity.Current` with a `null` check
    or use null coalescence.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity.Current`在这里是由ASP.NET Core创建的。它通过OpenTelemetry ASP.NET Core的仪器启用——如果跟踪被禁用，那么这里的`Activity.Current`将是`null`，因此我们应该始终使用`null`检查或使用空合并来保护`Activity.Current`。'
- en: We also check whether the activity is recorded – if the `IsAllDataRequested`
    flag is `true`. There is no point in recording attributes on a sampled-out activity,
    so it’s an optimization. While it’s very small in this case, it’s a good practice
    to use it to avoid any unnecessary string allocations or prevent heavier operations
    needed to retrieve the attribute value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查活动是否被记录——如果`IsAllDataRequested`标志为`true`。在采样出的活动上记录属性是没有意义的，所以这是一个优化。虽然在这种情况下它非常小，但使用它是避免任何不必要的字符串分配或防止执行更重的操作以检索属性值的好习惯。
- en: Finally, we call `SetTag` – a method that takes the string tag name and nullable
    object value. We’ll talk more about the Activity API and tags in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098),
    *Tracing* *Your Code*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`SetTag`方法——这是一个接受字符串标签名称和可空对象值的函数。我们将在[*第6章*](B19423_06.xhtml#_idTextAnchor098)
    *跟踪你的代码*中更多地讨论Activity API和标签。
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A tag in the .NET Activity API is the same as the OpenTelemetry `span` attribute.
    Tags came from OpenTracing and were not renamed for backward-compatibility reasons.
    This book uses *tag* and *attribute* interchangeably.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Activity API中的标签与OpenTelemetry的`span`属性相同。标签来自OpenTracing，并且没有重命名以保持向后兼容性。本书中*标签*和*属性*可以互换使用。
- en: With this approach, we can add meme names to all ASP.NET Core activities. But
    what about HTTP client and MySQL activities? Having meme names on them would be
    handy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以将梗图名称添加到所有ASP.NET Core活动中。但是，对于HTTP客户端和MySQL活动呢？在这些活动上拥有梗图名称将非常方便。
- en: In the general case, it can be done with a span processor, but some instrumentations
    provide extensibility hooks allowing them to enrich their activities.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，可以使用跨度处理器来完成，但一些仪器提供了可扩展的挂钩，允许它们丰富它们的活动。
- en: Let’s look at each of these approaches.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些方法。
- en: Span processors
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Span处理器
- en: The span processor is a component of the OpenTelemetry export pipeline. When
    OpenTelemetry is notified about activity start or stop events, it synchronously
    calls the corresponding method on the processor. By implementing our own processor
    and adding it to the tracer provider, we can intercept all activities and add
    attributes from `AsyncLocal`, `ThreadLocal`, or another context available globally.
    We could also overwrite or remove attributes or filter out activities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度处理器是OpenTelemetry导出管道的一个组件。当OpenTelemetry被通知有关活动开始或停止事件时，它会同步调用处理器上的相应方法。通过实现我们自己的处理器并将其添加到跟踪提供程序中，我们可以拦截所有活动并添加来自`AsyncLocal`、`ThreadLocal`或全局可用的另一个上下文中的属性。我们还可以覆盖或删除属性或过滤活动。
- en: Enriching
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Enriching
- en: Before we do this for the meme name, we need to decide how to pass it to the
    processor. Since we want meme names to be on all spans from all services, it would
    be a good case for baggage. Baggage, as we saw in [*Chapter 1*](B19423_01.xhtml#_idTextAnchor016),
    *Observability Needs of Modern Applications*, represents application-specific
    context propagated between services.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对梗名称执行此操作之前，我们需要决定如何将其传递给处理器。由于我们希望梗名称出现在所有服务的所有跨度中，这将是行李的一个很好的用例。行李，正如我们在[*第1章*](B19423_01.xhtml#_idTextAnchor016)，“现代应用程序的可观察性需求”中看到的，代表在服务之间传播的应用特定上下文。
- en: 'So, let’s go ahead and add the meme name to the baggage on the frontend `Meme`
    and `Upload` pages:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续在前端“Meme”和“Upload”页面上添加梗名称到行李中：
- en: Meme.cshtml.cs
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Meme.cshtml.cs
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs)'
- en: 'Setting `Baggage` does not always affect an activity that has started beforehand
    and is current now – it’s a side effect of `AsyncLocal`, and we’ll dig into this
    in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098), *Tracing Your Code*. So, we’re
    going to keep setting meme name tags on activities on the frontend pages. `Baggage`
    uses `AsyncLocal` underneath, so we can now reliably use it in the processor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`Baggage`并不总是影响之前开始并当前正在进行的活动——它是`AsyncLocal`的副作用，我们将在[*第6章*](B19423_06.xhtml#_idTextAnchor098)，“跟踪您的代码”中深入探讨这一点。因此，我们将在前端页面上继续在活动上设置梗名称标签。`Baggage`在底层使用`AsyncLocal`，因此我们现在可以在处理器中可靠地使用它：
- en: MemeNameEnrichingProcessor.cs
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: MemeNameEnrichingProcessor.cs
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs)'
- en: We’re overriding the `OnEnd` method here – we first get the meme name from the
    baggage and add it as a tag to the activity. We don’t need to check whether the
    activity is `null` since the processor won’t be called in such a case, but we
    might still need to check whether it’s sampled in because, as we’ll see soon,
    sampled-out activities can still sometimes reach your processor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里重写了`OnEnd`方法——我们首先从行李中获取梗名称并将其添加为活动的一个标签。我们不需要检查活动是否为`null`，因为在这种情况下处理器不会被调用，但我们可能仍然需要检查它是否被采样，因为，正如我们很快就会看到的，采样出的活动有时仍然可以到达您的处理器。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We get a name from `Baggage.Current`, but if it’s not there, we also check `Activity.Baggage`.
    The reason is that the `Baggage` type lives in the `OpenTelemetry` namespace and
    can be used beyond tracing. But ASP.NET Core is not aware of it and populates
    `Baggage` on `Activity`. As a rule of thumb, always set `Baggage` with `Baggage.SetBaggage`,
    but read it from `Baggage` and `Activity`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Baggage.Current`获取一个名称，但如果它不在那里，我们也会检查`Activity.Baggage`。原因是`Baggage`类型位于`OpenTelemetry`命名空间中，并且可以在跟踪之外使用。但ASP.NET
    Core并不知道它，并在`Activity`上填充`Baggage`。作为一个经验法则，始终使用`Baggage.SetBaggage`设置`Baggage`，但从`Baggage`和`Activity`中读取它。
- en: 'The last step is to register this processor on `TracerProvider` on the frontend
    and storage services:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在前端和存储服务上的`TracerProvider`上注册此处理器：
- en: Program.cs
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
- en: That’s it – the frontend adds a meme name to `Baggage`, then `Baggage` is automatically
    propagated to **storage**. Whenever any activity ends, the enriching processor
    stamps the meme name on it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样 - 前端将meme名称添加到`Baggage`中，然后`Baggage`会自动传播到**存储**。每当任何活动结束时， enriching 处理器都会在它上面打印meme名称。
- en: By the way, we can also use the processor to remove unwanted tags by calling
    `SetTag` with a `null` value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们还可以通过使用`SetTag`方法并传入`null`值来调用处理器以删除不需要的标签。
- en: Filtering
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤
- en: Sometimes you want to drop some activities – for example, those that represent
    retrieving static files on a frontend or requests from web crawlers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您想丢弃一些活动 - 例如，那些代表前端上检索静态文件或来自网络爬虫的请求的活动。
- en: Dropping an activity after it has started in the middle of a trace breaks causation.
    It should be only done for activities that don’t have any children.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪中间开始的活动后丢弃活动会破坏因果关系。这应该只针对没有子活动的事件进行。
- en: Some instrumentations provide a hook to suppress activities so they are never
    even created – we’ll see some examples of it later in this section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些仪表化提供了抑制活动的钩子，这样它们甚至不会被创建 - 我们将在本节稍后看到一些示例。
- en: 'But instrumentations don’t always support suppression, and filtering out already
    started activities might be the only option. Let’s see how to do it with a processor:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仪表化并不总是支持抑制，过滤掉已经启动的活动可能只是一种选择。让我们看看如何使用处理器来完成它：
- en: StaticFilesFilteringProcessor.cs
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: StaticFilesFilteringProcessor.cs
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs)'
- en: In this processor, we check whether the activity has a `Server` kind (describes
    an incoming request), a `GET` method, and does not have a route. We can only check
    route presence in the `OnEnd` callback as the route is calculated after the activity
    starts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处理器中，我们检查活动是否具有`Server`类型（描述一个传入请求），使用`GET`方法，并且没有路由。我们只能在`OnEnd`回调中检查路由的存在，因为路由是在活动开始后计算的。
- en: Hence, we unset the recording flag on `Activity` so it will be dropped later
    in the exporting pipeline.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`Activity`上取消设置记录标志，以便它将在导出管道中稍后丢弃。
- en: You may come up with a better heuristic to identify static files, and if it
    doesn’t require a route, you could suppress such activities using ASP.NET Core
    instrumentation options, as we’ll see a bit later.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想出一个更好的启发式方法来识别静态文件，如果它不需要路由，您可以使用ASP.NET Core仪表选项来抑制此类活动，正如我们稍后将看到的。
- en: 'To register this processor, add it to `TracerProviderBuilder` with the `AddProcessor`
    method. Make sure to add processors in the order you want them to run:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册此处理器，请使用`AddProcessor`方法将其添加到`TracerProviderBuilder`中。确保按照您希望它们运行的顺序添加处理器：
- en: Program.cs
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs)'
- en: We just learned how to filter and enrich activities with processors; let’s now
    see what we can do with instrumentation options.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何使用处理器过滤和丰富活动；现在让我们看看我们可以使用仪表化选项做什么。
- en: Customizing instrumentations
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义仪表化
- en: 'Instrumentations may provide configuration options allowing to customize telemetry
    collection. For example, you can configure recording exception events with HTTP
    client and ASP.NET Core instrumentations through the `RecordException` flag on
    the corresponding configuration options:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表化可能提供配置选项，允许自定义遥测收集。例如，您可以通过相应配置选项上的`RecordException`标志来配置记录HTTP客户端和ASP.NET
    Core仪表化的异常事件：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instrumentations can also provide callbacks allowing to populate attributes
    from instrumentation-specific contexts such as `request` or `response` objects.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器也可以提供回调，允许从特定的仪器上下文中填充属性，例如`request`或`response`对象。
- en: 'Let’s use it to set a request size on incoming HTTP requests on storage, so
    we can analyze meme sizes using ASP.NET Core instrumentation enrichments hooks:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用它来设置存储中传入HTTP请求的大小，这样我们就可以使用ASP.NET Core仪器丰富钩子来分析表情包的大小：
- en: Program.cs
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs)'
- en: In addition to ASP.NET Core, you can find similar hooks for HTTP, gRPC, and
    SQL client instrumentations available in the `opentelemetry-dotnet` repo.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了ASP.NET Core，你还可以在`opentelemetry-dotnet`仓库中找到类似的HTTP、gRPC和SQL客户端仪器钩子。
- en: 'The same instrumentations also provide hooks that prevent `Activity` from being
    created. For example, if we wanted to suppress activities created for static files
    instead of dropping them in the processor, we could write something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的仪器还提供了防止创建`Activity`的钩子。例如，如果我们想抑制为静态文件创建的活动而不是在处理器中丢弃它们，我们可以编写如下内容：
- en: Program.cs
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
- en: If you consider suppressing or enriching individual activities based on dynamic
    context, instrumentation hooks, when available, are the best option. If you want
    to enrich all activities with ambient context, processors would be the right choice.
    Let’s now see how to populate static context on all activities with resources.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑根据动态上下文抑制或丰富单个活动，当可用时，仪器钩子是最佳选择。如果你想用环境上下文丰富所有活动，处理器将是正确的选择。现在让我们看看如何使用资源在所有活动中填充静态上下文。
- en: Resources
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: An OpenTelemetry resource describes a service instance – it’s a set of static
    attributes describing the service name, version, namespace, instance, or any other
    static property. OpenTelemetry defines semantic conventions for Kubernetes, generic
    containers, clouds, processes, OS, devices, and other common resource kinds.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry资源描述了一个服务实例——它是一组静态属性，描述了服务名称、版本、命名空间、实例或任何其他静态属性。OpenTelemetry为Kubernetes、通用容器、云、进程、操作系统、设备和其他常见资源类型定义了语义约定。
- en: You can configure resources explicitly or through environment variables. For
    example, we already used the `OTEL_SERVICE_NAME` environment variable to configure
    the service name. We can set `OTEL_RESOURCE_ATTRIBUTES` to a list of comma-separated
    key-value pairs (for example, `region=westus,tag=foo`) to specify any custom resources.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以显式配置资源或通过环境变量。例如，我们已经使用了`OTEL_SERVICE_NAME`环境变量来配置服务名称。我们可以将`OTEL_RESOURCE_ATTRIBUTES`设置为逗号分隔的键值对列表（例如，`region=westus,tag=foo`）来指定任何自定义资源。
- en: 'Explicit configuration can be done with `ResourceBuilder`, which we should
    register on `TraceProviderBuilder`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ResourceBuilder`进行显式配置，我们应该在`TraceProviderBuilder`上注册它：
- en: Program.cs
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
- en: Note that environment variable detection is done by default, but you can turn
    it off by using `ResourceBuilder.CreateEmpty` instead of the `CreateDefault` factory
    method. Resources are populated on each of the signals, and we can configure different
    resources for traces, metrics, and logs if needed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，环境变量检测是默认进行的，但你可以通过使用`ResourceBuilder.CreateEmpty`而不是`CreateDefault`工厂方法来关闭它。资源在每个信号上都会被填充，如果需要，我们可以为跟踪、指标和日志配置不同的资源。
- en: 'We’re ready to run the meme service and check out the result. Go ahead and
    run it with `compose up --build`. After the application starts, hit the frontend
    at `http://locahost:5051` and upload and download some memes. Now, you should
    be able to see new attributes – meme names on all spans and content size on incoming
    requests on storage. *Figure 5**.2* shows an example of a `GET` request:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好运行 meme 服务并查看结果。使用 `compose up --build` 运行它。应用程序启动后，访问 `http://locahost:5051`
    的前端并上传和下载一些 meme。现在，您应该能够看到新的属性——所有跨度上的 meme 名称和在存储的传入请求上的内容大小。*图 5**.2* 展示了一个
    `GET` 请求的示例：
- en: '![Figure 5.2 – Auto-collected ASP.NET Core activity with custom attributes](img/B19423_05_02.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 带自定义属性的自动收集的 ASP.NET Core 活动截图](img/B19423_05_02.jpg)'
- en: Figure 5.2 – Auto-collected ASP.NET Core activity with custom attributes
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 带自定义属性的自动收集的 ASP.NET Core 活动截图
- en: 'We also get new resource attributes on every exported span, as well as exception
    events on incoming and outgoing HTTP spans, as shown in *Figure 5**.3*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在每个导出的跨度上获得了新的资源属性，以及在传入和传出的 HTTP 跨度上的异常事件，如图 *5**.3* 所示：
- en: '![Figure 5.3 – Resource attributes and exception events](img/B19423_05_03.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 资源属性和异常事件](img/B19423_05_03.jpg)'
- en: Figure 5.3 – Resource attributes and exception events
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 资源属性和异常事件
- en: Here, we can see `service.version`, `service.namespace`, `service.instance.id`,
    `env`, `region`, and `tag` attributes coming from our application, while `host.name`
    and `os.type` are added later on by the OpenTelemetry Collector resource detector.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到来自我们应用程序的 `service.version`、`service.namespace`、`service.instance.id`、`env`、`region`
    和 `tag` 属性，而 `host.name` 和 `os.type` 是由 OpenTelemetry Collector 资源检测器稍后添加的。
- en: With resource attributes, processors and baggage, instrumentation hooks, and
    flags, you can customize telemetry auto-collection, enrich activities with custom
    attributes, add events, and record exceptions. You can also change or remove attributes
    and suppress or filter out activities. But what about metrics, can we customize
    them?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过资源属性、处理器和行李、仪器钩子和标志，您可以自定义遥测自动收集，使用自定义属性丰富活动，添加事件，并记录异常。您还可以更改或删除属性，以及抑制或过滤活动。但关于指标，我们能自定义它们吗？
- en: Metrics
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标
- en: Auto-collected metrics are not as customizable as traces. With OpenTelemetry
    SDK, we can only enrich them using static resource attributes, but OpenTelemetry
    Collector provides processors that can add, remove, or rename attribute names
    and values, aggregate across attributes, change data types, or massage metrics
    in other ways.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 自动收集的指标不如跟踪可定制。使用 OpenTelemetry SDK，我们只能使用静态资源属性来丰富它们，但 OpenTelemetry Collector
    提供了可以添加、删除或重命名属性名称和值、跨属性聚合、更改数据类型或以其他方式处理指标的处理器。
- en: 'Still, you can filter out specific instruments or their attributes using the
    `MeterProviderBuilder.AddView` method. For example, you can drop an instrument
    with a specific name using the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，您可以使用 `MeterProviderBuilder.AddView` 方法过滤出特定的仪器或其属性。例如，您可以使用以下代码删除具有特定名称的仪器：
- en: Program.cs
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
- en: 'Prometheus replaces the dot with an underscore and the corresponding instrument
    appears as `process_runtime_dotnet_jit_il_compiled_size` there. Check the corresponding
    OpenTelemetry instrumentation documentation to find the original name of the instrument.
    For example, .NET runtime instrumentation documentation can be found here: git[hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md](http://hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 将点替换为下划线，相应的仪器在那里显示为 `process_runtime_dotnet_jit_il_compiled_size`。检查相应的
    OpenTelemetry 仪器文档以找到仪器的原始名称。例如，.NET 运行时仪器文档可以在以下位置找到：[github.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md](http://hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md)。
- en: You can also specify attributes you want on the instrument – OpenTelemetry will
    use only those specified and will drop other attributes. It can be done to save
    costs on unused attributes or to remove high-cardinality attributes added by mistake.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定你希望在仪表化中使用的属性 – OpenTelemetry 将仅使用指定的属性，并将丢弃其他属性。这样做可以节省未使用属性的成本或删除错误添加的高基数属性。
- en: 'For example, this code removes `http.scheme` and `http.flavor` from the ASP.NET
    Core request duration metric:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此代码从 ASP.NET Core 请求持续时间指标中删除了 `http.scheme` 和 `http.flavor`：
- en: Program.cs
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
- en: We just saw how to enrich traces and metrics with application-specific context,
    and update or remove attributes using different mechanisms available in OpenTelemetry.
    Let’s continue exploring OpenTelemetry configuration and learn how to configure
    context propagation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用应用程序特定的上下文丰富跟踪和指标，并使用 OpenTelemetry 中可用的不同机制更新或删除属性。让我们继续探索 OpenTelemetry
    配置，并学习如何配置上下文传播。
- en: Customizing context propagation
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义上下文传播
- en: When instrumenting new systems, using W3C trace context propagation is the default
    and the easiest option – it does not need any explicit configuration since .NET
    and OpenTelemetry use it by default. However, existing systems may employ legacy
    context propagation conventions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当对新的系统进行仪表化时，使用 W3C 跟踪上下文传播是默认且最简单的选项 – 由于 .NET 和 OpenTelemetry 默认使用它，因此不需要任何显式配置。然而，现有的系统可能采用遗留的上下文传播约定。
- en: To support them, we can configure a custom global propagator on OpenTelemetry
    using `Sdk.SetDefaultTextMapPropagator`. For example, if one of your old client
    applications still uses some variation of custom correlation ID, you can still
    read it from request headers and convert it to a `trace-id`-compatible format
    (or move it to baggage).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持它们，我们可以在 OpenTelemetry 上配置自定义的全局传播器，使用 `Sdk.SetDefaultTextMapPropagator`。例如，如果你的某个旧客户端应用程序仍然使用一些自定义关联
    ID 的变体，你仍然可以从请求头中读取它并将其转换为 `trace-id` 兼容的格式（或将其移动到行李中）。
- en: 'You can use a composite propagator and support multiple standards at once as
    shown in this example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用复合传播器同时支持多个标准，如下例所示：
- en: XCorrelationIdPropagator.cs
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: XCorrelationIdPropagator.cs
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs)'
- en: Here, we configured the B3 propagator from the `OpenTelemetry.Extensions.Propagators`
    package, a custom one for the `x-correlation-id` support, and also one for baggage.
    Note that we also disabled native ASP.NET Core and HTTP client propagation by
    setting `DistributedContextPropagator.Current` to the no-output propagator. If
    we don’t do it, they will keep extracting and injecting `Trace-Context` headers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们配置了来自 `OpenTelemetry.Extensions.Propagators` 包的 B3 传播器，一个用于 `x-correlation-id`
    支持的自定义传播器，以及一个用于行李的传播器。请注意，我们还通过将 `DistributedContextPropagator.Current` 设置为无输出传播器来禁用了本机
    ASP.NET Core 和 HTTP 客户端传播。如果我们不这样做，它们将继续提取和注入 `Trace-Context` 头部。
- en: When using composite context propagators, make sure to resolve collisions and
    define priority in case you get multiple conflicting combinations of trace context
    in the same request – we’ll talk more about it in *Chapter 16*, *Instrumenting*
    *Brownfield Applications*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用复合上下文传播器时，确保解决冲突并在同一请求中获取多个冲突的跟踪上下文组合时定义优先级 – 我们将在 *第 16 章*，*仪表化* *现有应用程序*
    中更多地讨论这个问题。
- en: Processing a pipeline with the OpenTelemetry Collector
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry Collector 处理管道
- en: 'As we’ve seen before, the OpenTelemetry Collector is another component that’s
    capable of controlling, enriching, filtering, converting, routing, aggregating,
    sampling, and processing telemetry in any other possible way. *Figure 5**.4* shows
    the main Collector components:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，OpenTelemetry Collector 是另一个能够控制、丰富、过滤、转换、路由、聚合、采样和以任何其他可能的方式处理遥测数据的组件。*图
    5**.4* 展示了主要的收集器组件：
- en: '![Figure 5.4 – OpenTelemetry Collector pipeline](img/B19423_05_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – OpenTelemetry Collector 管道](img/B19423_05_04.jpg)'
- en: Figure 5.4 – OpenTelemetry Collector pipeline
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - OpenTelemetry收集器管道
- en: Receivers get telemetry from different sources, and processors massage data
    and pass it over to exporters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器从不同的来源获取遥测数据，处理器对数据进行处理并将其传递给导出器。
- en: Since the collector is a separate process, potentially running on a different
    machine, it does not have a dynamic context, such as a specific HTTP request header,
    which you might want to stamp on spans. Such context can only be added inside
    your application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于收集器是一个单独的过程，可能运行在不同的机器上，它没有动态上下文，例如您可能想要在跨度上盖章的特定HTTP请求头。这种上下文只能添加到您的应用程序内部。
- en: But the collector could have more context about the environment the application
    runs in – for example, it can enrich telemetry with Kubernetes or cloud provider
    context. It can also receive telemetry in any format and convert it into OpenTelemetry
    signals.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但收集器可能对应用程序运行的环境有更多上下文信息——例如，它可以丰富遥测数据，包括Kubernetes或云提供商上下文。它还可以接收任何格式的遥测数据并将其转换为OpenTelemetry信号。
- en: The Collector supports a variety of receivers including Docker stats, statsd,
    or containerd for metrics, Kubernetes events, syslog, or journald for logs, and
    many others. Collector processors can enrich, filter, or change attribute names
    and values on any signal. One of the common use cases is sensitive data redaction.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 收集器支持多种接收器，包括用于指标的Docker统计信息、statsd或containerd，以及用于日志的Kubernetes事件、syslog或journald，还有许多其他接收器。收集器处理器可以在任何信号上丰富、过滤或更改属性名称和值。其中一个常见的用例是敏感数据编辑。
- en: You can find available Collector components in the OpenTelemetry Registry, [https://opentelemetry.io/registry](https://opentelemetry.io/registry);
    just make sure to check the stability level for each component you consider using.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在OpenTelemetry注册表中找到可用的收集器组件，[https://opentelemetry.io/registry](https://opentelemetry.io/registry)；只需确保检查您考虑使用的每个组件的稳定性级别。
- en: In many cases, it’s not a question of whether to configure and customize your
    telemetry pipeline in-process or with Collector – it’s both. Collector can help
    you migrate from one observability stack to another, provide safety belts on telemetry
    collection, and offload some work from your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，问题不在于是否在过程中或使用收集器配置和自定义遥测管道——两者都是。收集器可以帮助您从一个可观察性堆栈迁移到另一个堆栈，提供遥测收集的安全带，并从您的应用程序中卸载一些工作。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In previous chapters, we explored telemetry auto-collection, and now we have
    learned how to customize this telemetry. We learned about different sampling approaches
    – head-based and tail-based. Head-based sampling makes the decision to record
    a trace (or span) when it starts with a certain probability. Children can follow
    parent decisions and then traces are always complete, but it’s not possible to
    control the volume of traces on individual services. To overcome this, downstream
    services can configure different rates and use consistent sampling to maximize
    the number of complete traces. Some traces become partial but are still useful
    for monitoring individual services or groups of them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了遥测自动收集，现在我们已经学会了如何自定义这种遥测。我们了解到了不同的采样方法——基于头部和基于尾部。基于头部的采样会在以一定概率开始时决定记录跟踪（或跨度）。子跟踪可以跟随父跟踪的决定，并且跟踪总是完整的，但无法控制单个服务上的跟踪量。为了克服这一点，下游服务可以配置不同的速率并使用一致的采样来最大化完整跟踪的数量。一些跟踪可能是不完整的，但仍然可用于监控单个服务或服务组。
- en: Probability sampling captures a percentage of all traces and is great to mitigate
    performance overhead. If you need predictable costs, you should consider rate-based
    sampling. It’s implemented in the OpenTelemetry Collector or by observability
    vendors. The OpenTelemetry Collector can also do tail-based sampling and record
    failures and long traces with higher probability.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 概率采样捕获所有跟踪的一部分，并且对于减轻性能开销非常有用。如果您需要可预测的成本，您应该考虑基于速率的采样。它在OpenTelemetry收集器或可观察性供应商中实现。OpenTelemetry收集器还可以执行基于尾部的采样，并以更高的概率记录失败和长跟踪。
- en: Auto-instrumentations collect generic information, so we need to add application-specific
    context to gain a much deeper level of observability. Enrichment can be done inside
    the process with resources – static attributes describing your service instance,
    or with span processors, instrumentation hooks, or configuration options that
    can capture dynamic context. We can add, remove, or change attributes, and we
    can use baggage to propagate application-specific context within our system.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 自动检测收集通用信息，因此我们需要添加应用程序特定的上下文以获得更深入的可见性。增强可以在进程内部使用资源完成 - 描述你的服务实例的静态属性，或者使用跨度处理器、检测钩子或配置选项来捕获动态上下文。我们可以添加、删除或更改属性，并且我们可以使用行李来在我们的系统中传播应用程序特定的上下文。
- en: We can sometimes suppress activities with instrumentation hooks or flags or
    filter them out using processors. Filtering activities that have already started
    should be done with caution as it will break the correlation between dropped activity’s
    ancestors and successors. It should only be done for activities that don’t have
    children.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时可以使用检测钩子、标志或使用处理器过滤掉活动。对于已经启动的活动进行过滤应该谨慎，因为这会破坏已丢弃活动的前辈和后继之间的关联。这仅适用于没有子活动的情况。
- en: Metrics allow some customization too – we can enrich them with resource attributes,
    drop specific instruments, or limit attributes populated by instrumentations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 指标也允许一些自定义 - 我们可以用资源属性丰富它们，删除特定的检测，或限制由检测填充的属性。
- en: We also looked at context propagation customization, which can provide interoperability
    with custom and legacy correlation solutions you might have.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了上下文传播的自定义，这可以提供与你可能拥有的自定义和旧版相关解决方案的互操作性。
- en: Finally, we talked about Collector features that can be used in addition to
    in-process configuration – environment resource detection or filtering and massaging
    telemetry. It can also provide rate-limiting sampling and protect your telemetry
    pipeline from overloading.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了除了进程内配置之外可以使用的收集器功能 - 环境资源检测或过滤和按摩遥测。它还可以提供速率限制采样，并保护你的遥测管道免受过载。
- en: In this chapter, you learned to choose a sampling strategy and implement it,
    enrich traces with application context, and customize context propagation. It
    concludes our auto-instrumentation journey; from now on, we’re going to explore
    instrumentation internals and learn how to write our own. In the next chapter,
    we’ll focus on creating activities.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何选择采样策略并实现它，用应用程序上下文丰富跟踪，并自定义上下文传播。这标志着我们的自动检测之旅结束；从现在开始，我们将探索检测内部机制，并学习如何编写我们自己的。在下一章中，我们将专注于创建活动。
- en: Questions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you build a general-purpose sampling solution that also captures failures
    and long-running traces in a distributed application?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何构建一个通用的采样解决方案，它还能捕获分布式应用程序中的失败和长时间运行的跟踪？
- en: How would you record retries on the HTTP client spans?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何记录 HTTP 客户端跨度中的重试？
- en: Configure rate-limiting sampling on the OpenTelemetry Collector.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OpenTelemetry 收集器上配置速率限制采样。
