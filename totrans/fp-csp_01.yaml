- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is a way of thinking about software based on treating
    computation as the evaluation of mathematical functions. It avoids changing state
    and mutable data, focusing instead on pure functions, immutability, and composing
    functions to solve complex problems. By sticking to these principles, functional
    programming creates code that is more predictable, easier to understand, and less
    prone to bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why should you consider adopting functional programming in your projects?
    The benefits are many, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased readability and maintainability**: Functional code is often more
    concise and expressive, making it easier to read and maintain. By focusing on
    what needs to be done rather than how to do it, functional programming promotes
    clearer and more readable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced testability**: Pure functions always produce the same output for
    a given input and have no side effects, making them easier to test. This leads
    to more comprehensive and reliable unit testing, resulting in higher code quality
    and fewer bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved concurrency and parallelism**: The emphasis on immutability and
    avoiding shared state in functional programming makes it well suited for concurrent
    and parallel processing. It reduces the risks associated with race conditions
    and allows safer and more efficient use of multi-core processors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability and composability**: Functional programming encourages the creation
    of small, focused functions that can be easily combined and reused throughout
    the code base. This promotes code reuse, modularity, and the ability to build
    complex systems from simple building blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we progress through this book, we’ll explore these benefits in greater detail,
    making it more compelling to use functional programming in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Functional versus imperative versus object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully appreciate the power of functional programming, it’s essential to understand
    how it differs from other paradigms, such as imperative and object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imperative programming is the traditional approach in many languages. It focuses
    on explicitly specifying the sequence of steps to solve a problem. This style
    relies heavily on mutable state and side effects, which can make code more prone
    to bugs and harder to understand as the code base grows.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) organizes code around objects, which
    encapsulate data and behavior. OOP is great for modeling real-world entities and
    promoting encapsulation. However, it can sometimes lead to complex hierarchies
    and tight coupling between objects, making code harder to modify and test.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming, in contrast, emphasizes pure functions and immutable
    data. It treats computation as the evaluation of expressions rather than a sequence
    of state changes. By minimizing side effects and focusing on the input-output
    relationship of functions, functional programming enables more declarative and
    composable code.
  prefs: []
  type: TYPE_NORMAL
- en: Blending paradigms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to note that these paradigms are not mutually exclusive. Modern
    programming languages such as C# support a mix of imperative, object-oriented,
    and functional programming styles. The key is to understand the strengths and
    weaknesses of each paradigm and apply them wisely based on the problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: How functional programming is supported in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# has evolved significantly over the years, incorporating a range of functional
    programming features that make it a powerful language for this paradigm. Let’s
    take a closer look at some of these features and how they support functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lambda expressions**: These provide a concise syntax for creating anonymous
    functions, enabling easy creation of higher-order functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ**: This provides a set of extension methods that enable functional-style
    operations such as filtering, mapping, and reducing collections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable data types**: Data types such as strings and tuples guarantee that
    once created, their values cannot be changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pattern matching**: This allows us to test values against patterns and extract
    data based on those patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegates and events**: These allow you to treat functions as first-class
    citizens, passing them as arguments and storing them in variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this book, we’ll explore how to utilize these features to write code
    in a functional approach. Let’s look at what I mean by a functional approach next.
  prefs: []
  type: TYPE_NORMAL
- en: How to write functional code in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing functional code in C# means the implementation of functional concepts
    and techniques that will help us write functional code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expressions**: By favoring expressions over statements, we can write more
    declarative code that focuses on the desired result rather than the steps to achieve
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pure functions**: A pure function always produces the same output for a given
    input and has no side effects. It relies solely on its input parameters and does
    not modify any external state. Using pure functions, we can create easier code
    to reason about, test, and parallelize.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Honest functions**: Honest functions are an extension of pure functions that
    provide a clear and unambiguous contract. They explicitly communicate their input
    requirements and potential output scenarios, including error cases. Honest functions
    enhance code readability, maintainability, and error handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher-order functions**: These functions can accept other functions as arguments
    or return functions as results. They enable powerful abstractions and allow you
    to create reusable and composable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functors and monads**: Functors and monads are abstractions that help you
    manage and compose computations in a functional way. A functor is a type that
    defines a mapping operation, allowing you to apply a function to the values inside
    the functor while preserving its structure. Monads, on the other hand, provide
    a way to chain computations together, handling complexities such as error propagation
    and state management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t worry if any of these concepts and techniques are not familiar to you.
    Throughout this book, we’ll explore them in detail and use practical coding examples
    to help you understand how to use them in your code.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example – a book publishing system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s examine an example that demonstrates functional programming concepts
    using a book publishing system scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates several key functional programming concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`record` for the `Book` type, which is immutable by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsValid` and `FormatBook` are pure functions. They always return the same
    output for the same input and have no side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessBooks` is a higher-order function that takes two functions as parameters
    (a validator and a formatter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessBooks` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative style**: We describe what we want (valid, formatted books) rather
    than how to do it step by step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Where` and `Select`) that align well with functional programming principles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example shows how functional programming can be applied to a real-world
    scenario such as a book publishing system.
  prefs: []
  type: TYPE_NORMAL
- en: How to combine functional and object-oriented paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the strengths of C# is its ability to seamlessly combine functional
    and object-oriented programming paradigms. By leveraging the best of both worlds,
    we can create code that is modular, reusable, and expressive. Here are some strategies
    for combining functional and object-oriented programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutable objects**: Immutable objects are thread-safe, easier to reason
    about, and align well with functional programming principles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extension methods**: These allow us to enhance the functionality of types
    without modifying their original implementation, promoting a more functional and
    compositional approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher-order functions as instance methods**: This approach helps us to encapsulate
    behavior and provide a fluent and expressive API for working with objects in a
    functional manner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection and composition**: By injecting functional dependencies
    and composing objects based on their behavior, you can achieve a more modular
    and flexible design that aligns with functional programming principles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools help us combine functional and object-oriented programming techniques,
    making our code more expressive and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Meet Steve and Julia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make our journey through functional programming in C# more engaging and
    relatable, let’s introduce our main characters: Steve and Julia.'
  prefs: []
  type: TYPE_NORMAL
- en: Steve is a middle-level C# software developer who has heard that functional
    programming can help him write better code, become more valuable at his current
    job, and gain an advantage over other candidates if he decides to pursue a new
    opportunity. He’s eager to learn but unsure where to start.
  prefs: []
  type: TYPE_NORMAL
- en: Julia, on the other hand, is already an expert in functional programming in
    C#. She’s passionate about the paradigm and enjoys sharing her knowledge with
    others. Throughout the book, Julia will provide Steve with advice, guidance, and
    practical examples to help him master functional programming concepts.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through the chapters, we’ll follow Steve’s journey as he learns
    from Julia and applies functional programming techniques to real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on taking the first step toward mastering functional programming
    in C#! In this chapter, we’ve explored the differences between functional, imperative,
    and object-oriented programming paradigms. We’ve also delved into the functional
    features of C#, such as lambda expressions, LINQ, immutable data types, pattern
    matching, and delegates, and how they support functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we’ve introduced the concepts and techniques for writing functional
    code in C# such as expressions, pure functions, honest functions, higher-order
    functions, functors, and monads. Finally, we’ve discussed strategies for combining
    functional and object-oriented programming in C#, allowing us to leverage the
    best of both paradigms in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through the next chapters, we’ll dive deeper into each of these
    concepts, learning how to write cleaner, more modular, and more testable code
    using functional principles.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
