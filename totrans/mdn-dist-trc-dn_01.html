<html><head></head><body>
<div id="_idContainer025">
<h1 class="chapter-number" id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.2.1">Observability Needs of Modern Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">With the increasing complexity of distributed systems, we need better tools to build and operate our applications. </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Distributed tracing</span></strong><span class="koboSpan" id="kobo.5.1"> is one such technique that allows you to collect</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.6.1"> structured and correlated telemetry with minimum effort and enables observability vendors to build powerful analytics </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">and automation.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we’ll explore common observability challenges and see how distributed tracing brings observability to our systems where logs and counters can’t. </span><span class="koboSpan" id="kobo.8.2">We’ll see how correlation and causation along with structured and consistent telemetry help answer arbitrary questions about the system and mitigate </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">issues faster.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Here’s what you </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">will learn:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">An overview of monitoring techniques using counters, logs, </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">and events</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Core concepts of distributed tracing – the span and </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">its structure</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Context </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">propagation standards</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">How to generate meaningful and </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">consistent telemetry</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">How to use distributed tracing along with metrics and logs for performance analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">and debugging</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.22.1">By the end of this chapter, you will become familiar with the core concepts and building blocks of distributed tracing, which you will be able to use along with other telemetry signals to debug functional issues and investigate performance issues in </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">distributed applications.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.24.1">Understanding why logs and counters are not enough</span></h1>
<p><span class="koboSpan" id="kobo.25.1">Monitoring and observability cultures vary across the industry; some teams use ad hoc debugging with </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">printf</span></strong><span class="koboSpan" id="kobo.27.1"> while others employ sophisticated observability solutions and automation. </span><span class="koboSpan" id="kobo.27.2">Still, almost every system uses a combination of common telemetry signals: logs, events, metrics or counters, and profiles. </span><span class="koboSpan" id="kobo.27.3">Telemetry collection</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.28.1"> alone is not enough. </span><span class="koboSpan" id="kobo.28.2">A system is </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">observable</span></strong><span class="koboSpan" id="kobo.30.1"> if we can detect and investigate issues, and to achieve this, we need tools to store, index, visualize, and query the telemetry, navigate across different signals, and automate </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">repetitive analysis.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">Before we begin exploring tracing and discovering how it helps, let’s talk about other telemetry signals and </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">their limitations.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.34.1">Logs</span></h2>
<p><span class="koboSpan" id="kobo.35.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">log</span></strong><span class="koboSpan" id="kobo.37.1"> is a record of some event. </span><span class="koboSpan" id="kobo.37.2">Logs</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.38.1"> typically have a timestamp, level, class name, and formatted message, and may also have a property bag with </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">additional context.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Logs are a low-ceremony tool, with plenty of logging libraries and tools for </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">any ecosystem.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">Common problems with logging</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.43.1"> include </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Verbosity</span></strong><span class="koboSpan" id="kobo.46.1">: Initially, we won’t have enough logs, but eventually, as we fill gaps, we will have too many. </span><span class="koboSpan" id="kobo.46.2">They become hard to read and expensive </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">to store.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Performance</span></strong><span class="koboSpan" id="kobo.49.1">: Logging is a common performance issue even when used wisely. </span><span class="koboSpan" id="kobo.49.2">It’s also very common to serialize objects or allocate strings for logging even when the logging level </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">is disabled.</span></span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.51.1">One new log statement can take your production down; I did it once. </span><span class="koboSpan" id="kobo.51.2">The log I added was written every millisecond. </span><span class="koboSpan" id="kobo.51.3">Multiplied by a number of service instances, it created an I/O bottleneck big enough to significantly increase latency and the error rate for users</span></em><span class="koboSpan" id="kobo.52.1">.</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">Not queryable</span></strong><span class="koboSpan" id="kobo.54.1">: Logs coming from applications are intended for humans. </span><span class="koboSpan" id="kobo.54.2">We can add context and unify the format within our application and still only be able to filter logs by context properties. </span><span class="koboSpan" id="kobo.54.3">Logs change with every refactoring, disappear, or become out of date. </span><span class="koboSpan" id="kobo.54.4">New people joining a team need to learn logging semantics specific to a system, and the learning curve can </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">be steep.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">No correlation</span></strong><span class="koboSpan" id="kobo.57.1">: Logs for different operations are interleaved. </span><span class="koboSpan" id="kobo.57.2">The process of finding logs</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.58.1"> describing certain operations</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.59.1"> is called correlation. </span><span class="koboSpan" id="kobo.59.2">In general, log correlation, especially across services, must be implemented manually (spoiler: not in </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">ASP.NET Core).</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.61.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.62.1">Logs are easy to produce but are verbose, and then can significantly impact performance. </span><span class="koboSpan" id="kobo.62.2">They are also difficult to filter, query, </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">or visualize.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">To be accessible</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.65.1"> and useful, logs are sent to some central place, a </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">log management system</span></strong><span class="koboSpan" id="kobo.67.1">, which stores, parses, and indexes them so they can be queried. </span><span class="koboSpan" id="kobo.67.2">This implies that your logs need to have at least </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">some structure.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">ILogger</span></strong><span class="koboSpan" id="kobo.70.1"> in .NET supports structured logging, as we’ll see in </span><a href="B19423_08.xhtml#_idTextAnchor131"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.71.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.72.1">, </span><em class="italic"><span class="koboSpan" id="kobo.73.1">Writing Structured and Correlated Logs</span></em><span class="koboSpan" id="kobo.74.1">, so you get the human-readable message, along with the context. </span><span class="koboSpan" id="kobo.74.2">Structured logging, combined with structured storage and indexing, converts your logs into rich events that you can use for </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">almost anything.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.76.1">Events</span></h2>
<p><span class="koboSpan" id="kobo.77.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">event</span></strong><span class="koboSpan" id="kobo.79.1"> is a structured record of something. </span><span class="koboSpan" id="kobo.79.2">It has a timestamp</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.80.1"> and a property bag. </span><span class="koboSpan" id="kobo.80.2">It may have a name, or that could just be one of </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the properties.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The difference between logs and events is semantical – an event is structured and usually follows a </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">specific schema.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">For example, an event that describes adding an item to a shopping bag should have a well-known name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">shopping_bag_add_item</span></strong><span class="koboSpan" id="kobo.86.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">user-id</span></strong><span class="koboSpan" id="kobo.88.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">item-id</span></strong><span class="koboSpan" id="kobo.90.1"> properties. </span><span class="koboSpan" id="kobo.90.2">Then, you can query them by name, item, and user. </span><span class="koboSpan" id="kobo.90.3">For example, you can find the top 10 popular items across </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">all users.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">If you write it as a log message, you’d probably write something </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
logger.LogInformation("Added '{item-id}' to shopping bag
  for '{user-id}'", itemId, userId)</span></pre>
<p><span class="koboSpan" id="kobo.95.1">If your logging provider captures individual properties, you would get the same context as with events. </span><span class="koboSpan" id="kobo.95.2">So, now we can find every log for this user and item, which probably includes other logs not related to adding </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">an item.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.97.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.98.1">Events</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.99.1"> with consistent schema can be queried efficiently but have the same verbosity and performance problems </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">as logs.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.101.1">Metrics and counters</span></h2>
<p><span class="koboSpan" id="kobo.102.1">Logs and events share the same problem – verbosity and performance overhead. </span><span class="koboSpan" id="kobo.102.2">One way to solve them </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">is aggregation.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">metric</span></strong><span class="koboSpan" id="kobo.106.1"> is a value of something aggregated by dimensions</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.107.1"> and over a period of time. </span><span class="koboSpan" id="kobo.107.2">For example, a request latency metric can have an HTTP route, status code, method, service name, and </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">instance dimensions.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Common problems with metrics</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.110.1"> include </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Cardinality</span></strong><span class="koboSpan" id="kobo.113.1">: Each combination of dimensions is a time series, and aggregation happens within one time series. </span><span class="koboSpan" id="kobo.113.2">Adding a new dimension causes a combinatorial explosion, so metrics must have low cardinality – that is, they cannot have too many dimensions, and each one must have a small number of distinct values. </span><span class="koboSpan" id="kobo.113.3">As a result, you can’t measure granular things such as per-user experience </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">with metrics.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">No causation</span></strong><span class="koboSpan" id="kobo.116.1">: Metrics only show correlation and no cause and effect, so they are not a great tool to </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">investigate issues.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.118.1">As an expert on your system, you might use your intuition to come up with possible reasons for certain types of behavior and then use metrics to confirm your hypothesis.</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.119.1">Verbosity</span></strong><span class="koboSpan" id="kobo.120.1">: Metrics have problems with verbosity too. </span><span class="koboSpan" id="kobo.120.2">It’s common to add metrics that measure just one thing, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">queue_is_full</span></strong><span class="koboSpan" id="kobo.122.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">queue_is_empty</span></strong><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">Something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">queue_utilization</span></strong><span class="koboSpan" id="kobo.126.1"> would be more generic. </span><span class="koboSpan" id="kobo.126.2">Over time, the number of metrics grows along with the number of alerts, dashboards, and team processes</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.127.1"> relying </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">on them.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.129.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.130.1">Metrics have low impact on performance, low volume that doesn’t grow much with scale, low storage costs, and low query time. </span><span class="koboSpan" id="kobo.130.2">They are great for dashboards and alerts but not for issue investigation or </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">granular analytics.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">counter</span></strong><span class="koboSpan" id="kobo.134.1"> is a single time series – it’s a metric </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.135.1">without dimensions, typically used to collect resource utilization such as CPU load or memory usage. </span><span class="koboSpan" id="kobo.135.2">Counters don’t work well for application performance or usage, as you need a dedicated counter per each combination of attributes, such as HTTP route, status code, and method. </span><span class="koboSpan" id="kobo.135.3">It is difficult to collect and even harder to use. </span><span class="koboSpan" id="kobo.135.4">Luckily, .NET supports metrics with dimensions, and we will discuss them in </span><a href="B19423_07.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.136.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.137.1">, </span><em class="italic"><span class="koboSpan" id="kobo.138.1">Adding </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.139.1">Custom Metrics</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.141.1">What’s missing?</span></h2>
<p><span class="koboSpan" id="kobo.142.1">Now you know all you need to monitor a monolith or small distributed system – use metrics for system health analysis and alerts, events for usage, and logs for debugging. </span><span class="koboSpan" id="kobo.142.2">This approach has taken the tech industry far, and there is nothing essentially wrong </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">with it.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">With up-to-date documentation, a few key performance and usage metrics, concise, structured, correlated, and consistent events, common conventions, and tools across all services, anyone operating your system can do performance analysis and </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">debug issues.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.146.1">Note</span></p>
<p class="callout"><em class="italic"><span class="koboSpan" id="kobo.147.1">So, the ultimate goal is to efficiently operate a system, and the problem is not a specific telemetry signal or its limitations but a lack of standard solutions and practices, correlation, and structure for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.148.1">existing signals.</span></em></span></p>
<p><span class="koboSpan" id="kobo.149.1">Before we jump into distributed tracing and see how its ecosystem addresses these gaps, let’s summarize the new requirements we have for the perfect observability solution we intend to solve with tracing and the new capabilities it brings. </span><span class="koboSpan" id="kobo.149.2">Also, we should keep in mind the old capabilities – low-performance overhead and </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">manageable costs.</span></span></p>
<h3><span class="koboSpan" id="kobo.151.1">Systematic debugging</span></h3>
<p><span class="koboSpan" id="kobo.152.1">We need to be able</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.153.1"> to investigate issues in a generic way. </span><span class="koboSpan" id="kobo.153.2">From an error report to an alert on a metric, we should be able to drill down into the issue, follow specific requests end to end, or bubble up from an error deep in the stack to understand its effect </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">on users.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">All this should be reasonably easy to do when you’re on call and paged at 2AM to resolve an incident </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">in production.</span></span></p>
<h3><span class="koboSpan" id="kobo.157.1">Answering ad hoc questions</span></h3>
<p><span class="koboSpan" id="kobo.158.1">I might want to understand </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.159.1">whether users from Redmond, WA, who purchased a product from my website are experiencing longer delivery times than usual and why – because of the shipment company, rain, cloud provider issues in this region, or </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">anything else.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">It should not be required to add more telemetry to answer most of the usage or performance questions. </span><span class="koboSpan" id="kobo.161.2">Occasionally, you’d need to add a new context property or an event, but it should be rare on a stable </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">code path.</span></span></p>
<h3><span class="koboSpan" id="kobo.163.1">Self-documenting systems</span></h3>
<p><span class="koboSpan" id="kobo.164.1">Modern systems</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.165.1"> are dynamic – with continuous deployments, feature flag changes in runtime, and dozens of external dependencies with their own instabilities, nobody can </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">know everything.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">Telemetry becomes your single source of truth. </span><span class="koboSpan" id="kobo.167.2">Assuming it has enough context and common semantics, an observability vendor should be able to visualize it </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">reasonably well.</span></span></p>
<h3><span class="koboSpan" id="kobo.169.1">Auto-instrumentation</span></h3>
<p><span class="koboSpan" id="kobo.170.1">It’s difficult to instrument </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.171.1">everything in your system – it’s repetitive, error-prone, and hard to keep up to date, test, and enforce common schema and semantics. </span><span class="koboSpan" id="kobo.171.2">We need shared instrumentations for common libraries, while we would only add application-specific telemetry</span><a id="_idIndexMarker017"/> <span class="No-Break"><span class="koboSpan" id="kobo.172.1">and context.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">With an understanding of these requirements, we will move on to </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">distributed tracing.</span></span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.175.1">Introducing distributed tracing</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.176.1">Distributed tracing</span></strong><span class="koboSpan" id="kobo.177.1"> is a technique that brings</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.178.1"> structure, correlation and causation to collected telemetry. </span><span class="koboSpan" id="kobo.178.2">It defines a special event called </span><em class="italic"><span class="koboSpan" id="kobo.179.1">span</span></em><span class="koboSpan" id="kobo.180.1"> and specifies causal relationships between spans. </span><span class="koboSpan" id="kobo.180.2">Spans follow common conventions that are used to visualize and </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">analyze traces.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.182.1">Span</span></h2>
<p><span class="koboSpan" id="kobo.183.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">span</span></strong><span class="koboSpan" id="kobo.185.1"> describes an operation such as an incoming</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.186.1"> or outgoing HTTP</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.187.1"> request, a database call, an expensive I/O call, or any other interesting call. </span><span class="koboSpan" id="kobo.187.2">It has just enough structure to represent anything and still be useful. </span><span class="koboSpan" id="kobo.187.3">Here are the most important</span><a id="_idIndexMarker021"/> <span class="No-Break"><span class="koboSpan" id="kobo.188.1">span properties:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.189.1">The span’s name should describe the operation type in human-readable format, have low cardinality, and </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">be human-readable.</span></span></li>
<li><span class="koboSpan" id="kobo.191.1">The span’s start time </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">and duration.</span></span></li>
<li><span class="koboSpan" id="kobo.193.1">The status indicates success, failure, or </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">no status.</span></span></li>
<li><span class="koboSpan" id="kobo.195.1">The span kind distinguishes the client, server, and internal calls, or the producer and consumer for </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">async scenarios.</span></span></li>
<li><span class="koboSpan" id="kobo.197.1">Attributes (also known as tags or annotations) describe</span><a id="_idIndexMarker022"/> <span class="No-Break"><span class="koboSpan" id="kobo.198.1">specific</span></span><span class="No-Break"><a id="_idIndexMarker023"/></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1"> operations.</span></span></li>
<li><span class="koboSpan" id="kobo.200.1">Span context identifies spans and is propagated everywhere, enabling correlation. </span><span class="koboSpan" id="kobo.200.2">A parent span identifier is also included on child spans </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">for causation.</span></span></li>
<li><span class="koboSpan" id="kobo.202.1">Events provide additional information about operations within </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">a span.</span></span></li>
<li><span class="koboSpan" id="kobo.204.1">Links connect traces and spans when parent-child relationships don’t work – for example, for </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">batching</span></span><span class="No-Break"><a id="_idIndexMarker024"/></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1"> scenarios.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.207.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.208.1">In .NET, the tracing span is represented by </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">System.Diagnostics.Activity</span></strong><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">System.Span</span></strong><span class="koboSpan" id="kobo.212.1"> class is not related to </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">distributed tracing.</span></span></p>
<h3><span class="koboSpan" id="kobo.214.1">Relationships between spans</span></h3>
<p><span class="koboSpan" id="kobo.215.1">A span is a unit of tracing, and to trace</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.216.1"> more complex operations, we need </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">multiple spans.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">For example, a user may attempt to get an image and send a request to the service. </span><span class="koboSpan" id="kobo.218.2">The image is not cached, and the service requests it from the cold storage (as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.219.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.220.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.222.1"><img alt="Figure 1.1 – A GET image request flow" src="image/B19423_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.223.1">Figure 1.1 – A GET image request flow</span></p>
<p><span class="koboSpan" id="kobo.224.1">To make this operation debuggable, we should report </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">multiple spans:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.226.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">incoming request</span></span></li>
<li><span class="koboSpan" id="kobo.228.1">The attempt to get the image from </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">the cache</span></span></li>
<li><span class="koboSpan" id="kobo.230.1">Image retrieval from the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">cold storage</span></span></li>
<li><span class="koboSpan" id="kobo.232.1">Caching </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the image</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.234.1">These spans form a </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">trace</span></strong><span class="koboSpan" id="kobo.236.1"> – a set of related spans fully describing</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.237.1"> a logical end-to-end operation sharing the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">trace-id</span></strong><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">Within the trace, each span is identified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">span-id</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">Spans include a pointer to a parent span – it’s just their </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">parent’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">span-id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">trace-id</span></strong><span class="koboSpan" id="kobo.246.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">span-id</span></strong><span class="koboSpan" id="kobo.248.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">parent-span-id</span></strong><span class="koboSpan" id="kobo.250.1"> allow us to not only correlate spans but also record relationships between them. </span><span class="koboSpan" id="kobo.250.2">For example, in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.251.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.252.1">.2</span></em><span class="koboSpan" id="kobo.253.1">, we can see that Redis </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">GET</span></strong><span class="koboSpan" id="kobo.255.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">SETEX</span></strong><span class="koboSpan" id="kobo.257.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">HTTP GET</span></strong><span class="koboSpan" id="kobo.259.1"> spans are siblings and the incoming request is </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">their parent:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.261.1"><img alt="Figure 1.2 – Trace visualization showing relationships between spans" src="image/B19423_01_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.262.1">Figure 1.2 – Trace visualization showing relationships between spans</span></p>
<p><span class="koboSpan" id="kobo.263.1">Spans can have more complicated relationships, which we’ll talk about later in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.264.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.265.1">, </span><em class="italic"><span class="koboSpan" id="kobo.266.1">Tracing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.267.1">Your Code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.269.1">Span context</span></strong><span class="koboSpan" id="kobo.270.1"> (aka </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">trace-id</span></strong><span class="koboSpan" id="kobo.272.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">span-id</span></strong><span class="koboSpan" id="kobo.274.1">) enables even more interesting</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.275.1"> cross-signal scenarios. </span><span class="koboSpan" id="kobo.275.2">For example, you can stamp parent span context on logs (spoiler: just configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">ILogger</span></strong><span class="koboSpan" id="kobo.277.1"> to do it) and you can correlate logs to traces. </span><span class="koboSpan" id="kobo.277.2">For example, if you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">ConsoleProvider</span></strong><span class="koboSpan" id="kobo.279.1">, you will see something </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.281.1"><img alt="Figure 1.3 – Logs include span context and can be correlated to other signals" src="image/B19423_01_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.282.1">Figure 1.3 – Logs include span context and can be correlated to other signals</span></p>
<p><span class="koboSpan" id="kobo.283.1">You could also link metrics to traces using exemplars – metric metadata containing the trace context of operations that contributed to a recorded measurement. </span><span class="koboSpan" id="kobo.283.2">For instance, you can check examples of spans that </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.284.1">correspond to the long tail of your </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">latency distribution.</span></span></p>
<h3><span class="koboSpan" id="kobo.286.1">Attributes</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.287.1">Span attributes</span></strong><span class="koboSpan" id="kobo.288.1"> are a property bag that contains</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.289.1"> details about </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">the operation.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">Span attributes should describe this specific operation well enough to understand what happened. </span><span class="koboSpan" id="kobo.291.2">OpenTelemetry semantic conventions specify attributes for popular technologies to help with this, which we’ll talk about in the </span><em class="italic"><span class="koboSpan" id="kobo.292.1">Ensuring consistency and structure</span></em><span class="koboSpan" id="kobo.293.1"> section later in </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">For example, an incoming HTTP request is identified with at least the following attributes: the HTTP method, path, query, API route, and </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">status code:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.297.1"><img alt="Figure 1.4 – The HTTP server span attributes" src="image/B19423_01_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.298.1">Figure 1.4 – The HTTP server span attributes</span></p>
<h3><span class="koboSpan" id="kobo.299.1">Instrumentation points</span></h3>
<p><span class="koboSpan" id="kobo.300.1">So, we have defined</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.301.1"> a span and its properties, but when should we create spans? </span><span class="koboSpan" id="kobo.301.2">Which attributes should we put on them? </span><span class="koboSpan" id="kobo.301.3">While there is no strict standard to follow, here’s the rule </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">of thumb:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.303.1">Create a new span for every incoming and outgoing network call and use standard attributes for the protocol or technology </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.304.1">whenever available.</span></em></span></p>
<p><span class="koboSpan" id="kobo.305.1">This is what we’ve done previously with the memes example, and it allows us to see what happened on the service boundaries and detect common problems: dependency issues, status, latency, and errors on each service. </span><span class="koboSpan" id="kobo.305.2">This also allows us to correlate logs, events, and anything else we collect. </span><span class="koboSpan" id="kobo.305.3">Plus, observability backends are aware of HTTP semantics and will know how to interpret and visualize </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">your spans.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">There are exceptions</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.308.1"> to this rule, such as socket calls, where requests could be too small to be instrumented. </span><span class="koboSpan" id="kobo.308.2">In other cases, you might still be rightfully concerned with verbosity and the volume of generated data – we’ll see how to control it with sampling in </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.309.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.310.1">, </span><em class="italic"><span class="koboSpan" id="kobo.311.1">Configuration and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.312.1">Control Plane</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.314.1">Tracing – building blocks</span></h2>
<p><span class="koboSpan" id="kobo.315.1">Now that you are familiar</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.316.1"> with the core concepts of tracing and its methodology, let’s talk about implementation. </span><span class="koboSpan" id="kobo.316.2">We need a set of convenient APIs</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.317.1"> to create and enrich spans and pass context around. </span><span class="koboSpan" id="kobo.317.2">Historically, every </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">Application Performance Monitoring</span></strong><span class="koboSpan" id="kobo.319.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.320.1">APM</span></strong><span class="koboSpan" id="kobo.321.1">) tool had its own SDKs</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.322.1"> to collect telemetry with their own APIs. </span><span class="koboSpan" id="kobo.322.2">Changing the APM vendor meant rewriting all your </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">instrumentation code.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">OpenTelemetry solves this problem – it’s a cross-language telemetry platform for tracing, metrics, events, and logs that unifies telemetry collection. </span><span class="koboSpan" id="kobo.324.2">Most of the APM tools, log management, and observability backends support OpenTelemetry, so you can change vendors without rewriting any </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">instrumentation code.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">.NET tracing implementation conforms to the OpenTelemetry API specification, and in this book, .NET tracing APIs and OpenTelemetry APIs are used interchangeably. </span><span class="koboSpan" id="kobo.326.2">We’ll talk about the difference between them in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.327.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.328.1">, </span><em class="italic"><span class="koboSpan" id="kobo.329.1">Tracing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.330.1">Your Code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Even though OpenTelemetry primitives are baked into .NET and the instrumentation code does not depend on them, to collect telemetry</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.333.1"> from the application, we still need to add the </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">OpenTelemetry SDK</span></strong><span class="koboSpan" id="kobo.335.1">, which has everything we need to configure a collection and an exporter. </span><span class="koboSpan" id="kobo.335.2">You might as well write your own solution compatible with .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">tracing APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">OpenTelemetry became an industry standard for tracing and beyond; it’s available in multiple languages, and in addition to a unified collection of APIs it provides configurable SDKs</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.338.1"> and a standard wire format for the telemetry – </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">OpenTelemetry protocol </span></strong><span class="koboSpan" id="kobo.340.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.341.1">OTLP</span></strong><span class="koboSpan" id="kobo.342.1">). </span><span class="koboSpan" id="kobo.342.2">You can send telemetry to any compatible vendor, either by adding a specific exporter or, if the backend supports OTLP, by configuring the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">vendor’s endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.345.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.346.1">.5</span></em><span class="koboSpan" id="kobo.347.1">, the application configures the OpenTelemetry SDK to export telemetry to the observability backend. </span><span class="koboSpan" id="kobo.347.2">Application code, .NET libraries, and various instrumentations use .NET tracing APIs to create spans, which the OpenTelemetry SDK listens to, processes, and forwards to </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">an exporter.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.349.1"><img alt="Figure 1.5 – Tracing building blocks" src="image/B19423_01_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.350.1">Figure 1.5 – Tracing building blocks</span></p>
<p><span class="koboSpan" id="kobo.351.1">So, OpenTelemetry decouples instrumentation</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.352.1"> code from the observability vendor, but it does much more than that. </span><span class="koboSpan" id="kobo.352.2">Now, different applications can share instrumentation libraries and observability vendors have unified and structured telemetry on top of which they can build </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">rich experiences.</span></span></p>
<h3><span class="koboSpan" id="kobo.354.1">Instrumentation</span></h3>
<p><span class="koboSpan" id="kobo.355.1">Historically, all APM vendors</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.356.1"> had to instrument popular libraries: HTTP clients, web frameworks, Entity Framework, SQL clients, Redis client libraries, RabbitMQ, cloud providers’ SDKs, and so on. </span><span class="koboSpan" id="kobo.356.2">That did not scale well. </span><span class="koboSpan" id="kobo.356.3">But with .NET tracing APIs and OpenTelemetry semantics, instrumentation became common for all vendors. </span><span class="koboSpan" id="kobo.356.4">You can find a growing list of shared community instrumentations in the OpenTelemetry Contrib </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">repo: </span></span><a href="https://github.com/open-telemetry/opentelemetry-dotnet-contrib"><span class="No-Break"><span class="koboSpan" id="kobo.358.1">https://github.com/open-telemetry/opentelemetry-dotnet-contrib</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.359.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Moreover, since OpenTelemetry is a vendor-neutral standard and baked into .NET, it’s now possible for libraries to implement native instrumentation – HTTP and gRPC clients, ASP.NET Core, and several other libraries </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">support it.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Even with native tracing support, it’s off by default – you need to install and register specific instrumentation (which we’ll cover in </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.363.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.364.1">, </span><em class="italic"><span class="koboSpan" id="kobo.365.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.366.1">). </span><span class="koboSpan" id="kobo.366.2">Otherwise, tracing code</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.367.1"> does nothing and, thus, does not add any </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">performance overhead.</span></span></p>
<h3><span class="koboSpan" id="kobo.369.1">Backends</span></h3>
<p><span class="koboSpan" id="kobo.370.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">observability backend</span></strong><span class="koboSpan" id="kobo.372.1"> (aka monitoring, APM tool, and log management system) is a set</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.373.1"> of tools responsible</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.374.1"> for ingestion, storage, indexing, visualization, querying, and probably other things that help you monitor your system, investigate issues, and </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">analyze performance.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.376.1">Observability vendors</span></strong><span class="koboSpan" id="kobo.377.1"> build these tools and provide rich user experiences</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.378.1"> to help you use traces along with </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">other signals.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Collecting traces for common libraries became easy with the OpenTelemetry ecosystem. </span><span class="koboSpan" id="kobo.380.2">As you’ll see in </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.381.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.382.1">, </span><em class="italic"><span class="koboSpan" id="kobo.383.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.384.1">, most of it can be done automatically with just a few lines of code at startup. </span><span class="koboSpan" id="kobo.384.2">But how do we </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">use them?</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">While you can send spans to </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">stdout</span></strong><span class="koboSpan" id="kobo.388.1"> and store them on the filesystem, this would not leverage all tracing benefits. </span><span class="koboSpan" id="kobo.388.2">Traces can be huge, but even when they are small, grepping them is </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">not convenient.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Tracing visualizations (such as a Gantt chart, trace viewer, or trace timeline) is one of the common features tracing providers have. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.391.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.392.1">.6</span></em><span class="koboSpan" id="kobo.393.1"> shows a trace timeline in Jaeger – an open source distributed </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">tracing platform:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.395.1"><img alt="Figure 1.6 – Trace visualization in Jaeger﻿ with errors marked with exclamation point" src="image/B19423_01_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.396.1">Figure 1.6 – Trace visualization in Jaeger with errors marked with exclamation point</span></p>
<p><span class="koboSpan" id="kobo.397.1">While it may take a while to find an error log, the visualization shows what’s important – where failures are, latency, and a sequence of steps. </span><span class="koboSpan" id="kobo.397.2">As we can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.398.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.399.1">.6</span></em><span class="koboSpan" id="kobo.400.1">, the frontend call failed because of failure on the storage side, which we can further </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">drill into.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">However, we can also see</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.403.1"> that the frontend made four consecutive calls into storage, which potentially could be done in parallel to speed </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">things up.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Another common feature is filtering or querying by any of the span properties such as name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">trace-id</span></strong><span class="koboSpan" id="kobo.407.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">span-id</span></strong><span class="koboSpan" id="kobo.409.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">parent-id</span></strong><span class="koboSpan" id="kobo.411.1">, name, attribute name, status, timestamp, duration, or anything else. </span><span class="koboSpan" id="kobo.411.2">An example of such a query is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.412.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.413.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.415.1"><img alt="Figure 1.7 – A custom Azure Monitor query that calculates the Redis hit rate" src="image/B19423_01_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.416.1">Figure 1.7 – A custom Azure Monitor query that calculates the Redis hit rate</span></p>
<p><span class="koboSpan" id="kobo.417.1">For example, we don’t report a metric for the cache hit rate, but we can estimate it from traces. </span><span class="koboSpan" id="kobo.417.2">While they’re not precise because of sampling and might be more expensive to query than metrics, we can still do</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.418.1"> it ad hoc, especially when we investigate </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">specific failures.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">Since traces, metrics, and logs are correlated, you will fully leverage observability capabilities if your vendor supports multiple signals or integrates well with </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">other tools.</span></span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.422.1">Reviewing context propagation</span></h1>
<p><span class="koboSpan" id="kobo.423.1">Correlation and causation</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.424.1"> are the foundation of distributed tracing. </span><span class="koboSpan" id="kobo.424.2">We’ve just covered how related spans share the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">trace-id</span></strong><span class="koboSpan" id="kobo.426.1"> and have a pointer to the parent recorded in </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">parent-span-id</span></strong><span class="koboSpan" id="kobo.428.1">, forming a casual chain of operations. </span><span class="koboSpan" id="kobo.428.2">Now, let’s explore how it works </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">in practice.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.430.1">In-process propagation</span></h2>
<p><span class="koboSpan" id="kobo.431.1">Even within a single service, we usually</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.432.1"> have nested</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.433.1"> spans. </span><span class="koboSpan" id="kobo.433.2">For example, if we trace a request to a REST service that just reads an item from a database, we’d want to see at least two spans – one for an incoming HTTP request and another for a database query. </span><span class="koboSpan" id="kobo.433.3">To correlate them properly, we need to pass span context from ASP.NET Core to the </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">database driver.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">One option is to pass context explicitly as a function argument. </span><span class="koboSpan" id="kobo.435.2">It’s a viable solution in Go, where explicit context propagation is a standard, but in .NET, it would make onboarding onto distributed tracing difficult and would ruin the </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">auto-instrumentation magic.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">.NET Activity (aka the span) is propagated implicitly. </span><span class="koboSpan" id="kobo.437.2">Current activity can always be accessed via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.439.1"> property, backed up </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">System.Threading.AsyncLocal&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">Using our previous example of a service reading from the database, ASP.NET Core creates an Activity for the incoming request, and it becomes current for anything that happens within the scope of this request. </span><span class="koboSpan" id="kobo.443.2">Instrumentation for the database driver creates another one that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.445.1"> as its parent, without knowing anything about ASP.NET Core and without the user application passing the Activity around. </span><span class="koboSpan" id="kobo.445.2">The logging framework would stamp </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">trace-id</span></strong><span class="koboSpan" id="kobo.447.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">span-id</span></strong><span class="koboSpan" id="kobo.449.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.451.1">, if configured to </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">It works for sync or async code, but if you process items in the background using in-memory queues or manipulate with threads explicitly, you would have</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.454.1"> to help runtime and propagate activities explicitly. </span><span class="koboSpan" id="kobo.454.2">We’ll talk</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.455.1"> more about it in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.456.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.457.1">, </span><em class="italic"><span class="koboSpan" id="kobo.458.1">Tracing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.459.1">Your Code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.461.1">Out-of-process propagation</span></h2>
<p><span class="koboSpan" id="kobo.462.1">In-process correlation</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.463.1"> is awesome, and for monolith</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.464.1"> applications, it would be almost sufficient. </span><span class="koboSpan" id="kobo.464.2">But in the microservice world, we need to trace requests end to end and, therefore, propagate context over the wire, and here’s where standards come </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">into play.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">You can find multiple practices in this space – every complex system used to support something custom, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">x-correlation-id</span></strong><span class="koboSpan" id="kobo.468.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">x-request-id</span></strong><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">You can find </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">x-cloud-trace-context</span></strong><span class="koboSpan" id="kobo.472.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">grpc-trace-bin</span></strong><span class="koboSpan" id="kobo.474.1"> in old Google systems, </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">X-Amzn-Trace-Id</span></strong><span class="koboSpan" id="kobo.476.1"> on AWS, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Request-Id</span></strong><span class="koboSpan" id="kobo.478.1"> variations and </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">ms-cv</span></strong><span class="koboSpan" id="kobo.480.1"> in the Microsoft ecosystem. </span><span class="koboSpan" id="kobo.480.2">Assuming your system is heterogeneous and uses a variety of cloud providers and tracing tools, correlation </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">is difficult.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Trace</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.483.1"> context (which you can explore in more detail at </span><a href="https://www.w3.org/TR/trace-context"><span class="koboSpan" id="kobo.484.1">https://www.w3.org/TR/trace-context</span></a><span class="koboSpan" id="kobo.485.1">) is a relatively new standard, converting context propagation over HTTP, but it’s widely adopted and used by default in OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">and .NET.</span></span></p>
<h3><span class="koboSpan" id="kobo.487.1">W3C Trace Context</span></h3>
<p><span class="koboSpan" id="kobo.488.1">The trace context</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.489.1"> standard defines </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">traceparent</span></strong><span class="koboSpan" id="kobo.491.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">tracestate</span></strong><span class="koboSpan" id="kobo.493.1"> HTTP headers and</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.494.1"> the format to populate context </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">on them.</span></span></p>
<h4><span class="koboSpan" id="kobo.496.1">The traceparent header</span></h4>
<p><span class="koboSpan" id="kobo.497.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">traceparent</span></strong><span class="koboSpan" id="kobo.499.1"> is an HTTP request header</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.500.1"> that carries the protocol version, </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">trace-id</span></strong><span class="koboSpan" id="kobo.502.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">parent-id</span></strong><span class="koboSpan" id="kobo.504.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">trace-flags</span></strong><span class="koboSpan" id="kobo.506.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">following format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
traceparent: {version}-{trace-id}-{parent-id}-{trace-flags}</span></pre>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">version</span></strong><span class="koboSpan" id="kobo.510.1">: The protocol version – only </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">00</span></strong><span class="koboSpan" id="kobo.512.1"> is defined at </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the moment.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">trace-id</span></strong><span class="koboSpan" id="kobo.515.1">: The logical end-to-end </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">operation ID.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">parent-id</span></strong><span class="koboSpan" id="kobo.518.1">: Identifies the client span and serves as a parent for the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">server span.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">trace-flags</span></strong><span class="koboSpan" id="kobo.521.1">: Represents the sampling decision (which we’ll talk about in </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.522.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.523.1">, </span><em class="italic"><span class="koboSpan" id="kobo.524.1">Configuration and Control Plane</span></em><span class="koboSpan" id="kobo.525.1">). </span><span class="koboSpan" id="kobo.525.2">For now, we can determine that </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">00</span></strong><span class="koboSpan" id="kobo.527.1"> indicates that the parent span was sampled out and </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">01</span></strong><span class="koboSpan" id="kobo.529.1"> means it was </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">sampled in.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.531.1">All identifiers must be present – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">traceparent</span></strong><span class="koboSpan" id="kobo.533.1"> has a fixed length</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.534.1"> and is easy to parse. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.535.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.536.1">.8</span></em><span class="koboSpan" id="kobo.537.1"> shows an example of context propagation with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">traceparent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1"> header:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.540.1"><img alt="Figure 1.8 – traceparent is populated from the outgoing span context and becomes a parent for the incoming span" src="image/B19423_01_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.541.1">Figure 1.8 – traceparent is populated from the outgoing span context and becomes a parent for the incoming span</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.542.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.543.1">The protocol does not require creating spans and does not specify instrumentation points. </span><span class="koboSpan" id="kobo.543.2">Common practice is to create spans per outgoing and incoming requests, and put client span context into </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">request headers.</span></span></p>
<h4><span class="koboSpan" id="kobo.545.1">The tracestate header</span></h4>
<p><span class="koboSpan" id="kobo.546.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">tracestate</span></strong><span class="koboSpan" id="kobo.548.1"> is another request header, which carries</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.549.1"> additional context for the tracing tool to use. </span><span class="koboSpan" id="kobo.549.2">It’s </span><em class="italic"><span class="koboSpan" id="kobo.550.1">designed for OpenTelemetry or an APM tool to carry additional control information and not for application-specific context</span></em><span class="koboSpan" id="kobo.551.1"> (covered in detail later in the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.552.1">Baggage</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">tracestate</span></strong><span class="koboSpan" id="kobo.556.1"> consists of a list of key-value pairs, serialized to a string with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">format: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">"vendor1=value1,vendor2=value2"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">tracestate</span></strong><span class="koboSpan" id="kobo.562.1"> can be used to propagate incompatible legacy correlation IDs, or some additional identifiers </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">vendor needs.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">OpenTelemetry, for example, uses it to carry a sampling probability and score. </span><span class="koboSpan" id="kobo.564.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">tracestate: "ot=r:3;p:2"</span></strong><span class="koboSpan" id="kobo.566.1"> represents a key-value pair, where the key is </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">ot</span></strong><span class="koboSpan" id="kobo.568.1"> (OpenTelemetry tag) and the value </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">r:3;p:2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">tracestate</span></strong><span class="koboSpan" id="kobo.574.1"> header has a soft limitation</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.575.1"> on size (512 characters) and can </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">be truncated.</span></span></p>
<h4><span class="koboSpan" id="kobo.577.1">The traceresponse (draft) header</span></h4>
<p><span class="koboSpan" id="kobo.578.1">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">traceparent</span></strong><span class="koboSpan" id="kobo.580.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">tracestate</span></strong><span class="koboSpan" id="kobo.582.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.583.1">traceresponse</span></strong><span class="koboSpan" id="kobo.584.1"> is a response header. </span><span class="koboSpan" id="kobo.584.2">At the time</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.585.1"> of writing, it’s defined</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.586.1"> in W3C Trace-Context Level 2 (</span><a href="https://www.w3.org/TR/trace-context-2/"><span class="koboSpan" id="kobo.587.1">https://www.w3.org/TR/trace-context-2/</span></a><span class="koboSpan" id="kobo.588.1">) and has reached W3C Editor’s Draft status. </span><span class="koboSpan" id="kobo.588.2">There is no support for it in .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">or OpenTelemetry.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">traceresponse</span></strong><span class="koboSpan" id="kobo.591.1"> is very similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">traceparent</span></strong><span class="koboSpan" id="kobo.593.1">. </span><span class="koboSpan" id="kobo.593.2">It has the same format, but instead of client-side identifiers, it returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">trace-id</span></strong><span class="koboSpan" id="kobo.595.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">span-id</span></strong><span class="koboSpan" id="kobo.597.1"> values of the </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">server span:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
traceresponse: 00-{trace-id}-{child-id}-{trace-flags}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">traceresponse</span></strong><span class="koboSpan" id="kobo.601.1"> is optional in the sense that the server does not need to return it, even if it supports W3C Trace-Context Level 2. </span><span class="koboSpan" id="kobo.601.2">It’s useful to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">traceresponse</span></strong><span class="koboSpan" id="kobo.603.1"> when the client did not pass a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">traceparent</span></strong><span class="koboSpan" id="kobo.605.1">, but can </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">log </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">traceresponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">External-facing services may decide to start a new trace, because they don’t trust the caller’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">trace-id</span></strong><span class="koboSpan" id="kobo.611.1"> generation algorithm. </span><span class="koboSpan" id="kobo.611.2">Uniform random distribution is one concern; another reason could be a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">trace-id</span></strong><span class="koboSpan" id="kobo.613.1"> format. </span><span class="koboSpan" id="kobo.613.2">If the service restarts a trace, it’s a good idea to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">traceresponse</span></strong><span class="koboSpan" id="kobo.615.1"> header </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">to caller.</span></span></p>
<h3><span class="koboSpan" id="kobo.617.1">B3</span></h3>
<p><span class="koboSpan" id="kobo.618.1">The B3</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.619.1"> specification (</span><a href="https://github.com/openzipkin/b3-propagation"><span class="koboSpan" id="kobo.620.1">https://github.com/openzipkin/b3-propagation</span></a><span class="koboSpan" id="kobo.621.1">) was adopted</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.622.1"> by Zipkin – one of the first distributed </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">tracing systems.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">B3 identifiers can be propagated as a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">b3</span></strong><span class="koboSpan" id="kobo.626.1"> header in the </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">following format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
b3: {trace-id}-{span-id}-{sampling-state}-{parent-span-id}</span></pre>
<p><span class="koboSpan" id="kobo.629.1">Another way is to pass individual components, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">X-B3-TraceId</span></strong><span class="koboSpan" id="kobo.631.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">X-B3-SpanId</span></strong><span class="koboSpan" id="kobo.633.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">X-B3-ParentSpanId</span></strong><span class="koboSpan" id="kobo.635.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">X-B3-Sampled</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">The sampling state suggests whether a service should trace the corresponding request. </span><span class="koboSpan" id="kobo.639.2">In addition to </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">0</span></strong><span class="koboSpan" id="kobo.641.1"> (don’t record) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">1</span></strong><span class="koboSpan" id="kobo.643.1"> (do record), it allows us to force tracing with a flag set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">d</span></strong><span class="koboSpan" id="kobo.645.1">. </span><span class="koboSpan" id="kobo.645.2">It’s usually done for debugging purposes. </span><span class="koboSpan" id="kobo.645.3">The sampling state can be passed without other identifiers to specify the desired sampling decision to </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">the service.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.647.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.648.1">The key difference with W3C Trace-Context, beyond header names, is the presence of both </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">span-id</span></strong><span class="koboSpan" id="kobo.650.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">parent-span-id</span></strong><span class="koboSpan" id="kobo.652.1">. </span><span class="koboSpan" id="kobo.652.2">B3 systems can use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">span-id</span></strong><span class="koboSpan" id="kobo.654.1"> on the client and server sides, creating a single span </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">for both.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">Zipkin reuses </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">span-id</span></strong><span class="koboSpan" id="kobo.658.1"> from the incoming request, also specifying </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">parent-span-id</span></strong><span class="koboSpan" id="kobo.660.1"> on it. </span><span class="koboSpan" id="kobo.660.2">The Zipkin span represents the client and server at the same time, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.661.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.662.1">.9</span></em><span class="koboSpan" id="kobo.663.1">, recording different durations and statuses </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">for them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.665.1"><img alt="Figure 1.9 – Zipkin creates one span to represent the client and server" src="image/B19423_01_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.666.1">Figure 1.9 – Zipkin creates one span to represent the client and server</span></p>
<p><span class="koboSpan" id="kobo.667.1">OpenTelemetry and .NET support </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">b3</span></strong><span class="koboSpan" id="kobo.669.1"> headers</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.670.1"> but ignore </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">parent-span-id</span></strong><span class="koboSpan" id="kobo.672.1"> – they generate a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">span-id</span></strong><span class="koboSpan" id="kobo.674.1"> for every span, as it’s not possible</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.675.1"> to reuse </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">span-id</span></strong><span class="koboSpan" id="kobo.677.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.678.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.679.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.681.1"><img alt="Figure 1.10 – OpenTelemetry does not use parent-span-id from B3 headers and creates different spans for the client and server" src="image/B19423_01_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.682.1">Figure 1.10 – OpenTelemetry does not use parent-span-id from B3 headers and creates different spans for the client and server</span></p>
<h3><span class="koboSpan" id="kobo.683.1">Baggage</span></h3>
<p><span class="koboSpan" id="kobo.684.1">So far, we have talked about span</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.685.1"> context and correlation. </span><span class="koboSpan" id="kobo.685.2">But in many cases, distributed</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.686.1"> systems have application-specific context. </span><span class="koboSpan" id="kobo.686.2">For example, you authorize users on your frontend service, and after that, </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">user-id</span></strong><span class="koboSpan" id="kobo.688.1"> is not needed for application logic, but you still want to add it as an attribute on spans from all services to query and aggregate it on a </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">per-user basis.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">You can stamp </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">user-id</span></strong><span class="koboSpan" id="kobo.692.1"> once on the frontend. </span><span class="koboSpan" id="kobo.692.2">Then, spans recorded on the backend will not have </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">user-id</span></strong><span class="koboSpan" id="kobo.694.1">, but they will share the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">trace-id</span></strong><span class="koboSpan" id="kobo.696.1"> as the frontend. </span><span class="koboSpan" id="kobo.696.2">So, with some joins in your queries, you can still do per-user analysis. </span><span class="koboSpan" id="kobo.696.3">It works to some extent but may be expensive or slow, so you might decide to propagate </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">user-id</span></strong><span class="koboSpan" id="kobo.698.1"> and stamp it on the backend </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">spans too.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.701.1">baggage</span></strong><span class="koboSpan" id="kobo.702.1"> (</span><a href="https://www.w3.org/TR/baggage/"><span class="koboSpan" id="kobo.703.1">https://www.w3.org/TR/baggage/</span></a><span class="koboSpan" id="kobo.704.1">) defines a generic propagation</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.705.1"> format for distributed</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.706.1"> context, and you can use it for business logic or anything else by adding, reading, removing, and modifying baggage members. </span><span class="koboSpan" id="kobo.706.2">For example, you can route requests to the test environment and pass feature flags or extra </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">telemetry context.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">Baggage consists of a list of semicolon-separated members. </span><span class="koboSpan" id="kobo.708.2">Each member has a key, value, and optional properties in the following formats –</span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1"> key=value;property1;key2=property2</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.710.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">key=value;property1;key2=property2,anotherKey=anotherValue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">OpenTelemetry and .NET only propagate baggage, but don’t stamp it on any telemetry. </span><span class="koboSpan" id="kobo.713.2">You can configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">ILogger</span></strong><span class="koboSpan" id="kobo.715.1"> to stamp baggage and need to enrich traces explicitly. </span><span class="koboSpan" id="kobo.715.2">We’ll see how it works in </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.716.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.717.1">, </span><em class="italic"><span class="koboSpan" id="kobo.718.1">Configuration and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.719.1">Control Plane</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.721.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.722.1">You should not put any sensitive information in baggage, as it’s almost impossible to guarantee where it would flow – your application or sidecar infrastructure can forward it to your cloud provider or </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">anywhere else.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.724.1">Maintain a list of well-known baggage keys across your system and only use known ones, as you might receive baggage from another </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">system otherwise.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">Baggage specification</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.727.1"> has a </span><em class="italic"><span class="koboSpan" id="kobo.728.1">working draft</span></em><span class="koboSpan" id="kobo.729.1"> status and may </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">still</span></span><span class="No-Break"><a id="_idIndexMarker070"/></span><span class="No-Break"><span class="koboSpan" id="kobo.731.1"> change.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.732.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.733.1">While the W3C Trace Context standard is HTTP-specific and B3 applies to any RPC calls, they are commonly used for any context propagation needs – for example, they are passed as the event payload in messaging scenarios. </span><span class="koboSpan" id="kobo.733.2">This may change once protocol-specific standards </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">are introduced.</span></span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.735.1">Ensuring consistency and structure</span></h1>
<p><span class="koboSpan" id="kobo.736.1">As we already defined, spans</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.737.1"> are structured</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.738.1"> events describing </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">interesting operations.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">A span’s start time, duration, status, kind, and context are strongly typed – they enable correlation and causation, allowing us to visualize traces and detect failures or </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">latency issues.</span></span></p>
<p><span class="koboSpan" id="kobo.742.1">The span’s name and attributes describe an operation but are not strongly typed or strictly defined. </span><span class="koboSpan" id="kobo.742.2">If we don’t populate them in a meaningful way, we can detect an issue but have no knowledge of what </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">actually happened.</span></span></p>
<p><span class="koboSpan" id="kobo.744.1">For example, for client HTTP calls, beyond generic properties, we want to capture at least the URL, method, and response code (or exception) – if we don’t know any of these, we’re blind. </span><span class="koboSpan" id="kobo.744.2">Once we populate them, we can start doing some powerful analysis with queries over such spans to answer the following </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">common questions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.746.1">Which dependency calls were made in the scope of this request? </span><span class="koboSpan" id="kobo.746.2">Which of them failed? </span><span class="koboSpan" id="kobo.746.3">What was the latency of each </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">of them?</span></span></li>
<li><span class="koboSpan" id="kobo.748.1">Does my application make independent dependency calls in parallel or sequentially? </span><span class="koboSpan" id="kobo.748.2">Does it make any unnecessary requests when they can be </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">done lazily?</span></span></li>
<li><span class="koboSpan" id="kobo.750.1">Are dependency endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">configured correctly?</span></span></li>
<li><span class="koboSpan" id="kobo.752.1">What are the success or error rates and latency per </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">dependency API?</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.754.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.755.1">This analysis relies on an application using the same attributes for all HTTP dependencies. </span><span class="koboSpan" id="kobo.755.2">Otherwise, the operator that performs the queries will have a hard time writing and </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">maintaining them.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">With unified and community-driven telemetry collection taken off the observability vendor’s plate, they can now fully focus on (semi-)automating analysis and giving us powerful performance and fault </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">analysis tools.</span></span></p>
<p><span class="koboSpan" id="kobo.759.1">OpenTelemetry defines</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.760.1"> a set of semantic</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.761.1"> conventions for spans, traces, and resources, which we’ll talk more about in </span><a href="B19423_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.762.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.763.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.764.1">Best Practices</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.766.1">Building application topology</span></h2>
<p><span class="koboSpan" id="kobo.767.1">Distributed tracing, combined</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.768.1"> with semantic conventions, allows us to build visualizations such as an application map (aka service map), as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.769.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.770.1">.11</span></em><span class="koboSpan" id="kobo.771.1"> – you could see your whole system along with key health metrics. </span><span class="koboSpan" id="kobo.771.2">It’s an entry point to </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">any investigation.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.773.1"><img alt="Figure 1.11 – An Azure Monitor ﻿application map for a meme service is an up-to-date system diagram with all the basic health metrics" src="image/B19423_01_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.774.1">Figure 1.11 – An Azure Monitor application map for a meme service is an up-to-date system diagram with all the basic health metrics</span></p>
<p><span class="koboSpan" id="kobo.775.1">Observability vendors depend on trace and metrics semantics to build service maps. </span><span class="koboSpan" id="kobo.775.2">For example, the presence of HTTP attributes on the client span represents an outgoing HTTP call, and we need to show the outgoing arrow to a new dependency node. </span><span class="koboSpan" id="kobo.775.3">We should name this node based on the span’s </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">host attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">If we see the corresponding</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.778.1"> server span, we can now merge the server node with the dependency node, based on span context and causation. </span><span class="koboSpan" id="kobo.778.2">There are other visualizations or automation tools that you might find useful – for example, critical path analysis, or finding common attributes that correspond to higher latency or error rates. </span><span class="koboSpan" id="kobo.778.3">Each of these relies on span properties and attributes following common semantics</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.779.1"> or at least being consistent </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">across services.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.781.1">Resource attributes</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.782.1">Resource attributes</span></strong><span class="koboSpan" id="kobo.783.1"> describe the process, host, service, and</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.784.1"> environment, and are the same for all spans reported by the service instance – for example, the service name, version, unique service instance ID, cloud provider account ID, region, availability zone, and </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">K8s metadata.</span></span></p>
<p><span class="koboSpan" id="kobo.786.1">These attributes allow us to detect anomalies specific to certain environments or instances – for example, an error rate increase only on instances that have a new version of code, an instance that goes into a restart loop, or a cloud service in a region and availability zone that </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">experiences issues.</span></span></p>
<p><span class="koboSpan" id="kobo.788.1">Based on standard attributes, observability vendors can write generic queries to perform this analysis or build common dashboards. </span><span class="koboSpan" id="kobo.788.2">It also enables the community to create vendor-agnostic tools and solutions for </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">popular technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.790.1">Such attributes describe a service instance and don’t have to appear on every span – OTLP, for example, passes resource attributes once per batch </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">of spans.</span></span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.792.1">Performance analysis overview</span></h1>
<p><span class="koboSpan" id="kobo.793.1">Now that you know the core concepts</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.794.1"> around distributed</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.795.1"> tracing, let’s see how we can use the observability stack to investigate common distributed </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">system problems.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.797.1">The baseline</span></h2>
<p><span class="koboSpan" id="kobo.798.1">Before we talk about</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.799.1"> problems, let’s establish a baseline representing the behavior of a healthy system. </span><span class="koboSpan" id="kobo.799.2">We also need it to make data-driven decisions to help with common design and development tasks such as </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.801.1">Risk estimation</span></strong><span class="koboSpan" id="kobo.802.1">: Any feature work on the hot path is a good candidate for additional performance testing prior to release and guarding new code with </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">feature flags.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.804.1">Capacity planning</span></strong><span class="koboSpan" id="kobo.805.1">: Knowing the current load is necessary to understand whether a system can handle planned growth and </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">new features.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.807.1">Understand improvement potential</span></strong><span class="koboSpan" id="kobo.808.1">: It makes more sense to optimize frequently executed code, as even small optimizations bring significant performance gains or cost reductions. </span><span class="koboSpan" id="kobo.808.2">Similarly, improving reliability brings the most benefits for components that have a higher error rate and that are used by </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">other services.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.810.1">Learning usage patterns</span></strong><span class="koboSpan" id="kobo.811.1">: Depending on how users interact with your system, you might change your scaling or caching strategy, extract specific functionality to a new service, or </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">merge services.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.813.1">Generic indicators that describe the performance</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.814.1"> of each service include </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.816.1">Latency</span></strong><span class="koboSpan" id="kobo.817.1">: How fast a </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">service responds</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.819.1">Throughput</span></strong><span class="koboSpan" id="kobo.820.1">: How many requests, events, or bytes the service is handling </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">per second</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.822.1">Error rate</span></strong><span class="koboSpan" id="kobo.823.1">: How many errors a </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">service returns</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.825.1">Your system might need other indicators to measure durability or </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">data correctness.</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">Each of these signals is useful when it includes an API route, a status code, and other context properties. </span><span class="koboSpan" id="kobo.827.2">For example, the error rate could be low overall but high for specific users or </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">API routes.</span></span></p>
<p><span class="koboSpan" id="kobo.829.1">Measuring signals on the server</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.830.1"> and client sides, whenever possible, gives you a better picture. </span><span class="koboSpan" id="kobo.830.2">For example, you can detect network failures and avoid “</span><em class="italic"><span class="koboSpan" id="kobo.831.1">it works on my machine</span></em><span class="koboSpan" id="kobo.832.1">” situations when clients see issues and </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">servers don’t.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.834.1">Investigating performance issues</span></h2>
<p><span class="koboSpan" id="kobo.835.1">Let’s divide performance issues</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.836.1"> into two </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">overlapping categories:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.838.1">Widespread issues that affect a whole instance, server, or even the system, and move the </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">distribution median.</span></span></li>
<li><span class="koboSpan" id="kobo.840.1">An individual request or job that takes too much time to complete. </span><span class="koboSpan" id="kobo.840.2">If we visualize the latency distribution, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.841.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.842.1">.12</span></em><span class="koboSpan" id="kobo.843.1">, we’ll see such issues in the long tail</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.844.1"> of distribution – they are rare, but part of </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">normal behavior.</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.846.1"><img alt="Figure 1.12 – Azure Monitor latency distribution visualization, with a median request (the 50th percentile) taking around 80 ms and the 95th percentile around 250 ms" src="image/B19423_01_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.847.1">Figure 1.12 – Azure Monitor latency distribution visualization, with a median request (the 50th percentile) taking around 80 ms and the 95th percentile around 250 ms</span></p>
<h3><span class="koboSpan" id="kobo.848.1">Long tails</span></h3>
<p><span class="koboSpan" id="kobo.849.1">Individual issues</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.850.1"> can be caused by an unfortunate chain of events – transient</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.851.1"> network issues, high contention in optimistic concurrency algorithms, hardware failures, and </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.853.1">Distributed tracing is an excellent tool to investigate such issues. </span><span class="koboSpan" id="kobo.853.2">If you have a bug report, you might have a trace context for a problematic operation. </span><span class="koboSpan" id="kobo.853.3">To achieve it, make sure you show the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">traceparent</span></strong><span class="koboSpan" id="kobo.855.1"> value on the web page and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">traceresponse</span></strong><span class="koboSpan" id="kobo.857.1"> or a document that users need to record, or log </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">traceresponse</span></strong><span class="koboSpan" id="kobo.859.1"> when sending requests to </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">your service.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">So, if you know the trace context, you can start by checking the trace view. </span><span class="koboSpan" id="kobo.861.2">For example, in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.862.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.863.1">.13</span></em><span class="koboSpan" id="kobo.864.1">, you can see an example of a long request caused by transient </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">network issues.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.866.1"><img alt="Figure 1.13 – A request with high latency caused by transient network issues and retries" src="image/B19423_01_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.867.1">Figure 1.13 – A request with high latency caused by transient network issues and retries</span></p>
<p><span class="koboSpan" id="kobo.868.1">The frontend request took about 2.6 seconds and the time was spent on the storage service downloading meme content. </span><span class="koboSpan" id="kobo.868.2">We see three tries of </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">Azure.Core.Http.Request</span></strong><span class="koboSpan" id="kobo.870.1">, each of which was fast, and the time between them corresponds to the back-off interval. </span><span class="koboSpan" id="kobo.870.2">The last try </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">was successful.</span></span></p>
<p><span class="koboSpan" id="kobo.872.1">If you don’t have </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">trace-id</span></strong><span class="koboSpan" id="kobo.874.1">, or perhaps if the trace was sampled out, you might be able to filter similar operations based on the context and </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">high latency.</span></span></p>
<p><span class="koboSpan" id="kobo.876.1">For example, in Jaeger, you can filter</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.877.1"> spans based on the service, span</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.878.1"> name, attributes, and duration, which helps you to find a needle in </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">a haystack.</span></span></p>
<p><span class="koboSpan" id="kobo.880.1">In some cases, you will end up with mysterious gaps – the service was up and running but spent significant time doing nothing, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.881.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.882.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.884.1"><img alt="Figure 1.14 – A request with high latency and gaps in spans" src="image/B19423_01_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.885.1">Figure 1.14 – A request with high latency and gaps in spans</span></p>
<p><span class="koboSpan" id="kobo.886.1">If you don’t get enough data from traces, check whether there are any logs available in the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">this span.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">You might also check resource utilization metrics – was there a CPU spike, or maybe a garbage collection pause at this moment? </span><span class="koboSpan" id="kobo.888.2">You might find some correlation using timestamps and context, but it’s impossible to tell whether this was a root cause or </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">a coincidence.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">If you have a continuous profiler that correlates profiles to traces (yes, they can do it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.892.1">), you can check whether there are profiles available for this or </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">similar operations.</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">We’ll see how to investigate this further with .NET diagnostics tools in </span><a href="B19423_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.895.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.896.1">, </span><em class="italic"><span class="koboSpan" id="kobo.897.1">Low-Level Performance Analysis with Diagnostic Tools</span></em><span class="koboSpan" id="kobo.898.1">, but if you’re curious about what happened in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.899.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.900.1">.14</span></em><span class="koboSpan" id="kobo.901.1">, the service read a network stream that was </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">not instrumented.</span></span></p>
<p><span class="koboSpan" id="kobo.903.1">Even though we talk about individual performance</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.904.1"> issues, in many cases we</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.905.1"> don’t know how widespread they are, especially when we’re at the beginning of an incident. </span><span class="koboSpan" id="kobo.905.2">Metrics and rich queries across traces can be used to find out how common a problem is. </span><span class="koboSpan" id="kobo.905.3">If you’re on call, checking whether an issue is widespread or becoming more frequent is usually more urgent than finding the </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">root cause.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.907.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.908.1">Long-tail latency requests are inevitable in distributed systems, but there are always opportunities for optimization, with caching, collocation, adjusting timeouts and the retry policy, and so on. </span><span class="koboSpan" id="kobo.908.2">Monitoring P95 latency and analyzing traces for long-tail issues helps you find such areas </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">for improvement.</span></span></p>
<h3><span class="koboSpan" id="kobo.910.1">Performance issues</span></h3>
<p><span class="koboSpan" id="kobo.911.1">Performance problems</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.912.1"> manifest as latency or throughput degradation beyond usual variations. </span><span class="koboSpan" id="kobo.912.2">Assuming you fail fast or rate-limit incoming calls, you might also see an increase in the error rate for </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">408</span></strong><span class="koboSpan" id="kobo.914.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">429</span></strong><span class="koboSpan" id="kobo.916.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">503</span></strong><span class="koboSpan" id="kobo.918.1"> HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">status codes.</span></span></p>
<p><span class="koboSpan" id="kobo.920.1">Such issues can start as a slight decrease in dependency availability, causing a service to retry. </span><span class="koboSpan" id="kobo.920.2">With outgoing requests taking more resources than usual, other operations slow down, and the time to process client requests grows, along with number of active requests </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">and connections.</span></span></p>
<p><span class="koboSpan" id="kobo.922.1">It could be challenging to understand what happened first; you might see high CPU usage and a relatively high GC rate  – all symptoms you would usually see on an overloaded system, but nothing that stands out. </span><span class="koboSpan" id="kobo.922.2">Assuming you measure the dependency throughput and error rate, you could see the anomaly there, but it might be difficult to tell whether it’s a cause </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">or effect.</span></span></p>
<p><span class="koboSpan" id="kobo.924.1">Individual distributed traces</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.925.1"> are rarely useful in such cases – each operation takes longer, and there are more transient errors, but traces may look </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">normal otherwise.</span></span></p>
<p><span class="koboSpan" id="kobo.927.1">Here’s a list of trivial things to check first, and they serve as a foundation for more </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">advanced analysis:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.929.1">Is there an active deployment or a recent feature rollout? </span><span class="koboSpan" id="kobo.929.2">You can find out whether a problem is specific to instances running a new version of code using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">service.version</span></strong><span class="koboSpan" id="kobo.931.1"> resource attribute. </span><span class="koboSpan" id="kobo.931.2">If you include feature flags on your traces or events, you can query them to check whether degradation is limited to (or started from) the requests with a new </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">feature enabled.</span></span></li>
<li><span class="koboSpan" id="kobo.933.1">Are issues specific to a certain API, code path, or combination of attributes? </span><span class="koboSpan" id="kobo.933.2">Some backends, such as Honeycomb, automate this analysis, finding attributes corresponding to a higher latency or </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">error rate.</span></span></li>
<li><span class="koboSpan" id="kobo.935.1">Are all instances affected? </span><span class="koboSpan" id="kobo.935.2">How many instances are alive? </span><span class="koboSpan" id="kobo.935.3">Attribute-based analysis is helpful </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">here too.</span></span></li>
<li><span class="koboSpan" id="kobo.937.1">Are your dependencies healthy? </span><span class="koboSpan" id="kobo.937.2">If you can, check their server-side telemetry and see whether they experience problems with other services, not </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">just yours.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.939.1">Attribute analysis can help here as well – assuming just one of your cloud storage accounts or database partitions is misbehaving, you will see it.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.940.1">Did the load increase sharply prior to the incident? </span><span class="koboSpan" id="kobo.940.2">Or, if your service is auto-scaled, is the auto-scaler functioning properly, and are you able to catch up with </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">the load?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.942.1">There are more questions to ask about infrastructure, the cloud provider, and other aspects. </span><span class="koboSpan" id="kobo.942.2">The point of this exercise is to narrow down and understand the problem as much as possible. </span><span class="koboSpan" id="kobo.942.3">If the problem is not in your code, investigation helps to find a better way to handle problems like these in the future and gives you an opportunity to fill the gaps in your telemetry, so next time something similar happens, you can identify </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">it faster.</span></span></p>
<p><span class="koboSpan" id="kobo.944.1">If you suspect a problem</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.945.1"> in your code, .NET provides a set of signals and tools to help investigate high CPU, memory leaks, deadlocks, thread pool starvation, and profile code, as we’ll see in </span><a href="B19423_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.946.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.947.1">, </span><em class="italic"><span class="koboSpan" id="kobo.948.1">Low-Level Performance Analysis with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.949.1">Diagnostic Tools</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.951.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.952.1">Distributed systems need a new approach to observability that simplifies investigating incidents and minimizes the time to resolve issues. </span><span class="koboSpan" id="kobo.952.2">This approach should focus on human experience such as data visualization, the correlation across telemetry signals, and analysis automation. </span><span class="koboSpan" id="kobo.952.3">It requires structured, correlated telemetry signals that work together and new tools that leverage them to build a </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">rich experience.</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">Distributed tracing is one such signal – it follows requests through any system and describes service operations with spans, the events representing operations in the system. </span><span class="koboSpan" id="kobo.954.2">.NET supports distributed tracing and integrates natively with OpenTelemetry, which is a cross-language platform to collect, process, and export traces, metrics, and logs in a vendor-agnostic way. </span><span class="koboSpan" id="kobo.954.3">Most modern vendors are compatible with OpenTelemetry and leverage distributed tracing capabilities. </span><span class="koboSpan" id="kobo.954.4">The OpenTelemetry ecosystem includes a diverse set of shared instrumentation libraries that automate common telemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">collection needs.</span></span></p>
<p><span class="koboSpan" id="kobo.956.1">Distributed tracing enables correlation and causation by propagating context within the process and between services. </span><span class="koboSpan" id="kobo.956.2">OpenTelemetry defines standard semantics for common technologies so that vendors can build trace visualizations, application maps, shared dashboards, alerts, or queries that rely on consistent and standard attributes. </span><span class="koboSpan" id="kobo.956.3">Trace context and consistent attributes enable correlation between spans, logs, metrics, and any other signals coming from </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">your system.</span></span></p>
<p><span class="koboSpan" id="kobo.958.1">Individual issues can be efficiently analyzed with distributed tracing and investigations into widespread performance issues rely on attributes and timestamp correlation on metrics and across traces. </span><span class="koboSpan" id="kobo.958.2">Observability vendors may automate </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">this analysis.</span></span></p>
<p><span class="koboSpan" id="kobo.960.1">A combination of metrics, traces, and events gives the right number of details. </span><span class="koboSpan" id="kobo.960.2">Metrics allow us to receive unbiased data in a cost-effective way. </span><span class="koboSpan" id="kobo.960.3">By querying traces and events over high-cardinality attributes, we can answer ad hoc questions about </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.962.1">In the next chapter, we’ll get hands-on experience with distributed tracing. </span><span class="koboSpan" id="kobo.962.2">We’ll build a demo application and explore native tracing capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">in .NET.</span></span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.964.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.965.1">How would you define spans and traces? </span><span class="koboSpan" id="kobo.965.2">What information does a </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">span contain?</span></span></li>
<li><span class="koboSpan" id="kobo.967.1">How does span </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">correlation work?</span></span></li>
<li><span class="koboSpan" id="kobo.969.1">Assuming you are on call and receive a report from a user about slow response time from your service, how would you approach </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">the investigation?</span></span></li>
</ol>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.971.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.972.1">Cloud-Native Observability with OpenTelemetry</span></em><span class="koboSpan" id="kobo.973.1"> by </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">Alex Boten</span></span></li>
</ul>
</div>
</body></html>