- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technical Debt, Code Smells, and Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New software projects start out clean and optimistic, but quickly grow in complexity
    and difficulty to maintain until the code is difficult to understand, brittle
    to change, and impossible to test.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve worked with code for any length of time, chances are you’ve come across
    code like this. In fact, if you’ve been in development for even a little bit of
    time, it’s likely you’ve *written* code you now regret.
  prefs: []
  type: TYPE_NORMAL
- en: It could be that the code is hard to read or understand. Maybe the code is inefficient
    or prone to errors. Perhaps the code was built under a certain set of business
    assumptions that later changed. Maybe the code simply no longer conforms to the
    standards you and your team have agreed to. Whatever the reason, bad code feels
    like it is practically everywhere in codebases of any significant size or age.
  prefs: []
  type: TYPE_NORMAL
- en: This code litters our software projects and reduces our development speed, causes
    us to introduce bugs, and generally makes us less happy and productive as software
    engineers.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we’ll talk about how technical debt arises and what we can do
    about it through the process of refactoring, guided by tests and code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding technical debt and legacy code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying code smells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding technical debt and legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While computer science education, books, tutorials, and online courses all focus
    on creating new projects from scratch, the reality is that almost all development
    jobs you’ll have will center around understanding, maintaining, and expanding
    pre-existing code that may not meet your current standards.
  prefs: []
  type: TYPE_NORMAL
- en: This pre-existing code is referred to as **legacy code**. You almost always
    inherit some amount of legacy code when joining a new project. This can be a large
    amount of code for pre-existing projects or a smaller set of libraries your code
    must work with.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different definitions of the term *legacy code*. One that stands
    out to me from my readings is Michael C. Feather’s definition, in *Working Effectively
    with Legacy Code*, that legacy code is *code* *without tests*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While I like Michael’s definition and believe testing is critically important,
    as we’ll see in *Part 2* of this book, I personally define legacy code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Legacy code refers to any pre-existing code that would be implemented significantly
    differently were it* *rewritten today.*'
  prefs: []
  type: TYPE_NORMAL
- en: One key factor in legacy code is that it is *code you don’t currently fully
    understand* and as a result, its presence causes some degree of anxiety and apprehension.
  prefs: []
  type: TYPE_NORMAL
- en: This anxiety you feel when maintaining old systems is a prime symptom of something
    called **technical debt**.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, technical debt is *the negative effect of legacy code on future*
    *development efforts*.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, legacy code has a certain amount of inherent *risk* that bad
    things will happen when the code is modified. These bad things could be bugs that
    are introduced due to the brittleness of the pre-existing code (or our lack of
    understanding of it), slower development speed, or even catastrophic issues such
    as critical bugs or security breaches from out-of-date security practices or deprecated
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: What’s worse is that technical debt will only grow over time – particularly
    if left unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: Where technical debt comes from
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we move on, I want to address a common point of confusion I see in organizations:
    technical debt is not the same thing as bad code.'
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, some of the technical debt we have in our systems may be simply poor-quality
    code. It could be that an inexperienced developer wrote it and didn’t properly
    benefit from code review by other developers. Sometimes, projects are in a rush
    and the team didn’t have time to write the code properly to begin with, and never
    got to go back and clean it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, “quick and dirty” code written for prototypes makes it into production
    applications when “throwaway prototypes” get hastily promoted to actual production
    applications, as we’ll explore in [*Chapter 15*](B21324_15.xhtml#_idTextAnchor316)*:
    Communicating* *Technical Debt*.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are other causes of technical debt as well.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the development team is under the impression that they are building
    software to accomplish a specific task and then that task changes as business
    needs evolve and new information is discovered. In these cases, teams often don’t
    start over with the code they were writing. They simply evolve the old code to
    suit the new task at hand. The result is code that works but isn’t ideally suited
    for the new task.
  prefs: []
  type: TYPE_NORMAL
- en: This change in requirements is normal and even expected in software development
    environments. Modern software development occurs in an agile manner where requirements
    and plans naturally evolve over time and understanding them up-front is virtually
    impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Even if development teams understood requirements perfectly and wrote perfect
    code, this code will eventually become a form of technical debt due to the changing
    nature of software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: In software development, tools and libraries change over time. At the time of
    writing, **.NET 8** and **C# 12** are the latest ways to run C# code, but these
    technologies will go out of support at some point in the future only to be replaced
    by newer versions.
  prefs: []
  type: TYPE_NORMAL
- en: Even entire ways of thinking about software can change. Over the last twenty
    years, organizations have shifted from having their own on-premises servers to
    using cloud hosting on **Azure**, **AWS**, or **Google Cloud**. Even the very
    nature of what a server is has changed with technologies, including containerization
    technologies such as **Docker**, **platform as a service** (**PaaS**) offerings
    such as **Azure App Services**, and serverless computing offerings such as **Azure
    Functions** and **AWS Lambda**.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, newer AI technologies such as **ChatGPT** and **GitHub Copilot Chat**
    are poised to change what it even means to be a software developer, and this only
    underscores how much constant change is at the heart of the software engineering
    industry.
  prefs: []
  type: TYPE_NORMAL
- en: Change in software projects
  prefs: []
  type: TYPE_NORMAL
- en: In software development, change is a constant and can be unpredictable and sudden.
    All this change leads to code that was once considered perfect to later be considered
    a significant risk to the ongoing success of the business.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, technical debt is to some degree or another an unavoidable part
    of software development. Thankfully, you can take some steps to reduce the rate
    at which it accumulates (as we’ll discuss in *Part 2* of this book). Fortunately,
    we can detect technical debt through its symptoms, or “smells.”
  prefs: []
  type: TYPE_NORMAL
- en: Identifying code smells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how do you know whether your code has issues?
  prefs: []
  type: TYPE_NORMAL
- en: How do you know whether food has spoiled, clothing needs to be washed, or a
    diaper needs changing? It turns out that it just smells bad.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some metrics about what constitutes “good” and “bad” code, and we’ll
    explore them in [*Chapter 12*](B21324_12.xhtml#_idTextAnchor259)*: Code Analysis
    in Visual Studio* and [*Chapter 16*](B21324_16.xhtml#_idTextAnchor341)*: Adopting
    Code Standards*. Smelly code can be subjective to some degree or another. A developer
    who wrote a section of code or frequently modifies that portion of code may find
    the code to be more tolerable than a developer encountering the code for the first
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: While not all pieces of technical debt are identical, it turns out that many
    pieces of legacy code share a set of common symptoms.
  prefs: []
  type: TYPE_NORMAL
- en: 'These symptoms are commonly referred to as “code smells” and can include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s difficult to understand what it does or *why* it does it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You or people on your team avoid working with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s slower to modify than other areas or tends to break when modified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s hard to test or debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New code starts out good and pristine, but real code that lives in a business
    setting evolves over time as more capabilities are required and additional features
    and fixes are introduced. As that happens, code that was once nice and neat starts
    to accumulate code smells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all code is created equal, and not all code lasts as long as other pieces
    of code. Certainly, there are things we can do to make our code more resilient
    (as we’ll see in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173)*: Avoiding Code
    Anti-Patterns with SOLID*). However, at some point in time, your nice and shiny
    new code will start to get smelly and will need to be cleaned up through a process
    called refactoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Refactoring** is one of those words that doesn’t make a lot of sense to newer
    programmers, but here’s a simple definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Refactoring is the act of changing the shape or form of code without changing
    its functionality* *or behavior*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two key concepts here:'
  prefs: []
  type: TYPE_NORMAL
- en: The first concept is that refactoring is an effort to improve the maintainability
    of existing code. Sometimes, restructuring means introducing a new variable, method,
    or class. Other times, refactoring simply changes how individual lines of code
    are arranged or which language features are used. Even something as simple as
    renaming a variable could be considered a small act of refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second concept in this definition is that refactoring does not alter the
    *behavior* of the code in question. Refactoring is a structural change done to
    bring some piece of technical merit without altering the existing behavior of
    your code. If a method typically returned a certain value before you refactored
    it and now it returns a different value, that is a *change* and not a refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring also should provide some benefit to the engineering team. The code
    resulting from refactoring should be easier to understand, less likely to break
    when changed, and have less technical debt and fewer code smells than the starting
    code did.
  prefs: []
  type: TYPE_NORMAL
- en: Every line of code the development team produces should have a business value.
    Refactoring is no different, except the business value it produces should be more
    maintainable code with fewer issues and delays arising from its presence.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we try to improve our code through refactoring and we accidentally
    introduce new behavior – typically in the form of new bugs. This makes our refactoring
    become an unintentional change in the software that can result in emergency fixes
    to restore code to a working state.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking code while refactoring can be a critical problem and a significant
    barrier to being allowed to perform refactored code in the future, which in turn
    can allow technical debt to thrive.
  prefs: []
  type: TYPE_NORMAL
- en: In *Part 2* of this book, we’ll explore ways of safely refactoring your code
    so that you don’t accidentally introduce bugs, while in *Part 4*, we’ll discuss
    getting organizational buy-in to refactor your code, and what to do when a defect
    does arise out of your refactoring efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring tools in Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thankfully, all editions of **Visual Studio** now include refactoring tools
    built into the editor that allow you to quickly perform a set of common refactorings
    in a reliable and repeatable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026)*: Introduction to Refactoring*
    and the remaining chapters in *Part 1*, we’ll see a number of refactorings in
    action. Here’s a preview of some of the refactoring options Visual Studio provides
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Visual Studio Quick Actions context menu showing a set of refactoring
    operations](img/B21324_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Visual Studio Quick Actions context menu showing a set of refactoring
    operations
  prefs: []
  type: TYPE_NORMAL
- en: 'Tool-assisted refactorings such as these are fantastic for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They are fast and efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are reliable and repeatable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They *rarely* introduce defects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: Note that I use the word *rarely* when talking about bugs introduced by refactoring
    tools. There are a few rare scenarios where using the built-in refactoring tools
    without thinking about their actions may introduce bugs into your application.
    We’ll talk specifically about those areas as we encounter them in the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Over the rest of *Part 1*, we’ll explore using these tools to quickly and effectively
    refactor your C# applications and talk about the types of scenarios in which you
    might use each one of these.
  prefs: []
  type: TYPE_NORMAL
- en: With all that our tools can do, it is important to remember that these tools
    are just one way of refactoring code. Often, the most effective ways of removing
    code smells involve a combination of writing code yourself and using the built-in
    refactoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring’s key value is the long-term health of an organization, but many
    obstacles to refactoring can come from the organization itself. To help illustrate
    the practical aspects of refactoring in a real organization, each chapter will
    involve a case study from a fictitious organization. Some chapters will focus
    entirely on code from the case study while others, such as this chapter, will
    conclude with a dedicated case study section. These case study sections illustrate
    the concepts of the chapter applied to a fictitious organization.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s meet our first case study section and see how technical debt and legacy
    code affect a typical company.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – Cloudy Skies Airlines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rest of this book will follow code examples from an airline called **Cloudy
    Skies Airlines**, or **Cloudy Skies** for short. Through these examples, we should
    be able to see how technical debt and refactoring can apply to a “real” organization
    and its software.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Cloudy Skies is a fictitious airline company created for this book for teaching
    purposes only. Any resemblance to any real company is purely coincidental. Additionally,
    I have never worked in aviation, so the code examples presented in the book are
    likely significantly different from actual software systems used in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Cloudy Skies is an airline that’s been around for the past 50 years and currently
    operates a little over 500 jets in its fleet, serving around 70 cities in its
    region.
  prefs: []
  type: TYPE_NORMAL
- en: Twenty years ago, the airline made a major move and started replacing its aging
    software systems with custom in-house applications built by its development team.
    Cloudy Skies chose to use .NET and C#. The initial systems performed well and
    resulted in increased developer productivity and high-performance software applications,
    so Cloudy Skies continued to migrate its applications to .NET.
  prefs: []
  type: TYPE_NORMAL
- en: As time went by, the airline and its systems grew. The engineering team at Cloudy
    Skies was once held in high esteem as the pride and joy of the organization and
    a key to its future.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, management has been somewhat frustrated by its engineering team over
    the past few years. Some of its key complaints include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Product managers are frustrated by large estimates for seemingly simple changes
    to existing systems, and a growing amount of time between software releases due
    to long implementation times and numerous bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Quality Assurance department has been overwhelmed by a growing number of
    bugs present in the software, a tendency for the same things to break repeatedly,
    and bugs appearing in seemingly unrelated areas when changes occur in other parts
    of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For its part, the engineering team feels overwhelmed by the code it’s working
    with. Strategic initiatives have been pushed aside for years while the organization
    has the team focus on urgent changes or tight deadlines for new releases. As a
    result, nobody has had time to address the growing amount of technical debt the
    team is facing.
  prefs: []
  type: TYPE_NORMAL
- en: The Cloudy Skies codebase is constantly growing in complexity to account for
    each new feature or “special case” added to the system. This complexity in turn
    makes the application harder to test, understand, and modify, which has led to
    difficulties in onboarding new developers and some experienced developers leaving
    the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Out of frustration after several severe delays and high-profile bugs, Cloudy
    Skies brings in a new engineering manager and empowers the team to make changes
    to ensure the airline can stay efficient and effective in the years to come.
  prefs: []
  type: TYPE_NORMAL
- en: This engineering manager determines that the primary cause of these problems
    is technical debt and that targeted refactoring of the most critical areas throughout
    the suite of applications could significantly reduce risk and improve the team’s
    effectiveness going forward.
  prefs: []
  type: TYPE_NORMAL
- en: To its credit, management agrees and allows the team to allocate resources to
    pay down technical debt and improve the maintainability of the code through refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of this book, we’ll follow aspects of this fictitious team’s
    journey in paying down technical debt and paving the way to a better future through
    refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Legacy code is an unavoidable byproduct of the forces of time and constant change
    that are present in software development projects. This legacy code becomes a
    breeding ground for technical debt, which threatens our productivity as developers
    and the quality of our software.
  prefs: []
  type: TYPE_NORMAL
- en: While technical debt can arise due to a number of reasons, refactoring is the
    cure. Refactoring reworks existing code into a more maintainable and less risky
    form, reducing our technical debt and helping us control our legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: The more you understand the causes and effects of technical debt in your code,
    the better you’ll find yourself equipped to explain technical debt to others in
    your organization, advocate for refactoring, and avoid things that cause your
    code to decline in effectiveness over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore refactoring in more depth by walking through
    a set of targeted changes to improve a piece of sample code from the Cloudy Skies
    Airlines codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between technical debt and legacy code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some causes of technical debt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the effects of technical debt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to avoid technical debt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to get to a point where your code cannot be refactored further?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about technical debt, legacy code, and refactoring
    at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Defining Technical* *Debt*: [https://killalldefects.com/2019/12/23/defining-technical-debt/](https://killalldefects.com/2019/12/23/defining-technical-debt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identify Technical* *Debt*: [https://learn.microsoft.com/en-us/training/modules/identify-technical-debt/](https://learn.microsoft.com/en-us/training/modules/identify-technical-debt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The True Cost of Technical* *Debt*: [https://killalldefects.com/2019/11/09/the-true-cost-of-technical-debt/](https://killalldefects.com/2019/11/09/the-true-cost-of-technical-debt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code* *refactoring*: [https://en.wikipedia.org/wiki/Code_refactoring](https://en.wikipedia.org/wiki/Code_refactoring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
