- en: Network Analysis and Packet Inspection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络分析和数据包检查
- en: In this chapter, we'll look at writing software and systems that allow us to
    explore the network they're deployed on. Whereas previously, we looked at how
    our software was performing in the context of the network, in this chapter, we'll
    be looking specifically at how the network itself is performing. We'll examine
    how to implement resource and device discovery from within our network software,
    as well as how we can collect, examine, and then pass along packets traveling
    over the network. We'll consider how the activity on our network can potentially
    negatively impact our software, and how to proactively account for those impacts
    and recover from or avoid them altogether.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨编写软件和系统，使我们能够探索它们部署的网络。而之前，我们研究了我们的软件在网络环境中的表现，在本章中，我们将具体探讨网络本身的表现。我们将检查如何在网络软件内部实现资源和设备发现，以及我们如何收集、检查并传递通过网络传输的数据包。我们将考虑我们的网络活动如何可能对我们的软件产生负面影响，以及如何积极应对这些影响并从中恢复或完全避免它们。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Broadcast ports and IP addresses, and using them to identify your own software
    or host on a network, or learn information about other hosts on a network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播端口和IP地址，以及如何使用它们来识别网络上的自己的软件或主机，或了解网络上其他主机的信息
- en: Capturing and analyzing device and traffic information for the host to which
    your software is deployed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获和分析部署软件的主机上的设备和流量信息
- en: Identifying some of the risks posed by traffic on our network and how to build
    our applications to be resilient against those risks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别我们网络上的一些风险以及如何构建我们的应用程序以抵御这些风险
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll be using sample code that is available from this book's
    GitHub repository, here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter
    18](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2018).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用本书GitHub仓库中可用的示例代码，链接如下：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2018](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2018)。
- en: Check out the following video to see the code in action: [http://bit.ly/2HUai2a](http://bit.ly/2HUai2a)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[http://bit.ly/2HUai2a](http://bit.ly/2HUai2a)
- en: Additionally, we'll briefly discuss the merits of using WireShark to examine
    and understand the breadth and volume of network requests that are interacting
    with our machine. If you haven't already downloaded this software for the previous
    chapters, it can be found here: [https://www.wireshark.org/#download](https://www.wireshark.org/#download).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将简要讨论使用Wireshark检查和理解与我们的机器交互的网络请求的广度和数量的优点。如果您还没有为前几章下载此软件，它可以在以下链接找到：[https://www.wireshark.org/#download](https://www.wireshark.org/#download)。
- en: I strongly recommend familiarizing yourself with it, as it can prove invaluable
    as a tool for network software engineers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您熟悉它，因为它可以证明作为网络软件工程师的工具是无价的。
- en: Network resources and topography
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络资源和拓扑结构
- en: As we discussed all the way back in [Chapter 1](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml),
    *Networks in a Nutshell*, a network is a system that is agnostic of the participants
    of that system. Any given network has no knowledge of the entities or hosts that
    are wired up to it. As such, it can give no such information to any new hosts
    that try to connect to it. Instead, those hosts are responsible for broadcasting
    information about themselves out to others. Not only that, they're responsible
    for listening for broadcast information coming from other hosts so that they might
    know what other resources or hosts are on their network. So, how exactly does
    this happen?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第1章](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml)“网络概览”中讨论的那样，网络是一个对系统参与者无差别的系统。任何给定的网络对其连接的实体或主机没有任何了解。因此，它不能向任何试图连接到它的新主机提供此类信息。相反，这些主机负责向其他主机广播有关自己的信息。不仅如此，它们还负责监听来自其他主机的广播信息，以便它们可能知道网络上有哪些其他资源或主机。那么，这究竟是如何发生的呢？
- en: Node-to-node communication
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点间通信
- en: In just about all of the host-to-host interactions we've described in this book,
    one host must resolve a domain name or IP address for another host by communicating
    over a path of routers, switches, and gateways. However, this process of address
    resolution through a chain of external host devices doesn't help us establish
    the *initial* communication with the next host on our network. If we want our
    host to successfully transmit information to the nearest neighbor in the network
    path, we need to know specifically what address it might be listening on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中描述的大多数主机到主机的交互中，一个主机必须通过路由器、交换机和网关的路径与另一个主机通信，以解析域名或IP地址。然而，通过外部主机设备链的地址解析过程并不能帮助我们建立与网络中下一个主机的**初始**通信。如果我们想让我们的主机成功地将信息传输到网络路径中的最近邻居，我们需要知道它可能监听的具体地址。
- en: While I realize you're already aware of this fact, I would wager that you don't
    often think about the fact that when you establish a connection between two hosts,
    that connection is purely *logical*. The expectation is that each router or switch
    along the network path between your hosts will simply forward your packets along
    to their target, creating an unbroken chain of physical connections. Taken together,
    that chain of connections constitutes a single, logical connection. However, for
    that to work, your host must first connect to the next-nearest neighbor in that
    connection chain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我意识到你已经知道这个事实，但我敢打赌你并不经常思考这样一个事实：当你建立两个主机之间的连接时，那个连接完全是**逻辑上的**。预期是，在您的主机之间的网络路径上的每个路由器或交换机将简单地转发您的数据包到其目标，创建一个不间断的物理连接链。这些连接的总和构成了一个单一的逻辑连接。然而，为了使这起作用，您的宿主必须首先连接到该连接链中的下一个最近邻居。
- en: 'Every time we want to establish a higher-level connection with a remote host
    over something such as TCP or HTTP, the software that operates at the device and
    network level must determine the path for us. It does so by sending a message
    to its nearest neighbor and, essentially, asking if that neighbor can resolve
    a path. Then, that network device will forward the request to any of its neighbors,
    asking the same thing. As long as one of them responds affirmatively, your nearest
    neighbor will also respond affirmatively. If we consider our network as a tree,
    with our host as the root, we can think of this process in terms of a recursive
    tree-traversal algorithm. This recursive algorithm continues until one of two
    possible determinations is made. In the event that a path cannot be established,
    every leaf node of the network tree responds negatively, shown in the following
    diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要通过TCP或HTTP等协议与远程主机建立高级连接时，运行在设备和网络层的软件必须为我们确定路径。它是通过向其最近的邻居发送消息并本质上询问该邻居是否可以解析路径来做到这一点的。然后，该网络设备将请求转发给其任何邻居，询问同样的问题。只要其中之一做出肯定的回答，你的最近邻居也会做出肯定的回答。如果我们把我们的网络看作一棵树，以我们的主机为根，我们可以用递归树遍历算法来考虑这个过程。这个递归算法会一直持续到做出两种可能的确定之一。在无法建立路径的情况下，网络树中的每个叶节点都会做出否定的回答，如下面的图所示：
- en: '![](img/eeb00f10-578c-4072-9ff7-4a5ea8b62b64.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eeb00f10-578c-4072-9ff7-4a5ea8b62b64.png)'
- en: 'Meanwhile, in the event of a successful path determination, the target host
    is eventually reached by some path through our network tree. In that case, *any *node
    in our tree that can connect directly with our destination host will respond affirmatively,
    and the affirmative responses will propagate all the way back to our source host,
    notifying it that a connection can be made, shown in the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在成功确定路径的情况下，目标主机最终将通过我们的网络树中的某些路径到达。在这种情况下，**任何**可以直接连接到我们的目标主机的主机节点都会做出肯定的回答，肯定的回答会一直传播回我们的源主机，通知它可以建立连接，如下面的图所示：
- en: '![](img/dd7392f5-f1ab-456d-acdf-ab844953ccc6.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd7392f5-f1ab-456d-acdf-ab844953ccc6.png)'
- en: Note, though, that the source only learns that a path *can* be established.
    Even in the best cases, if multiple paths can be established between two hosts,
    there is no guarantee that any given packet will travel along the optimal path
    (if there even is an optimal path). In fact, there's no guarantee that all the
    packets of a given request will even travel along the *same *path. This is what
    causes the out-of-order packet delivery that we discussed in [Chapter 11](a4847953-41ef-48ee-aa39-75f920467992.xhtml),
    *The Transport Layer – TCP, UDP, and Multicasting*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管如此，源端只知道可以建立一条路径。即使在最好的情况下，如果两个主机之间可以建立多条路径，也无法保证任何给定的数据包都会沿着最优路径（如果存在最优路径的话）传输。实际上，也无法保证给定请求的所有数据包都会沿着相同的路径传输。这正是我们在[第11章](a4847953-41ef-48ee-aa39-75f920467992.xhtml)“传输层——TCP、UDP和多播”中讨论的乱序数据包传输的原因。
- en: So far, we've only considered connections as being established between two hosts
    over a transport or application layer protocol. With that as our context, there
    hasn't been any need for us to *identify* anything but our target host, using
    an IP address or domain name and the designated listening port. Using only these
    identifying details, network and device layer protocols have done the work of
    establishing a path on our network and forwarding our requests packets along that
    path. Our software simply receives an open line of communication between the two
    hosts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了在传输层或应用层协议之间建立两个主机之间的连接。在这个背景下，我们没有必要使用IP地址或域名以及指定的监听端口来识别除了目标主机以外的任何东西。仅使用这些识别细节，网络和设备层协议就完成了在我们的网络上建立路径并将我们的请求数据包沿该路径转发的工作。我们的软件只是简单地接收两个主机之间的开放通信线路。
- en: What you may not realize, though, is that the software running at the network
    layer has to explicitly identify the nearest neighbor in our network by *its*
    network address. Moreover, our host has to communicate with its nearest neighbor
    through a port and communication mechanism that the neighbor is configured to
    listen for. This leaves us with the sort of chicken-and-egg problem that is so
    common when trying to solve communication over an agnostic network. How can a
    source host identify the address and protocol with which to communicate with a
    destination host, without first communicating with the destination host to learn
    of those details? The answer is with a broadcast address.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能没有意识到，在网络层运行的软件必须通过其网络地址明确标识我们网络中的最近邻。此外，我们的主机必须通过邻居配置为监听的端口和通信机制与其最近邻进行通信。这使我们陷入了一种常见的鸡生蛋问题，即在尝试解决无差别的网络通信时经常遇到的问题。源主机如何识别与目标主机通信的地址和协议，而不首先与目标主机通信以了解这些细节？答案是使用广播地址。
- en: Broadcast addressing
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播地址
- en: When you first connect a device to a network, there are a number of things that
    must be coordinated between the new device and any other devices on the network
    before it can effectively communicate over that network. Your device must be assigned
    a local IP address, and it must be informed of the IP addresses and listening
    ports or sockets for any devices to which it has a direct connection. Additionally,
    any gateways into your subnetwork must be made aware of the new device so that,
    if any host outside your subnetwork wants to establish a connection, the gateways
    will respond affirmatively to any pathing requests they receive while attempting
    to establish a connection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次将设备连接到网络时，在设备能够有效地通过该网络进行通信之前，需要在新的设备和网络上的其他设备之间协调许多事情。您的设备必须分配一个本地IP地址，并且必须通知它直接连接的任何设备的IP地址和监听端口或套接字。此外，您的子网络中的任何网关都必须知道新设备，这样，如果子网络外的任何主机想要建立连接，网关将对其收到的任何路径请求做出肯定响应，以尝试建立连接。
- en: To establish the initial identity of a new host on a network, every standard
    network device will have what's known as a **broadcast address. **A broadcast
    address is simply any address on which every device on a given network or subnetwork
    is expected to be listening. With this standard universally established, any new
    host attempting to connect to a network can establish its presence for any devices
    that may need to know about it by sending out basic identifying information to
    a broadcast address. Once a message is broadcast, routers, switches, and gateways
    can use whatever conventions or protocols they've been configured with to mutually
    agree on a new network address to provision for the new host.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在网络上建立新主机的初始身份，每个标准网络设备都将有一个被称为**广播地址**的属性。广播地址简单地是指任何给定网络或子网络上的每个设备都期望监听其上的地址。随着这一标准的普遍建立，任何试图连接到网络的新的主机可以通过向广播地址发送基本识别信息来建立其存在，以便任何可能需要了解它的设备。一旦消息被广播，路由器、交换机和网关可以使用它们配置的任何约定或协议来相互同意为新主机提供的新网络地址。
- en: In the initial broadcast message, a new host won't have been assigned an IP
    address from its network. However, it still needs to establish a unique identifier
    by which other devices can communicate *back *to it. To give its nearest physical
    neighbor some identifier by that to return configuration information, a new host
    will typically send a **media access control address**, or **MAC address,** as
    part of its initial broadcast message. A MAC address is a globally unique identifier
    that's given to every single physical **network interface card** (**NIC**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始广播消息中，新主机尚未从其网络分配IP地址。然而，它仍然需要通过其他设备可以与之通信的唯一标识符来建立身份。为了给其最近的物理邻居提供一个标识符，以便返回配置信息，新主机通常会将其**媒体访问控制地址**，或**MAC地址**，作为其初始广播消息的一部分发送。MAC地址是一个全球唯一的标识符，分配给每个单独的物理**网络接口卡**（**NIC**）。
- en: 'The MAC address is occasionally called the **burned-in** address, since it
    is configured and fixed at the hardware level at the time the network card was
    fabricated, and cannot be changed by any means. A MAC address consists of six
    hexadecimal digits, separated by a colon, hyphen, or no separator at all. And
    because there is a unique MAC address per network card, any host which is configured
    with multiple network cards is going to have multiple MAC addresses, identifying
    each physical interface it has available to it. If you''ve ever opened up your
    command Terminal and run this command, you''ll have seen your MAC address for
    any network card installed on your machine:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MAC地址有时被称为**烧录**地址，因为它在网卡制造时在硬件级别配置并固定，无法通过任何方式更改。MAC地址由六个十六进制数字组成，由冒号、破折号或没有任何分隔符分隔。由于每个网卡都有一个唯一的MAC地址，因此配置了多个网络卡的主机将拥有多个MAC地址，以标识它可用的每个物理接口。如果你曾经打开过命令终端并运行此命令，你会看到你机器上安装的任何网络卡的MAC地址：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following command terminal, it''s the property labeled Physical Address:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下命令终端中，它是指示为物理地址的属性：
- en: '![](img/6de78d99-45ad-4a9e-9ad2-b29915b915ff.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6de78d99-45ad-4a9e-9ad2-b29915b915ff.png)'
- en: Since a MAC address cannot be changed and is known to be globally unique, a
    new host may broadcast it out to its network and hope for network configuration
    details, including IP address assignment and subnet mask specification, in response.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MAC地址不能更改且众所周知是全球唯一的，新主机可能会将其广播到其网络中，并希望获得网络配置细节，包括IP地址分配和子网掩码指定作为回应。
- en: By using the broadcast information from each connection host, network servers
    and routers can build an internal representation of the logical topology of their
    network. This topology and registry of device configuration are used to control
    and monitor the flow of inter-network communication. So, now, the question is,
    how can we leverage these broadcasts and other information when we need to establish
    the same knowledge about the networks our software is hosted on?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用每个连接主机的广播信息，网络服务器和路由器可以构建其网络的逻辑拓扑的内部表示。这个拓扑和设备配置的注册表用于控制和监控互联网通信的流量。因此，现在的问题是，当我们需要建立关于我们软件托管网络的相同知识时，我们如何利用这些广播和其他信息？
- en: Network analysis
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络分析
- en: Now that we have a basic picture of how network information is communicated
    between arbitrary nodes across our network, we can start to leverage that information
    to implement lower-level network software from within our .NET Core projects.
    So, what information are we looking for and how can we use it in code?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对网络信息如何在我们的网络中任意节点之间进行通信有一个基本的了解，我们可以开始利用这些信息在我们的 .NET Core 项目中实现低级网络软件。那么，我们在寻找什么信息，我们如何在代码中使用它呢？
- en: Understanding the NetworkInformation namespace
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 NetworkInformation 命名空间
- en: Many of the details and network interactions we discussed in the previous section
    exist and are managed by software and devices lower in the network stack than
    .NET Core libraries can provide access to. There is, however, a wealth of information
    about the transport layer traffic that moves through your application's listening
    network sockets and interfaces. For that information, the .NET Standard provides
    the `System.Net.NetworkInformation` namespace.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中讨论的许多细节和网络交互都存在于网络堆栈中比 .NET Core 库可以提供访问权限的软件和设备中。然而，关于通过您的应用程序的监听网络套接字和接口传输的传输层流量，有大量信息。为此信息，.NET
    Standard 提供了 `System.Net.NetworkInformation` 命名空间。
- en: The `NetworkInformation` namespace provides an array of utility classes and
    interfaces that can be used to build a comprehensive picture of the ways in which
    your software interacts with the network it's connected to. Using the classes
    in this namespace, you can learn about packet traffic, device addresses, including
    the registered IP addresses for routers and gateways on your current sub-network,
    and utilities for identifying the availability of remote devices in your network.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkInformation` 命名空间提供了一系列实用类和接口，可用于构建软件与连接的网络交互的全面图景。使用这个命名空间中的类，您可以了解数据包流量、设备地址，包括您当前子网络中路由器和网关的注册
    IP 地址，以及用于识别网络中远程设备可用性的实用工具。'
- en: What's especially interesting about this namespace and its use case is that
    it can be used to investigate *all *connections and traffic moving across your
    host machine. This gives you the ability to analyze how network requests targeting
    a different process co-located on your machine could potentially impact the performance
    and behavior of your own network software. Additionally, leveraging this class
    gives your code the information that's necessary to manage connections and sockets
    for more internal processes, allowing for such applications as writing your own
    application server or a request management solution. So, what kind of information
    can we glean from the classes in this namespace?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命名空间及其用例特别有趣的地方在于，它可以用来调查**所有**跨越您主机机器的连接和流量。这使您能够分析针对您机器上不同进程的网络请求可能会如何影响您自己的网络软件的性能和行为。此外，利用这个类可以为您的代码提供管理更多内部进程的连接和套接字所需的信息，从而允许编写自己的应用程序服务器或请求管理解决方案等应用。那么，我们能从这个命名空间中的类中获得哪些信息呢？
- en: Querying physical device information
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询物理设备信息
- en: Suppose for a moment that you want to write an application that provides detailed
    information about the network devices on the host computer. Certainly, you could
    use something such as Powershell scripting or simple batch processes to run terminal
    commands such as `ipconfig /all` or the `netsh dump` command, writing the results
    to a text file. But what if you want more information about your system? What
    if you want to deploy this software to multiple hosts with incompatible terminals?
    A scripting solution, while relatively simple, is incredibly inflexible and limited
    in its potential scope.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想编写一个提供主机计算机上网络设备详细信息的应用程序。当然，您可以使用诸如 Powershell 脚本或简单的批处理过程来运行终端命令，如 `ipconfig
    /all` 或 `netsh dump` 命令，并将结果写入文本文件。但如果你想要更多关于你系统的信息呢？如果你想要将此软件部署到具有不兼容终端的多台主机上呢？虽然脚本解决方案相对简单，但它非常不灵活，其潜在范围有限。
- en: 'Instead, using the `NetworkInterface` class and its subclasses, you could access
    information about your network devices directly from within your software solution.
    Using the `NetworkInterface` abstract class, we can access every physical network
    device detectable from our software''s host operating system and display information
    about the current active status, interface type, physical MAC address, current
    operational status, and more. To see that in action, let''s write our network
    information display software. We''ll start by creating a console application for
    our demo code for this chapter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用`NetworkInterface`类及其子类，您可以直接从您的软件解决方案中访问有关网络设备的信息。使用`NetworkInterface`抽象类，我们可以访问从我们的软件的主操作系统可检测到的每个物理网络设备，并显示有关当前活动状态、接口类型、物理MAC地址、当前操作状态等信息。为了看到这一点，让我们编写我们的网络信息显示软件。我们将从为这一章的演示代码创建一个控制台应用程序开始：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, from within our `Main()` method, we''ll get a list of all network adapters
    that are currently detectable by our operating system using the `GetAllNetworkInterfaces()`
    static method on the `NetworkInterface` class. This will return an array of subclasses
    of the `NetworkInterface` abstract class, with each instance in the array representing
    exactly one physical device on your system. Once we have the list of devices,
    we''ll loop through them and see what information we can discover about them using
    this interface:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从我们的`Main()`方法内部，我们将使用`NetworkInterface`类上的`GetAllNetworkInterfaces()`静态方法获取当前由我们的操作系统检测到的所有网络适配器的列表。这将返回一个`NetworkInterface`抽象类的子类的数组，数组中的每个实例代表系统上的一个物理设备。一旦我们有了设备列表，我们将遍历它们，并使用此接口查看我们可以发现有关它们的信息：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `NetworkInterface` class is actually an abstract base class. The resulting
    instances that are returned to our adapters container will be instances of a `SystemNetworkInterface`.
    Now, let''s find out what information we can glean from these adapter instances.
    We''ll just use a basic loop through our adapters to print out some of the more
    interesting properties and find out just what kind of details we can learn about:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkInterface`类实际上是一个抽象基类。返回到我们的适配器容器中的实例将是`SystemNetworkInterface`的实例。现在，让我们找出我们可以从这些适配器实例中获取哪些信息。我们将通过遍历我们的适配器来打印一些更有趣的属性，并找出我们可以学习到的详细信息的类型：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see by the properties, through this class, we can gather just about
    the same level of detail about our host machine as we might gather from a terminal
    command querying our NIC. In fact, we can confirm as much by running an `ipconig
    /all` command, and comparing the device details that are returned against the
    output of our program. Doing so on my own machine, we can compare my program output
    against the terminal output I showed you in the previous section of this chapter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您通过属性所看到的，通过这个类，我们可以收集到与通过终端命令查询我们的网络接口卡（NIC）所收集到的几乎相同水平细节关于我们的宿主机器。实际上，我们可以通过运行一个`ipconig
    /all`命令来确认这一点，并将返回的设备细节与我们的程序输出进行比较。在我的机器上这样做，我们可以将我的程序输出与上一节中展示的终端输出进行比较：
- en: '![](img/29444859-3296-4464-9475-3f3c13e688a5.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29444859-3296-4464-9475-3f3c13e688a5.png)'
- en: Here, we can see that we can access much of the information returned by our
    `ipconfig /all` call from the previous section. While the hex digits aren't grouped
    into dash-delimited pairs, the `PhysicalAddress` property obviously maps directly
    to the MAC address for your adapter, and the `OperationalStatus` property gives
    an accurate representation of the availability of the device for network requests.
    We can also see that my operating system is configured to use a Teredo tunneling
    adapter to allow IPv4 communication over IPv6 sub-networks, just as we discussed
    in [Chapter 12](0311281d-9a21-4dd0-a3cd-4e047ced436a.xhtml), *The Internet Protocol*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以访问上一节中`ipconfig /all`调用返回的大部分信息。虽然十六进制数字没有分组为破折号分隔的对，但`PhysicalAddress`属性显然直接映射到适配器的MAC地址，而`OperationalStatus`属性给出了设备对网络请求可用性的准确表示。我们还可以看到，我的操作系统配置为使用Teredo隧道适配器，以便在IPv6子网络上进行IPv4通信，正如我们在第12章[The
    Internet Protocol](0311281d-9a21-4dd0-a3cd-4e047ced436a.xhtml)中讨论的那样。
- en: Exploring the `NetworkInterface` class more, you can find information about
    the devices your network adapters are connected to. By requesting information
    that's through the `GetIPProperties()` method, you have access to details about
    the network configuration information currently set for each adapter. This includes
    the IP addresses for  DHCP servers, DNS servers, and your sub-networks gateway
    device, as well as any registered multicast or unicast addresses registered on
    your machine for other devices on your network.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入地探索`NetworkInterface`类，你可以找到有关你的网络适配器连接到的设备的信息。通过请求通过`GetIPProperties()`方法的信息，你可以访问每个适配器当前设置的网络配置信息的细节。这包括DHCP服务器、DNS服务器以及你的子网网关设备的IP地址，以及在你机器上注册的任何多播或单播地址，这些地址是为你的网络上的其他设备设置的。
- en: The depth of information we can learn about our physical adapters from this
    class is considerably more extensive than what we can learn from our terminal
    commands. Especially when we consider the information retrieved by the `GetIPProperties()`
    method. The benefit of using this class over a simple terminal command, though,
    is that it gives us access to all of this information from insideour software.
    We can implement conditional behavior based on device availability, or provide
    meaningful statistics and information to a system health report all without having
    to rely on host-specific terminal commands and external load modules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从这门课程中我们可以学习到的有关我们物理适配器的信息深度，比从我们的终端命令中学习到的要广泛得多。特别是当我们考虑到通过`GetIPProperties()`方法检索到的信息时。然而，使用这个类而不是简单的终端命令的好处是，它让我们能够从软件内部访问所有这些信息。我们可以根据设备可用性实现条件行为，或者向系统健康报告提供有意义的统计数据和信息，而无需依赖于特定主机的终端命令和外部加载模块。
- en: With this information, we could feasibly implement our own software for broadcasting
    our MAC address and requesting addressing, as well as configuration information
    from our network. Even if you don't ever find a need for implementing that code
    yourself, this hopefully paints a clear picture of the kind of features opened
    up to you with this class. This provides a host-agnostic mechanism for low-level
    network details and programming. So, what other information can we learn from
    the classes in the `System.Net.NetworkInformation` namespace?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些信息，我们可以实际实现自己的软件来广播我们的MAC地址并请求地址配置，以及从我们的网络获取配置信息。即使你永远不会找到自己实现该代码的需求，这也可能清楚地描绘出这个类为你打开的功能类型。这提供了一个主机无关的机制，用于低级网络细节和编程。那么，我们还能从`System.Net.NetworkInformation`命名空间中的类中学习到哪些其他信息？
- en: Querying connection information
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询连接信息
- en: While learning information about the status and availability of our own network
    interfaces is useful (and, indeed, even critical in many contexts), it doesn't
    paint the complete picture. For that, we'll need to examine the incoming and outgoing
    network traffic our adapters are being exposed to. Thankfully, as was the case
    with information about our network adapters, the .NET standard provides a set
    of classes that can display and monitor this information through clean and easy-to-use
    abstractions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解我们自己的网络接口的状态和可用性是有用的（实际上，在许多情况下甚至至关重要），但它并不能描绘出完整的画面。为了做到这一点，我们需要检查我们的适配器所暴露的进出网络流量。幸运的是，就像我们网络适配器的信息一样，.NET标准提供了一套可以通过简洁且易于使用的抽象来显示和监控这些信息的类。
- en: Instead of interacting with a `NetworkInterface` method, we'll want to look
    at our TCP connections, so for this next segment, we'll be looking at the `IPGlobalProperties`
    abstract base class. In much the same way that we examined the network interface
    information by calling the `GetAllNetworkInterfaces()` method, we can collect
    a wealth of IP traffic information using the `GetIpGlobalProperties()` static
    method. Once we have that, we can get everything from a list of all the active
    TCP connections (useful for determining the current load on your device), to statistics
    about incoming and outgoing IP packets. You can even sort your IP traffic statistics
    by the transport protocol that facilitated their delivery, with distinct methods
    targeting TCP statistics and UDP statistics.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想与 `NetworkInterface` 方法交互，而想查看我们的 TCP 连接，因此在这个下一部分，我们将查看 `IPGlobalProperties`
    抽象基类。与通过调用 `GetAllNetworkInterfaces()` 方法检查网络接口信息的方式非常相似，我们可以使用 `GetIpGlobalProperties()`
    静态方法收集大量的 IP 流量信息。一旦我们有了这些信息，我们可以从所有活动 TCP 连接的列表（对于确定设备当前负载很有用）到关于传入和传出 IP 数据包的统计信息获取一切。你甚至可以根据促进其交付的传输协议对
    IP 流量统计信息进行排序，有专门针对 TCP 统计信息和 UDP 统计信息的方法。
- en: 'Let''s see what sort of information we can learn about using these classes
    and their queries. We''ll start by learning about what active TCP connections
    we have running against our machine at the current moment. First, we''ll get our
    global properties, and then we''ll request our active TCP connection information:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以通过这些类及其查询了解哪些信息。我们将从了解当前时刻正在我们机器上运行的哪些活动 TCP 连接开始。首先，我们将获取我们的全局属性，然后请求我们的活动
    TCP 连接信息：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have our active connections, we can loop through them to determine
    who is connected to who, and what state the connection is in:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的活动连接，我们可以遍历它们以确定谁连接到谁，以及连接的状态：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By running this, you should see some variation of your localhost address (either
    `192.168.1.XXX`, or `127.0.0.1`) as the local address for every connection, and
    it might not seem entirely obvious why you might want access to that information.
    However, consider a scenario where you've got multiple IP addresses registered
    to a single host, and each address is mapped to a single, distinct application
    process. Let's say you've configured these distinct listening patterns through
    the `UsingUrls(...)` method of your kestrel `IWebHostBuilder`, as we discussed
    in [Chapter 9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml), *HTTP in .NET*. If
    that's the case, you could use the local address information to distinguish between
    connections to different applications on your host. This could give you insight
    into application traffic and resource usage. I expect by now you've got an intuitive
    idea of how that could be immensely useful in a number of contexts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你应该会看到本地地址（无论是 `192.168.1.XXX` 还是 `127.0.0.1`）作为每个连接的本地地址的某种变化，这可能并不完全明显为什么你可能想要访问这些信息。然而，考虑一个场景，你有一个单一的主机注册了多个
    IP 地址，并且每个地址都映射到一个单一、独特的应用程序进程。假设你已经通过我们在第 9 章[HTTP in .NET](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)中讨论的
    `IWebHostBuilder` 的 `UsingUrls(...)` 方法配置了这些不同的监听模式。如果那样的话，你可以使用本地地址信息来区分主机上不同应用程序的连接。这可能会让你对应用程序流量和资源使用有更深入的了解。我预计你现在已经对这种信息在许多情况下可能非常有用有了直观的认识。
- en: Monitoring traffic and remote device information
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控流量和远程设备信息
- en: Finally, let's wrap up our discussion about the `System.Net.NetworkInterface`
    namespace by looking at some of the traffic statistics and information made available
    through its classes. This will give us statistical information that's about the
    total number of packets we've received at a given point in time, fragmentation
    failures, dropped outbound packets, and much more. We can request these statistics
    based on IP version, with distinct methods for `GetIPv4GlobalStatistics()` and
    `GetIPv6GlobalStatistics()`, as well as filtering those statistics by transport
    protocol with `GetTcpIPv4Statistics()` and `GetUdpIPv4Statistics()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过查看通过其类提供的某些流量统计信息和信息来总结我们对 `System.Net.NetworkInterface` 命名空间的讨论。这将为我们提供关于在特定时间点接收到的总数据包数量、分段失败、丢弃的出站数据包以及更多统计信息的统计信息。我们可以根据
    IP 版本请求这些统计信息，使用 `GetIPv4GlobalStatistics()` 和 `GetIPv6GlobalStatistics()` 不同的方法，以及通过
    `GetTcpIPv4Statistics()` 和 `GetUdpIPv4Statistics()` 过滤这些统计信息，按传输协议进行过滤。
- en: 'Taking a look at some of the properties made available through instances of
    the `IPGlobalStatistics` class, we can see the kind of valuable information we
    can draw out of our traffic. Let''s look at just a few examples of this in some
    sample code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`IPGlobalStatistics`类实例提供的某些属性，我们可以看到我们可以从我们的流量中提取出的有价值信息。让我们通过一些示例代码来看看其中的几个例子：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you can see the kind of picture you can paint about your network's overall
    health and stability. We have access to information about fragmentation and reassembly
    failure, dropped packets, and the overall incoming and outgoing traffic. In this
    case, we were looking at our global IP traffic, but we could have just as easily
    sorted this by TCP and UDP for more meaningful breakdowns of our network interactions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到关于你的网络整体健康和稳定性的各种可能描绘的图片。我们可以获取有关碎片化和重组失败、丢失的数据包以及整体进出流量的信息。在这种情况下，我们正在查看我们的全球IP流量，但我们可以很容易地按TCP和UDP排序，以获得我们网络交互的更有意义的细分。
- en: Not all properties of the `IpGlobalStatistics` are supported on all platforms.
    Some information about discarded packets and fragment failures will only be available
    on Windows hosts. Make sure to validate that the statistical information you want
    access to is supported by the platform your software will be deployed to, and
    always write your code to degrade gracefully when host support may be limited.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有`IpGlobalStatistics`的属性在所有平台上都受支持。有关丢弃的数据包和碎片失败的信息将仅在Windows主机上可用。请确保你想要访问的统计信息受你软件将部署到的平台支持，并且始终编写代码以便在主机支持可能有限的情况下优雅地降级。
- en: While I hope this has provided a clear understanding of just what sort of information
    you can learn about the broader network context surrounding your hosted software,
    I've only begun to scratch the service of the information that's available through
    the `System.Net.NetworkInformation` namespace. I'd strongly encourage you to read
    through the Microsoft docs yourself to see what other tools are at your disposal.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我希望这已经清楚地说明了你可以了解关于你托管软件周围更广泛网络环境中的哪些信息，但我只是刚刚开始探索通过`System.Net.NetworkInformation`命名空间可用的信息。我强烈建议你自己阅读Microsoft文档，看看还有哪些工具可供使用。
- en: Additional tools and analysis
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工具和分析
- en: 'While the information we can capture with the `System.Net.NetworkInformation`
    namespace provides a very clear picture of the state of our network, it does have
    one major shortcoming when it comes to network analysis: it cannot provide any
    insight into the content of any traffic or requests in real time. The only way
    to access that information in code is to actively register a listener on an open
    port and process the incoming traffic accordingly. So, for network and DevOps
    engineers who need to monitor the content of their network traffic as well as
    the volume and context, what other tools are available?'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用`System.Net.NetworkInformation`命名空间捕获的信息为我们提供了关于我们网络状态的非常清晰的画面，但它在对网络分析来说有一个主要的缺点：它不能提供任何关于实时流量或请求内容的洞察。在代码中访问这些信息的唯一方法是在一个开放的端口上主动注册一个监听器，并相应地处理传入的流量。因此，对于需要监控其网络流量内容以及流量量和上下文的网络和DevOps工程师来说，还有哪些其他工具可用？
- en: Using Wireshark for packet inspection
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wireshark进行数据包检查
- en: As we saw back in [Chapter 4](9d6266fb-4428-4044-b63b-44f1317f64e7.xhtml), *Packets
    and Streams*, Wireshark can be a powerful tool for performing network analysis
    and what's called **packet sniffing**. Put simply, packet sniffing is inspecting
    the content of packets outside the context of their intended recipient. So, for
    example, if I've requested a web page in my browser, but then investigate the
    packet stream that makes up that web page with a tool such as Wireshark, that
    would constitute packet sniffing. The packets were intended for receipt and use
    by my browser, not Wireshark. It doesn't actually matter whether I was the one
    who requested them through the browser in the first place.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第4章](9d6266fb-4428-4044-b63b-44f1317f64e7.xhtml)“数据包和流”中看到的，Wireshark可以是一个强大的网络分析和所谓的**数据包嗅探**工具。简单来说，数据包嗅探是在不考虑其预期接收者的上下文的情况下检查数据包的内容。例如，如果我通过浏览器请求了一个网页，然后用Wireshark之类的工具调查构成该网页的数据包流，那么这就算作数据包嗅探。这些数据包原本是打算由我的浏览器接收和使用的，而不是Wireshark。实际上，我是否是第一个通过浏览器请求它们的人并不重要。
- en: In some contexts, this can be a dangerous tool for malicious actors to gain
    access to other internet traffic. However, in the hands of a network engineer
    behaving ethically, it can be a wonderful way to identify unintended or undesirable
    activity on your network.  So, how can we use this to our advantage?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可能是一个恶意行为者获取对其他互联网流量访问权限的危险工具。然而，在遵守道德的网络工程师手中，它可以是一种识别网络上的意外或不希望的活动的好方法。那么，我们如何利用这一点呢？
- en: Consider a case where you've got software running that uses the `System.Net.NetworkInformation`
    classes to provide real-time health information about your hosting environment.
    If you've designed your alerting mechanism well (as discussed in [Chapter 16](5abf726d-855c-410e-8547-a54da3deac58.xhtml),* Performance
    Analysis and Monitoring*), you would quickly be made aware of any unanticipated
    spikes in network traffic beyond a given threshold. If that happens, the information
    that's available to you from your health monitoring software is limited by what's
    provided by the `System.Net.NetworkInformation` library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个案例，你有一个正在运行的软件，它使用`System.Net.NetworkInformation`类来提供关于托管环境的实时健康信息。如果你已经很好地设计了你的警报机制（如第16章[5abf726d-855c-410e-8547-a54da3deac58.xhtml]，*性能分析和监控*所述），你会迅速意识到任何超出给定阈值的意外网络流量峰值。如果发生这种情况，从你的健康监控软件中可获得的信息将受到`System.Net.NetworkInformation`库提供的限制。
- en: With the resources we've discussed in this chapter, you can devise a sound strategy
    for detecting and responding to those kinds of critical network events. Simply
    use the statistical information that's available through the `System.Net.NetworkInformation`
    classes as your alert system, and a more robust inspection tool, such as Wireshark,
    for deeper analysis when alerts arise. This can give you deeper insight into what
    information is being conveyed to your host in that high-volume spike of packets.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了这些资源，你可以制定一个合理的策略来检测和响应这些类型的网络事件。简单地将`System.Net.NetworkInformation`类提供的统计信息作为你的警报系统，并在出现警报时使用更强大的检查工具，如Wireshark，进行深入分析。这可以让你更深入地了解在数据包高流量峰值中向你的主机传达了哪些信息。
- en: The basics of using Wireshark for rudimentary packet sniffing were discussed
    in [Chapter 4](9d6266fb-4428-4044-b63b-44f1317f64e7.xhtml), *Packets and Streams*,
    in the *The Anatomy of a Packet* *section*. With that in mind, I won't belabor
    the point, as more advanced use cases for Wireshark are well beyond the scope
    of this book. However, I felt it was important to address it in this chapter,
    since anyone who's serious about network programming and all it entails should
    have as deep of a set of tools at their disposal as possible. To that end, I'd
    highly encourage you to set aside time at your job, or even in your free time,
    to learn and practice using Wireshark and other packet inspection tools for deep
    network analysis.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章[9d6266fb-4428-4044-b63b-44f1317f64e7.xhtml]，*数据包和流*的*数据包解剖学*部分中，讨论了使用Wireshark进行基本数据包嗅探的基本方法。考虑到这一点，我不会过多地强调这一点，因为Wireshark的更高级用法超出了本书的范围。然而，我认为在本章中讨论它很重要，因为任何对网络编程及其所有内容认真的人都应该尽可能拥有尽可能多的工具。为此，我强烈建议你在工作中或甚至在业余时间抽出时间学习和练习使用Wireshark和其他数据包检查工具进行深入的网络分析。
- en: With that out of the way, we're ready to tackle our final topic. In the next
    chapter, we'll be exploring the SSH interaction scheme. We'll learn how it came
    about, how it's evolved over time, and how we can use it for remote process invocation
    and host access.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了这些问题之后，我们准备处理我们的最后一个主题。在下一章中，我们将探讨SSH交互方案。我们将了解它是如何产生的，它是如何随着时间的推移而演变的，以及我们如何使用它进行远程过程调用和主机访问。
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the very niche, but extremely powerful, subject
    of network device analysis using .NET Core libraries. We started by learning about
    how network devices communicate information about themselves across device-agnostic
    connections to establish an internal registry of nearby device addresses and interaction
    mechanisms. In doing so, we learned about the use of broadcasting, and broadcast
    addresses for transmitting messages reliably, even without any connection information
    about the devices you intend to communicate with. Finally, we learned how uniquely
    addressing hardware interfaces can facilitate device identification even in the
    absence of a registered network address.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用.NET Core库进行网络设备分析的非常小众但极其强大的主题。我们首先学习了网络设备如何通过设备无关的连接来传递关于自身的信息，以建立附近设备地址和交互机制的内部注册表。在这个过程中，我们了解了广播和广播地址的使用，即使没有关于您打算与之通信的设备任何连接信息，也能可靠地传输消息。最后，我们学习了如何通过唯一地寻址硬件接口，即使在没有注册的网络地址的情况下，也能促进设备识别。
- en: Once we learned about the features and interactions that are necessary to facilitate
    more typical interactions between hosts on a network, we looked at how we can
    access that low-level network information from within our .NET applications. We
    explored various classes within the `System.Net.NetworkInformation` namespace,
    and saw how we could use them to access valuable information about our network
    adapters, and the devices to which they were connected. We saw how we could access
    critical operational information about our physical network adapters programmatically,
    giving us access to a wide range of diagnostic and statistical information. We
    also looked at how we could examine and monitor IP traffic against each of our
    network interfaces to perform packet inspection and network health analysis. Finally,
    we considered additional tools available that could provide greater context and
    detail about network traffic, and how we could use all of this information to
    identify and respond to an unstable network. Going into our final chapter, we'll
    look at how computers can control and operate hosts remotely over a network using
    SSH.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了促进网络中主机之间更典型交互所需的特性和交互，我们就研究了如何在.NET应用程序中访问这些低级网络信息。我们探索了`System.Net.NetworkInformation`命名空间内的各种类，并看到了如何使用它们来访问有关我们的网络适配器和它们所连接的设备的有价值信息。我们看到了如何通过编程方式访问有关我们的物理网络适配器的关键操作信息，这为我们提供了广泛的诊断和统计信息。我们还研究了如何检查和监控每个网络接口的IP流量，以执行数据包检查和网络健康分析。最后，我们考虑了其他可用的工具，这些工具可以提供更多关于网络流量的上下文和细节，以及我们如何使用所有这些信息来识别和响应不稳定的网络。在进入最后一章时，我们将探讨计算机如何通过网络使用SSH远程控制和操作主机。
- en: Questions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Describe the process of address resolution, as it occurs at the network layer.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述地址解析的过程，如它在网络层发生的那样。
- en: What is a broadcast address? How is it used?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 广播地址是什么？它是如何使用的？
- en: What is a MAC address? How is it distinct from other network addresses?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MAC地址是什么？它与其他网络地址有什么区别？
- en: What sort of information can be learned from instances of the `NetworkInterface`
    class?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从`NetworkInterface`类的实例中学习哪些信息？
- en: What is packet sniffing? How is it useful in network analysis?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据包嗅探是什么？它在网络分析中有什么用途？
- en: What sort of traffic information can we query using the `NetworkInformation`
    classes?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`NetworkInformation`类查询哪些类型的流量信息？
- en: How can we use traffic statistics to detect and respond to unstable network
    conditions?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何利用流量统计来检测和响应不稳定的网络条件？
- en: Further reading
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Once again, we've covered a relatively niche topic in this chapter, and the
    additional resources for learning more are few and far between. I'd certainly
    recommend you explore the Microsoft documentation for the `System.Net.NetworkInformation`
    namespace, which can be found here: [https://docs.microsoft.com/en-us/dotnet/api/system.net.networkinformation?view=netcore-3.0](https://docs.microsoft.com/en-us/dotnet/api/system.net.networkinformation?view=netcore-3.0)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在本章中，我们讨论了一个相对小众的主题，而且学习更多相关内容的额外资源也相对稀少。我当然建议您探索微软关于`System.Net.NetworkInformation`命名空间的文档，您可以通过以下链接找到：[https://docs.microsoft.com/en-us/dotnet/api/system.net.networkinformation?view=netcore-3.0](https://docs.microsoft.com/en-us/dotnet/api/system.net.networkinformation?view=netcore-3.0)
- en: Additionally, if you have any interest in continuing down the path of network
    traffic analysis and packet inspection, I'd recommend the book *Packet Analysis
    with Wireshark* by Anish Nath. This book provides an extensive how-to for investigating
    and understanding the nature of the raw network packets that come into contact
    with your network adapters moment to moment. It's available through Packt, here: [https://www.packtpub.com/networking-and-servers/packet-analysis-wireshark](https://www.packtpub.com/networking-and-servers/packet-analysis-wireshark).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你对继续深入网络流量分析和数据包检查的路径感兴趣，我推荐阅读Anish Nath所著的《Wireshark数据包分析》一书。这本书提供了详尽的指南，用于调查和理解与你的网络适配器时刻接触的原始网络数据包的本质。你可以在Packt购买此书，链接如下：[https://www.packtpub.com/networking-and-servers/packet-analysis-wireshark](https://www.packtpub.com/networking-and-servers/packet-analysis-wireshark).
