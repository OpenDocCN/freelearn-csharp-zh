<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer037">
<h1 id="_idParaDest-99"><em class="italic"><a id="_idTextAnchor098"/>Chapter 6</em>: Parallel Programming Concepts</h1>
<p>The <strong class="bold">Task Parallel Library</strong> (<strong class="bold">TPL</strong>) encompasses various .NET programming constructs, including parallel loops, parallel invocations, <strong class="bold">PLINQ</strong>, and task-based async programming. In <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>, we explored async programming with <strong class="source-inline">Task</strong> objects. This chapter will delve deeper into the <strong class="source-inline">System.Threading.Tasks.Parallel</strong> members in the TPL and some additional tasking concepts for handling related tasks.</p>
<p>The lines between parallel programming, concurrency, and asynchronous programming are not always clear-cut, and you will discover where the three concepts intersect as we read ahead. </p>
<p>In this chapter, you will learn the following:</p>
<ul>
<li>Getting started with the TPL</li>
<li>Parallel loops in .NET</li>
<li>Relationships between parallel tasks</li>
<li>Common pitfalls with parallelism</li>
</ul>
<p>By the end of this chapter, you will understand how to use parallel programming in your own projects, why you would choose a parallel loop over a standard loop, and when to use <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> instead of a parallel loop.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later</li>
<li>.NET 6</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06</a>.</p>
<p>Let’s get started by discussing the TPL and where it fits within the world of parallel programming in .NET.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Getting started with the TPL</h1>
<p>The <strong class="bold">TPL</strong> consists of <a id="_idIndexMarker284"/>the types that were added to the <strong class="source-inline">System.Threading</strong> and <strong class="source-inline">System.Threading.Tasks</strong> namespaces in <em class="italic">.NET Framework 4.0</em>. The TPL provides features that make parallelism and concurrency simpler for .NET developers. There is no need to manage the <strong class="source-inline">ThreadPool</strong> tasks in your code. The TPL handles thread management and automatically scales the number of active threads based on processor capability and availability.</p>
<p>Developers should use the TPL when they need to introduce parallelism or concurrency to their code for improved performance. However, the TPL is not the right choice for every scenario. How do you know when to choose the TPL and which TPL constructs are the best choice for each scenario? </p>
<p>Let’s explore a few common scenarios.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>I/O-bound operations</h2>
<p>When dealing <a id="_idIndexMarker285"/>with I/O-bound operations <a id="_idIndexMarker286"/>such as file operations, database calls, or web service calls, asynchronous programming with <strong class="source-inline">Task</strong> objects and C# <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> operations are your best choice. If your service requires that you loop through a large collection, making a service call for each object in the loop, you should consider refactoring the service to return the data as a single service call. This will minimize the overhead associated with each network operation. It will also allow your client code to make a single <strong class="source-inline">async</strong> call to the service while keeping the main thread free to do other work.</p>
<p>I/O-bound operations are usually not suited to parallel operations, but there are exceptions to every rule. If you need to iterate through a set of folders and subfolders in the filesystem, a parallel loop can be well-suited for this. However, it is important that none of the <a id="_idIndexMarker287"/>iterations of your loop attempt to access the same file <a id="_idIndexMarker288"/>in order to avoid locking issues.</p>
<p>Now, let’s explore some CPU-bound scenarios.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>CPU-bound operations</h2>
<p>CPU-bound operations are not reliant on outside resources such as the filesystem, network, or <a id="_idIndexMarker289"/>the internet. They involve <a id="_idIndexMarker290"/>processing data in memory within your application’s process. There are many types of data transformation that fall into this category. Your application may be serializing or deserializing data, converting between file types, or processing images or other binary data.</p>
<p>These types of operations make sense for data parallelism and parallel loops in particular, with a couple of exceptions. First, if each iteration is not very CPU intensive, using the TPL is not worth the overhead it introduces. If the process is very intensive, but there are very few objects to iterate over, consider using <strong class="source-inline">Parallel.Invoke</strong> instead of one of the parallel loops, <strong class="source-inline">Parallel.For</strong> or <strong class="source-inline">Parallel.ForEach</strong>. Using parallel constructs for less CPU-intense operations can often slow your code due to the overhead of using the TPL. In <a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a> we will learn how to use Visual Studio to determine the performance of parallel and concurrent code.</p>
<p>Now that you have some understanding of when to use parallelism in your applications, let’s explore some practical examples of using <strong class="source-inline">Parallel.For</strong> and <strong class="source-inline">Parallel.ForEach</strong>.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Parallel loops in .NET</h1>
<p>In this <a id="_idIndexMarker291"/>section, we will explore some examples of leveraging data parallelism in .NET projects. The parallel versions of the C# <strong class="source-inline">for</strong> and <strong class="source-inline">foreach</strong> loops, <strong class="source-inline">Parallel.For</strong> and <strong class="source-inline">Parallel.ForEach</strong>, are part of the <strong class="source-inline">System.Threading.Tasks.Parallel</strong> namespace. Using these parallel loops is similar to using their standard counterparts in C#.</p>
<p>One key <a id="_idIndexMarker292"/>difference is that the body of the parallel loops is declared as a <strong class="bold">lambda expression</strong>. As a result, there are some changes to how you would continue or break from the parallel loops. Instead of using <strong class="source-inline">continue</strong> to stop the current iteration of the loop without <a id="_idIndexMarker293"/>breaking the entire loop, you would use a <strong class="source-inline">return</strong> statement. The equivalent of using <strong class="source-inline">break</strong> to break out of a parallel loop is to use the <strong class="source-inline">Stop()</strong> or <strong class="source-inline">Break()</strong> statements.</p>
<p>Let’s look at an example of using a <strong class="source-inline">Parallel.For</strong> loop in a .NET WinForms application.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Basic Parallel.For loops</h2>
<p>We are going <a id="_idIndexMarker294"/>to create a new <strong class="bold">WinForms application</strong> that allows <a id="_idIndexMarker295"/>users to select a folder on their workstation and examine some information about the files in the selected folder. The project’s <strong class="source-inline">FileProcessor</strong> class will iterate the files to aggregate the file size and find the <a id="_idIndexMarker296"/>most recently written file:</p>
<ol>
<li>Start by creating a new .NET 6 WinForms project in Visual Studio</li>
<li>Add a new class named <strong class="source-inline">FileData</strong>. This class will contain the data from <strong class="source-inline">FileProcessor</strong>:<p class="source-code">public class FileData</p><p class="source-code">{</p><p class="source-code">    public List&lt;FileInfo&gt; FileInfoList { get; set; } = </p><p class="source-code">        new();</p><p class="source-code">    public long TotalSize { get; set; } = 0;</p><p class="source-code">    public string LastWrittenFileName </p><p class="source-code">        { get; set; } = "";</p><p class="source-code">    public DateTime LastFileWriteTime { get; set; }</p><p class="source-code">}</p></li>
</ol>
<p>We will be returning a list of the <strong class="source-inline">FileInfo</strong> objects for the files in the selected folder, the total size of all files, the name of the last written file, and the date and time that the file was written.</p>
<ol>
<li value="3">Next, create <a id="_idIndexMarker297"/>a new class named <strong class="source-inline">FileProcessor</strong></li>
<li>Add a <a id="_idIndexMarker298"/>static method named <strong class="source-inline">GetInfoForFiles</strong> to <strong class="source-inline">FileProcessor</strong>:<p class="source-code">public static FileData GetInfoForFiles(string[] files)</p><p class="source-code">{</p><p class="source-code">    var results = new FileData();</p><p class="source-code">    var fileInfos = new List&lt;FileInfo&gt;();</p><p class="source-code">    long totalFileSize = 0;</p><p class="source-code">    DateTime lastWriteTime = DateTime.MinValue;</p><p class="source-code">    string lastFileWritten = "";</p><p class="source-code">    object dateLock = new();</p><p class="source-code"><strong class="bold">    Parallel.For(0, files.Length,</strong></p><p class="source-code"><strong class="bold">            index =&gt; {</strong></p><p class="source-code"><strong class="bold">                </strong><strong class="bold">FileInfo fi = new(files[index]);</strong></p><p class="source-code"><strong class="bold">                long size = fi.Length;</strong></p><p class="source-code"><strong class="bold">                DateTime lastWrite = </strong></p><p class="source-code"><strong class="bold">                    fi.LastWriteTimeUtc;</strong></p><p class="source-code"><strong class="bold">                lock (dateLock)</strong></p><p class="source-code"><strong class="bold">                {</strong></p><p class="source-code"><strong class="bold">                    if (lastWriteTime &lt; lastWrite)</strong></p><p class="source-code"><strong class="bold">                    {</strong></p><p class="source-code"><strong class="bold">                        lastWriteTime = lastWrite;</strong></p><p class="source-code"><strong class="bold">                        lastFileWritten = fi.Name;</strong></p><p class="source-code"><strong class="bold">                    </strong><strong class="bold">}</strong></p><p class="source-code"><strong class="bold">                }</strong></p><p class="source-code"><strong class="bold">                Interlocked.Add(ref totalFileSize, </strong></p><p class="source-code"><strong class="bold">                    size);</strong></p><p class="source-code"><strong class="bold">                fileInfos.Add(fi);</strong></p><p class="source-code"><strong class="bold">            });</strong></p><p class="source-code">    results.FileInfoList = fileInfos;</p><p class="source-code">    results.TotalSize = totalFileSize;</p><p class="source-code">    results.LastFileWriteTime = lastWriteTime;</p><p class="source-code">    results.LastWrittenFileName = lastFileWritten;</p><p class="source-code">    return results;</p><p class="source-code">}</p></li>
</ol>
<p>The <strong class="source-inline">Parallel.For</strong> loop <a id="_idIndexMarker299"/>and the <strong class="bold">lambda expression</strong> of its body are highlighted in the <a id="_idIndexMarker300"/>preceding code. There are a few things to note about the code <a id="_idIndexMarker301"/>inside the loop: </p>
<ol>
<li>First, <strong class="source-inline">index</strong> is provided as a parameter to the lambda expression so the expression body can use it to access the current member of the <strong class="source-inline">files</strong> array. </li>
<li>The <strong class="source-inline">totalFileSize</strong> gets updated inside a call to <strong class="source-inline">Interlocked.Add</strong>. This is the most efficient way to safely add values in parallel code. </li>
<li>There isn’t a simple way to leverage <strong class="source-inline">Interlocked</strong> to update the <strong class="source-inline">lastWriteTime</strong> DateTime value. So, instead, we are using a <strong class="source-inline">lock</strong> block with a <strong class="source-inline">dateLock</strong> object to safely read and set the <strong class="source-inline">lastWriteTime</strong> method-level variable.</li>
</ol>
<ol>
<li value="5">Next, open the designer for <strong class="source-inline">Form1.cs</strong> and add the following controls to the form:<p class="source-code">private GroupBox FileProcessorGroup;</p><p class="source-code">private Button FolderProcessButton;</p><p class="source-code">private Button FolderBrowseButton;</p><p class="source-code">private TextBox FolderToProcessTextBox;</p><p class="source-code">private Label label1;</p><p class="source-code">private TextBox FolderResultsTextBox;</p><p class="source-code">private Label label2;</p><p class="source-code">private FolderBrowserDialog folderToProcessDialog;</p></li>
</ol>
<p>View the <strong class="source-inline">Form1.designer.cs</strong> file on this chapter’s GitHub repository (<a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp</a>) to review and set all <a id="_idIndexMarker302"/>of the properties for these controls. </p>
<p>When <a id="_idIndexMarker303"/>you are finished, the form’s designer should look like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 6.1 – The completed Form1.cs designer view in Visual Studio " height="512" src="image/Figure_6.1_B18552.jpg" width="1015"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The completed Form1.cs designer view in Visual Studio</p>
<ol>
<li value="6">Next, double-click the <strong class="bold">Browse</strong> button in the <strong class="source-inline">Form1</strong> designer, and a <strong class="source-inline">FolderBrowserButton_Click</strong> event handler will be generated in the code-behind <a id="_idIndexMarker304"/>file. Add the following <a id="_idIndexMarker305"/>code to use the <strong class="source-inline">folderToProcessDialog</strong> object to show a folder picker dialog to the user:<p class="source-code">private void FolderBrowseButton_Click(object sender, </p><p class="source-code">    EventArgs e)</p><p class="source-code">{</p><p class="source-code">    var result = folderToProcessDialog.ShowDialog();</p><p class="source-code">    if (result == DialogResult.OK)</p><p class="source-code">    {</p><p class="source-code">        FolderToProcessTextBox.Text = </p><p class="source-code">            folderToProcessDialog.SelectedPath;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>The selected folder path will be set in <strong class="source-inline">FolderToProcessTextBox</strong> for use in the next step. The user can alternatively manually type or paste a folder path in the field. If you would like to prevent manual entry, you can set <strong class="source-inline">FolderToProcessTextBox.ReadOnly</strong> to <strong class="source-inline">true</strong>.</p>
<ol>
<li value="7">Next, double-click the <strong class="bold">Process</strong> button in the designer view. A <strong class="source-inline">FolderProcessButton_Click</strong> event handler will be generated in the code behind. Add the following code to call <strong class="source-inline">FileProcessor</strong> and display the results in <strong class="source-inline">FolderResultsTextBox</strong>:<p class="source-code">private void FolderProcessButton_Click(object sender, </p><p class="source-code">    EventArgs e)</p><p class="source-code">{</p><p class="source-code">    if (!string.IsNullOrWhiteSpace</p><p class="source-code">        (FolderToProcessTextBox.Text) &amp;&amp;</p><p class="source-code">        Directory.Exists(FolderToProcessTextBox.Text))</p><p class="source-code">    {</p><p class="source-code">        string[] filesToProcess = Directory.GetFiles</p><p class="source-code">            (FolderToProcessTextBox.Text);</p><p class="source-code">        FileData? results = FileProcessor</p><p class="source-code">            .GetInfoForFiles(filesToProcess);</p><p class="source-code">        if (results == null)</p><p class="source-code">        {</p><p class="source-code">            FolderResultsTextBox.Text = "";</p><p class="source-code">            return;</p><p class="source-code">        }</p><p class="source-code">        StringBuilder resultText = new();</p><p class="source-code">        resultText.Append($"Total file count: </p><p class="source-code">            {results.FileInfoList.Count}; ");</p><p class="source-code">        resultText.AppendLine($"Total file size: </p><p class="source-code">            {results.TotalSize} bytes");</p><p class="source-code">        resultText.Append($"Last written file: </p><p class="source-code">            {results.LastWrittenFileName} ");</p><p class="source-code">        resultText.Append($"at </p><p class="source-code">            {results.LastFileWriteTime}");</p><p class="source-code">        FolderResultsTextBox.Text = </p><p class="source-code">            resultText.ToString();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>The code here is straightforward enough. The static <strong class="source-inline">GetInfoForFiles</strong> method returns a <strong class="source-inline">FileData</strong> instance with the file information. We’re using <strong class="source-inline">StringBuilder</strong> to create the output to be set in <strong class="source-inline">FolderResultsTextBox</strong>.</p>
<ol>
<li value="8">We’re <a id="_idIndexMarker306"/>ready to run the application. Start <a id="_idIndexMarker307"/>debugging the project in Visual Studio and give it a try. Your results should look something like this:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 6.2 – Running the Parallel Loops application " height="443" src="image/Figure_6.2_B18552.jpg" width="1109"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Running the Parallel Loops application</p>
<p>That’s all there is to it. If you want to try something more advanced, you can try modifying the project to also process files in all subfolders of the selected folder. Let’s make a different change to the project so we can reduce the locking calls to <strong class="source-inline">Interlocked.Add</strong>.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Parallel loops with thread-local variables</h2>
<p>The <strong class="source-inline">Parallel.For</strong> construct has an overload that will allow our code to keep a running <a id="_idIndexMarker308"/>subtotal of the total file size for each thread participating in the loop. What that means is that we will only need to use <strong class="source-inline">Interlocked.Add</strong> when aggregating the subtotal from each thread to <strong class="source-inline">totalFileSize</strong>. This is <a id="_idIndexMarker309"/>accomplished by providing a <strong class="bold">thread-local variable</strong> to the loop. The subtotal in the following code is stored discretely <a id="_idIndexMarker310"/>for each thread. So, if the loop has 200 iterations, but only 5 threads participate in the loop, <strong class="source-inline">Interlocked.Add</strong> will only be called 5 times instead of 200 times without losing any thread safety:</p>
<pre class="source-code">public static FileData GetInfoForFilesThreadLocal(string[] </pre>
<pre class="source-code">    files)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var results = new FileData();</pre>
<pre class="source-code">    var fileInfos = new List&lt;FileInfo&gt;();</pre>
<pre class="source-code">    long totalFileSize = 0;</pre>
<pre class="source-code">    DateTime lastWriteTime = DateTime.MinValue;</pre>
<pre class="source-code">    string lastFileWritten = "";</pre>
<pre class="source-code">    object dateLock = new();</pre>
<pre class="source-code">    <strong class="bold">Parallel.For&lt;long&gt;(0, files.Length, () =&gt; 0,</strong></pre>
<pre class="source-code"><strong class="bold">        (index, loop, subtotal) =&gt; {</strong></pre>
<pre class="source-code">            FileInfo fi = new(files[index]);</pre>
<pre class="source-code">            long size = fi.Length;</pre>
<pre class="source-code">            DateTime lastWrite = fi.LastWriteTimeUtc;</pre>
<pre class="source-code">            lock (dateLock)</pre>
<pre class="source-code">            {</pre>
<pre class="source-code">                if (lastWriteTime &lt; lastWrite)</pre>
<pre class="source-code">                {</pre>
<pre class="source-code">                    lastWriteTime = lastWrite;</pre>
<pre class="source-code">                    lastFileWritten = fi.Name;</pre>
<pre class="source-code">                }</pre>
<pre class="source-code">            }</pre>
<pre class="source-code">            <strong class="bold">subtotal += size;</strong></pre>
<pre class="source-code">            fileInfos.Add(fi);</pre>
<pre class="source-code">            <strong class="bold">return subtotal;</strong></pre>
<pre class="source-code">            }<strong class="bold">,</strong></pre>
<pre class="source-code"><strong class="bold">        (runningTotal) =&gt; Interlocked.Add(ref </strong></pre>
<pre class="source-code"><strong class="bold">            totalFileSize, runningTotal)</strong></pre>
<pre class="source-code">    );</pre>
<pre class="source-code">    results.FileInfoList = fileInfos;</pre>
<pre class="source-code">    results.TotalSize = totalFileSize;</pre>
<pre class="source-code">    results.LastFileWriteTime = lastWriteTime;</pre>
<pre class="source-code">    results.LastWrittenFileName = lastFileWritten;</pre>
<pre class="source-code">    return results;</pre>
<pre class="source-code">}</pre>
<p>To summarize <a id="_idIndexMarker311"/>the preceding changes, you will notice we are using the <strong class="source-inline">Parallel.For&lt;long&gt;</strong> generic method to indicate that the <strong class="source-inline">subtotal</strong> thread-local variable should be <strong class="source-inline">long</strong> instead of <strong class="source-inline">int</strong> (the default type). The size is added to <strong class="source-inline">subtotal</strong> in the first lambda expression without any locking expression. We now have to return <strong class="source-inline">subtotal</strong>, so the other iterations have access to the data. Finally, we have added a final parameter to <strong class="source-inline">For</strong> with a lambda expression that adds each thread’s <strong class="source-inline">runningTotal</strong> to <strong class="source-inline">totalFileSize</strong> using <strong class="source-inline">Interlocked.Add</strong>.</p>
<p>If you update <strong class="source-inline">FolderProcessButton_Click</strong> to call <strong class="source-inline">GetInfoForFilesThreadLocal</strong>, the output will be the same, but the performance will be improved, perhaps not noticeably. The performance improvement depends on the number of files in your selected folder.</p>
<p>Now that we have tried a couple of exercises with the <strong class="source-inline">Parallel.For</strong> loop, let’s create a sample using the <strong class="source-inline">Parallel.ForEach</strong> method.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Simple Parallel.ForEach loops</h2>
<p>The <strong class="source-inline">Parallel.ForEach</strong> methods, such as <strong class="source-inline">Parallel.For</strong>, are similar in use to their <a id="_idIndexMarker312"/>non-parallel counterpart. You would use <strong class="source-inline">Parallel.ForEach</strong> over <strong class="source-inline">Parallel.For</strong> when you have an <strong class="source-inline">IEnumerable</strong> collection <a id="_idIndexMarker313"/>to process. In this sample, we will create a new method that accepts a <strong class="source-inline">List&lt;string&gt;</strong> of image files to iterate and convert to <strong class="source-inline">Bitmap</strong> objects:</p>
<ol>
<li value="1">Start by creating a new private static method named <strong class="source-inline">ConvertJpgToBitmap</strong> in the <strong class="source-inline">FileProcessor</strong> class. This method will open each JPG file and return a new <strong class="source-inline">Bitmap</strong> containing the image data:<p class="source-code">private static Bitmap ConvertJpgToBitmap(string </p><p class="source-code">    fileName)</p><p class="source-code">{</p><p class="source-code">    Bitmap bmp;</p><p class="source-code">    using (Stream bmpStream = File.Open(fileName, </p><p class="source-code">        FileMode.Open))</p><p class="source-code">    {</p><p class="source-code">        Image image = Image.FromStream(bmpStream);</p><p class="source-code">        bmp = new Bitmap(image);</p><p class="source-code">    }</p><p class="source-code">    return bmp;</p><p class="source-code">}</p></li>
<li>Next, create a public static method in the same class named <strong class="source-inline">ConvertFilesToBitmaps</strong>:<p class="source-code">public static List&lt;Bitmap&gt; ConvertFilesToBitmaps</p><p class="source-code">    (List&lt;string&gt; files)</p><p class="source-code">{</p><p class="source-code">    var result = new List&lt;Bitmap&gt;();</p><p class="source-code">    Parallel.ForEach(files, file =&gt;</p><p class="source-code">    {</p><p class="source-code">        FileInfo fi = new(file);</p><p class="source-code">        string ext = fi.Extension.ToLower();</p><p class="source-code">        if (ext == ".jpg" || ext == ".jpeg")</p><p class="source-code">        {</p><p class="source-code">            result.Add(ConvertJpgToBitmap(file));</p><p class="source-code">        }</p><p class="source-code">    });</p><p class="source-code">    return result;</p><p class="source-code">}</p></li>
</ol>
<p>This method <a id="_idIndexMarker314"/>accepts <strong class="source-inline">List&lt;string&gt;</strong> containing the files in the selected folder. Inside the <strong class="source-inline">Parallel.ForEach</strong> loop, it checks whether the file has a <strong class="source-inline">.jpg</strong> or <strong class="source-inline">.jpeg</strong> file extension. If it does, it is converted to a bitmap and added to the <strong class="source-inline">result</strong> collection.</p>
<ol>
<li value="3">Add a new button to <strong class="source-inline">Form1.cs</strong>. Set the <strong class="source-inline">Name</strong> property as <strong class="source-inline">ProcessJpgsButton</strong> and the <strong class="source-inline">Text</strong> property as <strong class="source-inline">Process JPGs</strong>.</li>
<li>Double-click the new button to create an event handler in the code-behind file. Add the following code to the new event handler:<p class="source-code">private void ProcessJpgsButton_Click(object sender, </p><p class="source-code">    EventArgs e)</p><p class="source-code">{</p><p class="source-code">    if (!string.IsNullOrWhiteSpace</p><p class="source-code">        (FolderToProcessTextBox.Text) &amp;&amp;</p><p class="source-code">        Directory.Exists(FolderToProcessTextBox.Text))</p><p class="source-code">    {</p><p class="source-code">        List&lt;string&gt; filesToProcess = Directory</p><p class="source-code">            .GetFiles(FolderToProcessTextBox.Text)</p><p class="source-code">                .ToList();</p><p class="source-code">        List&lt;Bitmap&gt; results = FileProcessor</p><p class="source-code">            .ConvertFilesToBitmaps(filesToProcess);</p><p class="source-code">        StringBuilder resultText = new();</p><p class="source-code">        foreach (var bmp in results)</p><p class="source-code">        {</p><p class="source-code">            resultText.AppendLine($"Bitmap height: </p><p class="source-code">                {bmp.Height}");</p><p class="source-code">        }</p><p class="source-code">        FolderResultsTextBox.Text = </p><p class="source-code">            resultText.ToString();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Now, run the project, select a folder containing some JPG files, and click the new <strong class="bold">Process JPGs</strong> button. You should see the height of each converted JPG listed in the output.</li>
</ol>
<p>That’s <a id="_idIndexMarker315"/>all you need for a simple <strong class="source-inline">Parallel.ForEach</strong> loop. What can you do if you need to cancel a long-running parallel loop? Let’s update our example to do just that with <strong class="source-inline">Parallel.ForEachAsync</strong>.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Cancel a Parallel.ForEachAsync loop</h2>
<p><strong class="source-inline">Parallel.ForEachAsync</strong> is new in .NET 6. It is an awaitable version of <strong class="source-inline">Parallel.ForEach</strong> with an <strong class="source-inline">async</strong> lambda expression as its body. Let’s update the previous <a id="_idIndexMarker316"/>example to use this new <a id="_idIndexMarker317"/>parallel method and add the ability to cancel the operation:</p>
<ol>
<li value="1">We are going to start by making an <strong class="source-inline">async</strong> copy of <strong class="source-inline">ConvertFilesToBitmaps</strong> named <strong class="source-inline">ConvertFilesToBitmapsAsync</strong>. The differences are highlighted in the following:<p class="source-code">public static <strong class="bold">async Task&lt;List&lt;Bitmap&gt;&gt; </strong></p><p class="source-code"><strong class="bold">    ConvertFilesToBitmapsAsync</strong>(List&lt;string&gt; files<strong class="bold">, </strong></p><p class="source-code"><strong class="bold">        CancellationTokenSource cts</strong>)</p><p class="source-code">{</p><p class="source-code">    <strong class="bold">ParallelOptions po = new()</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">        CancellationToken = cts.Token,</strong></p><p class="source-code"><strong class="bold">        MaxDegreeOfParallelism = </strong></p><p class="source-code"><strong class="bold">            Environment.ProcessorCount == 1 ? 1</strong></p><p class="source-code"><strong class="bold">                      : Environment.ProcessorCount - 1</strong></p><p class="source-code"><strong class="bold">    };</strong></p><p class="source-code">    var result = new List&lt;Bitmap&gt;();</p><p class="source-code">    <strong class="bold">try</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">        await Parallel.ForEachAsync(files, po, async </strong></p><p class="source-code"><strong class="bold">            (file, _cts) </strong>=&gt; </p><p class="source-code">        {</p><p class="source-code">            FileInfo fi = new(file);</p><p class="source-code">            string ext = fi.Extension.ToLower();</p><p class="source-code">            if (ext == ".jpg" || ext == "jpeg")</p><p class="source-code">            {</p><p class="source-code">                result.Add(ConvertJpgToBitmap(file));</p><p class="source-code">                <strong class="bold">await Task.Delay(2000, _cts);</strong></p><p class="source-code">            }</p><p class="source-code">        });</p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code"><strong class="bold">    catch (OperationCanceledException e)</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">        MessageBox.Show(e.Message);</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">    finally</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">        cts.Dispose();</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    return result;</p><p class="source-code">}</p></li>
</ol>
<p>The <a id="_idIndexMarker318"/>new method is <strong class="source-inline">async</strong>, returns <strong class="source-inline">Task&lt;List&lt;Bitmap&gt;&gt;</strong>, accepts <strong class="source-inline">CancellationTokenSource</strong>, and uses that <a id="_idIndexMarker319"/>when creating <strong class="source-inline">ParallelOptions</strong> to pass to the <strong class="source-inline">Parallel.ForEachAsync</strong> method. <strong class="source-inline">Parallel.ForEachAsync</strong> is awaited and its lambda expression is declared as <strong class="source-inline">async</strong> so we can await the new <strong class="source-inline">Task.Delay</strong> that has been added to give us enough time to click the <strong class="bold">Cancel</strong> button before the loop completes.</p>
<p>Enclosing <strong class="source-inline">Parallel.ForEachAsync</strong> in a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block that handles <strong class="source-inline">OperationCanceledException</strong> enables the method to catch the cancellation. We’ll show a message to the user after the cancellation is handled.</p>
<p>The code is also setting the <strong class="source-inline">ProcessorCount</strong> option. If there is only one CPU core available, we will set the value to <strong class="source-inline">1</strong>; otherwise, we want to use no more than the number of available cores minus one. The .NET runtime typically manages this value very well, so you should only change this option if you find it improves your application’s performance.</p>
<ol>
<li value="2">In the <strong class="source-inline">Form1.cs</strong> file, add a new <strong class="source-inline">CancellationTokenSource</strong> private variable:<p class="source-code">private CancellationTokenSource _cts;</p></li>
<li>Update <a id="_idIndexMarker320"/>the event handler <a id="_idIndexMarker321"/>to be <strong class="source-inline">async</strong>, set <strong class="source-inline">_cts</strong> to be a new instance of <strong class="source-inline">CancellationTokenSource</strong>, and pass it to <strong class="source-inline">ConvertFilesToBitmapsAsync</strong>. Add <strong class="source-inline">await</strong> to that call as well. </li>
</ol>
<p>All of the necessary changes are highlighted in the following snippet:</p>
<p class="source-code">private <strong class="bold">async</strong> void ProcessJpgsButton_Click(object </p>
<p class="source-code">    sender, EventArgs e)</p>
<p class="source-code">{</p>
<p class="source-code">    if (!string.IsNullOrWhiteSpace</p>
<p class="source-code">        (FolderToProcessTextBox.Text) &amp;&amp;</p>
<p class="source-code">        Directory.Exists(FolderToProcessTextBox.Text))</p>
<p class="source-code">    {</p>
<p class="source-code">        <strong class="bold">_cts = new CancellationTokenSource();</strong></p>
<p class="source-code">        List&lt;string&gt; filesToProcess = Directory</p>
<p class="source-code">           .GetFiles(FolderToProcessTextBox.Text)</p>
<p class="source-code">               .ToList();</p>
<p class="source-code">        List&lt;Bitmap&gt; results = <strong class="bold">await</strong> FileProcessor</p>
<p class="source-code">            .<strong class="bold">ConvertFilesToBitmapsAsync</strong></p>
<p class="source-code"><strong class="bold">                </strong>(filesToProcess<strong class="bold">, _cts</strong>);</p>
<p class="source-code">        StringBuilder resultText = new();</p>
<p class="source-code">        foreach (var bmp in results)</p>
<p class="source-code">        {</p>
<p class="source-code">            resultText.AppendLine($"Bitmap height: </p>
<p class="source-code">                {bmp.Height}");</p>
<p class="source-code">        }</p>
<p class="source-code">        FolderResultsTextBox.Text = resultText</p>
<p class="source-code">            .ToString();</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<ol>
<li value="4">Add a <a id="_idIndexMarker322"/>new button to the form named <strong class="source-inline">CancelButton</strong> with a caption of <strong class="source-inline">Cancel</strong></li>
<li>Double-click <a id="_idIndexMarker323"/>the <strong class="bold">Cancel</strong> button and add the following event handler code:<p class="source-code">private void CancelButton_Click(object sender, </p><p class="source-code">    EventArgs e)</p><p class="source-code">{</p><p class="source-code">    if (_cts != null)</p><p class="source-code">    {</p><p class="source-code">        _cts.Cancel();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Run the application, browse to and select a folder containing JPG files, click the <strong class="bold">Process JPGs</strong> button, and immediately click the <strong class="bold">Cancel</strong> button. You should receive a message indicating that processing has been canceled. No further records are processed.</li>
</ol>
<p>We will <a id="_idIndexMarker324"/>learn more about canceling <a id="_idIndexMarker325"/>asynchronous and parallel work in <a href="B18552_11_ePub.xhtml#_idTextAnchor173"><em class="italic">Chapter 11</em></a>. Now, let’s discuss the <strong class="source-inline">Parallel.Invoke</strong> construct and relationships between tasks in the TPL.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Relationships between parallel tasks</h1>
<p>In the previous chapter, <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>, we learned how <a id="_idIndexMarker326"/>to use <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> to perform work in parallel and manage the flow of tasks by using <strong class="source-inline">ContinueWith</strong>. In this section, we will examine some of the TPL features that can be leveraged to manage relationships between tasks running in parallel.</p>
<p>Let’s start by looking deeper into the <strong class="source-inline">Parallel.Invoke</strong> method provided by the TPL.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Under the covers of Parallel.Invoke</h2>
<p>In <a href="B18552_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, we learned how to use the <strong class="source-inline">Parallel.Invoke</strong> method to execute multiple tasks in parallel. We are going to revisit <strong class="source-inline">Parallel.Invoke</strong> now and <a id="_idIndexMarker327"/>discover what is happening under the covers. Consider <a id="_idIndexMarker328"/>using it to invoke two methods:</p>
<pre class="source-code">Parallel.Invoke(DoFirstAction, DoSectionAction);</pre>
<p>This is what is happening behind the scenes:</p>
<pre class="source-code">List&lt;Task&gt; taskList = new();</pre>
<pre class="source-code">taskList.Add(Task.Run(DoFirstAction));</pre>
<pre class="source-code">taskList.Add(Task.Run(DoSectionAction));</pre>
<pre class="source-code">Task.WaitAll(taskList.ToArray());</pre>
<p>Two tasks will be created and queued on the thread pool. Assuming the system has available resources, the two tasks should be picked up and run in parallel. The calling method will block the current thread, waiting for the parallel tasks to complete. The action will block the calling thread for the duration of the longest-running task.</p>
<p>If this is acceptable for your application, using <strong class="source-inline">Parallel.Invoke</strong> makes the code cleaner and easy to understand. However, if you don’t want to block the calling thread, there are a couple of options. First, let’s make a change to the second example to use <strong class="source-inline">await</strong>:</p>
<pre class="source-code">List&lt;Task&gt; taskList = new();</pre>
<pre class="source-code">taskList.Add(Task.Run(DoFirstAction));</pre>
<pre class="source-code">taskList.Add(Task.Run(DoSectionAction));</pre>
<pre class="source-code">await Task.WhenAll(taskList.ToArray());</pre>
<p>By awaiting <strong class="source-inline">Task.WhenAll</strong> instead of using <strong class="source-inline">Task.WaitAll</strong>, we’re allowing the current thread <a id="_idIndexMarker329"/>to do other work while waiting for the two child tasks to <a id="_idIndexMarker330"/>finish processing in parallel. To achieve the same result with <strong class="source-inline">Parallel.Invoke</strong>, we can wrap it in <strong class="source-inline">Task</strong>:</p>
<pre class="source-code">await Task.Run(() =&gt; Parallel.Invoke(DoFirstTask, </pre>
<pre class="source-code">    DoSecondTask));</pre>
<p>The same technique can be used with <strong class="source-inline">Parallel.For</strong> to avoid blocking the calling thread while waiting for the loop to complete. This is not necessary for <strong class="source-inline">Parallel.ForEach</strong>. Instead of wrapping <strong class="source-inline">Parallel.ForEach</strong> in <strong class="source-inline">Task</strong>, we can replace it with <strong class="source-inline">Parallel.ForEachAsync</strong>. We learned earlier in this chapter that .NET 6 added <strong class="source-inline">Parallel.ForEachAsync</strong>, which returns <strong class="source-inline">Task</strong> and can be awaited.</p>
<p>Next, let’s discuss how the relationship between parent tasks and their children can be managed.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Understanding parallel child tasks</h2>
<p>When <a id="_idIndexMarker331"/>executing nested tasks, by default, the parent task <a id="_idIndexMarker332"/>will not wait for its child tasks unless we use the <strong class="source-inline">Wait()</strong> method or <strong class="source-inline">await</strong> statements. However, this default behavior can be controlled with some options when using <strong class="source-inline">Task.Factory.StartNew()</strong>. To illustrate the available options, we are going to create a new sample project:</p>
<ol>
<li value="1">First, create a new C# console application named <strong class="source-inline">ParallelTaskRelationshipsSample</strong>.</li>
<li>Add a class to the project named <strong class="source-inline">ParallelWork</strong>. This is where we will create the parent methods and their children.</li>
<li>Add the <a id="_idIndexMarker333"/>three following methods to the <strong class="source-inline">ParallelWork</strong> class. These will be our child methods. Each one writes some console <a id="_idIndexMarker334"/>output when starting and completing. Delays are injected with <strong class="source-inline">Thread.SpinWait</strong>. If you are unfamiliar with <strong class="source-inline">Thread.SpinWait</strong>, it puts the current thread into a loop for the number of iterations specified, injecting a wait without removing the thread from consideration with the scheduler:<p class="source-code">public void DoFirstItem()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Starting DoFirstItem");</p><p class="source-code">    Thread.SpinWait(1000000);</p><p class="source-code">    Console.WriteLine("Finishing DoFirstItem");</p><p class="source-code">}</p><p class="source-code">public void DoSecondItem()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Starting DoSecondItem");</p><p class="source-code">    Thread.SpinWait(1000000);</p><p class="source-code">    Console.WriteLine("Finishing DoSecondItem");</p><p class="source-code">}</p><p class="source-code">public void DoThirdItem()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Starting DoThirdItem");</p><p class="source-code">    Thread.SpinWait(1000000);</p><p class="source-code">    Console.WriteLine("Finishing DoThirdItem");</p><p class="source-code">}</p></li>
<li>Next, add a method named <strong class="source-inline">DoAllWork</strong>. This method will create a parent task that calls <a id="_idIndexMarker335"/>the preceding three methods with child <a id="_idIndexMarker336"/>tasks. There is no code added to wait for the child tasks:<p class="source-code">public void DoAllWork()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Starting DoAllWork");</p><p class="source-code">    Task parentTask = Task.Factory.StartNew(() =&gt;</p><p class="source-code">    {</p><p class="source-code">        var child1 = Task.Factory.StartNew</p><p class="source-code">             (DoFirstItem);</p><p class="source-code">        var child2 = Task.Factory.StartNew</p><p class="source-code">              (DoSecondItem);</p><p class="source-code">        var child3 = Task.Factory.StartNew</p><p class="source-code">              (DoThirdItem);</p><p class="source-code">    });</p><p class="source-code">    parentTask.Wait();</p><p class="source-code">    Console.WriteLine("Finishing DoAllWork");</p><p class="source-code">}</p></li>
<li>Now, add some code to run <strong class="source-inline">DoAllWork</strong> from <strong class="source-inline">Program.cs</strong>:<p class="source-code">using ParallelTaskRelationshipsSample;</p><p class="source-code">var parallelWork = new ParallelWork();</p><p class="source-code">parallelWork.DoAllWork();</p><p class="source-code">Console.ReadKey();</p></li>
<li>Run the <a id="_idIndexMarker337"/>program and examine the output. As you <a id="_idIndexMarker338"/>might expect, the parent task completes before its children:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 6.3 – The console application runs DoAllWork " height="425" src="image/Figure_6.3_B18552.jpg" width="757"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The console application runs DoAllWork</p>
<ol>
<li value="7">Next, let’s create a method named <strong class="source-inline">DoAllWorkAttached</strong>. This method will run the same three child tasks, but the child task will include the <strong class="source-inline">TaskCreationOptions.AttachedToParent</strong> option:<p class="source-code">public void DoAllWorkAttached()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Starting DoAllWorkAttached");</p><p class="source-code">    Task parentTask = Task.Factory.StartNew(() =&gt;</p><p class="source-code">    {</p><p class="source-code">        var child1 = Task.Factory.StartNew</p><p class="source-code">            (DoFirstItem, <strong class="bold">TaskCreationOptions</strong></p><p class="source-code"><strong class="bold">                .AttachedToParent</strong>);</p><p class="source-code">        var child2 = Task.Factory.StartNew</p><p class="source-code">            (DoSecondItem, <strong class="bold">TaskCreationOptions</strong></p><p class="source-code"><strong class="bold">                .AttachedToParent</strong>);</p><p class="source-code">        var child3 = Task.Factory.StartNew</p><p class="source-code">            (DoThirdItem, <strong class="bold">TaskCreationOptions</strong></p><p class="source-code"><strong class="bold">                .AttachedToParent</strong>);</p><p class="source-code">    });</p><p class="source-code">    parentTask.Wait();</p><p class="source-code">    Console.WriteLine("Finishing DoAllWorkAttached");</p><p class="source-code">}</p></li>
<li>Update <strong class="source-inline">Program.cs</strong> to <a id="_idIndexMarker339"/>call <strong class="source-inline">DoAllWorkAttached</strong> instead <a id="_idIndexMarker340"/>of <strong class="source-inline">DoAllWork</strong> and run the application again:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer035">
<img alt="Figure 6.4 – Running our application and calling DoAllWorkAttached " height="476" src="image/Figure_6.4_B18552.jpg" width="762"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Running our application and calling DoAllWorkAttached</p>
<p>You can see <a id="_idIndexMarker341"/>that even though we are not explicitly <a id="_idIndexMarker342"/>waiting for the child tasks, the parent task does not complete until its children do.</p>
<p>Now, suppose you have another parent that should not wait for its child tasks, regardless of whether they are started with the <strong class="source-inline">TaskCreationOptions.AttachedToParent</strong> option. Let’s create a new method that can handle this scenario:</p>
<ol>
<li value="1">Create a method named <strong class="source-inline">DoAllWorkDenyAttach</strong> with the following code:<p class="source-code">public void DoAllWorkDenyAttach()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Starting DoAllWorkDenyAttach");</p><p class="source-code">    Task parentTask = Task.Factory.StartNew(() =&gt;</p><p class="source-code">    {</p><p class="source-code">        var child1 = Task.Factory.StartNew</p><p class="source-code">            (DoFirstItem, <strong class="bold">TaskCreationOptions</strong></p><p class="source-code"><strong class="bold">                .AttachedToParent</strong>);</p><p class="source-code">        var child2 = Task.Factory.StartNew</p><p class="source-code">             (DoSecondItem, <strong class="bold">TaskCreationOptions</strong></p><p class="source-code"><strong class="bold">                 .AttachedToParent</strong>);</p><p class="source-code">        var child3 = Task.Factory.StartNew</p><p class="source-code">            (DoThirdItem, <strong class="bold">TaskCreationOptions</strong></p><p class="source-code"><strong class="bold">                .AttachedToParent</strong>);</p><p class="source-code">    }, <strong class="bold">TaskCreationOptions.DenyChildAttach</strong>);</p><p class="source-code">    parentTask.Wait();</p><p class="source-code">    Console.WriteLine("Finishing DoAllWork</p><p class="source-code">        DenyAttach");</p><p class="source-code">}</p></li>
</ol>
<p>The child <a id="_idIndexMarker343"/>tasks are still being created with <a id="_idIndexMarker344"/>the <strong class="source-inline">AttachedToParent</strong> option, but the parent task now has a <strong class="source-inline">DenyChildAttach</strong> option set. This will supersede the child requests to attach to the parent.</p>
<ol>
<li value="2">Update <strong class="source-inline">Program.cs</strong> to call <strong class="source-inline">DoAllWorkDenyAttach</strong> and run the application once more:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 6.5 – The console application calls DoAllWorkDenyAttach " height="463" src="image/Figure_6.5_B18552.jpg" width="810"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The console application calls DoAllWorkDenyAttach</p>
<p>You can <a id="_idIndexMarker345"/>see that <strong class="source-inline">DenyChildAttach</strong> did <a id="_idIndexMarker346"/>override the <strong class="source-inline">AttachToParent</strong> option set on each child task. The parent completed without waiting for the children, as it did when calling <strong class="source-inline">DoAllWork</strong>.</p>
<p>One final note about this example. You may have noticed that we used <strong class="source-inline">Task.Factory.StartNew</strong> instead of <strong class="source-inline">Task.Run</strong>, even when we didn’t need to set <strong class="source-inline">TaskCreationOption</strong>. That is because <strong class="source-inline">Task.Run</strong> will prohibit any child tasks from attaching to a parent. If you used <strong class="source-inline">Task.Run</strong> for the parent task in the <strong class="source-inline">DoAllWorkAttached</strong> method, the parent would have completed first, as it did in the other methods.</p>
<p>Let’s finish up this chapter by covering some potential pitfalls when working with parallel programming in .NET.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Common pitfalls with parallelism</h1>
<p>When working with the TPL, there are some practices to avoid in order to ensure the best outcomes <a id="_idIndexMarker347"/>in your applications. In some cases, parallelism used incorrectly can result in performance degradation. In other cases, it can cause errors or data corruption.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Parallelism is not guaranteed</h2>
<p>When using one of the parallel loops or <strong class="source-inline">Parallel.Invoke</strong>, the iterations can run in parallel, but they are not guaranteed to do so. The code in these parallel delegates should be able to run successfully in either scenario.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>Parallel loops are not always faster</h2>
<p>We discussed this earlier in this chapter, but it is important to remember that parallel versions of <strong class="source-inline">for</strong> and <strong class="source-inline">foreach</strong> loops are not always faster. If each loop iteration runs quickly, the overhead of adding parallelism can slow down your application.</p>
<p>This is important to remember when introducing any threading to applications. Always test your code before and after introducing concurrency or parallelism to ensure that the performance gains are worth the overhead of threading.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Beware of blocking the UI thread</h2>
<p>Remember that <strong class="source-inline">Parallel.For</strong> and <strong class="source-inline">Parallel.ForEach</strong> are <em class="italic">blocking calls</em>. If you use them on the UI thread, they will block the UI for the duration of the call. This blocking duration will be, at a minimum, the duration of the longest-running loop iteration.</p>
<p>As we discussed in the previous section, you can wrap the parallel code in a call to <strong class="source-inline">Task.Run</strong> to move the execution from the UI thread to a background thread on the thread pool.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Thread safety</h2>
<p>Do not make calls to .NET methods that are not thread-safe within parallel loops. The thread safety of each .NET type is documented on Microsoft Docs. Use the .NET API browser to quickly find information about specific .NET APIs: <a href="https://docs.microsoft.com/dotnet/api/">https://docs.microsoft.com/dotnet/api/</a>.</p>
<p>Limit the <a id="_idIndexMarker348"/>use of static .NET methods in parallel loops, even if they are marked as thread-safe. They will not cause errors or problems with data consistency, but they can negatively impact the loop performance. Even calls to <strong class="source-inline">Console.WriteLine</strong> should only be used for testing or demonstration purposes. Do not use these in production code.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>UI controls</h2>
<p>In Windows client <a id="_idIndexMarker349"/>applications, do not try to access UI controls within parallel loops. WinForms and WPF controls can only be accessed from the thread on which they were created. You can use <strong class="source-inline">Dispatcher.Invoke</strong> to invoke actions on other threads, but this will have performance implications. It is best to update the UI after your parallel loops have been completed.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>ThreadLocal data</h2>
<p>Remember to take advantage of <strong class="source-inline">ThreadLocal</strong> variables in your parallel loops. We illustrated how to do this in the <em class="italic">Parallel loops with thread-local variables</em> section earlier in this chapter.</p>
<p>That covers your introduction to parallel programming with C# and .NET. Let’s wrap up by reviewing everything we have learned in the chapter.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Summary</h1>
<p>In this chapter, we learned how to leverage parallel programming concepts in our .NET applications. We got hands-on with <strong class="source-inline">Parallel.For</strong>, <strong class="source-inline">Parallel.ForEach</strong>, and <strong class="source-inline">Parallel.ForEachAsync</strong> loops. In those sections, we learned how to safely aggregate data while maintaining thread safety. Next, we learned how to manage relationships between parent tasks and their parallel children. This will help to ensure your applications maintain an expected order of operations. </p>
<p>Finally, we covered some important pitfalls to avoid when implementing parallelism in our applications. Developers will want to pay close attention to avoid any of these pitfalls in their own applications.</p>
<p>To read more about data parallelism in .NET, the <em class="italic">Data Parallelism</em> documentation on Microsoft Docs is a great place to start: <a href="https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library">https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library</a>.</p>
<p>In the next chapter, we will continue our exploration of the TPL by learning how to leverage the various building blocks included in the TPL Dataflow Library.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Questions</h1>
<ol>
<li value="1">Which parallel loop executes a delegate in parallel for a given number of iterations?</li>
<li>Which parallel loop is the awaitable version of <strong class="source-inline">Parallel.ForEach</strong>?</li>
<li>Which parallel method can execute two or more provided actions in parallel?</li>
<li>Which <strong class="source-inline">Task.Factory.StartNew</strong> option can attach a child task’s completion to its parent?</li>
<li>Which <strong class="source-inline">Task.Factory.StartNew</strong> option can be provided to a parent task to prevent any child tasks from attaching?</li>
<li>Why should you never use <strong class="source-inline">Task.Run</strong> when using <strong class="source-inline">TaskCreationOptions</strong> to establish parent/child relationships?</li>
<li>Are parallel loops always faster than their traditional counterparts?</li>
</ol>
</div>
</div>
</body></html>