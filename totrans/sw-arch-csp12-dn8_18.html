<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer292">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">18</span></h1>
<h1 class="chapterTitle" id="_idParaDest-363"><span class="koboSpan" id="kobo.2.1">Implementing Frontend Microservices with ASP.NET Core</span></h1>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.3.1">Chapter 14</span></em><span class="koboSpan" id="kobo.4.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.6.1">, described general techniques for implementing microservices in .NET but focused mainly on worker microservices, that is, on microservices that perform background jobs without communicating with anything outside of the application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.7.1">Microservices that communicate with the world outside of the application bring with them other problems and need further techniques.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.8.1">More specifically, microservices that communicate with a human user must implement a presentation layer, while microservices that expose APIs must conform to well-established standards and should preferably have documentation. </span><span class="koboSpan" id="kobo.8.2">Moreover, web APIs that target </span><strong class="keyWord"><span class="koboSpan" id="kobo.9.1">single-page applications</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.11.1">SPAs</span></strong><span class="koboSpan" id="kobo.12.1">) must conform with browser policies; that is, either they are exposed on a single domain that is the same domain the SPA was downloaded from, or they must configure CORS policies. </span><span class="koboSpan" id="kobo.12.2">We will see how to address both CORS and issues due to browser policies in </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter 19</span></em><span class="koboSpan" id="kobo.14.1">, </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Client Frameworks: Blazor</span></em><span class="koboSpan" id="kobo.16.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Worth mentioning also are all the challenges brought by any presentation layer, that is, ensuring a fast and effective interaction with the user and managing the state of the interaction with the user with maintainable code without falling into spaghetti code. </span><span class="koboSpan" id="kobo.17.2">General usability problems and solutions were discussed in </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 2, Non-Functional Requirements</span></em><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">We will discuss more technology-specific usability and status management problems in this chapter and in </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 19</span></em><span class="koboSpan" id="kobo.21.1">, </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Client Frameworks: Blazor</span></em><span class="koboSpan" id="kobo.23.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.24.1">Finally, all front end microservices must put solid security policies in place to defend the application from hackers. </span><span class="koboSpan" id="kobo.24.2">Some techniques are common to both front-ends and web APIs and are automatically handled by all major web servers, such as countermeasures against path-transversal attacks and denial of service. </span><span class="koboSpan" id="kobo.24.3">Others, instead, are specific to HTML pages, such as forgery. </span><span class="koboSpan" id="kobo.24.4">ASP.NET Core MVC defenses against forgery are discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Chapter 21,</span></em> <em class="italic"><span class="koboSpan" id="kobo.26.1">Case study</span></em><span class="koboSpan" id="kobo.27.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.28.1">Techniques for implementing public self-documented web APIs were described in </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Chapter 15</span></em><span class="koboSpan" id="kobo.30.1">, </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Applying Service-Oriented Architectures with .NET</span></em><span class="koboSpan" id="kobo.32.1">, while techniques for implementing server-based presentation layers were covered in </span><em class="italic"><span class="koboSpan" id="kobo.33.1">Chapter 17</span></em><span class="koboSpan" id="kobo.34.1">, </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.36.1">, and techniques for implementing client-based presentation layers will be covered in </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Chapter 19</span></em><span class="koboSpan" id="kobo.38.1">, </span><em class="italic"><span class="koboSpan" id="kobo.39.1">Client Frameworks: Blazor</span></em><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">Moreover, general techniques for implementing microservices were covered in </span><em class="italic"><span class="koboSpan" id="kobo.41.1">Chapter 11</span></em><span class="koboSpan" id="kobo.42.1">, </span><em class="italic"><span class="koboSpan" id="kobo.43.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.44.1">, </span><em class="italic"><span class="koboSpan" id="kobo.45.1">Chapter 7</span></em><span class="koboSpan" id="kobo.46.1">, </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.48.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.49.1">Chapter 14</span></em><span class="koboSpan" id="kobo.50.1">, </span><em class="italic"><span class="koboSpan" id="kobo.51.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.52.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.53.1">Therefore, in this chapter, after a short section about concepts and techniques specific to front-end microservices, we will show you how to put all these concepts and techniques together in the practical implementation of a front-end microservice. </span><span class="koboSpan" id="kobo.53.2">More specifically, we will discuss various implementation options and how to architect the whole layer structure of a front-end microservice. </span><span class="koboSpan" id="kobo.53.3">A complete example that shows how all layers of a front-end microservice work together, in practice, is described in the </span><em class="italic"><span class="koboSpan" id="kobo.54.1">A frontend microservice</span></em><span class="koboSpan" id="kobo.55.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.56.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.57.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.58.1">More specifically, this chapter covers the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.59.1">Front-ends and micro-frontends</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.60.1">Defining the domain layer interface</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.61.1">Defining the domain layer implementation</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.62.1">Defining the application layer</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.63.1">Defining controllers</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.64.1">We will use the onion architecture and the patterns described in </span><em class="italic"><span class="koboSpan" id="kobo.65.1">Chapter 7</span></em><span class="koboSpan" id="kobo.66.1">, </span><em class="italic"><span class="koboSpan" id="kobo.67.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.68.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-364"><span class="koboSpan" id="kobo.69.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.70.1">This chapter requires the free Visual Studio 2022 Community edition or better with all database tools installed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.71.1">The code samples necessary to clarify the concepts in this chapter will be taken from a practical example application based on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">WWTravelClub</span></code><span class="koboSpan" id="kobo.73.1"> book use case. </span><span class="koboSpan" id="kobo.73.2">The full example application is described in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.74.1">A front end microservice</span></em><span class="koboSpan" id="kobo.75.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.76.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">Its code is available at </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.78.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.79.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-365"><span class="koboSpan" id="kobo.80.1">Front-ends and micro-frontends</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.81.1">The main peculiarity of front-end microservices is that they need a robust web server that is able to optimize all </span><a id="_idIndexMarker1274"/><span class="koboSpan" id="kobo.82.1">the request/response handling and ensure the needed level of security. </span><span class="koboSpan" id="kobo.82.2">Moreover, high-traffic applications also need a load balancer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.83.1">Examples of </span><a id="_idIndexMarker1275"/><span class="koboSpan" id="kobo.84.1">services offered by robust web servers like IIS, Apache, and NGINX are:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.85.1">Limiting access to just some file types and directories to prevent access to private files and to prevent remote file execution; that is, execution of server commands/scripts through web requests.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.86.1">Blocking dangerous requests that might cause access to unwanted files or directories (path-traversal attacks).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.87.1">Blocking requests that exceed a customizable length since they might cause a denial of service.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.88.1">Logging and IP address blocking to discover and contrast hacker attacks.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.89.1">Redirecting requests to the application associated with each URL.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.90.1">Queueing requests and assigning them to available threads. </span><span class="koboSpan" id="kobo.90.2">This capability is fundamental for performance optimization since executing too many requests compared to the available processor cores might cause unacceptable performance.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.91.1">Ensuring the isolation of applications running on the same process but in different threads and more.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.92.1">If the front-end service is hosted on a Kubernetes cluster, both an adequate web server and load balancing can be provided </span><a id="_idIndexMarker1276"/><span class="koboSpan" id="kobo.93.1">through an </span><strong class="keyWord"><span class="koboSpan" id="kobo.94.1">Ingress</span></strong><span class="koboSpan" id="kobo.95.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.96.1">Otherwise, </span><strong class="keyWord"><span class="koboSpan" id="kobo.97.1">Azure App Service</span></strong><span class="koboSpan" id="kobo.98.1"> (see the </span><em class="italic"><span class="koboSpan" id="kobo.99.1">Further reading</span></em><span class="koboSpan" id="kobo.100.1"> section) might be a good option since it offers a scalable level </span><a id="_idIndexMarker1277"/><span class="koboSpan" id="kobo.101.1">of load balancing, excellent security, monitoring services, and so on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.102.1">A front-end </span><a id="_idIndexMarker1278"/><span class="koboSpan" id="kobo.103.1">microservice doesn’t need to interface directly with anything outside of an application. </span><span class="koboSpan" id="kobo.103.2">In fact, in micro-frontend architectures, there is no unique front-end, but the role of the front-end is split among several microservices. </span><span class="koboSpan" id="kobo.103.3">In these architectures, typically, the role of directing traffic toward the right front-end and/or of combining several responses into a unique response is taken by an interface front-end that is load-balanced and carries the burden of ensuring the right level of security.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.104.1">The reasons for </span><a id="_idIndexMarker1279"/><span class="koboSpan" id="kobo.105.1">using micro-frontends are the same as the ones for using other microservices. </span><span class="koboSpan" id="kobo.105.2">We discussed them in detail in </span><em class="italic"><span class="koboSpan" id="kobo.106.1">Chapter 11</span></em><span class="koboSpan" id="kobo.107.1">, </span><em class="italic"><span class="koboSpan" id="kobo.108.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.109.1">, but it is worth repeating the more important ones here:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.110.1">Optimizing the usage of hardware resources by scaling just the microservices that need more resources</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.111.1">Having independent software lifecycles for each microservice, so each microservice can evolve independently from the others to match the user needs and so that each microservices developer team can work independently from the others</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.112.1">Micro-frontend architectures use quite different techniques for HTML websites, like ASP.NET Core MVC websites, and for web APIs. </span><span class="koboSpan" id="kobo.112.2">Actually, the word “micro-frontend” is used just with HTML websites/SPAs, while web APIs exposed to the outside world are referred to as public web APIs. </span><span class="koboSpan" id="kobo.112.3">We will describe public web APIs and HTML micro-frontends and the techniques they use in two dedicated subsections, starting with public web APIs.</span></p>
<h2 class="heading-2" id="_idParaDest-366"><span class="koboSpan" id="kobo.113.1">Public web APIs</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.114.1">In the case </span><a id="_idIndexMarker1280"/><span class="koboSpan" id="kobo.115.1">of web APIs, all microservices are accessible through a unique load-balanced piece of software called an </span><strong class="keyWord"><span class="koboSpan" id="kobo.116.1">API gateway</span></strong><span class="koboSpan" id="kobo.117.1"> that sits </span><a id="_idIndexMarker1281"/><span class="koboSpan" id="kobo.118.1">in between the clients and the various API services. </span><span class="koboSpan" id="kobo.118.2">The basic role of an API gateway is to make the whole API accessible from a unique domain to both avoid problems with the browser’s unique domain policy and make the usage of all API services simpler.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.119.1"><img alt="" role="presentation" src="../Images/B19820_18_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.120.1">Figure 18.1: API gateway</span></p>
<p class="normal"><span class="koboSpan" id="kobo.121.1">However, the API gateway </span><a id="_idIndexMarker1282"/><span class="koboSpan" id="kobo.122.1">offers the opportunity to centralize other functions that are common to all API services, such as:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.123.1">Authentication</span></strong><span class="koboSpan" id="kobo.124.1">, that is, validating and decoding the authentication token that comes with each request (please do not confuse authentication with login).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.125.1">Caching</span></strong><span class="koboSpan" id="kobo.126.1">, that is, caching responses according to configurable caching policies.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.127.1">Translation</span></strong><span class="koboSpan" id="kobo.128.1">, that is, adapting the interface, as seen by the client, to the actual signature of the various API methods. </span><span class="koboSpan" id="kobo.128.2">This way, each API can change its interface without affecting existing clients.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.129.1">Versioning</span></strong><span class="koboSpan" id="kobo.130.1">, that is, directing each request toward a compatible version of each API service.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.131.1">Documentation</span></strong><span class="koboSpan" id="kobo.132.1">, that is, offering a unique documentation endpoint.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.133.1">API gateways </span><a id="_idIndexMarker1283"/><span class="koboSpan" id="kobo.134.1">have continued to evolve, absorbing and offering more and more functions, giving rise to the so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.135.1">API management systems</span></strong><span class="koboSpan" id="kobo.136.1"> that now automate and take care of most of the burden of handling public web APIs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.137.1">Azure, like all clouds, offers a good API management service. </span><span class="koboSpan" id="kobo.137.2">You can find more information about it here: </span><a href="https://azure.microsoft.com/en-us/services/api-management/#overview"><span class="url"><span class="koboSpan" id="kobo.138.1">https://azure.microsoft.com/en-us/services/api-management/#overview</span></span></a><span class="koboSpan" id="kobo.139.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.140.1">It is also </span><a id="_idIndexMarker1284"/><span class="koboSpan" id="kobo.141.1">worth mentioning </span><strong class="keyWord"><span class="koboSpan" id="kobo.142.1">Ocelot</span></strong><span class="koboSpan" id="kobo.143.1"> (</span><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot"><span class="url"><span class="koboSpan" id="kobo.144.1">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot"</span></span></a><span class="koboSpan" id="kobo.145.1">), a library for easily creating custom API gateways. </span><span class="koboSpan" id="kobo.145.2">You can either use it to fill in configuration files or as a base for a completely custom API gateway.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.146.1">Now, we are ready to discuss HTML micro-frontends, which also add the challenge of combining several HTML fragments into a unique HTML page.</span></p>
<h2 class="heading-2" id="_idParaDest-367"><span class="koboSpan" id="kobo.147.1">HTML micro-frontends</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.148.1">Several HTML micro-frontends can cooperate on the same application by furnishing each with a different set of web pages. </span><span class="koboSpan" id="kobo.148.2">In this case, coordinating them requires nothing more than links pointing to the other micro-frontends </span><a id="_idIndexMarker1285"/><span class="koboSpan" id="kobo.149.1">and a common sign-in so that users don’t need to log in each time they move to a different micro-frontend.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.150.1">However, very often, several micro-frontends cooperate in the construction of the same page by supplying various page areas. </span><span class="koboSpan" id="kobo.150.2">In this case, a software component must take the burden of assembling the various parts into a unique page.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.151.1">The main difficulty of combining several HTML fragments into a single HTML page is offering a coherent experience to the user, thus avoiding assembling all page areas in a way that is hard to understand for the user. </span><span class="koboSpan" id="kobo.151.2">Another problem is avoiding the continuous page flipping and reorganization each time new content reaches the browser. </span><span class="koboSpan" id="kobo.151.3">In what follows, we will discuss how these problems are solved by different technologies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.152.1">In the case of classic web applications that build the HTML on the server side, an interface application furnishes the page layout and then calls the various micro-frontends to fill the various layout areas.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.153.1"><img alt="" role="presentation" src="../Images/B19820_18_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.154.1">Figure 18.2: Server-side micro-frontend</span></p>
<p class="normal"><span class="koboSpan" id="kobo.155.1">In this case, there is no browser page flipping and reorganization issue since the whole HTML page is assembled on the server side and sent to the browser only when it is ready. </span><span class="koboSpan" id="kobo.155.2">However, we pay for this advantage with the memory consumption for the whole time needed to assemble the whole page before sending it to the browser.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.156.1">Both the layout to use and which calls to make to the involved micro-frontends are obtained by processing the request URL according to rules that are either hardwired in the code or, better, stored in one or more configuration sources (in the simplest case, a unique configuration file). </span><span class="koboSpan" id="kobo.156.2">Using predefined page patterns ensures coherence and a good user experience, but we pay the cost in maintainability because we need to update and test the interface application at each non-trivial change of any single micro-frontend that furnishes page areas.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.157.1">In the case </span><a id="_idIndexMarker1286"/><span class="koboSpan" id="kobo.158.1">of SPAs, the assembly process takes place on the client, that is, in the browser:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.159.1">A kernel application furnishes the initial HTML page.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.160.1">The kernel application downloads a JavaScript file from each micro-frontend. </span><span class="koboSpan" id="kobo.160.2">Each of these JavaScript files is a micro-SPA that creates page areas.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.161.1">The kernel application, based on the current URL, decides which URL to pass to each micro-SPA and then puts the HTML produced by each micro-SPA in the right place.</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.162.1"><img alt="" role="presentation" src="../Images/B19820_18_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.163.1">Figure 18.3: Client-side micro-frontend</span></p>
<p class="normal"><span class="koboSpan" id="kobo.164.1">The various </span><a id="_idIndexMarker1287"/><span class="koboSpan" id="kobo.165.1">micro-SPAs do not interfere with each other because each of them runs in a separate JavaScript scope. </span><span class="koboSpan" id="kobo.165.2">Therefore, for instance, we can mix micro-SPAs implemented with different and incompatible versions of Angular and/or React.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.166.1">Micro-frontends can also be implemented using WebAssembly frameworks like Blazor (see </span><em class="italic"><span class="koboSpan" id="kobo.167.1">Chapter 19</span></em><span class="koboSpan" id="kobo.168.1">,</span><em class="italic"><span class="koboSpan" id="kobo.169.1"> Client Frameworks: Blazor</span></em><span class="koboSpan" id="kobo.170.1">) that run .NET code. </span><span class="koboSpan" id="kobo.170.2">However, in this case, the various micro-SPAs do not run in separate environments, so they must be based on compatible .NET versions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.171.1">SPA micro-frontends have the same maintainability costs as server-based micro-frontends and have browser page flipping and reorganization issues since the page is created dynamically as new content and/or data reach the browser. </span><span class="koboSpan" id="kobo.171.2">This problem can be solved by pre-allocating each content area of the browser page with fixed-size HTML tags. </span><span class="koboSpan" id="kobo.171.3">Thus, for instance, we may pre-allocate a 300 px X 300 px area to show weather forecasts and some pictures or animation while the actual content is loading.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.172.1">In the next section, we will introduce the architectural schema for building a front-end microservice based on ASP.NET Core MVC.</span></p>
<h1 class="heading-1" id="_idParaDest-368"><span class="koboSpan" id="kobo.173.1">Defining the application architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.174.1">The application will be implemented with the </span><strong class="keyWord"><span class="koboSpan" id="kobo.175.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.176.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.177.1">DDD</span></strong><span class="koboSpan" id="kobo.178.1">) approach and associated patterns </span><a id="_idIndexMarker1288"/><span class="koboSpan" id="kobo.179.1">described in </span><em class="italic"><span class="koboSpan" id="kobo.180.1">Chapter 7</span></em><span class="koboSpan" id="kobo.181.1">, </span><em class="italic"><span class="koboSpan" id="kobo.182.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.183.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.184.1">Chapter 13</span></em><span class="koboSpan" id="kobo.185.1">, </span><em class="italic"><span class="koboSpan" id="kobo.186.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.187.1">, so having a </span><a id="_idIndexMarker1289"/><span class="koboSpan" id="kobo.188.1">good understanding of the content covered in those chapters is a fundamental prerequisite to reading this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.189.1">The application is organized based on a DDD approach and uses SOLID principles to map your domain sections. </span><span class="koboSpan" id="kobo.189.2">That is, the application is organized into three layers, each implemented as a different project:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.190.1">There’s a domain layer, which contains the repository’s implementation and the classes describing database entities. </span><span class="koboSpan" id="kobo.190.2">It is a .NET library project. </span><span class="koboSpan" id="kobo.190.3">However, since it needs some interfaces, like </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">IServiceCollection</span></code><span class="koboSpan" id="kobo.192.1">, which are defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">Microsoft.NET.Sdk.web</span></code><span class="koboSpan" id="kobo.194.1">, and since the </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">DBContext</span></code><span class="koboSpan" id="kobo.196.1"> layer must inherit from the identity framework in order to also handle the application authentication and authorization database tables, we must add a reference not only to the .NET SDK but also to the ASP.NET Core SDK. </span><span class="koboSpan" id="kobo.196.2">However, it is also common to implement custom user management.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.197.1">There’s also a domain layer abstraction, which contains repository specifications; that is, interfaces that describe repository implementations and DDD aggregates. </span><span class="koboSpan" id="kobo.197.2">In our implementation, we decided to implement aggregates by hiding the forbidden operations/properties of root data entities behind interfaces, as discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.198.1">How data and domain layers communicate with other layers</span></em><span class="koboSpan" id="kobo.199.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.200.1">Chapter 13, Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.201.1">. </span><span class="koboSpan" id="kobo.201.2">Hence, for instance, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">Package</span></code><span class="koboSpan" id="kobo.203.1"> data layer class, which is an aggregate root, has a corresponding </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">IPackage</span></code><span class="koboSpan" id="kobo.205.1"> interface in the domain layer abstraction that hides all the property setters of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">Package</span></code><span class="koboSpan" id="kobo.207.1"> entity. </span><span class="koboSpan" id="kobo.207.2">The domain layer abstraction also contains the definitions of all the domain events, while the event handlers that will subscribe to these events are defined in the application layer.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.208.1">Finally, there’s the application layer – that is, the ASP.NET Core MVC application (ASP.NET Core MVC is discussed in </span><em class="italic"><span class="koboSpan" id="kobo.209.1">Chapter 17</span></em><span class="BS---InfoBox-Normal--PACKT--Char"><span class="koboSpan" id="kobo.210.1">, </span></span><em class="italic"><span class="koboSpan" id="kobo.211.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.212.1">) – where we define DDD queries, commands, command handlers, and event handlers. </span><span class="koboSpan" id="kobo.212.2">Controllers fill query objects and execute them to get ViewModels they can pass to Views. </span><span class="koboSpan" id="kobo.212.3">They update storage by filling command objects and executing their associated command handlers. </span><span class="koboSpan" id="kobo.212.4">In turn, command handlers use </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">IRepository</span></code><span class="koboSpan" id="kobo.214.1"> interfaces and </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.216.1"> instances coming from the domain layer to manage and coordinate transactions.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.217.1">The application </span><a id="_idIndexMarker1290"/><span class="koboSpan" id="kobo.218.1">uses the </span><strong class="keyWord"><span class="koboSpan" id="kobo.219.1">Command Query Responsibility Segregation</span></strong><span class="koboSpan" id="kobo.220.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.221.1">CQRS</span></strong><span class="koboSpan" id="kobo.222.1">) pattern; therefore, it uses command objects to modify the storage and the query object to query it. </span><span class="koboSpan" id="kobo.222.2">CQRS was described in the </span><em class="italic"><span class="koboSpan" id="kobo.223.1">Command Query Responsibility Segregation (CQRS) pattern</span></em><span class="koboSpan" id="kobo.224.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.225.1">Chapter 7, Understanding the Different Domains in Software Solutions.</span></em></p>
<p class="normal"><span class="koboSpan" id="kobo.226.1">The query is simple to use and implement: controllers fill their parameters and then call their execution methods. </span><span class="koboSpan" id="kobo.226.2">In turn, query objects have direct LINQ implementations that project results directly onto the ViewModels used by the controller Views with </span><code class="inlineCode"><span class="koboSpan" id="kobo.227.1">Select</span></code><span class="koboSpan" id="kobo.228.1"> LINQ methods. </span><span class="koboSpan" id="kobo.228.2">You may also decide to hide the LINQ implementation behind the same repository classes used for the storage update operations, but this would turn the definition and modification of simple queries into very time-consuming tasks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.229.1">In any case, it could be beneficial to encapsulate query objects behind interfaces so that their implementations can be replaced by fake implementations when you test controllers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.230.1">However, the chain of objects and calls involved in the execution of commands is more complex. </span><span class="koboSpan" id="kobo.230.2">This is because it requires the construction and modification of aggregates, as well as a definition of the interaction between several aggregates and between aggregates and other applications through domain events to be provided.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.231.1">The following diagram is a sketch of how storage update operations are performed. </span><span class="koboSpan" id="kobo.231.2">The circles are data being exchanged </span><a id="_idIndexMarker1291"/><span class="koboSpan" id="kobo.232.1">between the various layers, while the rectangles are the procedures that process them. </span><span class="koboSpan" id="kobo.232.2">Moreover, dotted arrows connect interfaces with the types that implement them:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.233.1"><img alt="" role="presentation" src="../Images/B19820_18_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.234.1">Figure 18.4: Diagram of command execution</span></p>
<p class="normal"><span class="koboSpan" id="kobo.235.1">Here’s the flow of action through </span><em class="italic"><span class="koboSpan" id="kobo.236.1">Figure 18.4</span></em><span class="koboSpan" id="kobo.237.1"> as a list of steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.238.1">A controller’s action method receives one or more ViewModels and performs validation.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.239.1">One or more ViewModels containing changes to apply are hidden behind interfaces (</span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">IMyUpdate</span></code><span class="koboSpan" id="kobo.241.1">) defined in the domain layer. </span><span class="koboSpan" id="kobo.241.2">They are used to fill the properties of a command object. </span><span class="koboSpan" id="kobo.241.3">These interfaces must be defined in the domain layer since they will be used as arguments of the repository aggregate methods defined there.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.242.1">A command handler </span><a id="_idIndexMarker1292"/><span class="koboSpan" id="kobo.243.1">matching the previous command is retrieved via </span><strong class="keyWord"><span class="koboSpan" id="kobo.244.1">Dependency Injection</span></strong><span class="koboSpan" id="kobo.245.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.246.1">DI</span></strong><span class="koboSpan" id="kobo.247.1">) in the controller action method. </span><span class="koboSpan" id="kobo.247.2">Then, the handler is executed. </span><span class="koboSpan" id="kobo.247.3">During its execution, the handler interacts with various repository interface methods and with the aggregates they return.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.248.1">When creating the command handler discussed in </span><em class="italic"><span class="koboSpan" id="kobo.249.1">step 3</span></em><span class="koboSpan" id="kobo.250.1">, the ASP.NET Core DI engine automatically injects all parameters declared in its constructor. </span><span class="koboSpan" id="kobo.250.2">In particular, it injects all </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">IRepository</span></code><span class="koboSpan" id="kobo.252.1"> implementations needed to perform all command handler transactions. </span><span class="koboSpan" id="kobo.252.2">The command handler performs its job by calling the methods of these </span><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">IRepository</span></code><span class="koboSpan" id="kobo.254.1"> implementations received in its constructor to build aggregates and modify the built aggregates. </span><span class="koboSpan" id="kobo.254.2">Aggregates either represent already-existing entities or newly created ones. </span><span class="koboSpan" id="kobo.254.3">Handlers use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.256.1"> interface contained in each </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">IRepository</span></code><span class="koboSpan" id="kobo.258.1">, as well as the concurrency exceptions returned by the data layer, to organize their operations as transactions. </span><span class="koboSpan" id="kobo.258.2">It is worth pointing out that each aggregate has its own </span><code class="inlineCode"><span class="koboSpan" id="kobo.259.1">IRepository</span></code><span class="koboSpan" id="kobo.260.1"> and that the whole logic for updating each aggregate is defined in the aggregate itself, not in its associated </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">IRepository</span></code><span class="koboSpan" id="kobo.262.1">, to keep the code more modular.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.263.1">Behind the scenes, in the data layer, </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">IRepository</span></code><span class="koboSpan" id="kobo.265.1"> implementations use Entity Framework to perform their job. </span><span class="koboSpan" id="kobo.265.2">Aggregates are implemented by root data entities hidden behind interfaces defined in the domain layer, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.267.1"> methods, which handle transactions and pass changes to the database, are implemented with </span><code class="inlineCode"><span class="koboSpan" id="kobo.268.1">DbContext</span></code><span class="koboSpan" id="kobo.269.1"> methods. </span><span class="koboSpan" id="kobo.269.2">In other words, </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.271.1"> is implemented with the application’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">DbContext</span></code><span class="koboSpan" id="kobo.273.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.274.1">Domain events are generated during each aggregate processing and are added to the aggregates themselves by calling their </span><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">AddDomainEvent</span></code><span class="koboSpan" id="kobo.276.1"> methods. </span><span class="koboSpan" id="kobo.276.2">However, they are not triggered immediately. </span><span class="koboSpan" id="kobo.276.3">Usually, they are triggered at the end of all the aggregates’ processing and before changes are passed </span><a id="_idIndexMarker1293"/><span class="koboSpan" id="kobo.277.1">to the database; however, this is not a general rule.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.278.1">The application handles errors by throwing exceptions. </span><span class="koboSpan" id="kobo.278.2">A more efficient approach would be to define a request-scoped object in the dependency engine, where each application subpart may add its errors as domain events. </span><span class="koboSpan" id="kobo.278.3">However, while this approach is more efficient, it increases the complexity of the code and the application development time.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.279.1">The Visual Studio solution is composed of three projects:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.280.1">There’s a project containing the domain layer abstraction, which is a .NET Standard 2.1 library. </span><span class="koboSpan" id="kobo.280.2">When a library doesn’t use features or NuGet packages that are specific to a .NET version, it is a good practice to implement it as a .NET Standard library because this way, it doesn’t need modifications when the application is moved to a newer .NET version.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.281.1">There’s a project containing the whole data layer, which is a .NET 8.0 library based on Entity Framework.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.282.1">Finally, there’s an ASP.NET Core MVC 8.0 project that contains both the application and presentation layers. </span><span class="koboSpan" id="kobo.282.2">When you define this project, select </span><strong class="keyWord"><span class="koboSpan" id="kobo.283.1">No Authentication</span></strong><span class="koboSpan" id="kobo.284.1">; otherwise, the user database will be added directly to the ASP.NET Core MVC project instead of to the database layer. </span><span class="koboSpan" id="kobo.284.2">We will add the user database manually in the data layer.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.285.1">In the remaining sections, we will describe the implementation of each layer that composes the architecture described so far, starting with domain layer abstraction.</span></p>
<h1 class="heading-1" id="_idParaDest-369"><span class="koboSpan" id="kobo.286.1">Defining the domain layer interface</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.287.1">Once the </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">PackagesManagementDomain</span></code><span class="koboSpan" id="kobo.289.1"> Standard 2.1 library project has been added to the solution, we’ll add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">Tools</span></code><span class="koboSpan" id="kobo.291.1"> folder to the project root. </span><span class="koboSpan" id="kobo.291.2">Then, we’ll place all the </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">DomainLayer</span></code><span class="koboSpan" id="kobo.293.1"> tools contained in the code associated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">ch7</span></code><span class="koboSpan" id="kobo.295.1">. </span><span class="koboSpan" id="kobo.295.2">Since the </span><a id="_idIndexMarker1294"/><span class="koboSpan" id="kobo.296.1">code contained in this folder uses data annotations and defines DI extension methods, we must also add references to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">System.ComponentModel.Annotations</span></code><span class="koboSpan" id="kobo.298.1"> and</span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1"> Microsoft.Extensions.DependencyInjection.Abstration</span></code><span class="koboSpan" id="kobo.300.1"> NuGet packages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.301.1">Then, we need an </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">Aggregates</span></code><span class="koboSpan" id="kobo.303.1"> folder containing all the aggregate definitions (which, as already said, we will implement as interfaces).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.304.1">Below is an example of an aggregate definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.305.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.306.1">interface</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.307.1">IPackage</span></span><span class="koboSpan" id="kobo.308.1"> : </span><span class="hljs-title"><span class="koboSpan" id="kobo.309.1">IEntity</span></span><span class="koboSpan" id="kobo.310.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.311.1">int</span></span><span class="koboSpan" id="kobo.312.1">&gt;
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.313.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.314.1">FullUpdate</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.315.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.316.1">IPackageFullEditDTO packageDTO</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.317.1">)</span></span><span class="koboSpan" id="kobo.318.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.319.1">string</span></span><span class="koboSpan" id="kobo.320.1"> Name { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.321.1">get</span></span><span class="koboSpan" id="kobo.322.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.323.1">set</span></span><span class="koboSpan" id="kobo.324.1">; }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.325.1">string</span></span><span class="koboSpan" id="kobo.326.1"> Description { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.327.1">get</span></span><span class="koboSpan" id="kobo.328.1">;}
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.329.1">decimal</span></span><span class="koboSpan" id="kobo.330.1"> Price { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.331.1">get</span></span><span class="koboSpan" id="kobo.332.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.333.1">set</span></span><span class="koboSpan" id="kobo.334.1">; }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.335.1">int</span></span><span class="koboSpan" id="kobo.336.1"> DurationInDays { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.337.1">get</span></span><span class="koboSpan" id="kobo.338.1">; }
    DateTime? </span><span class="koboSpan" id="kobo.338.2">StartValidityDate { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.339.1">get</span></span><span class="koboSpan" id="kobo.340.1">;}
    DateTime? </span><span class="koboSpan" id="kobo.340.2">EndValidityDate { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.341.1">get</span></span><span class="koboSpan" id="kobo.342.1">; }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.343.1">int</span></span><span class="koboSpan" id="kobo.344.1"> DestinationId { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.345.1">get</span></span><span class="koboSpan" id="kobo.346.1">; }
       
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.347.1">It contains the </span><a id="_idIndexMarker1295"/><span class="koboSpan" id="kobo.348.1">same properties as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">Package</span></code><span class="koboSpan" id="kobo.350.1"> entity, which we saw in </span><em class="italic"><span class="koboSpan" id="kobo.351.1">Chapter 13</span></em><span class="koboSpan" id="kobo.352.1">, </span><em class="italic"><span class="koboSpan" id="kobo.353.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.354.1">. </span><span class="koboSpan" id="kobo.354.2">The only differences are the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.355.1">It inherits from </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">IEntity&lt;int&gt;</span></code><span class="koboSpan" id="kobo.357.1">, which furnishes all basic functionalities of aggregates</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.358.1">It has no </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">Id</span></code><span class="koboSpan" id="kobo.360.1"> property since it is inherited from </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">IEntity&lt;int&gt;</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.362.1">All properties are read-only, and it has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">FullUpdate</span></code><span class="koboSpan" id="kobo.364.1"> method since all aggregates can only be modified through update operations defined in the user domain (in our case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">FullUpdate</span></code><span class="koboSpan" id="kobo.366.1"> method)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.367.1">Now, let’s also add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">DTOs</span></code><span class="koboSpan" id="kobo.369.1"> folder. </span><span class="koboSpan" id="kobo.369.2">Here, we place all interfaces used to pass updates to the aggregates. </span><span class="koboSpan" id="kobo.369.3">Such interfaces are implemented by the application layer ViewModels used to define such updates. </span><span class="koboSpan" id="kobo.369.4">In our case, it contains </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">IPackageFullEditDTO</span></code><span class="koboSpan" id="kobo.371.1">, which we can use to update existing packages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.372.1">An </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">IRepositories</span></code><span class="koboSpan" id="kobo.374.1"> folder contains all repository specifications; the following is an example repository interface:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.375.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.376.1">interface</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.377.1">IPackageRepository</span></span><span class="koboSpan" id="kobo.378.1">:
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.379.1">IRepository</span></span><span class="koboSpan" id="kobo.380.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.381.1">IPackage</span></span><span class="koboSpan" id="kobo.382.1">&gt;
{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.383.1">Task&lt;IPackage&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.384.1">Get</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.385.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.386.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.387.1"> id</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.388.1">)</span></span><span class="koboSpan" id="kobo.389.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.390.1">IPackage </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.391.1">New</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.392.1">()</span></span><span class="koboSpan" id="kobo.393.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.394.1">Task&lt;IPackage&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.395.1">Delete</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.396.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.397.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.398.1"> id</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.399.1">)</span></span><span class="koboSpan" id="kobo.400.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.401.1">Repositories always contain just a few methods since all business logic should be represented as aggregate methods – in our case, just the methods to create a new package, retrieve an existing package, and delete an existing package. </span><span class="koboSpan" id="kobo.401.2">The logic to modify an existing package is included in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">FullUpdate</span></code><span class="koboSpan" id="kobo.403.1"> method of </span><code class="inlineCode"><span class="koboSpan" id="kobo.404.1">IPackage</span></code><span class="koboSpan" id="kobo.405.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.406.1">Finally, we also have an event folder containing all domain event definitions. </span><span class="koboSpan" id="kobo.406.2">We can name this folder </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">Events</span></code><span class="koboSpan" id="kobo.408.1">. </span><span class="koboSpan" id="kobo.408.2">Events are triggered whenever a change to an aggregate has consequences either on other aggregates or on other microservices. </span><span class="koboSpan" id="kobo.408.3">They are a way to implement weak interactions between aggregates and microservices while keeping the code of aggregates independent of each other.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.409.1">By using events, we may keep the code of each aggregate substantially independent of the code of other aggregates that are involved in the same database transactions: each aggregate generates events that might interest other aggregates, such as a price change in a touristic package aggregate, and all other aggregates that depend on this price subscribe to that event, so they can update their data coherently. </span><span class="koboSpan" id="kobo.409.2">This way, when a new aggregate that depends on the tourist package price is added during system maintenance, we don’t need to modify the tourist package aggregate.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.410.1">When the event might also interest other microservices, the event is also passed to a message broker, which makes </span><a id="_idIndexMarker1296"/><span class="koboSpan" id="kobo.411.1">the event also available for subscription to code in other microservices. </span><span class="koboSpan" id="kobo.411.2">Message brokers were discussed in </span><em class="italic"><span class="koboSpan" id="kobo.412.1">Chapter 14</span></em><span class="koboSpan" id="kobo.413.1">, </span><em class="italic"><span class="koboSpan" id="kobo.414.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.415.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.416.1">Below is an example event definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.417.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.418.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.419.1">PackagePriceChangedEvent</span></span><span class="koboSpan" id="kobo.420.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.421.1">IEventNotification</span></span><span class="koboSpan" id="kobo.422.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.423.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.424.1">PackagePriceChangedEvent</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.425.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.426.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.427.1"> id, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.428.1">decimal</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.429.1"> price,</span></span>
<span class="hljs-params"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.430.1">long</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.431.1"> oldVersion, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.432.1">long</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.433.1"> newVersion</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.434.1">)</span></span><span class="koboSpan" id="kobo.435.1">
    {
            PackageId = id;
            NewPrice = price;
            OldVersion = oldVersion;
            NewVersion = newVersion;
     }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.436.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.437.1">int</span></span><span class="koboSpan" id="kobo.438.1"> PackageId { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.439.1">get</span></span><span class="koboSpan" id="kobo.440.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.441.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.442.1">decimal</span></span><span class="koboSpan" id="kobo.443.1"> NewPrice { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.444.1">get</span></span><span class="koboSpan" id="kobo.445.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.446.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.447.1">long</span></span><span class="koboSpan" id="kobo.448.1"> OldVersion { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.449.1">get</span></span><span class="koboSpan" id="kobo.450.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.451.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.452.1">long</span></span><span class="koboSpan" id="kobo.453.1"> NewVersion { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.454.1">get</span></span><span class="koboSpan" id="kobo.455.1">; }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.456.1">When an aggregate sends all its changes to another microservice, it should have a version property. </span><span class="koboSpan" id="kobo.456.2">The microservice that receives the changes uses this version property to apply all changes in the right order. </span><span class="koboSpan" id="kobo.456.3">An explicit version number is necessary because changes are sent asynchronously, so the order in which they are received may differ from the order in which they were sent. </span><span class="koboSpan" id="kobo.456.4">For this purpose, events that are used to publish changes outside of the application have both </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">OldVersion</span></code><span class="koboSpan" id="kobo.458.1"> (the version before the change) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">NewVersion</span></code><span class="koboSpan" id="kobo.460.1"> (the version after the change) properties. </span><span class="koboSpan" id="kobo.460.2">Events associated with delete events have no </span><code class="inlineCode"><span class="koboSpan" id="kobo.461.1">NewVersion</span></code><span class="koboSpan" id="kobo.462.1"> since, after being deleted, an entity can’t store any versions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.463.1">The next subsection explains how all interfaces defined in the domain layer are implemented in the data layer.</span></p>
<h1 class="heading-1" id="_idParaDest-370"><span class="koboSpan" id="kobo.464.1">Defining the domain layer implementation</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.465.1">The domain layer implementation contains the implementation of all repository interfaces and aggregate </span><a id="_idIndexMarker1297"/><span class="koboSpan" id="kobo.466.1">interfaces defined in the domain layer interface. </span><span class="koboSpan" id="kobo.466.2">In the case of .NET 8, it uses Entity Framework Core entities to implement aggregates. </span><span class="koboSpan" id="kobo.466.3">Adding a domain layer interface in between the domain layer’s actual implementation and the application layer decouples the application layer from EF and entity-specific details. </span><span class="koboSpan" id="kobo.466.4">Moreover, it conforms with the onion architecture, which, in turn, is an advised way to architect microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.467.1">The domain layer implementation project should contain references to </span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">Microsoft.AspNetCore.Identity.EntityFrameworkCore</span></code><span class="koboSpan" id="kobo.469.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.470.1">Microsoft.EntityFrameworkCore.SqlServer</span></code><span class="koboSpan" id="kobo.471.1"> NuGet packages, since we are using Entity Framework Core with SQL Server. </span><span class="koboSpan" id="kobo.471.2">It references </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">Microsoft.EntityFrameworkCore.Tools</span></code><span class="koboSpan" id="kobo.473.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">Microsoft.EntityFrameworkCore.Design</span></code><span class="koboSpan" id="kobo.475.1">, which is needed to generate database migrations, as explained in the </span><em class="italic"><span class="koboSpan" id="kobo.476.1">Entity Framework Core migrations</span></em><span class="koboSpan" id="kobo.477.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.478.1">Chapter 13</span></em><span class="koboSpan" id="kobo.479.1">, </span><em class="italic"><span class="koboSpan" id="kobo.480.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.481.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.482.1">We should have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">Models</span></code><span class="koboSpan" id="kobo.484.1"> folder that contains all database entities. </span><span class="koboSpan" id="kobo.484.2">They are similar to the ones in </span><em class="italic"><span class="koboSpan" id="kobo.485.1">Chapter 13</span></em><span class="koboSpan" id="kobo.486.1">. </span><span class="koboSpan" id="kobo.486.2">The only differences are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.487.1">They inherit from </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">Entity&lt;T&gt;</span></code><span class="koboSpan" id="kobo.489.1">, which contains all the basic features of aggregates. </span><span class="koboSpan" id="kobo.489.2">Please note that inheriting from </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">Entity&lt;T&gt;</span></code><span class="koboSpan" id="kobo.491.1"> is only needed for aggregate roots; all other entities must be defined as explained in </span><em class="italic"><span class="koboSpan" id="kobo.492.1">Chapter 13</span></em><span class="koboSpan" id="kobo.493.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.494.1">They have no </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">Id</span></code><span class="koboSpan" id="kobo.496.1"> since it is inherited from </span><code class="inlineCode"><span class="koboSpan" id="kobo.497.1">Entity&lt;T&gt;</span></code><span class="koboSpan" id="kobo.498.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.499.1">Some of them might have an </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">EntityVersion</span></code><span class="koboSpan" id="kobo.501.1"> property decorated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">[ConcurrencyCheck]</span></code><span class="koboSpan" id="kobo.503.1"> attribute. </span><span class="koboSpan" id="kobo.503.2">It contains the entity version that is needed to send changes to other microservices. </span><span class="koboSpan" id="kobo.503.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">ConcurrencyCheck</span></code><span class="koboSpan" id="kobo.505.1"> attribute is needed to prevent concurrency errors while updating the entity version. </span><span class="koboSpan" id="kobo.505.2">This prevents suffering the performance penalty implied by a transaction.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.506.1">More specifically, when saving entity changes, if the value of a field marked with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">ConcurrencyCheck</span></code><span class="koboSpan" id="kobo.508.1"> attribute is </span><a id="_idIndexMarker1298"/><span class="koboSpan" id="kobo.509.1">different from the one that was read when the entity was loaded in memory, a concurrency exception is thrown to inform the calling method that someone else modified this value after the entity was read, but before we attempted to save its changes. </span><span class="koboSpan" id="kobo.509.2">This way, the calling method can repeat the whole operation with the hope that this time, no one will write the same entity in the database during its execution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.510.1">It is worth analyzing an example entity:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.511.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.512.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.513.1">Package</span></span><span class="koboSpan" id="kobo.514.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.515.1">Entity</span></span><span class="koboSpan" id="kobo.516.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.517.1">int</span></span><span class="koboSpan" id="kobo.518.1">&gt;, </span><span class="hljs-title"><span class="koboSpan" id="kobo.519.1">IPackage</span></span><span class="koboSpan" id="kobo.520.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.521.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.522.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.523.1">FullUpdate</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.524.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.525.1">IPackageFullEditDTO o</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.526.1">)</span></span><span class="koboSpan" id="kobo.527.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.528.1">if</span></span><span class="koboSpan" id="kobo.529.1"> (IsTransient())
        {
            Id = o.Id;
            DestinationId = o.DestinationId;
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.530.1">else</span></span><span class="koboSpan" id="kobo.531.1">
        {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.532.1">if</span></span><span class="koboSpan" id="kobo.533.1"> (o.Price != </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.534.1">this</span></span><span class="koboSpan" id="kobo.535.1">.Price)
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.536.1">this</span></span><span class="koboSpan" id="kobo.537.1">.AddDomainEvent(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.538.1">new</span></span><span class="koboSpan" id="kobo.539.1"> PackagePriceChangedEvent(
                        Id, o.Price, EntityVersion, EntityVersion+</span><span class="hljs-number"><span class="koboSpan" id="kobo.540.1">1</span></span><span class="koboSpan" id="kobo.541.1">));
        }
        Name = o.Name;
        Description = o.Description;
        Price = o.Price;
        DurationInDays = o.DurationInDays;
        StartValidityDate = o.StartValidityDate;
        EndValidityDate = o.EndValidityDate;
    }
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.542.1">MaxLength(128)</span></span><span class="koboSpan" id="kobo.543.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.544.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.545.1">string</span></span><span class="koboSpan" id="kobo.546.1"> Name { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.547.1">get</span></span><span class="koboSpan" id="kobo.548.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.549.1">set</span></span><span class="koboSpan" id="kobo.550.1">; }
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.551.1">MaxLength(128)</span></span><span class="koboSpan" id="kobo.552.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.553.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.554.1">string</span></span><span class="koboSpan" id="kobo.555.1">? </span><span class="koboSpan" id="kobo.555.2">Description { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.556.1">get</span></span><span class="koboSpan" id="kobo.557.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.558.1">set</span></span><span class="koboSpan" id="kobo.559.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.560.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.561.1">decimal</span></span><span class="koboSpan" id="kobo.562.1"> Price { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.563.1">get</span></span><span class="koboSpan" id="kobo.564.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.565.1">set</span></span><span class="koboSpan" id="kobo.566.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.567.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.568.1">int</span></span><span class="koboSpan" id="kobo.569.1"> DurationInDays { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.570.1">get</span></span><span class="koboSpan" id="kobo.571.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.572.1">set</span></span><span class="koboSpan" id="kobo.573.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.574.1">public</span></span><span class="koboSpan" id="kobo.575.1"> DateTime? </span><span class="koboSpan" id="kobo.575.2">StartValidityDate { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.576.1">get</span></span><span class="koboSpan" id="kobo.577.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.578.1">set</span></span><span class="koboSpan" id="kobo.579.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.580.1">public</span></span><span class="koboSpan" id="kobo.581.1"> DateTime? </span><span class="koboSpan" id="kobo.581.2">EndValidityDate { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.582.1">get</span></span><span class="koboSpan" id="kobo.583.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.584.1">set</span></span><span class="koboSpan" id="kobo.585.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.586.1">public</span></span><span class="koboSpan" id="kobo.587.1"> Destination MyDestination { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">get</span></span><span class="koboSpan" id="kobo.589.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.590.1">set</span></span><span class="koboSpan" id="kobo.591.1">; }
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.592.1">ConcurrencyCheck</span></span><span class="koboSpan" id="kobo.593.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.594.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.595.1">long</span></span><span class="koboSpan" id="kobo.596.1"> EntityVersion{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.597.1">get</span></span><span class="koboSpan" id="kobo.598.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.599.1">set</span></span><span class="koboSpan" id="kobo.600.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.601.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.602.1">int</span></span><span class="koboSpan" id="kobo.603.1"> DestinationId { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.604.1">get</span></span><span class="koboSpan" id="kobo.605.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.606.1">set</span></span><span class="koboSpan" id="kobo.607.1">; }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.608.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.609.1">FullUpdate</span></code><span class="koboSpan" id="kobo.610.1"> method is </span><a id="_idIndexMarker1299"/><span class="koboSpan" id="kobo.611.1">the only way to update the </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">IPackage</span></code><span class="koboSpan" id="kobo.613.1"> aggregate. </span><span class="koboSpan" id="kobo.613.2">When the price changes, it adds a </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">PackagePriceChangedEvent</span></code><span class="koboSpan" id="kobo.615.1"> to the entity list of events.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">MainDBContext</span></code><span class="koboSpan" id="kobo.617.1"> implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.618.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.619.1">. </span><span class="koboSpan" id="kobo.619.2">The following code shows the implementation of all methods that start, rollback, and commit a transaction:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.620.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.621.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.622.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.623.1">StartAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.624.1">()</span></span><span class="koboSpan" id="kobo.625.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.626.1">await</span></span><span class="koboSpan" id="kobo.627.1"> Database.BeginTransactionAsync();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.628.1">public</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.629.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.630.1">CommitAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.631.1">()</span></span><span class="koboSpan" id="kobo.632.1">
{
    Database.CommitTransaction();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.633.1">return</span></span><span class="koboSpan" id="kobo.634.1"> Task.CompletedTask;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.635.1">public</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.636.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.637.1">RollbackAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.638.1">()</span></span><span class="koboSpan" id="kobo.639.1">
{
    Database.RollbackTransaction();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.640.1">return</span></span><span class="koboSpan" id="kobo.641.1"> Task.CompletedTask;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.642.1">However, they are rarely used by command classes in a distributed environment. </span><span class="koboSpan" id="kobo.642.2">In fact, like distributed transactions, local database-blocking transactions are also avoided because they might block database resources for too much time, which is incompatible with the maximization of traffic typical of microservices-based applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.643.1">Likely, as already mentioned, all databases support tagging some row fields as </span><strong class="keyWord"><span class="koboSpan" id="kobo.644.1">concurrency checks</span></strong><span class="koboSpan" id="kobo.645.1">. </span><span class="koboSpan" id="kobo.645.2">In Entity Framework Core, this is done by decorating the entity property corresponding to the field with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">ConcurrencyCheck</span></code><span class="koboSpan" id="kobo.647.1"> attribute.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.648.1">Concurrency checks detect interferences of another transaction, B, on a record while performing transaction A. </span><span class="koboSpan" id="kobo.648.2">This way, we can perform transaction A without blocking any database record or table, and if we detect interference, we abort transaction A and retry it till it succeeds without interference. </span><span class="koboSpan" id="kobo.648.3">This technique works well if transactions are very quick and, consequently, interferences are rare.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.649.1">More specifically, if during transaction A, the value of the concurrency checks specified by an update operation differs from the one stored in the record being updated, the update is aborted, and a concurrency exception is thrown. </span><span class="koboSpan" id="kobo.649.2">The rationale is that another transaction, B, modified the concurrency check, thus interfering with the operation being performed by A.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.650.1">Accordingly, the method </span><a id="_idIndexMarker1300"/><span class="koboSpan" id="kobo.651.1">that passes all changes applied to </span><code class="inlineCode"><span class="koboSpan" id="kobo.652.1">DbContext</span></code><span class="koboSpan" id="kobo.653.1"> to the database performs a check for concurrency exceptions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.654.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.655.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.656.1"> Task&lt;</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.657.1">bool</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.658.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.659.1">SaveEntitiesAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.660.1">()</span></span><span class="koboSpan" id="kobo.661.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.662.1">try</span></span><span class="koboSpan" id="kobo.663.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.664.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.665.1">await</span></span><span class="koboSpan" id="kobo.666.1"> SaveChangesAsync() &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.667.1">0</span></span><span class="koboSpan" id="kobo.668.1">;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.669.1">catch</span></span><span class="koboSpan" id="kobo.670.1"> (DbUpdateConcurrencyException ex)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.671.1">foreach</span></span><span class="koboSpan" id="kobo.672.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.673.1">var</span></span><span class="koboSpan" id="kobo.674.1"> entry </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.675.1">in</span></span><span class="koboSpan" id="kobo.676.1"> ex.Entries)
        {
            entry.State = EntityState.Detached;
                        
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.677.1">throw</span></span><span class="koboSpan" id="kobo.678.1">;
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.679.1">The preceding implementation just calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">SaveChangesAsync DbContext</span></code><span class="koboSpan" id="kobo.681.1"> context method, which saves all changes to the database, but then it intercepts all concurrency exceptions and detaches all the entities involved in the concurrency error from the context. </span><span class="koboSpan" id="kobo.681.2">This way, the next time a command retries the whole failed operation, their updated versions will be reloaded from the database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.682.1">In other words, when the update fails because of the interference of transaction B, we allow the interfering transaction B to complete its process. </span><span class="koboSpan" id="kobo.682.2">Then, EF automatically reloads all entities modified by B that contain the value of the concurrency check modified by B. </span><span class="koboSpan" id="kobo.682.3">This way, when the operation is retried, if no other transaction interferes, there will be no conflict on the concurrency check.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.683.1">The practical usage of concurrency checks is detailed in the </span><em class="italic"><span class="koboSpan" id="kobo.684.1">A frontend microservice </span></em><span class="koboSpan" id="kobo.685.1">example of</span><em class="italic"><span class="koboSpan" id="kobo.686.1"> Chapter 21</span></em><span class="koboSpan" id="kobo.687.1">, </span><em class="italic"><span class="koboSpan" id="kobo.688.1">Case Study</span></em><span class="koboSpan" id="kobo.689.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.690.1">All repository implementations are defined in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.691.1">Repositories</span></code><span class="koboSpan" id="kobo.692.1"> folder to ensure better maintainability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.693.1">Finally, all repositories are automatically discovered and added to the application DI engine, calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">AddAllRepositories</span></code><span class="koboSpan" id="kobo.695.1"> method, which is defined in the DDD tools we added to the domain layer project. </span><span class="koboSpan" id="kobo.695.2">More details on how to ensure this method is called when the application starts are given in the example detailed description in the </span><em class="italic"><span class="koboSpan" id="kobo.696.1">A frontend microservice</span></em><span class="koboSpan" id="kobo.697.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.698.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.699.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-371"><span class="koboSpan" id="kobo.700.1">Defining the application layer</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.701.1">The application </span><a id="_idIndexMarker1301"/><span class="koboSpan" id="kobo.702.1">layer contains the definition of all business operations. </span><span class="koboSpan" id="kobo.702.2">These business operations use data provided by the user to modify domain layer abstraction aggregates, such as touristic packages. </span><span class="koboSpan" id="kobo.702.3">When all business operations involved in the current user request have been performed, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">IUnitOfWork.SaveEntitiesAsync()</span></code><span class="koboSpan" id="kobo.704.1"> operation is performed to save all changes to the database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.705.1">As a first step, for simplicity, let’s freeze the application culture to </span><code class="inlineCode"><span class="koboSpan" id="kobo.706.1">en-US</span></code><span class="koboSpan" id="kobo.707.1"> by adding the following code to the ASP.NET Core pipeline:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.708.1">app.UseAuthorization();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.709.1">// Code to add: configure the Localization middleware</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.710.1">var</span></span><span class="koboSpan" id="kobo.711.1"> ci = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.712.1">new</span></span><span class="koboSpan" id="kobo.713.1"> CultureInfo(</span><span class="hljs-string"><span class="koboSpan" id="kobo.714.1">"en-US"</span></span><span class="koboSpan" id="kobo.715.1">);
app.UseRequestLocalization(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.716.1">new</span></span><span class="koboSpan" id="kobo.717.1"> RequestLocalizationOptions
{
    DefaultRequestCulture = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.718.1">new</span></span><span class="koboSpan" id="kobo.719.1"> RequestCulture(ci),
    SupportedCultures = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.720.1">new</span></span><span class="koboSpan" id="kobo.721.1"> List&lt;CultureInfo&gt;
    {
        ci,
    },
     SupportedUICultures = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.722.1">new</span></span><span class="koboSpan" id="kobo.723.1"> List&lt;CultureInfo&gt;
    {
        ci,
    }
});
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.724.1">As a second step, we can create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">Tools</span></code><span class="koboSpan" id="kobo.726.1"> folder to place the </span><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">ApplicationLayer</span></code><span class="koboSpan" id="kobo.728.1"> code, which you can find in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">ch7</span></code><span class="koboSpan" id="kobo.730.1"> code of </span><a id="_idIndexMarker1302"/><span class="koboSpan" id="kobo.731.1">the GitHub repository associated with this book. </span><span class="koboSpan" id="kobo.731.2">With these tools in place, in </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">Program.cs</span></code><span class="koboSpan" id="kobo.733.1">, we can add the code that automatically discovers and adds all queries, command handlers, and event handlers to the DI engine, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.734.1">...
</span><span class="koboSpan" id="kobo.734.2">...
</span><span class="koboSpan" id="kobo.734.3">builder.Services.AddAllQueries(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.735.1">this</span></span><span class="koboSpan" id="kobo.736.1">.GetType().Assembly);
builder.Services.AddAllCommandHandlers(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">this</span></span><span class="koboSpan" id="kobo.738.1">.GetType().Assembly);
builder.Services.AddAllEventHandlers(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.739.1">this</span></span><span class="koboSpan" id="kobo.740.1">.GetType().Assembly);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.741.1">Then, we must add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">Queries</span></code><span class="koboSpan" id="kobo.743.1"> folder to place all queries and their associated interfaces. </span><span class="koboSpan" id="kobo.743.2">As an example, let’s have a look at the query that lists all packages:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.744.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.745.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.746.1">PackagesListQuery</span></span><span class="koboSpan" id="kobo.747.1">:</span><span class="hljs-title"><span class="koboSpan" id="kobo.748.1">IPackagesListQuery</span></span><span class="koboSpan" id="kobo.749.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.750.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.751.1">readonly</span></span><span class="koboSpan" id="kobo.752.1"> MainDbContext ctx;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.753.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.754.1">PackagesListQuery</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.755.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.756.1">MainDbContext ctx</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.757.1">)</span></span><span class="koboSpan" id="kobo.758.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.759.1">this</span></span><span class="koboSpan" id="kobo.760.1">.ctx = ctx;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.761.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.762.1">async</span></span><span class="koboSpan" id="kobo.763.1"> Task&lt;IReadOnlyCollection&lt;PackageInfosViewModel&gt;&gt; GetAllPackages()
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.764.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.765.1">await</span></span><span class="koboSpan" id="kobo.766.1"> ctx.Packages.Select(m =&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.767.1">new</span></span><span class="koboSpan" id="kobo.768.1"> PackageInfosViewModel
        {
            StartValidityDate = m.StartValidityDate,
            ...
        </span><span class="koboSpan" id="kobo.768.2">})
            .OrderByDescending(m=&gt; m.EndValidityDate)
            .ToListAsync();
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.769.1">The query object is automatically injected into the application DB context. </span><span class="koboSpan" id="kobo.769.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">GetAllPackages</span></code><span class="koboSpan" id="kobo.771.1"> method uses LINQ to project all of the required information into </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">PackageInfosViewModel</span></code><span class="koboSpan" id="kobo.773.1"> and sorts all results in descending order on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">EndValidityDate</span></code><span class="koboSpan" id="kobo.775.1"> property.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.776.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.777.1">Commands</span></code><span class="koboSpan" id="kobo.778.1"> folder contains all commands. </span><span class="koboSpan" id="kobo.778.2">As an example, let’s have a look at the command used to modify packages:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.779.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.780.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.781.1">UpdatePackageCommand</span></span><span class="koboSpan" id="kobo.782.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.783.1">ICommand</span></span><span class="koboSpan" id="kobo.784.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.785.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.786.1">UpdatePackageCommand</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.787.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.788.1">IPackageFullEditDTO updates</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.789.1">)</span></span><span class="koboSpan" id="kobo.790.1">
    {
        Updates = updates;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.791.1">public</span></span><span class="koboSpan" id="kobo.792.1"> IPackageFullEditDTO Updates { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.793.1">get</span></span><span class="koboSpan" id="kobo.794.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.795.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.796.1">set</span></span><span class="koboSpan" id="kobo.797.1">; }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.798.1">Command handlers </span><a id="_idIndexMarker1303"/><span class="koboSpan" id="kobo.799.1">can be placed in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.800.1">Handlers</span></code><span class="koboSpan" id="kobo.801.1"> folder. </span><span class="koboSpan" id="kobo.801.2">It is worth analyzing the command that updates packages:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.802.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.803.1">readonly</span></span><span class="koboSpan" id="kobo.804.1"> IPackageRepository repo;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.805.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.806.1">readonly</span></span><span class="koboSpan" id="kobo.807.1"> IEventMediator mediator;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.808.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.809.1">UpdatePackageCommandHandler</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.810.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.811.1">IPackageRepository repo, IEventMediator mediator</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.812.1">)</span></span><span class="koboSpan" id="kobo.813.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.814.1">this</span></span><span class="koboSpan" id="kobo.815.1">.repo = repo;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.816.1">this</span></span><span class="koboSpan" id="kobo.817.1">.mediator = mediator;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.818.1">Its constructor has automatically injected the </span><code class="inlineCode"><span class="koboSpan" id="kobo.819.1">IPackageRepository</span></code><span class="koboSpan" id="kobo.820.1"> repository and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.821.1">IEventMediator</span></code><span class="koboSpan" id="kobo.822.1"> instance needed to trigger event handlers. </span><span class="koboSpan" id="kobo.822.2">The following code also shows the implementation of the standard </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">HandleAsync</span></code><span class="koboSpan" id="kobo.824.1"> command handler method:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.825.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.826.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.827.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.828.1">HandleAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.829.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.830.1">UpdatePackageCommand command</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.831.1">)</span></span><span class="koboSpan" id="kobo.832.1">
{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.833.1">bool</span></span><span class="koboSpan" id="kobo.834.1"> done = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.835.1">false</span></span><span class="koboSpan" id="kobo.836.1">;
    IPackage model;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.837.1">while</span></span><span class="koboSpan" id="kobo.838.1"> (!done)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.839.1">try</span></span><span class="koboSpan" id="kobo.840.1">
        {
            model = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.841.1">await</span></span><span class="koboSpan" id="kobo.842.1"> repo.Get(command.Updates.Id);
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.843.1">if</span></span><span class="koboSpan" id="kobo.844.1"> (model == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.845.1">null</span></span><span class="koboSpan" id="kobo.846.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.847.1">return</span></span><span class="koboSpan" id="kobo.848.1">;
            model.FullUpdate(command.Updates);
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.849.1">await</span></span><span class="koboSpan" id="kobo.850.1"> mediator.TriggerEvents(model.DomainEvents);
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.851.1">await</span></span><span class="koboSpan" id="kobo.852.1"> repo.UnitOfWork.SaveEntitiesAsync();
            done = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.853.1">true</span></span><span class="koboSpan" id="kobo.854.1">;
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.855.1">catch</span></span><span class="koboSpan" id="kobo.856.1"> (DbUpdateConcurrencyException)
        {
          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.857.1">// add some logging here</span></span><span class="koboSpan" id="kobo.858.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.859.1">Command operations are repeated until no concurrency exception is returned. </span><code class="inlineCode"><span class="koboSpan" id="kobo.860.1">HandleAsync</span></code><span class="koboSpan" id="kobo.861.1"> uses the repository to get an instance of the entity to modify. </span><span class="koboSpan" id="kobo.861.2">If the entity is not found (it has been deleted), the commands stop its execution. </span><span class="koboSpan" id="kobo.861.3">Otherwise, all changes are passed to the retrieved aggregate. </span><span class="koboSpan" id="kobo.861.4">Immediately after the update, all events contained in the aggregate are triggered. </span><span class="koboSpan" id="kobo.861.5">In particular, if the price has changed, the event handler associated with the price change is executed. </span><span class="koboSpan" id="kobo.861.6">The concurrency check declared with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.862.1">[ConcurrencyCheck]</span></code><span class="koboSpan" id="kobo.863.1"> attribute on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.864.1">EntityVersion</span></code><span class="koboSpan" id="kobo.865.1"> property of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">Package</span></code><span class="koboSpan" id="kobo.867.1"> entity ensures </span><a id="_idIndexMarker1304"/><span class="koboSpan" id="kobo.868.1">that the package version is updated properly (by incrementing its previous version number by 1), as well as that the price-changed event is passed the right version numbers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.869.1">Also, event handlers are placed in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.870.1">Handlers</span></code><span class="koboSpan" id="kobo.871.1"> folder. </span><span class="koboSpan" id="kobo.871.2">As an example, let’s have a look at the price-changed event handler:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.872.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.873.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.874.1">PackagePriceChangedEventHandler</span></span><span class="koboSpan" id="kobo.875.1"> :
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.876.1">IEventHandler</span></span><span class="koboSpan" id="kobo.877.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.878.1">PackagePriceChangedEvent</span></span><span class="koboSpan" id="kobo.879.1">&gt;
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.880.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.881.1">readonly</span></span><span class="koboSpan" id="kobo.882.1"> IPackageEventRepository repo;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.883.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.884.1">PackagePriceChangedEventHandler</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.885.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.886.1">IPackageEventRepository repo</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.887.1">)</span></span><span class="koboSpan" id="kobo.888.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.889.1">this</span></span><span class="koboSpan" id="kobo.890.1">.repo = repo;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.891.1">public</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.892.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.893.1">HandleAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.894.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.895.1">PackagePriceChangedEvent ev</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.896.1">)</span></span><span class="koboSpan" id="kobo.897.1">
    {
        repo.New(PackageEventType.CostChanged, ev.PackageId,
            ev.OldVersion, ev.NewVersion, ev.NewPrice);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.898.1">return</span></span><span class="koboSpan" id="kobo.899.1"> Task.CompletedTask;
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.900.1">The constructor has automatically injected the </span><code class="inlineCode"><span class="koboSpan" id="kobo.901.1">IPackageEventRepository</span></code><span class="koboSpan" id="kobo.902.1"> repository, which handles the database table and all the events to send to other applications. </span><span class="koboSpan" id="kobo.902.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.903.1">HandleAsync</span></code><span class="koboSpan" id="kobo.904.1"> implementation simply calls the repository method that adds a new record to this table.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.905.1">All records in the table are handled by </span><code class="inlineCode"><span class="koboSpan" id="kobo.906.1">IPackageEventRepository</span></code><span class="koboSpan" id="kobo.907.1">, which can be retrieved and sent to all interested microservices by a parallel task defined in the DI engine with a call such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.908.1">builder.Services.AddHostedService&lt;MyHostedService&gt;();</span></code><span class="koboSpan" id="kobo.909.1">, as detailed in the </span><em class="italic"><span class="koboSpan" id="kobo.910.1">Using generic hosts</span></em><span class="koboSpan" id="kobo.911.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.912.1">Chapter 11</span></em><span class="koboSpan" id="kobo.913.1">, </span><em class="italic"><span class="koboSpan" id="kobo.914.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.915.1">. </span><span class="koboSpan" id="kobo.915.2">However, this parallel task is not implemented in the GitHub code associated with this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.916.1">It is worth recalling that the usage of events promotes code decoupling, and when events cross the microservice boundary, they implement efficient asynchronous communication between microservices, which improves performance and maximizes hardware resource usage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.917.1">The next subsection describes how to define controllers.</span></p>
<h1 class="heading-1" id="_idParaDest-372"><span class="koboSpan" id="kobo.918.1">Defining controllers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.919.1">Each controller </span><a id="_idIndexMarker1305"/><span class="koboSpan" id="kobo.920.1">interacts with a use case that emerged in the analysis stage with its action methods. </span><span class="koboSpan" id="kobo.920.2">Action methods do their job by requiring command handlers and query interfaces from the dependency injection engine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.921.1">Below is an example of how query objects are required and used:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.922.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.923.1">HttpGet</span></span><span class="koboSpan" id="kobo.924.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.925.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.926.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.927.1"> Task&lt;IActionResult&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.928.1">Index</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.929.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.930.1">    [FromServices] IPackagesListQuery query</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.931.1">)</span></span><span class="koboSpan" id="kobo.932.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.933.1">var</span></span><span class="koboSpan" id="kobo.934.1"> results = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.935.1">await</span></span><span class="koboSpan" id="kobo.936.1"> query.GetAllPackages();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.937.1">var</span></span><span class="koboSpan" id="kobo.938.1"> vm = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.939.1">new</span></span><span class="koboSpan" id="kobo.940.1"> PackagesListViewModel { Items = results };
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.941.1">return</span></span><span class="koboSpan" id="kobo.942.1"> View(vm);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.943.1">Below, instead, is an </span><a id="_idIndexMarker1306"/><span class="koboSpan" id="kobo.944.1">example of the usage of command handlers:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.945.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.946.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.947.1"> Task&lt;IActionResult&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.948.1">Edit</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.949.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.950.1">    PackageFullEditViewModel vm,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.951.1">    [FromServices] ICommandHandler&lt;UpdatePackageCommand&gt; command</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.952.1">)</span></span><span class="koboSpan" id="kobo.953.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.954.1">if</span></span><span class="koboSpan" id="kobo.955.1"> (ModelState.IsValid)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.956.1">await</span></span><span class="koboSpan" id="kobo.957.1"> command.HandleAsync(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.958.1">new</span></span><span class="koboSpan" id="kobo.959.1"> UpdatePackageCommand(vm));
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.960.1">return</span></span><span class="koboSpan" id="kobo.961.1"> RedirectToAction(
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.962.1">nameof</span></span><span class="koboSpan" id="kobo.963.1">(ManagePackagesController.Index));
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.964.1">else</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.965.1">return</span></span><span class="koboSpan" id="kobo.966.1"> View(vm);
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.967.1">ICommandHandler&lt;UpdatePackageCommand&gt;</span></code><span class="koboSpan" id="kobo.968.1"> retrieves the command handler associated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.969.1">UpdatePackageCommand</span></code><span class="koboSpan" id="kobo.970.1"> command from DI.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.971.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.972.1">ModelState</span></code><span class="koboSpan" id="kobo.973.1"> is valid, </span><code class="inlineCode"><span class="koboSpan" id="kobo.974.1">UpdatePackageCommand</span></code><span class="koboSpan" id="kobo.975.1"> is created, and its associated handler is invoked; otherwise, the View is displayed again to the user to enable them to correct all the errors.</span></p>
<h1 class="heading-1" id="_idParaDest-373"><span class="koboSpan" id="kobo.976.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.977.1">In this chapter, we analyzed the peculiarities of front-end microservices and the techniques used to implement them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.978.1">Then, we put together the techniques learned in this chapter and in previous chapters in the complete implementation of a front-end microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.979.1">We used an onion architecture with a data layer and a domain layer abstraction, and we implemented each as a separate project. </span><span class="koboSpan" id="kobo.979.2">The application layer and the presentation layer were implemented together in the same ASP.NET Core MVC project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.980.1">The microservice used the CQRS pattern and used a queue implemented with a database table to store the events to send to other microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.981.1">The next chapter explains how to implement a presentation layer with client-based techniques. </span><span class="koboSpan" id="kobo.981.2">We will use Blazor as an example client framework.</span></p>
<h1 class="heading-1" id="_idParaDest-374"><span class="koboSpan" id="kobo.982.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.983.1">What is the difference between a front-end and an API gateway?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.984.1">Why should all front-ends and API gateways use a robust web server?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.985.1">Why should complex blocking database transactions be avoided?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.986.1">When does the concurrency technique ensure a better performance?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.987.1">What is the advantage of using domain events to implement interactions between different aggregates?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-375"><span class="koboSpan" id="kobo.988.1">Further reading</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.989.1">Since this chapter just put into practice concepts explained in other chapters (mainly </span><em class="italic"><span class="koboSpan" id="kobo.990.1">Chapter 7</span></em><span class="koboSpan" id="kobo.991.1">, </span><em class="italic"><span class="koboSpan" id="kobo.992.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.993.1">, </span><em class="italic"><span class="koboSpan" id="kobo.994.1">Chapter 11</span></em><span class="koboSpan" id="kobo.995.1">, </span><em class="italic"><span class="koboSpan" id="kobo.996.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.997.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.998.1">Chapter 13</span></em><span class="koboSpan" id="kobo.999.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1000.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.1001.1">), here we will include just a few links on how to use API gateways and further information on the MediatR library, which was mentioned in the example:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1002.1">Ocelot GitHub repository: </span><a href="https://github.com/ThreeMammals/Ocelot"><span class="url"><span class="koboSpan" id="kobo.1003.1">https://github.com/ThreeMammals/Ocelot</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1004.1">How to implement your API gateway with Ocelot: </span><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot"><span class="url"><span class="koboSpan" id="kobo.1005.1">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1006.1">Azure API Management: </span><a href="https://azure.microsoft.com/en-us/services/api-management/#overview "><span class="url"><span class="koboSpan" id="kobo.1007.1">https://azure.microsoft.com/en-us/services/api-management/#overview</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1008.1">Azure App Service: </span><a href="https://azure.microsoft.com/en-us/services/app-service/"><span class="url"><span class="koboSpan" id="kobo.1009.1">https://azure.microsoft.com/en-us/services/app-service/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1010.1">More information on MediatR can be found on MediatR’s GitHub repository: </span><a href="https://github.com/jbogard/MediatR"><span class="url"><span class="koboSpan" id="kobo.1011.1">https://github.com/jbogard/MediatR</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1012.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1013.1">Enjoying this book? </span><span class="koboSpan" id="kobo.1013.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.1013.3">Scan the QR code below for a 20% discount code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1014.1"><img alt="" role="presentation" src="../Images/Leave_a_review_QR.png"/></span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.1015.1">*Limited Offer</span></em></p>
</div>
</body></html>