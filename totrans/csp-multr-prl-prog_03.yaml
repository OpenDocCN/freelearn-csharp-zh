- en: Chapter 3. Thread Class – Heavyweight Concurrency in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we examined the `BackgroundWorker` component and how
    to use it to achieve performance gains by multithreading our application. This
    component is useful but has many limitations. In order to have very precise control
    over the concurrently running threads in our applications, we can use the `Thread`
    class instead.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will study this class in detail and develop more complex
    multithreaded applications that take full advantage of the multiprocessing capabilities
    of today's hardware.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the terms **heavyweight concurrency** and **lightweight concurrency**
    throughout this book. Let's take a minute to reflect on what we mean by this.
    When we use the `Thread` class, as we will see in this and the next chapter, we
    will develop multithreaded applications through heavyweight concurrency. This
    means that it is up to us to create, coordinate, and manage the different threads
    in our application. It will also be up to us to know how many processing cores
    the hardware has that runs our application in order to maximize the multithreading
    efficiency of our application. We use the term heavyweight concurrency to describe
    this kind of multithreaded development because it takes extra code and work on
    the developer's part to achieve maximum benefits. We have to create the threads,
    coordinate the interaction of the threads, manage when threads have completed,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the book, we will study the `Task` class and **Task Parallel Library**
    (**TPL**). This library is a recent addition to the .NET framework and takes multithreading
    application development to the next level. Using these classes allows the developer
    to achieve the maximum benefits of multithreading an application with much less
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: TPL handles thread creation, coordination, and management for you. Developing
    using the TPL classes is referred to as lightweight concurrency because it takes
    less effort by the developer. There are some downsides, as we will see, to using
    these classes because much of the multithreaded work is handled for you and may
    not be done exactly how you want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: So, depending on your application and expertise, there are times when both heavyweight
    concurrency and lightweight concurrency are the right solution. The key is to
    understand both and know when to use each.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will focus on heavyweight concurrency and the `Thread` class. After
    reading this chapter and following the exercises, we shall be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop applications with great control over multiple running threads, offering
    exciting performance enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to create independent and very flexible threads using a very powerful
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out how to start, control, and coordinate multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to send parameters to and retrieve data from threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to share data between many threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out how to combine asynchronous and synchronous execution in order to have
    exhaustive control over the running threads and their tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop applications capable of launching multiple threads when necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating threads with the Thread class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the `BackgroundWorker` component to create new threads
    independent of the main application thread. The applications can respond to UI
    events while processing continues and take full advantage of multiple cores, thus
    running faster. However, there are some restrictions when we must control and
    coordinate the execution of many threads that are not intended to just run in
    the background. Now, let's learn how to use the `Thread` class to make an application
    capable of taking full control of the synchronous and asynchronous execution of
    concurrent threads. The `Thread` class is just what it sounds like, a class that
    allows you to create separate threads of execution for your process to run.
  prefs: []
  type: TYPE_NORMAL
- en: We can work with many instances of the `Thread` class (`System.Threading.Thread`)
    in order to run many concurrent threads with more control capabilities than the
    ones created using the `BackgroundWorker` component. As we learned in the previous
    chapter, the performance results will depend upon the number of cores or processors
    available in the computer on which we run the application. However, the `Thread`
    class offers many fine-tuning capabilities to help us achieve the desired performance
    using multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread` class does a great job of offering great flexibility while offering
    a simple way to initialize, coordinate, run, stop, and free multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with an encryption program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate how to use the `Thread` class, we are going to create a simple
    WPF application that takes text messages and encrypts and decrypts them. The customers
    of this application are working with a new cellular phone capable of sending SMS
    (text messages) with access to the complete Unicode character set. The cellular
    phone is a single-core device. The application has to work in a very fast and
    efficient encryption engine capable of encrypting the incoming text messages and
    leaving them in an output queue. This engine is going to run on a huge server
    with many multi-core processors. They want it to use a very fine-tuned multithreading
    application capable of working with as many threads as there are available cores
    in the computer on which the engine is being executed. So, the application will
    have to be smart enough to detect the number of cores and create that many threads.
    In this way, it uses the full capabilities of the hardware, but doesn't create
    extra threads that will not further enhance performance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we are going to build a new C# WPF application, and we will define and
    test the methods to encrypt and decrypt a string:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# project using the WPF application template in Visual Studio.
    Use `SMSEncryption` as the project's name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainWindow.xaml` in the designer mode, add the following controls, and
    align them as shown in the following screenshot:![How to do it](img/8321EN_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One image showing a text message graphic called `imgTextMessage`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Three textboxes with their `Text` property set to `SMS Encryption Engine`, `Original
    Messages`, and `Encrypted Messages`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two textboxes with their `Names` property set to `txtOriginalSMS` and `txtEncryptedSMS`,
    and their `AcceptsReturn` property set to `true`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One button control named `butTest` with its `Text` property set to `Test`. This
    is the button that will test the encryption and decryption methods.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, add a class file called `EncryptionProcedures` that has two static methods,
    one called `Encrypt` and the other called `Decrypt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Encrypt` method will encrypt the string received as a parameter and return
    a string containing the resulting encoded message with unrecognizable characters.
    Add the following code for this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Decrypt` method will decrypt the encrypted string received as a parameter
    and return a string with the resulting decoded message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Click` event handler method for the button, `butTest`, and enter
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a short text in the textbox labeled `Original SMS Messages`, and click
    on the **Test** button. The encrypted message will appear in the textbox labeled
    `Encrypted SMS Messages`. The decrypted message will also become visible in the
    bottom textbox, but this will be the result of decrypting the encrypted message
    to test the algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results will look similar to the following screenshot:![How to do it](img/8321EN_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this program, we have created the `Encrypt` and `Decrypt` methods that take
    a `String` value and encrypt and decrypt it, respectively. The encryption algorithm
    uses a random number generator and many **Exclusive OR** (**XOR**) operations.
    It also adds garbage in the text in order to confuse potential hackers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that in C#, the XOR operation is specified by the `^` operator and
    can be applied to numbers. Thus, we needed many typecastings to `char` type, and
    then we called the `ToString()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most exciting properties of the XOR operation is the possibility
    of returning to the original value when it is applied twice. For example, consider
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The value assigned to `liSecondXOR` will be the same as is in `liOriginalValue`,
    that is, `120`.
  prefs: []
  type: TYPE_NORMAL
- en: As the encryption algorithms use the complete Unicode character set, with 65,536
    possible characters, the resulting text is unreadable and very confusing, as it
    is not limited to the classic 256-character set.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application with threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have tested the decryption of the previously encrypted message, we are
    sure it is working fine. We are now going to run the encryption algorithm in a
    new thread created using the `Thread` class.
  prefs: []
  type: TYPE_NORMAL
- en: We want to use the `Thread` class to have tight control over the execution of
    the different processing threads in our application. First, we need to make the
    encryption function run in just one thread. Later, we will align the threads with
    the number of cores in our hardware to ensure maximum efficiency. So, for now,
    we will change the application we previously built so that the encryption logic
    runs in a separate thread from the main application. This will begin to give us
    control over when and how we encrypt the text messages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are going to make some changes to the application, and we will encrypt
    the messages in a new independent thread created and configured using the `Thread`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SMSEncryption` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button control (`butRunInThread`). Set its `Text` property to `Run in
    a Thread`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we are going to use the `Thread` class, we need to add a `Using` statement
    so that our application can find this class from the .NET framework. Add the following
    line of code at the beginning (as we are going to use the `System.Threading.Thread`
    class):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line in the `MainWindow` code-behind file, `MainWindow.xaml.cs`
    class definition to declare three new private variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add one button control named `butRunInThread` with its `Text` property set to
    `Run in a Thread`. This is the button that will test the encryption and decryption
    methods running in a separate thread from the main thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Click` event method for the `butRunInThread` button and enter the
    following code to run the encryption process in a new thread created using the
    `Thread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to create the `ThreadEncryptProcedure` that will run in a separate
    thread and encrypt the text message. Enter the following code to create this procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter or copy and paste a long text in the `Textbox` labeled `Original SMS Messages`
    and click on the **Run in a Thread** button. The encrypted message will appear
    in the `Textbox` labeled `Encrypted Messages`. However, the code runs in a different
    thread. The results will be similar to what is shown in the following screenshot:![How
    to do it](img/8321EN_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, when the user clicks the **Run in a Thread** button, the encryption runs
    in a new thread, but with synchronous execution. We create the thread and then
    we start the thread with the `proThreadEncryption.Start();` command. Since it
    is a synchronous operation, we then wait on the thread to complete operation with
    the `proThreadEncryption.Join();` command. So, in a separate thread, the `ThreadEncryptProcedure`
    runs and encrypts the text message string into a list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: When the thread running the `ThreadEncryptProcedure` completes, the main thread,
    which was waiting on the thread to complete by executing the `Join` command, continues
    and takes the encrypted list of strings and displays them in the bottom textbox.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread.Join` method tells the issuing thread to wait here until the thread
    completes. As we are not using a `BackgroundWorker` component, which simplified
    UI decoupling, we must do that work in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines declare the two private string lists that will work as
    an input (`prlsSMSToEncrypt`) and as an output (`prlsEncryptedSMS`) for the new
    independent thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When started, the thread will execute the code in the `ThreadEncryptProcedure`
    (without parameters). This procedure is private and resides in the same class
    as the two aforementioned private string lists. Thus, the code in the `ThreadEncryptProcedure`
    can access these two variables to take the input strings, encrypt them, and add
    them to the output string list. Instead of working against the UI controls, we
    decouple the UI and avoid the problems related to multithreading with the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '`ThreadEncryptProcedure` does a very simple task without touching the UI controls.
    For each string in the input string list (`prlsSMSToEncrypt`), it encrypts the
    string and adds it to the output string list (`prlsEncryptedSMS`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the **Run in a Thread** button, the following lines
    prepare everything the thread needs from the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new instance of `List<string>`. As mentioned earlier, we
    pass the number of items (capacity) as a parameter in order to optimize the execution,
    using the `LineCount` property for the lines in the `txtOriginalSMS` textbox.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the `Add` method to add all the strings to our new `List<string>`
    instance. Now, we have everything the thread needs as an input in a private `List<string>`,
    which it can access without problems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mastering the use of lists, arrays, and collections is a must when working with
    multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple way to share data with a new independent thread without
    complications. However, we must be very careful, as we must learn more things
    in order to change data in the same variables accessed from many threads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we access variables from multiple threads, they must be of thread safety
    types. **Thread safety types** are those that are safe for multithreaded operations.
    If you have any doubt about a type, you can check whether it is of a thread safety
    type or not in the C# documentation. It offers a section describing the thread
    safety, as shown in the following screenshot for the `Int32` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following line declared the `proThreadEncryption` variable with the `Thread`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks on the **Run in a Thread** button, the following lines
    create an instance of the `Thread` class specifying the method it must execute
    in the new thread when it is started. In order to accomplish this, we use the
    `ThreadStart` delegate because we do not need to send parameters or other data
    to the thread for initialization purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the thread is created, it does not start running the code in the specified
    `ThreadEncryptProcedure` until we call the `Start()` method. Since we do not want
    to send parameters to the procedure, we use the `Start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This method tells the scheduler to start running the code in the new independent
    thread with an asynchronous execution. However, as it is executed asynchronously,
    we lose control over the time when the code in the thread begins running. It can
    be 100 milliseconds, 200 milliseconds, or 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we do not want to start an independent thread and lose control
    over its execution time, but we want to start it with a synchronous execution
    and wait, in the main thread, until it finishes. In order to do so, we call the
    `Join` method in the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It makes the new thread run the `ThreadEncryptProcedure` code. Once it finishes
    its execution, it returns control to the main thread and goes on with the next
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It works as if we were calling a classic method, but in another thread.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the code in a new thread using the `Thread` class is easy if we follow
    this simple code pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it was joined with the main thread, the statements after the call to
    the `Join` method are executed as soon as the thread finishes its execution. These
    lines collect the encrypted strings generated in the `prlsEncryptedSMS` string
    list and append them, one per line, in the `txtEncryptedSMS` textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As the thread stores the results of its processing in a private variable, which
    is also accessible from the main thread, we can use it to show the results in
    the UI controls.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple way to retrieve data from threads, leaving the results
    in a variable, accessible from both the main and the secondary threads.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the main advantages of threads over processes. It is very easy
    to share data between threads without much effort.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the `BackgroundWorker` component and the `Thread` class
    to execute code in independent threads. The `Thread` class allows us to have great
    control over the thread while the `BackgroundWorker` component offers a very simple
    way to update the UI without using complicated delegates or callbacks. How can
    we combine this component and this class in an application to make it faster to
    complete while keeping the UI responsive?
  prefs: []
  type: TYPE_NORMAL
- en: If we want to work with a `BackgroundWorker` component to show some feedback
    or progress to the UI controls, while one or more threads created using the `Thread`
    class is running, we must find a way to share data between threads.
  prefs: []
  type: TYPE_NORMAL
- en: We made something like that in our last example. However, we must use some techniques
    in order to avoid confusion between the different ways in which this useful component,
    `BackgroundWorker`, and this flexible and powerful class, `Thread`, work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can do it using the `Thread` class, but there is a `BackgroundWorker` component
    ready to help us. Thus, let's be pragmatic and use the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are going to make some changes to the application, adding a `BackgroundWorker`
    component to display progress. In order to accomplish that, we must share data
    between two threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SMSEncryption` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a label control (`lblNumberOfSMSEncrypted`). Set its `Text` property to
    `0`. Add another label control, and set its `Text` property to `Number of Messages
    Encrypted`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `BackgroundWorker` component (`bakShowEncryptedStrings`) to create a
    new independent thread capable of talking to the UI, as we learned in the previous
    chapter. Declare the following variable in the `MainWindow.xaml.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order for the program to recognize the `BackgroundWorker` class, you will
    also need to add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the following properties of the `BackgroundWorker` component in the `MainWindow`
    constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines in the `MainWindow` class definition to declare three
    new private variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line of code at the beginning of `ThreadEncryptProcedure`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line of code after the line `prlsEncryptedSMS.Add(lsEncryptedText);`
    in `ThreadEncryptProcedure`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register the `DoWork` event handler in the `MainWindow` constructor for the
    `BackgroundWorker` component `bakShowEncryptedStrings`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, enter the following code in the `bakShowEncryptedStrings_DoWork` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register the `ProgressChanged` event handler in the `MainWindow` constructor
    for the `BackgroundWorker` component `bakShowEncryptedStrings`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `ProgressChanged` event in the `BackgroundWorker bakShowEncryptedStrings`,
    and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Click` event in the `butRunInThread` button and enter the following
    code before the line `proThreadEncryption.Start();` (we must start the `BackgroundWorker`
    component before we start the encryption thread):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to comment out the `proThreadEncryption.Join();` line because
    we do not want the main thread to wait on the encryption routine to finish. We
    will also comment out lines after this that display the encrypted text message
    once the encryption thread finishes. We will be doing this through the `BackgroundWorker`
    processing and will explain this in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try running the application before commenting out these lines after the `Join`
    method but leave the `proThreadEncryption.Join();` command uncommented. You will
    create a race condition that may throw a null exception error for the variable,
    `prlsEncryptedSMS`. If the main thread tries to use this variable to display the
    encrypted text message before the encryption thread finishes the first line, then
    this variable will still be null. Since both the main thread and the encryption
    thread are running in parallel, we cannot ensure this will not happen.![How to
    do it](img/8321EN_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's build and run the application with those lines commented out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter or copy and paste a very long text (with more than 5,000 lines) in the
    textbox labeled `Original Messages`, and click on the **Run in a Thread** button.
    You will see the strings representing the messages encrypted appearing in the
    textbox labeled **Encrypted Messages** as the number of messages that are encrypted
    increases. The application will look something like the following screenshot:![How
    to do it](img/8321EN_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, when the user clicks on the **Run in a Thread** button, the encryption
    runs in a new thread, but with an asynchronous execution because we no longer
    tell the main thread to wait on it with the `Thread.Join()` method. At the same
    time, the `BackgroundWorker` component creates a new thread to give some feedback
    to the UI and also runs asynchronously. Thus, we have two concurrent threads with
    an asynchronous execution, doing completely different tasks in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why we added the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we start the `BackgroundWorker` thread, and then the encryption thread
    that is created with the `Thread` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With these examples, we have learned and seen the differences between executing
    a thread in a synchronous and an asynchronous way. We must master this in order
    to have complete control over many concurrent threads.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `BackgroundWorker` component in order to give some feedback
    to the UI controls. In order to do so, the encryption thread must share data with
    the `BackgroundWorker` thread.
  prefs: []
  type: TYPE_NORMAL
- en: We use the same technique that we used in the previous example. However, this
    time, our application is operating concurrently. While the encryption thread is
    adding encrypted strings to the `prlsEncryptedSMS` string list, the `BackgroundWorker`
    thread looks at the number of the last encrypted string and calls the `ReportProgress`
    method, sending it as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that too many calls to the `ReportProgress` method can generate a stack
    overflow exception. Because this method runs code that upgrades the textbox adding
    lines, it takes a lot more time than encrypting. If we have 100,000 messages to
    encrypt, and we make 100,000 calls to the `ReportProgress` method; it is highly
    probable that a stack overflow will be generated. The code in this method runs
    in the main thread, and for this reason, we must sacrifice some UI feedback to
    achieve a better overall performance and avoid exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `DoWork` and the `ReportProgress` event handlers is a little
    complex to account for this and not send updates for every single line encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we define three new private variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The encryption thread initializes `priLastEncryptedString` and then increments
    its value each time it adds an encrypted string to the `prlsEncryptedSMS` string
    list. This value is useful for the `BackgroundWorker` thread.
  prefs: []
  type: TYPE_NORMAL
- en: The code executed in the `DoWork` event handler by the `BackgroundWorker` thread
    concurrently with the encryption thread initializes `priLastEncryptedStringShown`
    and `priOldLastEncryptedStringShown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it waits until the encryption thread has some results. This is necessary
    because both the threads are launched asynchronously, at nearly the same time.
    It is a `while` loop, but with a call to the `Thread.Sleep` method, with 10 milliseconds
    of inactivity for the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since the `priLastEncryptedString` variable has a value less than `1`, the encryption
    thread has not added any value yet.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread.Sleep` method suspends the current thread (the thread in the actual
    context) for a specified time in milliseconds (0.001 seconds). As it suspends
    the thread execution, it does not consume CPU cycles. Hence, it does not waste
    processing power.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never use loops without instructions to wait for some time in a thread, because
    you will be wasting processing power. Instead, use the `Thread.Sleep` method when
    you have to pause a thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the encryption thread finishes encrypting the first string, adding it
    to the encrypted string list, and incrementing the value of `priLastEncryptedString`,
    the `BackgroundWorker` thread will move on to the next part of the code in the
    `DoWork` event handler method. Now, it will enter in the other loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The loop (and the `DoWork` thread) will go on running while the encryption thread
    is running, or while there are encrypted strings to be shown. We know when the
    `proThreadEncryption` thread is not running, or is not calling its `IsAlive` method.
    The `IsAlive` method returns either `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The first line in the loop saves the value of `priLastEncryptedString` in `liLast`.
    This is necessary because the value is changing concurrently on another thread
    (the encryption thread)—we are not alone (the joys of multithreaded logic!). We
    must save the value to work with the captured value in the rest of the comparisons
    and assignments. We do not want to work with a moving target within one iteration
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: If the last encrypted string is not the last string shown, we use the `sender`
    parameter typecast to a `BackgroundWorker` component to call the `ReportProgress`
    method with the last string shown as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `ReportProgress` method returns with an asynchronous event triggered
    to update the UI, we save the last string shown and make the thread suspend its
    execution for 1 second (1,000 milliseconds). This is necessary in order to avoid
    a probable stack overflow. Because the execution of the `DoWork` code is faster
    than the code programmed in the `ProgressChanged` event handler, we must give
    some time to the UI controls to get updated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we call the `Thread.Sleep` method, the current thread suspends its execution
    for a specified time, though the other threads keep running. That is the reason
    why the counter shows big steps when we run the application with several text
    lines. The encryption thread works without suspensions.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the `BackgroundWorker` component helps the `Thread` class to update the
    UI controls. The `ProgressChanged` event handler does the rest of the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it updates the number of SMS messages encrypted with the line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It then casts the `e.ProgressPercentage` property received as a parameter to
    an integer in order to obtain the last encrypted string, instead of a progress
    percentage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it appends each new string with a loop from `priOldLastEncryptedStringShown`
    (the previous last encrypted string shown) to the last encrypted string received
    (in the `e.ProgressPercentage` property). We access the `prlsEncryptedSMS` string
    list in an element number that the encryption thread is not modifying (because
    it is already encrypted). Therefore, we can append the string to the textbox without
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the string previous to the last encrypted string is now the last encrypted
    string shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By using a `BackgroundWorker` component with some threads created using the
    `Thread` class, we can easily give feedback to the UI and achieve better performance
    with a responsive application.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should mention that the `BackgroundWorker` component is a
    little like the black sheep of the family. In the .NET framework, with the advent
    of the `Thread` class and now the Task Parallel Library and `Async` methods (to
    be covered later in the book), some .NET developers consider use of `BackgroundWorker`
    a little passé. While it might not be the latest cool feature of .NET, it is still
    a very easy-to-use, helpful, and powerful component. According to me all multithreaded
    options in .NET have their place and the `BackgroundWorker` component is still
    relevant.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `Start` method, the thread is sent to the scheduler for execution.
    As mentioned earlier, it does not mean an immediate execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we call the `Start` method for many threads, one after the other, or when
    combined with a `BackgroundWorker` thread as in our example, we are not sure which
    one is going to run faster. We cannot assume one of them will reach some statement
    first, because the execution speed will depend upon the processor or the core
    it is assigned to and its capabilities. If it needs more context switches than
    the other thread, it will take longer to reach the same statement.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most important issues with concurrency. It all depends on
    something that we do not know how to predict sometimes. Therefore, we must consider
    every possible situation the code that will be executed concurrently might experience.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `Join` method, the thread is attached to the thread that calls
    the `Join` method and it will not execute anything else until the thread method
    finishes its execution. This is one of the most difficult things to achieve for
    programmers used to traditional linear code.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used the `BackgroundWorker` component combined with the `Thread` class
    to provide fast execution and UI feedback. Now, we will combine multiple `Thread`
    class instances with many `BackgroundWorker` components to create an application
    that runs as fast as possible on modern computer architectures. In fact, it will
    inspect the computer it is running on and create an encryption thread for each
    processing core the computer has. This will maximize the performance without creating
    extra threads that will not further improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with dynamic lists and the `Environment.ProcessorCount` property
    to create threads on the fly according to the number of cores on the machine.
    However, we need some technique to distribute the SMS messages that must be encrypted
    to the many encrypting threads. At the same time, we must provide feedback through
    many `BackgroundWorker` components. It sounds complex, and it is indeed complex.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this goal, we must pass specific parameters to the common procedure
    that the many threads will run. We want to reuse the procedure because we want
    it to be dynamically organized according to the number of available cores at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are going to make some big changes to the application, modifying variables
    to be lists, or lists of lists, so they can be accessed by multiple threads created
    dynamically. In order to accomplish that, we must share data between the many
    threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SMSEncryption` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line in the `MainWindow` class definition to declare a new
    private variable that will tell us the number of cores on the machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the definition for the following private variables in the `MainWindow`
    class definition to make them lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line in the `MainWindow` class definition to declare a new
    private variable that will hold the list of the `Thread` class instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variables required to grow dynamically, according to the number of cores
    found in the computer, have been added to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: One potential problem of manually assigning a value greater than the number
    of available cores to the `priProcessorCount` variable is that the increasing
    context switches needed by the operating system scheduler will degrade performance.
    Therefore, you must be wary of wrong fine-tuning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's change the different methods to allow multiple threads to encrypt
    the strings as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is going to be easier rewriting these than making the changes, as we are
    replacing single variables by lists. In order to accomplish this, we must create
    a thread with a parameter indicating its number:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SMSEncryption` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the definition for `ThreadEncryptProcedure` with the following (now
    it receives a parameter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the text in the labels from `Encrypted Message` to `Encrypted Message(by
    thread 1)` and `Number of Messages Encrypted` to `Number of Messages Encrypted(by
    thread 1)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the code in the `ThreadEncryptProcedure` procedure with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the code where the threads were initialized and started in the `Click`
    event handler in the `butRunInThread` button, after the line `prlsSMSToEncrypt.AddRange(txtOriginalSMS.Lines);`,
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `DoWork` event in the `BackgroundWorker bakShowEncryptedStrings` and
    make the following code replacements to the existing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `priLastEncryptedString` with `priLastEncryptedString[0]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace `proThreadEncryption` with `prloThreadList[0]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the `ProgressChanged` event in the `BackgroundWorker bakShowEncryptedStrings`
    and make the following code replacements to the existing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `priLastEncryptedString` with `priLastEncryptedString[0]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace `prlsEncryptedSMS[i]` with `prlsEncryptedSMS[0][i]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter or copy and paste a very long text (with more than 20,000 lines) in the
    textbox labeled **Original Messages** and click on the **Run in a Thread** button.
    You will see the strings representing the messages encrypted by thread 1 appearing
    in the textbox labeled **Encrypted Messages (by thread 1)**, while the number
    of messages encrypted by thread 1 increases. In this example, there were 119 lines
    in the text message with a `ProcessorCount` of `4`:![How to do it](img/8321EN_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code has become more complex. However, running this application in a quad-core
    computer improves the performance by almost a factor of four. We do not realize
    the full 4x performance gain because of the overhead of multithreading that we
    discussed in [Chapter 1](ch01.html "Chapter 1. Understanding Multiprocessing and
    Multiple Cores"), *Understanding Multiprocessing and Multiple Cores*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the user clicks on the **Run in a Thread** button, the encryption
    runs in as many threads as there are available cores in the computer with an asynchronous
    execution. At the same time, the `BackgroundWorker` component starts running concurrently
    displaying the results just for the first thread.
  prefs: []
  type: TYPE_NORMAL
- en: The private string list that works as an input for the many threads is the same
    as in the previous examples (`prlsSMSToEncrypt`), but is accessed in a different
    way by each thread.
  prefs: []
  type: TYPE_NORMAL
- en: The private string list that works as an output (`prlsEncryptedSMS`) is now
    a list of string lists. Thus, each thread can work in its own output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a new thread list that will be aligned with the value in the `priProcessorCount`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This replaces the line that declared the `proThreadEncryption` variable with
    the `Thread` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the **Run in a Thread** button, the following lines
    create an instance of the `Thread` class specifying the method it must execute
    in the new thread when started. In order to accomplish this, we use the `ParameterizedThreadStart`
    delegate because we need to send a parameter with the number of threads to identify
    each thread in the method it runs. This is an important change to note. Earlier,
    we just called the `ThreadStart` method. This new method allows us to start a
    thread that has a delegate method that takes a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Once each thread is created, it does not start running the code in the specified
    `ThreadEncryptProcedure` procedure until we call the `Start` method. But first
    we initialize the threads, and then we call the `Start` method for each one. We
    want to send a parameter (the thread number) to the method. Therefore, we use
    the `Start` method with one parameter. Take a moment to make sure you understand
    how these methods operate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This method tells the scheduler to start running the code in the new threads
    (one per available core). Then, we want to run the `BackgroundWorker` thread concurrently
    to report the UI with feedback from the first created thread (thread number `0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In a dual-core or dual-processor computer, we will have two encrypting threads
    and one `BackgroundWorker` thread. In a quad-core computer, we will have four
    encrypting threads and one `BackgroundWorker` thread.
  prefs: []
  type: TYPE_NORMAL
- en: It makes the new threads run the `ThreadEncryptProcedure` method code (with
    the thread number as a parameter), and when they finish their execution, it returns
    the control to the main thread and goes on with the next statement.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the code into many concurrent threads using the `Thread` class and
    sending parameters to them is easy if we follow this simple code pattern and we
    have a good knowledge of working with lists or dynamic arrays.
  prefs: []
  type: TYPE_NORMAL
- en: We did not want to use many methods, one for each new thread. We wanted to share
    the same method and differentiate among the threads using a parameter with a number
    that identifies each.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to distribute the work in many concurrent threads working
    on the same algorithm, taking the same input and producing almost the same output.
    We used one of them, and we will learn more in the following chapters using both
    the `Thread` and `Task` classes and the `Parallel` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter that is sent when calling the `Start` method for the thread instance
    is received in the `object` parameter, `poThreadParameter`, as shown in the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we must use typecasting to convert it to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With the thread number and the total number of threads (the value in the `priProcessorCount`
    variable) that will be sharing the work to be done, we can easily distribute the
    work of a list to be processed (encrypted). A simple way to do this is to make
    each thread take the input it must process and leave the rest untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in the iteration, which goes through the string list from the
    thread number (hence, each thread will begin in a different number) to the total
    number of strings to encrypt, stepping up the value in the `priProcessorCount`
    variable (the total number of threads):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s suppose that there are four threads. They will work on
    the following strings from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Thread #1: 0; 4; 8; 12; 16; 20; …`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread #2: 1; 5; 9; 13; 17; 21; …`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread #3: 2; 6; 10; 14; 18; 22; …`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread #4: 3; 7; 11; 15; 19; 23; …`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we will consider them running concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The string list capacity for `prlsEncryptedSMS[liThreadNumber]` is determined
    by the total number of strings to be encrypted divided by the total number of
    threads (the value in the `priProcessorCount` variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be wrong by `1`, but it does not matter in this case (reserving capacity
    is better), because the thread increments a variable with the number of processed
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The code in the `BackgroundWorker` component was modified to show only the progress
    of the first thread. This can be changed or additional `BackgroundWorker` components
    added to display the progress of all encryption threads.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – concurrent UI feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, there is still some work to be done. The FBI wants to
    see all the code being encrypted and not just the work done by the first thread.
    Remember, they have a computer with 16 quad-core microprocessors (64 cores).
  prefs: []
  type: TYPE_NORMAL
- en: Using everything we have learned, develop a new version of this application
    that shows the progress for each dynamically created thread. Show the progress
    in numbers, in a progress bar, and in textboxes (adding the encrypted SMS messages).
    For all these controls, as many concurrent threads as the number of available
    cores are running in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, use the control procedures of the `Thread` class instances we learned
    in order to create a final collection procedure that takes the results of all
    the running threads and shows the complete list of encrypted messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhance the application changing the string lists with instances of a new class,
    using the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Caller ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destination number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypt all the fields and compute the total number of characters sent.
  prefs: []
  type: TYPE_NORMAL
- en: Show the incoming and outgoing SMS messages with their information in a grid
    with many columns, instead of using textboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Switch off the webcam. The FBI is looking for you for a new mission!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about working with threads and the `Thread`
    class. We learned how to create threads, coordinate them synchronously and asynchronously,
    and pass parameters to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications that are able to provide greater control over multiple
    running threads, created using the `Thread` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming the code to be executed by the `Thread` class instance when started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating independent and flexible threads using the powerful `Thread` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting, controlling, and coordinating multiple threads with great flexibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending parameters and retrieving data from independently running threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data between many threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining asynchronous and synchronous execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the number of available cores with the number of concurrent threads
    to take full advantage of parallel processing capabilities in modern computers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will take an even deeper dive into the `Thread` class.
  prefs: []
  type: TYPE_NORMAL
