<html><head></head><body>
		<div><h1 id="_idParaDest-166"><em class="italic"><a id="_idTextAnchor168"/>Chapter 9</em>: Enhancing the Performance of Networked Applications</h1>
			<p>You will be very hard pressed when you turn your computer on to not have a single application using some kind of network application. Your operating system connects to a network to download and install Windows updates. Installed applications will poll (check at regular intervals) application servers over the internet to see if there are newer versions available for download. </p>
			<p>Browsers download audio and visual data over the internet, and websites allow you to upload and download files. Business applications communicate with database servers. Communication applications send large volumes of textual, audio, and visual data over networks – often with multiple people from various parts of the world involved in online video meetings and training sessions. Your fintech applications communicate with your financial providers over the internet. This is only just scratching the surface. </p>
			<p>Our world is very interconnected via technology, and it is networks that make all this possible. I am sure that you have felt some frustration as a user of a website or application when it experiences a slowdown, an application hang, or the application temporarily freezes while some other tasks block the UI until they have been completed, preventing you from doing any work.</p>
			<p>Due to this, having applications that are highly performant over a network is crucial in today’s fast-paced world. And that is why Microsoft is busy working to always improve the efficiency and speed of their software. One such piece of software that is relatively new on the scene is <strong class="bold">Google Remote Procedural Calls</strong> (<strong class="bold">gRPCs</strong>). A software framework for making <strong class="bold">Remote Procedural Calls</strong> (<strong class="bold">RPCs</strong>), gRPC/gRPC-Web has received a performance boost.</p>
			<p>In this chapter, you will learn how to speed up the performance of network applications. You will also learn how to communicate over a network using the <code>System.IO.Pipelines</code> to provide performant streaming capabilities.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li><strong class="bold">Understanding the network layers and protocols</strong>: To produce working network software, you don’t necessarily need to know anything about networks and how they work – that is, unless you are writing low-level software to improve the network performance of networked applications. In this section, we will start looking at improving the network performance of software by looking at the different layers of a network and the protocols that live in those layers.</li>
				<li><strong class="bold">Improving web-based network traffic</strong>: Many of us use the internet daily during our work, family, education, and leisure time. The internet works over a web-based network that covers the globe. This network is made up of very slow copper wire networks to ultra-fast fiber-optic networks, and many computers with varying degrees of processing power. In this section, we will learn how to improve traffic over the internet to improve internet resource transfer. You will also learn how to monitor web application performance using Microsoft Edge.</li>
				<li><strong class="bold">High-performance communication using gRPC</strong>: In this section, we will learn how to perform high-speed network inter-process communication using gRPC and gRPC-Web. When it comes to gRPC-Web, we will be using Blazor Server for the server-side code and Blazor WebAssembly for the client-side code.</li>
				<li><strong class="bold">Optimizing internet resources</strong>: To improve resource upload and download times, it pays for you to spend time performing the right kinds of resource optimization. In this section, we will learn how to optimize images, text characters, and data transmission.</li>
				<li><strong class="bold">Using pipelines for content streaming</strong>: In this section, you will learn how to break down the data processing, data transmission, and data reception phases into several atomic tasks that work together using pipelines.</li>
				<li><strong class="bold">Caching resources in memory</strong>: In this section, you will learn how to cache resources in memory to reduce page transfer and display times. This can help reduce network load for other users and prevent bottlenecks and throttling.</li>
			</ul>
			<p>Upon completing this chapter, you will be able to do the following:</p>
			<ul>
				<li>Understand and apply UDP-based and TCP-based network protocols</li>
				<li>Monitor and identify problems with network traffic</li>
				<li>Improve the network retrieval performance of resources using caching</li>
				<li>Issue web requests and process responses securely</li>
				<li>Efficiently stream content over a network such as the internet using pipelines<p class="callout-heading">Note</p><p class="callout">As with all performance-sensitive work, all the techniques and examples in this chapter, as well as throughout this book, should be measured in the context of your application. The overhead of certain techniques mentioned may not be necessary, depending on the scale your networking applications need to handle.</p></li>
			</ul>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor169"/>Technical requirements</h1>
			<p>To follow along with the contents of this chapter, you will need the following:</p>
			<ul>
				<li>Visual Studio 2022 or later</li>
				<li>Microsoft Edge</li>
				<li>This book’s source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH09">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH09</a></li>
			</ul>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor170"/>Understanding the network layers and protocols</h1>
			<p>When writing applications that interact with networks, it is very useful to know what <strong class="bold">network protocols</strong> are used. A network protocol is a defined set of rules that defines how data is formatted, transmitted, and <a id="_idIndexMarker876"/>received between different devices and applications over a network. Different network protocols are used for different tasks. Some protocols are secure by nature, while some protocols are insecure by nature. The <strong class="bold">OSI network layer reference model</strong> is a good place to start in understanding the layers of a device’s networking capabilities and the associated protocols for those layers.</p>
			<p><strong class="bold">OSI</strong> stands for <strong class="bold">Open Standards Institute</strong>. The OSI network layer reference model is a conceptual model that <a id="_idIndexMarker877"/>defines and standardizes the communication between computers and telecommunication devices. It is independent of the technology that underpins such communication, so it is a technology-agnostic representation of the layers and protocols of a device’s network layers:</p>
			<div><div><img src="img/B16617_Table_9.1.jpg" alt="Table 9.1 – The OSI network layer reference model &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.1 – The OSI network layer reference model </p>
			<p>As you can see, a network has seven layers of operation. These layers are as follows:</p>
			<ul>
				<li><strong class="bold">Application layer</strong>: The application layer provides a user interface that allows users to send and <a id="_idIndexMarker878"/>receive data over a network. This layer contains <a id="_idIndexMarker879"/>all the applications you use and that operate behind the scenes to interact with the presentation level. For example, your internet browser employs the HTTP, HTTPS, and FTP protocols for transmitting and receiving files over the internet, while email clients use POP3, SMTP, and IMAP for sending and receiving email data.</li>
				<li><strong class="bold">Presentation layer</strong>: The presentation layer encrypts, formats, and compresses the data <a id="_idIndexMarker880"/>ready for network transmission. The <a id="_idIndexMarker881"/>protocols that are employed in this layer include POP/SMTP, Usenet, HTTP, FTP, Telnet, DNS, SNMP, and NFS.</li>
				<li><strong class="bold">Session layer</strong>: The session layer initiates and terminates sessions with remote systems. This is the <a id="_idIndexMarker882"/>layer where ports are assigned for network <a id="_idIndexMarker883"/>communication. Examples include port 25 for POP/SMTP, port 532 for Usenet, port 80 for HTTP, port 443 for HTTPS, ports 20 and 21 for FTP, port 23 for Telnet, port 53 for DNS, ports 161 and 162 for SNMP, and the use of an RPC Portmapper for NFS.</li>
				<li><strong class="bold">Transport layer</strong>: The transport layer breaks <a id="_idIndexMarker884"/>down data streams into smaller data delivery segments <a id="_idIndexMarker885"/>using either TCP or UDP.</li>
				<li><strong class="bold">Network layer</strong>: The network layer provides <a id="_idIndexMarker886"/>logical addressing using either the original IPv4 or the newer IPv6.</li>
				<li><strong class="bold">Data Link layer</strong>: The data link layer prepares the data for transmission. This layer translates information <a id="_idIndexMarker887"/>from the network layer into a <a id="_idIndexMarker888"/>format that can be easily transmitted over the required network type using the SLIP, PPP, 802.2 SNAP, and Ethernet II protocols.</li>
				<li><strong class="bold">Physical layer</strong>: The physical <a id="_idIndexMarker889"/>layer is responsible for moving <a id="_idIndexMarker890"/>data between device locations. The types of physical network connections that this layer can make available include RS-X, CAT1 to CAT8, ISDN, ADSL, ATM, FDDI, and Coaxial Cable.</li>
			</ul>
			<p>The following protocols are used in these various levels:</p>
			<ul>
				<li><strong class="bold">Domain Name Service</strong> (<strong class="bold">DNS</strong>): The purpose of the DNS protocol is to translate <a id="_idIndexMarker891"/>host names into IP addresses and vice versa using what is known as domain name resolution. Port 53 is the default port for DNS.</li>
				<li><strong class="bold">Dynamic Host Configuration Protocol</strong> (<strong class="bold">DHCP</strong>): The purpose of DHCP is to <a id="_idIndexMarker892"/>assign IP address-related information dynamically to networked devices. Ports 67 and 68 are the default ports for DHCP.</li>
				<li><strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>): The purpose of HTTP is to enable the transfer <a id="_idIndexMarker893"/>of web pages and supporting material over the internet. Port 80 is the default port for the HTTP protocol.</li>
				<li><strong class="bold">Hypertext Transfer Protocol Secure</strong> (<strong class="bold">HTTPS</strong>): The purpose of HTTPS is to <a id="_idIndexMarker894"/>enable the safe transfer of web pages and their supporting material securely over the internet. Port 443 is the default port for HTTPS.</li>
				<li><strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>): The purpose of the SSH protocol is to securely connect to a remote <a id="_idIndexMarker895"/>computer and move files around and execute various commands. The default port for SSH is port 22.</li>
				<li><strong class="bold">Secure Socket Layer</strong> (<strong class="bold">SSL</strong>): The purpose of the SSL protocol is to secure the data that is <a id="_idIndexMarker896"/>transferred between a server and a web browser. Port 443 is the default port for SSL.</li>
				<li><strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>): The purpose of FTP is to transfer files over <a id="_idIndexMarker897"/>the internet. Ports 20 and 21 are the default ports for FTP.</li>
				<li><strong class="bold">Telnet</strong>: Telnet provides insecure two-way interactive text-based communication between two <a id="_idIndexMarker898"/>computers using virtual terminal connections. Port 23 is the default port for Telnet.</li>
				<li><strong class="bold">Trivial File Transfer Protocol</strong> (<strong class="bold">TFTP</strong>): The default <a id="_idIndexMarker899"/>port for TFTP is port 69. </li>
				<li><strong class="bold">Simple Mail Transfer Protocol</strong> (<strong class="bold">SMTP</strong>): The purpose of SMTP is to <a id="_idIndexMarker900"/>ensure the safe transmission of emails over the network. Port 25 is the default for the SMTP protocol.</li>
				<li><strong class="bold">Post Office Protocol version 3</strong> (<strong class="bold">POP3</strong>): The purpose of POP3 is to <a id="_idIndexMarker901"/>download and read emails from email servers. Port 110 is the default port for POP3.</li>
				<li><strong class="bold">Internet Message Access Protocol 4</strong> (<strong class="bold">IMAP4</strong>): The purpose of IMAP <a id="_idIndexMarker902"/>is to access emails on a remote email server without the need to download them. Port 143 is the default port for IMAP.</li>
				<li><strong class="bold">Remote Desktop Protocol</strong> (<strong class="bold">RDP</strong>): The purpose of RDP is to establish <a id="_idIndexMarker903"/>a remote connection to a computer and take control of it. Port 3389 is the default for RDP.</li>
				<li><strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>): The purpose of TCP is to provide <a id="_idIndexMarker904"/>trustworthy assurance that transmitted data will be received. TCP enables data sending and receiving. Different protocols come under the banner of TCP and each TCP protocol has a default port number.</li>
				<li><strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>): The purpose of UDP is to provide <a id="_idIndexMarker905"/>untrusted data transmission without the assurance that the data will be received. UDP only <a id="_idIndexMarker906"/>allows data to be transmitted. Different protocols come under the banner of UDP and each UDP protocol has a default port number.</li>
				<li><strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>): The purpose of the IP is to address how data packets are <a id="_idIndexMarker907"/>routed between host computers on a TCP/IP network.</li>
				<li><strong class="bold">Ethernet</strong>: The purpose of the Ethernet protocol is to provide control over how data is transmitted <a id="_idIndexMarker908"/>over a LAN per the IEEE 802.3 protocol.</li>
				<li><strong class="bold">Point-to-Point</strong> (<strong class="bold">PPP</strong>): The purpose <a id="_idIndexMarker909"/>of the PPP protocol is to establish a data link connection between two routers using authentication, transmission encryption, and data compression.</li>
				<li><strong class="bold">Network Time Protocol</strong> (<strong class="bold">NTP</strong>): The purpose of NTP is to provide clock <a id="_idIndexMarker910"/>synchronization between computer systems over packet-switched data networks with variable latency.</li>
				<li><strong class="bold">Network News Transport Protocol</strong> (<strong class="bold">NNTP</strong>): The purpose of NNTP is to <a id="_idIndexMarker911"/>transport Usenet articles (<em class="italic">netnews</em>) between news servers. It is also used by end user client applications to read and post articles.</li>
			</ul>
			<p>These are only a small subset of the various network protocols that are used in today’s world. You are encouraged to further research the various protocols in use if you do a lot of programming that requires network access. You can find some useful articles to assist your advancement in the <em class="italic">Further reading</em> section.</p>
			<p>Once you understand what network protocols are used for, you can select the protocol that best suits your need. This helps reduce overhead. For example, if you only want to transmit data and do not wish to receive it or care whether it is received or not, then you would use the UDP network protocol. However, if you must guarantee that data is sent and received, then you must use TCP instead. </p>
			<p><strong class="bold">The Internet Engineering Task Force</strong> (<strong class="bold">IETF</strong>) has defined two <strong class="bold">Request For Comments</strong> (<strong class="bold">RFCs</strong>) network <a id="_idIndexMarker912"/>transport protocols that <a id="_idIndexMarker913"/>have become internet standards. RFC 768 (UDP) defines <a id="_idIndexMarker914"/>UDP, whereas RFC 793 (TCP) defines <a id="_idIndexMarker915"/>TCP. Here are the official links for these RFCs for you to look at:</p>
			<ul>
				<li>RFC <a id="_idIndexMarker916"/>768 (UDP): <a href="https://tools.ietf.org/html/rfc768.">https://tools.ietf.org/html/rfc768</a></li>
				<li>RFC <a id="_idIndexMarker917"/>793 (TCP): <a href="https://tools.ietf.org/html/rfc793">https://tools.ietf.org/html/rfc793</a></li>
			</ul>
			<p>TCP is a connection-oriented protocol responsible for ensuring that data is transferred reliably across <a id="_idIndexMarker918"/>networks via sessions. The sender and receiver agree on what data will be transferred. Packet error checking is performed on the received data. If there are errors, then a request is submitted to re-transmit the packet that failed. TCP is often used with <strong class="bold">IP</strong>. Packets are made aware of where to go and how to get there by IP. The combination of the TCP and IP protocols, when they work together, is defined as TCP/IP.</p>
			<p>UDP differs from TCP as it is connectionless. UDP receivers listen for UDP packets with sessions <a id="_idIndexMarker919"/>being established. No error checking is performed with UDP. Therefore, packets may be lost with the receiver being unaware of the loss of those packets. UDP does not acknowledge the sender when data is received or when packets are lost.</p>
			<p>With TCP establishing connections for communication sessions and performing error checking and resubmitting lost or corrupted packets, it is generally considered slower than UDP. UPD is faster than TCP because it does not establish connections for sessions or perform error checking. Therefore, TCP is the best option when data must be received without errors, such as with financial transactions. However, UDP is the best option when it comes to streaming live images, such as when you are watching a movie. That’s why movies can sometimes appear a bit grainy at times.</p>
			<p>In the real world, the OSI model does not exist in all practicality. Instead, the universally accepted network model that is tangible in a practical way is the TCP/IP model.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor171"/>The TCP/IP model</h2>
			<p>The TCP/IP model differs <a id="_idIndexMarker920"/>from the OSI model in that there are only four layers that make <a id="_idIndexMarker921"/>up the TCP/IP model. These layers are as follows:</p>
			<ul>
				<li>Application layer</li>
				<li>Transport layer</li>
				<li>Internet layer</li>
				<li>Network interface layer</li>
			</ul>
			<p>So, how do the <a id="_idIndexMarker922"/>layers of the TCP/IP model map to the OSI model? The <a id="_idIndexMarker923"/>following table presents both models and their layers side by side for comparison:</p>
			<div><div><img src="img/B16617_Table_9.2.jpg" alt="Table 9.2 – Comparison between the TCP/IP model and the OSI model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.2 – Comparison between the TCP/IP model and the OSI model</p>
			<p>Let’s describe each layer in the TCP/IP model:</p>
			<ul>
				<li>The<strong class="bold"> Application layer</strong> enables users to initiate communication between applications and <a id="_idIndexMarker924"/>systems over a network. This can be sending an email, opening a web page, running an application over a network, accessing application information from a database, and performing file transfers over a network.</li>
				<li>The <strong class="bold">Transport layer</strong> resolves <a id="_idIndexMarker925"/>host-to-host communication.</li>
				<li>The <strong class="bold">Internet layer</strong> connects <a id="_idIndexMarker926"/>different networks.</li>
				<li>The <strong class="bold">Network Interface layer</strong> is the physical hardware that enables network communication <a id="_idIndexMarker927"/>between a server and its hosts.</li>
			</ul>
			<p>Now that we have learned <a id="_idIndexMarker928"/>about the TCP/IP model, in the next section, we will write a simple email application and discuss how it relates to the TCP/IP model.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor172"/>Writing an example email application with the TCP/IP model </h2>
			<p>In this section, we <a id="_idIndexMarker929"/>are going to write a simple <a id="_idIndexMarker930"/>console application that sends an email using SMTP. Then, we will discuss how this email is sent through the TCP/IP model. To write a simple console application, follow these steps:</p>
			<ol>
				<li>Start a new .NET 6.0 Console Application and call it <code>CH09_OsiReferenceModel</code>.</li>
				<li>Add a new class called <code>EmailServer</code> with the following <code>using</code> statements:<pre>using System;
using System.Net.Mail;</pre></li>
			</ol>
			<p>We need these two namespaces for handling exceptions and sending emails.</p>
			<ol>
				<li value="3">Add the following method:<pre>public static void SendEmail(
string from, string to, string title, string message
)
{
    try
    {
    MailMessage mailMessage = new MailMessage();
    mailMessage.From = new MailAddress(from);
    mailMessage.To.Add(to);
    mailMessage.Subject = title;
    mailMessage.Body = message;
    SmtpClient smtpServer = new SmtpClient();
    smtpServer.DeliveryMethod = 
        SmtpDeliveryMethod.Network;
    smtpServer.Host = “smtp-mail.outlook.com”;
    smtpServer.Port = 587;
    smtpServer.UseDefaultCredentials = false;
    smtpServer.Credentials = new 
        System.Net.NetworkCredential(“EMAIL_ADDRESS”, 
            “PASSWORD”);
    smtpServer.EnableSsl = true;
    smtpServer.Send(mailMessage);
}
catch (Exception ex)
{
            throw ex.GetBaseException();
}
}</pre></li>
			</ol>
			<p>The preceding code takes the necessary parameters for sending our email programmatically. A <code>MailMessage</code> is built up from those parameters. Then, we initialize and configure a <code>SmtpClient</code> to connect to a networked-host email server that sends our email.</p>
			<ol>
				<li value="4">Update the <code>Program</code> class, as follows:<pre>using CH09_OsiReferenceModel;
Console.WriteLine(“Hello World!”);
SendMail();
Console.WriteLine(“Email has been sent.”);</pre></li>
			</ol>
			<p>Here, we are <a id="_idIndexMarker931"/>writing a greeting to the <a id="_idIndexMarker932"/>console window. Then, we are calling <code>SendMail()</code> to send our email, and then finishing with a message.</p>
			<ol>
				<li value="5">Now, add the <code>SendMail()</code> method:<pre>static void SendMail()
{
EmailServer.SendEmail(
    “FROM_EMAIL”
    , “TO_EMAIL”
    , “Test Message”
    , “Test Body. You can delete!”
);
}</pre></li>
			</ol>
			<p>Replace the email addresses with valid ones. This method calls the <code>SendMail</code> method in the <code>EmailServer</code> class.</p>
			<p>Run the program; you should have an email in your email account.</p>
			<p>With your project working, it is time to discuss how your project links in with the TCP/IP network model. Let’s start by looking at the following diagram:</p>
			<div><div><img src="img/B16617_Figure_9.1.jpg" alt="Figure 9.1 – Sending and receiving an email over a network via SMTP using the TCP/IP protocol&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Sending and receiving an email over a network via SMTP using the TCP/IP protocol</p>
			<p>First, start with your <a id="_idIndexMarker933"/>email client putting together an <a id="_idIndexMarker934"/>email, and the user clicking <strong class="bold">Send</strong>. When the data hits the Application layer, this is where the SMTP protocol comes into play. In this layer, the recipient is contacted, and the data is formatted and prefixed with an SMTP header.</p>
			<p>The email is then passed to the Transport layer. TCP is employed in this layer and is used to break down messages into smaller packets prefixed with a TCP header. </p>
			<p>From the transport layer, the email is passed to the Internet layer. IP formats the email packets so that they’re ready to be transmitted over the internet and prefixes them with an IP header. These formatted TCP/IP packets are then passed to the Network interface layer.</p>
			<p>At the network interface layer, the sender and receiver IP addresses are added to the header that is prefixed to the email. The email is then sent to the receiver.</p>
			<p>When the email packet reaches the receiver, it first hits the network layer. The header for the network layer is removed, and the email packet is passed to the Internet layer. The IP header is removed, and the email packet is passed to the transport layer. </p>
			<p>At the transport layer, the email packets are then reassembled. Once all the packets have been <a id="_idIndexMarker935"/>assembled with the TCP headers removed, they <a id="_idIndexMarker936"/>are passed to the application layer, where the SMTP protocol removes the SMTP header, passes the pure email data to the client, and closes the session.</p>
			<p>With that, we have covered the conceptual OSI model and the practical four-layer TCP/IP model. Sending an email was the example we used to discuss the journey from the sender to the receiver over the four-layer TCP/IP layer.</p>
			<p>Now that you understand the different layers that make up a network and some of the different network protocols and their uses, let’s look at netwo<a id="_idTextAnchor173"/>rk tracing.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor174"/>Improving web-based network traffic</h1>
			<p>It is a good idea to keep an eye on the performance of your web applications. This helps you see how well <a id="_idIndexMarker937"/>your application transmits and receives information from the network we all know as the internet or, as it is increasingly being referred to, the cloud. You can even track down those calls that are taking a long time to complete, enabling you to improve the responsive performance of your application.</p>
			<p>There are various ways that you can accomplish this task. But we will only focus on one way, and that way is to record your application’s performance in the web browser using the in-built development tools performance analyzer. Specifically, we will be looking at using Microsoft Edge’s <strong class="bold">development tools</strong>. This will be the topic of the next section.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor175"/>Recording your web-applications performance using Microsoft Edge</h2>
			<p>In this section, you will be using the Microsoft Edge web browser to analyze the performance <a id="_idIndexMarker938"/>of your web <a id="_idIndexMarker939"/>applications. Internet is the name given to the <strong class="bold">Wide Area Network </strong>(<strong class="bold">WAN</strong>) that we use every <a id="_idIndexMarker940"/>day to browse the web. Sometimes, web applications can be slow, and they are often much slower than their desktop counterparts. That is where the developer tools provided by various browsers come in.</p>
			<p>With the browser developer tools, you have some powerful capabilities for seeing what your application is doing behind the scenes. The main features that are provided by various browsers are as follows:</p>
			<ul>
				<li>The ability to navigate the elements of the currently loaded website to view the HTML structure, styles employed, computed styles, layout, event listeners, DOM breakpoints, properties, and accessibility.</li>
				<li>You can view console messages, including any error messages raised.</li>
				<li>You can view all the resources that make up a page with sources, synchronize changes with the local filesystem, override page assets with files from a local folder, view content scripts served by extensions, and create and save code snippets for later reuse.</li>
				<li>You can record and view the network traffic generated by a page, including information such as name, status, type, initiator, size, time, and waterfall with the <strong class="bold">Network</strong> tab.</li>
				<li>You can record a process. This information can be extremely detailed and you can save screenshots, record memory usage, and view the web vitals for the page with the <strong class="bold">Performance</strong> tab.</li>
				<li>You can profile memory usage and have the option to record a heap snapshot, allocate instrumentation on time, and allocate a sample.</li>
				<li>You can see and debug the background services for your applications on the <strong class="bold">Application</strong> tab, including their storage and caches.</li>
				<li>Security, which enables you to view the main origin and secure origins of your application, along with its security information, such as whether it has a valid <strong class="bold">SSL certificate</strong>.</li>
			</ul>
			<p>Each browser from various vendors works in subtly different ways. Developers each have <a id="_idIndexMarker941"/>their preferences <a id="_idIndexMarker942"/>as to which browser and set of developer tools they like to use. In this section, we will be using the <strong class="bold">Microsoft Edge Network</strong> and <strong class="bold">Performance</strong> tabs to analyze the performance of a web page. To do so, follow these steps:</p>
			<ol>
				<li value="1">Open <strong class="bold">Microsoft Edge</strong> and press <em class="italic">F12</em> to open the developer tools. The following screen should appear:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_9.2.jpg" alt="Figure 9.2 – Microsoft Edge developer tools displaying the default tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Microsoft Edge developer tools displaying the default tab</p>
			<ol>
				<li value="2">Click on the <strong class="bold">Network</strong> tab.</li>
				<li>In the address box, type <code>docs.microsoft.com</code>.</li>
			</ol>
			<p>The website will now load. As it does, you will see the network traffic being generated and logged. The following screenshot shows a portion of the data that’s been ordered by the resources that took the longest time to process:</p>
			<div><div><img src="img/B16617_Figure_9.3.jpg" alt="Figure 9.3 – The Microsoft Edge developer tools' Network tab displaying network traffic data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – The Microsoft Edge developer tools' Network tab displaying network traffic data</p>
			<p>As you can see, the <strong class="bold">Network</strong> tab is useful for seeing what resource has been requested (<strong class="bold">name</strong>), the <strong class="bold">status</strong> and <strong class="bold">type</strong> values of the request, what initiated the request (<strong class="bold">initiator</strong>), the request <strong class="bold">size</strong> and <strong class="bold">time</strong> to process, and its visual representation on the <strong class="bold">Waterfall</strong> chart. This information can be applied to your pages and their resources to reduce the overall size of a complete request and reduce the time it takes to complete the request.</p>
			<p>Now that <a id="_idIndexMarker943"/>we’ve seen <a id="_idIndexMarker944"/>the <strong class="bold">Network</strong> tab in action, let’s look at the <strong class="bold">Performance</strong> tab in action. To do so, follow these steps:</p>
			<ol>
				<li value="4">Click on the <strong class="bold">Performance</strong> tab, and then click on the <strong class="bold">record</strong> button.</li>
				<li>Type <code>docs.microsoft.com</code> into the address bar and press <em class="italic">Enter</em>.</li>
				<li>Once the page has fully loaded, stop the recording by clicking on the popup dialog’s <strong class="bold">Stop</strong> button.</li>
			</ol>
			<p>The profile that has just been captured will now be loaded and presented to you. How long this process will take varies based on how long you were recording and how much traffic was generated.</p>
			<p>Once the profile has finished loading, you should be presented with the following screen:</p>
			<div><div><img src="img/Figure_9.4.jpg" alt="Figure 9.4 – The Microsoft Edge performance profile for docs.microsoft.com&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – The Microsoft Edge performance profile for docs.microsoft.com</p>
			<p>You may be unable to read the contents of the preceding screenshot. That’s okay – this screenshot <a id="_idIndexMarker945"/>just represents the <a id="_idIndexMarker946"/>amount of data that you can glean using the performance profiler. You have screenshots, a Waterfall chart, a breakdown of all the methods and properties that were utilized to load the URL, and a summary of the types of traffic by time, such as loading time, scripting time, rendering time, painting time, system time, and idle time. </p>
			<p>You can use this information to find where most of the time is being taken up for a request and identify the method where the time is being consumed. This will help you identify the areas of your web projects that may be candidates for performance improvement.</p>
			<p>There is a wealth of information that can be gathered regarding the performance of your application <a id="_idIndexMarker947"/>using browser <a id="_idIndexMarker948"/>tools. And not all that information has been covered here. For instance, we have not even touched on the memory profiling tab in Microsoft Edge Developer Tools due to this chapter’s page length restrictions. However, you are actively encouraged to try out all the different features available in the web browser’s development tools for yourself to help you profile and improve the performance of your web applications and their network utilization.</p>
			<p>Now that we have learned how to use browser development tools to profile the internet traffic that’s produced by our application requests and responses, let’s look at the performance-enhanced <strong class="bold">gRPC Remote Procedural Call</strong> (<strong class="bold">gRPC</strong>) framework for high-speed network data transfer and communication.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor176"/>High-performance communication using gRPC</h1>
			<p>What is gRPC? It is an open source <strong class="bold">RPC</strong> framework. Applications use RPC to talk to each other. gRPC is <a id="_idIndexMarker949"/>built upon <a id="_idIndexMarker950"/>the modern technologies <a id="_idIndexMarker951"/>of HTTP/2 for the <strong class="bold">transport protocol layer</strong> and <strong class="bold">protocol buffers</strong> (<strong class="bold">Protobuf</strong>) for <a id="_idIndexMarker952"/>serializing technology for messages. Protobuf also provides a language-neutral contract language.</p>
			<p>gRPC has been designed with modern high-performance and cross-platform applications in mind. There are <a id="_idIndexMarker953"/>implementations for all manner of programming languages. This enables applications developed on different operating systems and in different programming languages to talk to each other.</p>
			<p>gRPC is in an opinionated contract-first framework with the contract being defined in a <strong class="bold">proto file</strong>. This proto file contains <a id="_idIndexMarker954"/>your API definitions and the messages they will send and receive. Code generation is then used to generate strongly typed clients and messages for your language and platforms, which in our case will be C# and .NET. The language of gRPC is binary and designed for computers. This makes gRPC perform better than text-based HTTP APIs. The complexity of remoting is hidden from the programmer in the gRPC framework. Much of the work you would normally have to do by hand as a programmer is done for you by code generation tools. And so, all you must do is call methods on your clients and await the results. For increased developer productivity and application performance, you are better off using gRPC over HTTP APIs.</p>
			<p>HTTP APIs are content-first and consider <a id="_idIndexMarker955"/>the shape of URLs, HTTP methods, JSON and XML, and more. REST APIs are code-first. Normally, you would write your code and then generate Swagger or RAML contracts afterward. REST APIs are human-readable as they are text-based. This makes them easy to debug with the right tools, but these APIs perform slower than gRPC. REST APIs deal with low-level HTTP, so you have more to think about in terms <a id="_idIndexMarker956"/>of HTTP requests, responses, and <a id="_idIndexMarker957"/>routing. This is more complicated than using gRPC, but you do end up with a high degree of control. So, even though HTTP APIs are not big on performance, they will appeal to the widest developer audience. They can be easier to get started with. However, they can become incredibly complex and deep-routed when you’re working on complicated enterprise software.</p>
			<p>Now that you know about gRPC and HTTP, you will appreciate that the fastest network and inter-application communication will be carried out by gRPC and not HTTP. And since this book is about performance, we will now demonstrate gRPC at work with a simple demonstration.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor177"/>Programming a simple gRPC client/server application</h2>
			<p>In this section, we will be building a gRPC service that returns a single message. Then, we will write a client to call the gRPC service and update our client and server so that we can stream messages. Let’s begin by writing our gRPC service.</p>
			<h3>Building a gRPC service</h3>
			<p>In this section, we <a id="_idIndexMarker958"/>are going to build a gRPC service in <strong class="bold">Visual Studio</strong>. Later in <a id="_idIndexMarker959"/>this chapter, we will consume this service. To build a gRPC service in Visual Studio, follow these steps:</p>
			<ol>
				<li value="1">Open Visual Studio and select <strong class="bold">Start a new project</strong>.</li>
				<li>Search for and select the ASP.NET Core <strong class="bold">gRPC Service</strong> template and click <strong class="bold">Next</strong>.</li>
				<li>On the <code>CH09_GrpcService</code>, and click <strong class="bold">Create</strong>.</li>
				<li>You will then be presented with the <strong class="bold">Additional information</strong> page. Ensure the latest version of .NET Framework is selected from the drop-down; this should be .NET 6.0.</li>
				<li>Click on the <code>appsettings.json</code> file.</li>
				<li>Make sure the project is set as the startup project, and then run it. You should be presented with a <strong class="bold">Trust ASP.NET Core SSL Certificate</strong> dialog. Click on <strong class="bold">Yes</strong>.</li>
				<li>You will now be presented with a security dialog, informing you that you are about to install a security certificate. Click <strong class="bold">Yes</strong> to install it. Once the certificate has been installed, your service should <a href="http://localhost:5000">be running. The gRPC </a>service URLs are <a href="http://localhost:5000">http://localhost:5000</a> and <a href="https://localhost:5001">https://localhost:5001</a>.<p class="callout-heading">Note</p><p class="callout">Ports 5000 and 5001 may be different on your system if they are already in use.</p></li>
				<li>Enter https://localhost:5001 in a browser; you should get the following message: <strong class="bold">Communication with gRPC endpoints must be made through a gRPC client.</strong> To learn how to create a client, visit <a href="https://go.microsoft.com/fwlink/?linkid=2086909">https://go.microsoft.com/fwlink/?linkid=2086909</a>. This message informs us that the next step is for us to write a client that will be able to communicate with the service.</li>
			</ol>
			<p>And that is how easy it is to get started with a gRPC service. Open the <code>greet.proto</code> file in the <code>Proto</code> folder and enter the following code:</p>
			<pre>syntax = “proto3”;
option csharp_namespace = “CH09_GrpcService”;
package greet;
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply);
}
// The request message containing the user’s name.
message HelloRequest {
  string name = 1;
}
// The response message containing the greetings.
message HelloReply {
  string message = 1;
}</pre>
			<p>As you can see, the <a id="_idIndexMarker962"/>proto language is straightforward. In this <a id="_idIndexMarker963"/>file, we stated the language’s syntax, assembly namespace, and the name of the package. We then provided a service definition, which defines the RPC request and response, followed by the request and response messages.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is a lot of code generation that goes on under the hood. So, in case you are wondering where certain files are located, you will find them hiding away in your <code>Obj\Debug\net6.0\Protos</code> folder.</p>
			<p>Since we are <a id="_idIndexMarker964"/>using gRPC for our service, we need a <a id="_idIndexMarker965"/>client. So, in the next section, we will build our client.</p>
			<h3>Building a gRPC client</h3>
			<p>In this section, we are <a id="_idIndexMarker966"/>going to add a gRPC client project that will consume our gRPC service. Also, for our client project, we will write a simple console application. To add a client project, follow these steps:</p>
			<ol>
				<li value="1">Start a new .NET 6.0 Console Application project named <code>CH09_GrpcServiceClient</code> and change the target framework to <code>.NET 6.0</code>.</li>
				<li>Right-click on the project’s <strong class="bold">Service dependences</strong> node in the Solution Explorer and select the <strong class="bold">Add Connected Service</strong> menu option. This will present you with the following tab:<div><img src="img/B16617_Figure_9.5.jpg" alt="Figure 9.5 – The Connected Services tab in Visual Studio&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 9.5 – The Connected Services tab in Visual Studio</p>
			<ol>
				<li value="3">Click on the <strong class="bold">Add</strong> button under the <strong class="bold">Service References (OpenAPI, gRPC)</strong> section. This will <a id="_idIndexMarker967"/>bring up the <strong class="bold">Add service reference</strong> dialog, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_9.6.jpg" alt="Figure 9.6 – The Add service reference dialog in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – The Add service reference dialog in Visual Studio</p>
			<ol>
				<li value="4">Click on the <strong class="bold">gRPC</strong> option and then click on the <strong class="bold">Next</strong> button. The wizard dialog presented in the <a id="_idIndexMarker968"/>preceding screenshot will move to the <strong class="bold">Add a new gRPC service reference</strong> page, as shown here:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_9.7.jpg" alt="Figure 9.7 – The Add a new gRPC service reference page of the Add service reference dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – The Add a new gRPC service reference page of the Add service reference dialog</p>
			<ol>
				<li value="5">Click on the <code>greet.proto</code> file in your gRPC service project, and select <a id="_idIndexMarker969"/>it. Ensure the <strong class="bold">client</strong> option is selected from the dropdown list. Then, click <strong class="bold">Finish</strong>.</li>
				<li>The dialog will change to <strong class="bold">Service reference configuration progress</strong>. When you get a message stating <strong class="bold">Successfully added service reference(s)</strong>, click the <strong class="bold">Close</strong> button. Your gRPC connected service will now appear in the <strong class="bold">Service References</strong> section of the <strong class="bold">Connected Services</strong> tab, as shown here:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_9.8.jpg" alt="Figure 9.8 – The Connected Services tab displaying our connected gRPC service&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – The Connected Services tab displaying our connected gRPC service</p>
			<p>With that, you have added a client project to your gRPC service. With the client projected added, we can <a id="_idIndexMarker970"/>now write the console applications. Follow these steps:</p>
			<ol>
				<li value="7">Open the <code>CH09_GrpcServiceClient.csproj</code> file by selecting it in the Solution Explorer. You should see the following XML:<pre>&lt;Project Sdk=”Microsoft.NET.Sdk”&gt;
&lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
&lt;/PropertyGroup&gt;
&lt;ItemGroup&gt;
    &lt;PackageReference Include=”Google.Protobuf” 
        Version=”3.13.0” /&gt;
    &lt;PackageReference Include=”Grpc.Net.ClientFactory” 
        Version=”2.32.0” /&gt;
    &lt;PackageReference Include=”Grpc.Tools” 
        Version=”2.32.0”&gt;
        &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
        &lt;IncludeAssets&gt;runtime; build; native; 
            contentfiles; analyzers; 
            buildtransitive&lt;/IncludeAssets&gt;
    &lt;/PackageReference&gt;
&lt;/ItemGroup&gt;
&lt;ItemGroup&gt;
    &lt;Protobuf 
        Include=”..\CH09_GrpcService\Protos\greet.proto”
        GrpcServices=”Client”&gt;
        &lt;Link&gt;Protos\greet.proto&lt;/Link&gt;
    &lt;/Protobuf&gt;
&lt;/ItemGroup&gt;
&lt;/Project&gt;</pre></li>
			</ol>
			<p>In the preceding <a id="_idIndexMarker971"/>XML code, you can see the references to Google’s <code>Protobuf</code> library and the <code>gRPC</code> libraries. You will also see a Protobuf link to your proto file in the gRPC service, which indicates that your project is taking on the role of the client.</p>
			<ol>
				<li value="8">Open the <code>Program</code> class in your client project.</li>
				<li>Update the <code>Main(string[] args)</code> method, as follows:<pre>static async void Main(string[] args)
{
    await ExecuteGrpcClient();}</pre></li>
			</ol>
			<p>In our entry point method, we call the asynchronous <code>ExecuteGrpClient()</code> method. However, because <a id="_idIndexMarker972"/>we cannot mark our main method as async, we have to call <code>Wait()</code> on the <code>ExecuteGrpcClient()</code> method:</p>
			<pre>tatic async Task ExecuteGrpcClient()
{
GrpcChannel grpcChannel = 
    GrpcChannel.ForAddress(“https://localhost:5001”);
Greeter.GreeterClient greeterClient = 
    new Greeter.GreeterClient(grpcChannel);
HelloReply helloReply = 
    await greeterClient.SayHelloAsync(new HelloRequest
    {
        Name = “gRPC Demonstration!”
    });
Console.WriteLine(
    $”Message From gRPC Server: {helloReply.Message}”);
}</pre>
			<p>Because we will be awaiting an asynchronous call, we must make the <code>ExecuteGrpcClient()</code> method asynchronous with the async modifier. This method does not return anything. However, it cannot be declared void, so we must provide <code>Task</code> as the return type. Then, we must declare our gRPC channel by pointing it to our gRPC HTTPS address. Then, we must declare our client by passing in the gRPC channel we have just declared and initialized. Next, we must obtain a reply by <a id="_idIndexMarker973"/>awaiting our asynchronous call to our server method and passing in a message request where we set the properties as necessary. Finally, we must print the response from the server to the console window.</p>
			<ol>
				<li value="10">Open the server project in the terminal and type <code>dotnet run</code>. The server will be running locally on port 5001.</li>
				<li>Then, open the client project in the terminal window and type <code>dotnet run</code>. It will print the following message in the console window:</li>
			</ol>
			<pre>Message From gRPC Server: Hello gRPC Demonstration!</pre>
			<p>With that, you have successfully written a gRPC server and consumed its message by writing and running a gRPC client. So what? What does this mean for you? It means that you now have a cross-platform way of communication between different applications using a common protocol. And what is the big deal in this regard? Well, say that you have several legacy applications written in various languages and you want to migrate them all to a common platform and programming language such as .NET or C# – you now have a straightforward way to accomplish this.</p>
			<p>By using gRPC, you can provide a phased migration from legacy platforms to the .NET 5 and higher platforms and C# 9 and higher programming language. You would accomplish this by writing gRPC clients for your .NET clients and legacy clients. This would enable you to start using .NET and C# as you incrementally replace older systems. Then, gradually, as the older systems are replaced by one modern system, you can fully utilize .NET and C# and benefit from all the performance improvements the Microsoft teams have made to the language and framework. Plus, you can leverage all the business and performance benefits of using the Microsoft ecosystem, which includes the Microsoft Azure Cloud services that have been built with security, scalability, and performance in mind.</p>
			<p>At this point, it is worth noting the various languages that are officially supported by gRPC. The officially supported languages, operating systems, compilers, and SDKs are shown in the following table:</p>
			<div><div><img src="img/B16617_Table_9.3.jpg" alt="Table 9.3 – Officially supported languages by gRPC&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.3 – Officially supported languages by gRPC</p>
			<p>As we can see, gRPC is well <a id="_idIndexMarker974"/>supported across languages, operating systems, SDKs, and compilers. So, gRPC is the perfect networking technology to bring disparate systems together using one harmonious messaging framework. </p>
			<p>So far, you have consumed a unary request and know that gRPC can be used with various operating systems <a id="_idIndexMarker975"/>and programming languages. But what if you need to handle a whole batch of gRPC requests? How do we do that? Good question. We’ll learn how to do this in the next section.</p>
			<h3>Streaming multiple gRPC requests</h3>
			<p>In this section, we will be <a id="_idIndexMarker976"/>modifying our client and server gRPC projects to send and process message streams. By the end of this project, you will be sending 10 messages from the server to the client. On the client, you will process each message as it comes in and write it to the console window. To do so, follow these steps:</p>
			<ol>
				<li value="1">Update the <code>greet.proto</code> file in the <code>CH09_GrpcService</code> project, as follows:<pre>// The greeting service definition.
service Greeter {
// Sends a greeting
rpc SayHello (HelloRequest) returns (HelloReply);
rpc SayHelloStream(HelloRequest)
    returns (stream HelloReply);
}</pre></li>
			</ol>
			<p>You will see that you have added a new message stream to our service definition. Instead of returning a single <code>HelloReply</code> message, the message stream returns a stream of messages of the <code>HelloReply</code> type.</p>
			<ol>
				<li value="2">In the <code>GreeterService</code> class of the <code>CH09_GrpcServer</code> project, add the following method:<pre>public override async Task SayHelloStream(HelloRequest 
    request, IServerStreamWriter&lt;HelloReply&gt; 
        responseStream, ServerCallContext context)
{
    for (int i = 0; i &lt; 10; i++)
    {
    await responseStream.WriteAsync(new HelloReply
    {
        Message = $”Response Stream Message: {i}”
    });
    await Task.Delay(TimeSpan.FromSeconds(1));
}
}</pre></li>
			</ol>
			<p>In this method, you are iterating 10 times. For each iteration, you await the <code>responseStream.WriteAsync(HelloReply)</code> method. In this asynchronous call, you set the message on the <code>HelloReply</code> object. With each iteration taking only <a id="_idIndexMarker977"/>milliseconds, you will purposefully slow down the processing of the task for human eyes to see each method being written one after the other. This delay slows down your task by 10 seconds – a second for each iteration. In a normal application, you would normally not have such a delay in place.</p>
			<ol>
				<li value="3">Now that you have updated your server project, rebuild both projects to see the changes and move to your <code>CH09_GrpcServiceClient</code> project.</li>
				<li>In the <code>Program</code> class, move the code inside the <code>ExecuteGrpcClient()</code> method into its own method called <code>SingleGrpcMessageClient()</code>. Then, add the following two lines of code to the <code>ExecuteGrpcClient()</code> method:<pre>await SingleGrpcMessageResponse();
await GrpcMessageResponseStream();</pre></li>
			</ol>
			<p>The preceding code contains two asynchronous calls: one for a single message, and one for streaming multiple messages.</p>
			<ol>
				<li value="5">Add the <code>GrpcMessageResponseStream()</code> method:<pre>static async Task GrpcMessageResponseStream()
{
    GrpcChannel grpcChannel = 
        GrpcChannel.ForAddress(“https://localhost:5001”);
    Greeter.GreeterClient greeterClient = 
        new Greeter.GreeterClient(grpcChannel);
    AsyncServerStreamingCall&lt;HelloReply&gt; helloReply =   
        greeterClient.SayHelloStream(new HelloRequest
        {
            Name = “gRPC Streaming Demonstration!”
        });            
    await foreach (HelloReply item in 
        helloReply.ResponseStream.ReadAllAsync())
        {
            Console.WriteLine(item.Message);
        }        
}</pre></li>
			</ol>
			<p><code>GrpcMessageResponseStream()</code> creates a <code>GrpcChannel</code> and assigns it to a new client. A call is then made to a gRPC stream. This iterates through all the items in the stream <a id="_idIndexMarker978"/>that have been sent back to the client from the server, and then prints the message for each item to the console window.</p>
			<ol>
				<li value="6">Open each of the projects in their own terminals and type the <code>dotnet run</code> command. This will start the server and run the client. You should see the following console window output:<pre><strong class="bold">Message From gRPC Server: Hello gRPC Demonstration!</strong>
<strong class="bold">Response Stream Message: 0</strong>
<strong class="bold">Response Stream Message: 1</strong>
<strong class="bold">Response Stream Message: 2</strong>
<strong class="bold">Response Stream Message: 3</strong>
<strong class="bold">Response Stream Message: 4</strong>
<strong class="bold">Response Stream Message: 5</strong>
<strong class="bold">Response Stream Message: 6</strong>
<strong class="bold">Response Stream Message: 7</strong>
<strong class="bold">Response Stream Message: 8</strong>
<strong class="bold">Response Stream Message: 9</strong></pre></li>
			</ol>
			<p>You now know how <a id="_idIndexMarker979"/>to use gRPC with desktop applications. In the next section, you will learn how to use gRPC with Blazor.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor178"/>Programming a simple gRPC Blazor application</h2>
			<p><strong class="bold">Blazor</strong> is a web programming model. With Blazor, you can have server-side Blazor projects that you would <a id="_idIndexMarker980"/>write when you have sensitive information that you need <a id="_idIndexMarker981"/>to keep secret. You can have client-side Blazor projects when application performance is of the utmost importance. As part of an organization’s enterprise application, you have many different Blazor server-side and client-side applications working together as one.</p>
			<p>For gRPC to work with web projects, a wrapper called gRPC-Web has been developed. This enables you to have both gRPC-Web services and gRPC-Web clients. With gRPC-Web, it is possible to build end-to-end pipelines that are compatible with the HTTP/1.1 and HTTP/2 protocols. This provides a competitive edge over browser APIs that are unable to call gRPC HTTP/2, especially when you consider that not all .NET platforms have support for HTTP/2 via the <code>HttpClient</code> class. Another benefit of gRPC-Web is that you <a id="_idIndexMarker982"/>don’t have to use just TCP for <strong class="bold">Inter-Process Communication</strong> (<strong class="bold">IPC</strong>). For IPC, you <a id="_idIndexMarker983"/>can also use named pipes (UDP) and <strong class="bold">Unix domain sockets</strong> (<strong class="bold">UDS</strong>). </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The default template app for Blazor has a fetch data page that uses JSON for its data backend. The data size for this JSON file is 627 bytes. But when JSON is replaced with gRPC, the size of the data is reduced to 309 bytes. This example shows that data transfer is quicker using gRPC-Web than it is using JSON, as there is not so much data to transmit and receive over the network. The reduced size of the data transmission using gRPC-Web means that more requests can be made over the network before the requests need to be throttled.</p>
			<p>In .NET 6.0, applications are made smaller via aggressive trimming. You can aggressively trim gRPC-based <a id="_idIndexMarker984"/>applications to reduce their size and increase their performance, especially when it comes to sending data over networks. This is because of the in-built code generation that is part of gRPC.</p>
			<p>In web projects, gRPC cannot be directly accessed. Therefore, a proxy project known as gRPC-Web was introduced to enable the use of gRPC with web projects.</p>
			<p>In the following sections, we will be writing a Blazor client and Server gRPC application consisting of a Blazor Server Application and a Blazor WebAssembly Application. Let’s begin.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor179"/>The blank solution</h2>
			<p>We need to <a id="_idIndexMarker985"/>start with a blank solution:</p>
			<ol>
				<li value="1">Open Visual Studio and search for <code>Blank Solution</code>.</li>
				<li>Create the blank solution and name it <code>CH09_BlazorGrpc</code>.</li>
			</ol>
			<p>This will provide a blank solution to which we can add our client and server Blazor applications. Next, we will work on our client project.</p>
			<h3>The Blazor client project</h3>
			<p>In this section, we will <a id="_idIndexMarker986"/>build our Blazor client gRPC application. Follow these steps:</p>
			<ol>
				<li value="1">Add a new <code>CH09_BlazorGrpc.Client</code>.</li>
				<li>Add the following NuGet packages:<ol><li><code>Google.Protobuf</code></li><li><code>Grpc.Net.Client</code></li><li><code>Grpc.Net.Client.Web</code></li><li><code>Grpc.Tools</code></li></ol></li>
				<li>Add a folder called <code>Protos</code> and a file to that folder called <code>person.proto</code>.</li>
				<li>Open the <code>person.proto</code> file and add the following code:<pre>syntax = “proto3”;
option csharp_namespace = “CH09_BlazorGrpc.Client”;
package grpcpeople;
service Person {
  rpc GetPeople (PeopleRequest) returns (PeopleResponse);
}
message PeopleRequest {
}
message PeopleResponse{
        repeated PersonResponse people = 1;
}
message PersonResponse {
     string name = 1;
}</pre></li>
			</ol>
			<p>Our proto file defines the proto definition version as proto3. So, the <code>proto3</code> syntax will be used. The namespace for our service definition is <code>CH09_BlazorGrpc.Client</code>. The name that’s been given to our package is <code>grpcpeople</code>. There are three messages called <code>PeopleRequest</code>, <code>PeopleResponse</code>, and <code>PersonResponse</code>. Finally, we define our service as <code>Person</code> with an RPC called <code>GetPeople</code> that takes a <code>PeopleRequest</code> and returns a <code>PeopleResponse</code>.</p>
			<ol>
				<li value="5">Add the <a id="_idIndexMarker987"/>following imports to the <code>_Imports.razor</code> file:<pre>@using CH09_BlazorGrpc.Client
@using CH09_BlazorGrpc.Client.Shared
@using Grpc.Net.Client;
@using Grpc.Net.Client.Web;</pre></li>
			</ol>
			<p>These imports will be available to all our files.</p>
			<ol>
				<li value="6">Locate the <code>Pages</code>/<code>Index.razor</code> page and replace its contents with the following code:<pre>@page “/”
@using CH09_BlazorGrpc.Client
&lt;<strong class="bold">PageTitle</strong>&gt;Index&lt;/<strong class="bold">PageTitle</strong>&gt;
&lt;h1&gt;People from Grpc Service&lt;/h1&gt;
@foreach(var person in model.People)
{
    &lt;p&gt;Name : @person.Name&lt;/p&gt;
}    
@code{
    private PeopleResponse model = new PeopleResponse();
    protected override async Task OnInitializedAsync()
    {
            using var channel = GrpcChannel.ForAddress
               (“https://localhost:7272/”, new 
                   GrpcChannelOptions
    {
        HttpHandler = new GrpcWebHandler(new 
            HttpClientHandler())
    });
            var client = new Person.PersonClient
                (channel);
            model = await client.GetPeopleAsync(
                              new PeopleRequest { });
    }
}</pre></li>
			</ol>
			<p>The preceding code will call the gRPC service that has been located by the service app <a id="_idIndexMarker988"/>and list the people that have been returned.</p>
			<p>That’s our client application completed. Now, let’s write our server application.</p>
			<h3>The Blazor server project</h3>
			<p>In this section, we <a id="_idIndexMarker989"/>will write our server application, which will contain our service responsible for returning the requested data to the client. Let’s begin:</p>
			<ol>
				<li value="1">Add a new Blazor Server app called <code>CH09_BlazorGrpc.Server</code>.</li>
				<li>Add the <code>Grpc.AspNetCore</code> and <code>Grpc.AspNetCore.Web</code> NuGet packages.</li>
				<li>Copy the <code>Protos</code> folder and its contents from the client project and paste it into the server project.</li>
				<li>Add the <code>PeopleService</code> class to the root of the server project.</li>
				<li>Replace the contents of the <code>PeopleService</code> class with the following code:<pre>namespace CH09_BlazorGrpc.Server;
using Grpc.Core;
using CH09_BlazorGrpc.Client;
public class PeopleService : Person.PersonBase
{
    public override async Task&lt;PeopleResponse&gt; 
        GetPeople(PeopleRequest request, 
            ServerCallContext context)
    {
        PeopleResponse response = new PeopleResponse();
        response.People.Add(new PersonResponse { Name = 
            “Person One” });
        response.People.Add(new PersonResponse { Name = 
            “Person Two” });
        response.People.Add(new PersonResponse { Name = 
            “Person Three” });
        return response;
    }
}</pre></li>
			</ol>
			<p>This service has a single method that returns a list of people.</p>
			<ol>
				<li value="6">Replace the <a id="_idIndexMarker990"/>code in the <code>Program.cs</code> file with the following:<pre>using CH09_BlazorGrpc.Server;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddGrpc(options =&gt;
{
    options.EnableDetailedErrors = true;
    options.MaxReceiveMessageSize = 2 * 1024 * 1024; 
    // 2 MB
    options.MaxSendMessageSize = 5 * 1024 * 1024; // 5 MB
});
builder.Services.AddCors(setupAction =&gt;
{
    setupAction.AddDefaultPolicy(policy =&gt;
    {
        policy.AllowAnyHeader().AllowAnyOrigin()
            .AllowAnyMethod()
          .WithExposedHeaders(“Grpc-Status”, 
               “Grpc-Message”, “Grpc-Encoding”, 
                   “Grpc-Accept-Encoding”);
    });
});
var app = builder.Build();
app.UseCors();
app.UseRouting();
app.UseGrpcWeb(new GrpcWebOptions { DefaultEnabled = 
    true });
app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapGrpcService&lt;PeopleService&gt;();
});
app.Run();</pre></li>
			</ol>
			<p>The preceding <a id="_idIndexMarker991"/>code configures our Blazor application to use gRPC and sets up our <code>PeopleService</code> class so that our client application can use it. We also configured <code>Cors</code> so that our gRPC requests and responses don’t get blocked.</p>
			<ol>
				<li value="7">Right-click on the solution and select <strong class="bold">Properties</strong>.</li>
				<li>Under <strong class="bold">Startup Project</strong>, select <strong class="bold">Multiple startup projects</strong> and change <strong class="bold">Action</strong> to <strong class="bold">Start</strong> for both the client and the server projects.</li>
				<li>Click on <strong class="bold">OK</strong> to close the property dialog.</li>
			</ol>
			<p>Run the project. Two browser and two console windows should open. If all goes well, then you should see the following browser window:</p>
			<div><div><img src="img/B16617_Figure_9.9.jpg" alt="Figure 9.9 – The client Blazor application showing the response from the gRPC service in the server app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – The client Blazor application showing the response from the gRPC service in the server app</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The port numbers depend on the ports that are available on a system. So, alternative ports will be used if ports 5000 and 5001 are already in use. This has happened here, in which port 7272 is being used for the server app and port 7108 is being used for the client app.</p>
			<p>With that, you have <a id="_idIndexMarker992"/>learned about desktop and web-based network data transmission and communication using gRPC and gRPC-Web, both of which have received several performance enhancements along with C# and .NET Framework. You have also used the Blazor server and Blazor WebAssembly to perform web data transmissions and receive data.</p>
			<p>You can use this information to replace your code that uses the JSON data format with the binary format of gRPC. This should cut down the size of your data transmissions and reduce the time it takes for the data to be transmitted and received, thus improving the performance of your networked applications – especially those applications that deal with huge<a id="_idTextAnchor180"/> volumes of data.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor181"/>Optimizing internet resources</h1>
			<p>The best web page is a web page that does the minimum it needs to present the necessary data that you <a id="_idIndexMarker993"/>want your users to view. Noisy web pages take longer to load and can be a source of irritation to your end users.</p>
			<p>When you use advert services and analytical and health monitoring services, these can produce unnecessary network traffic and an increase in page load time. So, you need to be concise in what data you gather regarding the page that is loading. You also need to reduce the number of resources that your page is downloading. Some of these resources will be explained here. </p>
			<h3>Images</h3>
			<p><strong class="bold">Images</strong> are one of the resources that can significantly increase the time it takes to load a page. Therefore, it is important <a id="_idIndexMarker994"/>to use the right image format and <a id="_idIndexMarker995"/>compression for your images. It is often necessary to <a id="_idIndexMarker996"/>reduce the file size of images. Images usually come in three file <a id="_idIndexMarker997"/>formats: <strong class="bold">JPEG/JPG</strong>, <strong class="bold">PNG</strong>, and <strong class="bold">GIF/animated GIF</strong>. When it comes to image optimization, you are best off experimenting based on your website requirements. This is because you will need to factor in the tradeoff between image quality and image size, depending on your specific requirements.</p>
			<p>An example of a tool that you <a id="_idIndexMarker998"/>can use for PNG optimization is PNGGauntlet by Ben Hollis: <a href="https://pnggauntlet.com/">https://pnggauntlet.com/</a>. This tool creates small PBGs by combining PNGOUT, OptiPNG, and DeflOpt with no loss of image quality. It can also convert the JPG, GIF, TIFF, and BMP file formats into PNG. You can configure the tool to your liking.</p>
			<h3>Text characters</h3>
			<p>When transmitting text over the internet, the more characters you have, the larger the file you will have. As <a id="_idIndexMarker999"/>a page grows, the time to load that page increases. You can reduce the size of each request and response by enabling deflate or <code>gzip</code> compression. Most, if not all, web servers provide web compression. You will have to look at how to enable web compression in the web server that you are using.</p>
			<p>You can also reduce the size of your HTML, CSS, and JavaScript files in production by using minification. During development, when you have reached the stage where you are ready to deploy your application, you can employ tools such as webpack that will condense your files by removing unnecessary whitespace, comments, and unused code. Tools such as webpack can drastically reduce the size of your files. </p>
			<p>This size reduction results in less data being transmitted over a network, meaning that the files a user has <a id="_idIndexMarker1000"/>requested get downloaded on their device much faster. The quicker that requested files are downloaded to a user’s device, the quicker the requested page will be rendered for them to view.</p>
			<h3>Data transmission</h3>
			<p>Transmitting data over a network takes time. That time can vary based on several different factors, such <a id="_idIndexMarker1001"/>as the amount of network traffic and the route taken. Not all networks use fiber optic, and there are still locations over the internet that are still on slow copper wire connections.</p>
			<p>One way to reduce network traffic and load time for networked resources is to <strong class="bold">cache</strong> them on the user’s computer that requested the resource. When a network resource is requested, the application will check if it exists in the cache. If it does, then the item will be retrieved from the cache on the user’s computer. But if the item is not in the cache, it will be downloaded over the network and stored in the user’s cache. When an item is being retrieved from the cache, the expiration date and time will be checked for the resource. If the expiry date and time have been reached, then the resource will be downloaded from over the network.</p>
			<p>Also, when working with large volumes of data, it is best to filter the data on the server and only return the subset of the data that you require. If the amount of data that you require is quite large, then employ data paging, whereby the data is divided into pages. Then, you only need to download a page as it is requested. This reduces the time it takes to receive the data once the request has been made. </p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor182"/>Using pipelines for content streaming</h1>
			<p><code>System.IO.Pipelines</code> is <a id="_idIndexMarker1002"/>a high-performance I/O .NET library <a id="_idIndexMarker1003"/>that was first shipped with .NET Core 2.1 and was born from performance work carried out by the Kestrel team. The purpose behind pipelines is to reduce the complexity of correctly parsing stream and socket data.</p>
			<p>In this section, we will learn how to use pipelines with sockets. We will write to small console applications. The first console application will listen for incoming requests on port <code>7000</code> and output the contents to the console window. The second console application will listen <a id="_idIndexMarker1004"/>for the newline key. When it is detected, it will <a id="_idIndexMarker1005"/>send the contents of the command line to the server on port <code>7000</code>. By completing this project, you will see how easy it is to write a network communication application with a minimal number of lines of code using pipes and sockets.</p>
			<p>Let’s start by writing our server console app.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor183"/>Writing and running a TCP server console application</h2>
			<p>In this section, we <a id="_idIndexMarker1006"/>will use sockets and pipelines to write a <a id="_idIndexMarker1007"/>console application that listens for incoming data on port <code>7000</code>. When data is received, it is processed and output to the console window. To write a TCP server console application, follow these steps:</p>
			<ol>
				<li value="1">Start a new .NET 6.0 Console Application called <code>CH09_TcpServer</code>.</li>
				<li>Add the <code>System.IO.Pipelines</code> NuGet package.</li>
				<li>Add a new class called <code>SocketExtensions</code>:<pre>using System;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
internal static class SocketExtensions
{
}</pre></li>
			</ol>
			<p>This is our <code>SocketExtensions</code> class, which we will build up with extension methods to simplify our socket code.</p>
			<ol>
				<li value="4">Add the <code>ReceiveAsync</code> extension method:<pre>public static Task&lt;int&gt; ReceiveAsync(this Socket socket, 
    Memory&lt;byte&gt; memory, SocketFlags socketFlags)
{
    ArraySegment&lt;byte&gt; arraySegment = GetArray(memory);
return SocketTaskExtensions.ReceiveAsync(socket, 
    arraySegment, socketFlags);
}</pre></li>
			</ol>
			<p>This method <a id="_idIndexMarker1008"/>extends a socket to delimit a section <a id="_idIndexMarker1009"/>of a one-dimensional array. It receives data from a connected socket and returns a <code>Task</code> that represents the asynchronous receive operation.</p>
			<ol>
				<li value="5">Add the <code>GetString</code> extension method:<pre>public static string GetString(this Encoding encoding, 
    ReadOnlyMemory&lt;byte&gt; memory)
{
    ArraySegment&lt;byte&gt; arraySegment = GetArray(memory);
     return encoding.GetString(arraySegment.Array, 
         arraySegment.Offset, arraySegment.Count);
}</pre></li>
			</ol>
			<p>This method extends a socket to delimit a section of a one-dimensional array. Then, it decodes a sequence of bytes into a string and returns the decoded string.</p>
			<ol>
				<li value="6">Add the <code>GetArray</code> method:<pre>private static ArraySegment&lt;byte&gt; GetArray(Memory&lt;byte&gt; 
    memory)
{
return GetArray((ReadOnlyMemory&lt;byte&gt;)memory);
}</pre></li>
			</ol>
			<p>This method <a id="_idIndexMarker1010"/>gets contiguous memory and <a id="_idIndexMarker1011"/>returns a delimited section of a one-dimensional array.</p>
			<ol>
				<li value="7">Add the final extension method – that is, <code>GetArray</code>:<pre>private static ArraySegment&lt;byte&gt; GetArray
    (ReadOnlyMemory&lt;byte&gt; memory)
{
if (!MemoryMarshal.TryGetArray(memory, out var result))
{
    throw new InvalidOperationException(“Buffer backed by 
        array was expected”);
}
return result;
}</pre></li>
			</ol>
			<p>This method tries to get a segment from the underlying memory buffer. The return <a id="_idIndexMarker1012"/>value indicates the success of the <a id="_idIndexMarker1013"/>operation. A delimited segment of a one-dimensional array is returned.</p>
			<ol>
				<li value="8">Switch to the <code>Program</code> class.</li>
				<li>Replace the <code>Program.cs</code> file’s source code with the following code:<pre>using CH09_TcpServer;
using System;
using System.Buffers;
using System.IO.Pipelines;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.tasks;
Socket listenSocket = new Socket(SocketType.Stream, 
    ProtocolType.Tcp);
listenSocket.Bind(new IPEndPoint(IPAddress.Loopback, 
    7000));
Console.WriteLine(“Listening on port 7000”);
listenSocket.Listen(120);
while (true)
{
    Socket socket = await listenSocket.AcceptAsync();
    _ = ProcessLinesAsync(socket);
}</pre></li>
			</ol>
			<p>Our top-level <a id="_idIndexMarker1014"/>code creates a socket on <a id="_idIndexMarker1015"/>port <code>7000</code>. Then, it listens for incoming data on port <code>7000</code> and processes the data.</p>
			<ol>
				<li value="10">Add the <code>ProcessLinesAsync</code> method:<pre>tatic async Task ProcessLinesAsync(Socket socket)
{
Console.WriteLine($”[{socket.RemoteEndPoint}]: 
    connected”);
NetworkStream stream = new NetworkStream(socket);
PipeReader reader = PipeReader.Create(stream);
while (true)
{
    ReadResult result = await reader.ReadAsync();
    ReadOnlySequence&lt;byte&gt; buffer = result.Buffer;
    while (TryReadLine(ref buffer, out 
        ReadOnlySequence&lt;byte&gt; line))
        ProcessLine(line);    reader.AdvanceTo
            (buffer.Start, buffer.End);
    if (result.IsCompleted)
        break;
}
    await reader.CompleteAsync();
        Console.WriteLine($”[{socket.RemoteEndPoint}]:
            disconnected”);
}</pre></li>
			</ol>
			<p>With this method, we pass in a socket. The socket is assigned to a new <code>NetworkStream</code> object. Then, the new <code>NetworkStream</code> object is passed into a new <code>PipeReader</code> object. While there is data to be read, we read and process <a id="_idIndexMarker1016"/>each line in the stream in turn. Once the <a id="_idIndexMarker1017"/>stream has been completely read from start to finish, we mark the reader as complete so that no more data will be read from it.</p>
			<ol>
				<li value="11">Now, add the <code>TryReadLine</code> method:<pre>static bool TryReadLine(ref ReadOnlySequence&lt;byte&gt; 
    buffer, out ReadOnlySequence&lt;byte&gt; line)
{
SequencePosition? position = buffer.PositionOf
    ((byte)’\n’);
if (position == null)
{
    line = default;
    return false;
}
            line = buffer.Slice(0, position.Value);
            buffer = buffer.Slice(buffer.GetPosition
                (1, position.Value));
            return true;
        }</pre></li>
			</ol>
			<p>This method attempts to read a line of a <code>ReadOnlySequence</code> of bytes. If is unable to, it will return false. But if it can, it will set the line it can read as a <code>ReadOnlySequence</code> of bytes and return true.</p>
			<ol>
				<li value="12">Add our <a id="_idIndexMarker1018"/>final method for our TCP Server <a id="_idIndexMarker1019"/>called <code>ProcessLine</code>:<pre>static void ProcessLine(in ReadOnlySequence&lt;byte&gt; buffer)
{
foreach (ReadOnlyMemory&lt;byte&gt; segment in buffer)
{         
    Console.Write(Encoding.UTF8.GetString(segment.Span));
}
Console.WriteLine();
}</pre></li>
			</ol>
			<p>All we are doing here is printing the contents of the stream to the console window line by line.</p>
			<ol>
				<li value="13">Run the program. You should see something similar to the following:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_9.12.jpg" alt="Figure 9.10 – The TCP Server in a running state ready to receive connections on port 7000&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – The TCP Server in a running state ready to receive connections on port 7000</p>
			<p>You now have your TCP Server project up and running. The next step in developing your understanding of pipelines is to write our TCP Client project. We will do this in the next section.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor184"/>Writing and running a TCP client console application</h2>
			<p>In this section, we <a id="_idIndexMarker1020"/>will continue looking at pipelines by <a id="_idIndexMarker1021"/>writing the TCP client console application that will be sending console input to the TCP Server. The data received by the TCP Server from our TCP client will be displayed in the TCP Server’s window:</p>
			<ol>
				<li value="1">Start a new .NET 6.0 Console Application called <code>CH09_TcpClient</code>.</li>
				<li>In the <code>Program.cs</code> file, you will need to include the following namespaces:<pre>using System;
using System.IO;
using System.IO.Pipelines;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;</pre></li>
			</ol>
			<p>We will need these namespaces for our TCP Client to read the console input and send it to the TCP Server for processing.</p>
			<ol>
				<li value="3">Add the following top-level statements:<pre>Socket clientSocket = new Socket(SocketType.Stream, 
    ProtocolType.Tcp);
Console.WriteLine(“Connecting to port 7000”);
clientSocket.Connect(new IPEndPoint(IPAddress.Loopback, 
    7000));
NetworkStream networkStream = new NetworkStream
    (clientSocket);
await Console.OpenStandardInput().CopyToAsync
    (networkStream);</pre></li>
			</ol>
			<p>For our TCP Client, we simply open a new TCP socket on port <code>7000</code> and connect using the <code>IPAddress.Loopback</code> address. Then, we pass the socket into a new <code>NetworkStream</code>. Finally, we listen for input from the console window’s standard input <a id="_idIndexMarker1022"/>and copy that input to the network <a id="_idIndexMarker1023"/>stream that transmits the data to our TCP Server for processing.</p>
			<ol>
				<li value="4">Run the program. You should see the following:</li>
			</ol>
			<div><div><img src="img/Image87742.jpg" alt="Figure 9.11 – The TCP Client listening on port 7000&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – The TCP Client listening on port 7000</p>
			<ol>
				<li value="5">Type <code>Hello, World!</code> and press <em class="italic">Enter</em>. Your TCP Client console application should look as follows:</li>
			</ol>
			<div><div><img src="img/Image87751.jpg" alt="Figure 9.12 – The TCP Client console window displaying user input&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – The TCP Client console window displaying user input</p>
			<ol>
				<li value="6">Observe the TCP Server console window. You will see that the message <strong class="bold">Hello, World!</strong> has appeared since you typed the same message in the TCP Client window and pressed <em class="italic">Enter</em>, as shown here:</li>
			</ol>
			<div><div><img src="img/Image87759.jpg" alt="Figure 9.13 – The TCP Server console window displaying the response from the TCP Client&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – The TCP Server console window displaying the response from the TCP Client</p>
			<p>With that, you have finished writing and running the TCP client and server console applications, and you have seen just how simple it is to write a console application with sockets and pipelines. The code is very minimal and you can chain multiple pipelines together. For example, on <a id="_idIndexMarker1024"/>the client end, a chained pipeline could <a id="_idIndexMarker1025"/>be the serialization of an object followed by its encryption. Then, at the server end, the data could be decrypted and deserialized, and the resulting object could then be passed to LINQ, which would save the data contained in the object to a database. We can use sockets and pipelines with most C# project types, and you are encouraged to experiment with your own little projects to further your knowledge.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor185"/>Caching resources in memory</h1>
			<p><strong class="bold">Caching</strong> items in memory <a id="_idIndexMarker1026"/>requires RAM to be allocated so that they <a id="_idIndexMarker1027"/>can be stored and retrieved efficiently. Storing frequently accessed resources in memory greatly improves the performance of applications.</p>
			<p>A typical application that benefits from caching is a website. A traditional website will consist of HTML pages that define the structure of the visual web page that’s displayed to end users, CSS, which styles the page and makes it look nice, and JavaScript, which makes websites dynamic and interactive.</p>
			<p>Many pages of a website can use the same resources, such as data, images, sounds, files, and objects. Caching – temporarily storing some item so that it can be retrieved efficiently – can be done with a database, filesystem, or memory.</p>
			<p>In this section, we will learn how to store items in memory. Microsoft recommends the use of their <code>Microsoft.Extensions.Caching.Memory</code> NuGet package for caching items in memory. Therefore, we will follow their guidance and use this library in our example project.</p>
			<p>We will be creating a very simple ASP.NET Core website that displays the current time and the cached time. When the cached time has expired, we will reset the cache. Each time the home view is called, we will output some text to the immediate window that displays the current time, the cached time, and the time difference in seconds. </p>
			<p>After each specified period has elapsed, you will see that the cache is reset, along with the time that’s output <a id="_idIndexMarker1028"/>to the screen after the page refresh. To write <a id="_idIndexMarker1029"/>our ASP.NET Core MVC web application, follow these steps:</p>
			<ol>
				<li value="1">Start a new empty ASP.NET Core MVC Web Application, ensuring that your target framework is <code>net6.0</code> and called <code>CH09_AspNetCoreCaching</code>.</li>
				<li>Add the <code>Microsoft.Extensions.Caching.Memory</code> NuGet package, and then add the <code>using</code> statement for this package to the <code>HomeController</code> class.</li>
				<li>Add an <code>IMemoryCache</code> member variable and update the <code>HomeController</code> constructor, as follows:<pre>private IMemoryCache _memoryCache;
public HomeController(ILogger&lt;HomeController&gt; logger, 
    IMemoryCache memoryCache)
{
    _logger = logger;
    _memoryCache = memoryCache;
}</pre></li>
			</ol>
			<p>Our <code>_memoryCache</code> variable will hold our cache in memory. The object that’s being used as our memory cache is injected into the <code>HomeController</code> constructor as a parameter and assigned to our variable.</p>
			<ol>
				<li value="4">Next, add the <code>SetCache</code> method:<pre>private void SetCache(string key, object value)
{
    var cachedEntryOptions = 
     new MemoryCacheEntryOptions()
         .SetSlidingExpiration(TimeSpan.FromSeconds(20));
     _memoryCache.Set(key, value, cachedEntryOptions);
}</pre></li>
			</ol>
			<p>This method accepts a key and a value. We set our <code>MemoryCacheEntryOptions</code> with a sliding expiration of 20 seconds and then set the cached entry’s value, which will expire in 20 seconds.</p>
			<ol>
				<li value="5">The next <a id="_idIndexMarker1030"/>thing we need to do is update the <code>HomeController</code> constructor’s <code>Index</code> method, as <a id="_idIndexMarker1031"/>shown here:<pre>public IActionResult Index()
{
     DateTime whenCached;
    bool exists = _memoryCache.TryGetValue(“WhenCached”, 
        out whenCached);
    if (!exists)
    {
        Debug.WriteLine(“Creating cached entry...”);
        whenCached = DateTime.Now;
        SetCache(“WhenCached”, whenCached);
    }
    else
    {
         DateTime now = DateTime.Now;
        double differenceInSeconds = 
            now.Subtract(whenCached).TotalSeconds;
        if (differenceInSeconds &lt; 20)
        {
            Debug.WriteLine($”Now: {now}, When Cached: 
                {whenCached}, Time Difference (Seconds): 
                    {differenceInSeconds}”);
            return View(whenCached);
        }
        else
        {
            Debug.WriteLine(“Resetting cache...”);
            whenCached = DateTime.Now;
            SetCache(“WhenCached”, whenCached);
        }
    }
    return View(whenCached);
}</pre></li>
			</ol>
			<p>The preceding code declares a <code>DateTime</code> variable called <code>whenCached</code>. It checks if the value exists. If it does, its value will be set to the time when the variable was <a id="_idIndexMarker1032"/>cached. If the variable does not exist, then it <a id="_idIndexMarker1033"/>will be added to the cache. If it does exist, then the difference in time between now and when the variable was cached is calculated, and the results will be output to the debug window if the cache has not expired. If the cache has expired, then the cached variable will be updated with the current time.</p>
			<ol>
				<li value="6">Now, we need to update our Home view’s HTML code, as follows:<pre>@model DateTime?
@{
    ViewData[“Title”] = “Index”;
}
&lt;h1&gt;Index&lt;/h1&gt;
&lt;div class=”row”&gt;
    &lt;span&gt;
        When Cached: @Model.Value.ToString();
    &lt;/span&gt;
    &lt;span&gt;
        Current Time: @DateTime.Now.ToString();
    &lt;/span&gt;
&lt;/div&gt;</pre></li>
			</ol>
			<p>The preceding code defines our model for the Razor page. The title of our page is set to <code>Index</code>. Our main page title is <code>Index</code>. Finally, we have a row that defines when the variable was cached and the current time.</p>
			<ol>
				<li value="7">Now, we <a id="_idIndexMarker1034"/>need to update our <code>Program.cs file</code> to inform <a id="_idIndexMarker1035"/>our website to use memory caching:<pre>builder.Services.AddControllersWithViews();
builder.<strong class="bold">Services.AddMemoryCache();</strong></pre></li>
			</ol>
			<p>With that, our services have been configured to use the memory cache.</p>
			<p>With that, we have configured our MVC application to use memory caching with sliding expiration. This means that we are now ready to run our project. Run the project and refresh a few times within 20 seconds, and then watch what happens. You will see that the cached and current times start the same. Then, when you refresh the page, you will see that the cached time remains the same, but the current time is ahead of the cached time. Then, when 20 seconds is over, the cached time will be updated in sync with the current time, as shown here:</p>
			<div><div><img src="img/B16617_Figure_9.14.jpg" alt="Figure 9.14 – ASP.NET Core MVC memory caching example in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – ASP.NET Core MVC memory caching example in action</p>
			<p>As you can see from the preceding screenshot and by running the code, we now have a way of storing items <a id="_idIndexMarker1036"/>in a computer’s memory cache, and we can determine <a id="_idIndexMarker1037"/>when its cache value expires and has to be updated. This is a really simple way to improve a networked application’s network performance. It also reduces the amount of data that is transmitted over a network. This, in turn, helps reduce bandwidth problems and reduces transaction and network traffic costs for cloud-hosted operations.</p>
			<p>That concludes this chapter. Now, let’s summarize what we have learned from working through this chapter.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor186"/>Summary</h1>
			<p>In this chapter, you studied the OSI reference model to understand the different layers of a network and the various protocols available for each layer. You also learned that the various protocols can be grouped into two main groups: TCP and UDP.</p>
			<p>Then, you learned about web browser development tools, which allow you to monitor your website’s activities, such as memory usage and network traffic. You also saw the errors it raises via the console window. This can help identify problems and resolve them.</p>
			<p>From there, you learned how to add gRPC for desktop clients and servers, and gRPC-Web for web-based clients and servers. You learned that gRPC helps reduce the size of data compared to the JSON data format, thus reducing page load time.</p>
			<p>After that, you learned how to optimize internet resources. This includes using the correct file format and reducing the size of images, caching items to reduce network traffic and load times, reducing the number of background services that are running, and limiting the number of resources that your page loads. You also considered filtering data on the server and dividing it into pages that are returned as requested.</p>
			<p>Finally, you learned how to write and run TCP client and server console applications before looking at memory caching, in which you can use ASP.NET Core MVC as your host project.</p>
			<p>In the next chapter, we will be working with data by benchmarking different methods for inserting, updating, and deleting data efficiently. This will help us choose the best method for data operations based on our benchmark results. But before we do that, take some time to go through the <em class="italic">Further reading</em> section to further your knowledge on improving network performance. Also, try your hand at the questions to see how much knowledge you have retained.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor187"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">Name the seven layers of the OSI reference model.</li>
				<li>Name some network protocols.</li>
				<li>What is the difference between TCP/IP and UDP?</li>
				<li>How can you see what errors are produced by your web page, what network traffic it produces, and how much memory it uses?</li>
				<li>What are gRPC and gRPC-Web?</li>
				<li>How you can optimize internet resources?</li>
			</ol>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor188"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>OSI seven layers model explained with examples: <a href="https://www.computernetworkingnotes.com/ccna-study-guide/osi-seven-layers-model-explained-with-examples.html#:~:text=The%20OSI%20(Open%20System%20Interconnection)%20Reference%20Model%20is,and%20software%20applications%20which%20work%20in%20dissimilar%20en">https://www.computernetworkingnotes.com/ccna-study-guide/osi-seven-layers-model-explained-with-examples.html#:~:text=The%20OSI%20(Open%20System%20Interconnection)%20Reference%20Model%20is,and%20software%20applications%20which%20work%20in%20dissimilar%20environments</a></li>
				<li>TCP/IP model: <a href="https://ipcisco.com/lesson/tcp-ip-model/">https://ipcisco.com/lesson/tcp-ip-model/</a></li>
				<li>Overview of common TCP and UDP default ports: <a href="https://www.examcollection.com/certification-training/network-plus-overview-of-common-tcp-and-udp-default-ports.html#:~:text=%20Overview%20of%20common%20TCP%20and%20UDP%20default,FTP%20is%20to%20transfer%20files%20over...%20More">https://www.examcollection.com/certification-training/network-plus-overview-of-common-tcp-and-udp-default-ports.html#:~:text=%20Overview%20of%20common%20TCP%20and%20UDP%20default,FTP%20is%20to%20transfer%20files%20over...%20More</a></li>
				<li>List of TCP and UDP port numbers: <a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a></li>
				<li>Internet protocol suite: <a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">https://en.wikipedia.org/wiki/Internet_protocol_suite</a></li>
				<li>.NET network tracing: <a href="https://www.shanebart.com/dotnet-network-tracing/">https://www.shanebart.com/dotnet-network-tracing/</a></li>
				<li>dotnet-trace instructions: <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md">https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md</a></li>
				<li>How to view and kill processes using the Terminal in Mac OS X: <a href="https://www.chriswrites.com/how-to-view-and-kill-processes-using-the-terminal-in-mac-os-x/">https://www.chriswrites.com/how-to-view-and-kill-processes-using-the-terminal-in-mac-os-x/</a></li>
				<li>How to find a process name using a PID number in Linux: <a href="https://www.tecmint.com/find-process-name-pid-number-linux/">https://www.tecmint.com/find-process-name-pid-number-linux/</a></li>
				<li>High-performance services with gRPC – what’s new in .NET 5: <a href="https://www.youtube.com/watch?v=EJ8M2Em5Zzc">https://www.youtube.com/watch?v=EJ8M2Em5Zzc</a></li>
				<li>gRPC-Web with .NET: <a href="https://www.youtube.com/watch?v=UV-VnlcpDhU">https://www.youtube.com/watch?v=UV-VnlcpDhU</a></li>
				<li>.NET Conf 2021 new Blazor WebAssembly capabilities in .NET 6: https://www.youtube.com/watch?v=kesUNeBZ1Os&amp;list=PLdo4fOcmZ0oVFtp9MDEBNb A2sSqYvXSXO&amp;index=20</li>
				<li>.NET Conf 2021 high-performance services with gRPC – what’s new in .NET 6: <a href="https://www.youtube.com/watch?v=CXH_jEa8dUw&amp;list=PLdo4fOcmZ0oVFtp9MDEBNbA2sSqYvXSXO&amp;index=31">https://www.youtube.com/watch?v=CXH_jEa8dUw&amp;list=PLdo4fOcmZ0oVFtp9MDEBNbA2sSqYvXSXO&amp;index=31</a></li>
				<li>Everything about Blazor: <a href="https://codewithmukesh.com/blog/category/dotnet/blazor/">https://codewithmukesh.com/blog/category/dotnet/blazor/</a></li>
			</ul>
		</div>
	</body></html>