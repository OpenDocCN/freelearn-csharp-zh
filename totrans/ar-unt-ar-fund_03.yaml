- en: '*Chapter 2*: Your First AR Scene'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：您的第一个AR场景'
- en: Creating a simple Augmented Reality (AR) scene is quite simple with Unity AR
    Foundation. The steps involved might only take a page or two. However, when we
    create a scene together in this chapter, each step will be explained in context
    so that you can gain a full understanding of what comprises an AR scene using
    AR Foundation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity AR基础创建一个简单的增强现实（AR）场景相当简单。涉及的步骤可能只需要一页或两页。然而，在本章中，我们将一起创建一个场景，每个步骤都将结合上下文进行解释，以便您能够全面了解使用AR基础构建的AR场景。
- en: But before we do that, we'll take a look at some AR examples provided by Unity,
    including the AR Foundation Samples project, and build their example scenes for
    your device. And because that project contains some useful assets, we'll export
    those as an asset package for reuse in our own projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，我们将查看Unity提供的某些AR示例，包括AR基础示例项目，并为您的设备构建它们的示例场景。由于该项目包含一些有用的资产，我们将将其导出为资产包，以便在您自己的项目中重复使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building and running the AR Foundation Samples project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行AR基础示例项目
- en: Exporting and importing sample assets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出和导入示例资产
- en: Constructing a new Unity AR scene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建新的Unity AR场景
- en: Introduction to C# programming and the MonoBehaviour class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#编程和MonoBehaviour类的介绍
- en: Using AR raycast to place an object on a plane
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AR射线投射将对象放置在平面上
- en: Instantiating a GameObject
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化GameObject
- en: Creating and editing prefabs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和编辑预制件
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To implement the project provided in this chapter, you will need Unity installed
    on your development computer, connected to a mobile device that supports augmented
    reality applications (see [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*,
    Setting Up for AR Development*, for instructions). The completed project can be
    found in this book's GitHub repository at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现本章提供的项目，您需要在您的开发计算机上安装Unity，并将其连接到支持增强现实应用程序的移动设备（有关说明，请参阅[*第一章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*，为AR开发设置*）。完成的项目可在此书的GitHub存储库中找到：[https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)。
- en: Exploring the AR Foundation example projects from Unity
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Unity的AR基础示例项目
- en: 'A great way to learn about how to create AR projects with Unity AR Foundation
    is to explore the various example projects from Unity. These projects include
    example scenes, scripts, prefabs, and other assets. By cloning a project and opening
    an example scene, you can learn how to use AR Foundation, experiment with features,
    and see some best practices. In particular, consider these projects:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用Unity AR基础创建AR项目的一个好方法是探索Unity的各种示例项目。这些项目包括示例场景、脚本、预制件和其他资产。通过克隆一个项目并打开一个示例场景，您可以学习如何使用AR基础，尝试功能，并了解一些最佳实践。特别是，请考虑以下项目：
- en: '*AR Foundation Samples*: [https://github.com/Unity-Technologies/arfoundation-samples](https://github.com/Unity-Technologies/arfoundation-samples).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AR基础示例*：[https://github.com/Unity-Technologies/arfoundation-samples](https://github.com/Unity-Technologies/arfoundation-samples)。'
- en: '*AR Foundation Demos*: [https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AR基础演示*：[https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos)。'
- en: '*XR Interaction Toolkit Examples*: [https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/tree/master/AR](https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/tree/master/AR).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*XR交互工具包示例*：[https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/tree/master/AR](https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/tree/master/AR)。'
- en: For more advanced work, I'm also a fan of several individual contributors, including
    Dan Miller, a senior XR developer at Unity. See [https://github.com/DanMillerDev](https://github.com/DanMillerDev)
    for more information.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更高级的工作，我也喜欢几位个人贡献者，包括Unity的高级XR开发者丹·米勒。更多信息请见[https://github.com/DanMillerDev](https://github.com/DanMillerDev)。
- en: Please look through the **README** file for each of these projects (found on
    the GitHub project's home page) to gain an understanding of what the project does,
    any dependencies it has, and other useful information about the project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅每个项目的**README**文件（可在GitHub项目主页找到），以了解项目功能、依赖项以及其他有关项目的有用信息。
- en: Each of these repositories contains a full Unity project. That is, they are
    not simply Unity asset packages you can import into an existing project. Rather,
    you'll clone the entire repository and open it as its own project. This is typical
    for demo projects that may have other package dependencies and require preset
    settings to build and run properly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些存储库中的每个都包含一个完整的Unity项目。也就是说，它们不仅仅是您可以导入到现有项目中的Unity资产包。相反，您将克隆整个存储库，并将其作为自己的项目打开。这对于可能具有其他包依赖项并需要预设设置才能正确构建和运行的项目来说是典型的。
- en: The *AR Foundation Samples* project is my *go-to project* for learning various
    AR Foundation features. It contains many example scenes demoing individual features,
    often in place of detailed documentation elsewhere (see [https://github.com/Unity-Technologies/arfoundation-samples/tree/main/Assets/Scenes](https://github.com/Unity-Technologies/arfoundation-samples/tree/main/Assets/Scenes)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*AR基础示例* 项目是我学习各种AR基础功能的**首选项目**。它包含许多示例场景，演示了单个功能，通常替代其他地方的详细文档（见[https://github.com/Unity-Technologies/arfoundation-samples/tree/main/Assets/Scenes](https://github.com/Unity-Technologies/arfoundation-samples/tree/main/Assets/Scenes)）。'
- en: Each scene is extremely simple (almost to a fault) as it has the atomic purpose
    of illustrating a single feature. For example, there are separate scenes for plane
    detection, plane occlusion, and feathered planes. Notably, the project also contains
    a main menu scene (`Assets/Scenes/ARFoundationMenu/Menu`) that launches the other
    scenes when you build them all into a single executable. I recommend starting
    with the scene named **SimpleAR**, which we'll review in a moment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景都非常简单（几乎到了错误的地步），因为它的原子目的是说明单个功能。例如，有单独的场景用于平面检测、平面遮挡和羽毛状平面。值得注意的是，该项目还包含一个主菜单场景（`Assets/Scenes/ARFoundationMenu/Menu`），当您将所有场景构建成一个单独的可执行文件时，它会启动其他场景。我建议从名为**SimpleAR**的场景开始，我们稍后会对其进行回顾。
- en: Another is the *AR Foundation Demos* project, which contains some more complex
    user scenarios and features not covered in the Samples project. For example, it
    demonstrates the Unity **Onboarding UX** assets, which we'll introduce you to
    in [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*, Creating an
    AR User Framework*. It also covers image tracking, mesh placement, language localization,
    and some useful shaders (for example, wireframe, shadows, and fog).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是 *AR基础演示* 项目，它包含一些更复杂的用户场景和未在示例项目中涵盖的功能。例如，它演示了Unity的**Onboarding UX**资产，我们将在[*第4章*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*，创建AR用户框架*中向您介绍。它还涵盖了图像跟踪、网格放置、语言本地化和一些有用的着色器（例如，线框、阴影和雾气）。
- en: 'The *XR Interaction Toolkit Examples* repository contains two separate Unity
    projects: one for VR and another for AR. It is largely a placeholder (in my opinion)
    for things to come.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*XR交互工具包示例* 仓库包含两个独立的Unity项目：一个用于VR，另一个用于AR。在我看来，它主要是为了将来要添加的内容而保留的占位符。'
- en: Information – XR Interaction Toolkit
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 – XR交互工具包
- en: The XR Interaction Toolkit from Unity is not covered in this book. It provides
    components and other assets for developing interactive scenes using hand controllers
    and device-supported hand gestures. At the time of writing, XR Interaction Toolkit
    is focused on **Virtual Reality** (**VR**) applications (evidenced by its Examples
    project, which contains seven scenes for VR and just one for AR, which only supports
    mobile AR) but I believe it is a key part of Unity's XR strategy and architecture
    for the future. If you are interested in XR Interaction Toolkit for VR, check
    out my other book, *Unity 2020 Virtual Reality Projects – Third Edition*, from
    Packt Publishing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的XR交互工具包在本书中没有涉及。它提供组件和其他资产，用于使用手控制器和设备支持的手势开发交互式场景。在撰写本文时，XR交互工具包专注于**虚拟现实**（**VR**）应用（其示例项目包含七个VR场景和仅支持移动AR的一个AR场景），但我相信它是Unity未来XR策略和架构的关键部分。如果您对VR的XR交互工具包感兴趣，请查看我另一本书，Packt出版社出版的*Unity
    2020虚拟现实项目 – 第三版*。
- en: Let's get a copy of the AR Foundation Samples project and take a look at the
    **SimpleAR** scene.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取AR基础示例项目的副本，并查看**SimpleAR**场景。
- en: Building and running the Samples project
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 和 运行 示例项目
- en: 'In this section, you are going to build the *AR Foundation Samples* project
    and run it on your device. First, please clone the project from its GitHub repository
    and open it in Unity, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将构建 *AR基础示例* 项目并在您的设备上运行它。首先，请从其GitHub仓库克隆项目，并在Unity中打开它，如下所示：
- en: Clone a copy of the project from GitHub to your local machine. The project can
    be found at [https://github.com/Unity-Technologies/arfoundation-samples](https://github.com/Unity-Technologies/arfoundation-samples).
    Please use whatever cloning method you prefer; for example, GitHub Desktop ([https://desktop.github.com/](https://desktop.github.com/))
    or the command line ([https://git-scm.com/download/](https://git-scm.com/download/)).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub克隆项目的副本到您的本地机器。项目可以在[https://github.com/Unity-Technologies/arfoundation-samples](https://github.com/Unity-Technologies/arfoundation-samples)找到。请使用您喜欢的任何克隆方法；例如，GitHub
    Desktop ([https://desktop.github.com/](https://desktop.github.com/))或命令行([https://git-scm.com/download/](https://git-scm.com/download/))。
- en: Add the project to **Unity Hub** by selecting **Projects | Add**, navigating
    to the cloned project's root folder, and pressing **Select Folder**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目添加到**Unity Hub**中，通过选择**项目 | 添加**，导航到克隆项目的根文件夹，然后点击**选择文件夹**。
- en: Open the project in Unity. In the **Unity Hub** projects list, if you see a
    yellow warning icon, then the cloned project's Unity version is not currently
    installed on your system. Use the **Unity Version** selection to choose a newer
    version of the editor that you have, preferably of the same major release (for
    example, 20XX).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中打开项目。在**Unity Hub**的项目列表中，如果您看到一个黄色的警告图标，那么克隆项目的Unity版本目前尚未安装到您的系统上。使用**Unity版本**选择来选择您拥有的较新版本的编辑器，最好是同一主要版本的（例如，20XX）。
- en: Open the project by selecting it from the Unity Hub projects list.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity Hub的项目列表中选择项目来打开它。
- en: If your version of Unity is newer than the project from when it was last saved,
    you will see a prompt asking, "**Do you want to upgrade your project to a newer
    version of Unity?**." Press **Confirm**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的Unity版本比项目最后保存时的版本新，您将看到一个提示，询问“**您想要将项目升级到Unity的新版本吗？**”。点击**确认**。
- en: 'One of the scenes, **SimpleAR**, is a basic AR example scene. When run, the
    user will scan their room with their device''s camera and the app will detect
    any horizontal planes that are rendered on the screen. When your user taps on
    one of these planes, a small red cube will be placed in the environment. You can
    walk around the room and the cube will remain where it was placed. If you tap
    again on another location, the cube will be moved there. Let''s briefly review
    this **SimpleAR** scene''s GameObjects:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个场景，**SimpleAR**，是一个基本的AR示例场景。当运行时，用户将使用设备的摄像头扫描他们的房间，并且应用将检测屏幕上渲染的任何水平平面。当您的用户点击这些平面中的一个时，一个小的红色立方体将被放置在环境中。您可以在房间里走动，立方体将保持在放置的位置。如果您再次点击另一个位置，立方体将被移动到那里。让我们简要回顾一下这个**SimpleAR**场景的GameObject：
- en: Open the `Scenes/SimpleAR/` folder and double-clicking the `SimpleAR` scene
    file.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Scenes/SimpleAR/`文件夹，双击`SimpleAR`场景文件。
- en: 'In the **Hierarchy** window, you will find two GameObjects of particular interest:
    **AR Session** and **AR Session Origin**.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，您将找到两个特别感兴趣的GameObject：**AR会话**和**AR会话原点**。
- en: Select the **AR Session Origin** object and examine its components in the **Inspector**
    window. These include **AR Plane Manager**, **AR Point Cloud Manager**, **AR Raycast
    Manager**, and a **Place On Plane** script. We'll explain all of this later in
    this chapter.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**AR会话原点**对象，并在**检查器**窗口中检查其组件。这些包括**AR平面管理器**、**AR点云管理器**、**AR射线投射管理器**和一个**放置在平面上**脚本。我们将在本章后面解释所有这些内容。
- en: 'Now, let''s try to build and run the project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试构建和运行项目：
- en: Switch to your target platform if necessary. To do this, go to **File | Build
    Settings**, choose your device's platform from the **Platform** list (for example,
    Android or iOS), and click **Switch Platform**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，切换到您的目标平台。为此，转到**文件 | 构建设置**，从**平台**列表中选择您的设备平台（例如，Android或iOS），然后点击**切换平台**。
- en: Most likely, the cloned project's settings have already been configured, but
    let's make sure. From the **Build Settings** window, click the **Player Settings**
    button to open that window and confirm the necessary settings mentioned in [*Chapter
    1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*, Setting Up for AR Development*.
    For example, Android ARCore does not support Vulcan graphics and needs **Nougat
    (API Level 24)** as a minimum requirement.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很可能，克隆项目的设置已经配置好了，但让我们确保一下。从**构建设置**窗口，点击**玩家设置**按钮打开该窗口，并确认在[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*，设置AR开发*中提到的必要设置。例如，Android
    ARCore不支持Vulkan图形，需要**牛轧糖（API级别24）**作为最低要求。
- en: In the **Build Settings** window again, notice that the list of scenes in **Scenes
    in Build** starts with the **Menu** scene and contains all the demo scenes from
    this project (the first in the list will be the first scene to load when the app
    loads). You can leave these alone or just pick the one you want in the build.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在**构建设置**窗口中注意，**构建中的场景**列表以**菜单**场景开头，并包含此项目中的所有演示场景（列表中的第一个将是应用加载时首先加载的场景）。您可以保留这些设置，或者只需选择构建中想要的一个即可。
- en: Ensure your mobile device is plugged into a USB port on your computer.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的移动设备已连接到计算机上的USB端口。
- en: Press the `Builds/`. Give it a filename (if required) and press **Save**. It
    may take a while to complete this task.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`Builds/`。如果需要，输入一个文件名，然后按**保存**。完成此任务可能需要一段时间。
- en: If all goes well, the project will build, be installed on your device, and launch.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，项目将构建，安装到您的设备上，并启动。
- en: If you encounter errors while building the project, look at the **Console**
    window in the Unity Editor for messages (in the default layout, it's a tab behind
    the **Project** window). Read the messages carefully, generally starting from
    the top. If the fix is not obvious, do an internet search for the message's text,
    as you can be certain you're probably not the first person to have a similar question!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构建项目时遇到错误，请查看Unity编辑器中的**控制台**窗口中的消息（在默认布局中，它位于**项目**窗口后面的一个标签页）。仔细阅读这些消息，通常从顶部开始。如果修复方法不明显，请在网络上搜索消息文本，因为您可以确信您可能不是第一个遇到类似问题的人！
- en: Tip – "Failed to generate ARCore reference image library" error
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 – “无法生成ARCore参考图像库”错误
- en: If you receive an error when attempting to build the project that says something
    like **Failed to generate ARCore reference image library**, please make sure there
    are no spaces in the pathname of your project folder! See [https://github.com/Unity-Technologies/arfoundation-samples/issues/119](https://github.com/Unity-Technologies/arfoundation-samples/issues/119)
    for more information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在尝试构建项目时收到类似“无法生成ARCore参考图像库”的错误，请确保项目文件夹的路径名中没有空格！有关更多信息，请参阅[https://github.com/Unity-Technologies/arfoundation-samples/issues/119](https://github.com/Unity-Technologies/arfoundation-samples/issues/119)。
- en: 'The main menu will be displayed, as shown in the following screen capture (left
    panel):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单将显示，如下面的屏幕截图所示（左侧面板）：
- en: '![Figure 2.1 – Screenshot of my phone running the arfoundation-samples app
    and SimpleAR scene'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 我手机运行 arfoundation-samples 应用和 SimpleAR 场景的截图'
- en: '](img/Figure_2.01-arf-samples-screenshot-twin.jpg.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.01 – 样本项目截图](img/Figure_2.01-arf-samples-screenshot-twin.jpg.jpg)'
- en: Figure 2.1 – Screenshot of my phone running the arfoundation-samples app and
    SimpleAR scene
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 我手机运行 arfoundation-samples 应用和 SimpleAR 场景的截图
- en: A cool thing about AR Foundation (and this project) is that it can detect the
    capabilities of the device it is running on at runtime. This means that the buttons
    in the main menu will be disabled when AR Foundation detects that the features
    demoed in that scene are not supported on the device. (The device I'm using in
    the preceding screen capture is an Android phone, so some iOS-only feature scenes
    are disabled).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: AR Foundation（以及这个项目）的一个酷特点是它可以在运行时检测运行其上的设备的性能。这意味着当AR Foundation检测到该场景中演示的功能不支持该设备时，主菜单中的按钮将被禁用。（我在前面的屏幕截图中使用的设备是安卓手机，因此一些仅限iOS的功能场景被禁用）。
- en: Click the **Simple AR** button to open that scene. You should see a camera video
    feed on your device's screen. Move your phone slowly in different directions and
    closer/away. As it scans the environment, feature points and planes will be detected
    and rendered on the screen. Tap one of the planes to place a cube on the scene,
    as shown in the right-hand panel of the preceding screen capture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**简单AR**按钮打开该场景。您应该在设备屏幕上看到相机视频流。缓慢地将手机向不同方向移动，靠近或远离。当它扫描环境时，特征点和平面将被检测并在屏幕上渲染。轻触其中一个平面，在场景中放置一个立方体，如前一个屏幕截图的右侧面板所示。
- en: Some of the assets and scripts in the Samples project can be useful for building
    our own projects. I'll show you how to export them now.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 样本项目中的某些资源和脚本对于构建我们自己的项目可能很有用。我现在将向您展示如何导出它们。
- en: Exporting the sample assets for reuse
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出样本资源以供重用
- en: 'Unity offers the ability to share assets between projects using `.unitypackage`
    files. Let''s export the assets from the AR Foundation Samples project for reuse.
    One trick I like to do is move all the sample folders into a root folder first.
    With the *arfoundation-samples* project open in Unity, please perform the following
    steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了使用`.unitypackage`文件在项目之间共享资产的能力。让我们从AR Foundation Samples项目中导出资产以供重用。我喜欢的一个技巧是首先将所有示例文件夹移动到一个根文件夹中。在Unity中打开*arfoundation-samples*项目，请执行以下步骤：
- en: In the `Assets` named `ARF-samples` by clicking the **+** icon (top left of
    the window) and selecting **Folder**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击窗口左上角的**+**图标并选择**文件夹**，在`Assets`中命名`ARF-samples`。
- en: 'Drag the following folders into the `ARF-samples` one: `Materials`, `Meshes`,
    `Prefabs`, `Scenes`, `Scripts`, `Shaders`, and `Textures`. That is, move all of
    them but leave the `XR` folder at the root.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文件夹拖入`ARF-samples`文件夹中：`Materials`、`Meshes`、`Prefabs`、`Scenes`、`Scripts`、`Shaders`和`Textures`。也就是说，将它们全部移动，但保留根目录下的`XR`文件夹。
- en: Right-click on the `ARF-samples` folder and select **Export Package**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`ARF-samples`文件夹并选择**导出包**。
- en: The **Exporting Package** window will open. Click **Export**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导出包**窗口将打开。点击**导出**。'
- en: Choose a directory outside this project's root, name the file (for example,
    `arf-samples`), and click **Save**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择项目根目录外的目录，命名文件（例如，`arf-samples`），然后点击**保存**。
- en: 'The `Assets/ARF-samples/` folder in the **Project** window is shown in the
    following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目**窗口中的`Assets/ARF-samples/`文件夹在以下屏幕截图中显示：'
- en: '![Figure 2.2 – The Samples assets folder being exported to a .unitypackage
    file'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – 正在导出到.unitypackage文件的示例资产文件夹](img/Figure_2.02-arf-samples-folders.jpg)'
- en: '](img/Figure_2.02-arf-samples-folders.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – 正在导出到.unitypackage文件的示例资产文件夹](img/Figure_2.02-arf-samples-folders.jpg)'
- en: Figure 2.2 – The Samples assets folder being exported to a .unitypackage file
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 正在导出到.unitypackage文件的示例资产文件夹
- en: You can close the `arfoundation-samples` project now if you want. You now have
    an asset package you can use in other projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，现在可以关闭`arfoundation-samples`项目了。你现在有一个资产包可以在其他项目中使用。
- en: Tip – Starting a New Project by Copying the Samples Project
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 – 通过复制示例项目开始新项目
- en: An alternative to starting a new Unity AR project from scratch is to duplicate
    the *arfoundation-samples* project as the starting point for new AR projects.
    To do that, from your Windows Explorer (or macOS Finder), duplicate the entire
    project folder and then add it to Unity Hub. This way, you get all the example
    assets and demo scenes in one place, and it's set up with reasonable default project
    settings. I often do this, especially for quick demos and small projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始创建新的Unity AR项目的一个替代方法是复制*arfoundation-samples*项目作为新AR项目的起点。为此，从你的Windows资源管理器（或macOS
    Finder），复制整个项目文件夹，然后将其添加到Unity Hub中。这样，你就可以在一个地方获得所有示例资产和演示场景，并且它已经设置了合理的默认项目设置。我经常这样做，特别是对于快速演示和小型项目。
- en: Next, we are going to import the Samples assets into your Unity project and
    build the given SimpleAR scene.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将导入示例资产到你的Unity项目中，并构建给定的SimpleAR场景。
- en: Building the SimpleAR scene in your own project
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的项目中构建SimpleAR场景
- en: As you will see later in this chapter, the Samples project includes some assets
    we can use in your own projects, saving you time and effort, especially at the
    start. We will import `unitypackage`, which we just exported, and then build the
    given SimpleAR scene as another test to verify that you're set up to build and
    run AR applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本章后面看到的那样，示例项目包括一些我们可以用于你自己的项目的资产，节省了你的时间和精力，尤其是在开始时。我们将导入我们刚刚导出的`unitypackage`，然后构建给定的SimpleAR场景，作为另一个测试来验证你是否已经设置好构建和运行AR应用程序。
- en: Creating a new project
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: If you already have a Unity project set up for AR development, as detailed in
    [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*, Setting Up for
    AR Development*, you can open it in Unity and skip this section. If not, perform
    the following steps, which have been streamlined for your convenience. If you
    require more details or explanations, please revisit [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*,
    Setting Up for AR Development*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了一个用于AR开发的Unity项目，如[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*，*为AR开发设置*中详细说明，你可以在Unity中打开它并跳过本节。如果没有，请执行以下步骤，这些步骤已经简化以方便你。如果你需要更多详细信息或解释，请重新查阅[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*，*为AR开发设置*。
- en: 'To create and set up a new Unity project with AR Foundation, Universal Render
    Pipeline, and the new Input System, here are the abbreviated steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和设置一个新的Unity项目，其中包含AR Foundation、Universal Render Pipeline和新的输入系统，以下是简化的步骤：
- en: '*Create a new project* by opening `MyARProject`, and clicking **Create**.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开`MyARProject`并点击**创建**来**创建一个新的项目**。
- en: '*Open your project* in the Unity Editor by selecting it from Unity Hub''s **Projects**
    list.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Unity编辑器中选择Unity Hub的**项目**列表中的项目来**打开你的项目**。
- en: '*Set your target platform* by going to **File | Build Settings**, choosing
    **Android** or **iOS** from the **Platform** list, and clicking **Switch Platform**.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件 | 构建设置**，从**平台**列表中选择**Android**或**iOS**，并点击**切换平台**来**设置你的目标平台**。
- en: '*Set up the Player Settings* according to [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*,
    Setting Up for AR Development*, and/or your device''s documentation by going to
    the **Edit | Project Settings | Player** window. For example, Android ARCore does
    not support Vulcan graphics and needs **Nougat (API Level 24)** as a minimum requirement.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*，通过转到**编辑 | 项目设置 |
    玩家**窗口来**设置玩家设置**，设置AR开发或你的设备的文档。例如，Android ARCore不支持Vulkan图形，需要**牛轧糖（API级别24）**作为最低要求。
- en: '*Install an XR plugin* by going to **Edit | Project Settings | XR Plugins Manager
    | Install XR Plugin Management**. Then, check the checkbox for your device''s
    **Plug-in Provider**.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**编辑 | 项目设置 | XR插件管理器 | 安装XR插件管理**来**安装XR插件**。然后，勾选你设备的**插件提供商**复选框。
- en: '*Install AR Foundation* by going to `ar` using the search input field, selecting
    the **AR Foundation** package, and clicking **Install**.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索输入字段中转到`ar`，选择**AR Foundation**包，并点击**安装**来**安装AR Foundation**。
- en: '*Install the Input System package* by going to `input` using the search input
    field, selecting the **Input System** package, and clicking **Install**.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索输入字段中转到`input`，选择**输入系统**包，并点击**安装**来**安装输入系统包**。
- en: When prompted to enable the input backend, you can say **Yes**, but we'll actually
    change this setting to **Both** in the next topic when we import the Sample assets
    into the project.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当提示启用输入后端时，你可以回答**是**，但我们将实际上在将样本资产导入项目时将此设置更改为**两者**。
- en: '*Add the AR Background Renderer* to the URP Forward renderer by locating the
    `Assets/Settings/` folder. In its **Inspector** window, click **Add Renderer Feature**
    and select **AR Background Renderer Feature**.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定位到`Assets/Settings/`文件夹，将**AR背景渲染器**添加到URP前向渲染器中。在其**检查器**窗口中，点击**添加渲染器功能**并选择**AR背景渲染器功能**。
- en: You might want to bookmark these steps for future reference. Next, we'll import
    the Sample assets we exported from the AR Foundation Samples project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要将这些步骤添加到书签中以便将来参考。接下来，我们将导入从AR Foundation示例项目中导出的样本资产。
- en: Importing the Sample assets into your own project
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将样本资产导入到你的项目中
- en: 'Now that you have a Unity project set up for AR development, you can import
    the sample assets into your project. With your project open in Unity, perform
    the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了一个用于AR开发的Unity项目，你可以将样本资产导入到你的项目中。在你的Unity项目中打开项目，执行以下步骤：
- en: Import the package from the main menu by selecting **Assets | Import Package
    | Custom Package**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在主菜单中选择**资产 | 导入包 | 自定义包**来导入包。
- en: Locate the `arf-samples.unitypackage` file on your system and click **Open**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的系统上定位`arf-samples.unitypackage`文件并点击**打开**。
- en: The **Import Unity Package** window will open. Click **Import**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会打开**导入Unity包**窗口。点击**导入**。
- en: If you created your project using the *Universal Render Pipeline* (or HDRP),
    rather than using the built-in render pipeline like we did, you need to convert
    the imported materials. Select **Edit | Render Pipeline | URP | Upgrade Project
    Materials to URP Materials**. Then, when prompted, click **Proceed**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是**通用渲染管线**（或HDRP），而不是像我们这样使用内置渲染管线，你需要转换导入的材料。选择**编辑 | 渲染管线 | URP | 将项目材料升级到URP材料**。然后，当提示时，点击**继续**。
- en: Then, go to **Player Settings** using **Edit | Project Settings | Player**,
    select **Configuration | Active Input Handling**, and choose **Both**. Then, when
    prompted, click **Apply**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用**编辑 | 项目设置 | 玩家**转到**玩家设置**，选择**配置 | 活动输入处理**，并选择**两者**。然后，当提示时，点击**应用**。
- en: We will use the new Input System for projects in this book. However, some demo
    scenes in the Samples project use the old Input Manager. If you choose **Input
    System Package (New)** for **Active Input Handling**, then those demo scenes may
    not run.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书的项目中，我们将使用新的输入系统。然而，一些示例项目中的演示场景仍在使用旧的输入管理器。如果你选择**输入系统包（新）**作为**活动输入处理**，那么这些演示场景可能无法运行。
- en: 'Hopefully, all the assets will import without any issues. However, there may
    be some errors while compiling the Samples scripts. This could happen if the Samples
    project is using a newer version of AR Foundation than your project and it is
    referencing API functions for features your project does not have installed. The
    simplest solution is to upgrade the version of AR Foundation to the same or later
    version as the Samples project. To do so, perform the following steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 希望所有资产都能无问题导入。然而，在编译示例脚本时可能会出现一些错误。这可能发生如果示例项目使用比您的项目更新的AR Foundation版本，并且它引用了您的项目未安装的功能的API函数。最简单的解决方案是将AR
    Foundation的版本升级到与示例项目相同或更新的版本。为此，请执行以下步骤：
- en: To see error messages, open the **Console** window using its tab or selecting
    **Window | General | Console**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看错误消息，请使用其标签或选择**窗口 | 通用 | 控制台**来打开**控制台**窗口。
- en: Suppose that, in my project, I have additional errors because I have installed
    *AR Foundation 4.0.12* but the Samples project uses *version 4.1.3* features,
    which are not available in my version. Here, I'll go to **Window | Package Manager**,
    select the **AR Foundation** package, click **See Other Versions**, select the
    4.1.3 version, and then click the **Update to 4.1.3** button.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设在我的项目中，我安装了*AR Foundation 4.0.12*，但示例项目使用的是*版本4.1.3*的功能，这些功能在我的版本中不可用。在这里，我将前往**窗口
    | 软件包管理器**，选择**AR Foundation**软件包，点击**查看其他版本**，选择4.1.3版本，然后点击**更新到4.1.3**按钮。
- en: The project also might be using preview versions of packages. Enable preview
    packages by selecting **Edit | Project Settings | Package Manager | Enable preview
    packages**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目也可能正在使用软件包的预览版本。通过选择**编辑 | 项目设置 | 软件包管理器 | 启用预览软件包**来启用预览软件包。
- en: Ensure the ARCore XR plugin and/or AR Kit XR plugin version matches the version
    of the AR Foundation package the project is using.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保ARCore XR插件和/或AR Kit XR插件版本与项目使用的AR Foundation软件包版本相匹配。
- en: Another message you might see is that some Samples scripts require that you
    enable "unsafe" code in the project. Go to **Project Settings | Player | Script
    Compilation | Allow 'unsafe' code** and check the checkbox.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还会看到一条消息，说明一些示例脚本需要您在项目中启用“不安全”的代码。前往**项目设置 | 玩家 | 脚本编译 | 允许'不安全'代码**并勾选复选框。
- en: This is not as threatening as it may sound. "Unsafe" code usually means that
    something you installed is calling C++ code from the project that is *potentially*
    unsafe from the compiler's point of view. Enabling unsafe code in Unity is usually
    not a problem unless, for example, you are publishing WebGL to a WebPlayer, which
    we are not.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这并不像听起来那么可怕。“不安全”的代码通常意味着您安装的某个组件正在从项目调用C++代码，从编译器的角度来看，该项目可能存在潜在的不安全性。在Unity中启用不安全代码通常不会成问题，除非，例如，您正在将WebGL发布到WebPlayer，而我们不是这样做的。
- en: 'Finally, you can verify your setup by building and running the SimpleAR scene,
    this time from your own project. Perform the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过构建和运行SimpleAR场景来验证您的设置，这次是从您自己的项目中。请执行以下步骤：
- en: Open the `ARF-samples/Scenes/SimpleAR/` folder and double-clicking the **SimpleAR**
    scene file.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ARF-samples/Scenes/SimpleAR/`文件夹，双击**SimpleAR**场景文件。
- en: Open the **Build Settings** window by going to **File | Build Settings**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过前往**文件 | 构建设置**来打开**构建设置**窗口。
- en: For the **Scenes in Build** list, click the **Add Open Scenes** button and uncheck
    all the scenes in the list other than the SimpleAR one.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**构建中的场景**列表，点击**添加打开场景**按钮，并取消勾选列表中除SimpleAR之外的所有场景。
- en: Ensure your device is connected via USB.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的设备通过USB连接。
- en: Press the `Builds/`. Give it a filename (if required) and press **Save**. It
    may take a while to complete this task.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`Builds/`。如果需要，给出一个文件名，然后按**保存**。完成此任务可能需要一些时间。
- en: The app should successfully build and run on your device. If you encounter any
    errors, please review each of the steps detailed in this chapter and [*Chapter
    1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*, Setting Up for AR Development*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应在您的设备上成功构建和运行。如果您遇到任何错误，请查阅本章以及[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*，设置AR开发环境*中详细说明的每个步骤。
- en: When the app launches, as described earlier, you should see a camera video feed
    on your screen. Move your phone slowly in different directions and closer/away.
    As it scans the environment, feature points and planes will be detected and rendered
    on the screen. Tap one of these planes to place a cube on the scene.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，如前所述，您应该在屏幕上看到一个相机视频流。慢慢将您的手机向不同方向移动，靠近/远离。当它扫描环境时，特征点和平面将被检测并在屏幕上渲染。轻触这些平面之一，在场景中放置一个立方体。
- en: Your project is now ready for AR development!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目现在已准备好进行 AR 开发了！
- en: Starting a new, basic AR scene
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个新的基本 AR 场景
- en: In this section, we'll create a scene very similar to `SimpleAR` (actually,
    more like the Samples scene named `InputSystem_PlaceOnPlane`) but we will start
    with a new empty scene. We'll add AR Session and AR Session Origin objects provided
    by AR Foundation to the scene hierarchy, and then add trackable feature managers
    for planes and point clouds. In the subsequent sections of this chapter, we'll
    set up an Input System action controller, write a C# script to handle any user
    interaction, and create a prefab 3D graphic to place in the scene.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个与 `SimpleAR`（实际上，更像是名为 `InputSystem_PlaceOnPlane` 的样本场景）非常相似的场景，但我们将从一个新的空场景开始。我们将向场景层次结构中添加
    AR 会话和 AR 会话原点对象，由 AR Foundation 提供，然后添加平面和点云的可追踪功能管理器。在本章的后续部分，我们将设置输入系统动作控制器，编写一个
    C# 脚本来处理任何用户交互，并创建一个 3D 预制件图形以放置在场景中。
- en: 'So, start the new scene by performing the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，按照以下步骤开始新场景：
- en: Create a new scene by going to **File | New Scene**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **文件 | 新场景** 创建一个新的场景。
- en: If prompted, choose the **Basic (Built-in)** template. Then, click **Create**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提示，请选择 **基本（内置）** 模板。然后，点击 **创建**。
- en: Unity allows you to use a Scene template when creating a new scene. The one
    named **Basic (Built-in)** is comparable to the default new scene in previous
    versions of Unity.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Unity 允许你在创建新场景时使用场景模板。名为 **基本（内置）** 的模板与 Unity 早期版本中的默认新场景相当。
- en: Delete **Main Camera** from the **Hierarchy** window by using *right-click*
    | **Delete** (or the *Del* key on your keyboard).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 *右键单击* | **删除**（或键盘上的 *Del* 键）从 **层次结构** 窗口中删除 **主摄像头**。
- en: Add an AR Session by selecting **GameObject** from the main menu, then **XR
    | AR Session**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从主菜单中选择 **GameObject**，然后选择 **XR | AR Session** 来添加 AR 会话。
- en: Add an AR Session Origin by selecting **GameObject** from the main menu, then
    **XR | AR Session Origin**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从主菜单中选择 **GameObject**，然后选择 **XR | AR Session Origin** 来添加 AR 会话原点。
- en: Unfold **AR Session Origin** and select its child; that is, **AR Camera**. In
    the **Inspector** window, use the **Tag** selector at the top left to set it as
    our **MainCamera**. (This is not required but it is a good practice to have one
    camera in the scene tagged as **MainCamera**.)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**AR 会话原点**并选择其子项；即 **AR 摄像头**。在 **检查器** 窗口中，使用左上角的 **标签** 选择器将其设置为我们的 **主摄像头**。（这不是必需的，但将场景中有一个标记为
    **主摄像头** 的摄像头作为良好实践是不错的。）
- en: Save the scene using `Assets/Scenes/` folder, name it `BasicARScene`, and click
    **Save**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Assets/Scenes/` 文件夹保存场景，命名为 `BasicARScene`，然后点击 **保存**。
- en: 'Your scene Hierarchy should now look as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你的场景层次结构现在应该如下所示：
- en: '![Figure 2.3 – Starting a scene Hierarchy'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 开始场景层次结构'
- en: '](img/Figure_2.03-starting-hierarchy.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.03-starting-hierarchy.jpg)'
- en: Figure 2.3 – Starting a scene Hierarchy
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 开始场景层次结构
- en: We can now take a closer look at the objects we just added, beginning with the
    AR Session object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更仔细地查看我们刚刚添加的对象，从 AR 会话对象开始。
- en: Using AR Session
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AR 会话
- en: 'The **AR Session** object is responsible for enabling and disabling augmented
    reality features on the target platform. When you select the **AR Session** object
    in your scene **Hierarchy**, you can see its components in the **Inspector** window,
    as shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR 会话** 对象负责在目标平台上启用和禁用增强现实功能。当你在场景 **层次结构** 中选择 **AR 会话** 对象时，你可以在 **检查器**
    窗口中看到其组件，如下面的截图所示：'
- en: '![Figure 2.4 – The AR Session object''s Inspector window'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – AR 会话对象的检查器窗口'
- en: '](img/Figure_2.04-arsession-inspector.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.04-arsession-inspector.jpg)'
- en: Figure 2.4 – The AR Session object's Inspector window
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – AR 会话对象的检查器窗口
- en: Each AR scene must include one (and only one) AR Session. It provides several
    options. Generally, you can leave these as their default values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 AR 场景必须包含一个（且仅有一个）AR 会话。它提供了几个选项。通常，你可以将这些选项保留为它们的默认值。
- en: The **Attempt Update** option instructs the AR Session to try and install the
    underlying AR support software on the device if it is missing. This is not required
    for all devices. iOS, for example, does not require any additional updates if
    the device supports AR. On the other hand, to run AR apps on Android, the device
    must have the ARCore services installed. Most AR apps will do this for you if
    they are missing, and that is what the **Attempt Update** feature of **AR Session**
    does. If necessary, when your app launches and support is missing or needs an
    update, AR Session will attempt to install *Google Play Services for AR* (see
    [https://play.google.com/store/apps/details?id=com.google.ar.core](https://play.google.com/store/apps/details?id=com.google.ar.core)).
    If the required software is not installed, then AR will not be available on the
    device. You could choose to disable automatic updates and implement them yourself
    to customize the user onboarding experience.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试更新**选项指示AR会话尝试在设备上安装底层AR支持软件（如果尚未安装）。并非所有设备都需要这样做。例如，iOS设备如果支持AR，则不需要任何额外的更新。另一方面，要在Android上运行AR应用程序，设备必须安装ARCore服务。大多数AR应用程序会在缺少时为你这样做，这就是**AR会话**的**尝试更新**功能所做的事情。如果需要，当你的应用程序启动且支持软件缺失或需要更新时，AR会话将尝试安装*Google
    Play Services for AR*（见[https://play.google.com/store/apps/details?id=com.google.ar.core](https://play.google.com/store/apps/details?id=com.google.ar.core))。如果所需的软件未安装，则设备上将无法使用AR。你可以选择禁用自动更新并自行实现它们，以自定义用户入门体验。'
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **Match Frame Rate** option in the **Inspector** window is obsolete. Ordinarily,
    you would want the frame updates of your apps to match the frame rate of the physical
    device, and generally, there is no need to tinker with this. If you need to tune
    it, you should control it via scripting (see [https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html](https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查器**窗口中的**匹配帧率**选项已过时。通常，你希望你的应用程序的帧更新与物理设备的帧率相匹配，通常不需要调整。如果你需要调整它，你应该通过脚本控制（见[https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html](https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html))。'
- en: 'Regarding **Tracking Mode**, you will generally leave it set to **Position
    and Rotation**, as this specifies that your VR device is tracking in the physical
    world 3D space using both its XYZ position and its rotation around each axis.
    This is referred to as *6DOF*, for six-degrees-of-freedom tracking, and is probably
    the behavior that you expect. But for face tracking, for example, we should set
    it to **Rotation Only**, as you''ll see in [*Chapter 9*](B15145_09_Final_SB_epub.xhtml#_idTextAnchor224)*,
    Selfies: Making Funny Faces*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**跟踪模式**，你通常会将其设置为**位置和旋转**，因为这指定了你的VR设备正在使用其XYZ位置和围绕每个轴的旋转在物理世界的3D空间中进行跟踪。这被称为*6自由度跟踪*，这可能是你期望的行为。但对于面部跟踪，例如，我们应该将其设置为**仅旋转**，正如你在[*第9章*](B15145_09_Final_SB_epub.xhtml#_idTextAnchor224)*，自拍：制作有趣的面孔*中看到的。
- en: The **AR Session** GameObject also has an **AR Input Manager** component that
    manages our **XR Input Subsystem** for tracking the device's pose in a physical
    3D space. It reads input from the AR Camera's **AR Pose Driver** (discussed shortly).
    There are no options for the component, but this is required for device tracking.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR会话** GameObject还有一个**AR输入管理器**组件，用于管理我们的**XR输入子系统**以跟踪设备在物理3D空间中的姿态。它从AR相机的**AR姿态驱动器**（稍后讨论）读取输入。该组件没有选项，但这是设备跟踪所必需的。'
- en: We also added an AR Session Origin GameObject to the Hierarchy. Let's look at
    that next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在层次结构中添加了一个AR会话原点GameObject。让我们接下来看看它。
- en: Using AR Session Origin
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AR会话原点
- en: The **AR Session Origin** will be the root object of all trackable objects.
    Having a root origin keeps the Camera and any trackable objects in the same space
    and their positions relative to each other. This *session* (or *device) space*
    includes the AR Camera and any *trackable* features that have been detected in
    the real-world environment by the AR software. Otherwise, detected features, such
    as planes, won't appear in the correct place relative to the Camera.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR会话原点**将是所有可跟踪对象的根对象。拥有根原点可以保持相机和任何可跟踪对象在同一空间中，并且它们相对于彼此的位置。这个*会话*（或*设备空间*）包括AR相机和任何在真实世界环境中由AR软件检测到的*可跟踪*特征。否则，检测到的特征，如平面，将不会相对于相机出现在正确的位置。'
- en: Tip – Scaling Virtual Scenes in AR
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 - 在AR中缩放虚拟场景
- en: If you plan to scale your AR scene, place your game objects as children of AR
    Session Origin and then scale the parent AR Session Origin transform, rather than
    the child objects themselves. For example, consider a world-scale city map or
    game court resized to fit on a tabletop. Don't scale the individual objects in
    the scene; instead, scale everything by resizing the root session origin object.
    This will ensure the other Unity systems, especially physics and particles, retain
    their scale relative to the camera space. Otherwise, things such as gravity, calculated
    as meters per second, and particle rendering could mess up.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划扩展你的 AR 场景，将你的游戏对象放置为 AR Session Origin 的子对象，然后缩放父 AR Session Origin 变换，而不是子对象本身。例如，考虑一个世界级城市地图或游戏法庭缩放到桌面大小。不要缩放场景中的单个对象；相反，通过调整根会话起源对象的大小来缩放一切。这将确保其他
    Unity 系统，特别是物理和粒子系统，相对于摄像机空间保持其比例。否则，像重力这样的东西，以每秒米计算，以及粒子渲染可能会出错。
- en: 'When you select the **AR Session Origin** object in your scene **Hierarchy**,
    you can see its components in the **Inspector** window, as shown in the following
    screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在场景 **层次结构** 中选择 **AR Session Origin** 对象时，你可以在 **检查器** 窗口中看到其组件，如下截图所示：
- en: '![Figure 2.5 – The AR Session object''s Inspector window'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – AR Session 对象的检查器窗口'
- en: '](img/Figure_2.05-arsessionorigin-inspector.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.05-arsessionorigin-inspector.jpg)'
- en: Figure 2.5 – The AR Session object's Inspector window
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – AR Session 对象的检查器窗口
- en: 'At the time of writing, the default AR Session Origin object simply has an
    **AR Session Origin**     component. We''ll want to build out its behavior by adding more components in
    a moment.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，默认的 AR Session Origin 对象仅有一个 **AR Session Origin** 组件。我们希望通过添加更多组件来扩展其行为。
- en: The Session Origin's **Camera** property references its own child **AR Camera**
    GameObject, which we'll look at next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Session Origin 的 **Camera** 属性引用其自身的子 **AR Camera** GameObject，我们将在下一节中探讨。
- en: Using the AR Camera
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AR Camera
- en: 'The **AR Camera** object is a child of AR Session Origin. Its **Inspector**
    window is shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR Camera** 对象是 AR Session Origin 的子对象。其 **检查器** 窗口如下截图所示：'
- en: '![Figure 2.6 – The AR Camera object''s Inspector window'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – AR Camera 对象的检查器窗口'
- en: '](img/Figure_2.06-arcamera-inspector.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.06-arcamera-inspector.jpg)'
- en: Figure 2.6 – The AR Camera object's Inspector window
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – AR Camera 对象的检查器窗口
- en: During setup, we tagged the AR Camera as our `Camera.main`, which is a shortcut
    for the find by tag name.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置过程中，我们将 AR Camera 标记为 `Camera.main`，这是一个通过标签名称查找的快捷方式。
- en: As its name implies, the AR Camera object includes a `0.1, 20`) meters. In AR
    apps, it's not unusual to place the device within inches of a virtual object,
    so we wouldn't want it to be clipped. Conversely, in an AR app, if you walk more
    than 20 meters away from an object that you've placed in the scene, you probably
    don't need it to be rendered at all.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，AR Camera 对象包含一个 `0.1, 20`) 米的视野。在 AR 应用中，将设备放置在虚拟对象几英寸之内并不罕见，因此我们不希望它被裁剪。相反，在
    AR 应用中，如果你离你放置在场景中的对象超过 20 米，你可能根本不需要渲染它。
- en: Importantly, rather than using a Skybox, as you'd expect in non-AR scenes, the
    camera's **Background** is set to a **Solid** black color. This means the background
    will be rendered using the camera's video feed. This is controlled using the **AR
    Camera Background** component of the AR Camera. In an advanced application, you
    can even customize how the video feed is rendered, using a custom video *material*
    (this topic is outside the scope of this book). Similarly, on a wearable AR device,
    a black camera background is required, but with no video feed, to mix your virtual
    3D graphics atop the visual see-through view.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，与在非 AR 场景中预期使用 Skybox 不同，摄像机的 **背景** 被设置为 **纯黑** 颜色。这意味着背景将通过摄像机的视频流进行渲染。这可以通过
    AR Camera 的 **AR Camera Background** 组件进行控制。在高级应用中，你甚至可以自定义视频流的渲染方式，使用自定义的视频 *材质*（这个主题超出了本书的范围）。同样，在可穿戴
    AR 设备上，需要一个黑色的摄像机背景，但没有视频流，以便在你的虚拟 3D 图形上方混合视觉透视视图。
- en: 'The video feed source is controlled using the AR Camera Manager component.
    You can see, for example, that **Facing Direction** can be changed from **World**
    to **User** for a selfie face tracking app (see [*Chapter 9*](B15145_09_Final_SB_epub.xhtml#_idTextAnchor224)*,
    Selfies: Making Funny Faces*).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 视频流源由 AR Camera Manager 组件控制。例如，你可以看到 **面向方向** 可以从 **世界** 更改为 **用户**，用于自拍人脸追踪应用（见
    [*第 9 章*](B15145_09_Final_SB_epub.xhtml#_idTextAnchor224)*，自拍：制作有趣的面孔*）。
- en: The **Light Estimation** options are used when you want to emulate real-world
    lighting when rendering your virtual objects. We'll make use of this feature later
    in this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在渲染虚拟对象时模拟真实世界光照时，会使用**光照估计**选项。我们将在本章后面使用此功能。
- en: You also have the option to disable **Auto Focus** if you find that the camera
    feature is inappropriate for your AR application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现相机功能不适合您的AR应用，您还可以选择禁用**自动对焦**。
- en: Tip – When to Disable Camera Auto Focus for AR
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 - 何时禁用AR的自动对焦
- en: Ordinarily, I disable Auto Focus for AR applications. When the software uses
    the video feed to help detect planes and other features in the environment, it
    needs a clear, consistent, and detailed video feed, not one that may be continually
    changing for Auto Focus. That would make it difficult to process AR-related algorithms
    accurately to decode their tracking. On the other hand, a selfie face tracking
    app may be fine with Auto Focus enabled and could improve the user experience
    when the area behind the user loses focus due to depth of field.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我会禁用AR应用的自动对焦。当软件使用视频流来帮助检测环境中的平面和其他特征时，它需要一个清晰、一致且详细的视频流，而不是可能因自动对焦而不断变化的视频流。这会使准确处理与AR相关的算法以解码其跟踪变得困难。另一方面，自拍人脸跟踪应用可能允许启用自动对焦，并且当用户背后的区域因景深而失去焦点时，可能会改善用户体验。
- en: The **AR Pose Driver** component is responsible for updating the AR Camera's
    transform as it tracks the device in the real world. (There are similar components
    for VR headsets and hand controllers, for instance.) This component relies on
    the XR plugin and the Input XR Subsystem to supply the positional tracking data
    (see [https://docs.unity3d.com/Manual/XRPluginArchitecture.html](https://docs.unity3d.com/Manual/XRPluginArchitecture.html)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR姿态驱动器**组件负责在真实世界中跟踪设备时更新AR摄像机的变换。（例如，还有类似用于VR头戴设备和手柄的组件。）此组件依赖于XR插件和输入XR子系统来提供位置跟踪数据（见[https://docs.unity3d.com/Manual/XRPluginArchitecture.html](https://docs.unity3d.com/Manual/XRPluginArchitecture.html)）。'
- en: Our next step is to add Plane and Point Cloud visualizers to the scene.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是向场景中添加平面和点云可视化器。
- en: Adding Plane and Point Cloud managers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加平面和点云管理器
- en: When your application runs, you'll ask the user to scan the room for the AR
    software to detect features in the environment, such as depth points and flat
    planes. Usually, you'll want to show these to the user as they're detected. We
    do this by adding the corresponding feature managers to the AR Session Origin
    game object. For example, to visualize planes, you'll add an **AR Plane Manager**
    to the AR Session Origin object, while to visualize point clouds, you'll add an
    **AR Point Cloud Manager**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用运行时，您会要求用户扫描房间，以便AR软件检测环境中的特征，如深度点和平面。通常，您会在检测到这些特征时向用户展示。我们通过向AR会话原点游戏对象添加相应的特征管理器来实现这一点。例如，要可视化平面，您将向AR会话原点对象添加**AR平面管理器**，而要可视化点云，您将添加**AR点云管理器**。
- en: 'AR Foundation supports detecting and tracking the following features:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: AR Foundation支持检测和跟踪以下功能：
- en: '*Anchor*: A fixed pose (consisting of location and rotation) in the physical
    environment (controlled by the AR Anchor Manager component). This is also known
    as a Reference Point.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*锚点*：物理环境中的固定姿态（由位置和旋转组成）（由AR锚点管理器组件控制）。这也被称为参考点。'
- en: '*Reflection Probe*: Environment reflection probes for rendering shiny surface
    materials (controlled by the AR Environment Probe Manager component).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反射探针*：用于渲染具有光泽表面材料的场景反射探针（由AR环境探针管理器组件控制）。'
- en: '*Face*: A human face detected by the AR device (controlled by the AR Face Manager
    component).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人脸*：由AR设备检测到的人脸（由AR人脸管理器组件控制）。'
- en: '*Human Body*: A trackable human body and the body''s skeleton (controlled by
    the AR Human Body Manager component).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人体*：可跟踪的人体及其骨骼（由AR人体管理器组件控制）。'
- en: '*Image*: A 2D image that has been detected and tracked in the environment''s
    AR Tracked Image Manager component.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图像*：在环境中的AR跟踪图像管理器组件中检测和跟踪的二维图像。'
- en: '*Participant*: Another user (device) in a collaborative session.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参与者*：协作会话中的另一个用户（设备）。'
- en: '*Plane*: A flat plane, usually horizontally or vertically inferred from the
    point cloud (controlled by the AR Plane Manager component).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平面*：通常从点云中推断出的水平或垂直的平面（由AR平面管理器组件控制）。'
- en: '*Point Cloud*: A set of depth points detected by the AR device (controlled
    by the AR Point Cloud Manager component).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*点云*：由AR设备检测到的深度点集（由AR点云管理器组件控制）。'
- en: '*Object*: A 3D object detected and tracked in the environment (controlled by
    the AR Tracked Object Manager component).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象*：在环境中检测和跟踪的 3D 对象（由 AR 跟踪对象管理器组件控制）。'
- en: 'Not all of these are supported on every platform. See the documentation for
    your current version of AR Foundation (for example, visit [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/index.html#platform-support](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/index.html#platform-support)
    and select your version at the top left). We will be using many of these in various
    projects throughout this book. Here, we will use the Plane and Point Cloud trackables.
    Please perform the following steps to add them:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有这些功能在所有平台上都受支持。请参阅您当前版本的 AR Foundation 文档（例如，访问 [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/index.html#platform-support](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/index.html#platform-support)
    并在左上角选择您的版本）。我们将在本书的各个项目中使用其中许多功能。在这里，我们将使用平面和点云可追踪对象。请按照以下步骤添加它们：
- en: Select the **AR Session Origin** object from the **Hierarchy** window.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次结构** 窗口中选择 **AR 会话原点** 对象。
- en: Add a Point Cloud Manager by selecting `ar` in the search input field, then
    clicking **AR Point Cloud Manager**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索输入字段中选择 `ar` 并点击 **AR 点云管理器** 来添加点云管理器。
- en: Add a Plane Manager by selecting `ar` in the search input field, and clicking
    **AR Plane Manager**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索输入字段中选择 `ar` 并点击 **AR 平面管理器** 来添加平面管理器。
- en: On the AR Plane Manager, change **Detection Mode** to only horizontal planes
    by selecting **Nothing** (to clear the list), then selecting **Horizontal**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AR 平面管理器上，将 **检测模式** 更改为仅水平平面，通过选择 **无**（以清除列表），然后选择 **水平**。
- en: 'You''ll notice that the Point Cloud Manager has an empty slot for the Point
    Cloud Prefab visualizer and that the Plane Manager has an empty slot for the Plane
    Prefab visualizer. We''ll use prefabs from the Samples project, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到点云管理器有一个空槽用于点云预制件可视化器，而平面管理器有一个空槽用于平面预制件可视化器。我们将使用来自 Samples 项目的预制件，如下所示：
- en: In the **Inspector** window, go to **AR Point Cloud Manager | Point Cloud Prefab**
    and press the *doughnut* icon on the right-hand side of the field to open the
    **Select GameObject** dialog box.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中，转到 **AR 点云管理器 | 点云预制件** 并在字段右侧按下 *甜甜圈* 图标以打开 **选择游戏对象** 对话框。
- en: Click the **Assets** tab and double-click the **AR Point Cloud Visualizer**
    prefab.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **资产** 选项卡并双击 **AR 点云可视化器** 预制件。
- en: There are alternative point cloud visualizer prefabs you might like to try out
    also, such as **AR Point Cloud Debug Visualizer** and **AllPointCloudPointsPrefab**.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可能想尝试其他一些点云可视化器预制件，例如 **AR 点云调试可视化器** 和 **AllPointCloudPointsPrefab**。
- en: Likewise, for **AR Plane Manager | Plane Prefab**, press the *doughnut* icon
    on the right-hand side of the field to open the **Select GameObject** dialog box.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，对于**AR 平面管理器 | 平面预制件**，在字段右侧按下 *甜甜圈* 图标以打开 **选择游戏对象** 对话框。
- en: Click the **Assets** tab and double-click **AR Feathered Plane**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **资产** 选项卡并双击 **AR 羽毛平面**。
- en: There are alternative plane visualizer prefabs to try out also, such as **AR
    Plane Debug Visualizer**, **AR Feathered Plane Fade**, and **CheckeredPlane**.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有一些其他的平面可视化预制件可以尝试，例如 **AR 平面调试可视化器**、**AR 羽毛平面淡入** 和 **棋盘格平面**。
- en: Save the scene by going to **File | Save**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到 **文件 | 保存** 来保存场景。
- en: We're using the visualizer prefabs we got from the Samples project. Later in
    this chapter, we'll talk more about prefabs, take a closer look at the visualizer
    ones, and learn how to edit them to make our own custom visualizers. First, we'll
    add the AR Raycast Manager to the scene.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用从 Samples 项目中获得的可视化器预制件。在本章的后面部分，我们将更多地讨论预制件，更仔细地查看可视化器预制件，并学习如何编辑它们以创建我们自己的自定义可视化器。首先，我们将向场景中添加
    AR Raycast 管理器。
- en: Adding AR Raycast Manager
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 AR Raycast 管理器
- en: 'There''s another component I know we''re going to need soon, known as **AR
    Raycast Manager**. This will be used by our scripts to determine if a user''s
    screen touch corresponds to a 3D trackable feature detected by the AR software.
    We''re going to use it in our script to place an object on a plane. Perform the
    following steps to add it to the scene:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我们很快还需要另一个组件，称为 **AR Raycast 管理器**。这个组件将由我们的脚本用于确定用户的屏幕触摸是否对应于 AR 软件检测到的
    3D 跟踪特征。我们将在脚本中使用它来在平面上放置对象。按照以下步骤将其添加到场景中：
- en: Select the **AR Session Origin** object from the **Hierarchy** window.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次结构** 窗口中选择 **AR 会话原点** 对象。
- en: Select `ar` in the search input field, and click **AR Raycast Manager**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索输入字段中输入`ar`，然后点击**AR射线投射管理器**。
- en: 'The **AR Session Origin** GameObject with the manager components we added now
    looks like this in the **Inspector** window:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，我们现在可以看到我们添加的管理组件的**AR会话原点**GameObject看起来是这样的：
- en: '![](img/Figure_2.07-arorigin-withmanagers.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_2.07-arorigin-withmanagers.jpg)'
- en: Figure 2.7 – AR Session Origin with various manager components
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 带有各种管理组件的AR会话原点
- en: One more thing that's handy to include is light estimation, which helps with
    rendering your virtual objects more realistically.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方便包含的功能是光估计，它有助于更真实地渲染您的虚拟对象。
- en: Adding Light Estimation
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加光估计
- en: By adding a Light Estimation component to your Directional Light source, the
    AR camera can use this information when rendering your scene to try and match
    the scene's lighting more closely to the real-world environment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向您的方向光源添加光估计组件，AR摄像头可以在渲染场景时使用这些信息，尝试使场景的照明更接近真实世界环境。
- en: 'To add light estimation, perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加光估计，执行以下步骤：
- en: In the **Hierarchy** window, select the **Directional Light** object.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中，选择**方向光**对象。
- en: In the `light estimation`, and add the **Basic Light Estimation** component.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`光估计`中，添加**基本光估计**组件。
- en: In the **Hierarchy** window, find **AR Camera** (child of AR Session Origin),
    drag it into the **Inspector** window, and drop it onto the **Light Estimation
    | Camera Manager** slot.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中，找到**AR摄像头**（AR会话原点的子项），将其拖入**检查器**窗口，并将其放置在**光估计 | 摄像头管理器**槽中。
- en: In the **Hierarchy** window, select **AR Camera**, then set **AR Camera Manager
    | Light Estimation** to **Everything**. Note that not all platforms support all
    light estimation capabilities, but using the **Everything** flags will have them
    use all of the ones that are available at runtime.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中，选择**AR摄像头**，然后将**AR摄像头管理器 | 光估计**设置为**全部**。请注意，并非所有平台都支持所有光估计功能，但使用**全部**标志将使它们在运行时使用所有可用的功能。
- en: Save your work by going to **File | Save**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**文件 | 保存**来保存您的作品。
- en: Good! I think we should try to build and run what we have done so far and make
    sure it's working.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我认为我们应该尝试构建并运行到目前为止所做的工作，并确保它正在运行。
- en: Building and running the scene
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行场景
- en: 'Currently, the scene initializes an AR Session, enables the AR camera to scan
    the environment, detects points and horizontal planes, and renders these on the
    screen using visualizers. Let''s build the scene and make sure it runs:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，场景初始化AR会话，启用AR摄像头扫描环境，检测点和平面，并使用可视化工具在屏幕上渲染这些内容。让我们构建场景并确保它运行：
- en: Open the **Build Settings** window by going to **File | Build Settings**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**文件 | 构建设置**来打开**构建设置**窗口。
- en: For the **Scenes in Build** list, click the **Add Open Scenes** button and uncheck
    all the scenes in the list other than this current scene (mine is named **BasicARScene**).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**构建中的场景**列表，点击**添加打开场景**按钮，并取消选中列表中除当前场景之外的所有场景（我的场景名为**BasicARScene**）。
- en: Ensure your device is connected to your computer via USB.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的设备通过USB连接到您的电脑。
- en: Press the `Builds/`. Give it a filename (if required) and press **Save**. It
    may take a while to complete this task.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 `Builds/`。如果需要，输入一个文件名，然后按**保存**。完成这个任务可能需要一些时间。
- en: The app should successfully build and run on your device. If you encounter any
    errors, please read the error messages carefully in the **Console** window. Then,
    review each of the setup steps detailed in this chapter and [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*,
    Setting Up for AR Development*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 应用应该能够在您的设备上成功构建和运行。如果您遇到任何错误，请仔细阅读**控制台**窗口中的错误消息。然后，回顾本章和[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*，设置AR开发环境*中详细说明的每个设置步骤。
- en: When the app launches, you should see a video feed on your screen. Move the
    device slowly in different directions and closer/away. As it scans the environment,
    feature points and planes will be detected and rendered on the screen using the
    visualizers you chose.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用启动时，您应该在屏幕上看到一个视频流。慢慢将设备向不同方向移动，靠近或远离。当它扫描环境时，特征点和平面将被检测并在屏幕上使用您选择的可视化工具渲染。
- en: Next, let's add the ability to tap on one of the planes to instantiate a 3D
    object there.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个功能，可以点击其中一个平面以在那里实例化一个3D对象。
- en: Placing an object on a plane
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在平面上放置一个对象
- en: 'We will now add the ability for the user to tap on a plane and place a 3D virtual
    object in the scene. There are several parts to implementing this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加用户在平面上点击并放置 3D 虚拟对象在场景中的功能。实现这一功能有几个部分：
- en: Setting up a Place Object input action when the user taps the screen.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击屏幕时设置放置对象输入动作。
- en: Writing a PlaceObjectOnPlane script that responds to the input action and places
    an object on the plane.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 PlaceObjectOnPlane 脚本，该脚本响应输入动作并在平面上放置一个对象。
- en: Determining which plane and where to place the object using AR Raycast Manager.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AR Raycast Manager 确定放置对象的位置和平面。
- en: Importing a 3D model and making it a prefab for placing in this scene.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 3D 模型并将其制作成预制件以放置在此场景中。
- en: Let's begin by creating an input action for a screen tap.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个屏幕点击的输入动作开始。
- en: Setting up a PlaceObject input action
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 PlaceObject 输入动作
- en: We are going to use the Unity Input System package for user input. If the Input
    System is new to you, the steps in this section may seem complicated, but only
    because of its great versatility.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Unity 输入系统包来处理用户输入。如果您对输入系统不熟悉，本节中的步骤可能看起来很复杂，但这只是因为它的多功能性。
- en: The Input System lets you define **Actions** that separate the logical meaning
    of the input from the physical means of the input. Using named actions is more
    meaningful to the application and programmers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输入系统允许您定义 **动作**，这些动作将输入的逻辑意义与物理输入方式分开。使用命名动作对应用程序和程序员来说更有意义。
- en: Note – Input System Tutorial
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 – 输入系统教程
- en: For a more complete tutorial on using the Input System package, see [https://learn.unity.com/project/using-the-input-system-in-unity](https://learn.unity.com/project/using-the-input-system-in-unity).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解使用输入系统包的更完整教程，请参阅 [https://learn.unity.com/project/using-the-input-system-in-unity](https://learn.unity.com/project/using-the-input-system-in-unity)。
- en: Here, we will define a **PlaceObject** action that is bound to screen tap input
    data. We'll set this up now, and then use this input action in the next section
    to find the AR plane that was tapped and place a virtual object there.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一个与屏幕点击输入数据绑定的 **PlaceObject** 动作。我们将现在设置它，然后在下一节中使用这个输入动作来找到被点击的 AR
    平面并在那里放置一个虚拟对象。
- en: 'Before we begin, I will assume you have already imported the **Input System**
    package via **Package Manager** and set **Active Input Handing** to **Input System
    Package** (or **Both**) in **Player Settings**. Now, follow these steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我将假设您已经通过 **包管理器** 导入了 **输入系统** 包，并在 **玩家设置** 中将 **活动输入处理** 设置为 **输入系统包**（或
    **两者**）。现在，按照以下步骤操作：
- en: In the `Inputs` using *right-click* `_App/` folder.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `输入` 中使用 *右键点击* `_App/` 文件夹。
- en: Create an input action controller asset by *right-clicking* inside the `Inputs`
    folder, then selecting `AR Input Actions`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `输入` 文件夹内 *右键点击*，然后选择 `AR 输入动作` 来创建一个输入动作控制器资产。
- en: Click **Edit Asset** to open its editor window.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **编辑资产** 以打开其编辑器窗口。
- en: In the leftmost `ARTouchActions`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最左侧的 `ARTouchActions`。
- en: In the middle `PlaceObject` using *right-click* | **Rename**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间的 `PlaceObject` 中使用 *右键点击* | **重命名**。
- en: In the right-hand side **Properties** panel, set **Action Type** to **Value**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的 **属性** 面板中，将 **动作类型** 设置为 **值**。
- en: Set its **Control Type** to **Vector 2**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **控制类型** 设置为 **Vector 2**。
- en: In the middle **Actions** panel, click the child **<No Binding>** item to add
    a binding.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间的 **动作** 面板中，点击子项 **<无绑定>** 以添加绑定。
- en: In the right-hand side **Properties** panel, under **Binding**, using the **Path**
    select list, choose **TouchScreen | Primary Touch | Position**.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的 **属性** 面板下 **绑定** 中，使用 **路径** 选择列表，选择 **TouchScreen | Primary Touch | Position**。
- en: At the top of the window, click **Save Asset** (unless the **Auto-Save** checkbox
    is checked).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口顶部，点击 **保存资产**（除非已勾选 **自动保存** 复选框）。
- en: 'With that, we''ve created a data asset named `Vector2`) with the X, Y values
    in pixel coordinates. The input action asset is shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们创建了一个名为 `Vector2` 的数据资产，其中包含像素坐标中的 X、Y 值。输入动作资产在以下屏幕截图中显示：
- en: '![Figure 2.8 – Our AR Input Actions set up for screen taps'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – 我们为屏幕点击设置的 AR 输入动作'
- en: '](img/Figure_2.08-ar-input-action.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.08-ar-input-action.jpg)'
- en: Figure 2.8 – Our AR Input Actions set up for screen taps
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 我们为屏幕点击设置的 AR 输入动作
- en: 'Now, we can add the input actions to the scene. This can be done via a Player
    Input component. For our AR scene, we''ll add a Player Input component to the
    AR Session Origin, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将输入动作添加到场景中。这可以通过玩家输入组件来完成。对于我们的 AR 场景，我们将在 AR Session Origin 上添加一个玩家输入组件，如下所示：
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口中，选择 **AR Session Origin** 对象。
- en: In its **Inspector** window, click **Add Component | Input | Player Input**.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其 **Inspector** 窗口中，点击 **Add Component | Input | Player Input**。
- en: From the `Inputs/` folder into the **Player Input | Actions** slot in the **Inspector**
    window.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Inputs/` 文件夹到 **Inspector** 窗口中的 **Player Input | Actions** 插槽。
- en: Leave `On`" prefix (for example, `OnPlaceObject`) and receives an `InputValue`
    argument ([https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputValue.html](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputValue.html)).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 留下 `On` 前缀（例如，`OnPlaceObject`）并接收一个 `InputValue` 参数([https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputValue.html](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputValue.html))。
- en: '*Broadcast Messages*: Like Send Messages, Broadcast Messages will send messages
    to components on this GameObject *and all its children* ([https://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html](https://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html)).'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*广播消息*: 与 Send Messages 类似，广播消息将向此 GameObject 的组件及其所有子组件发送消息([https://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html](https://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html))。'
- en: '*Invoke Unity Events*: You can set event callback functions using the Inspector
    or in scripts ([https://docs.unity3d.com/Manual/UnityEvents.html](https://docs.unity3d.com/Manual/UnityEvents.html)).
    The callback function receives an `InputAction.CallbackContext` argument ([https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputAction.CallbackContext.html)](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputAction.CallbackContext.html)).'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*调用 Unity 事件*: 你可以使用 Inspector 或在脚本中设置事件回调函数([https://docs.unity3d.com/Manual/UnityEvents.html](https://docs.unity3d.com/Manual/UnityEvents.html))。回调函数接收一个
    `InputAction.CallbackContext` 参数([https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputAction.CallbackContext.html)](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputAction.CallbackContext.html))。'
- en: '*Invoke C# Events*: You can set event listeners in scripts ([https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/)).'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*调用 C# 事件*: 你可以在脚本中设置事件监听器([https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/))。'
- en: To learn more about the Player Input component, see [https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.PlayerInput.html](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.PlayerInput.html).
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解更多关于 Player Input 组件的信息，请参阅 [https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.PlayerInput.html](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.PlayerInput.html)。
- en: I've decided to use `OnPlaceObject` function, which we'll do next. But first,
    I'll provide a quick introduction to Unity C# programming.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经决定使用 `OnPlaceObject` 函数，我们将在下一部分进行操作。但首先，我将提供一个关于 Unity C# 编程的快速介绍。
- en: Introducing Unity C# programming and the MonoBehaviour class
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Unity C# 编程和 MonoBehaviour 类
- en: 'Writing C# scripts is an essential skill for every Unity developer. You don''t
    need to be an expert programmer, but you cannot avoid writing some code to make
    your projects work. If you are new to coding, you can simply follow the instructions
    provided here, and over time, you''ll get more comfortable and proficient. I also
    encourage you to go through some of the great beginner tutorials provided by Unity
    ([https://learn.unity.com/](https://learn.unity.com/)) and others, including the
    following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 C# 脚本是每个 Unity 开发者必备的技能。你不需要成为编程专家，但无法避免编写一些代码来使你的项目工作。如果你是编程新手，可以简单地遵循这里提供的说明，随着时间的推移，你会变得更加熟练。我也鼓励你学习
    Unity 提供的一些优秀的入门教程([https://learn.unity.com/](https://learn.unity.com/))以及其他教程，包括以下内容：
- en: '**Coding in C# in Unity for Beginners**: https://unity3d.com/learning-c-sharp-in-unity-for-beginners'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity 中 C# 编程入门**: https://unity3d.com/learning-c-sharp-in-unity-for-beginners'
- en: '**Working with Scripts**: [https://learn.unity.com/tutorial/working-with-scripts](https://learn.unity.com/tutorial/working-with-scripts)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与脚本一起工作**: [https://learn.unity.com/tutorial/working-with-scripts](https://learn.unity.com/tutorial/working-with-scripts)'
- en: '**Beginner Scripting**: https://learn.unity.com/project/beginner-gameplay-scripting'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入门脚本编程**: https://learn.unity.com/project/beginner-gameplay-scripting'
- en: Given that, I will offer some brief explanations as we work through this section.
    But I'll assume that you have at least a basic understanding of C# language syntax,
    common programming vocabulary (for example, *class*, *variable*, and *function*),
    using an editor such as Visual Studio, and how to read error messages that may
    appear in your **Console** window due to typos or other common coding mistakes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 既然如此，当我们通过这一节时，我会提供一些简要的解释。但我会假设您至少对C#语言语法、常见的编程词汇（例如，*类*、*变量*和*函数*）、使用编辑器（例如Visual
    Studio）以及如何阅读由于打字错误或其他常见的编码错误而在您的**控制台**窗口中出现的错误消息有基本的了解。
- en: 'We''re going to create a new script named `PlaceObjectOnPlane`. Then, we can
    attach this script as a component to a GameObject in the scene. It will then appear
    in the object''s **Inspector** window. Let''s begin by performing the following
    steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`PlaceObjectOnPlane`的新脚本。然后，我们可以将此脚本作为组件附加到场景中的GameObject上。它将随后出现在对象的**检查器**窗口中。让我们首先执行以下步骤：
- en: In the `Scripts/` folder (mine is `Assets/_App/Scripts/`), *right-click* it,
    and select **Create | C# Script**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts/`文件夹中（我的文件夹是`Assets/_App/Scripts/`），右键单击它，然后选择**创建 | C# 脚本**。
- en: Name the file `PlaceObjectOnPlane` (no spaces nor other special characters are
    allowed in the name, and it should start with a capital letter).
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件命名为`PlaceObjectOnPlane`（文件名中不允许有空格或其他特殊字符，并且应以大写字母开头）。
- en: This creates a new C# script with the `.cs` file extension (although you don't
    see the extension in the **Project** window).
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个具有`.cs`文件扩展名的新C#脚本（尽管您在**项目**窗口中看不到扩展名）。
- en: Double-click the **PlaceObjectOnPlane** file to open it in your code editor.
    By default, my system uses Microsoft Visual Studio.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**PlaceObjectOnPlane**文件以在您的代码编辑器中打开它。默认情况下，我的系统使用Microsoft Visual Studio。
- en: 'As you can see in the following initial script content of the template, the
    `PlaceObjectOnPlane.cs` file declares a C# class, `PlaceObjectsOnPlane`, that
    has the same name as the `.cs` file (the names *must* match; otherwise, it will
    cause compile errors in Unity):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下模板的初始脚本内容中看到的，`PlaceObjectOnPlane.cs`文件声明了一个名为`PlaceObjectsOnPlane`的C#类，其名称与`.cs`文件相同（名称*必须*匹配；否则，将在Unity中引起编译错误）：
- en: '[PRE0]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first three lines in this script have a `using` directive, which declares
    an SDK library, or namespace, that will be used in the script. When a script references
    external symbols, the compiler needs to know where to find them. In this case,
    we're saying that we'll potentially be using standard .NET system libraries for
    managing sets of objects (*collections*). And here, we are using the UnityEngine
    API.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中的前三行有一个`using`指令，它声明了一个将用于脚本中的SDK库或命名空间。当脚本引用外部符号时，编译器需要知道它们的位置。在这种情况下，我们说的是我们可能会使用标准.NET系统库来管理对象集合（*集合*）。在这里，我们正在使用Unity
    API。
- en: One of the symbols defined by *UnityEngine* is the `PlaceObjectsOnPlane` class
    is declared as a subclass of `MonoBehaviour`. (Beware its British spelling, "iour").
    Scripts attached to a GameObject in your scene must be a subclass of `MonoBehaviour`,
    which provides a litany of features and services related to the GameObject where
    it is attached.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*UnityEngine*定义的符号之一是`PlaceObjectsOnPlane`类被声明为`MonoBehaviour`的子类。（请注意其英式拼写，“iour”）。附加到场景中GameObject的脚本必须是`MonoBehaviour`的子类，它提供了一系列与附加的GameObject相关的功能和服务的功能。'
- en: For one, `MonoBehaviour` provides hooks into the GameObject life cycle and the
    Unity `Start()` function will automatically be called. This is a good place to
    add some initialization code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`MonoBehaviour`提供了对GameObject生命周期和Unity `Start()`函数的钩子。这是一个添加一些初始化代码的好地方。
- en: The Unity game engine's main purpose is to render the current scene view every
    frame, perhaps 60 times per second or more. Each time the frame is updated, your
    `Update()` function will automatically be called. This is where you put any runtime
    code that needs to be run every frame. Try to keep the amount of work that's done
    in `Update()` to a minimum; otherwise, your app may feel slow and sluggish.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Unity游戏引擎的主要目的是每帧渲染当前场景视图，可能是每秒60次或更多。每次帧更新时，您的`Update()`函数将自动被调用。这就是您放置需要每帧运行的任何运行时代码的地方。尽量保持`Update()`中完成的工作量最小；否则，您的应用程序可能会感觉缓慢和笨拙。
- en: 'You can learn more about the MonoBehaviour class here: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
    To get a complete picture of the GameObject and MonoBehaviour scripts'' life cycles,
    take a look at this flowchart here: [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于 MonoBehaviour 类的信息：[MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)。要全面了解
    GameObject 和 MonoBehaviour 脚本的生命周期，请查看此流程图：[执行顺序](https://docs.unity3d.com/Manual/ExecutionOrder.html)。
- en: We can now write our script. Since this is the first script in this book, I'll
    present it slowly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写脚本。由于这是本书中的第一个脚本，我会慢慢展示。
- en: Writing the PlaceObjectOnPlane script
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 PlaceObjectOnPlane 脚本
- en: 'The purpose of the `PlaceObjectOnPlane` script is to place a virtual object
    on the AR plane when and where the user taps. We''ll outline the logic first (in
    C#, any text after `//` on the same line is a comment):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaceObjectOnPlane` 脚本的目的是在用户触摸时将虚拟对象放置在 AR 平面上。我们首先概述逻辑（在 C# 中，同一行后面的任何文本
    `//` 都是注释）：'
- en: '[PRE1]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As it turns out, in this script, there is no need for an `Update` function as
    it is only used for frame updates, which this script can ignore.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在此脚本中不需要 `Update` 函数，因为它仅用于帧更新，而此脚本可以忽略这些更新。
- en: This script implements `OnPlaceObject`, which is called when the user taps the
    screen. As we mentioned previously, the Player Input component we added to the
    AR Session Origin uses the `OnPlacedObject` for the `InputValue`. Notice that
    I also added a line using `UnityEngine.InputSystem;`, which defines the `InputValue`
    class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本实现了 `OnPlaceObject` 方法，该方法在用户触摸屏幕时被调用。正如我们之前提到的，我们添加到 AR Session Origin 的
    Player Input 组件使用 `OnPlacedObject` 作为 `InputValue`。请注意，我还添加了一行使用 `UnityEngine.InputSystem;`，它定义了
    `InputValue` 类。
- en: 'First, we need to get the screen touch position from the input value we passed
    in. Add the following code, which declares and assigns it to the `touchPosition`
    local variable:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从传递的输入值中获取屏幕触摸位置。添加以下代码，它声明并分配给局部变量 `touchPosition`：
- en: '[PRE2]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to figure out if the screen touch corresponds to a plane that
    was detected in the AR scene. AR Foundation provides a solution by using the AR
    Raycast Manager component that we added to the AR Session Origin GameObject earlier.
    We''ll use it in our script now. Add these lines to the top of your script:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定屏幕触摸是否对应于在 AR 场景中检测到的平面。AR Foundation 通过使用我们之前添加到 AR Session Origin GameObject
    的 AR Raycast Manager 组件来提供解决方案。现在，我们将使用它来编写脚本。将以下行添加到脚本顶部：
- en: '[PRE3]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, inside the `OnPlaceObject` function, add the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `OnPlaceObject` 函数内部，添加以下代码：
- en: '[PRE4]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Firstly, we get a reference to the `raycaster`. We declare and initialize a
    list of `ARRaycastHit`, which will be populated when the raycast finds something.
    Then, we call `raycaster.Raycast()`, passing in the screen's `touchPosition`,
    and a reference to the `hits` list. If it finds a plane, it'll return `true` and
    populate the `hits` list with details. The third argument instructs `raycaster.Raycast`
    on what kinds of trackables can be hit. In this case, `PlaneWithinPolygon` filters
    for 2D convex-shaped planes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取 `raycaster` 的引用。我们声明并初始化一个 `ARRaycastHit` 列表，当射线检测到物体时，该列表将被填充。然后，我们调用
    `raycaster.Raycast()`，传入屏幕的 `touchPosition` 和 `hits` 列表的引用。如果找到平面，它将返回 `true`
    并将 `hits` 列表填充详细信息。第三个参数指示 `raycaster.Raycast` 可以击中的跟踪类型。在这种情况下，`PlaneWithinPolygon`
    过滤器用于 2D 凸多边形平面。
- en: Information – For More Information on AR Raycasting
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 - 关于 AR 射线投射的更多信息
- en: For more information on using ARRaycastManager, see [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/raycast-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/raycast-manager.html).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用 ARRaycastManager 的更多信息，请参阅[这里](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/raycast-manager.html)。
- en: For a list of trackable types you can pass in, see [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.1/api/UnityEngine.XR.ARSubsystems.TrackableType.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.1/api/UnityEngine.XR.ARSubsystems.TrackableType.html).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[可传递的跟踪类型列表](https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.1/api/UnityEngine.XR.ARSubsystems.TrackableType.html)中查看。
- en: 'The code inside the `if` statement will only be executed if `raycaster.Raycast`
    returns `true`; that is, if the user had tapped a location on the screen that
    casts to a trackable plane in the scene. In that case, we must create a 3D GameObject
    there. In Unity, creating a new GameObject is referred to as **instantiating**
    the object. You can read more about it here: [https://docs.unity3d.com/Manual/InstantiatingPrefabs.html](https://docs.unity3d.com/Manual/InstantiatingPrefabs.html).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句内的代码只有在`raycaster.Raycast`返回`true`时才会执行；也就是说，如果用户在屏幕上点击了一个可以投射到场景中可追踪平面的位置。在这种情况下，我们必须在那里创建一个3D
    GameObject。在Unity中，创建一个新的GameObject被称为**实例化**对象。您可以在此处了解更多信息：[https://docs.unity3d.com/Manual/InstantiatingPrefabs.html](https://docs.unity3d.com/Manual/InstantiatingPrefabs.html)。'
- en: 'First, let''s declare a variable, `placedPrefab`, to hold a reference to the
    prefab that we want to instantiate on the selected plane. Using the `[SerializedField]`
    directive permits the property to be visible and settable in the Unity Inspector.
    We''ll also declare a `private` variable, `spawnedObject`, that holds a reference
    to the instantiated object. Add the following code to the top of the class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们声明一个变量`placedPrefab`，用于保存我们想要在所选平面上实例化的预制体的引用。使用`[SerializedField]`指令允许属性在Unity检查器中可见并可设置。我们还将声明一个`private`变量`spawnedObject`，它保存已实例化对象的引用。将以下代码添加到类顶部：
- en: '[PRE5]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, inside the `if` statement, we will instantiate a new object if this is
    the first time the user has tapped the screen, and then assign it to `spawnedObject`.
    If the object had already been spawned and the user taps the screen again, we''ll
    move the object to the new location instead. Add the following highlighted code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`if`语句内部，如果这是用户第一次点击屏幕，我们将实例化一个新的对象，并将其分配给`spawnedObject`。如果对象已经实例化并且用户再次点击屏幕，我们将把对象移动到新位置。添加以下突出显示的代码：
- en: '[PRE6]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Raycast` populates a list of hit points, as there could be multiple trackable
    planes in line where the user has tapped the screen. They''re sorted closest to
    furthest, so in our case, we''re only interested in the first one, `hits[0]`.
    From there, we get the point''s `Pose`, a simple structure that includes 3D position
    and rotation values. These, in turn, are used when placing the object.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`Raycast`填充了一个包含击中点的列表，因为用户点击屏幕的线上可能有多个可追踪的平面。它们按从近到远的顺序排序，所以在这种情况下，我们只对第一个感兴趣，即`hits[0]`。从那里，我们获取点的`Pose`，这是一个包含3D位置和旋转值的简单结构。这些值在放置对象时被使用。'
- en: After that, save the script file.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，保存脚本文件。
- en: 'Now, back in Unity, we''ll attach our script as a component to **AR Session
    Origin** by performing the following steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到Unity中，我们将通过以下步骤将我们的脚本作为组件附加到**AR Session Origin**：
- en: First, check the **Console** window (using the **Console** tab or **Window |
    General | Console**) and ensure there are no compile errors from the script. If
    there are, go back to your code editor and fix them.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查**控制台**窗口（使用**控制台**选项卡或**窗口 | 通用 | 控制台**）并确保没有来自脚本的编译错误。如果有，请回到您的代码编辑器并修复它们。
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中，选择**AR Session Origin**对象。
- en: In the `placedPrefab` variable we declared in the script. Let's populate it
    with the red cube prefab provided by the Samples assets.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中声明的`placedPrefab`变量中。让我们用Samples资源提供的红色立方体预制体填充它。
- en: In the `ARF-samples/Prefabs/` folder.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ARF-samples/Prefabs/`文件夹中。
- en: Drag the **AR Placed Cube** prefab into the **Inspector** window, on the **Place
    Object On Plane | Placed Prefab** slot.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR Placed Cube**预制体拖动到**检查器**窗口中的**Place Object On Plane | Placed Prefab**槽位。
- en: Save the scene by going to **File | Save**.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**文件 | 保存**来保存场景。
- en: 'Our script, as a component on the AR Session Origin GameObject, should now
    look as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为组件在AR Session Origin GameObject上的脚本现在应该如下所示：
- en: '![Figure 2.9 – PlaceObjectOnPlane as a component with its Placed Prefab slot
    populated'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – 将PlaceObjectOnPlane作为组件使用，其Placed Prefab槽位已填充]'
- en: '](img/Figure_2.09-placeobjectonplane-inspector.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.09 – 在检查器中放置对象在平面上](img/Figure_2.09-placeobjectonplane-inspector.jpg)'
- en: Figure 2.9 – PlaceObjectOnPlane as a component with its Placed Prefab slot populated
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 将PlaceObjectOnPlane作为组件使用，其Placed Prefab槽位已填充
- en: Let's try it! We're now ready to build and run the scene.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试！我们现在准备好构建和运行场景。
- en: Building and running the scene
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行场景
- en: 'If you''ve built the scene before, in the previous section, you can go to **File
    | Build And Run** to start the process. Otherwise, perform the following steps
    to build and run the scene:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前已经构建了场景，在上一节中，您可以访问**文件 | 构建并运行**以启动此过程。否则，执行以下步骤来构建和运行场景：
- en: Open the **Build Settings** window by going to **File | Build Settings**.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**文件 | 构建设置**来打开**构建设置**窗口。
- en: For the **Scenes in Build** list, click the **Add Open Scenes** button and uncheck
    all the scenes in the list other than this one (mine is named **BasicARScene**).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**构建中的场景**列表，点击**添加打开场景**按钮，取消勾选列表中除这个场景之外的所有场景（我的名为**BasicARScene**）。
- en: Ensure your device is connected via USB.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的设备通过USB连接。
- en: Press the `Builds/`. Give it a filename (if required) and press `Update()` into
    `Start()` (for example, initialize the `raycaster` variable).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下`Builds/`。如果需要，输入一个文件名，然后按`Update()`按钮将其更新为`Start()`（例如，初始化`raycaster`变量）。
- en: Avoid allocating new memory in `Update()` to avoid memory fragmentation and
    garbage collection (for example, initialize the `hits` list as a class variable).
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免在`Update()`中分配新的内存，以避免内存碎片化和垃圾回收（例如，将`hits`列表初始化为类变量）。
- en: 'The modified script is shown in the following code block. The changed code
    is highlighted, beginning with the top part, which contains the new class variables
    and the `Start()` function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的脚本如下所示。更改的代码以顶部部分开始，其中包含新的类变量和`Start()`函数：
- en: '[PRE7]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, add the `OnPlacedObject` function, as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`OnPlacedObject`函数，如下所示：
- en: '[PRE8]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: if (raycaster.Raycast(touchPosition, hits, TrackableType.PlaneWithinPolygon))
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: if (raycaster.Raycast(touchPosition, hits, TrackableType.PlaneWithinPolygon))
- en: '[PRE9]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Please save the script, then build and run it one more time to verify it still
    works.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请保存脚本，然后再次构建并运行它以验证它仍然有效。
- en: Information – Public versus Private and Object Encapsulation
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 - 公共与私有以及对象封装
- en: One of the driving principles of object-oriented programming is `private` and
    `public` declarations for this purpose. And in C#, any symbol not declared public
    is assumed to be private. In Unity, any public variables are also visible (serialized)
    in the Inspector window when the script is attached to a GameObject as a component.
    Ordinarily, private variables are not visible. Using the `[SerializeField]` directive
    enables a private variable to also be visible and modifiable in the Inspector
    window.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的驱动原则之一是为此目的进行`private`和`public`声明。在C#中，任何未声明为`public`的符号都假定是私有的。在Unity中，任何公共变量在脚本作为组件附加到游戏对象时，在检查器窗口中也是可见的（序列化的）。通常，私有变量是不可见的。使用`[SerializeField]`指令可以使私有变量在检查器窗口中也可见并可修改。
- en: Congratulations! It's not necessarily a brilliant app, and it's modeled after
    the example scenes found in the Samples projects, but you started from **File
    | New Scene** and built it up all on your own. Now, let's have a little fun with
    it and find a 3D model that's a little more interesting than a little red cube.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这并不一定是一个出色的应用程序，它是根据Samples项目中的示例场景建模的，但你从**文件 | 新场景**开始，完全自己构建了它。现在，让我们玩玩它，找到一个比小红立方体更有趣的3D模型。
- en: Creating a prefab for placing
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于放置的预制件
- en: The prefab object we've been placing on the planes in this chapter is the one
    named *AR Placed Cube*, which we imported from the AR Foundation Samples project.
    Let's find a different, more interesting, model to use instead. In the process,
    we'll learn a bit more about GameObjects, Transforms, and prefabs.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中放置在平面的预制件对象是名为*AR Placed Cube*的对象，它是从AR Foundation Samples项目中导入的。让我们找到一个不同、更有趣的模型来使用。在这个过程中，我们将了解更多关于游戏对象、变换和预制件的知识。
- en: Understanding GameObjects and Transforms
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解游戏对象和变换
- en: 'I think a good place to start is by taking a closer look at the *AR Placed
    Cube* prefab we''ve been using. Let''s open it in the Editor by performing the
    following steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为一个好的开始是仔细看看我们一直在使用的*AR Placed Cube*预制件。让我们通过以下步骤在编辑器中打开它：
- en: In the `ARF-samples/Prefabs/` folder.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ARF-samples/Prefabs/`文件夹中。
- en: Double-click the **AR Placed Cube** prefab.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**AR Placed Cube**预制件。
- en: 'We are now editing the prefab, as shown in the following screenshot (I have
    rearranged my windows differently from the default layout):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在编辑预制件，如下面的截图所示（我已将我的窗口布局调整为与默认布局不同）：
- en: '![Figure 2.10 – Editing the AR Placed Cube prefab'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.10 – Editing the AR Placed Cube prefab'
- en: '](img/Figure_2.10-arplacedcube-edit.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_2.10-arplacedcube-edit.jpg](img/Figure_2.10-arplacedcube-edit.jpg)'
- en: Figure 2.10 – Editing the AR Placed Cube prefab
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 编辑AR Placed Cube预制件
- en: The `0, 0, 0`), `0, 0, 0`), and `1, 1, 1`).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`(0, 0, 0)`), `(0, 0, 0)`), 和 `(1, 1, 1)`）。'
- en: Beneath the AR Placed Cube is a child `0.05, 0.05, 0.05`). These units are in
    meters (0.05 meters is about 2 inches per side). And that's its size when it's
    placed in the physical environment with our app.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置在AR立方体下面的子立方体是`0.05, 0.05, 0.05`（单位是米，0.05米大约是每边2英寸）。这就是它在我们的应用物理环境中放置时的尺寸。
- en: You'll also notice that the child Cube's X-Y-Z `0, 0.025, 0`), where Y in Unity
    is the up-axis. As 0.025 is half of 0.05, we've raised the cube half its height
    above the zero X-Z plane.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到子立方体的X-Y-Z坐标`0, 0.025, 0`），在Unity中，Y轴是向上轴。由于0.025是0.05的一半，我们将立方体提升到其高度的一半以上零X-Z平面。
- en: The origin of a Cube is its center. So, the origin of the AR Placed Cube is
    the bottom of the child Cube. In other words, when we place this prefab in the
    scene, the cube's bottom side rests on the pose position, as determined by the
    *hit* raycast.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体的原点是它的中心。因此，AR放置立方体的原点是子立方体的底部。换句话说，当我们放置这个预制件在场景中时，立方体的底部侧面位于由*射线投射*确定的姿态位置。
- en: Parenting a model with an empty GameObject to normalize its scale and adjust
    its origin is a common pattern in Unity development.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空的GameObject来归一化模型的比例并调整其原点，在Unity开发中是一个常见的模式。
- en: Now, let's find a different model for our app and normalize its Transform as
    we make it a prefab.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的应用找到一个不同的模型，并在将其制作成预制件时对其进行归一化。
- en: Finding a 3D model
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找3D模型
- en: To find a 3D model, feel free to search the internet for a 3D model you like.
    If you're a 3D artist, you may already have ones of your own. You will want a
    relatively simple, low-poly model (that is, with not many polygons). Look for
    files in `.FBX` or `.OBJ` format, as they will import into Unity without conversion.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个3D模型，你可以自由地在互联网上搜索你喜欢的3D模型。如果你是3D艺术家，你可能已经有了自己的模型。你将需要一个相对简单、低多边形的模型（即多边形数量不多）。寻找`.FBX`或`.OBJ`格式的文件，因为它们将无需转换即可导入Unity。
- en: 'I found a model of a virus microbe on `cgtrader.com` here: [https://www.cgtrader.com/free-3d-models/science/medical/microbe](https://www.cgtrader.com/free-3d-models/science/medical/microbe).
    It is a free download and royalty-free, has 960 polygons, and is available in
    FBX format. My file is named `uploads_files_745381_Microbe.fbx`.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`cgtrader.com`这里找到了一个病毒微生物的模型：[https://www.cgtrader.com/free-3d-models/science/medical/microbe](https://www.cgtrader.com/free-3d-models/science/medical/microbe)。这是一个免费下载且无版税的模型，有960个多边形，以FBX格式提供。我的文件名为`uploads_files_745381_Microbe.fbx`。
- en: 'Once you''ve found a file and downloaded it to your computer, perform the following
    steps to import it into Unity:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了文件并将其下载到你的电脑上，执行以下步骤将其导入Unity中：
- en: In the `Models` under your `_App` folder (this step is optional).
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`_App`文件夹下的`Models`中（这一步是可选的）。
- en: Drag the model from your Windows File Explorer or macOS Finder into the `Models`
    folder to import it into the project. Alternatively, you can use the main menu
    by clicking **Assets | Import New Asset**.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型从你的Windows文件资源管理器或macOS Finder拖到`Models`文件夹中，以将其导入到项目中。或者，你也可以通过主菜单点击**Assets
    | Import New Asset**。
- en: When you select the model in the **Project** window, you can review it in the
    **Inspector** window. While there, take a look at the many **Import Settings**.
    Generally, you can keep their default values.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在**Project**窗口中选择模型时，你可以在**Inspector**窗口中查看它。在那里，看看许多**导入设置**。通常，你可以保持它们的默认值。
- en: 'Now, we''ll make a prefab of the model and make sure it''s been scaled to a
    usable size. I like to use a temporary Cube object to measure it:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将制作模型的预制件，并确保它已缩放到可用的尺寸。我喜欢使用临时的立方体对象来测量它：
- en: In the `Prefabs` under your `_App` folder (this step is optional).
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`_App`文件夹下的`Prefabs`中（这一步是可选的）。
- en: Right-click inside the `Prefabs` folder, select `Virus`).
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prefabs`文件夹内右键点击，选择`Virus`）。
- en: Double-click the new prefab, or click its **Open Prefab** button in the **Inspector**
    window.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击新的预制件，或者在**Inspector**窗口中点击其**Open Prefab**按钮。
- en: For measurement purposes, add a temporary Cube by selecting **GameObject | 3D
    Object | Cube** from the main menu (or use the **+** button at the top left, or
    right-click directly in the **Hierarchy** window).
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测量目的，从主菜单中选择**GameObject | 3D Object | Cube**来添加一个临时立方体（或者使用左上角的**+**按钮，或者在**Hierarchy**窗口中直接右键点击）。
- en: Assuming I want my model to appear in the scene as the same size as the red
    cube we had been using, set this measuring cube `0.05, 0.05, 0.05`) and its `0,
    0.025, 0`).
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我想我的模型在场景中看起来与之前使用的红色立方体大小相同，设置这个测量立方体`0.05, 0.05, 0.05`）和其`0, 0.025, 0`）。
- en: Drag the 3D model you imported from your `Models` folder into the **Hierarchy**
    window as a child of the root object.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你从`Models`文件夹中导入的3D模型拖到**Hierarchy**窗口中，作为根对象的子对象。
- en: Use the `0.5, 0.05, 0.05`), `0, 0.04, 0`), `0, 0, 0`).
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`0.5, 0.05, 0.05`), `0, 0.04, 0`), `0, 0, 0`）。
- en: Delete or disable the Cube. With **Cube** selected, in its **Inspector** window,
    uncheck the **Enable** checkbox at the top left.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或禁用立方体。在**立方体**被选中时，在其**检查器**窗口中，取消勾选左上角的**启用**复选框。
- en: Save the prefab by clicking the **Save** button at the top of the **Scene**
    window.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**场景**窗口顶部的**保存**按钮来保存预制件。
- en: 'The model I found did not come with a material, so let''s create one for it
    now. With the prefab we''re working on still open for editing, perform the following
    additional steps:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我找到的模型没有附带材质，所以现在让我们为它创建一个。在我们正在编辑的预制件仍然打开以供编辑时，执行以下额外步骤：
- en: In the `Materials` under your `_App` folder (this step is optional).
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`_App`文件夹下的`Materials`中（此步骤是可选的）。
- en: Right-click inside the `Materials` folder, select `Virus Material`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Materials`文件夹内右键点击，选择`Virus Material`。
- en: Drag **Virus Material** onto the model object (**uploads_files_745381_Microbe**)
    in the **Hierarchy** window.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**病毒材料**拖放到**层次**窗口中的模型对象（**uploads_files_745381_Microbe**）上。
- en: With the microbe model selected in the `0.5`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0.5`中选择微生物模型。
- en: Again, **Save** your prefab.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，**保存**你的预制件。
- en: Exit back to scene editing by clicking the **<** button at the top left of the
    **Hierarchy** window.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**层次**窗口左上角的**<**按钮返回场景编辑。
- en: 'My prefab now looks like this while open for editing (I have rearranged my
    windows so that they''re different from the default layout):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开进行编辑时，我的预制件现在看起来是这样的（我已经重新排列了我的窗口，使它们与默认布局不同）：
- en: '![Figure 2.11 – Editing my Virus prefab'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11 – 编辑我的病毒预制件'
- en: '](img/Figure_2.11-virus-edit.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.11-virus-edit.jpg)'
- en: Figure 2.11 – Editing my Virus prefab
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 编辑我的病毒预制件
- en: We're now ready to add this prefab to the scene. After, we will build and run
    the finished project.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好将这个预制件添加到场景中。之后，我们将构建并运行完成的项目。
- en: Completing the scene
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成场景
- en: 'We now have our own prefab to place in the AR scene. Let''s add it to the **Place
    Object On Plane** component, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了自己的预制件可以放置在AR场景中。让我们将其添加到**放置对象在平面上**组件中，如下所示：
- en: Ensure you've exited the prefab edit mode and are now editing BasicARScene.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经退出了预制件编辑模式，现在正在编辑BasicARScene。
- en: Select the **AR Session Origin** object in the **Hierarchy** window.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中选择**AR会话原点**对象。
- en: From the `_App/Prefabs/Virus`) into the **Inspector** window, onto the **Place
    Object On Plane | Placed Prefab** slot.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`_App/Prefabs/Virus`拖放到**检查器**窗口，到**放置对象在平面上 | 放置预制件**槽位。
- en: Save the scene with **File | Save**.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件 | 保存**来保存场景。
- en: Build and run the scene by going to **File | Build And Run**.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件 | 构建并运行**来构建并运行场景。
- en: As shown in the following screenshot, I have infected my desk with a virus!
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，我已经在我的桌子上感染了病毒！
- en: '![Figure 2.12 – Running the project shows a virus on my keyboard'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12 – 运行项目显示键盘上的病毒'
- en: '](img/Figure_2.12-virus-keyboard.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.12-virus-keyboard.jpg)'
- en: Figure 2.12 – Running the project shows a virus on my keyboard
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 运行项目显示键盘上的病毒
- en: There it is. You've successfully created an augmented reality scene that places
    a virtual 3D model in the real world. Perhaps you wouldn't have chosen a virus,
    but it's a sign of the times!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你已经成功创建了一个增强现实场景，将虚拟3D模型放置在现实世界中。也许你不会选择病毒，但这却是时代的标志！
- en: You're now ready to proceed with creating your own AR projects in Unity.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以开始创建自己的Unity AR项目了。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the core structure of an augmented reality scene
    using AR Foundation. We started with the AR Foundation Samples project from Unity,
    building it to run on your device, and then exported its assets into an asset
    package for reuse. Then, we imported these sample assets into our own project,
    took a closer look at the `SimpleAR` scene, and built that to run on your device.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用AR Foundation检查了增强现实场景的核心结构。我们从Unity的AR Foundation Samples项目开始，构建它以在您的设备上运行，然后将其资产导出为资产包以供重用。然后，我们将这些示例资产导入到我们的项目中，更详细地查看`SimpleAR`场景，并在您的设备上构建它。
- en: Then, starting from a new empty scene, we built our own basic AR demo from scratch
    that lets the user place a virtual 3D object in the physical world environment.
    For this, we added `OnPlaceObject` action message. This function performs a raycast
    from the screen touch position to find a pose point on a trackable horizontal
    plane. It then instantiates an object on the plane at that location. We concluded
    this chapter by finding a 3D model on the internet, importing it into the project,
    creating a scaled prefab from the model, and using it as the virtual object placed
    into the scene. Several times along the way, we did a **Build And Run** of the
    project to verify that our work at that point runs as expected on the target device.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从一个全新的空白场景开始，我们从头开始构建了自己的基本AR演示，允许用户在物理世界环境中放置一个虚拟3D对象。为此，我们添加了`OnPlaceObject`动作消息。这个函数从屏幕触摸位置进行射线投射，以在可追踪的水平平面上找到一个姿态点。然后，它在该位置平面上实例化一个对象。我们通过在互联网上找到一个3D模型，将其导入到项目中，从模型创建一个缩放预制件，并将其用作场景中放置的虚拟对象来结束这一章节。在过程中，我们多次进行了**构建和运行**项目，以验证我们在此阶段的工作在目标设备上是否按预期运行。
- en: In the next chapter, we will look at tools and practices to facilitate developing
    and troubleshooting AR projects, which will help improve the developer workflow,
    before moving on to creating more complete projects in subsequent chapters.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨工具和实践，以促进AR项目的开发和故障排除，这将有助于提高开发者的工作流程，然后再继续在后续章节中创建更完整的项目。
