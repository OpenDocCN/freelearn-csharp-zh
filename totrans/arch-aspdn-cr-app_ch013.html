<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>12 Behavioral Patterns</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="13">12 Behavioral Patterns</h1>

<h2 data-number="13.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file67.png" style="width:10em"/></p>
<p>This chapter explores two new design patterns from the well-known <strong>Gang of Four</strong> (<strong>GoF</strong>). They are behavioral patterns, meaning they help simplify system behavior management.Often, we need to encapsulate some core algorithm while allowing other pieces of code to extend that implementation. That is where the <strong>Template Method</strong> pattern comes into play.Other times, we have a complex process with multiple algorithms that all apply to one or more situations, and we need to organize it in a testable and extensible fashion. This is where the <strong>Chain of Responsibility</strong> pattern can help. For example, the ASP.NET Core middleware pipeline is a Chain of Responsibility where all the middleware inspects and acts on the request.In this chapter, we cover the following topics:</p>
<ul>
<li>Implementing the Template Method pattern</li>
<li>Implementing the Chain of Responsibility pattern</li>
<li>Mixing the Template Method and Chain of Responsibility patterns</li>
</ul>


<h2 data-number="13.2">Implementing the Template Method pattern</h2>
<p>The <strong>Template Method</strong> is a GoF behavioral pattern that uses inheritance to share code between the base class and its subclasses. It is a very powerful yet simple design pattern.</p>

<h3 data-number="13.2.1">Goal</h3>
<p>The goal of the Template Method pattern is to encapsulate the outline of an algorithm in a base class while leaving some parts of that algorithm open for modification by the subclasses, which adds flexibility at a low cost.</p>


<h3 data-number="13.2.2">Design</h3>
<p>First, we need to define a base class that contains the <code>TemplateMethod</code> method and then define one or more sub-operations that need to be implemented by its subclasses (<code>abstract</code>) or that can be overridden (<code>virtual</code>).Using UML, it looks like this:</p>
<figure>
<img alt="Figure 12.1: Class diagram representing the Template Method pattern" src="img/file68.png"/><figcaption aria-hidden="true">Figure 12.1: Class diagram representing the Template Method pattern</figcaption>
</figure>
<p>How does this work?</p>
<ul>
<li><code>AbstractClass</code> implements the shared code: the algorithm in its <code>TemplateMethod</code> method.</li>
<li><code>ConcreteClass</code> implements its specific part of the algorithm in its inherited <code>Operation</code> method.</li>
<li><code>Client</code> calls <code>TemplateMethod()</code>, which calls the subclass implementation of one or more specific algorithm elements (the <code>Operation</code> method in this case).</li>
</ul>
<blockquote>
<p>We could also extract an interface from <code>AbstractClass</code> to allow even more flexibility, but that’s beyond the scope of the Template Method pattern.</p>
</blockquote>
<p>Let’s now get into some code to see the Template Method pattern in action.</p>


<h3 data-number="13.2.3">Project – Building a search machine</h3>
<p>Let’s start with a simple, classic example to demonstrate how the Template Method pattern works.<strong>Context</strong>: Depending on the collection, we want to use a different search algorithm. We want to use a <em>binary search</em> for sorted collections, but we want to use a <em>linear search</em> for unsorted collections.Let’s start with the consumer, a REST endpoint in the <code>Program.cs</code> file that returns <code>plain/text</code> results:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddSingleton&lt;SearchMachine&gt;(x
        =&gt; new LinearSearchMachine(1, 10, 5, 2, 123, 333, 4))
    .AddSingleton&lt;SearchMachine&gt;(x
        =&gt; new BinarySearchMachine(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
;
var app = builder.Build();
app.MapGet("/", (IEnumerable&lt;SearchMachine&gt; searchMachines) =&gt;
{
    var sb = new StringBuilder();
    var elementsToFind = new int[] { 1, 10, 11 };
    foreach (var searchMachine in searchMachines)
    {
        var typeName = searchMachine.GetType().Name;
        var heading = $"Current search machine is {typeName}";
        sb.AppendLine("".PadRight(heading.Length, '='));
        sb.AppendLine(heading);
        foreach (var value in elementsToFind)
        {
            var index = searchMachine.IndexOf(value);
            var wasFound = index.HasValue;
            if (wasFound)
            {
                sb.AppendLine($"The element '{value}' was found at index {index!.Value}.");
            }
            else
            {
                sb.AppendLine($"The element '{value}' was not found.");
            }
        }
    }
    return sb.ToString();
});
app.Run(); </code></pre>
</div>
<p>As highlighted in the first few lines, we configure <code>LinearSearchMachine</code> and <code>BinarySearchMachine</code> as two <code>SearchMachine</code> implementations. We initialize each instance using a different sequence of numbers.Afterward, we inject all registered <code>SearchMachine</code> services into the endpoint (highlighted in the code block). That handler iterates all <code>SearchMachine</code> instances and tries to find all elements of the <code>elementsToFind</code> array before outputting the <code>text/plain</code> results.Next, let’s explore the <code>SearchMachine</code> class:</p>
<div><pre><code>namespace TemplateMethod;
public abstract class SearchMachine
{
    protected int[] Values { get; }
    protected SearchMachine(params int[] values)
    {
        Values = values ?? throw new ArgumentNullException(nameof(values));
    }
    public int? IndexOf(int value)
    {
        if (Values.Length == 0) { return null; }
        var result = Find(value);
        return result;
    }
    protected abstract int? Find(int value);
}</code></pre>
</div>
<p>The <code>SearchMachine</code> class represents <code>AbstractClass</code>. It exposes the <code>IndexOf</code> template method, which uses the required hook represented by the <code>abstract</code> <code>Find</code> method (see highlighted code). The hook is required because each subclass must implement that method, thereby making that method a required extension point (or hook).Next, we explore our first implementation of <code>ConcreteClass</code>, the <code>LinearSearchMachine</code> class:</p>
<div><pre><code>namespace TemplateMethod;
public class LinearSearchMachine : SearchMachine
{
    public LinearSearchMachine(params int[] values)
        : base(values) { }
    protected override int? Find(int value)
    {
        for (var i = 0; i &lt; Values.Length; i++)
        {
            if (Values[i] == value) { return i; }
        }
        return null;
    }
}</code></pre>
</div>
<p>The <code>LinearSearchMachine</code> class is a <code>ConcreteClass</code> representing the linear search implementation used by <code>SearchMachine</code>. It contributes a part of the <code>IndexOf</code> algorithm through its <code>Find</code> method.Finally, we move on to the <code>BinarySearchMachine</code> class:</p>
<div><pre><code>namespace TemplateMethod;
public class BinarySearchMachine : SearchMachine
{
    public BinarySearchMachine(params int[] values)
        : base(values.OrderBy(v =&gt; v).ToArray()) { }
    protected override int? Find(int value)
    {
        var index = Array.BinarySearch(Values, value);
        return index &lt; 0 ? null : index;
    }
}</code></pre>
</div>
<p>The <code>BinarySearchMachine</code> class is a <code>ConcreteClass</code> representing the binary search implementation of <code>SearchMachine</code>. As you may have noticed, we skipped the binary search algorithm’s implementation by delegating it to the built-in <code>Array.BinarySearch</code> method. Thanks to the .NET team!</p>
<blockquote>
<p>The binary search algorithm requires an ordered collection to work; hence the sorting done in the constructor when passing the values to the base class (<code>OrderBy</code>). That may not be the most performant way of ensuring the array is sorted (precondition/guard), but it is a very fast to write and readable way to write it. Moreover, in our case, performance is not an issue.</p>
<blockquote>
<p>If you must optimize such an algorithm to work with a large data set, you can leverage parallelism (multithreading) to help out. In any case, run a proper benchmark to ensure you optimize the right thing and assess your real gains. Look at BenchmarkDotNet (<a href="https://adpg.link/C5E9">https://adpg.link/C5E9</a>) if you are looking at benchmarking .NET code.</p>
</blockquote>
</blockquote>
<p>Now that we have defined the actors and explored the code, let’s see what is happening in our consumer (the <code>Client</code>):</p>
<ol>
<li>The <code>Client</code> uses the registered <code>SearchMachine</code> instances and searches for values 1, 10, and 11.</li>
<li>Afterward, <code>Client</code> displays to the user whether the numbers were found or not.</li>
</ol>
<p>The <code>Find</code> method returns <code>null</code> when it does not find a value and, by extension, the <code>IndexOf</code> method.By running the program, we get the following output:</p>
<div><pre><code>=============================================
Current search machine is LinearSearchMachine
The element '1' was found at index 0.
The element '10' was found at index 1.
The element '11' was not found.
=============================================
Current search machine is BinarySearchMachine
The element '1' was found at index 0.
The element '10' was found at index 9.
The element '11' was not found.</code></pre>
</div>
<p>The preceding output shows the two algorithms at play. Both <code>SearchMachine</code> implementations did not contain the value <code>11</code>. They both contained the values <code>1</code> and <code>10</code> placed at different positions. Here is a reminder of the values:</p>
<div><pre><code>new LinearSearchMachine(1, 10, 5, 2, 123, 333, 4)
new BinarySearchMachine(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</code></pre>
</div>
<p>The consumer was iterating the <code>SearchMachine</code> registered with the IoC container. The base class implements the <code>IndexOf</code> but delegates the search (<code>Find</code>) algorithm to the subclasses. The preceding output shows that each <code>SearchMachine</code> could execute the expected task by implementing only the <code>Find</code> piece of the algorithm.And voilà! We have covered the Template Method pattern, as easy as that. Of course, our algorithm was trivial, but the concept remains.To ensure the correctness of the implementation, I also created two tests, one per class. Here’s a test for the <code>LinearSearchMachine</code> class:</p>
<div><pre><code>namespace TemplateMethod;
public class LinearSearchMachineTest
{
    public class IndexOf
    {
        [Theory]
        [InlineData(1, 0)]
        [InlineData(2, 4)]
        [InlineData(3, 2)]
        [InlineData(7, null)]
        public void Should_return_the_expected_result(
            int value, int? expectedIndex)
        {
            // Arrange
            var sorter = new LinearSearchMachine(1, 5, 3, 4, 2);
            // Act
            var index = sorter.IndexOf(value);
            // Assert
            Assert.Equal(expectedIndex, index);
        }
    }
}</code></pre>
</div>
<p>The preceding test ensures that the correct values are found or not by the <code>IndexOf</code> method of the <code>LinearSearchMachine</code> class.Next is a similar test for the <code>BinarySearchMachine</code> class:</p>
<div><pre><code>namespace TemplateMethod;
public class BinarySearchMachineTest
{
    public class IndexOf
    {
        [Theory]
        [InlineData(1, 0)]
        [InlineData(8, 5)]
        [InlineData(3, 2)]
        [InlineData(7, null)]
        public void Should_return_the_expected_result(int value, int? expectedIndex)
        {
            // Arrange
            var sorter = new BinarySearchMachine(1, 2, 3, 4, 5, 8);
            // Act
            var index = sorter.IndexOf(value);
            // Assert
            Assert.Equal(expectedIndex, index);
        }
    }
}</code></pre>
</div>
<p>The preceding test does a similar job of ensuring that the correct values are found or not by the <code>IndexOf</code> method of the <code>BinarySearchMachine</code> class.</p>
<blockquote>
<p>We can add <code>virtual</code> methods in the base class to create optional hooks. Those methods would become optional extension points that subclasses can implement or not. That would allow a more complex and more versatile scenario to be supported. We will not cover this here because it is not part of the pattern itself, even if very similar. There are many examples in the .NET <strong>base class library</strong> (<strong>BCL</strong>), like most methods of the <code>ComponentBase</code> class (in the <code>Microsoft.AspNetCore.Components</code> namespace). For example, when overriding the <code>OnInitialized</code> method in a Blazor component, we leverage an optional extension hook. The base method does nothing and is there only for extensibility purposes, allowing us to run code as part of the component’s lifecycle. You can consult the <code>ComponentBase</code> class code in the official .NET repo on GitHub: <a href="https://adpg.link/1WYq">https://adpg.link/1WYq</a>.</p>
</blockquote>
<p>This concludes our study of another simple yet powerful design pattern.</p>


<h3 data-number="13.2.4">Conclusion</h3>
<p>The Template Method is a powerful and easy-to-implement design pattern allowing subclasses to reuse the algorithm’s skeleton while implementing (abstract) or overriding (virtual) subparts. It allows implementation-specific classes to extend the core algorithm. It can reduce the duplication of logic and improve maintainability while not cutting out any flexibility in the process. There are many examples in the .NET BCL, and we leverage this pattern at the end of the chapter based on a real-world scenario.Now, let’s see how the Template Method pattern can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: The Template Method pushes algorithm-specific portions of the code to subclasses while keeping the core algorithm in the base class. Doing that helps follow the <strong>single responsibility principle</strong> (<strong>SRP</strong>) by distributing responsibilities.</li>
<li><strong>O</strong>: By opening extension hooks, it opens the template for extensions (allowing subclasses to extend it) and closes it from modifications (no need to modify the base class since the subclasses can extend it).</li>
<li><strong>L</strong>: As long as the subclasses are the implementations and do not alter the base class per se, following the <strong>Liskov substitution principle</strong> (<strong>LSP</strong>) should not be a problem. However, this principle is tricky, so it is possible to break it; by throwing a new type of exception or altering the state of a more complex base class in a way that changes its behavior, for example.</li>
<li><strong>I</strong>: As long as the base class implements the smallest cohesive surface possible, using the Template Method pattern should not negatively impact the program. On top of this, having a smaller interface surface in classes diminishes the chances of breaking the LSP.</li>
<li><strong>D</strong>: The Template Method pattern is based on an abstraction, so as long as consumers depend on that abstraction, it should help to get in line with the <strong>dependency inversion principle</strong> (<strong>DIP</strong>).</li>
</ul>
<p>Next, we move to the Chain of Responsibility design pattern before mixing the Template Method and the Chain of Responsibility pattern to improve our code.</p>



<h2 data-number="13.3">Implementing the Chain of Responsibility pattern</h2>
<p>The <strong>Chain of Responsibility</strong> is a GoF behavioral pattern that chains classes to handle complex scenarios efficiently, with limited effort. Once again, the goal is to take a complex problem and break it into multiple smaller units.</p>

<h3 data-number="13.3.1">Goal</h3>
<p>The Chain of Responsibility pattern aims to chain multiple handlers that each solve a limited number of problems. If a handler cannot solve the specific problem, it passes the resolution to the chain’s next handler.</p>
<blockquote>
<p>We often create a default handler that executes logic at the end of the chain as the terminal handler. Such a handler can throw an exception (for example, <code>OperationNotHandledException</code>) to cascade the issue up the call stack to a consumer who knows how to handle and react to it. Another strategy is creating a terminal handler that does the opposite and ensures nothing happens.</p>
</blockquote>


<h3 data-number="13.3.2">Design</h3>
<p>The most basic Chain of Responsibility starts by defining an interface that handles a request (<code>IHandler</code>). Then we add classes that handle one or more scenarios (<code>Handler1</code> and <code>Handler2</code>):</p>
<figure>
<img alt="Figure 12.2: Class diagram representing the Chain of Responsibility pattern" src="img/file69.png"/><figcaption aria-hidden="true">Figure 12.2: Class diagram representing the Chain of Responsibility pattern</figcaption>
</figure>
<p>A difference between the Chain of Responsibility pattern and many other patterns is that no central dispatcher knows the handlers; all handlers are independent. The consumer receives a handler and tells it to handle the request. Each handler determines if it can process the request. If it can, it processes it. In both cases, it also evaluates if it should forward the request to the next handler in the chain. The handler can execute these two tasks in any order, like executing some logic, sending the request down the chain, then executing more logic when the request comes back (like a pipeline).This pattern allows us to divide complex logic into multiple pieces that handle a single responsibility, improving testability, reusability, and extensibility in the process. Since no orchestrator exists, each chain element is independent, leading to a cohesive and loosely coupled design.</p>
<blockquote>
<p>When creating the chain of responsibility, you can order the handlers so that the most requested handlers are closer to the beginning of the chain and the least requested handlers are closer to the end. This helps limit the number of “chain links” that are visited for each request before reaching the right handler.</p>
</blockquote>
<p>Enough theory; let’s look at some code.</p>


<h3 data-number="13.3.3">Project – Message interpreter</h3>
<p><strong>Context</strong>: We need to create the receiving end of a messaging application where each message is unique, making it impossible to create a single algorithm to handle them all.After analyzing the problem, we decided to build a chain of responsibility where each handler can manage a single message. The pattern seems more than perfect!</p>
<blockquote>
<p>This project is based on something that I built years ago. IoT devices were sending bytes (messages) due to limited bandwidth. Then, we had to associate those bytes with real values in a web application. Each message had a fixed header size but a variable body size. The headers were handled in a base handler (template method), and each handler in the chain managed a different message type. For the current example, we keep it simpler than parsing bytes, but the concept is the same.</p>
</blockquote>
<p>For our demo application, the messages are as simple as this:</p>
<div><pre><code>namespace ChainOfResponsibility;
public record class Message(string Name, string? Payload);</code></pre>
</div>
<p>The <code>Name</code> property is used as a discriminator to differentiate messages, and each handler is responsible for doing something with the <code>Payload</code> property.</p>
<blockquote>
<p>We won’t do anything with the payload as it is irrelevant to the pattern, but conceptually, that is the logic that should happen.</p>
</blockquote>
<p>The handlers are very simple, here’s the interface:</p>
<div><pre><code>namespace ChainOfResponsibility; 
public interface IMessageHandler
{
    void Handle(Message message);
}</code></pre>
</div>
<p>The only thing a handler can do is handle a message. Our initial application can handle the following messages:</p>
<ul>
<li>The <code>AlarmTriggeredHandler</code> class handles <code>AlarmTriggered</code> messages.</li>
<li>The <code>AlarmPausedHandler</code> class handles <code>AlarmPaused</code> messages.</li>
<li>The <code>AlarmStoppedHandler</code> class handles <code>AlarmStopped</code> messages.</li>
</ul>
<blockquote>
<p>The real-world logic is that a machine can send an alarm to a REST API indicating it has reached a certain threshold. Then the REST API can push that information to a UI, send an email, a text message, or whatnot.</p>
<blockquote>
<p>An alerted human can then pause the alarm while investigating the issue so other people know the alarm is getting handled.</p>
</blockquote>
<blockquote>
<p>Finally, a human can go to the physical device and stop the alarm because the person has resolved the issue.</p>
</blockquote>
<blockquote>
<p>We could extrapolate on many more sub-scenarios, but this is the gist.</p>
</blockquote>
</blockquote>
<p>The three handlers are very similar and share quite a bit of logic, but we fix that later. In the meantime, we have the following handlers:</p>
<div><pre><code>namespace ChainOfResponsibility;
public class AlarmTriggeredHandler : IMessageHandler
{
    private readonly IMessageHandler? _next;
    public AlarmTriggeredHandler(IMessageHandler? next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (message.Name == "AlarmTriggered")
        {
            // Do something clever with the Payload
        }
        else
        {
            _next?.Handle(message);
        }
    }
}
public class AlarmPausedHandler : IMessageHandler
{
    private readonly IMessageHandler? _next;
    public AlarmPausedHandler(IMessageHandler? next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (message.Name == "AlarmPaused")
        {
            // Do something clever with the Payload
        }
        else
        {
            _next?.Handle(message);
        }
    }
}
public class AlarmStoppedHandler : IMessageHandler
{
    private readonly IMessageHandler? _next;
    public AlarmStoppedHandler(IMessageHandler? next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (message.Name == "AlarmStopped")
        {
            // Do something clever with the Payload
        }
        else
        {
            _next?.Handle(message);
        }
    }
}</code></pre>
</div>
<p>Each handler does two things:</p>
<ul>
<li>It receives an optional “next handler” from its constructor (highlighted in the code). This creates a chain similar to a singly linked list.</li>
<li>It handles only the request it knows about, delegating the others to the next handler in the chain.</li>
</ul>
<p>Let’s use <code>Program.cs</code> as the consumer of the Chain of Responsibility (the Client) and use a POST requests to interface with our REST API and build the message.Here is the first part of our REST API:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;IMessageHandler&gt;(
    new AlarmTriggeredHandler(
        new AlarmPausedHandler(
            new AlarmStoppedHandler())));</code></pre>
</div>
<p>In the preceding code, we manually create the Chain of Responsibility and register it as a singleton bound to the <code>IMessageHandler</code> interface. In that registration code, each handler is manually injected in the previous constructor (created with the <code>new</code> keyword).The next code represents the second half of the <code>Program.cs</code> file:</p>
<div><pre><code>var app = builder.Build();
app.MapPost(
    "/handle",
    (Message message, IMessageHandler messageHandler) =&gt;
    {
        messageHandler.Handle(message);
        return $"Message '{message.Name}' handled successfully.";
    });
app.Run();</code></pre>
</div>
<p>The consuming endpoint is reachable through the <code>/handle</code> URL and expects a <code>Message</code> object in its body. It then uses the injected implementation of the <code>IMessageHandler</code> interface and passes it the message. If we run any of the HTTP requests in the <code>ChainOfResponsibility.http</code> file, we get a successful result similar to this:</p>
<div><pre><code>Message 'AlarmTriggered' handled successfully.</code></pre>
</div>
<p>The problem is that even if we send an invalid message, there is no way to know from the consumer, so it is always valid even when no handler picks up the message.To handle this scenario, let’s add a fourth handler (terminal handler) that notifies the consumers of invalid requests:</p>
<div><pre><code>public class DefaultHandler : IMessageHandler
{
    public void Handle(Message message)
    {
        throw new NotSupportedException(
            $"Messages named '{message.Name}' are not supported.");
    }
}</code></pre>
</div>
<p>This new terminal handler throws an exception that notifies the consumers about the error.</p>
<blockquote>
<p>We can create custom exceptions to make differentiating between system and application errors easier. In this case, throwing a system exception is good enough. In a real-world application, I recommend creating a custom exception that represents the end of the chain and contains the relevant information for the consumers to react to it according to your use case.</p>
</blockquote>
<p>Next, let’s register it in our chain (highlighted):</p>
<div><pre><code>builder.Services.AddSingleton&lt;IMessageHandler&gt;(
    new AlarmTriggeredHandler(
        new AlarmPausedHandler(
            new AlarmStoppedHandler(
                new DefaultHandler()
            ))));</code></pre>
</div>
<p>If we send a POST request with the name <code>SomeUnhandledMessageName</code>, the endpoint now yields the following exception:</p>
<div><pre><code>System.NotSupportedException: Messages named 'SomeUnhandledMessageName' are not supported.
   at ChainOfResponsibility.DefaultHandler.Handle(Message message) in C12\src\ChainOfResponsibility\DefaultHandler.cs:line 7
   at ChainOfResponsibility.AlarmStoppedHandler.Handle(Message message) in C12\src\ChainOfResponsibility\AlarmStoppedHandler.cs:line 19
   at ChainOfResponsibility.AlarmPausedHandler.Handle(Message message) in C12\src\ChainOfResponsibility\AlarmPausedHandler.cs:line 19
   at ChainOfResponsibility.AlarmTriggeredHandler.Handle(Message message) in C12\src\ChainOfResponsibility\AlarmTriggeredHandler.cs:line 19
   at Program.&lt;&gt;c.&lt;&lt;Main&gt;$&gt;b__0_0(Message message, IMessageHandler messageHandler) in C12\src\ChainOfResponsibility\Program.cs:line 22
   at lambda_method1(Closure, Object, HttpContext, Object)
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.&lt;&gt;c__DisplayClass100_2.&lt;&lt;HandleRequestBodyAndCompileRequestDelegateForJson&gt;b__2&gt;d.MoveNext()
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)
HEADERS
=======
Host: localhost:10001
Content-Type: application/json
traceparent: 00-5d737fdbb1018d5b7d060b74baf26111-2805f137fe1541af-00
Content-Length: 77</code></pre>
</div>
<p>So far, so good, but the experience is not great, so let’s add a try-catch block to handle this in the endpoint:</p>
<div><pre><code>app.MapPost(
    "/handle",
    (Message message, IMessageHandler messageHandler) =&gt;
    {
        try
        {
            messageHandler.Handle(message);
            return $"Message '{message.Name}' handled successfully.";
        }
        catch (NotSupportedException ex)
        {
            return ex.Message;
        }
    });</code></pre>
</div>
<p>Now, when we send an invalid message, the API gently returns the following message to us:</p>
<div><pre><code>Messages named 'SomeUnhandledMessageName' are not supported.</code></pre>
</div>
<blockquote>
<p>Of course, when you expect machines to consume your APIs, you should produce a data structure that is easier to parse, like using JSON.</p>
</blockquote>
<p>And voilà. We have built a simple Chain of Responsibility that handles messages.</p>


<h3 data-number="13.3.4">Conclusion</h3>
<p>The Chain of Responsibility pattern is another great GoF pattern. It divides a large problem into smaller, cohesive units, each doing one job: handling its specific request(s).Now, let’s see how the Chain of Responsibility pattern can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: The Chain of Responsibility pattern aims to this exact principle: create a single unit of logic per class!</li>
<li><strong>O</strong>: The Chain of Responsibility pattern allows the addition, removal, and reordering of handlers without touching the code but by altering the chain's composition in the composition root.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: The Chain of Responsibility pattern helps with the ISP if we create a small interface. The handler interface is not limited to a single method; it can expose multiple.</li>
<li><strong>D</strong>: By using the handler interface, no element of the chain, nor the consumers, depends on a specific handler; they only depend on the interface that represents the chain, which helps invert the dependency flow.</li>
</ul>
<p>Next, let’s use the Template Method and Chain of Responsibility patterns to encapsulate our handlers’ duplicated logic.</p>



<h2 data-number="13.4">Mixing the Template Method and Chain of Responsibility patterns</h2>
<p>This section explores a combination of two powerful design patterns: the Template Method and the Chain of Responsibility. As we are about to explore, those two patterns fit together well. We use the Template Method pattern as the base structure, providing the handlers' blueprint. Meanwhile, the Chain of Responsibility pattern manages the handling sequence, ensuring each request is routed to the correct handler.When these two patterns work in tandem, they form a robust framework that facilitates easy management, maintains order, and increases the adaptability of our system.</p>

<h3 data-number="13.4.1">Project – Improved message interpreter</h3>
<p>Now that we know both the <strong>Chain of Responsibility</strong> and the <strong>Template Method</strong> patterns, it is time to <em>DRY</em> out our handlers by extracting the shared logic into an abstract base class using the Template Method pattern and providing extension points to the subclasses.OK, so what logic is duplicated?</p>
<ul>
<li>The <code>next</code> handler injection code is the same in all but the terminal handlers. Moreover, this is an important part of the pattern we should encapsulate in the base class.</li>
<li>The logic testing whether the current handler can handle the message is also the same in all but the terminal handlers.</li>
</ul>
<p>Let’s create a new base class that implements the Template Method pattern and a large part of the logic of our chain of responsibility:</p>
<div><pre><code>namespace ImprovedChainOfResponsibility; 
public abstract class MessageHandlerBase : IMessageHandler
{
    private readonly IMessageHandler? _next;
    public MessageHandlerBase(IMessageHandler? next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (CanHandle(message))
        {
            Process(message);
        }
        else if (HasNext())
        {
            _next.Handle(message);
        }
    }
    [MemberNotNullWhen(true, nameof(_next))]
    private bool HasNext()
    {
        return _next != null;
    }
    protected virtual bool CanHandle(Message message)
    {
        return message.Name == HandledMessageName;
    }
    protected abstract string HandledMessageName { get; }
    protected abstract void Process(Message message);
}</code></pre>
</div>
<p>Based on those few changes, what is the template method, and what are the extension points (hooks)?The <code>MessageHandlerBase</code> class adds the <code>Handle</code> template method. Then, the <code>MessageHandlerBase</code> class exposes the following extension points:</p>
<ul>
<li>The <code>CanHandle</code> method tests whether <code>HandledMessageName</code> is equal to the value of the <code>message.Name</code> property. A subclass can override this method if it requires a different comparison logic. This method is an optional hook.</li>
<li>All subclasses must implement the <code>HandledMessageName</code> property, which is the key driver of the <code>CanHandle</code> method. This property is a mandatory hook.</li>
<li>All subclasses must implement the <code>Process</code> method, allowing them to run their logic against the message. This method is a mandatory hook.</li>
</ul>
<p>To understand how these hooks play out, let’s take a look at the three simplified alarm handlers:</p>
<div><pre><code>public class AlarmTriggeredHandler : MessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmTriggered";
    public AlarmTriggeredHandler(IMessageHandler? next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}
public class AlarmPausedHandler : MessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmPaused";
    public AlarmPausedHandler(IMessageHandler? next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}
public class AlarmStoppedHandler : MessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmStopped";
    public AlarmStoppedHandler(IMessageHandler? next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}</code></pre>
</div>
<p>As we can see from the updated alarm handlers, they are now limited to a single responsibility: processing the messages they can handle. In contrast, <code>MessageHandlerBase</code> now handles the chain of responsibility’s plumbing. We left the <code>DefaultHandler</code> class unchanged since it is the end of the chain and does not support having a next handler, nor processing messages.Mixing those two patterns created a complex messaging system that divides responsibilities into handlers. There is one handler per message, and the chain logic is pushed into a base class.The beauty of such a system is that we don’t have to think about all the messages simultaneously; we can focus on just one message at a time. When dealing with a new type of message, we can focus on that precise message, implement its handler, and forget about the other <em>N</em> types. The consumers can also be super dumb, sending the request into the pipe without knowing about the Chain of Responsibility, and like magic, the right handler shall prevail!Nonetheless, have you noticed an issue with this design? Let’s have a look next.</p>


<h3 data-number="13.4.2">Project – A final, finer-grained design</h3>
<p>In the last example, we used <code>HandledMessageName</code> and <code>CanHandle</code> to decide whether a handler could handle a request. There is one problem with that code: if a subclass decides to override <code>CanHandle</code>, and then decides that it no longer requires <code>HandledMessageName</code>, we would end up having a lingering, unused property in our system.</p>
<blockquote>
<p>There are worse situations, but we are talking component design here, so why not push that system a little further toward a better design?</p>
</blockquote>
<p>One way to fix this is to create a finer-grained class hierarchy, as follows:</p>
<figure>
<img alt="Figure 12.4: Class diagram representing the design of the finer-grained project that implements the Chain of Responsibility and Template Method patterns" src="img/file70.png"/><figcaption aria-hidden="true">Figure 12.4: Class diagram representing the design of the finer-grained project that implements the Chain of Responsibility and Template Method patterns</figcaption>
</figure>
<p>The preceding diagram looks more complicated than it is. But let’s look at our refactored code first, starting with the new <code>MessageHandlerBase</code> class:</p>
<div><pre><code>namespace FinalChainOfResponsibility;
public interface IMessageHandler
{
    void Handle(Message message);
}
public abstract class MessageHandlerBase : IMessageHandler
{
    private readonly IMessageHandler? _next;
    public MessageHandlerBase(IMessageHandler? next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (CanHandle(message))
        {
            Process(message);
        }
        else if (HasNext())
        {
            _next.Handle(message);
        }
    }
    [MemberNotNullWhen(true, nameof(_next))]
    private bool HasNext()
    {
        return _next != null;
    }
    protected abstract bool CanHandle(Message message);
    protected abstract void Process(Message message);
}</code></pre>
</div>
<p>The <code>MessageHandlerBase</code> class manages the Chain of Responsibility by handling the next handler logic and by exposing two hooks (the Template Method pattern) for subclasses to extend:</p>
<ul>
<li><code>bool CanHandle(Message message)</code></li>
<li><code>void Process(Message message)</code></li>
</ul>
<p>This class is similar to the previous one, but the <code>CanHandle</code> method is now abstract, and we removed the <code>HandledMessageName</code> property leading to a better responsibility segregation and better hooks.Next, let’s look at the <code>SingleMessageHandlerBase</code> class, which replaces the logic we removed from the <code>MessageHandlerBase</code> class:</p>
<div><pre><code>public abstract class SingleMessageHandlerBase : MessageHandlerBase
{
    public SingleMessageHandlerBase(IMessageHandler? next = null)
        : base(next) { }
    protected override bool CanHandle(Message message)
    {
        return message.Name == HandledMessageName;
    }
    protected abstract string HandledMessageName { get; }
}</code></pre>
</div>
<p>The <code>SingleMessageHandlerBase</code> class inherits from the <code>MessageHandlerBase</code> class and overrides the <code>CanHandle</code> method. It implements the logic related to it and adds the <code>HandledMessageName</code> property that subclasses must define for the <code>CanHandle</code> method to work (a required extension point).The <code>AlarmPausedHandler</code>, <code>AlarmStoppedHandler</code>, and <code>AlarmTriggeredHandler</code> classes now inherit from <code>SingleMessageHandlerBase</code> instead of <code>MessageHandlerBase</code>, but nothing else has changed. Here’s the code as a reminder:</p>
<div><pre><code>namespace FinalChainOfResponsibility;
public class AlarmPausedHandler : SingleMessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmPaused";
    public AlarmPausedHandler(IMessageHandler? next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}
public class AlarmStoppedHandler : SingleMessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmStopped";
    public AlarmStoppedHandler(IMessageHandler? next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}
public class AlarmTriggeredHandler : SingleMessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmTriggered";
    public AlarmTriggeredHandler(IMessageHandler? next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}</code></pre>
</div>
<p>Those subclasses of <code>SingleMessageHandlerBase</code> implement the <code>HandledMessageName</code> property, which returns the message name they can handle, and they implement the handling logic by overriding the <code>Process</code> method as before.Next, we look at the <code>MultipleMessageHandlerBase</code> class, which enables its sub-types to handle more than one message type:</p>
<div><pre><code>public abstract class MultipleMessageHandlerBase : MessageHandlerBase
{
    public MultipleMessageHandlerBase(IMessageHandler? next = null)
        : base(next) { }
    protected override bool CanHandle(Message message)
    {
        return HandledMessagesName.Contains(message.Name);
    }
    protected abstract string[] HandledMessagesName { get; }
}</code></pre>
</div>
<p>The <code>MultipleMessageHandlerBase</code> class does the same as <code>SingleMessageHandlerBase</code>, but it uses a string array instead of a single string, supporting multiple handler names.The <code>DefaultHandler</code> class has not changed. For demonstration purposes, let’s add the <code>SomeMultiHandler</code> class that simulates a message handler that can handle <code>"Foo"</code>, <code>"Bar"</code>, and <code>"Baz"</code> messages:</p>
<div><pre><code>namespace FinalChainOfResponsibility;
public class SomeMultiHandler : MultipleMessageHandlerBase
{
    public SomeMultiHandler(IMessageHandler? next = null)
        : base(next) { }
    protected override string[] HandledMessagesName
        =&gt; new[] { "Foo", "Bar", "Baz" };
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}</code></pre>
</div>
<p>This class hierarchy may sound complicated, but what we did was to allow extensibility without the need to keep any unnecessary code in the process, leaving each class with a single responsibility:</p>
<ul>
<li>The <code>MessageHandlerBase</code> class handles <code>_next</code>.</li>
<li>The <code>SingleMessageHandlerBase</code> class handles the <code>CanHandle</code> method of handlers supporting a single message.</li>
<li>The <code>MultipleMessageHandlerBase</code> class handles the <code>CanHandle</code> method of handlers supporting multiple messages.</li>
<li>Other classes implement their version of <code>Process</code> method to handle one or more messages.</li>
</ul>
<p>And voilà! This is another example demonstrating the strength of the Template Method and Chain of Responsibility patterns working together. That last example also emphasizes the importance of the SRP by allowing greater flexibility while keeping the code reliable and maintainable.Another strength of that design is the interface at the top. Anything that does not fit the class hierarchy can be implemented directly from the interface instead of trying to adapt logic from inappropriate structures. The <code>DefaultHandler</code> class is a good example of that.</p>
<blockquote>
<p>Tricking code into doing your bidding instead of properly designing that part of the system leads to half-baked solutions that become hard to maintain.</p>
</blockquote>


<h3 data-number="13.4.3">Conclusion</h3>
<p>Mixing the Template Method and the Chain of Responsibility patterns leads to smaller classes with a single responsibility each.We removed the lingering property while keeping that logic out of the handlers. We even extended the logic to more use cases.</p>



<h2 data-number="13.5">Summary</h2>
<p>In this chapter, we covered two GoF behavioral patterns. These patterns can help us create flexible yet easy-to-maintain systems. As the name suggests, behavioral patterns aim at encapsulating application behaviors into cohesive pieces.First, we looked at the Template Method pattern, which allows us to encapsulate an algorithm’s outline inside a base class, leaving some parts open for modification by subclasses. The subclasses then fill in the gaps and extend that algorithm at those predefined locations. These locations can be required (<code>abstract</code>) or optional (<code>virtual</code>).Then, you learned about the Chain of Responsibility pattern, which opens the possibility of chaining multiple small handlers into a chain of processing, inputting the message to be processed at the beginning of the chain (the interface), and waiting for one or more handlers to execute the logic related to that message against it.</p>
<blockquote>
<p>You don’t have to stop the chain’s execution at the first handler. The Chain of Responsibility can become a pipeline instead of associating one message to one handler, as we explored.</p>
</blockquote>
<p>Lastly, leveraging the Template Method pattern to encapsulate the Chain of Responsibility’s chaining logic led us to a simpler, robust, flexible, and testable implementation without any sacrifices. The two design patterns fits very well together.In the next chapter, we dig into the Operation Result design pattern to discover efficient ways of managing return values.</p>


<h2 data-number="13.6">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>What is the main goal of the Template Method pattern?</li>
<li>What is the main goal of the Chain of Responsibility pattern?</li>
<li>Is it true that we can only add one <code>abstract</code> method when implementing the Template Method design pattern?</li>
<li>Can we use the Strategy pattern in conjunction with the Template Method pattern?</li>
<li>Is it true that there is a limit of 32 handlers in a Chain of Responsibility?</li>
<li>In a Chain of Responsibility, can multiple handlers process the same message?</li>
<li>In what way can the Template Method help implement the Chain of Responsibility pattern?</li>
</ol>


<h2 data-number="13.7">Answers</h2>
<ol>
<li>The Template Method pattern encapsulates an algorithm's outline in a base class while leaving some parts of that algorithm open for modification by its subclasses.</li>
<li>The Chain of Responsibility pattern divides a larger problem into small pieces (handlers). Each piece is self-governed, while the chain's existence is abstracted from its consumers.</li>
<li>False; you can create as many <code>abstract</code> (required) or <code>virtual</code> (optional) extension points (hooks) as you need.</li>
<li>Yes, there is no reason not to.</li>
<li>No, there is no greater limit than with any other code.</li>
<li>Yes, you can have one handler per message or multiple handlers per message. It is up to you and your requirements.</li>
<li>It helps divide responsibilities between classes by encapsulating the shared logic into one or more base classes.</li>
</ol>


</body>
</html>
