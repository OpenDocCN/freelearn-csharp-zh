- en: Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having given a rendering ([Chapter 4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No
    Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone – Sweet-Toothed
    Pandas Strike*) and a physical shape ([Chapter 5](part0062.xhtml#aid-1R42S1 "Chapter 5. The
    Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient Is a Dash of
    Physics*) to our Pandas, it's now time to give them intelligence. In particular,
    the ability to walk/navigate through the map towards the player's cake to eat
    it. In fact, as we have already pointed out, **artificial intelligence** (**AI**)
    is at the core of giving life to NPCs, so that they can move around and act within
    the world. However, this chapter will focus on navigation.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we will implement a waypoint system for our Pandas. We will do
    it twice, so that we can have two different perspectives on the same thing, and
    we will highlight the advantages and disadvantages of each method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an outline of the topics that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of AI in video games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation in video games and an overview of the main techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a waypoint system as a static list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a waypoint system as a dynamic pool of game objects (and display
    them as icons on the map)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting an idea of what's beyond navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in all the other chapters of this book, you can practice your skill at the
    end with the Homework section. So, let's get ready to start!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only requirement for this chapter, is that you have already done all the
    parts of the book that dealt with the `PandaScript` so far.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to artificial intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Artificial intelligence** (**AI**) is an extensive topic, even if we limit
    ourselves just to video games. In fact, due to its complexity, it''s one of the
    hardest parts to program for a video game. A good AI programmer should have knowledge
    of math (such as graph theory, Bayesian networks, operational research, and so
    on), physics (such as the motion equations) and psychology (to understand how
    the player reacts to AI in the game). Whereas the first two are well known, the
    last one is sometimes neglected, but is just as equally important. In fact, sometimes
    the most believable behavior of an NPC character is not the most enjoyable for
    the player. If you are interested in learning more, I wrote an article that you
    can find on my website at [francescosapio.com](http://francescosapio.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: However, I hope I haven't scared you by quoting such concepts of mathematics.
    In fact, in these sections, we won't cover such complicated things, but it is
    useful to have an idea about the foundations of what we will do, even if we will
    only create a simple ground to make our tower defense game work. In any case,
    I invite you to learn more about artificial intelligence in video games, since
    what you can achieve is really awesome!
  prefs: []
  type: TYPE_NORMAL
- en: The importance of artificial intelligence in video games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a tower defense game without enemies to compete against, it's just you
    and a bunch of towers. Games like *SimCity* ([www.simcity.com](http://www.simcity.com))
    would cease to exist. Games would become predictable experiences, their replay
    value would be greatly diminished, and MMOs would become ordinary. It would be
    the apocalypse of dynamic gameplay, without being too dramatic. Therefore, for
    any game to provide a dynamic and growing experience, AI is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence, or simply AI, allows systems to think and then behave
    just like humans, *or* animals*.* Over time, these systems can learn from the
    behavior of its user; for example, if they are progressing too easily, or if they
    are struggling, then the system is able to make adjustments to the game (in real
    time) so that the game adapts to the player. This concept refers to **machine
    learning***.*
  prefs: []
  type: TYPE_NORMAL
- en: AI in computer games refers to the behaviour and decision-making process of
    game components such as non-player characters, or NPCs for short. In modern games,
    there is real-time, very dynamic AI that in some cases feels like you're playing
    against other real players. In this way, well done AI allows you to make fast
    and intelligent decisions in order to progress through the game and achieve greatness.
    Some examples of AI in games can range from early arcade games such as *Pac-Man*,
    to enemies in first person shooters, such as *Battlefield*, *Call of Duty*, and
    *Alpha Protocol*; or *hordes of orcs* and beasts in strategy games, such as *World
    of Warcraft* and *Guild Wars 2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a book about AI (*Artificial Intelligence for Games* by Ian Millington and
    John Funge), which I recommend you to have a look at, we can think of AI as having
    the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Movement**: This refers to AI that involves NPCs making decisions that then
    produce a type of motion, such as attacking or fleeing the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decision making**: As the name suggests, this requires that a decision is
    made by the NPC about what to do next. For instance, if the enemy sees you, will
    it attack, run, or call for help?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: Imagine trying to coordinate a whole team, like in *S.W.A.T*
    or Tom Clancy''s *Rainbow Six*. In these situations, AI does not affect just one
    or two characters, but the entire team who, in turn, may have his or her own decision
    making tree, such as what to do when they sight an enemy; do they take them out
    on their own or do they notify you?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure**: This refers to how the AI is structured, which will ultimately
    determine how well it works in a game. This isn''t just about creating the write
    algorithms to make NPCs perform certain actions, it is also about utilizing the
    computer''s resources in an efficient way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent-based AI**: This refers to the concept of creating autonomous NPCs
    that take in information from the game data, determine what actions to take, and
    then carry out those actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A great site to check out is Intel''s: [http://tinyurl.com/IntelAI](http://tinyurl.com/IntelAI),
    which provides a nice explanation and introduction to the use of AI in games.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we should have a better understanding of why AI is so important and vital
    for video games, but it's such an extensive topic that it cannot be dealt with
    in a small chapter like this. Therefore, we will focus on just one particular
    aspect, which is navigation. Since this is an introductory chapter to the topic,
    we will hope to understand the basic concepts of navigation, but implement just
    one of the simple techniques that we will use in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Aspects of navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Game characters move within the game and its levels. The movement can be quite
    simple, such as that of arcade games or NPCs following or targeting you, and others
    can be quite complex like in fast paced action and adventure games. Fixed routes
    are simple to implement within a game, but keep in mind that it is possible to
    break their illusion when objects and other characters get in the way. For example,
    in games that are highly populated by NPCs (such as *Assassin's Creed*), characters
    that roam the environment can get stuck on environmental objects and appear to
    be moon walking, or in other words moving but not going anywhere. In a more dynamic
    situation, characters that will follow you or come towards you (friend or foe)
    will not know your future movements and therefore must act accordingly, as you
    do. This can range from waves of enemies in real-time strategy games, to guards
    who you need to avoid in order to infiltrate high-level security buildings.
  prefs: []
  type: TYPE_NORMAL
- en: For each of these characters (and situations), the AI must be able to calculate
    a suitable route within the game level, ensuring that it can respond to objects
    that come into its path, in order to reach its goal. Ideally, you want the character
    to act as natural as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In larger contexts, navigation can be used in a space, which can represent the
    environment, but also more abstract things, such as the space of moves of a problem.
    For example, in the famous *Eight queens* game (placing eight queens on a chess
    board such that each one of them doesn't attack another; you should try it), finding
    a path in the space of moves might be equivalent to finding a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In video games, navigation can exist in various forms, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Steering behaviours**: These find an immediate path in front of the agent
    to avoid collisions. It can be used for basic obstacle avoidance, also in multi-agent
    system contexts. Since these behaviours are at a low-level, in video games they
    always have been implemented in a Kinematic way (in the same way we saw in [Chapter
    5](part0062.xhtml#aid-1R42S1 "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The
    Secret Ingredient Is a Dash of Physics*). However recently, some dynamic steering
    behaviours have arisen in the game development world, bringing more realistic
    games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pathfinding**: These finds a path from a starting location to a destination.
    This level is the most used, and many techniques have been discovered/invented
    and implemented. It is this type of navigation that will be the focus of this
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Driven pathfinding**: These finds one or multiple paths according to some
    driven behaviours. This is still a level that has never been implemented in the
    game industry, but it''s a field of research for game development in academia,
    and therefore it''s worth mentioning. This level is placed between decision making
    and pathfinding. In fact, some decisions are taken at pathfinding time, bringing
    a more intelligent pathfinding and efficiency in decision processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information about the different types of navigation can be found in more
    detail on my website. Moreover, my research involves directly driven pathfinding,
    such as the BDP (we will see later in the chapter). Here is the link: [francescosapio.com](http://francescosapio.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Pathfinding and its techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the last few decades, many pathfinding algorithms and techniques have been
    explored. One of the very first pathfinding algorithms that was invented was the
    **dijkstra algorithm**, which gave the foundation for modern pathfinding algorithms.
    Of course, since Dijkstra, much progress has been made and algorithms have become
    much more efficient (especially when we deal with specific information or we have
    a priori knowledge about the problem that we can use). The most used of these
    in video games is the **A* algorithm** (along with all its derivations), which
    uses some additional information about the map. The main concept of Dijkstra was
    to explore in all directions until a route was found; the main concept of A* is
    to explore towards the direction of the destination (which may sound simple, but
    it is not always easy to determine a function that in some way tells you which
    is the direction towards the destination). Of course, this is a simplification,
    but good enough to gain a better overview.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding mentioned algorithms work in many situations, but if the route
    which we want to find is easy enough to be found in a small map, it wouldn't be
    worthwhile developing such algorithms, since there are easier techniques. One
    of these techniques is the use of waypoints, which is the technique we will use
    for our game. The main concept is that the map is split into a graph which, potentially,
    is very small (enough to be drawn by hand) and finding a path can happen in a
    distributed way. Of course, there is another entire world beyond distributed pathfinding
    (a practical application would be IP packets that need to travel the world on
    the Internet, and the path between the different routers is determined in a distributed
    way since the map of the network changes continuously).
  prefs: []
  type: TYPE_NORMAL
- en: Another important fact that influences pathfinding (but also other techniques
    of AI) is whether the algorithm needs to work online or offline. Online means
    that the algorithm needs to find a solution in real time, whereas offline means
    that the solution can be found a priori. In video games, there are situations
    in which we need to use online solutions (such as finding the path for your NPCs)
    and others where we need an offline solution (for instance, when you have more
    time to compute, such as with turn-based games, or when some AI calculations are
    performed at loading time).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we would need another book just to describe navigation in video
    games, but this chapter is giving you a nice and gentle introduction to the world
    that's behind all of this, and you can use the references (suggested books and
    links) to continue your journey in learning AI in games.
  prefs: []
  type: TYPE_NORMAL
- en: Waypoints for enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A waypoint is a special point on the map where NPCs change their direction to
    move towards another waypoint. They can contain logic to actually lead the character
    to specific places that change over time, such as next to the player. For instance,
    in a shooting game, enemies want to get closer to the player to shoot him/her.
    Waypoints can also perform part of the decision-making process. For example, imagine
    a tower defense level where the path of the enemies splits in two. In this case,
    the waypoints can be used to decide which direction a particular enemy should
    take (we will see this in the last chapter of this book). The advantages of waypoints
    are that, in some cases, they can be more efficient than implementing a complete
    pathfinding algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In more complex implementations, waypoints can be connected in different ways
    and these connections can also be created automatically by letting the waypoints
    find each other. Furthermore, they can also contain other information, such as
    which is the closest waypoint to the player. Here, the enemy can ask or query
    the waypoints where to head towards in order to find the player without running
    a complete pathfinding algorithm on the map itself.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, we don't need to implement a particular logic behind the waypoints.
    However, they are a useful tool since they allow us to move enemies around the
    map easily, and they are modular enough so to be able to create other levels of
    our game without many problems.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to create waypoints. In particular, we will
    see two ways to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the waypoint coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start creating waypoints, we first need to decide where to place
    them on the map. Therefore, we need to find all the places where our Pandas change
    their direction. In this simple map, they are located at all corners of their
    path. In the following image, they are indicated by the red dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the waypoint coordinates](img/image00581.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, there are 11 and we need one waypoint that is on the cake in
    the map. This final waypoint is the finishing spot, where the Panda has succeeded
    in his mission to steal a big bite of the player's cake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have spotted them, we need to take note of their coordinates on
    the map. A fast way to do it is to drag the Panda Prefab around the map in the
    **Scene** view and then take note of the position of our waypoints. In this case,
    we could obtain the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Waypoint number** | **X coordinate** | **Y coordinate** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `-28` | `8` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `-28` | `-16` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `-16` | `-16` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `-16` | `7` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `-2` | `7` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `-2` | `-6` |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `12` | `-6` |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `12` | `9` |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | `25` | `9` |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | `25` | `-17` |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | `32` | `-17` |'
  prefs: []
  type: TYPE_TB
- en: Implementing waypoints – the first/static way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all the waypoint coordinates, we can implement them. In this
    section, we will explore the first way to implement them. The main advantage of
    this method is the simplicity of the implementation and the possibility to learn
    more about static variables and iterating over waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing waypoints in the Game Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this first implementation of waypoints, they won't be separate entities in
    the game, but rather a collection of positions in a specific order. All the enemies
    will consult this list, and based on which waypoint they are currently at, take
    the next one in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this method has some limitations such as we won't be able to implement
    custom features in the waypoints, as we will see in [Chapter 8](part0100.xhtml#aid-2VBO82
    "Chapter 8. What Is beyond the Cake?"), *What Is beyond the Cake?*. However, it
    is simpler to implement, and it gives us the opportunity to explore how to use
    static variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to create another script, and call it `GameManagerScript`.
    We will implement more functionality in this script in the next chapter. But at
    the moment, it is needed to store the waypoints. In fact, for now, we just need
    to add an array of positions, so you can write the following in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a `Vector3` array, which basically just stores a set of positions in
    a specific order. Save the code, and create an empty GameObject in the **Scene**,
    which you can rename `Game Manager`. Attach the script on it, and in the **Inspector**
    you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints in the Game Manager](img/image00582.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to set the number of elements of our array with the number of waypoints
    we have found, in this case 11\. Therefore, our **Inspector** looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints in the Game Manager](img/image00583.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can fill all those values with our waypoint positions. But what
    about the *z*-axis? Since we don''t want the Pandas to change their *z*-axis,
    we can just set its value to the same *z*-axis value of our `PandaPrefab`, which
    is `-1`. At the end, we should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints in the Game Manager](img/image00584.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The reader may wonder if it was worthwhile using `Vector2` instead of `Vector3`.
    The answer is: it''s your choice. Nothing prevents you from using `Vector2` and
    forgetting about `Vector3`. But, since we have made the choice to handle the depth
    of our game with z-buffering, I personally prefer to have direct control over
    the *z*-axis as well, so be sure to achieve the intended behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving along the designed path – static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need to give an opportunity for the enemies to have access to the waypoints
    stored in the `GameManagerScript`. Therefore, we need to get a reference it. There
    are many ways to do so, but for learning's sake, we will use a static variable
    (so as to unravel the use of such variables). In fact, all the Pandas share the
    same game manager, and it's a waste of computational resources if every time a
    Panda is created, it needs to search for the `Game Manager`. A static variable
    is a value which is shared among all the instances of the `PandaScript`. Of course,
    we need to be careful not to assign this variable many times.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that static variables are persistent over different scenes/levels.
    Therefore, if you are planning to release a game with more than one level, most
    likely you will need to reset this variable when the level is changed. We will
    explore this better in [Chapter 8](part0100.xhtml#aid-2VBO82 "Chapter 8. What
    Is beyond the Cake?"), *What Is beyond the Cake?*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PandaScript`, and let''s add the static variable to store the reference
    to the `Game Manager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the `Start()` function we need to check if another instance
    (another Panda) has already been assigned this variable. If not, we will assign
    it by finding its reference in the scene, even though there will only be one game
    manager in the scene at the time. As a result, this Panda will actually initialize
    the variable. As such, all the other instances of Pandas that will be created
    will have a reference to the `Game Manager` ready, and thanks to this check, we
    are sure that we are assigning it only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to make the Panda move. But first, we need a variable to store
    the current waypoint that the Panda is heading towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a constant to establish a threshold after which the waypoint
    is considered as having been reached. In fact, there are numerical instabilities,
    and we cannot check directly if the distance from the waypoint is actually zero,
    only a value very close to it. As you can see, the value assigned to this constant
    is very low:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to implement the mechanism under which the Panda heads towards
    the right waypoint, and changes direction to the next one when the previous is
    reached. Since the `MoveTowards()` function we will use to move the Panda deals
    with physics, we need to implement this whole mechanism of the waypoints within
    the `FixedUpdate()` function, as we learnt from [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*. So, we can start writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, we need to do three things within the `FixedUpdate()` function.
    The first one is to check if the Panda has reached the end of the waypoint list,
    which means it is in front of the delicious player''s cake. If so, we need to
    trigger the eat animation in the same fashion we triggered the others in [Chapter
    4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No Longer Alone – Sweet-Toothed Pandas
    Strike"), *No Longer Alone – Sweet-Toothed Pandas Strike*. Then, we need to remove
    this script from the Panda. In fact, the `State Machine Behaviour` script we wrote
    in [Chapter 4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No Longer Alone – Sweet-Toothed
    Pandas Strike"), *No Longer Alone – Sweet-Toothed Pandas Strike*, will take care
    of removing the Panda from the scene. Finally, we return so that the rest of the
    function is not executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second thing, in case the Panda is not at the last waypoint yet, is to
    calculate the distance between the current Panda''s position, through its Transform,
    and the waypoint it is heading towards. This value is stored within a local variable
    `dist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing is to check if the Panda is close enough to the waypoint. Enough
    means below the constant threshold stored in the `changeDist`. If so, we just
    increase the counter of the waypoints so that at the next iteration, the Panda
    will head to the next waypoint. Otherwise, we just use the `MoveTowards()` function
    implemented in the previous chapter to move the Panda towards the waypoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can save our script and test it out. By placing a Panda in the scene somewhere
    near the first waypoint and pressing play, we will see it moving along the path.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing waypoints – the second/dynamic way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore a second way to implement the waypoint system
    of our game. Of course, the outcome will be the same, but this approach offers
    many other advantages. First of all, it's easier for designers to collocate, change,
    move, and replace waypoints within the map itself. Second, it allows a great flexibility
    in behaviors, which can be implemented in such a way to make it easier for designers
    to use the script created. We will exploit some of the potentiality of this system
    later in the last chapter of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, this approach does suffer from some drawbacks, as with every choice
    in life. In particular, the complexity of the system increases. Moreover, it uses
    a different game object for each one of the waypoints, and this is critical if
    the number of waypoints is really high.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To overcome this last problem of having different game objects for each of the
    waypoints, we have many possibilities, but making each one of them work is a challenge
    and at the same time, easy for designers to use. In fact, waypoints can still
    be stored as a list, not as positions this time, but rather of the `waypoint`
    class, and at the same time expose functionalities to allow designers to edit
    and place them within the **Scene** view. This is left as a challenge in the *Homework*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing waypoints as separate entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen a simple implementation of the waypoints. Now, we will
    implement them again, but this time as separate entities. As such, in [Chapter
    8](part0100.xhtml#aid-2VBO82 "Chapter 8. What Is beyond the Cake?"), *What Is
    beyond the Cake?*, we will explore how to unlock the potential of waypoints in
    a game. In fact, at the end of this section, the effect on our game will be the
    same; however, we will change the script in [Chapter 8](part0100.xhtml#aid-2VBO82
    "Chapter 8. What Is beyond the Cake?"), *What Is beyond the Cake?*, by implementing
    more features.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to erase the `waypoints` variable from the `GameManagerScript`
    (but don't erase the script, even if it is empty, because we will use it; for
    the same reasons, don't erase the `gameManager` variable from the `PandaScript`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to create a new script, which will be the actual waypoint. As such,
    we can rename it as `Waypoint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a variable of the same class to store the next waypoint. In this way,
    each waypoint will be able to point/reference towards another waypoint. The goal
    is to build a chain which the Pandas will follow. Since the variable is private
    but we still need to have access to it in the **Inspector**, we need to add the
    serializable property. So, we can add the following to our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, from the waypoint, a Panda would like to retrieve its position and the
    next waypoint to follow, once the current one is reached. To achieve this, we
    can expose two functions from our `Waypoint` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetPosition()` function will return a `Vector3` with the position of the
    waypoint, which (in this specific implementation) is stored in the Transform of
    the waypoint. The code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetNextWaypoint()` function, instead, will return just the next waypoint
    (at least for the moment), stored in the `nextWaypoint` variable. In fact, the
    `nextWaypoint` variable is private, and so Pandas need a function to retrieve
    it. Therefore, we can just write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have finished with this script for now, so we can save it.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a Prefab for our waypoints. Create an empty GameObject
    and attach the `Waypoint` script. Then, in the **Project** panel, create a Prefab
    called `WaypointPrefab` and drag and drop the empty GameObject you have created.
    Finally, erase the empty GameObject from the scene, since now we have our Prefab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag and drop as many Prefabs as the number of waypoints you have identified;
    in our example, there are 11\. For your convenience, I suggest you rename them
    in a progressive order, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints as separate entities](img/image00585.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to link them to each other. In particular, `waypoint1` will be
    linked to `waypoint2`, which will be linked to `waypoint3`, and so on. For instance,
    `waypoint4` should look linked in the **Inspector** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints as separate entities](img/image00586.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The only exception is in the last waypoint, which has nothing in the `nextWaypoint`
    variable, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints as separate entities](img/image00587.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we need to place them at the coordinates we have identified in the
    *Getting the waypoint coordinates* section. To quickly recognize them, I recommend
    that you add a Gizmo icon. As the name suggests, a Gizmo is an icon that will
    be shown in the Scene view to quickly and easily recognize specific objects, but
    won't be visible once the game is built. Recently, Unity added also the possibility
    to see them within the **Game** view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to insert a Gizmo is by clicking the cube-shaped icon next
    to the name of the GameObject, highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints as separate entities](img/image00588.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same holds for Prefabs, but their icon is a blue cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have clicked on this icon, a menu appears as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints as separate entities](img/image00589.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By selecting one of the ellipse-shaped icons, you will place a label to the
    object with its name in it. We will choose one of these for our waypoints. If
    you click on the circle-shaped or crystal-shaped icons, the Gizmo will look like
    a circle or a crystal, without any text. If you click the **Other…** button, you
    can use your own graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more complex way to insert Gizmos is through scripting. In fact, there is
    a special function called `OnDrawGizmos()` which is called by Unity when rendering
    Gizmos is enabled. Within this function, you are able to use any of the functions
    listed at [https://docs.unity3d.com/ScriptReference/Gizmos.html](https://docs.unity3d.com/ScriptReference/Gizmos.html),
    which allow you to draw shapes on the screen. This is a very powerful tool, because
    it can enhance tremendously the usability of your scripts. For instance, in our
    specific case of waypoints, we could draw the path that Pandas will follow. This
    is left as an exercise in the *Homework* section.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we can select one of the ellipse-shaped icon for all the waypoints.
    As a result, we are able to see them in the **Scene** view (even if they don't
    have any explicit rendering component and thus they won't be visible in any way
    in the final game) and quickly place them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, your **Scene** view should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints as separate entities](img/image00590.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to specify to the game, which one of these waypoints is the first
    of the chain. As such, we can store this information within the `Game Manager`.
    So, let''s add the following variable to the `GameManagerScript`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after having saved the script, set the variable in the **Inspector**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing waypoints as separate entities](img/image00591.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In conclusion, we have created a chain of waypoints, which is exactly what we
    need for our game. However, we still need to define how the Pandas get to them.
  prefs: []
  type: TYPE_NORMAL
- en: Moving along the designed path – dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to slightly modify the `PandaScript` to take care of this new
    waypoint system. So, let's open the script again.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to substitute the integer variable, `currentWaypointNumber`,
    with a proper waypoint variable, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to initialize this new variable; we can do it in the `Start()`
    function, by retrieving the first waypoint from the `Game Manager`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the first check of the `FixedUpdate()` function, we need to check
    if the variable itself is null (which means that the Panda has reached the cake,
    because the last waypoint will return a null pointer). Here is the code, with
    the modified parts highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Going on in the `FixedUpdate()` function, we need to change how the distance
    is calculated, by using the `GetPosition()` function of our waypoint in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to change the last `if` statement of the `FixedUpdate()` function
    to get the next waypoint when the previous one is reached. We also need to decide
    which parameter we should give to our `MoveTowards()` function. Again, the modified
    parts are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Save the script. We have finished this second way of implementing waypoints.
    [Chapter 8](part0100.xhtml#aid-2VBO82 "Chapter 8. What Is beyond the Cake?"),
    *What Is beyond the Cake?*, will suggest some ways to take advantage of this structure
    to implement more complex behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: More about artificial intelligence in games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we have seen a couple of implementations of a waypoint
    system to move characters within the game environment. However, as we already
    said in the introduction, this is not even scratching the surface of AI in games.
    This section presents some techniques, without entering into detail, as they are
    not needed to develop our tower defense game. In fact, to master AI in games,
    you need a specific book about it. Therefore, feel free to skip this section,
    or read it. You can always come back here later, maybe when you finish the book,
    for a deeper look at its content. The main goal of this section is just to give
    you a basic understanding of AI in games.
  prefs: []
  type: TYPE_NORMAL
- en: Other techniques for navigation at the pathfinding level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Pathfinding and its techniques* section at the beginning of this chapter
    was in no way exhaustive, and of course thousands of other techniques exist at
    the pathfinding level which are used in video games.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s worth quoting one in particular: Navigation Mesh. This is important,
    because it''s built into the Unity engine for 3D games. The main concept behind
    this technique is a pre-analysis of the geometry of the level to extract a graph
    (this is for instance, an offline algorithm) where other pathfinding algorithms
    can extract paths when needed (these, instead, work online).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate such a graph by setting some parameters by clicking in the
    top menu bar on **Window | Navigation**. Specifically, you can set the general
    options in the **Bake** tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Other techniques for navigation at the pathfinding level](img/image00592.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once this graph is built, agents can have access to it through specific classes
    in scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, this belongs to the 3D part of Unity, and we won''t go into it
    any further. But if you are interested in learning more, you can start from the
    official documentation at: [https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html)
    (as you may notice from the table of contents, it''s quite a large and extensive
    tool in Unity, but powerful).'
  prefs: []
  type: TYPE_NORMAL
- en: Navigation at the level of steering behaviours
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember how we could implement physics equations in Unity from [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*? We can implement all the equations of the motion and we
    will obtain any kind of movement. If then, we mix this with a goal, a destination,
    or even just a direction, along with some obstacle avoidance techniques, we have
    made a steering behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you implement obstacle avoidance as magnets that repulse the
    NPC, and the goal as an attractive magnet, you obtain a pretty nice steering behaviour.
    Characters could reach destinations without any pathfinding algorithms. Note that
    I said *could*. In fact, they can get stuck, and there are many other issues related
    to steering behaviours as an end-solution. But integrating steering behaviours
    in a pathfinding algorithm (the first deals with high-level navigation, such as
    going from one room to another, the second can navigate within the room to reach
    the door to the next room) is a great addition, which can lead to highly-realistic
    behaviours with very low performance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation at the level of steering behaviours](img/image00593.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example of steering behaviour with magnets
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the attraction range of the goal is extended to the whole map, whereas
    the repulsion force of the obstacles is just local. Moreover, these forces can
    follow different potential laws, and have different shapes. To help you to visualize
    magnetic fields, you can give a look at the picture by Dayna Mason at: [https://www.flickr.com/photos/daynoir/2180507211](https://www.flickr.com/photos/daynoir/2180507211).
    Each compass represents which kind of force the character is subject to when he/she
    is in that position. The same happens in our example, where the character is pushed
    away from obstacles and attracted by goals. It is also interesting to note that
    our goals and obstacles are single pole magnets, but in our physical world they
    don’t exist (only magnetic dipoles exist).'
  prefs: []
  type: TYPE_NORMAL
- en: Navigation at the level of pathfinding/decision making – belief-driven pathfinding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I have already mentioned, research in academia has recently started to merge
    portions of decision-making within pathfinding. An example of this is one of my
    own publications about **Belief-Driven Pathfinding** (**BDP**).
  prefs: []
  type: TYPE_NORMAL
- en: The key concept is that NPCs do not necessarily know the entire map. Imagine
    there was a bridge to cross a river, but the player had destroyed the bridge;
    therefore, when the character navigates through the environment, the character
    should consider the map as if the bridge was still there, because he is not aware
    that the bridge is down. Only when he approaches the river, he realizes that the
    bridge is down, and therefore, takes action on it (such as find another path,
    build another bridge, create a raft with the wood, or swim). That is why it is
    belief-driven, because the character navigates through the environment as he/she believes
    the environment is and, as such, makes assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are interested in learning more about BDP, you can check out my website
    at: [francescosapio.com](http://francescosapio.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AI in games is not limited to only navigation, but as we said in the introduction,
    there are many levels that AI can be applied to in video games. Imagine turn-based
    games, in which NPCs needs to take strategic decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'But AI does not only apply to non-player characters. Some games implement algorithms
    to adapt the difficulty to the game (adaptive and learning algorithms), others
    handle how the camera should move in order to raise a specific emotional state
    in the player (such as in the work of Georgios N. Yannakakis in particular, in
    the paper, *Space Maze: Experience-Driven Game Camera Control*). Other games have
    algorithms of **Procedural Content Generation** (**PCG**), like the famous *Temple
    Run* (Imangi studios, 2011) which procedurally generates the level, or even *Minecraft* (Mojang,
    2011) in which a whole world is procedurally generated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'AI is also applied for analysis of games and players, such as to study the
    inner structures of games or to gather psychological player profiles. Regarding
    the latter, you need to imagine the application in serious games, where games
    can be used to evaluate the performance of people within specific contexts. You
    can find an interesting introductory paper titled; *Towards personalized, gamified
    systems: an investigation into game design, personality and player typologies* by
    Lauren S. Ferro (available at: [http://dl.acm.org/citation.cfm?id=2513024](http://dl.acm.org/citation.cfm?id=2513024)).'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it's worth mentioning that the relationship between games and AI is
    not mono-directional. In fact, not only do games use AI, but also the opposite
    applies. Some studies and research on AI are helped by video games, which can
    provide a perfect simulation environment (for instance, for robots), and also
    create algorithms that take the place of the player and play the game (without
    cheating, because the AI within the game always uses additional extra data to
    gather the specific state of the game).
  prefs: []
  type: TYPE_NORMAL
- en: In any case, keep in mind that when AI is used in games, the most important
    aim is not to be realistic, but to create an immersive and entertaining experience
    for the player (which may also result in learning experiences, if the design of
    the game includes that).
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we gained an overview of AI in games. However, we focused
    only on navigation, and in particular, implementing the waypoint system for our
    game. But you can still improve it, and this section proposes some exercises to
    achieve that. Therefore, before the next chapter, I invite you to do the following
    exercises to develop your skills even more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Becoming an AI designer and programmer**: Think of five games that you play,
    and select a part of that game that contains NPCs such as the enemies or even
    the boss. Now, write down a list of behaviors that each of them have. Now, remove
    some behaviors, or even add some and think about how it would alter the experience.
    Does it improve it, or does it change the atmosphere entirely? Could you make
    a relatively realistic behavior into intelligent, yet not realistic, by changing
    some of the behaviors, and vice versa? By doing this, you will begin to understand
    the importance that some behaviors play in not only providing life to your characters,
    but in also giving emotions to the player.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Waypoints as colliders**: From the previous chapter, we learnt how to use
    colliders and detect collisions. In particular, we saw how the sprinkles collided
    with Pandas to trigger actions (in this case, to shoot down the Panda). However,
    the same principle can be applied here as well. Instead, to use the `changeDist`
    constant and check the distance from the Panda to the waypoint, we can use the
    `OnTriggerEnter2D()` function again to check when a Panda has reached a waypoint.
    Implement the changing of waypoints in this way, regardless of whether you are
    using the first or second implementation. Little hint: you probably need to set
    a new tag (remember how to set a tag from [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers*?) for the waypoints,
    and add colliders on them too.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Waypoints that auto-reach themselves**: In more complex waypoint systems,
    you shouldn''t manually create the chain (even though the solution becomes hard
    to scale when the map becomes bigger). As such, try to design and implement a
    system where the waypoints auto-connect themselves once placed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a Gizmo path displayer**: Back in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers*, we saw how it was
    possible to use some Gizmo functions to draw useful stuff on the scene. Use those
    functions, and in particular `Gizmos.DrawLine()`, to show the chain of waypoints
    on the **Scene** view.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And finally, there is a challenge for you:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Easy waypoint**: In the second implementation, we use a different game object
    for each one of the waypoints. Design and implement a system that is as easy as
    the one implemented in this chapter for designers (so they can drag around the
    waypoints in the **Scene** view, and possibly see the chain from the previous
    exercise), but at the same time is efficient, since it won''t use game objects
    for waypoints (but rather an array stored somewhere).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learnt the very basics of artificial intelligence in video
    games. We went through an overview about navigation and some common techniques
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we built our navigation system for our game, based on waypoints. In particular,
    we have implemented two types of waypoint systems for our game, to learn different
    ways of achieving the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we had another general overview about AI in games.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will finish our game! Already excited? Well, what are
    you waiting for? The next chapter is just a page away.
  prefs: []
  type: TYPE_NORMAL
