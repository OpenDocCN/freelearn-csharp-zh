- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic Concepts of Console Applications in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our development environment has been set up, it’s time to start our
    journey through the development of CLI applications using .NET.
  prefs: []
  type: TYPE_NORMAL
- en: However, first, we will explore console applications!
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re probably familiar with console applications, and you may be wondering
    why we need to discuss console applications in a book dedicated to CLI applications.
    The reason is that at the core of every CLI application is a console application.
    That’s why, in this chapter, we’ll take a moment to explore console applications.
    Plus, you know what they say: a reminder never hurts 😉.'
  prefs: []
  type: TYPE_NORMAL
- en: Console applications can be seen as the simplest CLI applications one can build.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, by exploring how we create, run, and interact with a console application,
    we will gain a basic understanding of how to work with CLI applications and how
    to build them by leveraging the console application template provided with the
    .NET SDK.
  prefs: []
  type: TYPE_NORMAL
- en: We will then create a very simple .NET console application, which takes some
    arguments as input and displays a message as an output. We will then enhance this
    application so it can perform some basic validations on the inputs and display
    the appropriate message as an output. This message will be displayed in a given
    color, depending on its severity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to create and execute console applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage the `System.Console` class for reading user input and outputting responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole).
  prefs: []
  type: TYPE_NORMAL
- en: Creating (and executing) a simple console application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by opening Visual Studio Code and displaying the integrated terminal
    window by going to **View** | **Terminal**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, position yourself where you want the code folder to be created (I always
    create a `code` folder in my `C:` drive where all my code folders are located;
    I find it convenient to centralize all my code at the same location).
  prefs: []
  type: TYPE_NORMAL
- en: 'After ensuring that you are in the right working directory, type the following
    command to create a .NET console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this command to understand what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dotnet new console`: This will ask the .NET CLI tool to create a new console
    application. This will use C# as a language and .NET 8 as a framework (since these
    are the default values).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n helloConsole`: Our application will be named `helloConsole`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o helloConsole`: A `helloConsole` folder will be created that will contain
    all the code files for our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--use-program-main`: The `Program` class containing the `Main` method will
    be added to the created `Program.cs` file. This method is the entry point of our
    program, and we will use its parameter to pass input values to our console application
    when we execute it. You can skip using `--use-program-main`, of course, but I
    prefer using it since it makes the `Program` class more explicit and familiar
    to developers coming from older versions of .NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the command completes, you should see an output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This confirms that the application has been successfully created.
  prefs: []
  type: TYPE_NORMAL
- en: A brief tour of the generated project
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated project contains three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '- `Main` method). While it may contain all the application’s logic in very
    simple applications, it usually serves as a starting point, delegating to other
    classes and methods as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '- `.csproj`) file is essential for .NET development as it centralizes project
    configuration, making it easier to manage, build, and share projects across different
    development environments and build systems. It’s particularly important in the
    modern .NET ecosystem, which emphasizes cross-platform development and flexible
    project structures. In this file, we typically find information about the project
    definition, the build configuration, the dependency management (both project references
    and references to NuGet packages), the compilation settings, resource inclusion,
    any build process customization, project-wide properties (such as assembly name
    and version), cross-platform compatibility, and IDE integration.'
  prefs: []
  type: TYPE_NORMAL
- en: '- `.sln`) file is a text-based file that serves as a container for organizing
    and managing related projects. It plays a crucial role in the development workflow,
    especially for larger applications that comprise multiple projects. Its purpose
    is to organize multiple related projects into a single solution, define build
    configurations and platforms for all projects, store solution-wide settings and
    metadata, and allow Visual Studio to load all related projects simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s load the project into Visual Studio Code by typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A new instance of Visual Studio Code will open, and you’ll see the content
    of the newly created project, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The helloConsole project opened in Visual Studio Code](img/B22400_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The helloConsole project opened in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse code with code!
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `code` command is the executable name for Visual Studio Code.
    It should not be confused with the `code` folder 😉.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code contained in the `Main` method of the `Program.cs` file doesn’t do
    much at the moment. In fact, it only displays a `"Hello, World!"` message when
    the application is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s execute this application and see what it returns. For that matter, we
    will need to type this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that this command can be executed in any terminal:
    the PowerShell terminal, the CMD console, or the Bash terminal (if you are running
    Linux or macOS). However, since we are using Visual Studio Code, the easiest way
    to run commands is to use the integrated terminal within Visual Studio Code. That
    being said, you must ensure that you are in the project folder, which means that
    the `dotnet run` command should be executed in the same working directory as the
    `.``csproj` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will build and then execute the application. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Hello, World! output](img/B22400_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Hello, World! output
  prefs: []
  type: TYPE_NORMAL
- en: This is not very useful at the moment, is it?
  prefs: []
  type: TYPE_NORMAL
- en: However, we can notice that the `Main` method takes an array of strings as an
    argument (that is, as an input parameter). So, let’s use that to pass some parameters
    to our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we modify our application code to show the value of that parameter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, once executed, our program will display the `Hello` message, followed by
    the value we passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Passing in one parameter](img/B22400_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Passing in one parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, of course, pass in more than one parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Passing in more than one parameter](img/B22400_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Passing in more than one parameter
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three remarks you need to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The parameter to be passed to the `Main` method is an array of **strings**.
    This means that you’ll need to parse these strings if the program is expecting
    an input of another data type (such as an integer, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Since this parameter is an array of strings, you can use the passed-in values
    by specifying their index, which represents their position from the program execution.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. If you use a parameter value in the code but don’t pass it when executing
    the program, an exception will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: What do these remarks mean from a code perspective? Let’s consider some illustrative
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll address the first remark. This example shows that the input parameter
    is of the `string` type despite its value, `42`, representing an integer. In order
    to use that value as an integer, we need to parse it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Parsing input parameters](img/B22400_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Parsing input parameters
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s consider the second remark. This example shows that by switching
    the indexes of the parameters, we also switch the display of their values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Switching input parameters](img/B22400_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Switching input parameters
  prefs: []
  type: TYPE_NORMAL
- en: Finally, regarding the third remark, this example demonstrates that failing
    to provide a value for the input parameter when executing the program will cause
    it to crash and throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Missing an input parameter](img/B22400_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Missing an input parameter
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to create and execute .NET console applications. Let’s see how
    we can interact with user inputs and better format our outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the System.Console class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that in all our examples up to this point, we have used
    the `Console` class. More specifically, we only used one of its methods (namely
    `WriteLine`). This method displays the value of the expression passed as a parameter,
    and then gets to the next line. If we don’t want to get to the next line, we can
    use the `Write` method instead.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `Console` class provides other useful properties and methods. We
    won’t go into the details of all of them (for that matter, I’d recommend that
    you visit [https://learn.microsoft.com/en-us/dotnet/api/system.console](https://learn.microsoft.com/en-us/dotnet/api/system.console)).
    Instead, I’ll highlight the most interesting ones when it comes to console applications.
  prefs: []
  type: TYPE_NORMAL
- en: Useful properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three properties I would like to tell you about in particular: `BackgroundColor`,
    `ForegroundColor`, and `Title`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first two, as their names suggest, are used to alter the background and
    foreground color of the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The third one, `Title`, is used to alter the title of the terminal window. Keep
    in mind that you will need to execute the program in an external terminal (not
    in the Visual Studio Code integrated terminal) to see the effect of changing the
    terminal’s title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustrative example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, at the beginning of the program, we performed a backup of both
    the foreground and the background colors, and we restored them at the end of the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to do this for the terminal’s title since the set value is
    only effective during the execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Useful methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are also a few interesting (and useful) methods I would like to talk
    about. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadLine`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadKey`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with `ReadLine`. This method reads all the characters from the user
    input until they hit *Enter* and returns the user input as a `string`. So, it
    is useful to gather user inputs, such as a name, an age, or an address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Reading user input from the console](img/B22400_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Reading user input from the console
  prefs: []
  type: TYPE_NORMAL
- en: Next, Let’s talk about `ReadKey`. This method reads the character or function
    key the user pressed. It returns an object of the `ConsoleKeyInfo` type, which
    includes information about the pressed key. It also takes an optional Boolean
    parameter that, if set to `true`, will not display the pressed key to the console,
    and if set to `false`, will display it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example with the Boolean parameter set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – A ReadKey method with the Boolean parameter set to true](img/B22400_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – A ReadKey method with the Boolean parameter set to true
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, notice the output when the Boolean parameter is set to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – A ReadKey method with the Boolean parameter set to false](img/B22400_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – A ReadKey method with the Boolean parameter set to false
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you noticed that the pressed key is displayed twice: once after it is
    pressed, and a second time with the output message?'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, you can visit [https://learn.microsoft.com/en-us/dotnet/api/system.consolekey](https://learn.microsoft.com/en-us/dotnet/api/system.consolekey)
    to find a list of all of the values of the `ConsoleKey` enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s see the `Clear` method. As its name suggests, it clears the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Clearing the console with the Clear method](img/B22400_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Clearing the console with the Clear method
  prefs: []
  type: TYPE_NORMAL
- en: After the user presses the *C* key, the console is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is typically used in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**At the startup of the program**: It is used here so that your program gets
    a clean interface by removing all previous outputs from other programs or commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When entering a new section or menu item**: This prevents outputs from previous
    sections from polluting the current one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve ever run a CLI application, you’re probably aware of the *Ctrl* +
    *C* or *Ctrl* + *Break* key combinations that make you exit the program at any
    time by terminating it.
  prefs: []
  type: TYPE_NORMAL
- en: In a .NET console application, these key combinations raise an event called
    `CancelKeyPress`. When one of the key combinations is pressed, the event is raised
    and interrupts the operation being executed. Our code can handle this event to
    allow for a graceful shutdown of the program, cleaning and freeing up resources
    before the shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate this with an example. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may notice, this code uses an infinite loop with no exit condition.
    Hence, the only way to exit from it is by using one of the canceling key combinations
    (*Ctrl* + *C* or *Ctrl* + *Break*). However, when pressed, this will abruptly
    terminate the program without giving it a chance to perform some actions in order
    to exit gracefully, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving the execution state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging out of services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing database connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will then modify the previous code to handle that termination event, allowing
    the program to gracefully terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the result of the execution looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Canceling the current operation](img/B22400_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Canceling the current operation
  prefs: []
  type: TYPE_NORMAL
- en: So, if your CLI application interacts with external resources or services (as
    we will do in the upcoming chapters), you should leverage the `Console.CancelKeyPress`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have executed the program using the .NET CLI `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are familiar with CLI applications, you will know that this
    type of application is usually executed by the name of its executable file.
  prefs: []
  type: TYPE_NORMAL
- en: The first question that comes to mind is “Why have we executed our program using
    the .NET CLI `run` command?”. The answer is “because this is how you will do it
    when developing and testing your CLI application.”
  prefs: []
  type: TYPE_NORMAL
- en: The next question that comes to mind is “Well, how do I execute my program using
    its executable?”. The answer to that question is “by reaching the location of
    that executable file and running the program from there.”
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build the program, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the executable file in the `bin\Debug\net8.0` folder on your
    hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Windows machine, this will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The generated executable file](img/B22400_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The generated executable file
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the program using its executable file name, open a terminal window,
    navigate to that location, and then type the following command (here, we are passing
    `42` as a parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Running the program from its executable file](img/B22400_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Running the program from its executable file
  prefs: []
  type: TYPE_NORMAL
- en: Should I use dotnet run or run the executable file?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some differences between running the program using the `dotnet run`
    command and running the program from its executable file. Here are the most significant
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '- `dotnet run` command builds the project before running it, which ensures
    that we are always running the most up-to-date version of the code. The executable
    file represents the last compiled version of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '- `dotnet run` is slower (due to the build step) compared to running the program
    from its executable file. While the `dotnet run` command may take a few seconds
    to build and execute the code, the executable file usually executes in a matter
    of milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep this in mind since, during the development phase, you’ll
    likely rely on `dotnet run` to execute your program. However, in the testing and
    production phases, you’ll rely on the name of the executable. So, make sure you
    carefully choose the name for your program (and its executable) 😉.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored what lies at the core of a CLI application: a
    console application! This is why it is crucial to learn how to work with console
    applications, as they are the foundation for building more complex CLI applications.'
  prefs: []
  type: TYPE_NORMAL
- en: We saw how we can execute a console application, providing values as input parameters
    and parsing these input parameters’ values in order to convert them into the data
    type expected by our program. We saw how we can gather user inputs through the
    use of the `ReadKey` and `ReadLine` methods of the `Console` class. Finally, we
    saw how we can handle exceptions raised as the result of a missing input parameter
    value.
  prefs: []
  type: TYPE_NORMAL
- en: However, a CLI application is more than a console one. It contains named parameters,
    flags, and subcommands.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will see how we can leverage these capabilities
    into a fully functional CLI application. In the next chapter, we will start by
    creating the CLI application and learning how to parse its inputs, including commands,
    flags, and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to achieve the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a console application that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the title of the terminal window to **GUESSING GAME!**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generates a random integer value between 1 and 20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tells the player that they have three chances to figure out that number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After each player’s trial, it should then do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player figured out the number, the program displays, in green text, **Congratulations,
    you won!**, along with the number of trials it took the player to figure it out
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player was not able to figure out the number within the three granted
    trials, the program should display, in red text, **Better luck next time! The
    number to be guessed was** along with the value to be guessed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player hits *Enter* without providing a number, the program should consider
    that the value is zero and proceed with it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player hits *Ctrl* + *C*, the program should exit and display, in yellow
    text, **Thank you** **for playing!**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Foundations of Building CLI Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will delve into the essential components of CLI application
    development. You'll explore command-line parsing techniques, learning how to effectively
    handle user input and parse arguments using libraries. Next, you'll learn about
    input/output operations and file handling, covering methods to read from and write
    to files, as well as manipulate file streams for efficient data processing. Finally,
    you'll discover best practices for error handling and logging, including implementing
    structured logging with different severity levels, gracefully managing exceptions,
    and providing informative error messages to users while maintaining detailed logs
    for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B22400_04.xhtml#_idTextAnchor048)*, Command-Line Parsing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B22400_05.xhtml#_idTextAnchor068)*, Input/Output and File Handling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B22400_06.xhtml#_idTextAnchor084)*, Error Handling and Logging*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
