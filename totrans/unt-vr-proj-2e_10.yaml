- en: Using All 360 Degrees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '360-degree photos and videos are a different way of using virtual reality that
    is accessible to consumers today, both in terms of experiencing them as well as
    producing and publishing them. Viewing prerecorded images requires much less compute
    power than rendering full 3D scenes, and this works very well on mobile phone-based
    VR in particular. In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding 360-degree media and formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using textures to view globes, photo spheres, and skyboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding 360-degree video to your Unity projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and using custom shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing 360-degree images and video from within your Unity app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the projects in this chapter are separate and not directly required
    by the other chapters in this book. If you decided to skip any of it or not save
    your work, that's okay.
  prefs: []
  type: TYPE_NORMAL
- en: 360-degree media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The terms 360-degree and *virtual reality* are tossed around a lot lately, often
    in the same sentence. Consumers may be led to believe that it's all the same thing,
    it's all figured out, and it's all very easy to produce, when in fact it is not
    so simple.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the term 360-degree refers to viewing of prerecorded photos or videos
    in a manner that allows you to rotate your view's direction to reveal content
    that was just outside your field of view.
  prefs: []
  type: TYPE_NORMAL
- en: Non-VR 360-degree media has become relatively common. For example, many real-estate
    listing sites provide panoramic previews with a web-based player that lets you
    interactively pan around to view the space. Similarly, Facebook and YouTube support
    uploading and playback of 360-degree videos and provides a player with interactive
    controls to look around during the playback. Google Maps lets you upload 360-degree
    still photosphere images, much like their Street View that you can create with
    an Android or iOS app or a consumer camera (for more information, visit [https://www.google.com/maps/about/contribute/photosphere/](https://www.google.com/maps/about/contribute/photosphere/)).
    The internet is teeming with 360-degree media!
  prefs: []
  type: TYPE_NORMAL
- en: With a VR headset, viewing 360-degree media is surprisingly immersive, even
    just still photos. You're standing at the center of a sphere with an image projected
    onto the inside surface, but you feel like you're really there in the captured
    scene. Simply turn your head to look around. It's one of those things that gets
    people interested in VR the first time they see it, and it is a popular application
    for Google Cardboard and Gear VR, having jump-started the consumer VR revolution
    for a lot of people.
  prefs: []
  type: TYPE_NORMAL
- en: Equirectangular projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since it was discovered that the Earth is round, cartographers and mariners
    have struggled with how to project the spherical globe onto a two-dimensional
    chart. The variations are plentiful and the history is fascinating (if you're
    fascinated by that sort of thing!) The result is an inevitable distortion of some
    areas of the globe.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about map projections and spherical distortions, visit [http://en.wikipedia.org/wiki/Map_projection](http://en.wikipedia.org/wiki/Map_projection).
  prefs: []
  type: TYPE_NORMAL
- en: As a computer graphics designer, it's perhaps a little less mysterious than
    it was to ancient mariners because we know about *UV Texture mapping*.
  prefs: []
  type: TYPE_NORMAL
- en: 3D computer models in Unity are defined by *meshes*-a set of Vector3 points
    connected with edges, forming triangular-shaped facets. You can unwrap a mesh
    (in Blender, for instance) into a flattened 2D configuration to define the mapping
    of texture pixels to the corresponding areas on the mesh surface (UV coordinates).
    A globe of the Earth, when unwrapped, will be distorted, as defined by the unwrapped
    mesh. The resulting image is called a **UV Texture image**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In computer graphic modeling, this UV mapping can be arbitrary and depends
    on the artistic requirements at hand. However, for 360-degree media, this typically
    is done using an *equirectangular* (or a Meridian) projection (for more information,
    visit [http://en.wikipedia.org/wiki/Equirectangular_projection](http://en.wikipedia.org/wiki/Equirectangular_projection)),
    where the sphere is unraveled into a cylindrical projection, stretching the texture
    as you progress towards the north and south poles while keeping the meridians
    as equidistant vertical straight lines. The following *Tissot''s indicatrix* (visit [http://en.wikipedia.org/wiki/Tissot%27s_indicatrix](http://en.wikipedia.org/wiki/Tissot%27s_indicatrix) for
    more information) shows a globe with strategically arranged identical circles
    (illustration by Stefan Kühn):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f695cbde-47c3-4a57-b695-d7a76748677b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image shows the globe unwrapped with an equirectangular projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e26ea8f-b682-4664-bde2-102d79283334.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Illustration by Eric Gaba - Wikimedia Commons user: Sting'
  prefs: []
  type: TYPE_NORMAL
- en: We will use an equirectangular mesh for our photo spheres and an appropriately
    projected (warped) image for its texture map.
  prefs: []
  type: TYPE_NORMAL
- en: VR is hacking your field of view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, but why are 360-degree media in virtual reality so compelling? There's a
    huge difference in how we experience viewing a 360-degree video on a flat screen
    versus inside a VR headset. For example, an IMAX cinema theater with larger screens
    than that of the conventional cinema encompasses more of your peripheral vision
    and has a wider **field of view** (**FOV**). A mobile phone or computer monitor,
    at a natural viewing distance, is about a 26-degree FOV; a movie theatre is 54
    degrees (IMAX is 70 degrees). Oculus Rift and HTC VIVE are about 120 degrees.
    In human vision, one eye is about 160 degrees, both eyes combined provides about
    a 200-degree horizontal field of view.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about FOV adjustments in conventional video games, read
    the excellent article *All about* FOV (July 18, 2014) by visiting [http://steamcommunity.com/sharedfiles/filedetails/?id=287241027](http://steamcommunity.com/sharedfiles/filedetails/?id=287241027).
  prefs: []
  type: TYPE_NORMAL
- en: In VR, you're not so obviously limited by the FOV and physical dimensions of
    the screen because you can easily move your head to change your view direction
    at any time. This provides a fully immersive view, horizontal 360 degrees, as
    you look side to side and up and down by 180 degrees. In VR, with your head still,
    the field of view is only significant with regard to the outer reaches of your
    peripheral vision and eyeball movement. But move your head (at the neck and/or
    full body); the software detects the change in head pose (viewing direction) and
    updates the display. The result is you believe to have an uninterrupted view of
    the 360-degree image.
  prefs: []
  type: TYPE_NORMAL
- en: 180-degree media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I sometimes joke that taking pictures and videos with my consumer 360-degree
    camera is like shooting a landscape and a selfie at the same time! Especially
    if you're holding the camera when taking the pictures, you are always in it. But
    really, when you take a photo, you're most likely already facing the action, and
    so when viewing the photo the user is also facing the action. So maybe all you
    need is 180 degrees. Furthermore, it can be tedious to look all the way behind
    you. As the name implies, a 180-degree image is half a 360 one, projected onto
    a hemisphere.
  prefs: []
  type: TYPE_NORMAL
- en: In 2017, Google introduced a standard for 180-degree media intended for VR ([https://vr.google.com/vr180/](https://vr.google.com/vr180/)).
    In addition to offering equirectangular projection, the cameras have two lenses
    for capturing stereographic, one for each eye. It works pretty well for a 180-degree
    view because while you can move left-right to look around, the actual movement
    needed is relatively small (human peripheral vision is about 200-degree horizontal
    anyway). Stereo 360 is more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Stereo 360-degree media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To capture monoscopic 360-degree media, you can use a consumer 360-degree camera.
    These cameras typically have a couple of back-to-back super wide angle lenses
    and corresponding image sensors. The resulting image captures are stitched together,
    using clever algorithms to avoid seams, and the result is processed into an equirectangular
    projection. Viewing it in VR, each eye sees the same 360 photo. For landscapes,
    such as mountain views or other large areas, where the subject is more than 20
    meters from your viewing position, it is fine because there is no parallax. Each
    eye sees pretty much from the same viewing angle. But if the photo includes objects
    closer to you, it will look incorrect, or at least artificially flattened, because
    you expect parallax where each eye has a slightly different view.
  prefs: []
  type: TYPE_NORMAL
- en: What about true 360-degree stereo? Shouldn't each eye have its own photo sphere
    offset from the other eye's position?
  prefs: []
  type: TYPE_NORMAL
- en: To capture *stereo* 360-degree media, it cannot simply be photographed by two
    360 cameras from two viewpoints but can be constructed by stitching together images
    from a rotating stereo pair. The distance between camera image captures simulates
    a human's separation between eyes (IPD, interpupillary distance).  There is a
    new generation of consumer cameras (such as *Fuze Camera*, [https://vuze.camera/](https://vuze.camera/) with
    eight cameras), and high-end professional camera rigs, such as *Google Jump* ([https://vr.google.com/jump/](https://vr.google.com/jump/)),
    which arranges sixteen separate cameras in a cylindrical array. Advanced image
    processing software then constructs stereographic views.
  prefs: []
  type: TYPE_NORMAL
- en: Google has introduced an advanced file format for stereo 360-degree video: *omni-directional
    stereo*, or ODS. It is a variant of conventional equirectangular projections with
    the advantages of avoiding bad seams or dead zones, it is pre-rendered for faster
    playback, and video uses conventional encoding so you can edit using conventional
    tools.  And Unity supports ODS in their Panoramic Skybox shaders (see the topic
    later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed explanation of the challenges and geometry of stereo 360
    media captures, see the Google whitepaper *Rendering Omni-directional Stereo Content*
    ([https://developers.google.com/vr/jump/rendering-ods-content.pdf](https://developers.google.com/vr/jump/rendering-ods-content.pdf)).
    Also, check out the article *Stereographic 3D Panoramic Images* by Paul Bourke
    (May 2002) by visiting [http://paulbourke.net/stereographics/stereopanoramic/](http://paulbourke.net/stereographics/stereopanoramic/).
  prefs: []
  type: TYPE_NORMAL
- en: Fun with photo globes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin exploring these concepts, let's have a little fun as we apply an ordinary
    (rectangular) image as a texture to a sphere, just to see what it does and how
    bad it looks. Then, we'll use a properly distorted equirectangular photosphere
    texture.
  prefs: []
  type: TYPE_NORMAL
- en: Crystal balls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Auntie Em! Auntie Em!* cried Dorothy in the Wizard of Oz, as she gazed into
    a crystal ball seeking help from the Wicked Witch. Let''s consider making a crystal
    ball using Unity, *my little pretty!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set up a new scene for this chapter by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by navigating to File | New Scene. Then, navigate to File
    | Save Scene As... and name it `360Degrees`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new plane by navigating to GameObject | 3D Object | Plane and reset
    its transformation using the Transform component's *gear* icon | Reset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Main Camera Position to (`0`, `0`, `-1`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can choose to use the MeMyselfEye camera rig we've been using throughout
    the book, but it is not necessary in this project. The Main Camera will implement
    the VR camera based on the SDK you've selected in Player Settings. We will not
    be using device-specific input or other features.
  prefs: []
  type: TYPE_NORMAL
- en: Now, create the first sphere and write a rotator script while we're at it. I'm
    using the `EthanSkull.png` image that was provided with this book (drag and drop
    it into your Project Assets Textures folder).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new sphere by navigating to GameObject | 3D Object | Sphere, reset
    its transformation using the Transform component's *gear* icon | Reset, and name
    it `CrystalBall`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position to (`0`, `1.5`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the texture named `EthanSkull` (you can use any photo that you
    want) onto the sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new script by navigating to Add Component | New Script and name it
    `Rotator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that dropping the texture onto the game object will automatically create
    a corresponding Material named `EthanSkull.mat` in your `Materials/` folder, with
    this texture in the Albedo texture map slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `rotator.cs` script and write it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that we added a `Tooltip` attribute for the Unity Editor that gives the
    developer more detail how to use the `rate` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, set the rotation rate so that it spins around the *y* axis 20 degrees
    per second, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On the Rotator Script component, set Rate for X, Y, Z as (`0`, `20`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene. Try it in VR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d934cac4-dcc4-4e67-a1f5-d19d02aa51fd.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Is that scary or what?* No worries. The projected image may be distorted,
    but it looks wicked cool. For some applications, a little distortion is the artistic
    intent, and you don''t need to worry about it.'
  prefs: []
  type: TYPE_NORMAL
- en: Careful editing such as smudging the edges of the photo can help avoid seams
    in the texture map.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, lets try making the ball look more like crystal glass by
    adjusting the shader properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `CrystalBall` in Inspector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Metallic value to `0.75`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Smoothness value to `0.75`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Albedo color (click the color swatch), and adjust the Alpha (A) value
    to `100`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That looks better. Add more objects with various textures into your scene to
    visualize the transparency and specular highlights.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re interested in more realistic glass simulation for your crystal balls,
    here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider adding a reflection probe to the scene ([https://docs.unity3d.com/Manual/class-ReflectionProbe.html](https://docs.unity3d.com/Manual/class-ReflectionProbe.html))
    so the surface seems to reflect other objects in the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For transparency and refraction, a `GlassRefractive` material is provided in
    the Standard Assets Effects package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try a custom shader in your material. An example of a Simple Glass shader is
    given in the Unity ShaderLab documentation ([https://docs.unity3d.com/Manual/SL-CullAndDepth.html](https://docs.unity3d.com/Manual/SL-CullAndDepth.html)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also consider third-party materials and shaders that simulate glass with refraction,
    distortions, glass surface patterns, and colors (search the Asset Store, [https://assetstore.unity.com/search?q=category%3A121&q=glass](https://assetstore.unity.com/search?q=category%3A121&q=glass)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that transparency should be used sparingly in VR applications as it requires
    additional rendering passes per pixel, potentially slowing your frame generation
    and causing unwanted latency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Globes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll make another sphere and add a texture, like we just did, but this
    time use a texture with an equirectangular (photosphere) distortion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Tissot_euirectangular.png` image, which is included with this book
    (and available on Wikipedia at [https://en.wikipedia.org/wiki/Tissot%27s_indicatrix#/media/File:Tissot_behrmann.png](https://en.wikipedia.org/wiki/Tissot%27s_indicatrix#/media/File:Tissot_behrmann.png)),  into
    your Texture folder and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new sphere and name it `Globe`. Add the `Rotator` script if you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the texture named `Tissot_equirectangular` onto the sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try it in VR. Take a close look at the globe, as shown in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd9f3888-fb32-406f-8169-a9d864dffbab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that unfortunately the Tissot circles are oval, not circular, except along
    the equator. It turns out that the default sphere provided in Unity does not mesh
    well for equirectangular texture maps. Instead, I have provided one designed specifically
    for this purpose, `PhotoSphere.fbx` (which happens to be the default sphere model
    in 3D Studio Max). Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `PhotoSphere.fbx` file by dragging it into your Project Assets Models
    folder (or through the menu: Assets | Import New Asset...).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new equirectangular sphere by dragging the `PhotoSphere` model from Project
    Assets into Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its position and name it `Globe2`. Add the `Rotator` script if you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the texture named `Tissot_equirectangular` onto the sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try it in VR. *Much better.* You can see the texture is correctly mapped now;
    the circles are round (and the underlying mesh grid is more regular):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b928357-0792-4f5e-8f71-7daeacca25dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you can apply any 360 degree photo to the globe, creating your own *photo-globes*
    or virtual Christmas tree ornaments!
  prefs: []
  type: TYPE_NORMAL
- en: Expanding upon this topic further, you could build a nice model of the Solar
    System. Equirectangular texture maps of each of the planets and moons can be downloaded
    free from Solar System Scope ([https://www.solarsystemscope.com/](https://www.solarsystemscope.com/)).
    Data regarding the rate of rotation (day/night) and orbit (around the sun) can
    be found on the NASA site ([https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html](https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html)).
    A complete Unity tutorial project can be found in the book *Augmented Reality
    for Developers* ([https://www.amazon.com/Augmented-Reality-Developers-Jonathan-Linowes/dp/1787286436](https://www.amazon.com/Augmented-Reality-Developers-Jonathan-Linowes/dp/1787286436)).
  prefs: []
  type: TYPE_NORMAL
- en: Another idea is that photo globes have been used as a teleportation mechanism
    in VR games-- as a player, you grab a globe depicting another scene, put it on
    your face and you are teleported into that world. See the topic on *Capturing 360-degree
    media* for how to capture a 360-degree photo of your Unity scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering photospheres
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The inverse of a globe is a photosphere. Where a globe maps an equirectangular
    texture onto the outside surface of a sphere, a photosphere would map the texture
    onto the inside surface, and you view it from the inside so it surrounds you.
  prefs: []
  type: TYPE_NORMAL
- en: For our examples, I'm using the `Farmhouse.png` image which is provided with
    this book, as shown below. Feel free to use your own 360-degree photo, whether
    you have a 360-degree camera such as the Ricoh Theta or other brand, use a photo
    stitching app for Android or iOS, or download one from any number of photo sources
    on the web.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a52dc709-37e7-43c5-b207-0f6e2686fd2a.png)'
  prefs: []
  type: TYPE_IMG
- en: As we've seen, Unity ordinarily renders only the outward-facing surfaces of
    objects. This is determined, mathematically, as the *normal* direction vector
    of each facet of its surface mesh. A Plane is the simplest example. Back in [Chapter
    2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content, Objects, and Scale*,
    we created a big screen image plane with the Grand Canyon on it. When you are
    facing the plane, you see the image. But if you move around behind the plane,
    it is not rendered, as if it were not in the scene at all. Similarly, suppose
    there is a cube or sphere in front of you; you will see it rendered, lit, and
    shaded. But if you put your head inside the object, it seems to disappear, because
    you're now looking at the inside faces of the object's mesh. This is all handled
    by the shader. And since we want to change it, we need to use a different shader.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom Inward shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to write a custom shader to render our texture on the inside of
    the sphere mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders are a critical part of the Unity rendering pipeline, and it's where
    a lot of the magic of computer graphics and virtual reality actually occurs. Unity
    provides an impressive set of built-in shaders, as you've likely noticed just
    by opening the Shader select list on any object's Material in the Inspector. Many
    asset packages you import may also include shaders that implement custom effects,
    including some we've already used in previous chapters, such as TextMeshPro and
    TiltBrush. The VR toolkits from Oculus, Google Daydream, and SteamVR also include
    shaders that provide an extra kick in performance and optimization of the rendering
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Writing shaders is an advanced topic in computer graphics and Unity development.
    Nonetheless, Unity provides tools to facilitate the programming of shaders (see
    [https://docs.unity3d.com/Manual/SL-Reference.html](https://docs.unity3d.com/Manual/SL-Reference.html)),
    including a declarative language called *ShaderLab*, a lot of documentation and
    tutorials, and example shaders to work from. We are not going to go very deep
    here but many find it a very interesting and valuable skill to learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new shader, begin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Create | Shader | Unlit Shader and name it `MyInwardShader`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the new shader file to open it for editing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To turn the shader into an inside shader, all you need to do is add the line
    `Cull Front`, for example, immediately after the `Tags` line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Cull` command tell the shader whether to ignore front or back facing surfaces.
    The default is Back; we're changing it to cull the front ones and render the back
    ones. (For details on this, see [https://docs.unity3d.com/Manual/SL-CullAndDepth.html](https://docs.unity3d.com/Manual/SL-CullAndDepth.html).)
  prefs: []
  type: TYPE_NORMAL
- en: Save the file. Now we can use it in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the top line of the shader file names it `Shader "Unlit/MyInwardShader"`,
    which means you'll find it in the select Shader | Unlit submenu, or you can modify
    it without the submenu to `Shader "MyInwardShader"`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're inverting the texture, it may appear mirrored backwards. We will
    fix that by setting its X Tiling to `-1`, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach is to invert the vertex normals within the shader.
    We used that technique in the first edition of this book, and it is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Briefly, this shader script declares the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Lets you supply  both a texture and a color property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does no culling of surfaces (the texture will be visible both inside and out)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses a simple Lambert diffuse lighting algorithm (versus unlit or the Standard
    Unity physically-based lighting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vert` function inverts the mesh vertices (by multiplying the normal vector
    by `-1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `surf` renderer copies the texture pixel and also lets you tint it with
    an Albedo color (but forces Alpha to be opaque)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use this shader instead of the quick one we wrote previously.
  prefs: []
  type: TYPE_NORMAL
- en: Consider what would happen if you used an Alpha channel in your shader settings
    and set up a cutout mask. It would allow photospheres with some areas completely
    transparent. This opens the possibility of nesting multiple photospheres to create
    visual layers of 360 activity within your scene!
  prefs: []
  type: TYPE_NORMAL
- en: Magic orbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we do full 360-photo viewing, for fun let's first consider a special
    case, *magic orbs*. For this example, we'll look at the sphere from the inside,
    mapping a 360-degree image onto its inside surface. Then, we'll put a solid colored
    *shell* around the outside. So, you really have to stick your head into the sphere
    to see what's there, or grab the sphere and "put it on your eyes!"
  prefs: []
  type: TYPE_NORMAL
- en: 'To build it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material by navigating to Assets | Create | Material and name it
    `FarmhouseInward`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, use the Shader selector and choose Unlit | MyInwardShader, the
    one we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `Farmhouse` texture image and drag it onto the shader component's
    Albedo texture. If needed, set Tiling X to `-1` to compensate for mirroring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new sphere to the scene, dragging the `PhotoSphere.fbx` from your *Models*
    folder introduced before, and name it "MagicOrb."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `FarmhouseInward` material onto the sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll encase it in a solid colored orb by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `MagicOrb` object in Hierarchy, right-click, and navigate to 3D Object
    | Sphere so that the new sphere is a child.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to something a little bigger than the inner sphere, such as (`1.02`,
    `1.02`, `1.02`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable its Sphere Collider component by unchecking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a solid material, such as the one we made in a previous chapter named `RedMaterial`,
    and drag it onto the new sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try it in VR. From the outside, it looks like a solid ball, but lean into it
    and there's a whole new little world in there! The following image is a capture
    of what I see. It's like peering into an egg shell!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e051aec-b008-4d5b-b497-9b7bd2764a29.png)'
  prefs: []
  type: TYPE_IMG
- en: For non-positionally tracked mobile VR devices, you may not be able to do this
    in VR, but you can manually drag the camera rig in the Scene view while playing
    the scene in the Editor. Or, add some locomotion as described in [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), *Locomotion
    and Comfort*. Or, make the orb grab-able, so the player can pick it up and move
    it very close to their face, using techniques described in [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml),
    *Handy Interactables*.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to dive deeper into shaders, as an exercise, try and see how you
    could modify InwardShader to take an additional Color parameter that is used to
    render the outward facing surface, while the texture is used to render the inward
    facing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Photospheres
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Yes sir, it''s all the rage these days. It''s better than panoramas. It''s
    better than selfies. It may be even better than Snapchat! We''re finally getting
    to the moment that you''ve been waiting for! It''s 360-degree photospheres!*'
  prefs: []
  type: TYPE_NORMAL
- en: We covered a lot of topics in this chapter, which will now make it fairly easy
    to talk about 360-degree photospheres. To build one, we'll just make a very big
    sphere with the `MyInwardShader` shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a new empty scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by navigating to File | New Scene. Then, File | Save Scene
    and name it `PhotoSphere`. Delete the default Main Camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `MyMyselfEye` prefab and reset its Transform Position to (`0`, `0`,
    `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an equirectangular sphere by dragging the `PhotoSphere` model from the `Project
    Models` folder into the scene (as imported from `PhotoSphere.fbx` in the previous
    example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its Transform  (*gear* icon | Reset) and set its Scale to (`10`, `10`,
    `10`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a material (Create | Material) and name it to `PhotoSphere Material`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Shader | Unlit | MyInwardShader (as created earlier in this chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Photosphere` Material onto the `Photosphere` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there will be other objects in the Scene, you may need to disable shadows.
    On the Photosphere game object, in its Mesh Renderer component, uncheck the Receive
    Shadows checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to add the photo:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the photo that you want to use; ours is named `FarmHouse.jpg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `PhotoSphere` selected (or the `PhotoSphere Material` itself), drag the
    `FarmHouse` texture onto the Albedo texture tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Tiling X value to `-1` to compensate for the mirror inversion, if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play. You should now see the photosphere surrounding you in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a device with positional tracking, such as the Oculus Rift,
    we need to disable it. Create a new script on  `MemMyselfEye` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You may find that the default texture resolution and/or compression are not
    high enough quality for your taste. To modify the resolution, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the texture (Farmhouse.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, change the Max Size to `4096` or `8192`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Apply to re-import the texture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the file size (at bottom of Inspector) can grow exponentially, affecting
    the final size of your app, load times, and runtime performance. Also try the
    other compression settings, including the new Crunch Compression ([https://blogs.unity3d.com/2017/11/15/updated-crunch-texture-compression-library/](https://blogs.unity3d.com/2017/11/15/updated-crunch-texture-compression-library/)).
    You can configure these settings on a per-platform basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To switch images, repeat the last two steps: import the asset and assign it
    to the Albedo texture of the `Photosphere Mataterial`. If you want to do this
    in-game, you can do this in a script (for example, by using `Material.mainTexture()`).'
  prefs: []
  type: TYPE_NORMAL
- en: Playing 360-degree videos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The steps for adding a 360-degree video are pretty much the same as adding a
    regular rectangular one to your project (see [https://docs.unity3d.com/Manual/class-MovieTexture.html](https://docs.unity3d.com/Manual/class-MovieTexture.html)). To
    play a 360-degree video, you use a  `Video Player` to render the video on a `Render
    Texture`.  If you do not have a 360-degree video handy, search the web free downloads
    and pick one that's not too long and a limited file size.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the format of your video, you may need to install QuickTime on
    your system first before you can import it into Unity, for the conversion codec.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like, start a new scene and reset the MyMyselfEye Transform to
    the origin. Then, import a 360 video into your Project Assets. Note its dimensions
    (for example, a 4K video is 4096 x 2048). You can see it in Inspector, if you're
    not sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a video player to your project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty named `"VideoPlayer"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Component | Video Player
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your video file onto its Video Clip slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Play On Awake checkbox and the Loop checkbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure Render Mode is set to Render Texture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will create a `Render Texture`, a special Unity texture that will be
    rendered at runtime by the video player:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Project Assets, Create | Render Texture, name it `"Video Render Texture"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Size to exactly the size of your video, (such as 4096 x 2048).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting Anti aliasing to 2 samples is recommended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can set Depth Buffer to No Depth Buffer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select VideoPlayer in Hierarchy and drag VideoRenderTexture onto its Target
    Texture slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create your photosphere:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D Sphere and name it "VideoSphere"
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its Transform, so its Position is (`0`, `0`, `0`), then set its Scale
    to  (`10`, `10`, `10`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag Video Render Texture onto the sphere and make a new Material (or you could
    have separately created this material first)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Material Shader to MyInwardShader
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A resulting VideoPlayer in Inspector is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f207c7e-e32f-44d4-8c85-1e12178cb4f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Press Play. You now have a basic 360 video player built with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: To review, the sphere uses a material with an inward shader. The shader renders
    an equirectangular texture on the inside of the sphere. The video player modifies
    that texture each update with the next video frame.
  prefs: []
  type: TYPE_NORMAL
- en: When building for Android and iOS, you must put your video file (such as MP4)
    into a folder named *StreamingAssets* in your Project Assets. For more information
    on this and other considerations for Video Player and codecs, see the Unity documentation
    at [https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html](https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the video has audio, we can make the video an Audio Source as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the VideoPlayer and Add Component | Audio Source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag `VideoPlayer` itself onto its Video Player component's Audio Source slot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with all Unity components, the video player has an API and can be controlled
    via scripting. For example, to simply pause the video with a button click, you
    could add this script to the `VideoPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For additional tips, also check out the tutorial from Unity *Getting started
    in interactive 360 video: Download our sample project* at  [https://blogs.unity3d.com/2018/01/19/getting-started-in-interactive-360-video-download-our-sample-project/](https://blogs.unity3d.com/2018/01/19/getting-started-in-interactive-360-video-download-our-sample-project/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Unity skyboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the olden days, or at least before 360 photos, we simply referred to
    *skyboxes* as the way to create background imagery in computer graphics. Skyboxes
    depict what's far on the horizon, may contribute to the ambient lighting of the
    scene, be used for rendering reflections on object surfaces, and are not interactable.
    Unity supports skyboxes as part of the Lighting Environment for each scene. We
    used skyboxes already in a few of the previous chapters' projects (including Wispy
    Sky and Skull Platform ones).
  prefs: []
  type: TYPE_NORMAL
- en: Common sources of skyboxes are cylindrical panorama, spherical panorama (360
    images), and a six-sided cube. We won't consider the cylindrical one, since it's
    less useful for VR.
  prefs: []
  type: TYPE_NORMAL
- en: Six-sided or cubemap skyboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A skybox can be represented by a six sides of a cube, where each side is akin
    to a camera capturing its view pointing in each of the six directions, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78ce7543-9205-4ef8-9d59-52b9e69e89d8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Given these six images, as textures, you''d create a *six-sided* skybox material
    like the one shown next for the WispySky cubemap. And then, set it in the Lighting
    window as the Skybox Material for the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17612320-89bb-42d0-a15b-c2d3827a621a.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, you could combine the six images into a single *cubemap* image,
    laid out similarly.
  prefs: []
  type: TYPE_NORMAL
- en: Cubemaps have an advantage because equirectangular textures waste pixels where
    the image is stretched at the top and bottom poles of the spherical projection.
    On the other hand, care must be taken to properly design images so they'll smoothly
    stitch together and not cause seams or other visual artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: A variant over traditional cubemaps is the **Equi-Angular Cubemap** (**EAC**).
    EAC strives to have even more uniform pixel sizes and "equal angle pixel distribution
    in 3D."  (See [https://blog.google/products/google-vr/bringing-pixels-front-and-center-vr-video/](https://blog.google/products/google-vr/bringing-pixels-front-and-center-vr-video/).)
  prefs: []
  type: TYPE_NORMAL
- en: But most 360 media today, especially coming from consumer cameras, use equirectangular
    projections, aka spherical panoramas.
  prefs: []
  type: TYPE_NORMAL
- en: Spherical panoramic skyboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a 360 photo for a skybox is referred to a *spherical panoramic*. Earlier
    in this chapter we used a spherical game object to render an equirectangular texture
    and placed the player camera dead-center inside it. Now, we'll now use the same
    image in a skybox. (Note, this will also work for 180-degree content.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a new empty scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by navigating to File | New Scene. Then, File | Save Scene and
    name it `Skybox`. Replace the `Main Camera` with the `MyMyselfEye` prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming you're using the `Farmhouse.jpg` image as earlier, create a new `Material`
    and name it `Farmhouse Skybox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the material's Shader, choose Skybox | Panoramic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your 360 image (`Farmhouse.jpg`) onto the Spherical texture area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Mapping to Latitude Longitude Layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Image Type to 360 Degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Material settings are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3e9a35d-d730-4581-bd73-702ab099fab3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now to use it in your scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Lighting window tab (if not in your Editor, navigate to Window | Lighting)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your `Farmhouse Skybox` material onto the Skybox Material slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Lighting Environment settings are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d6bd60f-d428-4a70-a8f8-8ffe841991e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Press Play. *Voila! *You should now see the photosphere surrounding you in the
    scene. That was almost too easy. Thank goodness!
  prefs: []
  type: TYPE_NORMAL
- en: One thing that's interesting is, since skyboxes are always rendered as if at
    a very far distance away, the camera will always be at the center of the photosphere.
    Thus, we don't need to set the camera rig at the origin, and we don't need to
    disable positional tracking, as we did for the spherical game object version of
    this project. Wherever you move, the skybox will surround you just the same. If
    your 360 image contains content (people or objects) that are relatively near,
    this may feel very unnatural, as if the objects are projected or flattened against
    the spherical projection (which they are!). This is why skyboxes are generally
    used for landscapes and wide open spaces. (Later, we'll see how this can be solved
    using *stereo* skyboxes.)
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can add more content to your scene. After all, we're in Unity
    and not just making an generic 360 photo viewer. Enhance your lovely outdoor scene
    by adding falling snow or leaves (for example, see the *Falling Leaves* particle
    package, [https://assetstore.unity.com/packages/3d/falling-leaves-54725](https://assetstore.unity.com/packages/3d/falling-leaves-54725)).
  prefs: []
  type: TYPE_NORMAL
- en: A common application is to use a 360 image in a lobby scene, and add an interactive
    menu panel for launching other apps or scenes. The Google Daydream lobby comes
    to mind.
  prefs: []
  type: TYPE_NORMAL
- en: Another application is to make the 360 image more interactive by add UI canvases
    to label content in the photo. It may take some thoughtful work to align the labels
    with the photosphere. Then, using a camera raycast, you can dynamically highlight
    what the player is looking at (see [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control* for coding tips).
  prefs: []
  type: TYPE_NORMAL
- en: 360 video skyboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Turning your skybox into a 360 degree video player is nearly identical to the
    steps outlined previously for the spherical game object version. We won''t repeat
    everything again, but briefly it goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a `Video Player` to play back the video source to a `Render Texture`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a `Skybox Material` that will receive the `Render Texture`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the scene to use the `Skybox Material`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note, according to Unity, equirectangular videos should have an aspect ratio
    of exactly 2:1 (or for 180-degree content, 1:1) for the skybox shader. Also, many
    desktop hardware video decoders are limited to 4K resolutions and mobile hardware
    video decoders are often limited to 2K or less, limiting the resolution that can
    be played back in real time on those platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 3D stereo skyboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a 360 image or video with stereo views, for each of the left and
    right eyes, Unity can now use that too. As of Unity 2017.3, the Panoramic Skybox
    material supports 3D textures in with a 3D layout. You can specify Side by side
    or Over under, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4bb26a6-bff9-459c-a55a-3be8628c4a59.png)'
  prefs: []
  type: TYPE_IMG
- en: An example 3D stereographic equirectangular over-under image is given in the
    next topic, where we discuss capturing 360 media within your Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing 360-degrees in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've talked about using 360-degree media captured using 360 cameras. But what
    if you wanted to capture a 360 image or video from within your Unity app and share
    it on the internet? This could be useful for marketing and promoting your VR apps,
    or just simply using Unity as a content generation tool but using 360 video as
    the final distribution medium.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing cubemaps and reflection probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity includes support for capturing scene views as part of its lighting engine. A
    call to `camera.RenderToCubemap()` will bake a static cubemap of your scene, using
    the camera's current position and other settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example script given in the Unity documentation,  [https://docs.unity3d.com/Documentation/ScriptReference/Camera.RenderToCubemap.html](https://docs.unity3d.com/Documentation/ScriptReference/Camera.RenderToCubemap.html),
    implements an editor wizard for capturing a cubemap of your scene directly in
    the Editor, and is included here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty game object for the camera position to capture from
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cubemap to render into (Assets | Create | Legacy | Cubemap)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Face size to a high resolution, such as `2048`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Readable checkbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the wizard (GameObject | Render into Cubemap)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the position object into the Render From Position slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag cubemap into the Cubemap slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Render!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `.cubemap` file can now be used in a Skybox Cubemap material.
  prefs: []
  type: TYPE_NORMAL
- en: A similar but different approach is to use Reflection probes. They're normally used
    by objects with reflective materials to render realistic surface reflections (see
    [https://docs.unity3d.com/Manual/class-ReflectionProbe.html](https://docs.unity3d.com/Manual/class-ReflectionProbe.html)). A
    reflection probe captures a spherical view of its surroundings and is then stored
    as a cubemap. Scene designers will strategically place multiple reflection probes
    in a scene to provide more realistic rendering. You can repurpose a reflection
    probe as a 360 image capture of your scene! Since they're intended for reflection
    lighting, they're usually low resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Unity chooses where to store the reflection probe lightmap file (`.exr`) depending
    on your lighting settings. To save it under your *Assets* folder (rather than
    the GI cache), go to the Lighting tab, disable Realtime Global Illumination, and
    disable Auto Generate. This will generate the refection probe `.exr` file in a
    folder with the same name as your scene.
  prefs: []
  type: TYPE_NORMAL
- en: Try adding one to your scene by navigating to GameObject | Light | Reflection
    Probe. Set Resolution to a high value, like `2048`. Then, press Bake.  You can
    then assign this `.exr` file to a Skybox Cubemap material, making a quick and
    easy 360 scene-shot.
  prefs: []
  type: TYPE_NORMAL
- en: Using a third-party package for 360 image capture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of packages that provide the ability to capture 360 images
    and video in Unity, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 360 Panorama Capture from eVRydayVR (free) ([https://assetstore.unity.com/packages/tools/camera/360-panorama-capture-38755](https://assetstore.unity.com/packages/tools/camera/360-panorama-capture-38755))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VR Panorama 360 PRO from OliVR ($49) ([https://assetstore.unity.com/packages/tools/video/vr-panorama-360-pro-renderer-35102](https://assetstore.unity.com/packages/tools/video/vr-panorama-360-pro-renderer-35102))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oculus 360-Capture-SDK (free), includes a sample Unity project ([https://github.com/facebook/360-Capture-SDK](https://github.com/facebook/360-Capture-SDK))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these packages support mono and stereoscopic capture, sequenced captures
    for video encoding, and possibly other features for color conversion, antialiasing,
    camera image effects, and 3D spatialized audio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the  360 Panorama Capture script from eVRydayVR, for example, to capture
    a single 360 image, open a scene you want to capture, then:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty game object, named `CapturePanorama`, positioned where you want
    to make the capture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Capture Panorama script as a component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play, then press *P* on the keyboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The screen will fade to black, and an image will be captured and saved to your
    project root directory. The component options are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5594290d-e4aa-4bc6-979b-39cb13e54e2e.png)'
  prefs: []
  type: TYPE_IMG
- en: To capture video, you would enable the Capture Every Frame checkbox. It recommends
    the open source *ffmpeg* tool ([https://www.ffmpeg.org/](https://www.ffmpeg.org/))
    to assemble the frames and encode the video. See the README file for details.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this component can also be controlled via scripts, and can be built
    into your runtime game, not just used in the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Unity built-in stereo 360 image and video capture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Unity 2018.1, Unity includes an integrated stereo 360 image and video
    capture capability. The feature is based on Google's omni-directional stereo (ODS),
    described at the beginning of this chapter. Details in this section summarize
    the Unity Blogs post from January, 2018 ([https://blogs.unity3d.com/2018/01/26/stereo-360-image-and-video-capture/](https://blogs.unity3d.com/2018/01/26/stereo-360-image-and-video-capture/)),
    which explains how to capture ODS stereo cubemaps and convert them to stereo equirectangular
    textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture a scene in Editor or standalone player, call `camera.RenderToCubemap()`
    once per eye. We used this function earlier; there is a variant that takes a `stereoEye`
    parameter, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert cubemaps to stereo equirectangular maps, call `RenderTexture.ConvertToEquirect()` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the Unity frame recorder ([https://github.com/Unity-Technologies/GenericFrameRecorder](https://github.com/Unity-Technologies/GenericFrameRecorder)),
    a sequence of these images can be captured as frames of a stereo 360 video.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture in the PC standalone build, you need to enable the 360 Stereo Capture
    in the Build Settings, as shown here, so Unity generates the shader variants required
    by this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4556c754-2c22-4e95-83db-9c99e7aa2557.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an example of a resulting stereo equirectangular video capture (from
    the Unity blog, [https://blogs.unity3d.com/wp-content/uploads/2018/01/image5-2.gif](https://blogs.unity3d.com/wp-content/uploads/2018/01/image5-2.gif)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e293df6-c23e-4662-9b62-1b95e06258fb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 360-degree media is compelling because VR hacks your field of view (FOV). The
    view you see is updated in real time as you move your head around, making it seem
    to have no edges. We started this chapter by describing what 360-degree images
    are, and how the surface of a sphere would be flattened (projected) into a 2D
    image, and equirectangular projections in particular. Stereo 3D media includes
    separate equirectangular views for the left and right eyes.
  prefs: []
  type: TYPE_NORMAL
- en: We began exploring this in Unity by simply mapping a regular image on the outside
    of a sphere, and were perhaps frightened by the distortions. Then, we saw how
    an equirectangular texture covers the sphere evenly. Next, we inverted the sphere
    with a custom shader, mapping the image inside the sphere, making it a 360 photosphere
    viewer. And, we added video.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at using skyboxes instead of a game object for rendering 360
    media. We saw how Unity supports cubemaps and spherical panoramas, video skyboxes,
    and 3D stereo skyboxes too.  Lastly, we explored capturing 360 media from within
    your Unity scenes using third-party packages and Unity's built-in API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we consider an important application of virtual reality,
    for storytelling. Using the animation and cinematic editing feature of Unity,
    we build a short VR cinematic experience.
  prefs: []
  type: TYPE_NORMAL
