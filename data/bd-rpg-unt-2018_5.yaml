- en: GameMaster and Game Mechanics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏大师和游戏机制
- en: In chapters 1 through 4, we learned how to make some of the necessary components
    needed for the design and implementation of our RPG. For instance, you should
    have a good understanding of how to organize and arrange your player character
    and non-player character assets and components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 章到第 4 章中，我们学习了如何制作我们 RPG 设计和实现所需的一些必要组件。例如，你应该对如何组织和安排你的玩家角色和非玩家角色资产和组件有一个很好的理解。
- en: 'Here is a breakdown of the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章内容的概述：
- en: GameMaster
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏大师
- en: Managing game settings and scenes
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理游戏设置和场景
- en: Managing scenes
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景管理
- en: Improving GameMaster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完善 GameMaster
- en: Level controller
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别控制器
- en: Audio controller
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频控制器
- en: Player data management
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家数据管理
- en: PC class enhancements
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PC 类增强
- en: Character customization class update
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色定制类更新
- en: Changes to the UI controller
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 控制器的更改
- en: Testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: In this chapter, we are going to make more adjustments and updates to everything
    we have done so far.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对迄今为止所做的一切进行更多调整和更新。
- en: GameMaster
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏大师
- en: Even though we have created a `GameMaster.cs` script, we have not really utilized
    it to manage our game. We have created bits and pieces of our game assets and
    used them to do quick testing. Now is the time to start looking at how to combine
    everything together and create a better game manager for our RPG.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经创建了 `GameMaster.cs` 脚本，但我们并没有真正利用它来管理我们的游戏。我们创建了一些游戏资产的部分，并使用它们进行快速测试。现在是时候开始考虑如何将所有这些结合起来，为我们的
    RPG 创建一个更好的游戏管理器。
- en: 'There are a few things that I want `GameMaster.cs` to perform. These are as
    follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望 `GameMaster.cs` 执行以下几件事情。具体如下：
- en: Having a reference to the UI controller for each particular scene
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个特定场景的 UI 控制器引用
- en: Having a reference to the player character in the scene
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中拥有玩家角色的引用
- en: Having a reference to the non-player character(s) in the scene
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中拥有非玩家角色（NPC）的引用
- en: Having a reference to the audio source for control
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有音频源的引用以进行控制
- en: There should always be one instance of the `GameMaster` class available
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应始终有一个 `GameMaster` 类的实例可用
- en: As we create our GameMaster, we will add or subtract some of the elements as
    we see fit. Let's start by integrating the User Interface with the GameMaster.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的 GameMaster 时，我们将根据需要添加或删除一些元素。让我们从将用户界面与 GameMaster 集成开始。
- en: 'Open up your Main Menu scene. It should look something like the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开主菜单场景。它应该看起来像以下截图：
- en: '![](img/00107.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'The following screenshots display the main menu we have designed for our RPG:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了为我们设计的 RPG 主菜单：
- en: '![](img/00108.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: It is pretty simple, just to illustrate the concept. When the player clicks
    the Options button, they will get the Options window, where they will have the
    ability to adjust the volume within the game. When they are done, they will click
    the close button and go back to the main menu.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，只是为了说明概念。当玩家点击选项按钮时，他们将获得选项窗口，在那里他们可以调整游戏中的音量。完成操作后，他们将点击关闭按钮并返回主菜单。
- en: 'Here is a screenshot of the Hierarchy window for the Main Menu scene:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主菜单场景的层次结构窗口截图：
- en: '![](img/00109.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: Managing game settings and audio
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理游戏设置和音频
- en: Create an `Empty` GameObject and name it `uiController`. We now need to create
    a UI Controller script that will handle the user interaction. Create a new C#
    script and name it `UiController.cs`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `uiController` 的空 GameObject。我们现在需要创建一个 UI 控制器脚本，该脚本将处理用户交互。创建一个新的 C#
    脚本并命名为 `UiController.cs`。
- en: 'Note: The scripts in this chapter will be updated and modified as we progress.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：随着我们的进展，本章中的脚本将进行更新和修改。
- en: 'A listing of the UI controller is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: UI 控制器的列表如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Currently, we have just a few functions defined: `DisplaySettings()` and `MainVolume()`.
    The functions are really simple; they are referencing the UI components needed
    to display the settings panel, as well as to retrieve the value of the volume
    control slider. The information is then passed to the `GameMaster.cs` script for
    further processing.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只定义了几个函数：`DisplaySettings()` 和 `MainVolume()`。这些函数非常简单；它们引用了用于显示设置面板以及检索音量控制滑块值的
    UI 组件。然后，这些信息被传递到 `GameMaster.cs` 脚本以进行进一步处理。
- en: 'We need to make several changes to the `GameMaster.cs` script. A listing of
    the code is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对 `GameMaster.cs` 脚本进行一些更改。以下是代码列表：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code needs a little bit of explanation. The first and most important concept
    to take away is the concept of a Singleton. This is done by first defining a static
    variable, which will be used to hold our `GameMaster` instance:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码需要一点解释。首先要理解的最重要概念是 Singleton 的概念。这是通过首先定义一个静态变量来完成的，该变量将用于保存我们的 `GameMaster`
    实例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, in our `Awake()` function, we need the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 `Awake()` 函数中，我们需要以下代码：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `Awake()` function, we are checking to see if the `instance` variable
    has been initialized. It sets the `instance` variable once. The next check ensures
    that we always have one instance. In other words, if the `GameMaster` object gets
    instantiated a second time by mistake, it will destroy it. The last line of code, `DotDestroyOnLoad()`,
    will ensure that the GameObject does not get destroyed when we move from one scene
    to the next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Awake()` 函数中，我们正在检查 `instance` 变量是否已初始化。它将 `instance` 变量初始化一次。接下来的检查确保我们始终只有一个实例。换句话说，如果由于错误而再次实例化
    `GameMaster` 对象，它将被销毁。代码的最后一条，`DotDestroyOnLoad()`，将确保当从当前场景移动到下一个场景时，GameObject
    不会被销毁。
- en: In the `Start()` function, we are checking to see if `uiController` is present,
    and if it is, we get a reference to it. Once we have a reference to `uiController`,
    we make sure that the Settings panel is disabled by default, that is, hidden.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Start()` 函数中，我们检查 `uiController` 是否存在，如果存在，我们就获取它的引用。一旦我们有了 `uiController`
    的引用，我们确保设置面板默认是禁用的，也就是说，是隐藏的。
- en: The `MasterVolume()` function gets called from the `UIController.cs` script,
    which then passes the actual value from the slider defined to control the volume
    of the background music.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`MasterVolume()` 函数由 `UIController.cs` 脚本调用，然后传递从定义的滑块中获取的实际音量值来控制背景音乐的音量。'
- en: Managing scenes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理场景
- en: 'The next item I want to make is to have the `GameMaster` control loading the
    different scenes for the game. Let''s look at how `GameMaster.cs` will look with
    the new addition of scene management:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我想实现的是让 `GameMaster` 控制游戏的不同场景加载。让我们看看 `GameMaster.cs` 将如何看起来，随着场景管理的添加：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have already discussed what the `Awake()` function is doing, so let''s take
    a look at the next important function, `OnLevelWasLoaded()`. Take a look at the
    following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 `Awake()` 函数的作用，现在让我们看看下一个重要的函数，`OnLevelWasLoaded()`。看看以下代码：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `OnLevelWasLoaded()` function is called by Unity after the scene was loaded.
    We are using this function in the `GameMaster` script to perform a few tasks.
    The first thing we do is get the current scene we are in. This information will
    be used later to determine what `GameMaster` will do.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnLevelWasLoaded()` 函数是在场景加载后由 Unity 调用的。我们在 `GameMaster` 脚本中使用此函数执行一些任务。我们首先做的事情是获取我们当前所在的场景。这些信息将用于稍后确定
    `GameMaster` 将执行什么操作。'
- en: We check to see if we are in the character customization scene. This is where
    the player can customize the PC before they start playing the game. If we are
    in the character customization scene, we want to get a reference to the `Base`
    GameObject in the scene. If you recall, the `Base` GameObject has the `CharacterCutomization.cs`
    script attached to it, which is used to, well, customize the character.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查是否处于角色定制场景。这是玩家在开始游戏之前可以定制 PC 的地方。如果我们处于角色定制场景，我们想要获取场景中 `Base` GameObject
    的引用。如果你还记得，`Base` GameObject 上附加了 `CharacterCutomization.cs` 脚本，该脚本用于定制角色。
- en: If we are in any other scene, then we want to get a reference to the player
    character, as well as the starting position of the player character at the beginning
    of the scene, if there is one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于任何其他场景，那么我们想要获取玩家角色的引用，以及场景开始时玩家角色的起始位置（如果有的话）。
- en: We then use the `DetermineLevel()` function to determine the level we are currently
    on, to make some more configurations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `DetermineLevel()` 函数来确定我们当前所在的级别，以便进行更多配置。
- en: The two functions currently implemented for starting the game and loading the
    levels are handled by the `StartGame()` function and the `LoadLevel()` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现用于启动游戏和加载级别的两个函数由 `StartGame()` 函数和 `LoadLevel()` 函数处理。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `SceneName` class is designed to make it easier to refer to the scene names
    in the C# code. This makes it easier to chance the actual scene name within the
    project, but have a consistent call name in the code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`SceneName` 类旨在使在 C# 代码中引用场景名称变得更加容易。这使得在项目中更改实际场景名称变得更容易，但代码中的调用名称保持一致。'
- en: This is all good so far, but we can try to make it better.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利，但我们可以尝试让它变得更好。
- en: Improving GameMaster
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进GameMaster
- en: The code we have so far works, but it is not very clean. Let's go ahead and
    structure the code a little better. Let's create a new script, called `GameLevelController.cs`.
    This new script will be handling the logic for our level management.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前拥有的代码是可行的，但它并不十分整洁。让我们继续改进代码结构。让我们创建一个新的脚本，命名为`GameLevelController.cs`。这个新的脚本将处理我们的等级管理逻辑。
- en: Level controller
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等级控制器
- en: 'A listing of `GameLevelController.cs` is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameLevelController.cs`的代码列表如下：'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What I have done is basically move all of the code that deals with level management
    into `GameLevelController.cs`. Our `GameMaster` script drives the LevelController
    class. We will see this a bit later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的是基本上将所有处理等级管理的代码移动到了`GameLevelController.cs`文件中。我们的`GameMaster`脚本来驱动LevelController类。我们稍后会看到这一点。
- en: Audio controller
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频控制器
- en: 'The next code clean-up I want to do is for the audio. Let''s create a new script,
    called `GameAudioController.cs`. The code for the new script is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码清理工作是我想要对音频进行的。让我们创建一个新的脚本，命名为`GameAudioController.cs`。新脚本的代码如下：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code is pretty straightforward. Now, let''s take a look at how `GameMaster.cs`
    looks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当直接。现在，让我们看看`GameMaster.cs`的样子：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the code is easier to read, and it is also structured better.
    GameMaster is using the controllers to perform each specific task. This also makes
    it easier to maintain code for different tasks within our game. For instance,
    all of the audio-related code can be now implemented in the controller, and so
    on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码更容易阅读，并且结构也更好。GameMaster正在使用控制器来执行每个具体任务。这也使得维护我们游戏中不同任务中的代码更容易。例如，所有与音频相关的代码现在可以实现在控制器中，等等。
- en: 'For all this to work, you have to make sure that you have properly hooked up
    your `uiController` GameObject to communicate with the `UiController.cs` class
    when the user interacts with the Options/Settings menu, as shown in the following
    screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有这些工作，你必须确保你已经正确地将你的`uiController`GameObject连接到`UiController.cs`类，以便当用户与选项/设置菜单交互时进行通信，如下面的截图所示：
- en: '![](img/00110.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00110.jpeg)'
- en: UI element events
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: UI元素事件
- en: 'Your project should also have the following Tags defined by now:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目现在应该已经定义了以下标签：
- en: '![](img/00111.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00111.jpeg)'
- en: These are used within the C# code to identify GameObjects at runtime.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在C#代码中用于在运行时识别GameObject。
- en: Player data management
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家数据管理
- en: We have not saved the actual data representing the customization of our player.
    The next step is to enhance our `PlayerCharacter.cs` and `BarbarianCharacterCustomization.cs`
    scripts to actually save the selected data in our PC object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有保存代表玩家定制的数据的实际数据。下一步是增强我们的`PlayerCharacter.cs`和`BarbarianCharacterCustomization.cs`脚本，以便实际上在我们的PC对象中保存所选数据。
- en: PC class enhancements
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PC类增强
- en: 'To do this, we need to modify our `PlayerCharacter.cs` code. The new listing
    is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要修改我们的`PlayerCharacter.cs`代码。新的代码列表如下：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have defined several enumeration types that describe the different parts
    of the player character's customization. There are several advantages to using
    enumeration in our code, a few of them being named constants, the name describes
    what they are for, type safety, and it is easier to change the value of the enumeration
    without having to check a hundred different places within your code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了几个枚举类型，用于描述玩家角色定制的不同部分。使用枚举在我们的代码中有几个优点，其中一些是命名常量，名称描述了它们的作用，类型安全，并且更容易更改枚举的值，而无需检查代码中的数百个不同位置。
- en: As stated in previous chapters, the character customization code is heavily
    related to your character model and how you have rigged up your character model
    to be used in the game.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，角色定制代码与你的角色模型以及你如何为游戏使用角色模型绑定紧密相关。
- en: You will need to modify the name of your UI elements to match the new code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改你的UI元素的名称，以匹配新的代码。
- en: 'Take a look at the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/00112.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00112.jpeg)'
- en: Hooking up UI element events
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 连接UI元素事件
- en: There are a few things you will need to configure to make sure the code works
    properly. First, you will need to name your UI elements properly to match the
    enumeration. The preceding screenshot illustrates one of the UI elements representing
    a shoulder pad.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保代码能够正常工作，你需要配置一些事情。首先，你需要正确命名你的UI元素，以匹配枚举。前面的截图展示了代表肩垫的一个UI元素。
- en: Character customization class update
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色定制类更新
- en: 'The events that drive character customization are attached to the `Base` prefab,
    which has the `CharacterCustomization.cs` script as a component. The `CharacterCustomization.cs`
    script is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动角色定制的活动附加到具有 `CharacterCustomization.cs` 脚本组件的 `Base` 预制件上。`CharacterCustomization.cs`
    脚本如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the code listed, what we have done is add a new variable of type `PlayerCharacter`
    named `PlayerCharacterData`. The `PlayerCharacter` class is the player character
    class we have defined and enhanced to contain the data for our player character
    as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出的代码中，我们所做的是添加了一个名为 `PlayerCharacterData` 的新变量，其类型为 `PlayerCharacter`。`PlayerCharacter`
    类是我们定义并增强的玩家角色类，用于包含我们的玩家角色的数据，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next logic we need to implement is to detect which option the player has
    selected through the character customization UI, and appropriately set the data
    in the `PlayerCharacter` object. See the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要实现的是检测玩家通过角色定制 UI 选择的哪个选项，并适当地设置 `PlayerCharacter` 对象中的数据。请看以下代码：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The implementation concept is the same for all the different parts of the player
    character that can be customized. One of them is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有可以定制的玩家角色不同部分，实现概念是相同的。以下是一个例子：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code is for the customization of the body type of the player character.
    The first thing it tries to do is to parse and convert the value passed to the
    function by the UI component. Next it sets the `selectedClothing` variable in
    the `PlayerCharacter` object. If, for some reason, the value passed does not exist
    in the enumeration, we will assign the default value to the `selectedClothing`
    variable. There are also debug statements to give you feedback about the current
    value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是用于定制玩家角色身体类型的。它首先尝试解析并转换由 UI 组件传递给函数的值。接下来，它设置 `PlayerCharacter` 对象中的 `selectedClothing`
    变量。如果由于某种原因，传递的值在枚举中不存在，我们将为 `selectedClothing` 变量分配默认值。同时也有调试语句来提供关于当前值的反馈。
- en: Changes to the game level controller
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏关卡控制器的更改
- en: 'The game level controller will also need to be updated now, to make the necessary
    changes to the `GameMaster` object. We will need to update the `LoadLevel()` function
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏关卡控制器现在也需要更新，以便对 `GameMaster` 对象进行必要的更改。我们需要更新 `LoadLevel()` 函数，如下所示：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will make sure that GameMaster is updated with the proper player character
    data. Let's go ahead and test the code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保 `GameMaster` 被更新为正确的玩家角色数据。让我们继续测试代码。
- en: Testing
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Starting from the `Main Menu` scene, make sure that you have the following
    GameObjects in the scene: `uiController` and `_GameMaster`. The `uiController`
    GameObject should have `UiController.cs` attached, and `_GameMaster` should have
    the following components attached: `GameMaster.cs` and an `AudioSource` component
    that will be used for the background music.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Main Menu` 场景开始，确保场景中有以下 GameObjects：`uiController` 和 `_GameMaster`。`uiController`
    GameObject 应该附加 `UiController.cs`，而 `_GameMaster` 应该附加以下组件：`GameMaster.cs` 和一个用于背景音乐的
    `AudioSource` 组件。
- en: 'Have the `_GameMaster` GameObject selected in the Hierarchy window, and run
    the game. Select the Start Game button. This will load the character customization
    scene. The `_GameMaster` GameObject should still be selected. If not, go ahead
    and select it from the Hierarchy window, do some of the character customization,
    and click the Save button. Refer to the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构窗口中选择 `_GameMaster` GameObject，并运行游戏。选择开始游戏按钮。这将加载角色定制场景。`_GameMaster`
    GameObject 应仍然被选中。如果不是，请从层次结构窗口中选择它，进行一些角色定制，然后点击保存按钮。请参考以下截图：
- en: '![](img/00113.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00113.jpeg)'
- en: The first level should have been loaded with your character and the customization
    you have made to your character in the previous step. So visually, your character
    has retained all of the customization you have done, and from a data point of
    view, when you look at the `_GameMaster` GameObject in the Inspector window, you
    will notice that the data has been saved properly, as shown in the preceding screenshot.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一级应该已经加载了你在上一步中为角色所做的定制和你的角色。因此，从视觉上看，你的角色保留了你所做的所有定制，从数据角度来看，当你查看检查器窗口中的 `_GameMaster`
    GameObject 时，你会注意到数据已经正确保存，如前一张截图所示。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was mostly code. We enhanced the `GameMaster` class to handle the
    game settings and scene management. We began the chapter by making `GameMaster`
    handle the user interface, the player character data, and the game settings, which
    currently is just the volume for the background music.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要是代码。我们增强了`GameMaster`类以处理游戏设置和场景管理。我们开始本章时让`GameMaster`处理用户界面、玩家角色数据和游戏设置，目前只是背景音乐的音量。
- en: We added a new UI element that displays the settings panel for the game. At
    the moment, it only contains the main volume control. Next, we added the necessary
    code in the `UiController` class and the `GameMaster` class to handle the display
    of the settings window, as well as the slider value passed from the UI component
    to `UiController` to the `GameMaster` class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的UI元素，用于显示游戏的设置面板。目前，它只包含主音量控制。接下来，我们在`UiController`类和`GameMaster`类中添加了必要的代码，以处理设置窗口的显示，以及从UI组件传递到`UiController`再到`GameMaster`类的滑块值。
- en: We also made the `GameMaster` class into a singleton. A singleton in software
    engineering is a design pattern that restricts the instantiation of a class to
    one object. This pattern fits perfectly for `GameMaster`, as we only need to have
    one instance of it active at any given time throughout the lifespan of the game.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`GameMaster`类设计为单例模式。在软件工程中，单例模式是一种设计模式，它限制一个类的实例只能有一个对象。这种模式非常适合`GameMaster`，因为我们只需要在任何给定时间内游戏生命周期中有一个活跃的实例。
- en: We also looked at how to perform scene management. We defined a static class
    named `SceneName` that contains constant string variables identifying the scene
    references in our game.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何执行场景管理。我们定义了一个名为`SceneName`的静态类，其中包含标识我们游戏中场景引用的常量字符串变量。
- en: We then took the next step to improve `GameMaster` and the internal structure
    for our code. We created a new class, called `GameLevelController.cs` that handles
    the scene management, which in turn is driven by `GameMaster`. We practically
    took the logic for level handling from within the `GameMaster` class, and reworked
    and improved it in the `GameLevelController` class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们采取下一步改进`GameMaster`和代码内部结构。我们创建了一个新类，称为`GameLevelController.cs`，该类处理场景管理，这反过来又由`GameMaster`驱动。我们实际上从`GameMaster`类中提取了级别处理的逻辑，并在`GameLevelController`类中重新工作并改进了它。
- en: Next we developed an `AudioController` class that basically manages the audio
    for our game. This class is also driven by `GameMaster`. By this time, `GameMaster`
    is a lean script that manages all of the other components.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开发了一个`AudioController`类，该类基本上管理我们游戏中的音频。这个类也是由`GameMaster`驱动的。到这时，`GameMaster`已经是一个精简的脚本，负责管理所有其他组件。
- en: The next big challenge was how to handle the player character data. Specifically,
    how to save the character customization data for the player character internally,
    after the player has customized the character. In order to save the data, we had
    to modify the `PlayerCharacter.cs` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的重大挑战是如何处理玩家角色数据。具体来说，如何在玩家定制角色后，内部保存角色定制数据。为了保存数据，我们必须修改`PlayerCharacter.cs`类。
- en: We created several enumerations representing each part of the character that
    could be customized, such as the shoulder pad, the body type, the weapon type,
    the helmet type and so on. We used enumeration to make it easier to reference
    them within the code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了几个枚举，代表可以定制的角色各个部分，例如护肩、体型、武器类型、头盔类型等等。我们使用枚举来使它们在代码中更容易引用。
- en: This approach forced us to make some modifications to the existing character
    customization setup that we implemented previously. We had to update the UI components
    to reflect the enumeration defined for each customizable type, and we also had
    to modify the `BarbarianCharacterCustomization.cs` class to handle the new changes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法迫使我们修改了之前实现的现有角色定制设置。我们必须更新UI组件以反映为每个可定制类型定义的枚举，还必须修改`BarbarianCharacterCustomization.cs`类以处理新的更改。
- en: The `BarbarianCharacterCustomization` class implemented a PC type variable to
    keep track of the customizations and finally pass the data along to `GameMaster`.
    During the process, we also improved the case handling of the `BarbarianCharacterCustomization`
    class for default values and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`BarbarianCharacterCustomization`类实现了一个PC类型变量来跟踪定制，并最终将数据传递给`GameMaster`。在这个过程中，我们还改进了`BarbarianCharacterCustomization`类的默认值等案例处理。'
- en: Finally, we did a test run of the game to double-check everything worked as
    designed and implemented.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对游戏进行了测试运行，以确保一切按设计实施的方式正常工作。
- en: We have created a lot of code in this chapter. In the next chapter, we will
    start building our inventory system, and yes, that is going to involve more code!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们编写了大量的代码。在下一章，我们将开始构建我们的库存系统，是的，这将涉及更多的代码！
