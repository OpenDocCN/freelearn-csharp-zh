<html><head></head><body>
		<div id="_idContainer065">
			<p><a id="_idTextAnchor298"/></p>
			<h1 id="_idParaDest-191" class="chapter-number"><a id="_idTextAnchor299"/>17</h1>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor300"/>Static Code Analysis</h1>
			<p>In today’s software development world, I believe it’s more important than ever to write clean and maintainable code. The increasing complexity of software, lower retention in the workforce, and increased competition should lead us to standardize our way of writing software more and put the next developer in the pit of success coming into the codebase. Catching errors early is super important when the developers have it in their mind, preferably. One of the ways to achieve this is through the use of static code analysis, which allows developers to identify potential issues and bugs in their code before it is even executed. With the Roslyn compiler extensions in C#, developers have the ability to create custom analyzers and code fixes that can help automate <span class="No-Break">this process.</span></p>
			<p>In this chapter, we’ll explore the basics of static code analysis and how to use Roslyn compiler extensions to write your own analyzers and code fixes. We’ll cover everything from the fundamentals of writing an analyzer to create automated tests to ensure that your code is working <span class="No-Break">as intended.</span></p>
			<p>Whether you’re a seasoned developer looking to improve your code quality or a newcomer to the world of static code analysis, this chapter will provide you with the tools and knowledge you need to get started with Roslyn compiler extensions and take your code analysis to the next level. </p>
			<ul>
				<li>What is static <span class="No-Break">code analysis?</span></li>
				<li>How to write <span class="No-Break">an analyzer</span></li>
				<li>How to write a code fix for <span class="No-Break">an analyzer</span></li>
				<li>How to write <span class="No-Break">automated tests</span></li>
			</ul>
			<p>By the end of this chapter, you should have a solid understanding of how to use Roslyn compiler extensions to implement static code analysis in C#. You should be able to write your own custom analyzers and code fixes and know how to create automated tests to ensure the correctness of their implementation. Additionally, you should have a good understanding of the benefits of static code analysis and how it can improve the overall quality and maintainability of their code. With this knowledge, you will be well equipped to apply static code analysis techniques in your own development projects, leading to more efficient and effective <span class="No-Break">software development.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor301"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter17">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter17</a>), and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>). It also leverages the <strong class="source-in ine">Roslyn.Extensions</strong> code that is found in the GitHub <span class="No-Break">repository (</span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Roslyn.Extensions"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Roslyn.Extensions</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor302"/>What is static code analysis?</h1>
			<p><strong class="bo d">Static code analysis</strong> is a powerful technique for detecting issues and bugs in your code before it’s even <a id="_idIndexMarker709"/>executed. While it may seem like a relatively new development, the truth is that static code analysis has been around for decades and has been used in languages such as C/C++ through tools such <span class="No-Break">as linters.</span></p>
			<p>Linters are essentially static code analysis tools that analyze source code to flag suspicious constructs <a id="_idIndexMarker710"/>or style inconsistencies. They have been around for several decades and are widely used in languages such as C/C++ to improve code quality <span class="No-Break">and maintainability.</span></p>
			<p>In recent years, static code analysis has gained more popularity with the rise of languages such as JavaScript and TypeScript. Tools such as ESLint have been developed to provide similar benefits to JavaScript and TypeScript developers by analyzing code for potential issues and providing feedback on <span class="No-Break">best practices.</span></p>
			<p>The .NET Compiler <strong class="bo d">Software Development Kit</strong> (<strong class="bo d">SDK</strong>) from Microsoft takes a comprehensive <a id="_idIndexMarker711"/>approach to extending the compiler. Rather than just focusing on expanding its functionality, the SDK also enables the code <a id="_idIndexMarker712"/>to identify potential issues within your code editor or <strong class="bo d">Integrated Development Environment</strong> (<strong class="bo d">IDE</strong>). This feature is supported by popular editors, including <strong class="bo d">Visual Studio Code</strong> (<strong class="bo d">VSCode</strong>), Rider, and Visual Studio. As you work with files, the editors run analyzers <a id="_idIndexMarker713"/>in the background, highlighting potential issues with squiggly underlines. These analyzers can flag code that is incorrect or could be improved, providing real-time feedback to help you catch and correct mistakes <span class="No-Break">more efficiently.</span></p>
			<p>Alongside analyzers, Microsoft has introduced code fixers, a feature that enables analyzer vendors to provide code that can automatically fix flagged code issues. These code fixes are represented by light bulbs within the editor, and you can click on them to execute the code fix. With this feature, you can quickly and easily apply fixes to your code and improve its <span class="No-Break">overall quality.</span></p>
			<p>In the following <a id="_idIndexMarker714"/>sections, we will provide an overview of static code analysis and code fixes in the context of the C# compiler and how they work. Although we won’t delve into the subject in great depth, we’ll provide you with the necessary information to get started. It’s important to note that the C# compiler APIs are extensive and offer great possibilities, and this introduction will serve as a starting point for exploring <span class="No-Break">these features.</span></p>
			<p>Let’s dive into writing <span class="No-Break">an anal<a id="_idTextAnchor303"/>yzer.</span></p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor304"/>How to write an analyzer</h1>
			<p>Writing an analyzer that gets automatically run as part of the compile process has been made <a id="_idIndexMarker715"/>very simple by Microsoft. It follows the same principles as source generators, as we saw in <a href="B19418_16.xhtml#_idTextAnchor272"><span class="No-Break"><em class="ita ic">Chapter 16</em></span></a>, <em class="ita ic">Generating Code</em>. Once you have the project set up, as we did back in <a href="B19418_15.xhtml#_idTextAnchor250"><span class="No-Break"><em class="ita ic">Chapter 15</em></span></a>, <em class="ita ic">Roslyn Compiler Extensions</em>, it’s all about dropping in a class that represents <span class="No-Break">the analyzer.</span></p>
			<p>In this chapter, all code assumes you have the <strong class="source-in ine">Roslyn.Extensions</strong> project that we established in <a href="B19418_15.xhtml#_idTextAnchor250"><span class="No-Break"><em class="ita ic">Chapter 15</em></span></a>, <em class="ita ic">Roslyn </em><span class="No-Break"><em class="ita ic">Compiler Extensions</em></span><span class="No-Break">.</span></p>
			<p>The analyzer we’re going to make is a highly opinionated one that affects the naming of exception types. One of the things we tend to do is to suffix our types with what they technically represent; for instance, exceptions are often suffixed with <strong class="source-in ine">Exception</strong>. Looking at exceptions found in the .NET base class libraries, you’ll see things such as <strong class="source-in ine">NotImplementedException</strong>, <strong class="source-in ine">ArgumentException</strong>, or <strong class="source-in ine">ArgumentNullException</strong>. This is something I personally don’t like, and I believe that it is not important information to communicate, and we should instead put effort into properly naming the types for what <span class="No-Break">they do.</span></p>
			<p>Take <strong class="source-in ine">ArgumentException</strong> as an example. Its name does not convey its purpose. By simply changing it <a id="_idIndexMarker716"/>to be called <strong class="source-in ine">InvalidArgument</strong>, it communicates that there is a violation – <em class="ita ic">the argument </em><span class="No-Break"><em class="ita ic">is invalid</em></span><span class="No-Break">.</span></p>
			<p>You might not agree with this type of rule in your code base. But let’s set aside that for a minute and just use this as <span class="No-Break">an e<a id="_idTextAnchor305"/>xample.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor306"/>Fleshing out an analyzer</h2>
			<p>Let’s start by <a id="_idIndexMarker717"/>creating a home for the analyzer. In the <strong class="source-in ine">Roslyn.Extensions</strong> project, add a folder called <strong class="source-in ine">CodeAnalysis</strong>. I like to have folders for every analyzer type since we might be providing code fixes for the analyzer, and we might want to have more than just the analyzer class to create the analyzer. With that as a principle, add a folder within the <strong class="source-in ine">CodeAnalysis</strong> folder called <strong class="source-in ine">ExceptionShouldNotBeSuffixed</strong>; this will be the name of <span class="No-Break">the analyzer.</span></p>
			<p>In <strong class="source-in ine">ExceptionShouldNotBeSuffixed</strong>, you can now add a file called <strong class="source-in ine">Analyzer.cs</strong>. Put the following into <span class="No-Break">the file:</span></p>
			<pre class="source-code">
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
namespace Roslyn.Extensions.CodeAnalysis
  .ExceptionShouldNotBeSuffixed;
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class Analyzer : DiagnosticAnalyzer
{
}</pre>
			<p>The code sets up the basics for an analyzer by inheriting the <strong class="source-in ine">DiagnosticAnalyzer</strong> type from the <strong class="bo d">.NET Compiler SDK</strong>. In addition to this, it adorns the <a id="_idIndexMarker718"/>class with an <strong class="source-in ine">[DiagnosticAnalyzer]</strong> attribute, instructing it that the supported language is C#. All the <strong class="source-in ine">using</strong> statements are for the code <span class="No-Break">to come.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Analyzers can support multiple languages by specifying the additional languages it supports. It can, however, <a id="_idIndexMarker719"/>affect the complexity of your analyzer as there are differences in how the <strong class="bo d">abstract syntax tree</strong> (<strong class="bo d">AST</strong>) <span class="No-Break">is represented.</span></p>
			<p>For the analyzer to work and be hooked up, it needs to be configured properly and register any actions <a id="_idIndexMarker720"/>that should <span class="No-Break">be called.</span></p>
			<p>Add the following method to the <span class="No-Break"><strong class="source-in ine">Analyzer</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public override void Initialize(AnalysisContext context)
{
    context.EnableConcurrentExecution();
    context.ConfigureGeneratedCodeAnalysis
      (GeneratedCodeAnalysisFlags.None);
    context.RegisterSyntaxNodeAction(
        HandleClassDeclaration,
        ImmutableArray.Create(
            SyntaxKind.ClassDeclaration));
}</pre>
			<p>The code calls <strong class="source-in ine">EnableConcurrentExecution()</strong> on the <strong class="source-in ine">AnalysisContext</strong> passed, which informs the compiler that your analyzer can be executed concurrently with other analyzers in an asynchronous manner. If your analyzer does not support concurrent execution, you can simply omit this call. If your analyzer does support concurrent execution, it can help to speed up your builds, making your development process more efficient. Next, it configures whether or not your analyzer should be run on generated code. The analyzer you’re building now should not care about generated code; it is therefore configured to <span class="No-Break">ignore it.</span></p>
			<p>Lastly, the code registers an action to be run on syntax nodes. A <strong class="bo d">syntax node</strong> is a fundamental unit of the AST, as we looked at in <a href="B19418_16.xhtml#_idTextAnchor272"><span class="No-Break"><em class="ita ic">Chapter 16</em></span></a>, <em class="ita ic">Generating Code</em>, and corresponds to a <a id="_idIndexMarker721"/>specific syntactic construct, such as a method call, a loop statement, or a class declaration. Syntax nodes are represented as objects in memory and are linked together in a tree-like structure that mirrors the structure of the <span class="No-Break">source code.</span></p>
			<p>In our case, we’re only interested in class declarations; it therefore registers a <strong class="source-in ine">HandleClassDeclaration</strong> callback <span class="No-Break">with </span><span class="No-Break"><strong class="source-in ine">SyntaxKind.ClassDeclaration</strong></span><span class="No-Break">.</span></p>
			<p>When an analyzer encounters a problem, it needs to produce a response to the compiler that tells there is <a id="_idIndexMarker722"/>an issue, and it should be reported back to the developer. The representation of the issue is formalized into something called <strong class="source-in ine">DiagnosticDescriptor</strong>. You need to create specific ones of these for every specific broken rule <span class="No-Break">you get.</span></p>
			<p>Add the following to the top of the <span class="No-Break"><strong class="source-in ine">Analyzer</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public const string DiagnosticId = "PP0001";
public static readonly DiagnosticDescriptor BrokenRule =
  new(
        id: DiagnosticId,
        title: "ExceptionShouldNotBeSuffixed",
        messageFormat: "The use of the word 'Exception'
        should not be added as a suffix - create a well
        understood and self explanatory name for the
        exception",
        category: "Naming",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: null,
        helpLinkUri: string.Empty,
        customTags: Array.Empty&lt;string&gt;());
public override ImmutableArray&lt;DiagnosticDescriptor&gt;
  SupportedDiagnostics =&gt; ImmutableArray.Create
    (BrokenRule);</pre>
			<p>The code establishes a custom <strong class="source-in ine">DiagnosticDescriptor</strong> that holds a reference to a unique diagnostic identifier (<strong class="source-in ine">PP0001</strong>), a title, and a message to display to the developer. It also <a id="_idIndexMarker723"/>puts the broken rule into a category (<strong class="source-in ine">Naming</strong>). Since the category is a string, this could be anything, but there are a few well-known ones used by other analyzers, such as <strong class="bo d">Naming</strong>, <strong class="bo d">Design</strong>, <strong class="bo d">Correctness</strong>, <strong class="bo d">Performance</strong>, and <strong class="bo d">Documentation</strong>. The categories are used by tools to let developers group warnings or errors in a codebase. In the descriptor, you also put the severity level for the broken rule. The levels are shown in <span class="No-Break">this table:</span></p>
			<table id="table001-2" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bo d">Level</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bo d">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Hidden</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Not surfaced through <span class="No-Break">normal means</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Info</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Information that does not indicate <span class="No-Break">a problem</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Warning</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Suspicious but allowed; the developer should just know <span class="No-Break">about it</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Error</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Not allowed; the build will <span class="No-Break">be broken</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">If the developer using your analyzer decides to use the <strong class="source-in ine">TreatWarningsAsErrors</strong> option in the <strong class="source-in ine">.csproj</strong> file, the warnings will be treated as errors and break the build. The <strong class="source-in ine">Roslyn.Extension.props</strong> file that is included in projects using this extension has that option <span class="No-Break">turned on.</span></p>
			<p>The last few properties of <strong class="source-in ine">DiagnosticDescriptor</strong> are further details to help the developers understand <a id="_idIndexMarker724"/>the compiler error or warning you want to communicate. You could, for instance, include a link to a web page describing in detail the analyzer or the specific rule you <span class="No-Break">have implemented.</span><a id="_idTextAnchor307"/></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor308"/>Handling the syntax nodes</h2>
			<p>For the analyzer to <a id="_idIndexMarker725"/>work, you’re going to need an <a id="_idIndexMarker726"/>implementation of the <strong class="source-in ine">HandleClassDeclaration</strong> callback that was given during the <strong class="source-in ine">Initialize</strong> method. Add the following private method to the <span class="No-Break"><strong class="source-in ine">Analyzer</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
    void HandleClassDeclaration(SyntaxNodeAnalysisContext
      context)
    {
        var classDeclaration = context.Node as
          ClassDeclarationSyntax;
        if (classDeclaration?.BaseList == null ||
          classDeclaration?.BaseList?.Types == null)
            return;
        var classSymbol = context.SemanticModel
          .GetDeclaredSymbol(classDeclaration);
        if (classSymbol?.BaseType is null) return;
        var exceptionType = context.Compilation
          .GetTypeByMetadataName("System.Exception");
        if (SymbolEqualityComparer.Default.Equals
          (classSymbol?.BaseType, exceptionType) &amp;&amp;
            classDeclaration.Identifier.Text
              .EndsWith("Exception", StringComparison
               .InvariantCulture))
        {
            var diagnostic = Diagnostic.Create(BrokenRule,
              classDeclaration.Identifier.GetLocation());
            context.ReportDiagnostic(diagnostic);
        }
    }</pre>
			<p>The code starts by looking at the syntax node being analyzed. The syntax node would typically be things such as a method declaration, a class definition, or a variable declaration. Syntax nodes are used to represent the structure of the code but do not convey information about the meaning or semantics of <span class="No-Break">the code.</span></p>
			<p>The code assumes the syntax node is a <strong class="source-in ine">ClassDeclarationSyntax</strong> node, as that was what was configured as a filter in the <strong class="source-in ine">Initialize()</strong> method. It then looks at the <strong class="source-in ine">BaseList</strong> property <a id="_idIndexMarker727"/>to see whether the class declaration inherits <a id="_idIndexMarker728"/>from another type. If it doesn’t, the analyzer is not interested in the node, as it only wants to analyze types that inherit <span class="No-Break">from </span><span class="No-Break"><strong class="source-in ine">Exception</strong></span><span class="No-Break">.</span></p>
			<p>For the analyzer to understand the semantic meaning of the node being passed, it has to use <strong class="source-in ine">SemanticModel</strong> to do so. From the declared symbol, it makes sure it has a base type; if not, it <span class="No-Break">just returns.</span></p>
			<p>Next, the code asks for a representation of the <strong class="source-in ine">System.Exception</strong> type, which is then used to check if <strong class="source-in ine">BaseType</strong> is, in fact, an exception. If it is an exception, it then checks the class identifier to see whether it is suffixed with the <strong class="source-in ine">Exception</strong> text. If it is suffixed, it then reports back with an instance of the broken rule that holds the location of the class declaration identifier that <span class="No-Break">was wrong.</span></p>
			<p>That is pretty much it for creating a <span class="No-Break">simple analy<a id="_idTextAnchor309"/>zer.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor310"/>Release tracking</h2>
			<p>Suppose you <a id="_idIndexMarker729"/>go and build the <strong class="source-in ine">Roslyn.Extensions</strong> project, you will get a warning that looks something like <span class="No-Break">the following:</span></p>
			<pre class="console">
MSBuild version 17.5.1+f6fdcf537 for .NET
  Determining projects to restore...
  All projects are up-to-date for restore.
/Users/einari/Projects/Metaprogramming-in-C/
Roslyn.Extensions/CodeAnalysis/ExceptionShouldNotBeSuffixed
/Analyzer.cs(15,10): warning RS2008: Enable analyzer
release tracking for the analyzer project containing rule
'PP0001' [/Users/einari/Projects/Metaprogramming-in-C/
Roslyn.Extensions/Roslyn.Extensions.csproj]
  Roslyn.Extensions -&gt; /Users/einari/Projects/
Metaprogramming-in-C/Roslyn.Extensions/bin/
Debug/netstandard2.0/Roslyn.Extensions.dll
Build succeeded.
/Users/einari/Projects/Metaprogramming-in-C/
Roslyn.Extensions/CodeAnalysis/ExceptionShouldNotBeSuffixed
/Analyzer.cs(15,10): warning RS2008: Enable analyzer
release tracking for the analyzer project containing rule
'PP0001' [/Users/einari/Projects/Metaprogramming-in-
C/Roslyn.Extensions/Roslyn.Extensions.csproj]
    1 Warning(s)
    0 Error(s)
Time Elapsed 00:00:00.52</pre>
			<p>The <strong class="source-in ine">RS2008</strong> warning tells you that we could add information to our project that would make it easier to track releases of your packaged analyzers and the rules it provides. If this is not <a id="_idIndexMarker730"/>important to you, you can ignore this warning and <span class="No-Break">move on.</span></p>
			<p>To satisfy the warning, we need to provide two files. One that contains the shipped rules and one that contains the unshipped rules. For an initial release, the unshipped rules file would typically be empty, while you might be putting in unshipped rules as part of releases for rules that are upcoming. When the rules are shipped, you typically move these from unshipped <span class="No-Break">to shipped.</span></p>
			<p>You can read more detail about the purpose of these files on <span class="No-Break">GitHub (</span><a href="https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md"><span class="No-Break">https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md</span></a><span class="No-Break">).</span></p>
			<p>Let’s add a file in the root of the <strong class="source-in ine">Roslyn.Extensions</strong> project called <strong class="source-in ine">AnalyzerReleases.Shipped.md</strong> and add the following content <span class="No-Break">to it:</span></p>
			<pre class="source-code">
## Release 1.0
### New Rules
Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
PP0001  |  Naming  |  Error   |</pre>
			<p>The content indicates a release version of <strong class="source-in ine">1.0</strong> and provides a table of rules. In your case, you only have one rule. The <strong class="source-in ine">Notes</strong> column could hold the name of the analyzer and, if you’d like, a link to a description of the <span class="No-Break">broken rule.</span></p>
			<p>With the shipped file in place, you’ll need a file for unshipped. Add a file called <strong class="source-in ine">AnalyzerReleases.Unshipped.md</strong>. This file can be empty at this point, so just leave it <span class="No-Break">as is.</span></p>
			<p>When packaging your Roslyn extension as a NuGet package, you want the files to be included. Open <a id="_idIndexMarker731"/>the <strong class="source-in ine">Roslyn.Extensions.csproj</strong> file and add the following at the bottom of the file, within the <span class="No-Break"><strong class="source-in ine">Project</strong></span><span class="No-Break"> tag:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;AdditionalFiles Include="AnalyzerReleases.Shipped.md" /&gt;
    &lt;AdditionalFiles Include="
      AnalyzerReleases.Unshipped.md" /&gt;
&lt;/ItemGroup&gt;</pre>
			<p>That’s it! Your analyzer is now ready to be put into the real world <span class="No-Break">an<a id="_idTextAnchor311"/>d used.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor312"/>Trying out the analyzer</h2>
			<p>To test the analyzer and <a id="_idIndexMarker732"/>see that it works and performs the way we expect it to, you’ll need a project that has code that violates the rule put into <span class="No-Break">the analyzer:</span></p>
			<ol>
				<li>Create a new folder, next to the <strong class="source-in ine">Roslyn.Extensions</strong> folder called <strong class="source-in ine">Chapter17</strong>. Within the <strong class="source-in ine">Chapter17</strong> folder in a terminal, create a <span class="No-Break">new project:</span><pre class="console">
<strong class="bo d">dotnet new console</strong></pre></li>
				<li>Then you need a reference to the <strong class="source-in ine">Roslyn.Extensions</strong> project. The project reference can not be a standard project reference; it needs to be slightly different. Add the following within the <strong class="source-in ine">Project</strong> tag of the <span class="No-Break"><strong class="source-in ine">Chapter17.csproj</strong></span><span class="No-Break"> file:</span><pre class="console">
&lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\Roslyn.Extensions\
      Roslyn.Extensions.csproj" OutputItemType=
        "Analyzer" ReferenceOutputAssembly="false" /&gt;
&lt;/ItemGroup&gt;</pre></li>
			</ol>
			<p>By telling it that <strong class="source-in ine">OutputItemType</strong> is <strong class="source-in ine">Analyzer</strong>, it will automatically hook up the assembly output from the <strong class="source-in ine">Roslyn.Extensions</strong> project to the compiler. <strong class="source-in ine">ReferenceOutputAssembly</strong> set to <strong class="source-in ine">false</strong> tells it that the compiled output of the project will not reference the output assembly of the <strong class="source-in ine">Roslyn.Extensions</strong> project.</p>
			<ol>
				<li value="3">Since <a id="_idIndexMarker733"/>your <strong class="source-in ine">Roslyn.Extensions</strong> project should, at this point in time, be holding the <strong class="bo d">General Data Protection Regulation</strong> (<strong class="bo d">GDPR</strong>) solution built in <a href="B19418_16.xhtml#_idTextAnchor272"><span class="No-Break"><em class="ita ic">Chapter 16</em></span></a>, <em class="ita ic">Generating Code</em>, and it has a requirement of a configuration property to be <a id="_idIndexMarker734"/>present, you’ll need to add the following within a <strong class="source-in ine">PropertyGroup</strong> tag in the <span class="No-Break"><strong class="source-in ine">Chapter17.csproj</strong></span><span class="No-Break"> file:</span><pre class="console">
&lt;GDPRReport&gt;$(MSBuildThisFileDirectory)GDPRReport.txt
  &lt;/GDPRReport&gt;</pre></li>
				<li>Then, in the <strong class="source-in ine">Chapter17.csproj</strong> file in the <strong class="source-in ine">Chapter17</strong> folder, you will need to add a reference to the props file from the <strong class="source-in ine">Roslyn.Extensions</strong> project. Add the following at the top of the file within the <span class="No-Break"><strong class="source-in ine">Project</strong></span><span class="No-Break"> tag:</span><pre class="console">
&lt;Import Project="$(MSBuildThisFileDirectory)
  ../Roslyn.Extensions/Roslyn.Extensions.props"/&gt;</pre></li>
				<li>In the <strong class="source-in ine">Chapter17</strong> folder, add a file called <strong class="source-in ine">MyException.cs</strong> and add the following <span class="No-Break">to it:</span><pre class="console">
namespace Chapter17;
public class MyException : Exception
{
}</pre></li>
				<li>Open your <a id="_idIndexMarker735"/>terminal and do a build, you should see something like <span class="No-Break">the following:</span><pre class="console">
<strong class="bo d">MSBuild version 17.5.1+f6fdcf537 for .NET</strong>
<strong class="bo d">  Determining projects to restore...</strong>
<strong class="bo d">  All projects are up-to-date for restore.</strong>
<strong class="bo d">  Roslyn.Extensions -&gt; /Users/einari/Projects/</strong>
<strong class="bo d">Metaprogramming-in-C/Roslyn.Extensions/bin/Debug/</strong>
<strong class="bo d">netstandard2.0/Roslyn.Extensions.dll</strong>
<strong class="bo d">/Users/einari/Projects/Metaprogramming-in-C/</strong>
<strong class="bo d">Chapter17/MyException.cs(3,14): error PP0001: The use</strong>
<strong class="bo d">of the word 'Exception' should not be added as a</strong>
<strong class="bo d">suffix - create a well understood and self explanatory</strong>
<strong class="bo d">name for the exception [/Users/einari/Projects/</strong>
<strong class="bo d">Metaprogramming-in-C/Chapter17/Chapter17.csproj]</strong>
<strong class="bo d">Build FAILED.</strong>
<strong class="bo d">/Users/einari/Projects/Metaprogramming-in-C/</strong>
<strong class="bo d">Chapter17/MyException.cs(3,14): error PP0001: The use</strong>
<strong class="bo d">of the word 'Exception' should not be added as a</strong>
<strong class="bo d">suffix - create a well understood and self explanatory</strong>
<strong class="bo d">name for the exception [/Users/einari/Projects/</strong>
<strong class="bo d">Metaprogramming-in-C/Chapter17/Chapter17.csproj]</strong>
<strong class="bo d">    0 Warning(s)</strong>
<strong class="bo d">    1 Error(s)</strong>
<strong class="bo d">Time Elapsed 00:00:01.81</strong></pre></li>
			</ol>
			<p>The output clearly says that you have a <strong class="source-in ine">PP0001</strong> error, and the text describes the actual problem.</p>
			<p>This is pretty cool, but <a id="_idIndexMarker736"/>what’s even cooler is that in your editor, you should get a clear indication that you have an error by getting a squiggly line underlining <a id="_idIndexMarker737"/>the <strong class="source-in ine">MyException</strong> class name. In <strong class="bo d">Visual Studio Code</strong> (<strong class="bo d">VS Code</strong>), this would look like <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B19418_17_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – VS Code analysis error</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">If you’re having trouble getting your editor to show the analyzer error, you might need to restart it, or if it has a language server, just restart that. For VS Code, you can simply bring up the command palette (<em class="ita ic">F1</em>) and type <strong class="source-in ine">OmniSharp</strong> and then select <strong class="bo d">OmniSharp: </strong><span class="No-Break"><strong class="bo d">Restart OmniSharp</strong></span><span class="No-Break">.</span></p>
			<p>With an analyzer in place, it’s time to look into making your developers more productive so that they can fix errors <span class="No-Break">q<a id="_idTextAnchor313"/>uite easily.</span></p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor314"/>How to write a code fix for an analyzer</h1>
			<p>As discussed <a id="_idIndexMarker738"/>earlier, the .NET Compiler SDK supports more <a id="_idIndexMarker739"/>than just writing analyzers that analyze your code. You can also provide code that quickly fixes any errors that occur. These are understood by most editors and IDEs and will automatically be loaded and presented <span class="No-Break">when applicable.</span></p>
			<p>You’ll be reusing the <strong class="source-in ine">Roslyn.Extensions</strong> project for the code fix as well. The code fix needs to tap into specific APIs and needs another package reference. Add a reference to <strong class="source-in ine">Microsoft.CodeAnalysis.CSharp.Workspaces</strong> by running the following in your terminal within the <span class="No-Break"><strong class="source-in ine">Roslyn.Extensions</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="console">
dotnet add package Microsoft.CodeAnalysis.CSharp.Workspaces</pre>
			<p>With the package <a id="_idIndexMarker740"/>reference in place, it’s time for the implementation <a id="_idIndexMarker741"/>of the <span class="No-Break">code fix:</span></p>
			<ol>
				<li>Start by adding a file called <strong class="source-in ine">CodeFix.cs</strong> within the <strong class="source-in ine">CodeAnalysis/ExceptionShouldNotBeSuffixed</strong> folder in the <strong class="source-in ine">Roslyn.Extensions</strong> project folder. Add the following <span class="No-Break">to it:</span><pre class="console">
using System.Collections.Immutable;
using System.Composition;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeActions;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
namespace Roslyn.Extensions.CodeAnalysis
  .ExceptionShouldNotBeSuffixed;
[ExportCodeFixProvider(LanguageNames.CSharp, Name =
  nameof(CodeFix))]
[Shared]
public class CodeFix : CodeFixProvider
{
}</pre></li>
			</ol>
			<p>The code sets up a code fix by inheriting from the <strong class="source-in ine">CodeFixProvider</strong> and adding the <strong class="source-in ine">[ExportCodeFixProvider]</strong> attribute. It specifies the language it supports and the name of the code fix. As with the analyzer, you can support multiple languages by specifying that on the attribute. If you want, you can narrow down the document types you want to support and also file extensions by setting the <strong class="source-in ine">DocumentKinds</strong> or <strong class="source-in ine">DocumentExtensions</strong> properties of <strong class="source-in ine">ExportCodeFixProvider</strong>. We leave these as default, as we trust the editor to call us correctly.</p>
			<ol>
				<li value="2">For the code fix <a id="_idIndexMarker742"/>to be invoked, it needs to specify what <a id="_idIndexMarker743"/>broken rule it can fix. This is done by providing an array of the rule diagnostic identifier. Add the following within the <span class="No-Break"><strong class="source-in ine">CodeFix</strong></span><span class="No-Break"> class:</span><pre class="console">
public override ImmutableArray&lt;string&gt;
  FixableDiagnosticIds =&gt; ImmutableArray.Create
    (Analyzer.DiagnosticId);</pre></li>
				<li>With the broken rule association in place, the next thing you’ll need is a method that registers the code fix and the code to be called when the code fix is invoked. Add the following method to the <span class="No-Break"><strong class="source-in ine">CodeFix</strong></span><span class="No-Break"> class:</span><pre class="console">
public override Task RegisterCodeFixesAsync
  (CodeFixContext context)
{
    var diagnostic = context.Diagnostics[0];
    context.RegisterCodeFix(
        CodeAction.Create(
            title: "Remove Exception suffix",
            createChangedDocument: c =&gt;
              RemoveSuffix(context.Document,
                diagnostic, c)),
        diagnostic);
    return Task.CompletedTask;
}</pre></li>
			</ol>
			<p>The code assumes there is only one <strong class="source-in ine">Diagnostic</strong> that can be errored. This is because there is only one in the analyzer. If you have more, you’d need to find the correct diagnostic and match the appropriate code fix to it. However, for maintainability, I would recommend having one file per code fix linked to one broken rule.</p>
			<ol>
				<li value="4">Next, the code registers a code fix for the diagnostic; it does so by creating a <strong class="source-in ine">CodeAction</strong> that holds a title to display the code fix and the callback to be called when the code fix is invoked by <span class="No-Break">the developer.</span></li>
			</ol>
			<p>All code fix providers can fix single problems, but they can also fix multiple by providing <strong class="source-in ine">FixAllProvider</strong>. This is something you can choose to implement yourself if it <a id="_idIndexMarker744"/>needs special handling or use the <a id="_idIndexMarker745"/>default <strong class="source-in ine">BatchFixer</strong>. Add the following method to provide <strong class="source-in ine">FixAllProvider</strong>. This is completely optional; by default, it does not provide any:</p>
			<pre class="console">
    public override FixAllProvider?
      GetFixAllProvider() =&gt; WellKnownFixAllProviders
        .BatchFixer;</pre>
			<ol>
				<li value="5">The last thing you’ll need is the code that performs the code fix. The only fix you can really do is to provide code that removes the suffix. Add the following code to the <span class="No-Break"><strong class="source-in ine">CodeFix</strong></span><span class="No-Break"> class:</span><pre class="console">
async Task&lt;Document&gt; RemoveSuffix(Document document,
  Diagnostic diagnostic, CancellationToken c)
{
    var root = await document.GetSyntaxRootAsync(c);
    if (!(root!.FindNode(diagnostic.Location
      .SourceSpan) is ClassDeclarationSyntax node))
        return document;
    var newName = node.Identifier.Text.Replace
      ("Exception", string.Empty);
    var newRoot = root.ReplaceNode(node,
      node.WithIdentifier(SyntaxFactory.Identifier
        (newName)));
    return document.WithSyntaxRoot(newRoot);
}</pre></li>
			</ol>
			<p>The code navigates the document and finds the <strong class="source-in ine">ClassDeclarationSyntax</strong> node. If it can’t find it, the code fix does not do anything. It then <a id="_idIndexMarker746"/>replaces the <strong class="source-in ine">Exception</strong> text in <a id="_idIndexMarker747"/>the <strong class="source-in ine">Identifier</strong> of the node with <strong class="source-in ine">string.Empty</strong> and then replaces the node. It then returns a modified version of the document with the modified node.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Since this code fix is a very simple one, it does not leverage much of the APIs available for code fixes. An important aspect of code fixes is to be aware of formatting and make sure the result is formatted correctly. This is done by adding <strong class="source-in ine">.WithAdditionalAnnotations(Formatter.Annotation)</strong> on the node when <span class="No-Break">altering it.</span></p>
			<p>This is all you need to do for a simple code fix to work. All you now need to do is compile it and open a file that violates the rule. In your case, that would be the <strong class="source-in ine">MyException.cs</strong> file within the <span class="No-Break"><strong class="source-in ine">Chapter17</strong></span><span class="No-Break"> folder.</span></p>
			<p>Editors do this slightly differently, but within VS Code, the code fix capability would show up as a lightbulb, and <a id="_idIndexMarker748"/>clicking the lightbulb would then <a id="_idIndexMarker749"/>show the <strong class="source-in ine">Remove Exception suffix</strong> <span class="No-Break">code fix:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B19418_17_02.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – VS Code code fix</p>
			<pre class="console">
Important note</pre>
			<p class="ca out">If you’re having trouble getting your editor to show the code fix, you might need to restart it, or if it has a language server, just restart that. For VS Code, you can simply bring up the command palette (<em class="ita ic">F1</em>) and type <strong class="source-in ine">OmniSharp</strong> and then select <strong class="bo d">OmniSharp: </strong><span class="No-Break"><strong class="bo d">Restart OmniSharp</strong></span><span class="No-Break">.</span></p>
			<p>Testing your analyzer and <a id="_idIndexMarker750"/>code fix with the compiler and an editor does <a id="_idIndexMarker751"/>not give you the best feedback loop, and as with any code you write, it would be hard <a id="_idTextAnchor315"/>to catch <span class="No-Break">regression bugs.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor316"/>How to write automated tests</h1>
			<p>Writing automated tests for all your code gives you the confidence to change your code and know <a id="_idIndexMarker752"/>whether you broke anything. This applies to all code, including analyzers and code fixes. For anything that extends the compiler or provides editors or IDEs with new capabilities, it’s also harder to test whether or not your implementation works. It can be frustrating at times to get things working and can hamper your productivity by <span class="No-Break">building these.</span></p>
			<p>Luckily, Microsoft has provided an easy way to test your analyzers and <span class="No-Break">code fixes:</span></p>
			<ol>
				<li>Next to the <strong class="source-in ine">Roslyn.Extensions</strong> folder, create a folder called <strong class="source-in ine">Roslyn.Extensions.Tests</strong>. In a terminal, navigate to the <strong class="source-in ine">Roslyn.Extensions.Tests</strong> folder and run <span class="No-Break">the following:</span><pre class="console">
<strong class="bo d">dotnet new xunit</strong></pre></li>
			</ol>
			<p>The command will <a id="_idIndexMarker753"/>set up a <a href="https://xunit.net">test project usin</a>g the xUnit (<a href="https://xunit.net">https://xunit.net</a>) testing library.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">You can use other testing frameworks as well, such as MSTest <span class="No-Break">or NUnit.</span></p>
			<p>We will not cover unit testing or the specifics of xUnit. You can read more about xUnit on its site.</p>
			<ol>
				<li value="2">The next thing you’ll need is a project reference to the <strong class="source-in ine">Roslyn.Extensions</strong> project. Run the following command within the <span class="No-Break"><strong class="source-in ine">Roslyn.Extensions.Tests</strong></span><span class="No-Break"> folder:</span><pre class="console">
<strong class="bo d">dotnet add reference ../Roslyn.Extensions</strong></pre></li>
			</ol>
			<p>This adds a project reference to the <strong class="source-in ine">Roslyn.Extensions</strong> project, and you may notice that you did this differently than with the <strong class="source-in ine">Chapter17</strong> project. The reason is that in <a id="_idIndexMarker754"/>the context of testing, you need the <strong class="source-in ine">Roslyn.Extensions</strong> assembly to be referenced by the test assembly and be present <a id="_idTextAnchor317"/>at the runtime of the tests.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor318"/>Analyzer tests</h2>
			<p>With the test project in place and the reference to the extension project itself, we can start filling it with the <a id="_idIndexMarker755"/>tests we want. The first thing you want to write a test for is the analyzer. The purpose of the tests for the analyzer is to verify that the analyzer will give an error when the code contains an exception that is suffixed and not give an error when exception types do not have <span class="No-Break">a suffix.</span></p>
			<p>Add a folder called <strong class="source-in ine">ExceptionShouldNotBeSuffixed</strong> within the <strong class="source-in ine">Roslyn.Extensions.Tests</strong> folder. Then add a file called <strong class="source-in ine">AnalyzerTests</strong>. Put the following content <span class="No-Break">into it:</span></p>
			<pre class="source-code">
namespace Roslyn.Extensions.CodeAnalysis
  .ExceptionShouldNotBeSuffixed;
using Xunit;
using Verify = Microsoft.CodeAnalysis.CSharp.Testing
  .XUnit.AnalyzerVerifier&lt;Analyzer&gt;;
public class AnalyzerTests
{
}</pre>
			<p>This sets up the basics needed for writing the tests. You’re probably asking yourself why the namespace declaration comes before the <strong class="source-in ine">using</strong> statements. We’re doing that to avoid having to use the fully qualified name in <strong class="source-in ine">Verify</strong> using an alias. The <strong class="source-in ine">Verify</strong> alias creates an alias for the <strong class="source-in ine">AnalyzerVerifier&lt;&gt;</strong> generic type and gives it the analyzer under test as a generic parameter. The aliasing is just for convenience, making your tests easier to read <span class="No-Break">and write.</span></p>
			<p>Also, another slightly different thing is the word <strong class="source-in ine">Tests</strong>, which the <strong class="source-in ine">Roslyn.Extensions.Tests</strong> project name is suffixed with, which is normally something you would also reflect in the namespace. Personally, I prefer not to, as test projects are not something you’re deploying, and it generally makes things simpler if you omit this <a id="_idIndexMarker756"/>from your namespace. But that is entirely a <span class="No-Break">personal preference.</span></p>
			<p>The first thing you want to test is whether the analyzer is analyzing the correct code. Add the following method to the <span class="No-Break"><strong class="source-in ine">AnalyzerTests</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
[Fact]
public async Task WithoutSuffix()
{
    const string content = @"
            using System;
            namespace MyNamespace;
            public class SomethingWentWrong : Exception
            {
            }
        ";
    await Verify.VerifyAnalyzerAsync(content);
}</pre>
			<p>The test sets up a valid C# program and calls the <strong class="source-in ine">VerifyAnalyzerAsync()</strong> method for <span class="No-Break">that program.</span></p>
			<p>Then you need a test for testing the violation of the rule. Add the following method to the <span class="No-Break"><strong class="source-in ine">AnalyzerTests</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
[Fact]
public async Task WithSuffix()
{
    const string content = @"
            using System;
            namespace MyNamespace;
            public class MyException : Exception
            {
            }
        ";
    var expected = Verify.Diagnostic().WithLocation(5,
      30).WithArguments("MyException");
    await Verify.VerifyAnalyzerAsync(content, expected);
}</pre>
			<p>The test sets up an invalid C# program and sets up an expectation of a failure at line <strong class="source-in ine">5</strong> and column <strong class="source-in ine">30</strong>. Since you’re putting in the content of the file this way, the first line will be empty, and the column is also then the column you see in the editor, which should be <strong class="source-in ine">30</strong> with the <a id="_idIndexMarker757"/>method indented. You could improve this by embedding files as embedded resources that you could then maintain separately and have a more predictable setup for. The <strong class="source-in ine">VerifyAnalyzerAsync()</strong> method is then called with the content and <span class="No-Break">the expectations.</span></p>
			<p>That’s the tests we want to perform for the analyzer at this point. But we do also ha<a id="_idTextAnchor319"/>ve a code fix for <span class="No-Break">the analyzer.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor320"/>Code fix tests</h1>
			<p>As with the <a id="_idIndexMarker758"/>analyzer, you can create tests specific to code fixes. It uses a different verifier than the analyzer: <strong class="source-in ine">CodeFixVerifier</strong>. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Add a file called <strong class="source-in ine">CodeFixTests</strong> within the <strong class="source-in ine">ExceptionShouldNotBeSuffixed</strong> folder in the <strong class="source-in ine">Roslyn.Extensions.Test</strong> project folder. Then add a file called <strong class="source-in ine">CodeFixTests.cs</strong> and add the following content <span class="No-Break">to it:</span><pre class="console">
namespace Roslyn.Extensions.CodeAnalysis
  .ExceptionShouldNotBeSuffixed;
using Xunit;
using Verify = Microsoft.CodeAnalysis.Csharp
  .Testing.XUnit.CodeFixVerifier&lt;Analyzer, CodeFix&gt;;
public class CodeFixTests
{
}</pre></li>
			</ol>
			<p>As you did with <a id="_idIndexMarker759"/>the analyzer tests, you used a verifier. For code fixes, it is a different type of verifier: <strong class="source-in ine">CodeFixVerifier</strong>.</p>
			<p>The <strong class="source-in ine">CodeFixVerifier</strong> verifier needs two generic arguments, the first one representing the analyzer and the second representing the code fix being tested.</p>
			<ol>
				<li value="2">Add the following test method to the <span class="No-Break"><strong class="source-in ine">CodeFixTests</strong></span><span class="No-Break"> class:</span><pre class="console">
[Fact]
public async Task WithoutSuffix()
{
    const string content = @"
            using System;
            namespace MyNamespace;
            public class SomethingWentWrong :
              Exception
            {
            }
        ";
    await Verify.VerifyCodeFixAsync(content, content);
}</pre></li>
			</ol>
			<p>The code verifies that the code fix does not perform any actions when the C# program is a valid program that doesn’t break the rule.</p>
			<ol>
				<li value="3">Next, you need a test that verifies the code fix actually performs what is expected. Add the <a id="_idIndexMarker760"/>following method to the <span class="No-Break"><strong class="source-in ine">CodeFixTests</strong></span><span class="No-Break"> class:</span><pre class="console">
[Fact]
public async Task WithSuffix()
{
    const string content = @"
            using System;
            namespace MyNamespace;
            public class MyException : Exception
            {
            }
        ";
    var expected = Verify.Diagnostic().WithLocation(5,
      30).WithArguments("MyException");
    await Verify.VerifyCodeFixAsync(content, expected,
       content.Replace("MyException", "My"));
}</pre></li>
			</ol>
			<p>As with the analyzer test for the broken rule scenario, it sets up an expectation that there should be a compiler error at a specific location. Additionally, it then verifies that the code fix actually replaces the <strong class="source-in ine">MyException</strong> text by removing the suffix.</p>
			<ol>
				<li value="4">With tests for both the analyzer and the code fix in place, you can run these by running the <a id="_idIndexMarker761"/>following in your terminal within the <span class="No-Break"><strong class="source-in ine">Roslyn.Extensions.Tests</strong></span><span class="No-Break"> folder:</span><pre class="console">
<strong class="bo d">dotnet test</strong></pre></li>
			</ol>
			<p>You should then see something like the following:</p>
			<pre class="console">
<strong class="bo d">Microsoft (R) Test Execution Command Line Tool Version</strong>
<strong class="bo d">17.5.0 (arm64)</strong>
<strong class="bo d">Copyright (c) Microsoft Corporation.  All rights</strong>
<strong class="bo d">reserved.</strong>
<strong class="bo d">Starting test execution, please wait...</strong>
<strong class="bo d">A total of 1 test files matched the specified pattern.</strong>
<strong class="bo d">Passed!  - Failed:     </strong><strong class="bo d">0, Passed:     4, Skipped:</strong>
<strong class="bo d">0, Total:     4, Duration: 522 ms - Roslyn.Extensions</strong>
<strong class="bo d">.Tests.dll (net7.0)</strong></pre>
			<p>If you are using an editor that supports xUnit tests, chances are they are already visible in <a id="_idIndexMarker762"/>the test explorer of your editor, and you can run them from there as well.</p>
			<p>For a full overview of the <strong class="source-in ine">Microsoft.CodeAnalysis.Testing</strong> project, I recommend heading over to <span class="No-Break">GitHub (</span><a href="https://github.com/dotnet/roslyn-sdk/blob/main/src/Microsoft.CodeAnalysis.Testing/README.md"><span class="No-Break">https://github.com/dotnet/roslyn-sdk/blob/main/src/Micros<span id="_idTextAnchor321"/>oft.CodeAnalysis.Testing/README.md</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor322"/>Summary</h1>
			<p>In this chapter, we’ve covered the use of Roslyn compiler extensions for performing static code analysis in C#. We began by explaining what static code analysis is and how it differs from dynamic analysis, as well as its benefits and limitations. We then covered how to write custom analyzers using Roslyn, using diagnostics to report issues, and implementing code fixes to automatically <span class="No-Break">correct issues.</span></p>
			<p>We also discussed best practices for testing and maintaining code analysis tools, as well as how to build rules that are specific to your team and domain. Catching errors fast is crucial for minimizing development time and cost, and static code analysis is a powerful tool for achieving this. By detecting issues and bugs in your code before it’s even executed, you can avoid costly mistakes and improve overall code quality <span class="No-Break">and maintainability.</span></p>
			<p>You should now have a solid understanding of how to use Roslyn for static code analysis in C#, as well as the benefits and challenges of this approach. You should also understand how to write effective analyzers and code fixes and how to build custom rules for their specific team <span class="No-Break">and domain.</span></p>
			<p>Static code analysis is a powerful technique for catching errors quickly and improving overall code quality and maintainability. By building custom rules that are specific to your team and domain, you can ensure that your code is not only error-free but also conforms to your team’s standards and practices. This can save time and resources that would otherwise be spent on debugging and testing, allowing you to deliver higher-quality <span class="No-Break">software faster.</span></p>
			<p>This chapter concludes the practical sides of the book, and the next and final chapter will cover general caveats and some final words about everything discussed in <span class="No-Break">the book.</span></p>
		</div>
	</body></html>