- en: Interoperability with Win32 and WinForm
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Hosting WinForm controls in WPF applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting WPF controls in WinForm applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Win32 APIs from WPF applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding ActiveX controls in WPF applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **interoperability** describes the capability of different applications
    to exchange data via a common set of exchangeable formats. It is a characteristic
    of the product or system, whose interfaces are completely understood, to work
    with other products or systems.
  prefs: []
  type: TYPE_NORMAL
- en: WPF and Windows Forms present two different architectures for creating application
    interfaces. The `WindowsFormsHost` and `ElementHost` classes are used to implement
    the interoperation capabilities between these two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, WPF provides interoperability with Win32 programs, which are written
    in unmanaged C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a955b43-8436-49ad-a54f-f6832f9ef5d3.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will start with interoperation between WPF and WinForm,
    demonstrating the way to host a WinForm control in a WPF application and a WPF
    control in a WinForm application. Then, we will move forward to learn interoperability
    between WPF and Win32, followed by embedding ActiveX controls inside WPF.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting WinForm controls in WPF applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though **Windows Platform Foundation** (**WPF**) provides a huge set of controls
    with a rich set of features, there can still be chances of various cases when
    you have some **Windows Form** (**WinForm**) controls that are not available in
    WPF. There could be some cases too, when you are porting your WinForm application
    to WPF, where you have no other choice than reusing existing controls and/or forms,
    as the reimplementation will burn huge efforts. So, what needs to be done in such
    cases?
  prefs: []
  type: TYPE_NORMAL
- en: WPF provides a way to reuse existing controls from Windows Forms and host them
    inside it (whether in a control, a window, or a page). This is called interoperation
    between the two platforms as they present two different architectures for creating
    application interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Windows.Forms.Integration` namespace provides you with the classes
    that enable the common interoperation scenarios, whereas the `WindowsFormsHost`
    class provides you with the capability to implement the interoperation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing interoperation between the two technologies to host a Windows
    Forms control inside WPF, the following scenarios may occur applicable:'
  prefs: []
  type: TYPE_NORMAL
- en: One or more WinForm controls can be hosted in WPF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more composite controls can be hosted in a WPF element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more ActiveX controls can also be hosted in WPF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WinForm container controls containing other WinForm controls can also be
    hosted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also host a master/detail form with WPF as master, WinForm as details,
    and/or WinForm as master, and WPF as details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A point to note is that multilevel hybrid controls are not supported. A **multilevel
    hybrid control** contains a control from one technology inside a control from
    another technology.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take WinForm's `PropertyGrid` control as an example,
    which is not available in WPF, and will host it inside a WPF window using the
    `WindowsFormsHost` control.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating a new WPF application. Open your Visual Studio IDE,
    and create a new project named `CH11.WinFormInWpfXamlDemo`. Make sure to select
    WPF App as the project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to host a WinForm control inside a WPF application window
    and map its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin with opening the WPF application window. From Solution Explorer, open
    the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s split the default `Grid` panel to have two columns. The second column
    will have a width based on its child elements, and the first column will accommodate
    the rest of the space. Add the following XAML mark-up inside `Grid` to split it
    by the specific requirement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Place a `TextBlock` control inside the first cell (0^(th) column) of `Grid`,
    name it as `txtBlock`, and set `Hello World!` as its `Text` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after the `TextBlock` control, add a `<WindowsFormsHost> </WindowsFormsHost>`
    element. When added, this will throw the following design-time error messageâ€”WindowsFormsHost
    is not supported in a Windows Presentation Foundation (WPF) project. This is because
    the required assembly to resolve the `WindowsFormsHost` element is not referenced
    in this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad6839aa-df5f-4164-8fc9-085f7bb081cb.png)'
  prefs: []
  type: TYPE_IMG
- en: To add the dependent assembly references in the project, right-click on the
    project node and select Add | Reference... from the context menu entries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Reference Manager dialog window, check the following two assembly
    references (System.Windows.Forms and WindowsFormsIntegration) and click OK, which
    will add the references in the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa791620-0266-4ab1-87b6-6ead98c6e89f.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the XAML file now. The preceding design-time error will now go away, as
    the required assembly reference has been established.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the `<WindowsFormsHost>` in the second column (`Grid.Column="1"`) and
    set its `Width` property to `300`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, inside the `WindowsFormsHost` element, place another element of type `PropertyGrid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You need to add the XMLNS namespace for the `PropertyGrid` to resolve from
    the `System.Windows.Forms` assembly. As shown in the following screenshot, click
    the lightbulb icon, or simply press *CTRL +* to add the required XMLNS entry to
    the `MainWindow.xaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c81326c-b495-4a67-a651-228715a18d0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can add the following XMLNS declaration to the `Window`
    tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `x:Name="propertyGrid"` to the `PropertyGrid` element to define it with
    a name. This will be useful later when we want to access it from the code. Here''s
    the complete XAML markup of the `Grid` that we will be using here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, let''s run the application. You will see the following output, having
    text and an empty property grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dedc978f-07d7-4a35-a9f9-121cd026d1b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's navigate to the code behind file (`MainWindow.xaml.cs`) of the application
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just after the `InitializeComponent()` call inside the constructor of `MainWindow`,
    add the following line, `propertyGrid.SelectedObject = txtBlock;`, to set the
    `SelectionObject` property of the property grid that we have already added in
    the UI. After this change, the code will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application again. This time you will see that the property
    grid contains a set of properties, pointing to the `txtBlock` control placed in
    the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/40af7fae-9137-4880-8fd5-af19c60a5bfa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scroll up the property grid and change the FontSize property inside the grid
    to `40`. This will have immediate effect to the font-size of the text that we
    have added in the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06b8a6e8-b9ae-4102-a59a-08fc1ce367be.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, change some other properties such as HorizontalAlignment, VerticalAlignment,
    FontStyle, FontWeight, Foreground, and so on, and see the effect on the screen:![](img/41f289b2-2629-4ce7-abfb-834d1d555a24.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PropertyGrid` control, part of the .NET Framework, allows you to browse,
    view, and edit the properties of one or more objects. It uses reflection to retrieve
    and display properties of any object or type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reflection** is a technology that allows you to retrieve the type information
    at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using WinForm, you will be able to use the `PropertyGrid` control
    easily from the control toolbar. But, unfortunately, this control is not available
    in WPF. To use this inside a WPF application, you will need to use the interoperability
    of WPF and WinForm. For this to work, we need to use the `WindowsFormsHost` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `WindowsFormsHost` class allows you to host a Windows Forms control on a
    WPF page. It is part of the `System.Windows.Forms.Integration` namespace and it
    is available inside the `WindowsFormsIntegration.dll` assembly. That's the reason
    why we had to reference the `System.Windows.Forms` and `WindowsFormsIntegration`
    assemblies inside the project.
  prefs: []
  type: TYPE_NORMAL
- en: The default location for the `WindowsFormsIntegration.dll` assembly is `%programfiles%Reference
    AssembliesMicrosoftFrameworkv3.0`, which comes with the other WPF assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Once the hosting of the WinForm control is successful inside a WPF window, you
    can then set/get its properties. In the preceding example, we assigned the `txtBlock`
    control (which is a WPF control) as the `SelectedObject` property of the `propertyGrid`
    control (which is a WinForm control). Thus, when you run the application, it uses
    reflection to retrieve all the properties exposed by the `TextBlock` control (`txtBlock`)
    and populates those inside the `PropertyGrid` with the default values set to each
    one of them. When you modify a property value at runtime, it changes the associated
    control based on the selection. Hence, you can see a change in the UI of `TextBlock`,
    when you change the `FontSize`, `Foreground`, and other properties.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though most of the properties work with `WindowsFormsHost`, there are some limitations
    with **z-order** and transformations when used in a hybrid application. By default,
    the `WindowsFormsHost` elements are drawn on top of other WPF elements, and thus
    there exists no-effect of the z-order property on that.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to enable z-ordering, set the `IsRedirected` property of the `WindowsFormsHost`
    to `True`, and the `CompositionMode` property to either `CompositionMode.Full`
    or `CompositionMode.OutputOnly`.
  prefs: []
  type: TYPE_NORMAL
- en: As the WinForm controls do not support proper scaling and rotating features,
    the `WindowsFormsHost` element does not scale or rotate with other WPF elements.
    To enable these transforming features, such as z-ordering, set the `IsRedirected`
    property to `True` and the `CompositionMode` property to either `CompositionMode.Full`
    or `CompositionMode.OutputOnly`.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting WPF controls in WinForm applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As WPF provides a rich user interface to applications, you may want to apply
    the same to your existing applications. But when you have a large Windows Form
    application project, where you already made a large investment, you won't like
    to reinvest on the same to scrap it and rewrite the entire project in WPF.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, WPF interoperation with WinForms is ideal. Using this, you can
    embed a WPF control inside a form and leverage the additional features of WPF,
    wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to host WinForm controls into a WPF application.
    But in this recipe, we will learn the reverse, that is, how to host a **WPF composite
    control** in a **Windows Forms** application. We will learn this by following
    some simple walkthrough steps. You can extend this procedure later to host more
    complex applications and controls.
  prefs: []
  type: TYPE_NORMAL
- en: This walkthrough will basically be divided into two logical parts. In the first
    part, we will build a WPF UserControl, and in the second part, we will host it
    inside a form window.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start with this recipe to host a WPF control in a Windows Form, make
    sure that Visual Studio is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to create a WPF composite control and host it inside
    the Windows Form:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create a **WPF User Control Library** project. To do this, from
    Solution Explorer, right-click on the existing solution and select Add | New Project...
    from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select WPF User Control Library (.NET Framework) as the project template, name
    it as `CH11.WpfUserControlLibrary`, and click the OK button, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d503d6b6-8e16-4829-9585-75f93348ee2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the project gets created by Visual Studio, you will find a user control
    named `UserControl1.xaml`, inside the project folder. From Solution Explorer,
    double-click on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Divide the default `Grid` of the `UserControl1` into two columns. Set the first
    column as stretchable to occupy maximum available space and set the second column
    as `Auto`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Place a `TextBox` control inside the first column and name it as `searchBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Place a `Button` control, named `searchButton`, and place it inside the second
    column of the `Grid`. Set its `Content` property to Search and register its `Click`
    event with `OnSearchButtonClicked`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete XAML of `Grid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, press *F7* to navigate to the code behind the `UserControl1.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following event implementation inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to integrate the created user control inside a Windows Form.
    For this, we need a WinForm project. Let''s add the new project inside the solution.
    To do this, from Solution Explorer, right-click on the solution file and select
    Add | New Project... from the context menu. Use the following Windows Forms App
    (.NET Framework) template during project creation. Name it as `CH11.WpfInWinFormDemo`
    and click the OK button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/93863ea5-9950-4f1a-a495-ca0c8b9bc5e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the project gets created, you need to add the reference of the UserControl
    Library into this project. To do so, right-click on the References node of the
    `CH11.WpfInWinFormDemo` project and then click Add Reference... from the context
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Reference Manager dialog, as shown in the following screenshot, expand
    the Projects entry, select the desired library project (in our case, it is CH11.WpfUserControlLibrary),
    and click OK. This will add the reference of the library into the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3f3fab58-6c54-4f50-af77-3a04b9b3bfe7.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, add the following assembly referencesâ€”`PresentationCore`, `PresentationFramework`,
    `System.Xaml`, `WindowsBase`, and `WindowsFormsIntegration` inside the project.
    These are required to use WPF controls and host them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebuild the solution and make sure that the solution is building without any
    errors. This step also ensures that the library project gets compiled and becomes
    discoverable in the main project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From Solution Explorer, double-click on the `Form1.cs` file to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the Toolbox, and as shown in the following screenshot, drag the ElementHost
    element to the form (`Form1.cs`), from the WPF Interoperability section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/56707bef-7d48-49df-a0ed-6775ede02851.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expand the small arrow-head of the `ElementHost` element to select the hosted
    content. As shown in the following screenshot, click on the Select Hosted Content
    combo and select UserControl1 to host inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/790bf580-b88a-4f97-a0f4-610b7444a53a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can also drag UserControl1 from the toolbox. In this case,
    Visual Studio will add the `ElementHost` and configure it to load the UserControl
    that you have dragged to the form. Once done, resize the control and position
    it inside the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f7cb1f72-94f8-4bb4-8657-0a2f1cba0ac8.png)'
  prefs: []
  type: TYPE_IMG
- en: Now rebuild the solution again and run the form application (`CH11.WpfInWinFormDemo`).
    You will see a form window on the screen, containing the WPF UserControl that
    we have created. It basically consists of a `TextBox` and a `Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter some text in the search box and click the button. You will see the message
    box pop up on the screen, containing the text that you have entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a0e2448a-1224-40bb-86e5-fe80394dc819.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To host the **WPF composite control**, the `ElementHost` object is used inside
    the Windows Forms host application. The `ElementHost` class is part of the `System.Windows.Forms.Integration`
    namespace, and thus you will need to reference the `WindowsFormsIntegration.dll`
    in the project.
  prefs: []
  type: TYPE_NORMAL
- en: To host a WPF element in a Windows Form, you must assign it to the `Child` property
    of the `ElementHost` control. If it is required, use the `PropertyMap` property
    to assign the custom mappings between an `ElementHost` and its hosted WPF element.
    Optionally, you can use the boolean `BackColorTransparent` property to set a transparent
    background to the hosted element.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Win32 APIs from WPF applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Presentation Foundation and Win32 interpolation can work as different
    approaches. You can either host a Win32 application in a WPF application, a WPF
    application in a Win32 application, or call a Win32 API from WPF by importing
    the specified system DLL. These are often useful when you have already invested
    a lot in Win32 applications and now you would like to build a rich WPF application
    by utilizing the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to call a Win32 API from a WPF. We will use
    a simple example to launch a browser window and then activate/refresh the browser
    window from our WPF code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get started by creating a WPF application. Open your Visual Studio IDE, and
    create a new project named `CH11.Win32ApiCallDemo`. Make sure to select WPF App
    (.NET Framework) as the project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to give a call to Win32 APIs from WPF applications:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set up the project. Once the project gets created by Visual
    Studio, right-click on the References node of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the context menu entry Add Reference... to add assembly references.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Reference Manager dialog, search for forms, and select System.Windows.Forms
    from the list. Click OK to add the reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/527e8f84-db19-4208-ada0-bf771ca78cdc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, from Solution Explorer, navigate to the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing `Grid` panel with the following markup, which contains
    a `TextBox` (`address`) and three `Button` controls (`goButton`, `bringToFrontButton`,
    and `refreshButton`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once the UI is ready, it's time to create the button click event implementations.
    Press *F7* within the XAML page to navigate to its code behind. Alternatively,
    you can open the `MainWindow.xaml.cs` file from Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the code behind the file, add the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `MainWindow` class, add the following declarations and make
    sure that the `DllImport` attribute and the `Process` class are discoverable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `OnGoClicked` event handler. Copy the following code to
    launch Internet Explorer with the specified URL address, which is `http://www.kunal-chowdhury.com`
    in our case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `OnBringToFrontClicked` event handler to bring the launched
    Internet Explorer window to the front, if it lost its focus. Copy the following
    code to get the `MainWindowHandle` of the process instance and call the Win32
    API method, `SetForegroundWindow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the event implementation of the Refresh button. Add the following
    `OnRefreshClicked` handler inside the class file to activate the Internet Explorer
    window and then call the *F5* key of the keyboard to refresh the said browser
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As the code implementation is done, let's run the application. You will see
    the following UI on the screen:![](img/6187bcb6-2f5c-4a23-bf9d-e1f2e6405b5c.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the address field of the application is already populated, click on the
    Go... button. This will launch Internet Explorer and will navigate to the address
    specified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b8b57c2c-0eda-402e-9fdf-d3b434e03db9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on the application window. This will bring the application to the
    front.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click the BringToFront button, which will activate Internet Explorer and
    bring it to the front.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, click on the application window, and then click on the Refresh button.
    This time, Internet Explorer will activate and refresh the content of the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f86b8888-e7a2-486c-9f13-70f57861c619.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you click the Go... button of the application window, this creates the
    new process of the Internet Explorer (`iexplore.exe`) window and opens the URL
    specified to the process as its `Arguments`, once we call the `process.Start()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: When you click the BringToFront button, it retrieves the handle of the main
    window of the process and passes it as parameter to the `SetForegroundWindow`
    Win32 API method. The said API method brings the thread into the foreground and
    activates the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'A process can set the foreground window only if one of the following conditions
    is satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: The process itself is a foreground process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was started by a foreground process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process is being debugged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foreground process is not a Modern Application or the Start screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No menus are active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DllImport` attribute indicates that the attributed method is exposed by
    an unmanaged **dynamic-link library** (**DLL**) as a static entry point. In our
    case, it's the `User32.dll` file.
  prefs: []
  type: TYPE_NORMAL
- en: When you click on the Refresh button, just like the BringToFront button, it
    first activates the Internet Explorer window by bringing it to the front. The
    keyboard input is then being directed to the window.
  prefs: []
  type: TYPE_NORMAL
- en: Note that an application can't force a window to the foreground if the user
    is working on another window. In this case, the window will flash in the task
    bar to notify the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `SendKeys.SendWait("{F5}")` method call sends the given key (*F5*, in our
    case) to the active application, and then waits for the messages to be processed.
    As we have passed the *F5* key here, it will call the `refresh` method of the
    browser. Make sure that `System.Windows.Forms` is properly referenced in the project,
    for the `SendKeys.SendWait` method to work.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding ActiveX controls in WPF applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WPF also supports **ActiveX**, which you can easily embed in a WPF application.
    This is not feature specific to WPF, but it works because of interoperability
    with Windows Forms. The WinForm acts as an intermediate layer between the two.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ActiveX controls present, which can be easily embedded in
    any WPF application. In this recipe, we will learn how to embed an ActiveX control
    by following some simple steps. We will demonstrate it using the **Microsoft Terminal
    Services Control** that ships with Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure Visual Studio is up and running. Create a new WPF project and name
    it as `CH11.ActiveXDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to generate the required libraries for the **Microsoft Terminal
    Services ActiveX** control and embed it inside our WPF application:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to generate the required libraries of our ActiveX control.
    This is required to get a managed and Windows Forms compatible definition of the
    relevant type. To do this, open **Visual Studio Developer Command Prompt** and
    navigate to an empty folder (let's say, `D:libs`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the Command Prompt, enter the following command to generate the managed
    definitions of the Terminal Service DLL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will generate two DLL files, named `MSTSCLib.dll` and `AxMSTSCLib.dll`,
    in the same folder (`D:libs`, in our case):![](img/7c71dc2d-ae3a-4cc3-a80b-9c3dee2c8e61.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's copy those DLLs in our project folder. Create a folder named `libs`, inside
    the root folder of our project, and copy both files there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add the references of those binaries into our project. Navigate back to
    Visual Studio, and from Solution Explorer, right-click on the References node.
    Then, click Add Reference... from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Reference Manager dialog window, click Browse... to add the references.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select both MSTSCLib.dll and AxMSTSCLib.dll, as shown in the following screenshot
    and click Add, which will add the selection to the Reference Manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f1cbf53-5796-4072-9867-92105f2914ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Search for `forms`, inside the Reference Manager dialog, and select System.Windows.Forms
    and WindowsFormsIntegration dlls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to confirm adding the references of the four assembly files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open the `MainWindow.xaml` file and add the following XMLNS attribute to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <Grid>
  prefs: []
  type: TYPE_NORMAL
- en: <WindowsFormsHost>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <lib:AxMsTscAxNotSafeForScripting
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: x:Name="terminal"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Height="500" Width="1000"/>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </WindowsFormsHost>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Grid>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: terminal.Server = "192.168.0.10";
  prefs: []
  type: TYPE_NORMAL
- en: terminal.Connect();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
