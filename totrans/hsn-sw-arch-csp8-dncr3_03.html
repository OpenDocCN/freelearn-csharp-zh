<html><head></head><body>
        

                            
                    <h1 class="header-title">Functional and Nonfunctional Requirements</h1>
                
            
            
                
<p>Once you have gathered the system requirements, it is time to think about the impact they have on the architectural design. Scalability, performance, multithreading, interoperability, and other subjects need to be analyzed so that we can meet user needs.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400">What is scalability and how does it interact with Azure and .NET Core?</li>
<li style="font-weight: 400">Good tips for writing better code when it comes to performance improvement</li>
<li style="font-weight: 400">Creating a safe and useful multithreading software</li>
<li>Software usability, that is, how to design effective user interfaces</li>
<li style="font-weight: 400">.NET Core and interoperability</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The samples provided in this chapter will require Visual Studio 2019 Community Edition or Visual Studio Code.</p>
<p>You can find the sample code for this chapter here: <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch02">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch02</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How does scalability interact with Azure and .NET Core?</h1>
                
            
            
                
<p>A short search on scalability returns a definition such as <em>the ability of a system to keep working well when there's an increase in demand</em>. Once developers read this, many of them incorrectly conclude <em>that scalability only means add more hardware to keep things working without stopping the app</em>.</p>
<p>Scalability relies on technologies involving hardware solutions. However, as a software architect, you have to be aware that good software will keep scalability in a sustainable model, which means that a well-architected software can save a lot of money. Hence, it is not just a matter of hardware but also a matter of overall software design.</p>
<p>In <a href="14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml">Chapter 1</a>, <em>Understanding the Importance of Software Architecture</em>, while discussing software performance, we proposed some good tips to overcome bad performance issues. The same tips will help you with scalability too. The fewer resources we spend on each process, the more users the application can handle.</p>
<p>It is worth knowing that Azure and .NET Core web apps can be configured to handle scalability too. Let's check this out in the following subsections.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a scalable web app in Azure</h1>
                
            
            
                
<p>It is pretty simple to create a web app in Azure, ready for scaling. The reason why you have to do so is to be able to maintain different amounts of users during different seasons. The more users you have, the more hardware you will need. The following steps will show you how to create a scalable web application in Azure:</p>
<ol>
<li>As soon as you log in to your Azure account, you will be able to create a new resource (web app, database, virtual machine, and so on), as you can see in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e9d04d4-4cde-4373-b4c3-e37a870c504b.png" style="width:40.75em;height:40.17em;"/></p>
<ol start="2">
<li>After that, you can select Web App. This tutorial will take you to the following screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6c7100ab-983a-439c-8de1-31190c059b43.png" style="width:37.25em;height:45.50em;"/></p>
<p>The required details are as follows:</p>
<ul>
<li>App name: As you can see, this is the URL that your web app will assume after its creation. The name is checked to ensure it is available.</li>
<li>Subscription: This is the account that will be charged for all application costs. </li>
<li>Resource Group: This is the collection of resources you can define to organize policies and permissions. You may specify a new resource group name or add the web app to a group specified during the definition of other resources.</li>
<li>OS: This is the operating system that will host the web app. Both Windows and Linux may be used for ASP.NET Core projects.</li>
<li>Publish: This parameter indicates whether the web app will be delivered directly or whether it is going to use Docker technology to publish content. Docker will be discussed in more detail in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application.</em></li>
<li>App Service Plan/Location: This is where you define the hardware plan that's used to handle the web app and the location of the servers. This choice defines application scalability, performance, and costs.</li>
<li>Application Insights: This is a useful Azure toolset for monitoring and troubleshooting web apps. </li>
</ul>
<p>Applications may be scaled in two conceptually different ways:</p>
<ul>
<li>Vertically (Scale up)</li>
<li>Horizontally (Scale out)</li>
</ul>
<p class="mce-root"/>
<p>Both of them are available in the web app settings, as you can see in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0626f955-69b8-4ade-9e81-3683d9ed56d7.png"/></p>
<p>Let's checkout the two types of scaling.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Vertical scaling (Scale up)</h1>
                
            
            
                
<p>Scale up means changing the type of hardware that will sustain your application. In Azure, you have the opportunity of starting with free-shared hardware and moving to an isolated machine in a few clicks.</p>
<p>By selecting this option, you have the opportunity to select more powerful hardware (machines with more CPUs, storage, and RAM). The following screenshot shows the user interface for scaling up a web app:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1ccf3faa-5d47-4f59-97a7-25e7b14cc979.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Horizontal scaling (Scale out)</h1>
                
            
            
                
<p>Scaling out means splitting all requests among more servers with the same capacity instead of using more powerful machines. The load on all the servers is automatically balanced by the Azure infrastructure. This solution is advised when the overall load may change considerably in the future since horizontal scaling can be automatically adapted to the current load. The following screenshot shows an automatic Scale out strategy defined by two simple rules, which is triggered by CPU usage:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/084e5d5c-ef10-4dfd-8ddc-3bcb321f683d.png"/></p>
<p>A complete description of all the available auto scale rules is beyond the purpose of this book. However, they are quite self-explanatory and the <em>Further reading</em> section contains links to the full documentation.</p>
<p>The Scale out feature is only available in paid service plans.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a scalable web app with .NET Core</h1>
                
            
            
                
<p>Among all the available frameworks for implementing web apps, ASP.NET Core ensures good performance, together with low production and maintenance costs. ASP.NET Core performance is comparable with the performance of Node.js, but production and maintenance costs are lower because of the usage of C# (which is a strongly typed and advanced pure object language) instead of JavaScript.</p>
<p>The steps that follow will guide you through the creation of an ASP.NET Core-based web app. All the steps are quite simple, but some details require particular attention.</p>
<p>First of all, during the web app's creation, you can choose between .NET Core Framework and .NET Framework. Pay attention, because only .NET Core can run on both Windows and cheaper Linux servers, while classic .NET runs only on Windows servers. On the other hand, with classic .NET, you will have access to a larger code base of legacy libraries that include both Microsoft and third-party packages.</p>
<p>Nowadays, Microsoft recommends classic .NET, just in case the features you need are not available in .NET Core, or even when you deploy your web app in an environment that does not support .NET Core. In any other case, you should prefer .NET Core Framework because it allows you to do the following:</p>
<ul>
<li>Run your web app in Windows, Linux, or Docker containers</li>
<li>Design your solution with microservices</li>
<li>Have high performance and scalable systems</li>
</ul>
<p>Containers and microservices will be covered in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>. There, you'll get a better understanding of the advantages of these technologies. For now, it is enough to say that .NET Core and microservices were designed for performance and scalability, which is why you should prefer .NET Core in all of your new projects.</p>
<p>The following steps will show you how to create an ASP.NET Core web app in Visual Studio 2019 with .NET Core 3.0:</p>
<ol>
<li>Once you select ASP.NET Core Web Application, you will be directed to a screen where you will be asked to set up the Project name, Location, and Solution name:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5b160782-ca4c-48e7-a573-3e0e35990dc8.png" style="width:36.58em;height:26.25em;"/></p>
<ol start="2">
<li>After that, you will be able to select the .NET Core version to use. At the time of writing, .NET Core 3.0 was still in its Preview 1 version.</li>
<li>Now that we are done with adding the basic details, you can connect your web app project to your Azure account and have it published.</li>
</ol>
<ol start="4">
<li>In the Solution Explorer, you have the option to Publish... if you right-click anywhere in there:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5c431af5-0c1b-421d-b84d-e1e86330d050.png"/></p>
<ol start="5">
<li>After you select the Publish... menu item, you will be able to connect your Azure account and then select the web app you wish to deploy:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/41b66c52-c29c-46a2-807a-70b29620b0c2.png" style="width:38.92em;height:16.58em;"/></p>
<ol start="6">
<li>There is full integration between Visual Studio and Azure. This gives you the opportunity to view all the resources you created in the Azure Portal in your development environment:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f0e01e35-c1eb-4516-92dd-cc68034c3637.png" style="width:39.58em;height:20.75em;"/></p>
<ol start="7">
<li>Once you've decided on your publish settings, that is, your publish profile, the web app is automatically published when you click OK:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/443b5d84-b2dd-466e-8e6c-65758d394f94.png" style="width:36.42em;height:14.75em;"/></p>
<p>For publishing .NET Core Preview versions, you have to add an extension in the web app setup panel in Azure portal, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b5f79141-0422-4dee-9836-1fb169a2ad0c.png"/></p>
<p>For more information on deploying ASP.NET Core 3.0 to Azure App Service, please take a look at this link: <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service">https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service</a>.</p>
<p>Here, we described the simplest ways to deploy a web app. <a href="b444cf5c-311d-4f74-80b0-0e86c0c13307.xhtml">Chapter 17</a>, <em>Deploying Your Application with Azure DevOps,</em> will introduce you to the Azure DevOps <strong>Continuous Integration/Continuous Delivery</strong> (<strong>CI/CD</strong>) pipeline. This pipeline is a further Azure toolset that automates all the required steps to get the application in production, that is, build, testing, deployment in staging, and deployment in production.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performance issues that need to be considered when programming in C#</h1>
                
            
            
                
<p>Nowadays, C# is one of the most used programming languages all over the world, so good tips about C# programming are fundamental for the design of good architectures that satisfy the most common non-functional requirements.</p>
<p>The following sections mention a few simple but efficacious tips—the associated code samples are available in the GitHub repository of this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">String concatenation</h1>
                
            
            
                
<p>This is a classic one! A naive concatenation of strings with the <kbd>+</kbd> string operator may cause serious performance issues since each time two strings are concatenated, their contents are copied into a new string.</p>
<p>So, if we concatenate, say, 10 strings that have an average length of 100, the first operation has a cost of 200, the second one has a cost of <em>200+100=300</em>, the third one has a cost of 300+100= 400, and so on. It is not difficult to convince yourself that the overall cost grows like <em>m*n2</em>, where <em>n</em> is the number of strings and <em>m</em> is their average length. <em>n2</em> isn't too big for small <em>n</em> (say, <em>n</em> &lt; 10), but it becomes quite big when <em>n</em> reaches the magnitude of 100-1,000, and actually unacceptable for magnitudes of 10,000-100,000.</p>
<p>Let's take a look at this with some test code, which compares naive concatenation with the same operation that's performed with the help of the <kbd>StringBuilder</kbd> class (the code is available in this book's GitHub repository):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1711e2df-6610-4cc5-a45c-8592b91d0e20.png" style="width:44.58em;height:18.33em;"/></p>
<p>If you create a <kbd>StringBuilder</kbd> class with something like <kbd>var sb =new System.Text.StringBuilder()</kbd>, and then you add each string to it with <kbd>sb.Append(currString)</kbd>, the strings are not copied; instead, their pointers are queued in a list. They are copied in the final string just once, when you call <kbd>sb.ToString()</kbd> to get the final result. Accordingly, the cost of <kbd>StringBuilder</kbd>-based concatenation grows simply as <em>m*n</em>.</p>
<p>Of course, you will probably never find a piece of software with a function like the preceding one that concatenates 100,000 strings. However, you need to recognize pieces of code similar to these ones where the concatenation of some 20-100 strings, say, in a web server that handles several requests simultaneously, might cause bottlenecks that damage your non-functional requirements for performance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exceptions</h1>
                
            
            
                
<p>Always remember—exceptions take too much time to be handled! So, the usage of <kbd>try-catch</kbd> needs to be concise and essential; otherwise, you will create big performance issues.</p>
<p>The following two samples compare the usage of <kbd>try-catch</kbd> and <kbd>Int32.TryParse</kbd> to check whether a string can be converted into an integer, as follows:</p>
<pre>private static string ParseIntWithTryParse()<br/>{<br/>    string result = String.Empty;<br/>    int value;<br/>    if (Int32.TryParse(result, out value))<br/>        result = value.ToString();<br/>    else<br/>        result = "There is no int value";<br/>    return $"Final result: {result}";<br/>}<br/><br/>private static string ParseIntWithException()<br/>{<br/>    string result = String.Empty;<br/>    try<br/>    {<br/>        result = Convert.ToInt32(result).ToString();<br/>    }<br/>    catch (Exception)<br/>    {<br/>        result = "There is no int value";<br/>    }<br/>    return $"Final result: {result}";<br/>}</pre>
<p>The second function doesn't look dangerous, but it is thousands of times slower than the first one:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/422c9151-f741-489e-b71c-7b6a97295143.png" style="width:40.50em;height:16.25em;"/></p>
<p>To sum this up, exceptions must be used to deal with exceptional cases that break the normal flow of control, for instance, situations when operations must be aborted for some unexpected reasons, and control must be returned several levels up in the call stack.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multithreading environments for better results – do's and don'ts</h1>
                
            
            
                
<p>If you want to take advantage of all of the hardware that the system you're building provides, you have to use multithreading. This way, when a thread is waiting for an operation to complete, it can leave the CPU and other resources to other threads instead of wasting CPU time.</p>
<p>On the other hand, no matter how hard Microsoft is working to help with this, parallel code is not as simple as eating a piece of cake: it is error-prone and difficult to test and debug. The most important thing to remember as a software architect when you start considering using threads: <em>does your system require them?</em> Non-functional and some functional requirements will definitely answer this question for you. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As soon as you are sure that you need a multithreading system, you should decide on which technology is more adequate. There are a few options here, as follows:</p>
<ul>
<li><strong>Creating an instance of a System.Threading.Thread</strong>: This is a classic way of creating threads in C#. The entirety of the thread life cycle will be in your hands. This is good when you are sure about what you are going to do, but you need to worry about every single detail of the implementation. The resulting code is hard to conceive and debug/test/maintain. So, to keep development costs acceptable, this approach should be confined to a few fundamental performance critique modules.</li>
<li><strong>Programming using System.Threading.Tasks.Parallel and System.Threading.Tasks.Task classes</strong>: In the .NET Framework 4.0 versions, you can use parallel classes to enable threads in a simpler way. This is good because you don't need to worry about the life cycle of the threads you create, but it will give you less control about what is happening in each thread.</li>
<li><strong>Develop using asynchronous programming</strong>: This is for sure the easiest way to develop multithreading applications since you don't need to care about thread coordination and deadlocks are not possible. When an asynchronous method calls another asynchronous method, it goes in sleeping mode to avoid wasting resources until the called task returns. This way, asynchronous code mimics the behavior of classical synchronous code while keeping most of the performance advantages of general parallel programming.</li>
</ul>
<p style="padding-left: 60px">The overall behavior is deterministic and doesn't depend on the time taken by each task to complete, so non-reproducible bugs are not possible and the resulting code is easy to test/debug/maintain. Defining a method as an asynchronous task or not is the only choice left to the programmer; everything else is automatically handled by the runtime. The only thing you should be concern about is which methods should have asynchronous behavior.</p>
<p>Later on in this book, we will provide some simple examples of asynchronous programming. For more information about asynchronous programming and its related patterns, please check <em>Task-Based Asynchronous Patterns</em> in the Microsoft documentation (<a href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</a>).</p>
<p>No matter the option you choose, there are some do's and don'ts that, as a software architect, you have to pay attention to. These are as follows:</p>
<ul>
<li><strong>Do use concurrent collections</strong> (<kbd>System.Collections.Concurrent</kbd>): As soon as you start a multithreading application, you have to use these collections. The reason for this is that your program will probably manage the same list, dictionary, and so on from different threads. The use of concurrent collections is the only option for developing thread-safe programs.</li>
<li><strong>Do worry about static variables</strong>: It is not possible to say that static variables are prohibited in multithreading development, but you should pay attention to them. Again, multiple threads taking care of the same variable can cause a lot of trouble. If you decorate a static variable with the <kbd>[ThreadStatic]</kbd> attribute, each thread will see a different copy of that variable, hence solving the problem of several threads competing on the same value. However, <kbd>ThreadStatic</kbd> variables can't be used for extra-thread communications since values written by a thread can't be read by other threads.</li>
<li><strong>Do test system performance after multithreading implementations</strong>: Threads give you the ability to take full advantage of your hardware, but in some cases, badly written threads can waste CPU time just doing nothing! Similar situations may result in almost 100% CPU usage and unacceptable system slowdowns. In some cases, the problem can be mitigated or solved by adding a simple <kbd>Thread.Sleep(1)</kbd> call in the main loop of some threads to prevent them from wasting too much CPU time, but you need to test this. </li>
<li><strong>Do not consider multithreading easy</strong>: Multithreading is not as simple as it seems in some syntax implementations. While writing a multithreading application, you should consider things such as the synchronization of the user interface, threading termination, and coordination. In many cases, programs just stop working well due to a bad implementation of multithreading.</li>
<li><strong>Do not forget to plan the number of threads your system should have</strong>: This is really important for 32-bit programs. There is a limitation regarding how many threads you can have in 32-bit environments. You should consider this when you are designing your system.</li>
<li><strong>Do not forget to end your threads</strong>: If you do not have the correct termination procedure for each thread, you will probably have trouble with memory and handles leaks.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Usability – why inserting data takes too much time</h1>
                
            
            
                
<p>Scalability, performance tips, and multithreading are the main tools we can use to tune machine performance. However, the effectiveness of the system you design depends on the overall performance of the whole processing pipeline, which includes both humans and machines.</p>
<p>As a software architect, you can't improve the performance of humans, but you can improve the performance of man-machine interaction by designing an effective <strong>user interface</strong> (<strong>UI</strong>), that is, user interfaces that ensure a fast interaction with humans, which, in turn, means the following:</p>
<ul>
<li>The UI must be easy to learn to reduce the time that's needed for learning and time waste before the target users learn to operate quickly. This constraint is fundamental if UI changes are frequent, and for public websites that need to attract the greatest possible number of users. </li>
<li>The UI must not cause any kind of slowdown in data insertion; data insertion speed must be limited just by the user's ability to type, not by system delays or by additional gestures that could be avoided. </li>
</ul>
<p>The following are a few simple tips when it comes to designing <em>easy to learn</em> user interfaces:</p>
<ul>
<li>Each input screen must state its purpose clearly.</li>
<li>Use the language of the user, not the language of developers.</li>
<li>Avoid complications. Design the UI with the average case in mind; more complicated cases can be handled with extra inputs that appear only when needed. Split complex screens into more input steps.</li>
<li>Use past inputs to understand user intentions and to put users on the right paths with messages and automatic UI changes; for instance, cascading drop-down menus.</li>
<li>Error messages are not bad notes the system gives to the user, but they must explain how to insert correct input.</li>
</ul>
<p class="mce-root"/>
<p>Fast user interfaces result from efficacious solutions to the following three requirements:</p>
<ul>
<li>Input fields must be placed in the order they are usually filled, and it should be possible to move to the next input with the <em>Tab</em> or <em>Enter</em> key. Moreover, fields that often remain empty should be placed at the bottom of the form. Simply put, the usage of the mouse while filling a form should be minimized. This way, the number of user gestures is kept to a minimum. In a web application, once the optimal placement of input fields has been decided, it is enough to use the <kbd>tabindex</kbd> attribute to define the right way users move from one input field to the next with the <em>Tab</em> key.</li>
<li>System reactions to user inputs must be as fast as possible. In particular, error (or information) messages must appear as soon as the user leaves the input field. The simplest way to achieve this is to move most of the help and input validation logic to the client side so that system reactions don't need to pass through both communication lines and servers.</li>
<li>Efficacious selection logic. Selecting an existing item should be as easy as possible; for example, selecting one of some thousands of products in an offer must be possible with a few gestures and with no need to remember the exact product name or its barcode. The next subsection analyzes techniques we can use to increase complexity to achieve fast selection.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing fast selection logic</h1>
                
            
            
                
<p>When all the possible choices are in the order of magnitude of 1-50, the usual drop-down menu is enough. For instance, check the currency selection drop-down menu:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/64bf7d21-bbca-4f59-9a69-8c7777836a5e.png" style="width:4.67em;height:7.33em;"/> </p>
<p>When the order of magnitude is higher but less than a few thousand, an autocomplete that shows the names of all the items that start with the characters typed by the user is usually a good choice:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f74ec7cc-96e3-42e5-aa6d-4b48572c322d.png" style="width:7.50em;height:10.25em;"/></p>
<p>A similar solution can be implemented with a low computational cost since all the main databases can efficiently select strings that start with a given substring.</p>
<p>When names are quite complex, when searching for the characters that were typed in by the user, they should be extended inside each item string. This operation can't be performed efficiently with usual databases and requires ad hoc data structures.</p>
<p>Finally, when we are searching inside descriptions composed of several words, more complex search patterns are needed. This is the case, for instance, of product descriptions. If the chosen database supports full-text search, the system can search for the occurrence of several words that have been typed by the user inside all the descriptions efficiently.</p>
<p>However, when descriptions are made up of names instead of common words, it might be difficult for the user to remember a few exact names contained in the target description. This happens, for instance, with multi-country company names. In these cases, we need algorithms that find the best match for the character that was typed by the user. Substrings of the string that was typed by the user must be searched in different places of each description. In general, similar algorithms can't be implemented efficiently with databases based on indexes but require all the descriptions to be loaded in memory and ranked somehow against the string that was typed by the user.</p>
<p>The most famous algorithm in this class is probably the <strong>Levenshtein</strong> algorithm, which is used by most spell checkers to find a word that best fits the mistyped one by the user. This algorithm minimizes the Levenshtein distance between the description and the string typed by the user, that is, the minimum number of character removals and additions needed to transform one string into another.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The Levenshtein algorithm works great but has a very high computational cost. Now, we give a faster algorithm that works well for searching character occurrences in descriptions. Characters typed by the user don't need to occur consecutively in the description but must occur in the same order. Some characters may miss. Each description is given a penalty that depends on the missing characters and on how the occurrences of the characters typed by the user are far from the others. More specifically, the algorithm ranks each description with two numbers:</p>
<ul>
<li>The number of characters typed by the user that occurs in the description: The more characters contained in the description, the higher its rank.</li>
<li>Each description is given a penalty equal to the total distance among the occurrences of the characters typed by the user in the description.</li>
</ul>
<p>The following screenshot shows how the word <strong>Ireland</strong> is ranked against the string <strong>ilad</strong>, which was typed by the user:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cfd55e6c-1607-4a2d-8c4a-1a5677b8cc12.png" style="width:7.58em;height:4.83em;"/></p>
<p>The number of occurrences is four, while the total distance among characters occurrences is three.</p>
<p>Once all the descriptions have been rated they are sorted according to the number of occurrences. Descriptions with the same number of occurrences are sorted according to the lowest penalties. The following is an autocomplete that implements the preceding algorithm:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9c02622a-1350-4551-be69-4ea2b4e8eb5f.png" style="width:7.25em;height:9.67em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The C# code that ranks each description against the string typed by the user is as follows:</p>
<pre>public class SmartDictionary&lt;T&gt;<br/>{<br/>    ...<br/>    private Func&lt;T, string&gt; keyAccessor;<br/>    protected class Rater<br/>    {<br/>        public T Item;<br/>        public double Penalty=0;<br/>        public int FoundChars=0;<br/>    }<br/>    ...<br/>    protected Rater RateItem(string search, Rater x)<br/>    {<br/>        var toSearch = search.ToLower();<br/>        var destination = keyAccessor(x.Item).ToLower();<br/>        bool firstMatch = true;<br/>        for (var j = 0; j &lt; toSearch.Length; j++)<br/>        {<br/>            if (destination == string.Empty) return x;<br/>            var currChar = toSearch[j];<br/>            var index = destination.IndexOf(currChar);<br/>            if (index == -1) continue;<br/>            x.FoundChars++;<br/>            if (firstMatch)<br/>            {<br/>                x.Penalty += index;<br/>                firstMatch = false;<br/>                <br/>            }<br/>            else x.Penalty += index*1000;<br/>            if (index + 1 &lt; destination.Length)<br/>                destination = destination.Substring(index + 1);<br/>            else<br/>                destination = string.Empty;<br/>        }<br/>        return x;<br/>    }<br/>    ...<br/>}</pre>
<p>The item to rank is inserted in a <kbd>Rater</kbd> instance. Then, its string description is extracted by a <kbd>keyAccessor</kbd> function. After that, the code computes both character occurrences and occurrences in the total distance.</p>
<p>The full class code, along with a test console project, is available in this book's GitHub repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Selecting from a huge amount of items</h1>
                
            
            
                
<p>Here, huge doesn't refer to the amount of space needed to store the data, but to the difficulty the user has in remembering the features of each item. When an item must be selected from among more than 10,000-100,000 items, there is no hope to find it by searching for character occurrences inside a description. Here, the user must be driven toward the right item through a hierarchy of categories.</p>
<p>In this case, several user gestures are needed to perform a single selection. In other word, each selection requires interaction with several input fields. Once it's decided that the selection can't be done with a single input field, the simplest option is cascading drop-down menus, that is, a chain of drop-down menus whose selection list depends on the values that were selected in the previous drop-down menus.</p>
<p>For example, if the user needs to select a town located anywhere in the world, we may use the first drop-down menu to select the country, and once the country has been chosen, we may use this choice to populate a second one with all the towns in the selected country. A simple example is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/887f872b-d932-4737-965f-606bd1ad47a6.png" style="width:12.00em;height:9.33em;"/></p>
<p>Clearly, each drop-down menu can be replaced by an autocomplete when required due to having a high number of options.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If making the right selection can be done by intersecting several different hierarchies, cascading drop-down menus become inefficient too, and we need a filter form, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/47389640-dfa6-4283-9d0e-af7bf68564c5.png" style="width:23.58em;height:21.92em;"/></p>
<p>Now, let's understand interoperability with .NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The fantastic world of interoperability with .NET Core</h1>
                
            
            
                
<p>.NET Core brought Windows developers the ability to deliver their software into various platforms. And you, as a software architect, need to pay particular attention to this. Linux and macOS are no longer a problem for C# lovers—it's much better than that—they are really good opportunities to deliver to new customers. Therefore, we need to ensure performance and multi-platform support, two common non-functional requirements in several systems.</p>
<p>Both console applications and web apps designed with .NET Core in Windows are almost completely compatible with Linux and macOS, too. This means you do not have to build the app again to run it on these platforms. Also, very platform-specific behaviors now have multi-platform support, as shown, for instance, by the <kbd>System.IO.Ports.SerialPort</kbd><em> </em>class, which, starting from .NET Core 3.0, is on Linux.</p>
<p>Microsoft offers scripts to help you install .NET Core on Linux and macOS. You can find them at <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script">https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script</a>. Once you have the SDK installed, you just need to call <strong>dotnet</strong> the same way you do in Windows. </p>
<p class="mce-root"/>
<p>However, you must be aware of some features that are not fully compatible with Linux and macOS systems. For instance, no equivalent to the Windows Registry exists in these OSes and you have to develop an alternative yourself. If needed, an encrypted JSON config file can be a good option.</p>
<p>Another important point is that Linux is case-sensitive, while Windows is not. Please, remember this when you work with files. Another important thing is that the Linux path separator is different from the Windows separator. You can use the <kbd>Path.PathSeparator</kbd> property and all the other <kbd>Path</kbd> class methods to ensure your code is actually multi-platform.</p>
<p>Besides, you can also adapt your code to the underlying OS by using the runtime checks provided by .NET Core, as follows:</p>
<pre>using System;<br/>using System.Runtime.InteropServices;<br/><br/>namespace CheckOS<br/>{<br/>    class Program<br/>    {<br/>        static void Main()<br/>        {<br/>            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))<br/>                Console.WriteLine("Here you have Windows World!");<br/>            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))<br/>                Console.WriteLine("Here you have Linux World!");<br/>            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))<br/>                Console.WriteLine("Here you have macOS World!");<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a service in Linux</h1>
                
            
            
                
<p>The following script can be used to encapsulate a command-line .NET Core app in Linux. The idea is that this service works like a Windows Service. This can be really useful, considering that most Linux installations are command-line only and run without a user logged in:</p>
<ol>
<li>The first step is to create file that will run the command-line app. The name of the app is <kbd>app.dll</kbd> and it is installed in <kbd>appfolder</kbd>. The application will be checked every 5,000 milliseconds. This service was created on a CentOS 7 system. Using a Linux Terminal, you can type this:</li>
</ol>
<pre style="padding-left: 60px"><strong>cat &gt; sample.service &lt;&lt;EOF</strong><br/><strong>[Unit]</strong><br/><strong>Description=Your Linux Service</strong><br/><strong>After=network.target</strong><br/><strong>[Service]</strong><br/><strong>ExecStart=/usr/bin/dotnet $(pwd)/appfolder/app.dll 5000</strong><br/><strong>Restart=on-failure</strong><br/><strong>[Install]</strong><br/><strong>WantedBy=multi-user.target</strong><br/><strong>EOF</strong></pre>
<ol start="2">
<li class="mce-root">Once the file has been created, you have to copy the service file to a system location. After that, you have to reload <kbd>systemd</kbd> and enable the service so that it will restart on reboots:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>sudo cp sample.service /lib/systemd/system</strong><br/><strong>sudo systemctl daemon-reload </strong><br/><strong>sudo systemctl enable <em>sample</em></strong></pre>
<ol start="3">
<li class="mce-root">Done! Now, you can start, stop, and check the service using the following commands. The whole input that you need to provide in your command-line app is as follows:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Start the service<br/><strong>sudo systemctl start sample</strong><br/><br/># View service status<br/><strong>sudo systemctl status sample</strong><br/><br/># Stop the service<br/><strong>sudo systemctl stop sample<br/></strong></pre>
<p>Now that we've learned about a few concepts, let's learn how to implement them in our use case.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Book use case – understanding the main types of .NET Core projects</h1>
                
            
            
                
<p>The development of this book's use case will be based on various kinds of .NET Core Visual Studio projects. This section describes all of them. Let's select New project in the Visual Studio file menu. In the window that opens, all the .NET Core projects will be located under the .NET Core, .NET Standard, and Cloud items in the left-hand menu:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9897fec5-b7cd-41e5-8835-9db5c86f617c.png" style="width:7.50em;height:9.25em;"/></p>
<p>Most of them are available under .NET Core:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/91892c07-c0c3-4ce9-a574-b58b6fe2ca2e.png" style="width:16.50em;height:13.42em;"/></p>
<p>Here, we have a console project, a class library project, and various types of test projects, each based on a different test framework: xUnit, nUnit, and MSTest. Choosing among the various testing frameworks is just a matter of preference since all of them offer comparable features. Adding tests to each piece of software that composes a solution is a common practice and allows software to be modified frequently without jeopardizing its reliability.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Testing will be discussed in detail in <a href="c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml">Chapter 15</a>, <em>Testing Your Code with Unit Test Cases and TDD</em>, and <a href="e61b3c5d-3abd-4442-9c9c-e12fd3acedcc.xhtml">Chapter 20</a>, <em>Automation for Software Testing</em>. Finally, we have the ASP.NET Core application we already described in the <em>Creating a scalable web app with .NET Core</em> subsection. There, we defined an ASP.NET MVC application, but Visual Studio also contains project templates for projects based on RESTful APIs and the most important single-page application frameworks such as Angular, React, Vue.js, and the new Blazor framework based on WebAssembler. Some of them are available with the standard Visual Studio installation; others require the installation of a SPA package.</p>
<p>For each project type, we can choose the .NET Core version we would like to use. Under the .NET Standard menu item, we have only a class library project. .NET Standard class libraries are based on .NET standards instead of a specific .NET Core version so they are compatible with several .NET Core versions. For instance, libraries based on 2.0 standards are compatible with all .NET Core versions greater than or equal to 2.0, and with all .NET Framework versions greater than 4.6.</p>
<p>This compatibility advantage comes at the price of having less available features. However, features that are not a part of a standard can be added as references to additional library packages.</p>
<p>Finally, under the cloud menu, we have several more project types, but the only new project related to .NET Core is the Service Fabric Application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/72a033eb-6bf1-4da9-b7fd-3544d1f43541.png" style="width:25.50em;height:8.25em;"/></p>
<p>This allows us to define microservices. Microservice-based architectures allow an application to be split into several independent microservices. Several instances of the same microservice can be created and distributed across several machines to fine-tune the performance of each application part. Microservices will be described in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml"/><a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Functional requirements that describe system behavior must be completed with non-functional requirements that constrain system performance, scalability, interoperability, and usability. Performance requirements come from response-time and system load requirements. As a software architect, you should ensure you have the required performance with the minimum cost building efficient algorithms and taking full advantage of the available hardware resources with multithreading.</p>
<p>Scalability is the capability of a system to be adapted to an increasing load. Systems can be scaled vertically by providing more powerful hardware, or horizontally by replicating and load balancing the same hardware. The cloud, in general, and Azure, in particular, can help us implement strategies dynamically, with no need to stop your application.</p>
<p>Tools such as .NET Core that run on several platforms can ensure interoperability, that is, the capability of your software to run on different target machines and with different operating systems (Windows, Linux, macOS, Android, and so on).</p>
<p>Usability is ensured by taking care of the input field's order, the effectiveness of the item selection logic, and how easy your system is to learn.</p>
<p class="mce-root">In the next chapter, you will learn how Azure DevOps tools can help us when it comes to collecting, defining, and documenting our requirements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Which are the two conceptual ways to scale a system? </li>
<li>Can you deploy your web app automatically from Visual Studio to Azure?</li>
<li>What is multithreading useful for?</li>
<li>What are the main advantages of the asynchronous pattern over other multithreading techniques?</li>
<li>Why is the order of input fields so important?</li>
<li>Why is the .NET Core <kbd>Path</kbd> class so important for interoperability?</li>
<li>What is the advantage of a .NET standard class library over a .NET Core class library?</li>
<li>List the various types of .NET Core Visual Studio projects.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>The following are some books and links you may consider reading to gather more information about this chapter:</p>
<ul>
<li><a href="https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers">https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling">https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service">https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency">https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency</a></li>
</ul>


            

            
        
    </body></html>