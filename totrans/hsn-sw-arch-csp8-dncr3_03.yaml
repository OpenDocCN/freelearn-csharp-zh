- en: Functional and Nonfunctional Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have gathered the system requirements, it is time to think about the
    impact they have on the architectural design. Scalability, performance, multithreading,
    interoperability, and other subjects need to be analyzed so that we can meet user
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is scalability and how does it interact with Azure and .NET Core?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good tips for writing better code when it comes to performance improvement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a safe and useful multithreading software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software usability, that is, how to design effective user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core and interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The samples provided in this chapter will require Visual Studio 2019 Community
    Edition or Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter here: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch02](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch02).
  prefs: []
  type: TYPE_NORMAL
- en: How does scalability interact with Azure and .NET Core?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A short search on scalability returns a definition such as *the ability of a
    system to keep working well when there's an increase in demand*. Once developers
    read this, many of them incorrectly conclude *that scalability only means add
    more hardware to keep things working without stopping the app*.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability relies on technologies involving hardware solutions. However, as
    a software architect, you have to be aware that good software will keep scalability
    in a sustainable model, which means that a well-architected software can save
    a lot of money. Hence, it is not just a matter of hardware but also a matter of
    overall software design.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the
    Importance of Software Architecture*, while discussing software performance, we
    proposed some good tips to overcome bad performance issues. The same tips will
    help you with scalability too. The fewer resources we spend on each process, the
    more users the application can handle.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth knowing that Azure and .NET Core web apps can be configured to handle
    scalability too. Let's check this out in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scalable web app in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is pretty simple to create a web app in Azure, ready for scaling. The reason
    why you have to do so is to be able to maintain different amounts of users during
    different seasons. The more users you have, the more hardware you will need. The
    following steps will show you how to create a scalable web application in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you log in to your Azure account, you will be able to create a new
    resource (web app, database, virtual machine, and so on), as you can see in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e9d04d4-4cde-4373-b4c3-e37a870c504b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, you can select Web App. This tutorial will take you to the following
    screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c7100ab-983a-439c-8de1-31190c059b43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The required details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'App name: As you can see, this is the URL that your web app will assume after
    its creation. The name is checked to ensure it is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subscription: This is the account that will be charged for all application
    costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resource Group: This is the collection of resources you can define to organize
    policies and permissions. You may specify a new resource group name or add the
    web app to a group specified during the definition of other resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OS: This is the operating system that will host the web app. Both Windows and
    Linux may be used for ASP.NET Core projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Publish: This parameter indicates whether the web app will be delivered directly
    or whether it is going to use Docker technology to publish content. Docker will
    be discussed in more detail in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'App Service Plan/Location: This is where you define the hardware plan that''s
    used to handle the web app and the location of the servers. This choice defines
    application scalability, performance, and costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application Insights: This is a useful Azure toolset for monitoring and troubleshooting
    web apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applications may be scaled in two conceptually different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertically (Scale up)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontally (Scale out)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both of them are available in the web app settings, as you can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0626f955-69b8-4ade-9e81-3683d9ed56d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's checkout the two types of scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical scaling (Scale up)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scale up means changing the type of hardware that will sustain your application.
    In Azure, you have the opportunity of starting with free-shared hardware and moving
    to an isolated machine in a few clicks.
  prefs: []
  type: TYPE_NORMAL
- en: 'By selecting this option, you have the opportunity to select more powerful
    hardware (machines with more CPUs, storage, and RAM). The following screenshot
    shows the user interface for scaling up a web app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ccf3faa-5d47-4f59-97a7-25e7b14cc979.png)'
  prefs: []
  type: TYPE_IMG
- en: Horizontal scaling (Scale out)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scaling out means splitting all requests among more servers with the same capacity
    instead of using more powerful machines. The load on all the servers is automatically
    balanced by the Azure infrastructure. This solution is advised when the overall
    load may change considerably in the future since horizontal scaling can be automatically
    adapted to the current load. The following screenshot shows an automatic Scale
    out strategy defined by two simple rules, which is triggered by CPU usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/084e5d5c-ef10-4dfd-8ddc-3bcb321f683d.png)'
  prefs: []
  type: TYPE_IMG
- en: A complete description of all the available auto scale rules is beyond the purpose
    of this book. However, they are quite self-explanatory and the *Further reading*
    section contains links to the full documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The Scale out feature is only available in paid service plans.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scalable web app with .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among all the available frameworks for implementing web apps, ASP.NET Core ensures
    good performance, together with low production and maintenance costs. ASP.NET
    Core performance is comparable with the performance of Node.js, but production
    and maintenance costs are lower because of the usage of C# (which is a strongly typed
    and advanced pure object language) instead of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The steps that follow will guide you through the creation of an ASP.NET Core-based web
    app. All the steps are quite simple, but some details require particular attention.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, during the web app's creation, you can choose between .NET Core
    Framework and .NET Framework. Pay attention, because only .NET Core can run on
    both Windows and cheaper Linux servers, while classic .NET runs only on Windows
    servers. On the other hand, with classic .NET, you will have access to a larger
    code base of legacy libraries that include both Microsoft and third-party packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, Microsoft recommends classic .NET, just in case the features you
    need are not available in .NET Core, or even when you deploy your web app in an
    environment that does not support .NET Core. In any other case, you should prefer
    .NET Core Framework because it allows you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run your web app in Windows, Linux, or Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design your solution with microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have high performance and scalable systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers and microservices will be covered in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*. There,
    you'll get a better understanding of the advantages of these technologies. For
    now, it is enough to say that .NET Core and microservices were designed for performance
    and scalability, which is why you should prefer .NET Core in all of your new projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will show you how to create an ASP.NET Core web app in
    Visual Studio 2019 with .NET Core 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you select ASP.NET Core Web Application, you will be directed to a screen
    where you will be asked to set up the Project name, Location, and Solution name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b160782-ca4c-48e7-a573-3e0e35990dc8.png)'
  prefs: []
  type: TYPE_IMG
- en: After that, you will be able to select the .NET Core version to use. At the
    time of writing, .NET Core 3.0 was still in its Preview 1 version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we are done with adding the basic details, you can connect your web
    app project to your Azure account and have it published.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Solution Explorer, you have the option to Publish... if you right-click anywhere
    in there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c431af5-0c1b-421d-b84d-e1e86330d050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you select the Publish... menu item, you will be able to connect your
    Azure account and then select the web app you wish to deploy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/41b66c52-c29c-46a2-807a-70b29620b0c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is full integration between Visual Studio and Azure. This gives you the
    opportunity to view all the resources you created in the Azure Portal in your
    development environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f0e01e35-c1eb-4516-92dd-cc68034c3637.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you''ve decided on your publish settings, that is, your publish profile,
    the web app is automatically published when you click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/443b5d84-b2dd-466e-8e6c-65758d394f94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For publishing .NET Core Preview versions, you have to add an extension in
    the web app setup panel in Azure portal, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5f79141-0422-4dee-9836-1fb169a2ad0c.png)'
  prefs: []
  type: TYPE_IMG
- en: For more information on deploying ASP.NET Core 3.0 to Azure App Service, please
    take a look at this link: [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we described the simplest ways to deploy a web app. [Chapter 17](b444cf5c-311d-4f74-80b0-0e86c0c13307.xhtml),
    *Deploying Your Application with Azure DevOps,* will introduce you to the Azure
    DevOps **Continuous Integration/Continuous Delivery** (**CI/CD**) pipeline. This
    pipeline is a further Azure toolset that automates all the required steps to get
    the application in production, that is, build, testing, deployment in staging,
    and deployment in production.
  prefs: []
  type: TYPE_NORMAL
- en: Performance issues that need to be considered when programming in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, C# is one of the most used programming languages all over the world,
    so good tips about C# programming are fundamental for the design of good architectures
    that satisfy the most common non-functional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections mention a few simple but efficacious tips—the associated
    code samples are available in the GitHub repository of this book.
  prefs: []
  type: TYPE_NORMAL
- en: String concatenation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a classic one! A naive concatenation of strings with the `+` string
    operator may cause serious performance issues since each time two strings are
    concatenated, their contents are copied into a new string.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we concatenate, say, 10 strings that have an average length of 100, the
    first operation has a cost of 200, the second one has a cost of *200+100=300*,
    the third one has a cost of 300+100= 400, and so on. It is not difficult to convince
    yourself that the overall cost grows like *m*n2*, where *n* is the number of strings
    and *m* is their average length. *n2* isn't too big for small *n* (say, *n* <
    10), but it becomes quite big when *n* reaches the magnitude of 100-1,000, and
    actually unacceptable for magnitudes of 10,000-100,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this with some test code, which compares naive concatenation
    with the same operation that''s performed with the help of the `StringBuilder`
    class (the code is available in this book''s GitHub repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1711e2df-6610-4cc5-a45c-8592b91d0e20.png)'
  prefs: []
  type: TYPE_IMG
- en: If you create a `StringBuilder` class with something like `var sb =new System.Text.StringBuilder()`,
    and then you add each string to it with `sb.Append(currString)`, the strings are
    not copied; instead, their pointers are queued in a list. They are copied in the
    final string just once, when you call `sb.ToString()` to get the final result.
    Accordingly, the cost of `StringBuilder`-based concatenation grows simply as *m*n*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you will probably never find a piece of software with a function
    like the preceding one that concatenates 100,000 strings. However, you need to
    recognize pieces of code similar to these ones where the concatenation of some
    20-100 strings, say, in a web server that handles several requests simultaneously,
    might cause bottlenecks that damage your non-functional requirements for performance.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Always remember—exceptions take too much time to be handled! So, the usage of
    `try-catch` needs to be concise and essential; otherwise, you will create big
    performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two samples compare the usage of `try-catch` and `Int32.TryParse`
    to check whether a string can be converted into an integer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function doesn''t look dangerous, but it is thousands of times slower
    than the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/422c9151-f741-489e-b71c-7b6a97295143.png)'
  prefs: []
  type: TYPE_IMG
- en: To sum this up, exceptions must be used to deal with exceptional cases that
    break the normal flow of control, for instance, situations when operations must
    be aborted for some unexpected reasons, and control must be returned several levels
    up in the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading environments for better results – do's and don'ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to take advantage of all of the hardware that the system you're
    building provides, you have to use multithreading. This way, when a thread is
    waiting for an operation to complete, it can leave the CPU and other resources
    to other threads instead of wasting CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, no matter how hard Microsoft is working to help with this,
    parallel code is not as simple as eating a piece of cake: it is error-prone and
    difficult to test and debug. The most important thing to remember as a software
    architect when you start considering using threads: *does your system require
    them?* Non-functional and some functional requirements will definitely answer
    this question for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you are sure that you need a multithreading system, you should decide
    on which technology is more adequate. There are a few options here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an instance of a System.Threading.Thread**: This is a classic way
    of creating threads in C#. The entirety of the thread life cycle will be in your
    hands. This is good when you are sure about what you are going to do, but you
    need to worry about every single detail of the implementation. The resulting code
    is hard to conceive and debug/test/maintain. So, to keep development costs acceptable,
    this approach should be confined to a few fundamental performance critique modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programming using System.Threading.Tasks.Parallel and System.Threading.Tasks.Task
    classes**: In the .NET Framework 4.0 versions, you can use parallel classes to
    enable threads in a simpler way. This is good because you don''t need to worry
    about the life cycle of the threads you create, but it will give you less control
    about what is happening in each thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Develop using asynchronous programming**: This is for sure the easiest way
    to develop multithreading applications since you don''t need to care about thread
    coordination and deadlocks are not possible. When an asynchronous method calls
    another asynchronous method, it goes in sleeping mode to avoid wasting resources
    until the called task returns. This way, asynchronous code mimics the behavior
    of classical synchronous code while keeping most of the performance advantages
    of general parallel programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overall behavior is deterministic and doesn't depend on the time taken by
    each task to complete, so non-reproducible bugs are not possible and the resulting
    code is easy to test/debug/maintain. Defining a method as an asynchronous task
    or not is the only choice left to the programmer; everything else is automatically
    handled by the runtime. The only thing you should be concern about is which methods
    should have asynchronous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this book, we will provide some simple examples of asynchronous
    programming. For more information about asynchronous programming and its related
    patterns, please check *Task-Based Asynchronous Patterns* in the Microsoft documentation
    ([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)).
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter the option you choose, there are some do''s and don''ts that, as
    a software architect, you have to pay attention to. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do use concurrent collections** (`System.Collections.Concurrent`): As soon
    as you start a multithreading application, you have to use these collections.
    The reason for this is that your program will probably manage the same list, dictionary,
    and so on from different threads. The use of concurrent collections is the only
    option for developing thread-safe programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do worry about static variables**: It is not possible to say that static
    variables are prohibited in multithreading development, but you should pay attention
    to them. Again, multiple threads taking care of the same variable can cause a
    lot of trouble. If you decorate a static variable with the `[ThreadStatic]` attribute,
    each thread will see a different copy of that variable, hence solving the problem
    of several threads competing on the same value. However, `ThreadStatic` variables
    can''t be used for extra-thread communications since values written by a thread
    can''t be read by other threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do test system performance after multithreading implementations**: Threads
    give you the ability to take full advantage of your hardware, but in some cases,
    badly written threads can waste CPU time just doing nothing! Similar situations
    may result in almost 100% CPU usage and unacceptable system slowdowns. In some
    cases, the problem can be mitigated or solved by adding a simple `Thread.Sleep(1)` call
    in the main loop of some threads to prevent them from wasting too much CPU time,
    but you need to test this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not consider multithreading easy**: Multithreading is not as simple as
    it seems in some syntax implementations. While writing a multithreading application,
    you should consider things such as the synchronization of the user interface,
    threading termination, and coordination. In many cases, programs just stop working
    well due to a bad implementation of multithreading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not forget to plan the number of threads your system should have**: This
    is really important for 32-bit programs. There is a limitation regarding how many
    threads you can have in 32-bit environments. You should consider this when you
    are designing your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not forget to end your threads**: If you do not have the correct termination
    procedure for each thread, you will probably have trouble with memory and handles
    leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability – why inserting data takes too much time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability, performance tips, and multithreading are the main tools we can
    use to tune machine performance. However, the effectiveness of the system you
    design depends on the overall performance of the whole processing pipeline, which
    includes both humans and machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a software architect, you can''t improve the performance of humans, but
    you can improve the performance of man-machine interaction by designing an effective
    **user interface** (**UI**), that is, user interfaces that ensure a fast interaction
    with humans, which, in turn, means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The UI must be easy to learn to reduce the time that's needed for learning and
    time waste before the target users learn to operate quickly. This constraint is
    fundamental if UI changes are frequent, and for public websites that need to attract
    the greatest possible number of users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI must not cause any kind of slowdown in data insertion; data insertion
    speed must be limited just by the user's ability to type, not by system delays
    or by additional gestures that could be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are a few simple tips when it comes to designing *easy to learn*
    user interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Each input screen must state its purpose clearly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the language of the user, not the language of developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid complications. Design the UI with the average case in mind; more complicated
    cases can be handled with extra inputs that appear only when needed. Split complex
    screens into more input steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use past inputs to understand user intentions and to put users on the right
    paths with messages and automatic UI changes; for instance, cascading drop-down
    menus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error messages are not bad notes the system gives to the user, but they must
    explain how to insert correct input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fast user interfaces result from efficacious solutions to the following three
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Input fields must be placed in the order they are usually filled, and it should
    be possible to move to the next input with the *Tab* or *Enter* key. Moreover,
    fields that often remain empty should be placed at the bottom of the form. Simply
    put, the usage of the mouse while filling a form should be minimized. This way,
    the number of user gestures is kept to a minimum. In a web application, once the
    optimal placement of input fields has been decided, it is enough to use the `tabindex`
    attribute to define the right way users move from one input field to the next
    with the *Tab* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System reactions to user inputs must be as fast as possible. In particular,
    error (or information) messages must appear as soon as the user leaves the input
    field. The simplest way to achieve this is to move most of the help and input
    validation logic to the client side so that system reactions don't need to pass
    through both communication lines and servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficacious selection logic. Selecting an existing item should be as easy as
    possible; for example, selecting one of some thousands of products in an offer
    must be possible with a few gestures and with no need to remember the exact product
    name or its barcode. The next subsection analyzes techniques we can use to increase complexity to
    achieve fast selection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing fast selection logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When all the possible choices are in the order of magnitude of 1-50, the usual
    drop-down menu is enough. For instance, check the currency selection drop-down
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64bf7d21-bbca-4f59-9a69-8c7777836a5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the order of magnitude is higher but less than a few thousand, an autocomplete
    that shows the names of all the items that start with the characters typed by
    the user is usually a good choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f74ec7cc-96e3-42e5-aa6d-4b48572c322d.png)'
  prefs: []
  type: TYPE_IMG
- en: A similar solution can be implemented with a low computational cost since all
    the main databases can efficiently select strings that start with a given substring.
  prefs: []
  type: TYPE_NORMAL
- en: When names are quite complex, when searching for the characters that were typed
    in by the user, they should be extended inside each item string. This operation
    can't be performed efficiently with usual databases and requires ad hoc data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we are searching inside descriptions composed of several words,
    more complex search patterns are needed. This is the case, for instance, of product
    descriptions. If the chosen database supports full-text search, the system can
    search for the occurrence of several words that have been typed by the user inside
    all the descriptions efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: However, when descriptions are made up of names instead of common words, it
    might be difficult for the user to remember a few exact names contained in the
    target description. This happens, for instance, with multi-country company names.
    In these cases, we need algorithms that find the best match for the character
    that was typed by the user. Substrings of the string that was typed by the user
    must be searched in different places of each description. In general, similar
    algorithms can't be implemented efficiently with databases based on indexes but
    require all the descriptions to be loaded in memory and ranked somehow against
    the string that was typed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The most famous algorithm in this class is probably the **Levenshtein** algorithm,
    which is used by most spell checkers to find a word that best fits the mistyped
    one by the user. This algorithm minimizes the Levenshtein distance between the
    description and the string typed by the user, that is, the minimum number of character
    removals and additions needed to transform one string into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Levenshtein algorithm works great but has a very high computational cost.
    Now, we give a faster algorithm that works well for searching character occurrences
    in descriptions. Characters typed by the user don''t need to occur consecutively
    in the description but must occur in the same order. Some characters may miss.
    Each description is given a penalty that depends on the missing characters and
    on how the occurrences of the characters typed by the user are far from the others.
    More specifically, the algorithm ranks each description with two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of characters typed by the user that occurs in the description:
    The more characters contained in the description, the higher its rank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each description is given a penalty equal to the total distance among the occurrences
    of the characters typed by the user in the description.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the word **Ireland** is ranked against the
    string **ilad**, which was typed by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfd55e6c-1607-4a2d-8c4a-1a5677b8cc12.png)'
  prefs: []
  type: TYPE_IMG
- en: The number of occurrences is four, while the total distance among characters
    occurrences is three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the descriptions have been rated they are sorted according to the
    number of occurrences. Descriptions with the same number of occurrences are sorted
    according to the lowest penalties. The following is an autocomplete that implements
    the preceding algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c02622a-1350-4551-be69-4ea2b4e8eb5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The C# code that ranks each description against the string typed by the user
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The item to rank is inserted in a `Rater` instance. Then, its string description
    is extracted by a `keyAccessor` function. After that, the code computes both character
    occurrences and occurrences in the total distance.
  prefs: []
  type: TYPE_NORMAL
- en: The full class code, along with a test console project, is available in this
    book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from a huge amount of items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, huge doesn't refer to the amount of space needed to store the data, but
    to the difficulty the user has in remembering the features of each item. When
    an item must be selected from among more than 10,000-100,000 items, there is no
    hope to find it by searching for character occurrences inside a description. Here,
    the user must be driven toward the right item through a hierarchy of categories.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, several user gestures are needed to perform a single selection.
    In other word, each selection requires interaction with several input fields.
    Once it's decided that the selection can't be done with a single input field,
    the simplest option is cascading drop-down menus, that is, a chain of drop-down
    menus whose selection list depends on the values that were selected in the previous
    drop-down menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the user needs to select a town located anywhere in the world,
    we may use the first drop-down menu to select the country, and once the country
    has been chosen, we may use this choice to populate a second one with all the
    towns in the selected country. A simple example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/887f872b-d932-4737-965f-606bd1ad47a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, each drop-down menu can be replaced by an autocomplete when required
    due to having a high number of options.
  prefs: []
  type: TYPE_NORMAL
- en: 'If making the right selection can be done by intersecting several different
    hierarchies, cascading drop-down menus become inefficient too, and we need a filter
    form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47389640-dfa6-4283-9d0e-af7bf68564c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's understand interoperability with .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: The fantastic world of interoperability with .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core brought Windows developers the ability to deliver their software into
    various platforms. And you, as a software architect, need to pay particular attention
    to this. Linux and macOS are no longer a problem for C# lovers—it's much better
    than that—they are really good opportunities to deliver to new customers. Therefore,
    we need to ensure performance and multi-platform support, two common non-functional
    requirements in several systems.
  prefs: []
  type: TYPE_NORMAL
- en: Both console applications and web apps designed with .NET Core in Windows are
    almost completely compatible with Linux and macOS, too. This means you do not
    have to build the app again to run it on these platforms. Also, very platform-specific
    behaviors now have multi-platform support, as shown, for instance, by the `System.IO.Ports.SerialPort`class,
    which, starting from .NET Core 3.0, is on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft offers scripts to help you install .NET Core on Linux and macOS. You
    can find them at [https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script).
    Once you have the SDK installed, you just need to call **dotnet** the same way
    you do in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: However, you must be aware of some features that are not fully compatible with
    Linux and macOS systems. For instance, no equivalent to the Windows Registry exists
    in these OSes and you have to develop an alternative yourself. If needed, an encrypted
    JSON config file can be a good option.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point is that Linux is case-sensitive, while Windows is not.
    Please, remember this when you work with files. Another important thing is that
    the Linux path separator is different from the Windows separator. You can use
    the `Path.PathSeparator` property and all the other `Path` class methods to ensure
    your code is actually multi-platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, you can also adapt your code to the underlying OS by using the runtime
    checks provided by .NET Core, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating a service in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following script can be used to encapsulate a command-line .NET Core app
    in Linux. The idea is that this service works like a Windows Service. This can
    be really useful, considering that most Linux installations are command-line only
    and run without a user logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create file that will run the command-line app. The name
    of the app is `app.dll` and it is installed in `appfolder`. The application will
    be checked every 5,000 milliseconds. This service was created on a CentOS 7 system.
    Using a Linux Terminal, you can type this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file has been created, you have to copy the service file to a system
    location. After that, you have to reload `systemd` and enable the service so that
    it will restart on reboots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Now, you can start, stop, and check the service using the following commands.
    The whole input that you need to provide in your command-line app is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've learned about a few concepts, let's learn how to implement them
    in our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Book use case – understanding the main types of .NET Core projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The development of this book''s use case will be based on various kinds of
    .NET Core Visual Studio projects. This section describes all of them. Let''s select
    New project in the Visual Studio file menu. In the window that opens, all the
    .NET Core projects will be located under the .NET Core, .NET Standard, and Cloud
    items in the left-hand menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9897fec5-b7cd-41e5-8835-9db5c86f617c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Most of them are available under .NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91892c07-c0c3-4ce9-a574-b58b6fe2ca2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have a console project, a class library project, and various types
    of test projects, each based on a different test framework: xUnit, nUnit, and
    MSTest. Choosing among the various testing frameworks is just a matter of preference
    since all of them offer comparable features. Adding tests to each piece of software
    that composes a solution is a common practice and allows software to be modified
    frequently without jeopardizing its reliability.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing will be discussed in detail in [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml),
    *Testing Your Code with Unit Test Cases and TDD*, and [Chapter 20](e61b3c5d-3abd-4442-9c9c-e12fd3acedcc.xhtml),
    *Automation for Software Testing*. Finally, we have the ASP.NET Core application
    we already described in the *Creating a scalable web app with .NET Core* subsection.
    There, we defined an ASP.NET MVC application, but Visual Studio also contains
    project templates for projects based on RESTful APIs and the most important single-page
    application frameworks such as Angular, React, Vue.js, and the new Blazor framework
    based on WebAssembler. Some of them are available with the standard Visual Studio
    installation; others require the installation of a SPA package.
  prefs: []
  type: TYPE_NORMAL
- en: For each project type, we can choose the .NET Core version we would like to
    use. Under the .NET Standard menu item, we have only a class library project.
    .NET Standard class libraries are based on .NET standards instead of a specific
    .NET Core version so they are compatible with several .NET Core versions. For
    instance, libraries based on 2.0 standards are compatible with all .NET Core versions
    greater than or equal to 2.0, and with all .NET Framework versions greater than
    4.6.
  prefs: []
  type: TYPE_NORMAL
- en: This compatibility advantage comes at the price of having less available features.
    However, features that are not a part of a standard can be added as references
    to additional library packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, under the cloud menu, we have several more project types, but the
    only new project related to .NET Core is the Service Fabric Application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72a033eb-6bf1-4da9-b7fd-3544d1f43541.png)'
  prefs: []
  type: TYPE_IMG
- en: This allows us to define microservices. Microservice-based architectures allow
    an application to be split into several independent microservices. Several instances
    of the same microservice can be created and distributed across several machines
    to fine-tune the performance of each application part. Microservices will be described
    in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice
    Architecture to Your Enterprise Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional requirements that describe system behavior must be completed with
    non-functional requirements that constrain system performance, scalability, interoperability,
    and usability. Performance requirements come from response-time and system load
    requirements. As a software architect, you should ensure you have the required
    performance with the minimum cost building efficient algorithms and taking full
    advantage of the available hardware resources with multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability is the capability of a system to be adapted to an increasing load.
    Systems can be scaled vertically by providing more powerful hardware, or horizontally
    by replicating and load balancing the same hardware. The cloud, in general, and
    Azure, in particular, can help us implement strategies dynamically, with no need
    to stop your application.
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as .NET Core that run on several platforms can ensure interoperability,
    that is, the capability of your software to run on different target machines and
    with different operating systems (Windows, Linux, macOS, Android, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Usability is ensured by taking care of the input field's order, the effectiveness
    of the item selection logic, and how easy your system is to learn.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how Azure DevOps tools can help us when
    it comes to collecting, defining, and documenting our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which are the two conceptual ways to scale a system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you deploy your web app automatically from Visual Studio to Azure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is multithreading useful for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main advantages of the asynchronous pattern over other multithreading
    techniques?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the order of input fields so important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the .NET Core `Path` class so important for interoperability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of a .NET standard class library over a .NET Core class
    library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the various types of .NET Core Visual Studio projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some books and links you may consider reading to gather more
    information about this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-2.2#deploy-aspnet-core-preview-release-to-azure-app-service)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
