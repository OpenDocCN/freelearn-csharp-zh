- en: Working with the Middleware Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter provided an overview of ASP.NET Core projects. We looked
    at how to create an ASP.NET Core project and how to deal with the files and the
    structure involved. Also, we learned some of the basic concepts behind the MVC
    stack and ASP.NET Core. Now, let''s explore the concept of middleware in depth.
    Middleware is an essential part of the ASP.NET Core platform: it helps us to deal
    with incoming requests and outgoing responses. Most of all, these types of components
    can be used to monitor performances and implement cross-cutting functionalities.
    The chapter starts with an introduction to the middleware concept. It goes on
    to show how to implement custom middleware and it ends with an overview of the
    built-in middleware of ASP.NET Core.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing middleware and dealing with its different aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete use cases for middleware in an ASP.NET Core project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the built-in middleware of ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, middleware is a component placed between our application
    and incoming requests. Incoming requests hit the middleware's pipeline before
    they can reach the effective logic implemented in our application. As a result,
    middleware are considered one of the essential concepts of ASP.NET Core because
    it is the first layer in front of our application, and it is usually associated
    with cross-cutting concepts such as *logging*, *error handling*, *authentication*,
    and *validation.* It can also perform advanced tasks such as *conditional service
    initialization,* based on a request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, middleware can:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle, process, and modify incoming *HTTP requests*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle, process, and change outgoing *HTTP responses*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt the middleware pipeline by returning an *early response*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, the whole ASP.NET Core stack is composed of middleware. Middleware
    is also compliant with some essential concepts of *clean code*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each middleware focuses on a single purpose: taking a request and enhancing
    it. It is advisable to implement new middleware for each goal, to be compliant
    with the *single responsibility principle*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware also uses the concept of *chaining.* It takes an incoming request
    and passes it through the next piece of middleware. Therefore, every piece of
    middleware enhances the request and it decides whether to interrupt or continue
    the middleware pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As previously mentioned, middleware can *short-circuit* the pipeline, which
    means that it can block our requests and skip the rest of the pipeline. This *short-circuit*
    concept should not be underestimated as it is an excellent way to *increase the
    performance* of our service. Furthermore, the request will not hit our controllers
    if there is something wrong or if the user is not authorized to proceed. Moreover,
    the middleware pipeline is usually associated with a schema that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecf5ed76-d153-4a5b-95e1-0870d11ec63a.png)'
  prefs: []
  type: TYPE_IMG
- en: A single piece of middleware can act, and perform logic, on the *request* but
    also the *response.* Besides, it is essential to understand that the order of
    middleware countsâ€”indeed, we declare the order when we bind it to our pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The middleware pipeline in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have looked at some theory behind the middleware pipeline and how it can
    be useful in terms of short-circuiting and the single responsibility principle.
    Now let''s contextualize that in ASP.NET Core. In the previous chapter, we looked
    at the default Web API template provided by .NET Core. Let''s proceed by replacing
    the content of the `Startup` class with the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run this project by executing the following CLI command in the `SampleAPI`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned command starts our application using the `http://localhost:5000`
    address. We can invoke it using our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68e623dc-705d-4dc5-a2b1-a89fd8ce1baf.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, running Hello, World! using a middleware strategy is simple.
    It requires implementing the `Configure` method, which is the method whereby middleware
    is usually defined. `app.Run` executes a delegate method, which is the representation
    of our middleware. In our case, it takes the `HttpContext` of the request and
    writes content inside the response of the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is essential to understand how the ASP.NET Core framework implements the
    `Run` method. Let''s have a closer look at the implementation of the `Run` method
    by checking the code in the `Microsoft.AspNetCore.Builder` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code gives us more details about what we are doing. We notice
    that the `RequestDelegate` handler cannot be `null`, and if we go deep into the
    stack we can see that our delegate will be added *at the end of the pipeline*
    by using the `app.Use` extension method.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to understand that the order of middleware counts. The order
    of the middleware pipeline is implicitly defined in the `Configure` method of
    the `Startup` class. Furthermore, *MVC middleware* is usually the last one hit
    by requests; on the other hand, authorization *middleware* is generally placed
    before other middleware to guarantee the correct security level (putting authorization
    *middleware* after *MVC middleware* may damage our service and make it unsafe)*.*
  prefs: []
  type: TYPE_NORMAL
- en: HttpContext in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we saw how to create middleware using the `app.Run`
    extension method. A key concept involved in that implementation is the `HttpContext`
    type, which is the unique entry point for obtaining all information about HTTP
    properties; it is usually related to the incoming request. The `HttpContext` attribute
    exposes methods and properties to get information from the request and update
    information in the response. The response and request information are represented
    by the following attributes: `HttpContext.Response` and `HttpContext.Request`.
    For example, in the previous case, we used the `WriteAsync` method, which wrote
    the `Hello World!` string in response to the current `HttpContext`.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is a core part of ASP.NET Core. `HttpContext` has all references
    to services instantiated in the current request. To be specific, it provides a
    `RequestServices` property, which refers to the service container. We will explore
    dependency injection in more detail in the next chapter. Declaring a piece of
    *inline* middleware using the `app.Run` method is not the only way to define new
    middleware. Furthermore, in the following sub-section, we will see how to build
    middleware logic using a *class-based* approach.
  prefs: []
  type: TYPE_NORMAL
- en: Class-based middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Middleware can also be implemented by using a *class-based* approach*.* This
    kind of approach increases the r*eusability*, *testability*, and *maintainability*
    of middleware. A *class-based* approach involves the definition of a new type,
    for example. Let''s have a look at class-based middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine some key points in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestDelegate` represents the reference to the next element in the pipeline.
    This could be a delegate or other class-based middleware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvokeAsync` is the core part of our middleware*.* This contains the implementation
    of the middleware and calls the `_next` element in our pipeline. At this point,
    our implementation must choose between continuing the pipeline or only returning
    a result to the client. For example, in the case of a *not authorized* message,
    the middleware will interrupt the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After defining our middleware class, we need to add it to our pipeline. An
    excellent way to do this is to establish a new extension method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can add our middleware to the pipeline in our `Startup` class
    by executing the extension method previously defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation provides a way to encapsulate the logic of the
    middleware in the `SampleMiddleware` class. This approach is preferred for various
    reasons. First of all, the middleware class and the logic can be verified and
    tested using unit tests. Secondly, in an enterprise environment, it can be useful
    to create dedicated library projects containing common middleware used by the
    web services and to distribute them through the company's NuGet repository. Finally,
    the class-based approach provides a clear way to highlight middleware dependencies
    using constructor injection. We will look at this topic in more depth in [Chapter
    4](54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml), *Dependency Injection*. Now that
    we have seen how to declare and add middleware to the ASP.NET Core pipeline, it
    is necessary to cover the conditional initialization of middleware in slightly
    more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core provides some useful operators that let us put conditional initialization
    logic inside the middleware pipeline. Those kinds of operators may assist in providing
    additional performance benefits to our services and applications. Let's have a
    look at some of these operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IApplicationBuilder Map (this IApplicationBuilder app, PathString pathMatch,
    Action<IApplicationBuilder> configuration)` extension method helps us to initialize
    our middleware by mapping a URI path; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `SampleMiddleware` will only be added to our pipeline if it is
    called as a URI with the specified path. Notice that the `Map` operator can also
    be nested inside others: this approach provides a more advanced approach to conditional
    initialization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful operator is `MapWhen`, which only initializes the middleware
    provided as a parameter if the *predicate* function returns `true`; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if the request is HTTPS, we will initialize the `SampleMiddleware`
    class. Conditional middleware initialization can be really useful when we need
    to act on a specific type of request. It usually becomes necessary when we need
    to force the execution of some logic on HTTP request types, such as when a specific
    header is present in the request, or a specific protocol is used.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, *class-based* middleware is really useful when we need to implement
    custom logic in the middleware pipeline, and conditional initialization provides
    a cleaner way to initialize our set of middleware. In ASP.NET Core, middleware
    is a first-class citizen of the base logic of the framework; therefore, the next
    section covers some use cases and some middleware that comes out of the box with
    ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding built-in middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what are the use cases for middleware? As discussed earlier, they are usually
    related to cross-cutting concerns such as *logging*, *authentication,* and *exception
    handling*. ASP.NET Core itself provides some *built-in middleware* that represents
    a standard way to solve problems*:*
  prefs: []
  type: TYPE_NORMAL
- en: '`UseStaticFiles()`: Provides a way to deal with static files and assets inside
    your application. When the client asks for a static resource, this middleware
    filters the request and returns the requested file without hitting the rest of
    the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddResponseCaching()`: Helps developers to configure the caching system of
    the application. This middleware also adds all HTTP-compliant information related
    to the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseHttpsRedirection()`: This new, built-in piece of ASP.NET Core 2.1 middleware
    provides a way to force HTTPS redirection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseDeveloperExceptionPage()`: This shows a detailed error page (the new YSOD)
    in the case of exceptions*.* This is usually conditionally initialized, depending
    on the environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some built-in pieces of middleware provided by ASP.NET Core. As you
    can see, all middleware provides cross-cutting functionalities for your application.
    What''s important here is that the order of middleware initialization reflects
    the order of our pipeline; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `UseStaticFiles` middleware will never receive requests for
    static files because the MVC middleware handles them first. A general rule is
    to place `UseHttpsRedirection()` as the last middleware in the pipeline; otherwise,
    other middleware will not intercept requests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware is a useful tool for developers dealing with cross-cutting concerns.
    This is because it intercepts and enhances every *incoming request* and *outgoing
    response, and it can increase performance with early-return requests.* Concepts
    from logging to authentication should be handled by using middleware. The topics
    covered in the chapter provided you with the necessary knowledge to understand
    the middleware-first approach taken by the ASP.NET Core framework. Furthermore,
    the chapter also gave an overview of the built-in middleware of ASP.NET Core,
    and it described how to create custom middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will explore another core topic for increasing the
    maintainability and testability of our code: *dependency injection*. ASP.NET Core
    provides out-of-the-box dependency injection, and we will also explore how to
    solve dependencies and how to deal with different life cycle types.'
  prefs: []
  type: TYPE_NORMAL
