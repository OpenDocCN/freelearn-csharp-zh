<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-86"><a id="_idTextAnchor170"/>4</h1>
<h1 id="_idParaDest-87"><a id="_idTextAnchor171"/>ASP.NET Core Fundamentals (Part 2)</h1>
<p>In <a href="B18971_03.xhtml#_idTextAnchor130"><em class="italic">Chapter 3</em></a>, we learned about three important components in ASP.NET Core: routing, configuration, and environment. Next, let’s continue to explore the other components in ASP.NET Core.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Logging</li>
<li>Middleware</li>
</ul>
<p>ASP.NET Core provides a flexible logging API that works with many logging providers. We can send and store the logs in various destinations, such as the console, text files, Azure Application Insights, and so on. When the application has issues, logs can help us find out what is going on. Logging belongs to a bigger<a id="_idIndexMarker351"/> topic called <em class="italic">observability</em>, which is a set of practices that help us understand the state of the application. In this chapter, we will learn how to use the logging API in ASP.NET Core.</p>
<p>Middleware is a<a id="_idIndexMarker352"/> component that can be plugged into the request pipeline to handle requests and responses. It is one of the most important improvements in ASP.NET Core compared to the traditional ASP.NET framework. The request pipeline is a chain of middleware components, and each of these components can do something with the request or response, or pass it to the next middleware component in the pipeline. In this chapter, we will learn how to use built-in middleware components and how to develop custom middleware components.</p>
<p>By the end of this chapter, you will be able to use the logging API to log messages, set up log levels, and configure log providers. Additionally, you will be able to develop custom middleware components to process requests and responses.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor172"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter4">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter4</a>. You can use VS 2022 or VS Code to open the solutions<a id="_idTextAnchor173"/>.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor174"/>Logging</h1>
<p>Logging is<a id="_idIndexMarker353"/> an important part of any application. A well-designed logging system can capture data that helps you diagnose problems and monitor the application in production. Logging gives you insight into how, when, where, and why significant system events occurred so that you know how the application is performing and how users are interacting with it. Logging may help you to identify security weaknesses or potential attacks. Logging can also help you audit users activities.</p>
<p>Logging should not impact the performance of the application. It should be fast and efficient. It should not affect any logic of the application. When you add logging to an application, you should consider the following points:</p>
<ul>
<li>What information should be logged?</li>
<li>What format should log messages be in?</li>
<li>Where should log messages be sent?</li>
<li>How long should log messages be kept?</li>
<li>How to make sure log messages won’t impact the performance of the application?</li>
</ul>
<p>In this section, we will discuss how to use the logging system in ASP.NET Core.</p>
<p>Let's create a new project to learn how to use the logging API. Create a new ASP.NET Core web API project named <code>LoggingDemo</code> using the following command:</p>
<pre class="console">
dotnet new webapi -n LoggingDemo -controllers</pre> <p>You can also download the source code named <code>LoggingDemo</code> from the <code>samples/chapter4</code> folder in the chapter’s GitHub repositor<a id="_idTextAnchor175"/>y.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor176"/>Using built-in logging providers</h2>
<p>ASP.NET Core<a id="_idIndexMarker354"/> supports a logging API that works with<a id="_idIndexMarker355"/> various logging providers, including built-in logging providers and third-party logging providers. The default ASP.NET Core web API template has the following logging providers registered:</p>
<ul>
<li>Console logging provider</li>
<li>Debug logging provider</li>
<li><code>EventSource</code> logging provider</li>
<li><code>EventLog</code> logging provider (Windows only)</li>
</ul>
<p>To <a id="_idIndexMarker356"/>clearly see how these logging providers work, let’s remove all the pre-registered logging providers and then add the console<a id="_idIndexMarker357"/> logging provider. Open the <code>Program.cs</code> file and add the following code:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);builder.Logging.ClearProviders();
builder.Logging.AddConsole();</pre>
<p>Now, only the console logging provider is enabled. Let's use the console logging provider to output log messages. Open the <code>WeatherForecastController.cs</code> file; you can see the <code>ILogger&lt;WeatherForecastController&gt;</code> interface is injected into the constructor already:</p>
<pre class="source-code">
private readonly ILogger&lt;WeatherForecastController&gt; _logger;public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger
{
    _logger = logger;
}</pre>
<p>Open the <code>WeatherForecastController.cs</code> file in the project. Add the following code to the <code>Get()</code> method:</p>
<pre class="source-code">
[HttpGet(Name = "GetWeatherForecast")]public IEnumerable&lt;WeatherForecast&gt; Get()
{
    _logger.Log(LogLevel.Information, "This is a logging message.");
    // Omitted for brevity
}</pre>
<p>Run the application using the <code>dotnet run</code> command. Request the <code>/WeatherForecast</code> endpoint using the browser. You can see the log message in the console:</p>
<pre class="console">
info: LoggingDemo.WeatherForecastController[0]      This is a logging message.</pre>
<p>If you run <a id="_idIndexMarker358"/>the application in VS 2022 and run the<a id="_idIndexMarker359"/> application using the <em class="italic">F5</em> key, you can see a log message in the console window, but you cannot see it in the <strong class="bold">Output</strong> window of VS 2022:</p>
<div><div><img alt="Figure 4.1 – The Output window for debug messages in VS 2022" src="img/B18971_04_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The Output window for debug messages in VS 2022</p>
<p>To send logging messages to the <code>Debug</code> logging provider. Open the <code>Program.cs</code> file and add the following code:</p>
<pre class="source-code">
builder.Logging.ClearProviders();builder.Logging.AddConsole();
builder.Logging.AddDebug();</pre>
<p>Press <em class="italic">F5</em> to run the application in VS 2022 again. Now, you can see the log message in the <strong class="bold">Output</strong> window:</p>
<div><div><img alt="Figure 4.2 – Debug logging messages in VS 2022" src="img/B18971_04_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Debug logging messages in VS 2022</p>
<p>So, if want to add more <a id="_idIndexMarker360"/>other logging providers, we <a id="_idIndexMarker361"/>can call the extension methods of the <code>ILoggingBuilder</code> interface. Some third-party logging providers also provide the extension methods of the <code>ILoggingBuilder</code> interface.</p>
<p>For example, if we need to write the log messages to the Windows event log, we can add the <code>EventLog</code> logging provider. Add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Logging.AddEventLog();</pre> <p>Test the application and we should be able to see the log messages in the Windows event log.</p>
<p>Wait – why can’t we see it in the event log?</p>
<p>This is a specific scenario for the <code>EventLog</code> logging provider. Because it is a Windows-only logging provider, it does not inherit the default logging provider settings. We need to specify the logging level in the <code>appsettings.json</code> file. Open the <code>appsettings.Development.json</code> file and update the <code>Logging</code> section:</p>
<pre class="source-code">
{  "Logging": {
    "LogLevel": {
      "Default": "Trace",
      "Microsoft.AspNetCore": "Warning"
    },
    "EventLog": {
      "LogLevel": {
        "Default": "Information"
      }
    }
  }
}</pre>
<p>We need <a id="_idIndexMarker362"/>to add an <code>EventLog</code> section to specify the logging level for the <code>EventLog</code> logging provider. If it is not specified, the default logging level is <code>Warning</code>, which is higher than <code>Information</code>. This would result in us <a id="_idIndexMarker363"/>not being able to see <code>Information</code> logging messages. Run the application again, and now we can see the log messages in the event log:</p>
<div><div><img alt="Figure 4.3 – Event log on Windows" src="img/B18971_04_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Event log on Windows</p>
<p>We just introduced a new term – <strong class="bold">logging level</strong>. Wh<a id="_idTextAnchor177"/>at is it?</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor178"/>Logging levels</h2>
<p>In the preceding <a id="_idIndexMarker364"/>example, we used a <code>Log</code> method that accepts a <code>LogLevel</code> parameter. The <code>LogLevel</code> parameter indicates the severity of the log message. The <code>LogLevel</code> parameter can be one of the following values:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Level</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Value</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Trace</code></p>
</td>
<td class="No-Table-Style">
<p><code>0</code></p>
</td>
<td class="No-Table-Style">
<p>Used for the most detailed messages. These messages may contain sensitive application data. These messages are disabled by default and should never be enabled in a production environment.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Debug</code></p>
</td>
<td class="No-Table-Style">
<p><code>1</code></p>
</td>
<td class="No-Table-Style">
<p>Used for debugging information and development. Use with caution in production because of the high volume. Normally, these logs should not have a long-term value.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Information</code></p>
</td>
<td class="No-Table-Style">
<p><code>2</code></p>
</td>
<td class="No-Table-Style">
<p>Used for tracking the general flow of the application. These logs should have a long-term value.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Warning</code></p>
</td>
<td class="No-Table-Style">
<p><code>3</code></p>
</td>
<td class="No-Table-Style">
<p>Used to indicate potential problems or unexpected events. These issues typically do not cause the application to fail.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Error</code></p>
</td>
<td class="No-Table-Style">
<p><code>4</code></p>
</td>
<td class="No-Table-Style">
<p>Used to indicate failures in the current operation or request and not an application-wide failure. These errors and exceptions cannot be handled.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Critical</code></p>
</td>
<td class="No-Table-Style">
<p><code>5</code></p>
</td>
<td class="No-Table-Style">
<p>Used to indicate critical failures that require immediate attention; for example, data loss scenarios.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>None</code></p>
</td>
<td class="No-Table-Style">
<p><code>6</code></p>
</td>
<td class="No-Table-Style">
<p>Used to specify a logging category that should not write messages.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1 – Logging levels</p>
<p>To simplify the method call, the <code>ILogger&lt;TCategoryName&gt;</code> interface provides the following extension methods to log messages for different logging levels:</p>
<ul>
<li><code>LogTrace()</code></li>
<li><code>LogDebug()</code></li>
<li><code>LogInformation()</code></li>
<li><code>LogWarning()</code></li>
<li><code>LogError()</code></li>
<li><code>LogCritical()</code></li>
</ul>
<p>You can<a id="_idIndexMarker365"/> use the <code>LogInformation()</code> method to replace the <code>Log()</code> method in the preceding example:</p>
<pre class="source-code">
_logger.LogInformation("This is a logging message.");</pre> <p>You will see the same log message in the console window.</p>
<p>Let’s add a <code>LogTrace()</code> method in the <code>WeatherForecastController.cs</code> file, which will send a <code>Trace</code> log:</p>
<pre class="source-code">
_logger.LogTrace("This is a trace message");</pre> <p>Run the application using <code>dotnet run</code> and request the <code>WeatherForecast</code> endpoint again. You will not see the trace message in the console window. Why? Because the trace message is disabled by default. Open the <code>appsettings.json</code> file; we can find the following configuration:</p>
<pre class="source-code">
"Logging": {  "LogLevel": {
    "Default": "Information",
    "Microsoft.AspNetCore": "Warning"
  }
},</pre>
<p>Based on the configuration, the default logging level is <code>Information</code>. Look back at the logging level table we introduced before. The <code>Trace</code> logging level is 0, which is less than the <code>Information</code> logging level. So, the <code>Trace</code> logging level will not output by default. To enable the <code>Trace</code> logging level, we need to change the <code>Default</code> logging level to <code>Trace</code>. But there is another question – should we enable <code>Trace</code> logging for all environments?</p>
<p>The<a id="_idIndexMarker366"/> answer is <em class="italic">it depends</em>. The <code>Trace</code> logging level is used for the most detailed messages, which means it may contain sensitive application data. We can enable <code>Trace</code> logging in the development environment, but we may not want to enable it in the production environment. To achieve this, we can use the <code>appsettings.Development.json</code> file to override the <code>appsettings.json</code> file. That is what we learned in <a href="B18971_03.xhtml#_idTextAnchor130"><em class="italic">Chapter 3</em></a>. Open the <code>appsettings.Development.json</code> file and update the following configuration to enable the <code>Trace</code> log:</p>
<pre class="source-code">
"Logging": {  "LogLevel": {
    "Default": "Trace",
    "Microsoft.AspNetCore": "Warning"
  }
}</pre>
<p>Now, run the application again. You should be able to see a trace message in the console window for the development environment.</p>
<p class="callout-heading">Important note</p>
<p class="callout">To specify the logging level for the production environment, we can add an <code>appsettings.Production.json</code> file, and then override the settings for the <code>Logging</code> section.</p>
<p>Keep in mind that the logging levels such as <code>Trace</code>, <code>Debug</code>, and <code>Information</code> will produce a lot of log messages. If we need to enable them in the production environment for troubleshooting, we need to be careful. Think about where we want to store logging messages.</p>
<p>You may notice that in the <code>appsettings.json</code> file, there is a <code>Microsoft.AspNetCore</code> logging section. It is used to control the logging level for the ASP.NET Core framework. ASP.NET Core uses the category name to differentiate logging <a id="_idIndexMarker367"/>messages produced from the framework and the application. Check the code where we inject the <code>ILogger</code> service into the controller:</p>
<pre class="source-code">
public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger){
    _logger = logger;
}</pre>
<p>The <code>ILogger&lt;TCategoryName&gt;</code> interface is defined in the <code>Microsoft.Extensions.Logging</code> namespace. The <code>TCategoryName</code> type parameter is used to categorize log messages. You can use any string values for the category name, but using the class name as the logging category name is a common practice.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor179"/>Logging parameters</h2>
<p>These <code>Log{LOG LEVEL}()</code> methods have some overloads, such as the following:</p>
<ul>
<li><code>Log{LOG LEVEL}(string? message, params </code><code>object?[] args)</code></li>
<li><code>Log{LOG LEVEL}(EventId eventId, string? message, params </code><code>object?[] args)</code></li>
<li><code>Log{LOG LEVEL}(Exception exception, string message, params </code><code>object[] args)</code></li>
<li><code>Log{LOG LEVEL}(EventId eventId, Exception? exception, string? message, params </code><code>object?[] args)</code></li>
</ul>
<p>The <a id="_idIndexMarker368"/>parameters of these methods are set out here:</p>
<ul>
<li>The <code>eventId</code> parameter is used to identify the log message</li>
<li>The <code>message</code> parameter is used as a format string</li>
<li>The <code>args</code> parameter is used to pass arguments for the format string</li>
<li>The <code>exception</code> parameter is used to pass the exception object</li>
</ul>
<p>For example, we can define an <code>EventIds</code> class to identify log messages, like so:</p>
<pre class="source-code">
 public class EventIds{
    public const int LoginEvent = 2000;
    public const int LogoutEvent = 2001;
    public const int FileUploadEvent = 2002;
    public const int FileDownloadEvent = 2003;
    public const int UserRegistrationEvent = 2004;
    public const int PasswordChangeEvent = 2005;
    // Omitted for brevity
}</pre>
<p>Then, we can use the <code>eventId</code> parameter to identify log messages:</p>
<pre class="source-code">
_logger.LogInformation(EventIds.LoginEvent, "This is a logging message with event id.");</pre> <p>Some <a id="_idIndexMarker369"/>logging providers can use the <code>eventId</code> parameter to filter log messages.</p>
<p>We have introduced how to use the <code>message</code> parameter. You can use a plain string as the message, or you can use a format string and use the <code>args</code> parameter to pass arguments for the format string. Here is an example that uses the <code>message</code> and <code>args</code> parameters:</p>
<pre class="source-code">
_logger.LogInformation("This is a logging message with args: Today is {Week}. It is {Time}.", DateTime.Now.DayOfWeek, DateTime.Now.ToLongTimeString());</pre> <p>If an exception occurs, you can use the <code>LogError()</code> method with the <code>exception</code> parameter to log the exception:</p>
<pre class="source-code">
try{
    // Omitted for brevity
}
catch (Exception ex)
{
    _logger.LogError(ex, "This is a logging message with exception.");
}</pre>
<p>When <a id="_idIndexMarker370"/>using the <code>LogError()</code> method to log an exception, it is important to pass the exception object to the <code>exception</code> parameter. This is essential in order to preserve stack trace information; simply logging the exception message is not suffic<a id="_idTextAnchor180"/>ient.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor181"/>Using third-party logging providers</h2>
<p>The <a id="_idIndexMarker371"/>logging system in ASP.NET Core is designed <a id="_idIndexMarker372"/>to be extensible. The default logging providers, including the console logging provider and the <code>Debug</code> logging provider, can output logging messages in the console window or debug window, which is convenient for development. But in the production environment, we may want to send log messages to a file, a database, or a remote logging service. We can use third-party logging providers to achieve this.</p>
<p>There are many third-party logging frameworks or libraries that work with ASP.NET Core, such as the following:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-3">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Logging provider</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Website</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">GitHub repo</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Serilog</code></p>
</td>
<td class="No-Table-Style">
<p><a href="https://serilog.net/">https://serilog.net/</a></p>
</td>
<td class="No-Table-Style">
<p><a href="https://github.com/serilog/serilog-aspnetcore">https://github.com/serilog/serilog-aspnetcore</a></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>NLog</code></p>
</td>
<td class="No-Table-Style">
<p><a href="https://nlog-project.org/">https://nlog-project.org/</a></p>
</td>
<td class="No-Table-Style">
<p><a href="https://github.com/NLog/NLog.Extensions.Logging">https://github.com/NLog/NLog.Extensions.Logging</a></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>log4net</code></p>
</td>
<td class="No-Table-Style">
<p><a href="https://logging.apache.org/log4net/">https://logging.apache.org/log4net/</a></p>
</td>
<td class="No-Table-Style">
<p><a href="https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore">https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore</a></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2 – Third-party logging providers</p>
<p>Some other<a id="_idIndexMarker373"/> platforms provide rich features for collecting and analyzing the log messages, such as the following:</p>
<ul>
<li><strong class="bold">Exceptionless</strong> (<a href="https://exceptionless.com/">https://exceptionless.com/</a>)</li>
<li><strong class="bold">ELK </strong><strong class="bold">Stack</strong> (<a href="https://www.elastic.co/elastic-stack/">https://www.elastic.co/elastic-stack/</a>)</li>
<li><strong class="bold">Sumo </strong><strong class="bold">Logic</strong> (<a href="https://www.sumologic.com/">https://www.sumologic.com/</a>)</li>
<li><strong class="bold">Seq</strong> (<a href="https://datalust.co/seq">https://datalust.co/seq</a>)</li>
<li><strong class="bold">Sentry</strong> (<a href="https://sentry.io">https://sentry.io</a>)</li>
</ul>
<p>These<a id="_idIndexMarker374"/> platforms can provide a dashboard to view log messages. Technically, they are not just logging providers but also platforms for observability that contain logging, tracing, metrics, and so on.</p>
<p>Let’s start with a simple example. How can we print logging messages to a file?</p>
<p>We can use <strong class="bold">Serilog</strong> to<a id="_idIndexMarker375"/> write the log messages to a file. Serilog is a popular logging framework that works with .NET. It provides a standard logging API and a rich set of sinks that write log events to storage in various formats. These sinks target a variety of destinations, such as the following:</p>
<ul>
<li>File</li>
<li>Azure Application Insights</li>
<li>Azure Blob Storage</li>
<li>Azure Cosmos DB</li>
<li>Amazon CloudWatch</li>
<li>Amazon DynamoDB</li>
<li>Amazon Kinesis</li>
<li>Exceptionless</li>
<li>Elasticsearch</li>
<li>Sumo Logic</li>
<li>Email</li>
<li>PostgreSQL</li>
<li>RabbitMQ</li>
</ul>
<p>Serilog <a id="_idIndexMarker376"/>provides a <code>Serilog.AspNetCore</code> NuGet <a id="_idIndexMarker377"/>package that integrates with ASP.NET Core. It has a set of extension methods to configure the logging system. To use it, install the <code>Serilog.AspNetCore</code> NuGet package by running this command:</p>
<pre class="console">
dotnet add package Serilog.AspNetCore</pre> <p>Next, let’s use the <code>Serilog.Sinks.File</code> sink to write log messages to a file. Install the <code>Serilog.Sinks.File</code> NuGet package with this command:</p>
<pre class="console">
dotnet add package Serilog.Sinks.File</pre> <p>Then, update the <code>Program.cs</code> file to configure the logging system:</p>
<pre class="source-code">
using Serilog;var builder = WebApplication.CreateBuilder(args);
builder.Logging.ClearProviders();
var logger = new LoggerConfiguration().WriteTo.File(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "logs/log.txt"), rollingInterval: RollingInterval.Day, retainedFileCountLimit: 90).CreateLogger();
builder.Logging.AddSerilog(logger);</pre>
<p>In the preceding code, we first clear the default logging providers. Then, we create a <code>Serilog.ILogger</code> instance and add it to the logging system. The <code>WriteTo.File</code> method is used to configure the <code>Serilog.Sinks.File</code> sink. It will write log messages to a file named <code>log.txt</code> in the <code>logs</code> folder. The <code>rollingInterval</code> parameter is used to specify the rolling interval. In the current example, we set it up as daily. The <code>retainedFileCountLimit</code> parameter is used to specify the maximum number of log files to keep. In this case, we have kept the number of files to 90. Then, we call the <code>CreateLogger</code> method to create a <code>Serilog.ILogger</code> instance. Finally, we call the <code>AddSerilog()</code> method to add the <code>Serilog.ILogger</code> instance to the logging system.</p>
<p>There’s no<a id="_idIndexMarker378"/> need to change the code that uses the <code>ILogger</code> service. The <code>ILogger</code> service is still injected into the controller. The <a id="_idIndexMarker379"/>only difference is that log messages will be written to a file instead of the console window.</p>
<p>Run the application again and request the <code>/WeatherForecast</code> endpoint. You should be able to see log messages in the <code>logs/log.txt</code> file.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you write logging messages to a file, please make sure that there is enough disk space and that proper retention policies are set. Otherwise, the disk space may get exhausted. Also, it is recommended to use some professional logging systems for monitoring in the production environment. For example, if your application is deployed in Azure, you can easily integrate it with Azure Application Insights. Storing logging messages in a text file is not easy to manage and analyze.</p>
<p class="callout">If the amount of logging messages is huge, consider sending them to a message queue, such as RabbitMQ, and then have a separate process to consume the messages and write them to a database. Keep in mind that the logging system should not be a bottleneck for the application. Do not use asynchronous methods for logging because logging should be fast, and frequently switching between threads may cause performance i<a id="_idTextAnchor182"/>ssues.</p>
<p>In the <code>LoggingDemo</code> project, we have already configured the logging system to write log messages to a file. You can check the <code>Program.cs</code> file to see how it works. Serilog provides a rich set of sinks, and it supports various configurations as well. You can find more <a id="_idIndexMarker380"/>provided sinks here: <a href="https://github.com/serilog/serilog/wiki/Provided-Sinks">https://github.com/serilog/serilog/wiki/Provided-Sinks</a>.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor184"/>Structured logging</h2>
<p>In the <em class="italic">Logging parameters</em> section, we showed how we can use the <code>args</code> parameter to format<a id="_idIndexMarker381"/> a message string. You may wonder if we can use string concatenation to achieve the same outcome; for example, like this:</p>
<pre class="source-code">
logger.LogInformation($"This is a logging message with string concatenation: Today is {DateTime.Now.DayOfWeek}. It is {DateTime.Now.ToLongTimeString()}.");</pre> <p>The answer<a id="_idIndexMarker382"/> is yes and no. If you do not care about the values of the parameters, it does seem to work. However, a modern way to handle logs is to use <strong class="bold">structured logging</strong> instead of a plain string message. Structured logging is a way to log messages in a structured format. Parameters such as the day of the week are identified and structured so that a system can process them, which means we can perform special operations on them, such as filtering, searching, and so on. Let’s dive into the details.</p>
<p>Serilog efficiently supports structured logging when you use <code>args</code> parameters instead of string concatenation. Let’s update the <code>Program.cs</code> file to send logs to the console window in a structured format:</p>
<pre class="source-code">
var logger = new LoggerConfiguration()    .WriteTo.File(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "logs/log.txt"), rollingInterval: RollingInterval.Day, retainedFileCountLimit: 90)
    .WriteTo.Console(new JsonFormatter())
    .CreateLogger();
builder.Logging.AddSerilog(logger);</pre>
<p>Serilog supports multiple sinks in the same logging pipeline. In the preceding code, we add the console sink after the file sink. The console sink is automatically installed with the <code>Serilog.AspNetCore</code> NuGet package, so you do not need to manually install it. <code>JsonFormatter</code> is used to format log messages in JSON format. You can also specify the <code>formatter</code> type for the file sink.</p>
<p>In the <code>LoggingController</code> file, add a new action method to compare the structured logs and string concatenation logs:</p>
<pre class="source-code">
[HttpGet][Route("structured-logging")]
public ActionResult StructuredLoggingSample()
{
    logger.LogInformation("This is a logging message with args: Today is {Week}. It is {Time}.", DateTime.Now.DayOfWeek, DateTime.Now.ToLongTimeString());
    logger.LogInformation($"This is a logging message with string concatenation: Today is {DateTime.Now.DayOfWeek}. It is {DateTime.Now.ToLongTimeString()}.");
    return Ok("This is to test the difference between structured logging and string concatenation.");
}</pre>
<p>Run<a id="_idIndexMarker383"/> the <a id="_idIndexMarker384"/>application again and request the <code>api/Logging/structured-logging</code> endpoint. You should be able to see log messages in the console window in JSON format.</p>
<p>Log messages with structured logging look like this:</p>
<pre class="console">
{   "Timestamp":"2022-11-22T09:59:44.6590391+13:00",
   "Level":"Information",
   "MessageTemplate":"This is a logging message with args: Today is {Week}. It is {Time}.",
   "Properties":{
      "Week":"Tuesday",
      "Time":"9:59:44 AM",
      "SourceContext":"LoggingDemo.Controllers.LoggingController",
      "ActionId":"9fdba8d6-8997-4cba-a9e1-0cefe36cabd1",
      "ActionName":"LoggingDemo.Controllers.LoggingController.StructuredLoggingSample (LoggingDemo)",
      "RequestId":"0HMMC0D2M1GC4:00000001",
      "RequestPath":"/api/Logging/structured-logging",
      "ConnectionId":"0HMMC0D2M1GC4"
   }
}</pre>
<p>Log<a id="_idIndexMarker385"/> messages <a id="_idIndexMarker386"/>with string concatenation look like this:</p>
<pre class="console">
{   "Timestamp":"2022-11-22T09:59:44.6597035+13:00",
   "Level":"Information",
   "MessageTemplate":"This is a logging message with string concatenation: Today is Tuesday. It is 9:59:44 AM.",
   "Properties":{
      "SourceContext":"LoggingDemo.Controllers.LoggingController",
      "ActionId":"9fdba8d6-8997-4cba-a9e1-0cefe36cabd1",
      "ActionName":"LoggingDemo.Controllers.LoggingController.StructuredLoggingSample (LoggingDemo)",
      "RequestId":"0HMMC0D2M1GC4:00000001",
      "RequestPath":"/api/Logging/structured-logging",
      "ConnectionId":"0HMMC0D2M1GC4"
   }
}</pre>
<p>Note that the structured logging has <code>Week</code> and <code>Time</code> properties, while the string concatenation does not. Structured logging is more flexible and easier to process. Therefore, structured logging<a id="_idIndexMarker387"/> is recommended instead of string concatenation.</p>
<p>A great <a id="_idIndexMarker388"/>tool to <a id="_idIndexMarker389"/>analyze structured logging messages is Seq (<a href="https://datalust.co/seq">https://datalust.co/seq</a>). Seq is <a id="_idIndexMarker390"/>a powerful log management tool that creates the visibility you need to quickly identify and diagnose problems in your applications. It is a commercial product, but it provides a free trial. You can download it here: <a href="https://datalust.co/download">https://datalust.co/download</a>.</p>
<p>Install it on your local machine. When you see the following window, please take note of the <code>5341</code>:</p>
<div><div><img alt="Figure 4.4 – Installing Seq" src="img/B18971_04_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Installing Seq</p>
<p>Next, we need to configure Serilog to send log messages to Seq. Serilog has a sink for Seq, so we<a id="_idIndexMarker391"/> can easily<a id="_idIndexMarker392"/> install it using the following command:</p>
<pre class="console">
dotnet add package Serilog.Sinks.Seq</pre> <p>In the <code>Program.cs</code> file, update the logging configuration to send log messages to Seq:</p>
<pre class="source-code">
var logger = new LoggerConfiguration()    .WriteTo.File(formatter: new JsonFormatter(), Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "logs/log.txt"), rollingInterval: RollingInterval.Day, retainedFileCountLimit: 90)
    .WriteTo.Console(new JsonFormatter())
    .WriteTo.Seq("http://localhost:5341")
    .CreateLogger();</pre>
<p>Run the<a id="_idIndexMarker393"/> application again and request the <code>api/Logging/structured-logging</code> endpoint. You should be able to see log messages in Seq:</p>
<div><div><img alt="Figure 4.5 – Structured logging in Seq" src="img/B18971_04_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Structured logging in Seq</p>
<p>We can search the <code>Week</code> property to filter log messages, as shown in the following figure:</p>
<div><div><img alt="Figure 4.6 – Filtering structured logs in Seq" src="img/B18971_04_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Filtering structured logs in Seq</p>
<p>Now, we<a id="_idIndexMarker394"/> understand<a id="_idIndexMarker395"/> why structured logging is more powerful than string concatenation when you send logs. Serilog provides many powerful features for logging, such as enrichers. You can find more information about Serilog on<a id="_idIndexMarker396"/> its official website: <a href="https://serilog.net/">https://serilog.net/</a>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Seq is a <a id="_idIndexMarker397"/>good choice for local development. However, you may need to purchase a license for your critical applications and services for better support, or you may want to use another logging system. Please carefully consider your requirements before you choose a logging system. Don’t forget that we can use configurations to switch between different logging systems for different environments.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor185"/>What should/shouldn’t we log?</h2>
<p>Logging is a<a id="_idIndexMarker398"/> powerful tool to help us diagnose problems, monitor an application, audit a system, and so on. But logging is not free. It consumes resources and may slow down applications. Depending on the purpose of logging, we may need to log different information. Generally, there are some scenarios that we should log:</p>
<ul>
<li>Input/output validation errors, such as invalid input parameters or invalid response data</li>
<li>Authentication and authorization failures</li>
<li>Application errors, exceptions, and warnings, such as database connection errors, network errors, and so on</li>
<li>Application startup and shutdown</li>
<li>High-risk operations, such as deleting a record from the database, changing a user’s password, transferring money, and so on</li>
<li>Legal compliance, such as auditing, terms of service, personal data consent, and so on</li>
<li>Critical business events, such as a new order being placed, a new user being registered, and so on</li>
<li>Any suspicious activities, such as brute-force attacks, account lockouts, and so on</li>
</ul>
<p>What information<a id="_idIndexMarker399"/> should we log? If the information in the log message is not sufficient to diagnose the problem, it would be useless. Generally, we should log the following information:</p>
<ul>
<li><strong class="bold">When</strong>: What time did the event happen?</li>
<li><strong class="bold">Where</strong>: What is the application name and version? What is the hostname or IP address? What is the module or component name?</li>
<li><strong class="bold">Who</strong>: Which user or client is involved in the event? What is the username, request ID, or client ID?</li>
<li><strong class="bold">What</strong>: What is the event? What severity level does the event have? What is the error message or stack trace? Any other descriptive information?</li>
</ul>
<p>We may need to include more information based on the requirements. For example, for web API applications, we also need to log the request path, HTTP method, headers, status code, and so on. For database applications, we may need to log the SQL statement, parameters, and so on.</p>
<p>There is some information that we should not log:</p>
<ul>
<li>Application source code</li>
<li>Sensitive application information, such as application secrets, passwords, encryption keys, database connection strings, and so on</li>
<li>Sensitive <a id="_idIndexMarker400"/>user information, such as <strong class="bold">personally identifiable information</strong> (<strong class="bold">PII</strong>); for <a id="_idIndexMarker401"/>example, health status, government identification, and so on</li>
<li>Bank account information, credit card information, and so on</li>
<li>Information that users do not consent to share</li>
<li>Any other information that may violate the law or regulations</li>
</ul>
<p>We have explained the basics of logging in ASP.NET Core. Next, we will learn another important component of ASP.NET Core: middleware.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor186"/>Middleware</h1>
<p>In this section, we <a id="_idIndexMarker402"/>will introduce middleware, which is one of the most important improvements in ASP.NET Core.</p>
<p>To follow this section, you can run the following command to create a new ASP.NET Core web API project:</p>
<pre class="console">
dotnet new webapi -n MiddlewareDemo -controllers</pre> <p>You can download the example project named <code>MiddlewareDemo</code> from the ch<a id="_idTextAnchor187"/>apter’s GitHub repository.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor188"/>What is middleware?</h2>
<p>ASP.NET Core is a middleware-based framework. An ASP.NET Core application is built upon a set of middleware components. Middleware is a software component that is responsible for handling requests and responses. Multiple middleware components form a pipeline to process requests and generate responses. In this pipeline, each middleware component can perform a specific task, such as authentication, authorization, logging, and so on. Then, it passes the request to the next middleware component in the pipeline. It is a huge improvement over the traditional ASP.NET framework, which is based on the HTTP module and HTTP handler. In this way, the ASP.NET Core framework is more flexible and extensible. You can add or remove middleware components as needed. You can also write your own middleware components.</p>
<p>The following diagram shows a<a id="_idIndexMarker403"/> middleware pipeline:</p>
<div><div><img alt="Figure 4.7 – Middleware pipeline" src="img/B18971_04_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Middleware pipeline</p>
<p>A middleware component can perform tasks before and after the next middleware component in the pipeline. It can also choose whether to pass the request to the next middleware component or stop processing the request and gen<a id="_idTextAnchor189"/>erate a response directly.</p>
<h3>Creating simple middleware</h3>
<p>Let's <a id="_idIndexMarker404"/>see an example. Open the <code>MiddlewareDemo</code> project in VS Code. Add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
var app = builder.Build();app.Run(async context =&gt;
{
    await context.Response.WriteAsync("Hello world!");
});</pre>
<p class="callout-heading">Important note</p>
<p class="callout">In the preceding code, <code>builder.Build()</code> returns a <code>WebApplication</code> instance. It is the host for the web API project, which is responsible for app startup and lifetime management. It also manages logging, DI, configuration, middleware, and so on.</p>
<p>Run the <a id="_idIndexMarker405"/>application with <code>dotnet run</code> or <code>dotnet watch</code>, and you will see all requests will return a <code>Hello world!</code> response, regardless of the URL. This is because the <code>app.Run()</code> method handles all requests. In this case, the middleware short-circuits the pipeline and returns the response directly. We can also call it <em class="italic">terminal middleware</em>.</p>
<p>To use multiple middleware components, we can use the <code>app.Use()</code> method. The <code>app.Use()</code> method adds a middleware component to the pipeline. Update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
var app = builder.Build();app.Use(async (context, next) =&gt;
{
    var logger = app.Services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
    logger.LogInformation($"Request Host: {context.Request.Host}");
    logger.LogInformation("My Middleware - Before");
    await next(context);
    logger.LogInformation("My Middleware - After");
    logger.LogInformation($"Response StatusCode: {context.Response.StatusCode}");
});</pre>
<p>Run the application and request the <code>/weatherforecast</code> endpoint. You can see the following output in the console:</p>
<pre class="console">
info: Program[0]      Request Host: localhost:5170
info: Program[0]
      My Middleware - Before
info: Program[0]
      My Middleware - After
info: Program[0]
      Response StatusCode: 200</pre>
<p>The <code>WebApplication</code> instance uses an <code>app.Use()</code> method to add a simple middleware <a id="_idIndexMarker406"/>component to the pipeline. The middleware component is an anonymous function that takes two parameters: <code>context</code> and <code>next</code>. Let’s take a closer look at these:</p>
<ul>
<li>The <code>context</code> parameter is an instance of the <code>HttpContext</code> class that contains request and response information</li>
<li>The <code>next</code> parameter is a delegate that is used to pass the request to the next middleware component in the pipeline</li>
<li>The <code>await next()</code> statement passes the request to the next middleware component in the pipeline</li>
</ul>
<p>This middleware does not do anything with the request and response. It only outputs some information to the console. Let us add another middleware component to the pipeline. Update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
var app = builder.Build();app.Use(async (context, next) =&gt;
{
    var logger = app.Services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
    logger.LogInformation($"ClientName HttpHeader in Middleware 1: {context.Request.Headers["ClientName"]}");
    logger.LogInformation($"Add a ClientName HttpHeader in Middleware 1");
    context.Request.Headers.TryAdd("ClientName", "Windows");
    logger.LogInformation("My Middleware 1 - Before");
    await next(context);
    logger.LogInformation("My Middleware 1 - After");
    logger.LogInformation($"Response StatusCode in Middleware 1: {context.Response.StatusCode}");
});
app.Use(async (context, next) =&gt;
{
    var logger = app.Services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
    logger.LogInformation($"ClientName HttpHeader in Middleware 2: {context.Request.Headers["ClientName"]}");
    logger.LogInformation("My Middleware 2 - Before");
    context.Response.StatusCode = StatusCodes.Status202Accepted;
    await next(context);
    logger.LogInformation("My Middleware 2 - After");
    logger.LogInformation($"Response StatusCode in Middleware 2: {context.Response.StatusCode}");
});</pre>
<p>In this example, we add two middleware components to the pipeline. The first middleware<a id="_idIndexMarker407"/> component adds a <code>ClientName</code> HTTP header to the request. The second middleware component sets the response status code to <code>202 Accepted</code>. Run the application and request the <code>/weatherforecast</code> URL. You will see the following output in the console:</p>
<pre class="console">
info: Program[0]      ClientName HttpHeader in Middleware 1:
info: Program[0]
      Add a ClientName HttpHeader in Middleware 1
info: Program[0]
      My Middleware 1 - Before
info: Program[0]
      ClientName HttpHeader in Middleware 2: Windows
info: Program[0]
      My Middleware 2 - Before
info: Program[0]
      My Middleware 2 - After
info: Program[0]
      Response StatusCode in Middleware 2: 202
info: Program[0]
      My Middleware 1 - After
info: Program[0]
      Response StatusCode in Middleware 1: 202</pre>
<p>Note the following points:</p>
<ul>
<li>The original request does not contain the <code>ClientName</code> HTTP header. So, the value of the <code>ClientName</code> HTTP header in <code>Middleware 1</code> is empty.</li>
<li>Before <code>Middleware 1</code> passes the request to <code>Middleware 2</code>, <code>Middleware 1</code> adds the <code>ClientName</code> HTTP header to the request.</li>
<li><code>Middleware 1</code> does not output <code>My Middleware 1 - After</code> to the console after its <code>await next(context);</code> code. Instead, <code>Middleware 2</code> outputs the <code>ClientName</code> HTTP header value to the console.</li>
<li><code>Middleware 2</code> changes the response status code to <code>202 Accepted</code>. The response will be passed to <code>Middleware 1</code>. Then, <code>Middleware 1</code> outputs <code>My Middleware 1 - After</code> with the new response status code.</li>
</ul>
<p>That indicates<a id="_idIndexMarker408"/> how middleware c<a id="_idTextAnchor190"/>omponents work in the pipeline.</p>
<h3>How to assemble middleware components</h3>
<p>Besides<a id="_idIndexMarker409"/> the <code>app.Use()</code> method, the <code>WebApplication</code> class also provides <code>Map()</code>, <code>MapWhen()</code>, <code>UseWhen()</code>, and <code>Run()</code> methods to add middleware components to a pipeline. The following table shows the differences between these methods:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-3">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>app.Map()</code></p>
</td>
<td class="No-Table-Style">
<p>Maps a request path to a sub-request pipeline. The middleware component is only executed when the request path matches the specified path.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>app.MapWhen()</code></p>
</td>
<td class="No-Table-Style">
<p>Runs a sub-request pipeline when a given predicate is matched.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>app.Use()</code></p>
</td>
<td class="No-Table-Style">
<p>Adds an inline delegate to the application’s request pipeline.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>app.UseWhen()</code></p>
</td>
<td class="No-Table-Style">
<p>Adds an inline delegate to the application’s request pipeline when a given predicate is matched. It is rejoined to the main pipeline if it does not short-circuit or contain terminal middleware.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>app.Run()</code></p>
</td>
<td class="No-Table-Style">
<p>Adds a terminal middleware component to the pipeline. It prevents further middleware components from processing requests.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.3 –  The differences between the app.Map(), app.MapWhen(), app.Use(), app.UseWhen(), and app.Run() methods</p>
<p>To handle a<a id="_idIndexMarker410"/> request, we use <code>app.Map()</code> or <code>app.MapWhen()</code> to configure which request path (or predicate) should be handled by which middleware component. The <code>app.Use()</code> and <code>app.Run()</code> methods are used to add middleware components to the pipeline. One pipeline can have multiple <code>app.Use()</code> methods. But only one <code>app.Run()</code> method is allowed in one pipeline, and the <code>app.Run()</code> method must be the last method in the pipeline. The following diagram illustrates the process:</p>
<div><div><img alt="Figure 4.8 – The relationship between the app.Map(), app.Use(), and app.Run() methods" src="img/B18971_04_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The relationship between the app.Map(), app.Use(), and app.Run() methods</p>
<p>Let’s see an example. We will develop a lottery application that allows users to call an API to check <a id="_idIndexMarker411"/>whether they get the lucky number. Lucky numbers are generated randomly. We will add a couple of middleware components to the pipeline.</p>
<p>Update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
app.Map("/lottery", app =&gt;{
    var random = new Random();
    var luckyNumber = random.Next(1, 6);
    app.UseWhen(context =&gt; context.Request.QueryString.Value == $"?{luckyNumber.ToString()}", app =&gt;
    {
        app.Run(async context =&gt;
        {
            await context.Response.WriteAsync($"You win! You got the lucky number {luckyNumber}!");
        });
    });
    app.UseWhen(context =&gt; string.IsNullOrWhiteSpace(context.Request.QueryString.Value), app =&gt;
    {
        app.Use(async (context, next) =&gt;
        {
            var number = random.Next(1, 6);
            context.Request.Headers.TryAdd("number", number.ToString());
            await next(context);
        });
        app.UseWhen(context =&gt; context.Request.Headers["number"] == luckyNumber.ToString(), app =&gt;
        {
            app.Run(async context =&gt;
            {
                await context.Response.WriteAsync($"You win! You got the lucky number {luckyNumber}!");
            });
        });
    });
    app.Run(async context =&gt;
    {
        var number = "";
        if (context.Request.QueryString.HasValue)
        {
            number = context.Request.QueryString.Value?.Replace("?", "");
        }
        else
        {
            number = context.Request.Headers["number"];
        }
        await context.Response.WriteAsync($"Your number is {number}. Try again!");
    });
});
app.Run(async context =&gt;
{
    await context.Response.WriteAsync($"Use the /lottery URL to play. You can choose your number with the format /lottery?1.");
});</pre>
<p>This is a fun lottery program. Let’s see how it is configured:</p>
<ol>
<li>First, we use the <code>app.Map()</code> method to map the <code>/lottery</code> request path to a sub-request pipeline. In this part, there are a couple of things to do:<ol><li class="upper-roman">We use a <code>Random</code> instance to generate a lucky number. Note that this number is generated only once when the application starts.</li><li class="upper-roman">Next, we add a middleware component to the pipeline using the <code>app.UseWhen()</code> method. This middleware works only when the request has a query string. If the query string is the same as the lucky number, it uses <code>app.Run()</code> to write the response. This branch is done.</li><li class="upper-roman">Next, we <a id="_idIndexMarker412"/>add another middleware component when the request does not have a query string. This middleware consists of two sub-middleware components:<ul><li>The first one generates a random number and adds it to the HTTP header, then passes it to the second sub-middleware.</li><li>The second one uses <code>app.UseWhen()</code> to check the HTTP headers of the request. If the HTTP header contains the lucky number, it uses <code>app.Run()</code> to write the response. This branch is done. This part shows how we use the <code>app.UseWhen()</code> method to rejoin a middleware component to the main pipeline.</li></ul></li><li class="upper-roman">Next, we add a middleware component to the pipeline using the <code>app.Run()</code> method. This middleware component is used to handle all other requests for the <code>/lottery</code> URL. It writes the response to the client and shows the number that the client has chosen. Note that if the user already got the lucky number, this part will not be executed.</li></ol></li>
<li>At the end of the program, we have another middleware component using the <code>app.Run()</code> method. This middleware component is used to handle all other requests. It shows how to play the game.</li>
</ol>
<p>Run the application and request the <code>/lottery</code> endpoint a couple of times. Sometimes, you will see you win the lottery. Or, you can include a query string in the URL, such as <code>/lottery?1</code>. You should be able to notice that the lucky number is the same for all requests. If you restart the application, the lucky number may change, because it is generated randomly when the application starts.</p>
<p>There are a<a id="_idIndexMarker413"/> couple of things to note:</p>
<ul>
<li>A middleware component is initialized only once when the application starts.</li>
<li>You can mix the <code>app.Map()</code>, <code>app.MapWhen()</code>, <code>app.Use()</code>, <code>app.UseWhen()</code>, and <code>app.Run()</code> methods in one pipeline. But be careful to use them in the right order.</li>
<li><code>app.Run()</code> must be the last method in a pipeline.</li>
<li>You cannot change the response after <code>await next();</code> or <code>await next.Invoke();</code> is called because it may cause a protocol violation or corrupt the response body format. For example, if the response has been sent to the client, if you change the headers or the status code, it will throw an exception. If you want to change the response, please do so before <code>await next();</code> or <code>await next.Invoke();</code> is called.</li>
</ul>
<p>You may wonder what the difference between <code>app.MapWhen()</code> and <code>app.UseWhen()</code> is. Both of them are used to configure a conditional middleware execution. The differences are as follows:</p>
<ul>
<li><code>app.MapWhen()</code>: Used to branch the request pipeline based on the given predicate</li>
<li><code>app.UseWhen()</code>: Used to conditionally add a branch in the request pipeline that is rejoined to the main pipeline if it does not short-circuit or contain a terminal middleware</li>
</ul>
<p>To clarify the difference, update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
app.UseWhen(context =&gt; context.Request.Query.ContainsKey("branch"), app =&gt;{
    app.Use(async (context, next) =&gt;
    {
        var logger = app.ApplicationServices.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
        logger.LogInformation($"From UseWhen(): Branch used = {context.Request.Query["branch"]}");
        await next();
    });
});
app.Run(async context =&gt;
{
    await context.Response.WriteAsync("Hello world!");
});</pre>
<p>Run the <a id="_idIndexMarker414"/>application using <code>dotnet run</code> and request the <code>http://localhost:5170/?branch=1</code> URL. You will see the console window outputs the following message:</p>
<pre class="console">
info: Program[0]      From UseWhen(): Branch used = 1</pre>
<p>And the response is <code>Hello world!</code>. If you request any other URL, such as <code>http://localhost:5170/test</code>, you will still see a <code>Hello world!</code> response. But you will not see the console window that outputs the log message. That says <code>app.UseWhen()</code> only works when the predicate is <code>true</code>. If the predicate is <code>false</code>, the pipeline will continue to execute the next middleware component.</p>
<p>Next, let us try to change <code>app.UseWhen()</code> to <code>app.MapWhen()</code>. Update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
app.MapWhen(context =&gt; context.Request.Query.ContainsKey("branch"), app =&gt;{
    app.Use(async (context, next) =&gt;
    {
        var logger = app.ApplicationServices.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
        logger.LogInformation($"From MapWhen(): Branch used = {context.Request.Query["branch"]}");
        await next();
    });
});</pre>
<p>Run the application and request the <code>http://localhost:5170/?branch=1</code> URL again. You will see a log message in the console window, but it returns a <code>404</code> error! Why?</p>
<p>That is<a id="_idIndexMarker415"/> because the <code>app.MapWhen()</code> method is used to branch the request pipeline based on the given predicate. If the predicate is <code>true</code>, the request pipeline will be branched to the sub-pipeline defined in this <code>app.MapWhen()</code> method. But when the <code>next()</code> method is called, it does not have a next middleware component to execute, even though there is an <code>app.Run()</code> method defined at the end of the program. So, it returns a <code>404</code> error.</p>
<p>To make it work, we need to add another <code>app.Run()</code> method to the sub-pipeline. Update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
app.MapWhen(context =&gt; context.Request.Query.ContainsKey("branch"), app =&gt;{
    app.Use(async (context, next) =&gt;
    {
        var logger = app.ApplicationServices.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
        logger.LogInformation($"From MapWhen(): Branch used = {context.Request.Query["branch"]}");
        await next();
    });
    app.Run(async context =&gt;
    {
       var branchVer = context.Request.Query["branch"];
       await context.Response.WriteAsync($"Branch used = {branchVer}");
    });
});</pre>
<p>Now, run the application again and request the <code>http://localhost:5170/?branch=1</code> URL. You can see the logging message is <code>From MapWhen(): Branch used = 1</code>, and the response is returned as expected.</p>
<p>The middleware <a id="_idIndexMarker416"/>mechanism is very powerful. It makes the ASP.NET Core application incredibly flexible. But it may cause issues if you make incorrect orders. Please use it wisely.</p>
<p>In this section, we introduced how to apply middleware components using delegate methods. ASP.NET Core provides a lot of built-in middleware components to simplify development. In the next section, we will explore some of the built-in middleware compon<a id="_idTextAnchor191"/>ents.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor192"/>Built-in middleware</h2>
<p>ASP.NET Core framework<a id="_idIndexMarker417"/> provides a lot of built-in middleware <a id="_idIndexMarker418"/>components. Check the code of the <code>Program.cs</code> file. You can find <a id="_idIndexMarker419"/>some code like this:</p>
<pre class="source-code">
if (app.Environment.IsDevelopment()){
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();</pre>
<p>There are <a id="_idIndexMarker420"/>some middleware components to enable Swagger, HTTPS redirection, authorization, and so on. You can find a full list of built-in middleware components here: <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#built-in-middleware">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#built-in-middleware</a>.</p>
<p>Here are some common built-in middleware components. Note the <strong class="bold">Order</strong> column. Some middleware components must be called in a specific order. Some middleware may terminate the requests:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table004-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Middleware</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Order</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Authentication</p>
</td>
<td class="No-Table-Style">
<p>Enables authentication support.</p>
</td>
<td class="No-Table-Style">
<p>Before <code>HttpContext.User</code> is needed. Terminal for OAuth callbacks.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Authorization</p>
</td>
<td class="No-Table-Style">
<p>Enables authorization support.</p>
</td>
<td class="No-Table-Style">
<p>Immediately after the Authentication middleware.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>CORS</p>
</td>
<td class="No-Table-Style">
<p>Configures <strong class="bold">cross-origin resource </strong><strong class="bold">sharing</strong> (<strong class="bold">CORS</strong>).</p>
</td>
<td class="No-Table-Style">
<p>Before components that use CORS. <code>UseCors</code> currently must go before <code>UseResponseCaching</code>.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Health Check</p>
</td>
<td class="No-Table-Style">
<p>Checks the health status of the application and its dependencies.</p>
</td>
<td class="No-Table-Style">
<p>Terminal if a request matches a health check endpoint.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>HTTPS Redirection</p>
</td>
<td class="No-Table-Style">
<p>Redirects all HTTP requests to HTTPS.</p>
</td>
<td class="No-Table-Style">
<p>Before components that consume the URL.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Response Caching</p>
</td>
<td class="No-Table-Style">
<p>Enables response cache.</p>
</td>
<td class="No-Table-Style">
<p>Before components that require caching. <code>UseCors</code> must come before <code>UseResponseCaching</code>.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Endpoint Routing</p>
</td>
<td class="No-Table-Style">
<p>Defines and constrains request routes.</p>
</td>
<td class="No-Table-Style">
<p>Terminal for matching routes.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.4 – Common built-in middleware components</p>
<p>We will not cover all the <a id="_idIndexMarker421"/>built-in middleware components in this book. But we will introduce some of them in the following sub-sections, such as rate-limiting, request timeouts, short-circuits, and so on<a id="_idTextAnchor193"/>.</p>
<h3>Using the rate-limiting middleware</h3>
<p>The <a id="_idIndexMarker422"/>rate-limiting middleware is a new built-in middleware <a id="_idIndexMarker423"/>provided in ASP.NET Core 7. It is used to limit the <a id="_idIndexMarker424"/>number of requests that a client can make in a given time window. It is very useful <a id="_idIndexMarker425"/>to prevent <strong class="bold">distributed denial-of-service</strong> (<strong class="bold">DDoS</strong>) attacks.</p>
<p>The<a id="_idIndexMarker426"/> rate-limiting middleware defines four policies:</p>
<ul>
<li>Fixed window</li>
<li>Sliding window</li>
<li>Token bucket</li>
<li>Concurrency</li>
</ul>
<p>This section is just to introduce how to use the middleware, so we will not cover details of the policies. We will use the fixed window policy in this section. This policy uses a fixed time window to limit the number of requests. For example, we can limit the number of requests to 10 per 10 seconds. When the time window expires, a new time window starts, and<a id="_idIndexMarker427"/> the counter is reset to 0.</p>
<p>Update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
builder.Services.AddRateLimiter(_ =&gt;    _.AddFixedWindowLimiter(policyName: "fixed", options =&gt;
        {
            options.PermitLimit = 5;
            options.Window = TimeSpan.FromSeconds(10);
            options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;
            options.QueueLimit = 2;
        }));
// Omitted for brevity
app.UseRateLimiter();
app.MapGet("/rate-limiting-mini", () =&gt; Results.Ok($"Hello {DateTime.Now.Ticks.ToString()}")).RequireRateLimiting("fixed");</pre>
<p>The <a id="_idIndexMarker428"/>preceding code adds the rate-limiting middleware to a minimal API request pipeline. It creates a fixed window policy named <code>fixed</code>. The <code>options</code> property means a maximum of 5 requests per each 10-second window are allowed.</p>
<p>Run the application and request the <code>http://localhost:5170/rate-limiting-mini</code> URL 10 times. You will see the response is <code>Hello 638005...</code>. But the sixth request will be pending until the time window expires. You can try other policies if you want. To practice more, you can move the configuration for the policy to the <code>appsettings.json</code> file.</p>
<p>To apply this rate-limiting middleware to a controller-based API, we need to add the <code>EnableRateLimiting</code> attribute<a id="_idIndexMarker429"/> to the controller or action, as follows:</p>
<pre class="source-code">
[HttpGet("rate-limiting")][EnableRateLimiting(policyName: "fixed")]
public ActionResult RateLimitingDemo()
{
    return Ok($"Hello {DateTime.Now.Ticks.ToString()}");
}</pre>
<p> Next, we <a id="_idIndexMarker430"/>will introduce another built-in middleware component: the request timeout middleware.</p>
<h3>Using the request timeouts middleware</h3>
<p>ASP.NET Core 8 introduces<a id="_idIndexMarker431"/> the <a id="_idIndexMarker432"/>request timeout middleware, which allows developers to set a timeout for an endpoint. If the request is not completed within the allotted time, a <code>HttpContext.RequestAborted</code> cancellation token is triggered, allowing the application to handle the timeout request. This feature helps to prevent the application from being blocked by long-running requests.</p>
<p>To apply the<a id="_idIndexMarker433"/> request timeout middleware to the ASP.NET Core web API project, update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
builder.Services.AddRequestTimeouts(); // Omitted for brevity
 app.UseRequestTimeouts();</pre>
<p>The request timeout middleware can be used for a specific endpoint. To do this, we need to add the <code>EnableRequestTimeout</code> attribute to the controller or action, as follows:</p>
<pre class="source-code">
[HttpGet("request-timeout")] [RequestTimeout(5000)]
 public async Task&lt;ActionResult&gt; RequestTimeoutDemo()
 {
     var delay = _random.Next(1, 10);
     logger.LogInformation($"Delaying for {delay} seconds");
     try
     {
         await Task.Delay(TimeSpan.FromSeconds(delay), Request.HttpContext.RequestAborted);
     }
     catch
     {
         logger.LogWarning("The request timed out");
         return StatusCode(StatusCodes.Status503ServiceUnavailable, "The request timed out");
     }
     return Ok($"Hello! The task is complete in {delay} seconds");
 }</pre>
<p>In the <a id="_idIndexMarker434"/>preceding code, we use the <code>RequestTimeout</code> attribute to set the timeout to 5 seconds. In the action method, we <a id="_idIndexMarker435"/>use a <code>Task.Delay()</code> method to simulate a long-running task. The delay time is generated randomly. If the request is not completed within 5 seconds, a <code>Request.HttpContext.RequestAborted</code> cancellation token is triggered. Then, we can handle the timeout request in the <code>catch</code> block.</p>
<p>Run the application using the <code>dotnet run</code> command and request the <code>/api/request-timeout</code> endpoint a few times. Sometimes, you will get a <code>503</code> response. Note that the request timeout middleware does not work in the debug mode. To test this middleware, please ensure that the debugger is not attached to the application.</p>
<p>Similarly, if you <a id="_idIndexMarker436"/>want to apply this middleware to a minimal API, you can use the <code>WithRequestTimeout</code> method, as follows:</p>
<pre class="source-code">
app.MapGet("/request-timeout-mini", async (HttpContext context, ILogger&lt;Program&gt; logger) =&gt; {
     // Omited for brevity
 }).WithRequestTimeout(TimeSpan.FromSeconds(5));</pre>
<p>The timeout<a id="_idIndexMarker437"/> configuration can be configured with a policy. Then, we can apply the policy to the controller or action. Update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
builder.Services.AddRequestTimeouts(option =&gt; {
     option.DefaultPolicy = new RequestTimeoutPolicy { Timeout = TimeSpan.FromSeconds(5) };
     option.AddPolicy("ShortTimeoutPolicy", TimeSpan.FromSeconds(2));
     option.AddPolicy("LongTimeoutPolicy", TimeSpan.FromSeconds(10));
 });</pre>
<p>The preceding code defines three timeout policies. <code>DefaultPolicy</code> is used when no policy is specified. <code>ShortTimeoutPolicy</code> is used for short-running requests with a timeout of 2 seconds, while <code>LongTimeoutPolicy</code> is used for long-running requests with a timeout of 10 seconds. To apply the policy to the controller or action, the <code>EnableRequestTimeout</code> attribute can be used as follows:</p>
<pre class="source-code">
[HttpGet("request-timeout-short")] [RequestTimeout("ShortTimeoutPolicy")]
 public async Task&lt;ActionResult&gt; RequestTimeoutShortDemo()</pre>
<p>If the action method does not specify a policy, <code>DefaultPolicy</code> will be used.</p>
<h3>Using the short-circuit middleware</h3>
<p>The short-circuit middleware<a id="_idIndexMarker438"/> is another new middleware component introduced in ASP.NET Core 8. This<a id="_idIndexMarker439"/> middleware is used to short-circuit a request when it is not necessary to continue processing the request. For example, web robots may request the <code>/robots.txt</code> file to check if the website allows crawling. As a web API application, we do not need to process this request. However, the execution of the request pipeline will still continue. The short-circuit middleware can be used to short-circuit the request and return a response directly.</p>
<p>To apply the <a id="_idIndexMarker440"/>short-circuit middleware to a specific endpoint, add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
app.MapGet("robots.txt", () =&gt; Results.Content("User-agent: *\nDisallow: /", "text/plain")).ShortCircuit();</pre> <p>The preceding code uses the <code>ShortCircuit()</code> method to short-circuit the request. If the request path is <code>/robots.txt</code>, it will return a text/plain response directly.</p>
<p>Another way to use the short-circuit middleware is to use <code>MapShortCircuit</code> as follows:</p>
<pre class="source-code">
app.MapShortCircuit((int)HttpStatusCode.NotFound, "robots.txt", "favicon.ico");</pre> <p>In this example, when a request is made to <code>/robots.txt</code> or <code>/favicon.ico</code>, a <code>404 Not Found</code> response will be returned directly. This ensures that the server is not burdened with unnecessary requests.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The short-circuit middleware should be placed at the start of the pipeline to prevent other middleware components from processing the request unnecessarily. This will ensure that the request is handled in the most efficient manner.</p>
<p>ASP.NET Core provides a wide range of built-in middleware components. These components use extension methods such as <code>AddXXX()</code> and <code>UseXXX()</code> to add middleware<a id="_idIndexMarker441"/> components to the pipeline. In the following section, we will explore how to create a custom middleware component and apply it to the pipeline using <a id="_idTextAnchor194"/>an extension method.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor195"/>Creating a custom middleware component</h2>
<p>If the <a id="_idIndexMarker442"/>built-in middleware cannot meet <a id="_idIndexMarker443"/>your requirements, you can create your own middleware components. A custom middleware component does not have to derive from a base class or an interface. But a middleware class does need to follow some conventions:</p>
<ul>
<li>It must have a public constructor that accepts a <code>RequestDelegate</code> parameter.</li>
<li>It must have a public method named <code>Invoke()</code> or <code>InvokeAsync()</code> that accepts a <code>HttpContext</code> parameter and returns a <code>Task</code>. The <code>HttpContent</code> parameter must be the first parameter.</li>
<li>It can use DI to inject additional dependencies.</li>
<li>An extension method is needed to add the middleware to the <code>IApplicationBuilder</code> instance.</li>
</ul>
<p>Consider this scenario. For better tracking, we want to use the concept of correlation ID in the application. The correlation ID is a unique identifier for each request. It is used to track the request through the application, especially in a microservice architecture. ASP.NET Core provides a <code>HttpContext.TraceIdentifier</code> property to store the unique identifier. By default, Kestrel generates the ID using the <code>{ConnectionId}:{Request number}</code> format; for example, <code>0HML6LNF87PBV:00000001</code>.</p>
<p>If we have multiple services, such as <em class="italic">Service A</em> and <em class="italic">Service B</em>, when the client calls <em class="italic">Service A</em>, <em class="italic">Service A</em> will generate a <code>TraceIdentifier</code> instance for the current request, then <em class="italic">Service A</em> will call <em class="italic">Service B</em>, and <em class="italic">Service B</em> will generate another <code>TraceIdentifier</code> instance. It is hard to track the request through multiple services. We need to use the same <code>TraceIdentifier</code> instance for the request to be tracked.</p>
<p>The idea is to generate a correlation ID for each request chain. Then, set it in the <code>X-Correlation-Id</code> header for request/response as well. When we call <em class="italic">Service B</em> from <em class="italic">Service A</em>, attach the <code>X-Correlation-Id</code> header to the HTTP request headers so that we can attach the <code>X-Correlation-Id</code> value in the logs for future diagnostics. To do this, we<a id="_idIndexMarker444"/> need to create a custom middleware<a id="_idIndexMarker445"/> component. Create a new class named <code>CorrelationIdMiddleware</code> in the project folder:</p>
<pre class="source-code">
public class CorrelationIdMiddleware(RequestDelegate next, ILogger&lt;CorrelationIdMiddleware&gt; logger){    private const string CorrelationIdHeaderName = "X-Correlation-Id";
    public async Task InvokeAsync(HttpContext context)
    {
        var correlationId = context.Request.Headers[CorrelationIdHeaderName].FirstOrDefault();
        if (string.IsNullOrEmpty(correlationId))
        {
            correlationId = Guid.NewGuid().ToString();
        }
        context.Request.Headers.TryAdd(CorrelationIdHeaderName, correlationId);
        // Log the correlation ID
        logger.LogInformation("Request path: {RequestPath}. CorrelationId: {CorrelationId}", context.Request.Path, correlationId);
        context.Response.Headers.TryAdd(CorrelationIdHeaderName, correlationId);
        await next(context);
    }
}</pre>
<p>In the <a id="_idIndexMarker446"/>preceding code, the <code>CorrelationIdMiddleware</code> class has a public constructor that accepts a <code>RequestDelegate</code> parameter. It also has a public method named <code>InvokeAsync()</code> that accepts a <code>HttpContext</code> parameter and returns a <code>Task</code> instance. The <code>InvokeAsync()</code> method is the entry point of the middleware. It gets the correlation ID from the request header. If it is not found, it generates a new one. Then, it sets the <code>HttpContext.TraceIdentifier</code> property and adds<a id="_idIndexMarker447"/> the correlation ID to the response header. Finally, it calls the next middleware component in the pipeline. It also uses a logger via DI to log the correlation ID.</p>
<p>Next, add a new extension method to the <code>IApplicationBuilder</code> instance:</p>
<pre class="source-code">
public static class CorrelationIdMiddlewareExtensions{
    public static IApplicationBuilder UseCorrelationId(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;CorrelationIdMiddleware&gt;();
    }
}</pre>
<p>Now, we can apply the correlation ID middleware in the <code>Program.cs</code> file:</p>
<pre class="source-code">
app.UseCorrelationId();</pre> <p>Open the <code>WeatherForecastController.cs</code> file and add the following code to the <code>Get()</code> method:</p>
<pre class="source-code">
[HttpGet(Name = "GetWeatherForecast")]public IEnumerable&lt;WeatherForecast&gt; Get()
{
    // Get the "X-Correlation-Id" header from the request
    var correlationId = Request.Headers["X-Correlation-Id"].FirstOrDefault();
    // Log the correlation ID
    _logger.LogInformation("Handling the request. CorrelationId: {CorrelationId}", correlationId);
    // Call another service with the same "X-Correlation-Id" header when you set up the HttpClient
    //var httpContent = new StringContent("Hello world!");
    //httpContent.Headers.Add("X-Correlation-Id", correlationId);
    // Omitted for brevity</pre>
<p>Run the<a id="_idIndexMarker448"/> application and request the <code>http://localhost:5170/WeatherForecast</code> URL. You will see the response <a id="_idIndexMarker449"/>header contains the <code>X-Correlation-Id</code> property, as shown next:</p>
<pre class="console">
content-type: application/json; charset=utf-8date: Wed,05 Oct 2022 08:17:55 GMT
server: Kestrel
transfer-encoding: chunked
x-correlation-id: de67a42b-fd95-4ba1-bd2a-28a54c878d4a</pre>
<p>You can also see the correlation ID in the log, such as the following:</p>
<pre class="console">
MiddlewareDemo.CorrelationIdMiddleware: Information: Request path: /WeatherForecast. CorrelationId: 795bf955-50a1-4d71-a90d-f859e636775a...
MiddlewareDemo.Controllers.WeatherForecastController: Information: Handling the request. CorrelationId: 795bf955-50a1-4d71-a90d-f859e636775a</pre>
<p>In this way, we can use the correlation ID to track the request through multiple services, especially in a microservice architecture.</p>
<p>We did not <a id="_idIndexMarker450"/>call any other services in this example. You can have a try yourself. Create another service and call it from the current service. Apply the same correlation ID middleware in another service. It can get the <code>X-Correlation-Id</code> header from the request headers and continue to use it. Then, you will see the same correlation ID is used for<a id="_idIndexMarker451"/> each request chain in both services.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The preceding example is purely for demonstration purposes. Microsoft provides a NuGet package called <code>Microsoft.AspNetCore.HeaderPropagation</code> that can be used to propagate headers to downstream services. You can find the sample code here: <a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample">https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample</a>. You can also check <a href="B18971_16.xhtml#_idTextAnchor671"><em class="italic">Chapter 16</em></a> to learn more about the distribute<a id="_idTextAnchor196"/>d tracing using OpenTelemetry.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor197"/>Summary</h1>
<p>In this chapter, we learned about the logging framework in ASP.NET Core, and introduced a third-party logging framework, Serilog, to help us write logs to different sinks, such as files, console, and Seq, which is a tool that analyzes logs using structured logging. We also learned what middleware is, how to use the built-in middleware components, and how to create a custom middleware component.</p>
<p>It is time to implement some real business logic in the next chapter. We will introduce <strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>), a powerful <strong class="bold">object-relational mapper</strong> (<strong class="bold">ORM</strong>) framework, to help us access the database.</p>
</div>
</body></html>