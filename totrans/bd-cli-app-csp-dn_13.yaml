- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security Considerations for CLI Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is one of the most critical concerns in any application development
    project. Itâ€™s interesting to see that, in many projects, development teams tend
    to think that because they implemented measures to prevent their applicationâ€™s
    code from being subject to SQL injection, XSS attacks, or similar, their application
    is secure.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to keep in mind that security takes different forms
    and spans different areas, which means that it does not only concern the security
    of the applicationâ€™s code or its usage but also extends to the security of the
    whole development lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss these different areas and how they are related
    to securing CLI applications, and we will cover the key areas that you need to
    consider in order to enhance the security of your CLI application and the security
    of your development lifecycle. More specifically, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss the different areas in which security should be considered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to assess the security posture of a CLI application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to implement authentication in order to secure access to user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13)
  prefs: []
  type: TYPE_NORMAL
- en: Security areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, security is not only limited to the applicationâ€™s code,
    nor can it only be achieved by implementing authentication, although these areas
    are very important.
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s first start by highlighting the key areas involved in securing an application
    throughout its lifecycle. It is important for me to make this point (or reminder)
    here as I still meet with customers who introduce security too late in the lifecycle
    of an application (typically after the application has been developed and released
    to production), expecting security professionals to do miracles and secure the
    application with minimal or no modification to the application, which is, obviously,
    unrealistic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always keep in mind that security should span the entire lifecycle of the application.
    In concrete terms, security should be a concern from the early stages of designing
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In the design phase**: It is important to define security requirements and
    objectives and to conduct threat modeling using methodologies such as STRIDE to
    identify potential security risks so we can incorporate the appropriate security
    controls into the initial design. STRIDE helps categorize threats into six groups:
    Spoofing, Tampering, Repudiation, Information disclosure, Denial of service, and
    Elevation of privilege. After identifying threats, we can use the DREAD model
    to quantitatively assess and prioritize them based on their Damage potential,
    Reproducibility, Exploitability, Affected users, and Discoverability. During this
    phase, we should also consider privacy and data protection measures, such as encryption,
    authentication, and authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the architecture phase**: We are not only talking about the software architecture
    here but also about the infrastructure and networking architecture. Of course,
    we need to design a secure architecture that includes defense-in-depth strategies
    and integrates security mechanisms such as authentication and authorization. But
    we also need to plan for secure communication channels and data storage, using
    techniques such as encryption at rest and in transit along with network segmentation
    to ensure only appropriate routes of communication, through the appropriate network
    addresses, ports, and domains, and using appropriate protocols are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the development phase**: It is important to apply secure coding practices
    by relying on coding standards, such as implementing input validation and sanitization,
    and to ensure that our application is not vulnerable to common OWASP Top 10 security
    risks. It is equally important to ensure that secure coding practices are applied
    during code reviews. But this is not enough! You should use secure libraries and
    frameworks. In other words, ensure that your frameworks and libraries are still
    supported and receive security updates. Since we are using .NET 8 here, we know
    that it is still supported (and will receive security updates) until November
    10, 2026 (Iâ€™m writing this in November 2024). As a framework or a library becomes
    unsupported, it is important to plan to migrate to a newer version (not necessarily
    the latest, by the way ðŸ˜‰).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose our application communicates with external dependencies, such as web
    services. In that case, we have to ensure that these communications happen in
    a secure manner (by leveraging authentication and authorization) and using the
    appropriate protocols (such as HTTPS).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In the infrastructure configuration phase**: All efforts to enhance the applicationâ€™s
    security could be in vain if the infrastructure on which it is running is unsecured.
    In the case of CLI applications, which run on the userâ€™s computer, this responsibility
    is delegated to them or their organizationâ€™s IT department, which usually controls
    employeesâ€™ workstations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the testing phase**: Security-specific testing, including penetration
    testing and vulnerability assessments, should be performed during the testing
    phase to ensure user data cannot leak, user accounts cannot be compromised, and
    the application cannot be diverted from its intended usage toward malicious activities.
    Performing security testing allows us to validate that security requirements are
    met. Mature DevSecOps teams perform such testing on a regular basis. However,
    security tests should at least be performed before releasing an application to
    production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the deployment phase**: Every DevSecOps engineer knows that your CI/CD
    pipelines can be a security threat if not properly secured. Secrets (such as passwords,
    API keys, service connections, connection strings, and so on) should be keptâ€¦
    well, secret. Every CI/CD tool has its own secret management mechanism, which
    usually takes the form of a key vault, but we can also rely on external tools
    that are designed for such purposes, such as Azure Key Vault or HashiCorp Vault.
    Access to these secrets is usually restricted using roles and permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**While the application is being used**: It is a common mistake for immature
    teams and organizations to believe that once the application has been released
    to production, the job of security is done. Wrong! This is where it all starts.
    You may argue that we put a lot of effort into securing the application before
    releasing it to our users, and you would be right. However, by releasing our application
    into the wild, it will experience a wide range of usage patterns and user environments,
    way beyond what we could have expected, thought of, and planned for. We will hence
    have to monitor for security incidents and anomalies, by implementing logging
    and auditing mechanisms and by regularly updating and patching the application
    and its dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destructure.ByMaskingProperties` method and pass a list of properties to be
    ignored when logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As new versions or bug fixes are released**: Either when introducing new
    functionalities or fixing bugs, it is important to conduct a security impact analysis
    for the introduced changes. This can be done by performing regression testing
    to ensure existing security controls are still met and no vulnerability has been
    introduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, there is a variety of tools to help at every stage. If your team
    or organization has adopted a DevSecOps culture, you will already be aware of
    many of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: DevSecOps being way beyond the scope of this book, we will not be discussing
    the broad spectrum of tools you may use at every step. However, I do want to cover
    tools that will help us assess and enhance the security posture of a CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Assessing the security posture of a CLI application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple tools that help assess the security posture of an application
    (including a CLI application). Among the most widely used ones, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.csproj` files to detect vulnerabilities in third-party libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snyk**: This popular tool offers vulnerability reporting and scanning for
    .NET projects. It can be integrated into local development environments as well
    as into CI/CD pipelines for continuous monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mend Bolt**: Previously known as **WhiteSource Bolt**, this security scanning
    tool integrates with **Azure DevOps** or **GitHub** pipelines, scanning .NET projects
    for open source vulnerabilities and generating detailed reports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OWASP Dependency-Check**: This tool is effective for scanning third-party
    libraries and dependencies, which is crucial for .NET applications that often
    rely on external packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Advanced Security**: This tool integrates security features directly
    into GitHub or Azure DevOps workflows, performs code scanning (it uses static
    analysis to detect potential security vulnerabilities and coding errors) and secret
    scanning (it recognizes patterns for passwords, API keys, and other secrets and
    detects whether they are stored in clear text in the repository), and performs
    dependency reviews and highlights vulnerable ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools have in common that they inform us about the vulnerable library,
    and give us detailed information about the vulnerability itself and the recommended
    fix for it.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are either free (such as Mend Bolt and OWASP Dependency-Check) or
    offer a free plan but with limited functionality (such as SonarQube, Snyk, and
    GitHub Advanced Security).
  prefs: []
  type: TYPE_NORMAL
- en: They also vary in the level of complexity and effort required to set up and
    configure them. Hence, you will find SonarQube to be the most complex to set up,
    Snyk to be moderately easy to set up, and Mend Bolt, OWASP Dependency-Checker,
    and GitHub Advanced Security to be the easiest ones to set up.
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend Mend Bolt as a good starting point since it comes as an Azure
    DevOps or GitHub free extension that can be obtained from their respective marketplaces.
    For these reasons, these tools are usually intended for organizations or larger
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: However, the good news is that .NET already provides us with an out-of-the-box
    tool to serve this very purpose of assessing and enhancing the security posture
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: This tool, commonly known as dotnet-audit, focuses on detecting vulnerabilities
    in .NET project dependencies (namely, `NuGet` packages) by relying on the `GitHub
    Advisory Database`. For .NET-only projects, such as **Bookmarkr**, this tool is
    the perfect starting point!
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute this tool, we simply need to type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will be shown in the terminal window, and will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 â€“ Listing vulnerable packages](img/B22400_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 â€“ Listing vulnerable packages
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed in this figure, the command has not been executed on
    Bookmarkrâ€™s code but rather for another application. As it turns out, we are glad
    that no vulnerability has been detected for Bookmarkr (yeah!), but this might
    change over time as vulnerabilities in referenced libraries are detected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 â€“ No vulnerable packages for Bookmarkr](img/B22400_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 â€“ No vulnerable packages for Bookmarkr
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this command may ask you to run `dotnet restore` before you
    can execute it. This is especially true if this is the first time you have cloned
    the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: There is another command that does not directly scan for vulnerabilities, but
    which I recommend. This command lists outdated packages. While these packages
    might not have known vulnerabilities, being outdated means that they will no longer
    receive security updates. My recommendation is that you consider upgrading these
    packages to newer supported versions (once again, not necessarily the latest version
    if this introduces breaking changes).
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this command, simply type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the result of executing this command, although no vulnerability
    has been detected in Bookmarkrâ€™s dependencies, some of them are outdated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 â€“ Listing outdated packages](img/B22400_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 â€“ Listing outdated packages
  prefs: []
  type: TYPE_NORMAL
- en: The appropriate way to upgrade these packages is to create a new branch, update
    the packages, test the application (both using manual and automated testing, as
    described in [*Chapter 10*](B22400_10.xhtml#_idTextAnchor155)) to ensure that
    the application still works as expected and that we did not introduce regressions,
    and finally, issue a pull request to merge the modifications into the `main` branch.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the necessary knowledge and tools to assess, and ultimately enhance,
    the security posture of our CLI application. Letâ€™s focus our attention on securing
    communication between our CLI application and the external services it interacts
    with, to protect against unauthorized access and ensure proper user management.
    This can be achieved through authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Securing remote communications using authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B22400_09.xhtml#_idTextAnchor136), we introduced the `sync`
    command, which allows Bookmarkr to back up local bookmarks to a remote location
    and retrieve them when needed. When doing so, the command also synchronizes local
    and remote bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, the communication between the local CLI application and the remote
    external service has happened in an insecure manner. This means that anyone who
    invokes the `sync` command may retrieve your personal bookmarks, which you clearly
    donâ€™t want, do you?
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue, we need to implement authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Why is authentication important?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering why authentication should be required in the context of
    CLI applications. After all, a CLI application runs on the userâ€™s computer, which
    already requires that user to authenticate to their session.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of CLI applications, authentication is usually required when
    communicating with external services (i.e., sending data to and retrieving data
    from these services). This ensures that users have access to their data at the
    remote location by proving who they are.
  prefs: []
  type: TYPE_NORMAL
- en: How to perform authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication can be achieved in many ways. One of the most common ones is
    for the external service provider to provide you with a **Personal Access Token**
    (**PAT**). You can usually get or generate such tokens by visiting the service
    providerâ€™s website and logging in to your account. From there, on your accountâ€™s
    settings page, you should be able to get that token or to generate a new one.
    Such tokens are usually valid for a given period of time and expire after that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have this token, you can pass it as a parameter to a command that
    performs the call to the external service. An example of this would be the `sync`
    command, which could be invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `YOUR_PAT` is most commonly a GUID value.
  prefs: []
  type: TYPE_NORMAL
- en: This call would then authenticate the user using the received PAT value before
    performing the sync operation.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, this approach could quickly become tedious as it is
    not easy to remember the value of a PAT. For this reason, CLI applications usually
    store such values either in a local configuration file, in an environment variable,
    or in the operating systemâ€™s key vault. This allows the user to invoke the command
    without always having to pass the PAT as a parameter. The command will be smart
    enough to look for it in the local configuration file or in the environment variable
    and use it if it is present. If it is not present, the command should display
    an error message asking the user to provide it. If the PAT is invalid or expired,
    the command should also be able to inform the user about that.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the approach adopted by GitHub â€“ for example: you create a PAT within
    your GitHub account, which you can use to authenticate and access GitHub resources
    from external services or applications. In our use case, the external service
    is the one that provides and manages the tokens, whereas the CLI application is
    only responsible for sending these tokens to the external service.'
  prefs: []
  type: TYPE_NORMAL
- en: Another commonly used approach is to authenticate the user against an `auth`).
    Invoking this command usually triggers the default web browser and redirects the
    user to the application providerâ€™s login page. After successful authentication,
    the IdP provides access and an ID token that the CLI can use for subsequent requests
    to the external service. These tokens are, as for the PAT, usually included in
    the HTTP headers when performing the requests to the external service. This approach
    leverages the `OAuth 2.0` and the `OpenID` `Connect` protocols.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this chapter, we will explore how to implement authentication
    for Bookmarkr to secure communications with the **BookmarkrSyncr** external service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will leverage the PAT approach as it is more convenient and can work
    even in environments where no web browser can be launched, such as CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how this could be achieved, we will need to implement functionalities
    at two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BookmarkrSyncr**: The external service will receive the PAT, validate it,
    and authenticate the user if it is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bookmarkr**: The responsibility of the CLI application is to pass the token
    to the external service and act according to the response it gets from the sent
    request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letâ€™s start by adding the required functionality into BookmarkrSyncr.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating external services using a PAT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make things simple, we will assume that BookmarkrSyncr (the code for which
    can be found in the `AppendixB` folder) holds two PAT tokens: a valid one and
    an expired one. All other values that the user passes will be considered invalid
    and will be rejected for this reason.'
  prefs: []
  type: TYPE_NORMAL
- en: The token validation service will also be a very basic one.
  prefs: []
  type: TYPE_NORMAL
- en: 'While most of the code remains as it was, we had to make the following changes
    to the parameters we pass to the `MapPost` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s explain these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We indicate that the value of the PAT token comes from an HTTP header named
    `X-PAT` and that this value will be stored in the input parameter named `pat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass a parameter of type `ITokenValidator`, which is a service we have created
    to retrieve and validate PAT tokens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass the current HTTP context that we will need to set HTTP headers for the
    HTTP response, especially to notify the client that the received PAT token is
    either invalid or expired. We use a different response header to ensure that the
    client knows exactly why the request was unauthorized, as this is good programming
    practice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then invoke methods of the `TokenValidator` service to check whether the
    PAT token is invalid or expired, and if so, we set the appropriate HTTP header
    in the response object. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we set the HTTP header. We use the indexer syntax. This will set
    the header. If the header already exists, it will replace the existing value with
    the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is to register the `TokenValidator` service. This
    can be done for any service, using this widely known syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TokenValidator` service is very basic and its code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing worth mentioning here is that we are simulating a token store
    (in the classâ€™s constructor). In a real-world scenario, we would have a persistent
    token store (such as a database). But for the purposes of this demonstration,
    storing these PAT tokens in memory makes the code easier to understand. I also
    want you to notice that, for the purpose of the demonstration, we have two tokens:
    one is a valid token, and the other represents an expired token. Any other value
    will be considered invalid since it cannot be found in the token store (which
    is realistic, by the way ðŸ˜‰). The client (the CLI application) will hence behave
    differently depending on the validity of the token.'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! Now that we have our external service ready, itâ€™s time to update
    the client so that it can pass the PAT.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the PAT from the CLI application to the external service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this to happen, we will need to modify the code of both the `sync` command
    and the service agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `--pat` parameter to the `sync` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the request that the HTTP client makes to the external service so that
    it sends the PAT token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the code to store the PAT token in an environment variable and retrieve
    it from there if the `--pat` parameter is not specified when invoking the `sync`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Letâ€™s start with the first step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s go to the `SyncCommand.cs` file and, in the `Options` region, letâ€™s add
    an `Option` for the PAT as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `Option` is optional, as we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to make the command use this `Option`. For that matter, we need
    to add this instruction to the classâ€™s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, letâ€™s modify the commandâ€™s handler method so that the HTTP client can
    send the PAT to the BookmarkrSyncr service. For that matter, we need to modify
    the handler methodâ€™s signature to pass the PAT as a parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to the classâ€™s constructor again, we need to modify the call to the `SetHandler`
    method to pass the PAT Option as a parameter. The modified method call looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to pass this token to the service agent. For that matter, we
    first need to modify the call to the service agent in the handler method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, we need to update the code of the `BookmarkrSyncrServiceAgent` class to
    ensure the presence of the token before calling the external service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is, obviously, pass the PAT value as a parameter
    to its `Sync` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the first thing the method should do is to ensure the presence
    of the PAT (i.e., ensure that we are not sending a null or an empty value to the
    external service). We do this by adding the following code at the beginning of
    the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not validate the token, nor do we check whether it is expired. This is
    the role of the BookmarkrSyncr external service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment variable that is used to hold the PAT token is named `BOOKMARKR_PAT`.
    This name ensures that this variable does not conflict with any other variable
    set on the userâ€™s computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created a custom exception class, `PatNotFoundException`, to inform
    the client in case the PAT token has not been found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, since the PAT token is retrieved, we need to send it to the external service.
    We hence need to modify the HTTP client to pass the token in the HTTP headers
    of the request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the request to the external service is successful, we know that the PAT
    token is valid. We will then save it to the environment variable if it is not
    already present there. The updated code is therefore as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the PAT token is invalid or expired, we need to inform the client
    so that the proper error message is displayed to the user. We therefore need to
    modify the code block that handles the `Unauthorized` status code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code is straightforward and easy to understand. One thing worth mentioning
    though is that here, again, we created custom exception classes, namely `PatInvalidException`
    and `PatExpiredException`, to clearly express the intent of an error when raising
    them. These exception classes can be found in the `Exceptions.cs` file located
    in the `BookmarkrSyncrServiceAgent` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to go back to the `SyncCommand` class, handle the responses
    from the service agent, and display the appropriate error messages to the user.
    For that matter, we need to modify the code of the `OnSyncCommand` handler method
    to catch the custom exceptions described previoulsy. The `catch` blocks are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And thatâ€™s it â€“ we have completed all the required code modifications for Bookmarkr
    to ensure secure communication with the external service, BookmarkrSyncr, by using
    a PAT (it was about time, right? ðŸ˜‰).
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s see if this works!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test is to invoke the `sync` command without passing a PAT token.
    Knowing that it will not be found in the `BOOKMARKR_PAT` environment variable,
    the following error is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 â€“ The PAT token was not found](img/B22400_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 â€“ The PAT token was not found
  prefs: []
  type: TYPE_NORMAL
- en: 'The second test is to invoke the `sync` command with an invalid PAT token.
    Here too, an error message is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 â€“ The PAT token is invalid](img/B22400_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 â€“ The PAT token is invalid
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test is to invoke the `sync` command with an expired PAT token. Here
    too, an error message is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 â€“ The PAT token is expired](img/B22400_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 â€“ The PAT token is expired
  prefs: []
  type: TYPE_NORMAL
- en: 'The final test is to invoke the `sync` command with a valid PAT token. We can
    see that the bookmarks have been synchronized and that the PAT token has been
    saved to the `BOOKMARKR_PAT` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 â€“ The PAT token is valid](img/B22400_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 â€“ The PAT token is valid
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful! We now know all we need to know to assess and enhance the security
    of our CLI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the various forms security can take, and we learned
    that it is not limited to the security of the applicationâ€™s code but rather covers
    a broad spectrum of areas that span its entire lifecycle. We learned what tools
    and techniques we can use to assess and enhance the security posture of our CLI
    application. We also learned how to secure access to user data, especially when
    dealing with external services, by implementing authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have now all the necessary knowledge and skills to build,
    secure, test, package, and release your very own CLI applications to the world.
    Look at you â€“ what a milestone you have achieved. Take a moment to be proud of
    yourself and to celebrate!
  prefs: []
  type: TYPE_NORMAL
- en: My journey with you, throughout the pages of this book, is almost over. But
    before you turn the last page and gently close the cover of this book, there is
    one last thing I wanted to share with you, one final chapter whose purpose is
    to provide you with additional learning material to help you continue your journey
    as well as pointing you to some useful tools and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #1 â€“ Update dependency versions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to list outdated packages that have reached their end of support
    and talked about the importance of updating these. However, I havenâ€™t updated
    these.
  prefs: []
  type: TYPE_NORMAL
- en: Your task is to clone the code into your GitHub or Azure DevOps account and
    to update it.
  prefs: []
  type: TYPE_NORMAL
- en: Once the dependencies have been updated, you will need to validate that the
    behavior of the application was not impacted, in other words, you need to ensure
    that the application still behaves as expected. This can be done by running the
    tests you developed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #2 â€“ Use Mend Bolt to scan the code for vulnerabilities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your task is to clone the code into your GitHub or Azure DevOps account, enable
    Mend Bolt, and run a security scan. If any vulnerability is to be found, fix it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #3 â€“ Allow BookmarkrSyncr to manage multiple users'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we updated BookmarkrSyncr to receive and validate a PAT, it does not
    use this token to retrieve and update the appropriate userâ€™s data.
  prefs: []
  type: TYPE_NORMAL
- en: You are tasked to update the code to make this happen. The easiest way to achieve
    this is to have a separate JSON file for every user whose name matches the value
    of the PAT. Hence, the bookmarks for every user can be stored and retrieved from
    there.
  prefs: []
  type: TYPE_NORMAL
