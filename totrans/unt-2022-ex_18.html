<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-240"><a id="_idTextAnchor256" class="pcalibre1 pcalibre calibre6"/>13</h1>
<h1 id="_idParaDest-241" class="calibre5"><a id="_idTextAnchor257" class="pcalibre1 pcalibre calibre6"/>Implementing AI with Sensors, Behavior Trees, and ML-Agents</h1>
<p class="calibre3">In <a href="B18347_12.xhtml#_idTextAnchor232" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>, we dove into all the required details for approaching adding audio to our games. We did this by introducing an audio manager and individual reusable audio player components so that designers and developers can easily add different types of game audio to create a sound experience that encompasses our players. We enforced good coding practices to ensure we’re writing maintainable code, with an emphasis on reusability and extensibility, to simplify the challenges in our daily game developer lives.</p>
<p class="calibre3">Now that we have addressed the sound design of our game, we can continue to finish out the<a id="_idIndexMarker1325" class="pcalibre1 pcalibre calibre6"/> enemy <strong class="bold">non-player character</strong> (<strong class="bold">NPC</strong>) mechanics for our FPS game’s level by implementing some basic <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>). We’ll <a id="_idIndexMarker1326" class="pcalibre1 pcalibre calibre6"/>accomplish adding simple AI navigation by reusing and refactoring our previous 2D components and code to 3D. We’ll continue to discuss the elevation and sophistication of NPC<a id="_idIndexMarker1327" class="pcalibre1 pcalibre calibre6"/> systems <a id="_idIndexMarker1328" class="pcalibre1 pcalibre calibre6"/>with <strong class="bold">behavior trees</strong> and <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) tools.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topi<a id="_idTextAnchor258" class="pcalibre1 pcalibre calibre6"/>cs.</p>
<ul class="calibre17">
<li class="calibre15">Refactoring the 2D enemy systems to 3D with NavMesh</li>
<li class="calibre15">Dynamic enemies with sensors and behavior trees</li>
<li class="calibre15">Introducing ML with ML-Agents</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to create a remarkable gameplay experience for your players by implementing AI-based interactions with NPCs, seamlessly navigating the level environment, and executing a set of behaviors on their own. You will better understand the differences between 2D and 3D implementation because we’ll revisit the 2D methods and refactor for 3D while making improvements in the process.</p>
<h1 id="_idParaDest-242" class="calibre5">Technical requireme<a id="_idTextAnchor259" class="pcalibre1 pcalibre calibre6"/>nts</h1>
<p class="calibre3">You can download the complete project from GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<h1 id="_idParaDest-243" class="calibre5"><a id="_idTextAnchor260" class="pcalibre1 pcalibre calibre6"/>Refactoring the 2D enemy systems to 3D with NavMesh</h1>
<p class="calibre3">In this chapter, the<a id="_idIndexMarker1329" class="pcalibre1 pcalibre calibre6"/> goal is to guide you<a id="_idIndexMarker1330" class="pcalibre1 pcalibre calibre6"/> through the comprehensive process of bringing this hovering adversary to life, turned against us by the evil plant entity invading our systems. Its mission is to patrol the corridors of the habitat station to prevent the player from eradicating the infestation and getting back to Kryk’zylx normalcy (whatever that is).</p>
<div><div><img alt="Figure 13.1 – Enemy hover bot on patrol" src="img/B18347_13_01.jpg" class="calibre127"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Enemy hover bot on patrol</p>
<p class="calibre3">Way back in <a href="B18347_08.xhtml#_idTextAnchor151" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, for our 2D game, we solved the problem of enemy NPC navigation by using a simple patrol waypoint behavior where the enemy robot moves between two waypoints in 2D space – a left and a right.</p>
<p class="calibre3">Well, we’re going to do something similar here. However, because we’re now working in 3D space and have a more complex floor plan to navigate, we’ll still set up a patrol path using waypoints. Still, we’ll now use<a id="_idIndexMarker1331" class="pcalibre1 pcalibre calibre6"/> Unity’s <strong class="bold">AI Navigation</strong> package and its <strong class="bold">NavMesh</strong> components<a id="_idIndexMarker1332" class="pcalibre1 pcalibre calibre6"/> to accomplish the task of navigating between them. NPC navigation is crucial for creating immersive game environments, and Unity’s updated 3D NavMesh system, introduced in a Unity 2022.3 release, offers an efficient solution.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Information about the AI Navigation package can be found here: <a href="https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/</a></p>
<p class="calibre3">Revising and refactoring previously programmed components to save on development time is something we’ve discussed a few times already since the inception of the 3D FPS project, and there will be no exception now. There is no sense starting from scratch every time; let’s rely on the assets we already have in our bag of tricks and revise where required (ultimately, adding to our bag).</p>
<p class="calibre3">We’ll need a bit of a refresher for the basic component structure to understand where 3D-related revisions, specifically for NavMesh refactoring, will be required. So, here we go. Let’s review <a id="_idIndexMarker1333" class="pcalibre1 pcalibre calibre6"/>the <a id="_idIndexMarker1334" class="pcalibre1 pcalibre calibre6"/>following <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) diagram<a id="_idIndexMarker1335" class="pcalibre1 pcalibre calibre6"/> representing the behavior responsible for moving the NPC in the 2D project:</p>
<div><div><img alt="Figure 13.2 – 2D patrol waypoints reference UML" src="img/B18347_13_02.jpg" class="calibre151"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.2 – 2D patrol waypoints reference UML</p>
<p class="calibre3">Interestingly enough, we’re going to reuse about 96% of what we see in the preceding diagram (no, I didn’t do the math; don’t hold me to that percentage). It’s primarily the <code>PatrolWaypoints</code> class that is in need of revising because it’s the implementation of the <code>IBehaviorPatrolWaypoints</code> interface that actually moves the enemy NPCs between the waypoints. We simply need a behavior implementation for the NavMesh instead – because we did the work upfront, following good programming practices, to extend<a id="_idIndexMarker1336" class="pcalibre1 pcalibre calibre6"/> functionality<a id="_idIndexMarker1337" class="pcalibre1 pcalibre calibre6"/> without modifying the implementing class.</p>
<p class="calibre3">First things first, let’s gather the 2D scripts for reuse.</p>
<h2 id="_idParaDest-244" class="calibre8"><a id="_idTextAnchor261" class="pcalibre1 pcalibre calibre6"/>Importing scripts from the 2D project</h2>
<p class="calibre3">We currently <a id="_idIndexMarker1338" class="pcalibre1 pcalibre calibre6"/>require<a id="_idIndexMarker1339" class="pcalibre1 pcalibre calibre6"/> the scripts from the previous 2D adventure game project. We’ll need several files this time, unlike the previous time we reused and refactored the 2D components for 3D in <a href="B18347_10.xhtml#_idTextAnchor187" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, in the <em class="italic">Refactoring environment interactions to 3D API methods</em> section, where we only needed a few files. So, for the scripts necessary for the 3D FPS project, let’s use the Unity package exporter to obtain the scripts along with their dependencies.</p>
<p class="callout-heading">Download scripts</p>
<p class="callout">Alternatively, download <strong class="source-inline1">patrol-behavior-and-dependencies.zip</strong>, with the already exported scripts and dependencies required, from the book’s GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Script-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Script-Assets</a>.</p>
<p class="calibre3">For a review of the process, you can revisit <a href="B18347_09.xhtml#_idTextAnchor169" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, where we exported the sliding puzzle game assets. This process certainly isn’t one of the most fun parts of developing games, but you’ll find yourself doing these types of things from time to time. Let’s get to it.</p>
<p class="calibre3">Open the previous 2D <a id="_idIndexMarker1340" class="pcalibre1 pcalibre calibre6"/>adventure <a id="_idIndexMarker1341" class="pcalibre1 pcalibre calibre6"/>game project in Unity now and follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Go to the <code>Assets/Scripts/Behaviors</code> folder in the <strong class="bold">Project</strong> window.</li>
<li class="calibre15">Right-click on the <code>PatrolWaypoints.cs</code> file and select <strong class="bold">Export Package…</strong>, as seen in <em class="italic">Figure </em><em class="italic">13</em><em class="italic">.3</em> (<em class="italic">A</em>).</li>
</ol>
<p class="calibre3">The 2D patrolling waypoints behavior is what we want to leverage our reuse of for our enemy bot NPC in the 3D FPS game, so we’ll use it as the basis for our export and grab its dependencies and other related scripts in the process. Don’t worry – in the next step, I’ve already sorted out what scripts we’ll want here to save you the time and stress of figuring it out for yourself.</p>
<ol class="calibre14">
<li value="3" class="calibre15">Ensure you’ve selected the following files in the <code>Assets/Scripts/</code>:<ul class="calibre22"><li class="calibre15"><code>Bullet.cs</code></li><li class="calibre15"><code>Enemy.cs</code></li><li class="calibre15"><code>EnemyController.cs</code></li><li class="calibre15"><code>PlayerShootingPooled.cs</code></li><li class="calibre15"><code>ProjectileBase.cs</code></li><li class="calibre15"><code>ProjectileDamage.cs</code></li><li class="calibre15"><code>WeaponRanged.cs</code></li></ul></li><li class="calibre15"><code>Assets/Scripts/Behaviors/</code>:<ul class="calibre22"><li class="calibre15"><code>PatrolWaypoints.cs</code></li></ul></li><li class="calibre15"><code>Assets/Scripts/Data/</code>:<ul class="calibre22"><li class="calibre15"><code>EnemyConfigData.cs</code></li></ul></li><li class="calibre15"><code>Assets/Scripts/ExtensionMethods/</code>:<ul class="calibre22"><li class="calibre15"><code>LayerMaskExtensions.cs</code></li></ul></li><li class="calibre15"><code>Assets/Scripts/Interfaces/</code>:<ul class="calibre22"><li class="calibre15"><code>IBehaviorAttack.cs</code></li><li class="calibre15"><code>IBehaviorPatrolWaypoints.cs</code></li></ul></li><li class="calibre15"><code>IWeapon.cs</code>:<ul class="calibre22"><li class="calibre15"><code>IWeaponLaser.cs</code></li></ul></li><li class="calibre15"><code>Assets/Scripts/Systems/</code>:<ul class="calibre22"><li class="calibre15"><code>EventSystem Example/</code>:</li><li class="calibre15"><code>ExampleListener.cs</code></li><li class="calibre15"><code>ExampleTrigger.cs</code></li><li class="calibre15"><code>EventSystem.cs</code></li></ul></li></ul></li>
</ol>
<p class="calibre3">You can see <a id="_idIndexMarker1342" class="pcalibre1 pcalibre calibre6"/>from the list of <a id="_idIndexMarker1343" class="pcalibre1 pcalibre calibre6"/>dependencies selected that we’ll be using some of these later to fast-track the implementation of projectile shooting and events.</p>
<ol class="calibre14">
<li value="4" class="calibre15">Once you have the files selected, click the <strong class="bold">Export…</strong> button and save the exported package file (with any name you choose) to a location where we can easily find it to import into our current 3D FPS project.</li>
<li class="calibre15">Now, open the 3D FPS project, if not already, so we can import the files.</li>
</ol>
<p class="calibre3">As shown in <em class="italic">Figure 13</em><em class="italic">.3</em> (<em class="italic">B</em>), we’ll be presented with the <strong class="bold">Import Unity Package</strong> dialog when we drag and drop the exported package from your system’s file manager to the 3D FPS game’s <strong class="bold">Project</strong> window.</p>
<ol class="calibre14">
<li value="6" class="calibre15">Click <strong class="bold">Import</strong>.</li>
</ol>
<div><div><img alt="Figure 13.3 – 2D project export and 3D project import" src="img/B18347_13_03.jpg" class="calibre152"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.3 – 2D project export and 3D project import</p>
<p class="calibre3">You’ll likely <a id="_idIndexMarker1344" class="pcalibre1 pcalibre calibre6"/>notice<a id="_idIndexMarker1345" class="pcalibre1 pcalibre calibre6"/> after the import finishes that we immediately have a console error:</p>
<pre class="source-code">
Assets\Scripts\ProjectileDamage.cs(4,48): error CS0535: 'ProjectileDamage' does not implement interface member 'IDamage.DoDamage(Collider, bool)'</pre> <p class="calibre3">We’ll first – quickly and easily – fix this compiler error while the remainder of the changes will be focused on the refactoring of the 2D to 3D functionality. So, to fix the error, we simply need to change <code>Collider2D</code> to <code>Collider</code> in the <code>ProjectileDamage</code> class’s <code>DoDamage()</code> method signature to properly implement the <code>IDamage</code> interface as defined in this 3D project.</p>
<p class="calibre3">Open <code>Assets/Scripts/ProjectileDamage.cs</code> in your IDE and change both the <code>UnityEvent</code> declaration and the <code>DoDamage()</code> method signature to the following:</p>
<pre class="source-code">
public UnityEvent&lt;Collider, bool&gt; OnDamageEvent;
public void DoDamage(Collider collision, bool isAffected)
    =&gt; OnDamageEvent?.Invoke(collision, isAffected);</pre> <p class="calibre3">Simple.</p>
<p class="calibre3">Moving on with the remaining refactoring will require an additional step to ensure we can reference the <a id="_idIndexMarker1346" class="pcalibre1 pcalibre calibre6"/>required 3D navigation types. This <a id="_idIndexMarker1347" class="pcalibre1 pcalibre calibre6"/>simply means we must first<a id="_idIndexMarker1348" class="pcalibre1 pcalibre calibre6"/> add the <strong class="bold">AI Navigation</strong> package to our project.</p>
<p class="calibre3">Open <code>nav</code> in the search box to filter the available packages and select <strong class="bold">AI Navigation</strong> from the list view. Finish by clicking the <strong class="bold">Install</strong> button.</p>
<div><div><img alt="Figure 13.4 – Installing the AI Navigation package" src="img/B18347_13_04.jpg" class="calibre153"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Installing the AI Navigation package</p>
<p class="calibre3">Okay, now we’re<a id="_idIndexMarker1349" class="pcalibre1 pcalibre calibre6"/> ready to move on updating<a id="_idIndexMarker1350" class="pcalibre1 pcalibre calibre6"/> our code reuse to use the NavMesh components.</p>
<h2 id="_idParaDest-245" class="calibre8"><a id="_idTextAnchor262" class="pcalibre1 pcalibre calibre6"/>Refactoring the PatrolWaypoints class for NavMesh</h2>
<p class="calibre3">Unity’s NavMesh<a id="_idIndexMarker1351" class="pcalibre1 pcalibre calibre6"/> system greatly simplifies setting<a id="_idIndexMarker1352" class="pcalibre1 pcalibre calibre6"/> up complex 3D waypoint<a id="_idIndexMarker1353" class="pcalibre1 pcalibre calibre6"/> navigation where NPCs can move more naturally and interact in believable ways, which contributes to enhancing the game’s immersion for our players. The modular, adaptable code design (i.e., SOLID principles and composition) we adhere to also makes switching between 2D and 3D and adding or swapping components easy. That’s why we’ll be able to quickly make only a few updates to our existing 2D components to have the 3D FPS game up and running with patrolling enemy bot NPCs!</p>
<p class="calibre3">Primarily, as indicated earlier in the UML diagram, the most significant revision will be with the patrol waypoints behavior class. We’ll actually end up replacing most of it, so open the newly imported <code>Assets/Scripts/Behaviors/PatrolWaypoints</code> script in your IDE now so we can get started. And the first thing we’ll start with – beginning at the top of the script and working our way down – is the waypoint variables.</p>
<h3 class="calibre10">Updating the waypoint variables</h3>
<p class="calibre3">We’re simply <a id="_idIndexMarker1354" class="pcalibre1 pcalibre calibre6"/>going to replace the old transform <code>WaypointPatrolLeft</code> and <code>WaypointPatrolRight</code> variable declarations with the following single list of waypoint transforms declaration – serialized with the <code>[SerializeField]</code> attribute so they’re assignable in the Inspector:</p>
<pre class="source-code">
[Header("Patrol Waypoints")]
[SerializeField] private List&lt;Transform&gt; _waypoints;</pre> <p class="calibre3">Okay, off to a good start; we’ll now be able to add any number of waypoints to the <code>_waypoints</code> list for the enemy bot NPC to navigate. We’ll tackle the remaining variables next.</p>
<p class="calibre3">We’ll replace the movement-related private member variables with only the following two – <code>_waypointCurrentIndex</code> and <code>_navMeshAgent</code> – to hold the reference to <code>NavMeshAgent</code> and to keep track of the current waypoint the agent will head towards from the list of transforms we add to the preceding <code>_waypoints</code> list. Remove the 2D private member variables now and replace them with the following:</p>
<pre class="source-code">
private int _waypointCurrentIndex = 0;
private NavMeshAgent _navMeshAgent;</pre> <p class="calibre3">Since the <code>_navMeshAgent</code> variable will hold the reference to <code>NavMeshAgent</code> that’s used to move our enemy NPC – its accessor is private and not serialized, we’ll have to ensure it’s assigned by using the Unity <code>Awake()</code> lifecycle message event. Do that now by adding the following method to the <code>PatrolWaypoints</code> class:</p>
<pre class="source-code">
private void Awake()
{
    _navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    Debug.Assert(_navMeshAgent != null,
        $"[{nameof(PatrolWaypoints)} NavMesh agent is null!]",
            gameObject);
}</pre> <p class="calibre3">We’ll be adding<a id="_idIndexMarker1355" class="pcalibre1 pcalibre calibre6"/> the <code>NavMeshAgent</code> component to our enemy patrol bot when we set up its Prefab in the <em class="italic">Configuring the enemy NavMesh Agent (Prefab)</em> section. So, if we forget to add the component, <code>GetComponent()</code> will return a <code>null</code> assignment to the <code>_navMeshAgent</code> variable, and that just won’t do! To make ourselves aware of this potential forgetfulness, we’ll use a <code>Debug.Assert()</code> statement – if the condition is not met, an error message will be logged to the Unity console.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Information about <strong class="source-inline1">Debug.Assert</strong> can be found here: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Debug.Assert.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Debug.Assert.xhtml</a>.</p>
<p class="calibre3">That takes care of the variables! We can now move down to our first method to update, which involves<a id="_idIndexMarker1356" class="pcalibre1 pcalibre calibre6"/> getting things set up for the new patrolling behavior.</p>
<h3 class="calibre10">Initializing the patrolling behavior</h3>
<p class="calibre3">Now, let’s look<a id="_idIndexMarker1357" class="pcalibre1 pcalibre calibre6"/> at the <code>Init()</code> method. First, we’ll change the method signature, specifically the parameters, because we no longer need the values for the rigid body nor the direction, as <code>NavMeshAgent</code> will now take care of these. We’re just going to leave the <code>acceleration</code> and <code>speed</code> parameters since they still apply.</p>
<p class="calibre3">Modify the <code>Init()</code> method signature to the following:</p>
<pre class="source-code">
public void Init(float acceleration, float speed) { }</pre> <p class="calibre3">For the contents of the <code>Init()</code> method, we’re going to remove all the previous movement code and replace it with the following – for working with <code>NavMeshAgent</code>:</p>
<pre class="source-code">
public void Init(float acceleration, float speedMax)
{
    _navMeshAgent.acceleration = acceleration;
    _navMeshAgent.speed = speedMax;
    if (_waypoints.Count &gt; 0)
    {
        _navMeshAgent.SetDestination(_waypoints[0].position);
    }
    _waypointCurrentIndex = 0;
}</pre> <p class="calibre3">A quick breakdown of the code looks like this:</p>
<ul class="calibre17">
<li class="calibre15"><code>_navMeshAgent.acceleration</code>: We assign the acceleration that will be passed in from our enemy configuration data to determine how quickly the agent will reach its maximum speed.</li>
<li class="calibre15"><code>_navMeshAgent.speed</code>: We assign the speed passed in from our enemy configuration data to set the maximum speed the agent will travel along its path to the current waypoint.</li>
<li class="calibre15"><code>_waypoints.Count &gt; 0</code>: A quick insurance check that we indeed have a list of waypoints to work with before attempting to get the position of one.</li>
<li class="calibre15"><code>_navMeshAgent.SetDestination</code>: When the behavior is initialized, what waypoint will the NavMesh Agent travel to? This one. The index value of <code>0</code> addresses the first waypoint that was added to the <code>_waypoints</code> list.</li>
<li class="calibre15"><code>_waypointCurrentIndex</code>: Again, specifying the first waypoint in the <code>_waypoints</code> list by its index value of <code>0</code> as the current waypoint the agent will travel to.</li>
</ul>
<p class="calibre3">To quickly summarize what we did here, just as before in the 2D code, the <code>Init()</code> method is used to initialize the movement parameters for the NavMesh Agent. It is specifically designed to initiate navigation between waypoints as part of the implemented enemy NPC patrolling behavior.</p>
<p class="calibre3"><code>NavMeshAgent</code> parameters can be a vital part of game balancing. They allow developers to adjust NPC behavior and game difficulty to match the design – creating challenging areas or guiding gameplay experiences. Hint: you’ll be adjusting these values later as you playtest the game level.</p>
<p class="calibre3">With the <a id="_idIndexMarker1358" class="pcalibre1 pcalibre calibre6"/>initialization of the behavior completed, we can move down further in the class to revise the required methods.</p>
<h3 class="calibre10">Revising the update methods</h3>
<p class="calibre3">The <code>UpdateDirection()</code> method<a id="_idIndexMarker1359" class="pcalibre1 pcalibre calibre6"/> wasn’t technically responsible for moving the object in the previous 2D implementation (the <code>UpdateVelocity()</code> method was). Still, to keep within the same logical naming, I’ve decided to reuse it here.</p>
<p class="calibre3">The previous <code>UpdateDirection()</code> code was simply responsible for facing (flipping) the patrolling sprite object in the direction of movement – since the 2D game is a side-view, we don’t really have a rotation. Well, in a 3D perspective game, we certainly do have object rotation to contend with. Thankfully, the <code>NavMeshAgent</code> component will automatically calculate and apply the object’s rotation while pathfinding its way between waypoints.</p>
<p class="callout-heading">Tip</p>
<p class="callout">To have more control over the agent’s rotation, you’ll have to manage it manually. Keep in mind that if you choose to, you’ll need to disable the NavMesh Agent’s automatic rotation by setting <strong class="source-inline1">_navMeshAgent.updateRotation = </strong><strong class="source-inline1">false</strong>.</p>
<p class="calibre3">Let’s see what the new <code>UpdateDirection()</code> method looks like now. Replace the code with the<a id="_idIndexMarker1360" class="pcalibre1 pcalibre calibre6"/> following:</p>
<pre class="source-code">
private void UpdateDirection()
{
    if (!_navMeshAgent.pathPending
        &amp;&amp; _navMeshAgent.remainingDistance
            &lt;= _navMeshAgent.stoppingDistance)
    {
        MoveToNextWaypoint();
    }
}</pre> <p class="calibre3">As we can see here, for the <code>UpdateDirection()</code> method, we’re now dealing directly with <code>NavMeshAgent</code>. We’re evaluating the current values for the progression using the <code>pathPending</code> and <code>remainingDistance</code> properties of the agent heading to the currently set destination waypoint. Precisely, we’ll execute a call to <code>MoveToNextWaypoint()</code> to set moving to the next waypoint when the agent’s current remaining distance is less than the stopping distance.</p>
<p class="callout-heading">Important note</p>
<p class="callout">In this example, we rely on the <strong class="source-inline1">NavMeshAgent</strong> component’s default values for its stopping distance, obstacle avoidance, and path-finding values.</p>
<p class="calibre3">As you can see, we’ve added a new method to handle setting the next waypoint from the list of available waypoints for when the agent arrives at the currently assigned waypoint. If you’re following along with the code directly, you can automatically use your IDE’s refactoring tools to generate the new <code>MoveToNextWaypoint()</code> method. Either way, with the new method created, add the following code to it:</p>
<pre class="source-code">
private void MoveToNextWaypoint()
{
    if (_waypoints == null
        || _waypoints.Count == 0)
            return;
    _waypointCurrentIndex =
        (_waypointCurrentIndex + 1) % _waypoints.Count;
    _navMeshAgent.SetDestination
        (_waypoints[_waypointCurrentIndex].position);
}</pre> <p class="calibre3">Nothing too tricky is <a id="_idIndexMarker1361" class="pcalibre1 pcalibre calibre6"/>happening here; it’s just a simple <em class="italic">null check</em> and looping through the waypoints. Even so, a simple breakdown of these lines looks like this:</p>
<ul class="calibre17">
<li class="calibre15"><code>if (_waypoints == null || _waypoints.Count == 0)</code>: Doing a double-check on the available waypoints in the list here, we’re ensuring it’s not <code>null</code>, and the count for the number of waypoints in the list is not <code>0</code> (zero) before continuing to execute statements to assign the next waypoint for the agent to travel to.</li>
<li class="calibre15"><code>_(_waypointCurrentIndex + 1) % _waypoints.Count</code>: The modulus operator (or remainder operator) ensures we loop back to the <em class="italic">beginning of the list</em> index when the <code>_waypointsCurrentIndex</code> value equals the list count.</li>
<li class="calibre15"><code>_navMeshAgent.SetDestination</code>: This is the <code>NavMeshAgent</code> method we call to tell the agent to start heading toward the passed-in position – the index assigned in the preceding line.</li>
</ul>
<p class="callout-heading">Modulus or remainder operator % (C#)</p>
<p class="callout">A typical shorthand way of using the modulus operator is to guarantee a seamless infinite loop of a list of items by ensuring that the current item index progresses linearly through each list item and only wraps around to <strong class="source-inline1">0</strong> upon reaching the end of the list.</p>
<p class="callout">Additional reading can be found here: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators</a>.</p>
<p class="calibre3">In this section, we’ve sorted out the update methods to work with the new NavMesh system. Next, we’ll <a id="_idIndexMarker1362" class="pcalibre1 pcalibre calibre6"/>still work with methods, but instead of revising, we’ll remove ones that are no longer needed.</p>
<h3 class="calibre10">Cleaning up unused methods</h3>
<p class="calibre3">Still working <a id="_idIndexMarker1363" class="pcalibre1 pcalibre calibre6"/>within the <code>PatrolWaypoints</code> class, we have some no longer needed methods. Instead of just leaving them in the class, let’s clean them up – by removing them – so if we ever need to revisit the class later, we won’t be confused by methods with zero references.</p>
<p class="calibre3">Remove the following methods from the <code>PatrolWaypoints</code> class now:</p>
<ul class="calibre17">
<li class="calibre15"><code>UpdateVelocity()</code>: The velocity is now calculated internally by <code>NavMeshAgent</code>.</li>
<li class="calibre15"><code>SetWaypoints(Transform left, Transform right)</code>: We won’t be spawning the patrolling enemy NPC NavMesh agents in this example. Consider this an opportunity to add a patrolling enemy spawner to your game later!</li>
<li class="calibre15">Oh, and give “update <code>TickPhysics()</code>“ a quick fix by removing the now invalid call to the removed <code>UpdateVelocity()</code> method, leaving simply this expression:<pre class="source-code">
public void TickPhysics() =&gt; UpdateDirection();</pre></li> </ul>
<p class="calibre3">Methods removed; check! To compare your revisions to the completed <code>PatrolWaypoints</code> class, you can find it here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/blob/main/ch13/Unity-Project/Assets/Scripts/Behaviors/PatrolWaypoints.cs" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/blob/main/ch13/Unity-Project/Assets/Scripts/Behaviors/PatrolWaypoints.cs</a>.</p>
<p class="calibre3">Updated the<a id="_idIndexMarker1364" class="pcalibre1 pcalibre calibre6"/> behavior interface? Next refactoring item to check!</p>
<h3 class="calibre10">Updating the behavior interface</h3>
<p class="calibre3">This will be another<a id="_idIndexMarker1365" class="pcalibre1 pcalibre calibre6"/> quick section (very quick). The only changes we need to make for the <code>IBehaviorPatrolWaypoints</code> interface – you’ve probably already noticed the errors from saving the previous changes to the <code>PatrolWaypoints</code> class – are directly related to the implementing class’s changes.</p>
<p class="calibre3">Update the <code>IBehaviorPatrolWaypoints</code> code to the following to resolve the issues:</p>
<pre class="source-code">
public interface IBehaviorPatrolWaypoints
{
    void Init(float acceleration, float speedMax);
    void TickPhysics();
}</pre> <p class="calibre3">Lastly, in addition to the error we just resolved, we have a few additional ones to clean up before we can call this process entirely done.</p>
<h3 class="calibre10">Resolving remaining console errors</h3>
<p class="calibre3">For the last bit of <a id="_idIndexMarker1366" class="pcalibre1 pcalibre calibre6"/>housekeeping on the 2D code refactoring, when we changed the behavior <code>PatrolWaypoints.Init()</code> method’s signature in the <code>PatrolWaypoints</code> class, we caused an error in the implementing classes. So, we’ll simply remove the unnecessary parameter variables to fix it.</p>
<p class="calibre3">Open the <code>EnemyController.cs</code> script and update the portion of the <code>if</code> block body shown to the following:</p>
<pre class="source-code">
private void Awake()
{
    …
    // Get behaviors and initialize.
    if (TryGetComponent&lt;IBehaviorPatrolWaypoints&gt;(
        out _behaviorPatrol))
    {
        _behaviorPatrol.Init(
            _config.Acceleration,
            _config.SpeedMax);
    }
    …</pre> <p class="calibre3">For the <code>_behaviorPatrol.Init()</code> call, the only <code>config</code> variables we must pass now are the acceleration and speed values. Easy-peasy.</p>
<p class="callout-heading">Completed 2D to 3D refactored code</p>
<p class="callout">It wasn’t a ton of changes, but it certainly may have seemed that way as we stepped through each one at a time and touched multiple scripts. If it left you a bit fuzzy on the final state of the code, you can refer to the completed scripts in the GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts</a>.</p>
<p class="calibre3">Also, since we’re no longer using a rigid body to move the enemy NPC between waypoints, we can remove all references to <code>Rigidbody2D</code> in the <code>EnemyController</code> class, which includes removing the following lines:</p>
<pre class="source-code">
// In class EnemyController, delete:
  private Rigidbody2D _rb;
// In Awake(), delete:
  _rb = GetComponent&lt;Rigidbody2D&gt;();
// In FixedUpdate(), delete:
  else
      _rb.velocity = Vector2.zero;</pre> <p class="calibre3">Whew, we are done! We didn’t even break a sweat with all the 2D to 3D refactoring we completed in this section, right!? We are nearly there to test out our game’s new NavMesh setup for<a id="_idIndexMarker1367" class="pcalibre1 pcalibre calibre6"/> the 3D FPS enemy patrols. Two steps remain, including configuring the patrolling enemy Prefab next, and they’re also no sweat for us to complete now.</p>
<h2 id="_idParaDest-246" class="calibre8"><a id="_idTextAnchor263" class="pcalibre1 pcalibre calibre6"/>Configuring the enemy NavMesh Agent (Prefab)</h2>
<p class="calibre3">Setting up a NavMesh <a id="_idIndexMarker1368" class="pcalibre1 pcalibre calibre6"/>Agent for <a id="_idIndexMarker1369" class="pcalibre1 pcalibre calibre6"/>waypoint patrol requires technical and visual setup in the Unity Editor, as well as careful consideration of the bot’s behavior for optimal player experience – nothing we haven’t done before. But, because there are several steps involved in the process, let’s first break it down into high-level tasks:</p>
<ol class="calibre14">
<li class="calibre15"><strong class="bold">Designing the enemy bot</strong>: We’ll select the 3D model to use for the NavMesh Agent and create the Prefab asset.</li>
<li class="calibre15"><strong class="bold">Adding the enemy base type and controller components</strong>: We’ll add the required components to give the enemy object properties and state.</li>
<li class="calibre15"><strong class="bold">Configuring the patrolling behavior</strong>: We’ll add the behavior component that implements patrolling waypoints.</li>
<li class="calibre15"><strong class="bold">Adjusting NavMesh agent for the environment</strong>: We’ll set the NavMesh Agent type and properties for the enemy bot.</li>
<li class="calibre15"><strong class="bold">Testing and tweaking settings</strong>: We’ll playtest and adjust values for the desired gameplay.</li>
</ol>
<p class="calibre3">Not so bad, only <a id="_idIndexMarker1370" class="pcalibre1 pcalibre calibre6"/>five steps! Here<a id="_idIndexMarker1371" class="pcalibre1 pcalibre calibre6"/> we go; let’s knock out the first step.</p>
<h3 class="calibre10">Designing the enemy bot</h3>
<p class="calibre3">This will be super<a id="_idIndexMarker1372" class="pcalibre1 pcalibre calibre6"/> easy because we’ll leverage more Polypix Studios 3D models provided for our game’s use. We have a lovely hovering camera drone (armed with some type of weaponry) available in the assets we previously added to the 3D FPS project in <a href="B18347_11.xhtml#_idTextAnchor212" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a>, which will be perfect for a patrolling enemy!</p>
<div><div><img alt="Figure 13.5 – Patrol hover bot reporting for duty!" src="img/B18347_13_05.jpg" class="calibre154"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Patrol hover bot reporting for duty!</p>
<p class="calibre3">Here are the steps we’ll follow to build out the enemy patrol bot. Use <em class="italic">Figure 13</em><em class="italic">.6</em> as an object hierarchy <a id="_idIndexMarker1373" class="pcalibre1 pcalibre calibre6"/>reference while completing the following steps:</p>
<ol class="calibre14">
<li class="calibre15">Create an empty GameObject in the Hierarchy, reset its transform, and rename it <code>Enemy Hover </code><code>Bot A</code>.</li>
<li class="calibre15">In the <code>Assets/Polypix 3D Assets/Prefabs</code> folder, find the <code>SM_Camera_Drone Variant</code> Prefab and parent it to the new <code>Enemy Hover Bot A</code> object – seen in <em class="italic">Figure 13</em><em class="italic">.5</em>.</li>
</ol>
<p class="calibre3">Remember that it’s always preferred to maintain the graphics as a child of the root object to make future changes easily, should you want or need to.</p>
<ol class="calibre14">
<li value="3" class="calibre15">Set the following transform values for the <code>(0, </code><code>0, 0)</code></li><li class="calibre15"><code>(1.5, </code><code>1.5, 1.5)</code></li><li class="calibre15">Then, for the child <code>SM_Camera_Drone</code> object, set its Y-position value to <code>0.6</code> so that it’s a good height off the ground – this is a hovering patrol bot! We change the child mesh object because we want the parent object anchor to maintain its current position.</li></ul></li>
<li class="calibre15">Back to the <code>Enemy Hover Bot A</code> root object, add the following components to it:<ul class="calibre22"><li class="calibre15"><code>Enemy</code></li><li class="calibre15"><code>EnemyController</code></li><li class="calibre15"><code>PatrolWaypoints</code></li><li class="calibre15"><code>NavMeshAgent</code></li></ul></li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">More information about NavMesh Agent can be found here: <a href="https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshAgent.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshAgent.xhtml</a>.</p>
<ol class="calibre14">
<li value="5" class="calibre15">Now, make a<a id="_idIndexMarker1374" class="pcalibre1 pcalibre calibre6"/> Prefab by dragging <code>Enemy Hover Bot A</code> from the Hierarchy to the <code>Assets/Prefabs</code> folder.</li>
</ol>
<p class="calibre3">The results of these setup steps can be seen in <em class="italic">Figure 13</em><em class="italic">.6</em>. Note that for assigning the waypoints to the <code>PatrolWaypoints</code> component, we’ll add the waypoints to the scene in the <em class="italic">Adding waypoints to the level and </em><em class="italic">testing</em> section.</p>
<div><div><img alt="Figure 13.6 – Enemy hover bot setup" src="img/B18347_13_06.jpg" class="calibre155"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Enemy hover bot setup</p>
<p class="calibre3">That was just the first part. The second part of the setup requires the enemy configuration data<a id="_idIndexMarker1375" class="pcalibre1 pcalibre calibre6"/> that we’ll assign to the <code>EnemyController</code> component’s <strong class="bold">Config</strong> field, seen as (<em class="italic">A</em>) in <em class="italic">Figure 13</em><em class="italic">.6</em>.</p>
<h3 class="calibre10">Configuring the enemy bot properties</h3>
<p class="calibre3">If you<a id="_idIndexMarker1376" class="pcalibre1 pcalibre calibre6"/> remember, in <a href="B18347_07.xhtml#_idTextAnchor130" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 7</em></a>, we’re using a <code>ScriptableObject</code> asset to hold varying configurations to have different property values (for example, to change the enemy’s difficulty).</p>
<p class="calibre3">Following these steps, we’ll create a new enemy configuration asset to assign right now:</p>
<ol class="calibre14">
<li class="calibre15">Create a new <code>Assets/Data</code> folder in the <strong class="bold">Project</strong> window.</li>
<li class="calibre15">While within the new folder, use the <strong class="bold">Create</strong> menu and select <strong class="bold">ScriptableObjects</strong> | <strong class="bold">EnemyConfigData</strong>.</li>
<li class="calibre15">Rename the newly created file asset <code>Enemy Bot </code><code>A Config</code>.</li>
<li class="calibre15">Set the following starting values:<ul class="calibre22"><li class="calibre15"><code>10</code></li><li class="calibre15"><code>4</code></li><li class="calibre15"><code>0</code> (correct, we won’t have the patrol bot idle)</li><li class="calibre15"><code>Infinity</code> (yes, <strong class="bold">infinity</strong> is a valid float value!)</li></ul></li>
<li class="calibre15">Finally, assign the <code>Enemy Bot A Config</code> asset to the <code>Enemy Bot A</code> Prefab’s <code>Enemy</code> component’s <strong class="bold">Config</strong> field and save.</li>
</ol>
<p class="callout-heading">Bonus activity</p>
<p class="callout">Add a blob shadow projector to the enemy bot and light probes to the scene in the area of the level where the bot will be patrolling. This will maintain the high-quality visual fidelity of the game. You can refer to <a href="B18347_11.xhtml#_idTextAnchor212" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a> as a reminder of how we implemented these features.</p>
<p class="calibre3">And that’s all there <a id="_idIndexMarker1377" class="pcalibre1 pcalibre calibre6"/>is to creating the NavMesh Agent enemy patrol bot Prefab! Only two tasks remain to get the bot on patrol: defining the navigation surface and setting the waypoints.</p>
<h3 class="calibre10">Baking the NavMesh Surface</h3>
<p class="calibre3">Now that our NavMesh <a id="_idIndexMarker1378" class="pcalibre1 pcalibre calibre6"/>Agent enemy bot Prefab is ready and equipped with all the necessary components, baking only the desired patrol areas is the next crucial step. We accomplish this with a NavMesh Surface component. By selectively defining the patrol areas in our game’s level, we can influence our level design for more strategic gameplay.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">More information<a id="_idIndexMarker1379" class="pcalibre1 pcalibre calibre6"/> about the NavMesh Surface can be found here: <a href="https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshSurface.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/NavMeshSurface.xhtml</a>.</p>
<p class="calibre3">Using <em class="italic">Figure 13</em><em class="italic">.7</em> as a reference, you can see I’ve decided to have the enemy hover bot patrol the main corridors, indicated by the blue surfaces, connecting the two major sections of the habitat station. We use layers to accomplish selectively baking NavMesh surfaces. Comparatively, we’ve previously utilized layers in a physics context to identify and limit interactions – so, layers have different purposes in Unity.</p>
<div><div><img alt="Figure 13.7 – NavMesh Surface baked and waypoints added" src="img/B18347_13_07.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.7 – NavMesh Surface baked and waypoints added</p>
<p class="calibre3">We’ll first have to<a id="_idIndexMarker1380" class="pcalibre1 pcalibre calibre6"/> add a new layer to select the specific surfaces for NavMesh baking. Using the <code>Floor</code> in the first available numbered <strong class="bold">User </strong><strong class="bold">Layer</strong> fields.</p>
<p class="calibre3">Next, select the contiguous corridor floor sections in the <code>Floor</code> layer by selecting it from the Inspector’s <code>NavMeshSurface</code> component.</p>
<h3 class="calibre10">Configuring the NavMesh Surface</h3>
<p class="calibre3">After assigning floor <a id="_idIndexMarker1381" class="pcalibre1 pcalibre calibre6"/>sections<a id="_idIndexMarker1382" class="pcalibre1 pcalibre calibre6"/> to their designated layer, we’re ready to add the <code>NavMeshSurface</code> component and bake the surfaces – it’s like embedding invisible pathways that dictate the agent’s movements. This baking process will empower the agents we set up to navigate simple and complex paths with speed and accuracy, ensuring seamless AI navigation for our patrolling enemy hover bot!</p>
<p class="calibre3">To bake the NavMesh floor surfaces now, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Add a new empty GameObject to the <code>NavMesh Surface</code>.</li>
</ol>
<p class="calibre3">You can place this just under an organizational object in the <code>"---- </code><code>ENVIRONMENT ----"</code>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Set the <strong class="bold">EditorOnly</strong> tag on organization-only GameObjects in the <strong class="bold">Scene</strong> Hierarchy so these objects aren’t included in builds, saving some resources.</p>
<ol class="calibre14">
<li value="2" class="calibre15">Add a <code>NavMeshSurface</code> component to the <code>NavMesh </code><code>Surface</code> GameObject:<ul class="calibre22"><li class="calibre15">To ensure that only the floor sections we want the enemy bot to patrol get baked, in the <strong class="bold">Object Collection</strong> | <strong class="bold">Include Layers</strong> dropdown, first select <strong class="bold">Nothing</strong>, then select <strong class="bold">Floor</strong>.</li><li class="calibre15">Click the <strong class="bold">Bake</strong> button. The selected floor sections should now show a blue mesh that represents the baked navigation surface, as shown in <em class="italic">Figure 13.7</em>.</li></ul></li>
</ol>
<p class="calibre3">And that’s really all there is to setting up the navigation surfaces for our NavMesh agents. Make sure to revisit the <code>NavMeshSurface</code> component whenever you make changes and re-bake. We’ll now make one final adjustment to the navigation setup via <strong class="bold">Agent Type</strong> before adding waypoints and testing it all out.</p>
<h3 class="calibre10">Configuring the agent type</h3>
<p class="calibre3">An additional <a id="_idIndexMarker1383" class="pcalibre1 pcalibre calibre6"/>consideration we’ll make while baking the NavMesh Surface is to adjust the agent’s size to ensure its capabilities align with our needs. I’ve arbitrarily decided that we don’t want the bot to come too close to the sides of the corridor as it finds its way from waypoint to waypoint.</p>
<p class="calibre3">While referring to <em class="italic">Figure 13</em><em class="italic">.8</em>, proceed to create a new navigation agent type by following these steps:</p>
<ol class="calibre14">
<li class="calibre15">Open the <strong class="bold">Navigation</strong> window by going to <strong class="bold">Window</strong> | <strong class="bold">AI</strong> | <strong class="bold">Navigation</strong>.</li>
<li class="calibre15">Click the plus (<strong class="bold">+</strong>) icon at the bottom-right of the <strong class="bold">Agent Types</strong> list to add a new type.</li>
<li class="calibre15">In the <code>Bot</code>.</li>
<li class="calibre15">In the <code>1</code> to give the bot more of a margin from the walls of the corridors.</li>
<li class="calibre15">In the <code>0.75</code>.</li>
</ol>
<div><div><img alt="Figure 13.8 – Specifying a Bot agent type" src="img/B18347_13_08.jpg" class="calibre156"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Specifying a Bot agent type</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can also access the <strong class="bold">Navigation</strong> window from the <strong class="source-inline1">NavMeshSurface</strong> component by selecting <strong class="bold">Open Agent Settings…</strong> in the <strong class="bold">Agent </strong><strong class="bold">Type</strong> dropdown.</p>
<p class="calibre3">Now that we <a id="_idIndexMarker1384" class="pcalibre1 pcalibre calibre6"/>have a specific bot agent type to use with our navigation mesh surface, return to both the following components to set <code>Bot</code>:</p>
<ul class="calibre17">
<li class="calibre15">The <code>NavMeshSurface</code> component: On the <code>NavMesh Surface</code> object in the <strong class="bold">Scene</strong> Hierarchy.</li>
<li class="calibre15">The <code>NavMeshAgent</code> component: On the <code>Enemy Hover Bot A</code> Prefab (which can be seen as (<em class="italic">B</em>) in <em class="italic">Figure 13</em><em class="italic">.6</em>).</li>
</ul>
<p class="calibre3">Having <code>NavMeshSurface</code> and <code>NavMeshAgent</code> use the same agent type is a requirement of the AI Navigation system – you’ll receive odd <em class="italic">set destination</em>-related issues in the console if they don’t, and baking just won’t work!</p>
<p class="calibre3">With a different agent type selected, we’ll have to click the <strong class="bold">Bake</strong> button again to calculate the new navigation mesh surface – make sure you return to re-bake as needed when adjustments are made to the <strong class="bold">Agent </strong><strong class="bold">Type</strong> values.</p>
<p class="callout-heading">We’ve only touched the surface</p>
<p class="callout">Sorry, I couldn’t help the pun! The Unity AI Navigation system is capable of a <em class="italic">lot</em> more than what we’ve touched on here. I encourage you to explore the documentation and try implementing additional features into your game to level up the player experience even more:</p>
<p class="callout"><a href="https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.ai.navigation%401.1/manual/</a>.</p>
<p class="calibre3">Now that we <a id="_idIndexMarker1385" class="pcalibre1 pcalibre calibre6"/>have the navigation surface baked, we can finally add waypoints to get the bot performing its patrol duties while walking the beat!</p>
<h2 id="_idParaDest-247" class="calibre8"><a id="_idTextAnchor264" class="pcalibre1 pcalibre calibre6"/>Adding waypoints to the level and testing</h2>
<p class="calibre3">NPC patrolling <a id="_idIndexMarker1386" class="pcalibre1 pcalibre calibre6"/>enhances gameplay by making environments feel alive, increasing player immersion and challenge. While having an NPC patrol a set of waypoints may not be considered an <strong class="bold">emergent behavior</strong> on its own, encounters can still appear unpredictable, keeping<a id="_idIndexMarker1387" class="pcalibre1 pcalibre calibre6"/> gameplay exciting and testing the player’s adaptability.</p>
<p class="callout-heading">Emergent behavior</p>
<p class="callout">Emergent gameplay refers to complex situations that could arise from the implementation of simple game mechanics in both video and tabletop board games.</p>
<p class="calibre3">We’ve already configured all the requirements for adding the ability for our enemy bot to patrol; we just need to define the specific patrol points now. So, follow these steps to add our waypoints to specific locations within the navigation mesh surface we made:</p>
<ol class="calibre14">
<li class="calibre15">Add an empty GameObject named <code>Patrol Waypoints</code> to the <strong class="bold">Scene</strong> Hierarchy to parent (group) the waypoint objects under.</li>
</ol>
<p class="calibre3">Don’t forget to reset the transform position to <code>(0, 0, 0)</code> after adding the object.</p>
<ol class="calibre14">
<li value="2" class="calibre15">Add three GameObjects, one to each end of the corridors – whose transform position represents the actual waypoint location; see <em class="italic">Figure 13</em><em class="italic">.7</em> as a location reference.</li>
<li class="calibre15">With a waypoint object selected, use the Inspector to assign an icon for quick identification in the <strong class="bold">Scene</strong> view – <em class="italic">Figure 13</em><em class="italic">.7</em> shows a green label icon having been selected.</li>
</ol>
<p class="calibre3">Now that we have <a id="_idIndexMarker1388" class="pcalibre1 pcalibre calibre6"/>waypoints in our scene, we can assign them to the <code>PatrolWaypoints</code> behavior component’s <code>Enemy Bot A</code> object in the <strong class="bold">Scene</strong> Hierarchy, then lock the Inspector. Now, select all three waypoint objects we just made and drag them to the <strong class="bold">Waypoints</strong> field to add them all at once. If we didn’t lock the Inspector, it would have changed when we multi-selected the waypoint objects in the hierarchy, preventing the assignment. Alternatively, without locking the Inspector, you can drag each waypoint one at a time to assign them (yuck).</p>
<p class="callout-heading">Obligatory saving reminder</p>
<p class="callout">You’ve been hitting <em class="italic">Ctrl/Cmd</em> + <em class="italic">S</em> to save your scene periodically, right? Consider this a reminder to do it now. The waypoints assignment to the <strong class="source-inline1">Enemy Bot A</strong> Prefab is a scene-level save; they won’t be saved with the file-based Prefab asset.</p>
<p class="calibre3">Test out navigating the waypoints. Enter <strong class="bold">Play mode</strong>, switch back to the <strong class="bold">Scene</strong> view, adjust the view, and watch the bot navigate a path to the waypoints in the order they appear in the list of waypoints – make any adjustments to the <strong class="bold">Config</strong> values for acceleration, speed, or the navigation agent type radius, and so on. Repeat playtesting as needed to get the initial enemy bot patrolling in a, well, good patrolling fashion.</p>
<p class="calibre3">In this section, we learned how to refactor a 2D patrolling waypoint behavior to its 3D equivalent<a id="_idIndexMarker1389" class="pcalibre1 pcalibre calibre6"/> counterpart using Unity’s NavMesh system. Next, let’s make the enemy bot have the ability to detect – or sense – the player and respond with appropriate behavior.</p>
<h1 id="_idParaDest-248" class="calibre5"><a id="_idTextAnchor265" class="pcalibre1 pcalibre calibre6"/>Dynamic enemies with sensors and behavior trees</h1>
<p class="calibre3">In video games, sensors <a id="_idIndexMarker1390" class="pcalibre1 pcalibre calibre6"/>can play a crucial role in creating interactive and dynamic AI behaviors. They enable NPCs to <em class="italic">perceive</em> their surroundings, allowing them to react to not only the player but also other environmental things in a <em class="italic">more realistic</em> manner. For example, in stealth games such <a id="_idIndexMarker1391" class="pcalibre1 pcalibre calibre6"/>as <strong class="bold">Metal Gear Solid</strong>, enemies are often equipped with a <strong class="bold">field of view</strong> (<strong class="bold">FOV</strong>) sensor<a id="_idIndexMarker1392" class="pcalibre1 pcalibre calibre6"/> that detects the player when they enter their line of sight. Similarly, games such as <strong class="bold">The Last of Us</strong> incorporate audio sensors that enable enemies to detect the player based on noises they make. These types of sensors add depth to the gameplay by having players change the strategy of their movement and actions more carefully.</p>
<p class="calibre3">In short, sensors are abilities added to our objects that make them aware of their surroundings and other objects – especially true concerning an enemy NPC and the player!</p>
<p class="calibre3">In this section, we’ll look at some code that can be used to implement the two types of sensors we just identified: detecting the player based on an FOV and the player based on audio – such as the player’s footsteps.</p>
<h2 id="_idParaDest-249" class="calibre8"><a id="_idTextAnchor266" class="pcalibre1 pcalibre calibre6"/>Creating sensory behaviors</h2>
<p class="calibre3">The first sensor <a id="_idIndexMarker1393" class="pcalibre1 pcalibre calibre6"/>code we’ll look at is for detecting the player within an FOV of the patrolling enemy NPC. We’ll make this an event-based class that does not inherit from <code>MonoBehaviour</code>. That way, we can use it directly in the implementing class, <code>EnemyController</code>, by simply creating a new instance. It will be very straightforward.</p>
<p class="calibre3">First, look at the code template for our sensor classes:</p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.Events;
public class SensorTemplate
{
    private readonly MonoBehaviour _context;
    public event UnityAction OnSensorDetected;
    public SensorTemplate(MonoBehaviour context)
    {
        _context = context;
    }
    public void Tick()
    {
        // Invoke only if detection occurred.
        OnSensorDetected?.Invoke();
    }
}</pre> <p class="calibre3">Let’s break it<a id="_idIndexMarker1394" class="pcalibre1 pcalibre calibre6"/> down:</p>
<ul class="calibre17">
<li class="calibre15"><code>class SensorTemplate</code>: Note that we’re not a derived class, and there is no inheritance from <code>MonoBehaviour</code> since we won’t be using this class as a component in the Inspector. We’ll create an instance of the sensor class in the implementing class using the <code>new</code> keyword (remember, too, that we can’t use <code>new</code> with <code>MonoBehaviour</code>).</li>
<li class="calibre15"><code>MonoBehaviour _context</code>: Speaking of <code>MonoBehaviour</code>… we may still need access to it for running a coroutine or getting the <code>Transform</code> values or GameObject of the implementing class. We’ll use the class constructor to assign this variable.</li>
</ul>
<p class="callout-heading">Constructor (C#)</p>
<p class="callout">Every time an instance of a class or struct is created, its constructor is called. More information can be found here: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors</a>.</p>
<ul class="calibre17">
<li class="calibre15"><code>event UnityAction OnSensorDetected</code>: I mentioned the sensor class will be event-based, so here it is. This is the event, <code>UnityAction</code>, that we’ll invoke when the sensor detects, well, what we design it to detect. The <code>event</code> keyword enforces that only the declaring class can invoke it.</li>
<li class="calibre15"><code>SensorTemplate(MonoBehaviour context)</code>: We have our class’s constructor here. The method that shares the same name as the class is the constructor. We’ve added a parameter to set the <code>_context</code> member variable when creating the class instance.</li>
<li class="calibre15"><code>void Tick()</code>: This is where the magic happens. Typically, <code>Tick()</code> will be called from the implementing class’s <code>Update()</code> method to perform the detection work required for each sensor’s purpose. We’ll invoke the <code>OnSensorDetected</code> event only when the detection occurs.</li>
</ul>
<p class="calibre3">Now, before continuing <a id="_idIndexMarker1395" class="pcalibre1 pcalibre calibre6"/>onto the two sensor examples I’ve provided, let’s see how the sensor class is used in the implementing class. We’ll use <code>EnemyController</code> for this example, where we previously just used a simple member method, <code>IsPlayerInRange()</code>. You can see how we can instead use a sensor class as a way to construct an NPC’s abilities in the following code:</p>
<pre class="source-code">
public class EnemyController : MonoBehaviour
{
    private SensorTemplate _sensor;
    private void Start()
    {
        _sensor = new SensorTemplate(this);
        _sensor.OnSensorDetected += HandleSensor_Detected;
    }
    private void HandleSensor_Detected()
    {
        Debug.Log("Sensor triggered!");
        ChangeState(State.Detected);
    }
    private void Update()
    {
        _sensor.Tick();
    }
}</pre> <p class="calibre3">Here is another<a id="_idIndexMarker1396" class="pcalibre1 pcalibre calibre6"/> quick breakdown of the implementation:</p>
<ul class="calibre17">
<li class="calibre15"><code>private SensorTemplate _sensor</code>: This variable will hold the instance of the sensor class we create to refer to throughout its implementation in this class.</li>
<li class="calibre15"><code>_sensor = new SensorTemplate(this)</code>: Using the <code>new</code> keyword, we create a new instance of the sensor class for its use, passing in the <code>this</code> keyword, which represents the <code>EnemyController</code> class (derived from the <code>MonoBehaviour</code> base class).</li>
</ul>
<p class="callout-heading">this (C#)</p>
<p class="callout">The <strong class="source-inline1">this</strong> keyword refers to the current instance of a class. More information can be found here: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this</a>.</p>
<ul class="calibre17">
<li class="calibre15"><code>_sensor.OnSensorDetected += HandleSensor_Detected</code>: Adding the handler method for listening when the sensor detects something.</li>
</ul>
<p class="calibre3">In this template example, the <code>HandleSensor_Detected()</code> method simply changes to a different state where the controller will take action based on the sensor detection. Don’t forget that we can also pass parameters to the handler method via the event; simply change the event type declaration to something like <code>UnityAction&lt;float&gt;</code>.</p>
<ul class="calibre17">
<li class="calibre15"><code>void Update()</code>: We’ll run the <code>Update()</code> method every frame in the sensor class for it to perform its detecting workload.</li>
</ul>
<p class="calibre3">That’s all there is to implementing custom class instances for the purpose of adding sensing abilities to your<a id="_idIndexMarker1397" class="pcalibre1 pcalibre calibre6"/> NPCs. If you want to further solidify the sensor class’s architecture, you could use a base abstract class or an interface. Consider this your challenge to refactor the sensor template code with either of these patterns in mind!</p>
<p class="callout-heading">Abstract class or interface?</p>
<p class="callout">An abstract class can provide a starting point with some predefined ways to do things, whereas an interface simply states requirements that must be followed. Imagine you have a box of crayons with some colors already defined – that’s the abstract class. And a coloring book with outlines of pictures where you have to stay within the lines – that’s the interface.</p>
<p class="calibre3">In the following two subsections, I’ve provided two code examples for sensor classes that can be added<a id="_idIndexMarker1398" class="pcalibre1 pcalibre calibre6"/> to any controller class to detect a target within an FOV and detect any nearby player’s audio source that is playing.</p>
<h3 class="calibre10">Detecting the player within an FOV sensor</h3>
<p class="calibre3">Imagine having a <a id="_idIndexMarker1399" class="pcalibre1 pcalibre calibre6"/>pair of glasses that can assist you in finding your friends in a game of hide and seek. These glasses work similarly to the <em class="italic">player within the FOV sensor</em> in a video game, where you have a limited seeing distance and area of view and need to look in the correct direction to identify your friends. If the player is within the viewing angle and distance while not hidden behind anything, the sensor detects them and triggers an alert. By using this type of sensor in a video game, NPCs can detect, or sense, the player, similar to how the glasses help during the game of hide and seek.</p>
<p class="calibre3">I’ve provided the complete example <code>SensorTargetInFOV</code> class in the 3D FPS game project code available for download and its initial implementation in the <code>EnemyController</code> class. The script is located here: <code>Assets/Scripts/Sensors/SensorTargetInFOV.cs</code>.</p>
<p class="callout-heading">Download the complete sensor code</p>
<p class="callout">The code for all the example sensors can be found on the GitHub repository here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts/Sensors/" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch13/Unity-Project/Assets/Scripts/Sensors/</a>.</p>
<p class="calibre3">The class constructor has additional parameters added for specifying the FOV angle and the visual range:</p>
<pre class="source-code">
public SensorTargetInFOV(MonoBehaviour context,
    float fovAngle, float fovRange)
{
    _context = context;
    _fovAngle = fovAngle;
    _fovRange = fovRange;
}</pre> <p class="calibre3">These additional values are then used for the sensor’s detection calculation within its <code>IsTargetInsideFOV()</code> method called every frame tick, which does the following:</p>
<ol class="calibre14">
<li class="calibre15">Calculates the direction of the specified target object.</li>
</ol>
<p class="calibre3">The target object is set with a call to <code>SetTarget()</code> just before calling <code>Tick()</code>.</p>
<ol class="calibre14">
<li value="2" class="calibre15">If the direction to the target angle is within the specified <code>fovAngle</code>, it then calculates the distance to the target.</li>
<li class="calibre15">If the distance to the target is within <code>fovRange</code>, we finally do a physics <strong class="bold">raycast</strong> to detect the target object as the player.</li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">In game development, a <em class="italic">raycast</em> is a common way of detecting objects. It involves projecting an invisible laser beam in a specified direction to report on any objects that it intersects with.</p>
<p class="callout">More information about <strong class="source-inline1">Physics.Raycast</strong> can be found here: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.xhtml</a>.</p>
<ol class="calibre14">
<li value="4" class="calibre15">If the hit object of the raycast is the player – determined by comparing its tag – we invoke the <em class="italic">target </em><em class="italic">detected</em> event.</li>
</ol>
<p class="calibre3">Explore and discover the sensor code and its implementation to further solidify your understanding of<a id="_idIndexMarker1400" class="pcalibre1 pcalibre calibre6"/> the different ways in which we can create code architecture. We’ll now look at the second sensor example, the hearing sensor.</p>
<h3 class="calibre10">Detecting the player’s audio sensor</h3>
<p class="calibre3">In a video game, a hearing <a id="_idIndexMarker1401" class="pcalibre1 pcalibre calibre6"/>sensor gives your NPCs the ability to identify sounds from the surrounding environment with super-sensitive ears. This type of sensor can help the NPC locate and identify objects based on the sounds they make, even if the object is not visible to the NPC. My favorite example of this is the horrifying game <strong class="bold">Alien: Isolation</strong>, in which the alien NPC uses a sophisticated hearing sensor to not only hear noises made by the player but also recognize their severity – sound plays a crucial role in the survival-horror experience.</p>
<p class="calibre3">Using a hearing-type sensor in your game may or may not be so frightening, but it will elevate the gameplay experience nonetheless. I’ve provided the complete example <code>SensorHearing</code> class in the 3D FPS game project code available for download and its initial implementation in the <code>EnemyController</code> class. The script is located here: <code>Assets/Scripts/Sensors/SensorHearing.cs</code>.</p>
<p class="calibre3">The class constructor has additional parameters added for specifying the hearing range and update frequency (how often to check for audio sources):</p>
<pre class="source-code">
public SensorHearing(MonoBehaviour context,
    float hearingRange, float updateFrequency)
{
    _context = context;
    _hearingRange = hearingRange;
    _updateFrequency = updateFrequency;
    _context.StartCoroutine(
        PeriodicallyUpdateAudioSources());
    …</pre> <p class="calibre3">These additional<a id="_idIndexMarker1402" class="pcalibre1 pcalibre calibre6"/> values are then used for the sensor’s detection calculation within its <code>IsAudioDetected()</code> method called every frame tick. Additionally, we’re using the passed-in <code>MonoBehaviour</code> context to start a coroutine: coroutines require a <code>MonoBehaviour</code> object to run – to periodically update the list of audio sources in the scene (not particularly useful for our 3D FPS game but especially relevant for multiplayer games where players will drop in and out of gameplay).</p>
<p class="calibre3">The audio detection method, <code>IsAudioDetected()</code>, does the following:</p>
<ol class="calibre14">
<li class="calibre15">We’ll simply start by iterating through a list of audio sources found in the scene.</li>
<li class="calibre15">If an audio source is playing and we can hear the audio source, invoke the <em class="italic">target </em><em class="italic">detected</em> event.</li>
</ol>
<p class="calibre3"><code>CanHearAudioSource()</code> is used to determine whether the currently playing audio source is within <code>hearingRange</code>, adjusted for its playing volume.</p>
<p class="callout-heading">Player footsteps 3D audio source</p>
<p class="callout">Note that for our player footsteps audio, we implemented it as a 2D sound using the <strong class="source-inline1">AudioPlayerSFX</strong> component. For the enemy NPC to sense the player’s footstep sounds, with the <strong class="source-inline1">SensorHearing</strong> class, we’d need to use the <strong class="source-inline1">AudioPlayerSFX3D</strong> component instead. Refer to <a href="B18347_12.xhtml#_idTextAnchor232" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a> if you’d like to refactor the player footsteps to support audio-sensing behavior.</p>
<p class="calibre3">Similarly, for this sensor, explore and discover the sensor code and its implementation to further solidify your understanding of the different ways in which we can create code architecture.</p>
<p class="calibre3">In this section, we learned what a sensor is in game development terms and how to use a class that does not <a id="_idIndexMarker1403" class="pcalibre1 pcalibre calibre6"/>derive from <code>MonoBehaviour</code> to implement sensory abilities for our NPCs. Next, we’ll see how a behavior tree can help to manage the complexity of AI for NPCs.</p>
<h2 id="_idParaDest-250" class="calibre8"><a id="_idTextAnchor267" class="pcalibre1 pcalibre calibre6"/>Wrangling behaviors with a behavior tree</h2>
<p class="calibre3">A <strong class="bold">behavior tree</strong> (<strong class="bold">BT</strong>) is a <a id="_idIndexMarker1404" class="pcalibre1 pcalibre calibre6"/>powerful <a id="_idIndexMarker1405" class="pcalibre1 pcalibre calibre6"/>and flexible tool for implementing diverse AI-driven NPCs because it enables more complex hierarchical decision-making compared to a more<a id="_idIndexMarker1406" class="pcalibre1 pcalibre calibre6"/> traditional <strong class="bold">finite state machine</strong> (<strong class="bold">FSM</strong>) that would simply hold the current state. BTs work really well with predefined sensors, such as our <em class="italic">player within FOV sensor</em> and <em class="italic">hearing player audio</em> sensors we’ve discussed, since these sensors could be integrated into the BT as custom nodes in the graph. This sensor integration would allow NPCs to make decisions based on sensory input conditions, favorably enhancing enemy NPC behavior for the gameplay.</p>
<p class="calibre3">Because BTs are graph-based, with sequences, actions, and other nodes, they offer a more manageable way to visualize the relationship of the AI behavior being implemented. However, BTs are not visual scripting (although some BT frameworks do provide functionality that crosses over into what might be considered visual scripting). Conditional nodes are what allow the BT-driven NPC to react dynamically to the player’s actions, such as changing the NPC’s behavior from patrolling to investigating a noise or spotting the player.</p>
<p class="calibre3">Here is a simple example UML diagram of a BT for a patrolling NPC that can sense the player’s position within its FOV or hear the player, with the child nodes representing the resulting state of the triggered sensors:</p>
<div><div><img alt="Figure 13.9 – A simple BT graph" src="img/B18347_13_09.jpg" class="calibre157"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.9 – A simple BT graph</p>
<p class="calibre3">As you can see, the hierarchical structure of BTs offers a clear and manageable way to design AI behaviors. Tools such as <strong class="bold">Behavior Designer</strong>, <strong class="bold">Node Canvas</strong>, and <strong class="bold">Schema</strong> in the Unity <a id="_idIndexMarker1407" class="pcalibre1 pcalibre calibre6"/>Asset Store <a id="_idIndexMarker1408" class="pcalibre1 pcalibre calibre6"/>provide frameworks for creating BTs, mostly <a id="_idIndexMarker1409" class="pcalibre1 pcalibre calibre6"/>without the need to write any code. They <a id="_idIndexMarker1410" class="pcalibre1 pcalibre calibre6"/>offer intuitive editors, many <a id="_idIndexMarker1411" class="pcalibre1 pcalibre calibre6"/>pre-built nodes, plus their own custom actions and actions specific to the Unity Scripting API, too.</p>
<p class="calibre3">BT tools are designed to make it easier for Unity developers to implement complex behaviors for their NPCs. They’re also more accessible for integrating custom conditional nodes (e.g., sensors), allowing for rapid iteration of configurations to attain the desired behaviors.</p>
<p class="callout-heading">Free behavior tree asset | Unity Asset Store</p>
<p class="callout"><strong class="bold">Schema</strong> is described as “<em class="italic">A fast, easy platform to build artificial intelligence with Behavior Trees. Create complex and intelligent behaviors for your game without writing a single line of code. Behavior trees are used extensively by AAA studios to bring lifelike behaviors into </em><em class="italic">their AI.</em>”</p>
<p class="callout">Here is its Asset Store link: <a href="https://assetstore.unity.com/packages/tools/behavior-ai/schema-200876" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/tools/behavior-ai/schema-200876</a>.</p>
<p class="calibre3">I’ve already gone ahead and added the Schema BT asset to the 3D FPS project files in the book’s GitHub repo (link in the <em class="italic">Technical requirements</em> section) for you to explore and experiment with. You can use the Schema graph editor to create custom nodes for the sensors we made in the previous <em class="italic">Creating sensory behaviors</em> section and apply them to the enemy hover bot NPC.</p>
<p class="callout-heading">Unity Muse AI tools – Behavior</p>
<p class="callout"><strong class="bold">Muse Behavior</strong> is a new<a id="_idIndexMarker1412" class="pcalibre1 pcalibre calibre6"/> Unity built-in graph-based BT tool with an intuitive flow graph and action node stories for AI designers. It is currently in pre-release but looks to be an up-and-coming full-featured BT solution for AI NPC design – including the ability to use text-input generative AI to create node actions rapidly.</p>
<p class="callout">Here is the link to a Muse Behavior tutorial project: <a href="https://assetstore.unity.com/packages/templates/tutorials/muse-behavior-tutorial-project-269570" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/templates/tutorials/muse-behavior-tutorial-project-269570</a>.</p>
<p class="calibre3">As a game developer, you’ll gravitate toward certain technologies over others and favor either a code-only approach or adding some visual tools to your skill set over time. At the end of the day, remember, it’s about overcoming challenges effectively to implement all the features in the scope of your project, and especially to finish the game!</p>
<p class="calibre3">In this section, we learned the value of creating sensors for adding detecting abilities to our NPCs and<a id="_idIndexMarker1413" class="pcalibre1 pcalibre calibre6"/> using <a id="_idIndexMarker1414" class="pcalibre1 pcalibre calibre6"/>a BT as a visual tool for creating, managing, and setting up dynamic AI-driven NPC behaviors. Next, we’ll look at AI-driven behavior further by investigating Unity’s ML tools.</p>
<h1 id="_idParaDest-251" class="calibre5"><a id="_idTextAnchor268" class="pcalibre1 pcalibre calibre6"/>Introducing ML with ML-Agents</h1>
<p class="calibre3">Many parts of <a id="_idIndexMarker1415" class="pcalibre1 pcalibre calibre6"/>developing a video game touch on technologies that could fill entire books all on their own, and ML is definitely one of them! Unity has its own tooling for ML that is particularly suited for games, and it’s<a id="_idIndexMarker1416" class="pcalibre1 pcalibre calibre6"/> called <strong class="bold">ML-Agents</strong>.</p>
<p class="calibre3">ML-Agents is an <strong class="bold">AI toolkit</strong> for Unity<a id="_idIndexMarker1417" class="pcalibre1 pcalibre calibre6"/> developers that helps them create advanced and complex behaviors in their games and simulations using ML techniques. Unlike BTs, which rely on hand-crafted sets of rules, ML-Agents leverages ML to enable NPCs to <em class="italic">learn</em> and adapt their behavior by interacting with their surroundings. This is accomplished by training an agent using ML<a id="_idIndexMarker1418" class="pcalibre1 pcalibre calibre6"/> techniques <a id="_idIndexMarker1419" class="pcalibre1 pcalibre calibre6"/>such as <strong class="bold">reinforcement learning</strong>, <strong class="bold">imitation learning</strong>, or other <a id="_idIndexMarker1420" class="pcalibre1 pcalibre calibre6"/>custom <a id="_idIndexMarker1421" class="pcalibre1 pcalibre calibre6"/>methods. The process enables trained agent NPCs to determine the best course of action, all on their own, constantly changing and surprising you with dynamic and, hopefully, unpredictable gameplay. I briefly noted <strong class="bold">emergent gameplay</strong> before, and this is it!</p>
<p class="calibre3">Unity ML-Agents applies<a id="_idIndexMarker1422" class="pcalibre1 pcalibre calibre6"/> to<a id="_idIndexMarker1423" class="pcalibre1 pcalibre calibre6"/> various scenarios, from simple games to much more complex simulations. Here is a summarized list of what the ML-Agents toolkit offers:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Different training environments</strong>: You <a id="_idIndexMarker1424" class="pcalibre1 pcalibre calibre6"/>can create environments as simple or complex as the real world to train agents.</li>
<li class="calibre15"><strong class="bold">Variety of training algorithms</strong>: Also relatable to the toolkit’s flexibility, it supports various cutting-edge ML algorithms customizable for the agent training task at hand.</li>
<li class="calibre15"><strong class="bold">Unity integration</strong>: ML-Agents is designed to work specifically with Unity, which makes it very accessible to Unity game developers.</li>
</ul>
<p class="calibre3">Unity also provides a breadth of resources to learn ML-Agents, including the <strong class="bold">ML-Agents: Hummingbirds</strong> project, a comprehensive example project with approximately 10 hours of content!</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">More information about ML-Agents can be found here: <a href="https://unity.com/products/machine-learning-agents" class="pcalibre1 pcalibre calibre6">https://unity.com/products/machine-learning-agents</a>.</p>
<p class="callout">More information about the ML-Agents toolkit can be found here: <a href="https://github.com/Unity-Technologies/ml-agents/tree/latest_release" class="pcalibre1 pcalibre calibre6">https://github.com/Unity-Technologies/ml-agents/tree/latest_release</a>.</p>
<p class="callout">More information about ML-Agents: Hummingbirds can be found here: <a href="https://learn.unity.com/course/ml-agents-hummingbirds/?tab=overview" class="pcalibre1 pcalibre calibre6">https://learn.unity.com/course/ml-agents-hummingbirds/?tab=overview</a>.</p>
<p class="calibre3">There are three basic steps to how ML-Agents can work for Unity games:</p>
<ol class="calibre14">
<li class="calibre15"><strong class="bold">Integrating</strong>: This step<a id="_idIndexMarker1425" class="pcalibre1 pcalibre calibre6"/> involves integrating the Unity ML-Agents package into a Unity project designed for training.</li>
<li class="calibre15"><strong class="bold">Training agents</strong>: This step involves connecting the Unity project to train the agents to learn the desired behavior.</li>
<li class="calibre15"><strong class="bold">Embedding</strong>: This final step involves embedding the trained agent model into your game project.</li>
</ol>
<p class="calibre3">Let’s keep this simplified, high-level, three-step process in mind and build on our previous work with the Unity AI Navigation package. In this way, we can use a NavMesh Agent to optimize <a id="_idIndexMarker1426" class="pcalibre1 pcalibre calibre6"/>the <a id="_idIndexMarker1427" class="pcalibre1 pcalibre calibre6"/>efficiency of the ML-Agents agent training by having it focus on behavior training and not navigation.</p>
<h2 id="_idParaDest-252" class="calibre8"><a id="_idTextAnchor269" class="pcalibre1 pcalibre calibre6"/>Navigating training efficiency with NavMesh</h2>
<p class="calibre3">When developing a game <a id="_idIndexMarker1428" class="pcalibre1 pcalibre calibre6"/>using ML-Agents, we<a id="_idIndexMarker1429" class="pcalibre1 pcalibre calibre6"/> can use the <code>NavMeshAgent</code> component to handle the task of agent navigation while leaving the ML-Agents training to focus on the higher-level decision-making processes such as patrolling, investigating, and attacking the player character.</p>
<p class="calibre3">This approach of blending intelligent AI behavior with an established navigation setup results in a more streamlined and effective training result. The following figure shows a simple training scene with a NavMesh Surface setup:</p>
<div><div><img alt="Figure 13.10 – Example ML-Agents training scene" src="img/B18347_13_10.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.10 – Example ML-Agents training scene</p>
<p class="calibre3">Having noted this efficiency, let’s<a id="_idIndexMarker1430" class="pcalibre1 pcalibre calibre6"/> see what a <a id="_idIndexMarker1431" class="pcalibre1 pcalibre calibre6"/>general ML-Agents training setup looks like next.</p>
<h2 id="_idParaDest-253" class="calibre8"><a id="_idTextAnchor270" class="pcalibre1 pcalibre calibre6"/>Examining an ML-Agents setup</h2>
<p class="calibre3">Here is a more <a id="_idIndexMarker1432" class="pcalibre1 pcalibre calibre6"/>detailed breakdown of the steps we’d typically see setting up ML-Agents training and implementation within Unity:</p>
<ol class="calibre14">
<li class="calibre15">The ML-Agents package and dependencies.</li>
</ol>
<p class="calibre3">The latest installation instructions can be found in the ML-Agents GitHub repo at <a href="https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Installation.md" class="pcalibre1 pcalibre calibre6">https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Installation.md</a>:</p>
<ol class="calibre14">
<li class="calibre15">I recommend installing the latest version using the GitHub URL via the Package Manager: git+<a href="https://github.com/Unity-Technologies/ml-agents.git?path=com.unity.ml-agents#release_21" class="pcalibre1 pcalibre calibre6">https://github.com/Unity-Technologies/ml-agents.git?path=com.unity.ml-agents#release_21</a>.</li>
<li class="calibre15">Dependencies include ML-Agents extensions, <code>mlagents</code> Python package, <strong class="bold">PyTorch</strong> (Windows), <strong class="bold">Visual C++ Redistributable</strong>, and <strong class="bold">Unity Sentis</strong>.</li>
</ol>
<ol class="calibre14">
<li value="2" class="calibre15">Unity project setup:<ol class="calibre42"><li class="calibre15">Create a new Unity project, selecting a <strong class="bold">3D </strong><strong class="bold">Core</strong> template.</li><li class="calibre15">Design the environment with a baked NavMesh Surface and add objects to the scene representing the player character and the NPC that should observe the player. Refer to <em class="italic">Figure 13</em><em class="italic">.10</em> for a simple training scene representation.</li></ol></li>
<li class="calibre15">Setting up the agents:<ol class="calibre42"><li class="calibre15">Attach both the <code>NavMeshAgent</code> and ML-Agents <code>Agent</code> components to the NPC object.</li><li class="calibre15">Configure the <code>NavMeshAgent</code> properties such as speed, angular speed, and acceleration.</li></ol></li>
<li class="calibre15">Implement the <a id="_idIndexMarker1433" class="pcalibre1 pcalibre calibre6"/>agent methods:<ol class="calibre42"><li class="calibre15">Create a new class that inherits from <code>Unity.MLAgents.Agent</code>, named, for example, <code>AgentController</code>.</li><li class="calibre15">Override the <code>Agent.CollectObservations()</code> method to inform the agent with sensor information concerning the environment or player data:</li></ol><pre class="source-code">
public override void CollectObservations(VectorSensor sensor)
{
    // TODO: Implementation of sensor observations.
}</pre><ol class="calibre42"><li value="3" class="calibre15">Override the <code>Agent.OnActionReceived()</code> method to apply NPC actions such as setting the destination for the NavMesh Agent or turning to face the player:</li></ol><pre class="source-code">public override void OnActionReceived(ActionBuffers actionBuffers)
{
    // TODO: Implementation of actions.
}</pre></li> <li class="calibre15">Define the<a id="_idIndexMarker1434" class="pcalibre1 pcalibre calibre6"/> rewards and training:<ol class="calibre42"><li class="calibre15">Define rewards within the <code>OnActionReceived()</code> method:<ol class="calibre42"><li class="calibre15"><code>SetReward()</code> method and pass in a positive float value for successfully reaching a patrol point or facing the player, for example. Note that this function replaces any rewards given to the agent during the current step. You can also use <code>AddReward()</code> to incrementally change rewards instead of overriding.</li><li class="calibre15"><code>SetReward()</code> method and pass in a negative float value for undesirable behaviors such as running into walls or losing sight of the player:</li></ol></li></ol><pre class="source-code">
public override void OnActionReceived(ActionBuffers actionBuffers)
{
    …
    SetReward(0.1f); // Positive reward.
    SetReward(-1);   // Negative reward.
}</pre><ol class="calibre42"><li value="2" class="calibre15">Create a training configuration file (i.e., <code>trainer_config.yaml</code>) where the specified training algorithm will be defined (e.g., reinforcement learning algorithm) along with its configuration.</li><li class="calibre15">Configure both a <code>BehaviorParameters</code> and <code>DecisionRequestor</code> component on the player object agent for the observation and decision-making settings.</li></ol></li> <li class="calibre15">Run the training process:<ol class="calibre42"><li class="calibre15">Using Command Prompt or Terminal, navigate to your Unity project folder, run the training command (e.g., <code>mlagents-learn trainer_config.yaml --run-id=firstNPCPatrol</code> – here, <code>run-id</code> is any unique name for the session), and use <strong class="bold">TensorBoard</strong> to monitor the training process of the agent.</li></ol></li>
<li class="calibre15">Integrate the training results:<ol class="calibre42"><li class="calibre15">After finishing training, the inference model is saved as a <code>.nn</code> file. Import it into a folder in your Unity project.</li><li class="calibre15">On the agent, assign the model to the <code>BehaviorParameters</code> component’s <strong class="bold">Model</strong> property and set <strong class="bold">Behavior Type</strong> to <strong class="bold">Inference Only</strong> to test the behavior in your scene.</li></ol></li>
<li class="calibre15">Playtest and iterate on the design:<ol class="calibre42"><li class="calibre15">In Unity, play the scene and observe the NPC agent’s behavior (for example, as it patrols, senses, or detects the player).</li><li class="calibre15">Adjust rewards and rerun the training as needed to refine the NPC behavior incrementally.</li></ol></li>
</ol>
<p class="calibre3">By following these <a id="_idIndexMarker1435" class="pcalibre1 pcalibre calibre6"/>steps, you can set up a training environment that uses a NavMesh Agent for pathfinding. At the same time, ML-Agents is left to train only the complex NPC behavior, such as patrolling and player detection in our example.</p>
<p class="callout-heading">ML-Agents sample environments</p>
<p class="callout">The <strong class="bold">ML-Agents Toolkit</strong> GitHub<a id="_idIndexMarker1436" class="pcalibre1 pcalibre calibre6"/> repository contains a set of example environments that demonstrate the various features of the toolkit. These environments can also be used as a starting basis for new environments or a predefined setup for testing new ML algorithms.</p>
<p class="callout">Some example learning environments can be found here: <a href="https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Learning-Environment-Examples.md" class="pcalibre1 pcalibre calibre6">https://github.com/Unity-Technologies/ml-agents/blob/latest_release/docs/Learning-Environment-Examples.md</a>.</p>
<p class="calibre3">If you’re looking to create a truly exceptional gaming experience for your players, consider using ML with ML-Agents. It’s a powerful tool that can help you achieve remarkable results!</p>
<p class="callout-heading">Unity Muse | Additional reading</p>
<p class="callout">During the course of the Unity 2022 tech stream releases, Unity has released new AI tools for developers under the <a id="_idIndexMarker1437" class="pcalibre1 pcalibre calibre6"/>moniker <strong class="bold">Unity Muse</strong>. The tools are currently offered as a subscription service, starting with a free trial period.</p>
<p class="callout">More information about Unity Muse AI tools for developers can be found here: <a href="https://unity.com/products/muse" class="pcalibre1 pcalibre calibre6">https://unity.com/products/muse</a>.</p>
<p class="calibre3">In this section, we explored how Unity’s ML-Agents toolkit can be used to train NPCs with ML algorithms. The result is an NPC with adaptable behaviors that go beyond what we can pre-script for<a id="_idIndexMarker1438" class="pcalibre1 pcalibre calibre6"/> an AI (for example, with a BT). We further understood the required knowledge to use ML-Agents in a Unity project to elevate the player experience with adaptive NPC behavior.</p>
<h1 id="_idParaDest-254" class="calibre5"><a id="_idTextAnchor271" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we refactored our game’s enemy NPCs from 2D to 3D environments while still using waypoints but also leveraging Unity’s NavMesh system for AI navigation. We also improved our NPCs’ behavior complexity by enabling them to interact with the player and the environment more realistically by using sensors – the effect of which is to challenge players more engagingly.</p>
<p class="calibre3">We continued discussing dynamic enemy behavior by incorporating our sensors as conditions within BTs. We completed our advanced AI discussion with an introduction to ML by using Unity’s ML-Agents, enabling NPCs that can learn and evolve, allowing us to integrate advanced AI-based gameplay into our games for remarkable player experiences.</p>
<p class="calibre3">In the next chapter, we’ll finish things up with the 3D FPS game by creating a classic boss room battle in <strong class="bold">mixed reality</strong> (<strong class="bold">MR</strong>). Additionally, you will learn how to design a challenging boss room and its mechanics quickly by applying all the previous lessons learned for developing game systems.</p>
</div>
</div></body></html>