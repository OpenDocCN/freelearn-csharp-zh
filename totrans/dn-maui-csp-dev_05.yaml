- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Advanced Controls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级控件
- en: In the previous chapter, we looked at a number of controls and how to handle
    their events and commands. In this chapter, we’ll look at moving the logic into
    `ViewModel` using commands and messaging. We’ll then go on to cover Styles, which
    let you provide a uniform appearance to your controls with little effort.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了多个控件及其事件和命令的处理方法。在本章中，我们将探讨使用命令和消息将逻辑移动到`ViewModel`中。然后，我们将继续介绍样式，这些样式可以让你轻松地为控件提供统一的外观。
- en: One key feature of a well-designed user experience is that when something is
    going to take more than a second or so, you let the user know that the app is
    working on it so that it doesn’t look like your app froze.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好设计的用户体验的关键特性是，当某件事需要超过一秒钟的时间时，你让用户知道应用程序正在处理中，这样就不会显得你的应用程序已经冻结。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Keeping the user informed of activity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持用户对活动知情
- en: Moving event handling to `ViewModel`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件处理移动到`ViewModel`
- en: Sending and receiving messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送和接收消息
- en: Displaying collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示集合
- en: Styles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need Visual Studio. You can find the source code
    for this chapter here: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls).
    If you want to follow along, continue with the project you were working on in
    [*Chapter 4*](B19723_04.xhtml#_idTextAnchor054).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要Visual Studio。你可以在这里找到本章的源代码：[https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls)。如果你想继续学习，请继续你在[*第4章*](B19723_04.xhtml#_idTextAnchor054)中正在工作的项目。
- en: Keeping the user informed of activity
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持用户对活动知情
- en: 'There are two ways to let the user know that your application is working on
    something time-consuming:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式让用户知道你的应用程序正在处理耗时操作：
- en: '`ActivityIndicator`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityIndicator`'
- en: '`ProgressBar`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressBar`'
- en: '`ActivityIndicator` essentially says, “I’m working on it, but I don’t know
    how long it will take,” whereas `ProgressBar` says, “I’m working on it, and I’m
    about halfway done.” Let’s explore each of these in a bit more detail.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityIndicator`基本上表示，“我在处理中，但不知道需要多长时间”，而`ProgressBar`表示，“我在处理中，已经完成了一半。”让我们更详细地探讨这两个控件。'
- en: ActivityIndicator
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ActivityIndicator
- en: 'We’ll start by adding `ActivityIndicator` to the login page below the Buttons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`ActivityIndicator`添加到登录页面中按钮下方：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice that the `IsRunning` property is bound to the `ActivityIndicatorIsRunning`
    property. That property is in `LoginViewModel` (you’ll remember that we set that
    file as the binding context):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IsRunning`属性绑定到了`ActivityIndicatorIsRunning`属性。该属性位于`LoginViewModel`中（你可能会记得我们将其设置为绑定上下文）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I’ve set its default value to `true`, so the activity indicator will be running
    when the page comes up. Let’s shut it off after creating the account:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其默认值设置为`true`，因此当页面加载时活动指示器会运行。在创建账户后，让我们将其关闭：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Nothing has changed in the create page code except the addition of the final
    line. Here we reach into `ViewModel` and set the `ActivityIndicatorIsRunning`
    property to `false`. That should stop `ActivityIndicator` whose `IsRunning` property
    is bound to `showActivityIndicator`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建页面代码中，除了添加最后一行之外，没有其他变化。在这里，我们进入`ViewModel`并设置`ActivityIndicatorIsRunning`属性为`false`。这应该会停止与`showActivityIndicator`属性绑定的`ActivityIndicator`。
- en: 'The result looks like *Figure 5**.1*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像*图5.1*：
- en: '![Figure 5.1 – ActivityIndicator'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – ActivityIndicator'
- en: '](img/Figure_5.1_B19723.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B19723.jpg)'
- en: Figure 5.1 – ActivityIndicator
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – ActivityIndicator
- en: Working or hung?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行还是挂起？
- en: Note that under some circumstances, your program might hang, yet the activity
    indicator will continue spinning. This can cause enormous confusion and frustration
    for your user. One way to escape that problem is to set a timer, and if the task
    doesn’t complete in *n* seconds, you stop the indicator and, for example, display
    an error dialog. Of course, if everything is hung, you won’t be able to do that,
    but typically, the indicator will have frozen as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些情况下，你的程序可能会挂起，但活动指示器会继续旋转。这可能会给用户造成巨大的困惑和挫败感。避免这种问题的方法之一是设置一个计时器，如果任务在*n*秒内没有完成，你停止指示器，例如，显示一个错误对话框。当然，如果一切都已经挂起，你可能无法做到这一点，但通常，指示器也会冻结。
- en: '`ActivityIndicator` is great, but it only tells the user that something is
    happening, not how far it has progressed in its task. That is what `ProgressBar`
    is for.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityIndicator` 很好，但它只告诉用户有事情在进行中，并没有说明它在任务中的进展程度。这正是 `ProgressBar` 的作用。'
- en: ProgressBar
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProgressBar
- en: '`ProgressBar` divides a task into fractional parts (for example, percentages)
    and displays what part (fraction, percentage, and so on) has been completed. We’ve
    all seen progress bars: ideally, they move smoothly across the screen; in fact,
    they often move in fits and starts as the task they are tracking completes.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressBar` 将任务分成分数部分（例如，百分比）并显示已完成的部分（分数、百分比等）。我们都见过进度条：理想情况下，它们在屏幕上平滑移动；实际上，当它们跟踪的任务完成时，它们通常会断断续续地移动。'
- en: We’re going to create a progress bar, but we are going to fake an action. That
    is, we’ll progress the bar based on time rather than actual progress in a task.
    Nonetheless, the workings of `ProgressBar` will become evident.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个进度条，但我们将模拟一个动作。也就是说，我们将根据时间而不是实际任务进度来推进条。尽管如此，`ProgressBar` 的工作原理将变得明显。
- en: 'To get started, let’s comment out `ActivityIndicator` in `LoginPage.xaml`,
    and replace it with `ProgressBar`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们在 `LoginPage.xaml` 中注释掉 `ActivityIndicator`，并用 `ProgressBar` 替换它：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we have declared `ProgressBar` with only two properties: its color and
    its name. The name allows us to refer to the bar in the code-behind. We would,
    of course, normally update `ProgressBar` based on data in the `ViewModel`, but
    for now, as we have done before, we’ll do that work in the code-behind (`LoginPage.xaml.cs`).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只声明了 `ProgressBar` 的两个属性：其颜色和名称。名称允许我们在代码背后引用该条。当然，我们通常会根据 `ViewModel`
    中的数据更新 `ProgressBar`，但现在，就像我们之前做的那样，我们将在代码背后（`LoginPage.xaml.cs`）完成这项工作。
- en: 'Here is the code that will start and advance the progress bar based on the
    user clicking the **Submit** button:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是当用户点击 **提交** 按钮时启动和推进进度条的代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[1] We will set the value of `ProgressBar` based on the value of the counter
    variable (`i`) in the `for` loop. The `ProgressBar` values range from `0` to `1`,
    with the percentage or fraction of progress measured as values between those two
    numbers. Here, we initialize the counter variable to `0.0`, and until it reaches
    the `1.0` value, we increment by one-tenth.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 我们将根据 `for` 循环中计数器变量（`i`）的值设置 `ProgressBar` 的值。`ProgressBar` 的值范围从 `0`
    到 `1`，进度或分数的百分比或分数被测量为这两个数字之间的值。在这里，我们将计数器变量初始化为 `0.0`，直到它达到 `1.0` 值，我们以十分之一递增。'
- en: '[2] Within the `for` loop, we call `ProgressTo` on `ProgressBar`. That method
    takes three values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 在 `for` 循环中，我们在 `ProgressBar` 上调用 `ProgressTo` 方法。该方法接受三个值：'
- en: The value we want to progress to
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要进展到的值
- en: The amount of time to get there, in milliseconds
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到达该值所需的时间，以毫秒为单位
- en: The easing (see the following section)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Easing（见下一节）
- en: '[3] The action we’ll take when the progress bar completes.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 当进度条完成时我们将采取的行动。'
- en: Another related feature is *Easing*, which refers to how quickly an action goes
    from start to full speed. Let’s take a look at that in a bit more depth.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的功能是 *Easing*，它指的是动作从开始到全速所需的速度。让我们更深入地看看这一点。
- en: Easing
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Easing
- en: '*Easing* refers to the pattern of how an item moves. For example, a train does
    not go from standing still in the station to racing along at 75 miles per hour
    all at once; it *eases* into the final speed. If you drew a graph of the acceleration,
    it would look like a sine wave, and two of the enumerated values of easing are,
    in fact, `SineIn` (for the pattern of starting up) and `SineOut` (for the pattern
    of coming back into the station).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*Easing* 指的是项目移动的模式。例如，火车不会突然从车站静止不动加速到每小时75英里；它会 *逐渐加速* 到最终速度。如果你绘制一个加速度图，它看起来像正弦波，而列举的两种
    easing 值实际上是 `SineIn`（表示启动模式）和 `SineOut`（表示返回车站的模式）。'
- en: In our case, however, we want the progress bar to move smoothly and at a constant
    speed, which is what `easing.Linear` does.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，我们希望进度条平滑且匀速移动，这正是 `easing.Linear` 所做的。
- en: The net effect is that the progress bar will be animated across its entire course.
    We know that we are moving from `0` to `1` in tenths, and we know that we are
    taking half a second (500 milliseconds) to go each one-tenth of the way; thus,
    we know that the entire trip from `0.0` (nothing showing on the bar) to `1.0`
    (the bar fully filled with color) will take five seconds.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最终效果是进度条将在整个过程中进行动画。我们知道我们是以十分之一的速度从`0`移动到`1`，我们知道我们用半秒（500毫秒）走完每十分之一；因此，我们知道从`0.0`（条上没有显示任何内容）到`1.0`（条完全填充了颜色）的整个旅程将花费五秒钟。
- en: 'At the conclusion of our `for` loop, the dialog will pop up, giving a nice
    simulation of the completion of the task that the progress bar was tracking. A
    snapshot of that progress is shown in *Figure 5**.2*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环结束时，对话框将弹出，给出一个很好的模拟进度条所跟踪的任务完成情况。该进度的一个快照显示在*图5.2*中：
- en: '![Figure 5.2 – The progress bar is about 75% of the way toward completion'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 进度条已完成大约75%](img/Figure_5.2_B19723.jpg)'
- en: '](img/Figure_5.2_B19723.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B19723.jpg)'
- en: Figure 5.2 – The progress bar is about 75% of the way toward completion
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 进度条已完成大约75%
- en: For convenience and to keep things simple, we’ve been using the code-behind
    for event handling. Of course, as noted in [*Chapter 3*](B19723_03.xhtml#_idTextAnchor036),
    there are good reasons to use commands rather than events and to handle them in
    `ViewModel`. Let’s look at that next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便和保持简单，我们一直在使用代码后端来处理事件。当然，如[*第3章*](B19723_03.xhtml#_idTextAnchor036)中所述，使用命令而不是事件，并在`ViewModel`中处理它们是有很好的理由的。让我们看看这一点。
- en: Moving event handling to ViewModel
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将事件处理移至ViewModel
- en: Suppose that when a Button is pressed, we want to handle that fact in the `ViewModel`,
    as is preferred by the `ProgressBar`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当按钮被按下时，我们想在`ViewModel`中处理这个事实，这是`ProgressBar`所偏好的。
- en: 'Handling things in `ViewModel` gets tricky when we want to interact with the
    `Clicked` event and add a command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要与`Clicked`事件交互并添加一个命令时，在`ViewModel`中处理事情会变得复杂。
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll create `RelayCommand` in `ViewModel` to handle the `Submit` Command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`ViewModel`中创建`RelayCommand`来处理`Submit`命令：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[1] Access `LoginProgressBar` on `LoginPage` (more later on how to do that)
    and call `ProgressTo` as we saw earlier.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 在`LoginPage`上访问`LoginProgressBar`（稍后会详细介绍如何做到这一点），并像之前看到的那样调用`ProgressTo`。'
- en: '[2] Access `MainPage` through the `Application` object and call `DisplayAlert`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 通过`Application`对象访问`MainPage`并调用`DisplayAlert`。'
- en: 'So, how are we going to access the `LoginProgressBar` in the UI? We need a
    static member of `LoginPage` to accomplish this. We’ll pull the declaration of
    `LoginProgressBar` out of the **Extensible Application Markup Language** (**XAML**)
    and move it into the code-behind:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在UI中访问`LoginProgressBar`呢？我们需要`LoginPage`的一个静态成员来实现这一点。我们将`LoginProgressBar`的声明从**可扩展应用程序标记语言**（**XAML**）中提取出来，并将其移动到代码后端：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to be sure to initialize this in the constructor of `LoginPage`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保在`LoginPage`的构造函数中初始化这一点：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’re going to need to refer to `StackLayout` if we want to add that to `ProgressBar`,
    so let’s name it as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在`ProgressBar`中添加它，就需要引用`StackLayout`，所以让我们按照以下方式命名：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we’re ready to add `ProgressBar` to the children of `StackLayout`. Here’s
    the complete constructor:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将`ProgressBar`添加到`StackLayout`的子元素中。这是完整的构造函数：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[1] Notice that `InitializeComponent` comes before adding `ProgressBar` to
    the children of `StackLayout`. Until this is called, `LoginStackLayout` will be
    null.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 注意到`InitializeComponent`在将`ProgressBar`添加到`StackLayout`的子元素之前调用。在调用此之前，`LoginStackLayout`将为null。'
- en: '[2] By calling `Add` here, `LoginProgressBar` is added to `LoginStackLayout`
    below the controls created in the XAML.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 通过在这里调用`Add`，将`LoginProgressBar`添加到XAML中创建的控件下面的`LoginStackLayout`。'
- en: Huh? Let’s take it step by step.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哎？让我们一步一步来。
- en: Breaking it down
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解步骤
- en: 'Here is the order of what happens when you run this, enter your username and
    password, and click **Submit**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此程序，输入用户名和密码，然后点击**提交**时，以下是发生的事情的顺序：
- en: '`ProgressBar` is added to the page in the page constructor.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProgressBar`是在页面构造函数中添加到页面的。'
- en: When you click on `SubmitCommand` is sent to `ViewModel`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击`SubmitCommand`时，会发送到`ViewModel`。
- en: '`ViewModel` handles that in `Submit`, `RelayCommand`.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ViewModel`在`Submit`、`RelayCommand`中处理这一点。'
- en: In `RelayCommand`, it updates the (static) `LoginProgressBar`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RelayCommand`中，它更新了（静态的）`LoginProgressBar`。
- en: It then calls `DialogBox` through `MainPage`, which it has access to through
    the `Application` object.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它通过`MainPage`调用`DialogBox`，它通过`Application`对象可以访问。
- en: This works beautifully but is a bit labored. The use of `Application.Current.MainPage`
    is not unusual, but the hoops we jumped through to access `ProgressBar` are. The
    solution to that is to use `Messaging`, which is covered next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但有点繁琐。使用 `Application.Current.MainPage` 并不罕见，但我们为了访问 `ProgressBar` 而跳过的圈子是。解决这个问题的方法是使用
    `Messaging`，我们将在下一节中介绍。
- en: Visibility
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性
- en: It is generally considered best practice for `ViewModel` not to see aspects
    of the view (as it does here). In the next example, we will isolate the VM from
    the view.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为，`ViewModel` 不应看到视图的方面（正如这里所做的那样）。在下一个示例中，我们将隔离 VM 和视图。
- en: Sending and receiving messages
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送和接收消息
- en: Rather than reaching into `View`, we can have `ViewModel` signal `View` when
    it is time to display the dialog or other `View`-dependent element.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是深入到 `View` 中，我们可以在 `ViewModel` 信号 `View` 何时显示对话框或其他 `View` 相关元素时。
- en: For example, suppose we want to show `Snackbar` when the user clicks on the
    `Command` (which is preferred because it puts the logic into `ViewModel`). `ViewModel`
    might then massage data or otherwise do whatever it needs to do, and then signal
    `View` to display `Snackbar` by sending out a message to that effect.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在用户点击 `Command` 时显示 `Snackbar`（这更受欢迎，因为它将逻辑放入 `ViewModel`）。然后 `ViewModel`
    可能会处理数据或执行其他任何需要做的事情，并通过发送相关消息来指示 `View` 显示 `Snackbar`。
- en: The idea is that `ViewModel` publishes a message such as “anyone who has subscribed
    to this message, show a `Snackbar`” and the page subscribes to that message and
    so shows `Snackbar` when the message is received.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是 `ViewModel` 发布一条消息，例如“任何订阅此消息的人，显示 `Snackbar`”，页面订阅此消息，因此在收到消息时显示 `Snackbar`。
- en: 'In some circumstances, there may be more than one **Subscriber**. For that
    matter, in some circumstances, more than one **Publisher** can send the same message,
    as shown in *Figure 5**.3*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会有多个 **订阅者**。同样，在某些情况下，多个 **发布者** 可以发送相同的消息，如图 *5.3* 所示：
- en: '![Figure 5.3 – Publish and Subscribe'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 发布和订阅'
- en: '](img/Figure_5.3_B19723.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – B19723.jpg](img/Figure_5.3_B19723.jpg)'
- en: Figure 5.3 – Publish and Subscribe
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 发布和订阅
- en: Messaging center
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 消息中心
- en: .NET MAUI has a built-in messaging system, but it has been deprecated in favor
    of `WeakReferenceMessenger` provided in the .NET Community Toolkit MVVM, which
    we will cover next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 有一个内置的消息系统，但它已被弃用，转而使用 .NET Community Toolkit MVVM 中提供的 `WeakReferenceMessenger`，我们将在下一节中介绍。
- en: Getting started with WeakReferenceMessenger
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 WeakReferenceMessenger
- en: 'To set this up, first create a class that will serve as the message. You can
    create this class anywhere that both `View` and `ViewModel` can see it. For convenience,
    I’ll put it above the `LoginPage` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置此环境，首先创建一个将作为消息的类。你可以在 `View` 和 `ViewModel` 都能看到的任何地方创建此类。为了方便，我将它放在 `LoginPage`
    类之上：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, in the `LoginPage` constructor, we need to register to receive such a
    message. Once you receive the message you might call a method, or alternatively,
    you’ll use a Lambda expression to do the work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `LoginPage` 构造函数中，我们需要注册接收此类消息。一旦收到消息，你可能调用一个方法，或者你也可以使用 Lambda 表达式来完成这项工作。
- en: 'To register to receive the message, use the `WeakReferenceMessenger''s Register`
    method. Here is the code to do so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册接收消息，请使用 `WeakReferenceMessenger` 的 `Register` 方法。以下是实现此目的的代码：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What goes between the opening and closing braces is whatever you want to do
    when you receive that message. I’ve moved the code we were using in the event
    handler to here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在大括号之间的是你在收到该消息时想要做的事情。我已经将我们在事件处理器中使用的事件处理代码移动到这里：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, all we need to do is revise `LoginPage.xaml` so that the `ViewModel`,
    rather than an event handler in the code-behind:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要修改 `LoginPage.xaml`，以便 `ViewModel` 而不是代码背后的事件处理器：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will invoke the Create relay method in the **ViewModel**
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `ViewModel` 中调用创建中继方法
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`ViewModel` calls the `Send` method, sending in an instance of `ConstructMessage`
    as a signal to any registered listeners to take some action. The `Create` method
    might, before sending that message, do other work that is best done in `ViewModel`
    rather than code-behind.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 调用 `Send` 方法，发送 `ConstructMessage` 实例作为信号给任何已注册的监听器采取某些行动。在发送该消息之前，`Create`
    方法可能执行其他最好在 `ViewModel` 而不是代码背后完成的工作。'
- en: This is a much cleaner way of *decoupling* `ViewModel` and `View` when we need
    to have logic in `ViewModel` take an action that can only be taken by `View`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要的逻辑在 `ViewModel` 中执行的动作只能由 `View` 执行时，这是一种更干净的解耦 `ViewModel` 和 `View` 的方式。
- en: '`WeakReferenceMessenger` can also be used to communicate from one `ViewModel`
    to another.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakReferenceMessenger` 也可以用来在 `ViewModel` 之间进行通信。'
- en: Finally, it is called `WeakReferenceMessenger` in distinction from stet `StrongReferenceMessenger`.
    The advantage of `WeakReferenceMessenger`, and the reason it is generally what
    is chosen, is that it manages its own memory and cleanup, so you don’t have to.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它被称为 `WeakReferenceMessenger`，以区别于 `StrongReferenceMessenger`。`WeakReferenceMessenger`
    的优势，以及它通常被选择的原因，是它管理自己的内存和清理，因此你不需要。
- en: Creating the page in C#
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C# 中创建页面
- en: 'Before moving on, and to reinforce the fact that anything you can do in XAML
    you can do in C#, here is the version of `LoginPage` that we will be using in
    Forget Me Not (ForgetMeNotDemo) written in C# (in the repo, this page is called
    `LoginCS`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，为了强调在 XAML 中能做的事情在 C# 中也能做，这里展示了我们将要在 Forget Me Not (ForgetMeNotDemo)
    中使用的 `LoginPage` 版本，该版本是用 C# 编写的（在仓库中，这个页面被称为 `LoginCS`）：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[1] We start by declaring the class and giving it `LoginViewModel`. This is
    done by *dependency injection*, a topic covered in detail in [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 我们首先声明一个类并给它 `LoginViewModel`。这是通过 *依赖注入* 实现的，这个主题在 [*第 9 章*](B19723_09.xhtml#_idTextAnchor160)
    中有详细讲解。'
- en: '[2] `ActivityIndicator` is instantiated; it will be added to the page later.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] `ActivityIndicator` 被实例化；它稍后将被添加到页面中。'
- en: '[3] The `IsEnabled` property of `ActivityIndicator` is bound to a property
    in `ViewModel`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] `ActivityIndicator` 的 `IsEnabled` 属性绑定到 `ViewModel` 中的一个属性。'
- en: '[4] We add to `StackLayout` by adding to its `Children` collection.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 我们通过向其 `Children` 集合中添加内容来添加到 `StackLayout`。'
- en: '[5] We haven’t covered `Grid` yet, but you can see that it is a layout that
    has rows and columns. We’ll look at it in greater depth in the next chapter.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] 我们还没有介绍 `Grid`，但你可以看到它是一个具有行和列的布局。我们将在下一章更深入地探讨它。'
- en: '[6] In `Grid`, each individual row and column can be given a name from `enumeration`
    or can be referred to by its zero-based index.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] 在 `Grid` 中，每个单独的行和列都可以从 `枚举` 中获得一个名称，或者可以通过其零基索引来引用。'
- en: The key takeaway from this section is that you can certainly create all the
    controls and their commands and properties in C# as well as in XAML. I will continue
    to dip into C#, but I’m afraid it will drive you crazy to show each type in both,
    so again, for layout and controls, we’ll focus predominantly on XAML – the standard
    approach for .NET MAUI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键要点是，你当然可以在 C# 中创建所有控件及其命令和属性，就像在 XAML 中一样。我将继续深入 C#，但恐怕这会让你疯狂，因为我要在两者中展示每种类型，所以再次强调，对于布局和控制，我们将主要关注
    XAML – 这是 .NET MAUI 的标准方法。
- en: Displaying collections
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示集合
- en: It is common to have a collection of data and to want to display it in a list,
    allowing the user to select one or more items and then do some work with those
    items. There are a couple of ways to do this in .NET MAUI, but the most common
    (and best) is to use `CollectionView`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会有一个数据集合，并且希望将其以列表的形式显示出来，使用户能够选择一个或多个项目，然后对这些项目进行一些操作。在 .NET MAUI 中有几种方法可以做到这一点，但最常见（也是最好的）方法是使用
    `CollectionView`。
- en: To see this at work, examine `Preferences.xaml` along with its code-behind `Preferences.xaml.cs`
    and `ViewModel`, `PreferencesViewModel.cs`. We will use this page extensively
    as we build Forget Me Not, but let’s start slowly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其工作情况，请检查 `Preferences.xaml` 以及其代码背后的 `Preferences.xaml.cs` 和 `ViewModel`，`PreferencesViewModel.cs`。在我们构建
    Forget Me Not 的过程中，我们将广泛使用这个页面，但让我们先慢慢来。
- en: 'Our goal is to create a list of the user’s preferences (shirt size, music genre,
    and so on). For that, we’ll use `CollectionView`, and we’ll, of course, need a
    collection to view. The page, when completed, will look much like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个包含用户偏好的列表（如衬衫尺寸、音乐类型等）。为此，我们将使用 `CollectionView`，当然，我们还需要一个可以查看的集合。完成后的页面将看起来像这样：
- en: '![Figure 5.4 – The Preferences page'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 偏好页面'
- en: '](img/Figure_5.4_B19723.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.4_B19723.jpg]'
- en: Figure 5.4 – The Preferences page
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 偏好页面
- en: 'Rather than each line being a unique object, we’ll create one type that we
    can show repeatedly. In the `Model` folder, create a `Preference` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每行都是一个独特的对象，我们将创建一个可以重复显示的类型。在 `Model` 文件夹中创建一个 `Preference` 类：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Partial classes
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类
- en: In .NET MAUI virtually all classes are *partial* to support the Community Toolkit
    code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，几乎所有类都是 *部分类* 以支持社区工具包的代码。
- en: '`Preference` has only two properties, both strings. The `PreferencePrompt`
    string will hold the text on the left of the page, and the `PreferenceValue` string
    will hold the user’s preference on the right side.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Preference` 只有两个属性，都是字符串。`PreferencePrompt` 字符串将保存页面左侧的文本，而 `PreferenceValue`
    字符串将保存用户在右侧的偏好。'
- en: 'The first thing we need is a collection of these `Preference` objects. To get
    that, we’re going to build a `Service`, whose job, eventually, will be to interact
    with the API and get us our list of `Preference` objects. Perform the following
    steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是这些 `Preference` 对象的集合。为了得到这个集合，我们将构建一个 `Service`，其最终任务是与 API 交互并获取我们的
    `Preference` 对象列表。执行以下步骤：
- en: Create a new folder named `Services`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Services` 的新文件夹。
- en: In `Services`, create a `PreferenceService` class.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Services` 中创建一个 `PreferenceService` 类。
- en: Inside that file add a `GetPreferences` method.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件中添加一个 `GetPreferences` 方法。
- en: 'Here’s the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`ViewModel` will call `GetPreferences` on the service and get back a list of
    the `Preference` objects. We’ll turn to how `PreferenceService` gets those objects
    in just a bit.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 将在服务上调用 `GetPreferences` 并返回一个 `Preference` 对象的列表。我们稍后会讨论 `PreferenceService`
    如何获取这些对象。'
- en: 'Back in `PreferencesViewModel`, do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PreferencesViewModel` 中，执行以下操作：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[1] Declare an instance of `PreferenceService`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 声明一个 `PreferenceService` 的实例'
- en: '[2] Initialize it in the constructor'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 在构造函数中初始化它'
- en: '[3] In the `Init` method, fill the `Preferences` collection with what you get
    back from the service'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 在 `Init` 方法中，用从服务返回的内容填充 `Preferences` 集合'
- en: Dependency injection
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160), we will review dependency
    injection. At that point, we’ll pass in a `PreferenceService` interface and let
    the `InversionOfControl` container supply the service for us. If that didn’t make
    sense to you, no problem; it will all become clear in [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第9章*](B19723_09.xhtml#_idTextAnchor160) 中，我们将回顾依赖注入。那时，我们将传递一个 `PreferenceService`
    接口，并让控制反转容器为我们提供服务。如果你觉得这不太明白，没问题；所有这些都会在第9章中变得清晰。[*第9章*](B19723_09.xhtml#_idTextAnchor160)。
- en: 'So, who instantiates `ViewModel` and calls `Init`? For that, we turn to the
    code-behind of the `PreferencesPage` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，谁实例化了 `ViewModel` 并调用 `Init`？为了回答这个问题，我们转向 `PreferencesPage` 类的代码背后：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Naming the ViewModel vm
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ViewModel 命名为 vm
- en: I’m not big on using acronyms in code, and would normally have named the local
    instance of `ViewModel`. But using *vm* is such a convention in .NET MAUI (going
    back to `Xamarin.Forms`) that I indulge myself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太喜欢在代码中使用缩写，通常会为 `ViewModel` 的本地实例命名。但使用 *vm* 在 .NET MAUI（追溯到 `Xamarin.Forms`）中是一个惯例，所以我放纵自己。
- en: In .NET MAUI, the two life cycle events you will often want control over are
    when the page is first being shown (`OnAppearing`) and when it is being shut down
    (`OnDisappearing`). Let’s explore this next.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，你通常会想要控制的两个生命周期事件是页面首次显示时（`OnAppearing`）和页面关闭时（`OnDisappearing`）。让我们接下来探讨这个问题。
- en: Overriding OnAppearing
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写 OnAppearing
- en: Every time a page appears, its `OnAppearing` method is called. We override that
    method so that we can call `vm.Init()`. We do this because `Init` is asynchronous,
    and while we can make `OnAppearing` asynchronous using the `async` keyword, we
    can’t do that with the constructor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每次页面出现时，它的 `OnAppearing` 方法都会被调用。我们重写这个方法，以便调用 `vm.Init()`。我们这样做是因为 `Init` 是异步的，虽然我们可以使用
    `async` 关键字使 `OnAppearing` 异步，但我们不能在构造函数中这样做。
- en: '`OnInit()`, in turn, calls `GetPreferences` on the service and gets back a
    collection of the `Preference` objects.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInit()`，反过来，在服务上调用 `GetPreferences` 并返回一个 `Preference` 对象的集合。'
- en: Understanding how the service works
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解服务的工作原理
- en: In time, our `PreferenceService's` `GetPreferences` method will call into our
    API to get the list of preferences from our database, which will be stored in
    the cloud. For now, it will call `GetPreferencesMock`, which will handcraft the
    list and return it to us.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 逐渐地，我们的 `PreferenceService` 的 `GetPreferences` 方法将调用我们的 API 来获取数据库中的偏好设置列表，这些列表将存储在云端。目前，它将调用
    `GetPreferencesMock`，这将手工制作列表并返回给我们。
- en: 'Here’s an excerpt from the file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是文件的一个摘录：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The result is a collection of `Preference` objects. Let’s look at how to display
    that collection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个 `Preference` 对象的集合。让我们看看如何显示这个集合。
- en: Displaying the collection of Preference objects
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示偏好设置对象的集合
- en: 'Now that we have a collection of `Preference` objects in `ViewModel`, we can
    create our page:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 `ViewModel` 中有一个 `Preference` 对象的集合，我们可以创建我们的页面：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is much to see in this listing. Let’s take things one by one:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中有很多内容可以查看。让我们逐个来看：
- en: '[1] `Label` has multiple lines; we’ve seen this before. We set `LineBreakMode`
    to `WordWrap` so that we break the lines between words. Notice the use of `&#10;`,
    which forces a line break.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] `Label` 有多行；我们之前见过。我们将 `LineBreakMode` 设置为 `WordWrap` 以在单词之间断行。注意使用 `&#10;`，它强制换行。'
- en: '[2] The **Save** button is very unusual as it has a click event handler as
    well as a command! The click event handler will handle showing the toast.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] **保存**按钮非常不寻常，因为它不仅有点击事件处理器，还有一个命令！点击事件处理器将处理显示提示。'
- en: '[3] The command will be handled in `ViewModel` and will call the `Save` method
    in the service (which we will not implement just yet).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 命令将在 `ViewModel` 中处理，并将调用服务中的 `Save` 方法（我们暂时不会实现）。'
- en: '[4] The `ItemsSource` property points to the collection that `CollectionView`
    will display. In our case, that is the `Preferences` collection in `ViewModel`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] `ItemsSource` 属性指向 `CollectionView` 将显示的集合。在我们的例子中，那就是 `ViewModel` 中的 `Preferences`
    集合。'
- en: '[5] `SelectionMode` is set to `None`, as we won’t be selecting items in this
    display. We will be editing items and then pressing **Save** to save the changes.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] `SelectionMode` 设置为 `None`，因为我们不会在这个显示中选择项。我们将编辑项，然后按 **保存** 按钮保存更改。'
- en: '[6] An item template says, “here is how I want you to display each item in
    the collection, one by one.”'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] 项模板表示，“这是我想让你逐个显示集合中每个项的方式。”'
- en: '[7] Interestingly, we are using `Entry` for the prompt. This allows the user
    to change the prompt, which is what we want. We can’t anticipate every category,
    so we create a number of them, but we let the user tweak the list as needed.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] 有趣的是，我们正在使用 `Entry` 作为提示。这允许用户更改提示，这正是我们想要的。我们无法预测每个类别，所以我们创建了许多，但我们允许用户根据需要调整列表。'
- en: '[8] Not only will we be displaying the value of the prompt from the database,
    but we’ll want to write back whatever the user enters as well. Thus, we mark the
    text as two-way (that is, data > View and View > data)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[8] 我们不仅会显示数据库中的提示值，还希望将用户输入的内容写回。因此，我们将文本标记为双向（即数据 > 视图和视图 > 数据）'
- en: '[9] We’ve not seen `onPlatform` before. This says, “always use this value except,
    on this platform, use this other value.” Here we are saying that the text color
    is `Black`, except on `Ios`, where it is `White`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[9] 我们之前没有见过 `onPlatform`。这表示，“除了在这个平台上使用这个其他值之外，始终使用这个值。”在这里，我们说的是文本颜色是 `Black`，但在
    `Ios` 上是 `White`。'
- en: The code-behind
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码后置
- en: 'You’ll remember that we are not only handling the command in `ViewModel` but
    we’re also handling the `Clicked` event in the code-behind. Here is the rest of
    `PreferencesPage.xaml.cs`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，我们不仅处理了 `ViewModel` 中的命令，还在代码后置中处理了 `Clicked` 事件。以下是 `PreferencesPage.xaml.cs`
    的其余部分：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The event handler just calls the `ShowToast` method, which then does its thing,
    as described earlier.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器只是调用 `ShowToast` 方法，然后按照前面描述的方式执行。
- en: This way, when the list of preferences is saved, the toast notifies the user
    that all went well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当保存偏好列表时，提示框会通知用户一切顺利。
- en: Did it all go well?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都顺利吗？
- en: In the code shown, we just assume that it all went well. To do this properly,
    we’d want `ViewModel` to wait for confirmation from the API that the operation
    was completed successfully, and then it would send a message to the code-behind,
    which would then, and only then, display the toast.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码中，我们只是假设一切顺利。为了正确地做到这一点，我们希望 `ViewModel` 等待 API 确认操作成功完成，然后它会向代码后置发送消息，然后，只有然后，才会显示提示框。
- en: 'Before we go any further, open `AppShell.xaml` and change the startup as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，打开 `AppShell.xaml` 并按照以下方式更改启动方式：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once we get to [*Chapter 7*](B19723_07.xhtml#_idTextAnchor129), we can stop
    this silliness and just navigate to the page we want.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达 [*第 7 章*](B19723_07.xhtml#_idTextAnchor129)，我们就可以停止这种无聊的事情，直接导航到我们想要的页面。
- en: 'The effect of all of this is shown in *Figure 5**.5*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的效果都在 *图 5.5* 中展示：
- en: '![Figure 5.5 – The Preferences page'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 预设页面'
- en: '](img/Figure_5.5_B19723.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B19723.jpg)'
- en: Figure 5.5 – The Preferences page
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 预设页面
- en: A few quick things to note in *Figure 5**.5*. The fields on the left have been
    underlined, indicating that they are entry objects, not labels, and thus can be
    modified. The top arrow points to the fact that the fields are free-form, and
    the user can enter whatever they want, and the lower arrow points to the toast.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.5* 中有一些需要注意的快速事项。左侧的字段已被下划线标注，表示它们是输入对象，而不是标签，因此可以修改。顶部的箭头指向字段是自由形式的，用户可以输入任何他们想要的内容，底部的箭头指向提示框。
- en: 'So far, we’ve been setting numerous properties on our UI controls. Often, we’ve
    had to repeat the same properties on various instances of the same type of control.
    There is a better way: styles, which we’ll cover next.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在设置我们 UI 控件的众多属性。我们经常不得不在相同类型控制的各种实例上重复相同的属性。有更好的方法：样式，我们将在下一节中介绍。
- en: Styles
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式
- en: '**Styles** allow you to provide a uniform look to your controls by putting
    all the details in one place.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**样式**允许您通过将所有细节放在一个地方，为您的控件提供统一的外观。'
- en: You create a style for a control type (for example, `Button`), and that style
    is applied to all controls of that type (refer to the *Explicit versus implicit
    styles* section). You can also base a style on an existing style, extending or
    modifying the original.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您为控件类型（例如，`Button`）创建一个样式，并将该样式应用于该类型的所有控件（参见图**5.6**）。您还可以基于现有样式创建样式，扩展或修改原始样式。
- en: Styles can be stored on the page that uses the control, or they can be stored
    at the application level. In either case, they are created inside `ResourceDictionary`,
    typically declared at the top of the file. To make them available at the application
    level, just put them in `App.xaml`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 样式可以存储在使用控件的页面上，或者可以存储在应用程序级别。在两种情况下，它们都在`ResourceDictionary`内部创建，通常在文件顶部声明。要使它们在应用程序级别可用，只需将它们放在`App.xaml`中。
- en: Where to put your styles
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 样式的放置位置
- en: If you are only going to use the styles on objects on a single page, it makes
    sense to put the styles in the resources of that page. If you want to be able
    to reuse these styles on multiple pages, then you will want them in `App.xaml`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只打算在单个页面的对象上使用样式，那么将样式放在该页的资源中是有意义的。如果您想能够在多个页面上重用这些样式，那么您将希望它们在`App.xaml`中。
- en: 'As an example, let’s return to the `ResourceDictionary` and our first styles.
    Place this code at the very top of the file, just below the `ContentPage` element:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回到`ResourceDictionary`和我们的第一个样式。将此代码放在文件的顶部，紧接在`ContentPage`元素下方：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see that we have created a style for the labels on the page. In that
    style, we have set a number of properties with their values. This will be applied
    to every `Label` because this is an implicit style, as described next.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们已经为页面上的标签创建了一个样式。在这个样式中，我们设置了一系列属性及其值。这将应用于每个`Label`，因为这是一个隐式样式，如以下所述。
- en: 'The key to the use of styles is that they greatly simplify the controls they
    are applied to. For example, the labels now look like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 样式使用的关键是它们极大地简化了它们所应用的控件。例如，标签现在看起来是这样的：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: They are no longer cluttered with all the style information that has been centralized
    in `ResourceDictionary`. This not only makes for cleaner XAML, but if you later
    decide to change one of these values, you do so in one place rather than throughout
    the page. Thus, the same clean code guideline that applies to C# (don’t repeat
    yourself) applies to styles.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不再被所有集中存储在`ResourceDictionary`中的样式信息所杂乱。这不仅使XAML更干净，而且如果您以后决定更改这些值之一，您只需在一个地方进行更改，而不是在整个页面上。因此，适用于C#（不要重复自己）的相同清洁代码指南也适用于样式。
- en: 'There are two types of styles: implicit and explicit. `TargetType`, as we saw
    earlier. **Explicit styles** can be applied to controls individually. Let us explore
    this in more detail next.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 样式有两种类型：隐式和显式。`TargetType`，如我们之前所看到的。**显式样式**可以单独应用于控件。让我们接下来更详细地探讨这一点。
- en: Explicit versus implicit styles
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式样式与隐式样式
- en: 'To make a style explicit, you give it a key, as shown here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要使样式显式，您给它一个键，如下所示：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can now pick which of these styles you want to apply to `Label` based on
    that key:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以根据该键选择要应用于`Label`的这些样式中的哪一个：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The result is shown in *Figure 5**.6*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如**图5.6**所示：
- en: '![Figure 5.6 – Explicit styles applied'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 应用显式样式'
- en: '](img/Figure_5.6_B19723.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.6_B19723.jpg)'
- en: Figure 5.6 – Explicit styles applied
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 应用显式样式
- en: Overriding the style in the control
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖控件中的样式
- en: If you have a style that you want to use on all of your (for example) labels,
    but you have one `Label` that needs one or two properties to be different, one
    way to handle that is just to make the change in that `Label`. Properties assigned
    directly to the control override those of the style. On the other hand, if you
    have sets of controls that need nearly the same properties but differ in some
    ways, then you want to use style inheritance, which is covered next.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个要在所有（例如）标签上使用的样式，但有一个`Label`需要一两个不同的属性，一种处理方法是在该`Label`中进行更改。直接分配给控件的属性会覆盖样式的属性。另一方面，如果您有一组需要几乎相同属性但以某种方式不同的控件，那么您想要使用样式继承，这将在下一部分介绍。
- en: Style inheritance or BasedOn
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式继承或BasedOn
- en: 'The construct for `LargeLabel` and `SmallLabel` has a lot of duplication. You
    can refactor this to use a base style and then just add the changes in your explicit
    styles. Here’s an example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`LargeLabel` 和 `SmallLabel` 的结构有很多重复。你可以重构它以使用基础样式，然后在你的显式样式中添加更改。以下是一个示例：'
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[1] An implicit label style'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 一个隐式标签样式'
- en: '[2] A style created to be the base style for other styles'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 创建为其他样式提供基础样式的样式'
- en: '[3] A derived style that uses properties from the base style'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 使用基础样式属性的派生样式'
- en: '[4] Using the derived style'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 使用派生样式'
- en: Derived styles
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 派生样式
- en: Note that derived styles can add new properties (as was done here), they can
    override values in the base style, or both. Notice also that we refactored the
    styles, but did not have to refactor `Label` that uses it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，派生样式可以添加新属性（如这里所做的那样），它们可以覆盖基础样式中的值，或者两者都可以。还要注意，我们重构了样式，但不需要重构使用它的 `Label`。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dove deeper into some of the more advanced aspects of .NET
    MAUI controls. We looked at the `Activity` element as well as `ProgressBar`. We
    went on to look at moving command handling into `ViewModel` and using messages
    to communicate between `ViewModel` and `View`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 .NET MAUI 控件的一些更高级的方面。我们研究了 `Activity` 元素以及 `ProgressBar`。然后我们继续探讨将命令处理移动到
    `ViewModel` 并使用消息在 `ViewModel` 和 `View` 之间进行通信。
- en: We ended the chapter by looking at styles and how they can be used to provide
    a uniform appearance to the UI and how we can refactor duplication out of similar
    styles by using style inheritance (`BasedOn`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看样式以及它们如何被用来提供统一的 UI 外观，以及我们如何通过使用样式继承（`BasedOn`）从相似样式中重构重复内容来结束本章。
- en: In the next chapter, we’ll look at how we lay out `controls` on the page, moving
    beyond the simple `StackLayouts` we’ve been using so far.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在页面上布局 `controls`，超越我们迄今为止所使用的简单 `StackLayouts`。
- en: Quiz
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: What is the difference between `ActivityIndicator` and `ProgressBar`?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ActivityIndicator` 和 `ProgressBar` 之间的区别是什么？'
- en: What is the difference between an event and a command?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件和命令之间的区别是什么？
- en: What is `WeakReferenceManager`?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WeakReferenceManager` 是什么？'
- en: Why would you use a style?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会使用样式？
- en: How do you refactor common properties in styles?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何重构样式中的常见属性？
- en: You try it
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你试试看
- en: 'Create a small form that pretends to gather information on the user to create
    a profile (name, age, address, and so on). Add an image you can tap on and two
    buttons: one to accept the entered info and one to cancel it.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个小表单，假装收集用户信息以创建个人资料（姓名、年龄、地址等）。添加一个可点击的图片和两个按钮：一个用于接受输入的信息，另一个用于取消。
- en: If the user taps on the image, put up a dialog box with a message, but handle
    the tap itself in `ViewModel`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击图片，弹出一个带有消息的对话框，但本身在 `ViewModel` 中处理点击。
- en: Handle the button clicks in `ViewModel`. On clicking `Snackbar` to show what
    info they have saved, nicely formatted.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewModel` 中处理按钮点击。点击 `Snackbar` 显示他们保存的信息，格式良好。
