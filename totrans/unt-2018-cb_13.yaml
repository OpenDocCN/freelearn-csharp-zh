- en: Navigation Meshes and Agents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航网格和代理
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: NPC to travel to destination while avoiding obstacles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC 在避开障碍物的同时前往目的地
- en: NPC to seek or flee from a moving object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC 寻找或逃离移动物体
- en: Point-and-click move to object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指点并点击移动到对象
- en: Point-and-click move to tile
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指点并点击移动到瓦片
- en: Point-and-click raycast with user-defined higher-cost Navigation Areas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户定义的高成本导航区域的点按射线投射
- en: NPC to follow waypoints in sequence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC 按顺序跟随航点
- en: Controlling object group movement through flocking
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集群控制对象群体移动
- en: Creating a movable NavMesh Obstacle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可移动的 NavMesh 障碍物
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Unity provides **Navigation Meshes** and Artificial Intelligence (AI) Agents
    that can plan pathways and move objects along those calculated paths. **Pathfinding**
    is a classic AI task, and Unity has provided game developers with fast and efficient
    **Pathfinding** components that work out of the box.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了**导航网格**和人工智能（AI）代理，它们可以规划路径并沿着这些计算出的路径移动对象。**路径查找**是经典的人工智能任务，Unity
    为游戏开发者提供了快速高效的**路径查找**组件，无需额外配置即可使用。
- en: Having objects that can automatically plot and follow paths from their current
    location to a desired destination point (or a moving object) provides the components
    to many different kinds of interactive game characters and mechanics. For example,
    we can create point-and-click games by clicking on a location or object, towards
    which we wish one or more characters to travel. Or, we can have enemies that "wake
    up" when our player's character is nearby, and move towards (seek) our player,
    perhaps then going into combat or dialogue mode once they are within a short distance
    of our player's character.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有能够自动绘制并跟随从当前位置到目标位置点（或移动对象）路径的对象，为许多不同类型的交互式游戏角色和机制提供了组件。例如，我们可以通过点击位置或对象来创建点按游戏，指向我们希望一个或多个角色前往的位置。或者，我们可以让敌人在我们玩家的角色附近“醒来”，并移动向我们的玩家，一旦他们进入玩家角色短距离范围内，可能就会进入战斗或对话模式。
- en: Or, objects can collectively flock together, moving as a swarm towards a common
    destination.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对象可以集体集群在一起，作为一个群体向共同的目的地移动。
- en: This chapter explores ways to exploit Unity's navigation-based AI components
    to control game character **Pathfinding** and movement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了利用 Unity 的基于导航的 AI 组件来控制游戏角色的**路径查找**和移动的方法。
- en: The big picture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体图景
- en: 'At the core of Unity''s navigation system are two concepts/components:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 导航系统的核心是两个概念/组件：
- en: '**Navigation Meshes**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航网格**'
- en: '**Navigation Mesh Agents**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航网格代理**'
- en: A Navigation **Mesh** defines the areas of the world that are navigable. It
    is usually represented as a set of polygons (2D shapes), so that a path to a destination
    is plotted as the most efficient sequence of adjacent polygons to follow, taking
    into account the need to avoid non-navigable obstacles.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航网格**定义了世界中可导航的区域。它通常表示为一组多边形（二维形状），因此到目的地的路径是通过绘制最有效的相邻多边形序列来计算的，同时考虑到需要避开不可导航的障碍物。'
- en: The **Agent** is the object that needs to calculate (plot) a path through the
    mesh from its current position to its desired destination position. **NavMesh
    Agents** have properties such as a stopping distance, so they aim to arrive at
    a point a certain distance from the target coordinates, and auto braking, so they
    gradually slow down as they get close to their destination.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理**是需要计算（绘制）从当前位置到目标位置路径的对象。**NavMesh 代理**具有诸如停止距离等属性，因此它们的目标是在目标坐标一定距离的点到达，并且自动制动，因此当它们接近目的地时，会逐渐减速。'
- en: A **Navigation Mesh** can be made up of **Areas** that have different "costs."
    The default cost for an area is 1\. However, to make a more realistic path calculation
    by AI Agent controlled characters, we might want to model the additional effort
    it takes to travel through water, or mud, or up a steep slope. Therefore, Unity
    allows us to define custom Areas, with names that we choose (such as Water or
    Mud), and associated costs, such as 2 (that is, water is twice as tiring to travel
    through).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航网格**可以由具有不同“成本”的**区域**组成。区域的默认成本是1。然而，为了通过由AI代理控制的角色进行更现实的路径计算，我们可能想要模拟穿越水、泥或陡峭斜坡所需的额外努力。因此，Unity
    允许我们定义自定义区域，我们可以选择名称（例如水或泥），并关联成本，例如2（即水穿越起来是两倍费力）。'
- en: Different navigable areas can be connected via **NavMesh Links:**
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**NavMesh 链接**连接不同的可导航区域：
- en: '[https://docs.unity3d.com/Manual/class-NavMeshLink.html](https://docs.unity3d.com/Manual/class-NavMeshLink.html)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方文档 - NavMeshLink类](https://docs.unity3d.com/Manual/class-NavMeshLink.html)'
- en: Run-Time Nav Mesh Obstacles
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时Nav Mesh障碍物
- en: The most efficient way for games to work with **Navigation Meshes** is to pre-calculate
    the costs of polygons in the game world; this is known as **Baking** and is performed
    at **Design-Time**, before we run the game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏与**导航网格**最有效的工作方式是在游戏世界中预先计算多边形的成本；这被称为**烘焙**，在**设计时**执行，在我们运行游戏之前。
- en: However, sometimes there will be features in the game that we wish to use to
    influence navigation decisions and route planning differently at different times
    in the game, that is, dynamic Run-Time navigation obstacles. Unity provides a
    **NavMesh Obstacle** component, which can be added to GameObjects, and has features
    such as "carving out" (temporarily removing) areas of a **NavMesh** to force AI-Agents
    to recalculate paths that avoid areas blocked by GameObjects with **NavMesh Obstacle**
    components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时游戏中会有一些我们希望在不同时间影响导航决策和路线规划的功能，即在游戏的不同时间动态运行时导航障碍。Unity提供了一个**NavMesh障碍物**组件，可以添加到GameObject中，具有“雕刻”（临时移除）**NavMesh**区域的功能，迫使AI-Agent重新计算避开带有**NavMesh障碍物**组件的GameObject的路径。
- en: Source of further information about Unity and AI navigation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Unity和AI导航的更多信息来源
- en: 'Some **NavMesh** features (such as **NavMesh Links** and dynamic mesh baking
    at **Run-Time**) are not part of the standard Unity installation and require additional
    installation. Learn more about these components, their APIs, and how to install
    them here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些**NavMesh**功能（例如**NavMesh链接**和**运行时**的动态网格烘焙）不是标准Unity安装的一部分，需要额外安装。在此处了解更多关于这些组件、它们的API以及如何安装它们的信息：
- en: '[https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html](https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方文档 - NavMesh组件](https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html)'
- en: '[https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html](https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方文档 - NavMesh组件API](https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html)'
- en: 'Learn more about Unity **NavMeshes** from the Unity Technologies tutorial,
    which is available here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity Technologies教程中了解更多关于Unity **NavMeshes**的信息，该教程可在以下链接找到：
- en: '[http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes](http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方教程 - NavMeshes](http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes)'
- en: 'Learn lots about computer-controlled moving GameObjects from the classic paper
    entitled **Steering Behaviors For Autonomous Characters** by Craig W. Reynolds,
    presented at the GDC-99 (Game Developer''s Conference):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从克雷格·W·雷诺兹的经典论文《自主角色的驾驶行为》中学习大量关于计算机控制移动GameObject的知识，该论文在GDC-99（游戏开发者大会）上展出：
- en: '[http://www.red3d.com/cwr/steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Red3D - steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)'
- en: 'While the Unity development community have been asking for 2D **NavMeshes**
    for some years now, they''ve not yet been released as a core feature. There is
    a lot of online information about how to write your own **Pathfinding** system
    that would work in 2D. A good thread with plenty of links can be found at **TIGForums**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Unity开发社区已经呼吁几年了，但2D **NavMeshes**尚未作为核心功能发布。关于如何编写自己的2D**路径查找**系统的在线信息很多。在**TIGForums**上可以找到一个很好的帖子，其中包含大量链接：
- en: '[https://forums.tigsource.com/index.php?topic=46325.0](https://forums.tigsource.com/index.php?topic=46325.0)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TIGSource论坛 - 话题46325](https://forums.tigsource.com/index.php?topic=46325.0)'
- en: In this chapter, you'll learn how to add **NavMesh Agents** to control characters
    and how to work with your game environment to specify and bake **Navigation Meshes**
    for a scene. Some recipes explore how to create point-and-click style games, where
    you indicate where you want a character to navigate to by clicking on an object
    or point in the game world.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何添加**NavMesh代理**来控制角色，以及如何与您的游戏环境一起工作以指定和烘焙场景的**导航网格**。一些食谱探讨了如何创建点选式游戏，您可以通过在游戏世界中点击对象或点来指示角色想要导航到的位置。
- en: You'll create "swarms" of objects that move and flock together, and you'll also learn
    to add **NavMesh Obstacle** components to moving GameObjects, forcing AI agents
    to dynamically recalculate their paths at **Run-Time** due to objects moving in
    their way.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建“群体”对象，这些对象会移动并一起集群，你还将学习如何向移动的游戏对象添加**NavMesh Obstacle**组件，迫使AI代理在**运行时**动态重新计算路径，因为这些对象正在它们的方式中移动。
- en: NPC to travel to destination while avoiding obstacles
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC在避开障碍物的同时前往目的地
- en: The introduction of Unity's **NavMeshAgent** has greatly simplified the coding
    for NPC (Non-Player Character) and enemy agent behaviors. In this recipe, we'll
    add some wall obstacles (scaled cubes), and generate a **NavMesh** so that Unity
    knows not to try to walk through walls. We'll then add a **NavMeshAgent** component
    to our NPC GameObject, and tell it to head to a stated destination location by
    intelligently planning and following a path, while avoiding the wall obstacles.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**NavMeshAgent**的引入极大地简化了NPC（非玩家角色）和敌人代理行为的编码。在这个菜谱中，我们将添加一些墙壁障碍物（缩放立方体），并生成一个**NavMesh**，这样Unity就知道不要试图穿过墙壁。然后我们将向我们的NPC游戏对象添加一个**NavMeshAgent**组件，并告诉它通过智能规划和遵循路径，避开墙壁障碍物，前往指定的目的地位置。
- en: 'When the Navigation panel is visible, then the Scene panel displays the blue-shaded
    walkable areas, as well as unshaded, non-walkable areas at the edge of the terrain
    and around each of the two wall objects:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航面板可见时，场景面板将显示蓝色阴影的可行走区域，以及地形边缘和两个墙壁对象周围的未阴影、不可行走区域：
- en: '![](img/048040cc-d5f7-4f63-a674-d305ba4c62e6.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/048040cc-d5f7-4f63-a674-d305ba4c62e6.png)'
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The required Terrain TextureSandAlbedo can be found in the 15_01 folder. Alternatively,
    you can go to Assets |Import Package | Environments, deselect everything, and
    then locate and tick this asset: Assets/Environment/TerrainAssets/SurfaceTextures/SandAlbedo.psd'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Terrain TextureSandAlbedo可以在15_01文件夹中找到。或者，你可以转到 Assets |导入包 | 环境，取消选择所有内容，然后找到并勾选此资产：Assets/Environment/TerrainAssets/SurfaceTextures/SandAlbedo.psd
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make an NPC to travel to a destination while avoiding obstacles, follow
    these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使NPC在避开障碍物的同时前往目的地，请按照以下步骤操作：
- en: Create a new, empty 3D project.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空3D项目。
- en: 'Create a new 3D Terrain, choose menu: Create | 3D Object | Terrain. With this
    new Terrain GameObject selected in the Hierarchy, in its Inspector properties
    set its size to 30 x 20, and its position to (-15, 0, -10) so we have this GameObject
    centered at (0,0,0).'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D地形，选择菜单：创建 | 3D对象 | 地形。在层次结构中选择这个新的地形游戏对象，在其检查器属性中设置其大小为30 x 20，位置为(-15,
    0, -10)，这样我们就有一个以(0,0,0)为中心的游戏对象。
- en: Texture paint this terrain with the SandAlbedo texture.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SandAlbedo纹理绘制地形。
- en: Create a 3D Capsule named Capsule-destination at (-12, 0, 8). This will be the
    target destination for our NPC self-navigating GameObject.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(-12, 0, 8)处创建一个名为Capsule-destination的3D胶囊。这将是我们的NPC自主导航游戏对象的靶目标。
- en: Create a sphere named Sphere-arrow that is positioned at (2, 0.5, 2). Scale
    it to (1,1,1).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Sphere-arrow的球体，其位置在(2, 0.5, 2)。将其缩放为(1,1,1)。
- en: Create a second sphere named Sphere-small. Scale it to (0.5, 0.5, 0.5).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个名为Sphere-small的球体。将其缩放为(0.5, 0.5, 0.5)。
- en: 'In the Hierarchy, child Sphere-small to Sphere-arrow and position it at (0,
    0, 0.5):'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，将Sphere-small子组件移动到Sphere-arrow，并定位在(0, 0, 0.5)：
- en: '![](img/a5fbaa0f-cc6c-4038-b19c-0245d10cd029.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5fbaa0f-cc6c-4038-b19c-0245d10cd029.png)'
- en: 'In the Inspector panel, add a new NavMeshAgent to Sphere-arrow. Do this by
    choosing menu: Add Component | Navigation | Nav Mesh Agent.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，向Sphere-arrow添加一个新的NavMeshAgent。通过选择菜单：添加组件 | 导航 | Nav Mesh Agent来完成此操作。
- en: 'Set the Stopping Distance property of the NavMeshAgent component to 2:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将NavMeshAgent组件的停止距离属性设置为2：
- en: '![](img/fce3dcbe-0bba-4392-9583-b76fd15ba6dc.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fce3dcbe-0bba-4392-9583-b76fd15ba6dc.png)'
- en: 'Create the `ArrowNPCMovement` C# script-class, and add an instance-object to
    the Sphere-arrow GameObject:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ArrowNPCMovement`C#脚本类，并将其实例对象添加到Sphere-arrow游戏对象中：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ensure that Sphere-arrow is selected in the Inspector panel. For the ArrowNPCMovement
    scripted component, drag Capsule-destination over the Target Go variable.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在检查器面板中选择Sphere-arrow。对于ArrowNPCMovement脚本组件，将Capsule-destination拖到Target
    Go变量上。
- en: Create a 3D Cube named Cube-wall at (-6, 0, 0), and scale it to (1, 2, 10).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(-6, 0, 0)处创建一个名为Cube-wall的3D立方体，并将其缩放为(1, 2, 10)。
- en: Create another 3D Cube named Cube-wall2 at (-2, 0, 6), and scale it to (1, 2,
    7).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(-2, 0, 6)处创建另一个名为Cube-wall2的3D立方体，并将其缩放为(1, 2, 7)。
- en: 'Display the Navigation panel by choosing menu: Window | Navigation.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：窗口 | 导航来显示导航面板。
- en: A great place to dock the Navigation panel is next to the Inspector panel since
    you will never be using the Inspector and Navigation panels at the same time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将导航面板停靠在检查器面板旁边是一个好地方，因为你永远不会同时使用检查器和导航面板。
- en: 'In the Hierarchy panel, select both of the Cube-wall objects (we select the
    objects that are not supposed to be a part of the walkable parts of our scene),
    and then in the Navigation panel, click the **Object** button and check the Navigation
    Static checkbox:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级面板中，选择两个立方体墙面对象（我们选择那些不应该成为场景可通行部分的对象），然后在导航面板中，点击**对象**按钮并勾选导航静态复选框：
- en: '![](img/a6c23855-9001-4ce4-a621-e9d37cc79a66.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6c23855-9001-4ce4-a621-e9d37cc79a66.png)'
- en: 'In the Inspector, click on the Bake button at the top for baking options. Then, click
    on the Bake button at the bottom-right to create your Navigation Mesh asset:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，点击顶部的**烘焙**按钮以获取烘焙选项。然后，点击右下角的**烘焙**按钮以创建你的导航网格资产：
- en: '![](img/c2537923-7f65-4e30-a5ef-9379e266c76a.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2537923-7f65-4e30-a5ef-9379e266c76a.png)'
- en: When the Navigation panel is displayed, you'll see a blue tint on the parts
    of the Scene that are areas for a NavMeshAgent to consider for its navigation
    paths.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当导航面板显示时，你会在场景的部分看到蓝色色调，这些部分是NavMeshAgent考虑其导航路径的区域。
- en: Now, run your game. You will see the Sphere-arrow GameObject automatically move
    towards the Capsule-destination GameObject, following a path that avoids the two
    wall objects.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的游戏。你会看到球体箭头GameObject自动移动到胶囊目标GameObject，沿着避开两个墙面对象的路径移动。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The NavMeshAgent component that we added to Sphere-arrow GameObject does most
    of the work for us. NavMeshAgents need two things:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到球体箭头GameObject中的NavMeshAgent组件为我们做了大部分工作。NavMeshAgents需要两样东西：
- en: A destination location to head towards
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个要前往的目的地位置
- en: ANavMesh component of the terrain with walkable/non-walkable areas, so that
    it can plan a path by avoiding obstacles
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地形上的可通行/不可通行区域的NavMesh组件，以便它可以通过避开障碍物来规划路径
- en: We created two obstacles (the Cube-wall objects), and these were selected when
    we created the NavMesh for this scene in the Navigation panel. When the Navigation
    panel is displayed, at the same time in the Scene panel (and the Game panel with
    Gizmos enabled), we see walkable areas forming a blue navigation mesh.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个障碍物（立方体墙面对象），并在导航面板中为这个场景创建NavMesh时选择了它们。当导航面板显示时，同时场景面板（以及启用Gizmos的游戏面板）中，我们看到可通行区域形成一个蓝色导航网格。
- en: 'Note: The blue areas are the default NavMesh Area. See, later in this chapter,
    a recipe for different, custom named, costed, color-coded NavMesh Areas.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：蓝色区域是默认的NavMesh区域。请看，在本章后面，有一个不同、自定义命名、有成本、颜色编码的NavMesh区域的配方。
- en: The location for our NPC object to travel towards is the position of the Capsule-destination
    GameObject at (-12, 0, 8); but, of course we could just move this object in the
    Scene panel at Design-Time, and its new position would be the destination when
    we run the game.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们NPC对象要前往的位置是胶囊目标GameObject在(-12, 0, 8)的位置；当然，我们也可以在场景面板中设计时移动这个对象，其新的位置将在游戏运行时成为目的地。
- en: 'The `ArrowNPCMovement` C# script class has two variables: one is a reference
    to the destination GameObject, and the second is a reference to the NavMeshAgent
    component of the GameObject, in which our instance of the `ArrowNPCMovement` class
    is also a component. When the scene starts, the NavMeshAgent sibling component
    is found via the `Start()` method, and the `HeadForDestination()` method is called,
    which sets the destination of the NavMeshAgent to the position of the destination
    GameObject.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrowNPCMovement` C#脚本类有两个变量：一个是目标GameObject的引用，另一个是GameObject的NavMeshAgent组件的引用，其中我们的`ArrowNPCMovement`类实例也是一个组件。当场景开始时，通过`Start()`方法找到NavMeshAgent兄弟组件，并调用`HeadForDestination()`方法，将NavMeshAgent的目的地设置为目的地GameObject的位置。'
- en: Once the NavMeshAgent has a target to head towards, it will plan a path there
    and will keep moving until it arrives (or gets within the Stopping Distance if
    that parameter has been set to a distance greater than zero).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦NavMeshAgent有一个目标要前往，它将规划一条路径并持续移动，直到到达（或者如果该参数被设置为大于零的距离，则在其停止距离内）。
- en: In the Scene panel, if you select the GameObject that contains the NavMeshAgent
    and choose the Show Avoidance Gizmo, then you can see the candidate local target
    positions the agent is considering. The lighter the squares are, the better a
    position ranks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景面板中，如果您选择包含NavMeshAgent的GameObject并选择显示避免工具，那么您可以看到代理正在考虑的候选局部目标位置。方块越亮，位置排名越好。
- en: 'The darker red the squares are, the less desirable the position; so, dark red
    squares indicate positions to avoid, since they might, for instance, cause the
    agent to collide with a NavMesh Static obstacle:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 方块的颜色越深，位置就越不理想；因此，深红色方块表示要避免的位置，因为它们可能会造成代理与NavMesh静态障碍物碰撞：
- en: '![](img/0e9d87d2-7baf-448c-afca-5c874029bf90.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e9d87d2-7baf-448c-afca-5c874029bf90.png)'
- en: Ensure that the object with the NavMeshAgent component is selected in the Hierarchy
    panel at **Run-Time** to be able to see this navigation data in the Scene panel.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在**运行时**选择具有NavMeshAgent组件的对象在层次结构面板中，以便能够在场景面板中看到这些导航数据。
- en: NPC to seek or flee from a moving object
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC寻找或逃离移动对象
- en: Rather than a destination that is fixed when the scene starts, let's allow the
    Capsule-destination object to be moved by the player while the scene is running.
    In every frame, we'll get our NPC arrow to reset the NavMeshAgent's destination
    to wherever Capsule-destination has been moved to.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在场景开始时固定的目标，让我们允许Capsule-destination对象在场景运行时被玩家移动。在每一帧，我们将使NPC箭头重置NavMeshAgent的目标为Capsule-destination被移动到的任何位置。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是在之前的配方基础上增加的，所以请复制那个项目文件夹，并使用该副本来完成这个配方的任务。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To make an NPC seek or flee from a moving object, follow these steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使NPC寻找或逃离移动对象，请按照以下步骤操作：
- en: In the Inspector, add a Rigid Body Physics component to GameObject Capsule-destination.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，为Capsule-destination GameObject添加一个刚体物理组件。
- en: In the Inspector, for the Capsule-destination GameObject, check the Freeze Position
    constraint for the Y axis in the Constraints options of the RigidBody component.
    This will prevent the object moving in the Y-axis due to collisions when being
    moved.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，对于Capsule-destination GameObject，在刚体组件的约束选项中检查Y轴的冻结位置约束。这将防止由于移动时的碰撞而导致对象在Y轴上移动。
- en: 'Create the `SimplePlayerControl` C# script-class, and add an instance-object
    as a component to the Capsule-destination GameObject:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`SimplePlayerControl`C#脚本类，并将其作为组件添加到Capsule-destination GameObject：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update the `ArrowNPCMovement` C# script-class so that we call the `HeadForDestintation()`
    method every frame, that is, from `Update()`, rather than just once in `Start()`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ArrowNPCMovement`C#脚本类，以便我们每帧调用`HeadForDestintation()`方法，即从`Update()`而不是仅在`Start()`中调用一次：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `SimplePlayerControl` script-class detects arrow key presses and translates
    them into a force to apply to move the Capsule-destination GameObject in the desired
    direction.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimplePlayerControl`脚本类检测箭头键的按下，并将它们转换为应用于移动Capsule-destination GameObject的力的方向。'
- en: The `Update()` method of the `ArrowNPCMovement` script-class makes the NavMeshAgent
    update its path **every** frame, based on the current position of the Capsule-destination
    GameObject. As the user moves Capsule-destination, so the NavMeshAgent calculates
    a new path to the object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrowNPCMovement`脚本类的`Update()`方法使NavMeshAgent根据Capsule-destination GameObject的当前位置每帧更新其路径。当用户移动Capsule-destination时，NavMeshAgent会计算到该对象的新路径。'
- en: There's more
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: Here are some details that you don't want to miss.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你不想错过的细节。
- en: Using a Debug Ray to show a source-to-destination line
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试射线显示源到目标线
- en: It's useful to use a visual Debug Ray to show us the straight line from the
    NPC with the NavMeshAgent to the current destination it is trying to navigate
    towards. Since this is a common thing we may wish to do for many games, it's useful
    to create a static method in a general-purpose class, and then the ray can be
    drawn with a single statement.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可视调试射线显示NPC与NavMeshAgent之间的直线，以及它正在尝试导航到的当前目标非常有用。由于这是我们可能希望为许多游戏做的事情，因此在一个通用类中创建一个静态方法很有用，然后射线可以用一个单独的语句绘制。
- en: 'To use a Debug Ray to draw a source-to-destination line, follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用调试射线绘制源到目标线，请按照以下步骤操作：
- en: 'Create a `UsefulFunctions.cs` C# script-class, containing the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`UsefulFunctions.cs`C#脚本类，包含以下内容：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, add a statement at the end of the `HeadForDestination()` method in the `NPCMovement` C#
    script-class:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`NPCMovement`C#脚本类中的`HeadForDestination()`方法末尾添加一个语句：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now see a yellow line in the Scene panel when the scene is running.
    We can also see this in the Game panel if the Gizmos option is selected (top-right
    of the Game panel title bar):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景运行时，我们可以在场景面板中看到一个黄色的线。如果选择游戏面板中的Gizmos选项（游戏面板标题栏的右上角），我们也可以在游戏面板中看到这个：
- en: '![](img/37bd623b-435e-468e-9e93-6040dfc9c966.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37bd623b-435e-468e-9e93-6040dfc9c966.png)'
- en: Constantly updating NavMeshAgent destination to flee from Player's current location
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续更新NavMeshAgent目的地以避开玩家的当前位置
- en: There are times when we want an AI-controlled NPC character to move **away**
    from another character, rather than go towards it. For example, an enemy with
    very low health might run away, and so gain time to regain its health before fighting
    again. Or, a wild animal might flee from any other character moving near it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望由AI控制的NPC角色**远离**另一个角色，而不是朝它移动。例如，一个生命值非常低的敌人可能会逃跑，从而在再次战斗之前获得恢复生命值的时间。或者，一只野生动物可能会逃离任何靠近它的其他角色。
- en: 'To instruct our NavMeshAgent to flee from the player''s location, we need to
    replace the `ArrowNPCMovement` C# script class with the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要让我们的NavMeshAgent避开玩家的位置，我们需要将`ArrowNPCMovement`C#脚本类替换为以下内容：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is a public variable, `runAwayDistance`. When the distance to the enemy
    is less than the value of this `runAwayDistance` variable, then we'll instruct
    the computer-controlled object to flee in the opposite direction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个公共变量`runAwayDistance`。当敌人距离小于这个`runAwayDistance`变量的值时，我们将指示计算机控制的对象向相反方向逃跑。
- en: The `Start()` method caches a reference to the NavMeshAgent component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法缓存了NavMeshAgent组件的引用。'
- en: The `Update()` method calculates whether the distance to the enemy is within
    `runAwayDistance`, and if so, it calls the `FleeFromTarget(...)` method, which
    passes the location of the enemy as a parameter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`方法计算敌人距离是否在`runAwayDistance`范围内，如果是，则调用`FleeFromTarget(...)`方法，并将敌人位置作为参数传递。'
- en: The `FleeFromTarget(...)` method calculates a point that is the `runAwayDistance` in
    Unity units away from the Player's cube, in a direction that is directly away
    from the computer-controlled object. This is achieved by subtracting the enemy
    position vector from the current transform's position.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`FleeFromTarget(...)`方法计算一个点，该点在Unity单位中距离玩家立方体`runAwayDistance`，方向是直接远离计算机控制的对象。这是通过从当前变换的位置减去敌人位置向量来实现的。'
- en: Finally, the `HeadForDestintation(...)` method is called, passing the flee-to
    position, which results in the NavMeshAgent being told to set the location as
    its new destination.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`HeadForDestintation(...)`方法，传递逃跑到的位置，这将导致NavMeshAgent被指示将位置设置为新的目的地。
- en: 'Unity units are arbitrary, since they are just numbers on a computer. However,
    in most cases, it simplifies things to think of distances in terms of meters (1
    Unity unit = 1 meter), and mass in terms of kilograms (1 Unity unit = 1 kilogram).
    Of course, if your game is based on a microscopic world, or pan-galactic space
    travel, then you need to decide what each Unity unit corresponds to for your game
    context. For further discussion of units in Unity, check out this post about Unity
    measurements: [http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487](http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Unity单位是任意的，因为它们只是计算机上的数字。然而，在大多数情况下，将距离视为米（1 Unity单位 = 1米），质量视为千克（1 Unity单位
    = 1千克）会使事情变得简单。当然，如果你的游戏基于微观世界或跨银河系太空旅行，那么你需要决定每个Unity单位在你的游戏上下文中对应什么。有关Unity中单位的进一步讨论，请查看这篇关于Unity测量的帖子：[http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487](http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487)。
- en: 'The Debug Ray shows the point the NPC is aiming for, whether it be to flee
    away from the player''s character, or to catch up and maintain a constant distance
    from it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Debug Ray显示了NPC瞄准的点，无论是为了避开玩家的角色，还是为了赶上并保持与它的恒定距离：
- en: '![](img/875ba89b-7b33-43f8-a4d6-0eae3ae64f5a.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/875ba89b-7b33-43f8-a4d6-0eae3ae64f5a.png)'
- en: Maintain constant distance from target ("lurking" mode!)
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持与目标恒定的距离（“潜伏”模式！）
- en: It is simple to adapt the previous code to have an NPC try to maintain a constant
    distance from a target object. It involves always moving towards a point that
    is `runAwayDistance` away from the target, regardless of whether this point is
    towards or away from the target.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前的代码修改为NPC尝试与目标对象保持恒定距离很简单。这涉及到始终朝向距离目标`runAwayDistance`的点移动，无论这个点是否朝向或远离目标。
- en: 'Just remove the `If` statement in the `Update()` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 只需从`Update()`方法中移除`If`语句：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, with this variation, it might be better to have the method named something
    like `MoveTowardsConstantDistancePoint()` rather than `FleeFromTarget()`, since
    our NPC is sometimes fleeing and sometimes following.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种变化，可能最好将方法命名为`MoveTowardsConstantDistancePoint()`而不是`FleeFromTarget()`，因为我们的NPC有时在逃跑，有时在跟随。
- en: Point-and-click move to object
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击式移动到对象
- en: 'Another way to choose the destination for our Sphere-arrow GameObject is by
    the user clicking on an object on the screen, and then the Sphere-arrow GameObject
    moving to the location of the clicked object:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种为我们的Sphere-arrow GameObject选择目的地的方法是通过用户点击屏幕上的对象，然后Sphere-arrow GameObject移动到被点击对象的当前位置：
- en: '![](img/e088434d-ad3e-48e6-a2aa-1f47e15c30ea.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e088434d-ad3e-48e6-a2aa-1f47e15c30ea.png)'
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the first recipe in this chapter, so make a copy of that
    project folder and do your work for this recipe with that copy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方增加了本章的第一个配方，所以请复制那个项目文件夹，并使用该副本来完成这个配方的任务。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create an object-based point-and-click mini-game, do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建基于对象的点击式迷你游戏，请执行以下操作：
- en: In the Inspector, add the Player Tag to the Sphere-arrow GameObject.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将Player Tag添加到Sphere-arrow GameObject。
- en: Delete the two 3D Cubes and the 3D Capsule-destination from the scene.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中删除两个3D立方体和3D胶囊目标。
- en: 'Create a `ClickMeToSetDestination` C# script-class containing the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含以下内容的`ClickMeToSetDestination` C#脚本类：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add instance-objects of the `ClickMeToSetDestination` C# script-class as components
    to your 3D Cube, Sphere, and Cylinder.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ClickMeToSetDestination` C#脚本类的实例对象作为组件添加到您的3D立方体、球体和圆柱体中。
- en: Run the Scene. When you click on one of the 3D objects, the Sphere-arrow GameObject
    should navigate towards the clicked object.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。当你点击其中一个3D对象时，Sphere-arrow GameObject应该导航到被点击的对象。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `OnMouseDown()` method of the `ClickMeToSetDestination` C# script-class
    changes the destination of the NavMeshAgent in the Sphere-arrow GameObject to
    be the position of the clicked 3D object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClickMeToSetDestination` C#脚本类的`OnMouseDown()`方法将Sphere-arrow GameObject中的NavMeshAgent的目标位置更改为被点击的3D对象的位置。'
- en: The `Start()` method of the `ClickMeToSetDestination` C# script-class gets a
    reference to the NavMeshAgent component of the GameObject tagged Player (that
    is, the Sphere-arrow GameObject).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClickMeToSetDestination` C#脚本类的`Start()`方法获取标记为Player的GameObject（即Sphere-arrow
    GameObject）的NavMeshAgent组件的引用。'
- en: Each time a different object is clicked, the NavMeshAgent inside the Sphere-arrow
    GameObject is updated to make the GameObject move towards the position of the
    clicked object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击不同的对象时，Sphere-arrow GameObject内部的NavMeshAgent都会更新，使GameObject移动到被点击对象的当前位置。
- en: There's more
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容
- en: There are some details that you don't want to miss.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不应该错过。
- en: Creating a mouse-over yellow highlight
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建鼠标悬停黄色高亮
- en: A good UX (**User Experience**) feedback technique is to visually indicate to
    the user when an object can be interacted with via the mouse. A common way to
    do this is to present an audio or visual effect when the mouse is moved over an
    interactable object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的UX（**用户体验**）反馈技术是在用户可以通过鼠标与对象交互时，通过视觉方式向用户指示。一种常见的方法是在鼠标移到可交互对象上时，呈现音频或视觉效果。
- en: We can create a Material with a yellow color, which can make an object appear
    yellow while the mouse is over it, and then return to its original material when
    the mouse is moved away.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个黄色的Material，当鼠标悬停在对象上时，可以使对象看起来是黄色的，然后当鼠标移开时，对象恢复到原始材质。
- en: 'Create the `MouseOverHighlighter` C# `script-class` with the following contents.
    Then, add an instance-object as a component to each of the three 3D GameObjects:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包含以下内容的`MouseOverHighlighter` C#脚本类。然后，将实例对象作为组件添加到每个三个3D GameObject中：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, when running the game, when your mouse is over one of the three objects,
    that object will be highlighted yellow. If you click on the mouse button when
    the object is highlighted, the Sphere-arrow GameObject will make its way up to
    (but stop just before) the clicked object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当运行游戏时，当鼠标悬停在三个对象之一上时，该对象将被突出显示为黄色。如果你在对象突出显示时点击鼠标按钮，Sphere-arrow GameObject将移动到（但停止在点击对象之前）。
- en: Point-and-click move to tile
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点选移动到瓦片
- en: 'Rather than clicking specific objects to indicate the target for our AI-controlled
    agent, we can create a grid of 3D Plane (tile) objects to allow the player to
    click any tile to indicate a destination for the AI-controller character. So,
    any location can be clicked, rather than only one of a few specific objects:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过点击特定对象来指示我们的AI控制代理的目标相比，我们可以创建一个由3D平面（瓦片）对象组成的网格，允许玩家点击任何瓦片来指示AI控制角色的目的地。因此，任何位置都可以点击，而不仅仅是少数几个特定对象：
- en: '![](img/75c0c4bd-eb2c-4547-bf06-7f611705fb5d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75c0c4bd-eb2c-4547-bf06-7f611705fb5d.png)'
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方在先前的配方基础上进行扩展，因此请复制那个项目文件夹，并使用该副本来完成此配方的操作。
- en: For this recipe, we have prepared a red-outlined black square Texture image
    named square_outline.png in a folder named Textures in the `15_04` folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此配方，我们在`15_04`文件夹中的Textures文件夹中准备了一个名为square_outline.png的红色轮廓黑色方块Texture图像。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create a point-and-click game making GameObjects to a selected tile, do
    the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个点选游戏，将GameObject移动到选定的瓦片，请执行以下操作：
- en: Delete your 3D Cube, Sphere, and Cylinder GameObjects from the scene.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中删除你的3D立方体、球体和圆柱体GameObject。
- en: Create a new 3D Plane object, scaled to (0.1, 0.1, 0.1).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D平面对象，缩放为（0.1，0.1，0.1）。
- en: Create a new Material with the Texture image square_outline.png provided (black
    square with a red outline). Apply this Material to your 3D Plane.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质，使用提供的Texture图像square_outline.png（黑色带有红色轮廓的方块）。将此材质应用到你的3D平面上。
- en: Add an instance-object of the `ClickMeToSetDestination` script-class as a component
    to your 3D Plane.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ClickMeToSetDestination`脚本类的实例对象作为组件添加到3D平面。
- en: In the Project panel, create a new empty Prefab named tile.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为tile的新空Prefab。
- en: Populate your Prefab tile with the properties of your 3D Plane GameObject by
    dragging the plane GameObject over your Prefab tile (it should change from white
    to blue to indicate the Prefab now has the properties of your GameObject).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将平面GameObject拖动到Prefab瓦片上，将Prefab瓦片填充为你的3D平面GameObject的属性（它应该从白色变为蓝色，以指示Prefab现在具有你的GameObject的属性）。
- en: Delete your 3D Plane GameObject from the scene.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中删除你的3D平面GameObject。
- en: 'Create a new `TileManager` C# script-class containing the following, and add
    an instance-object as a component to the Main Camera GameObject:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`TileManager`C#脚本类，包含以下内容，并将其作为组件添加到主摄像机GameObject：
- en: '[PRE9]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Select the Main Camera in the Hierarchy, and in the Inspector for the Tile Manager
    (Script) component, populate the Prefab Clickable Tile public property with your
    Prefab tile from the Project panel.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择主摄像机，并在Tile Manager（脚本）组件的检查器中，将“Prefab Clickable Tile”公共属性填充为项目面板中的Prefab瓦片。
- en: Run the scene. You should now be able to click on any of the small square tiles
    to set the destination of the NavMeshAgent controlled Sphere-arrow GameObject.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。现在，你应该能够点击任何小方块瓦片来设置NavMeshAgent控制的Sphere-arrow GameObject的目标。
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You created a Prefab, containing the properties of a 3D Plane named tile, which
    contained a component instance-object of the `ClickMeToSetDestination` C# script-class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个Prefab，其中包含名为tile的3D平面的属性，该Prefab包含`ClickMeToSetDestination`C#脚本类的组件实例对象。
- en: The `TileManager` script class loops to create 50 x 50 instances of this tile
    Gameobject in the Scene.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`TileManager`脚本类循环创建场景中此瓦片GameObject的50 x 50个实例。'
- en: When you run the game, if you click on the mouse button when the mouse pointer
    is over a tile, the NavMeshAgent inside the Sphere-arrow GameObject is set to
    that tile's position. So, the Sphere-arrow GameObject will move towards, but stop
    just before reaching, the clicked tile position.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行游戏时，如果你在鼠标指针悬停在瓦片上时点击鼠标按钮，Sphere-arrow GameObject内部的NavMeshAgent将被设置为该瓦片的位置。因此，Sphere-arrow
    GameObject将移动到，但在到达点击的瓦片位置之前停止。
- en: The **Y** value of 0.01 means the plane will be just above the Terrain, so we
    avoid any kind of Moire interference pattern due to meshes at the same location.
    By subtracting `rows/2` and `cols/2` for the **X** and **Z** positions, we center
    our grid of tiles at (0, Y, 0).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**Y** 值为 0.01 表示平面将刚好位于地形之上，因此我们避免了由于同一位置网格造成的任何类型的摩尔纹干扰模式。通过从 **X** 和 **Z**
    位置减去 `rows/2` 和 `cols/2`，我们将瓦片网格的中心定位在 (0, Y, 0)。'
- en: There's more
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容
- en: There are some details that you don't want to miss.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节是你不想错过的。
- en: Yellow debug-ray to show destination of AI-agent
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黄色调试射线显示 AI 代理的目的地
- en: 'We can show a debug ray from a moving object to its destination tile by creating
    the `MouseOverHighlighter` C# script-class with the following contents. We then
    add an instance-object as a component to the NavMeshAgent controlled Sphere-arrow
    GameObject:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建具有以下内容的 `MouseOverHighlighter` C# 脚本类来显示移动对象到其目的地瓦片的调试射线。然后，我们将实例对象作为组件添加到
    NavMeshAgent 控制的 Sphere-arrow 游戏对象中：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Point-and-click Raycast with user-defined higher-cost Navigation Areas
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用户定义的更高成本导航区域的点按射线投射
- en: Rather than indicating a desired destination by clicking an object or tile,
    we can use Unity's built-in `Physics.Raycast(...)` method to identify which Vector3
    (x,y,z) position relates to the object surface in the game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是通过点击对象或瓦片来指示期望的目的地，我们可以使用 Unity 内置的 `Physics.Raycast(...)` 方法来识别与游戏中的对象表面相关的哪个
    Vector3 (x,y,z) 位置。
- en: This involves translating from the 2D (x,y) screen position to an imagined 3D
    "ray" from the user's point of view, through the screen, into the game world,
    and identifying which object (polygon) it **hits** first.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到从 2D (x,y) 屏幕位置转换到一个想象中的从用户视角出发的 3D “射线”，穿过屏幕，进入游戏世界，并识别它首先**击中**的对象（多边形）。
- en: 'This recipe uses `Physics.Raycast` to set the position of the location clicked
    on as the new destination for a NavMeshAgent controller object. The actual route
    followed can be influenced by defining Navigation Mesh Areas of different costs.
    For example, walking through mud or swimming through water can have a higher cost,
    since they would take longer, so the AI NavMeshAgent can calculate the lowest-cost
    route, which may not be the shortest distance route in the scene:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用 `Physics.Raycast` 将点击位置的位置设置为 NavMeshAgent 控制对象的新目的地。实际遵循的路线可以通过定义不同成本的导航网格区域来影响。例如，穿过泥地或游泳穿越水可能具有更高的成本，因为它们会花费更长的时间，所以
    AI NavMeshAgent 可以计算出最低成本的路线，这可能是场景中最短距离的路线：
- en: '![](img/baf3c66d-d516-42c3-aff4-84fb0eb05523.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/baf3c66d-d516-42c3-aff4-84fb0eb05523.png)'
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方在先前的配方上进行了扩展，因此请复制那个项目文件夹，并使用该副本为此配方进行工作。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a point-and-click game using a Raycast, do the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用射线投射创建一个点按游戏，请执行以下操作：
- en: Remove the Tile Manager (Script) component from the Main Camera GameObject.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主相机游戏对象中移除 Tile Manager (脚本) 组件。
- en: Create a new 3D Sphere, named Sphere-destination, scaled to (0.5, 0.5, 0.5).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 3D 球体，命名为 Sphere-destination，缩放为 (0.5, 0.5, 0.5)。
- en: Create a new Material that is red in color, and assign this material to the Sphere-destination GameObject.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的红色材质，并将其分配给 Sphere-destination 游戏对象。
- en: 'Create a new `MoveToClickPoint` C# script-class containing the following, and
    add an instance-object as a component to the Sphere-arrow GameObject:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`MoveToClickPoint` C# 脚本类，包含以下内容，并将实例对象作为组件添加到 Sphere-arrow 游戏对象中：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Select the Sphere-arrow GameObject in the Hierarchy, and in the Inspector for
    the MoveToClickPoint (Script) component, populate the Sphere Destination public
    property with your red Sphere-destination GameObject.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 中选择 Sphere-arrow 游戏对象，并在 MoveToClickPoint (脚本) 组件的 Inspector 中，将
    Sphere Destination 公共属性填充为你的红色 Sphere-destination 游戏对象。
- en: Run the scene. You should now be able to click anywhere on the Terrain to set
    the destination of the NavMeshAgent controlled Sphere-arrow GameObject. As you
    click, the red Sphere-destination GameObject should be positioned at this new
    destination point, towards which the Sphere-arrow GameObject will navigate.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。现在你应该能够点击地形上的任何位置来设置 NavMeshAgent 控制的 Sphere-arrow 游戏对象的目的地。当你点击时，红色 Sphere-destination
    游戏对象应该位于这个新的目的地点，Sphere-arrow 游戏对象将朝这个方向导航。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a small red 3D Sphere named Sphere-destination.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个名为 Sphere-destination 的小红色 3D 球体。
- en: There is one public variable for the `MoveToClickPoint` scripted component of
    the Sphere-arrow GameObject. This public `sphereDestination` variable has been
    linked to the red Sphere-destination GameObject in the scene.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Sphere-arrow GameObject的`MoveToClickPoint`脚本组件有一个公共变量。这个公共的`sphereDestination`变量已经与场景中的红色Sphere-destination
    GameObject链接。
- en: 'There are two private variables:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个私有变量：
- en: '`navMeshAgent`: This will be set to refer to the NavMeshAgent component of
    the Sphere-arrow GameObject, so its destination can be reset when appropriate.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navMeshAgent`：这将设置为指向Sphere-arrow GameObject的NavMeshAgent组件，以便在适当的时候重置其目的地。'
- en: '`hit`: This is a `RaycastHit` object, which is passed in as the object to be
    set by `Physics.Raycast(...)`. Various properties of this object are set after
    a Raycast has been created, including the position in the scene where the Raycast
    hit the surface of an object.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hit`：这是一个`RaycastHit`对象，作为`Physics.Raycast(...)`要设置的参数传入。在创建射线后，设置了该对象的多个属性，包括射线击中物体表面的场景中的位置。'
- en: The `Start()` method caches a reference to the NavMesh component of the Sphere-arrow
    GameObject, and also moves the Sphere-destination GameObject to the current object's
    location.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法缓存了Sphere-arrow GameObject的NavMesh组件的引用，并将Sphere-destination GameObject移动到当前对象的位置。'
- en: Each frame, in the `Update()` method, a Ray is created based on the Main Camera
    and the (2,y) point clicked on the screen. This Ray is passed as a parameter to
    the `FireRayCast(...)` method. If that method returns true, then the position
    of the object hit is extracted and passed to the `ProcessRayHit(...)` method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`方法中，每一帧都会根据主相机和屏幕上点击的(2,y)点创建一个射线。这个射线作为参数传递给`FireRayCast(...)`方法。如果该方法返回true，则提取被击中物体的位置并传递给`ProcessRayHit(...)`方法。
- en: The `FireRayCast(...)` method receives a Ray object. It uses `Phyics.Raycast(...)`
    to determine whether the Raycast collides with part of an object in the scene.
    If the Raycast hits something, the properties of the `RaycastHit hit` object are
    updated. A true/false for whether `Physics.Raycast(...)` hit a surface is returned
    by this method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`FireRayCast(...)`方法接收一个射线对象。它使用`Physics.Raycast(...)`来确定射线是否与场景中某个物体的部分发生碰撞。如果射线击中某个物体，则`RaycastHit
    hit`对象的属性将被更新。该方法返回一个布尔值，表示`Physics.Raycast(...)`是否击中了表面。'
- en: Each time the user clicks on the screen, the corresponding object in the scene
    is identified with the Raycast, the red sphere is moved there, and the NavMeshAgent
    begins to navigate towards that location.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户点击屏幕时，场景中的相应对象都会通过射线识别，红色球体被移动到那里，并且NavMeshAgent开始向该位置导航。
- en: Learn more about the Unity Raycast C# script-class at [https://docs.unity3d.com/ScriptReference/RaycastHit.html.](https://docs.unity3d.com/ScriptReference/RaycastHit.html.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://docs.unity3d.com/ScriptReference/RaycastHit.html](https://docs.unity3d.com/ScriptReference/RaycastHit.html)了解更多关于Unity射线C#脚本类的信息。
- en: There's more
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: Here are some details that you won't want to miss.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些细节，你不想错过。
- en: More intelligent pathfinding by setting different costs for custom-defined navigation
    areas such as Mud and Water
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过为自定义定义的导航区域（如泥地和水面）设置不同的成本来实现更智能的路径查找
- en: We can create objects whose meshes are defined as more expensive for NavMeshAgents
    to travel across, helping AI-agent behavior be more realistic in terms of choosing
    faster paths that avoid Water, Mud, and so on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建网格定义为NavMeshAgents旅行成本更高的对象，这有助于AI代理行为在避免水、泥地等时选择更快的路径，从而在现实世界中更加真实。
- en: 'To create a custom NavMesh Area (we''ll pretend it''s mud) with a higher travelling
    cost, do the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有更高旅行成本的定制NavMesh区域（我们假设它是泥地），请执行以下操作：
- en: 'In the Navigation panel, reveal the areas by clicking the Areas button. Then,
    define a new area named Mud with a cost of 2:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航面板中，通过点击区域按钮来揭示区域。然后，定义一个名为泥地的新区域，成本为2：
- en: '![](img/0d0a0568-05f0-4116-aff1-f59577632589.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d0a0568-05f0-4116-aff1-f59577632589.png)'
- en: Create a new 3D Cylinder named Cylinder-mud, positioned at (0, -4.9, 0) and
    scaled to (5,5,5).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D圆柱体，命名为Cylinder-mud，位置在(0, -4.9, 0)，缩放为(5,5,5)。
- en: Ensure the Cylinder-mud GameObject is selected in the Hierarchy, and that the
    Navigation panel is displayed.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在层次结构中选择Cylinder-mud GameObject，并且导航面板是显示的。
- en: 'In the Navigation panel, click the Object button, check Navigation Static,
    and choose Mud from the Navigation Area drop-down list:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航面板中，点击对象按钮，勾选导航静态，并从导航区域下拉列表中选择泥地：
- en: '![](img/c68362d4-149c-45df-9624-ac853d490a85.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c68362d4-149c-45df-9624-ac853d490a85.png)'
- en: Now, click the Bake button to show the NavigationBake sub-panel, and then in
    this sub-panel click the Bake button to regenerate the Navigation Mesh with the
    new object.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击烘焙按钮以显示导航烘焙子面板，然后在此子面板中点击烘焙按钮以使用新对象重新生成导航网格。
- en: 'Now, if you click to move the Sphere-arrow GameObject near the edge of the
    Cylinder-mud area, then, say, click on the opposite side, you''ll see the NavMeshAgent
    make the Sphere-arrow GameObject follow a semi-circular (lowest cost) path around
    the edge of the Cylinder-mud area, rather than follow a direct line (as the crow
    flies) path *through* the higher cost mud area:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你点击移动 Sphere-arrow GameObject 接近圆柱-泥地区域的边缘，然后，比如说，点击对面，你会看到 NavMeshAgent
    让 Sphere-arrow GameObject 沿着圆柱-泥地边缘的半圆形（最低成本）路径移动，而不是直接穿过成本更高的泥地路径：
- en: '![](img/3c20833a-cb82-4d40-9e15-d446f2ce068a.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c20833a-cb82-4d40-9e15-d446f2ce068a.png)'
- en: Improving UX by updating a "gaze" cursor each frame
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过每帧更新“注视”光标来提高用户体验
- en: It's nice to know where our destination will be set to **before** we click the
    mouse. So, let's add a yellow sphere to show the 'candidate' destination for where
    our Raycast is hitting a surface, updated each frame as we move the mouse.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击鼠标之前知道我们的目的地将被设置在哪里是很好的。所以，让我们添加一个黄色球体来显示我们的射线击中表面的“候选”目的地，这个目的地会随着我们移动鼠标而每帧更新。
- en: So, we need to create a second, yellow sphere. We also need to create a Layer
    to ignore; otherwise, if we move the yellow sphere to the point where a Raycast
    hits a surface, then in the next frame our Raycast will hit the surface of our
    yellow sphere - moving it closer and closer to us each frame!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建第二个黄色球体。我们还需要创建一个忽略层；否则，如果我们把黄色球体移动到射线击中表面的位置，那么在下一次帧中，我们的射线将会击中黄色球体的表面——每次帧都会让它离我们越来越近！
- en: 'To improve UX by updating a "gaze" cursor each frame, do the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过每帧更新“注视”光标来提高用户体验，请执行以下操作：
- en: Create a new yellow Material named m_yellow.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为 m_yellow 的黄色材质。
- en: Create a second 3D Sphere, named Sphere-destination-candidate and textured with
    m_yellow.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个 3D 球体，命名为 Sphere-destination-candidate，并使用 m_yellow 纹理。
- en: Create a new Layer, UISpheres.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的层，UISpheres。
- en: Set the Layer for both Sphere-destination and Sphere-destination-candidate GameObjects to
    LayerUISpheres.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Sphere-destination 和 Sphere-destination-candidate GameObject 的层设置为 LayerUISpheres。
- en: 'Modify the `MoveToClickPoint` C# script-class as follows to add a new public
    variable, `sphereDestinationCandidate`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MoveToClickPoint` C# 脚本类，添加一个新的公共变量 `sphereDestinationCandidate`：
- en: '[PRE12]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Modify the `MoveToClickPoint` C# script-class as follows to add an Else-clause
    **to the logic in the** `ProcessRayHit(...)`** method, so that if the mouse is**
    not clicked, then the yellow sphereDestinationCandidate object is moved to where
    the Raycast hit a surface:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MoveToClickPoint` C# 脚本类，在 `ProcessRayHit(...)` 方法的逻辑中添加一个 Else 子句，以便如果鼠标没有点击，则将黄色
    `sphereDestinationCandidate` 对象移动到射线击中表面的位置：
- en: '[PRE13]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Modify the `MoveToClickPoint` C# script-class as follows, so that a `LayerMask`
    is created to ignore Layer UISpheres, and passed as a parameter when `Physics.Raycast(...)`
    is invoked:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MoveToClickPoint` C# 脚本类，以便创建一个忽略层 UISpheres 的 `LayerMask`，并在调用 `Physics.Raycast(...)`
    时将其作为参数传递：
- en: '[PRE14]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Select the Sphere-arrow GameObject in the Hierarchy, and in the Inspector for
    the MoveToClickPoint (Script) component, populate the Sphere Destination Candidate public
    property with your yellow Sphere-destination-candidate GameObject.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 Sphere-arrow GameObject，然后在 MoveToClickPoint (Script) 组件的检查器中，将 Sphere
    Destination Candidate 公共属性填充为你的黄色 Sphere-destination-candidate GameObject。
- en: Run the scene. You should now be able to click anywhere on the Terrain to set
    the destination of the NavMeshAgent controlled Sphere-arrow GameObject. As you
    click, the red Sphere-destination GameObject should be positioned at this new
    destination point, towards which the Sphere-arrow GameObject will navigate.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。现在，你应该能够点击地形上的任何地方来设置 NavMeshAgent 控制的 Sphere-arrow GameObject 的目的地。当你点击时，红色的
    Sphere-destination GameObject 应该位于这个新的目的地点，Sphere-arrow GameObject 将朝这个方向导航。
- en: We have set a `LayerMask` using the `~LayerMask.GetMask("UISpheres") `statement,
    which means every layer apart from the named one. This is passed to the `Raycast(...)`
    method, so that our red and yellow Spheres are ignored when casting the ray and
    looking to see which surface the ray hits first.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `~LayerMask.GetMask("UISpheres")` 语句设置了一个 `LayerMask`，这意味着除了命名层之外的所有层。这个层被传递给
    `Raycast(...)` 方法，这样我们的红色和黄色球体在发射射线和查看射线首先击中哪个表面时会被忽略。
- en: NPC NavMeshAgent to follow waypoints in a sequence
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC NavMeshAgent 按顺序跟随航点
- en: Waypoints are often used as a guide to make autonomously moving NPCs and enemies
    follow a path in a general way, but be able to respond with other directional
    behaviors, such as flee or seek, if friends/predators/prey are sensed nearby.
    The waypoints are arranged in a sequence, so that when the character reaches or
    gets close to a waypoint, it will then select the next waypoint in the sequence
    as the target location to move towards. This recipe demonstrates an arrow object
    moving towards a waypoint, and then when it gets close enough, it will choose
    the next waypoint in the sequence as the new target destination. When the last
    waypoint has been reached, it again starts heading towards the first waypoint.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 航点通常用作指南，使自主移动的NPC和敌人以一般方式遵循路径，但能够在附近检测到朋友/捕食者/猎物时做出其他方向行为，如逃跑或寻找。航点按顺序排列，因此当角色到达或接近航点时，它将选择序列中的下一个航点作为移动的目标位置。这个配方演示了一个箭头对象移动到航点，然后当它足够接近时，它将选择序列中的下一个航点作为新的目标目的地。当到达最后一个航点后，它再次开始朝向第一个航点前进。
- en: 'Since Unity''s NavMeshAgent has simplified coding NPC behavior, our work in
    this recipe basically becomes finding the position of the next waypoint and then
    telling the NavMeshAgent that this waypoint is its new destination:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unity的NavMeshAgent简化了NPC行为的编码，我们在这个配方中的工作基本上变成了找到下一个航点的位置，然后告诉NavMeshAgent这个航点是其新的目的地：
- en: '![](img/b2a12d87-0083-436f-9144-ade4dbd9850d.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2a12d87-0083-436f-9144-ade4dbd9850d.png)'
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe adds to the first recipe in this chapter, so make a copy of that
    project folder and do your work for this recipe with that copy.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方增加了本章的第一个配方，所以复制那个项目文件夹，并使用那个副本来完成这个配方的任务。
- en: For this recipe, we have prepared the yellow brick texture image that you need
    in a folder named Textures in the `1362_08_06` folder.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`1362_08_06`文件夹中的Textures文件夹中准备了一张你需要使用的黄色砖块纹理图像。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To instruct an object to follow a sequence of waypoints, follow these steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示一个对象遵循一系列航点，请按照以下步骤操作：
- en: 'Replace the contents of the `ArrowNPCMovement` C# script class with the following:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ArrowNPCMovement`C#脚本类的内容替换为以下内容：
- en: '[PRE15]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a new 3D Capsule object named Capsule-waypoint-0 at (-12, 0, 8).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(-12, 0, 8)的位置创建一个新的3D胶囊对象，命名为Capsule-waypoint-0。
- en: Copy Capsule-waypoint-0, name the copy Capsule-waypoint-3, and position this
    copy at (8, 0, -8).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Capsule-waypoint-0，将其命名为Capsule-waypoint-3，并将此副本放置在(8, 0, -8)的位置。
- en: We are going to add some intermediate waypoints numbered 1 and 2 later on. This
    is why our second waypoint here is numbered 3, in case you were wondering.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将要添加一些中间的航点，编号为1和2。这就是为什么这里的第二个航点编号为3，以防你有所疑问。
- en: 'Create the `WaypointManager` C# script class with the following contents, and
    add an instance-object as a component to the Sphere-arrow GameObject:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下内容的`WaypointManager`C#脚本类，并将其作为组件添加到Sphere-arrow游戏对象中：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ensure that Sphere-arrow is selected in the Inspector for the `WaypointManager`
    scripted component. Drag Capsule-waypoint-0 and Capsule-waypoint-3 over the public
    variable projectiles called Way Point 0 and Way Point 3, respectively.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在检查器中选择了Sphere-arrow的`WaypointManager`脚本组件。将Capsule-waypoint-0和Capsule-waypoint-3拖动到名为Way
    Point 0和Way Point 3的公共变量projectiles上，分别对应。
- en: Now, run your game. The arrow object will first move towards one of the waypoint
    capsules, then when it gets close to it, it will slow down, turn around, head
    towards the other waypoint capsule, and keep doing that continuously.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的游戏。箭头对象将首先移动到其中一个航点胶囊，然后当它接近时，它会减速，掉头，朝向另一个航点胶囊前进，并持续这样做。
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The NavMeshAgent component that we added to the Sphere-arrow GameObject does
    most of the work for us. NavMeshAgent needs two things:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到Sphere-arrow游戏对象的NavMeshAgent组件为我们做了大部分工作。NavMeshAgent需要两样东西：
- en: A destination location to head towards
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个要前往的目的地位置
- en: A NavMesh, so that it can plan a path and avoid obstacles
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个NavMesh，以便它可以规划路径并避开障碍物
- en: 'We created two possible waypoints as the locations for our NPC to move towards:
    Capsule-waypoint-0 and Capsule-waypoint-3.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个可能的航点作为NPC移动的位置：Capsule-waypoint-0和Capsule-waypoint-3。
- en: 'The C# script class called `WaypointManager` has one job: to return a reference
    to the next waypoint that our NPC should head towards. There are two variables,
    `wayPoint0` and `wayPoint3`, which reference the two waypoint GameObjects in our
    scene. The `NextWaypoint(...)` method takes a single parameter named current,
    which is a reference to the current waypoint that the object is moving towards
    (or `null`). This method''s task is to return a reference to the next waypoint
    that the NPC should travel towards. The logic for this method is simple: if current
    refers to waypoint0, then we''ll return `waypoint3`; otherwise, we''ll return
    `waypoint0`. Note that if we pass this method `null`, then we''ll get `waypoint0`
    back (so, it is our default first waypoint).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `WaypointManager` 的 C# 脚本类有一个任务：返回我们的 NPC 应该前往的下一个路点的引用。有两个变量，`wayPoint0`
    和 `wayPoint3`，它们引用场景中的两个路点 GameObject。`NextWaypoint(...)` 方法接受一个名为 current 的单个参数，该参数是对象正在移动向其的当前路点的引用（或
    `null`）。此方法的任务是返回 NPC 应该前往的下一个路点的引用。此方法的逻辑很简单：如果 current 指向 `waypoint0`，则我们将返回
    `waypoint3`；否则，我们将返回 `waypoint0`。注意，如果我们向此方法传递 `null`，则我们将返回 `waypoint0`（因此，它是我们的默认第一个路点）。
- en: The `ArrowNPCMovement` C# script class has three variables. One is a reference
    to the destination GameObject named `targetGo`. The second is a reference to the
    `NavMeshAgent` component of the GameObject in which our instance of the class
    called `ArrowNPCMovement` is also a component. The third variable, called `waypointManager`,
    is a reference to the sibling scripted component, an instance of our `WaypointManager`
    script class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrowNPCMovement` C# 脚本类有三个变量。一个是名为 `targetGo` 的目标 GameObject 的引用。第二个是引用 GameObject
    的 `NavMeshAgent` 组件，其中我们的 `ArrowNPCMovement` 类实例也是一个组件。第三个变量，称为 `waypointManager`，是引用兄弟脚本组件，即我们的
    `WaypointManager` 脚本类的实例。'
- en: When the scene starts via the `Start()` method, the NavMeshAgent and WaypointManager
    sibling components are found, and the `HeadForDestination()` method is called.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景通过 `Start()` 方法开始时，找到 NavMeshAgent 和 WaypointManager 兄弟组件，并调用 `HeadForDestination()`
    方法。
- en: The `HeadForDestination()` method first sets the variable called `targetGO`
    to refer to the GameObject that is returned by a call to the `NextWaypoint(...)`
    of the scripted component called WaypointManager (that is, `targetGo` is set to
    refer to either Capsule-waypoint-0 or Capsule-waypoint-3). Next, it instructs
    the `NavMeshAgent` to make its destination the position of the `targetGO` GameObject.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeadForDestination()` 方法首先将名为 `targetGO` 的变量设置为指向通过调用名为 WaypointManager 的脚本组件的
    `NextWaypoint(...)` 方法返回的 GameObject（即，`targetGo` 被设置为指向 Capsule-waypoint-0 或
    Capsule-waypoint-3）。接下来，它指示 `NavMeshAgent` 将其目的地设置为 `targetGO` GameObject 的位置。'
- en: Each frame method called `Update()` is called. A test is made to see whether
    the distance from the NPC arrow object is close to the destination waypoint. If
    the distance is smaller than twice the stopping distance set in our NavMeshAgent,
    then a call is made to `WaypointManager.NextWaypoint(...)` to update our target
    destination to be the next waypoint in the sequence.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧都会调用名为 `Update()` 的方法。进行测试以查看 NPC 箭头对象与目的地路点的距离是否接近。如果距离小于我们在 NavMeshAgent
    中设置的停止距离的两倍，则调用 `WaypointManager.NextWaypoint(...)` 来更新我们的目标目的地为序列中的下一个路点。
- en: There's more...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some details that you won't want to miss.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你不想错过的细节。
- en: Working with arrays of waypoints
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与路点数组一起工作
- en: Having a separate `WaypointManager` C# script-class to simply swap between Capsule-waypoint-0
    and Capsule-waypoint-3 may have seemed to be a bit heavy duty and a case of over-engineering,
    but this was actually a very good move. An instance-object of the `WaypointManager` script-class has
    the job of returning the next waypoint. It is now very straightforward to add
    the more sophisticated approach of having an array of waypoints, without us having
    to change any code in the `ArrowNPCMovement` C# script-class. We can choose a
    random waypoint to be the next destination; for example, see the *Choosing destinations
    - find nearest (or a random) spawnpoint *recipe in [Chapter 14](eb0ea442-6350-4a86-9e16-708b80d8762f.xhtml),
    *Choosing and Controlling Positions*. Or, we can have an array of waypoints and
    choose the next one in the sequence.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个独立的`WaypointManager`C#脚本类，简单地在这几个胶囊位置（Capsule-waypoint-0和Capsule-waypoint-3）之间切换，可能看起来有点过于复杂，像是过度设计，但实际上这是一个非常好的举措。`WaypointManager`脚本类的实例对象负责返回下一个位置点。现在，在不修改`ArrowNPCMovement`C#脚本类中的任何代码的情况下，添加一个更复杂的具有位置点数组的实现方法变得非常简单。我们可以选择一个随机的位置点作为下一个目的地；例如，参见第14章中的*选择目的地
    - 查找最近的（或随机的）出生点*配方，*选择和控制位置*。或者，我们可以有一个位置点数组，并按顺序选择下一个位置点。
- en: 'To improve our game so that it works with an array of waypoints to be followed in
    sequence, we need to do the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的游戏，使其能够按顺序跟随一系列位置点，我们需要做以下几步：
- en: Copy Capsule-waypoint-0, name the copy Capsule-waypoint-1, and position this
    copy at (0, 0, 8).
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Capsule-waypoint-0，将其命名为Capsule-waypoint-1，并将此副本放置在（0，0，8）的位置。
- en: 'Make four more copies (named Capsule-waypoint-1, 2, 4, 5), and position them
    as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再复制四个（命名为Capsule-waypoint-1, 2, 4, 5），并按照以下方式定位它们：
- en: 'Capsule-waypoint-1: Position = (-2, 0, 8)'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Capsule-waypoint-1: 位置 = (-2, 0, 8)'
- en: 'Capsule-waypoint-2: Position = (8, 0, 8)'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Capsule-waypoint-2: 位置 = (8, 0, 8)'
- en: 'Capsule-waypoint-4: Position = (-2, 0, -8)'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Capsule-waypoint-4: 位置 = (-2, 0, -8)'
- en: 'Capsule-waypoint-5: Position = (-12, 0, -8)'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Capsule-waypoint-5: 位置 = (-12, 0, -8)'
- en: 'Replace the `WaypointManager` C# script-class with the following code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WaypointManager`C#脚本类替换为以下代码：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ensure that Sphere-arrow is selected. In the Inspector panel for the `WaypointManager`
    scripted component, set the size of the Waypoints array to 6\. Now, drag in all
    six capsule waypoint objects called Capsule-waypoint-0/1/2/3/4/5.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Sphere-arrow被选中。在`WaypointManager`脚本组件的检查器面板中，将Waypoints数组的大小设置为6。现在，拖入所有六个名为Capsule-waypoint-0/1/2/3/4/5的胶囊位置点对象。
- en: Run the game. Now, the Sphere-arrow GameObject will first move towards waypoint
    0 (top left), and then follow the sequence around the terrain.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。现在，Sphere-arrow GameObject将首先移动到位置点0（左上角），然后跟随地形周围的序列。
- en: Finally, you can make it look as if the Sphere is following a yellow brick road.
    Import the provided yellow brick texture, add this to your terrain, and paint
    the texture to create an oval-shaped path between the waypoints. You may also
    uncheck the Mesh Renderer component for each waypoint capsule, so that the user
    does not see any of the waypoints, just the arrow object following the yellow
    brick road.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以让它看起来像Sphere正在跟随一条黄色的砖路。导入提供的黄色砖纹理，将其添加到地形中，并绘制纹理以在位置点之间创建一个椭圆形路径。你也可以取消选中每个位置点胶囊的Mesh
    Renderer组件，这样用户就看不到任何位置点，只能看到跟随黄色砖路的箭头对象。
- en: In the `NextWaypoint(...)` method, first we check in case the array is empty,
    in which case an error is logged. Next, the array index for the current `waypoint`
    GameObject is found (if present in the array). Finally, the array index for the
    next waypoint is calculated using a modulus operator to support a cyclic sequence,
    returning to the beginning of the array after the last element has been visited.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NextWaypoint(...)`方法中，首先检查数组是否为空，如果是，则记录错误。接下来，找到当前`waypoint`GameObject在数组中的索引（如果存在）。最后，使用模运算符计算下一个位置点的数组索引，以支持循环序列，在访问到最后一个元素后返回数组的开始。
- en: Increased flexibility with a WayPoint class
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WayPoint类提高灵活性
- en: Rather than forcing a GameObject to follow a single rigid sequence of locations,
    we can make things more flexible by defining a `WayPoint` class where each waypoint
    GameObject has an array of possible destinations, and each of these has its own
    array. In this way, a digraph (directed graph) can be implemented, of which a
    linear sequence is just one possible instance.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是强制一个GameObject遵循单一的刚体位置序列，我们可以通过定义一个`WayPoint`类来使事情更加灵活，其中每个位置点GameObject都有一个可能的目的地数组，每个目的地也有自己的数组。这样，就可以实现一个有向图（digraph），其中线性序列只是可能的一个实例。
- en: 'To improve our game and make it work with a digraph of waypoints, do the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的游戏并使其与航点有向图一起工作，请执行以下操作：
- en: Remove the scripted `WayPointManager` component from the Sphere-arrow GameObject.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从球体箭头GameObject中移除脚本`WayPointManager`组件。
- en: 'Replace the `ArrowNPCMovement` C# script-class with the following code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ArrowNPCMovement`C#脚本类替换为以下代码：
- en: '[PRE18]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new `WayPoint` C# script-class containing the following code:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`WayPoint`C#脚本类，包含以下代码：
- en: '[PRE19]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Select all six GameObjects called Capsule-waypoint -0/1/2/3/4/5 and add to them
    an instance-object component of the `WayPoint` C# class.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有六个名为胶囊-航点-0/1/2/3/4/5的GameObject，并给它们添加一个`WayPoint`C#类的实例对象组件。
- en: Select the Sphere-arrow GameObject and add to it an instance-object component
    of the `WayPoint` C# class.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择球体箭头GameObject，并添加一个`WayPoint`C#类的实例对象组件。
- en: Ensure that the Sphere-arrow GameObject is selected. In the Inspector panel
    for the ArrowNPCMovement scripted component, drag Capsule-waypoint-0 into the
    `Waypoint` public variable slot.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择了球体箭头GameObject。在箭头NPCMovement脚本组件的检查器面板中，将胶囊-航点-0拖入`Waypoint`公共变量槽中。
- en: Now, we need to link Capsule-waypoint-0 to Capsule-waypoint-1, Capsule-waypoint-1
    to Capsule-waypoint -2, and so on. Select Capsule-waypoint-0, set its Waypoints
    array size to 1, and drag in Capsule-waypoint-1\. Next, select Capsule-waypoint-1,
    set its Waypoints array size to 1, and drag in Capsule-waypoint-2\. Continue in
    this way until you finally link Capsule-waypoint-5 back to Capsule-waypoint-0.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将胶囊-航点-0连接到胶囊-航点-1，胶囊-航点-1连接到胶囊-航点-2，依此类推。选择胶囊-航点-0，将其航点数组大小设置为1，并将胶囊-航点-1拖入。接下来，选择胶囊-航点-1，将其航点数组大小设置为1，并将胶囊-航点-2拖入。以此类推，直到最终将胶囊-航点-5连接回胶囊-航点-0。
- en: You now have a much more flexible game architecture, allowing GameObjects to
    randomly select one of several different paths at each waypoint reached. In this
    recipe variation, we have implemented a waypoint sequence, since each waypoint
    has an array of just one linked waypoint. However, if you change the array size
    to 2 or more, you will then be creating a graph of linked waypoints, adding random
    variations in the sequence of waypoints that a computer controlled character follows
    for any given run of your game.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在拥有一个更加灵活的游戏架构，允许GameObject在到达每个航点时随机选择几条不同的路径。在这个配方变体中，我们已经实现了一个航点序列，因为每个航点只有一个链接航点的数组。然而，如果您将数组大小更改为2或更多，那么您将创建一个链接航点的图，为计算机控制的字符在游戏运行中的任何给定运行添加随机变化。
- en: Controlling object group movement through flocking
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过鸟群控制对象组移动
- en: 'A realistic, natural-looking flocking behavior (for example birds, antelope,
    or bats) can be created through creating collections of objects with the following
    four simple rules:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建具有以下四个简单规则的对象集合，可以创建一个逼真的、自然外观的鸟群行为（例如鸟类、羚羊或蝙蝠）：
- en: '**Separation**: Avoid getting too close to neighbors'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：避免与邻居过于接近'
- en: '**Avoid obstacles**: Turn away from an obstacle immediately ahead'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免障碍物**：立即转向远离前方障碍物'
- en: '**Alignment**: Move in the general direction the flock is heading'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：向鸟群前进的一般方向移动'
- en: '**Cohesion**: Move towards a location in the middle of the flock'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内聚性**：向鸟群中间的位置移动'
- en: 'Each member of the flock acts independently, but needs to know about the current
    heading and location of the members of its flock. This recipe shows you how to
    create a scene with two flocks of cubes: one flock of green cubes and one flock
    of yellow cubes.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 鸟群中的每个成员都独立行动，但需要了解其鸟群成员的当前航向和位置。这个配方向您展示了如何创建一个包含两个鸟群立方体的场景：一个绿色立方体的鸟群和一个黄色立方体的鸟群。
- en: 'To keep things simple, we''ll not worry about separation in our recipe:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们不会在我们的配方中考虑分离：
- en: '![](img/3900a762-31ec-41ad-8a49-9d631f9d5401.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3900a762-31ec-41ad-8a49-9d631f9d5401.png)'
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created in the first recipe. So, make a copy of this project, open it, and then
    follow the steps for this recipe.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基于您在第一个配方中创建的玩家控制的3D立方体Unity项目。因此，复制此项目，打开它，然后按照此配方的步骤进行操作。
- en: The required script to control movement of the red Cube (`PlayerControl.cs`)
    is provided in the `15_07` folder.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 控制红色立方体（玩家控制）移动所需的脚本（`PlayerControl.cs`）在`15_07`文件夹中提供。
- en: How to do it...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make a group of objects flock together, please follow these steps:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一组对象聚集在一起，请按照以下步骤操作：
- en: Create a Material in the Project panel and name it m_green with the Main Color
    tinted green.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Project 面板中创建一个材质，命名为 m_green，并将主颜色设置为绿色。
- en: Create a Material in the Project panel and name it m_yellow with Main Color
    tinted yellow.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Project 面板中创建一个材质，命名为 m_yellow，并将主颜色设置为黄色。
- en: Create a 3D Cube GameObject named Cube-drone at (0,0,0). Drag the m_yellow Material
    into this object.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 (0,0,0) 位置创建一个名为 Cube-drone 的 3D 立方体 GameObject，并将 m_yellow 材质拖入此对象。
- en: Add a Navigation | NavMeshAgent component to Cube-drone. Set the Stopping Distance
    property of the NavMeshAgent component to 2.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 Cube-drone 添加一个 Navigation | NavMeshAgent 组件。将 NavMeshAgent 组件的 Stopping Distance
    属性设置为 2。
- en: 'Add a Physics RigidBody component to Cube-drone with the following properties:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 Cube-drone 添加一个具有以下属性的 Physics RigidBody 组件：
- en: Mass is 1
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量：1
- en: Drag is 0
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动为 0
- en: Angular Drag is 0.05
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度阻力为 0.05
- en: Use Gravity and Is Kinematic are both unchecked
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重力和不使用动力学都未勾选
- en: 'Constraints Freeze Position: check the Y-axis'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束冻结位置：勾选 Y 轴
- en: 'Create the following `Drone` C# script-class, and add an instance-object as
    a component to the Cube-drone GameObject:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `Drone` C# 脚本类，并将一个实例对象作为组件添加到 Cube-drone GameObject：
- en: '[PRE20]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create a new empty **Prefab** named dronePrefabYellow, and from the Hierarchy
    panel, drag your Cube-boid GameObject into this Prefab.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 **Prefab**，命名为 dronePrefabYellow，然后从 Hierarchy 面板中，将你的 Cube-boid GameObject
    拖入此 Prefab。
- en: Now, drag the m_green Material into the Cube-boid GameObject.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 m_green 材质拖入 Cube-boid GameObject。
- en: Create a new empty Prefab named dronePrefabGreen, and from the Hierarchy panel,
    drag your Cube-drone GameObject into this Prefab.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 Prefab，命名为 dronePrefabGreen，然后从 Hierarchy 面板中，将你的 Cube-drone GameObject
    拖入此 Prefab。
- en: Delete the Cube-drone GameObject from the Scene panel.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Scene 面板中删除 Cube-drone GameObject。
- en: 'Create the following `Swarm` C# script-class, and add an instance-object as
    a component to the Main Camera:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `Swarm` C# 脚本类，并将一个实例对象作为组件添加到 Main Camera：
- en: '[PRE21]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With Main Camera selected in the Hierarchy panel, drag dronePrefabYellow from
    the Project panel over the Drone Prefab public variable.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 面板中选择 Main Camera，从 Project 面板中将 dronePrefabYellow 拖到 Drone Prefab
    公共变量上。
- en: With Main Camera selected in the Hierarchy panel, add a second instance-object
    of the `Swarm` script-class to this GameObject, and then drag dronePrefabGreen from
    the Project panel over the Drone Prefab public variable.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 面板中选择 Main Camera，向此 GameObject 添加 `Swarm` 脚本类的一个第二个实例对象，然后从 Project
    面板中将 dronePrefabGreen 拖到 Drone Prefab 公共变量上。
- en: 'Create a new 3D Cube named wall-left with the following properties:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 3D 立方体，命名为 wall-left，具有以下属性：
- en: 'Position: (-15, 0.5, 0)'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置： (-15, 0.5, 0)
- en: 'Scale: (1, 1, 20)'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放： (1, 1, 20)
- en: Duplicate the wall-left object by naming the new object wall-right, and change
    the position of wall-right to (15, 0.5, 0).
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命名新对象 wall-right 复制 wall-left 对象，并将 wall-right 的位置更改为 (15, 0.5, 0)。
- en: 'Create a new 3D Cube named wall-top with the following properties:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 3D 立方体，命名为 wall-top，具有以下属性：
- en: 'Position: (0, 0.5, 10)'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置： (0, 0.5, 10)
- en: 'Scale: (31, 1, 1)'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放： (31, 1, 1)
- en: Duplicate the wall-top object by naming the new object wall-bottom, and change
    the position of wall-bottom to (0, 0.5, -10).
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命名新对象 wall-bottom 复制 wall-top 对象，并将 wall-bottom 的位置更改为 (0, 0.5, -10)。
- en: 'Create a new 3D Sphere named Sphere-obstacle with the following properties:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 3D 球体，命名为 Sphere-obstacle，具有以下属性：
- en: 'Position: (5, 0, 3)'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置： (5, 0, 3)
- en: 'Scale: (10, 3, 3)'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放： (10, 3, 3)
- en: In the Hierarchy panel, select the Sphere-obstacle GameObject. Then in the Navigation
    panel, check the Navigation Static checkbox. Then, click on the Bake button at
    the bottom of the Navigation panel.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 面板中选择 Sphere-obstacle GameObject。然后在 Navigation 面板中勾选 Navigation
    Static 复选框。然后，点击 Navigation 面板底部的 Bake 按钮。
- en: Finally, create a red 3D Cube for the player to control, making it red by adding Materialm_red
    to it and making it large by setting its scale to (3,3,3). Now, add an instance-object
    of the `PlayerControl` C# script-class provided as a component to this GameObject.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为玩家创建一个红色的 3D 立方体，通过添加 Materialm_red 使其变红，并通过将其缩放设置为 (3,3,3) 使其变大。现在，将 `PlayerControl`
    C# 脚本类的一个实例对象作为组件添加到这个 GameObject。
- en: How it works...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The Swarm class contains three variables:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm 类包含三个变量：
- en: '`droneCount`: It is an integer referencing the number of the Swarm class members
    created'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`droneCount`：它是一个整数，引用了创建的 Swarm 类成员的数量'
- en: '`dronePrefab`: It references the Prefab to be cloned to create swarm members'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dronePrefab`：它引用了要克隆以创建群体成员的 Prefab'
- en: '`drones`: A list of objects that reference drones; a list of all the scripted
    `Drone` components inside all the `Swarm` objects that have been created'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`drones`：一个引用无人机的对象列表；一个列表，包含所有已创建的`Swarm`对象中的所有脚本`Drone`组件'
- en: Upon creation, as the scene starts, the Swarm script class's `Awake()` method
    loops to create `droneCount` swarm members by repeatedly calling the `AddDrone()`
    method. This method instantiates a new GameObject from the prefab, and then sets
    the `newDrone` variable to be a reference to the Drone scripted object inside
    the new `Swarm` class member. In each frame, the `FixedUpdate()` method loops
    through the list of `Drone` objects by calling their `SetTargetPosition(...)`
    method, and passes in the `Swarm` center location and the average of all the swarm
    member velocities.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，随着场景的开始，Swarm脚本类的`Awake()`方法通过反复调用`AddDrone()`方法来循环创建`droneCount`个swarm成员。此方法从预制体实例化一个新的GameObject，然后将`newDrone`变量设置为对新的`Swarm`类成员中Drone脚本对象的引用。在每一帧中，`FixedUpdate()`方法通过调用它们的`SetTargetPosition(...)`方法来遍历`Drone`对象列表，并传入`Swarm`中心位置和所有swarm成员速度的平均值。
- en: 'The rest of this `Swarm` class is made up of two methods: one (`SwarmCenterAverage`)
    returns a `Vector3` object representing the average position of all the `Drone`
    objects, and the other (`SwarmMovementAverage`) returns a `Vector3` object representing
    the average velocity (movement force) of all the `Drone` objects:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Swarm`类的其余部分由两个方法组成：一个（`SwarmCenterAverage`）返回一个表示所有`Drone`对象平均位置的`Vector3`对象，另一个（`SwarmMovementAverage`）返回一个表示所有`Drone`对象平均速度（运动力）的`Vector3`对象：
- en: '`SwarmMovementAverage()`:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SwarmMovementAverage()`:'
- en: What is the general direction that the swarm is moving in?
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 群体正在移动的一般方向是什么？
- en: 'This is known as alignment: a swarm member attempting to move in the same direction
    as the swarm average'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这被称为对齐：一个swarm成员试图移动到与群体平均方向相同
- en: '`SwarmCenterAverage()`:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SwarmCenterAverage()`:'
- en: What is the center position of the swarm?
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 群体的中心位置在哪里？
- en: 'This is known as cohesion: a swarm member attempting to move towards the center
    of the swarm'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这被称为凝聚力：一个swarm成员试图移动到群体的中心
- en: The core work is undertaken by the `Drone` class. Each drone's `Start(...)`
    method finds and caches a reference to its NavMeshAgent component.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 核心工作由`Drone`类承担。每个无人机的`Start(...)`方法找到并缓存其NavMeshAgent组件的引用。
- en: 'Each drone''s `UpdateVelocity(...)` method takes as input two `Vector3` arguments:
    `swarmCenterAverage` and `swarmMovementAverage`. This method then calculates the
    desired new velocity for this `Drone` by simply adding the two vectors, and then
    uses the result (a `Vector3` location) to update the NavMeshAgent''s target location.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 每个无人机的`UpdateVelocity(...)`方法接受两个`Vector3`参数：`swarmCenterAverage`和`swarmMovementAverage`。然后此方法通过简单地将两个向量相加来计算这个`Drone`所需的新速度，并使用结果（一个`Vector3`位置）来更新NavMeshAgent的目标位置。
- en: Most of the flocking models in modern computing owe much to the work of Craig
    Reynolds in the 1980s. Learn more about Craig and his boids program at [http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)](http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算中的大多数群聚模型都归功于20世纪80年代克雷格·雷诺斯的工作。了解更多关于克雷格和他的boids程序的信息，请访问[http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)](http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics))。
- en: Creating a movable NavMesh Obstacle
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可移动的NavMesh障碍物
- en: Sometimes, we want a moving object to slow down or prevent an AI NavMeshAgent controlled
    character passing through an area of our game. Or, perhaps we want something like
    a door or drawbridge to sometimes permit travel, and not at other times. We can't
    "bake" these objects into the NavMesh at Design-Time, since we want to change
    them during Run-Time.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望移动对象减速或防止AI NavMeshAgent控制的角色穿过游戏中的某个区域。或者，也许我们希望像门或吊桥这样的东西有时允许通行，而有时不允许。我们无法在Design-Time将这些对象“烘焙”到NavMesh中，因为我们希望在Run-Time更改它们。
- en: While computationally more expensive (that is, they slow down your game more
    that static non-navigable objects), NavMesh Obstacles are components that can
    be added to GameObjects, and these components can be enabled and disabled like
    any other component.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在计算上更昂贵（也就是说，它们会减慢你的游戏速度，比静态不可导航的对象更多），但NavMesh障碍物是可以添加到GameObject的组件，并且这些组件可以像任何其他组件一样启用和禁用。
- en: A special property of NavMesh Obstacles is that they can be set to "carve out"
    areas of the NavMesh, causing NavMeshAgents to then recalculate routes that avoid
    these carved out parts of the mesh.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: NavMesh障碍物的一个特殊属性是它们可以被设置为“雕刻”NavMesh的区域，导致NavMeshAgents重新计算避免这些雕刻出的网格部分的路线。
- en: 'In this recipe, you''ll create a player-controlled red Cube, which you can
    move to obstruct an AI NavMeshAgent controlled character. Also, if your cube stays
    in one place for a half-second or longer, it will carve out part of the NavMesh
    around it, and so cause the NavMeshAgent to stop bumping into the obstacle, and
    calculate and follow a path that avoids it:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将创建一个玩家控制的红色立方体，你可以移动它来阻碍 AI NavMeshAgent 控制的角色。此外，如果你的立方体在一个地方停留半秒或更长时间，它将雕刻出其周围的
    NavMesh 的一部分，因此导致 NavMeshAgent 停止撞击障碍物，并计算并遵循一条避开它的路径：
- en: '![](img/78f156e6-4080-48b0-8eb5-8b829f2dbba4.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78f156e6-4080-48b0-8eb5-8b829f2dbba4.png)'
- en: Getting ready
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the first recipe in this chapter, so make a copy of that
    project folder and do your work for this recipe with that copy.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱增加了本章的第一个菜谱，所以请复制那个项目文件夹，并使用该副本来完成这个菜谱的工作。
- en: The required script to control the movement of the red Cube (`PlayerControl.cs`)
    is provided in the `15_08` folder.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 控制红色立方体移动所需的脚本 (`PlayerControl.cs`) 已在 `15_08` 文件夹中提供。
- en: How to do it...
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a movable NavMesh Obstacle, please follow these steps:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可移动的 NavMesh Obstacle，请按照以下步骤操作：
- en: Create a Material in the Project panel, and name it m_green with the Main Color
    tinted green.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个 Material，命名为 m_green，并将主颜色调整为绿色。
- en: Create a red 3D Cube for the player to control, named Cube-player, making it
    red by added Material m_red to it and making it large by setting its scale to
    (3,3,3).
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为玩家控制创建一个红色 3D 立方体，命名为 Cube-player，通过添加 Material m_red 使其变红，并通过将其比例设置为 (3,3,3)
    使其变大。
- en: Add an instance of the provided `PlayerControl` C# script-class as a component
    to this GameObject.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的 `PlayerControl` C# 脚本类的一个实例作为组件添加到这个 GameObject 上。
- en: In the Inspector, add a Navigation | NavMesh Obstacle component to Cube-player and
    check its Carve property.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，向 Cube-player 添加一个 Navigation | NavMesh Obstacle 组件并检查其 Carve 属性。
- en: Run the game. You can move the player-controlled red Cube to get in the way
    of the moving Sphere-arrow GameObject. After the NavMesh Obstacles Time-to-stationary
    time of half a second, if you have Gizmos displayed, you'll see the carving out
    of the NavMesh, so that the area occupied by Cube-player, and a little way around
    it, is removed from the NavMesh, and the Sphere-arrow GameObject will then recalculate
    a new route, avoiding the carved out area where Cube-player is located.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。你可以移动玩家控制的红色立方体来阻碍移动的 Sphere-arrow GameObject。在 NavMesh Obstacles Time-to-stationary
    时间为半秒后，如果你显示了 Gizmos，你会看到 NavMesh 的雕刻，这样 Cube-player 占据的区域以及其周围的一小部分就会被从 NavMesh
    中移除，然后 Sphere-arrow GameObject 将重新计算一条新的路线，避开 Cube-player 所在的雕刻区域。
- en: How it works...
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At Run-Time, the AI NavMeshAgent controlled Sphere-arrow GameObject heads towards
    the destination point, but stops when the player-controlled red Cube is in its
    way. Once the Cube is stationary for 0.5 seconds or more, the NavMesh is carved
    out, so that the AI NavMeshAgent controlled **Sphere-arrow** GameObject no longer
    even attempts to plan a path through the space occupied by the cube, and recalculates
    a new path completely avoiding the obstacle, even if it means back-tracking and
    heading away from the target for part of its path.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，AI NavMeshAgent 控制的 Sphere-arrow GameObject 会朝向目标点移动，但当玩家控制的红色立方体挡在路中间时，它会停止。一旦立方体静止超过
    0.5 秒，NavMesh 就会被雕刻出来，这样 AI NavMeshAgent 控制的 **Sphere-arrow** GameObject 就不再尝试规划通过立方体占据的空间的路径，而是重新计算一条完全避开障碍物的新路径，即使这意味着要回头并偏离目标的一部分路径。
