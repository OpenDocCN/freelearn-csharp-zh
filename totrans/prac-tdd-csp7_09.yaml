- en: Testing JavaScript Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started testing in JavaScript, we will need to create a ReactJS application
    and configure it for testing using the Mocha, Chai, Enzyme, and Sinon libraries.
  prefs: []
  type: TYPE_NORMAL
- en: These steps were discussed in detail in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    up the JavaScript Environment*, so here, we will simply walk through the steps
    and not explain them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals for this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Speaker Meet React application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Talk through our plan of attack for testing the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is our approach?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What parts of the app can we even test?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What part of the app do we start with?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write tests and complete a couple of features for the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speaker listing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Speaker detail
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this chapter is finished, you should be capable of unit-testing any  React-based
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a React app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the application in this book, to maintain compatibility, you will want to
    use Node.js version 8.5.0, NPM version 5.4.2, and create-react-app version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands to install and execute the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All three commands should run successfully. After running `npm test`, you will
    need to exit the test run by hitting `<q>`. After running `npm start`, you will
    need to exit the server by hitting *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Ejecting the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming the previous step went without a hitch, we can proceed to eject the
    React app. Again, as it has already been explained in detail in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    up the JavaScript Environment*, we will only do a short review here.
  prefs: []
  type: TYPE_NORMAL
- en: There is only a single command to eject the application. After ejection, we
    will want to rerun the commands in the previous section to ensure that the application
    still works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to eject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Mocha, Chai, Enzyme, and Sinon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to add the testing facilities that we would like to use for
    this app. As before, the addition of these utilities has been covered in detail
    in a previous chapter. So, we will only be providing the commands to execute and
    the versions of the packages to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands to install the libraries we are going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also a few other libraries we will be using as part of our Redux
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Including the version in the install command will ensure that you are using
    the same version of the libraries that we are and will reduce the number of potential
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the libraries we have just installed, we will also need to install an
    extra preset for babel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Update your babel config in `package.json` to remove react-app and include `react`
    and `es2015`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As described in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    up the JavaScript Environment*, delete the test configuration section from `package.json`.
    Then, update the test script to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And add a test watch script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to update the test execution file `test.js` in the scripts
    folder so it''s compatible with Mocha. Change all the contents of the file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step before we can use our new testing libraries is to update the
    `App.test.js` file to match the conventions used with Mocha and Chai. So, change
    the filename to `App.spec.js` and update the contents to match the code shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, as before, execute the test script and start the application to make sure
    nothing broke during our transformation to Mocha.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All three of those commands should work. If you have an issue, check all the
    steps we have just discussed and look to [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    Up a JavaScript Environment*, for a more detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our testing config has been updated and is working correctly, we can
    begin thinking about test-driving our first feature.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier chapters, we discussed where to start testing and decided that if
    possible an inside-out approach is preferred. To keep with that approach, we want
    to determine the different parts of our React app so that we can target the purest
    business logic we can.
  prefs: []
  type: TYPE_NORMAL
- en: Right off the bat, regardless of any other architectural choices, we can identify
    the React component and a service representing communication with our data source.
    We are planning to use Redux in this app so that makes up the missing piece and
    connects our component with our data.
  prefs: []
  type: TYPE_NORMAL
- en: Which one of these is the business logic though? Out of those base options,
    what would we even test? Let's examine each one a little more closely and see
    what we could test that would be considered a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the React component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, we want to avoid unit-testing third-party libraries. So, let's separate
    the third-party aspects of a React component from the parts that we would potentially
    unit-test.
  prefs: []
  type: TYPE_NORMAL
- en: The third-party aspects include any inherited features and functionality; this
    includes to some degree any life cycle methods and the JSX. So, what's left? The
    answer to this question depends on whether the component in question is a presentational
    component or a container component.
  prefs: []
  type: TYPE_NORMAL
- en: Presentational components are almost pure HTML and view mechanisms. There is
    almost no traditionally unit-testable behavior. Certainly, there is no real business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Container components are where the real action happens in a React application.
    These components can manipulate data and make business decisions that can control
    the flow of the application. So, let's keep container components in the list of
    possible places to start our unit-testing efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Redux testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is a third-party library, that controls data flow throughout the application
    and manages quite a bit of the normal data shuffling that we may want to unit
    test. Because it is third-party though, on the surface there doesn't seem to be
    too much that we can unit test. Let's take a closer look at the aspects of the
    Redux data flow to determine if there really is nothing to test or if we still
    need to unit test parts of Redux.
  prefs: []
  type: TYPE_NORMAL
- en: The store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Redux store is where all the data lives after it has been acquired by the
    application. Typically, there is only one store for each application using Redux.
    The store is almost completely contained within the Redux library and we have
    very few direct interactions with it. For this reason, there doesn't seem to be
    much we would or could test for the store and it falls squarely in the realm of
    third-party code that we must simply trust.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions in Redux represent an event carrying a data packet. The event is usually
    a command to either retrieve or update data within the data source which should
    be reflected by the store. Because actions are just a key with some data attached,
    there doesn't seem to be much to test here.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is anything to test within the Redux interactions, it is likely in
    the reducers. Reducers receive the actions and determine what to do, if anything,
    based on the actions requested and the data provided as part of those actions.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the reducer is going to simply call the API service once the appropriate
    service call is determined. It is possible that a reducer might also map the received
    data into a format that is more appropriate to the service call that must be made.
  prefs: []
  type: TYPE_NORMAL
- en: So, if the reducer is, in all reality, just going to call the service, what
    would we test for the reducer? Other than ensuring that the appropriate service
    method is called with the appropriate data there doesn't seem to be much. For
    completeness, we would want to test those things, but they do not represent the
    core of our business logic.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, it doesn't appear that much is testable in Redux and what is
    testable doesn't represent the core of our business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing an API service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, let's look at the API service. Normally, the service in a front-end
    application behaves much like the repository in a back-end application. The service's
    main function is to abstract data interactions with some data source. Those interactions
    don't necessarily contain any definable business logic. The real logic, if any,
    for a service exists on the server and doesn't need to be tested as part of a
    front-end application. At least it doesn't need to be tested the way you might
    think it does.
  prefs: []
  type: TYPE_NORMAL
- en: So, if the service doesn't contain any business logic, and Redux doesn't contain
    much business logic, and the components don't contain much business logic, what
    do we test and how can it be unit-tested?
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is that we are not off the hook for testing, but we will have
    to jump through some hoops to do any testing because it is difficult to remove
    ourselves from integration testing. In a typical front-end application, unlike
    in C#, there is no clear division between our code and their code. So, we will
    have to make some concessions and write quite a bit of code to abstract parts
    of third-party code to allow us to test what we need to be testing.
  prefs: []
  type: TYPE_NORMAL
- en: So, where does this leave us when it comes to a testing direction?  Unfortunately,
    there doesn't seem to be a clear winner. For the purposes of this application,
    we will work from the data source up so that we have a clear understanding of
    the data manipulations available to us while we write user interface aspects of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Speaker listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the functionality in our C# backend, we will start by testing a listing
    of the speakers available. We are not yet ready to connect to the backend and,
    for any of the tests we will write here as unit tests, we will need to mock the
    behaviors that the backend would normally present.
  prefs: []
  type: TYPE_NORMAL
- en: For the moment, we are not going to concern ourselves with any kind of authentication.
    So, the important functionality we will be looking to implement is that when no
    speakers exist we should let the user know, and when speakers do exist we should
    list them.
  prefs: []
  type: TYPE_NORMAL
- en: The way that we will produce both situations is through a mock API. As strange
    as it may seem, most of our business logic will be in the mock API. Because it
    will be crucial to all of the other tests we will write, we must unit test the
    mock API as if it were production code.
  prefs: []
  type: TYPE_NORMAL
- en: A mock API service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin testing the mock API service, let's create a new services folder and
    add a `mockSpeakerService.spec.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that file, we need to import our assertion library, create our initial
    describe, and write an existence test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Start the npm test script with watch. The test we just wrote should fail. To
    make the test pass, we must create a `MockSpeakerService` object. Let's play devil's
    advocate a little and create an object in this file, but only enough of an object
    to make the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This line passes the currently failing test, but clearly isn't what we are after.
    It does, however, force us to write more robust tests. The next test we can write
    is one that proves that the `MockSpeakerService` can be constructed. This test
    should ensure that we have defined the `MockSpeakerService` as a class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This test fails, stating that `MockSpeakerService` is not a constructor. The
    way to fix this is to change `MockSpeakerService` into a class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a class that can be instantiated, the next test we write can
    start to test actual functionality. So, what functionality are we going to test?
    Looking at the requirements, we can see that the first scenario involves requesting
    all the speakers and receiving no speakers. That's a reasonably simple scenario
    to test. What would we call the function in the `MockSpeakerService` that would
    get all the speakers? Because we are trying to get all the speakers, a simple
    name that would not be redundant and fits the repository pattern we discussed
    in the C# backend is simply `getAll`. Let's create a nested describe and an existence
    test for a `getAll` class method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As per usual, this test should fail and it should fail with `expected undefined
    to exist`. Making this test pass is relatively simple, just add a `getAll` method
    to the `MockSpeakerService` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we need to decide is the result we should expect when there are
    no speakers. Looking back at the backend, we should be receiving an empty array
    when no speakers are present. Looking at the requirements, the system should present
    a `NO_SPEAKERS_AVAILABLE` message. Should the service be responsible for displaying
    that message? In this case, the answer is no. The react component should be responsible
    for displaying the `NO_SPEAKERS_AVAILABLE` message when we get to that portion
    of the code. For now, we should expect, when no speakers exist, to receive an
    empty data set.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are extending the context of the test, let's create another describe
    for that context extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice the syntax we used for this test. We return the promise and make our
    assertions inside the then function. This is because we want our test to operate
    on asynchronous code from our service. The majority of backend operations will
    need to be asynchronous and one convention for dealing with that asynchronicity
    is to use promises. Asynchronous tests, that is, tests dealing with promises,
    in Mocha require that the promise be returned from the test so that Mocha can
    know to wait for the promise to resolve before closing out the test.
  prefs: []
  type: TYPE_NORMAL
- en: And now, to make the test pass, all we need to do is return a promise that resolves
    with an empty array from the `getAll` method. We are going to use a zero delay
    `setTimeout` here which will set us up to implement some kind of delay for development
    purposes later on. The reason we want a delay is so that we can test the operation
    of the UI in the event of a slow network response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the first scenario passing and enough code to warrant a refactoring.
    We are declaring the service variable in multiple places and we don't have a context
    that represents a baseline instantiation of that variable. Let's create a describe
    to wrap all the post instantiation tests and add a `beforeEach` to initialize
    a service variable scoped to that describe and available to all the tests within
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the tests after the refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The next scenario, the speaker listing, is for when speakers do exist. The first
    test for this scenario will need to add at least one speaker to the mock API.
    Let's create a new describe inside `GetAll` but separate from `No Speakers Exist`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have added, as part of the setup for this test, a reference to a `Create`
    method. This method does not yet exist and our test can't pass without it. So,
    we need to temporarily ignore this test and write tests for `Create`. We can ignore
    this test by skipping it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write a new describe block inside the `After Initialization` block
    for `Create`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And to make the test pass we add the `Create` method to the mock service class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We could, from this point, write a few tests to add validation logic to the
    `Create` method. However, we don't currently have any scenarios that reference
    a `Create` method on the API. Since this method exists only for testing purposes,
    we are going to leave it alone with just an exists test. Let's move back to our
    scenario test.
  prefs: []
  type: TYPE_NORMAL
- en: Now that `Create` exists, we should receive the failure that the test is expecting,
    which is that we expected a length of 1 but instead we have a length of 0\. Remove
    skip from the test and verify.
  prefs: []
  type: TYPE_NORMAL
- en: To make this test pass, we essentially have to implement the basic logic for
    create and make a modification to `getAll`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can consider the current tests sufficient to move forward and start testing
    our data flow.
  prefs: []
  type: TYPE_NORMAL
- en: The Get All Speakers action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin testing with Redux, there are a few testing entry points we could start
    with. We could begin by testing actions, reducers, or even interactions with the
    store. The store tests would be more integration tests and we want to concentrate
    on unit tests in this chapter. That leaves actions and reducers. Either is a fine
    place to start, but we will start with actions because they are extremely simple
    and uncomplicated as a concept for testing.
  prefs: []
  type: TYPE_NORMAL
- en: The action that we need right now is one to request the retrieval of speaker
    information; in essence, a get all speakers action. As stated earlier, actions
    can be extremely simple; however, we have an issue in that our get all speakers
    service call is asynchronous. Actions were not really designed to handle asynchronous
    calls. For that reason, let’s start with something a little bit simpler and we
    will come back to this problem after we understand how to test a normal action.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a standard action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need an action to notify Redux that we have the speakers after they
    have been loaded. There is no reason why we can't start there. So, let's write
    a test for the successful retrieval of speakers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Running this test should fail. To make the test pass, define a function named
    `getSpeakersSuccess`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Because of the simplicity of a typical action, our next test will essentially
    test the functionality of the action. We could break this into multiple tests,
    but all we are really doing is asserting on the structure of the data returned.
    Concerning the single assert rule, we are still only asserting one thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To make this test pass, we need to make significant changes to our current implementation
    of the `getSpeakersSuccess` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In Redux, actions have an expected format. They must contain a type property
    and usually contain some data structure. In the case of `getSpeakersSuccess,`
    our type is a constant, `GET_SPEAKERS_SUCCESS`, and the data is an array of speakers
    passed into the action. To make them available to the application, let's move
    the action and the constant into their own files. We need a `speakerActions` file
    and an `actionTypes` file,
  prefs: []
  type: TYPE_NORMAL
- en: '`src/actions/speakerActions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`src/reducers/actionTypes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Add import statements to the test and all the tests should pass. For a typical
    action, this is the format for testing. The placement of the action types in the
    reducers folder is for dependency inversion reasons. From a SOLID standpoint,
    the reducers are defining a contract of interaction, which is represented by the
    action types. The actions are fulfilling that contract.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a thunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because the `getSpeakersSuccess` action is intended to be the resulting action
    of a successful service call, we need a special kind of action to represent the
    service call itself. Redux does not inherently support asynchronous actions, as
    stated before. So, we need some other way to accomplish communication with the
    backend. Thankfully, Redux does support middleware and much middleware has been
    designed to add asynchronous capability to Redux. We are going to use `redux-thunk`
    for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: To start the next test, we need to first import `redux-thunk` and `redux-mock-store`
    to our speaker action tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Then we can test the getting speakers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we start with a test for existence. And, as usual, it is fairly easy
    to make this test pass. In the speaker actions file, add a definition for the
    `getSpeakers` function and export it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The next test is slightly more complicated than the tests we have been working
    on, so we will explain it in rather more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will need to do is configure a mock store and add the thunk
    middleware. We need to do this because to properly test a thunk we will have to
    pretend that Redux is actually running so that we can dispatch our new action
    and retrieve the results. So, let''s add our mock store configuration to the `Async
    Actions` `describe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a store available to us, we are ready to begin writing the
    test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the arrange, we are configuring a bare minimum speaker. Then, we call the
    action we previously tested to build the proper data structure. Finally, we define
    a mock store and its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, when testing asynchronously in Mocha, we can return a promise and Mocha
    will automatically know that test is asynchronous. Our assertions, for asynchronous
    tests, go in the resolve or the reject function of the promise. In the case of
    the get speaker action, we are going to assume a successful server interaction
    and test the resolved promise.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are not returning anything from our `getSpeakers` action, the `mockStore`
    throws an error stating that the action may not be an undefined. To move the test
    forward, we must return something. To move in the direction of using a `thunk`,
    we need to return a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Adding the return of a function that does nothing else moves the test failure
    message forward and now presents us with a failure to read the property `then`
    of undefined. So, now we need to return a promise from our action. We already
    have the service endpoint built in the mock API service, so let's call that now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now the test passes and we have written our first test dealing with thunks.
    As you can see, both the test and the code to pass the test are fairly easy to
    write.
  prefs: []
  type: TYPE_NORMAL
- en: The Get All Speakers reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have tested the actions related to getting all the speakers, it's
    time to move on to testing the reducers. As usual, let's begin with an exists
    test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To make this test pass, all we need to do is define a function named `speakersReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our next test will check the functionality of the reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This test is larger than we normally prefer, so let's walk through it. In the
    arrange, we configure the initial state and create an action result consisting
    of an array of a single speaker. When a reducer is called, the previous state
    of the application and the result of an action are passed to it. In this case,
    we start with an empty array and the modification is the addition of a single
    speaker.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the *Act* section of the test, we call the reducer passing in the `initialState`
    and the result of our action call. The reducer returns a new state for us to use
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the assert, we expect that the new state consists of a single speaker
    and that the speaker has the same data as the speaker we created for the action.
  prefs: []
  type: TYPE_NORMAL
- en: To make the test pass we need to handle the action being passed into the reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Because, in an application using Redux, reducers are called for every action,
    we need to determine what to do for any action that is not the action we want
    to handle. The proper response in those cases is to simply return the state with
    no modification.
  prefs: []
  type: TYPE_NORMAL
- en: For the action type that we do want to handle, in this case we are returning
    the actions speakers array. In other reducers, we might combine the initial state
    with the actions result, but for get speakers success we want to replace the state
    with the value we receive.
  prefs: []
  type: TYPE_NORMAL
- en: The last step, now that all our tests are passing, is to extract the speaker
    reducer from the test file and move it to `speakerReducer.js`
  prefs: []
  type: TYPE_NORMAL
- en: The Speaker listing component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another piece of the application that we can test is the components. There are
    two types of component in a typical React + Redux application. We have container
    and presentational components.
  prefs: []
  type: TYPE_NORMAL
- en: Container components don't typically hold any real HTML in them. The render
    function for a container component simply references a single presentational component.
  prefs: []
  type: TYPE_NORMAL
- en: Presentational components don't typically have any business logic in them. They
    receive properties and display those properties.
  prefs: []
  type: TYPE_NORMAL
- en: In our journey from the back-end to the front-end, we have been covering the
    retrieval and updating of data. Next, let's look at the container component that
    will use this data.
  prefs: []
  type: TYPE_NORMAL
- en: Our container component is going to be a simple one. Let's start with the typical
    existence test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Simple and straightforward; now to make it pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next is the render function of the component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This test introduces some new concepts. Starting at the act portion of the test.
    We are using Enzyme's shallow render. A shallow render will render the React component
    but not the component's children. In this case, we are expecting that a `SpeakerList`
    component exists and that this component is rendering it. The Enzyme adapter configuration
    is shown here, but it can also be moved to `test.js` after the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: We are also checking the props to make sure we pass the speakers into the presentational
    component. To make this test pass, we must make modifications to the `SpeakersPage`
    component, but we must also create a `SpeakerList` component. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: And then in a new file, we need to add the `SpeakerList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that our container component doesn't have any logic. In
    fact, all it does is render the `SpeakerList` component. If that is all it does,
    why is it a container component? The reason is that this component is going to
    be a Redux-connected component. We want to keep the Redux code in our business
    logic and out of our display components. So, we are treating this as a higher
    order component and just using it to pass data through to the presentational components.
    Later, when we get to the speaker detail component you will see a container component
    with a little business logic.
  prefs: []
  type: TYPE_NORMAL
- en: For now, our `SpeakerList` component looks a little anemic and doesn't really
    work as part of a React Redux app. Time to test our presentational components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Because of the last test, this test will automatically pass. Normally we would
    not write this test if we followed to progression what we just did. In reality,
    what we should have done is ignore the previous test, create this test, and then
    create the `SpeakerList` component. After which, we could have re-enabled the
    previous test and gotten it to pass.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to test that a message of no speakers available is rendered
    when the speakers array is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: For this test, we created a helper function to initialize the component with
    the props that we need. To make the test pass we just need to return a `div` with
    the correct text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: While we are only testing for the `no-speakers` `div`, we can have decoration
    that we decide not to test. In this case, we want a header on the page. Our tests
    should pass regardless.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we are ready to test for when speakers do exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we check for two things. We want the correct number of speaker
    rows to display and we want them to be rendered by a new `SpeakerListRow` component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The component code has changed significantly because of our latest test. We
    had to add some logic, and we also added a default error case if somehow the content
    were to make it through without being assigned.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more component to make the code work correctly for this section.
    We are not going to test that component in this book, though. The component has
    no logic inside it and is left as an exercise to you to create.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create that component, it would be nice if the application ran.
    Right now, we have not wired up Redux so the application won't render anything.
    Let's walk through the configuration we are using for Redux now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `index.js`, we need to add a few items to let Redux work. Your index
    should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The two parts that we have added are the Redux store including an initial call
    to dispatch the load speakers action, and markup to add the Redux provider.
  prefs: []
  type: TYPE_NORMAL
- en: Where your other routes are defined, you will need to add routes for the speaker
    section. We are placing the Routes in `App.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we have to convert our component to a Redux component. Add the following
    lines to the bottom of your speaker's page component file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Starting at the bottom of the code sample, the connect function is provided
    by Redux and will wire up all the Redux functionality into our component. The
    two functions passed in, `mapStateToProps` and `mapDispatchToProps`, are passed
    in as a way to populate state and provide actions for our component to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `mapDispatchToProps` we are calling `bindActionCreators`; this is another
    Redux-provided function and will give us an object containing all the actions.
    By returning that object directly from `mapDispatchToProps,` we are adding the
    actions directly to props. We could also create our own object containing an actions
    property and then assign the result of the `bindActionCreators` to that property.
  prefs: []
  type: TYPE_NORMAL
- en: Anywhere inside the application that references `SpeakersPage` can now be changed
    to just `SpeakersPage`, which will grab our new default export. Do not make this
    change in the tests. Inside the tests we still want the named import.
  prefs: []
  type: TYPE_NORMAL
- en: With those things done, we should be able to run the application and navigate
    to the speakers route. If you have not added a link to the speakers route, now
    would be a good time so that you don't have to type the route directly in the
    URL every time.
  prefs: []
  type: TYPE_NORMAL
- en: Once you arrive at the speakers route, you should see that there are no speakers
    and we receive our message. We need some way to populate the speakers so that
    we can test the listing. We will cover a way to populate speakers in the next
    section. For now, in the mock API modify the constructor to contain a couple of
    speakers. Modifying the service in this way will cause a few tests to break, so
    after you have visually verified that everything is looking good, be sure to remove
    or at least comment out the code you added.
  prefs: []
  type: TYPE_NORMAL
- en: Speaker detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our speakers listing nicely, it would be nice to be able to
    view a bit more information about a specific speaker. Let's look at the tests
    involved in retrieving and viewing a speakers-detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to the mock API Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the mock API, we need to add a call to get the details for a specific speaker.
    We can assume that the speaker has an ID field that we can use to gather that
    information. As usual, let's start our tests with a simple exists check. We will
    need to add a new describe inside the `After Initialization` describe for getting
    a speaker by ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: To make this test pass, we need to add a method to the mock API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write a test to verify the functionality we expect when a matching
    speaker cannot be found. The functionality we want in this case is for a `SPEAKER_NOT_FOUND`
    message to be shown once we get to the user interface. At the mock API level,
    we could assume that a 404 will be sent from the server. We can respond from the
    mock API with an error containing the `SPEAKER_NOT_FOUND` type. This is similar
    to the way an action would be used.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create another describe for our speaker not found scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that we snuck in `errorTypes`. The `errorTypes` are in
    their own folder, but build exactly like `actionTypes`.
  prefs: []
  type: TYPE_NORMAL
- en: To make this test pass, we must add a rejected promise to our mock API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We don't have any tests that enforce a positive result from this method, so
    we can reject every time for now.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to our next test. What happens if the speaker is found? Ideally,
    the speaker and all the speakers details would be delivered back to the caller.
    Let's write that test now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: To pass this test we will have to add some logic to the production code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To make the test pass, we need to first check to see if the speaker exists.
    If the speaker does exist, we return that speaker. If the speaker does not exist,
    we reject the promise and provide our error result.
  prefs: []
  type: TYPE_NORMAL
- en: The Get Speaker action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a mock API to call that behaves the way we want it to. Next on our
    list is creating the actions that will handle the results from our mock API. For
    the process of getting a speaker, we will need two actions. One of the actions
    will notify the application about a successful find and provide the found speaker
    to the reducers. The other action will notify the application about the failure
    to find the requested speaker.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a test to confirm its existence. This test should be inside the
    synchronous tests section of the speaker actions tests. We will also want to create
    a new describe for the get speaker success action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To make this test pass, we just create the action function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to verify the return value of the action. Just like our get all
    speakers success action, the get speaker success action will receive the found
    speaker and return an object containing a type and the speaker data. Let's write
    the test for that now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This test is fairly straightforward so let's look at the production code to
    pass it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Again, this code is straightforward. Next, let's handle the failure action.
    We will need to create a new describe for this test as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Nothing new here, you should be starting to get a feel for the flow by now.
    Let's keep going and make this test pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The data we should be getting back for a failure to retrieve a speaker should
    be the `SPEAKER_NOT_FOUND` error type. In our next test, we will receive that
    error and create the action type from it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Making this test pass is very similar to the implementation for the other synchronous
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the code, there is one important difference. This code doesn't have
    speaker data. The reason is because this action will need to be handled by a different
    reducer, an error reducer. We will create the error reducer and error component
    shortly. But first, we need to create the asynchronous action that will make the
    call to the mock API.
  prefs: []
  type: TYPE_NORMAL
- en: In testing the asynchronous action to get speakers, we should start with the
    failure case. In this case, the failure case is `GET_SPEAKER_FAILURE`. Here is
    a test to ensure the correct secondary action is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The code to make this test pass is similar to the code we have for getting all
    the speakers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have called the mock API and we expect it to reject the promise, resulting
    in the dispatching of the `getSpeakerFailure` action.
  prefs: []
  type: TYPE_NORMAL
- en: Our next test is the successful retrieval of a specific speaker. We do have
    a problem though. You may have noticed that we are creating a new `MockSpeakerService`
    for each asynchronous action. This is problematic because it prevents us from
    pre-populating our mock API with values for the test. Later in the development
    of this application, the back-end will be ready and we will want to point our
    front-end code to a real back-end. We can't do that as long as we are directly
    referencing and creating a mock API service.
  prefs: []
  type: TYPE_NORMAL
- en: There are many solutions for the problem that we are facing. We will explore
    making a factory to decide what back-end to provide for us. A factory will also
    allow us to treat the mock API as a singleton. Treating the service as a singleton
    will allow us to prepopulate the service as part of the test setup.
  prefs: []
  type: TYPE_NORMAL
- en: In the services folder, let's create a new set of tests for creating the factory
    class and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: All we need to make this test pass is a class definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now we want a method to create a speaker service. Add a new describe to the
    factory tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Notice the way we are using the factory, we are not initializing it. We want
    the factory to be a class with static methods. Having static functions will give
    us the singleton ability we want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we want to ensure that the `createSpeakerService` factory method will
    provide us with an instance of the mock API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Making this test pass is easy, just return a new mock speaker service from the
    factory method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This isn't a singleton though. So, we still have some more work to do here.
    Let's write one more test in the factory before we swap out all the service calls
    in the application for factory calls. To verify that something is a singleton,
    we have to make sure it is the same throughout the application. We can do that
    by doing reference comparisons on successive calls. Another option is to create
    the speaker service, add a speaker to it, create a new speaker service, and try
    to pull the speaker from the second service. If we have done things correctly,
    the second option is the most thorough. We will do the first option here, but
    it would be a good exercise to do the second option on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: To pass the test, we must ensure that the same instance of the speaker service
    is returned every time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The factory will now return the current value or create a new speaker service
    if the current value is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to go to each place where we are directly instantiating a mock
    speaker service and swap it out with a factory call. We will leave that as an
    exercise for you to do, but know that going forward we will assume that it has
    been done.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the factory swapped out and it is generating a singleton, we
    can write the next action test. We want to test a successful retrieval of a speaker.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot going on in this test; let's walk through it. First in the arrange,
    we create a speaker object to be placed in the service, and used for the assertions.
    Next, still in the arrange, we create and configure the mock store. Lastly, in
    the arrange, we create the speaker service and we create our test speaker using
    the service.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the act, we dispatch a call to get the test speaker. Remember, this
    call is asynchronous. So, we must subscribe to then.
  prefs: []
  type: TYPE_NORMAL
- en: When the promise is resolved, we store the actions in a variable and assert
    that the first action has the correct type and payload.
  prefs: []
  type: TYPE_NORMAL
- en: Now to make this test pass we need to make some modifications to the `getById`
    method on the service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: All we have really done here is add a then to handle the resolving of the promise.
    We now have, for all current intents and purposes, a working speaker service.
    Let's move on to creating the reducers for handling the get speaker actions.
  prefs: []
  type: TYPE_NORMAL
- en: The Get Speaker reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle the actions related to getting a speaker, we must create two reducers.
    The first reducer is extremely similar to the reducer we made for the get speakers
    actions. The second is going to need to be slightly different and is for handling
    the error case.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the simplest of the two and create the speaker reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Our typical existence test is easily passed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The next test ensures that the reducer updates state properly, and will close
    out the tests needed for this reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The changes from this test are the inputs to the reducer, and the output of
    a state. Let's make this test pass by modeling our reducer after the speakers
    reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the speakers reducer, this reducer simply checks the action type
    for `GET_SPEAKER_SUCCESS` and, if found, returns the speaker attached to the action
    as the new state. Otherwise, we just return the state object we received.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we need an error reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Passing this test is just as easy as all the other existence tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The error reducer will have some interesting functionality. In the event that
    an error is received, we want multiple errors to stack up so we won't be replacing
    the state. Instead, we will be cloning and adding to the state. However, when
    an action is received that is not an error we will want to clear the errors and
    allow normal program execution to continue. We will also want to ignore duplicate
    errors. First, we will handle the error we know about.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Our test is slightly different from the previous reducer test. The main difference
    is that we are wrapping our expected value in an array. We are doing this to meet
    the need for having multiple errors potentially stack up and display for the user.
  prefs: []
  type: TYPE_NORMAL
- en: To make this test pass we follow the familiar reducer pattern we have been using.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: For the same reasons as stated previously, notice how we use the rest of the
    parameter syntax to spread the existing state into a new array, effectively cloning
    state.
  prefs: []
  type: TYPE_NORMAL
- en: We have two more tests for the error reducer; the first is to ensure duplicate
    errors are not added. The second test will be to clear the errors when a non-error
    action is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In the test, to set the condition of having a prepopulated state, all we had
    to do was modify the `initialState` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: All we must do to make this test pass is make sure that the error type is not
    already present in the state array. There are many ways to do this; we have chosen
    to use the `every` function as a check that none of the existing errors match.
    It is likely that this method is not extremely performant, but there should only
    be a couple errors at most so it shouldn't be a performance issue.
  prefs: []
  type: TYPE_NORMAL
- en: The next test is to clear the error state when a non-error is received.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Making this test pass is exceedingly simple. All we have to do is replace the
    default functionality where the existing state is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The Speaker Detail component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to create our `SpeakerDetailPage`. There isn't much to this
    component. It will need to be another container component so that it can use the
    get speaker action. Because it is a container component, we will not be placing
    any markup directly into this component. The good news for us is that it means
    our tests will be short and simple.
  prefs: []
  type: TYPE_NORMAL
- en: To get the tests started, create an existence test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Create a `SpeakerDetailPage` file and add a component to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we want to test, the only other thing we can test without directly
    specifying the design, is that the model is received and somehow makes it to the
    screen. We only need to test one property of the model for now. We will write
    a test that shows that the first name of the speaker is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: If you are paying attention, you might have wondered why the get speaker action
    is just returning an empty resolved promise. We are not attached to Redux, so
    kicking off the action doesn't trigger a reducer, which doesn't update the store
    and doesn't trigger a refresh of the component state. We still want to complete
    the contract of the component in the test setup though and this component will
    call that function. We could leave this line out, but we will be adding it back
    as soon as we wire up Redux.
  prefs: []
  type: TYPE_NORMAL
- en: To make the test pass, we will need to make a couple of simple changes in the
    `SpeakerDetailPage` component, and create a whole new component. Following are
    the changes to this component, but it will be an exercise for you to create the
    next component. It is only for display and we are testing that it gets populated
    here so all you have to do is write the presentational component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will make the test pass, but now we have to connect the component
    to Redux. We will be adding a call to the `getSpeaker` action, binding to the
    `componentWillReceiveProps` life cycle event, and mapping props and dispatch using
    the connect function. Here is the final `SpeakerDetailPage` component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now that everything passes the tests, we have one last thing we need to do before
    we can properly develop further. Earlier we replaced the mock API with a call
    to a factory. We did this so that the tests could affect the state of the mock
    API in the actions. That same modification has made it possible to configure a
    starting point for our application. In the `index.js` file, add the following
    code after the store has been configured; now, when you run the app, you will
    have speakers available to test the UI with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That does it for unit-testing a React application, for now. We still don't have
    an example of testing some kind of input. Try to test and implement a `CreateSpeakerPage`.
    What would you need to do from a React standpoint? What would Redux cause you
    to do? In this chapter, we have attacked the React components as if they were
    components. For display-only components, which is what these have been, this approach
    is probably better. However, for a component with some real functionality you
    might want to try testing the functionality as a plain old JavaScript class before
    even attaching it to React. We also left quite a bit of work for you to do in
    this chapter. Don't be shy about looking at the source related to this chapter
    if you get lost or need a hint while you are filling in the blanks to complete
    the code.
  prefs: []
  type: TYPE_NORMAL
