- en: '*Chapter 7*: Creating a Game Loop and Mock Test'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we moved from the `testLevel` scene (where we controlled
    the player ship) to a `shop` scene (buying and calibrating the player's ship).
    In this chapter, we will be following a similar trend of stretching out to the
    rest of the other game scenes in our `Scene` folder (found in the `Assets` folder).
  prefs: []
  type: TYPE_NORMAL
- en: As part of scene management, all games we play have something called a "Game
    Loop" – if you're not familiar with the term, it basically means our game will
    have alternative routes to take. Each route will load a particular scene. We will
    need to cater for either outcome at each stage of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, all game loops will loop back to somewhere near the beginning.
    The following image shows what our game loop will look like by the end of this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Killer Wave''s Game Loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Killer Wave's Game Loop
  prefs: []
  type: TYPE_NORMAL
- en: Referring to the game loop image still, each name in its rectangular box represents
    a scene in Unity that we have in our `Scene` folder inside the **Project** window.
    The flow of each scene goes in one overall direction, starting at the top with
    **BOOTUP**. This is when the game is launched for the first time. The flow will
    fall through each scene until the player beats all three levels or dies. Either
    way, they will eventually reach the **GAMEOVER** scene, which will then loop back
    up to the **TITLE** scene to create a loop.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be in the position to run our game from
    the `bootUp` scene, where it will automatically move onto the `title` scene. From
    there, the player will press the fire button or tap the screen to then load up
    the `shop` scene, which is where purchases can be made.
  prefs: []
  type: TYPE_NORMAL
- en: Once the player presses the `shop` scene, the first level (`level1`) will start.
    If the player dies, the level will restart, whereas if the player completes the
    level, they will move onto the next level.
  prefs: []
  type: TYPE_NORMAL
- en: The final outcome from all of this will be that if the player dies three times,
    they will be taken back to the `title` scene, whereas if the player completes
    the `level3` scene, then the game will be over, and the player will be taken to
    the `gameOver` scene.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will cover a few mock test questions related to what we have covered
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning our player ship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding our `ScenesManager` script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing to loop our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core exam skills covered in this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the core exam skills that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Programming core interactions:*'
  prefs: []
  type: TYPE_NORMAL
- en: Implement and configure game object behavior and physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement and configure camera views and movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working in the art pipeline:*'
  prefs: []
  type: TYPE_NORMAL
- en: Understand materials, textures, and shaders, and write scripts that interact
    with Unity's rendering API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand 2D and 3D animation, and write scripts that interact with Unity's
    animation API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Programming for scene and environment design:*'
  prefs: []
  type: TYPE_NORMAL
- en: Identify methods for implementing Game Object instantiation, destruction, and
    management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize techniques for structuring scripts for modularity, readability, and
    reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_07](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_07).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: All the content for this chapter is held in this chapter's `unitypackage` file,
    including a `Complete` folder that holds all of the work we'll carry out in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/37Rie3B](https://bit.ly/37Rie3B).'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning our player ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our levels can only be completed when the player dies, causing the
    level to restart, or when the player loses all three lives. Only then are we taken
    to the game over screen. We now need to start thinking of how a player starts
    and ends a level. Currently, the player just appears at the start of a level.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to write some code that animates our player into
    the scene and, when the level completes, we will have the player ship exit the
    camera view.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's make a script the same way we did all the other scripts ([*Chapter
    2*](B18381_02_Epub.xhtml#_idTextAnchor048)*, Adding and Manipulating Objects*,
    if you need a reference). Name the script `PlayerTransition` and make sure we
    have the file in our `Script` folder in the Unity Editor **Project** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to attach the `PlayerTransition` script to our `player_ship` prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: Load up the `testLevel` scene from `Assets/Scene` in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, navigate to the `Assets/Prefab/Player` folder, and select the `player_ship`
    prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, drag and drop the `PlayerTransition` script into an empty area of the
    `player_ship` `PlayerTransition` component in the `PlayerTransition` component
    will start animating `player_ship` in the `shop` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that our script has been created and attached, we can go into it and start
    setting up the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding variables to our `PlayerTransition` script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding methods/functions to our `PlayerTransition` script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `if` statement checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding content to `PlayerMovement IEnumerator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the player ship out of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Adding variables to our PlayerTransition script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to make a start by setting up our `PlayerTransition`
    script. We'll do this by adding global variables so that these can be used to
    position the player ship.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start adding our global variables, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our newly created `PlayerTransition` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the script, make sure we have the following libraries added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, our script should be automatically named along with its default
    inherit `MonoBehaviour` as it's a requirement regarding the Unity Editor and other
    functionalities. The `System.Collections` library will be used for our `StartCoroutine`.
    Without this library, we can't create coroutines; we will explain more about this
    when we come to coding it in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check/enter the following code for our `PlayerTransition` script, which holds
    the script''s default name and `MonoBeaviour` inheritance for added functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `PlayerTransition` class, enter the following global `Vector3` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `startPos` and `readyPos` variables are used to measure the distance from
    where our player ship is and where we want it to travel to.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: At this point, be sure that the `_Player` game object's **Transform Position**
    property values are set to zero on its X, Y, and Z axes in the **Inspector** window.
    Otherwise, the player ship may animate into the wrong position when entering the
    level.
  prefs: []
  type: TYPE_NORMAL
- en: The `transitionToEnd` variables will be used as the coordinates where we want
    our player game object ship to travel to at the start of the level, as well as
    when the player's ship is about to leave a level. `transitionToCompleteGame` is
    only used when the player completes the third and final level and is used to alter
    the player's ending animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue entering the following `float` variables in our `PlayerTransition`
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`distCovered` will hold time data that will be used later to measure between
    two `Vector3` points (we will talk about this in more detail when we make `PlayerMovement`
    `IEnumerator`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`journeyLength` will hold the distance between the two `Vector3` points mentioned
    previously (`startPos` and `readyPos`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final set of variables are the bools to be added to our `PlayerTransition`
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`levelStarted` is the only `bool` set to `true` as it confirms that the level
    has started and will only be set to `false` after the transition of the player''s
    animation has finished. `speedOff` will be set to `true` when we want the player''s
    ship to leave the level.'
  prefs: []
  type: TYPE_NORMAL
- en: '`levelEnds` is set to `true` when the level has come to the end and the player
    ship will then move to its exit position. The last `bool` is for when the whole
    game has been completed. This is used to change the ending animation. The two
    properties are used for accessing the `levelEnds` and `gameCompleted` variables
    from outside of the script.'
  prefs: []
  type: TYPE_NORMAL
- en: That's our variables added to our script. Now, let's continue to the `PlayerTransition`
    methods and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods/functions to our PlayerTransition script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we continue through our `PlayerTransition` script, we will add Unity''s
    `Start` function and create our own `Distance` method to position the player''s
    ship in the correct location:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the `Start` function, continue entering the following code for
    our `PlayerTransition` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Start` function gets called as soon as this script is enabled. In this
    function, we will reset the position of the player's ship to its parent game object,
    which is the `PlayerSpawner` game object.
  prefs: []
  type: TYPE_NORMAL
- en: We will then assign the player ship's beginning world space position to one
    of the vectors we created earlier in this section (`startPos`). We will use this
    in the `Distance` method, which we will talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `Distance` method and its content in the `PlayerTransition` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Vector3.Distance` is a ready-made Unity function that will measure the distance
    between two vector points and gives the answer in the form of a `float` that we
    will be storing in `journeyLength`. The reason for this is that we will want to
    know the length between where our player ship is and where it needs to go (which
    we''ll cover later in this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will move into Unity's `Update` function, where we will
    check for when the level has ended so that we can exit (move) our player ship
    out of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding if statement checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to make use of Unity's frame update function,
    `Update`, so that we can run checks to see what state our game is at within the
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our `Update` function, we will have three `if` statements. `levelStarted`
    is from one of the `bool` variables that we introduced earlier on in this section,
    which is already set to `true`. So, this `if` statement is going to be called
    instantly. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by entering the first `if` statement in the `PlayerTransition`
    script''s `Update` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the first `if` statement is a method called `PlayerMovement`, which also
    takes two parameters. With regards to what this method does, we will review its
    content after we have covered the entirety of the `Update` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's continue with the second `if` statement in the `Update` function.
  prefs: []
  type: TYPE_NORMAL
- en: This `if` statement checks to see if the `levelEnds` variable is `true`, which,
    as you may recall, we set to `false` by default. This `bool` is accessed outside
    of the `PlayerTransition` class, which we will cover later, but for now, all we
    need to know is that it becomes `true` at the end of a level.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `if` statement, there are several lines that prepare our player's
    ship to begin the end of the level, starting with disabling the `Player` script
    by setting its `enabled` bool setting to `false`. This will knock out the player's
    controls so that we can animate the player ship into position for the end of the
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we disable the player ship's `SphereCollider` so that if an enemy or one
    of its bullets comes into contact with the player's ship, it won't destroy the
    ship while it's preparing to end the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the second following `if` statement inside the `PlayerTransition` `Update`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we measure the distance between where the player's ship was at the start
    of the level and where it needs to go with the `Distance` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, within the `if` statement, we have the same method that we mentioned
    earlier, with the only difference being that the argument value is set to `200`.
    These values will be explained after the fourth `if` statement for this `Update`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re still within the `Update` function, we can enter the `if` statement
    that covers when the player completes the third and final level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the `gameCompleted` `bool` is `true`, we fall into the `if` statements condition.
    Inside, we turn off the `Player` script to disable the player's controls. The
    second line disables the player's collider to avoid any collisions with any enemy-related
    game objects, while the third line makes the player ship translate from its current
    position to the value of `transitionToCompleteGame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the fourth `if` statement in our `PlayerTransition` `Update` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the fourth `if` statement, we run a check to see if the `speedOff` `bool`
    holds the value of `true`. If it does, we run Unity's own `Invoke` function, which
    delays the execution of the `SpeedOff` method with a 1-second delay.
  prefs: []
  type: TYPE_NORMAL
- en: Further Information
  prefs: []
  type: TYPE_NORMAL
- en: 'More about `Invoke` can be found on the Unity Scripting reference site: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will write some code so that the player is moved from
    where they are to where they need to be. The two cases where this will need to
    be achieved are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the player starts the game, we animate them into the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player has completed the level, they need to move into a position to
    leave the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be covering two new Unity functions (`Mathf.Round` and `Vector3.Lerp`).
  prefs: []
  type: TYPE_NORMAL
- en: Adding content to the PlayerMovement method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PlayerMovement` method holds the responsibility of animating our player
    ship in the near center of the screen so that it can begin and also exit the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go into more detail to fully understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code for our `PlayerMovement` method, along with its two
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As mentioned previously, our `PlayerMovement` takes two parameters: a `Vector3`
    with the reference name `point` and a `float` with the reference name `transitionSpeed`.
    As you can imagine, `transitionSpeed` is the speed of the player ship moving from
    one point to another.'
  prefs: []
  type: TYPE_NORMAL
- en: If we trace back to what the value of `point` is, it's coming from a variable
    that we've already initialized, `transitionToStart`, with a `Vector3` at the beginning
    of this script with a value of `(-100,0,0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, effectively, `transitionToStart` and `point` are the same – they''re just
    different in terms of their names, for the sake of keeping their references separate.
    Anyway, coming back to `point`, this value is for our player''s ship position.
    The following screenshot shows our player ship with `-100,0,0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Player Ship''s position'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Player Ship's position
  prefs: []
  type: TYPE_NORMAL
- en: So, when a level begins, our player ship will be on the far left, outside of
    the screen, and animate into the position we have marked in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Carrying on with the `PlayerMovement` method, we begin with an `if` statement
    that checks when a series of conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following `if` statement, along with its four conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous code, we''ve run a check on four occasions to see if the player
    is in the correct position before executing the rest of the code. Each line of
    code checks the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the player ship's X position is more than or equal to the value that is stored
    in `readyPos` variable's X position, minus 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player ship's X position is less than or equal to the value that is stored
    in `readyPos` variable's X position, plus 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player ship's Y position is more than or equal to the value that is stored
    in `readyPos` variable's Y position, minus 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player ship's Y position is less than or equal to the value that is stored
    in `readyPos` variable's Y position, plus 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Still within our `PlayerMovement` method and within the previous `if` statement,
    enter the following two `if` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous code block, we have two `if` statements (`levelEnds` and `levelStarted`)
    that check that each of the `bool` conditions are `true`. Let''s go through both
    of their content:'
  prefs: []
  type: TYPE_NORMAL
- en: '`levelEnds`: `if` `levelEnds` becomes `true`, we apply `false` to the `levelEnds`
    `bool` and apply `true` to the `speedOff` `bool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`levelStarted`: `if` `levelStarted` is given the value `true`, we apply false
    to the `levelStarted` `bool`, set the `distCovered` `float` to `0`, and we set
    the `Player` script to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, in our `PlayerMovement` method, enter the following `else` condition
    that sits outside the main `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Referring to the `else` condition code block, we add time and multiply it by
    `transitionSpeed`, which, as you may recall, is one of the two arguments this
    method takes. Make sure this else statement is relating to the Mathf.Round if
    statement and not the two bool checking if statements.
  prefs: []
  type: TYPE_NORMAL
- en: We then divide the `distCovered` variable by the `journeyLength` variable, which,
    as you may recall, is a measurement between two points. We store the division
    in a `float` variable called `fractionOfJourney`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we do in this `else` condition is use one of Unity''s pre-made
    functions called `Lerp`, which linearly interpolates our player''s ship between
    two points. `Lerp` takes three arguments: point A, point B, and the time scale
    it''s going to move between these two points. `transform.position` is our player''s
    ship, the second is the `Vector3` point, which is the other variable we brought
    into `IEnumerator`, and the third is the active `float` `fractionOfJourney`.'
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to `Lerp` colors over time with `Material.Lerp`.For more
    information about changing one color into another, check out [https://docs.unity3d.com/ScriptReference/Material.Lerp.html](https://docs.unity3d.com/ScriptReference/Material.Lerp.html).
  prefs: []
  type: TYPE_NORMAL
- en: We now need to add a single line of code in the `PlayerSpawner` script to turn
    the `PlayerTransition` script on after the player leaves the shop scene. As mentioned
    earlier in the chapter, if the `PlayerTransition` was left on in the shop scene,
    the `player_ship` would animate across the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to turn on the `PlayerTransition` script at the start of the `level1` scene,
    we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Script` and open the `PlayerSpawner` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll down to the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following line of code just after it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line of code will make our player ship animate into the `level1` scene.
  prefs: []
  type: TYPE_NORMAL
- en: The last change we need to make in the `PlayerSpawner` script is to remove the
    ability to enable the `Player` script in the `PlayerSpawner Start` function, we
    will enable this in the `ScenesManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PlayerSpawner` script, remove the following line in the `Start` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the `PlayerSpawner` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's move onto the last bit of code, where we'll be moving our player
    ship out of the screen at the end of the level.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the player ship out of the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last method we need to cover in the `PlayerTransition` script is the `SpeedOff`
    method. This method simply makes our player''s ship jet off, out of the screen,
    when the level is completed. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in our `PlayerTransition` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code block uses Unity's pre-made `Translate` function, which takes a `Vector3.left`
    multiplied by time, with `800` being used to make the player ship move a little
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That is the end of the `PlayerTransition` script. Now, our game has an introduction
    and an ending for our player ship. Originally, our player would just be present
    at the start of the level and when it was classed as being completed, the next
    level would load. We also technically covered three new functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vector3.Distance`, which measures between two `Vector3` points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vector3.Lerp`, which moves the player ship, smoothing between two `Vector3`
    points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MathF.Round`, which rounds off a number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We combined these new skills to make our player ship move into position to start
    the level and, when completed, no matter where the player was on the screen, we
    moved them into position. Finally, our player zooms off the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to revisit the `ScenesManager` script and
    apply some code so that there's a time limit, counting down to when the level
    is over.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding our ScenesManager script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to make our `ScenesManager` script recognize levels
    2 and 3 from our `scenes` folder (`Assets/Scene`). We will then add these levels
    to the game loop. Also, we will be adding a game timer for each level. When the
    timer reaches its limit, we can then trigger the player leaving the level with
    an animation that will play out. Lastly, we will add a few common methods to move
    the game onto the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by opening the `ScenesManager` script (`Assets/Script/Scenesmanager.cs`)
    and adding some variables to assist with what we were talking about. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `ScenesManager` script, add the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `gameTimer` variable timer will be used as our current counter to time how
    long the level has left until it is over. The following variable is an array that
    holds the time until each level ends. So, we have three levels in total, but the
    question is, how long do we want each level to last? We need to enter a value
    that represents the seconds until the level ends, so I've chosen `30` seconds
    for levels 1 and 2\. Level 3, however, will last 45 seconds. This is because we
    will be building a special level in , *NavMesh, Timeline, and a Mock Test*. We
    will go into more detail about this when we reach that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, `currentSceneNumber` will hold the number that denotes which
    scene our player is currently on. Lastly, we have the `gameEnding` bool, which
    will be used to trigger the end of the level animation for the player's ship.
    We will cover these variables in more detail later in this section, let's start
    with `currentSceneNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: Following on from the global variables we just set, let's make sure that the
    `ScenesManager` script is always aware of what scene our player is on during the
    game. This will help our code know which scene the player is on and what scene
    they will be going to next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Update` function, which will be called on every frame to check which
    scene we are at. Do this by entering the following code in the `ScenesManager`
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `Update` function, we use an `if` condition to check if the `currentSceneNumber`
    variable is not equal to the `buildIndex` we are grabbing from the active scene
    we are in.
  prefs: []
  type: TYPE_NORMAL
- en: If it is not equal, we update `currentSceneNumber` with the current scene's
    `buildIndex`, followed by the `GetScene` method. The `GetScene` method is a small
    method that is worth covering now instead of later as it relates to everything
    we've just said.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `GetScene` method is a single line of code that updates the scene's
    variable. This is an instance from the `Scenes` `enum` that holds the names for
    each scene in our game. Also, the code in the `GetScene` method is casting `currentSceneNumber`
    to an `enum`, which is why the `Scenes` type is in brackets. More about casting
    can be found at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code for our `ScenesManager` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can put the `GetScene` method anywhere in the `ScenesManager` class, as long
    as it's not within another method.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the `Update` function, after calling the `GetScene` method, we
    close the `if` conditions brackets. The last thing we do before closing the `Update`
    function is run the `GameTimer` method, which will keep track of our game's time
    and set up some basic methods that will start, reset, and end our game levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a timer to each game level. When the timer is up, that notifies the player
    has completed the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it so that when a level is completed, the `ScenesManager` script knows
    what to do next; that is, load a level, which level, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a game level timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `ScenesManager` script, we will set up a method that will be responsible
    for acknowledging the level has ended. The `GameTimer` method serves the purpose
    of adding time to a `gameTimer` variable and checking to see if it has reached
    its limit, depending on the `endLevelTimer` it's comparing to. Finally, if the
    game has been triggered to end the player ship's animation, it is set to start
    and the next level is loaded after `4` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'With your `ScenesManager` script still open, add the following method to your
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `GameTimer` method, we run a `switch` statement holding the `scenes`
    instance that will contain all of the `enum` names of each level. We run a check
    on three possible cases: `level1`, `level2`, and `level3`. If the `scenes` instance
    is set to either of the three possibilities, we will fall into an `if` condition
    that will then compare whether the `gameTimer` variable is less than what the
    `endLevelTimer` array has been set to.'
  prefs: []
  type: TYPE_NORMAL
- en: We only need to know what build index number levels 1, 2, and 3 are on. So,
    to avoid the first three scenes, we must subtract by `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Build Settings** window (**File** | **Build
    Settings**), which contains the scenes and their build numbers in your project
    on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Build Settings – scene order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Build Settings – scene order
  prefs: []
  type: TYPE_NORMAL
- en: 'If `gameTimer` is less than `levelTimer`, we will continue to increment `gameTimer`
    with the `Time.deltaTime` fixed function that Unity has pre-made for us. More
    information about `Time.deltaTime` can be found here: [https://docs.unity3d.com/ScriptReference/Time-deltaTime.html](https://docs.unity3d.com/ScriptReference/Time-deltaTime.html).'
  prefs: []
  type: TYPE_NORMAL
- en: If `gameTimer` is equal to or more than `levelTimer`, we will move into the
    `else` condition, which checks the condition of the `if` statement of the `gameEnding`
    `bool` being `false`. If the condition is `false`, we fall into the content of
    the `if` statement, which first sets the `gameEnding` `bool` to `true`. This will
    stop the `if` statement from repeating in the `Update` function's frame cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The last `if` statement checks which level our game is on. If we are not on
    `"level3"`, we set the `LevelEnds` property in the `PlayerTransition` script to
    `true`. Otherwise, we must have completed the game. So, in the `else` condition,
    we set the `GameComplete` property to `true` in the `PlayerTransition` script.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created a method in the `ScenesManager` script that made
    our game aware of how long each level will last before classing the level as completed.
  prefs: []
  type: TYPE_NORMAL
- en: We will now continue with the `ScenesManager` script by adding methods that
    will start, reset, and move our player onto the next level when triggered by the
    `GameTimer` method.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning, resetting, and skipping levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ScenesManager` will have the responsibility of starting a level, resetting
    it when the player dies, and moving onto the next level when the current one has
    been completed. Thankfully, these require minimal work thanks to Unity''s `SceneManagement`
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by revisiting the `ResetScene` method we have already started,
    but now, we will simplify it even more:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content from our `ResetScene` method with the following code in
    our `ScenesManager` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `ResetScene` method, we reset the `gameTimer` variable to zero, followed
    by replacing its parameter from the current `SceneManager.LoadScene` `buildIndex`
    to `GameManager.currentScene`, which we coded back in [*Chapter 3*](B18381_03_Epub.xhtml#_idTextAnchor073),
    *Managing Scripts and Taking aMock Test*. This is basically just holding the current
    build index as a `static` integer so that any script can access it.
  prefs: []
  type: TYPE_NORMAL
- en: With `ResetScene` updated, we can now move onto the next method, which is very
    similar to what we have just done, but it is separate to `ResetScene` in order
    to support the expansion of our code.
  prefs: []
  type: TYPE_NORMAL
- en: When a player completes a level, the `NextLevel` method runs, which will reset
    the `gameTimer` variable. The `gameTimer` `bool` will be set back to `false` and
    the same `SceneManager.LoadScene` command will be used to increment the `GameManager`
    `currentScene` integer by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following method in the `ScenesManager` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last method we need to change in our `ScenesManager` script is our `BeginGame`
    method, which will be called when the player is in the `shop` scene and pressing
    the `"START"` button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code for our `ScenesManager` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BeginGame` method will take an integer parameter called `gameLevel`. Inside
    this method is the same `SceneManager.LoadScene` we have already used, but this
    time, it will load the `gameLevel` integer we are providing it.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you remember, back in the previous chapter we set the `PlayerSpawner` script
    to temporary call the `GameManager.Instance.CameraSetup()`;
  prefs: []
  type: TYPE_NORMAL
- en: This call is no longer required and can now be removed. Let's remove it
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Script`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the PlayerSpawner script and remove the line from the Start function `GameManager.Instance.CameraSetup();`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because we have changed the `BeginGame` method to now take a parameter, we
    must update our `PlayerShipBuild` script, which has a `StartGame` method that
    runs the `BeginGame` method with, currently, no parameter value. To update the
    `PlayerShipBuild` `StartGame` method, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Unity Editor, navigate to the `Assets/Script/PlayerShipBuild.cs` folder
    in the **Project** window and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll down to the `StartGame` method and find this line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, change the preceding line of code to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code change will now call the `level1` scene directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have reached the end of this section. So far, we have covered
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Our game is now aware of how long a level will take until it is classed as completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ScenesManager` script can now call methods that will start, reset, and
    move the player onto the next level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of our code was created with the use of `switch` statements and
    an `enum` to call when the scenes need to be changed. To load the scenes themselves,
    we used Unity's own `SceneManager` class, which is fundamental to loading any
    scene in a Unity Project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will prepare the rest of the scenes in our project that
    aren't game levels (the `bootUp` scene, the `title` scene, and the `gameOver`
    scene).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to loop our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to move away from the `testLevel` scene and introduce
    three other levels (`level1`, `level2`, and `level3`) to demonstrate the game
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, our game loop will be complete. We will be able
    to start our game from the `bootUp` scene. From there, we will be able to progress
    through each scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by removing the placeholder levels in the Unity Editor. Go to
    the `Assets/Scene` location. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your `player_ship` is saved (`testLevel` scene. Next, Delete `level1`,
    `level2`, and `level3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `testLevel`, hold the *Left Ctrl* *(Command* on the Mac) key on the keyboard,
    and press *D* twice. We should now have three `testLevel` instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `testLevel` to `level1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `testLevel 1` to `level2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `testLevel 2` to `level3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to check the **Build Settings** window to check on the order of
    our scenes.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, click **File** | **Build Settings.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our order should look like the one shown in the following screenshot. If it
    doesn''t, select and move the scenes into the correct position by clicking and
    dragging them in the **Build Settings** window and by selecting and deleting any
    extra scenes in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Build Settings – complete scene order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Build Settings – complete scene order
  prefs: []
  type: TYPE_NORMAL
- en: We have duplicated our first level twice to test that our levels can be completed
    and move forward. Next, we will go back to the first scene in our project list
    and set it up so that it's ready to act like a boot up scene.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have removed our `testLevel` scene, we need to update our `GameManager`
    script with regards to the `LightandCameraSetup` method to keep its `Switch` statement
    in sync with the levels we need to light up, as well as set up our camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it so our camera and lights work correctly for each scene, we need
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Script` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `GameManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down to the `LightandCameraSetup` method''s content and make it so that
    each case number follows this pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each case represents the levels the player is going to play.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next few sections, we will be customizing a placeholder look for each
    nonlevel scene (basic but informative). These scenes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bootUp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gameOver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these scenes will also require basic coding so that the player either
    presses a button to continue or a timer will be issued. This timer will count
    down until the next scene is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the bootUp scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we run a game, typically, the game doesn't start straight away – there's
    normally a splash screen to show who developed/published the game. Sometimes,
    it's used as a loading screen, but for us, it will be used to get our game started.
    In this section, we are going to take away the typical Unity sky background and
    replace it with a neutral grey color background with a text title that states
    what screen has loaded up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start and open the `bootUp` scene in the Unity Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `level1` scene by going to `Assets/Scene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `prefab` folder if it isn't already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, double-click on the bootUp scene file from `Assets/Scene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `GameManager` prefab from the `Assets/Prefab`, to the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty game object in the **Hierarchy** window. If you have forgotten
    how to do this, refer to [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created game object `BootUpText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another empty game object as before and name that `BootUpComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the components on the left-hand side of the
    **Hierarchy** window. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main Camera**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direction Light**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GameManager**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BootUpComponent**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BootUp Text**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Game object Hierarchy window order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Game object Hierarchy window order
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side of the preceding screenshot, we have our `GameManager`
    game object selected showing its three main component scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Game Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenes Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may recall, our `GameManager` script will always remain in a scene, even
    if the scene is replaced with another, so it's vital we have these components
    in our Game Manager prefab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to change the background from sky to grey, as mentioned
    previously. To do this, select **Main Camera** from the **Hierarchy** window.
    Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Inspector** window, click the **Clear Flags** selection and change
    it from **Skybox** to **Solid Color**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just below `32323200`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will change the RGB values to `50`,`50`,`50` with an alpha setting of `zero`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following screenshot as a reference for the location for **Clear Flags**,
    **Background**, and **Hex Color**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Changing the background color of our scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.06_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Changing the background color of our scene
  prefs: []
  type: TYPE_NORMAL
- en: This will change the background in the **Game** window to gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will select `BootUpText` and add a **Text Mesh** that will be at the
    bottom center of the screen. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `BootUpText` game object in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the **Inspector** window, click the **Add Component** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the drop-down, type `Text Mes`h until you see it in the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Text Mesh** from the drop-down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `BootUp Text` game object still selected, change its **Transform**
    Position to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that our text is in the correct position, we need to fill out the **Text
    Mesh** component in **Inspector**. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BootUp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Anchor** to **Middle center**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Alignment** to **Center**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Game** window (shortcut: *Ctrl (command* on Mac*) + 2*). Now, we
    should have a gray screen with white text so that we can easily identify the scene
    we are in. The following screenshot shows the "**BootUp**" text''s settings, along
    with its **Inspector** properties for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Basic ''BootUp'' scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Basic 'BootUp' scene
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do for this `bootUp` scene is to make it function
    like most `bootUp` screens.
  prefs: []
  type: TYPE_NORMAL
- en: When the `bootUp` screen appears, it stays there for a couple of seconds and
    then moves onto the next scene.
  prefs: []
  type: TYPE_NORMAL
- en: To make it so the `bootUp` screen loads onto the next screen after a few seconds,
    we will need to create a script and add it to the `BootUpComponent` game object.
  prefs: []
  type: TYPE_NORMAL
- en: When we make the script, we need to store it with our other scripts in the `Assets/Script`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have forgotten how to make a script, check out the *Updating our camera
    properties via script* section in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects.*
  prefs: []
  type: TYPE_NORMAL
- en: Name the script `LoadSceneComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the `BootUpComponent` game object should
    look like when it''s selected in the **Hierarchy** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – ''BootUpComponent'' game object and script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – 'BootUpComponent' game object and script
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the grayed-out field of `LoadSceneComponent` in the **Inspector**
    window to open the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following code is similar to the code that we entered previously for loading
    a level, just in a shorter form. The basic principle is that we load in `UnityEngine.SceneManagement`
    to inherit Unity's `SceneManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Our game's score gets reset at the start of the script to stop any previous
    scores being carried over.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a timer and increment the time in Unity's `Update` function.
    Once the timer goes over `3` seconds, `SceneManager` will load whatever we have
    put in the `loadThisScene` public variable, which in our case is `"title"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `LoadSceneComponent` script in **Inspector**
    with a field where we can enter the scene we wish to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Load Scene Component will load the ''title'' scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Load Scene Component will load the 'title' scene
  prefs: []
  type: TYPE_NORMAL
- en: It's as simple as that – we don't need to worry about anything else as the `bootUp`
    scene isn't part of the game loop. The `bootUp` scene is only played once when
    the game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into `LoadSceneComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you're done, save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back into the Unity Editor and type `title` into the `loadThisScene` variable
    field in the **Inspector** window, as shown in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the `bootUp` scene and press `bootUp` scene should load up and then, after
    `3` seconds, load up the `title` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now repeat the majority of what we've done in the `bootUp` scene and
    duplicate this for the `title` and `gameOver` scenes. We will do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the title and gameOver scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way we set the `bootUp` scene in the previous section is similar to how
    we want the `title` and `gameOver` scenes to look and act before we add any new
    art and custom functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, with Unity, we don't have to repeat the entire process of making
    these two scenes from scratch. We can copy, paste, and rename the game objects
    we have already created in the `bootUp` scene's `title` and `gameOver` scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy the gray background and white `bootUp` scene, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `bootUp` scene still active in the Unity Editor, select all of the
    `5` game objects from the **Hierarchy** window (click the top or the bottom of
    the list, hold *Shift*, then click either end of the list to select all).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Left Ctrl* (*Command* on Mac) *+ C* to copy these `5` game objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `title` scene from the `Assets/Scene`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select and delete all game objects in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click anywhere in the open space of the `bootUp` game objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `BootUpText` in the `TitleText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `TitleText` game object still selected, change the `Title`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `BootUpComponent` in the `TitleComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `TitleComponent` game object still selected, click the three small
    dots in the **Inspector** window next to **LoadSceneComponent** (**Script**)**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A drop-down will appear; click **Remove Component** from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to make a script for the `TitleComponent` game object so that when
    the player taps or clicks the mouse button, the `shop` scene will load up next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the same process of making and attaching a script as we did with `BootUpComponent`,
    but this time, name the script `TitleComponent` (also, as with the `TitleComponent`
    script, make sure it is moved into the correct folder in the `Assets/Script`)
    and paste in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The difference between this `TitleComponent` script and the previous `BootUpComponent`
    script is that `TitleComponent` will move onto the next scene (`shop` scene) when
    a mouse button (or a finger on a touch screen) is pressed and released in `BootUpComponent`,
    which is dependent on a timer to increment the past `3` seconds to load the next
    scene, where its failsafe is to reset the game's score if the player completes
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Save the `TitleComponent` script and `title` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the `title` scene should look like in the
    Unity Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Hierarchy ''title'' scene game object order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Hierarchy 'title' scene game object order
  prefs: []
  type: TYPE_NORMAL
- en: We now need to repeat the exact same process for the `gameOver` scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `gameOver` scene from the `Assets/Scene`) and repeat the process of
    pasting and renaming the game objects. Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BootUpComponent` game object to `GameOver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Still in the `BootUpText` to `GameOverText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `GameOver` component in the `LoadSceneComponent` until we see it
    in the list. Then, select it if we don't have the component added already..
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `GameOver` component with the same `LoadSceneComponent`
    script where I added `"title"` to the `loadThisScene` variable field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Load Scene Component loading the ''title'' scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Load Scene Component loading the 'title' scene
  prefs: []
  type: TYPE_NORMAL
- en: Save the `gameOver` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our Unity Project is now ready to run its full game loop. We will talk about
    the game loop in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating that the game loop is complete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this final section, we will confirm what we have achieved in this chapter.
    Our game now has a game loop, so if we load up the `bootUp` scene and press **Play**
    in the Unity Editor, the sequence will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bootUp`: The scene runs for `3` seconds and then moves to the `title` scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: If the player presses the mouse button, the `shop` scene will load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shop`: The player presses the `level1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1`: The player completes the level after `30` seconds (45 seconds for
    level 3) or dies. If the player dies more than `3` times, they will be presented
    with the `gameOver` scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2`: The same rules apply as the ones present for `level1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level3`: The same rules apply as the ones present for `level1`, but if the
    player completes the level, they will be presented with the `gameOver` scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gameOver`: The scene runs for `3` seconds and then moves to the `title` scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows the process of our game loop moving through each
    scene, then going back to the `title` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Killer Wave''s game loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Killer Wave's game loop
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember that if any of our scenes look darker than usual, we will need to bake
    its lights manually, as we did back in [*Chapter 3*](B18381_03_Epub.xhtml#_idTextAnchor073),
    *Managing Scripts and Taking a Mock Test.*
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have created a series of scenes that carry their own individual
    responsibilities. When a scene comes to its end, either by its own choice or prompted
    to by the player, the next scene in the sequence will load. Eventually, by the
    player either completing all three levels or losing all their lives, our game
    will reach the `gameOver` scene. From the `gameOver` scene, we send the player
    back to the `title` scene. This is our game loop, and this is what every game
    will have. Game loops are a fundamental requirement for game development, and
    it's also possible that this will be mentioned in the exam.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this section and this chapter, where we have created and managed
    our scenes in order to create a game loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a game loop; these are fundamental to game development,
    and sometimes application development. To create a game loop for our project,
    we needed multiple scenes that served their own purposes. We also needed to know
    when a scene started and when it should end. A scene ends when the player presses
    a button to continue, such as the `7` scene, or when the `bootUp` title automatically
    moves onto the next scene after so many seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from making our game loops, we also learned some new vector math components
    on the way, including `Mathf.round`, which is used to round off figures `Vector3.distance`,
    which is used to measure the distance between two `Vector3` points; and `Vector3.lerp`,
    which is used to interpolate between two `Vector3` points.
  prefs: []
  type: TYPE_NORMAL
- en: These are useful components in game development and will also likely be mentioned
    in the exam.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be adding some polish to our placeholder scenes
    with custom fonts, creating our own images, and applying some UI animation in
    the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Mock test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What would be the best way for a UI menu system to be worked on from a programmer's
    perspective, but at the same time in a way that doesn't interfere with an artist
    working on the same workflow?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make it so that each UI component has its own class so that any art changes
    won't affect either outcome.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Give each UI component a separate material so that any changes in the code will
    be isolated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use prefabs for each UI component so that any artist can modify them individually.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a separate script that sweeps through all UI components to check any changes
    that are made so that they're known to everyone.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An **Image** component has a sprite in its **Source Image** parameter and its
    **Image Type** is set to **Filled**. What does **Filled** do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fills open spaces in the sprite.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It offers various ways to fill in the sprite.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Makes it so no other sprite can override it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inverts the color of the sprite.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What component does `CrossPlatformInputManager` replace?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`anyKey`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Input `'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mousePosition`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`acceleration`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When testing a top-down shooter game you have just developed, you want the controls
    to have an "Arcade" feel. To make the controls snap into position when moving
    the player, which property would help create what is required?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetAxisRaw `'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetJoystickNames`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InputString`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gyro`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing code such as variable names, which is the correct naming convention
    to use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pascal case
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lower case
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cake case
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Camel case
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You are working with a team to create a realistic simulation for the military
    that includes a series of explosions. You have been asked to take over from the
    previous developer who has, so far, created a framework that issues a series of
    explosions from a bank of prefabs. The prefabs are updated on a regular basis
    by one of the artists on the team. As impressive as this looks, the program has
    gotten quite big and the artist will need to have the option to update, swap out,
    replace, and delete prefabs from the framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What solution can you offer the team that keeps this framework from not going
    against SOLID principles and is accessible to the artist in the team?
  prefs: []
  type: TYPE_NORMAL
- en: Create a series of prefabs that hold a cluster of prefabs that randomize on
    each occasion when they're used in the Unity scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a single scriptable object that holds an array of prefabs that holds
    a reference to either script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a non-procedural particle system that creates its own explosions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold all the explosions in the scene at runtime but off-camera and then bring
    in those required using a random selection script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which collider is the fastest for the Unity physics system to calculate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hinge
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sphere
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mesh
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Box
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the cheapest MinMaxCurve to use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimized Curve
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Random between two constants
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Random between two curves
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Constant
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which property needs to be accessed through code to create a strobe effect for
    a nightclub scene?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`color.a`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spotAngle`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`range`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`intensity`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
