- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validating User Input Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explore the essential aspect of ensuring the accuracy and
    integrity of data submitted through forms in Blazor applications. With effective
    validation, you’ll prevent erroneous data entry and enhance user interactions
    and application security. Throughout this chapter, we will explore a comprehensive
    range of techniques and strategies you can employ while validating user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with the fundamental process of adding validation to a form, setting
    the stage for more complex validation scenarios. You will learn how Blazor handles
    basic validation scenarios and how you can extend them to meet specific domain
    needs. After that, we explore the use of data annotations for form validation.
    You’ll uncover how to simplify form validation using built-in annotations and
    how to leverage them to enforce rules and constraints directly on data models,
    reducing boilerplate code. Right after, you will see how to implement custom validation
    attributes, which provide the flexibility to address unique business requirements.
    Then, we address the validation of complex data models, ensuring that data integrity
    is maintained even in intricate scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we focus on improving the user experience of your
    forms. We cover the styling of validation messages and modernizing validation
    summaries. Good styling makes validation messages clear and more aligned with
    the application’s design, while toasts offer a dynamic way to alert users about
    issues without disrupting their workflow. Lastly, we explore how to dynamically
    control form actions based on validation results, ensuring that users can only
    submit forms in a valid state, thereby avoiding unnecessary submissions and server
    load.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll know how to implement effective validation
    strategies in your Blazor applications, ensuring correct user inputs and enhancing
    the usability and reliability of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the list of recipes we’re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation to a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging data annotations for form validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom validation attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating complex data models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling validation messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a toast when validation fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the submit option based on the form state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, recipes build on each other, so you can follow the entire
    journey within the same directory. However, for clarity and easier initial setup,
    at the beginning of each recipe, you will find instructions on what working directory
    to create and which files are required to execute the task at hand. But before
    diving in, make sure you have all the basic tools for Blazor development:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern IDE (that supports Blazor development)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser (that supports WebAssembly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser dev tools (which can be a part of the modern browser already)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blazor project (where you’ll write your code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Validating complex data models* recipe, we utilize the **Microsoft.AspNetCore.Components.DataAnnotations.Validation**
    NuGet package, which is not pre-installed by default, so you might as well add
    it to your project now. Keep in mind that the validation package is still in preview,
    so you’ll have to include prerelease packages in the NuGet feed in your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the code written in this chapter and code samples on GitHub
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter07](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation to a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore the basics of user input validation in Blazor.
    Validation is critical for preventing errors and security vulnerabilities, maintaining
    data consistency, and enhancing the user experience. The Blazor community has
    created various NuGet packages for handling input validation, offering a range
    of features and configurations. However, Blazor provides extensive built-in support
    for validating forms and displaying validation results in a user-friendly manner.
    The native functionalities are lightweight and integrate directly with Blazor’s
    data binding and UI features.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a small event creation form, where a user must provide the event
    name. We will also display a validation message when the event name is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we add the first, basic validation to a form, create a **Chapter07**
    / **Recipe01** directory – this will be your working directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a simple validation to a form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **Event** class with a **Name** property – we will use it as a form
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a routable **EventManager** component that implements the **IDisposable**
    interface. You will see compilation errors now, but we will resolve them later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block of **EventManager** , declare an **Event** model to
    serve as the backing model for the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **Model** parameter declaration, introduce the **Context** and **Store**
    variables for the form’s state management:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement a **Save()** placeholder method
    to simulate form submission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alongside **Save()** , implement a **ValidateForm()** method, with a signature
    matching the response of a **EventHandler** validation, which checks whether the
    **Model.Name** property has a valid value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continuing in the **@code** block, override the **OnInitialized()** life cycle
    method to initialize the **Model** instance if needed and set up both the form
    context and the validation message container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finalize the **@code** block by implementing the **Dispose()** method to adhere
    to the **IDisposable** requirement and unsubscribe from the validation event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **EventManager** markup, include an **EditForm** component, attaching
    **Context** to the appropriate parameter and linking the **Save()** method to
    handle the form submission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside **EditForm** , add an **InputText** component and bind it to the **Model.Name**
    property. Alongside **InputText** , add a **ValidationMessage** component to display
    validation errors for the attached property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, complete **EditForm** by adding a submit button below the form fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a simple **Event** class with a single **Name** property.
    We will use **Event** as a model for our form. Next, in *step 2* , we create a
    routable **EventManager** component, not specifying any render mode, which leads
    Blazor to default to static server-side mode. As form validation is event driven,
    **EventManager** must implement the **IDisposable** interface, which we apply
    using the **@implements** directive. You will see compilation errors now, but
    we will resolve them later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving to *step 3* , within the **@code** block of **EventManager** , we utilize
    the **Event** class to declare the **Model** parameter, tagging it with the **SupplyParameterFromForm**
    attribute to enable an automatic binding with the form. In *step 4* , we introduce
    two form-backing variables: **EditContext** and **ValidationMessageStore** . The
    **EditContext** instance tracks changes to form inputs and manages the validation
    state, while **ValidationMessageStore** holds and displays validation messages,
    simplifying the validation process.'
  prefs: []
  type: TYPE_NORMAL
- en: Proceeding to *step 5* , we implement a **Save()** placeholder method. Data
    persistence isn’t the focus of this chapter, so we log a brief message to the
    console to simulate a save operation. In *step 6* , we implement the **ValidateForm()**
    method with a signature that matches the validation handler required by **EditForm**
    . Whenever Blazor invokes **ValidateForm()** , we first clear any messages in
    **Store** to handle multiple validation attempts smoothly. Then, we check whether
    the user provided the **Model.Name** property; if not, we add a **You must provide
    a name.** message to **Store** and identify the invalid property with a delegate,
    **() => Model.Name** . Under the hood, Blazor breaks down this delegate into the
    object ( **Model** ) and the property path string ( **Name** ) to efficiently
    track and manage validation and error association.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we override the **OnInitialized()** life cycle method to set up
    the form’s underlying logic. We resolve the **Model** value, supporting the pattern
    for the parameter with the **SupplyParameterFromForm** attribute. We then initialize
    **Context** with the **Model** object and subscribe **ValidateForm()** to the
    **OnValidationRequested** event handler that **Context** exposes. With that, Blazor
    will automatically invoke **ValidateForm()** every time the user submits the form.
    Finally, we initialize **Store** by passing **Context** , so the validation container
    can access the **Model** fields. In *step 8* , we wrap up the **@code** block
    by implementing the **Dispose()** method, adhering to the **IDisposable** pattern.
    Within **Dispose()** , we safely unsubscribe **ValidateForm()** from the validation
    trigger of **Context** to prevent potential memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Having the backend logic in place, we proceed to the **EventManager** markup.
    In *step 9* , we add an **EditForm** component, but instead of attaching the backing
    **Model** instance directly, we attach **Context** to the **EditContext** parameter.
    Blazor will not allow attaching both **Model** and **EditContext** since **Context**
    already encompasses an instance of **Model** . We also use the **OnValidSubmit**
    callback rather than the standard **OnSubmit** . Blazor invokes **OnValidSumbit**
    only when all validations pass successfully, making it ideal for our needs. In
    *step 10* , within **EditForm** , we place an **InputText** component and bind
    it to the **Model.Name** property, enabling the user to provide the required event
    name. Alongside **InputText** , we position a **ValidationMessage** component
    that displays validation messages for the specific form field. As **ValidationMessage**
    requires a delegate to retrieve messages from the container, we leverage the same
    delegate we used in **ValidateForm()** for seeding a validation message into **Store**
    . Finally, in *step 11* , we complete the form implementation by adding a submit
    button.
  prefs: []
  type: TYPE_NORMAL
- en: When the user submits the form, Blazor triggers the **OnValidationRequested**
    event handler first. If validation results in errors, the **Save()** method is
    not activated, ensuring that only valid data is processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the validation error looks like in our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Validation message when user submits the form without providing
    the name](img/B22020_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Validation message when user submits the form without providing
    the name'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the **ValidationMessage** component, we can control where Blazor renders
    validation messages for each field, providing granular feedback directly next
    to individual form elements. However, you might want to display a consolidated
    validation summary rather than scattered messages. That’s where the **ValidationSummary**
    component comes in handy. The **ValidationSummary** component gathers and displays
    all validation messages within one container. You can see such summaries at the
    top or bottom of the forms or even as part of a validation popup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a summary in our form, we only need to replace **ValidationMessage**
    with **ValidationSummary** and add a **DataAnnotationsValidator** component within
    the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We must embed **DataAnnotationsValidator** as it triggers the population and
    re-render of **ValidationSummary** . Without the validator, will get the red input
    styling, indicating that the value provided is invalid, but no message explaining
    why.
  prefs: []
  type: TYPE_NORMAL
- en: We explore **DataAnnotationsValidator** further in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging data annotations for form validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore the role of **data annotations** in streamlining
    and enhancing the validation processes in a form in Blazor. Data annotations are
    attributes applied directly to model properties that enable a declarative way
    of specifying validation rules. By implementing data annotations, you can significantly
    simplify the validation logic and encapsulate it within the model rather than
    coupling it with any specific form. Such separation ensures that validation is
    consistently enforced across different parts of your application regardless of
    the context in which you use the model. Blazor has a built-in **DataAnnotationsValidator**
    component that seamlessly integrates data annotations into a form. **DataAnnotationsValidator**
    checks the data annotations applied to the model and produces validation results
    without additional coding.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s convert an explicit validation logic in a form into data annotations and
    leverage Blazor’s native support to handle validation efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we encapsulate the validation logic into a separate component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter07** / **Recipe02** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **EventManager** and **Event** from the *Adding validation to a form* recipe
    or from the **Chapter07** / **Recipe01** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to leverage data annotations for model validation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **Event** class and decorate the **Name** property with the
    **Required** attribute with a user-friendly error message. You must reference
    a **System.ComponentModel.DataAnnotations** namespace, but your IDE might include
    it automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Move to the **EventManager** component and remove the **IDisposable** declaration
    from the top of the file. You should have only a route declaration left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **EventManager** markup, locate **EditForm** and embed the **DataAnnotationsValidator**
    component just below the submission button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jump to the **@code** block of **EventManager** and do some cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the subscription to the **OnValidationRequested** event handler from
    the **OnInitialized()** method implementation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the **Dispose()** and **ValidateForm()** methods entirely
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we enhance the **Event** class by implementing data annotations
    to enforce input validation. We decorate the **Name** property with the **Required**
    attribute to ensure a user always provides that value. Data annotations also accept
    the **ErrorMessage** parameter, where we can pass in a user-friendly validation
    message, so we extend the **Required** attribute with the **You must provide a
    name.** error message.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we move to the **EventManager** component. With data annotations
    in place, we no longer need explicit event handling. Consequently, we remove the
    **IDisposable** declaration from the top of the **EventManager** file. In *step
    3* , we enhance the **EventManager** markup and embed the **DataAnnotationsValidator**
    component at the end of **EditForm** , just below the submission button. **DataAnnotationsValidator**
    operates seamlessly within the form, carrying no distinct markup and relying on
    the cascading **EditContext** for validation operations. We placed **DataAnnotationsValidator**
    at the end of the form, but you can put it anywhere as long as it’s within the
    **EditForm** tags. In *step 4* , we update the **@code** block of **EventManager**
    . With data annotations now managing validation, we can simplify the component
    code by removing most of the previously necessary validation logic. We remove
    the **OnValidationRequested** subscription within the **OnInitialized()** method,
    as **DataAnnotationsValidator** now automatically monitors the validation state.
    Following this, we also eliminate the **ValidateForm()** method, as the management
    of the validation message store and error messages has shifted to **DataAnnotationsValidator**
    as well. Lastly, we remove the **Dispose()** method because **EventManager** no
    longer implements the **IDisposable** interface or listens to any events.
  prefs: []
  type: TYPE_NORMAL
- en: With these few adjustments, we achieve the same validation scope as in the *Adding
    validation to a form* recipe but with significantly less code!
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With **DataAnnotationsValidator** in place, Blazor can perform two types of
    validation:'
  prefs: []
  type: TYPE_NORMAL
- en: The first type is **full-model validation** – Blazor executes when the user
    submits the form. This validation occurs when you click the **Save** button on
    the **EventManager** form. It involves checking every validation rule across all
    fields in the model, ensuring that all data meets the specified criteria before
    the form is processed. As we’re working in the SSR render mode, which has inherently
    limited interactivity, only full-model validation is supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, should you opt to render **EventManager** in an interactive mode, **DataAnnotationsValidator**
    can execute another layer of validation – **field validation** . Blazor triggers
    field validation when the user moves the focus away from an individual form field,
    displaying immediate feedback on the input provided in that specific field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom validation attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we dive into the flexibility of customizing validation attributes.
    While built-in data annotations simplify validation logic, they cover only the
    most commonly used validation rules. You might find yourself missing the coverage
    for your specific needs. Fortunately, you can implement custom data validation
    attributes with unique rules beyond the standard validations provided by .NET.
    Additionally, Blazor’s native **DataAnnotationsValidator** component seamlessly
    integrates with any custom attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement an event name validation attribute that checks whether the user
    provided the event name and scans for any forbidden keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we implement a custom validation attribute, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter07** / **Recipe03** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **EventManager** and **Event** from the *Leveraging data annotations for
    form validation* recipe or from the **Chapter07** / **Recipe02** directory in
    the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to implement a custom validation attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **EventNameValidationAttribute** class that inherits from a **ValidationAttribute**
    class. You must reference the **System.ComponentModel.DataAnnotations** assembly,
    but your IDE might include it automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **EventNameValidationAttribute** class, declare a private variable,
    **_forbidden** , and initialize it with the **event** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **_forbidden** variable, implement a **Failure()** method that accepts
    **message** and **member** parameters and returns an instance of **ValidationResult**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the implementation of **EventNameValidationAttribute** by overriding
    the **IsValid()** method, which returns a **ValidationResult** object. Return
    the result of **Failure()** invocation if the incoming **value** was not provided
    or it contains the **_forbidden** keyword. Otherwise, return the default **ValidationResult.Success**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **Event** class and update the decoration of the **Name** property
    by replacing the existing **Required** attribute with the newly implemented **EventNameValidation**
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create an **EventNameValidationAttribute** class, inheriting
    from **ValidationAttribute** . The **ValidationAttribute** class is a base class
    for validation attributes, providing a framework for implementing custom validation
    rules in .NET applications. It allows for defining specific conditions that data
    must meet before being processed further. In *step 2* , we declare a **_forbidden**
    variable within our custom validation attribute class to store the forbidden keyword
    to check against the input value. In *step 3* , we implement a **Failure()** method
    that accepts the **message** and **member** parameters. **Failure()** creates
    and returns an instance of **ValidationResult** , representing a failure in validation.
    The **member** parameter allows associating the error message with specific fields,
    enhancing the clarity of feedback provided to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we implement the custom validation logic by overriding the **IsValid()**
    method from the **ValidationAttribute** class. Blazor triggers **IsValid()** when
    it validates the form model. We choose to override the overload that returns a
    **ValidationResult** object rather than a simple **bool** , as we want to provide
    detailed feedback on validation issues. We first convert the incoming **value**
    to a **text** variable. If **text** doesn’t carry a meaningful value, we call
    the **Failure()** method to return a validation error with the message **You must
    provide a name.** . But **Failure()** also requires providing a **member** name.
    The **IsValid()** method accepts another parameter of type **ValidationContext**
    , which provides context about the validation operation, including **MemberName**
    identifying the validated field. With **MemberName** , we can conform to the **Failure()**
    method signature. We then check whether **text** contains the **_forbidden** keyword,
    ignoring case and culture differences. If the forbidden keyword is found, we invoke
    **Failure()** again with the message **You mustn’t use the ‘event’ keyword.**
    . Lastly, if all checks pass successfully, we return **ValidationResult.Success**
    – a success indicator encapsulated inside the **ValidationResult** class.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we navigate to the **Event** class and replace the existing **Required**
    attribute on the **Name** property with our newly created **EventNameValidation**
    attribute. Thanks to code generators and the C# and Blazor compilers, we can reference
    custom attributes using the class name without the **Attribute** suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we validate not only whether the user provides the event name but also
    whether they use the forbidden keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Validation message when user submits a value containing a forbidden
    keyword](img/B22020_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Validation message when user submits a value containing a forbidden
    keyword'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building multilingual applications, you might need to translate user-friendly
    error messages. Additionally, with continuous delivery trends, you may need to
    conditionally enable validation rules based on feature flags or application settings.
    You will require access to the dependency injection container to support such
    advanced scenarios. While in a class based on **ValidationAttribute** , you can
    reach dependency injection through the **ValidationContext** parameter, which
    encapsulates the behavior of **IServiceProvider** and exposes all the standard
    dependency injection methods available in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assuming that you’ve registered an **Api** service in the service
    container, you can inject this dependency within your attribute in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We override the **IsValid()** method, inherited from the **ValidationAttribute**
    class, and we get an instance of **ValidationContext** . As **ValidationContext**
    implements the **IServiceProvider** interface, we leverage the built-in generic
    **GetRequiredService()** extension method to retrieve an instance of our **Api**
    service.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that custom validation attributes in .NET do not support
    asynchronous validation. This limitation is crucial to consider when designing
    your validation strategy to ensure performance and user experience are not adversely
    affected.
  prefs: []
  type: TYPE_NORMAL
- en: Validating complex data models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we tackle the validation of complex forms and data models. Having
    well-structured and modularized code makes the code base easier to maintain and
    reduces the likelihood of errors by clearly defining and isolating each component’s
    responsibilities. In forms, complex models segment the data into manageable parts,
    each with its validation logic, making it easier to maintain the overall form’s
    state and ensuring each segment adheres to specific business rules. The **Microsoft.AspNetCore.Components.DataAnnotations.Validation**
    package, although experimental, exposes Blazor-native validators and offers enhanced
    data annotations that integrate smoothly with complex models.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s extend the event creation form to include a nested object that encapsulates
    details about the event location.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we set up nested, complex model validation, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter07** / **Recipe04** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **EventManager** , **Event** , and **EventNameValidationAttribute** from
    the *Implementing custom validation attributes* recipe or from the **Chapter07**
    / **Recipe03** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to enable validation of the nested model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a reference to the **Microsoft.AspNetCore.Components.DataAnnotations.Validation**
    package to your project file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **EventLocation** class and define two properties within it –
    **Venue** and **Capacity** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the **Required** attribute to the **Venue** property and include a meaningful
    error message when a user leaves the field blank:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the **Capacity** property, decorate it with both the **Required** and **Range**
    attributes and provide a meaningful error message to ensure the user inputs only
    valid capacity values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **Event** class and add a new **Location** property. Decorate
    **Location** with a **ValidateComplexType** attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the **EventManager** component, locate **EditForm** within the markup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside **EditForm** , directly below the input field for **Name** , add a new
    paragraph with an **InputText** component bound to the **Model.Location.Venue**
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **Venue** input field, add another paragraph containing an **InputNumber**
    component bound to the **Model.Location.Capacity** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within **EditForm** , replace the existing **ValidationMessage** for
    the **Model.Name** property with **ValidationSummary** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, swap out the **DataAnnotationsValidator** component for **ObjectGraphDataAnnotationsValidator**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we open the **csproj** file of our project and add a reference
    to the **Microsoft.AspNetCore.Components.DataAnnotations.Validation** package
    that contains all the extensions required for seamless validation of complex,
    nested data models.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in *step 2* , we create a new **EventLocation** class with the **Venue**
    and **Capacity** properties, representing event location details. In *step 3*
    , we decorate the **Venue** property with a **Required** attribute to ensure that
    users cannot submit the form without filling in the venue description. Should
    they forget to enter a **Venue** value, they will see a **You must provide a venue.**
    validation message to guide them. In *step 4* , we add validation to the **Capacity**
    property by applying both the **Required** and **Range** attributes. We enforce
    that users fill the capacity value and that it falls within a specified range
    (1 to 1,000). Users will receive a **Capacity must be between 1 and 1000.** error
    message if they enter a value outside the declared range.
  prefs: []
  type: TYPE_NORMAL
- en: For *step 5* , we turn to the **Event** class and extend it with a new property
    – **Location** , of type **EventLocation** . To ensure Blazor understands that
    this property represents a complex type requiring nested validation, we decorate
    it with the **ValidateComplexType** attribute. **ValidateComplexType** comes with
    the **Microsoft.AspNetCore.Components.DataAnnotations.Validation** package.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6* , we proceed to the **EventManager** component and locate the existing
    **EditForm** within the markup. We will extend the form to include fields for
    entering the event location details. In *step 7* , we embed a new paragraph just
    below the **Name** field where we insert an **InputText** component bound to **Model.Location.Venue**
    to allow users to input the venue details. In *step 8* , we add another paragraph,
    this time incorporating an **InputNumber** component bound to **Model.Location.Capacity**
    to allow users to specify the spots available in a given venue. In *step 9* ,
    aiming to streamline the display of validation messages, we replace the **ValidationMessage**
    component previously dedicated to the **Name** property with a **ValidationSummary**
    instance. The **ValidationSummary** component consolidates all form validation
    messages into one area. Finally, in *step 10* , we enhance our validation setup
    by replacing the standard **DataAnnotationsValidator** with **ObjectGraphDataAnnotationsValidator**
    . The **ObjectGraphDataAnnotationsValidator** component is an advanced component
    capable of validating nested object graphs, allowing Blazor to trigger validation
    on every part of our complex **Event** model.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with Blazor’s built-in input components, you get an additional
    layer of flexibility. Any default input component, inheriting from the **InputBase**
    class, such as the **InputNumber** component we’ve used in this recipe, automatically
    intercepts any unmatched parameters and attaches them directly to the underlying
    HTML **input** element as attributes. With that, you can easily enhance the **InputNumber**
    component used for **Model.Location.Capacity** by declaring **min** and **max**
    attributes and disallowing users from manually increasing or decreasing the value
    beyond the specified range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By adding **min** and **max** attributes to the **InputNumber** component in
    the form and declaring their values to **1** and **1000** , respectively, we ensure
    users won’t be able to reduce the value in the input below **1** nor increment
    it above **1000** . They can still type an invalid value by hand, but they’ll
    trigger validation on the model properties. Following that example, you can leverage
    any other HTML input attributes you’re familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Styling validation messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore the styling of form validation in Blazor. You’ve
    probably noticed in previous recipes that Blazor automatically applies validation
    classes to form fields during validation. Default validation CSS classes align
    with default Bootstrap styles, where invalid fields get a red accent and valid
    ones get a green accent. While the default settings increase the delivery velocity,
    in most cases, you will still have to customize the visual feedback to suit your
    application branding or functional requirements. Fortunately, Blazor allows customizing
    styling and classes appended to fields upon validation. This customization maintains
    the integrity of your application’s modular and loosely coupled architecture,
    ensuring that enhancements do not compromise the maintainability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a custom validation class provider, making Blazor mark missing
    labels in red while missing location capacity in yellow.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before implementing a custom validation class provider, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter07** / **Recipe05** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Event** , **EventLocation** , **EventManager** , and **EventNameValidationAttribute**
    from the *Validating complex data models* recipe or from the **Chapter07** / **Recipe04**
    directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps to add a custom validation class provider:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new **EventManager.razor.css** file to the working directory. Your IDE
    might automatically nest that CSS file under **EventManager.razor** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within **EventManager.razor.css** , define an **invalid-warning** style class
    that adds an orange outline to any element we apply it to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **TypeValidationClassProvider** class, inheriting from **FieldCssClassProvider**
    available under the **Microsoft.AspNetCore.Components.Forms** namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **TypeValidationClassProvider** , declare a private **_capacity** field
    holding the name of the **Capacity** property from the **EventLocation** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finalize the implementation of **TypeValidationClassProvider** , override
    the **GetFieldCssClass()** method and implement logic to return the **invalid-warning**
    class when the current field’s value is invalid and corresponds to the **_capacity**
    property; otherwise, fall back to the **base** implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **EventManager** component and find the **OnInitialized()**
    method. After the existing setup, use the **SetFieldCssClassProvider()** extension
    method of **EditContext** and attach **TypeValidationClassProvider** to **Context**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we add a new CSS file to our working directory, specifically naming
    it **EventManager.razor.css** to adhere to the CSS isolation requirements and
    match the name of the component it will style. In Blazor, **CSS isolation** allows
    styles defined in a component-specific CSS file to affect only that component,
    preventing styles from leaking. If you enable the file nesting in your IDE, you
    will see isolated CSS files wrapped under the parent component file. In *step
    2* , within **EventManager.razor.css** , we introduce a **.invalid-warning** class,
    which applies an orange outline to fields we attach it to. We use the **::deep**
    combinator to ensure that styling penetrates DOM-like encapsulations and affects
    nested components.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we initiate our custom validation class provider by creating a
    new **TypeValidationClassProvider** class, which inherits from **FieldCssClassProvider**
    . The **FieldCssClassProvider** class provides the necessary API to customize
    CSS classes that Blazor applies based on field validation states. In *step 4*
    , we persist the name of the **Capacity** field in a **_capacity** variable within
    **TypeValidationClassProvider** . By declaring it as **private** and **static**
    , we ensure that this value remains unchanged and consumes minimal memory throughout
    the application’s life cycle, effectively becoming a singleton instance. In *step
    5* , we complete our custom provider by overriding the **GetFieldCssClass()**
    method, which Blazor calls whenever it needs to determine the appropriate CSS
    class based on the validation state of a field. In our implementation, we first
    check whether the field’s current state is valid and its name matches the **_capacity**
    value. If the field is invalid and refers to the capacity, we return **invalid-warning**
    , instructing Blazor to apply the orange outline to highlight the error. Otherwise,
    we default to the base implementation by returning the result of the **base.GetFieldCssClass()**
    call, preserving standard behavior for other fields.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in *step 6* , we jump to the **EventManager** component and locate
    the overridden **OnInitialized()** life cycle method, where we initialize the
    **Context** variable. After the initial configurations, we utilize the **SetFieldCssClassProvider()**
    extension method of **EditContext** to configure **Context** to employ our **TypeValidationClassProvider**
    for resolving CSS classes based on field validation. Our custom styling logic
    is now in place.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve implemented a custom CSS validation class and leveraged the CSS isolation
    feature that Blazor offers. However, if you have already integrated a CSS framework
    into your application, you can simply use the validation classes the framework
    provides instead of creating custom ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bootstrap, being the most common CSS framework to date, offers **border** and
    **border-warning** CSS classes, which you can use to highlight invalid input fields.
    Navigate to **TypeValidationClassProvider** and update the **GetFieldCssClass()**
    implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The custom validation logic remains intact – we still check whether the validation
    context is valid and whether the validated field refers to the capacity. However,
    when the custom validation fails, instead of returning the custom warning class,
    we leverage the **border border-warning** classes combination and effectively
    delegate the styling to Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a toast when validation fails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore how to enhance form validation feedback with a custom
    display of validation errors. Blazor’s **ValidationSummary** component provides
    a straightforward way to collect and display all validation messages from a form
    in a single container, typically rendered as a simple **div** . While functional,
    this default presentation might not always align with a desired user experience
    or the aesthetic standards of your application. You can replace the standard **ValidationSummary**
    component with a custom implementation to make validation messages more engaging
    and fit seamlessly with the broader notification strategy of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a custom component that displays validation errors inside a
    default Bootstrap toast, making a more modern version of **ValidationSummary**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the implementation of a custom validation summary, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter07** / **Recipe06** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Event** , **EventLocation** , **EventManager** , **EventNameValidationAttribute**
    , and **TypeValidationClassProvider** from the *Styling validation messages* recipe
    or from the **Chapter07** / **Recipe05** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to introduce a custom validation summary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **ValidationToast** component that implements the **IDisposable**
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **@code** block of the **ValidationToast** component, declare a
    **CascadingParameter** parameter of type **EditContext** and an **IsDisplayed**
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement a **Rerender()** method, matching
    the signature of a subscriber of an **EventHandler<ValidationStateChangedEventArgs>**
    handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside **Rerender()** , set the **IsDisplayed** property based on whether there
    are any validation messages in **Context** and invoke the **StateHasChanged()**
    to trigger a UI refresh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below **Rerender()** , override the **OnInitialized()** life cycle method and
    subscribe to the **OnValidationStateChanged** event of **EditContext** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the **@code** block by implementing the **Dispose()** method and unsubscribe
    from the **OnValidationStateChanged** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **ValidationToast** markup, below the **@implements** directive, include
    a fast-return clause to prevent any markup rendering based on the **IsDisplayed**
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the fast-return clause, construct a frame of a default Bootstrap toast
    notification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the toast area, add an empty header for aesthetics, and in the toast
    body, implement logic to dynamically render the list of validation messages retrieved
    from **EditContext** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **EventManager** component, above the form submit button, and
    remove the existing **ValidationSummary** paragraph. Replace it with an instance
    of the new **ValidationToast** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a new **ValidationToast** component that implements
    the **IDisposable** interface to ensure a proper resource clean-up as we will
    work with an event handler.
  prefs: []
  type: TYPE_NORMAL
- en: From *step 2* , we work on the **@code** block of the **ValidationToast** component.
    We declare a **CascadingParameter** parameter of type **EditContext** to gain
    access to the parent form’s context. We also declare an **IsDisplayed** property,
    which will help us control the visibility of the toast based on validation results.
    In *step 3* , we initialize a **Rerender** method, accepting the **sender** parameter
    and **args** of type **ValidationStateChangedEventArgs** , so we can subscribe
    it later to a matching **EventHandler** . In *step 4* , we implement the **Rerender**
    logic, where we determine whether there are any validation messages in the **Context**
    instance and set the **IsDisplayed** property, indicating that there are errors
    to display. We then invoke **StateHasChanged()** to prompt Blazor to refresh the
    UI and reflect the updated state. In *step 5* , we override the **OnInitialized()**
    life cycle method to subscribe the **Rerender()** method to the **OnValidationStateChanged**
    event of **EditContext** . Blazor will execute **Rerender()** every time the form’s
    validation state changes, allowing our toast notification to update reactively.
    In *step 6* , we implement the **Dispose()** method, where we unsubscribe from
    the **OnValidationStateChanged** event, ensuring that **ValidationToast** does
    not continue to react to events after it has been removed from the UI, thus preventing
    memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we focus on the markup of **ValidationToast** . We start below
    the **@implements** directive with a fast-return clause, based on the **IsDisplayed**
    value, which instructs Blazor to immediately exit the rendering process when there
    are no validation messages. In *step 8* , we construct a visual frame using default
    Bootstrap classes to create a toast notification. As it’s standard Bootstrap code,
    we won’t analyze it deeply. Shortly, we position the frame fixed at the bottom
    end of the viewport, ensuring that it is visible but non-intrusive. We also make
    the toast red to clearly indicate that there’s a problem. In *step 9* , we implement
    the toast area. We add an empty header for visual balance and a body where we
    iterate over the result of the **Context.GetValidationMessages()** call and dynamically
    render each validation message.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in *step 10* , we jump to the **EventManager** component. Here, we remove
    the existing **ValidationSummary** paragraph and replace it with the new **ValidationToast**
    component, which now handles the display of validation messages in a more interactive
    and visually engaging manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We arrive at a still simple but more modern validation summary that our users
    will appreciate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Toast notification replacing a standard validation summary container](img/B22020_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Toast notification replacing a standard validation summary container'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling a submit option based on the form state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we dive into a strategy to enhance the user experience by dynamically
    controlling the state of the form’s submit button. We use forms not only when
    creating a new object but also when modifying an existing one as well. It makes
    sense that we would prevent the form submission when a user didn’t make any changes
    or if some input is invalid. Having that feature in place, we improve the user
    experience, conserve memory usage, and reduce unnecessary server requests.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enhance a form with a mechanism that enables form saving only when there
    have been changes to the form data and all inputs are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before making the form submit button react to the form state, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter07** / **Recipe07** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Event** , **EventLocation** , **EventManager** , **EventNameValidationAttribute**
    , **TypeValidationClassProvider** , and **ValidationToast** from the *Displaying
    toast when validation fails* recipe or from the **Chapter07** / **Recipe06** directory
    in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to make the form submit button reactive to the form state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **EventManager** component and update it to implement the **IDisposable**
    interface and to render mode in **InteractiveWebAssembly** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **@code** block of **EventManager** , introduce an **IsSubmittable**
    variable of type **bool** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the **@code** block, add a **FieldChanged()** method that conforms
    to the **EventHandler<FieldChangedEventArgs>** response pattern and resolve the
    form’s current state into the **IsSubmittable** variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **OnInitialized()** method, initiate a default value for the **Model**
    instance to simulate a data-editing scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the **OnInitialized()** method, subscribe the **FieldChanged()**
    method to the **OnFieldChanged** event, exposed by the **EditContext** API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the **IDisposable** implementation by adding a **Dispose()** method
    at the end of the **@code** block and unsubscribe **FieldChanged()** from the
    **OnFieldChanged** handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch to the **EventManager** markup and locate the submit button. Set the
    button’s **disabled** attribute to the negated value of the **IsSubmittable**
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we start by enhancing the interactivity of our form located in
    **EventManager** . We configure **EventManager** to render in an **InteractiveWebAssembly**
    mode, enabling component interactivity, and we declare that it will implement
    the **IDisposable** interface allowing a custom cleanup implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we move to the **@code** block of **EventManager** and declare
    an **IsSubmittable** variable that we will leverage in managing the state of the
    form’s submit button. In *step 3* , we implement a **FieldChanged()** method that
    takes the **sender** and **args** parameters of type **FieldChangedEventArgs**
    . Inside **FieldChanged()** , we utilize the **EditContext** API through the **Context**
    instance to dynamically evaluate the form’s state. We set the **IsSubmittable**
    variable by checking whether all form fields are valid, using **Context.Validate()**
    , and the form was modified, using **Context.IsModified()** . Given that this
    operation can affect the state of the form’s submit button, we call **StateHasChanged()**
    to notify Blazor that the UI might need updating.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we adjust how **EventManager** initializes. Instead of resetting
    the **Model** object to a new instance, we simulate editing an existing model
    by setting initial properties, reflecting a typical data-editing scenario. In
    *step 5* , as part of the initialization process, we also subscribe **FieldChanged()**
    to the **Context.OnFieldChanged** event handler. Blazor triggers **OnFieldChanged**
    whenever the form field’s value changes, ensuring our form responds to every edit.
    In *step 6* , we finalize the **IDisposable** implementation. We implement the
    **Dispose()** method, where we unsubscribe **FieldChanged()** from the **OnFieldChanged**
    event handler to prevent memory leaks and ensure that the **EventManager** component
    is disposed of gracefully when it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we jump to the **EventManager** markup to reflect our backend
    logic in the UI. We locate the form’s submit button and attach a **disabled**
    attribute, setting its value to the **IsSubmittable** negation. Whenever the user
    changes focus between fields in the form, we will recalculate the value of **IsSubmittable**
    – and since **IsSubmittable** indicates whether the user made changes and the
    form is in a valid state, negating this value determines when the submit button
    should be disabled, preventing unnecessary submission until all conditions for
    a valid and modified form are met.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**EditContext** in Blazor plays a crucial role in managing form states and
    validations but has some limitations. One significant caveat is that it does not
    track the initial state of model properties. **EditContext** monitors changes
    to input fields, marking them as modified when their values change. However, if
    the user reverts a field’s value to its original state, **EditContext** still
    considers it modified. This behavior can lead to scenarios where forms may incorrectly
    allow submission or display validation states because they do not recognize that
    the field value has returned to its initial state.'
  prefs: []
  type: TYPE_NORMAL
- en: To address this limitation and refine the behavior of form modifications, you
    must implement an equality comparer, inheriting from **IEqualityComparer<T>**
    to customize how equality for reference types is determined. Having an explicit
    comparison logic, we can persist the initial value of the model in an **_initialModel**
    variable and replace the standard **Context.IsModified()** check with an **_initialModel
    != Model** evaluation. Blazor will disable the submit button when the user’s input
    returns to the initial values, ensuring that the form is only submittable with
    actual changes.
  prefs: []
  type: TYPE_NORMAL
