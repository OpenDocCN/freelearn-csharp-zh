- en: Implementing Worker Services Using .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET Core实现工作服务
- en: The latest version of .NET Core includes a simple and convenient way to implement
    background processes. Moreover, starting from version 3.0, it is possible to create
    new projects using an out-of-the-box template for worker services. .NET worker
    services are suitable for multiple use cases. Furthermore, the increasing adoption
    of cloud technologies and distributed systems also involves event-driven communication
    between services, which requires the implementation of background processes. This
    chapter walks through some of the concepts and use cases of the worker services
    tools provided by ASP.NET Core. We will also have a look at how to integrate the
    worker service capabilities of ASP.NET Core to consume the `ItemSoldOut` event
    queue implemented in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core的最新版本包括一种简单方便的方式来实现后台进程。此外，从版本3.0开始，可以使用工作服务内置模板创建新项目。.NET工作服务适用于多种用例。此外，随着云计算技术和分布式系统的日益普及，也涉及到服务之间的事件驱动通信，这需要实现后台进程。本章将介绍ASP.NET
    Core提供的工作服务工具的一些概念和用例。我们还将探讨如何将ASP.NET Core的工作服务功能集成到消耗上一章中实现的`ItemSoldOut`事件队列中。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Introduction to worker services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作服务简介
- en: Implementing a worker service using .NET Core
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET Core实现工作服务
- en: Deploying and running a worker on Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker上部署和运行工作服务
- en: Extending the background services class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展背景服务类
- en: By the end of this chapter, you will be able to implement a worker service and
    deploy it using Docker container technology.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够实现工作服务并使用Docker容器技术部署它。
- en: Introducing worker services
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作服务介绍
- en: .NET Core worker services can be really useful every time we need to perform
    a repetitive or background-running operation. In more detail, they can be used
    in the application layer to enable asynchronous operations and handle the events
    of an event-based architecture. If every time you need to publish or listen for
    a message, you need to refresh data based on a schedule, or your application needs
    to queue a background work item, then you should probably use a worker service.
    Furthermore, with worker services, it is possible to run multiple background tasks
    on the same server without consuming a lot of resources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core工作服务在每次需要执行重复或后台运行的操作时都非常有用。更详细地说，它们可以在应用层中使用，以启用异步操作并处理基于事件的架构的事件。如果你每次需要发布或监听消息时都需要根据计划刷新数据，或者你的应用程序需要排队一个后台工作项，那么你可能需要使用工作服务。此外，使用工作服务，可以在同一服务器上运行多个后台任务，而不会消耗大量资源。
- en: The foundation of worker services in .NET Core is the `IHostedService` interface.
    The out-of-the-box worker service template can be used as a guideline to start
    implementing our worker service project. More importantly, the `IHostedService`
    interface is implemented by a `BackgroundService` class, which is the base class
    we should extend to implement our worker service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core中工作服务的基础是`IHostedService`接口。内置的工作服务模板可以作为开始实现我们的工作服务项目的指南。更重要的是，`IHostedService`接口由一个`BackgroundService`类实现，这是我们实现工作服务时应扩展的基类。
- en: Understanding the worker services life cycle
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解工作服务生命周期
- en: '.NET Core uses the definition of the `BackgroundService` class to identify
    a worker service. The `BackgroundService` class exposes three methods that represent
    the life cycle stages of the worker service:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core使用`BackgroundService`类的定义来识别工作服务。`BackgroundService`类公开了三个方法，这些方法代表了工作服务的生活周期阶段：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is the abstract implementation of the `BackgroundService`
    class. The class implements both the `IHostedService` and `IDisposable` interfaces,
    and it exposes the following methods:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`BackgroundService`类的抽象实现。该类实现了`IHostedService`和`IDisposable`接口，并公开了以下方法：
- en: The `StartAsync` method represents the first stage of the life cycle of the
    worker. This method is called when the host is ready to run the worker service.
    It accepts a `CancellationToken` type parameter, which can be used to cancel the
    running task.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartAsync`方法代表了工作生活周期的第一阶段。当宿主准备好运行工作服务时，会调用此方法。它接受一个`CancellationToken`类型参数，该参数可用于取消正在运行的任务。'
- en: The `ExecuteAsync` method contains the core implementation of the `BackgroundService`
    class. This method is called once the `IHostedService` starts, and it returns
    a `Task` type that represents the status of the `Task`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecuteAsync` 方法包含 `BackgroundService` 类的核心实现。该方法在 `IHostedService` 启动后调用，并返回一个表示
    `Task` 状态的 `Task` 类型。'
- en: The `StopAsync` method is called when the hosted application is stopped gracefully.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当托管应用程序优雅地停止时，会调用 `StopAsync` 方法。
- en: This section provided an overview of the worker service life cycle methods.
    In the next section, we will see the hosting models available for the worker services
    in .NET Core.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了工作服务生命周期方法的概述。在下一节中，我们将看到 .NET Core 中可用于工作服务的托管模型。
- en: Hosting models
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管模型
- en: The .NET Core worker template is nothing more than a common .NET Core app. Furthermore,
    we can run the worker template as a common console application. Besides, the worker
    template also provides the hosting APIs to run the worker as an always-running
    process. In the case of Windows, it is possible to run the worker using Windows
    services technology. In the case of Linux, the worker runs using `systemd`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 工作模板不过是一个普通的 .NET Core 应用程序。此外，我们还可以将工作模板作为普通的控制台应用程序运行。此外，工作模板还提供了托管
    API，以便将工作作为始终运行的过程运行。在 Windows 系统中，可以使用 Windows 服务技术运行工作。在 Linux 系统中，工作通过 `systemd`
    运行。
- en: 'Furthermore, .NET Core provides two different NuGet packages to specify the
    host behavior of the worker: the `Microsoft.Extensions.Hosting.WindowsServices`
    package and the `Microsoft.Extensions.Hosting.Systemd` package, both available
    on NuGet.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，.NET Core 提供了两个不同的 NuGet 包来指定工作的工作行为：`Microsoft.Extensions.Hosting.WindowsServices`
    包和 `Microsoft.Extensions.Hosting.Systemd` 包，这两个包都在 NuGet 上可用。
- en: The `Microsoft.Extensions.Hosting.WindowsServices` package provides an extension
    method called `UseWindowsService()`, which can be applied after the initialization
    of the host in the `Main` method of the `Program` class. The `UseWindowsService()`
    method sets `WindowsServiceLifetime` and uses the *Windows event log* as the default
    logging output.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Hosting.WindowsServices` 包提供了一个名为 `UseWindowsService()`
    的扩展方法，该方法可以在 `Program` 类的 `Main` 方法中初始化托管之后应用。`UseWindowsService()` 方法设置 `WindowsServiceLifetime`
    并使用 *Windows 事件日志* 作为默认的日志输出。'
- en: If we choose to host our worker as a `systemd` service, we need to use the `Microsoft.Extensions.Hosting.Systemd`
    NuGet package. This package provides the `UseSystemd()` method, which can be applied
    in the same way as `UseWindowsService()`; in this case, our worker service will
    use the `SystemdLifetime` class, and it configures the logging to be compliant
    with the `systemd` format.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择将我们的工作作为 `systemd` 服务托管，我们需要使用 `Microsoft.Extensions.Hosting.Systemd`
    NuGet 包。此包提供了 `UseSystemd()` 方法，它可以像 `UseWindowsService()` 一样应用；在这种情况下，我们的工作服务将使用
    `SystemdLifetime` 类，并配置日志以符合 `systemd` 格式。
- en: It is important to note that both the `UseWindowsService()` and `UseSystemd()`
    methods are executed only if the worker service is running respectively as a Windows
    service and a `systemd` service.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`UseWindowsService()` 和 `UseSystemd()` 方法仅在作为 Windows 服务和 `systemd`
    服务运行的工作服务上执行。
- en: Once we have discovered the different ways to host the worker service, we can
    proceed by applying these concepts to the concrete of a health-check process.
    Besides, we will also see how to run the worker on a Docker container.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们发现了托管工作服务的方法，我们就可以通过将这些概念应用到具体的健康检查过程中来继续操作。此外，我们还将看到如何在 Docker 容器上运行工作。
- en: Implementing a health-checking worker
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现健康检查工作
- en: The following section focuses on the implementation of a worker service. The
    use case we will cover is a health-checking worker of a generic web service. Furthermore,
    let's suppose that we want to check the health status of one of our web services
    regularly. This kind of check is usually performed at the end of the deployment
    pipeline, or once a service is deployed, to verify that the web service is up
    and running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分重点介绍工作服务的实现。我们将涵盖的用例是一个通用 Web 服务的健康检查工作。此外，假设我们想要定期检查我们 Web 服务的健康状态。这种检查通常在部署管道的末尾执行，或者一旦服务部署，以验证
    Web 服务是否正在运行。
- en: Project structure overview
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构概述
- en: 'This section gives you an overview of the worker template project provided
    out of the box by the .NET Core templating system. We will use this type of project
    to implement a health-check worker. First of all, let''s start by creating a new
    project using the following CLI command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为您概述了.NET Core模板系统提供的开箱即用的工作模板项目。我们将使用此类项目来实现一个健康检查工作。首先，让我们使用以下CLI命令创建一个新的项目：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command creates a new folder called `HealthCheckWorker` and it creates
    all of the files needed by a basic worker service project. Let's have a look at
    the files created by the template `dotnet new worker` command executed previously.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了一个名为`HealthCheckWorker`的新文件夹，并创建了基本工作服务项目所需的所有文件。让我们看看之前执行的`dotnet new
    worker`模板命令创建的文件。
- en: 'Secondly, we can run the `tree` CLI command (available both on macOS X and
    Windows), which shows the folder structure of the project previously created:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以运行`tree` CLI命令（在macOS X和Windows上均可用），该命令显示了之前创建的项目文件夹结构：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Program.cs` file is the entry point of our worker service. As the `webapi`
    template, the worker template uses the `Program.cs` file to initialize and retrieve
    a new `IHostBuilder` instance by calling the `Host.CreateDefaultBuilder` and `ConfigureServices`
    methods. The `Main` static method in the `Program.cs` file initializes a list
    of workers using the `AddHostedService` extension method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs`文件是我们工作服务的入口点。与`webapi`模板一样，工作模板使用`Program.cs`文件通过调用`Host.CreateDefaultBuilder`和`ConfigureServices`方法来初始化和检索一个新的`IHostBuilder`实例。`Program.cs`文件中的`Main`静态方法使用`AddHostedService`扩展方法初始化一系列工作：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As previously mentioned, the preceding snippet of code uses `AddHostedService`
    to initialize the `Worker` class created as a part of the default worker template.
    It is necessary to notice that, under the hood, `AddHostedService` initializes
    the class with a `Singleton` life cycle. Therefore, we will have one instance
    of the worker for the whole execution time of the worker service. In the next
    section, we will go deep into the life cycle execution of a worker.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前面的代码片段使用`AddHostedService`初始化作为默认工作模板的一部分创建的`Worker`类。需要注意的是，在底层，`AddHostedService`使用`Singleton`生命周期初始化类。因此，在整个工作服务执行期间，我们将有一个工作实例。在下一节中，我们将深入探讨工作生命周期的执行。
- en: 'Another major characteristic that distinguishes a worker project from any other
    .NET Core project is the use of the `Microsoft.NET.Sdk.Worker` SDK. Furthermore,
    we should also notice that the `*.csproj` file refers to only one additional NuGet
    package that provides the hosting extension methods used by the `Program` class
    and the `Main` method: `Microsoft.Extensions.Hosting`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将工作项目与其他任何.NET Core项目区分开来的主要特征是使用了`Microsoft.NET.Sdk.Worker` SDK。此外，我们还应该注意到，`*.csproj`文件仅引用了一个额外的NuGet包，该包提供了`Program`类和`Main`方法使用的宿主扩展方法：`Microsoft.Extensions.Hosting`。
- en: 'The next step is to create a new class that represents the configurations of
    the `HealthCheckWorker` project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个新的类，该类代表`HealthCheckWorker`项目的配置：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`HealthCheckSettings` will contain two attributes: the `Url` and `IntervalMs`
    attributes. The first attribute contains the HTTP URL of the health check address,
    specified in `appsettings.json`*.* The `IntervalMs` attribute represents the frequency
    life cycle (in milliseconds) of the worker.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`HealthCheckSettings`将包含两个属性：`Url`和`IntervalMs`属性。第一个属性包含健康检查地址的HTTP URL，该URL在`appsettings.json`中指定。`IntervalMs`属性表示工作生命周期的频率（以毫秒为单位）。'
- en: 'Furthermore, it is possible to use the configuration system of .NET Core to
    bind our configuration object at the execution of the `Main` method of the `Program.cs`
    file, using the following approach:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以使用.NET Core的配置系统在`Program.cs`文件的`Main`方法执行时绑定我们的配置对象，方法如下：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code uses `hostContext` to retrieve the `Configuration` instance
    provided by .NET Core. By default, `hostContext` will be populated with the settings
    structure written in the `appsettings.json` file. Moreover, it is possible to
    use the `GetSection` method to retrieve the specific configuration section from
    our `appsettings.json` file and bind it to the `HealthCheckSettings` type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`hostContext`检索.NET Core提供的`Configuration`实例。默认情况下，`hostContext`将填充`appsettings.json`文件中编写的设置结构。此外，可以使用`GetSection`方法从我们的`appsettings.json`文件中检索特定的配置部分，并将其绑定到`HealthCheckSettings`类型。
- en: 'After that, we can proceed with the concrete implementation of the `Worker`
    class. Furthermore, we are now able to inject the `HealthCheckSettings` type instance
    using the built-in dependency injection of .NET Core. The settings are injected
    using the `IOption` interface:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以继续进行`Worker`类的具体实现。此外，我们现在能够使用.NET Core的内置依赖注入来注入`HealthCheckSettings`类型实例。设置是通过`IOption`接口注入的：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code defines the attributes of the `Worker` class. As mentioned,
    the class implements an `_settings` attribute of the `HealthCheckSettings` type
    initialized using the constructor injection technique. Moreover, we can also see
    an `HttpClient` attribute, which will be initialized by the `StartAsync` method
    exposed by the `BackgroundService` class, and it is used in the `ExecuteAsync`
    method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了`Worker`类的属性。正如所述，该类实现了一个使用构造函数注入技术初始化的`_settings`属性，我们还可以看到一个`HttpClient`属性，它将由`BackgroundService`类公开的`StartAsync`方法初始化，并在`ExecuteAsync`方法中使用：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the initialization of the client, the `ExecuteAsync` method implements
    a `while` loop that will continue until the `stoppingToken` requests the cancellation
    of the process. The core part of the loop uses the `GetAsync` method of `HttpClient`
    to check whether the health check route returns an HTTP status message. Finally,
    the code calls `Task.Delay` with the `IntervalMs` property populated with the
    `_settings` instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端初始化之后，`ExecuteAsync`方法实现了一个`while`循环，该循环将持续到`stoppingToken`请求取消进程。循环的核心部分使用`HttpClient`的`GetAsync`方法检查健康检查路由是否返回HTTP状态消息。最后，代码调用`Task.Delay`并使用填充了`_settings`实例的`IntervalMs`属性。
- en: 'As the last step, the `Worker` class overrides the `StopAsync` method exposed
    by the `BackgroundService` class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，`Worker`类覆盖了由`BackgroundService`类公开的`StopAsync`方法：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `StopAsync` method executes the `HttpClient` instance disposition by calling
    the `Dispose()` method, and it calls `base.StopAsync(cancellationToken)` of the
    base `BackgroundService` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopAsync`方法通过调用`Dispose()`方法执行`HttpClient`实例的处置，并调用基类`BackgroundService`的`StopAsync(cancellationToken)`。'
- en: We should notice that the `StartAsync` and `StopAsync` methods always call the
    parent methods using the `base` keyword. Furthermore, in our case, we need to
    hold the behavior of the base `BackgroundService` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，`StartAsync`和`StopAsync`方法总是使用`base`关键字调用父方法。此外，在我们的情况下，我们需要保持基类`BackgroundService`类的行为。
- en: The next part of this chapter will be focused on the execution of the worker
    on a Docker container. We will see how to configure the `Dockerfile`, and deploy
    and run the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一部分将专注于在Docker容器上执行工作。我们将看到如何配置`Dockerfile`，以及部署和运行应用程序。
- en: Running a worker service on Docker
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker上运行工作服务
- en: This section is focused on the deployment step of the .NET worker template.
    We will proceed by running our service on a Docker Linux image. As we have already
    seen in [Chapter 12](d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml), *The Containerization
    of Services*, we will use Docker to run the application in a container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本节专注于.NET工作模板的部署步骤。我们将通过在Docker Linux镜像上运行我们的服务来继续操作。正如我们在[第12章](d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml)，“服务的容器化”中已经看到的，我们将使用Docker在容器中运行应用程序。
- en: 'Let''s start by configuring the `Dockerfile` in the project folder:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从配置项目文件夹中的`Dockerfile`开始：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code describes the container build and deployment process for
    our .NET Core worker application. The `Dockerfile` instructions can be grouped
    into five steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码描述了我们的.NET Core工作应用程序的容器构建和部署过程。`Dockerfile`指令可以分为五个步骤：
- en: 'The first step executes the build of the project using the `dotnet/core/sdk`
    Docker image:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步使用`dotnet/core/sdk` Docker镜像执行项目的构建：
- en: First of all, it sets the working directory as `/src` and copies the files in
    the project folder.
  id: totrans-60
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它将工作目录设置为`/src`并将项目文件夹中的文件复制过来。
- en: Secondly, it executes the `dotnet restore` and `dotnet build` commands.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它执行了`dotnet restore`和`dotnet build`命令。
- en: The second step runs the `dotnet publish` command using the `Release` configuration
    in the `/app/publish` folder.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步在`/app/publish`文件夹中使用`Release`配置运行`dotnet publish`命令。
- en: The third step uses the `dotnet/core/runtime` Docker image to run the result
    of the previously executed `dotnet publish` using the `dotnet` CLI command.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步使用`dotnet/core/runtime` Docker镜像，通过`dotnet` CLI命令运行之前执行过的`dotnet publish`的结果。
- en: 'It is possible to build the Docker image using the following command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下命令构建Docker镜像：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Furthermore, we can run the previously built image using the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们可以使用以下命令运行之前构建的镜像：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command runs the Docker container and, consequently, the worker
    service process. The worker service will perform an HTTP `GET` request to the
    URL configured in the `appsettings.json` file of the project by applying throttling,
    also specified in the `appsettings.json` file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将运行 Docker 容器，从而运行工作服务进程。工作服务将通过应用节流（也在 `appsettings.json` 文件中指定），向项目配置的
    URL 发送 HTTP `GET` 请求。
- en: The previously mentioned `Dockerfile` uses a multi-stage build approach and
    some other techniques to build the Docker image used to run the project. These
    concepts, and more, are described in detail in [Chapter 12](d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml),
    *The* *Containerization of Services*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的 `Dockerfile` 使用了多阶段构建方法和其他一些技术来构建用于运行项目的 Docker 镜像。这些概念以及更多内容在 [第 12 章](d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml)，*服务的容器化*中详细描述。
- en: Consuming the sold-out event
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费售罄事件
- en: The sold-out event we implemented in [Chapter 13](8f70e186-50f1-4d55-99e6-026c73d5bb96.xhtml),
    *Service Ecosystem Patterns,* provides the information on the items that are not
    available in the catalog. Furthermore, we can consume this event through the use
    of the `BackgroundService` type capabilities we described in this chapter. The
    cart service will implement a sold-out handler that will handle and remove the
    item IDs that are not available from the Redis instance.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 13 章](8f70e186-50f1-4d55-99e6-026c73d5bb96.xhtml)，*服务生态系统模式*中实现的售罄事件，提供了关于目录中不可用项目的信息。此外，我们可以通过使用本章中描述的
    `BackgroundService` 类型功能来消费此事件。购物车服务将实现一个售罄处理程序，用于处理和从 Redis 实例中删除不可用的项目 ID。
- en: Creating a sold-out handler
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建售罄处理程序
- en: 'Let''s start by creating a handler that manages the sold-out condition of a
    product in the cart service. First of all, we should proceed by adding the `RabbitMQ.Client`
    package to the `Cart.Domain` project by executing the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在购物车服务中创建一个处理程序来管理产品的售罄状态。首先，我们应该通过执行以下命令将 `RabbitMQ.Client` 包添加到 `Cart.Domain`
    项目中：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can continue by defining a class that represents the sold-out event that''s
    used by the cart service in a new project that will contain all of the events.
    Therefore, we will proceed by creating a new `ItemSoldOutEvent` type, which represents
    a sold-out event:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续定义一个类来表示购物车服务在新的项目中使用的售罄事件。因此，我们将创建一个新的 `ItemSoldOutEvent` 类型，它代表一个售罄事件：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `ItemSoldOutEvent` type contains a reference to `Id` of the item that''s
    sold out. The type will be used to deserialize the content of the queue into a
    strongly typed instance and send a message through the MediatR instance. As we
    did for the configurations of the catalog service, we will also need an analog
    class that represents the RabbitMQ configurations in the `Cart.Infrastructure`
    project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemSoldOutEvent` 类型包含对售罄项目的 `Id` 的引用。该类型将用于将队列内容反序列化为强类型实例并通过 MediatR 实例发送消息。正如我们对目录服务的配置所做的那样，我们还需要在
    `Cart.Infrastructure` 项目中有一个表示 RabbitMQ 配置的类似类：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `EventBusSettings` type defined previously describes `HostName` of the
    RabbitMQ instance, `User` and `Password` of the user, and the `EventQueue` name
    to use to push messages. Furthermore, we can proceed by defining the mediator
    handler for consuming the `ItemSoldOutEvent` events by defining a new class in
    the `Cart.Domain` project:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的 `EventBusSettings` 类型描述了 RabbitMQ 实例的 `HostName`、用户的 `User` 和 `Password`
    以及用于推送消息的 `EventQueue` 名称。此外，我们可以通过在 `Cart.Domain` 项目中定义一个新的类来定义消费 `ItemSoldOutEvent`
    事件的调解处理程序：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous `ItemSoldOutEventHandler` class implements the `IRequestHandler<T>`
    interface that's provided by the MediatR package. This interface contains the
    `Handle` method, which is the main entry point of the handler. A new `ItemSoldOutEventHandler`
    instance will be executed when an event of the `ItemSoldOutEvent` type is received
    by the cart service. `ItemSoldOutEventHandler` depends on `ICartRepository`. Furthermore,
    the `RemoveItemsInCart` method retrieves all of the carts stored in our repository,
    and it removes the sold-out items every time it receives a message of the `ItemSoldOutEvent`
    type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `ItemSoldOutEventHandler` 类实现了由 MediatR 包提供的 `IRequestHandler<T>` 接口。该接口包含
    `Handle` 方法，这是处理程序的主要入口点。当购物服务接收到 `ItemSoldOutEvent` 类型的事件时，将执行一个新的 `ItemSoldOutEventHandler`
    实例。`ItemSoldOutEventHandler` 依赖于 `ICartRepository`。此外，`RemoveItemsInCart` 方法检索我们存储库中所有存储的购物车，并在每次接收到
    `ItemSoldOutEvent` 类型的消息时移除售罄的商品。
- en: Testing the sold-out process
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试售罄过程
- en: 'It is possible to check the sold-out process by testing `ItemSoldOutHandler`.
    The handler will be tested with the same approach we saw for the other handlers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过测试 `ItemSoldOutHandler` 来检查售罄过程。处理程序将使用与其他处理程序相同的测试方法进行测试：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `ItemSoldOutEventHandlerTests` class uses the `CartContextFactory` class
    to initialize a new repository in each test method using the `_contextFactory.GetCartRepository();`
    method. Furthermore, the `should_not_remove_records_when_soldout_message_contains_not_existing_id`
    test method checks that nothing breaks if the `ItemSoldOutEvent` instance has
    a non-existent ID. On the other hand, the `should_remove_records_when_soldout_messages_contains_existing_ids`
    test method checks that `ItemSoldOutEventHandler` deletes the item in the basket
    when the `ItemSoldOutEvent` instance contains an existing ID:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemSoldOutEventHandlerTests` 类使用 `CartContextFactory` 类在测试方法的每个测试中初始化一个新的存储库，使用
    `_contextFactory.GetCartRepository();` 方法。此外，`should_not_remove_records_when_soldout_message_contains_not_existing_id`
    测试方法检查如果 `ItemSoldOutEvent` 实例具有不存在的 ID，则不会出现任何问题。另一方面，`should_remove_records_when_soldout_messages_contains_existing_ids`
    测试方法检查当 `ItemSoldOutEvent` 实例包含现有 ID 时，`ItemSoldOutEventHandler` 是否会删除篮子中的商品：'
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The second test method provides an existing item ID and verifies the handle
    method by checking whether the process has effectively removed the items. Now
    that we have verified the behavior of `ItemSoldOutHandler`, we can proceed by
    configuring and registering the event bus instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试方法提供了一个现有的商品 ID，并通过检查过程是否有效地移除了商品来验证处理方法。现在我们已经验证了 `ItemSoldOutHandler`
    的行为，我们可以继续配置和注册事件总线实例。
- en: Configuring the background service
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置后台服务
- en: 'Now that we have defined the event bus abstraction, we can proceed by creating
    a new `BackgroundService` type that will use the `IMediator` interface to dispatch
    the sold-out messages. This book uses RabbitMQ because it is open source and easy
    to configure but keep in mind that there are tons of products and technologies
    related to this topic. Before continuing with the implementation of the background
    service, it is necessary to add some packages to the `Cart.Infrastructure` project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了事件总线抽象，我们可以创建一个新的 `BackgroundService` 类型，该类型将使用 `IMediator` 接口来分发售罄消息。本书使用
    RabbitMQ，因为它开源且易于配置，但请记住，与此主题相关的产品和技术有成千上万种。在继续实现后台服务之前，有必要向 `Cart.Infrastructure`
    项目添加一些包：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Furthermore, we can proceed by creating a new class that extends the `BackgroundService`
    type:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过创建一个新的类来扩展 `BackgroundService` 类型：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding snippet defines the `ItemSoldOutBackgroundService` type. The
    class extends the `BackgroundService` base class exposed by the `Microsoft.Extensions.Hosting`
    namespace. The constructor injects the `IMediator` interface to dispatch the collected
    events to the `ItemSoldOutEventHandler` type. Furthermore, it also defines the
    attribute of the `IModel` type that will be populated by the `ConnectionFactory`
    type injected in the constructor. The `_channel` attribute will be used by the
    `ExecuteAsync` method provided by the `BackgroundService` class to dispatch the
    events. Let''s proceed by overriding the `ExecuteAsync` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段定义了 `ItemSoldOutBackgroundService` 类型。该类扩展了由 `Microsoft.Extensions.Hosting`
    命名空间公开的 `BackgroundService` 基类。构造函数注入 `IMediator` 接口以将收集的事件分发给 `ItemSoldOutEventHandler`
    类型。此外，它还定义了将由构造函数中注入的 `ConnectionFactory` 类型填充的 `IModel` 类型的属性。`_channel` 属性将由
    `BackgroundService` 类提供的 `ExecuteAsync` 方法使用，以分发事件。让我们通过重写 `ExecuteAsync` 方法来继续：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding snippet uses the `_channel` attribute to initialize a new `EventingBasicConsumer`
    instance. For each received message, it deserializes the `Body` attribute into
    an `ItemSoldOutEvent` type and it sends the event to the `IMediator` instance
    using the `Send` method. Finally, it activates the consuming process by using
    the `EventQueue` name provided by the `EventBusSettings` type. Also, in this case,
    the consumption process is wrapped using a try-catch to isolate the process in
    the event of failure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用 `_channel` 属性初始化一个新的 `EventingBasicConsumer` 实例。对于每个接收到的消息，它将 `Body`
    属性反序列化为 `ItemSoldOutEvent` 类型，并使用 `Send` 方法将事件发送到 `IMediator` 实例。最后，它通过使用 `EventBusSettings`
    类型提供的 `EventQueue` 名称激活消费过程。此外，在这种情况下，消费过程被 try-catch 包装，以便在发生失败时隔离过程。
- en: 'Before we can use RabbitMQ, it is necessary to configure the client so that
    we connect to the right event bus instance. Let''s start by creating a new extension
    method in the `Cart.Infrastructure` project, which can be found under the `Extensions`
    folder:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用 RabbitMQ 之前，有必要配置客户端以便我们连接到正确的消息总线实例。让我们首先在 `Cart.Infrastructure` 项目中创建一个新的扩展方法，这个方法可以在
    `Extensions` 文件夹下找到：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous definition implements an extension method bound with the `IServiceCollection`
    interface, which is provided by the dependency injection system of ASP.NET Core.
    It is used in the `Startup` class to connect to RabbitMQ.The `AddEventBus` method
    initializes the `ConnectionFactory` class by passing the parameter of RabbitMQ.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的定义实现了一个与 `IServiceCollection` 接口绑定的扩展方法，该接口由 ASP.NET Core 的依赖注入系统提供。它在 `Startup`
    类中使用，以连接到 RabbitMQ。`AddEventBus` 方法通过传递 RabbitMQ 参数初始化 `ConnectionFactory` 类。
- en: 'Finally, we can proceed by activating the background service by adding the
    following extension methods to the `ConfigureServices` method of the `Startup`
    class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过向 `Startup` 类的 `ConfigureServices` 方法中添加以下扩展方法来激活后台服务：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `AddEventBus` method adds all of the dependencies needed by the consumption
    process of the sold-out events to the dependency injection. Also, the `AddHostedService`
    method registers `ItemSoldOutBackgroundService` as the `IHostedService` type.
    Finally, to use the event bus, we can proceed by defining the connection information
    in the `appsettings.json` file of the `Cart.API` project, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddEventBus` 方法将销售一空事件消费过程所需的全部依赖项添加到依赖注入中。此外，`AddHostedService` 方法将 `ItemSoldOutBackgroundService`
    注册为 `IHostedService` 类型。最后，为了使用消息总线，我们可以在 `Cart.API` 项目的 `appsettings.json` 文件中定义连接信息，如下所示：'
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The connection parameters point to the `catalog_esb` instance defined in the
    `docker-compose.yml` file defined in the catalog service. Furthermore, the `ItemSoldOutBackgroundService`
    class will process the message in the `ItemSoldOut` queue and trigger the removal
    of the items.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 连接参数指向在目录服务中定义的 `docker-compose.yml` 文件中定义的 `catalog_esb` 实例。此外，`ItemSoldOutBackgroundService`
    类将处理 `ItemSoldOut` 队列中的消息并触发移除商品。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter described how you can use the .NET Core worker template to implement
    a continuously running task. .NET Core workers are really useful in distributed
    systems to perform all of the asynchronous and event-based computations without
    an increase in the load of the server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了如何使用 .NET Core 工作模板实现持续运行的任务。.NET Core 工作者在分布式系统中非常有用，可以在不增加服务器负载的情况下执行所有异步和基于事件的计算。
- en: The integration with Windows services and `systemd` also provides an efficient
    way to deploy and to run the worker. This chapter has given you an overview of
    the .NET Core worker service hosting models, and it showed how to set up and implement
    a worker service using .NET Core and how to run it on Docker. Finally, we saw
    how to integrate the `BackgroundService` class capabilities with the previously
    implemented item sold-out message integration.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Windows 服务和 `systemd` 的集成也提供了一种高效的方式来部署和运行工作。本章为您概述了 .NET Core 工作服务托管模型，并展示了如何使用
    .NET Core 设置和实现工作服务以及如何在 Docker 上运行它。最后，我们看到了如何将 `BackgroundService` 类的功能与之前实现的销售一空消息集成相结合。
- en: The next chapter will cover some of the common security practices provided and
    implemented by .NET Core.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 .NET Core 提供并实现的常见安全实践。
