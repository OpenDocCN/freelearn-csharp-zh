- en: Best Practices in Coding C# 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you act as a software architect on a project, it is your responsibility
    to define and/or maintain a coding standard that will direct the team for programming
    according to the company's expectations. This chapter covers some of the best
    practices in coding that will help developers like you to program safe, simple,
    and maintainable software. It also includes tips and tricks for coding in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How the complexity of your code can affect performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of using a version control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing safe code in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET core tips and tricks for coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book use case – dos and don'ts in writing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the Visual Studio 2019 free community edition or better
    with all database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the sample code of this chapter here: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch14](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch14).
  prefs: []
  type: TYPE_NORMAL
- en: The more complex your code is, the worse a programmer you are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many people, a good programmer is one who writes complex code. However,
    the evolution of maturity in software development means there is a different way
    of thinking about it. The complexity does not mean a good job, it means poor code
    quality. Some incredible scientists and researchers confirm this theory and emphasize
    that professional code needs to be focused on time, of high quality, and within
    budget.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want to write good code, you need to keep the focus on how to do
    it, considering you are not the only one who will read it later. This is a good
    tip that changes the way you write code. This is how we will discuss each point
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your understanding of the importance of writing good code is aligned to
    the idea of simplicity and clarity while writing it, you should have to take a
    look at the Visual Studio tool Code Metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a548e09-2e4e-4060-8ca5-5127de261882.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Code Metrics tool will deliver metrics that will give you insights about
    the quality of the software you are delivering. The metrics that the tool provides
    are listed here and can be found at this link [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019):'
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyclomatic complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth of inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lines of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next subsections are focused on describing how they are useful in some real-life
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This index indicates how easy it is to maintain the code—the easier the code,
    the higher the index (limited to 100). Easy maintenance is one of the key points
    to keep software in good health. It is obvious that any software will require
    changes in the future since change is inevitable. For this reason, consider refactoring
    your code if you have low levels of maintainability. Writing classes and methods
    dedicated to a single responsibility, avoiding duplicate code, and limiting the
    number of lines of code of each method are examples of how you can improve the
    maintainability index.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclomatic complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The author of *Cyclomatic Complexity Metric* is Thomas J. McCabe. He defines
    the complexity of a software function according to the number of code paths available
    (graph nodes). The more paths you have, the more complex your function is. McCabe
    considers that each function must have a complexity score of less than 10\. That
    means that, if the code has more complex methods, you have to refactor it, transforming
    parts of these codes into separate methods. There are some real scenarios where
    this behavior is easily detected:'
  prefs: []
  type: TYPE_NORMAL
- en: Loops inside loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of consecutive `if`-`else`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch` with code processing for each `case` inside the same method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, look at the first version of this method for processing different
    responses of a credit card transaction. As you can check, the cyclomatic complexity
    is bigger than the number considered by McCabe as a basis. The reason why this
    happens is because of the number of `if`-`else` inside each case of the main `switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you calculate the code metrics of this code, you will find a really bad
    result when it comes to cyclomatic complexity, as you can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dec95161-0d4a-4ef0-88a4-792cb2b3233b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code itself makes no sense, but the point here is to show you the number
    of improvements that can be made in order to write better code:'
  prefs: []
  type: TYPE_NORMAL
- en: The options from the `switch`-`case` could be written using `Enum`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each case processing can be done in a specific method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch`-`case` can be substituted with `Dictionary<Enum, Method>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By refactoring this code with the preceding techniques, the result is a piece
    of code that is much easier to understand, as you can see in the following code
    snippet of its main method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The full code can be found on the GitHub of this chapter and presents how lower-complexity
    code can be achieved. The following screenshot shows these results according to
    code metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0691000-1cfc-4488-a125-15c82e9c080b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, there is a considerable reduction
    of complexity after refactoring. The key point here is that with the techniques
    applied, understanding of the code increased and the complexity decreased, proving
    the importance of cyclomatic complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Depth of inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This metric represents the number of classes connected to the one that is being
    analyzed. The more classes you have inherited, the worse your code is. This is
    similar to class coupling and indicates how difficult it is to change your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following screenshot has four inherited classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/828e2f8e-52f8-45a5-ac76-19070e1a90b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see in the following screenshot that the deeper class has the worse
    the metric, considering there are three other classes that can change its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f239b8f1-bc7d-4ce7-9a80-22a0f5ca5d10.png)'
  prefs: []
  type: TYPE_IMG
- en: Inheritance is one of the basic object-oriented analysis principles. However,
    it can sometimes be bad for your code in that it can cause dependencies. So, if
    it makes sense to do so, instead of using inheritance, consider using aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Class coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you connect too many classes in a single class, obviously you will get
    coupling and this can cause bad maintenance of your code. For instance, see the
    following screenshot. It shows a design where aggregation has been done a lot.
    There is no sense to the code itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd79f53e-2805-4269-8c15-49258676ba77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have calculated the code metrics for the preceding design, you will
    see that the number of class coupling instances for the `ProcessData()` method,
    which calls `ExecuteTypeA()`, `ExecuteTypeB()`, and `ExecuteTypeC()`, equals three
    (`3`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08c80647-eb51-4e25-acc8-b4a452472021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some papers indicate that the maximum number of class coupling instances should
    be nine (`9`). With aggregation being a better practice than inheritance, the
    use of interfaces will solve class coupling problems. For instance, the same code
    with the following design will give you a better result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6df17e5-e99d-4631-b42f-7660ef6121f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that using the interface in the design will allow you the possibility
    of increasing the number of execution types without increasing the Class Coupling
    of the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18cce1ea-bacd-46e0-b3a2-3d12c7e27009.png)'
  prefs: []
  type: TYPE_IMG
- en: As a software architect, you have to consider designing your solution to have
    more cohesion than coupling. The literature indicates that good software has low
    coupling and high cohesion. This is a basic principle that can guide you to a
    better architectural model.
  prefs: []
  type: TYPE_NORMAL
- en: Lines of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This metric is useful to make you understand the size of the code you are dealing
    with. There is no way to connect lines of code and complexity since the number
    of lines is not indicative of that. On the other hand, the lines of code show
    the software size and software design. For instance, if you have too many lines
    of code in a single class (more than 1,000 lines of code—1 KLOC), it indicates
    that it is a bad design.
  prefs: []
  type: TYPE_NORMAL
- en: Using a version control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may find this topic in this book a bit obvious, but many people and companies
    still do not consider having a version control system as a basic tool for software
    development! The idea of writing about it is to force you to understand it. There
    is no architectural model or best practice that can save software development
    if you do not use a version control system.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, we have been enjoying the advantages of online version
    control systems, such as GitHub, BitBucket, and Azure DevOps. The fact is, you
    have to have a tool like that in your software development life cycle and there
    is no reason to not have it anymore since most providers offer free versions for
    small groups. Even if you develop by yourself, these tools are useful for tracking
    your changes, managing your software versions, and guaranteeing the consistency
    and integrity of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with version control systems in teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of a version control system tool when you are alone is quite obvious.
    You want to keep your code safe. But this kind of system was definitely developed
    to solve team problems while writing code. For this reason, some features such
    as branching and merging were introduced to keep code integrity even in scenarios
    where the number of developers is quite big.
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you will have to decide which branch strategy you will
    conduct in your team. Azure DevOps and GitHub suggest different ways to deliver
    that, and both of them are useful in some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The information about how Azure DevOps team deals with it can be found here: [https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/).
    GitHub describes its process here: [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
    We have no idea about which is the one that best fits your needs, but we do want
    you to understand that you need to have a strategy for controlling your code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing safe code in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# can be considered a safe programming language by design. Unless you force
    it, there is no need for pointers, and memory release is, in most cases, managed
    by the garbage collector. Even so, some care should be taken so you can get better
    and safe results from your code. Let's have a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: try-catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exceptions in coding are so frequent that you may have a way to manage them
    whenever they happen. `try`-`catch` statements are built to manage these exceptions
    and they are really important to keeping your code safe. There are a lot of cases
    where an application crashes and the reason for that is the lack of using `try`-`catch`.
    The following code shows an example of the lack of usageof the `try`-`catch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, bad `try`-`catch` usage can cause damage to your code too,
    especially because you will not see the correct behavior of that code and may
    misunderstand the results provided. The following code shows an example of an
    empty `try`-`catch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`try`-`catch` statements must always be connected to logging solutions, so
    that you can have a response from the system that will indicate the correct behavior
    and, at the same time, will not cause application crashes. The following code
    shows an ideal `try`-`catch` statement with logging management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As a software architect, you should conduct code inspections to fix this kind
    of behavior found in the code. Instability in a system is often connected to the
    lack of try-catch statements in the code.
  prefs: []
  type: TYPE_NORMAL
- en: try-finally and using
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory leaks can be considered one of the worst behaviors of software. They
    cause instability, bad usage of computer resources, and undesired application
    crashes. C# tries to solve this with Garbage Collector, which automatically releases objects
    from memory as soon as it realizes the object can be freed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects that interact with I/O are the ones that generally are not managed
    by Garbage Collector: filesystem, sockets, and so on. The following code is a
    sample of wrong usage of `FileStream` object, because it considers the Garbage
    Collector will release the memory used, but it will not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides, it takes a while for Garbage Collector to interact with objects that
    need to be released and sometimes you may want to do it yourself. For both cases,
    the use of `try`-`finally` or `using` statements is the best practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows exactly how to deal with objects that are not managed
    by Garbage Collector. You have both `try`-`finally` and `using` being implemented.
    As a software architect, you do need to pay attention to this kind of code. The
    lack of `try`-`finally` or `using` statements can cause huge damage to software
    behavior when it is running.
  prefs: []
  type: TYPE_NORMAL
- en: The IDisposable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same way you will have trouble if you do not manage objects created inside
    a method with try-finally/using statements, objects created in a class that does
    not properly implement the `IDisposable` interface may cause memory leaks in your
    application. For this reason, when you have a class that deals with and creates
    objects, you should implement the disposable pattern to guarantee the release
    of all resources created by it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fdb7e0f-fca3-448f-afca-b3090c577a50.png)'
  prefs: []
  type: TYPE_IMG
- en: The good news is that Visual Studio gives you the code snippet to implement
    this interface by just indicating it in your code and right-clicking on the Quick
    Actions and refactorings option, as you can see in the preceding screenshot. Once
    you have the code inserted, you need to follow the TODO instructions so that you
    have the correct pattern implemented.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core tips and tricks for coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core implements some good features that help us to write better code. One
    of the most useful for having safer code is **dependency injection** (**DI**),
    which was already discussed in [Chapter 9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml),
    *Design Patterns and .NET Core Implementation*. There are some good reasons to
    consider this. The first one is because you will not need to worry about disposing
    of injected objects since you are not going to be the creator of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, DI enables you to inject `ILogger`, a really useful tool for debugging
    exceptions that will need to be managed by try-catch statements in your code. Furthermore,
    programming in C# with .NET Core must follow the common good practices of any
    programming language. The following list shows some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classes, methods, and variables should have understandable names**: The name
    should explain everything the reader needs to know. There should be no need for
    an explanatory comment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods cannot have high complexity levels**: Cyclomatic complexity should
    be checked so that methods do not have too many lines of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duplicate code should be avoided**: There is no reason for having duplicate
    code in a high-level programming language like C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects should be checked before usage**: Since null objects can exist, the
    code must have null-type checking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constants and enumerators should be used**: A good way for avoiding magic
    numbers and text inside code is transforming this information into constants and
    enumerators, which generally are more understandable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsafe code should be avoided**: Unless there is no other way to implement
    code, unsafe code should be avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**try-catch statements cannot be empty**: There is no reason for a `try`-`catch`
    statement without treatment in the `catch` area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**try-finally/using statements should always be used**: Even for objects where
    Garbage Collector will take care of the disposed-of object, consider disposing
    of objects that you were responsible for creating yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**At least public methods should be commented**: Considering that public methods
    are the ones used outside your library, they have to be explained for their correct
    external usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**switch-case statements must have a default treatment**: Since the `switch`-`case`
    statement may receive an entrance variable unknown in some cases, the default
    treatment will guarantee that the code will not break in such a situation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a software architect, a good practice is to provide your developers with
    a code pattern that will be used by all programmers as a way to keep the style
    of the code consistent. You can use a code pattern as a checklist for coding inspection,
    which will enrich software code quality.
  prefs: []
  type: TYPE_NORMAL
- en: WWTravelClub – dos and don'ts in writing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a software architect, you have to define a code standard that matches the
    needs of the company you are working for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sample project of this book (check out more about the WWTravelClub project
    in [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the
    Importance of Software Architecture*), this is no different. The way we decided
    to present the standard for it is describing a list of dos and don''ts that we
    followed while writing the samples we produced. It is worth mentioning that the
    list is a good way to start your standard and as a software architect, you should
    discuss this list with the developers you have in the team, so you can evolve
    it in a practical and good manner:'
  prefs: []
  type: TYPE_NORMAL
- en: DO write your code in English.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO follow C# coding standards with CamelCase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO write classes, methods, and variables with understandable names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO comment public classes, methods, and properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO use the `using` statement whenever possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO use `async` implementation whenever possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO ask for authorization before implementing unmanaged code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO ask for authorization before implementing threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DON'T write empty `try`*-*`catch` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DON'T write methods with more than a score of 10 of cyclomatic complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DON'T use `break` and `continue` inside `for`/`while`/`do`*-*`while`/`foreach`
    statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DON'T use `goto` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These dos and don'ts are simple to follow and, better than that, will yield
    great results for the code your team produces. In [Chapter 16](47fba7aa-d9c6-46ad-b16a-1719f0d906f8.xhtml), *Using
    Tools to Write Better Code*, we will discuss the tools to help you to implement
    these rules.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed during this chapter some important tips for writing safe code.
    This chapter introduced a tool for analyzing code metrics, so you can manage the
    complexity and maintainability of the software you are developing. To finish,
    we presented some good tips to guarantee your software will not crash due to memory
    leaks and exceptions. In real life, a software architect will always be asked
    to solve this kind of problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about some unit testing techniques, the principles
    of unit testing, and a software process model that focuses on C# test projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need to care about maintainability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is cyclomatic complexity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the advantages of using a version control system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `try`-`catch`, `try`-`finally`, and `try`-`catch`-`finally`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Garbage Collector?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the importance of implementing the `IDisposable` interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages do we get from .NET Core when it comes to coding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some books and websites where you will find more information about
    the topics of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Art of Designing Embedded Systems* by Jack G. Ganssle. Elsevier, 1999.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring: Improving the Design of Existing Code* by Martin Fowler. Addison
    Wesley, 1999.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Complexity Measure* by Thomas J. McCabe. IEEE Trans. Software Eng. 2(4): 308-320, 1976
    ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/](https://github.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://bitbucket.org/](https://bitbucket.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/](https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
