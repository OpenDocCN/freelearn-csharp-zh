<html><head></head><body>
<div id="_idContainer186">
<h1 class="chapter-number" id="_idParaDest-363"><a id="_idTextAnchor698"/><span class="koboSpan" id="kobo.1.1">17</span></h1>
<h1 id="_idParaDest-364"><a id="_idTextAnchor699"/><span class="koboSpan" id="kobo.2.1">Cloud-Native Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the preceding chapters, we have covered a range of fundamental skills for web API development using ASP.NET Core. </span><span class="koboSpan" id="kobo.3.2">We discussed different styles of API development, such as REST, gRPC, and GraphQL, and how to implement the data access layer using Entity Framework Core. </span><span class="koboSpan" id="kobo.3.3">We also introduced how to secure a web API using the ASP.NET Core Identity framework. </span><span class="koboSpan" id="kobo.3.4">Additionally, we learned how to write unit tests and integration tests for web API applications, as well as common practices for API development, such as testing, caching, observability, and more. </span><span class="koboSpan" id="kobo.3.5">We also discussed how to deploy the containerized web API application to the cloud by using CI/CD pipelines. </span><span class="koboSpan" id="kobo.3.6">These are all essential skills for web </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">API development.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">However, this is just the beginning of the journey. </span><span class="koboSpan" id="kobo.5.2">As we wrap up our exploration of the fundamental concepts of web API development using ASP.NET Core, it is time to embark on a journey to explore more advanced topics. </span><span class="koboSpan" id="kobo.5.3">In this chapter, we will transition from the basics to delve into topics that are important for developers aspiring to master web API development. </span><span class="koboSpan" id="kobo.5.4">Now, let us elevate our skills to the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">next level.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will delve into the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Domain-driven design</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Clean architecture</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Microservices</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Web API </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">design patterns</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">By the end of this chapter, you will have a high-level understanding of these topics and be able to explore them further on </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">your own.</span></span></p>
<h1 id="_idParaDest-365"><a id="_idTextAnchor700"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.17.1">The code example in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">at </span></span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.20.1">.</span></span></p>
<h1 id="_idParaDest-366"><a id="_idTextAnchor701"/><span class="koboSpan" id="kobo.21.1">Domain-driven design</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The</span><a id="_idIndexMarker1929"/><span class="koboSpan" id="kobo.23.1"> term </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.25.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">DDD</span></strong><span class="koboSpan" id="kobo.27.1">, was coined by Eric Evans in his book </span><em class="italic"><span class="koboSpan" id="kobo.28.1">Domain-Driven Design: Tackling Complexity in the Heart of Software</span></em><span class="koboSpan" id="kobo.29.1">, published in 2003. </span><span class="koboSpan" id="kobo.29.2">DDD consists of a set of </span><a id="_idIndexMarker1930"/><span class="koboSpan" id="kobo.30.1">principles and practices that focus on the domain model and domain logic, which help developers manage the complexity and build flexible and maintainable software. </span><span class="koboSpan" id="kobo.30.2">DDD is not bound to any particular technology or framework. </span><span class="koboSpan" id="kobo.30.3">You can use it in any software project, including web </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">API development.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">In Eric Evans’ book, he </span><a id="_idIndexMarker1931"/><span class="koboSpan" id="kobo.33.1">defines three important principles </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">of DDD:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.35.1">Focusing on the core domain and </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">domain logic</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Basing complex designs on the </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">domain models</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Collaborating with technical and domain experts to iteratively refine the model that solves </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">domain problems</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.41.1">A domain </span><a id="_idIndexMarker1932"/><span class="koboSpan" id="kobo.42.1">is a subject area that the software system is built for. </span><span class="koboSpan" id="kobo.42.2">The domain model is a conceptual model of the domain, which incorporates both data and behavior. </span><span class="koboSpan" id="kobo.42.3">Developers build the domain model based on the domain knowledge from domain experts. </span><span class="koboSpan" id="kobo.42.4">The domain model is the core of the software system that can be used to solve </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">domain problems.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">In the following subsections, we will introduce the basic concepts of DDD and how to apply them to web API development. </span><span class="koboSpan" id="kobo.44.2">Note that domain-driven design is a comprehensive topic that cannot be covered in a single chapter. </span><span class="koboSpan" id="kobo.44.3">So, the subsections are not intended to be a complete guide to DDD. </span><span class="koboSpan" id="kobo.44.4">Instead, it will provide a high-level overview of DDD and explain some of the key concepts of DDD. </span><span class="koboSpan" id="kobo.44.5">If you want to learn more about DDD, you can refer to other resources, such as Eric Evans’ </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">DDD bo</span><a id="_idTextAnchor702"/><span class="koboSpan" id="kobo.46.1">ok.</span></span></p>
<h2 id="_idParaDest-367"><a id="_idTextAnchor703"/><span class="koboSpan" id="kobo.47.1">Ubiquitous language</span></h2>
<p><span class="koboSpan" id="kobo.48.1">One of</span><a id="_idIndexMarker1933"/><span class="koboSpan" id="kobo.49.1"> the core concepts of DDD is that to build a software system for a complex business domain, we need to build ubiquitous language and a domain model that reflects the business domain. </span><span class="koboSpan" id="kobo.49.2">Under domain-driven design, the software structure and code, such as class names, class methods, and so on, should match the business domain. </span><span class="koboSpan" id="kobo.49.3">The domain terms should be embedded in the code. </span><span class="koboSpan" id="kobo.49.4">When developers talk to domain experts, they should use the same terms. </span><span class="koboSpan" id="kobo.49.5">For example, if we are building a web API for a banking system, we may have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">Banking</span></strong><span class="koboSpan" id="kobo.51.1"> domain. </span><span class="koboSpan" id="kobo.51.2">When we discuss the requirements with domain experts, we may hear terms such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">Account</span></strong><span class="koboSpan" id="kobo.53.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">Transaction</span></strong><span class="koboSpan" id="kobo.55.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">Deposit</span></strong><span class="koboSpan" id="kobo.57.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">Withdrawal</span></strong><span class="koboSpan" id="kobo.59.1">, and so on. </span><span class="koboSpan" id="kobo.59.2">In a banking system, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">Account</span></strong><span class="koboSpan" id="kobo.61.1"> object can have different types, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">SavingAccount</span></strong><span class="koboSpan" id="kobo.63.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">LoanAccount</span></strong><span class="koboSpan" id="kobo.65.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">CreditCardAccount</span></strong><span class="koboSpan" id="kobo.67.1">, and so on. </span><span class="koboSpan" id="kobo.67.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">SavingAccount</span></strong><span class="koboSpan" id="kobo.69.1"> may have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">Deposit()</span></strong><span class="koboSpan" id="kobo.71.1"> method and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">Withdrawal()</span></strong><span class="koboSpan" id="kobo.73.1"> method. </span><span class="koboSpan" id="kobo.73.2">In the code of the system, we should use the same terms as the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">domain experts.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">The use of </span><a id="_idIndexMarker1934"/><span class="koboSpan" id="kobo.76.1">a ubiquitous language is an essential pillar of DDD. </span><span class="koboSpan" id="kobo.76.2">This language provides a common understanding between domain experts, developers, and users, allowing them to effectively communicate system requirements, design, and implementation. </span><span class="koboSpan" id="kobo.76.3">By consciously using the ubiquitous language in the code, developers can build a domain model that accurately reflects the business domain. </span><span class="koboSpan" id="kobo.76.4">Without this, the code may become disconnected from the business domain and become difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">to ma</span><a id="_idTextAnchor704"/><span class="koboSpan" id="kobo.78.1">nage.</span></span></p>
<h2 id="_idParaDest-368"><a id="_idTextAnchor705"/><span class="koboSpan" id="kobo.79.1">Bounded context</span></h2>
<p><span class="koboSpan" id="kobo.80.1">In the realm</span><a id="_idIndexMarker1935"/><span class="koboSpan" id="kobo.81.1"> of DDD, the concept of a bounded context is essential. </span><span class="koboSpan" id="kobo.81.2">A bounded context is a boundary that defines a domain model and serves as a delineated area of responsibility within a software system. </span><span class="koboSpan" id="kobo.81.3">It is like a linguistic territory in which a specific model holds meaning and relevance. </span><span class="koboSpan" id="kobo.81.4">By encapsulating a distinct understanding of the domain, bounded contexts promote clarity and precision in communication between domain experts </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">and developers.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Consider a scenario where we are building a web API for a banking system. </span><span class="koboSpan" id="kobo.83.2">Without bounded contexts, the term </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">Account</span></strong><span class="koboSpan" id="kobo.85.1"> could be interpreted differently in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">Banking </span></strong><span class="koboSpan" id="kobo.87.1">domain and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">customer relationship management</span></strong><span class="koboSpan" id="kobo.89.1"> (CRM) domain. </span><span class="koboSpan" id="kobo.89.2">This ambiguity can lead to confusion, misaligned expectations, and ultimately, a fragmented understanding of the entire system. </span><span class="koboSpan" id="kobo.89.3">To avoid this, bounded contexts should be used to clearly define the scope of the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">In many cases, a domain consists of several subdomains, each of which may refer to a distinct part of the business domain, thus creating different bounded contexts. </span><span class="koboSpan" id="kobo.91.2">These bounded contexts communicate with each other through programmatic interfaces, such as web APIs and </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">message q</span><a id="_idTextAnchor706"/><span class="koboSpan" id="kobo.93.1">ueues.</span></span></p>
<h2 id="_idParaDest-369"><a id="_idTextAnchor707"/><span class="koboSpan" id="kobo.94.1">DDD layers</span></h2>
<p><span class="koboSpan" id="kobo.95.1">A DDD solution</span><a id="_idIndexMarker1936"/><span class="koboSpan" id="kobo.96.1"> is often represented as a layered</span><a id="_idIndexMarker1937"/><span class="koboSpan" id="kobo.97.1"> architecture. </span><span class="koboSpan" id="kobo.97.2">Each layer has a specific responsibility. </span><span class="koboSpan" id="kobo.97.3">The following diagram shows the typical layers of a </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">DDD application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer181">
<span class="koboSpan" id="kobo.99.1"><img alt="Figure 17.1 – Typical layers of a DDD application" src="image/B18971_17_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.100.1">Figure 17.1 – Typical layers of a DDD application</span></p>
<p><span class="koboSpan" id="kobo.101.1">In the preceding diagram, there are </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">four layers:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Presentation layer</span></strong><span class="koboSpan" id="kobo.104.1">: This </span><a id="_idIndexMarker1938"/><span class="koboSpan" id="kobo.105.1">layer is responsible for presenting the data to the user and receiving user input. </span><span class="koboSpan" id="kobo.105.2">Normally, this layer is implemented as a user interface, such as a web application, a mobile application, or a desktop application. </span><span class="koboSpan" id="kobo.105.3">In this book, we mainly focus on web API applications that do not have a user interface. </span><span class="koboSpan" id="kobo.105.4">In this case, the presentation layer can be a client application that consumes the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">web API.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.107.1">Application layer</span></strong><span class="koboSpan" id="kobo.108.1">: This </span><a id="_idIndexMarker1939"/><span class="koboSpan" id="kobo.109.1">layer is responsible for coordinating the application’s activity. </span><span class="koboSpan" id="kobo.109.2">It receives user input from the presentation layer, invokes the domain layer to perform business logic, and returns the results to the presentation layer. </span><span class="koboSpan" id="kobo.109.3">In our case, the application layer is the web API application, which receives HTTP requests from the client</span><a id="_idIndexMarker1940"/><span class="koboSpan" id="kobo.110.1"> application, invokes the domain layer to execute business logic, and returns the results to the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">client application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Domain layer</span></strong><span class="koboSpan" id="kobo.113.1">: This </span><a id="_idIndexMarker1941"/><span class="koboSpan" id="kobo.114.1">layer is the heart of the application. </span><span class="koboSpan" id="kobo.114.2">It contains the domain model and domain logic, which is independent of the application layer and the infrastructure layer. </span><span class="koboSpan" id="kobo.114.3">In other words, the domain layer does not depend on any other layers. </span><span class="koboSpan" id="kobo.114.4">For example, if we need to implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">Deposit</span></strong><span class="koboSpan" id="kobo.116.1"> method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">SavingAccount</span></strong><span class="koboSpan" id="kobo.118.1"> class, the logic in the domain layer does not have any knowledge of how to save data to the database. </span><span class="koboSpan" id="kobo.118.2">Instead, it only focuses on the business logic of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Deposit</span></strong><span class="koboSpan" id="kobo.120.1"> method using abstractions and interfaces. </span><span class="koboSpan" id="kobo.120.2">This layer often contains entities, value objects, aggregates, repositories, and </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">domain services.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.122.1">Infrastructure layer</span></strong><span class="koboSpan" id="kobo.123.1">: This layer implements the application infrastructure, such as </span><a id="_idIndexMarker1942"/><span class="koboSpan" id="kobo.124.1">data access, caching, logging, messaging, and so on. </span><span class="koboSpan" id="kobo.124.2">It often integrates with external systems as dependencies, such as database, message queues, and so on. </span><span class="koboSpan" id="kobo.124.3">In our case, the infrastructure layer can include the data access layer, which uses EF Core to access </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the database.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.126.1">DDD focuses primarily on the domain and application layers. </span><span class="koboSpan" id="kobo.126.2">This is because the UI layer and the infrastructure layer are not specific to DDD and can be implemented with any technology </span><a id="_idIndexMarker1943"/><span class="koboSpan" id="kobo.127.1">or framework. </span><span class="koboSpan" id="kobo.127.2">For example, the UI layer can be implemented using </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">ASP.NET Core MVC</span></strong><span class="koboSpan" id="kobo.129.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">Blazor</span></strong><span class="koboSpan" id="kobo.131.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">React</span></strong><span class="koboSpan" id="kobo.133.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">WPF</span></strong><span class="koboSpan" id="kobo.135.1">, or any other UI framework </span><a id="_idIndexMarker1944"/><span class="koboSpan" id="kobo.136.1">on various </span><a id="_idIndexMarker1945"/><span class="koboSpan" id="kobo.137.1">platforms, while</span><a id="_idIndexMarker1946"/><span class="koboSpan" id="kobo.138.1"> the core domain logic remains the same. </span><span class="koboSpan" id="kobo.138.2">Similarly, DDD does not dictate data storage, which can be a relational database, a NoSQL database, or any other data storage. </span><span class="koboSpan" id="kobo.138.3">The domain layer uses the repository pattern to access the data, which is independent of data storage. </span><span class="koboSpan" id="kobo.138.4">Another example is the logging mechanism, which is also not specific to DDD, as the domain layer needs to log the business events but does not care about the logg</span><a id="_idTextAnchor708"/><span class="koboSpan" id="kobo.139.1">ing </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">system used.</span></span></p>
<h3><span class="koboSpan" id="kobo.141.1">DDD building blocks</span></h3>
<p><span class="koboSpan" id="kobo.142.1">DDD </span><a id="_idIndexMarker1947"/><span class="koboSpan" id="kobo.143.1">has a set of building blocks that can be </span><a id="_idIndexMarker1948"/><span class="koboSpan" id="kobo.144.1">used to build the domain model. </span><span class="koboSpan" id="kobo.144.2">These building blocks include entities, value objects, aggregates, repositories, and domain services. </span><span class="koboSpan" id="kobo.144.3">In the following subsections, we will introduce these building blocks and how to use them to build</span><a id="_idTextAnchor709"/><span class="koboSpan" id="kobo.145.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">domain model:</span></span></p>
<h4><span class="koboSpan" id="kobo.147.1">Entity</span></h4>
<p><span class="koboSpan" id="kobo.148.1">You may have essential knowledge of </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.150.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.151.1">OOP</span></strong><span class="koboSpan" id="kobo.152.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.154.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.155.1">ORM</span></strong><span class="koboSpan" id="kobo.156.1">) if you</span><a id="_idIndexMarker1949"/><span class="koboSpan" id="kobo.157.1"> have read the previous chapters. </span><span class="koboSpan" id="kobo.157.2">In OOP, an object is </span><a id="_idIndexMarker1950"/><span class="koboSpan" id="kobo.158.1">an instance of a class. </span><span class="koboSpan" id="kobo.158.2">An object has a state and behavior. </span><span class="koboSpan" id="kobo.158.3">The </span><a id="_idIndexMarker1951"/><span class="koboSpan" id="kobo.159.1">state is represented by the properties of the object, while the behavior is represented by the methods of </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">the object.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">In DDD, the entity is similar to an object in OOP, but it is more than that. </span><span class="koboSpan" id="kobo.161.2">An </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">entity</span></strong><span class="koboSpan" id="kobo.163.1"> is an object that has a unique identity and is defined by its identity, not its attributes. </span><span class="koboSpan" id="kobo.163.2">Normally, an entity is mapped to a table in </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">The identity of an entity is normally represented by an ID property. </span><span class="koboSpan" id="kobo.165.2">The ID property is immutable, which means that once it is set, it cannot be changed. </span><span class="koboSpan" id="kobo.165.3">The ID property can be a primitive type, such as an integer, a string, or a GUID. </span><span class="koboSpan" id="kobo.165.4">It can also be </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">composite keys.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">If two entities have the same properties but different identities, they are considered </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">different entities.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">For example, in a banking system, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Account</span></strong><span class="koboSpan" id="kobo.171.1"> is an entity. </span><span class="koboSpan" id="kobo.171.2">It has a unique identity that can be represented by an </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Id</span></strong><span class="koboSpan" id="kobo.173.1"> property. </span><span class="koboSpan" id="kobo.173.2">Two accounts cannot have </span><a id="_idTextAnchor710"/><span class="koboSpan" id="kobo.174.1">the same </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1"> property.</span></span></p>
<h4><span class="koboSpan" id="kobo.177.1">Value object</span></h4>
<p><span class="koboSpan" id="kobo.178.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">value object</span></strong><span class="koboSpan" id="kobo.180.1"> is </span><a id="_idIndexMarker1952"/><span class="koboSpan" id="kobo.181.1">another type of object in DDD. </span><span class="koboSpan" id="kobo.181.2">It is identified by its properties, rather than a unique identity. </span><span class="koboSpan" id="kobo.181.3">Normally, a value object is immutable, which means that its properties cannot be changed once it is created. </span><span class="koboSpan" id="kobo.181.4">If two value objects have the same properties, they are considered the same </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">value object.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Address</span></strong><span class="koboSpan" id="kobo.185.1"> is a value object. </span><span class="koboSpan" id="kobo.185.2">It is identified by its properties, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Street</span></strong><span class="koboSpan" id="kobo.187.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">City</span></strong><span class="koboSpan" id="kobo.189.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">State</span></strong><span class="koboSpan" id="kobo.191.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">ZipCode</span></strong><span class="koboSpan" id="kobo.193.1">. </span><span class="koboSpan" id="kobo.193.2">If two addresses have the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Street</span></strong><span class="koboSpan" id="kobo.195.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">City</span></strong><span class="koboSpan" id="kobo.197.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">State</span></strong><span class="koboSpan" id="kobo.199.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">ZipCode</span></strong><span class="koboSpan" id="kobo.201.1">, they are consid</span><a id="_idTextAnchor711"/><span class="koboSpan" id="kobo.202.1">ered the </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">same address.</span></span></p>
<h4><span class="koboSpan" id="kobo.204.1">Aggregate</span></h4>
<p><span class="koboSpan" id="kobo.205.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">aggregate</span></strong><span class="koboSpan" id="kobo.207.1"> is a </span><a id="_idIndexMarker1953"/><span class="koboSpan" id="kobo.208.1">cluster of associated objects, including entities and value objects, which are treated as a unit for data changes. </span><span class="koboSpan" id="kobo.208.2">An aggregate has a root entity, which is the only object that can be accessed from outside the aggregate. </span><span class="koboSpan" id="kobo.208.3">The root entity is responsible for maintaining the consistency and integrity of the aggregate. </span><span class="koboSpan" id="kobo.208.4">It is important to note that if the external objects need to access the objects inside the aggregate or modify the objects inside the aggregate, they must go through the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">root entity.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">For example, in an invoicing system, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">Invoice</span></strong><span class="koboSpan" id="kobo.212.1"> entity is an aggregate root. </span><span class="koboSpan" id="kobo.212.2">It contains a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.214.1"> entities, which are the items of the invoice. </span><span class="koboSpan" id="kobo.214.2">To add an item to the invoice, the external objects must go through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">Invoice</span></strong><span class="koboSpan" id="kobo.216.1"> entity, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
public class Invoice{
    public int Id { get; private set; } // Aggregate root Id, which should not be changed once it is set
    public DateTime Date { get; set; }
    public InvoiceStatus Status { get; private set; }
    public decimal Total { get; private set; } // The total amount of the invoice, which should be updated when an item is added or removed, but cannot be changed directly
    // Other properties
    public List&lt;InvoiceItem&gt; Items { get; private set; }
    public void AddItem(InvoiceItem item)
    {
        // Add the item to the invoice
        Items.Add(item);
        // Update the invoice total, etc.
</span><span class="koboSpan" id="kobo.218.2">        // ...
</span><span class="koboSpan" id="kobo.218.3">    }
    public void RemoveItem(InvoiceItem item)
    {
        // Remove the item from the invoice
        Items.Remove(item);
        // Update the invoice total, etc.
</span><span class="koboSpan" id="kobo.218.4">        // ...
</span><span class="koboSpan" id="kobo.218.5">    }
    public void Close()
    {
        // Close the invoice
        Status = InvoiceStatus.Closed;
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.219.1">In the </span><a id="_idIndexMarker1954"/><span class="koboSpan" id="kobo.220.1">preceding example, if we need to add or remove an item from the invoice, we must get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Invoice</span></strong><span class="koboSpan" id="kobo.222.1"> entity first, and then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">AddItem()</span></strong><span class="koboSpan" id="kobo.224.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">RemoveItem()</span></strong><span class="koboSpan" id="kobo.226.1"> method to add or remove the item. </span><span class="koboSpan" id="kobo.226.2">We cannot directly add or remove an item from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Items</span></strong><span class="koboSpan" id="kobo.228.1"> property because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Items</span></strong><span class="koboSpan" id="kobo.230.1"> property is private and can only be accessed from inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Invoice</span></strong><span class="koboSpan" id="kobo.232.1"> entity. </span><span class="koboSpan" id="kobo.232.2">In this way, the domain logic is encapsulated inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">Invoice</span></strong><span class="koboSpan" id="kobo.234.1"> entity, and the consistency and integrity of the invoice are maintained. </span><span class="koboSpan" id="kobo.234.2">Similarly, we cannot change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">Total</span></strong><span class="koboSpan" id="kobo.236.1"> property directly. </span><span class="koboSpan" id="kobo.236.2">Instead, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">AddItem</span></strong><span class="koboSpan" id="kobo.238.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">RemoveItem</span></strong><span class="koboSpan" id="kobo.240.1"> method can up</span><a id="_idTextAnchor712"/><span class="koboSpan" id="kobo.241.1">date the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">Total</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1"> property.</span></span></p>
<h4><span class="koboSpan" id="kobo.244.1">Repository</span></h4>
<p><span class="koboSpan" id="kobo.245.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">repository</span></strong> <a id="_idIndexMarker1955"/><span class="koboSpan" id="kobo.247.1">is an abstraction layer used to access the data persistence layer. </span><span class="koboSpan" id="kobo.247.2">It encapsulates the data access logic and provides a way to query and save data. </span><span class="koboSpan" id="kobo.247.3">To ensure the domain layer does not depend on any specific data access technology, a repository is typically implemented as an interface. </span><span class="koboSpan" id="kobo.247.4">The infrastructure layer can then use a specific data access technology, such as EF Core</span><a id="_idIndexMarker1956"/><span class="koboSpan" id="kobo.248.1"> or Dapper, to implement the repository interface and access different data sources, such as relational databases or NoSQL databases. </span><span class="koboSpan" id="kobo.248.2">This decouples the domain layer from the data access technology and </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">data storage.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">An example of a repository interface is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
public interface IInvoiceRepository{
    Task&lt;Invoice&gt; GetByIdAsync(Guid id);
    Task&lt;List&lt;Invoice&gt;&gt; GetByCustomerIdAsync(Guid customerId);
    Task AddAsync(Invoice invoice);
    Task UpdateAsync(Invoice invoice);
    Task DeleteAsync(Invoice invoice);
}</span></pre>
<p><span class="koboSpan" id="kobo.253.1">We introduced the repository pattern in </span><a href="B18971_09.xhtml#_idTextAnchor371"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.254.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.255.1">. </span><span class="koboSpan" id="kobo.255.2">It is not a specific DDD pattern. </span><span class="koboSpan" id="kobo.255.3">However, it is often used in DDD to decouple the domain layer f</span><a id="_idTextAnchor713"/><span class="koboSpan" id="kobo.256.1">rom the data </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">access layer.</span></span></p>
<h4><span class="koboSpan" id="kobo.258.1">Domain service</span></h4>
<p><span class="koboSpan" id="kobo.259.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">domain service</span></strong><span class="koboSpan" id="kobo.261.1"> is a </span><a id="_idIndexMarker1957"/><span class="koboSpan" id="kobo.262.1">stateless service that contains domain logic that does not belong to any specific entity or value object. </span><span class="koboSpan" id="kobo.262.2">It is often used to implement complex domain logic that involves multiple entities or value objects. </span><span class="koboSpan" id="kobo.262.3">To access the data persistence layer, a domain service may depend on one or more repositories. </span><span class="koboSpan" id="kobo.262.4">Additionally, it may also depend on other external services. </span><span class="koboSpan" id="kobo.262.5">These dependencies are injected into the domain service through the dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">injection mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">For example, in a </span><a id="_idIndexMarker1958"/><span class="koboSpan" id="kobo.265.1">banking system, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">TransferService</span></strong><span class="koboSpan" id="kobo.267.1"> domain service is responsible for the logic of transferring money from one account to another. </span><span class="koboSpan" id="kobo.267.2">To do this, it relies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">AccountRepository</span></strong><span class="koboSpan" id="kobo.269.1"> to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Account</span></strong><span class="koboSpan" id="kobo.271.1"> entity. </span><span class="koboSpan" id="kobo.271.2">Additionally, it may need to use an external service to send a notification to the account holder after the transfer is complete. </span><span class="koboSpan" id="kobo.271.3">If the accounts are in different banks, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">TransferService</span></strong><span class="koboSpan" id="kobo.273.1"> domain service may also need to use an external service to transfer money </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">between them.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">The following code shows an example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">domain service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
public class TransferService{
    private readonly IAccountRepository _accountRepository;
    private readonly ITransactionRepository _transactionRepository;
    private readonly INotificationService _notificationService;
    private readonly IBankTransferService _bankTransferService;
    public TransferService(IAccountRepository accountRepository, ITransactionRepository transactionRepository, INotificationService notificationService, IBankTransferService bankTransferService)
    {
        _accountRepository = accountRepository;
        _transactionRepository = transactionRepository;
        _notificationService = notificationService;
        _bankTransferService = bankTransferService;
    }
    public async Task TransferAsync(Guid fromAccountId, Guid toAccountId, decimal amount)
    {
        // Get the account from the repository
        var fromAccount = await _accountRepository.GetByIdAsync(fromAccountId);
        var toAccount = await _accountRepository.GetByIdAsync(toAccountId);
        // Transfer money between the accounts
        fromAccount.Withdraw(amount);
        toAccount.Deposit(amount);
        // Save the changes to the repository
        await _accountRepository.UpdateAsync(fromAccount);
        await _accountRepository.UpdateAsync(toAccount);
        // Create transaction records
        await _transactionRepository.AddAsync(new Transaction
        {
            FromAccountId = fromAccountId,
            ToAccountId = toAccountId,
            Amount = amount,
            Date = DateTime.UtcNow
        });
        await _transactionRepository.AddAsync(new Transaction
        {
            FromAccountId = toAccountId,
            ToAccountId = fromAccountId,
            Amount = -amount,
            Date = DateTime.UtcNow
        });
        // Send a notification to the account holder
        await _notificationService.SendAsync(fromAccount.HolderId, $"You have transferred {amount}to {toAccount.HolderId}");
        await _notificationService.SendAsync(toAccount.HolderId, $"You have received {amount} from{fromAccount.HolderId}");
        // Transfer money between the banks
        // await _bankTransferService.TransferAsync(fromAccount.BankId, toAccount.BankId, amount);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.278.1">The </span><a id="_idIndexMarker1959"/><span class="koboSpan" id="kobo.279.1">preceding code shows a </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">TransferService</span></strong><span class="koboSpan" id="kobo.281.1"> domain service. </span><span class="koboSpan" id="kobo.281.2">It has four dependencies: </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">IAccountRepository</span></strong><span class="koboSpan" id="kobo.283.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">ITransactionRepository</span></strong><span class="koboSpan" id="kobo.285.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">INotificationService</span></strong><span class="koboSpan" id="kobo.287.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">IBankTransferService</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">TransferAsync</span></strong><span class="koboSpan" id="kobo.291.1"> method transfers money from one account to another. </span><span class="koboSpan" id="kobo.291.2">It first obtains the accounts from </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">IAccountRepository</span></strong><span class="koboSpan" id="kobo.293.1">, and then transfers money between the accounts. </span><span class="koboSpan" id="kobo.293.2">After that, it saves the changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">IAccountRepository</span></strong><span class="koboSpan" id="kobo.295.1"> and creates transaction records in </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">ITransactionRepository</span></strong><span class="koboSpan" id="kobo.297.1">. </span><span class="koboSpan" id="kobo.297.2">Finally, it sends a notification to the account holders </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">INotificationService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.301.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.302.1">The preceding example is simplified for demonstration purposes. </span><span class="koboSpan" id="kobo.302.2">The actual implementation to transfer money between two accounts is much more complicated. </span><span class="koboSpan" id="kobo.302.3">For example, it may need to check the balance of the accounts, check the daily transfer limit, and so on. </span><span class="koboSpan" id="kobo.302.4">It may also need to transfer money between different banks, which involves a lot of complex logic to handle any errors that may occur during the transfer. </span><span class="koboSpan" id="kobo.302.5">If any error occurs, it may need to roll back the transaction. </span><span class="koboSpan" id="kobo.302.6">This is a typical example of a domain service that im</span><a id="_idTextAnchor714"/><span class="koboSpan" id="kobo.303.1">plements complex </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">domain logic.</span></span></p>
<h4><span class="koboSpan" id="kobo.305.1">Unit of work</span></h4>
<p><span class="koboSpan" id="kobo.306.1">In the preceding example, when transferring money between two accounts, the process involves multiple steps. </span><span class="koboSpan" id="kobo.306.2">What if an error occurs during the process? </span><span class="koboSpan" id="kobo.306.3">In order to prevent any money from being lost during the process of transferring funds between two accounts, it is necessary to wrap the process in a transaction. </span><span class="koboSpan" id="kobo.306.4">This will ensure that in the event of an error occurring, the transaction will be rolled back, and the funds will remain secure. </span><span class="koboSpan" id="kobo.306.5">For example, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">TransferAsync()</span></strong><span class="koboSpan" id="kobo.308.1"> method throws an exception after the money has been withdrawn from </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">fromAccount</span></strong><span class="koboSpan" id="kobo.310.1"> but before it is deposited to </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">toAccount</span></strong><span class="koboSpan" id="kobo.312.1">, the transaction will be rolled back, and the money will not </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">be lost.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">The term </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">transaction</span></strong><span class="koboSpan" id="kobo.316.1"> is often</span><a id="_idIndexMarker1960"/><span class="koboSpan" id="kobo.317.1"> used in the context of databases. </span><span class="koboSpan" id="kobo.317.2">This kind of transaction is called a </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">unit of work</span></strong><span class="koboSpan" id="kobo.319.1"> in DDD. </span><span class="koboSpan" id="kobo.319.2">A unit of work is a sequence of operations that must be performed as a whole. </span><span class="koboSpan" id="kobo.319.3">All the steps in a unit of work must succeed or fail together. </span><span class="koboSpan" id="kobo.319.4">If any step fails, the entire unit of work must be rolled back. </span><span class="koboSpan" id="kobo.319.5">This prevents the data from being left in an </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">inconsistent state.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">A unit of work can </span><a id="_idIndexMarker1961"/><span class="koboSpan" id="kobo.322.1">be implemented in various ways. </span><span class="koboSpan" id="kobo.322.2">In many scenarios, a unit of work is implemented as a database transaction. </span><span class="koboSpan" id="kobo.322.3">Another example is a message queue. </span><span class="koboSpan" id="kobo.322.4">When a message is received, it is processed as a unit of work. </span><span class="koboSpan" id="kobo.322.5">If the process is successful, the message is removed from the queue. </span><span class="koboSpan" id="kobo.322.6">Otherwise, the message remains in the queue and will be p</span><a id="_idTextAnchor715"/><span class="koboSpan" id="kobo.323.1">rocessed again at a </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">later time.</span></span></p>
<h4><span class="koboSpan" id="kobo.325.1">Application service</span></h4>
<p><span class="koboSpan" id="kobo.326.1">The application service </span><a id="_idIndexMarker1962"/><span class="koboSpan" id="kobo.327.1">is responsible for managing the application process. </span><span class="koboSpan" id="kobo.327.2">It receives user input from the presentation layer, invokes the domain service to execute business logic, and returns the results to the Presentation Layer. </span><span class="koboSpan" id="kobo.327.3">In a web API application, the Application Service can be implemented as a web API controller or a separate service that is invoked by the web </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">API controller.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">The </span><a id="_idIndexMarker1963"/><span class="koboSpan" id="kobo.330.1">application service should be thin and delegate most of the work to the domain service. </span><span class="koboSpan" id="kobo.330.2">Typically, the application service uses </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">data transfer objects</span></strong><span class="koboSpan" id="kobo.332.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.333.1">DTOs</span></strong><span class="koboSpan" id="kobo.334.1">) to transfer data between the presentation layer and the domain layer. </span><span class="koboSpan" id="kobo.334.2">A DTO is a simple object that contains data and does not have any behavior. </span><span class="koboSpan" id="kobo.334.3">The </span><a id="_idIndexMarker1964"/><span class="koboSpan" id="kobo.335.1">DTOs are often mapped to the entities using mapping tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">AutoMapper</span></strong><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">For example, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">InvoiceDto</span></strong><span class="koboSpan" id="kobo.339.1"> class may contain the properties of an invoice, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Id</span></strong><span class="koboSpan" id="kobo.341.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Date</span></strong><span class="koboSpan" id="kobo.343.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Status</span></strong><span class="koboSpan" id="kobo.345.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Total</span></strong><span class="koboSpan" id="kobo.347.1">, and so on. </span><span class="koboSpan" id="kobo.347.2">It does not have any method to add or remove an invoice item or close the invoice. </span><span class="koboSpan" id="kobo.347.3">It is purely a data container. </span><span class="koboSpan" id="kobo.347.4">If a property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Invoice</span></strong><span class="koboSpan" id="kobo.349.1"> entity is not needed in the presentation layer, it should not be included </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">InvoiceDto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">The presentation layer can send a DTO to the application service when it needs to create or update an entity. </span><span class="koboSpan" id="kobo.353.2">The application service will then map the DTO to the entity and invoke the domain service to execute the necessary business logic. </span><span class="koboSpan" id="kobo.353.3">Finally, the application service will map the entity back to the DTO and return it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">presentation layer.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Here is a simple example of an </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">application service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
[Route("api/[controller]")][ApiController]
public class InvoicesController : ControllerBase
{
    private readonly IInvoiceService _invoiceService;
    public InvoicesController(IInvoiceService invoiceService)
    {
        _invoiceService = invoiceService;
    }
    [HttpPost]
    public async Task&lt;IActionResult&gt; CreateAsync(InvoiceDto invoiceDto)
    {
        var invoice = await _invoiceService.CreateAsync(invoiceDto);
        return Ok(invoice);
    }
    // Omitted other methods
}
public interface IInvoiceService
{
    Task&lt;InvoiceDto&gt; CreateAsync(InvoiceDto invoiceDto);
    // Omitted other methods
}
public class InvoiceService : IInvoiceService
{
    private readonly IInvoiceRepository _invoiceRepository;
    private readonly IMapper _mapper;
    public InvoiceService(IInvoiceRepository invoiceRepository, IMapper mapper)
    {
        _invoiceRepository = invoiceRepository;
        _mapper = mapper;
    }
    public async Task&lt;InvoiceDto&gt; CreateAsync(InvoiceDto invoiceDto)
    {
        var invoice = _mapper.Map&lt;Invoice&gt;(invoiceDto);
        await _invoiceRepository.AddAsync(invoice);
        return _mapper.Map&lt;InvoiceDto&gt;(invoice);
    }
    // Omitted other methods
}</span></pre>
<p><span class="koboSpan" id="kobo.358.1">In the</span><a id="_idIndexMarker1965"/><span class="koboSpan" id="kobo.359.1"> preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">IInvoiceService</span></strong><span class="koboSpan" id="kobo.361.1"> interface defines the methods of the application service. </span><span class="koboSpan" id="kobo.361.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">InvoiceService</span></strong><span class="koboSpan" id="kobo.363.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">IInvoiceService</span></strong><span class="koboSpan" id="kobo.365.1"> interface. </span><span class="koboSpan" id="kobo.365.2">It has two dependencies: </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">IInvoiceRepository</span></strong><span class="koboSpan" id="kobo.367.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">IMapper</span></strong><span class="koboSpan" id="kobo.369.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">IInvoiceRepository</span></strong><span class="koboSpan" id="kobo.371.1"> is used to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Invoice</span></strong><span class="koboSpan" id="kobo.373.1"> entity, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">IMapper</span></strong><span class="koboSpan" id="kobo.375.1"> is used to map </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">InvoiceDto</span></strong><span class="koboSpan" id="kobo.377.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">Invoice</span></strong><span class="koboSpan" id="kobo.379.1"> entity and vice versa. </span><span class="koboSpan" id="kobo.379.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">CreateAsync()</span></strong><span class="koboSpan" id="kobo.381.1"> method receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">InvoiceDto</span></strong><span class="koboSpan" id="kobo.383.1"> from the presentation layer via the controller, maps it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Invoice</span></strong><span class="koboSpan" id="kobo.385.1"> entity, and then invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">AddAsync()</span></strong><span class="koboSpan" id="kobo.387.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">IInvoiceRepository</span></strong><span class="koboSpan" id="kobo.389.1"> to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Invoice</span></strong><span class="koboSpan" id="kobo.391.1"> entity to the database. </span><span class="koboSpan" id="kobo.391.2">Finally, it maps the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">Invoice</span></strong><span class="koboSpan" id="kobo.393.1"> entity back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">InvoiceDto</span></strong><span class="koboSpan" id="kobo.395.1"> and returns it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">presentation layer.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.397.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.398.1">In the preceding example, there is no domain service. </span><span class="koboSpan" id="kobo.398.2">This is because the logic to create an invoice is simple. </span><span class="koboSpan" id="kobo.398.3">In this case, the application service layer can directly invoke the repository to add the invoice to the database. </span><span class="koboSpan" id="kobo.398.4">However, if the logic is more complex, involving multiple entities or aggregates, it is better to use a domain service to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the logic.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">DDD focuses on how to build a domain model that reflects the business domain and how to maintain the consistency and integrity of the domain model. </span><span class="koboSpan" id="kobo.400.2">It is not used to produce reports or user interfaces. </span><span class="koboSpan" id="kobo.400.3">Reports may need complex queries that are not suitable for the domain model. </span><span class="koboSpan" id="kobo.400.4">For this case, you may need to use a separate reporting database or reporting service. </span><span class="koboSpan" id="kobo.400.5">Similarly, the user interface may need to display data in a different way than the domain model. </span><span class="koboSpan" id="kobo.400.6">However, the domain model should remain the same no matter how the data </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">are displayed.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">DDD can </span><a id="_idIndexMarker1966"/><span class="koboSpan" id="kobo.403.1">help you to manage the complexity and build a flexible and maintainable software system. </span><span class="koboSpan" id="kobo.403.2">But keep in mind that DDD is not a silver bullet. </span><span class="koboSpan" id="kobo.403.3">Typically, DDD is used for complex business domains. </span><span class="koboSpan" id="kobo.403.4">Developers must implement a lot of isolation, abstraction, and encapsulation to maintain the model. </span><span class="koboSpan" id="kobo.403.5">This may lead to a lot of effort and complexity. </span><span class="koboSpan" id="kobo.403.6">If your project is simple, DDD may be a bit overkill. </span><span class="koboSpan" id="kobo.403.7">In this case, a simple layered </span><a id="_idTextAnchor716"/><span class="koboSpan" id="kobo.404.1">architecture may be a </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">better choice.</span></span></p>
<h1 id="_idParaDest-370"><a id="_idTextAnchor717"/><span class="koboSpan" id="kobo.406.1">Clean architecture</span></h1>
<p><span class="koboSpan" id="kobo.407.1">Clean architecture</span><a id="_idIndexMarker1967"/><span class="koboSpan" id="kobo.408.1"> is a software architecture that was proposed by Robert C. </span><span class="koboSpan" id="kobo.408.2">Martin (also known as Uncle Bob) in his book </span><em class="italic"><span class="koboSpan" id="kobo.409.1">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</span></em><span class="koboSpan" id="kobo.410.1">, published in 2017. </span><span class="koboSpan" id="kobo.410.2">It is a layered architecture that focuses on the separation of concerns. </span><span class="koboSpan" id="kobo.410.3">Similar to DDD, clean architecture is not a specific technology or framework. </span><span class="koboSpan" id="kobo.410.4">It is a set of principles and practices that can be applied to any </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">software project.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">Clean architecture is also called onion architecture because the layers are arranged in a circular shape, like an onion. </span><span class="koboSpan" id="kobo.412.2">The following diagram shows the typical layers of </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">clean architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer182">
<span class="koboSpan" id="kobo.414.1"><img alt="Figure 17.2 – Typical layers of clean architecture" src="image/B18971_17_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.415.1">Figure 17.2 – Typical layers of clean architecture</span></p>
<p><span class="koboSpan" id="kobo.416.1">The preceding diagram illustrates the dependencies flowing from the outer layers to the inner layers. </span><span class="koboSpan" id="kobo.416.2">At the center of the architecture lies the application core layer, which contains the entities and interfaces for business logic. </span><span class="koboSpan" id="kobo.416.3">Additionally, this layer contains domain services that implement the interfaces. </span><span class="koboSpan" id="kobo.416.4">It does not depend on any other layers. </span><span class="koboSpan" id="kobo.416.5">Surrounding the application core layer is the Infrastructure Layer and UI layer, both of which depend on the application core layer. </span><span class="koboSpan" id="kobo.416.6">This architecture ensures that the application core layer is unaware of how the data are stored or presented to the user. </span><span class="koboSpan" id="kobo.416.7">In addition, the Infrastructure Layer and UI layer can be replaced without impacting the application </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">core layer.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">Clean architecture</span><a id="_idIndexMarker1968"/><span class="koboSpan" id="kobo.419.1"> shares some similarities with DDD. </span><span class="koboSpan" id="kobo.419.2">Both of them are layered architectures that focus on the separation of concerns. </span><span class="koboSpan" id="kobo.419.3">They both use dependency injection (or inversion of control) to decouple the layers. </span><span class="koboSpan" id="kobo.419.4">DDD focuses on the domain layer, while clean architecture prioritizes the importance of isolating the core business logic from the external dependencies. </span><span class="koboSpan" id="kobo.419.5">The separation of concerns allows for modifications to external components without affecting the core business logic, making it easier to adapt to </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">evolving requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">DDD and clean architecture complement each other and can be used together. </span><span class="koboSpan" id="kobo.421.2">While DDD guides how to build a domain model and understand the business domain, clean architecture </span><a id="_idIndexMarker1969"/><span class="koboSpan" id="kobo.422.1">offers a blueprint for organizing and structuring the codebase. </span><span class="koboSpan" id="kobo.422.2">Combining these approaches can lead to a flexible and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">software system.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">DDD and clean architecture are both layered architectures that focus on a business domain. </span><span class="koboSpan" id="kobo.424.2">Next, let us discuss the architecture of the entire software system. </span><span class="koboSpan" id="kobo.424.3">In the next section, we will introduce microservices, which is a popular architecture for building scala</span><a id="_idTextAnchor718"/><span class="koboSpan" id="kobo.425.1">ble and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">software systems.</span></span></p>
<h1 id="_idParaDest-371"><a id="_idTextAnchor719"/><span class="koboSpan" id="kobo.427.1">Microservices</span></h1>
<p><span class="koboSpan" id="kobo.428.1">Many traditional</span><a id="_idIndexMarker1970"/><span class="koboSpan" id="kobo.429.1"> applications are built as a monolith. </span><span class="koboSpan" id="kobo.429.2">A monolithic application is deployed as a single unit on a single server. </span><span class="koboSpan" id="kobo.429.3">The monolithic application is easy to develop and deploy. </span><span class="koboSpan" id="kobo.429.4">However, as the application grows, it becomes more and more difficult to maintain and scale. </span><span class="koboSpan" id="kobo.429.5">A small change in the application may require the entire application to be rebuilt, retested, and redeployed. </span><span class="koboSpan" id="kobo.429.6">Moreover, if one part of the application needs to be scaled, the application must be scaled as a whole, which is not cost-effective. </span><span class="koboSpan" id="kobo.429.7">In addition, if one part of the application fails, it may affect the </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">entire application.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">This is where </span><a id="_idIndexMarker1971"/><span class="koboSpan" id="kobo.432.1">microservices come in. </span><span class="koboSpan" id="kobo.432.2">A microservice is a small, independent service that is responsible for a specific business domain. </span><span class="koboSpan" id="kobo.432.3">Each microservice has its own database and dependencies. </span><span class="koboSpan" id="kobo.432.4">It can be developed, deployed, and scaled independently. </span><span class="koboSpan" id="kobo.432.5">These microservices communicate with each other through programmatic interfaces, such as web APIs or </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">message queues.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">Microservices </span><a id="_idIndexMarker1972"/><span class="koboSpan" id="kobo.435.1">provide </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">several benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.437.1">Single responsibility</span></strong><span class="koboSpan" id="kobo.438.1">: Each microservice is responsible for a specific business domain. </span><span class="koboSpan" id="kobo.438.2">It has its own dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">and database.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.440.1">Resilience and fault tolerance</span></strong><span class="koboSpan" id="kobo.441.1">: Microservices are designed to be resilient and fault tolerant. </span><span class="koboSpan" id="kobo.441.2">If one microservice fails, it does not affect </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">other microservices.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.443.1">Scalability</span></strong><span class="koboSpan" id="kobo.444.1">: Microservices can be scaled independently based on demand. </span><span class="koboSpan" id="kobo.444.2">If one microservice </span><a id="_idIndexMarker1973"/><span class="koboSpan" id="kobo.445.1">has a high workload, we can increase the number of instances of that microservice to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">the workload.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.447.1">Technology diversity</span></strong><span class="koboSpan" id="kobo.448.1">: Each microservice can be built using different technologies and frameworks as long as they communicate with each other through standard interfaces, such as HTTP APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">or gRPC.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.450.1">CI/CD</span></strong><span class="koboSpan" id="kobo.451.1">: Microservices facilitate CI/CD by allowing individual microservices to be built, tested, and deployed independently, minimizing disruption to the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">entire system.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.453.1">Microservices is not a new concept; it has been around for decades. </span><span class="koboSpan" id="kobo.453.2">However, it has become more popular in recent years, especially with the rise in cloud computing. </span><span class="koboSpan" id="kobo.453.3">Cloud computing provides a scalable and cost-effective infrastructure for microservices. </span><span class="koboSpan" id="kobo.453.4">In addition, the emergence of container technology, such as Docker, makes it easier to build and deploy microservices. </span><span class="koboSpan" id="kobo.453.5">By using containers and container orchestration tools, such as </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.455.1">, developers </span><a id="_idIndexMarker1974"/><span class="koboSpan" id="kobo.456.1">can easily build and deploy microservices to the cloud. </span><span class="koboSpan" id="kobo.456.2">The orchestration tools can automatically scale the microservices based on the workload. </span><span class="koboSpan" id="kobo.456.3">This makes it easier to build a scalable and cost-effective </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">software system.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">Microservices do not have to be exclusive to other architectures. </span><span class="koboSpan" id="kobo.458.2">In fact, they can be used in conjunction with other architectures to create a more robust and efficient system. </span><span class="koboSpan" id="kobo.458.3">You can use layers, such as DDD and clean architecture, to build each microservice. </span><span class="koboSpan" id="kobo.458.4">By leveraging the benefits of both architectures, organizations can create a powerful and reliable system that meets their needs. </span><span class="koboSpan" id="kobo.458.5">This approach can be especially beneficial for organizations that require a high degree of scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">and flexibility.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">For example, in an </span><a id="_idIndexMarker1975"/><span class="koboSpan" id="kobo.461.1">online shopping system, we may have the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">following microservices:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.463.1">Product service</span></strong><span class="koboSpan" id="kobo.464.1">: This </span><a id="_idIndexMarker1976"/><span class="koboSpan" id="kobo.465.1">service is responsible for managing the products, such as adding a new product, updating a product, deleting a product, and so on. </span><span class="koboSpan" id="kobo.465.2">It has its own database to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">product data.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.467.1">Order service</span></strong><span class="koboSpan" id="kobo.468.1">: This </span><a id="_idIndexMarker1977"/><span class="koboSpan" id="kobo.469.1">service is responsible for managing the orders, such as creating a new order, updating an order, deleting an order, and so on. </span><span class="koboSpan" id="kobo.469.2">It also has its own database to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">order data.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.471.1">Payment service</span></strong><span class="koboSpan" id="kobo.472.1">: This </span><a id="_idIndexMarker1978"/><span class="koboSpan" id="kobo.473.1">service is responsible for processing payments, such as credit card payments, PayPal payments, and so on. </span><span class="koboSpan" id="kobo.473.2">It has its own database to store the </span><a id="_idIndexMarker1979"/><span class="koboSpan" id="kobo.474.1">payment data. </span><span class="koboSpan" id="kobo.474.2">It may also need to integrate with external payment services, such as PayPal, Stripe, online banking services, and </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.476.1">Shipping service</span></strong><span class="koboSpan" id="kobo.477.1">: This </span><a id="_idIndexMarker1980"/><span class="koboSpan" id="kobo.478.1">service is responsible for shipping the products, such as shipping a product to a customer and tracking the shipment. </span><span class="koboSpan" id="kobo.478.2">It needs to integrate with external shipping services, such as FedEx, UPS, and </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.480.1">Notification service</span></strong><span class="koboSpan" id="kobo.481.1">: This </span><a id="_idIndexMarker1981"/><span class="koboSpan" id="kobo.482.1">service is responsible for sending notifications to the customers, such as sending an email or a text message notification, and so on. </span><span class="koboSpan" id="kobo.482.2">It needs to integrate with external notification services, such as SendGrid, Twilio, and </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.484.1">Identity service</span></strong><span class="koboSpan" id="kobo.485.1">: This</span><a id="_idIndexMarker1982"/><span class="koboSpan" id="kobo.486.1"> service is responsible for managing users, such as creating a new user, updating a user, deleting a user, and so on. </span><span class="koboSpan" id="kobo.486.2">It may provide third-party authentication, such as from Microsoft, Google, Facebook, and </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.488.1">Gateway service</span></strong><span class="koboSpan" id="kobo.489.1">: This </span><a id="_idIndexMarker1983"/><span class="koboSpan" id="kobo.490.1">service is responsible for routing the requests to the appropriate microservices. </span><span class="koboSpan" id="kobo.490.2">It is the entry point of the system. </span><span class="koboSpan" id="kobo.490.3">It does not have its own database. </span><span class="koboSpan" id="kobo.490.4">Instead, it routes the requests to the appropriate microservices based on the request URL. </span><span class="koboSpan" id="kobo.490.5">It can also implement rate-limiting, authentication, authorization, and </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.492.1">Client applications</span></strong><span class="koboSpan" id="kobo.493.1">: These </span><a id="_idIndexMarker1984"/><span class="koboSpan" id="kobo.494.1">are the client applications that consume the microservices. </span><span class="koboSpan" id="kobo.494.2">They can be web applications, mobile applications, or </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">desktop applications.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.496.1">Each service is responsible for a specific business domain and has its own dependencies. </span><span class="koboSpan" id="kobo.496.2">Developers can use different technologies and frameworks to build the services because they communicate with each other through standard HTTP APIs or gRPC. </span><span class="koboSpan" id="kobo.496.3">If one service needs to be scaled, it can be scaled independently. </span><span class="koboSpan" id="kobo.496.4">For example, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Order</span></strong><span class="koboSpan" id="kobo.498.1"> service has a high workload, we can increase the number of instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">Order</span></strong><span class="koboSpan" id="kobo.500.1"> service to handle the workload. </span><span class="koboSpan" id="kobo.500.2">This is much more cost-effective than scaling the entire application. </span><span class="koboSpan" id="kobo.500.3">Moreover, if one service fails, it does not affect other services. </span><span class="koboSpan" id="kobo.500.4">For example, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">Payment</span></strong><span class="koboSpan" id="kobo.502.1"> service fails, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">Order</span></strong><span class="koboSpan" id="kobo.504.1"> service and </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">Product</span></strong><span class="koboSpan" id="kobo.506.1"> service can still work. </span><span class="koboSpan" id="kobo.506.2">It can still receive orders and allow users to view products. </span><span class="koboSpan" id="kobo.506.3">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Payment</span></strong><span class="koboSpan" id="kobo.508.1"> service is back online, it can process the orders that have not </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">been processed.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">Microservices have become more and more popular in recent years. </span><span class="koboSpan" id="kobo.510.2">However, it increases the complexity of the system. </span><span class="koboSpan" id="kobo.510.3">Before adopting microservices, you should carefully consider whether it is suitable for your project. </span><span class="koboSpan" id="kobo.510.4">Consider the following challenges </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">to </span></span><span class="No-Break"><a id="_idIndexMarker1985"/></span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">microservices:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.513.1">Distributed system complexity</span></strong><span class="koboSpan" id="kobo.514.1">: Microservices are distributed systems. </span><span class="koboSpan" id="kobo.514.2">They are more complex than monolithic applications. </span><span class="koboSpan" id="kobo.514.3">For example, if one service needs to call another service, you need to consider how to handle the communication between the services and how to maintain the consistency of the data. </span><span class="koboSpan" id="kobo.514.4">In addition, you need to handle network failures, partial failures, cascading failures, and </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.516.1">Data management</span></strong><span class="koboSpan" id="kobo.517.1">: Each microservice has its own database. </span><span class="koboSpan" id="kobo.517.2">This makes it difficult to maintain data consistency, as transactions that span multiple microservices are not supported. </span><span class="koboSpan" id="kobo.517.3">To query data from multiple microservices, a distributed query mechanism must be implemented, which can be a </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">complex process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.519.1">Service discovery</span></strong><span class="koboSpan" id="kobo.520.1">: In a microservice architecture, each service has its own URL. </span><span class="koboSpan" id="kobo.520.2">They need to know the URLs of other services in order to communicate with them. </span><span class="koboSpan" id="kobo.520.3">This is called service discovery. </span><span class="koboSpan" id="kobo.520.4">There are many ways to implement service discovery, such as using a service registry, using a service mesh, and so on. </span><span class="koboSpan" id="kobo.520.5">The container orchestration tools, such as Kubernetes, can also be used to implement service discovery, as they can maintain the internal service URLs of </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">the microservices.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.522.1">Testing</span></strong><span class="koboSpan" id="kobo.523.1">: Testing a microservice architecture is more complex than testing a monolithic application. </span><span class="koboSpan" id="kobo.523.2">In addition to unit testing, integration testing, and end-to-end testing, you also need to test the communication between </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">the microservices.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.525.1">Monitoring</span></strong><span class="koboSpan" id="kobo.526.1">: Monitoring</span><a id="_idIndexMarker1986"/><span class="koboSpan" id="kobo.527.1"> a microservice architecture requires a well-designed monitoring system. </span><span class="koboSpan" id="kobo.527.2">You need to monitor the health of each microservice, as well as the communication between the microservices. </span><span class="koboSpan" id="kobo.527.3">The tracing mechanism can be used to trace the requests between </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">the microservices.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.529.1">In summary, if your application is simple, do not overcomplicate it by using microservices. </span><span class="koboSpan" id="kobo.529.2">As your application grows, you can consider refactoring it into microservice architecture step </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">by step.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">Next, let us discus</span><a id="_idTextAnchor720"/><span class="koboSpan" id="kobo.532.1">s some common design patterns for web </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">API applications.</span></span></p>
<h1 id="_idParaDest-372"><a id="_idTextAnchor721"/><span class="koboSpan" id="kobo.534.1">Web API design patterns</span></h1>
<p><span class="koboSpan" id="kobo.535.1">To build a</span><a id="_idIndexMarker1987"/><span class="koboSpan" id="kobo.536.1"> flexible, scalable, and maintainable </span><a id="_idIndexMarker1988"/><span class="koboSpan" id="kobo.537.1">web API application, leveraging well-established design patterns is essential. </span><span class="koboSpan" id="kobo.537.2">These patterns address common challenges encountered in web API development, providing effective solutions. </span><span class="koboSpan" id="kobo.537.3">Microsoft’s comprehensive guide offers insights into these design patterns, and you can find more details at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">link: </span></span><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/"><span class="No-Break"><span class="koboSpan" id="kobo.539.1">https://learn.microsoft.com/en-us/azure/architecture/patterns/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.540.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">These design patterns are not exclusive to ASP.NET Core; they can be applied to any web API, regardless of the underlying technology or framework. </span><span class="koboSpan" id="kobo.541.2">In the following sub-sections, we will introduce some key design patterns, outlining the problems they solve, their implementation details, and considerations for their usage. </span><span class="koboSpan" id="kobo.541.3">These patterns cover solution design and implementation, messaging, reliability, and so on, including </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.543.1">Command query responsibility </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.544.1">segregation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.545.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.546.1">CQRS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">)</span></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.548.1">Publish/subscribe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.549.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.550.1">pub/sub</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.552.1">Backend for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.553.1">fr</span><a id="_idTextAnchor722"/><span class="koboSpan" id="kobo.554.1">ontend</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.555.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.556.1">BFF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.558.1">Timeout</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.559.1">Rate limiting</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.560.1">Retry</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.561.1">Circuit breaker</span></span></li>
</ul>
<h2 id="_idParaDest-373"><a id="_idTextAnchor723"/><span class="koboSpan" id="kobo.562.1">CQRS</span></h2>
<p><span class="koboSpan" id="kobo.563.1">CQRS is a </span><a id="_idIndexMarker1989"/><span class="koboSpan" id="kobo.564.1">powerful tool for addressing the challenge </span><a id="_idIndexMarker1990"/><span class="koboSpan" id="kobo.565.1">of scaling and optimizing read and write operations. </span><span class="koboSpan" id="kobo.565.2">By separating the responsibilities for handling commands (writes) and queries (reads), CQRS enables each operation to be optimized independently, resulting in improved scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">and efficiency.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">Traditionally, the data model of an application is designed to support both read and write operations. </span><span class="koboSpan" id="kobo.567.2">However, the requirements for read and write operations are often different. </span><span class="koboSpan" id="kobo.567.3">The read operations may execute different queries, resulting in different DTO models. </span><span class="koboSpan" id="kobo.567.4">The write operations may need to update multiple tables in the database. </span><span class="koboSpan" id="kobo.567.5">This may lead to a complex data model that is difficult to maintain. </span><span class="koboSpan" id="kobo.567.6">In addition, the read operations and write operations may have different </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">performance requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">CQRS divides the application’s data model into separate models for reading and writing. </span><span class="koboSpan" id="kobo.569.2">This enables the use of different storage mechanisms and optimizations tailored to the specific needs of each operation. </span><span class="koboSpan" id="kobo.569.3">CQRS uses queries to read data and commands to update data. </span><span class="koboSpan" id="kobo.569.4">Queries do not change the state of the system, while </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">commands do.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">To better separate the read and write operations, CQRS can also use different data stores for reading and writing. </span><span class="koboSpan" id="kobo.571.2">For example, the read store can use multiple read-only replicas of the write store, which can improve the performance of the read operations. </span><span class="koboSpan" id="kobo.571.3">The replicas must be kept in sync with the write store, which can be done by using built-in database replication features or an </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">event-driven mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">The following</span><a id="_idIndexMarker1991"/><span class="koboSpan" id="kobo.574.1"> diagram shows a typical </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">CQRS architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer183">
<span class="koboSpan" id="kobo.576.1"><img alt="Figure 17.3 – Typical CQRS architecture" src="image/B18971_17_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.577.1">Figure 17.3 – Typical CQRS architecture</span></p>
<p><span class="koboSpan" id="kobo.578.1">To </span><a id="_idIndexMarker1992"/><span class="koboSpan" id="kobo.579.1">implement CQRS in ASP.NET Core web API applications, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">MediatR</span></strong><span class="koboSpan" id="kobo.581.1"> library, which is a simple mediator implementation in .NET. </span><span class="koboSpan" id="kobo.581.2">This library is a simple mediator implementation in .NET that enables the use of the mediator pattern. </span><span class="koboSpan" id="kobo.581.3">The mediator pattern is a behavioral design pattern that enables objects to interact without having to refer to each other explicitly. </span><span class="koboSpan" id="kobo.581.4">Instead, they communicate through the mediator, which decouples the objects and allows for </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">greater flexibility.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">The following diagram shows a typical CQRS architecture using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">MediatR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.585.1"> library:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer184">
<span class="koboSpan" id="kobo.586.1"><img alt="Figure 17.4 – Typical CQRS architecture using the MediatR library" src="image/B18971_17_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.587.1">Figure 17.4 – Typical CQRS architecture using the MediatR library</span></p>
<p><span class="koboSpan" id="kobo.588.1">In the preceding </span><a id="_idIndexMarker1993"/><span class="koboSpan" id="kobo.589.1">diagram, the mediator is responsible for receiving the commands and queries from the business logic layer and then invoking the corresponding handlers to execute the commands and queries. </span><span class="koboSpan" id="kobo.589.2">Then, the handlers can use the repositories to access the data persistence layer for reading and writing data. </span><span class="koboSpan" id="kobo.589.3">The business logic layer does not need to know how the mediator invokes the handlers. </span><span class="koboSpan" id="kobo.589.4">It only needs to send the commands and queries to the mediator. </span><span class="koboSpan" id="kobo.589.5">This decouples the business logic layer from the data persistence layer. </span><span class="koboSpan" id="kobo.589.6">This pattern also makes it easier to send commands and queries to multiple handlers. </span><span class="koboSpan" id="kobo.589.7">For example, if we have a command to send an email notification to the customer and we need to add a text message notification, we can simply add a new handler to handle the command without changing the </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">client code.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">You can find a sample application that demonstrates how to implement CQRS in ASP.NET Core web API applications in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">/chapter17/CqrsDemo</span></strong><span class="koboSpan" id="kobo.593.1"> folder of the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">source code.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.595.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.596.1">The sample project has a separate infrastructure project to implement the data persistence layer by following clean architecture. </span><span class="koboSpan" id="kobo.596.2">When you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">dotnet ef</span></strong><span class="koboSpan" id="kobo.598.1"> command to add a migration or update the database, you need to specify the startup project. </span><span class="koboSpan" id="kobo.598.2">For example, to add a migration, you need to navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">CqrsDemo.Infrastructure</span></strong><span class="koboSpan" id="kobo.600.1"> project and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">following command:</span></span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.602.1">dotnet ef migrations add InitialCreate --</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.603.1">startup-project ../CqrsDemo.WebApi</span></strong></span></p>
<p><span class="koboSpan" id="kobo.604.1">To learn more about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">dotnet ef</span></strong><span class="koboSpan" id="kobo.606.1"> command, you can refer to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">link: </span></span><a href="https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project"><span class="No-Break"><span class="koboSpan" id="kobo.608.1">https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.609.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">To follow the next steps, you can use the project in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">/chapter17/CqrsDemo/start</span></strong><span class="koboSpan" id="kobo.612.1"> folder of the source code. </span><span class="koboSpan" id="kobo.612.2">This project contains a basic ASP.NET Core web API application to manage the invoices. </span><span class="koboSpan" id="kobo.612.3">It contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">following projects:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">CqrsDemo.WebApi</span></strong><span class="koboSpan" id="kobo.615.1">: This is the ASP.NET Core web API project. </span><span class="koboSpan" id="kobo.615.2">It contains the controllers and </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">application configurations.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">CqrsDemo.Core</span></strong><span class="koboSpan" id="kobo.618.1">: This is the core project that contains the domain models, interfaces of repositories, services, and </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">so on.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">CqrsDemo.Infrastructure</span></strong><span class="koboSpan" id="kobo.621.1">: This project contains the implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the repositories.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.623.1">Implementing the model mapping</span></h3>
<p><span class="koboSpan" id="kobo.624.1">In the </span><a id="_idIndexMarker1994"/><span class="koboSpan" id="kobo.625.1">core project, note that the service layer uses DTOs, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
public interface IInvoiceService{
    Task&lt;InvoiceDto?&gt; GetAsync(Guid id, CancellationToken cancellationToken = default);
    Task&lt;List&lt;InvoiceWithoutItemsDto&gt;&gt; GetPagedListAsync(int pageIndex, int pageSize, CancellationToken cancellationToken = default);
    Task&lt;InvoiceDto&gt; AddAsync(CreateOrUpdateInvoiceDto invoice, CancellationToken cancellationToken = default);
    Task&lt;InvoiceDto?&gt; UpdateAsync(Guid id, CreateOrUpdateInvoiceDto invoice, CancellationToken cancellationToken = default);
    // Omitted
}</span></pre>
<p><span class="koboSpan" id="kobo.628.1">These methods </span><a id="_idIndexMarker1995"/><span class="koboSpan" id="kobo.629.1">use different DTO types for reading and writing. </span><span class="koboSpan" id="kobo.629.2">To map the entities to DTOs and vice versa, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">AutoMapper</span></strong><span class="koboSpan" id="kobo.631.1">, which is a popular </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">object-to-object mapper</span></strong><span class="koboSpan" id="kobo.633.1"> library. </span><span class="koboSpan" id="kobo.633.2">The following code shows how to configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">AutoMapper</span></strong><span class="koboSpan" id="kobo.635.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">InvoiceProfile.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
public InvoiceProfile(){
    CreateMap&lt;CreateOrUpdateInvoiceItemDto, InvoiceItem&gt;();
    CreateMap&lt;InvoiceItem, InvoiceItemDto&gt;();
    CreateMap&lt;CreateOrUpdateInvoiceDto, Invoice&gt;();
    CreateMap&lt;Invoice, InvoiceWithoutItemsDto&gt;();
    CreateMap&lt;Invoice, InvoiceDto&gt;();
}</span></pre>
<p><span class="koboSpan" id="kobo.639.1">Then, we can register </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">AutoMapper</span></strong><span class="koboSpan" id="kobo.641.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">Program.cs</span></strong><span class="koboSpan" id="kobo.643.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
builder.Services.AddAutoMapper(typeof(InvoiceProfile));</span></pre> <p><span class="koboSpan" id="kobo.646.1">To use the mapper, just simply inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">IMapper</span></strong><span class="koboSpan" id="kobo.648.1"> interface into the service layer, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.650.1">
public class InvoiceService(IInvoiceRepository invoiceRepository, IMapper mapper) : IInvoiceService{
    public async Task&lt;InvoiceDto?&gt; GetAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var invoice = await invoiceRepository.GetAsync(id, cancellationToken);
        return invoice == null ? </span><span class="koboSpan" id="kobo.650.2">null : mapper.Map&lt;InvoiceDto&gt;(invoice);
    }
    // Omitted
}</span></pre>
<p><span class="koboSpan" id="kobo.651.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">AutoMapper</span></strong><span class="koboSpan" id="kobo.653.1"> can </span><a id="_idIndexMarker1996"/><span class="koboSpan" id="kobo.654.1">save us a lot of time for mapping the entities to DTOs and vice versa. </span><span class="koboSpan" id="kobo.654.2">Next, we can implement the queries and commands using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">MediatR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.656.1"> library.</span></span></p>
<h3><span class="koboSpan" id="kobo.657.1">Implementing queries</span></h3>
<p><span class="koboSpan" id="kobo.658.1">Next, we will</span><a id="_idIndexMarker1997"/><span class="koboSpan" id="kobo.659.1"> implement the CQRS pattern using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">MediatR</span></strong><span class="koboSpan" id="kobo.661.1"> library. </span><span class="koboSpan" id="kobo.661.2">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.663.1">First, we need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">MediatR</span></strong><span class="koboSpan" id="kobo.665.1"> NuGet package. </span><span class="koboSpan" id="kobo.665.2">Run the following command in the terminal window to install the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">MediatR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1"> package:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.668.1">dotnet add package MediatR</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.669.1">You need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">MediatR</span></strong><span class="koboSpan" id="kobo.671.1"> package to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">CqrsDemo.Core</span></strong><span class="koboSpan" id="kobo.673.1"> project and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">CqrsDemo.WebApi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.675.1"> project.</span></span></p><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">MediatR</span></strong><span class="koboSpan" id="kobo.677.1"> provides the </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">following interfaces:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">IMediator</span></strong><span class="koboSpan" id="kobo.680.1">: This is the main interface of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">MediatR</span></strong><span class="koboSpan" id="kobo.682.1"> library. </span><span class="koboSpan" id="kobo.682.2">It can be used to send requests to the handlers. </span><span class="koboSpan" id="kobo.682.3">It can also be used to publish events to </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">multiple handlers.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">ISender</span></strong><span class="koboSpan" id="kobo.685.1">: This interface is used to send a request through the mediator pipeline to be handled by a </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">single handler.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">IPublisher</span></strong><span class="koboSpan" id="kobo.688.1">: This interface is used to publish a notification or event through the mediator pipeline to be handled by </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">multiple handlers.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.690.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">IMediator</span></strong><span class="koboSpan" id="kobo.692.1"> interface can be used to send all requests or events. </span><span class="koboSpan" id="kobo.692.2">For a clearer indication of the purpose of the request or event, it is recommended to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">ISender</span></strong><span class="koboSpan" id="kobo.694.1"> interface for requests handled by a single handler and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">IPublisher</span></strong><span class="koboSpan" id="kobo.696.1"> interface for notifications or events that require </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">multiple handlers.</span></span></p></li> <li><span class="koboSpan" id="kobo.698.1">Create</span><a id="_idIndexMarker1998"/><span class="koboSpan" id="kobo.699.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">Queries</span></strong><span class="koboSpan" id="kobo.701.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">CqrsDemo.Core</span></strong><span class="koboSpan" id="kobo.703.1"> project. </span><span class="koboSpan" id="kobo.703.2">Then, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">GetInvoiceByIdQuery.cs</span></strong><span class="koboSpan" id="kobo.705.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">Queries</span></strong><span class="koboSpan" id="kobo.707.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.709.1">
public class GetInvoiceByIdQuery(Guid id) : IRequest&lt;InvoiceDto?&gt;{    public Guid Id { get; set; } = id;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.710.1">The preceding code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">GetInvoiceByIdQuery</span></strong><span class="koboSpan" id="kobo.712.1"> class that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">IRequest&lt;InvoiceDto?&gt;</span></strong><span class="koboSpan" id="kobo.714.1"> interface. </span><span class="koboSpan" id="kobo.714.2">This interface is used to indicate that this is a query that returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">InvoiceDto</span></strong><span class="koboSpan" id="kobo.716.1"> object. </span><span class="koboSpan" id="kobo.716.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">Id</span></strong><span class="koboSpan" id="kobo.718.1"> property is used to specify the ID of the invoice to </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">be retrieved.</span></span></p></li> <li><span class="koboSpan" id="kobo.720.1">Similarly, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">GetInvoiceListQuery.cs</span></strong><span class="koboSpan" id="kobo.722.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">Queries</span></strong><span class="koboSpan" id="kobo.724.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.726.1">
public class GetInvoiceListQuery(int pageIndex, int pageSize) : IRequest&lt;List&lt;InvoiceWithoutItemsDto&gt;&gt;{    public int PageIndex { get; set; } = pageIndex;    public int PageSize { get; set; } = pageSize;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.727.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">GetInvoiceListQuery</span></strong><span class="koboSpan" id="kobo.729.1"> query returns a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">InvoiceWithoutItemsDto</span></strong><span class="koboSpan" id="kobo.731.1"> objects. </span><span class="koboSpan" id="kobo.731.2">This is because we do not need the invoice items when listing the invoices. </span><span class="koboSpan" id="kobo.731.3">This is an example to show how to use different DTOs for reading </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">and writing.</span></span></p></li> <li><span class="koboSpan" id="kobo.733.1">Next, create</span><a id="_idIndexMarker1999"/><span class="koboSpan" id="kobo.734.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">Handlers</span></strong><span class="koboSpan" id="kobo.736.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">Queries</span></strong><span class="koboSpan" id="kobo.738.1"> folder. </span><span class="koboSpan" id="kobo.738.2">Then, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">GetInvoiceByIdQueryHandler.cs</span></strong><span class="koboSpan" id="kobo.740.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">Handlers</span></strong><span class="koboSpan" id="kobo.742.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.744.1">
public class GetInvoiceByIdQueryHandler(IInvoiceService invoiceService) : IRequestHandler&lt;GetInvoiceByIdQuery, InvoiceDto?&gt;{    public Task&lt;InvoiceDto?&gt; Handle(GetInvoiceByIdQuery request, CancellationToken cancellationToken)    {        return invoiceService.GetAsync(request.Id, cancellationToken);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.745.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">GetInvoiceByIdQueryHandler</span></strong><span class="koboSpan" id="kobo.747.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">IRequestHandler&lt;GetInvoiceByIdQuery, InvoiceDto?&gt;</span></strong><span class="koboSpan" id="kobo.749.1"> interface. </span><span class="koboSpan" id="kobo.749.2">This interface is used to indicate that this handler handles the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">GetInvoiceByIdQuery</span></strong><span class="koboSpan" id="kobo.751.1"> query and returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">InvoiceDto</span></strong><span class="koboSpan" id="kobo.753.1"> object. </span><span class="koboSpan" id="kobo.753.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">Handle()</span></strong><span class="koboSpan" id="kobo.755.1"> method receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">GetInvoiceByIdQuery</span></strong><span class="koboSpan" id="kobo.757.1"> query and invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">GetAsync()</span></strong><span class="koboSpan" id="kobo.759.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">IInvoiceService</span></strong><span class="koboSpan" id="kobo.761.1"> to get the invoice by using </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">the ID.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.763.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">IInvoiceService</span></strong><span class="koboSpan" id="kobo.765.1"> interface can be injected into the handler. </span><span class="koboSpan" id="kobo.765.2">Alternatively, you may choose to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">IInvoiceRepository</span></strong><span class="koboSpan" id="kobo.767.1"> interface directly into the handler and implement business logic there. </span><span class="koboSpan" id="kobo.767.2">Ultimately, it is your decision where to store the logic. </span><span class="koboSpan" id="kobo.767.3">It is important to keep in mind that the goal is to separate business logic from the data </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">persistence layer.</span></span></p></li> <li><span class="koboSpan" id="kobo.769.1">Similarly, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">GetInvoiceListQueryHandler.cs</span></strong><span class="koboSpan" id="kobo.771.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">Handlers</span></strong><span class="koboSpan" id="kobo.773.1"> folder </span><a id="_idIndexMarker2000"/><span class="koboSpan" id="kobo.774.1">with the </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.776.1">
public class GetInvoiceListQueryHandler(IInvoiceService invoiceService) : IRequestHandler&lt;GetInvoiceListQuery, List&lt;InvoiceWithoutItemsDto&gt;&gt;{    public Task&lt;List&lt;InvoiceWithoutItemsDto&gt;&gt; Handle(GetInvoiceListQuery request, CancellationToken cancellationToken)    {        return invoiceService.GetPagedListAsync(request.PageIndex, request.PageSize, cancellationToken);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.777.1">Now, we have two handlers to handle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">GetInvoiceByIdQuery</span></strong><span class="koboSpan" id="kobo.779.1"> query and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">GetInvoiceListQuery</span></strong><span class="koboSpan" id="kobo.781.1"> query. </span><span class="koboSpan" id="kobo.781.2">Next, we need to update the controllers to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">MediatR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.783.1"> library.</span></span></p></li> <li><span class="koboSpan" id="kobo.784.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">InvoicesController.cs</span></strong><span class="koboSpan" id="kobo.786.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">CqrsDemo.WebApi</span></strong><span class="koboSpan" id="kobo.788.1"> project with the </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.790.1">
[Route("api/[controller]")][ApiController]public class InvoicesController(IInvoiceService invoiceService, ISender mediatorSender) : ControllerBase{    // Omitted}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.791.1">The </span><a id="_idIndexMarker2001"/><span class="koboSpan" id="kobo.792.1">preceding code injects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">ISender()</span></strong><span class="koboSpan" id="kobo.794.1"> interface into the controller. </span><span class="koboSpan" id="kobo.794.2">You can also inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">IMediator</span></strong><span class="koboSpan" id="kobo.796.1"> interface instead. </span><span class="koboSpan" id="kobo.796.2">In this example, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">ISender</span></strong><span class="koboSpan" id="kobo.798.1"> interface to send the requests to </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">the handlers.</span></span></p></li> <li><span class="koboSpan" id="kobo.800.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">GetInvoice()</span></strong><span class="koboSpan" id="kobo.802.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">InvoicesController</span></strong><span class="koboSpan" id="kobo.804.1"> class with the </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.806.1">
[HttpGet("{id}")]public async Task&lt;ActionResult&lt;InvoiceDto&gt;&gt; GetInvoice(Guid id){    var invoice = await mediatorSender.Send(new GetInvoiceByIdQuery(id));    return invoice == null ? </span><span class="koboSpan" id="kobo.806.2">NotFound() : Ok(invoice);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.807.1">The preceding code creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">GetInvoiceByIdQuery</span></strong><span class="koboSpan" id="kobo.809.1"> object that contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">id</span></strong><span class="koboSpan" id="kobo.811.1"> parameter. </span><span class="koboSpan" id="kobo.811.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">ISender</span></strong><span class="koboSpan" id="kobo.813.1"> interface will invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">GetInvoiceByIdQueryHandler</span></strong><span class="koboSpan" id="kobo.815.1"> handler to handle the query. </span><span class="koboSpan" id="kobo.815.2">Then, the handler will invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">GetAsync</span></strong><span class="koboSpan" id="kobo.817.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">IInvoiceService</span></strong><span class="koboSpan" id="kobo.819.1"> to get the invoice via the ID. </span><span class="koboSpan" id="kobo.819.2">So, the controller is decoupled from the </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">service layer.</span></span></p></li> <li><span class="koboSpan" id="kobo.821.1">Similarly, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">GetInvoices</span></strong><span class="koboSpan" id="kobo.823.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">InvoicesController</span></strong><span class="koboSpan" id="kobo.825.1"> class with the </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.827.1">
[HttpGet][Route("paged")]public async Task&lt;ActionResultIEnumerableInvoiceWithoutItemsDto&gt;&gt;&gt; GetInvoices(int pageIndex, int pageSize){    var invoices = await mediatorSender.Send(new GetInvoiceListQuery(pageIndex, pageSize));    return Ok(invoices);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.828.1">The </span><a id="_idIndexMarker2002"/><span class="koboSpan" id="kobo.829.1">preceding code creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">GetInvoiceListQuery</span></strong><span class="koboSpan" id="kobo.831.1"> object that contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">pageIndex</span></strong><span class="koboSpan" id="kobo.833.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">pageSize</span></strong><span class="koboSpan" id="kobo.835.1"> parameters. </span><span class="koboSpan" id="kobo.835.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">ISender</span></strong><span class="koboSpan" id="kobo.837.1"> interface will invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">GetInvoiceListQueryHandler</span></strong><span class="koboSpan" id="kobo.839.1"> handler to handle the query. </span><span class="koboSpan" id="kobo.839.2">Then, the handler will invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">GetPagedListAsync()</span></strong><span class="koboSpan" id="kobo.841.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">IInvoiceService</span></strong><span class="koboSpan" id="kobo.843.1"> to get the list </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">of invoices.</span></span></p></li> <li><span class="koboSpan" id="kobo.845.1">Next, we need to register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">MediatR</span></strong><span class="koboSpan" id="kobo.847.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">Program.cs</span></strong><span class="koboSpan" id="kobo.849.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.851.1">
builder.Services.AddMediatR(cfg =&gt; cfg.RegisterServicesFromAssembly(typeof(GetInvoiceByIdQueryHandler).Assembly));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.852.1">The preceding code registers all three </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">MediatR</span></strong><span class="koboSpan" id="kobo.854.1"> interfaces and the handlers in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">CqrsDemo.Core</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.856.1"> project.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.857.1">Now, we use the queries to implement the read operations. </span><span class="koboSpan" id="kobo.857.2">You can run the application and test the endpoints, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">/api/invoices/{id}</span></strong><span class="koboSpan" id="kobo.859.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">/api/invoices/paged</span></strong><span class="koboSpan" id="kobo.861.1">. </span><span class="koboSpan" id="kobo.861.2">These endpoints should work </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">as before.</span></span></p>
<h3><span class="koboSpan" id="kobo.863.1">Implementing commands</span></h3>
<p><span class="koboSpan" id="kobo.864.1">Next, we</span><a id="_idIndexMarker2003"/><span class="koboSpan" id="kobo.865.1"> will implement the write operations using commands. </span><span class="koboSpan" id="kobo.865.2">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.867.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">Commands</span></strong><span class="koboSpan" id="kobo.869.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">CqrsDemo.Core</span></strong><span class="koboSpan" id="kobo.871.1"> project. </span><span class="koboSpan" id="kobo.871.2">Then, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">CreateInvoiceCommand.cs</span></strong><span class="koboSpan" id="kobo.873.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">Commands</span></strong><span class="koboSpan" id="kobo.875.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.877.1">
public class CreateInvoiceCommand(CreateOrUpdateInvoiceDto invoice) : IRequest&lt;InvoiceDto&gt;{    public CreateOrUpdateInvoiceDto Invoice { get; set; } = invoice;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.878.1">The </span><a id="_idIndexMarker2004"/><span class="koboSpan" id="kobo.879.1">preceding code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">CreateInvoiceCommand</span></strong><span class="koboSpan" id="kobo.881.1"> class that implements the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">IRequest&lt;InvoiceDto&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.883.1"> interface.</span></span></p></li> <li><span class="koboSpan" id="kobo.884.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">Handlers</span></strong><span class="koboSpan" id="kobo.886.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">Commands</span></strong><span class="koboSpan" id="kobo.888.1"> folder. </span><span class="koboSpan" id="kobo.888.2">Then, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">CreateInvoiceCommandHandler.cs</span></strong><span class="koboSpan" id="kobo.890.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">Handlers</span></strong><span class="koboSpan" id="kobo.892.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.894.1">
public class CreateInvoiceCommandHandler(IInvoiceService invoiceService) : IRequestHandler&lt;CreateInvoiceCommand, InvoiceDto&gt;{    public Task&lt;InvoiceDto&gt; Handle(CreateInvoiceCommand request, CancellationToken cancellationToken)    {        return invoiceService.AddAsync(request.Invoice, cancellationToken);    }}</span></pre></li> <li><span class="koboSpan" id="kobo.895.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">InvoicesController</span></strong><span class="koboSpan" id="kobo.897.1"> class with the </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.899.1">
[HttpPost]public async Task&lt;ActionResult&lt;InvoiceDto&gt;&gt; CreateInvoice(CreateOrUpdateInvoiceDto invoice){    var result = await mediatorSender.Send(new CreateInvoiceCommand(invoice));    return CreatedAtAction(nameof(GetInvoice), new { id = result.Id }, result);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.900.1">Now, run</span><a id="_idIndexMarker2005"/><span class="koboSpan" id="kobo.901.1"> the application and send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">POST</span></strong><span class="koboSpan" id="kobo.903.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">/api/invoices</span></strong><span class="koboSpan" id="kobo.905.1"> endpoint. </span><span class="koboSpan" id="kobo.905.2">You should be able to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">new invoice.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.907.1">We will not implement all the commands and queries in this example. </span><span class="koboSpan" id="kobo.907.2">You can work on the remaining commands and queries as </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">an exercise.</span></span></p></li> </ol>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">MediatR</span></strong><span class="koboSpan" id="kobo.910.1"> makes it easy to implement the CQRS pattern in ASP.NET Core web API applications. </span><span class="koboSpan" id="kobo.910.2">However, it is not the only way to implement CQRS. </span><span class="koboSpan" id="kobo.910.3">You can also implement CQRS without using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">MediatR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.912.1"> library.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">One benefit of using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">MediatR</span></strong><span class="koboSpan" id="kobo.915.1"> library is that it can send requests to multiple handlers. </span><span class="koboSpan" id="kobo.915.2">For example, we can create a command to send an email notification and a text message notification to the customer. </span><span class="koboSpan" id="kobo.915.3">Then, we can create two handlers to handle the command. </span><span class="koboSpan" id="kobo.915.4">Follow these steps to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">this feature:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.917.1">Add the two properties to the invoice models, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.919.1">
public string ContactEmail { get; set; } = string.Empty;public string ContactPhone { get; set; } = string.Empty;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.920.1">You need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">Invoice</span></strong><span class="koboSpan" id="kobo.922.1"> class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">CreateOrUpdateInvoiceDto</span></strong><span class="koboSpan" id="kobo.924.1"> class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">InvoiceWithoutItemsDto</span></strong><span class="koboSpan" id="kobo.926.1"> class, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">InvoiceDto</span></strong><span class="koboSpan" id="kobo.928.1"> class. </span><span class="koboSpan" id="kobo.928.2">You can also define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">Contact</span></strong><span class="koboSpan" id="kobo.930.1"> class for </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">better encapsulation.</span></span></p></li> <li><span class="koboSpan" id="kobo.932.1">Add the </span><a id="_idIndexMarker2006"/><span class="koboSpan" id="kobo.933.1">database migration and update the database. </span><span class="koboSpan" id="kobo.933.2">You may also need to update the seed data. </span><span class="koboSpan" id="kobo.933.3">Note that you need to specify the startup project when running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">dotnet ef</span></strong><span class="koboSpan" id="kobo.935.1"> command. </span><span class="koboSpan" id="kobo.935.2">For example, to add a migration, you need to navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">CqrsDemo.Infrastructure</span></strong><span class="koboSpan" id="kobo.937.1"> project and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.939.1">dotnet ef migrations add AddContactInfo --startup-project ../CqrsDemo.WebApi</span></strong></pre></li> <li><span class="koboSpan" id="kobo.940.1">Then, update </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">the database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.942.1">
dotnet ef database update --startup-project ../CqrsDemo.WebApi</span></pre></li> <li><span class="koboSpan" id="kobo.943.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">Notification</span></strong><span class="koboSpan" id="kobo.945.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">CqrsDemo.Core</span></strong><span class="koboSpan" id="kobo.947.1"> project. </span><span class="koboSpan" id="kobo.947.2">Then, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">SendInvoiceNotification</span></strong><span class="koboSpan" id="kobo.949.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">Notification</span></strong><span class="koboSpan" id="kobo.951.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.953.1">
public class SendInvoiceNotification(Guid invoiceId) : INotification{    public Guid InvoiceId { get; set; } = invoiceId;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.954.1">The preceding code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">SendInvoiceNotification</span></strong><span class="koboSpan" id="kobo.956.1"> class that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">INotification</span></strong><span class="koboSpan" id="kobo.958.1"> interface. </span><span class="koboSpan" id="kobo.958.2">This interface is used to indicate that this is a notification that does not return </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">any result.</span></span></p></li> <li><span class="koboSpan" id="kobo.960.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">Handlers</span></strong><span class="koboSpan" id="kobo.962.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">Notification</span></strong><span class="koboSpan" id="kobo.964.1"> folder. </span><span class="koboSpan" id="kobo.964.2">Then, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">SendInvoiceEmailNotificationHandler</span></strong><span class="koboSpan" id="kobo.966.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">Handlers</span></strong><span class="koboSpan" id="kobo.968.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.970.1">
public class SendInvoiceEmailNotificationHandler(IInvoiceService invoiceService) : INotificationHandler&lt;SendInvoiceNotification&gt;{    public async Task Handle(SendInvoiceNotification notification, CancellationToken cancellationToken)    {        // Send email notification        var invoice = await invoiceService.GetAsync(notification.InvoiceId, cancellationToken);        if (invoice is null || string.IsNullOrWhiteSpace(invoice.ContactEmail))        {            return;        }        // Send email notification        Console.WriteLine($"Sending email notification to {invoice.ContactEmail} for invoice {invoice.Id}");    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.971.1">In the </span><a id="_idIndexMarker2007"/><span class="koboSpan" id="kobo.972.1">preceding code, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">IInvocieService</span></strong><span class="koboSpan" id="kobo.974.1"> to obtain the invoice via the ID. </span><span class="koboSpan" id="kobo.974.2">Then, we check if the invoice exists and if the contact email is specified. </span><span class="koboSpan" id="kobo.974.3">If so, we send an email notification to the customer. </span><span class="koboSpan" id="kobo.974.4">For simplicity, we just print a message to </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">the console.</span></span></p></li> <li><span class="koboSpan" id="kobo.976.1">Similarly, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">SendInvoiceTextMessageNotificationHandler</span></strong><span class="koboSpan" id="kobo.978.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">Handlers</span></strong><span class="koboSpan" id="kobo.980.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.982.1">
public class SendInvoiceTextMessageNotificationHandler(IInvoiceService invoiceService) : INotificationHandler&lt;SendInvoiceNotification&gt;{    public async Task Handle(SendInvoiceNotification notification, CancellationToken cancellationToken)    {        // Send text message notification        var invoice = await invoiceService.GetAsync(notification.InvoiceId, cancellationToken);        if (invoice is null || string.IsNullOrWhiteSpace(invoice.ContactPhone))        {            return;        }        // Send text message notification        Console.WriteLine($"Sending text message notification to {invoice.ContactPhone} for invoice {invoice.Id}");    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.983.1">The </span><a id="_idIndexMarker2008"/><span class="koboSpan" id="kobo.984.1">preceding code is similar to the previous handler. </span><span class="koboSpan" id="kobo.984.2">It sends a text message notification to </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">the customer.</span></span></p></li> <li><span class="koboSpan" id="kobo.986.1">Inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">IPublisher</span></strong><span class="koboSpan" id="kobo.988.1"> interface into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">InvoicesController</span></strong><span class="koboSpan" id="kobo.990.1"> class, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.992.1">
public class InvoicesController(IInvoiceService invoiceService, ISender mediatorSender, IPublisher mediatorPublisher) : ControllerBase{    // Omitted}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.993.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">IPublisher</span></strong><span class="koboSpan" id="kobo.995.1"> interface </span><a id="_idIndexMarker2009"/><span class="koboSpan" id="kobo.996.1">is used to publish a notification or event through the mediator pipeline to be handled by </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">multiple handlers.</span></span></p></li> <li><span class="koboSpan" id="kobo.998.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">CreateInvoice</span></strong><span class="koboSpan" id="kobo.1000.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">InvoicesController</span></strong><span class="koboSpan" id="kobo.1002.1"> class with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1004.1">
[HttpPost]public async Task&lt;ActionResult&lt;InvoiceDto&gt;&gt; CreateInvoice(CreateOrUpdateInvoiceDto invoiceDto){    //var invoice = await invoiceService.AddAsync(invoiceDto);    var invoice = await mediatorSender.Send(new CreateInvoiceCommand(invoiceDto));    await mediatorPublisher.Publish(new SendInvoiceNotification(invoice.Id));    return CreatedAtAction(nameof(GetInvoice), new { id = invoice.Id }, invoice);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1005.1">In the preceding code, when creating a new invoice, we send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">SendInvoiceNotification</span></strong><span class="koboSpan" id="kobo.1007.1"> notification to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">IPublisher</span></strong><span class="koboSpan" id="kobo.1009.1"> interface. </span><span class="koboSpan" id="kobo.1009.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">IPublisher</span></strong><span class="koboSpan" id="kobo.1011.1"> interface will invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">SendInvoiceEmailNotificationHandler</span></strong><span class="koboSpan" id="kobo.1013.1"> handler and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">SendInvoiceTextMessageNotificationHandler</span></strong><span class="koboSpan" id="kobo.1015.1"> handler to handle the notification. </span><span class="koboSpan" id="kobo.1015.2">Then, they will send the email notification and text message notification to the customer. </span><span class="koboSpan" id="kobo.1015.3">If we need more notifications, we can simply add more handlers to handle the notification without changing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">controller code.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1017.1">Run the </span><a id="_idIndexMarker2010"/><span class="koboSpan" id="kobo.1018.1">application and send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">POST</span></strong><span class="koboSpan" id="kobo.1020.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">/api/invoices</span></strong><span class="koboSpan" id="kobo.1022.1"> endpoint to create a new invoice. </span><span class="koboSpan" id="kobo.1022.2">You should be able to see the console messages for the email notification and text </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">message notifications.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1024.1">This is just a simple example to demonstrate how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">MediatR</span></strong><span class="koboSpan" id="kobo.1026.1"> library to implement the CQRS pattern. </span><span class="koboSpan" id="kobo.1026.2">CQRS and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">MediatR</span></strong><span class="koboSpan" id="kobo.1028.1"> allow us to separate the read and write concerns and decouple the business logic layer from the data persistence layer. </span><span class="koboSpan" id="kobo.1028.2">You can also try to use different databases for reading and writing or even for different projects. </span><span class="koboSpan" id="kobo.1028.3">However, note that using different databases may lead to data consistency issues. </span><span class="koboSpan" id="kobo.1028.4">You can use the event-sourcing pattern with the CQRS pattern to maintain data consistency and full audit trails. </span><span class="koboSpan" id="kobo.1028.5">We will not cover the event-sourcing pattern in this book. </span><span class="koboSpan" id="kobo.1028.6">You can find more details about the event-sourcing pattern at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">link: </span></span><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing"><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1032.1">Next, we will introduce a popular patte</span><a id="_idTextAnchor724"/><span class="koboSpan" id="kobo.1033.1">rn for asynchronous communication between microservices: the </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">pub/sub pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.1035.1">Pub/sub</span></h3>
<p><span class="koboSpan" id="kobo.1036.1">In a </span><a id="_idIndexMarker2011"/><span class="koboSpan" id="kobo.1037.1">microservice architecture, the microservices</span><a id="_idIndexMarker2012"/><span class="koboSpan" id="kobo.1038.1"> communicate with each other through standard interfaces, such as HTTP APIs or gRPC. </span><span class="koboSpan" id="kobo.1038.2">Sometimes, a microservice may need to communicate with other services in an asynchronous way. </span><span class="koboSpan" id="kobo.1038.3">It may also need to broadcast an event to multiple services. </span><span class="koboSpan" id="kobo.1038.4">The pub/sub pattern can be used to address the need for loosely coupled communication between microservices. </span><span class="koboSpan" id="kobo.1038.5">It facilitates broadcasting events or messages to multiple subscribers without them being directly aware of </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">The pub/sub pattern is a communication model that facilitates the exchange of messages between publishers and subscribers without requiring them to be aware of each other. </span><span class="koboSpan" id="kobo.1040.2">It consists of three components: publishers, subscribers, and a message broker. </span><span class="koboSpan" id="kobo.1040.3">Publishers are responsible for publishing events or messages to the message broker, which then distributes them to subscribers. </span><span class="koboSpan" id="kobo.1040.4">Subscribers, in turn, subscribe to the message broker and receive the events or messages that have been published. </span><span class="koboSpan" id="kobo.1040.5">This pattern allows for asynchronous communication between publishers and subscribers, enabling them to remain independent of </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.1042.1">Many </span><a id="_idIndexMarker2013"/><span class="koboSpan" id="kobo.1043.1">message brokers can be used to implement the</span><a id="_idIndexMarker2014"/><span class="koboSpan" id="kobo.1044.1"> pub/sub pattern. </span><span class="koboSpan" id="kobo.1044.2">Some popular message brokers include </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1046.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.1047.1">: RabbitMQ is </span><a id="_idIndexMarker2015"/><span class="koboSpan" id="kobo.1048.1">an open-source, cross-platform </span><a id="_idIndexMarker2016"/><span class="koboSpan" id="kobo.1049.1">message broker that is widely used in microservice architectures. </span><span class="koboSpan" id="kobo.1049.2">It is lightweight and easy to deploy on-premises and in the cloud. </span><span class="koboSpan" id="kobo.1049.3">For more details, refer to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">link: </span></span><a href="https://rabbitmq.com/"><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">https://rabbitmq.com/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1053.1">Redis</span></strong><span class="koboSpan" id="kobo.1054.1">: Redis </span><a id="_idIndexMarker2017"/><span class="koboSpan" id="kobo.1055.1">is an open-source in-memory data structure </span><a id="_idIndexMarker2018"/><span class="koboSpan" id="kobo.1056.1">store. </span><span class="koboSpan" id="kobo.1056.2">It is versatile and has high performance. </span><span class="koboSpan" id="kobo.1056.3">Redis is a popular choice for various use cases, such as key-value databases, caches, and message brokers. </span><span class="koboSpan" id="kobo.1056.4">We learned how to use Redis as a cache in </span><a href="B18971_15.xhtml#_idTextAnchor632"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1057.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.1058.1">. </span><span class="koboSpan" id="kobo.1058.2">It can also be used as a message broker to implement the pub/sub pattern. </span><span class="koboSpan" id="kobo.1058.3">For more details, refer to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">link: </span></span><a href="https://redis.io/"><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">https://redis.io/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1062.1">Apache Kafka</span></strong><span class="koboSpan" id="kobo.1063.1">: Apache Kafka</span><a id="_idIndexMarker2019"/><span class="koboSpan" id="kobo.1064.1"> is an open-source, distributed </span><a id="_idIndexMarker2020"/><span class="koboSpan" id="kobo.1065.1">event-streaming platform. </span><span class="koboSpan" id="kobo.1065.2">It is a reliable and scalable message broker that can be used to implement the pub/sub pattern. </span><span class="koboSpan" id="kobo.1065.3">It ensures the durable and reliable storage of event streams in a scalable, fault-tolerant, and secure manner. </span><span class="koboSpan" id="kobo.1065.4">You can manage it yourself or use a managed service provided by a variety of cloud providers. </span><span class="koboSpan" id="kobo.1065.5">For more details, refer to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">link: </span></span><a href="https://kafka.apache.org/"><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">https://kafka.apache.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1069.1">Azure Service Bus</span></strong><span class="koboSpan" id="kobo.1070.1">: Azure Service Bus</span><a id="_idIndexMarker2021"/><span class="koboSpan" id="kobo.1071.1"> is a fully managed </span><a id="_idIndexMarker2022"/><span class="koboSpan" id="kobo.1072.1">enterprise message broker provided by Microsoft Azure. </span><span class="koboSpan" id="kobo.1072.2">It supports message queues and topics. </span><span class="koboSpan" id="kobo.1072.3">For more details, refer to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">link: </span></span><a href="https://learn.microsoft.com/en-us/azure/service-bus-messaging/"><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">https://learn.microsoft.com/en-us/azure/service-bus-messaging/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1076.1">The pub/sub pattern decouples the microservices from each other. </span><span class="koboSpan" id="kobo.1076.2">It also improves the scalability and reliability. </span><span class="koboSpan" id="kobo.1076.3">All the messages or events are handled in an asynchronous way. </span><span class="koboSpan" id="kobo.1076.4">This helps the service continue to function even if the workload increases or one of the services fails. </span><span class="koboSpan" id="kobo.1076.5">However, it also increases the complexity of the system. </span><span class="koboSpan" id="kobo.1076.6">You need to manage the message ordering, message priority, message duplication, message expiration, dead-letter queues, and so on. </span><span class="koboSpan" id="kobo.1076.7">To learn more about the pub/sub pattern, you can refer to the following </span><a id="_idTextAnchor725"/><span class="No-Break"><span class="koboSpan" id="kobo.1077.1">link: </span></span><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber"><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.1080.1">Backends for frontends</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.1081.1">Backends for frontends</span></strong><span class="koboSpan" id="kobo.1082.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1083.1">BFFs</span></strong><span class="koboSpan" id="kobo.1084.1">) address</span><a id="_idIndexMarker2023"/><span class="koboSpan" id="kobo.1085.1"> the challenge of efficiently serving diverse client</span><a id="_idIndexMarker2024"/><span class="koboSpan" id="kobo.1086.1"> interfaces with distinct requirements. </span><span class="koboSpan" id="kobo.1086.2">This is useful when applications need to serve multiple client types, such as web, mobile, and desktop. </span><span class="koboSpan" id="kobo.1086.3">Each client type may need a different data format. </span><span class="koboSpan" id="kobo.1086.4">In this case, a monolithic backend may struggle to cater to the unique needs of each client. </span><span class="koboSpan" id="kobo.1086.5">Specifically, if the backend includes multiple microservices, each microservice may need to provide multiple endpoints to serve different client types. </span><span class="koboSpan" id="kobo.1086.6">This can lead to a complex and </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">inefficient system.</span></span></p>
<p><span class="koboSpan" id="kobo.1088.1">BFF architecture is a useful solution for applications that need to serve multiple client types, such as web, mobile, and desktop. </span><span class="koboSpan" id="kobo.1088.2">Each client type may have distinct requirements for a data format, which can be difficult to manage with a monolithic backend. </span><span class="koboSpan" id="kobo.1088.3">If the backend includes multiple microservices, each microservice may need to provide multiple endpoints to serve different client types, resulting in a complex and inefficient system. </span><span class="koboSpan" id="kobo.1088.4">BFFs can help address this challenge by efficiently serving diverse client interfaces with </span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1">distinct requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.1090.1">BFF introduces dedicated backend services tailored for specific frontend clients. </span><span class="koboSpan" id="kobo.1090.2">Each frontend client has its corresponding backend, enabling fine-grained control over data retrieval, processing, and presentation. </span><span class="koboSpan" id="kobo.1090.3">This allows for a more efficient and flexible system that can better meet the needs of </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">each client.</span></span></p>
<p><span class="koboSpan" id="kobo.1092.1">The following diagram shows a</span><a id="_idIndexMarker2025"/><span class="koboSpan" id="kobo.1093.1"> typical </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">BFF architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer185">
<span class="koboSpan" id="kobo.1095.1"><img alt="Figure 17.5 – Typical BFF architecture" src="image/B18971_17_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1096.1">Figure 17.5 – Typical BFF architecture</span></p>
<p><span class="koboSpan" id="kobo.1097.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1098.1">Figure 17</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1099.1">.5</span></em><span class="koboSpan" id="kobo.1100.1">, each</span><a id="_idIndexMarker2026"/><span class="koboSpan" id="kobo.1101.1"> BFF service is responsible for a specific frontend client. </span><span class="koboSpan" id="kobo.1101.2">It can retrieve data from multiple microservices </span><a id="_idIndexMarker2027"/><span class="koboSpan" id="kobo.1102.1">and combine the data into a single response. </span><span class="koboSpan" id="kobo.1102.2">Each BFF service is fine-tuned to meet the specific needs of the frontend client. </span><span class="koboSpan" id="kobo.1102.3">It also illustrates how each BFF service is responsible for a particular frontend client. </span><span class="koboSpan" id="kobo.1102.4">Each BFF service is tailored to meet the specific requirements of the frontend client. </span><span class="koboSpan" id="kobo.1102.5">It can retrieve data from multiple microservices and combine them into a </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">single response.</span></span></p>
<p><span class="koboSpan" id="kobo.1104.1">BFFs should be lightweight. </span><span class="koboSpan" id="kobo.1104.2">They can contain client-specific logic but should not contain business logic. </span><span class="koboSpan" id="kobo.1104.3">The main purpose of BFFs is to tailor the data for each frontend client. </span><span class="koboSpan" id="kobo.1104.4">However, this may lead to code duplic</span><a id="_idTextAnchor726"/><span class="koboSpan" id="kobo.1105.1">ation. </span><span class="koboSpan" id="kobo.1105.2">If the data format is similar for multiple frontend clients, BFFs may not </span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1">be required.</span></span></p>
<h3><span class="koboSpan" id="kobo.1107.1">Resilience patterns</span></h3>
<p><span class="koboSpan" id="kobo.1108.1">In a </span><a id="_idIndexMarker2028"/><span class="koboSpan" id="kobo.1109.1">microservice architecture, resilience and </span><a id="_idIndexMarker2029"/><span class="koboSpan" id="kobo.1110.1">reliability are essential for a successful system. </span><span class="koboSpan" id="kobo.1110.2">web APIs are often subject to unpredictable environments, such as network latency, transient failures, service unavailability, high traffic, and so on. </span><span class="koboSpan" id="kobo.1110.3">To ensure that these APIs are </span><a id="_idIndexMarker2030"/><span class="koboSpan" id="kobo.1111.1">resilient and reliable, several patterns can be implemented. </span><span class="koboSpan" id="kobo.1111.2">These include retry, rate-limiting, time out, circuit breaker, and so on. </span><span class="koboSpan" id="kobo.1111.3">In this section, we will discuss how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">Polly</span></strong><span class="koboSpan" id="kobo.1113.1"> library to implement these patterns in ASP.NET Core web </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">API applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1115.1">You can</span><a id="_idIndexMarker2031"/><span class="koboSpan" id="kobo.1116.1"> find a sample project in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">/chapter17/PollyDemo</span></strong><span class="koboSpan" id="kobo.1118.1"> folder. </span><span class="koboSpan" id="kobo.1118.2">This project contains two basic ASP.NET Core web </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">API applications:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1121.1">, which behaves as </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">a server</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1124.1">, which is also a web API application but also behaves as </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">a client</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1126.1">We will use these two applications to demonstrate how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">Polly</span></strong><span class="koboSpan" id="kobo.1128.1"> library to implement the rate-limiting, retry, timeout, and circuit breaker. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">Polly</span></strong><span class="koboSpan" id="kobo.1130.1"> is a popular .NET resilience and transient-fault-handling library. </span><span class="koboSpan" id="kobo.1130.2">You can find more details about </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">Polly</span></strong><span class="koboSpan" id="kobo.1132.1"> at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">link: </span></span><a href="https://www.thepollyproject.org/"><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">https://www.thepollyproject.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1136.1">To use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">Polly</span></strong><span class="koboSpan" id="kobo.1138.1"> in ASP.NET Core web API applications, you need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">Polly</span></strong><span class="koboSpan" id="kobo.1140.1"> NuGet package. </span><span class="koboSpan" id="kobo.1140.2">Navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1142.1"> project and run the following command in the terminal window to install the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">Polly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1"> package:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1145.1">
dotnet add package Polly.Core</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">Polly</span></strong><span class="koboSpan" id="kobo.1147.1"> provides a resilience pipeline builder to build a resilience pipeline. </span><span class="koboSpan" id="kobo.1147.2">A resilience pipeline runs a series of resilience policies. </span><span class="koboSpan" id="kobo.1147.3">Each policy is responsible for handling a specific type of issue. </span><span class="koboSpan" id="kobo.1147.4">The following code shows how to create a resilience </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">pipeline builder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1149.1">
var pipeline = new </span><a id="_idTextAnchor727"/><span class="koboSpan" id="kobo.1150.1">ResiliencePipelineBuilder();</span></pre> <p><span class="koboSpan" id="kobo.1151.1">Next, we will explore several resilience policies provided </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">Polly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.1155.1">Timeout</span></h4>
<p><span class="koboSpan" id="kobo.1156.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.1157.1">timeout</span></strong><span class="koboSpan" id="kobo.1158.1"> pattern is a </span><a id="_idIndexMarker2032"/><span class="koboSpan" id="kobo.1159.1">common pattern used to</span><a id="_idIndexMarker2033"/><span class="koboSpan" id="kobo.1160.1"> handle slow or unresponsive services. </span><span class="koboSpan" id="kobo.1160.2">When a service is slow or unresponsive, the client may wait for an extended period before receiving a response. </span><span class="koboSpan" id="kobo.1160.3">To avoid this, a timeout can be set for the service. </span><span class="koboSpan" id="kobo.1160.4">If the service cannot respond within the given time frame, the client can return an error to the user, thus preventing them from </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">waiting unnecessarily.</span></span></p>
<p><span class="koboSpan" id="kobo.1162.1">In </span><a href="B18971_04.xhtml#_idTextAnchor170"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1163.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1164.1">, we</span><a id="_idIndexMarker2034"/><span class="koboSpan" id="kobo.1165.1"> introduced a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">RequestTimeout</span></strong><span class="koboSpan" id="kobo.1167.1"> middleware to set the timeout for the ASP.NET Core web API application. </span><span class="koboSpan" id="kobo.1167.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">RequestTimeout</span></strong><span class="koboSpan" id="kobo.1169.1"> middleware is applied to the endpoints or actions that need to be </span><a id="_idIndexMarker2035"/><span class="koboSpan" id="kobo.1170.1">timed out. </span><span class="koboSpan" id="kobo.1170.2">Sometimes, we may need to set the timeout for a specific method call, such as calling a REST API or querying a database. </span><span class="koboSpan" id="kobo.1170.3">Let us explore other ways to set </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">the timeout.</span></span></p>
<p><span class="koboSpan" id="kobo.1172.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1174.1"> class in .NET Core provides a timeout feature. </span><span class="koboSpan" id="kobo.1174.2">You can set the timeout for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1176.1"> object by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">Timeout</span></strong><span class="koboSpan" id="kobo.1178.1"> property. </span><span class="koboSpan" id="kobo.1178.2">The following code shows how to set the timeout for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">HttpClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1181.1">
var httpClient = httpClientFactory.CreateClient();httpClient.Timeout = TimeSpan.FromSeconds(10);</span></pre>
<p><span class="koboSpan" id="kobo.1182.1">The preceding code creates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1184.1"> object and sets the timeout to 10 seconds. </span><span class="koboSpan" id="kobo.1184.2">If the service does not respond within 10 seconds, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1186.1"> object will throw an exception. </span><span class="koboSpan" id="kobo.1186.2">You can catch the exception and return an error to </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.1188.1">Setting the timeout for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1190.1"> object is useful for simple tasks, such as calling a REST API. </span><span class="koboSpan" id="kobo.1190.2">However, it is not suitable for more complex tasks that do not use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1192.1">, such as a database query. </span><span class="koboSpan" id="kobo.1192.2">For other tasks, such as a database query, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">CancellationToken</span></strong><span class="koboSpan" id="kobo.1194.1"> to set the timeout. </span><span class="koboSpan" id="kobo.1194.2">The following code shows how to set the timeout for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">database query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1196.1">
var cancellationToken = new CancellationTokenSource(TimeSpan.FromSeconds(10));var invoice = await invoiceRepository.GetAsync(id, cancellationToken.Token);</span></pre>
<p><span class="koboSpan" id="kobo.1197.1">The preceding code creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">CancellationTokenSource</span></strong><span class="koboSpan" id="kobo.1199.1"> object and sets the timeout to 10 seconds. </span><span class="koboSpan" id="kobo.1199.2">If the database query is not complete within 10 seconds, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">GetAsync()</span></strong><span class="koboSpan" id="kobo.1201.1"> method will throw an exception. </span><span class="koboSpan" id="kobo.1201.2">This prevents the client from waiting for an extended period before receiving </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">a response.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">Sometimes, there may be multiple services that need to be called. </span><span class="koboSpan" id="kobo.1203.2">Moreover, setting the timeout for each service call may be tedious. </span><span class="koboSpan" id="kobo.1203.3">To simplify this, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">Polly</span></strong><span class="koboSpan" id="kobo.1205.1"> library to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">timeout policy.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">Polly</span></strong><span class="koboSpan" id="kobo.1208.1"> provides</span><a id="_idIndexMarker2036"/><span class="koboSpan" id="kobo.1209.1"> a timeout policy that can be used to set the </span><a id="_idIndexMarker2037"/><span class="koboSpan" id="kobo.1210.1">timeout for a service. </span><span class="koboSpan" id="kobo.1210.2">Follow these steps to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">timeout policy:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1212.1">Create an endpoint in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1214.1"> application to simulate a slow service. </span><span class="koboSpan" id="kobo.1214.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1216.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1218.1">
app.MapGet("/api/slow-response", async () =&gt;{    var random = new Random();    var delay = random.Next(1, 20);    await Task.Delay(delay * 1000);    return Results.Ok($"Response delayed by {delay} seconds");});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1219.1">The preceding code defines a minimal API endpoint that simulates a slow service. </span><span class="koboSpan" id="kobo.1219.2">It generates a random delay between 1 and 20 seconds. </span><span class="koboSpan" id="kobo.1219.3">This endpoint will return a response after the delay. </span><span class="koboSpan" id="kobo.1219.4">This is just an example of simulating a slow service. </span><span class="koboSpan" id="kobo.1219.5">In a real-world application, the service may be slow due to network latency, high traffic, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">so on.</span></span></p></li> <li><span class="koboSpan" id="kobo.1221.1">Create a controller in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1223.1"> application to call the slow service. </span><span class="koboSpan" id="kobo.1223.2">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">PollyController</span></strong><span class="koboSpan" id="kobo.1225.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">Controllers</span></strong><span class="koboSpan" id="kobo.1227.1"> folder with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1228.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1229.1">
namespace PollyClientWebApi.Controllers;[Route("api/[controller]")][ApiController]public class PollyController(ILogger&lt;PollyController&gt; logger, IHttpClientFactory httpClientFactory) : ControllerBase{    [HttpGet("slow-response")]    public async Task&lt;IActionResult&gt; GetSlowResponse()    {        var client = httpClientFactory.CreateClient("PollyServerWebApi");        var response = await client.GetAsync("api/slow-response");        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1230.1">This</span><a id="_idIndexMarker2038"/><span class="koboSpan" id="kobo.1231.1"> controller uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1233.1"> to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1235.1"> object. </span><span class="koboSpan" id="kobo.1235.2">Then, it calls the slow service and returns the response to </span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">the client.</span></span></p></li> <li><span class="koboSpan" id="kobo.1237.1">Run the</span><a id="_idIndexMarker2039"/><span class="koboSpan" id="kobo.1238.1"> two applications and send a request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">/api/polly/slow-response</span></strong><span class="koboSpan" id="kobo.1240.1"> endpoint of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1242.1"> application. </span><span class="koboSpan" id="kobo.1242.2">You should be able to see the response after a random delay between 1 and </span><span class="No-Break"><span class="koboSpan" id="kobo.1243.1">20 seconds.</span></span></li>
<li><span class="koboSpan" id="kobo.1244.1">Next, we will implement the timeout policy using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">Polly</span></strong><span class="koboSpan" id="kobo.1246.1">. </span><span class="koboSpan" id="kobo.1246.2">For example, we can set the timeout to 5 seconds, which means if the service does not respond within 5 seconds, the client will return an error to the user instead of waiting for a long time. </span><span class="koboSpan" id="kobo.1246.3">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">GetSlowResponse()</span></strong><span class="koboSpan" id="kobo.1248.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">PollyController</span></strong><span class="koboSpan" id="kobo.1250.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1252.1">
[HttpGet("slow-response")]public async Task&lt;IActionResult&gt; GetSlowResponse(){    var pipeline = new ResiliencePipelineBuilder().AddTimeout(TimeSpan.FromSeconds(5)).Build();    try    {        var response = await pipeline.ExecuteAsync(async cancellationToken =&gt;            await client.GetAsync("api/slow-response", cancellationToken));        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError(e.Message);        return Problem(e.Message);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1253.1">The </span><a id="_idIndexMarker2040"/><span class="koboSpan" id="kobo.1254.1">preceding code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">Polly</span></strong><span class="koboSpan" id="kobo.1256.1"> to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">ResiliencePipelineBuilder</span></strong><span class="koboSpan" id="kobo.1258.1"> object. </span><span class="koboSpan" id="kobo.1258.2">Then, it adds a timeout policy with a</span><a id="_idIndexMarker2041"/><span class="koboSpan" id="kobo.1259.1"> timeout of 5 seconds. </span><span class="koboSpan" id="kobo.1259.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">ExecuteAsync()</span></strong><span class="koboSpan" id="kobo.1261.1"> method is used to execute the pipeline. </span><span class="koboSpan" id="kobo.1261.2">If the service does not respond within 5 seconds, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">ExecuteAsync()</span></strong><span class="koboSpan" id="kobo.1263.1"> method will throw an exception. </span><span class="koboSpan" id="kobo.1263.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">catch</span></strong><span class="koboSpan" id="kobo.1265.1"> block is used to catch the exception and return an error to </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">the user.</span></span></p></li> <li><span class="koboSpan" id="kobo.1267.1">Note that in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">ExecuteAsync()</span></strong><span class="koboSpan" id="kobo.1269.1"> method, the cancellation token is passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">GetAsync()</span></strong><span class="koboSpan" id="kobo.1271.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1273.1"> object. </span><span class="koboSpan" id="kobo.1273.2">If it does not, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1275.1"> will </span><a id="_idIndexMarker2042"/><span class="koboSpan" id="kobo.1276.1">continue to wait even if the timeout occurs. </span><span class="koboSpan" id="kobo.1276.2">It is important to respect the cancellation token from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">Polly</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1278.1">resilience pipeline.</span></span></li>
<li><span class="koboSpan" id="kobo.1279.1">Run the two applications and send a request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">/api/polly/slow-response</span></strong><span class="koboSpan" id="kobo.1281.1"> endpoint of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1283.1"> application. </span><span class="koboSpan" id="kobo.1283.2">You should be able to see the error message after </span><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">5 seconds.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1285.1">In the preceding example, we </span><a id="_idIndexMarker2043"/><span class="koboSpan" id="kobo.1286.1">defined the timeout policy in the controller. </span><span class="koboSpan" id="kobo.1286.2">To reuse the timeout policy, we can define a global timeout policy in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1288.1"> file and then use dependency injection to inject the policy into the controller. </span><span class="koboSpan" id="kobo.1288.2">Follow these steps to implement the global </span><span class="No-Break"><span class="koboSpan" id="kobo.1289.1">timeout policy:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1290.1">Install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">Polly.Extensions</span></strong><span class="koboSpan" id="kobo.1292.1"> NuGet package. </span><span class="koboSpan" id="kobo.1292.2">Navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1294.1"> project and run the following command in the terminal window to install the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">Polly.Extensions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1296.1"> package:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1297.1">dotnet add package Polly.Extensions</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1298.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1300.1"> file of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1302.1"> application and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1304.1">
builder.Services.AddResiliencePipeline("timeout-5s-pipeline", configure =&gt;{    configure.AddTimeout(TimeSpan.FromSeconds(5));});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1305.1">The preceding code defines a global timeout policy with a timeout of 5 seconds. </span><span class="koboSpan" id="kobo.1305.2">The policy is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">timeout-5s-pipeline</span></strong><span class="koboSpan" id="kobo.1307.1">. </span><span class="koboSpan" id="kobo.1307.2">You can use any name you like. </span><span class="koboSpan" id="kobo.1307.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">AddResiliencePipeline()</span></strong><span class="koboSpan" id="kobo.1309.1"> method is used to add the timeout policy to </span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1">the pipeline.</span></span></p></li> <li><span class="koboSpan" id="kobo.1311.1">Inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">ResiliencePipelineProvider&lt;string&gt;</span></strong><span class="koboSpan" id="kobo.1313.1"> class into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">PollyController</span></strong><span class="koboSpan" id="kobo.1315.1"> class, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.1316.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1317.1">
public class PollyController(ILogger&lt;PollyController&gt; logger, IHttpClientFactory httpClientFactory, ResiliencePipelineProvider&lt;string&gt; resiliencePipelineProvider) : ControllerBase{    // Omitted}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1318.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">ResiliencePipelineProvider&lt;string&gt;</span></strong><span class="koboSpan" id="kobo.1320.1"> class is used to retrieve the global </span><a id="_idIndexMarker2044"/><span class="koboSpan" id="kobo.1321.1">timeout policy. </span><span class="koboSpan" id="kobo.1321.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">string</span></strong><span class="koboSpan" id="kobo.1323.1"> type parameter specifies the type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1324.1">policy name.</span></span></p></li> <li><span class="koboSpan" id="kobo.1325.1">Update </span><a id="_idIndexMarker2045"/><span class="koboSpan" id="kobo.1326.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">GetSlowResponse()</span></strong><span class="koboSpan" id="kobo.1328.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">PollyController</span></strong><span class="koboSpan" id="kobo.1330.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1331.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1332.1">
var pipeline = resiliencePipelineProvider.GetPipeline("timeout-5s-pipeline");// Omitted</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1333.1">In this way, we can reuse the global</span><a id="_idTextAnchor728"/><span class="koboSpan" id="kobo.1334.1"> timeout policy by </span><span class="No-Break"><span class="koboSpan" id="kobo.1335.1">its name.</span></span></p></li> </ol>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">Polly</span></strong><span class="koboSpan" id="kobo.1337.1"> supports many other resilience patterns. </span><span class="koboSpan" id="kobo.1337.2">Next, let us </span><span class="No-Break"><span class="koboSpan" id="kobo.1338.1">discuss rate-limiting.</span></span></p>
<h4><span class="koboSpan" id="kobo.1339.1">Rate-limiting</span></h4>
<p><span class="koboSpan" id="kobo.1340.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.1341.1">rate-limiting</span></strong><span class="koboSpan" id="kobo.1342.1"> pattern is </span><a id="_idIndexMarker2046"/><span class="koboSpan" id="kobo.1343.1">a common pattern</span><a id="_idIndexMarker2047"/><span class="koboSpan" id="kobo.1344.1"> used to limit the number of requests that can be made to a service. </span><span class="koboSpan" id="kobo.1344.2">The rate should be set to a reasonable value to avoid overloading the service. </span><span class="koboSpan" id="kobo.1344.3">You can run a performance test to determine the optimal rate limit. </span><span class="koboSpan" id="kobo.1344.4">The performance of the service depends on many factors, such as the hardware, network, and the complexity of business logic. </span><span class="koboSpan" id="kobo.1344.5">Once you have determined the optimal rate limit, you can apply it to the service to ensure that it can handle </span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1">the workload.</span></span></p>
<p><span class="koboSpan" id="kobo.1346.1">For example, if a </span><a id="_idIndexMarker2048"/><span class="koboSpan" id="kobo.1347.1">service can handle 100 requests per second when the number of requests exceeds 100, the service may become slow or even unavailable. </span><span class="koboSpan" id="kobo.1347.2">The client may encounter a timeout error. </span><span class="koboSpan" id="kobo.1347.3">To avoid this, we can set the rate limit for the service. </span><span class="koboSpan" id="kobo.1347.4">When the number of requests exceeds the rate limit, the service will reject the requests and return an error to the client. </span><span class="koboSpan" id="kobo.1347.5">This can prevent the service from </span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">being overloaded.</span></span></p>
<p><span class="koboSpan" id="kobo.1349.1">ASP.NET Core</span><a id="_idIndexMarker2049"/><span class="koboSpan" id="kobo.1350.1"> provides a rate-limiting middleware that can be used to configure rate-limiting in various policies, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">fixed window</span></strong><span class="koboSpan" id="kobo.1352.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">sliding window</span></strong><span class="koboSpan" id="kobo.1354.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">token bucket</span></strong><span class="koboSpan" id="kobo.1356.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">concurrency</span></strong><span class="koboSpan" id="kobo.1358.1">. </span><span class="koboSpan" id="kobo.1358.2">We introduced rate-limiting middleware in </span><a href="B18971_04.xhtml#_idTextAnchor170"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1359.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1360.1">. </span><span class="koboSpan" id="kobo.1360.2">You can find more details about rate-limiting middleware at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1361.1">link: </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit"><span class="No-Break"><span class="koboSpan" id="kobo.1362.1">https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1363.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1364.1">You can open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">PollyDemo</span></strong><span class="koboSpan" id="kobo.1366.1"> solution in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">/chapter17/PollyDemo/end</span></strong><span class="koboSpan" id="kobo.1368.1"> folder. </span><span class="koboSpan" id="kobo.1368.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1370.1"> file of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1372.1"> project, you can find the </span><span class="No-Break"><span class="koboSpan" id="kobo.1373.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1374.1">
builder.Services.AddRateLimiter(options =&gt;{
    options.AddFixedWindowLimiter("FiveRequestsInThreeSeconds", limiterOptions =&gt;
    {
        limiterOptions.PermitLimit = 5;
        limiterOptions.Window = TimeSpan.FromSeconds(3);
    });
    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
    options.OnRejected = async (context, _) =&gt;
    {
        await context.HttpContext.Response.WriteAsync("Too many requests. </span><span class="koboSpan" id="kobo.1374.2">Please try later.", CancellationToken.None);
    };
});
// Omitted
app.UseRateLimiter();</span></pre>
<p><span class="koboSpan" id="kobo.1375.1">The rate-limiting policy</span><a id="_idIndexMarker2050"/><span class="koboSpan" id="kobo.1376.1"> is applied to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">WeatherForecastController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1379.1">
[EnableRateLimiting("FiveRequestsInThreeSeconds")][ApiController]
[Route("[controller]")]
public class WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger) : ControllerBase
{
    // Omitted
}</span></pre>
<p><span class="koboSpan" id="kobo.1380.1">The </span><a id="_idIndexMarker2051"/><span class="koboSpan" id="kobo.1381.1">preceding code configures a fixed window rate limiter with a rate limit of five requests per 3 seconds. </span><span class="koboSpan" id="kobo.1381.2">Of course, this is just an example for demonstration purposes. </span><span class="koboSpan" id="kobo.1381.3">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1383.1"> application sends more than five requests per 3 seconds to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1385.1"> application, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1387.1"> application will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">429 Too Many Requests</span></strong><span class="koboSpan" id="kobo.1389.1"> error to the client. </span><span class="koboSpan" id="kobo.1389.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">OnRejected</span></strong><span class="koboSpan" id="kobo.1391.1"> callback is used to handle the rejected requests. </span><span class="koboSpan" id="kobo.1391.2">In this example, we simply return a message to </span><span class="No-Break"><span class="koboSpan" id="kobo.1392.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.1393.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">dotnet run</span></strong><span class="koboSpan" id="kobo.1395.1"> command to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1397.1"> application and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1399.1"> application. </span><span class="koboSpan" id="kobo.1399.2">Then, send more than five requests per 3 seconds to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">/weatherforecast</span></strong><span class="koboSpan" id="kobo.1401.1"> endpoint of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1403.1"> application. </span><span class="koboSpan" id="kobo.1403.2">You should be able to see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">429 Too Many Requests</span></strong><span class="koboSpan" id="kobo.1405.1"> error in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1407.1"> application. </span><span class="koboSpan" id="kobo.1407.2">In this way, we can limit the number of requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1409.1"> service so that it can handle the workload without </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">being overloaded.</span></span></p>
<p><span class="koboSpan" id="kobo.1411.1">We can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">Polly</span></strong><span class="koboSpan" id="kobo.1413.1"> to implement the rate-limiting pattern. </span><span class="koboSpan" id="kobo.1413.2">Follow these steps to implement the rate-limiting</span><a id="_idIndexMarker2052"/><span class="koboSpan" id="kobo.1414.1"> pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">Polly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1418.1">Install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">Polly.RateLimiting</span></strong><span class="koboSpan" id="kobo.1420.1"> NuGet package for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1422.1"> project by running the following command in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1423.1">terminal window:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1424.1">dotnet add package Polly.RateLimiting</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1425.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1426.1">Polly.RateLimiting</span></strong><span class="koboSpan" id="kobo.1427.1"> package is a wrapper for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1428.1">System.Threading.RateLimiting</span></strong><span class="koboSpan" id="kobo.1429.1"> package provided by Microsoft. </span><span class="koboSpan" id="kobo.1429.2">It also depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">Polly.Core</span></strong><span class="koboSpan" id="kobo.1431.1"> package. </span><span class="koboSpan" id="kobo.1431.2">So, if you have not installed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">Polly.Core</span></strong><span class="koboSpan" id="kobo.1433.1"> package, it will be </span><span class="No-Break"><span class="koboSpan" id="kobo.1434.1">installed automatically.</span></span></p></li> <li><span class="koboSpan" id="kobo.1435.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">/api/normal-response</span></strong><span class="koboSpan" id="kobo.1437.1"> endpoint in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1439.1"> application</span><a id="_idIndexMarker2053"/><span class="koboSpan" id="kobo.1440.1"> to simulate a normal service. </span><span class="koboSpan" id="kobo.1440.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1442.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1443.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1444.1">
app.MapGet("/api/normal-response", async () =&gt;{    var random = new Random();    var delay = random.Next(1, 1000);    await Task.Delay(delay);    return Results.Ok($"Response delayed by {delay} milliseconds");});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1445.1">This endpoint will return a response after a random delay between 1 and 1000 milliseconds, which means, in the worst case, it may take 1 second to return a response. </span><span class="koboSpan" id="kobo.1445.2">To limit the number of requests to this endpoint, we can use the rate-limiting policy for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">PollyClientWebApi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1447.1"> application.</span></span></p></li> <li><span class="koboSpan" id="kobo.1448.1">We will use the dependency injection to inject the rate-limiting policy for convenience. </span><span class="koboSpan" id="kobo.1448.2">Define a rate-limiting policy in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1449.1">Program.cs</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1450.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1451.1">
builder.Services.AddResiliencePipeline("rate-limit-5-requests-in-3-seconds", configure =&gt;{    configure.AddRateLimiter(new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions    { PermitLimit = 5, Window = TimeSpan.FromSeconds(3) }));});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1452.1">The preceding </span><a id="_idIndexMarker2054"/><span class="koboSpan" id="kobo.1453.1">code defines a fixed window rate limiter with a rate limit of 5 requests per 3 seconds. </span><span class="koboSpan" id="kobo.1453.2">The policy is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">rate-limit-5-requests-in-3-seconds</span></strong><span class="koboSpan" id="kobo.1455.1">. </span><span class="koboSpan" id="kobo.1455.2">You can use any name </span><span class="No-Break"><span class="koboSpan" id="kobo.1456.1">you like.</span></span></p></li> <li><span class="koboSpan" id="kobo.1457.1">In this </span><a id="_idIndexMarker2055"/><span class="koboSpan" id="kobo.1458.1">example, we create a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">Polly</span></strong><span class="koboSpan" id="kobo.1460.1"> pipeline for the rate-limiting policy. </span><span class="koboSpan" id="kobo.1460.2">You can also combine multiple policies into a single pipeline. </span><span class="koboSpan" id="kobo.1460.3">For example, you can combine the rate-limiting policy and the timeout policy into a single pipeline using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1461.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1462.1">
builder.Services.AddResiliencePipeline("combined-resilience-policy", configure =&gt;{    configure.AddRateLimiter(        // Omitted    );    configure.AddTimeout(        // Omitted    );    // You can add more policies here});</span></pre></li> <li><span class="koboSpan" id="kobo.1463.1">Inject</span><a id="_idIndexMarker2056"/><span class="koboSpan" id="kobo.1464.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">ResiliencePipelineProvider&lt;string&gt;</span></strong><span class="koboSpan" id="kobo.1466.1"> class into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">PollyController</span></strong><span class="koboSpan" id="kobo.1468.1"> class </span><a id="_idIndexMarker2057"/><span class="koboSpan" id="kobo.1469.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1470.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1471.1"> project, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.1472.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1473.1">
[HttpGet("rate-limit")]public async Task&lt;IActionResult&gt; GetNormalResponseWithRateLimiting(){    var client = httpClientFactory.CreateClient("PollyServerWebApi");    try    {        var pipeline = resiliencePipelineProvider.GetPipeline("rate-limit-5-requests-in-3-seconds");        var response = await pipeline.ExecuteAsync(async cancellationToken =&gt;            await client.GetAsync("api/normal-response", cancellationToken));        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError($"{e.GetType()} {e.Message}");        return Problem(e.Message);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1474.1">You will find </span><a id="_idIndexMarker2058"/><span class="koboSpan" id="kobo.1475.1">that the code is quite similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1476.1">timeout policy.</span></span></p></li> <li><span class="koboSpan" id="kobo.1477.1">Run the two applications and send more than 5 requests per 3 seconds to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">/api/polly/rate-limit</span></strong><span class="koboSpan" id="kobo.1479.1"> endpoint of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1481.1"> application. </span><span class="koboSpan" id="kobo.1481.2">Sometimes, you may see an error message in the console window of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1483.1"> application </span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1485.1">
Polly.RateLimiting.RateLimiterRejectedException The operation could not be executed because it was rejected by the rate limiter. </span><span class="koboSpan" id="kobo.1485.2">It can be retried after '00:00:03'.</span></pre></li> <li><span class="koboSpan" id="kobo.1486.1">Similarly, you </span><a id="_idIndexMarker2059"/><span class="koboSpan" id="kobo.1487.1">can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">Polly</span></strong><span class="koboSpan" id="kobo.1489.1"> to implement other rate-limiting policies, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">sliding window</span></strong><span class="koboSpan" id="kobo.1491.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">concurrency</span></strong><span class="koboSpan" id="kobo.1493.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">token bucket</span></strong><span class="koboSpan" id="kobo.1495.1">. </span><span class="koboSpan" id="kobo.1495.2">Here is an example of the sliding window </span><span class="No-Break"><span class="koboSpan" id="kobo.1496.1">rate limiter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1497.1">
configure.AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions{ PermitLimit = 100, Window = TimeSpan.FromMinutes(1) }));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1498.1">The preceding code defines a sliding window rate limiter with a rate limit of 100 requests </span><span class="No-Break"><span class="koboSpan" id="kobo.1499.1">per minute.</span></span></p></li> <li><span class="koboSpan" id="kobo.1500.1">As the Polly </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">RateLimiter</span></strong><span class="koboSpan" id="kobo.1502.1"> is a disposable resource, it is a good practice to dispose of it when it is no longer needed. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">Polly</span></strong><span class="koboSpan" id="kobo.1504.1"> provides an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">OnPipelineDisposed</span></strong><span class="koboSpan" id="kobo.1506.1"> callback that can be used to dispose of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">RateLimiter</span></strong><span class="koboSpan" id="kobo.1508.1"> object. </span><span class="koboSpan" id="kobo.1508.2">For example, we can dispose of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">RateLimiter</span></strong><span class="koboSpan" id="kobo.1510.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">OnPipelineDisposed</span></strong><span class="koboSpan" id="kobo.1512.1"> callback </span><span class="No-Break"><span class="koboSpan" id="kobo.1513.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1514.1">
builder.Services.AddResiliencePipeline("rate-limit-5-requests-in-3-seconds", (configure, context) =&gt;{    var rateLimiter = new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions    { PermitLimit = 5, Window = TimeSpan.FromSeconds(3) });    configure.AddRateLimiter(rateLimiter);    // Dispose the rate limiter when the pipeline is disposed    context.OnPipelineDisposed(() =&gt; rateLimiter.Dispose());});</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1515.1">In this way, w</span><a id="_idTextAnchor729"/><span class="koboSpan" id="kobo.1516.1">e </span><a id="_idIndexMarker2060"/><span class="koboSpan" id="kobo.1517.1">can dispose of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">RateLimiter</span></strong><span class="koboSpan" id="kobo.1519.1"> object </span><a id="_idIndexMarker2061"/><span class="koboSpan" id="kobo.1520.1">when the pipeline is disposed of so that it does not consume </span><span class="No-Break"><span class="koboSpan" id="kobo.1521.1">resources unnecessarily.</span></span></p>
<h4><span class="koboSpan" id="kobo.1522.1">Retry</span></h4>
<p><span class="koboSpan" id="kobo.1523.1">Next, let us</span><a id="_idIndexMarker2062"/><span class="koboSpan" id="kobo.1524.1"> discuss </span><strong class="bold"><span class="koboSpan" id="kobo.1525.1">retry</span></strong><span class="koboSpan" id="kobo.1526.1">. </span><span class="koboSpan" id="kobo.1526.2">When the client API gets an error, such as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">429 Too Many Requests</span></strong><span class="koboSpan" id="kobo.1528.1"> error, or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1529.1">500 Internal Server Error</span></strong><span class="koboSpan" id="kobo.1530.1"> error, it can retry the request after a delay because the error may be caused by a temporary issue, such as rate-limiting or a network glitch. </span><span class="koboSpan" id="kobo.1530.2">The next time the client API sends the request, it may succeed. </span><span class="koboSpan" id="kobo.1530.3">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.1531.1">called retry.</span></span></p>
<p><span class="koboSpan" id="kobo.1532.1">The retry pattern</span><a id="_idIndexMarker2063"/><span class="koboSpan" id="kobo.1533.1"> is a common approach to addressing transient failures in communication between microservices. </span><span class="koboSpan" id="kobo.1533.2">This pattern is particularly useful in a microservice architecture, where network glitches or the temporary unavailability of a service can cause communication failures. </span><span class="koboSpan" id="kobo.1533.3">By implementing retry mechanisms, these transient issues can be managed, and the overall reliability of the system can </span><span class="No-Break"><span class="koboSpan" id="kobo.1534.1">be improved.</span></span></p>
<p><span class="koboSpan" id="kobo.1535.1">Follow these steps to implement the retry pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.1536.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1537.1">Polly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1538.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1539.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1540.1">Get()</span></strong><span class="koboSpan" id="kobo.1541.1"> method </span><a id="_idIndexMarker2064"/><span class="koboSpan" id="kobo.1542.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1543.1">WeatherForecastController</span></strong><span class="koboSpan" id="kobo.1544.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1545.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1546.1">
[HttpGet(Name = "GetWeatherForecast")]public async Task&lt;ActionResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt;&gt; Get(){    var httpClient = httpClientFactory.CreateClient("PollyServerWebApi");    var pollyPipeline = new ResiliencePipelineBuilder()    .AddRetry(new Polly.Retry.RetryStrategyOptions()    {        ShouldHandle = new PredicateBuilder().Handle&lt;Exception&gt;(),        MaxRetryAttempts = 3,        Delay = TimeSpan.FromMilliseconds(500),        MaxDelay = TimeSpan.FromSeconds(5),        OnRetry = args =&gt;        {            logger.LogWarning($"Retry {args.AttemptNumber}, due to: {args.Outcome.Exception?.Message}.");            return default;        }    })    .Build();    HttpResponseMessage? </span><span class="koboSpan" id="kobo.1546.2">response = null;    await pollyPipeline.ExecuteAsync(async _ =&gt;    {        response = await httpClient.GetAsync("/WeatherForecast");        response.EnsureSuccessStatusCode();    });    if (response != null &amp; response!.IsSuccessStatusCode)    {        var result = await response.Content.ReadFromJsonAsync&lt;IEnumerable&lt;WeatherForecast&gt;&gt;();        return Ok(result);    }    return StatusCode((int)response.StatusCode, response.ReasonPhrase);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1547.1">The </span><a id="_idIndexMarker2065"/><span class="koboSpan" id="kobo.1548.1">preceding code creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1549.1">ResiliencePipelineBuilder</span></strong><span class="koboSpan" id="kobo.1550.1"> object to build a resilience pipeline. </span><span class="koboSpan" id="kobo.1550.2">Then, it adds a retry policy to the pipeline. </span><span class="koboSpan" id="kobo.1550.3">The retry policy will retry the request three times if it fails. </span><span class="koboSpan" id="kobo.1550.4">The </span><a id="_idIndexMarker2066"/><span class="koboSpan" id="kobo.1551.1">delay between retries is 500 milliseconds. </span><span class="koboSpan" id="kobo.1551.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">MaxDelay</span></strong><span class="koboSpan" id="kobo.1553.1"> property is used to specify the maximum delay duration. </span><span class="koboSpan" id="kobo.1553.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">OnRetry</span></strong><span class="koboSpan" id="kobo.1555.1"> callback is used to log the retry attempts. </span><span class="koboSpan" id="kobo.1555.2">Finally, it executes the pipeline to send the request to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">PollyServerWebApi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1557.1"> application.</span></span></p></li> <li><span class="koboSpan" id="kobo.1558.1">Run the two applications and send more than five requests per 3 seconds to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1559.1">/weatherforecast</span></strong><span class="koboSpan" id="kobo.1560.1"> endpoint of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1561.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1562.1"> application. </span><span class="koboSpan" id="kobo.1562.2">Sometimes, you may see that the request takes a longer time to complete. </span><span class="koboSpan" id="kobo.1562.3">This is because the request is retried if it fails. </span><span class="koboSpan" id="kobo.1562.4">You should also be able to see the retry attempts in the console window of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1563.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1564.1"> application, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.1565.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1566.1">
warn: PollyClientWebApi.Controllers.WeatherForecastController[0]      Retry 2, due to: Response status code does not indicate success: 429 (Too Many Requests)..</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1567.1">In this way, we can automatically retry the request if it fails. </span><span class="koboSpan" id="kobo.1567.2">This can improve the reliability of </span><span class="No-Break"><span class="koboSpan" id="kobo.1568.1">the system.</span></span></p></li> <li><span class="koboSpan" id="kobo.1569.1">The </span><a id="_idIndexMarker2067"/><span class="koboSpan" id="kobo.1570.1">retry policy can be configured in various ways. </span><span class="koboSpan" id="kobo.1570.2">For example, we can configure the retry policy to retry the request only when the response status code is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1571.1">429</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1572.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1573.1">
ShouldHandle = new PredicateBuilder().Handle&lt;Exception&gt;().Or&lt;HttpRequestException&gt;(ex =&gt; ex.StatusCode == HttpStatusCode.TooManyRequests),</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1574.1">We can also delay the retry attempts with an exponential backoff strategy. </span><span class="koboSpan" id="kobo.1574.2">This is because the service may be overloaded, and the retry attempts may fail again. </span><span class="koboSpan" id="kobo.1574.3">In this case, we can delay the retry attempts to avoid overloading </span><span class="No-Break"><span class="koboSpan" id="kobo.1575.1">the service.</span></span></p></li> <li><span class="koboSpan" id="kobo.1576.1">To use</span><a id="_idIndexMarker2068"/><span class="koboSpan" id="kobo.1577.1"> the exponential backoff strategy, we can specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1578.1">BackoffType</span></strong><span class="koboSpan" id="kobo.1579.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">RetryStrategyOptions</span></strong><span class="koboSpan" id="kobo.1581.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.1582.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1583.1">
BackoffType = DelayBackoffType.Exponential,</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1584.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">BackoffType</span></strong><span class="koboSpan" id="kobo.1586.1"> property is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1587.1">DelayBackoffType</span></strong><span class="koboSpan" id="kobo.1588.1"> enum that can be set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1589.1">Constant</span></strong><span class="koboSpan" id="kobo.1590.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">Linear</span></strong><span class="koboSpan" id="kobo.1592.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1593.1">Exponential</span></strong><span class="koboSpan" id="kobo.1594.1">. </span><span class="koboSpan" id="kobo.1594.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1595.1">Constant</span></strong><span class="koboSpan" id="kobo.1596.1"> strategy will delay the retry attempts with a constant delay. </span><span class="koboSpan" id="kobo.1596.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1597.1">Linear</span></strong><span class="koboSpan" id="kobo.1598.1"> strategy will delay the retry attempts with a linear delay. </span><span class="koboSpan" id="kobo.1598.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1599.1">Exponential</span></strong><span class="koboSpan" id="kobo.1600.1"> strategy will delay the retry attempts with an exponential delay. </span><span class="koboSpan" id="kobo.1600.2">The default strategy </span><span class="No-Break"><span class="koboSpan" id="kobo.1601.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">Constant</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1603.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1604.1">There are a </span><a id="_idIndexMarker2069"/><span class="koboSpan" id="kobo.1605.1">few considerations when using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1606.1">retry pattern:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1607.1">The retry pattern should only be used to handle transient failures. </span><span class="koboSpan" id="kobo.1607.2">If you want to implement a repeatable operation, you should use some scheduling mechanism, such as a background service, or suitable tools, such </span><a id="_idIndexMarker2070"/><span class="koboSpan" id="kobo.1608.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.1609.1">Quartz.NET</span></strong><span class="koboSpan" id="kobo.1610.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1611.1">Hangfire</span></strong><span class="koboSpan" id="kobo.1612.1">. </span><span class="koboSpan" id="kobo.1612.2">Do </span><a id="_idIndexMarker2071"/><span class="koboSpan" id="kobo.1613.1">not use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">Polly</span></strong><span class="koboSpan" id="kobo.1615.1"> retry to implement a scheduled </span><span class="No-Break"><span class="koboSpan" id="kobo.1616.1">repeating operation.</span></span></li>
<li><span class="koboSpan" id="kobo.1617.1">Consider using different retry policies for different types of errors. </span><span class="koboSpan" id="kobo.1617.2">For example, an API call may involve HTTP requests, database queries, and JSON deserialization. </span><span class="koboSpan" id="kobo.1617.3">If the HTTP request fails due to a network glitch, you can retry the request. </span><span class="koboSpan" id="kobo.1617.4">However, if the JSON deserialization fails, it is unlikely to succeed even if</span><a id="_idTextAnchor730"/><span class="koboSpan" id="kobo.1618.1"> you retry the JSON deserialization method. </span><span class="koboSpan" id="kobo.1618.2">In this case, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">ShouldHandle</span></strong><span class="koboSpan" id="kobo.1620.1"> to specify the types of errors that should </span><span class="No-Break"><span class="koboSpan" id="kobo.1621.1">be retried.</span></span></li>
</ul>
<h4><span class="koboSpan" id="kobo.1622.1">Circuit breaker</span></h4>
<p><span class="koboSpan" id="kobo.1623.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.1624.1">circuit breaker</span></strong><span class="koboSpan" id="kobo.1625.1"> pattern</span><a id="_idIndexMarker2072"/><span class="koboSpan" id="kobo.1626.1"> is a useful tool for</span><a id="_idIndexMarker2073"/><span class="koboSpan" id="kobo.1627.1"> preventing service overload and failure. </span><span class="koboSpan" id="kobo.1627.2">In the event that a service is becoming seriously overloaded, a client should stop sending requests for a period of time in order to allow the service to recover. </span><span class="koboSpan" id="kobo.1627.3">This is known as the circuit breaker pattern and can help to avoid a service crash or </span><span class="No-Break"><span class="koboSpan" id="kobo.1628.1">total failure.</span></span></p>
<p><span class="koboSpan" id="kobo.1629.1">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1630.1">Polly</span></strong><span class="koboSpan" id="kobo.1631.1"> to implement the circuit breaker pattern. </span><span class="koboSpan" id="kobo.1631.2">As we have already learned how to use Polly to implement the timeout pattern, the rate-limiting pattern, and the retry pattern, you should be able to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.1632.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1633.1">Create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1634.1">/api/random-failure-response</span></strong><span class="koboSpan" id="kobo.1635.1"> endpoint in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1636.1">PollyServerWebApi</span></strong><span class="koboSpan" id="kobo.1637.1"> application to simulate an overloaded service. </span><span class="koboSpan" id="kobo.1637.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1638.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1639.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1640.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1641.1">
app.MapGet("/api/random-failure-response", () =&gt;{    var random = new Random();    var delay = random.Next(1, 100);    return Task.FromResult(delay &gt; 20 ? </span><span class="koboSpan" id="kobo.1641.2">Results.Ok($"Response is successful.") : Results.StatusCode(StatusCodes.Status500InternalServerError));});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1642.1">This </span><a id="_idIndexMarker2074"/><span class="koboSpan" id="kobo.1643.1">endpoint will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1644.1">500 Internal Server Error</span></strong><span class="koboSpan" id="kobo.1645.1"> error with an 80% chance (approximately). </span><span class="koboSpan" id="kobo.1645.2">This is just an example of simulating an overloaded service. </span><span class="koboSpan" id="kobo.1645.3">In a real-world application, the service may be overloaded due to high traffic, network latency, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1646.1">so on.</span></span></p></li> <li><span class="koboSpan" id="kobo.1647.1">Add the following code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1648.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1649.1"> file of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1650.1">PollyClientWebApi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1651.1"> application:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1652.1">
builder.Services.AddResiliencePipeline("circuit-breaker-5-seconds", configure =&gt;{    configure.AddCircuitBreaker(new CircuitBreakerStrategyOptions    {        FailureRatio = 0.7,        SamplingDuration = TimeSpan.FromSeconds(10),        MinimumThroughput = 10,        BreakDuration = TimeSpan.FromSeconds(5),        ShouldHandle = new PredicateBuilder().Handle&lt;Exception&gt;()    });});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1653.1">The </span><a id="_idIndexMarker2075"/><span class="koboSpan" id="kobo.1654.1">preceding code defines a circuit breaker policy named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1655.1">circuit-breaker-5-seconds</span></strong><span class="koboSpan" id="kobo.1656.1"> with a failure ratio of 0.7. </span><span class="koboSpan" id="kobo.1656.2">This means if the failure ratio is greater than 0.7, the circuit breaker will open. </span><span class="koboSpan" id="kobo.1656.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1657.1">SamplingDuration</span></strong><span class="koboSpan" id="kobo.1658.1"> property is used to specify the duration of the sampling over which the failure ratios are calculated. </span><span class="koboSpan" id="kobo.1658.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1659.1">MinimumThroughput</span></strong><span class="koboSpan" id="kobo.1660.1"> property means that at least 10 requests must be made within the sampling duration. </span><span class="koboSpan" id="kobo.1660.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1661.1">BreakDuration</span></strong><span class="koboSpan" id="kobo.1662.1"> property means that the circuit breaker will stay open for 5 seconds if it opens. </span><span class="koboSpan" id="kobo.1662.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1663.1">ShouldHandle</span></strong><span class="koboSpan" id="kobo.1664.1"> property is used to specify the types of errors that should be handled by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1665.1">circuit breaker.</span></span></p></li> <li><span class="koboSpan" id="kobo.1666.1">Create a new</span><a id="_idIndexMarker2076"/><span class="koboSpan" id="kobo.1667.1"> action in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">PollyController</span></strong><span class="koboSpan" id="kobo.1669.1"> class of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1670.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1671.1"> application to call the overloaded service. </span><span class="koboSpan" id="kobo.1671.2">Add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1672.1">following</span></span><span class="No-Break"><a id="_idIndexMarker2077"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1673.1"> code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1674.1">
[HttpGet("circuit-breaker")]public async Task&lt;IActionResult&gt; GetRandomFailureResponseWithCircuitBreaker(){    var client = httpClientFactory.CreateClient("PollyServerWebApi");    try    {        var pipeline = resiliencePipelineProvider.GetPipeline("circuit-breaker-5-seconds");        var response = await pipeline.ExecuteAsync(async cancellationToken =&gt;            {                var result = await client.GetAsync("api/random-failure-response", cancellationToken);                result.EnsureSuccessStatusCode();                return result;            });        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError($"{e.GetType()} {e.Message}");        return Problem(e.Message);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1675.1">The </span><a id="_idIndexMarker2078"/><span class="koboSpan" id="kobo.1676.1">preceding code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1677.1">result.EnsureSuccessStatusCode()</span></strong><span class="koboSpan" id="kobo.1678.1"> to throw an exception if the response status</span><a id="_idIndexMarker2079"/><span class="koboSpan" id="kobo.1679.1"> code is not successful. </span><span class="koboSpan" id="kobo.1679.2">As the overloaded service has an 80% chance of returning an error, the circuit breaker will open after a couple of requests. </span><span class="koboSpan" id="kobo.1679.3">Then, the circuit breaker will stay open for 5 seconds. </span><span class="koboSpan" id="kobo.1679.4">During this period, the client will not send any requests to the overloaded service. </span><span class="koboSpan" id="kobo.1679.5">After 5 seconds, the circuit breaker will close, and the client will send requests to the overloaded </span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">service again.</span></span></p></li> <li><span class="koboSpan" id="kobo.1681.1">Run the two applications and send more than 10 requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1682.1">/api/polly/circuit-breaker</span></strong><span class="koboSpan" id="kobo.1683.1"> endpoint of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1684.1">PollyClientWebApi</span></strong><span class="koboSpan" id="kobo.1685.1"> application. </span><span class="koboSpan" id="kobo.1685.2">Sometimes, you will see a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1686.1">500 Internal Server Error</span></strong><span class="koboSpan" id="kobo.1687.1"> error </span><span class="No-Break"><span class="koboSpan" id="kobo.1688.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1689.1">
{  "type": "https://tools.ietf.org/html/rfc9110#section-15.6.1",  "title": "An error occurred while processing your request.",  "status": 500,  "detail": "Response status code does not indicate success: 500 (Internal Server Error).",  "traceId": "00-c5982555dbf0e66d5ca79fd83aa3837c-46cd1cd7f6acb851-00"}</span></pre></li> <li><span class="koboSpan" id="kobo.1690.1">Send more</span><a id="_idIndexMarker2080"/><span class="koboSpan" id="kobo.1691.1"> requests, and you will see that the circuit breaker opens and returns a different error message </span><span class="No-Break"><span class="koboSpan" id="kobo.1692.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1693.1">
{  "type": "https://tools.ietf.org/html/rfc9110#section-15.6.1",  "title": "An error occurred while processing your request.",  "status": 500,  "detail": "The circuit is now open and is not allowing calls.",  "traceId": "00-1b6dc3f8912f5ebd4e67a39a89dd605a-495d67559eaf22b7-00"}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1694.1">You can see </span><a id="_idIndexMarker2081"/><span class="koboSpan" id="kobo.1695.1">that the error message is different from the previous one, which indicates that the circuit breaker is open, so any requests to the overloaded service will be rejected. </span><span class="koboSpan" id="kobo.1695.2">You need to wait for 5 seconds before sending more requests to the overloaded service. </span><span class="koboSpan" id="kobo.1695.3">During these 5 seconds, all the requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1696.1">/api/polly/circuit-breaker</span></strong><span class="koboSpan" id="kobo.1697.1"> endpoint will not be sent to the overloaded service and will return the same error </span><span class="No-Break"><span class="koboSpan" id="kobo.1698.1">message instead.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1699.1">Circuit breakers are not the same as the retry pattern. </span><span class="koboSpan" id="kobo.1699.2">The retry pattern expects the operation to succeed eventually. </span><span class="koboSpan" id="kobo.1699.3">However, the circuit breaker pattern prevents the operation from being executed if it is likely to fail, which can save resources and allow the external service to recover. </span><span class="koboSpan" id="kobo.1699.4">You can use these two patterns together. </span><span class="koboSpan" id="kobo.1699.5">But note that the retry logic should check the exception type thrown by the circuit breaker. </span><span class="koboSpan" id="kobo.1699.6">If the circuit breaker indicates that the operation failure is not a</span><a id="_idIndexMarker2082"/><span class="koboSpan" id="kobo.1700.1"> transient issue, the retry logic should not retry </span><span class="No-Break"><span class="koboSpan" id="kobo.1701.1">the operation.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1702.1">Polly</span></strong><span class="koboSpan" id="kobo.1703.1"> is a</span><a id="_idIndexMarker2083"/><span class="koboSpan" id="kobo.1704.1"> powerful library that implements many resilience patterns. </span><span class="koboSpan" id="kobo.1704.2">This section cannot cover all the patterns provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1705.1">Polly</span></strong><span class="koboSpan" id="kobo.1706.1">. </span><span class="koboSpan" id="kobo.1706.2">You can find more examples</span><a id="_idIndexMarker2084"/><span class="koboSpan" id="kobo.1707.1"> at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1708.1">link: </span></span><a href="https://www.pollydocs.org/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.1709.1">https://www.pollydocs.org/index.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1711.1">In addition</span><a id="_idIndexMarker2085"/><span class="koboSpan" id="kobo.1712.1"> to the design patterns discussed in this chapter, there are more patterns for microservice architecture. </span><span class="koboSpan" id="kobo.1712.2">As many of these patterns are beyond the scope of this book, we will not discu</span><a id="_idTextAnchor731"/><span class="koboSpan" id="kobo.1713.1">ss them in detail. </span><span class="koboSpan" id="kobo.1713.2">You can find more details about these patterns from Microsoft </span><span class="No-Break"><span class="koboSpan" id="kobo.1714.1">Learn: </span></span><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/"><span class="No-Break"><span class="koboSpan" id="kobo.1715.1">https://learn.microsoft.com/en-us/azure/architecture/patterns/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1716.1">.</span></span></p>
<h1 id="_idParaDest-374"><a id="_idTextAnchor732"/><span class="koboSpan" id="kobo.1717.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1718.1">In this chapter, we explored several concepts and patterns for microservice architecture, including domain drive design, clean architecture, CQRS, pub/sub, and BFF, and resilience patterns, such as timeout, rate-limiting, retry, and circuit breaker. </span><span class="koboSpan" id="kobo.1718.2">These patterns can help us design and implement a maintainable, reliable, and scalable microservice architecture. </span><span class="koboSpan" id="kobo.1718.3">Although this chapter does not cover all the patterns for microservice architecture, it should provide a basic understanding of what they are and how they can be used. </span><span class="koboSpan" id="kobo.1718.4">These patterns are essential for developers who wish to progress beyond the basic knowledge of ASP.NET Core </span><span class="No-Break"><span class="koboSpan" id="kobo.1719.1">web API.</span></span></p>
<p><span class="koboSpan" id="kobo.1720.1">In the next chapter, we will discuss some open-source frameworks that can be used to </span><span class="No-Break"><span class="koboSpan" id="kobo.1721.1">build ASP.NET</span></span><span class="koboSpan" id="kobo.1722.1">
Core web API applications. </span><span class="koboSpan" id="kobo.1722.2">You can check the chapter out at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1723.1">link: </span></span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18"><span class="No-Break"><span class="koboSpan" id="kobo.1724.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1725.1">.</span></span></p>
<h2 id="_idParaDest-375"><a id="_idTextAnchor733"/><span class="koboSpan" id="kobo.1726.1">Further reading</span></h2>
<p><span class="koboSpan" id="kobo.1727.1">To learn more about microservice architecture, the following resources from Microsoft Learn are </span><span class="No-Break"><span class="koboSpan" id="kobo.1728.1">highly recommended:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1729.1">Architectural </span><span class="No-Break"><span class="koboSpan" id="kobo.1730.1">principles: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles"><span class="No-Break"><span class="koboSpan" id="kobo.1731.1">https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1732.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1733.1">Common web application </span><span class="No-Break"><span class="koboSpan" id="kobo.1734.1">architectures: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures"><span class="No-Break"><span class="koboSpan" id="kobo.1735.1">https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1736.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1737.1">.NET Microservices: Architecture for Containerized .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.1738.1">Applications: </span></span><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/"><span class="No-Break"><span class="koboSpan" id="kobo.1739.1">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1740.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1741.1">Architect Modern Web Applications with ASP.NET Core and </span><span class="No-Break"><span class="koboSpan" id="kobo.1742.1">Azure: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/"><span class="No-Break"><span class="koboSpan" id="kobo.1743.1">https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1744.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1745.1">Architecting Cloud Native .NET Applications for </span><span class="No-Break"><span class="koboSpan" id="kobo.1746.1">Azure: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/"><span class="No-Break"><span class="koboSpan" id="kobo.1747.1">https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1748.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1749.1">Serverless apps: Architecture, patterns, and Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.1750.1">implementation: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/architecture/serverless/"><span class="No-Break"><span class="koboSpan" id="kobo.1751.1">https://learn.microsoft.com/en-us/dostnet/architecture/serverless/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1752.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1753.1">Cloud Design </span><span class="No-Break"><span class="koboSpan" id="kobo.1754.1">Patterns: </span></span><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/"><span class="No-Break"><span class="koboSpan" id="kobo.1755.1">https://docs.microsoft.com/en-us/azure/architecture/patterns/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1756.1">.</span></span></li>
</ul>
</div>
</body></html>