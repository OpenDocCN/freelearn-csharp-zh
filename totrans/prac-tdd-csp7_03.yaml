- en: Setting Up a JavaScript Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explore setting up your JavaScript development environment
    with examples in pure JavaScript and React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing your IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up your testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first tests in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js, commonly called Node, is practically a requirement for doing modern
    web application development. In this section, we will discuss what Node is exactly,
    provide reasons why you need Node, and, finally, talk about where you can get
    Node installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with these subjects, then feel free to jump to the
    next section, where we discuss NPM in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: What is Node?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node was created in late 2009 by Ryan Dahl. Based on Chrome's V8 engine, Node
    provides a JavaScript runtime built for the purpose of providing evented, non-blocking
    I/O (input/output) for serving web applications.
  prefs: []
  type: TYPE_NORMAL
- en: At the time, Chrome had created the fastest JavaScript engine available. At
    the same time, they had decided to open-source the code for it. For these two
    extremely compelling reasons, Node decided to use the V8 engine.
  prefs: []
  type: TYPE_NORMAL
- en: Ryan Dahl was unhappy with the performance, at the time, of the very popular
    Apache HTTP server. One of the problems with the way that Apache was handling
    concurrent connections was that it was creating a new thread for each connection.
    Task creation and task switching between these threads are both CPU-and memory-intensive.
    For these reasons, instead of using threads for concurrent connections, Dahl decided
    to write Node with the intent of using an event loop coupled with a callback paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need Node?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform TDD in JavaScript for a modern web application, we absolutely need
    Node. When writing a modern web application, you will very likely be using one
    of these popular frameworks: ReactJS, Angular, Ember.js, Vue.js, or Polymer. The
    majority of these applications require a compilation step in Node.'
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for using Node is that we want to take advantage of new features
    in JavaScript. Node doesn’t support these features itself, but libraries have
    been written that will allow you to transpile the newer versions of JavaScript,
    ECMAScript 2015+, into a version of JavaScript that is supported by your target
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, for the purposes of this book, we need Node so that we can run our tests.
    Later, we will discuss how we can also run our tests continuously while we are
    writing our code. This is known as continuous testing and is a must-have for rapid
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several options for installing Node on your machine. We will cover
    installing manually and installing from a package management repository.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using a package management repository are many. The main reason
    that you would want to install this way would be the benefit of version management.
    Node updates versions frequently, and using a package manager can help to notify
    you of available updates. It can also help install those updates in a simple and
    efficient manner. We will start with a manual install, followed by installing
    using a Linux package manager, a Mac OSX package manager, and finally a Windows
    package manager.
  prefs: []
  type: TYPE_NORMAL
- en: To install Node manually, open your favorite browser and go to [http://nodejs.org](http://nodejs.org).
    You should see something similar to the following screenshot. Regardless of your
    operating system, the Node website will have a download link for both current
    and **Long Term Support** (**LTS**) versions of Node installation files. For Windows
    and Mac, the Node website provides installers. For Linux, Node provides binaries
    and source code. Assuming you are familiar with your operating system, the installation
    process is fairly straightforward and shouldn't present any issues.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Package managers greatly simplify the installation of many applications. If
    you are unfamiliar with package managers in general, they are based on the concept
    of having a repository of applications and tools that are available for installation
    on the system the package manager is for. Almost every system available has a
    package manager for it now. Linux has a different package manager for many distributions.
    Mac uses a system called *Homebrew, *and Windows has a package manager named *Chocolatey*.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will cover using the Ubuntu package manager, called `apt`, as Ubuntu
    is one of the most popular Linux systems. If you are using a different distribution,
    the process should be very similar. The only difference is the name of your package
    manager. Open a terminal window and enter the following commands to install Node
    for Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's that simple; now the latest version of Node is installed and ready for
    you to begin using. These same commands will update Node when a new version is
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Mac OSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mac doesn''t come with a package manager preinstalled. To install Homebrew,
    you must open a Terminal and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have Homebrew installed, you also have one more requirement that
    you must fulfill. You must install Apple''s Xcode, which can be found by searching
    the App Store. Just like any other application on a Mac, once you have found it,
    just click the Install application button, and Xcode will download and install:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have both prerequisites for Node installed on the system, installation
    is extremely simple. From a Terminal window, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating Node is also just as simple. Occasionally, when you want to update,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You now have the latest version of Node installed on your Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Windows also has a package manager. Just like Mac, the Windows package manager
    does not come preinstalled. The package manager for Windows is named Chocolatey
    and can be found at [https://chocolatey.org](https://chocolatey.org):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To install Chocolatey, open a Command Prompt (`cmd.exe`) as administrator and
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the Chocolatey installation has finished, you may need to restart the
    command window before you can use it. Restart the Command Prompt as an administrator,
    and then execute the following commands to install Node on windows using the Chocolatey
    package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once you've executed the first command, you will be prompted to execute a script.
    You will need to agree to run the script to install Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To upgrade Node using Chocolatey, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may need to agree to run the installation script. If prompted, simply hit
    the *Y* key and press *Enter*. You now have the latest version of Node.
  prefs: []
  type: TYPE_NORMAL
- en: NPM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NPM is a critical piece of the Node environment and community. Without NPM,
    Node would not have taken off quite like it has. In this section, we will discuss
    what NPM is, what NPM isn't, why you need NPM for doing Node development, and
    finally, where you can get NPM and how to install it.
  prefs: []
  type: TYPE_NORMAL
- en: What is NPM?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially released in early 2010, **NPM** (**Node Package Manager**). NPM was
    written by Isaac Z. Schlueter, and is now maintained by a team of developers.
    Although NPM has Node in the acronym, it can also be used to manage packages for
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the past few years, many package managers were created specifically for browser
    packages. One of the most prominent is *Bower*. These secondary package managers
    were created because NPM was perceived as a package manager best suited for, or
    perhaps only suited for, managing Node packages. This belief has subsided; however,
    Bower’s own website now suggests that it not be used.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need NPM?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you do need to install NPM, you don't necessarily have to use it. In late
    2016, Facebook released an alternative package manager named *Yarn*, which uses
    the NPM registry, so all of your favorite packages are available.
  prefs: []
  type: TYPE_NORMAL
- en: There are likely other package management alternatives to NPM as well. These
    alternative package managers are important because they drive improvements in
    NPM, but ultimately, they will likely fade and NPM will continue to be the preferred
    package manager for Node, and for JavaScript in general. If you do decide to use
    an alternative package manager such as Yarn, you will need to install it using
    NPM.
  prefs: []
  type: TYPE_NORMAL
- en: Installing NPM?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Good news; you already have NPM installed if you have gone through the process
    of installing Node. You may occasionally want to upgrade NPM outside Node''s release
    cycle. To attempt an upgrade, simply open your operating system''s preferred console
    or Terminal window and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: NPM is just another executable on your computer. It takes a list of arguments
    or parameters. In this case, we are asking NPM to install a package. The second
    argument, `-g`, tells NPM that we want to install the requested package globally.
    Lastly, the package we are asking NPM to install is NPM.
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to JavaScript IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you don't need an **IDE** (**Integrated Development Environment**) per
    se, you will need a text editor. Why not have a text editor that does a little
    bit of the heavy lifting for you? There are, essentially, two types of IDEs available
    for JavaScript development. The first kind is really more of a text editor than
    anything else, whereas the second kind is a full-blown editor with compiling and
    source control built in.
  prefs: []
  type: TYPE_NORMAL
- en: While you can work on JavaScript with only a simple text editor and a console/Terminal
    window, we recommend using something with at least a little more power.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code, as described in the C# section, is a lightweight editor
    based on the Electron framework and developed in TypeScript, a language designed
    by Microsoft to extend JavaScript with static types. TypeScript compiles to JavaScript,
    so ultimately Visual Studio Code is a JavaScript application.
  prefs: []
  type: TYPE_NORMAL
- en: Why Visual Studio Code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For working with JavaScript, there are several reasons why you might choose
    Visual Studio Code or one of the other Electron-based editors. VSCode is lightweight,
    has an extensive plugin architecture, is integrated with source control, and is
    very easy to set up and use.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing VSCode is extremely simple. If you have already followed along in
    the *C#* section, then you likely have VSCode installed already. If not, here
    are some alternative ways to install it that were not discussed there.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install on Linux (again, this is an example for Ubuntu), simply execute
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, I don't have a fancy command-line way to install  VSCode on a
    Mac. Instead, go to the Visual Studio Code homepage at [https://code.visualstudio.com](https://code.visualstudio.com) and
    follow the installation instructions there.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Windows, just like with Node, we can install VSCode using Chocolatey. To
    install using Chocolatey ([https://chocolatey.org/install](https://chocolatey.org/install)),
    execute the following command in a console window. Remember, you may want to run
    the console as an administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Installing the plugins you will need
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two plugins that we would recommend getting are `npm` and `npm-intellisense`
    because they will aid in the flow and provide hints when you are not 100% sure
    that you are using the correct package name.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the testing environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code offers built-in test running capabilities. We are not going
    to choose those options for JavaScript development, however. For the purposes
    of test driving our application and demonstrating our approach to testing, we
    think using the available Terminal inside VSCode will be more appropriate and
    better suited to the flow that will be used.
  prefs: []
  type: TYPE_NORMAL
- en: WebStorm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebStorm is a full-blown IDE written by JetBrains in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Why WebStorm?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebStorm basically comes with everything you need to develop a JavaScript-based
    application. It also supports many of the JavaScript ecosystem alternatives to
    JavaScript, such as TypeScript, Flow, and React JSX. WebStorm also integrates
    seamlessly with many code-quality tools such as ESLine, TSLint, and JSHint.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside to WebStorm is that it does cost money. But, when you look
    at it, a paid product is actually a good thing. The company making the paid product
    has a good reason to continue maintaining it. JetBrains offers the purchase of
    WebStorm through a single purchase or through a subscription. We suggest the subscription,
    as the upfront cost to you is minimized and JetBrains has more motivation to keep
    you happy this way.
  prefs: []
  type: TYPE_NORMAL
- en: Installing WebStorm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install WebStorm, we are going to use a newer program created by JetBrains
    called *The JetBrains Toolbox App*. The Toolbox App is designed to track version
    updates and provide a common launching point for all JetBrains products. Once
    installed, it becomes very easy to install any of the JetBrains tools.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There does not appear to be, at the time of writing, a way to install ToolBox
    or WebStorm from `apt-get`*.* So, we will have to do it the hard way. Go to the
    ToolBox download page at [https://www.jetbrains.com/toolbox/app/](https://www.jetbrains.com/toolbox/app/) and
    download the Linux tarball. Then, open a Terminal to your download directory.
    Once there, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Mac, we can again use Homebrew for installation. Just execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Windows, we are able to use Chocolatey to install Toolbox. Execute the following
    command and then launch the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our ultimate goal when installing the Toolbox was to install WebStorm. So, with
    the Toolbox open, either sign in if you have purchased any JetBrains products
    or skip the sign in if you just want to try them out. Next, find WebStorm in the
    products list and click the button to install it. Once the install has finished,
    you will be able to click a Launch button that will replace the Install button.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the plugins you will need
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've got good news for plugins with WebStorm. WebStorm offers a great plugin
    community, with every plugin you could possibly want accessible through a plugin
    management system built into the application. For the purposes of this book, however,
    you don't actually need any. So, we are done installing plugins! In fact, if anything,
    WebStorm has too much functionality built in, and we will be ignoring or even
    turning off some of it so that we can work the way we want to.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the testing environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as in Visual Studio Code, for WebStorm we are not going to cover setting
    up any of the built-in test running capability. WebStorm offers a Terminal display
    that can be turned on and supports having multiple contexts open at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Create React App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have Node and NPM installed and up-to-date, turn your attention
    to the application you want to test drive. Due to its constantly increasing popularity,
    we are choosing to explain and demonstrate Test-Driven Development by testing
    a React application.
  prefs: []
  type: TYPE_NORMAL
- en: According to the React website, React is *A JavaScript library for building
    user interfaces*. We are going to focus on using it for a front-end browser application,
    but it can be used to create mobile and desktop applications as well.
  prefs: []
  type: TYPE_NORMAL
- en: React was created and is maintained by Facebook. React was created to solve
    issues that Facebook had in its own user interface, and it is now taking the internet
    by storm. Facebook has also created a library called Create React App to quickly
    get a React application going.
  prefs: []
  type: TYPE_NORMAL
- en: What is Create React App?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create React App is an NPM package created by Facebook for the purpose of providing
    a zero-configuration way to create a react application. React requires quite a
    lot to get started, and it can take days to configure a React application manually.
    Create React App can reduce that time to under a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the global module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create React App has a global NPM package that must be installed before you
    can use the command-line utility to actually create a React application. To install
    the latest version of the Create React App global script, execute the following
    command in a console or Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating a React application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the global module is installed, you will be ready to start using Create
    React App. Creating a React application is extremely streamlined and simple. On
    my system, I have a directory `\projects` that I use to house all my front-end
    application projects. Open a console/Terminal window to a similarly purposed directory
    on your machine and execute the following command to create a new React application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the name of our test case is Speaker Meet, so as an example, my
    command is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: SpeakerMeet, as mentioned in the C# section, has both a back-end (the RESTful
    Web API) and a front-end (a React-based **SPA** (**Single Page Application**)).
  prefs: []
  type: TYPE_NORMAL
- en: Running the Create React App script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `create-react-app` script finishes running, a list of available commands
    is displayed. You want to make sure that everything was successfully created.
    You can launch the application by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If everything installed correctly, your default browser will open and a new
    React application will be running.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha and Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create React App supports testing right out of the box. Initially, Create React
    App uses a testing library named Jest. We want to use Mocha and Chai due to their
    popularity in the JavaScript community.
  prefs: []
  type: TYPE_NORMAL
- en: Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest is a testing framework written by Facebook. Just like Create React App,
    Jest is designed to be a zero-configuration tool. Jest also supports continuous
    testing and code coverage analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Jest is designed to work within the common **BDD** (**behavior-driven development**)
    paradigms, as are many other JavaScript testing frameworks. As such, the testing
    functions `describe` and `it` can both be used to write your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha is another JavaScript testing framework and is the one we would like to
    use. As for library interaction differences, there doesn't appear to be much different
    in terms of base interactions. The differences come down to the assertion library
    and the mocking library.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking, which will be covered in detail in [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195), *What
    to Know Before Getting Started*, is essentially a way to provide alternative implementations
    of objects, classes, and functions, specifically to aid the testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha itself doesn't come with an assertion library, so one must be provided.
    The assertion library is what controls test results and how to verify that your
    code is executing correctly. Most developers who use Mocha rely on Chai for assertions.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, another consideration is what mocking library you want
    to use. For many Mocha users, that library is unquestionably *Sinon*.
  prefs: []
  type: TYPE_NORMAL
- en: We will explain the purpose of any and all parts of Mocha that we use in this
    book. If you want to know more or want the documentation for quick reference while
    you are developing, you can go to the Mocha home page at [https://mochajs.org](https://mochajs.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocha can be installed into a JavaScript application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chai is a BDD assertion library. Chai uses a fluent API to allow for extremely
    flexible assertions. The two most popular ways that Chai is used are through the *should* and *expect* interfaces
    provided. The way that Chai works, and in fact, the way that every testing frameworks
    assertion works, is by throwing an exception when the check done by the assertion
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you had a variable named `foo` with a value *3* and your assertion
    was `expect(foo).to.equal(5)` when the test ran, that assertion would throw an
    exception with a message that says `expected 3 to equal 5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Chai into your project, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have Chai installed, there is one more step that must be taken to
    be able to use it within your project. You must include the following import at
    the top of each test file in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you wish to use should assertions, you can either replace `expect` with `should` or
    add `should` inside the curly braces, separating it from `expect` with a comma.
  prefs: []
  type: TYPE_NORMAL
- en: For more information or to refer to the documentation, the Chai home page is [https://chaijs.com](https://chaijs.com).
  prefs: []
  type: TYPE_NORMAL
- en: Sinon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won't be getting into mocking until [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195),
    *What to Know Before Getting Started*, but Sinon is the generally preferred mocking
    library among Mocha + Chai users. Some testing frameworks, such as Jest and Jasmine,
    come with their own mocking library features, but Mocha does not, and Sinon provides
    an excellent mocking experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Sinon into your project, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you will need to import Sinon before you can use it. Use the
    following import statement to enable the use of Sinon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Enzyme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enzyme is a library designed to aid in the testing of React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Enzyme into your project, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The extra libraries listed, `react-test-renderer` and `react-dom`, are dependencies
    of Enzyme that it needs to function correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other testing utilities mentioned in this section, we will get
    into usage as needed, while we discuss the topics covered in this book. But here
    is a quick example of a test using Enzyme from the Enzyme documentation at [https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Ejecting the React app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, this is where we part company with Create React App. In order
    to use Mocha, we will need to find an alternative way to work with the application.
    Because of the zero-configuration setup of Create React App, we cannot simply
    update the testing framework being used, and that is a problem for us.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Create React App gives us an out in the form of ejecting the application.
    Ejecting the React application will install all the necessary configuration files
    and utilities into our project and remove Create React App.  Once the ejection
    process is finished, we will have access to all the configuration files and we
    will have the ability to switch to using Mocha.
  prefs: []
  type: TYPE_NORMAL
- en: 'To eject Create React App, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you take a look at the `package.json` in the root of the project, you will
    see that a lot of information and configuration have been added.
  prefs: []
  type: TYPE_NORMAL
- en: After any major modification to `package.json`, it is a good idea to delete
    `node_modules` and `package-lock.json` and then re-run `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring to use Mocha and Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have ejected the React app, before you make any further modifications,
    you should make sure everything still works. Execute the following command before
    making any further modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now check that a browser launched and that the application is running correctly.
    You will have to *Ctrl* + *C* to exit the running process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After this command, check that a build folder was created at the root of your
    project and that there were no errors displayed in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Even though you are about to change the test configuration, you will be using
    some of the libraries that were provided by Create React App. You want to make
    sure that those prerequisites transitioned properly when you ejected. As with `npm
    start`, you will have to *Ctrl* + *C* to exit this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming all of the commands executed without issues, you can now start the
    process of switching the test environment over to Mocha. Execute the following
    command to ensure the installation of the necessary dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `package.json` and update the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding code to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to install the BabelJS preset for ES2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, find and delete the `jest` setting in `package.json`. You are now ready
    to change the `test` script to execute Mocha instead of Jest. Find NPM scripts
    and update the test script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding code to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The change you just made will cause Mocha to execute all of your tests. It will
    only execute them once, though. You want a way to have your tests running continuously
    while you work, so you need to add an additional script. Add a comma to the end
    of the line you just modified and then add the following script just beneath `test`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to update the `test.js` file provided when you ejected. Open `<project
    root>/scripts/test.js` and replace all the code inside with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This file just sets up the base environment for your tests to execute inside.
    Make note of the `noop` function and usage. Currently, you are ignoring the `css`
    and `svg` extensions that are required by your production code when you are testing.
    In the course of testing, if you run into issues while requiring a different extension,
    you might have to come back to this file and add the troublesome extension to
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are almost done; you only have one more modification to make before you
    are officially switched over to Mocha. Find the file `App.test.js` in your `src` directory,
    and change its name to `App.spec.js`, then update the contents to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All you have really done here is import Chai and add a `describe` block. The
    rest of this test has remained unchanged and is the default test provided with
    Create React App.
  prefs: []
  type: TYPE_NORMAL
- en: A quick kata to check our test setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this setup test, you are going to do the Palindrome code kata. This code
    kata can get complex, but you are only going to concern yourself with the most
    basic form.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements for this kata are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you always should, you will begin with a templated test file designed to
    verify that the unit testing framework is configured correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have shown a failing version of this template. Before you begin writing the
    tests that are actually for the kata, run the `test:watch` NPM script and verify
    that the test fails. Also, verify that it fails for the right reason. It should
    fail because *1* was expected but *0* was the actual result. After the test properly
    fails, change the zero to a one and verify that the test now passes. As long as
    these two validations work correctly, we will continue and begin working through
    the code kata.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the kata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you will do for the kata is write an `ItExists` test. Again,
    these types of test help to get the ball rolling and prevent writer's block. You
    will replace the code for checking the framework with the following.
  prefs: []
  type: TYPE_NORMAL
- en: '*Red phase*; write a failing test that expects an `isPalindrome` function to
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Verify that this test fails. It's important to see a failure before moving on
    to making the test pass. This will help confirm that your test setup is working
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: And now the *green phase*; make the test pass. Define an `isPalindrome` function
    and run the test once more to see it pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For the next test, we want to think of the simplest test case that would produce
    a result. Again, we are skipping bad data issues. The simplest test case we can
    think of that would product a result is a single letter. For the definition of
    palindrome that you will be using for these tests, a single letter is a palindrome.
    Add the following test under the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to make it pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have a passing test, but you are always returning true. You want the
    next test to fail when you write it. So, you should write a test for when the
    value passed in is not a palindrome. The simplest non-palindrome would be two
    letters that are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make it pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so now you only return true single letters. This opens us up for our
    next test, flipping back to something that is a palindrome; write a test for two
    letters that are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to make it pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The next test is to have a three-letter word that is a palindrome. Currently,
    this should fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this test pass, think about what you have so far. One algorithm for
    checking a palindrome is to simply start on the outsides and check the two outermost
    letters. If those two letters are a match, then move in one letter on each side.
    Repeat this check until you get to the center of the word or phrase. If the center
    is one letter, then it''s a palindrome; otherwise, check if the two center-most
    characters are a match. Let''s try this concept out by using recursion to make
    the latest test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to check if a four-letter palindrome will pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It passes; excellent! We will end this code kata with two exercises for you.
    The first exercise is to add a test for "a man a plan a canal panama" and make
    it pass. The second exercise is to refactor the code for `isPalindrome`. While
    this is a small function, it could still do with some tidying up, and potentially
    some optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have Node installed and your JavaScript development environment
    configured. JavaScript examples throughout the rest of the book will assume your
    use of WebStorm.
  prefs: []
  type: TYPE_NORMAL
- en: But, before diving right in, [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195), *What
    to Know Before Getting Started*, will focus on what more you need to know before
    getting started.
  prefs: []
  type: TYPE_NORMAL
