- en: '*Chapter 8*: Parallel Data Structures and Parallel LINQ'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET provides many useful features and data constructs for developers who are
    introducing parallelism to their projects. This chapter will explore these features,
    including `SpinLock<T>` **synchronization primitive**, and **Parallel LINQ** (**PLINQ**).
    These features can improve the performance of your applications while maintaining
    safe threading practices.
  prefs: []
  type: TYPE_NORMAL
- en: Most .NET developers are familiar with LINQ frameworks, including LINQ to Objects,
    LINQ to SQL, and LINQ to XML. There are even open source .NET LINQ libraries,
    such as LINQ to Twitter ([https://github.com/JoeMayo/LinqToTwitter](https://github.com/JoeMayo/LinqToTwitter)).
    We will take those LINQ skills and leverage them in parallel programming with
    PLINQ. Every LINQ developer can be a PLINQ developer after reading this chapter.
    Read ahead for some useful examples of working with PLINQ in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting LINQ queries to PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving data order and merging data with PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures for parallel programming in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a new appreciation for LINQ when it
    comes to parallel programming.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To complete the WPF sample, you will need to install the .NET desktop development
    workload for Visual Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by discussing LINQ, PLINQ, and why the query language can
    be a great way to improve your parallel programming with C#.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PLINQ is a set of .NET extensions for LINQ that allow part of the LINQ query
    to execute in parallel by leveraging the thread pool. The PLINQ implementation
    provides parallel versions of all of the available LINQ query operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like LINQ queries, PLINQ queries offer deferred execution. This means that
    the objects are not queried until they need to be enumerated. If you aren’t familiar
    with LINQ’s deferred execution, we will look at a simple example to illustrate
    the concept. Consider these two LINQ queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the LINQ query that populates `citiesWithS` is executed immediately
    because of the call to `ToList()`. The second query that populates `citiesWithT`
    is not immediately executed. The execution is deferred until the `IEnumerable`
    values are required. The `citiesWithT` values are not required until we iterate
    over them in the `foreach` loop. The same principle holds true for PLINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unfamiliar with LINQ concepts or the LINQ method syntax, the book
    *C# 10 and .NET 6 – Modern Cross-Platform Development – Sixth Edition* by *Mark
    J. Price* has a chapter dedicated to explaining LINQ syntax and several of its
    implementations. It is an excellent book for every .NET developer. You can find
    out more about the book here: [https://subscription.packtpub.com/product/mobile/9781801077361](https://subscription.packtpub.com/product/mobile/9781801077361).'
  prefs: []
  type: TYPE_NORMAL
- en: PLINQ is similar to LINQ in other ways, too. You can create PLINQ queries on
    any collection that implements `IEnumerable` or `IEnumerable<T>`. You can use
    all of the familiar LINQ operations such as `Where`, `FirstOrDefault`, `Select`,
    and so on. The primary difference is that PLINQ attempts to leverage the power
    of parallel programming by part or all of a query across multiple threads. Internally,
    PLINQ partitions the in-memory data into multiple segments and performs the query
    on each segment in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: There are several factors that impact the performance gained by using PLINQ.
    Let’s explore those next.
  prefs: []
  type: TYPE_NORMAL
- en: PLINQ and performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When deciding which LINQ queries are good candidates to leverage the power of
    PLINQ, you must consider a number of factors. The primary factor to consider is
    whether the magnitude or complexity of the work to be performed is great enough
    to offset the overhead of threading. You should be operating on a large dataset
    and be performing an expensive operation on each item in the collection. The LINQ
    example that checked the first letter of a string is not a very good candidate
    for PLINQ, especially if the source collection only contains a handful of items.
  prefs: []
  type: TYPE_NORMAL
- en: Another factor in the performance to potentially be gained with PLINQ is the
    number of cores available on the system where the queries will be running. The
    greater the number of cores that PLINQ can leverage, the better the potential
    gain. PLINQ can break down a large dataset into more units of work to be executed
    in parallel with many cores at its disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering and grouping data can incur a larger amount of overhead than it would
    in a traditional LINQ query. The PLINQ data is segmented, but grouping and ordering
    must be performed across the entire collection. PLINQ is best suited for queries
    where the data sequence is not important.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss some other factors that impact query performance in the *Preserving
    data order and merging data with PLINQ* section. Now, let’s start creating our
    first PLINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PLINQ query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The majority of the functionality of PLINQ is exposed through members of the
    `System.Linq.ParallelEnumerable` class. This class contains implementations of
    all of the LINQ operators that are available to in-memory object queries. There
    are some additional operators in this class that are specific to PLINQ queries.
    The two most important operators to understand are `AsParallel` and `AsSequential`.
    The `AsParallel` operator indicates that all subsequent LINQ operations should
    be attempted to be performed in parallel. In contrast, the `AsSequential` operator
    indicates to PLINQ that the LINQ operations that follow it should be performed
    in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example that uses both of these PLINQ operators. Our query
    will be operating on `List<Person>` with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider that we are working with a dataset of thousands or even millions
    of people. We want to leverage PLINQ to query only the adults aged 18 or older
    from the data and then group them by their last name. We want to execute only
    the `Where` clause of the query in parallel. The `GroupBy` operation will be performed
    sequentially. This method will do exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `GroupBy` LINQ method will return `IEnumerable<IGrouping<string, Person>>`
    with each `IGrouping<string, Person>` instance containing all of the people with
    the same `LastName`. Whether or not this `GroupBy` operation would be faster to
    run in parallel or sequentially depends on the makeup of the data. You should
    always test your application to determine whether introducing parallelism is improving
    the performance when working with production data. We will cover ways to performance-test
    your code in [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how PLINQ queries can be written with the **method syntax**
    that we have used thus far or by using LINQ **query syntax**.
  prefs: []
  type: TYPE_NORMAL
- en: Query syntax versus method syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINQ queries can be coded either by using method syntax or query syntax. Method
    syntax is where you string multiple methods together to build a query. This is
    what we have been doing throughout this section. Query syntax is slightly different,
    and it is akin to T-SQL query syntax. Let’s examine the same PLINQ query written
    both ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple PLINQ query to return only adults from a list of people written
    with method syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the exact same PLINQ query written with query syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You should use whichever syntax you prefer. Throughout the rest of this chapter,
    we will be using method syntax for the examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will continue to explore the operations available in
    PLINQ and create some parallel versions of LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Converting LINQ queries to PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at some additional PLINQ operators and show you
    how you can leverage them to turn existing LINQ queries into PLINQ queries. Your
    existing queries may have requirements for preserving the order of data. Perhaps
    your existing code doesn’t use LINQ at all. There could be an opportunity there
    to convert some logic in `foreach` loops into PLINQ operations.
  prefs: []
  type: TYPE_NORMAL
- en: The way to convert a LINQ query to a PLINQ query is by inserting an `AsParallel()`
    statement into the query, as we did in the previous section. Everything that follows
    `AsParallel()` will run in parallel until an `AsSequential()` statement is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your queries require that the original order of objects be preserved, you
    can include an `AsOrdered()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this will not be as performant as queries that do not preserve the
    sequence of data. To explicitly tell PLINQ to not preserve data order, use the
    `AsUnordered()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The unordered version of the query will perform much better if the order of
    your data is not important; you should never use `AsOrdered()` with PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another example. We will start with a method that iterates over
    a list of people with a `foreach` loop and calls a method named `ProcessVoterActions`
    for each person aged 18 or older. We’re going to assume that this method is processor-intensive
    and also uses some I/O to save the voter information in a database. Here is the
    starting code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not leverage parallel processing at all. We could improve on this
    by using LINQ to filter out the children under 18 and then call `ProcessVoterActions`
    with a `Parallel.ForEach` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This will certainly improve the performance if `ProcessVoterActions` takes
    some time to run for each person. However, with PLINQ, we can improve the performance
    even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `Where` query will run in parallel. This will certainly help performance
    if we expect to have thousands or millions of objects in the `people` collection.
    The `ForAll` extension method is another PLINQ operation that runs in parallel.
    It is meant to be used to perform an operation in parallel on each object in the
    query results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance of `ForAll` will also be superior to the `Parallel.ForEach`
    operation in the previous example. One difference is the deferred execution of
    PLINQ. These calls to `ProcessVoterActions` will not be performed until the `IEnumerable`
    result is iterated over. The other advantage is the same advantage over performing
    a standard `foreach` loop with `IEnumerable` after completing a PLINQ query on
    your data. The data must be merged back from the multiple threads before it can
    be enumerated by either `foreach` or `Parallel.ForEach`. With a `ForAll` operation,
    the data can remain segmented by PLINQ and merged once at the end. This diagram
    illustrates the difference between `Parallel.ForEach` and `ForAll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Advantages of PLINQ, data segmentation, and ForAll ](img/Figure_8.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Advantages of PLINQ, data segmentation, and ForAll
  prefs: []
  type: TYPE_NORMAL
- en: Before we explore more details about data order and merging data, let’s discuss
    how to handle exceptions when working with PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions with PLINQ queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing good exception handling in your .NET projects is important. It’s
    one of the fundamental practices of software development. When working with parallel
    programming in general, exception handling can be more complicated. This is also
    true with PLINQ. When any exception is unhandled within a parallel operation inside
    a PLINQ query, the query will throw an exception of type `AggregateException`.
    So, at the very minimum, all of your PLINQ queries should run within a `try`/`catch`
    block that catches the `AggregateException` exception type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take our PLINQ `ForAll` example with `ProcessVoterActions` and add some
    exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to run this example in a .NET console application, so create a
    new project in Visual Studio and add a class named `Person`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add a new class named `PlinqExceptionsExample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a private method to `PlinqExceptionsExample` named `ProcessVoterActions`.
    We’re going to throw `ArgumentException` for any person older than `120:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the `ProcessAdultsWhoVoteWithPlinq` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method’s logic remains the same. It’s filtering out the children with a
    PLINQ `Where` clause and calling `ProcessVoterActions` as a delegate to `ForAll`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along with the sample code on GitHub for this chapter ([https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08/LINQandPLINQsnippets](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08/LINQandPLINQsnippets)),
    you will need to uncomment the lines of code in *Step 5*. You should also comment
    out the lines in the `Main` method that follow those lines to prevent other samples
    from executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open `Program.cs` and add some code to create an instance of `List<Person>`
    in an inline function called `GetPeople`. It can contain as many people as you
    like, but at least one of them needs to have an age greater than `120`. Call `ProcessAdultsWhoVoteWithPlinq`,
    passing the data from `GetPeople`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the program and observe the console output. If Visual Studio breaks
    at the exception, just click **Continue**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Receiving an exception in the console ](img/Figure_8.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Receiving an exception in the console
  prefs: []
  type: TYPE_NORMAL
- en: The problem with handling the exception from outside the PLINQ query is that
    the entire query is stopped. It isn’t able to run to completion. If you have an
    exception that shouldn’t stop the entire process, you should handle it from within
    the code inside the query and continue processing the remaining items.
  prefs: []
  type: TYPE_NORMAL
- en: If you handle exceptions inside `ProcessVoterActions`, you have a chance to
    process them gracefully and continue.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to explore some examples of how to preserve the order of
    your data and handle different options for merging segments back together.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving data order and merging data with PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When fine-tuning PLINQ queries for your applications, there are some extension
    methods that impact the sequencing of data that you can leverage. Preserving the
    original order of your items may be something that is required. We have touched
    on the `AsOrdered` method in this chapter, and we will experiment with it in this
    section. When PLINQ operations have been completed and items are returned as part
    of the final enumeration, the data is merged from the segments that were created
    to operate on multiple threads. The merge behavior can be controlled by setting
    `ParallelMergeOptions` with the `WithMergeOptions` extension method. We will discuss
    the behavior of the three available merge options provided.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by creating some samples with the `AsOrdered` and `AsUnordered`
    extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: PLINQ data order samples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create five methods that each accept the same set
    of data and perform the same filtering on the input data. However, the ordering
    in each PLINQ query will be handled differently. We are going to be working with
    the same `Person` class from the previous section. So, you can either work with
    the same project or create a new .NET console application project and add the
    `People` class from the previous example. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the `Person` class and add a new `bool` property named `IsImportant`.
    We are going to use this to add a second data point for filtering in the PLINQ
    queries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add a new class to the project named `OrderSamples`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it’s time to start adding the queries. In this first query, we are not
    specifying `AsOrdered` or `AsUnordered`. By default, PLINQ should not be attempting
    to preserve the original order of the data. In each of these queries, we are returning
    each `Person` object with `Age` less than 18 and with `IsImportant` set to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the second example, we are explicitly adding `IsUnordered` to the query
    after `AsParallel`. The behavior should be the same as the first query, with PLINQ
    not concerning itself with the original order of the items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third example breaks up the filters into two separate `Where` clauses;
    `IsSequential` is added after the first `Where` clause. How do you think this
    will impact the item sequence? We will find out when we run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the fourth example, we are using `AsParallel().AsOrdered()` to signal to
    PLINQ that we want the original order of items to be preserved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the fifth and final example, we are adding a `Reverse` method after `AsOrdered`.
    This should preserve the original order of items in reverse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open `Program.cs` and add two local functions. One will create a list
    of `Person` objects to pass to each method. The other will iterate over `List<Person>`
    to output each `FirstName` to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will add the code to call each method. The timestamp, including
    milliseconds, is being output to the console before each method call and again
    at the end. You can run the application multiple times to inspect the performance
    of each method call. Try running it on PCs with more or fewer cores and different-sized
    datasets to see how that impacts the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the program and examine the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Comparing the order of items from five PLINQ queries ](img/Figure_8.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Comparing the order of items from five PLINQ queries
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the output that the order of items is only predictable in the
    last two examples where we have specified `AsOrdered()` and `AsOrdered().Reverse()`.
    The impact of the different PLINQ operations is difficult to measure on such a
    small dataset. If you run this several times, you are likely to see different
    results in the timing. Try adding larger datasets on your own to experiment with
    the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s discuss merging segments and test the different options in a sample.
  prefs: []
  type: TYPE_NORMAL
- en: Using WithMergeOptions in PLINQ queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we discuss merging data in PLINQ, it is the merge that happens as each
    segment of an operation completes its actions, and the results are merged back
    into the result on the calling thread. Most of the time, you will not need to
    specify any merge options. For times when you may need to do so, it’s important
    to understand the behavior of each of the options. Let’s review each of the members
    of the `ParallelMergeOptions` enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: ParallelMergeOptions.NotBuffered
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think of the `NotBuffered` option as streaming data. Each item is returned from
    the query immediately after it has finished processing. There are some PLINQ operations
    that cannot support this option and will ignore it. For instance, the `OrderBy`
    and `OrderByDescending` operations cannot return items until the sorting has completed
    on the merged data. These are always `FullyBuffered`. However, queries that use
    `AsOrdered` can use this option. Use this option if your application needs to
    consume items in a streaming manner.
  prefs: []
  type: TYPE_NORMAL
- en: ParallelMergeOptions.AutoBuffered
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AutoBuffered` option returns sets of items as they are collected. The size
    of the item set and how frequently it is returned to clear the buffer are not
    configurable or known to your code. If you want to make your data available in
    this manner, this option may suit your needs. Once again, the `OrderBy` and `OrderByDescending`
    operations will not accept this option. This is the default for most PLINQ operations
    and is the fastest overall in most scenarios. The `AutoBuffered` option allows
    PLINQ the most flexibility to buffer items as necessary based on current system
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: ParallelMergeOptions.FullyBuffered
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `FullyBuffered` option will not make any results available until they have
    all been processed and buffered by the query. The option will take the longest
    to make the first item available, but many times, it is the fastest to provide
    the entire dataset.
  prefs: []
  type: TYPE_NORMAL
- en: ParallelMergeOptions.Default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also the `ParallelMergeOptions.Default` value, which will act the same
    as not calling `WithMergeOptions` at all. You should choose your merge option
    based on how the data needs to be consumed. If you have no strict requirements,
    it is usually best to not set merge options.
  prefs: []
  type: TYPE_NORMAL
- en: WithMergeOptions in action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create examples of using the same `Person` query with each merge option
    and with no merge options set at all:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a `MergeSamples` class to the console application project you
    previously created. First, add the following three methods to test the types of
    merges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following two methods to the `MergeSamples` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each of the methods in the last two steps performs a PLINQ query that filters
    for `IsImportant` equal to `true` and `Age` less than `18`. It then performs a
    `Take(3)` operation to return only the first three items from the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add code to `Program.cs` to call each method and output the timestamp before
    each call, as well as a final timestamp at the end. This is the same process we
    used when calling the methods to test ordering in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the program and examine the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Reviewing the output of the PLINQ merge options methods ](img/Figure_8.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Reviewing the output of the PLINQ merge options methods
  prefs: []
  type: TYPE_NORMAL
- en: The first option with no merge option specified takes the longest to run, but
    often, the first time you run a PLINQ query, it will be slower than subsequent
    executions. The remaining queries are all very fast. You should test these queries
    on some large sets of data from your own databases and see how the timings differ
    for different PLINQ operators and different merge options. You can even take timings
    between the output of each item to see how quickly the first item is returned
    for `NotBuffered` versus `FullyBuffered`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we review everything that we have learned in this chapter, let’s discuss
    a few .NET objects and data structures that complement parallel programming and
    PLINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures for parallel programming in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with parallel programming in .NET, and with PLINQ, you should take
    advantage of the data structures, types, and primitives that .NET provides. In
    this section, we will touch on concurrent collections and **synchronization primitives**.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent collections are useful when working with parallel programming. We
    will cover them in great detail in [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146),
    but let’s quickly discuss how we can leverage them when working with PLINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: If you are simply selecting and sorting data with PLINQ, it is not necessary
    to incur the overhead that is added with the collections in the `System.Collections.Concurrent`
    namespace. However, if you are calling a method with `ForAll` that modifies items
    in your source data, you should use one of these current collections, such as
    `BlockingCollection<T>`, `ConcurrentBag<T>`, or `ConcurrentDictionary<TKey, TValue>`.
    They can also guard against any simultaneous `Add` or `Remove` operations on the
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are unable to introduce concurrent collections into your existing code
    base, another option to provide concurrency and performance is synchronization
    primitives. We covered many of these types in [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014).
    These types in the `System.Threading` namespace, including `Barrier`, `CountdownEvent`,
    `SemaphoreSlim`, `SpinLock`, and `SpinWait`, provide the right balance of thread
    safety and performance. Other locking mechanisms, such as `lock` and `Mutex`,
    can be more expensive to implement, causing a greater performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to guard one of our PLINQ queries that uses `ForAll` with `SpinLock`,
    we can simply wrap the method in a `try`/`finally` block and use the `Enter` and
    `Exit` calls on `SpinLock`. Take this example where we were checking where a person
    had an age greater than `120`. Let’s imagine that the code also modifies the age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'To read more about synchronization primitives, check out this section in Microsoft
    Docs: [https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives](https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s wrap up by reviewing what we have learned in this chapter on parallel
    programming and PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the power of PLINQ to introduce parallel processing
    to our LINQ queries. We started by looking at how PLINQ differs from standard
    LINQ queries. Next, we explored how to introduce PLINQ into existing code by converting
    some standard LINQ queries. It is important to understand how PLINQ is impacting
    the performance of your applications, and we examined some timings in our sample
    applications. (Later, in [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158),
    we will discuss some tools to test your application performance while testing
    it locally.) We covered some optimizations you can make to your queries with merge
    options and data ordering. Finally, we wrapped up by touching on some other .NET
    data structures and types to help provide type safety and performance to your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore each of the concurrent collections in the
    `System.Collections.Concurrent` namespace in depth. The concurrent collections
    are key to ensuring that your parallel and concurrent code maintains type safety
    when operating on shared data.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which PLINQ method signals that the query should start processing in parallel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which PLINQ method signals that the query should not process in parallel any
    longer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method tells PLINQ to preserve the original order of the source data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which PLINQ method will execute a delegate in parallel on each item in the query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What performance impact does `AsOrdered()` have on a PLINQ query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which PLINQ operations cannot be used with `ParallelMergeOptions.NotBuffered`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is PLINQ always faster than an equivalent LINQ query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which PLINQ merge option would you select if you want results to stream back
    from the query as they become available?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
