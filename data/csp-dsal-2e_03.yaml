- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Arrays and Sorting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和排序
- en: As a developer, you have certainly stored various collections within your applications,
    such as data of users, books, and logs. One of the natural ways of storing such
    data is by using arrays. However, have you ever thought about their variants?
    For example, have you heard about jagged arrays? In this chapter, you will see
    arrays in action, together with examples and detailed descriptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，您肯定在您的应用程序中存储了各种集合，例如用户数据、书籍和日志。存储此类数据的一种自然方式是使用数组。然而，您是否曾想过它们的变体？例如，您听说过锯齿形数组吗？在本章中，您将看到数组在实际中的应用，包括示例和详细描述。
- en: You can use an array to `int`, `string`, as well as a user-defined class or
    record. Just keep in mind that **the number of elements in an array cannot be
    changed after initialization**. For this reason, you will not be able to easily
    add a new item at the end of the array or insert an element in a given position
    within the array while moving the remaining items one position further. If you
    need such features, you can use another data structure, namely a list and its
    variants, which will be described in the following chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用数组来存储`int`、`string`，以及用户自定义的类或记录。只需记住，**数组在初始化后其元素数量不能改变**。因此，您无法轻松地在数组的末尾添加新项或在数组中指定位置插入元素，同时将剩余项移动一个位置。如果您需要此类功能，可以使用另一种数据结构，即列表及其变体，这些将在下一章中描述。
- en: While developing applications in the C# language, you can benefit from a few
    variants of arrays, namely **single-dimensional arrays**, **multi-dimensional
    arrays**, and **jagged arrays**. In this chapter, you will also get to know seven
    **sorting algorithms**, namely **selection sort**, **insertion sort**, **bubble
    sort**, **merge sort**, **Shell sort**, **quicksort**, and **heap sort**. For
    each, you will see an illustration-based example, the implementation code, and
    a step-by-step explanation. You will also see their performance analysis, presented
    with charts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在用C#语言开发应用程序时，您可以受益于几种数组的变体，即**单维数组**、**多维数组**和**锯齿形数组**。在本章中，您还将了解七种**排序算法**，即**选择排序**、**插入排序**、**冒泡排序**、**归并排序**、**希尔排序**、**快速排序**和**堆排序**。对于每种算法，您将看到基于图示的示例、实现代码和逐步解释。您还将看到它们的性能分析，以图表的形式展示。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Single-dimensional arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单维数组
- en: Multi-dimensional arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组
- en: Jagged arrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锯齿形数组
- en: Sorting algorithms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序算法
- en: Single-dimensional arrays
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单维数组
- en: Let’s start with the simplest variant of arrays, namely single-dimensional ones.
    `0`, while the last one has an index equal to the length of the array minus one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从数组最简单的变体开始，即单维数组。第一个元素的索引为`0`，而最后一个元素的索引等于数组的长度减一。
- en: Imagine a single-dimensional array
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个单维数组
- en: If you want to better imagine a single-dimensional array, take your eyes off
    this book for a moment and look at the chest of drawers or wardrobe in your room.
    A standard chest of drawers consists of several drawers and a single-dimensional
    array looks similar. It also has several elements (as drawers), which are accessible
    via the index. You cannot change the size of the array in the same way as you
    cannot change the number of drawers since the furniture is prepared. An array
    has one significant advantage over a chest of drawers, namely all its “drawers”
    are always working as expected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更好地想象单维数组，请暂时将目光从这本书上移开，看看您房间里的抽屉柜或衣柜。一个标准的抽屉柜由几个抽屉组成，单维数组看起来很相似。它也有几个元素（即抽屉），可以通过索引访问。您不能像改变抽屉数量一样改变数组的大小，因为家具已经准备好了。数组相对于抽屉柜有一个显著的优势，即所有的“抽屉”总是按预期工作。
- en: 'An example of a single-dimensional array is shown in the following figure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了单维数组的示例：
- en: '![Figure 3.1 – Example of a single-dimensional array](img/B18069_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 单维数组的示例](img/B18069_03_01.jpg)'
- en: Figure 3.1 – Example of a single-dimensional array
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 单维数组的示例
- en: 'It contains five elements with the following values: `9`, `-11`, `6`, `-12`,
    and `1`. The first element has an index equal to `0`, while the last one has an
    index equal to `4`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含五个元素，其值分别为`9`、`-11`、`6`、`-12`和`1`。第一个元素的索引等于`0`，而最后一个元素的索引等于`4`。
- en: 'To use a single-dimensional array, you need to declare and initialize it. The
    declaration is very simple because you just need to specify a type of element
    and a name, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一维数组，你需要声明和初始化它。声明非常简单，因为你只需要指定元素类型和名称，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The declaration of an array with integer values is shown in the following line:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 整数数组的声明如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: numbers = new int[5];
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = new int[5];
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: int[] numbers = new int[5];
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: int[] numbers = new int[5];
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: numbers[0] = 9;
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[0] = 9;
- en: numbers[1] = -11;
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[1] = -11;
- en: numbers[2] = 6;
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[2] = 6;
- en: numbers[3] = -12;
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[3] = -12;
- en: numbers[4] = 1;
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[4] = 1;
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: int[] numbers = new int[] { 9, -11, 6, -12, 1 };
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: int[] numbers = new int[] { 9, -11, 6, -12, 1 };
- en: int[] numbers = { 9, -11, 6, -12, 1 };
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: int[] numbers = { 9, -11, 6, -12, 1 };
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'int[] numbers = [] operator and by specifying the index, as shown in the following
    line of code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: int[] numbers = [] 运算符和指定索引，如下所示的一行代码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: int last = numbers[numbers.Length - 1];
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: int last = numbers[numbers.Length - 1];
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: int last = numbers[^2], the third by [^3], and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: int last = numbers[^2]，第三个通过 [^3]，以此类推。
- en: 'The other property is named `Rank` and returns the number of dimensions of
    the array. Usage of this property is shown in the following line of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个属性名为 `Rank`，返回数组的维度数。此属性的用法如下所示的一行代码：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'bool anyPositive = Array.TrueForAll to check whether all elements meet the
    provided predicate, such as to ensure that there are no zeros in the array:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: bool anyPositive = Array.TrueForAll 检查是否所有元素都满足提供的谓词，例如确保数组中没有零：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'int firstNegative = Array.FindAll method. The following code shows how to get
    all negative numbers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: int firstNegative = Array.FindAll 方法。以下代码展示了如何获取所有负数：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'int index = Array.ForEach. It allows you to perform some operations for all
    the elements in the array. As an example, you can use it to write the absolute
    value of each array element in the console, as shown in the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: int index = Array.ForEach。它允许你对数组中的所有元素执行一些操作。例如，你可以用它将每个数组元素的绝对值写入控制台，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, even for as simple a data structure as a single-dimensional
    array, you have a lot of useful built-in features. Let’s continue learning them
    and take a look at the two next methods, namely `Reverse` and `Sort`. According
    to their names, the first allows you to reverse the order of the elements, either
    for the whole array or only within some range. This is presented in the following
    line of code, which reverses the first three elements:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，即使对于像一维数组这样简单的数据结构，你也有很多有用的内置功能。让我们继续学习它们，并看看接下来的两种方法，即 `Reverse` 和 `Sort`。根据它们的名称，第一个允许你反转元素顺序，无论是整个数组还是仅在某些范围内。以下代码展示了如何反转前三个元素：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Array.for loop and simply iterate through suitable indices and assign a given
    value. However, you can use the Fill method instead. The following line places
    3 as a value of all elements in the array:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Array.for 循环并简单地遍历合适的索引并分配给定的值。然而，你可以使用 Fill 方法。以下行将 3 作为数组中所有元素的值：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Array.Copy, which copies a range of elements from the source array to the destination
    array. You can use one out of a few variants, such as to specify indices from
    both arrays. As an example, let’s copy 3 elements (specified as length) from the
    numbers array (as the source array), starting from the first element (source index
    set to 0), and place them in the subarray array, starting from the first element
    (destination index set to 0):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Array.Copy，它将源数组中的一系列元素复制到目标数组。你可以使用几种变体之一，例如指定两个数组中的索引。例如，让我们从 numbers 数组（作为源数组）复制
    3 个元素（指定为长度），从第一个元素（源索引设置为 0）开始，并将它们放置在 subarray 数组中，从第一个元素（目标索引设置为 0）开始：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'bool contains = numbers.Contains method is not the only available extension
    method. Among others, you can find All and Any. The first (All) checks whether
    all of the elements match the given predicate, while the other (Any) verifies
    whether at least one element meets the condition. You can use them to ensure that
    there are no zeros in the array and check whether there is at least one positive
    element, as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: bool contains = numbers.Contains 方法不是唯一可用的扩展方法。其中，你可以找到 All 和 Any。第一个（All）检查所有元素是否与给定的谓词匹配，而另一个（Any）验证是否至少有一个元素满足条件。你可以使用它们来确保数组中没有零并检查是否至少有一个正元素，如下所示：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: int min = numbers.Min();
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: int min = numbers.Min();
- en: 'int max = numbers.Average and Sum methods, which easily calculate the average
    value of all of the elements, as well as their sum:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: int max = numbers.Average 和 Sum 方法，它们可以轻松计算所有元素的平均值以及它们的总和：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After this short introduction to single-dimensional arrays, it’s high time to
    take a look at an example of how to apply such arrays in real-world scenarios.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在对一维数组进行简短介绍之后，现在是时候看看如何在现实场景中应用这样的数组了。
- en: Where can you find more information?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: You can find a lot of interesting information about arrays and their various
    variants in the context of the C# language at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[C#语言中关于数组和它们各种变体的有趣信息](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/)中找到很多。
- en: Example – month names
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 月份名称
- en: To summarize what you’ve learned about single-dimensional arrays, let’s use
    an array to store names of months, written in English. Such names should be obtained
    automatically, not by hardcoding them in the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下关于一维数组的所学内容，我们可以用一个数组来存储英文月份的名称。这些名称应该自动获取，而不是通过在代码中硬编码它们。
- en: 'The implementation is shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下所示：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, you create a new instance of the `CultureInfo` class (from the `System.Globalization`
    namespace), passing `en` as a parameter, to later get the names of months in English.
    Then, you declare a new single-dimensional array and initialize it with default
    values. It contains `12` elements to store the names of all the months in a year.
    Then, the `for` loop is used to iterate through the numbers of all months – that
    is, from `1` to `12`. For each of them, a `DateTime` instance representing the
    first day in a particular month from the current year is created.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个新的`CultureInfo`类实例（来自`System.Globalization`命名空间），传递`en`作为参数，以便稍后获取英文月份的名称。然后，你声明一个新的单维数组，并用默认值初始化它。它包含`12`个元素，用于存储一年中所有月份的名称。然后，使用`for`循环遍历所有月份的数字——即从`1`到`12`。对于每一个，创建一个表示当前年份特定月份第一天的`DateTime`实例。
- en: The name of the month is obtained by calling the `ToString` method on the `DateTime`
    instance, passing the proper format of the date (`MMMM`), as well as specifying
    the culture. Then, the name is stored in the array using the `[]` operator and
    an index of the element. It is worth noting that the index is equal to the current
    value of the `month` variable minus one. Such subtraction is necessary because
    the first element in the array has an index equal to zero, instead of one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`DateTime`实例上调用`ToString`方法，并传递适当的日期格式（`MMMM`）以及指定文化，来获取月份的名称。然后，使用`[]`操作符和元素的索引将名称存储在数组中。值得注意的是，索引等于`month`变量的当前值减一。这种减法是必要的，因为数组中的第一个元素的索引等于零，而不是一。
- en: 'The next interesting part of the code is the `foreach` loop, which iterates
    through all elements of the array. For each of them, the name of the month is
    shown in the console:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中下一个有趣的部分是`foreach`循环，它遍历数组的所有元素。对于每一个元素，月份的名称会在控制台显示：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As mentioned earlier, single-dimensional arrays are not the only available variant.
    You will learn more about multi-dimensional arrays in the following section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一维数组并不是唯一可用的变体。你将在下一节中了解更多关于多维数组的内容。
- en: Multi-dimensional arrays
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组
- en: The arrays in the C# language do not need to have only one dimension. It is
    possible to create two-dimensional arrays as well. As you will see, multi-dimensional
    arrays are very useful and are frequently used while developing various applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#语言中，数组不需要只有一个维度。你可以创建二维数组。正如你将看到的，多维数组非常有用，并且在开发各种应用程序时经常被使用。
- en: Imagine a two-dimensional array
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个二维数组
- en: If you want to imagine a two-dimensional array, take a break, close your eyes,
    and play Sudoku. If you don’t know what this is, Sudoku is a popular game that
    requires you to fill empty cells of a 9x9 board with numbers from 1 to 9\. However,
    each row, each column, and each 3x3 box can only contain unique numbers. Surprise
    – this board forms a two-dimensional array! You can point to any place on the
    board by specifying its *row* and *column*, the same as in the case of a two-dimensional
    array. And if you are a bit tired of solving such puzzles with a pencil and a
    piece of paper, take a look at [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367),
    *See in Action*, where you will learn how to create an algorithm for solving a
    Sudoku puzzle!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想想象一个二维数组，请休息一下，闭上眼睛，玩玩数独。如果你不知道这是什么，数独是一种流行的游戏，要求你用 1 到 9 的数字填充 9x9 葫芦娃的空格。然而，每一行、每一列以及每一个
    3x3 的方块只能包含唯一的数字。惊喜！这个板子形成了一个二维数组！你可以通过指定其 *行* 和 *列* 来指向板上的任何位置，就像在二维数组中一样。如果你对用铅笔和一张纸解决这样的谜题感到有点厌倦，请看看
    [*第 9 章*](B18069_09.xhtml#_idTextAnchor367)，*实战*，在那里你将学习如何创建解决数独谜题的算法！
- en: 'An example two-dimensional array that stores integer values is shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个存储整数值的二维数组示例：
- en: '![Figure 3.2 – Example of a two-dimensional array](img/B18069_03_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.2 – Example of a two-dimensional array](img/B18069_03_02.jpg)'
- en: Figure 3.2 – Example of a two-dimensional array
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.2 – Example of a two-dimensional array
- en: 'First, you need to declare and initialize a two-dimensional array with `5`
    rows and `3` columns, as shown in the following line of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要声明并初始化一个具有 `5` 行和 `3` 列的二维数组，如下面的代码行所示：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can combine a declaration with an initialization in a bit different way
    as well:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以以稍微不同的方式将声明和初始化结合起来：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A small explanation is necessary for the way you access particular elements
    from a two-dimensional array. Let’s take a look at the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从二维数组中访问特定元素的方式，需要做一些简单的解释。让我们看看以下示例：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: int[,,] numbers = new int[3, 2, 3];
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: int[,,] numbers = new int[3, 2, 3];
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: int[,,,] numbers = new int[5, 4, 3, 2];
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: int[,,,] numbers = new int[5, 4, 3, 2];
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 1   2   3   4   5   6   7   8   9  10
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 1   2   3   4   5   6   7   8   9  10
- en: 2   4   6   8  10  12  14  16  18  20
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 2   4   6   8  10  12  14  16  18  20
- en: 3   6   9  12  15  18  21  24  27  30
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 3   6   9  12  15  18  21  24  27  30
- en: 4   8  12  16  20  24  28  32  36  40
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 4   8  12  16  20  24  28  32  36  40
- en: 5  10  15  20  25  30  35  40  45  50
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 5  10  15  20  25  30  35  40  45  50
- en: 6  12  18  24  30  36  42  48  54  60
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 6  12  18  24  30  36  42  48  54  60
- en: 7  14  21  28  35  42  49  56  63  70
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 7  14  21  28  35  42  49  56  63  70
- en: 8  16  24  32  40  48  56  64  72  80
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 8  16  24  32  40  48  56  64  72  80
- en: 9  18  27  36  45  54  63  72  81  90
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 9  18  27  36  45  54  63  72  81  90
- en: 10  20  30  40  50  60  70  80  90 100
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 10  20  30  40  50  60  70  80  90 100
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: int[,] results = new int[10, 10];
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: int[,] results = new int[10, 10];
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: for (int i = 0; i < results.GetLength(0); i++)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < results.GetLength(0); i++)
- en: '{'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int j = 0; j < results.GetLength(1); j++)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: for (int j = 0; j < results.GetLength(1); j++)
- en: '{'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: results[i, j] = (i + 1) * (j + 1);
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: results[i, j] = (i + 1) * (j + 1);
- en: Console.Write($"{results[i, j],4}");
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Console.Write($"{results[i, j],4}");
- en: '}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Console.WriteLine();
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine();
- en: '}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ConsoleColor GetColor(char terrain)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleColor GetColor(char terrain)
- en: '{'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return terrain switch
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: return terrain switch
- en: '{'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '''g'' => ConsoleColor.Green,'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '''g'' => ConsoleColor.Green,'
- en: '''s'' => ConsoleColor.Yellow,'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '''s'' => ConsoleColor.Yellow,'
- en: '''w'' => ConsoleColor.Blue,'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '''w'' => ConsoleColor.Blue,'
- en: _ => ConsoleColor.DarkGray
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: _ => ConsoleColor.DarkGray
- en: '};'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: char GetChar(char terrain)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: char GetChar(char terrain)
- en: '{'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return terrain switch
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: return terrain switch
- en: '{'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '''g'' => ''\u201c'','
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '''g'' => ''\u201c'','
- en: '''s'' => ''\u25cb'','
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '''s'' => ''\u25cb'','
- en: '''w'' => ''\u2248'','
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '''w'' => ''\u2248'','
- en: _ => '\u25cf'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: _ => '\u25cf'
- en: '};'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: using System.Text;
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: using System.Text;
- en: char[,] map =
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: char[,] map =
- en: '{'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '{ ''s'', ''s'', ''s'', ''g'', ''g'', ''g'', ''g'', ''g'' },'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '{ ''s'', ''s'', ''s'', ''g'', ''g'', ''g'', ''g'', ''g'' },'
- en: '{ ''s'', ''s'', ''s'', ''g'', ''g'', ''g'', ''g'', ''g'' },'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '{ ''s'', ''s'', ''s'', ''g'', ''g'', ''g'', ''g'', ''g'' },'
- en: '{ ''s'', ''s'', ''s'', ''s'', ''s'', ''b'', ''b'', ''b'' },'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '{ ''s'', ''s'', ''s'', ''s'', ''s'', ''b'', ''b'', ''b'' },'
- en: '{ ''s'', ''s'', ''s'', ''s'', ''s'', ''b'', ''s'', ''s'' },'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '{ ''s'', ''s'', ''s'', ''s'', ''s'', ''b'', ''s'', ''s'' },'
- en: '{ ''w'', ''w'', ''w'', ''w'', ''w'', ''b'', ''w'', ''w'' },'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '{ ''w'', ''w'', ''w'', ''w'', ''w'', ''b'', ''w'', ''w'' },'
- en: '{ ''w'', ''w'', ''w'', ''w'', ''w'', ''b'', ''w'', ''w'' }'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '{ ''w'', ''w'', ''w'', ''w'', ''w'', ''b'', ''w'', ''w'' }'
- en: '};'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Console.OutputEncoding = Encoding.UTF8;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Console.OutputEncoding = Encoding.UTF8;
- en: for (int r = 0; r < map.GetLength(0); r++)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: for (int r = 0; r < map.GetLength(0); r++)
- en: '{'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int c = 0; c < map.GetLength(1); c++)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: for (int c = 0; c < map.GetLength(1); c++)
- en: '{'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.ForegroundColor = GetColor(map[r, c]);
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ForegroundColor = GetColor(map[r, c]);
- en: Console.Write(GetChar(map[r, c]) + " ");
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Console.Write(GetChar(map[r, c]) + " ");
- en: '}'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Console.WriteLine();
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine();
- en: '}'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Console.ResetColor();
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ResetColor();
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: int[][] numbers = new int[4][];
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: int[][] numbers = new int[4][];
- en: numbers[0] = new int[] { 9, 5 };
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[0] = new int[] { 9, 5 };
- en: numbers[1] = new int[] { 0, -3, 12 };
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[1] = new int[] { 0, -3, 12 };
- en: numbers[3] = new int[] { 54 };
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[3] = new int[] { 54 };
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: int[][] numbers = new int[4][];
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: int[][] numbers = new int[4][];
- en: numbers[0] = [9, 5];
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[0] = [9, 5];
- en: numbers[1] = [0, -3, 12];
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[1] = [0, -3, 12];
- en: numbers[3] = numbers array is initialized with default values, namely null.
    For this reason, we need to manually initialize particular elements, as shown
    in the following three lines of code. It is worth noting that the third element
    is not initialized.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[3] = numbers 数组使用默认值初始化，即 null。因此，我们需要手动初始化特定元素，如下三行代码所示。值得注意的是，第三个元素未初始化。
- en: 'You can also write the preceding code in a different way, as shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用不同的方式编写前面的代码，如下所示：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That’s not all – an even shorter variant is available:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部 - 还有一个更短的变体可用：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'How can you access a particular element from a jagged array? Let’s see:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从一个交错数组中访问特定元素？让我们看看：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: public enum MeanEnum { Car, Bus, Subway, Bike, Walk }
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: public enum MeanEnum { Car, Bus, Subway, Bike, Walk }
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Random random = new();
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Random random = new();
- en: int meansCount = Enum.GetNames<MeanEnum>().Length;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: int meansCount = Enum.GetNames<MeanEnum>().Length;
- en: int year = DateTime.Now.Year;
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: int year = DateTime.Now.Year;
- en: MeanEnum[][] means = new MeanEnum[12][];
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: MeanEnum[][] means = new MeanEnum[12][];
- en: for (int m = 1; m <= 12; m++)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: for (int m = 1; m <= 12; m++)
- en: '{'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int daysCount = DateTime.DaysInMonth(year, m);
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: int daysCount = DateTime.DaysInMonth(year, m);
- en: means[m - 1] = new MeanEnum[daysCount];
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: means[m - 1] = new MeanEnum[daysCount];
- en: for (int d = 1; d <= daysCount; d++)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: for (int d = 1; d <= daysCount; d++)
- en: '{'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int mean = random.Next(meansCount);
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: int mean = random.Next(meansCount);
- en: means[m - 1][d - 1] = (MeanEnum)mean;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: means[m - 1][d - 1] = (MeanEnum)mean;
- en: '}'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: string[] months = GetMonthNames();
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: string[] months = GetMonthNames();
- en: int nameLength = months.Max(n => n.Length) + 2;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: int nameLength = months.Max(n => n.Length) + 2;
- en: for (int m = 1; m <= 12; m++)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: for (int m = 1; m <= 12; m++)
- en: '{'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string month = months[m - 1];
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: string month = months[m - 1];
- en: Console.Write($"{month}:".PadRight(nameLength));
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Console.Write($"{month}:".PadRight(nameLength));
- en: for (int d = 1; d <= means[m - 1].Length; d++)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: for (int d = 1; d <= means[m - 1].Length; d++)
- en: '{'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: MeanEnum mean = means[m - 1][d - 1];
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: MeanEnum mean = means[m - 1][d - 1];
- en: (char character, ConsoleColor color) = Get(mean);
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: (char character, ConsoleColor color) = Get(mean);
- en: Console.ForegroundColor = ConsoleColor.White;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ForegroundColor = ConsoleColor.White;
- en: Console.BackgroundColor = color;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Console.BackgroundColor = color;
- en: Console.Write(character);
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Console.Write(character);
- en: Console.ResetColor();
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ResetColor();
- en: Console.Write(" ");
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Console.Write(" ");
- en: '}'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Console.WriteLine();
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine();
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: string[] GetMonthNames()
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: string[] GetMonthNames()
- en: '{'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: CultureInfo culture = new("en");
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: CultureInfo culture = new("en");
- en: string[] names = new string[12];
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: string[] names = new string[12];
- en: foreach (int m in Enumerable.Range(1, 12))
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (int m in Enumerable.Range(1, 12))
- en: '{'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: DateTime firstDay = new(DateTime.Now.Year, m, 1);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime firstDay = new(DateTime.Now.Year, m, 1);
- en: string name = firstDay.ToString("MMMM", culture);
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: string name = firstDay.ToString("MMMM", culture);
- en: names[m - 1] = name;
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: names[m - 1] = name;
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return names;
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: return names;
- en: '}'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: (char Char, ConsoleColor Color) Get(MeanEnum mean)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (char Char, ConsoleColor Color) Get(MeanEnum mean)
- en: '{'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return mean switch
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: return mean switch
- en: '{'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: MeanEnum.Bike => ('B', ConsoleColor.Blue),
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: MeanEnum.Bike => ('B', ConsoleColor.Blue),
- en: MeanEnum.Bus => ('U', ConsoleColor.DarkGreen),
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: MeanEnum.Bus => ('U', ConsoleColor.DarkGreen),
- en: MeanEnum.Car => ('C', ConsoleColor.Red),
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: MeanEnum.Car => ('C', ConsoleColor.Red),
- en: MeanEnum.Subway => ('S', ConsoleColor.Magenta),
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: MeanEnum.Subway => ('S', ConsoleColor.Magenta),
- en: MeanEnum.Walk => ('W', ConsoleColor.DarkYellow),
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: MeanEnum.Walk => ('W', ConsoleColor.DarkYellow),
- en: _ => throw new Exception("Unknown type")
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: _ => throw new Exception("Unknown type")
- en: '};'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: void Sort(int[] a)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: void Sort(int[] a)
- en: '{'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int i = 0; i < a.Length - 1; i++)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < a.Length - 1; i++)
- en: '{'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int minIndex = i;
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: int minIndex = i;
- en: int minValue = a[i];
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: int minValue = a[i];
- en: for (int j = i + 1; j < a.Length; j++)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: for (int j = i + 1; j < a.Length; j++)
- en: '{'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (a[j] < minValue)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: if (a[j] < minValue)
- en: '{'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: minIndex = j;
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: minIndex = j;
- en: minValue = a[j];
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: minValue = a[j];
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: (a[i], a[minIndex]) = (a[minIndex], a[i]);
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (a[i], a[minIndex]) = (a[minIndex], a[i]);
- en: '}'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: int[] array = [-11, 12, -42, 0, 1, 90, 68, 6, -9];
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: int[] array = [-11, 12, -42, 0, 1, 90, 68, 6, -9];
- en: Sort(array);
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Sort(array);
- en: Console.WriteLine(string.Join(" | ", array));
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(string.Join(" | ", array));
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: -42 | -11 | -9 | 0 | 1 | 6 | 12 | 68 | 90
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: -42 | -11 | -9 | 0 | 1 | 6 | 12 | 68 | 90
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: void Sort(int[] a)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: void Sort(int[] a)
- en: '{'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int i = 1; i < a.Length; i++)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 1; i < a.Length; i++)
- en: '{'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int j = i;
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: int j = i;
- en: while (j > 0 && a[j] < a[j - 1])
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: while (j > 0 && a[j] < a[j - 1])
- en: '{'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: (a[j], a[j - 1]) = (a[j - 1], a[j]);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: (a[j], a[j - 1]) = (a[j - 1], a[j]);
- en: j--;
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: j--;
- en: '}'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: void Sort(int[] a)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: void Sort(int[] a)
- en: '{'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int i = 0; i < a.Length; i++)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < a.Length; i++)
- en: '{'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: for (int j = 0; j < a.Length - 1; j++)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: for (int j = 0; j < a.Length - 1; j++)
- en: '{'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (a[j] > a[j + 1])
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: if (a[j] > a[j + 1])
- en: '{'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: (a[j], a[j + 1]) = (a[j + 1], a[j]);
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: (a[j], a[j + 1]) = (a[j + 1], a[j]);
- en: '}'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: void Sort(int[] a)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: void Sort(int[] a)
- en: '{'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int i = 0; i < a.Length; i++)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < a.Length; i++)
- en: '{'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: bool isAnyChange = false;
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: bool isAnyChange = false;
- en: for (int j = 0; j < a.Length - 1; j++)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: for (int j = 0; j < a.Length - 1; j++)
- en: '{'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if (a[j] > a[j + 1])
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: if (a[j] > a[j + 1])
- en: '{'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: isAnyChange = true;
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: isAnyChange = true;
- en: (a[j], a[j + 1]) = (a[j + 1], a[j]);
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: (a[j], a[j + 1]) = (a[j + 1], a[j]);
- en: '}'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if (!isAnyChange) { break; }
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: if (!isAnyChange) { break; }
- en: '}'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE43]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: void Sort(int[] a)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: void Sort(int[] a)
- en: '{'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (a.Length <= 1) { return; }
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: if (a.Length <= 1) { return; }
- en: int m = a.Length / 2;
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: int m = a.Length / 2;
- en: int[] left = GetSubarray(a, 0, m - 1);
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: int[] left = GetSubarray(a, 0, m - 1);
- en: int[] right = GetSubarray(a, m, a.Length - 1);
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: int[] right = GetSubarray(a, m, a.Length - 1);
- en: Sort(left);
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Sort(left);
- en: Sort(right);
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Sort(right);
- en: int i = 0, j = 0, k = 0;
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 0, j = 0, k = 0;
- en: while (i < left.Length && j < right.Length)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: while (i < left.Length && j < right.Length)
- en: '{'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (left[i] <= right[j]) { a[k] = left[i++]; }
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: if (left[i] <= right[j]) { a[k] = left[i++]; }
- en: else { a[k] = right[j++]; }
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: else { a[k] = right[j++]; }
- en: k++;
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: k++;
- en: '}'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: while (i < left.Length) { a[k++] = left[i++]; }
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: while (i < left.Length) { a[k++] = left[i++]; }
- en: while (j < right.Length) { a[k++] = right[j++]; }
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: while (j < right.Length) { a[k++] = right[j++]; }
- en: '}'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE44]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: int[] GetSubarray(int[] a, int si, int ei)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: int[] GetSubarray(int[] a, int si, int ei)
- en: '{'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int[] result = new int[ei - si + 1];
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: int[] result = new int[ei - si + 1];
- en: Array.Copy(a, si, result, 0, ei - si + 1);
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Array.Copy(a, si, result, 0, ei - si + 1);
- en: return result;
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: return result;
- en: '}'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE45]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: void Sort(int[] a)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: void Sort(int[] a)
- en: '{'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int h = a.Length / 2; h > 0; h /= 2)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: for (int h = a.Length / 2; h > 0; h /= 2)
- en: '{'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int i = h; i < a.Length; i++)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = h; i < a.Length; i++)
- en: '{'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int j = i;
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: int j = i;
- en: int ai = a[i];
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: int ai = a[i];
- en: while (j >= h && a[j - h] > ai)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: while (j >= h && a[j - h] > ai)
- en: '{'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: a[j] = a[j - h];
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: a[j] = a[j - h];
- en: j -= h;
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: j -= h;
- en: '}'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: a[j] = ai;
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: a[j] = ai;
- en: '}'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: for loop is used to calculate proper values of h, starting with the array (a)
    length divided by 2. It is further divided by 2 after each iteration and the last
    acceptable value is 1.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环来计算`h`的适当值，从数组（a）的长度除以2开始。每次迭代后，它进一步除以2，最后一个可接受值是1。
- en: The next `for` loop calculates the `i` index, starting with `h`, and increases
    it until the end of the array is reached. This part is used to perform the insertion
    sort on virtual subarrays.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`for`循环计算`i`索引，从`h`开始，并增加到达到数组的末尾。这部分用于在虚拟子数组上执行插入排序。
- en: Within the loop, you can use the `ai` variable to store the current value of
    the element with the `i` index, so you can replace it later with another value.
    Then, a `while` loop is used to shift elements in the virtual subarray to find
    the correct location for `ai`. Finally, you store the `ai` variable in the location
    indicated by the `j` variable.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，你可以使用`ai`变量来存储具有`i`索引的元素的当前值，以便稍后用另一个值替换它。然后，使用一个`while`循环来移动虚拟子数组中的元素，以找到`ai`的正确位置。最后，将`ai`变量存储在由`j`变量指示的位置。
- en: As you can see, the implementation is very short and quite simple. What’s more,
    this algorithm is efficient and can be used for sorting large collections of data,
    as you will see later in this chapter. But what about the time complexity? **In
    the worst case, it is** **O(n**2**)**. However, its **average time complexity
    is about** **O(n log(n))**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，实现非常简短且简单。更重要的是，这个算法效率高，可以用于排序大量数据，正如你将在本章后面看到的那样。但是，时间复杂度如何？**在最坏的情况下，它是**
    **O(n**2**)**。然而，其**平均时间复杂度大约是** **O(n log(n))**。
- en: Quicksort
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序
- en: The sixth sorting algorithm described in this book is **quicksort**. It is one
    of the popular algorithms from the divide and conquer group and divides a problem
    into a set of smaller ones. How does it work?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所描述的第六种排序算法是**快速排序**。它是分治法组中的一种流行算法，将一个问题分解成一系列更小的子问题。它是如何工作的？
- en: '**The algorithm picks some value (for example, from the last element of the
    array) as a pivot. Then, it reorders the array in such a way that values lower
    than the pivot are placed before it (forming the lower subarray), while values
    greater than or equal to the pivot are placed** **after it (the higher subarray).
    Such a process is called** **partitioning****. Next, the algorithm recursively
    sorts each of the aforementioned subarrays. Each subarray is further divided into
    the next two subarrays, and so on. The recursive calls stop when there are one
    or zero elements in a subarray because in such a case, there is nothing** **to
    sort**.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法选择某个值（例如，从数组的最后一个元素）作为枢轴。然后，它以这种方式重新排列数组，使得小于枢轴的值放在它之前（形成下子数组），而大于或等于枢轴的值放在它之后（形成上子数组）。这个过程称为**分区****。接下来，算法递归地对上述每个子数组进行排序。每个子数组进一步分解成下一个两个子数组，依此类推。递归调用在子数组中有一个或零个元素时停止，因为在这样的情况下，没有东西**
    **需要排序**。'
- en: The preceding description may sound a bit complicated. However, the following
    figure and the algorithm’s implementation should remove any doubts.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述可能听起来有点复杂。然而，以下图和算法的实现应该可以消除任何疑问。
- en: 'The following diagram shows how the quicksort algorithm sorts a single-dimensional
    array with nine elements (`-11`, `12`, `-42`, `0`, `1`, `90`, `68`, `6`, and `-9`):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了快速排序算法如何对一个包含九个元素的单维数组（`-11`，`12`，`-42`，`0`，`1`，`90`，`68`，`6` 和 `-9`）进行排序：
- en: '![Figure 3.12 – Illustration of the quicksort algorithm](img/B18069_03_12.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 快速排序算法的示意图](img/B18069_03_12.jpg)'
- en: Figure 3.12 – Illustration of the quicksort algorithm
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 快速排序算法的示意图
- en: In our case, it is assumed that the pivot is chosen as a value of the last element
    of the subarray that is currently being sorted. In *Step 1*, `-9` is chosen as
    the pivot. Then, it is necessary to swap `12` with `-42` (*Step 1*), as well as
    `12` with `-9` (*Step 2*), to ensure that only values lower than the pivot (`-11`,
    `-42`) are in the lower subarray and only values greater than or equal to the
    pivot (`0`, `1`, `90`, `68`, `6`, `12`) are placed in the higher subarray (*Step
    3*). Then, the algorithm is called recursively for both aforementioned subarrays,
    namely (`-11`, `-42`, from *Step 4*) and (`0`, `1`, `90`, `68`, `6`, `12`, from
    *Step 7*), so that they are processed in the same way as the input array.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，假设枢轴被选为当前正在排序的子数组的最后一个元素的值。在 *步骤 1* 中，`-9` 被选为枢轴。然后，需要将 `12` 与 `-42`（*步骤
    1*）以及 `12` 与 `-9`（*步骤 2*）交换，以确保只有小于枢轴的值（`-11`，`-42`）位于较低子数组中，而大于或等于枢轴的值（`0`，`1`，`90`，`68`，`6`，`12`）被放置在较高子数组中（*步骤
    3*）。然后，算法对上述两个子数组进行递归调用，即（`-11`，`-42`，从 *步骤 4*）和（`0`，`1`，`90`，`68`，`6`，`12`，从
    *步骤 7*），这样它们就可以像输入数组一样进行处理。
- en: As an example, *Step 7* shows that `12` is chosen as the pivot. After partitioning,
    the subarray is divided into two other subarrays, namely (`0`, `1`, `6`) and (`90`,
    `68`). For both, other pivot elements are chosen, namely `6` and `68`. After performing
    such operations for all the remaining parts of the array, you receive the result
    shown in *Step 16*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*步骤 7* 显示 `12` 被选为枢轴。在分区后，子数组被分为两个其他子数组，即（`0`，`1`，`6`）和（`90`，`68`）。对于这两个子数组，选择其他枢轴元素，即
    `6` 和 `68`。在执行所有剩余数组部分的此类操作后，你将得到 *步骤 16* 中显示的结果。
- en: 'It is worth mentioning that the pivot can be selected variously in other implementations
    of this algorithm. Now that you understand how the algorithm works, let’s proceed
    to its implementation. It’s no more complicated than the examples shown earlier,
    and it uses **recursion** to call the sorting method for subarrays. The main code
    is as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，枢轴可以在该算法的其他实现中根据不同的方式选择。现在你了解了算法的工作原理，让我们继续其实现。它并不比前面展示的例子更复杂，它使用 **递归**
    来调用子数组的排序方法。主要代码如下：
- en: '[PRE46]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `Sort` method takes only one parameter, namely the array that should be
    sorted. It just calls the `SortPart` method, which makes it possible to `SortPart`
    method is shown here:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort` 方法只接受一个参数，即应该排序的数组。它只是调用 `SortPart` 方法，这使得 `SortPart` 方法得以展示如下：'
- en: '[PRE47]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, the method checks whether the array (or subarray) has at least two elements
    by comparing the values of the `l` (*lower index*) and `u` (*upper index*) variables.
    If not, you return from this method. Otherwise, you perform the partitioning phase.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，方法检查数组（或子数组）是否至少有两个元素，通过比较 `l`（*下标*）和 `u`（*上标*）变量的值。如果不是，你将从这个方法返回。否则，你将执行分区阶段。
- en: Here, the pivot is chosen as a value of the last element in the array (or subarray)
    and stored as a value of the `pivot` variable. Then, a `for` loop is used to rearrange
    the array using comparisons and swapping elements. You need to perform this stage
    to ensure that values lower than the pivot are placed before it, while values
    greater than or equal to the pivot are placed after it.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，枢轴被选为数组（或子数组）中的最后一个元素的值，并存储为 `pivot` 变量的值。然后，使用 `for` 循环通过比较和交换元素来重新排列数组。你需要执行这个阶段以确保小于枢轴的值位于其前面，而大于或等于枢轴的值位于其后。
- en: Finally, you store a new index of the pivot value as `p` and perform swapping
    to place it there. The `p` variable is also used to calculate lower and upper
    bounds for subarrays, namely as (`l`, `p-1`) and (`p+1`, `u`). Such ranges are
    then used while calling the `SortPart` method recursively for the lower and upper
    parts. That’s all!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将枢轴值的新索引存储为 `p` 并执行交换以将其放置在那里。`p` 变量还用于计算子数组的上下界，即作为 (`l`, `p-1`) 和 (`p+1`,
    `u`)。然后，在递归调用 `SortPart` 方法对较低和较高部分进行排序时使用这些范围。这就是全部！
- en: What about the time complexity? It has **O(n log(n)) average time complexity,
    despite having O(n**2**) worst time complexity**. Does this look similar to Shell
    sort to you? If so, you are right! You are coming closer and closer to the end
    of this chapter, where you will see results from conducting performance tests
    on various sorting algorithms.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 关于时间复杂度呢？它具有**O(n log(n))的平均时间复杂度，尽管最坏情况下的时间复杂度为O(n^2**)。这看起来像Shell排序吗？如果是这样，你就对了！你越来越接近本章的结尾了，在那里你将看到对各种排序算法进行性能测试的结果。
- en: Heap sort
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序
- en: The last approach we’ll cover is based on an interesting data structure known
    as a **binary heap**. To give you a brief introduction, **it is a tree-based structure
    where each node contains either zero, one, or two child nodes**. You’ll learn
    more about trees and their variants later in this book.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一个方法是基于一种有趣的数据结构，称为**二叉堆**。为了给你一个简要的介绍，**它是一种基于树的结构的树，其中每个节点包含零个、一个或两个子节点**。你将在本书的后面部分了解更多关于树及其变体的内容。
- en: It won’t come as a surprise to you that the sorting solution is named **heap
    sort**. **First, the algorithm** **builds a** **max-heap** **from the array (the**
    **heapify** **operation). Then, it repeats a** **few steps until there is only
    one element in** **the heap:**
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会感到惊讶，这个排序解决方案被命名为**堆排序**。**首先，算法** **从数组中构建一个** **最大堆** **（执行堆化操作）。然后，它重复以下几个步骤，直到堆中只剩下一个元素：**
- en: '**Swap the first element (root with the maximum value) with the** **last element.**'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将第一个元素（最大值的根）与最后一个元素交换。**'
- en: '**Remove the last element (which is currently the maximum value) from** **the
    heap.**'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从堆中移除最后一个元素（当前的最大值）。**'
- en: '**Build the** **max-heap again.**'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**再次构建** **最大堆。**'
- en: By performing these operations, you efficiently receive the sorted array.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行这些操作，你有效地得到了排序后的数组。
- en: 'As a new data structure must be introduced here, let’s look at what the binary
    heap looks like and how the algorithm operates to sort the example array:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里需要引入一个新的数据结构，让我们看看二叉堆的样子以及算法是如何对示例数组进行排序的：
- en: '![Figure 3.13 – Illustration of the heap sort algorithm](img/B18069_03_13.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 堆排序算法的示意图](img/B18069_03_13.jpg)'
- en: Figure 3.13 – Illustration of the heap sort algorithm
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 堆排序算法的示意图
- en: 'The input array consists of six elements, namely `-11`, `12`, `-42`, `0`, `90`,
    and `-9`. You form a binary heap from it by placing the first element as a *root*
    and then by adding two of its child nodes: `12` and `-42`. You do not have more
    space at this level of the heap, so let’s add the following two elements from
    the array (`0` and `90`) as child nodes to the node with `12`. The last element
    from the array is left. You must place it as a child node of the node with `-42`.
    As you can see, you can easily map an array to a binary heap data structure and
    use an array as a data structure to store the data of a binary heap.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数组由六个元素组成，即`-11`、`12`、`-42`、`0`、`90`和`-9`。你通过将第一个元素作为**根**，然后添加它的两个子节点：`12`和`-42`，从它形成二叉堆。在这个堆的级别上，你没有更多的空间，所以让我们将数组中的以下两个元素（`0`和`90`）作为子节点添加到值为`12`的节点上。数组的最后一个元素被留下。你必须将它放置在值为`-42`的节点的子节点上。正如你所看到的，你可以轻松地将一个数组映射到二叉堆数据结构，并使用数组作为数据结构来存储二叉堆的数据。
- en: Interesting properties of a binary heap
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉堆的有趣特性
- en: Remember that a root node in a binary heap, represented by an array, is available
    at `array[0]`. If you need to access the data of a parent node of the *i*-th element,
    you can get it from `array[(i-1)/2]`. The left and right child nodes of the *i*-th
    element are available in `array[(2*i)+1]` and `array[(2*i)+2]`, respectively.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在以数组表示的二叉堆中，根节点位于`array[0]`。如果你需要访问第*i*个元素的父节点数据，你可以从`array[(i-1)/2]`中获取它。第*i*个元素的左子节点和右子节点分别在`array[(2*i)+1]`和`array[(2*i)+2]`中可用。
- en: The next operation, which takes an important role in the heap sort algorithm,
    is named `90` is located as the *root*. It contains `12` and `-9` as nodes. The
    node with `12` contains child nodes with smaller values, namely `0` and `-11`.
    The node with `-9` contains only one element, which is also smaller than it, namely
    `-42`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序算法中扮演重要角色的下一个操作被命名为`90`作为**根**。它包含`12`和`-9`作为节点。值为`12`的节点包含值较小的子节点，即`0`和`-11`。值为`-9`的节点只包含一个元素，这个元素也小于它，即`-42`。
- en: Max-heap is not the only option
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最大堆不是唯一的选择
- en: You can also use the *heapify* operation to form the **min-heap**. It is similar
    to the max-heap, but each node needs to meet the condition that the values of
    its child nodes are greater than or equal to the parent node’s value.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用*heapify*操作来形成**min-heap**。它与最大堆类似，但每个节点都需要满足其子节点的值大于或等于父节点值的条件。
- en: Let’s proceed to the second row of the preceding figure. Here, the last element
    of the array (`90`) is already sorted. This is the result of swapping the root
    (previously, `90`) with the last element in the array (previously, `-42`). Then,
    you must perform another *heapify* operation and receive the max-heap with `12`
    as the *root*. The aforementioned actions are repeated until the heap contains
    only one element. In the end, you receive the sorted array, as shown in the bottom-right
    corner of the preceding figure.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看一下前面图中的第二行。在这里，数组的最后一个元素（`90`）已经排序了。这是通过将根（之前是`90`）与数组中的最后一个元素（之前是`-42`）交换的结果。然后，你必须执行另一个*heapify*操作，并得到以`12`为*root*的最大堆。上述操作会一直重复，直到堆中只剩下一个元素。最后，你将得到前面图右下角所示的排序数组。
- en: 'At this point, you should be ready to analyze the implementation code in the
    C# language:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该准备好分析C#语言的实现代码：
- en: '[PRE48]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Sort` method contains two `for` loops. The first performs the initial *heapify*
    operation to prepare the *max-heap*. You can do so by calling the `Heapify` multiple
    times, namely in reverse order and on each node that is not a leaf. Then, you
    have the array with data forming the *max-heap*.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort`方法包含两个`for`循环。第一个循环执行初始的*heapify*操作，以准备*max-heap*。你可以通过多次调用`Heapify`来实现，即以相反的顺序和每个非叶子节点进行操作。然后，你将得到由数据形成的*max-heap*的数组。'
- en: The second `for` loop is performed until there is at least one element in the
    heap. In each iteration, it swaps the *root* element (with an index equal to `0`)
    with the last element, which has an index equal to `i`. Then, you need to restore
    the *max-heap* property, which you do by calling the `Heapify` method, regarding
    the affected part of the heap.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`for`循环会一直执行，直到堆中至少有一个元素。在每次迭代中，它将*root*元素（索引等于`0`）与最后一个元素（索引等于`i`）交换。然后，你需要通过调用`Heapify`方法来恢复*max-heap*属性，这涉及到堆的受影响部分。
- en: 'Now, let’s take a look at the code of the `Heapify` method:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`Heapify`方法的代码：
- en: '[PRE49]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It takes three parameters, namely an array (`a`), the number of elements in
    a heap (`n`), as well as an index of an element (`i`), which is a root of a subtree
    that should be *heapified*. First, you get an index of the maximum element (*root*,
    as `max`), as well as its left and right children (`l` and `r`, respectively).
    You can calculate indices according to the formulas presented earlier, namely
    `2*i+1` and `2*i+2`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个参数，即数组（`a`）、堆中的元素数量（`n`），以及一个元素的索引（`i`），它是应该*heapify*的子树的根。首先，你得到最大元素的索引（*root*，作为`max`），以及它的左子节点和右子节点（`l`和`r`，分别）。你可以根据前面提到的公式计算索引，即`2*i+1`和`2*i+2`。
- en: In the following two lines, you check whether the left child index (`l`) is
    still within the heap (`l<n`) and whether the element with this index (`a[l]`)
    is greater than the current root value (`a[max]`). If so, you update the root
    index (`max`). In the same way, you check the right child and adjust the `max`
    variable, if necessary.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下两行中，你检查左子节点索引（`l`）是否仍在堆中（`l<n`），以及具有该索引的元素（`a[l]`）是否大于当前根值（`a[max]`）。如果是这样，你更新根索引（`max`）。以同样的方式，你检查右子节点并调整`max`变量，如果需要的话。
- en: In the next line, you check whether the *root* index changed during the mentioned
    operations. If so, this means that the current *root* is not the biggest value
    and you need to swap two elements in the array, namely representing the *root*
    (the `i` index) and the biggest value (the `max` index). Next, you recursively
    perform the *heapify* operation for the affected subtree, namely a tree with a
    new root value.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，你检查在提到的操作中*root*索引是否发生了变化。如果是这样，这意味着当前的*root*不是最大值，你需要交换数组中的两个元素，即表示*root*（`i`索引）和最大值（`max`索引）。接下来，你递归地对受影响的子树执行*heapify*操作，即具有新根值的树。
- en: After this detailed explanation, it is worth mentioning the time complexity.
    It is very important in this case because the method is efficient and can be used
    successfully while sorting large data collections. **The time complexity is**
    **O(n log(n))**.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个详细的解释之后，值得提到的是时间复杂度。在这种情况下，它非常重要，因为该方法效率高，可以在排序大型数据集合时成功使用。**时间复杂度是** **O(n
    log(n))**。
- en: Despite learning about seven different sorting algorithms, please keep in mind
    that there are many more such algorithms available, including **block sort**,
    **tree sort**, **cube sort**, **strand sort**, and **cycle sort**. If you are
    interested in this topic, I strongly encourage you to take a look at them on your
    own. In the meantime, let’s compare the algorithms we’ve covered in this chapter.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管学习了七种不同的排序算法，但请记住，还有许多其他这样的算法可供选择，包括**块排序**、**树排序**、**立方排序**、**链排序**和**循环排序**。如果你对这个主题感兴趣，我强烈建议你亲自查看它们。在此期间，让我们比较一下本章中涵盖的算法。
- en: Performance analysis
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析
- en: To perform some tests, you need to configure your environment. So, let’s start
    by preparing the code for running various sorting algorithms using the same input
    arrays.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行一些测试，你需要配置你的环境。因此，让我们首先准备运行各种排序算法的代码，使用相同的输入数组。
- en: Do you remember that each implementation presented in this chapter involves
    the `Sort` method, taking only one parameter (namely the `a` array)? Now, you
    can benefit from this assumption and create the `AbstractSort` abstract class,
    which requires you to implement this method while deriving from this class.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得吗，本章中展示的每个实现都涉及`Sort`方法，它只接受一个参数（即`a`数组）？现在，你可以利用这个假设并创建一个`AbstractSort`抽象类，该类要求你在派生此类时实现此方法。
- en: 'The code for the abstract class is as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类的代码如下：
- en: '[PRE50]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, you need to prepare a separate class for each sorting algorithm (such
    as `SelectionSort` or `HeapSort`) according to the following template:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要为每个排序算法（如`SelectionSort`或`HeapSort`）准备一个单独的类，根据以下模板：
- en: '[PRE51]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Since all the classes representing sorting algorithms derive from the base
    abstract class (`AbstractSort`)you can easily create a list containing their instances:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有表示排序算法的类都从基抽象类`AbstractSort`派生，你可以轻松地创建一个包含它们实例的列表：
- en: '[PRE52]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The most interesting part of the code is shown here:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分如下所示：
- en: '[PRE53]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, you use a `for` loop to choose suitable values of `n`, which is the length
    of the input array used for sorting. You start with an array with zero elements
    (`n` = `0`) and end with hundreds of thousands of elements (`n` = `100000`), increasing
    the size by `10000` in each iteration. The values of `n` will be `0`, `10000`,
    `20000`, and `30000`, up to `100000`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用一个`for`循环来选择合适的`n`值，这是用于排序的输入数组的长度。你从一个包含零个元素的数组开始（`n` = `0`），并以每迭代增加`10000`的方式，直到有数十万个元素（`n`
    = `100000`）。`n`的值将是`0`、`10000`、`20000`、`30000`，直到`100000`。
- en: In each iteration, you create a new instance of the list (`milliseconds`) .
    Each its element stores a tuple consisting of two elements, namely a type of the
    sorting algorithm class (`Type`) and elapsed milliseconds of execution (`Ms`).
    Then, you use another `for` loop to perform such tests `5` times. In each of them,
    you get a random array (`array`) with a given size by calling `GetRandomArray`,
    which will be used as a template for each test. Next, you declare and initialize
    the input array (`input`).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，你创建列表（`milliseconds`）的新实例。每个元素存储一个由两个元素组成的元组，即排序算法类的类型（`Type`）和执行消耗的毫秒数（`Ms`）。然后，你使用另一个`for`循环执行这样的测试`5`次。在每次测试中，你通过调用`GetRandomArray`获取一个给定大小的随机数组（`array`），它将被用作每个测试的模板。接下来，你声明并初始化输入数组（`input`）。
- en: The next part involves a `foreach` loop and iterates through all instances of
    classes deriving from `AbstractSort`. For each of them, you create an input array
    by copying elements from `array` to `input`. Then, you start the stopwatch and
    call the `Sort` method. As soon as it has finished running, you stop the stopwatch
    and add results to the `milliseconds` list.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分涉及一个`foreach`循环，遍历所有从`AbstractSort`派生出来的类的实例。对于每一个，你通过从`array`复制元素到`input`来创建一个输入数组。然后，你开始计时并调用`Sort`方法。一旦它运行完成，你停止计时并将结果添加到`milliseconds`列表中。
- en: The last part of the code is related to calculating the average result for each
    sorting algorithm and its presentation in the console. To do so, you use a few
    extension methods, such as `GroupBy`, `Select`, and `Average`, as well as a `foreach`
    loop.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分与计算每个排序算法的平均结果及其在控制台中的展示有关。为此，你使用一些扩展方法，例如`GroupBy`、`Select`和`Average`，以及一个`foreach`循环。
- en: 'The `GetRandomArray` method was mentioned earlier, so let’s take a look at
    it:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到了`GetRandomArray`方法，让我们来看看它：
- en: '[PRE54]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It uses the `Random` class to get a random integer value in the range of `<-100,000,
    100,000)`. The whole array is filled with such random values.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`Random`类在`<-100,000, 100,000)`范围内获取一个随机整数。整个数组填充了这样的随机值。
- en: 'At this point, your environment is ready and you can perform tests! So, let’s
    run the code and see the results. I received the following values:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的环境已经准备就绪，你可以进行测试！所以，让我们运行代码并查看结果。我得到了以下值：
- en: "![Figure 3.14 – Results of analyzing the performance of \uFEFFthe sorting algorithms](img/B18069_03_14.jpg)"
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – 分析排序算法性能的结果](img/B18069_03_14.jpg)'
- en: Figure 3.14 – Results of analyzing the performance of the sorting algorithms
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 分析排序算法性能的结果
- en: 'Apart from the table and its data, let’s take a look at the chart:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表格及其数据之外，让我们看看图表：
- en: '![Figure 3.15 – Comparison of the sorting algorithms’ performance results](img/B18069_03_15.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – 排序算法性能结果的比较](img/B18069_03_15.jpg)'
- en: Figure 3.15 – Comparison of the sorting algorithms’ performance results
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 排序算法性能结果的比较
- en: As you can see, the worst results are received for bubble sort, then the insertion
    sort and selection sort algorithms. For an array with 100,000 elements, they need
    almost 33 seconds (bubble sort), almost 14 seconds (insertion sort), and more
    than 5 seconds (selection sort). Such values look extremely high compared to the
    results of merge sort, Shell sort, quicksort, and heap sort. These algorithms
    needed between 12 and 28 milliseconds! Does this seem surprising? It shouldn’t
    if you recall time complexity.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最差的结果是冒泡排序，然后是插入排序和选择排序算法。对于包含10万个元素的数组，它们需要几乎33秒（冒泡排序）、几乎14秒（插入排序）和超过5秒（选择排序）。与归并排序、希尔排序、快速排序和堆排序的结果相比，这些值看起来非常高。这些算法需要12到28毫秒！这看起来令人惊讶吗？如果你回想一下时间复杂度，就不应该感到惊讶。
- en: 'Let’s remember the average time complexity for the mentioned algorithms:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住所提及算法的平均时间复杂度：
- en: '*O(n*2*)*: Selection sort, insertion sort, and bubble sort'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(n^2)*：选择排序、插入排序和冒泡排序'
- en: '*O(n log(n))*: Merge sort, Shell sort, quicksort, and heap sort'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(n log(n))*：归并排序、希尔排序、快速排序和堆排序'
- en: Oh, so it seems that such time complexities really have an importance! ;-) If
    you earlier had any doubts, it’s the high time to take attention to the algorithms
    you use in your applications. You should choose them carefully and optimize the
    solution to handle various amounts of data that need to be processed.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，所以这样的时间复杂度确实很重要！ ;-) 如果你之前有任何怀疑，现在是时候注意你在应用中使用的算法了。你应该仔细选择它们，并优化解决方案以处理需要处理的各种数据量。
- en: Don’t forget about performance
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记性能
- en: Taking care of performance is important not only for sorting but for all operations
    that you perform in your mobile applications, web applications, APIs, and long-running
    background services. Let’s try to write efficient code and test it not only by
    meeting the functional requirements but also by taking care of non-functional
    ones, such as those related to performance.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 重视性能不仅对排序操作重要，对你在移动应用、Web应用、API和长时间运行的后台服务中进行的所有操作都很重要。让我们尝试编写高效的代码，并通过满足功能需求以及关注非功能需求（如与性能相关的需求）来测试它。
- en: 'In the previous chart, you almost cannot see any data regarding the algorithms
    with *O(n log(n))* time complexity, so let’s prepare another set of tests. Now,
    you can choose only these algorithms and increase the maximum number of *n* to
    one million! You can see my results in the following chart:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图表中，你几乎看不到任何关于具有*O(n log(n))*时间复杂度的算法的数据，所以让我们准备另一组测试。现在，你只能选择这些算法，并将最大数*n*增加到一百万！你可以在以下图表中看到我的结果：
- en: '![Figure 3.16 – Comparison of the sorting algorithms’ performance results](img/B18069_03_16.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – 排序算法性能结果的比较](img/B18069_03_16.jpg)'
- en: Figure 3.16 – Comparison of the sorting algorithms’ performance results
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 排序算法性能结果的比较
- en: There are some differences here, especially between quicksort and the remaining
    ones, namely Shell sort, merge sort, and heap sort. However, such changes are
    only visible with quite a huge input size and can be caused by the implementation
    details. All of the sorting algorithms with *O(n log(n))* time complexity are
    good solutions for sorting and can handle various amounts of data. It is also
    worth noting that these results were received on my device, so you may get different
    results. However, the relationship between the received number of elapsed milliseconds
    should be consistent.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些差异，尤其是在快速排序和其他排序算法（如希尔排序、归并排序和堆排序）之间。然而，这种变化只有在相当大的输入大小下才能看到，并且可能由实现细节引起。所有具有
    *O(n log(n))* 时间复杂度的排序算法都是排序的良好解决方案，可以处理各种数量的数据。还值得注意的是，这些结果是在我的设备上获得的，所以你可能得到不同的结果。然而，接收到的已过毫秒数之间的关系应该是一致的。
- en: Summary
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: Arrays are among the most common data structures that are used while developing
    various kinds of applications, such as mobile, web, or distributed ones. However,
    this topic is not as easy as it seems to be because even arrays can be divided
    into a few variants, namely **single-dimensional** and **multi-dimensional**,
    such as two-dimensional and three-dimensional, as well as **jagged arrays**, also
    referred to as arrays of arrays.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是开发各种类型的应用程序（如移动、Web 或分布式应用程序）时最常用的数据结构之一。然而，这个话题并不像看起来那么简单，因为即使是数组也可以分为几种变体，即**一维**和**多维**，例如二维和三维，以及**锯齿数组**，也称为数组数组。
- en: While talking about arrays, don’t forget about **sorting algorithms**, which
    are one of the most popular algorithms used with this data structure. There are
    plenty of sorting algorithms that differ by their concept, application, implementation
    details, and performance results. In this chapter, you learned about seven different
    sorting algorithms, namely **selection sort**, **insertion sort**, **bubble sort**,
    **merge sort**, **Shell sort**, **quicksort**, and **heap sort**. Each of them
    was described, visualized in figures, and written in C# code.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论数组时，不要忘记**排序算法**，这是与这种数据结构一起使用最流行的算法之一。有大量的排序算法，它们在概念、应用、实现细节和性能结果上都有所不同。在本章中，你学习了七种不同的排序算法，即**选择排序**、**插入排序**、**冒泡排序**、**归并排序**、**希尔排序**、**快速排序**和**堆排序**。每种算法都进行了描述，并在图中进行了可视化，并以
    C# 代码编写。
- en: At the end of this chapter, you saw how important time complexity is and how
    big an impact it can have on **performance results** while you’re using algorithms
    with different computational complexity, such as *O(n*2*)* and *O(n log(n))*.
    You learned how to prepare a simple environment for the performance tests and
    run them to get the results. They were later shown in a table, as well as in charts,
    together with an explanation.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你看到了时间复杂性的重要性以及它在使用不同计算复杂性的算法（如 *O(n^2)* 和 *O(n log(n))*) 时对**性能结果**的影响有多大。你学习了如何准备一个简单的性能测试环境并运行它们以获取结果。这些结果随后在表格以及图表中展示，并附有解释。
- en: Are you ready to learn other data structures? If so, proceed to the next chapter,
    where you’ll learn about various **variants of lists**, namely simple, generic,
    sorted, as well as singly, doubly, and circular linked. You will see their implementation
    and a few examples of how you can use them in real-world examples.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好学习其他数据结构了吗？如果是的话，请继续阅读下一章，在那里你将学习关于各种**列表变体**的内容，包括简单、泛型、排序的，以及单链、双链和循环链。你将看到它们的实现和一些如何在现实世界例子中使用它们的示例。
- en: '[PRE55]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
