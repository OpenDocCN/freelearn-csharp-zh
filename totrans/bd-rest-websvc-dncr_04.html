<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Item Catalogue, Cart, and Checkout</h1>
                </header>
            
            <article>
                
<p>This chapter will take a look at coding the main sections of an e-commerce app and its related API endpoints.</p>
<p>We have already discussed user registration and authentication in the previous chapter, and we will be carrying forward that knowledge to help us implement security inside different controllers that we build in this chapter.</p>
<p>To display products and search for them efficiently, we are also going to design <kbd>ProductsController</kbd>.</p>
<p>After that, we will also look at how to put your products into your shopping cart, discussing how to add, update, and delete items in a cart.</p>
<p>Last, but not least, we will also take a look at order management and processing.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Implementing different controllers</li>
<li>Product listing and product searching</li>
<li>Adding, updating, and deleting cart items</li>
<li>Imposing security on controllers</li>
<li>Order processing and shipping information</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing controllers</h1>
                </header>
            
            <article>
                
<p>As we are going to learn about the core functions of our app, we need to design its controllers so that we have REST endpoints to perform tasks from our client. Things such as <em>product listing</em>, <em>product searching</em>, <em>add to cart</em>, <em>placing orders</em>, and <em>processing shipments</em> can be done with one dedicated controller for each function. These controllers will be responsible for performing actions on the database, so we need to model classes for the related tables. Let's get to work!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating models</h1>
                </header>
            
            <article>
                
<p>The following line can be executed inside the Package Manager Console to generate model classes for all the tables in the database:</p>
<pre>Scaffold-DbContext "Server=.;Database=FlixOneStore;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Force</pre>
<p>The preceding command will populate class files for each table inside the <kbd>Models</kbd> folder, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/281b8757-ef5d-40b2-b86c-3702e6fdbabc.png" style="width:14.83em;height:26.08em;"/></div>
<div class="packt_infobox">If you have not already done so, please refer to the database script in <a href="https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core</a> to generate the database table for your application.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating controllers</h1>
                </header>
            
            <article>
                
<p>To generate controllers for the models, r<span>ight-click on</span> <kbd>Controllers</kbd> <span>folder |</span> <span class="packt_screen">Add</span> <span>|</span> <span class="packt_screen">Controller</span> <span>|</span> <span class="packt_screen">API Controller with actions, using Entity Framework</span><span>.</span></p>
<p>First, let's start with <kbd>ProductsdetailsController</kbd>, as we want to show the products list to our customers initially.</p>
<p>The <kbd>Productsdetail.cs</kbd> model class generated through scaffolding should look like the following snippet:</p>
<pre>public partial class Productsdetail<br/>{<br/>  public Guid Id { get; set; }<br/>  public Guid? Productid { get; set; }<br/>  public string Name { get; set; }<br/>  public string Description { get; set; }<br/>  public string Url { get; set; }<br/>  public int Views { get; set; }<br/>  public Products Product { get; set; }<br/>} </pre>
<p>The preceding code can also be used to generate the controller with <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> action methods: (We're focusing on the <kbd>GetProductsdetail</kbd> method for now.)</p>
<pre>// GET: api/Productsdetails<br/>[HttpGet]<br/>public IEnumerable&lt;Productsdetail&gt; GetProductsdetail()<br/>{<br/>  return _context.Productsdetail;<br/>}</pre>
<p>You can quickly test whether your controller is working using Postman, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d6c1645c-c091-4b39-9e5e-8da4ea9e01ee.png"/></div>
<p>Here, the URL is <kbd>http://localhost:57571/api/Productsdetails</kbd> and the type is <kbd>GET</kbd>. We can see the results in the result box, which shows us an array of product details in a JSON format. Note that we sent this request by setting the <kbd>contentType</kbd> header with the value <kbd>application/json</kbd> inside the request's <span class="packt_screen">Header</span> tab.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Product listing</h1>
                </header>
            
            <article>
                
<p>Let's now design the jQuery code needed to consume this endpoint so that we can show these records on a web page and list our products available to buy. This should look as follows:</p>
<pre>function LoadProducts() <br/>{<br/>  // Load products' details.<br/>  $.ajax({<br/>    url: 'http://localhost:57571/api/Productsdetails',<br/>    type: "GET",<br/>    contentType: "application/json",<br/>    dataType: "json",<br/>    success: function (result) {<br/>      $.each(result, function (index, value) {<br/>        $('#tblProducts')<br/>        .append('&lt;tr&gt;&lt;td&gt;' +<br/>        '&lt;h3&gt;' + value.name + '&lt;/h3&gt;' +<br/>        '&lt;p&gt;' + value.description + '&lt;/p&gt;' +<br/>        '&lt;a target="_blank" href=' + value.url + '&gt;Amazon Link&lt;/a&gt;' +<br/>        '&lt;input type="button" style="float:right;" <br/>        class="btn btn-success" value="Add To Cart" /&gt;' +<br/>        '&lt;/td&gt;&lt;/tr&gt;');<br/>      });<br/>    }<br/>  });<br/>}</pre>
<div class="mce-root packt_tip">To get the code to call the API in different languages, you can click on the <em>code</em> link inside Postman and then select the desired language. We have already discussed this in previous chapters.</div>
<p>The preceding method makes a call to the endpoint <kbd>http://localhost:57571/api/Productsdetails</kbd> and loops through the records after receiving them with the <kbd>success</kbd> method. While looping, it builds an HTML table row that appends to a pre-existing table on the page.</p>
<p>The following screenshot is the reflection of the jQuery code which is showing the details of all products:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c88b2b8d-1a9f-4846-bfd2-367b627532fe.png" style="width:34.17em;height:24.83em;"/></div>
<p>Notice that we have one <span class="packt_screen">Search</span> box at the top, as well as <span class="packt_screen">Add To Cart</span> buttons for each product. We will take a look at these functionalities later on.</p>
<p>Did you notice that the product's main parameter, the price, is not displayed? This is because the price isn't present in the <kbd>Productdetail</kbd> table. So, let's now take a look at the <kbd>Product.cs</kbd> model class, as follows:</p>
<pre>public partial class Products<br/>{<br/>  public Products()<br/>  {<br/>    Cart = new HashSet&lt;Cart&gt;();<br/>    CartAttributes = new HashSet&lt;CartAttributes&gt;();<br/>    OrdersProducts = new HashSet&lt;OrdersProducts&gt;();<br/>    ProductsAttributes = new HashSet&lt;ProductsAttributes&gt;();<br/>    Productsdetail = new HashSet&lt;Productsdetail&gt;();<br/>    Reviews = new HashSet&lt;Reviews&gt;();<br/>  }<br/>  public Guid Id { get; set; }<br/>  public int Qty { get; set; }<br/>  public string Model { get; set; }<br/>  public string Image { get; set; }<br/>  public decimal Price { get; set; }<br/>  public DateTime Addedon { get; set; }<br/>  public DateTime Modifiedon { get; set; }<br/>  public decimal Weight { get; set; }<br/>  public byte Status { get; set; }<br/>  public Guid? ManufactureId { get; set; }<br/>  public Guid? Taxclassid { get; set; }<br/>  public ICollection&lt;Cart&gt; Cart { get; set; }<br/>  public ICollection&lt;CartAttributes&gt; CartAttributes { get; set; }<br/>  public ICollection&lt;OrdersProducts&gt; OrdersProducts { get; set; }<br/>  public ICollection&lt;ProductsAttributes&gt; ProductsAttributes <br/>  { get; set; }<br/>  public ICollection&lt;Productsdetail&gt; Productsdetail { get; set; }<br/>  public ICollection&lt;Reviews&gt; Reviews { get; set; }<br/>}</pre>
<p>Clearly, the <kbd>Product</kbd> class contains everything we need including <kbd>Name</kbd><span>,</span> <kbd>Description</kbd><span>,</span> <kbd>Url</kbd><span>,</span> <kbd>Views</kbd><span>, and so on,</span> with <kbd>Productdetail</kbd> as a reference point. We have already consumed the <kbd>GET</kbd> action of <kbd>ProductdetailsController</kbd> to display our products, so now it's time to read all of our products using <kbd>ProductsController</kbd>.</p>
<p>The <kbd>GET</kbd> action of <kbd>ProductsController</kbd> would return us all of the product records in <kbd>Productdetail</kbd>, as follows:</p>
<pre>// GET: api/Products<br/>[HttpGet]<br/>public IEnumerable&lt;Products&gt; GetProducts()<br/>{<br/>  return _context.Products<strong>.Include(x =&gt; x.Productsdetail)</strong>.ToList();<br/>}</pre>
<p>The snippet in bold in the preceding code is the <kbd>Include</kbd> clause, which is used to include results from the <kbd>Productdetail</kbd>. Now, instead of calling <kbd>/api/Productsdetails</kbd>, we will call <kbd>/api/Products</kbd>.</p>
<div class="packt_infobox">Calling this endpoint won't actually work, this is because of circular reference. If you observe both the <kbd>Products</kbd> and <kbd>Productdetail</kbd> models closely, you should see that both contain references to each other. This creates a problem when parsing to JSON. To avoid this, we need to write the following code inside <kbd>Startup</kbd>:<br/>
<kbd>services.AddMvc()</kbd><br/>
<kbd>.AddJsonOptions(options =&gt;</kbd><br/>
<kbd>{</kbd><br/>
<kbd>options.SerializerSettings.ReferenceLoopHandling =</kbd><br/>
<kbd>ReferenceLoopHandling.Ignore;</kbd><br/>
<kbd>});</kbd></div>
<p>Let's now have a look at the response we receive for one product when we call this endpoint, as shown in the following snippet. Note that you would get an array in reality, but we are only showing you one record for brevity:</p>
<pre>{<br/>  "id": "98a95bb6-c573-450d-a470-0a637e126dd7",<br/>  "qty": 30,<br/>  "model": "A",<br/>  "image": "NA",<br/>  "price": 49.99,<br/>  "addedon": "2018-05-13T12:09:39.873",<br/>  "modifiedon": "2018-05-13T12:09:39.873",<br/>  "weight": 0.9,<br/>  "status": 1,<br/>  "manufactureId": null,<br/>  "taxclassid": null,<br/>  "cart": [],<br/>  "cartAttributes": [],<br/>  "ordersProducts": [],<br/>  "productsAttributes": [],<br/>  "productsdetail": [<br/>  {<br/>    "id": "c96ac991-6581-4675-b00c-439df3961f03",<br/>    "productid": "98a95bb6-c573-450d-a470-0a637e126dd7",<br/>    "name": "Dependency Injection in .NET Core 2.0",<br/>    "description": "Make use of constructors, parameters, <br/>    setters, and interface injection to write reusable and <br/>    loosely-coupled code",<br/>    "url": "https://www.amazon.com/Dependency-Injection-NET-Core-<br/>    loosely-coupled/dp/1787121305/ref=tmm_pap_swatch_0? <br/>    _encoding=UTF8&amp;qid=1510939068&amp;sr=8-3",<br/>    "views": 5000<br/>  }],<br/>  "reviews": []<br/>}</pre>
<p>Now, we need to alter our client-side code to reflect the fact that <kbd>Productdetail</kbd> is now inside the <kbd>Product</kbd> object, as follows:</p>
<pre>function LoadProducts() <br/>{<br/>  // Load products' details.<br/>  $.ajax({<br/>    url: '<strong>http://localhost:57571/api/Products</strong>',<br/>    type: "GET",<br/>    contentType: "application/json",<br/>    dataType: "json",<br/>    success: function (result) {<br/>      console.log(result);<br/>      $.each(result, function (index, value) {<br/>        $('#tblProducts')<br/>        .append('&lt;tr&gt;&lt;td&gt;' +<br/>        '&lt;h3&gt;' + <strong>value.productsdetail[0].name</strong> + '&lt;/h3&gt;' +<br/>        '&lt;span class="spanPrice"&gt;Price: $' + <strong>value.price</strong> + <br/>        '&lt;/span&gt;' +<br/>        '&lt;p&gt;' + <strong>value.productsdetail[0].description</strong> + '&lt;/p&gt;' +<br/>        '&lt;a target="_blank" href=' + <strong>value.productsdetail[0].url</strong> +<br/>        '&gt;Amazon Link&lt;/a&gt;' +<br/>        '&lt;input type="button" style="float:right;" class="btn btn-<br/>        success" value="Add To Cart" /&gt;' +<br/>        '&lt;/td&gt;&lt;/tr&gt;');<br/>      });<br/>    }<br/>  });<br/>}</pre>
<p>That was easy to understand, wasn't it? Here, you should notice the changes we made to the URL and how we read the product details. <kbd>Productsdetail</kbd> is inside the <kbd>Product</kbd> object as an array, so it is written as <kbd>value.productsdetail[0]</kbd>, where <kbd>value</kbd> is the product object. We also introduced <kbd>value.price</kbd>.</p>
<p>You should now see the following screenshot, which has been updated:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1b9d9b63-0b41-4a06-8d3b-c2bb24178216.png" style="width:50.25em;height:38.58em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Product searching</h1>
                </header>
            
            <article>
                
<p>It's now time to implement the search feature, allowing customers to put any string inside the search box to look up a product. We need to add one search button to the UI, which when clicked will receive the entered string and fetch records accordingly.</p>
<p>Firstly<span>, the</span> <kbd>action</kbd> <span>method needs to accept the search text entered by a customer as a parameter; currently,</span> <kbd>GetProducts()</kbd> <span>does not accept any parameter.</span></p>
<p>The updated <kbd>GetProducts()</kbd> should look like the following snippet:</p>
<pre>// GET: api/Products<br/>[HttpGet]<br/>public IEnumerable&lt;Products&gt; GetProducts(<strong>string searchText</strong>)<br/>{<br/>  var products = _context.Products.Include(x =&gt; <br/>  x.Productsdetail).ToList();<br/>  if (!string.IsNullOrEmpty(searchText))<br/>  products = products.<strong>Where(p =&gt; p.Productsdetail</strong><br/><strong>  .Any(pd =&gt; pd.Name.ToLower().Contains(searchText.ToLower())))</strong><br/>  .ToList();<br/>  return products;<br/>}</pre>
<p>The <kbd>searchText</kbd> <span>parameter</span> <span>is taken into consideration and the results are filtered by the title of a book, which resides in the</span> <kbd>Name</kbd> <span>field of the</span> <kbd>Productsdetail</kbd> <span>collection inside the</span> <kbd>Product</kbd> <span>object. Thus,</span> <kbd>Any</kbd> <span>is used to check if the</span> <kbd>searchText</kbd> <span>is present in the</span> <kbd>Productsdetail</kbd> <span>object.</span></p>
<p>Now that the API is ready to search, let's update the client-side code to send the parameter as follows:</p>
<pre>function LoadProducts(<strong>searchText</strong>) <br/>{<br/>  if (!searchText)<br/>  searchText = "";<br/>  // Load products' details.<br/>  $.ajax({<br/>    url: <strong>'http://localhost:57571/api/Products?searchText=' + <br/>    searchText</strong>,<br/>    type: "GET",<br/>    // Other codes removed for brevity.</pre>
<p>As you can see in the preceding snippet, <kbd>LoadProducts</kbd> now accepts a <kbd>searchText</kbd> parameter that is passed to the API as a URL parameter. Now it is just a matter of sending the parameter value to this method while calling.</p>
<p>The following code illustrates the search function as it fetches text and executes <kbd>LoadProducts</kbd> with the entered value:</p>
<pre>$('#btnSearch').click(function () <br/>{<br/>  var searchText = $('#txtSearch').val().trim();<br/>  if (searchText) <br/>  {<br/>    $('#tblProducts').empty();<br/>    LoadProducts(searchText);<br/>  }<br/>});</pre>
<p>The following screenshot shows this function in action:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/92ffc624-a897-4b61-ba88-b4733c80a311.png" style="width:43.42em;height:21.92em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding to cart</h1>
                </header>
            
            <article>
                
<p>We're now ready for the next important topic: all about adding to cart! <span>Before implementing this function, however, there is something worth taking note of. In our application, we are not going to allow unknown users to add to cart, as we will be storing any information related to the cart in our database.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing security</h1>
                </header>
            
            <article>
                
<p>This is where security comes in, namely, authentication. As discussed in <a href="09fe6ad3-7061-4ae2-a2cb-c454ba802985.xhtml">Chapter 3</a>, <em>User Registration and Administration</em>, basic authentication can be applied with the help of handlers, or bearer authentication can be applied with the help of tokens.</p>
<p>First, let's generate <kbd>CartsController</kbd> using the same steps as previously. We now need to apply the <kbd>[Authorize]</kbd> attribute to the controller directly, so that all operations in the cart can be authenticated. Our app is already set up to handle bearer authentication.</p>
<p>The following is a code snapshot of <kbd>CartsController</kbd>:</p>
<pre>[Produces("application/json")]<br/>[Route("api/Carts")]<br/><strong>[Authorize]</strong><br/>public class CartsController : Controller</pre>
<p>Due to the <kbd>[Authorize]</kbd> attribute, this controller won't allow you to access the <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> action methods if you don't provide the access token.</p>
<p>Let's start designing some cart-related functions on the client side and try to call the action methods in this controller, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/43c4f6fe-749c-4aa6-9e7d-fa1b32a95f35.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-side AddToCart function</h1>
                </header>
            
            <article>
                
<p>When a customer hits <span class="packt_screen">Add To Cart</span>, information is added to another HTML table called <span class="packt_screen">My Cart</span>. If you hit <span class="packt_screen">Add To Cart</span> twice for one product, its quantity is updated to <span class="packt_screen">2</span> and the price is calculated accordingly. Each click assumes one unit of a particular product.</p>
<p>Let's now dive into the code. The following snippet shows us the <kbd>AddToCart</kbd> function for JavaScript:</p>
<pre>function AddToCart(productId, productName, qty, price) <br/>{<br/>  $('#tblCart tbody')<br/>  .append($('&lt;tr&gt;')<br/>    <strong>.attr('data-product-id', productId)</strong><br/>    .append($('&lt;td&gt;').html(productName))<br/>    .append($('&lt;td class="qty"&gt;').html(qty))<br/>    .append($('&lt;td class="price"&gt;').html('$' + qty * price))<br/>    .append($('&lt;td&gt;')<br/>      .append($('&lt;a&gt;')<br/>        .attr('href', '#')<br/>        .append($('&lt;span&gt;').addClass('glyphicon glyphicon-trash')) <br/><strong>        // For Delete Icon.</strong><br/>        .click(function () <br/>        {<br/>          // Delete Cart from Database.<br/>        })<br/>      )<br/>    )<br/>  );<br/>  // Add one Cart record in Database.<br/>}</pre>
<p>This function takes the parameters <kbd>productId</kbd>, <kbd>productName</kbd>, <kbd>qty</kbd>, and <kbd>price</kbd> as this information is shown in the cart HTML table.</p>
<p>Notice, in the preceding image, that there is a delete icon in each row. This is produced by adding a <kbd>glyphicon</kbd> inside a span that is wrapped with an anchor whose <kbd>click</kbd> event is also defined. We will take a look at the delete functionality later on in this chapter.</p>
<p>Also, note the <kbd>data-product-id</kbd> attribute that has been added to the row. This helps us identify a cart row uniquely, and you will see how that helps in a moment.</p>
<p>We are now all set to call <kbd>CartsController</kbd> to insert cart details into the database. However, we still need one more thing inside this method. After all, what happens if a product is added to the cart unexpectedly?</p>
<p>Here, we need the opportunity to update the cart, instead of just adding products to it, as shown in the following snippet:</p>
<pre>function AddToCart(productId, productName, qty, price) <br/>{<br/>  // Check if item already present. If yes, increase the qty <br/>  and calculate price.<br/>  var cartItem = $('#tblCart').find('tr[data-product-id=' + <br/>  productId + ']');<br/>  if (cartItem.length &gt; 0) <br/>  {<br/>    var qtyTd = cartItem.find('td.qty');<br/>    var newQty = parseInt(qtyTd.html()) + qty;<br/>    qtyTd.html(newQty);<br/>    cartItem.find('td.price').html('$' + (newQty * price).toFixed(2));<br/><strong>    // Update Cart in Database: PUT /api/Carts/{id}</strong><br/><strong>    </strong>return;<br/>  }<br/>  $('#tblCart tbody')<br/>  .append($('&lt;tr&gt;')<br/>    .attr('data-product-id', productId)<br/>    .append($('&lt;td&gt;').html(productName))<br/>    .append($('&lt;td class="qty"&gt;').html(qty))<br/>    .append($('&lt;td class="price"&gt;').html('$' + qty * price))<br/>    .append($('&lt;td&gt;')<br/>      .append($('&lt;a&gt;')<br/>        .attr('href', '#')<br/>        .append($('&lt;span&gt;').addClass('glyphicon glyphicon-trash'))<br/>        .click(function () {<br/>          <strong>// Delete Cart from Database: DELETE /api/Carts/{id}</strong><br/>        })<br/>      )<br/>    )<br/>  );<br/>  <strong>// Add one Cart record in Database: POST /api/Carts</strong><br/>}</pre>
<p>Simple, isn't it? First, the record is fetched from the cart table with the help of a product ID and then its quantity and price is updated accordingly. From that block, a <kbd>return</kbd> statement ensures that the record isn't added to the table anymore.</p>
<p>Now everything should work on the client side. We now just need to call our APIs to involve database operations so that any rows that have been inserted, updated, and deleted are also updated on the server side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API calls for AddToCart</h1>
                </header>
            
            <article>
                
<p>In this section, we will take a look at the actual API calls made by the client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">POST – api/Carts</h1>
                </header>
            
            <article>
                
<p>Inserting data into the cart table can be done by calling the <kbd>POST</kbd> action, which should look like the following code block in <kbd>CartsController</kbd>:</p>
<pre>// POST: api/Carts<br/>[HttpPost]<br/>public async Task&lt;IActionResult&gt; PostCart([FromBody] Cart cart)<br/>{<br/>  if (!ModelState.IsValid)<br/>  {<br/>    return BadRequest(ModelState);<br/>  }<br/>  _context.Cart.Add(cart);<br/>  try<br/>  {<br/>    await _context.SaveChangesAsync();<br/>  }<br/>  catch (DbUpdateException)<br/>  {<br/>    if (CartExists(cart.Id))<br/>    {<br/>      return new StatusCodeResult(StatusCodes.Status409Conflict);<br/>    }<br/>    else<br/>    {<br/>      throw;<br/>    }<br/>  }<br/>  return CreatedAtAction("GetCart", new { id = cart.Id }, cart);<br/>}</pre>
<p>The client-side function to call this action can be designed as follows:</p>
<pre>function PostCart(customerId, productId, qty, finalPrice) <br/>{<br/>  var cart = <br/>  {<br/>    Customerid: customerId,<br/>    Productid: productId,<br/>    Qty: qty,<br/>    Finalprice: finalPrice<br/>  };<br/>  $.ajax({<br/>    url: 'http://localhost:57571/api/Carts',<br/>    type: "POST",<br/>    contentType: "application/json",<br/>    dataType: "json",<br/>    <strong>data: JSON.stringify(cart),</strong><br/>    success: function (result) {<br/>      console.log(result);<br/>    },<br/>    error: function (message) {<br/>      console.log(message.statusText);<br/>    }<br/>  });<br/>}</pre>
<p>Straightforward, isn't it? Now we can build a cart object and send it a <kbd>POST</kbd> action. You can try this out by calling the following method inside our <kbd>AddToCart()</kbd> function:</p>
<pre><strong>// Add one Cart record in Database: POST /api/Carts</strong><br/>PostCart('910D4C2F-B394-4578-8D9C-7CA3FD3266E2',<br/>  productId,<br/>  cartItem.find('td.qty').html(),<br/>  cartItem.find('td.price').html().replace('$', ''))</pre>
<p>Here, the first parameter is <kbd>Customerid</kbd>, which we have hard-coded. <kbd>Customerid</kbd> can be held in session storage for any requests—although this is considered a risky practice.</p>
<div class="packt_infobox">Instead of sending the <kbd>Customerid</kbd>, you can send the email id to the POST action. Then using email id, you can get the <kbd>Customerid</kbd>, which can be used to insert a Cart record.</div>
<p>Let's now run our app and click on <span class="packt_screen">Add To Cart</span> for a particular product. Oops! The following error has appeared in the developer tool:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/240e3e1e-4746-4876-b4bc-8e23d8b1b07b.png" style="width:32.83em;height:24.25em;"/></div>
<p><em>Why has this happened?</em></p>
<p>The reason for this error is actually pretty obvious. As an <kbd>[Authorize]</kbd> attribute has been applied to the controller, every call to <kbd>CartsController</kbd> now expects a token generated by a request to the OAuth2.0 Authorize server with <kbd>Email Id</kbd> and <kbd>Password</kbd>.</p>
<div class="packt_infobox">We already explored <em>OAuth2.0 Authentication</em> in detail.</div>
<p>To move on with our implementation, we will call the token server from Postman and use that inside our app. Ideally, when you receive an <span class="packt_screen">Unauthorized</span> error, you should open the login screen so that the user can log in. If <kbd>Email Id</kbd> and <kbd>Password</kbd> are validated, a token would be returned. This token can be used for further requests, such as <span class="packt_screen">Add To Cart</span>.</p>
<p>To save time and space, we will generate a token using Postman directly by using <kbd>taditdash@gmail.com</kbd> as our email ID and <kbd>12345</kbd> as our password<em>.</em> The subsequent Ajax call with the token should look like the following:</p>
<pre>$.ajax({<br/>  url: 'http://localhost:57571/api/Carts',<br/>  type: "POST",<br/>  contentType: "application/json",<br/>  dataType: "json",<br/>  data: JSON.stringify(cart),<br/>  headers: { <strong>"Authorization": "Bearer eyJhbGciOiJSUzI1NiIs...<br/>  [Long String Removed]" </strong>},<br/>  success: function (result) <br/>  {<br/>    var cartItem = $('#tblCart').find('tr[data-product-id=' + <br/>    productId + ']');<br/>    cartItem.attr('data-cart-id', result.id);<br/>  },<br/>});</pre>
<p>Note that we have removed the token string in the preceding snippet for brevity. With the previous code, one cart record will be created and data returned from the API will give us all the detail about that record. You can store the cart's <kbd>Id</kbd> on the HTML row (as shown inside the preceding code block) for further processing while updating or deleting the cart record.</p>
<p>The following screenshot of the <span class="packt_screen">Elements</span> tab in the Chrome Developer Tool illustrates the cart record's ID stored as a <kbd>data-cart-id</kbd> attribute:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0855f623-f91a-4c67-bd89-27533f9274e6.png" style="width:41.25em;height:14.92em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PUT – api/Carts/{id}</h1>
                </header>
            
            <article>
                
<p>Now that we have added one cart record, let's move to update that record whenever a customer repeatedly hits the <span class="packt_screen">Add To Cart</span> button. We already have the code that updates the quantity and price on the client-side table, so we just need to write the code to call the <kbd>PUT</kbd> endpoint to update the record, as follows:</p>
<pre>function PutCart(cartItem) <br/>{<br/>  var cart = <br/>  {<br/>    Id: cartItem.attr('data-cart-id'),<br/>    Customerid: '910D4C2F-B394-4578-8D9C-7CA3FD3266E2',<br/>    Productid: cartItem.attr('data-product-id'),<br/>    Qty: cartItem.find('td.qty').html(),<br/>    Finalprice: cartItem.find('td.price').html().replace('$', '')<br/>  };<br/>  $.ajax({<br/>    <strong>url: 'http://localhost:57571/api/Carts/' + cart.Id,</strong><br/>    type: "PUT",<br/>    contentType: "application/json",<br/>    dataType: "json",<br/>    <strong>data: JSON.stringify(cart),</strong><br/>    headers: { "Authorization": "Bearer eyJhbGciOiJSUzI1NiIs..." }<br/>  });<br/>}</pre>
<p>The important part of the preceding code is the URL, which also contains the cart <kbd>Id</kbd> because the route is actually <kbd>api/Carts/{id}</kbd>. The data goes inside the body.</p>
<p class="mce-root">The parameter <kbd>cartItem</kbd> is the row which can be passed from the <kbd>AddToCart</kbd> function as follows:</p>
<pre><strong>// Update Cart in Database: PUT /api/Carts/{id}</strong><br/>PutCart($('#tblCart').find('tr[data-product-id=' + productId + ']'));</pre>
<p>The API action should look as follows:</p>
<pre>// PUT: api/Carts/5<br/>[HttpPut("{id}")]<br/>public async Task&lt;IActionResult&gt; PutCart([FromRoute] Guid id, [FromBody] Cart cart)<br/>{<br/>  if (!ModelState.IsValid)<br/>  {<br/>    return BadRequest(ModelState);<br/>  }<br/>  if (id != cart.Id)<br/>  {<br/>    return BadRequest();<br/>  }<br/>  _context.Entry(cart).State = EntityState.Modified;<br/>  try<br/>  {<br/>    await _context.SaveChangesAsync();<br/>  }<br/>  catch (DbUpdateConcurrencyException)<br/>  {<br/>    if (!CartExists(id))<br/>    {<br/>      return NotFound();<br/>    }<br/>    else<br/>    {<br/>      throw;<br/>    }<br/>  }<br/>  return NoContent();<br/>}</pre>
<p><span>Notice that <kbd>id</kbd> is read from the route, as it is marked with the attribute <kbd>[FromRoute]</kbd>, and the cart object is read from the body of the request, as it is marked <kbd>[FromBody]</kbd>. If an ID is not sent with a route, the client would receive a <span class="packt_screen">400 BadRequest</span> error.</span></p>
<p>The API action has now updated the record with the necessary details, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3fdcedea-ae97-4a06-8a44-167ae0bf3b07.png"/></div>
<p>As you can see, we have clicked <span class="packt_screen">Add To Cart</span> four times. The <kbd>finalPrice</kbd> is calculated accordingly as <kbd>49.99 * 4</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DELETE – api/Carts/{id}</h1>
                </header>
            
            <article>
                
<p>Route <kbd>/api/Carts/{id}</kbd> tells us that we just need to send the cart <kbd>Id</kbd> to the API; everything else will be handled by the API so as to delete the record from the database.</p>
<p>The action method for deleting a record is as follows:</p>
<pre>// DELETE: api/Carts/5<br/>[HttpDelete("{id}")]<br/>public async Task&lt;IActionResult&gt; DeleteCart([FromRoute] Guid id)<br/>{<br/>  if (!ModelState.IsValid)<br/>  {<br/>    return BadRequest(ModelState);<br/>  }<br/>  var cart = await _context.Cart.SingleOrDefaultAsync(m =&gt; m.Id == id);<br/>  if (cart == null)<br/>  {<br/>    return NotFound();<br/>  }<br/>  _context.Cart.Remove(cart);<br/>  await _context.SaveChangesAsync();<br/>  return Ok(cart);<br/>}</pre>
<p>The client-side application has to be updated to allow this feature. As the delete icon is already shown on every cart row on the HTML table, we just need to send the cart's ID to the API when clicked by the user.</p>
<p>The following JavaScript function can be used to delete a cart record:</p>
<pre>function DeleteCart(cartId) <br/>{<br/>  $.ajax({<br/>    <strong>url: 'http://localhost:57571/api/Carts/' + cartId,</strong><br/>    <strong>type: "DELETE",</strong><br/>    contentType: "application/json",<br/>    headers: { "Authorization": "Bearer " + accessToken },<br/>    success: function (result) {<br/>      if (result.id) {<br/><strong>        // Deleting the row from the html table.</strong><br/>        var cartItem = $('#tblCart').find('tr[data-cart-id=' + <br/>        cartId + ']');<br/>        cartItem.remove();<br/>      }<br/>    }<br/>  });<br/>}</pre>
<p>As you can see, the <kbd>DeleteCart</kbd> function expects one parameter, <kbd>cartId</kbd>, which will be provided when the delete icon is clicked. This function calls the API with the type <kbd>DELETE</kbd>, as well as the <kbd>Id</kbd> and URL. On successful deletion, the cart row is removed from the HTML table.</p>
<p>The code block where <kbd>DeleteCart</kbd> is called is inside <kbd>AddToCart</kbd>, as shown in the following code snippet:</p>
<pre>cartItem = $('#tblCart tbody')<br/>.append($('&lt;tr&gt;')<br/>  .attr('data-product-id', productId)<br/>  .append($('&lt;td&gt;').html(productName))<br/>  .append($('&lt;td class="qty"&gt;').html(qty))<br/>  .append($('&lt;td class="price"&gt;').html('$' + qty * price))<br/>  .append($('&lt;td&gt;')<br/>    .append($('&lt;a&gt;')<br/>      .attr('href', '#')<br/>      .append($('&lt;span&gt;').addClass('glyphicon glyphicon-trash'))<br/>      .click(function () {<br/>        <strong>// Delete Cart from Database: DELETE /api/Carts/{id}</strong><br/>        DeleteCart($(this).parents('tr').attr('data-cart-id'));<br/>      })<br/>    )<br/>  )<br/>);</pre>
<p><kbd>DeleteCart</kbd> is called inside the click event of the anchor where the delete icon is shown. Inside the event, we get the cart <kbd>Id</kbd> from the row itself by extracting the value of the <kbd>data-cart-id</kbd> attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Placing orders</h1>
                </header>
            
            <article>
                
<p>Our cart is now full with the correct number of the desired products, so it's now time to place our order. For that, we need to call another controller—<kbd>OrdersController</kbd>.</p>
<p>The following two tables are responsible for the ordering process:</p>
<ul>
<li><strong>Orders</strong>: This stores the shipping address details, customer details, order status, and so on</li>
<li><strong>OrdersProducts</strong>: This stores the products added to the cart, their price, and their quantity</li>
</ul>
<p>The <kbd>Orders</kbd> class is generated by the scaffolding we did initially, which contains all the necessary information. Let's generate the controller with this class. Follow the same process to generate the controller as we did for <kbd>ProductsController</kbd>, <kbd>ProductsdetailsController</kbd>, and <kbd>CartsController</kbd>.</p>
<div class="packt_infobox">The model and controller class can be found in the GitHub repository.</div>
<p>Now it's time to call the <kbd>POST</kbd> action of <kbd>OrdersController</kbd> to save the order on the client-side. The following code is the skeleton of the function that does that:</p>
<pre>function PostOrders()<br/>{<br/>  // 1. Build order object to match the model class Orders.cs.<br/>  // 2. Push cart items into order object as an array.<br/>  // 3. Call POST /api/Orders.<br/>}</pre>
<p>Let's now explain this step-by-step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UI design for placing an order</h1>
                </header>
            
            <article>
                
<p>Before we move on any further, we need to show a modal to the user where they can enter their shipping address. The modal will be opened once the <span class="packt_screen">Place Order</span> button is clicked, as shown in the following screenshot.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/be1c0d95-e89f-4215-bdb1-17aeb01e44e2.png" style="border: 1em solid black;text-align: center;width:24.75em;height:19.25em;"/></div>
<p>The following code snippet illustrates the click event for <span class="packt_screen">Place Order</span> (the modal is opened if cart items are present):</p>
<pre>$('#btnPlaceOrder').click(function () <br/>{<br/>  var cartItems = $('#tblCart tbody tr');<br/>  // If Cart items present, then show modal to enter Shipping Address.<br/>  if (cartItems.length &gt; 0) {<br/>    <strong>$('#Order').modal('show');</strong><br/>    return;<br/>  }<br/>  alert("Please add items into the cart.");<br/>});</pre>
<p>An Ajax call inserts an order's record in the database by clicking <span class="packt_screen">Submit</span> using <kbd>POST</kbd>. The following code snippet is the click event of <span class="packt_screen">Submit</span>:</p>
<pre>$('#btnConfirmOrder').click(function () {<br/>  PostOrders();<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The client-side PostOrder function</h1>
                </header>
            
            <article>
                
<p>Let's now move on to the steps required for <kbd>PostOrders</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building order objects to match the model class Orders.cs</h1>
                </header>
            
            <article>
                
<p>Here, we have to read the values from the text boxes related to shipping information and match them with the fields of <kbd>Orders.cs</kbd> to build an object. <kbd>OrdersProducts</kbd> is an array representing the model class, <kbd>OrdersProducts.cs</kbd>. Every order can have multiple products associated with it.</p>
<p>The following code implements order objects:</p>
<pre>// 1. Build order object to match the model class Orders.cs.<br/>var order = {<br/>  Customerid: customerId,<br/>  CustomerStreetaddress: $('#txtStreetAdd').val(),<br/>  Customercity: $('#txtCity').val(),<br/>  Customerstate: $('#txtState').val(),<br/>  Customerpostalcode: $('#txtPostalCode').val(),<br/>  Customercountry: $('#txtCountry').val(),<br/>  OrdersProducts: new Array()<br/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pushing cart items into an order object as an array</h1>
                </header>
            
            <article>
                
<p>Populating the <kbd>OrdersProducts</kbd> array is the next step, and this can be done by looping through the cart table's rows and pushing each cart row's details to the array. Inside the loop, read all the necessary values from the row, either from its attribute or <kbd>td</kbd>. Remember to form an object and assign the values to field names that match the model class, as follows:</p>
<pre>// 2. Push cart items into order object as an array.<br/>$('#tblCart tbody tr').each(function () <br/>{<br/>  order.OrdersProducts.push(<br/>  {<br/>    Productid: $(this).attr('data-product-id'),<br/>    Productname: $(this).find('td.name').html(),<br/>    Productprice: $(this).attr('data-price'),<br/>    Finalprice: $(this).find('td.price').html().replace('$', ''),<br/>    Productqty: $(this).find('td.qty').html()<br/>  });<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calling POST /api/Orders</h1>
                </header>
            
            <article>
                
<p>Great, now we have our object! It's now time to call the API <kbd>/api/Orders</kbd> with a <kbd>POST</kbd> request so that our order goes into the database, as follows:</p>
<pre>// 3. Call POST /api/Orders.<br/>$.ajax({<br/>  url: 'http://localhost:57571/api/Orders',<br/>  type: "POST",<br/>  contentType: "application/json",<br/>  dataType: "json",<br/>  data: JSON.stringify(order),<br/>  headers: { "Authorization": "Bearer " + accessToken },<br/>  success: function (result) {<br/>    alert("Order Placed Successfully.")<br/>  }<br/>});</pre>
<p>If everything works correctly, you should see something like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/73a57966-56ba-42d0-89d3-7692b980e20b.png" style="width:32.83em;height:10.17em;"/></div>
<p>But we are forgetting something here; although our order has been placed successfully, we need to empty the cart. This can be done by calling <kbd>DELETE /api/Carts</kbd> for each cart item inside the <kbd>success</kbd> function of <kbd>PostOrders</kbd>, shown as follows:</p>
<pre>success: function (result) <br/>{<br/>  <strong>// Empty Cart.</strong><br/><strong>  $('#tblCart tbody tr').each(function () {</strong><br/><strong>    DeleteCart($(this).attr('data-cart-id'));</strong><br/><strong>  });</strong><br/>  alert("Order Placed Successfully.");<br/>},</pre>
<p>We've explored everything from the client side, so now it's time to check the API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PostOrders API POST method</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">Orders</span> table looks a little different to what we sent to the client. In the following screenshot, note the fields marked in boxes. These are the fields we are not sending and will instead manipulate inside the action method:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c498012d-ce9e-4bfd-9946-601fd6c4d6a8.png" style="width:20.50em;height:32.17em;"/></div>
<p>Fields such as name, email, and telephone number can be fetched from the <span class="packt_screen">Customers</span> table. <kbd>Customerid</kbd> is sent from the client, using which we will fetch these details, as follows:</p>
<pre>// POST: api/Orders<br/>[HttpPost]<br/>public async Task&lt;IActionResult&gt; PostOrders([FromBody] Orders orders)<br/>{<br/>  if (!ModelState.IsValid)<br/>  {<br/>    return BadRequest(ModelState);<br/>  }<br/>  // Retrieve customer details and add to order.<br/>  if (orders.Customerid != null)<br/>  {<br/>    var customer = _context.Customers.SingleOrDefault<br/>    (x =&gt; x.Id == orders.Customerid);<br/>    if (customer != null)<br/>    {<br/>      <strong>orders.Deliveryname = orders.Customername = customer.Firstname;</strong><br/><strong>      orders.Customeremail = customer.Email;</strong><br/><strong>      orders.Customertelephone = customer.Telephone;</strong><br/>    }<br/>  }<br/>  ...</pre>
<p>The following code snippet illustrates how a user can copy their billing address so that it is also their delivery address:</p>
<pre>// Copy customer address to delivery address.<br/>orders.Deliverycity = orders.Customercity;<br/>orders.Deliverycountry = orders.Customercountry;<br/>orders.Deliverystreetaddress = orders.CustomerStreetaddress;<br/>orders.Deliverypostalcode = orders.Customerpostalcode;<br/>orders.Deliverystate = orders.Customerstate;</pre>
<p>Additional fields, including <kbd>datapurchased</kbd>, <kbd>lastmodified</kbd>, and <kbd>orderdatefinished</kbd>, will be set as <kbd>DateTime.Now</kbd>. Details such as <kbd>currency</kbd> and <kbd>currency_value</kbd> will be set as dollars ($) and zero (0). We will also set <kbd>Guid.NewGuid</kbd> as <kbd>shipingmethodid</kbd> and <kbd>paymentmethodid</kbd>.</p>
<p>These can be made inside the Orders constructor as follows:</p>
<pre>public Orders()<br/>{<br/>  Id = Guid.NewGuid();<br/>  OrderProductAttributes = new HashSet&lt;OrderProductAttributes&gt;();<br/>  OrdersProducts = new HashSet&lt;OrdersProducts&gt;();<br/>  Datepurchased = DateTime.Now;<br/>  Lastmodified = DateTime.Now;<br/>  Shipingmethodid = Guid.NewGuid();<br/>  Paymentmethodid = Guid.NewGuid();<br/>  Shippingcost = 0;<br/>  Orderdatefinished = DateTime.Now;<br/>  Currency = "$";<br/>  CurrencyValue = 0;<br/>  Orderstatus = "Placed";<br/>}</pre>
<p>Notice that the <kbd>Orderstatus</kbd> is <span class="packt_screen">Placed</span>. This is something that can be updated by the site when an order is ready for shipping. Subsequent statuses might include <span class="packt_screen">Approved</span>, <span class="packt_screen">Ready</span>, <span class="packt_screen">Shipped</span>, <span class="packt_screen">Delivered</span>, and so on. If you design the admin screen, make sure you handle this field update along with <kbd>latsmodified</kbd> and <kbd>orderdatefinished</kbd>.</p>
<div class="packt_infobox">The application demonstrated in this book is not production-ready. Generally, there should be a login page that works with <em>OAuth2.0 Authentication</em>. Basic validations on the API side, as well as the client side, also need to be handled. In this book, our application is built to showcase the concepts we are exploring, but you can definitely optimize our example and even build on top of it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exposing shipping details</h1>
                </header>
            
            <article>
                
<p><kbd>GET</kbd> requests can be used on <kbd>OrdersController</kbd> with an order ID so that order details can be consumed by third party sites for display. For example, many courier companies expose their APIs, which is used by other sites to display order, shipment, and tracking information.</p>
<p>As an example, let's check out our <kbd>GET</kbd> method <span><kbd><span>OrdersController</span></kbd>, which takes the ID as a parameter:</span></p>
<pre>// GET: api/Orders/5<br/>[HttpGet("{id}")]<br/>public async Task&lt;IActionResult&gt; GetOrders([FromRoute] Guid id)<br/>{<br/>  if (!ModelState.IsValid)<br/>  {<br/>    return BadRequest(ModelState);<br/>  }<br/>  var orders = await _context.Orders.<strong>Include<br/>  (o =&gt; o.OrdersProducts)</strong>.SingleOrDefaultAsync(m =&gt; m.Id == id);<br/>  if (orders == null)<br/>  {<br/>    return NotFound();<br/>  }<br/>  return Ok(orders);<br/>}</pre>
<p>Notice that the <kbd>Include</kbd> clause is used to include results from the <kbd>OrdersProducts</kbd> table. Let's now perform a quick Postman call to this endpoint to see the result of our earlier order, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/538eb690-57ed-4097-9e78-4856fce019ef.png" style="width:37.17em;height:38.17em;"/></div>
<p>Here, you can see every detail relating to the order, along with its products, are returned from the API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>If you've reached this point of the book, you will have designed some cool things using APIs. Well done!</p>
<p>In this chapter, we moved towards consuming <kbd>ProductsController</kbd> to display the product list on our client-side app. Product attributes along with their pricing details were shown with a simple UI that was designed using Bootstrap, jQuery, and HTML.</p>
<p>Slightly modified <kbd>GET</kbd> requests inside <kbd>ProductsController</kbd> with a <kbd>searchString</kbd> parameter helped us to retrieve search results from the API. Clients could easily implement the search function by consuming the endpoint with text.</p>
<p>We then looked at our shopping cart. We explored how <kbd>CartsController</kbd> actions can be consumed to add, update, and delete cart items while updating the UI. In the process, we implemented security for the controller using authentication.</p>
<p>Finally, we converted the items in our cart into a visualized order. This was done using <kbd>OrdersController</kbd>, which can also be used to provide shipping and tracking information to clients.</p>
<p>In the next chapter, we're going to take a look at different techniques for testing the RESTful Web API designed in .NET Core.</p>


            </article>

            
        </section>
    </body></html>