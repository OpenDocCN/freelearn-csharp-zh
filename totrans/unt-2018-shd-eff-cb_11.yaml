- en: Advanced Shading Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Using Unity's built-in CgInclude files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your shader world modular with CgInclude
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Fur Shader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Heatmaps with arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers some advanced shader techniques that you can use for your
    game. You should remember that many of the most eye-catching effects you see in
    games are made by testing the limits of what shaders can do. This book provides
    you with the technical foundations to modify and create shaders, but you are strongly
    encouraged to play and experiment with them as much as you can. Making a good
    game is not a quest for photorealism; you should not approach shaders with the
    intention of replicating reality because this is unlikely to happen. Instead,
    you should try to use shaders as a tool to make your game truly unique. With the
    knowledge of this chapter, you will be able to create the materials that you want.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Using Unity's built-in CgInclude files
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first step in writing our own `CgInclude` files is to understand what Unity
    is already providing with us for shaders. When writing Surface Shaders, there
    is a lot happening under the hood, which makes the process of writing Surface
    Shaders so efficient. We can see this code in the included `CgInclude` files found
    in the directory that you installed Unity in at `Editor `| `Data `| `CGIncludes`.
    All the files contained within this folder do their part to render our objects
    with our shaders on the screen. Some of these files take care of shadows and lighting,
    some take care of helper functions, and some manage platform dependencies. Without
    them, our shader-writing experience would be much more laborious.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of the information that Unity has provided us with at the
    following link:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Documentation/Components/SL-BuiltinIncludes.html](http://docs.unity3d.com/Documentation/Components/SL-BuiltinIncludes.html).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin the process of understanding these built-in `CgInclude` files,
    using some of the built-in helper functions from the `UnityCG.cginc` file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00216.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start diving into the meat of writing the shader, we need to get
    a few items set up in our scene. Let''s do the following and then open the shader
    in your IDE of choice:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and fill it with a simple sphere model.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new shader (`Desaturate`) and material (`DesaturateMat`).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the new shader to the new material and assign the material to the sphere.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directional light and position it above your sphere.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, open the `UnityCG.cginc` file from Unity's `CgInclude` folder located
    in Unity's install directory. This will let us analyze some of the helper functions'
    code so that we can understand what is happening when we use them.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now have a simple scene set up to work on the shader. Refer to the
    following screenshot, which is an example:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00217.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the scene prepared, we can now begin the process of experimenting with
    some of the built-in helper functions included with the `UnityCG.cginc` file.
    Double-click on the shader that was created for this scene in order to open it
    in your IDE of choice and insert the code given in the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 场景准备就绪后，我们现在可以开始尝试使用 `UnityCG.cginc` 文件中包含的一些内置辅助函数了。双击为这个场景创建的着色器，以便在您选择的 IDE
    中打开它，并按照以下步骤插入代码：
- en: 'Add the following code to the `Properties` block of the new shader file. We
    will need a single texture and slide for our example shader:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到新着色器文件的 `Properties` 块中。我们的示例着色器需要一个纹理和一个滑动条：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We then need to make sure that we create the data connection between our `Properties`
    and `CGPROGRAM` blocks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要确保在 `Properties` 和 `CGPROGRAM` 块之间创建数据连接。
- en: 'Use the following code, placed after the `CGPROGRAM` declaration and `#pragma`
    directives, removing the other default properties:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CGPROGRAM` 声明和 `#pragma` 指令之后放置以下代码，移除其他默认属性：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we just have to update our `surf()` function to include the following
    code. We introduce a new function that we haven''t seen yet, which is built into
    Unity''s `UnityCG.cginc` file:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需更新我们的 `surf()` 函数，以包含以下代码。我们引入了一个我们还没有见过的函数，它是 Unity 的 `UnityCG.cginc`
    文件内置的：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save your script and return to the Unity editor. From there, you should be
    able to assign a material to the `DesaturateMat` (I used the `TerrainBlend` texture
    from the `Chapter 3 `| `Textures` folder):'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的脚本并返回到 Unity 编辑器。从那里，您应该能够将材质分配给 `DesaturateMat`（我使用了来自 `第 3 章 `| `纹理` 文件夹的
    `TerrainBlend` 纹理）：
- en: '![](img/00218.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00218.jpeg)'
- en: 'With the shader code modified, you should see something similar to the preceding
    screenshot. We have simply used a helper function, built into Unity''s `CgInclude`
    file, to give us an effect of desaturating the main texture of our shader. Notice
    that if we change the value to `1`, all of the color leaves, giving us a grayscale
    effect:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改着色器代码后，您应该会看到类似于前面的截图。我们只是使用了一个内置的辅助函数，这个函数是 Unity 的 `CgInclude` 文件的一部分，以给我们一个去饱和化主纹理的效果。注意，如果我们把值改为
    `1`，所有的颜色都会消失，给我们一个灰度效果：
- en: '![](img/00219.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00219.jpeg)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the built-in helper function named `Luminance()`, we are able to quickly
    get a desaturation or grayscale effect on our shaders. This is all possible because
    of the `UnityCG.cginc` file is brought automatically to our shader as we are using
    a Surface Shader.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 `Luminance()` 的内置辅助函数，我们能够快速在我们的着色器上获得去饱和化或灰度效果。这一切都是因为当我们使用 Surface Shader
    时，`UnityCG.cginc` 文件会自动带到我们的着色器中。
- en: 'If you search through the `UnityCG.cginc` file when opened in a script editor,
    you will find the implementation of this function at line *473*. The following
    snippet is taken from the file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在脚本编辑器中搜索 `UnityCG.cginc` 文件，您将在第 *473* 行找到这个函数的实现。以下代码片段来自该文件：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As this function is included in the file and Unity automatically compiles with
    this file, we can use the function in our code as well, thereby reducing the amount
    of code that we have to write over and over again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个函数包含在文件中，并且 Unity 会自动与这个文件一起编译，因此我们也可以在我们的代码中使用这个函数，从而减少我们需要反复编写的代码量。
- en: Notice there is also a `Lighting.cginc` file, which Unity comes with. This file
    houses all the lighting models that we use when we declare something like `#pragma
    Surface surf Lambert`. Sifting through this file reveals that all the built-in
    lighting models are defined here for reuse and modularity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个名为 `Lighting.cginc` 的文件，这是 Unity 自带的。这个文件包含了我们在声明类似 `#pragma Surface
    surf Lambert` 这样的内容时使用的所有光照模型。浏览这个文件可以发现，所有内置的光照模型都定义在这里，以便重用和模块化。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You''ll notice that the `Luminance` function we are using will return the dot
    product between the color passed in and a property called `unity_ColorSpaceLuminance`.
    To see what that is, you can use Find menu in your text editor (*Ctrl *+ *F*)
    and type it in. After searching for it, you should be able to see the following
    on line *28*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们使用的 `Luminance` 函数将返回传入的颜色和名为 `unity_ColorSpaceLuminance` 的属性之间的点积。要查看这是什么，您可以使用文本编辑器的
    `查找` 菜单 (*Ctrl *+ *F*) 并输入它。搜索后，您应该能够在第 *28* 行看到以下内容：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that, depending on the color space being used, the values given will
    change. By default, Unity uses a Gamma color space as only certain platforms support
    linear. To check what color space you are using in your project, you can go to Edit
    | Project Settings| Player | Other Settings and look at the Color Space property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，根据所使用的色彩空间，给定的值将发生变化。默认情况下，Unity 使用伽玛色彩空间，因为只有某些平台支持线性。要检查你的项目中使用的是哪种色彩空间，你可以转到
    Edit | Project Settings | Player | Other Settings，并查看色彩空间属性。
- en: For more information on color spaces check out: [http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ](http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于色彩空间的信息，请查看：[http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ](http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ)。
- en: Making your shader world in a modular way with CgInclude
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CgInclude 以模块化方式构建你的着色器世界
- en: Knowing about the built-in `CgInclude` files is great, but what if we want to
    build our own `CgInclude` files to store our own lighting models and helper functions?
    We can, in fact, create our own `CgInclude` files, but we need to learn a little
    more code syntax before we can start using them efficiently in our shader-writing
    pipelines. Let's take a look at the process of creating a new `CgInclude` file
    from scratch.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 了解内置的 `CgInclude` 文件很好，但如果我们想构建自己的 `CgInclude` 文件来存储我们自己的光照模型和辅助函数呢？实际上，我们可以创建自己的
    `CgInclude` 文件，但在我们能够高效地在着色器编写管道中使用它们之前，我们需要学习一些更多的代码语法。让我们看看从头开始创建一个新的 `CgInclude`
    文件的过程。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s walk through the process of generating a new item for this recipe:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个过程来生成这个食谱的新条目：
- en: 'From the Project tab, right-click on the `Assets` folder and select Show in
    Explorer. You should see your project folder. Then create a text file by right-clicking
    and selecting New | Text Document:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目标签页中，右键单击 `Assets` 文件夹，并选择 Show in Explorer。你应该能看到你的项目文件夹。然后通过右键单击并选择 New
    | Text Document 来创建一个文本文件：
- en: '![](img/00220.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00220.jpeg)'
- en: 'Rename the file to `MyCGInclude` and replace the `.txt` file extension with
    `.cginc`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件重命名为 `MyCGInclude`，并将 `.txt` 文件扩展名替换为 `.cginc`：
- en: '![](img/00221.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00221.jpeg)'
- en: Windows will give you a warning message saying that the File may become unusable,
    but it will still work.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows 将会给出一个警告消息，说文件可能会变得不可用，但它仍然可以工作。
- en: Import this new `.cginc` file into your Unity project and let it compile. If
    all goes well, you will see that Unity knew to compile it into a `CgInclude` file.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的 `.cginc` 文件导入到你的 Unity 项目中，并让它编译。如果一切顺利，你将看到 Unity 已经知道将其编译成 `CgInclude`
    文件。
- en: We are now ready to begin creating our own custom `CgInclude` code. Simply double-click
    on the `CgInclude` file that you created in order to open it in your IDE of choice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始创建我们自己的自定义 `CgInclude` 代码。只需双击你创建的 `CgInclude` 文件，以便在你的首选 IDE 中打开它。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'With our `CgInclude` file open, we can begin to enter the code that will get
    it working with our Surface Shaders. The following steps will get our `CgInclude`
    file ready for use within our Surface Shaders and allow us to continually add
    more code to it as we develop more shaders:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `CgInclude` 文件打开时，我们可以开始输入将使其与我们的表面着色器一起工作的代码。以下步骤将使我们的 `CgInclude` 文件准备好在表面着色器中使用，并允许我们在开发更多着色器时不断向其中添加更多代码：
- en: 'We begin our `CgInclude` file with what is called a preprocessor directive.
    These are statements such as `#pragma` and `#include`. In this case, we want to
    define a new set of code that will be executed if our shader includes this file
    in its compiler directives. Enter the following code at the top of your `CgInclude`
    file:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从所谓的预处理器指令开始我们的 `CgInclude` 文件。这些指令包括 `#pragma` 和 `#include` 等语句。在这种情况下，我们想要定义一组新的代码，如果我们的着色器在编译指令中包含此文件，则将执行这些代码。在你的
    `CgInclude` 文件顶部输入以下代码：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We always need to make sure that we close `#ifndef` or `#ifdef` with `#endif`
    to close the definition check, just like an `if` statement needs to be closed
    with two brackets in C#. Enter the following code just after the `#define` directive:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们始终需要确保使用 `#endif` 来关闭 `#ifndef` 或 `#ifdef` 的定义检查，就像在 C# 中，一个 `if` 语句需要用两个括号来关闭一样。在
    `#define` 指令之后立即输入以下代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, we just need to implement the contents of the `CgInclude` file.
    So, we finish off our `CgInclude` file by entering the following code after the
    `#define` and before the `#endif`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们只需要实现 `CgInclude` 文件的内容。因此，我们在 `#define` 之后和 `#endif` 之前输入以下代码来完成我们的
    `CgInclude` 文件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this completed, you now have your very first `CgInclude` file. With just
    this little bit of code, we can greatly reduce the amount of code that we have
    to rewrite, and we can begin to store the lighting models that we use all the
    time here so that we never lose them. Your `CgInclude` file should look similar
    to the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，你现在就有了你的第一个`CgInclude`文件。仅用这么一点代码，我们就可以大大减少需要重写的代码量，并且我们可以开始在这里存储我们经常使用的光照模型，这样我们就永远不会丢失它们。你的`CgInclude`文件应该看起来类似于以下代码：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are a couple more steps that we need to complete before we can fully
    utilize this `CgInclude` file. We simply need to tell the current shader that
    we are working with to use this file and its code. To complete the process of
    creating and using `CgInclude` files, let''s complete the next set of steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以完全利用这个`CgInclude`文件之前，我们还需要完成几个步骤。我们只需要告诉当前我们正在处理的着色器使用这个文件及其代码。为了完成创建和使用`CgInclude`文件的过程，让我们完成以下步骤：
- en: We have to have our `CgInclude` file in the same directory as our shader, so
    drag and drop it into the `Chapter 11 `| `Shaders` folder from the Project tab.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将我们的`CgInclude`文件放在与我们的着色器相同的目录中，所以从项目标签中将其拖放到`第11章 `| `着色器`文件夹中。
- en: If *step 1* is not completed, you will get a compilation error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*步骤1*未完成，你将得到一个编译错误。
- en: Now that we are in the folder, select the `Desaturate` shader created in the
    previous recipe and duplicate it (*Ctrl *+ *D*). Name the duplicate `Colorize`,
    and double-click on it to open it up.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在这个文件夹中，选择在先前的菜谱中创建的`Desaturate`着色器，并对其进行复制（*Ctrl *+ *D*）。将副本命名为`Colorize`，然后双击它以打开它。
- en: 'From there, update the shader name:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，更新着色器名称：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you turn your attention to our shader, you will see that we need to tell
    our `CGPROGRAM` block to include our new `CgInclude` file, so that we can access
    the code it contains. Modify the directives of our `CGPROGRAM` block to include
    the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将注意力转向我们的着色器，你会看到我们需要告诉我们的`CGPROGRAM`块包含我们的新`CgInclude`文件，这样我们就可以访问它包含的代码。修改我们的`CGPROGRAM`块的指令以包含以下代码：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our current shader is currently using the built-in Standard lighting model,
    but we want to use the Half Lambert lighting model that we created in our `CgInclude`.
    As we have included the code from our `CgInclude` file, we can use the Half Lambert
    lighting model with the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们当前的着色器目前正在使用内置的标准光照模型，但我们想使用我们在`CgInclude`中创建的半朗伯光照模型。由于我们已经包含了`CgInclude`文件中的代码，我们可以使用以下代码使用半朗伯光照模型：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we have also declared a custom variable in our `CgInclude` file to
    show that we can set up default variables for our shaders to use. To see this
    in action, enter the following code in the `Properties` block of your shader:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还在我们的`CgInclude`文件中声明了一个自定义变量，以表明我们可以为我们的着色器设置默认变量。要查看此操作，请在着色器的`Properties`块中输入以下代码：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, we need to update our `surf` function header since we use `SurfaceOutput`
    in our `LightingHalfLambert` function:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的`surf`函数头，因为我们使用了`LightingHalfLambert`函数中的`SurfaceOutput`：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Back in Unity, create a new material that will use the newly created `Colorize`
    shader (`ColorizeMat`) and assign it to the sphere we created in the last recipe.
    Assign the material as normal and modify the MyColor value from the Inspector
    to see how it modifies the object. The following screenshot shows the result of
    using our `CgInclude` file:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity中，创建一个新的材质，它将使用新创建的`Colorize`着色器（`ColorizeMat`），并将其分配给我们在上一个菜谱中创建的球体。像往常一样分配材质，并从检查器中修改MyColor值以查看它如何修改对象。以下截图显示了使用我们的`CgInclude`文件的结果：
- en: '![](img/00222.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00222.jpeg)'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When using shaders, we can include other sets of code using the `#include` preprocessor
    directive. This tells Unity that we want to let the current shader use the code
    from within the included file in the shader; this is the reason why these files
    are called `CgInclude` files. We are including snippets of Cg code using the `#include`
    directive.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用着色器时，我们可以使用`#include`预处理指令包含其他代码集。这告诉Unity我们希望当前着色器使用包含文件中的代码；这就是为什么这些文件被称为`CgInclude`文件。我们使用`#include`指令包含Cg代码片段。
- en: Once we have declared the `#include` directive and Unity is able to find the
    file in the project, Unity will then look for code snippets that have been defined.
    This is where we start to use the `#ifndef` and `#endif` directives. When we declare
    the `#ifndef` directive, we are simply saying "if not defined, define something
    with a name." In this recipe's case, we said we wanted to `#define MY_CG_INCLUDE`.
    So, if Unity doesn't find a definition called `MY_CG_INCLUDE`, it goes and creates
    it when the `CgInclude` file is compiled, thereby giving us access to the code
    that follows. The `#endif` method simply says that this is the end of this definition,
    so stop looking for more code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了`#include`指令，并且Unity能够在项目中找到该文件，Unity就会开始寻找已经定义的代码片段。这就是我们开始使用`#ifndef`和`#endif`指令的地方。当我们声明`#ifndef`指令时，我们只是在说“如果没有定义，就用一个名字定义一些东西。”在这个菜谱的情况下，我们说我们想要`#define
    MY_CG_INCLUDE`。所以，如果Unity找不到名为`MY_CG_INCLUDE`的定义，它会在`CgInclude`文件编译时创建它，从而让我们能够访问随后的代码。`#endif`方法只是简单地表示这是这个定义的结束，所以停止寻找更多的代码。
- en: You can now see how powerful this is we can now store all of our lighting models
    and custom variables in one file and greatly reduce the amount of code that we
    have to write. The real power is when you can begin to give your shaders flexibility
    by defining multiple states of functions in the `CgInclude` files.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到这是多么强大，我们可以在一个文件中存储所有的光照模型和自定义变量，从而大大减少我们需要编写的代码量。真正的力量在于你可以在`CgInclude`文件中定义多个函数状态，从而开始给你的着色器提供灵活性。
- en: Implementing a Fur Shader
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现毛皮着色器
- en: The look of a material depends on its physical structure. The shaders attempt
    to simulate them, but, in doing so, they oversimplify the way light behaves. Materials
    with a complex macroscopic structure are particularly hard to render. This is
    the case for many fabrics and animal furs. This recipe will show you how it is
    possible to simulate fur and other materials (such as grass) that are more than
    just a flat surface. In order to do this, the same material is drawn multiple
    times over and over, increasing in size every time. This creates the illusion
    of fur.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 材质的外观取决于其物理结构。着色器试图模拟它们，但在这样做的时候，它们过于简化了光的行为。具有复杂宏观结构的材料尤其难以渲染。许多织物和动物毛皮就是这样。这个菜谱将向你展示如何模拟毛皮和其他材料（如草地），这些材料不仅仅是平面。为了做到这一点，相同的材质被多次绘制，每次都增加大小。这创造了毛发的错觉。
- en: 'The shader presented here is based on the work of Jonathan Czeck and Aras Pranckevičius:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的着色器是基于Jonathan Czeck和Aras Pranckevičius的工作：
- en: '![](img/00223.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00223.jpeg)'
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order for this recipe to work, you will need a texture that shows how you
    wish to have your fur displayed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个菜谱工作，你需要一个显示你希望如何显示毛发的纹理：
- en: '![](img/00224.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00224.jpeg)'
- en: I have provided two examples in `Chapter 11 `| `Textures` folder with the book's
    example code (`Faux Fur` and `panda`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我在书的第11章`Textures`文件夹中提供了两个示例，包括书中的示例代码（`Faux Fur`和`panda`）。
- en: 'Like all the other shaders before, you will need to create a new Standard Surface
    Shader (`Fur`) and a material (`FurMat`) to host it, and attach it to a sphere
    for demonstration purposes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前所有的着色器一样，你需要创建一个新的标准表面着色器（`Fur`）和一个材质（`FurMat`）来承载它，并将其附加到一个球体上进行演示：
- en: '![](img/00225.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00225.jpeg)'
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we can start modifying a Standard Surface Shader:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们可以开始修改一个标准表面着色器：
- en: 'Double-click on the `Fur` Shader to open it up in your IDE of choice. Once
    opened, add the following bolded `Properties`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Fur`着色器以在您选择的IDE中打开它。一旦打开，添加以下加粗的`Properties`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This shader requires you to repeat the same pass several times. We will use
    the technique introduced in the *Making your shader world modular with CgIncludes *recipe
    to group all the code necessary from a single pass in an external file. Let''s
    start creating a new `CgInclude` file called `FurPass.cginc` with the following
    code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个着色器需要你重复执行相同的流程多次。我们将使用在*使用CgIncludes使你的着色器世界模块化*菜谱中介绍的技术，将单个流程中所有必要的代码组合到一个外部文件中。让我们开始创建一个名为`FurPass.cginc`的新`CgInclude`文件，并包含以下代码：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Got back to your original shader and add this extra pass after the `ENDCG`
    section:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你的原始着色器，并在`ENDCG`部分之后添加这个额外的流程：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Go back into Unity and assign the `FauxFur` texture in the Albedo (RGB) property.
    You should notice little dots along the shader:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，并将`FauxFur`纹理分配到Albedo（RGB）属性中。你应该会注意到着色器上沿着一些小点：
- en: '![](img/00226.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00226.jpeg)'
- en: 'Add more passes, progressively increasing `FUR_MULTIPLIER`. You can get decent
    results with 20 passes, from `0.05` to `0.95`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加更多遍历，逐步增加`FUR_MULTIPLIER`。使用20遍，从`0.05`到`0.95`可以得到相当不错的结果：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the shader has been compiled and attached to a material, you can change
    its appearance from the Inspector.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦着色器被编译并附加到材质上，您就可以在检查器中更改其外观。
- en: The `Fur Length` property determines the space between the fur shells, which
    will alter the length of the fur. Longer fur might require more passes to look
    realistic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fur Length`属性决定了毛发壳之间的空间，这将改变毛发的长度。较长的毛发可能需要更多的遍历来看起来逼真。'
- en: '`Alpha Cutoff` and `Alpha Cutoff End` are used to control the density of the
    fur and how it gets progressively thinner.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alpha Cutoff`和`Alpha Cutoff End`用于控制毛发的密度以及其如何逐渐变薄。'
- en: '`Edge Fade` determines the final transparency of the fur and how fuzzy it looks.
    Softer materials should have a high `Edge Fade`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Edge Fade`决定了毛发的最终透明度和其外观的模糊程度。较软的材料应该有较高的`Edge Fade`。'
- en: 'Finally, `Gravity Direction` and `Gravity Strength` curve the fur shells to
    simulate the effect of gravity:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Gravity Direction`和`Gravity Strength`使毛发壳弯曲，以模拟重力效果：
- en: '![](img/00227.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00227.jpeg)'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The technique presented in this recipe is known as Lengyel''s concentric fur-shell
    technique or simply the shell technique. It works by creating progressively bigger
    copies of the geometry that needs to be rendered. With the right transparency,
    it gives the illusion of a continuous thread of hair:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中介绍的技术被称为Lengyel的同心毛发壳技术，或简单地称为壳技术。它是通过创建需要渲染的几何形状的逐渐增大的副本来工作的。通过适当的透明度，它会产生连续毛发线的错觉：
- en: '![](img/00228.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00228.jpeg)'
- en: The shell technique is extremely versatile and relatively easy to implement.
    Realistic fur requires not only extruding the geometry of the model but also altering
    its vertices. This is possible with tessellation shaders, which are much more
    advanced and not covered in this book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 壳技术非常灵活且相对容易实现。要实现逼真的毛发，不仅需要拉伸模型的几何形状，还需要改变其顶点。这可以通过细分着色器实现，这些着色器更为先进，但本书没有涉及。
- en: 'Each pass in this `Fur` Shader is contained in `FurPass.cginc`. The vertex
    function creates a slightly bigger version of the model, which is based on the
    principle of normal extrusion. Additionally, the effect of gravity is taken into
    account, so that it gets more intense the further we are from the center:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`Fur`着色器中的每一遍都在`FurPass.cginc`中。顶点函数创建了一个稍微大一点的模型版本，这是基于法线拉伸原理。此外，还考虑了重力效应，因此越远离中心，效果越强烈：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the alpha channel is used to determine the final length of
    the `Fur`. This allows for more precise control.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，alpha通道用于确定毛发的最终长度，这允许更精确的控制。
- en: 'Finally, the surface function reads the control mask from the alpha channel.
    It uses the cutoff value to determine which pixels to show and which ones to hide.
    This value changes from the first to the final fur shell to match `Alpha Cutoff`
    and `Alpha Cutoff End`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，表面函数从alpha通道读取控制掩码。它使用截止值来确定哪些像素要显示，哪些要隐藏。此值从第一个到最后的毛发壳都会改变，以匹配`Alpha Cutoff`和`Alpha
    Cutoff End`：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The final alpha value of the fur also depends on its angle from the camera,
    giving it a softer look.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 毛发的最终alpha值还取决于其与摄像机的角度，使其看起来更柔和。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Fur` shader has been used to simulate fur. However, it can be used for
    a variety of other materials. It works very well for materials that are naturally
    made of multiple layers, such as forest canopies, fuzzy clouds, human hair, and
    even grass.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fur`着色器已被用于模拟毛发。然而，它可以用于各种其他材质。它非常适合由多层自然构成的材质，如森林树冠、毛茸茸的云朵、人类头发，甚至草地。'
- en: 'Some additional examples of the same shader being used by just tweaking the
    parameters can be seen in the book''s example code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例代码中，可以看到仅通过调整参数就使用相同着色器的额外示例：
- en: '![](img/00229.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00229.jpeg)'
- en: There are many other improvements that can dramatically increase its realism.
    You can add a very simple wind animation by changing the direction of the gravity
    based on the current time. If calibrated correctly, this can give the impression
    that the fur is moving because of the wind.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他改进可以显著提高其真实感。您可以通过根据当前时间改变重力的方向来添加一个非常简单的风动画。如果校准正确，这可以给人一种毛发因风而移动的印象。
- en: 'Additionally, you can make your fur move when the character is moving. All
    these little tweaks contribute to the believability of your fur, giving the illusion
    that it is not just a static material drawn on the surface. Unfortunately, this
    shader comes at a price: 20 passes are very heavy to compute. The number of passes
    determines roughly how believable the material is. You should play with fur length
    and passes in order to get the effect that works best for you. Given the performance
    impact of this shader, it is advisable to have several materials with different
    numbers of passes; you can use them at different distances and save a lot of computation.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以在角色移动时使您的毛发移动。所有这些小调整都有助于使您的毛发看起来更加逼真，给人一种它不仅仅是绘制在表面上的静态材质的错觉。不幸的是，这个着色器代价很高：20次遍历计算非常沉重。遍历的次数大致决定了材质的逼真程度。您应该调整毛发长度和遍历次数，以获得最适合您的效果。鉴于这个着色器的性能影响，建议您拥有几个不同遍历次数的材质；您可以在不同的距离处使用它们，从而节省大量的计算。
- en: Implementing Heatmaps with arrays
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组实现热图
- en: One characteristic that makes shaders hard to master is the lack of proper documentation.
    Most developers learn shaders by messing around with the code, without having
    a deep knowledge of what's going on. The problem is amplified by the fact that
    Cg/HLSL makes a lot of assumptions, some of which are not properly advertised.
    Unity3D allows C# scripts to communicate with shaders using methods such as `SetFloat`,
    `SetInt`, `SetVector`, and so on. Unfortunately, Unity3D doesn't have a `SetArray`
    method, which leads many developers to believe that `Cg/HLSL` doesn't support
    arrays either. This is not true. This post will show you how it's possible to
    pass arrays to shaders. Just remember that GPUs are highly optimized for parallel
    computations, and using for loops in a shader will dramatically decrease its performance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使着色器难以掌握的一个特点是缺乏适当的文档。大多数开发者通过在代码中摸索来学习着色器，而没有深入了解正在发生的事情。由于Cg/HLSL做出了很多假设，其中一些并没有得到适当的宣传，这个问题变得更加严重。Unity3D允许C#脚本使用`SetFloat`、`SetInt`、`SetVector`等方法与着色器通信。不幸的是，Unity3D没有`SetArray`方法，这使得许多开发者认为`Cg/HLSL`也不支持数组。这并不正确。本文将向您展示如何将数组传递给着色器。只需记住，GPU高度优化了并行计算，在着色器中使用循环将大大降低其性能。
- en: 'For this recipe, we will implement a heatmap, as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将实现一个热图，如下面的截图所示：
- en: '![](img/00230.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00230.jpeg)'
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The effect in this recipe creates a heatmap from a set of points. This heatmap
    can be overlaid on top of another picture, like in the preceding screenshot. The
    following steps are necessary:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的效果是从一组点创建热图。这个热图可以叠加在另一张图片上，如前面的截图所示。以下步骤是必要的：
- en: Create a quad with the texture that you want to use for the `Heatmap` (`GameObject`
    | `3D Object` | `Quad`). In this example, a map of London has been used. In order
    to put the texture on the quad, create a new material (`Map`) using the Unlit/Texture
    shader, and assign the image to the Base (RGB) property. Once created, drag and
    drop that object onto the quad. The position of quad object must be set to (0,
    0, 0).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有您想要用于`Heatmap`的纹理的四边形（`GameObject` | `3D Object` | `Quad`）。在这个例子中，使用了伦敦的地图。为了将纹理放在四边形上，使用Unlit/Texture着色器创建一个新的材质（`Map`），并将图像分配给Base
    (RGB)属性。创建后，将此对象拖放到四边形上。四边形对象的位置必须设置为（0，0，0）。
- en: Create another quad and place it on top of the previous one. Our `Heatmap` will
    appear on this quad.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个四边形，并将其放置在之前的四边形之上。我们的`Heatmap`将显示在这个四边形上。
- en: 'Attach a new shader (`Heatmap`) and material (`HeatmapMat`) to the second quad:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的着色器（`Heatmap`）和材质（`HeatmapMat`）附加到第二个四边形上：
- en: '![](img/00231.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00231.jpeg)'
- en: For ease of visualization, I also selected the MainCamera and changed the Projection
    to `Orthographic` and the Size property to `0.5`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了便于可视化，我还选择了MainCamera，并将投影改为`Orthographic`，大小属性设置为`0.5`。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'This shader is quite different from the ones created before, yet it is relatively
    short. For this reason, the entire code is provided in the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器与之前创建的着色器相当不同，但它相对较短。因此，以下步骤提供了整个代码：
- en: 'Copy this code to the newly created shader:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码复制到新创建的着色器中：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you have attached this script to your material, you should provide a ramp
    texture for the heatmap. It''s important to configure it so that its Wrap Mode
    is set to Clamp:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦将此脚本附加到您的材料上，您应该为热图提供渐变纹理。重要的是要配置它，使其Wrap Mode设置为Clamp：
- en: '![](img/00232.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00232.jpeg)'
- en: If your heatmap is going to be used as an overlay, then make sure that the ramp
    texture has an alpha channel and the texture is imported with the Alpha is Transparency option.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的热图将要用作叠加层，那么请确保渐变纹理具有alpha通道，并且纹理是以“Alpha is Transparency”选项导入的。
- en: 'Create a new script called `HeatmapDrawer` using the following code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个名为 `HeatmapDrawer` 的新脚本：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Attach the script to an object in your scene, preferably to the quad. Then,
    drag the material created for this effect to the `Material` slot of the script.
    By doing this, the script will be able to access the `Material` and initialize
    it.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本附加到场景中的对象上，最好是四边形。然后，将为此效果创建的材料拖到脚本的 `Material` 槽中。通过这样做，脚本将能够访问 `Material`
    并初始化它。
- en: 'Lastly, expand the positions, radiuses, and intensities fields of your script
    and fill them with the values of your heatmap. Positions indicate the points (in
    world coordinates) of your heatmaps, radii indicate their size, and intensities
    indicate how strongly they affect the surrounding area:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，扩展你的脚本中的位置、半径和强度字段，并用你的热图值填充它们。位置表示你的热图在世界坐标中的点，半径表示它们的大小，强度表示它们对周围区域的影响强度：
- en: '![](img/00233.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00233.jpeg)'
- en: 'If all went well, once you play the game you should notice something similar
    to the following screenshot:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，当你玩游戏时，你应该会注意到以下截图类似的内容：
- en: '![](img/00234.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00234.jpeg)'
- en: If you do not see this, make sure that the heatmap is placed in front of the
    map quad and that both objects are in front of the camera.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到这个，请确保热图放置在地图四边形之前，并且两个对象都在摄像机之前。
- en: If you get a warning saying the number of points has changed, go into your shader,
    modify the script by adding a space, and then save it again.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一个警告说点的数量已更改，请进入你的着色器，通过添加一个空格修改脚本，然后再次保存。
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This shader relies on things that have not been introduced before in this book;
    the first one is arrays. Cg allows arrays that can be created with the following
    syntax:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器依赖于本书之前未介绍的内容；第一个是数组。Cg 允许使用以下语法创建数组：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Cg doesn''t support arrays with an unknown size: you must preallocate all the
    space that you need beforehand. The preceding line of code creates an array of
    `20` elements.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Cg 不支持未知大小的数组：你必须预先分配你需要的所有空间。前面的代码行创建了一个包含 `20` 个元素的数组。
- en: Unity allows us to set arrays through using a number of methods, including `SetVectorArray`,
    `SetColorArray`, `SetFloatArray`, and `GetMatrixArray`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 允许我们通过使用多种方法来设置数组，包括 `SetVectorArray`、`SetColorArray`、`SetFloatArray`
    和 `GetMatrixArray`。
- en: The `SetVectorArray` function only works with the `Vector4` class at present.
    That will not cause us any issues, though, as you can automatically assign a `Vector3` to
    a `Vector4`, and Unity will automatically include a zero in for the last element.
    Also, it is possible to instead use our `Start` code in an `Update` loop to be
    able to see the values change as we're modifying them, but it would be computationally
    expensive.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetVectorArray` 函数目前只与 `Vector4` 类一起使用。这不会给我们带来任何问题，因为你可以自动将一个 `Vector3` 分配给一个
    `Vector4`，Unity 会自动在最后一个元素中包含一个零。此外，你也可以在 `Update` 循环中使用我们的 `Start` 代码来能够看到我们修改它们时的值变化，但这将非常耗费计算资源。'
- en: 'In the fragment function of the shader, there is a similar for loop, which,
    for each pixel of the material, queries all the points to find their contribution
    to the heatmap:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器的片段函数中，有一个类似的循环，它对材料的每个像素查询所有点以找到它们对热图的贡献：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `h` variable stores the heat from all the points, given their radii and
    intensities. It is then used to look up which color to use from the ramp texture.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`h` 变量存储了所有点的热量，这些点由它们的半径和强度给出。然后它被用来查找从渐变纹理中使用的颜色。'
- en: The shaders and arrays are a winning combination, especially as very few games
    are using them at their full potential. However, they introduce a significant
    bottleneck, as, for each pixel, the shader has to loop through all the points.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器和数组是一个获胜的组合，尤其是由于非常少有游戏能够充分利用它们。然而，它们引入了一个显著的瓶颈，因为对于每个像素，着色器必须遍历所有点。
