<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating and Implementing Events and Callbacks</h1>
                </header>
            
            <article>
                
<p>This chapter focuses on events and callbacks in C#. They are important to understand since they give us more control over programs. An event is a message or notification from an object when either its property has been changed or a button has been clicked. A callback, also known as a delegate, holds a reference to a function. C# comes with Lambda expressions, which can be used to create delegates. These are also called anonymous methods.</p>
<p>We will also spend some time looking at a new operator, known as a Lambda operator. These are used in Lambda expressions. They were introduced in version 3.0 of C# so that developers could instantiate delegates. Lambda expressions replaced the anonymous methods that were introduced in C# 2.0 and are now widely used.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Understanding delegates</li>
<li>Handling and raising events</li>
</ul>
<p><span>By the end of this chapter, you will know what delegates are and how you can use them in events and callbacks.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The exercises in this chapter can be practiced using Visual Studio 2012 or above with .NET Framework 2.0 or above. However, any new C# features from 7.0 onward require that you have Visual Studio 2017 installed.</p>
<p class="mce-root"/>
<p>If you don't have a license for any of the aforementioned products, you can download the community version of Visual Studio 2017 from<span> <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a></span>.</p>
<p>The sample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide">https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding delegates</h1>
                </header>
            
            <article>
                
<p class="mce-root">A <strong>delegate</strong> is nothing but a reference to a method, along with some parameters and a return type. When a delegate is defined, it can be associated with any instance that provides a compatible signature and a return type of the method. In other terms, delegates can be defined as function pointers in C and C++. However, delegates are type-safe, secure, and object-oriented. </p>
<p>A delegate model follows the observer pattern, which allows the subscriber to register with and receive notifications from the provider. To get a better understanding of the observer pattern, take a look at the references provided at the end of this chapter, in the <em>Further reading</em> section.</p>
<p class="mce-root">A classic example of a delegate is event handlers in a Windows application, which are methods that are invoked by delegates. In the context of events, a delegate is an intermediary between the event source and the code that handles the event.</p>
<p class="mce-root">Delegates are ideal for callbacks because of their ability to pass methods as parameters. Delegates are derived from the <kbd>System.Delegate</kbd> class.</p>
<p>The general syntax of <kbd>delegate</kbd> is as follows:</p>
<pre>delegate &lt;return type&gt; &lt;delegate name&gt; &lt;parameter list&gt;</pre>
<p>An example of a delegate declaration is as follows:</p>
<pre>public delegate string delegateexample (string strVariable);</pre>
<p>In the preceding example, the delegate that's been defined can be referenced by any method that has a single string parameter and returns a string variable.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instantiating a delegate</h1>
                </header>
            
            <article>
                
<p>The named method can be used to a when we're using versions of C# prior to 2.0. Version 2.0 introduced a new way to instantiate delegates. We will try to understand these methods in the upcoming sections. Version 3.0 of C# replaces anonymous methods with Lambda expressions, which are now widely used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initiating delegates using NamedMethod</h1>
                </header>
            
            <article>
                
<p>Let's look at an example of <kbd>NamedMethod</kbd> so that we can understand how to initiate a <kbd>delegate</kbd>. This is the method that was used prior to C# 2.0:</p>
<pre>delegate void MathDelegate(int i, double j);<br/>public class Chapter5Samples<br/>{<br/>  // Declare a delegate<br/>  public void NamedMethod()<br/>  {<br/>    Chapter5Samples m = new Chapter5Samples();<br/>    // Delegate instantiation using "Multiply"<br/>    MathDelegate d = m.Multiply;<br/>    // Invoke the delegate object.<br/>    Console.WriteLine("Invoking the delegate using 'Multiply':");<br/>    for (int i = 1; i &lt;= 5; i++)<br/>    {<br/>      d(i, 5);<br/>    }<br/>    Console.WriteLine("");<br/><br/>  }<br/>  // Declare the associated method.<br/>  void Multiply(int m, double n)<br/>  {<br/>    System.Console.Write(m * n + " ");<br/>  }<br/>}<br/>//Output:<br/><strong>Invoking the delegate using 'Multiply':</strong><br/><strong>5 10 15 20 25</strong></pre>
<p>In the preceding code, first, we defined a delegate called <kbd>MathDelegate</kbd>, which accepts <kbd>2</kbd> parameters, <kbd>1</kbd> integer and another double type. Then, we defined a class where we wanted to invoke <kbd>MathDelegate</kbd> using a named method known as <kbd>Multiply</kbd>.</p>
<p>The <kbd>MathDelegate d = m.Multiply;</kbd> line is where we assigned a named method to a delegate.</p>
<p><span>Named method delegates can encapsulate a static or instance method with any accessible class or structure that matches the type of delegate. This allows the developer to extend these methods.</span></p>
<p>In the following example, we will see how a delegate can be mapped to static and instance methods. Add the following method to the <kbd>Chapter5Samples</kbd> class we created previously:</p>
<pre>public void InvokeDelegate()<br/>{<br/>  HelperClass helper = new HelperClass();<br/><br/>  // Instance method mapped to delegate:<br/>  SampleDelegate d = helper.InstanceMethod;<br/>  d();<br/><br/>  // Map to the static method:<br/>  d = HelperClass.StaticMethod;<br/>  d();<br/>}<br/><br/>//Create a new Helper class to hold two methods<br/>// Delegate declaration<br/>delegate void SampleDelegate();<br/><br/>internal class HelperClass<br/>{<br/>  public void InstanceMethod()<br/>  {<br/>    System.Console.WriteLine("Instance Method Invoked.");<br/>  }<br/><br/>  static public void StaticMethod()<br/>  {<br/>    System.Console.WriteLine("Invoked function Static Method.");<br/>  }<br/>}<br/><br/>//Output: <br/><strong>Invoked function Instance Method.</strong><br/><strong>Invoked function Static Method.</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding code, we defined two methods: the first one is a normal method, while the second one is a static method. In the case of invoking delegates using a named method, we can either use the first normal method or the second static method:</p>
<ul>
<li><kbd>SampleDelegate d = helper.InstanceMethod;</kbd>: This is a normal method.</li>
<li><kbd>d = HelperClass.StaticMethod;</kbd>: This is a static method.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initiating a delegate using anonymous functions</h1>
                </header>
            
            <article>
                
<p>In a situation where creating new methods can be classed as overhead, C# allows us to initiate a delegate and specify a code block. The delegate will process this code block when it is invoked. This is the method that's used in C# 2.0 to invoke delegates. They are also known as anonymous methods.</p>
<p>An expression or a statement that's defined inline instead of a delegate type is known as an anonymous function.</p>
<p>There are two types of anonymous function:</p>
<ul>
<li>Lambda expressions</li>
<li>Anonymous methods</li>
</ul>
<p>We will look at these two types of functions in the upcoming subsections. However, before we move on, we should also understand one new operator, called the <strong>Lambda operator</strong>. This is used to represent Lambda expressions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lambda expressions</h1>
                </header>
            
            <article>
                
<p>With C# 3.0, Lambda expressions were introduced and are widely used in invoking delegates. Lambda expressions are created using Lambda operators. On the left-hand side of the operator, we specify the input parameters, while on the left-hand side, we specify the expression or code block. When a Lambda operator is used in an expression body, it separates the member's name from the member's implementation.</p>
<p>The Lambda operator is represented as a <kbd><span><span>=&gt;</span></span></kbd> token. This operator is right-associative and has the same precedence as an assignment operator. An assignment operator assigns a right-hand operand value to a left-hand operand.</p>
<p class="mce-root"/>
<p class="mce-root">In the following code, we are using a Lambda operator to compare a specific word in a string array and return it. Here, <span>we are applying a Lambda expression to each element of the <kbd>words</kbd> array:</span></p>
<pre>words.Where(w =&gt; w.Equals("apple")).FirstOrDefault();</pre>
<p>This example also shows how we can use a LINQ query to get the same output. </p>
<p>We are trying to find "apple" from an array of words using a LINQ query. Any enumerable collection allows us to query using LINQ and returns the desired output:</p>
<pre><span>public void LambdaOperatorExample()<br/>{<br/>    string[] words = { "bottle", "jar", "drum" };<br/>    </span><span>// apply Lambda expression to each element in the array<br/>    string searchedWord = words.Where(w =&gt; <br/>                            w.Equals("drum")).FirstOrDefault();<br/>    Console.WriteLine(searchedWord);<br/></span><span>    // Get the length of each word in the array.<br/>    var query = from w in words<br/>                where w.Equals("drum")<br/>                select w;<br/>                <br/>    string search2 = query.FirstOrDefault();<br/>    Console.WriteLine(search2);<br/></span><span>}</span><br/><br/>//Output:<br/><strong>drum</strong><br/><strong>drum</strong></pre>
<p>A Lambda expression is the right-hand side operator of a Lambda operator and is widely used in expression trees.</p>
<div class="packt_infobox">More information on expression trees can be on the Microsoft documentation website.</div>
<p>This Lambda expression must be a valid expression. If the member type is void, it's classed as a statement expression.</p>
<p>From C# 6 onward, these expressions support method and property get statements, while from C# 7 onward, these expressions support constructors, finalizers, property set statements, and indexers.</p>
<p class="mce-root"/>
<p>In the following code, we are using an expression to write the first name and last name of the variable and we have also used the <kbd>Trim()</kbd> function:</p>
<pre><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">string</span> <span class="hljs-title">ToString</span>() </span><span>=&gt; </span><span class="hljs-string">$"<span class="hljs-subst">{fname}</span> <span class="hljs-subst">{lname}</span>"</span><span>.Trim();</span></pre>
<p>With this basic understanding of Lambda expressions and the Lambda operator, we can move on and look at how we can use Lambda expressions to invoke a delegate.</p>
<p><span>Recall that a Lambda expression can be represented like so:</span></p>
<pre>Input-Parameters =&gt; Expression</pre>
<p>In the following example, two extra lines have been added to the existing method to invoke the delegate using a Lambda expression. <kbd>X</kbd> is the input parameter, where the type of <kbd>X</kbd> is identified by the compiler:</p>
<pre>delegate void StringDelegate(string strVariable);<br/>public void InvokeDelegatebyAnonymousFunction()<br/>{<br/>  //Named Method<br/>  StringDelegate StringDel = HelperClass.StringMethod;<br/>  StringDel("Chapter 5 - Named Method");<br/><br/>  //Anonymous method<br/>  StringDelegate StringDelB = delegate (string s) { Console.WriteLine(s); };<br/>  StringDelB("Chapter 5- Anonymous method invocation");<br/><br/>  //LambdaExpression<br/>  StringDelegate StringDelC = (X)=&gt; { Console.WriteLine(X); };<br/>  StringDelB("Chapter 5- Lambda Expression invocation");<br/><br/>}<br/><br/>//Output:<br/><strong>Chapter 5 - Named Method</strong><br/><strong>Chapter 5- Anonymous method invocation</strong><br/><strong>Chapter 5- Lambda Expression invocation</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Anonymous methods</h1>
                </header>
            
            <article>
                
<p>C# 2.0 introduced anonymous methods, while C# 3.0 introduced Lambda expressions, which were later replaced with anonymous methods.</p>
<p class="mce-root"/>
<p>One case where anonymous methods provide functionality that isn't possible when using a Lambda expression is that they allow us to avoid parameters. These allow anonymous methods to be converted into delegates with a number of different signatures.</p>
<p class="mce-root"><span>Let's look at an example of how to use anonymous methods to initiate a delegate:</span></p>
<pre>public void InvokeDelegatebyAnonymousFunction()<br/>{<br/>  //Named Method<br/>  StringDelegate StringDel = HelperClass.StringMethod;<br/>  StringDel("Chapter 5");<br/><br/>  //Anonymous method<br/>  StringDelegate StringDelB = delegate (string s) { Console.WriteLine(s); };<br/>  StringDelB("Chapter 5- Anonymous method invocation");<br/><br/>}<br/>internal class HelperClass<br/>{<br/>  public void InstanceMethod()<br/>  {<br/>    System.Console.WriteLine("Instance method Invoked.");<br/>  }<br/><br/>  public static void StaticMethod()<br/>  {<br/>    System.Console.WriteLine("Invoked function Static Method.");<br/>  }<br/><br/>  public static void StringMethod(string s)<br/>  {<br/>    Console.WriteLine(s);<br/>  }<br/>}<br/><br/>//Output:<br/><strong>Chapter 5</strong><br/><strong>Chapter 5- Anonymous method invocation</strong></pre>
<p>In the preceding code, we defined a string delegate and wrote some inline code to invoke it. The following is the code where we defined the inline delegate, also known as an anonymous method:</p>
<pre>StringDelegate StringDelB = delegate (string s) { Console.WriteLine(s); };</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The following code shows how we can create an anonymous method:</p>
<pre>// Creating a handler for a click event.<br/>sampleButton.Click += delegate(System.Object o, System.EventArgs e)<br/>                   { System.Windows.Forms.MessageBox.Show(<br/>                     "Sample Button Clicked!"); };</pre>
<p>Here, we created a code block and passed it as a <kbd>delegate</kbd> parameter.</p>
<p>An anonymous method will throw an error if the runtime encounters any jump statements, such as <kbd>goto</kbd>, <kbd>break</kbd>, or <kbd>continue</kbd>, inside the code block and the target is outside the code block. Also, in a scenario where a jump statement is outside the code block and the target is in it, with the <kbd>int</kbd> anonymous method, an exception will be thrown.</p>
<p><span>Any local variables that are created outside of the delegate's scope and contained in an anonymous method declaration are called</span> <em>outer</em> <span>variables of the anonymous method. For example, in the following code segment, <kbd>n</kbd> is an outer variable:</span></p>
<pre>int n = 0;<br/>Del d = delegate() { System.Console.WriteLine("Copy #:{0}", ++n); };</pre>
<p>Anonymous methods are not allowed on the left-hand side of the is operator. No unsafe code can be accessed or used in an anonymous method, including the <kbd>in</kbd>, <kbd>ref</kbd>, or <kbd>out</kbd> parameters of an outer scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variance in delegates</h1>
                </header>
            
            <article>
                
<p>C# supports variance in delegate types with matching method signatures. This feature was introduced in .NET Framework 3.5. This means delegates can now be assigned with matching signatures but also that methods can return derived types.</p>
<p>If a method has a return type derived from the one defined in a delegate, it is defined as covariance in delegates. Similarly, if a method has fewer derived parameter types than those defined in a delegate, it is defined as contravariance.</p>
<p>Let's look at an example to understand covariance. For the purpose of this example, we will create a few classes.</p>
<p class="mce-root"/>
<p>Here, we will create the <kbd>ParentReturnClass</kbd>, <kbd>Child1ReturnClass</kbd>, and <kbd>Child2Return</kbd> classes. Each of these has a string type property. Both child classes are inherited from <kbd>ParentReturnClass</kbd>:</p>
<pre>internal class ParentReturnClass<br/>{<br/>  public string Message { get; set; }<br/>}<br/><br/>internal class Child1ReturnClass : ParentReturnClass<br/>{<br/>  public string ChildMessage1 { get; set; }<br/>}<br/>internal class Child2ReturnClass : ParentReturnClass<br/>{<br/>  public string ChildMessage2 { get; set; }<br/>}</pre>
<p>Now, let's add two new methods to the previously defined helper class, each returning the respective child classes we defined earlier:</p>
<pre>public Child1ReturnClass ChildMehod1() <br/>{ <br/>    return new Child1ReturnClass <br/>    { <br/>        ChildMessage1 = "ChildMessage1" <br/>    }; <br/>}<br/>public Child2ReturnClass ChildMehod2() <br/>{ <br/>    return new Child2ReturnClass <br/>    { <br/>        ChildMessage2 = "ChildMessage2" <br/>    }; <br/>}</pre>
<p>Now, we will define a delegate that returns <kbd>ParentReturnClass</kbd>. We'll also define a new method that will initiate this delegate for each of the child methods. One important point to observe in the following code is that we have used explicit typecast to convert <kbd>ParentReturnClass</kbd> into <kbd>ChildReturnClass1</kbd> and <kbd>ChildReturnClass2</kbd>:</p>
<pre>delegate ParentReturnClass covrianceDelegate();<br/>public void CoVarianceSample()<br/>{<br/>  covrianceDelegate cdel;<br/>  cdel = new HelperClass().ChildMehod1;<br/>  Child1ReturnClass CR1 = (Child1ReturnClass)cdel();<br/>  Console.WriteLine(CR1.ChildMessage1);<br/>  cdel = new HelperClass().ChildMehod2;<br/> Child2ReturnClass CR2 = (Child2ReturnClass)cdel();<br/>Console.WriteLine(CR2.ChildMessage2);<br/>}<br/><br/><br/>//Output:<br/><strong>ChildMessage1</strong><br/><strong>ChildMessage2</strong></pre>
<p>In the preceding example, the delegate is returning <kbd>ParentReturnClass</kbd>. However, both <kbd>ChildMethod1</kbd> and <kbd>ChildMethod2</kbd> are returning child classes that were inherited from <kbd>ParentReturnClass</kbd>. This means that methods that return more derived types than those defined in the delegate are permitted. This is called covariance.</p>
<p>Now, let's look at another example to understand contravariance. Extend the previously created helper class by adding a new method that accepts <kbd>ParentReturnClass</kbd> as a parameter and returns void:</p>
<pre>public void Method1(ParentReturnClass parentVariable1) <br/>{ <br/>    Console.WriteLine(((Child1ReturnClass)parentVariable1).ChildMessage1); <br/>}</pre>
<p>Define a delegate that accepts <kbd>Child1ReturnClass</kbd> as a parameter:</p>
<pre>delegate void contravrianceDelegate(Child1ReturnClass variable1);</pre>
<p>Now, create a method to initiate the delegate:</p>
<pre>public void ContraVarianceSample()<br/>{<br/>  Child1ReturnClass CR1 = new Child1ReturnClass() { ChildMessage1 = "ChildMessage1" };<br/>  contravrianceDelegate cdel = new HelperClass().Method1;<br/>  cdel(CR1);<br/>  <br/>}<br/><br/>//Output:<br/><strong>ChildMessage1</strong></pre>
<p>Because method one works with the parent class, it will definitely work with the class that is inherited from the parent class. C# permits fewer derived types as parameters than those defined in the delegate.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Built-in delegates</h1>
                </header>
            
            <article>
                
<p>So far, we have seen how we can create custom delegates and use them in our program. C# comes with a couple of built-in delegates, which developers can use instead of having to create custom delegates. They are as follows:</p>
<ul>
<li><kbd>Func</kbd></li>
<li><kbd>Action</kbd></li>
</ul>
<p><kbd>Func</kbd> takes zero or more parameters and returns one value as an <kbd>out</kbd> parameter, whereas <kbd>Action</kbd> accepts zero or more parameters but returns nothing.</p>
<p>There is no requirement to declare an explicit delegate when working with <kbd>Func</kbd> or <kbd>Action</kbd>:</p>
<pre>public delegate TResult Func&lt;out TResult&gt;();</pre>
<p class="mce-root"><kbd>Action</kbd> can be defined as follows:</p>
<pre><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>()</span><span>;</span></pre>
<p>As we mentioned earlier, both take zero or more parameters. C# supports 16 different forms of both delegates, all of which can be used in our program.</p>
<p>The general form of <kbd>Func</kbd> with two or more parameters is as follows. It takes comma-separated in and out parameters, where the last parameter is always an out parameter called <kbd>TResult</kbd>:</p>
<pre>public delegate TResult Func&lt;in T1,in T2,in T3,in T4,out TResult&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4);</pre>
<p>Similar to <kbd>Func</kbd>, here is the general form for <kbd>Action</kbd> with two or more parameters:</p>
<pre>public delegate void Action&lt;in T1,in T2,in T3,in T4&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multicast delegates</h1>
                </header>
            
            <article>
                
<p>Invoking more than one method through a delegate is called multicasting. You can use <kbd>+</kbd>, <kbd>-</kbd>, <kbd>+=</kbd>, or <kbd>-+</kbd> to add or remove methods from the list of invoking methods. This list is called the invocation list. It's used in event handling.</p>
<p class="mce-root"/>
<p>The following example shows how we can invoke multiple methods by invoking a delegate. We have two methods, both of which accept a string parameter and display it on the screen. In the multicast delegate method, we are associating two methods with <kbd>stringdelegate</kbd>: </p>
<pre>delegate void StringDelegate( string strVariable);<br/>public void MulticastDelegate()<br/>{<br/>  StringDelegate StringDel = HelperClass.StringMethod;<br/>  StringDel += HelperClass.StringMethod2;<br/>  StringDel("Chapter 5 - Multicast delegate Method1");<br/>}<br/><br/>//Helper Class Methods<br/>public static void StringMethod(string s)<br/>{<br/>  Console.WriteLine(s);<br/>}<br/><br/>public static void StringMethod2(string s)<br/>{<br/>  Console.WriteLine("Method2 :" + s);<br/>}<br/><br/><br/>/Output:<br/><strong>Chapter 5 - Multicast delegate Method1</strong><br/><strong>Method2 :Chapter 5 - Multicast delegate Method1</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling and raising events</h1>
                </header>
            
            <article>
                
<p><span>As we mentioned in the introduction of this chapter, events are any actions, such as a keypress, mouse movement, or I/O operation, performed by the user. Sometimes, events can be raised by system-generated operations such as creating/updating a record in a table. </span></p>
<p>.NET Framework events are based on the delegate model, which follows the observer pattern. The observer pattern allows a subscriber to register for notifications and a publisher to register for push notifications. It's like late binding and is a way for an object to broadcast that something has happened.</p>
<p>A design pattern that allows you to subscribe/unsubscribe to a stream of events coming from a publisher is called an observer pattern.</p>
<p class="mce-root"/>
<p>For example, in the previous chapter, we worked on a code snippet where the program finds whether the character that was entered by the user is a vowel or not. Here, the user pressing a key on the keyboard is the publisher, which notifies the program regarding which key was pressed. Now, our program, which is a subscriber to the provider, responds to it by checking whether the character that was entered was a vowel or not and displays it on the screen.</p>
<p>A message that's sent by an object to notify it that an action has occurred is called an event. The object that raises this event is called an event sender or publisher. An object that receives and responds to an event is called a subscriber.</p>
<p>A publisher event can have multiple subscribers, while a subscriber can handle publishing events. Remember that multicast delegates, which we discussed in the previous sections, are extensively used in events (publish-subscribe pattern).</p>
<p>By default, if a publisher has multiple subscribers, all are invoked <span>synchronously</span>. C# supports calling these event methods a<span>synchronously. We will understand this in more detail in the upcoming chapters.</span></p>
<p>Before we dive into an example, let's try to understand a few of the terms we are going to use:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 21.0968%"><kbd>event</kbd></td>
<td style="width: 77.9032%">This is a keyword that's used to define an event in the <kbd>publisher</kbd> class in C#. </td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 21.0968%"><kbd>EventHandler</kbd></td>
<td style="width: 77.9032%">This method is used to handle an event. This may or may not have event data.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 21.0968%"><kbd>EventArgs</kbd></td>
<td style="width: 77.9032%">It represents a base class for the class that contains event data.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Event handlers support two variations: one with no event data and another with event data. The following code represents a method that handles an event with no event data:</p>
<pre><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EventHandler</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><span>;<br/></span></pre>
<p>The following code represents a method that handles an event with event data:</p>
<pre>public delegate void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e);</pre>
<p>Let's look at an example and try to understand how we can raise events and handle them. </p>
<div class="packt_infobox">In this scenario, we are going to have a banking application where customers make transactions such as creating new accounts, looking at their credit and debit amounts, and making requests for their total balance. We will raise events whenever such a transaction is made and notify the customer.</div>
<p>We will start with an <kbd>Account</kbd> class (<kbd>publisher</kbd> class), along with all the supporting methods, such as <kbd>credit()</kbd>, <kbd>debit()</kbd>, <kbd>showbalance()</kbd>, and <kbd>initialdeposit()</kbd>. These are the types of transactions a customer can operate their account with. Because the customer needs to be notified whenever such a transaction happens, we will define an event and an event handler with event data to handle the event:</p>
<pre><span>public delegate void BankTransHandler(object sender, <br/>BankTransEventArgs e); // Delegate Definition <br/>    class Account<br/>    {<br/>        // Event Definition<br/>        public event BankTransHandler ProcessTransaction; <br/>        public int BALAmount;<br/>        public void SetInitialDeposit(int amount)<br/>        {<br/>            this.BALAmount = amount;<br/>            BankTransEventArgs e = new BankTransEventArgs(amount, <br/>                                   "InitialBalance");<br/>            // InitialBalance transaction made<br/>            OnProcessTransaction(e);<br/>        }<br/>        public void Debit(int debitAmount)<br/>        {<br/>            if (debitAmount &lt; BALAmount)<br/>            {<br/>                BALAmount = BALAmount - debitAmount;<br/>                BankTransEventArgs e = new BankTransEventArgs(<br/>                                           debitAmount, "Debited");<br/>                OnProcessTransaction(e); // Debit transaction made <br/>            }<br/>        }<br/>        public void Credit(int creditAmount)<br/>        {<br/>            BALAmount = BALAmount + creditAmount;<br/>            BankTransEventArgs e = new BankTransEventArgs(<br/>                                       creditAmount, "Credited");<br/>            OnProcessTransaction(e); // Credit transaction made<br/>        }<br/></span><span>        public void ShowBalance()<br/>        {<br/>            BankTransEventArgs e = new BankTransEventArgs(<br/>                                       BALAmount, "Total Balance");<br/>            OnProcessTransaction(e); // Credit transaction made<br/>        }<br/>        protected virtual void OnProcessTransaction(<br/>                                       BankTransEventArgs e)<br/>        {<br/>            ProcessTransaction?.Invoke(this, e);<br/>        }<br/>    }</span></pre>
<p>You may have observed the new class that we used in the previous example, that is, <kbd>TrasactionEventArgs</kbd>. This class carries event data. We are going to define this class now, which inherits from the <kbd>EventArgs</kbd> base class. We are going to define two variables, <kbd>amt</kbd> and <kbd>type</kbd>, to carry variables to the event handler:</p>
<pre><span>public class BankTransEventArgs : EventArgs<br/>    {<br/>        private int _transactionAmount;<br/>        private string _transactionType;<br/>        public BankTransEventArgs(int amt, string type)<br/>        {<br/>            this._transactionAmount = amt;<br/>            this._transactionType = type;<br/>        }<br/>        public int TransactionAmount<br/>        {<br/>            get<br/>            {<br/>                return _transactionAmount;<br/>            }<br/>        }<br/>        public string TranactionType<br/>        {<br/>            get<br/>            {<br/>                return _transactionType;<br/>            }<br/>        }<br/>    }</span></pre>
<p>Now, let's define a subscriber class to test how our event and event handler work. Here, we will define an <kbd>AlertCustomer</kbd> method whose signature matches the delegate that was declared in the <kbd>publisher</kbd> class. Pass a reference of this method to the delegate so that it reacts to the event:</p>
<pre><span>public class EventSamples<br/>{<br/> private void AlertCustomer(object sender, BankTransEventArgs e)<br/> {<br/>  Console.WriteLine("Your Account is {0} for Rs.{1} ", <br/>                     e.TranactionType, e.TransactionAmount);<br/> }<br/> public void Run()<br/> {<br/>  Account bankAccount = new Account();<br/></span><span>  bankAccount.ProcessTransaction += new <br/>      BankTransHandler(AlertCustomer);<br/>  bankAccount.SetInitialDeposit(5000);<br/>  bankAccount.ShowBalance();<br/>  bankAccount.Credit(500);<br/>  bankAccount.ShowBalance();<br/>  bankAccount.Debit(500);<br/>  bankAccount.ShowBalance();<br/> }<br/>}</span></pre>
<p>When you execute the preceding program, for each transaction made, a transaction handler event is raised that invokes the notify-customer method and displays what type of transactions took place on the screen, as follows:</p>
<pre>//Output:<br/><strong>Your Account is InitialBalance for Rs.5000</strong><br/><strong>Your Account is Total Balance for Rs.5000</strong><br/><strong>Your Account is Credited for Rs.500</strong><br/><strong>Your Account is Total Balance for Rs.5500</strong><br/><strong>Your Account is Debited for Rs.500</strong><br/><strong>Your Account is Total Balance for Rs.5000</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about delegates and how we can define, initiate, and use them in our program. We understood variance in delegates, built-in delegates, and multicast delegates. Finally, we looked at how delegates form the base for events before understanding events, event handlers, and <kbd>EventArgs</kbd>.</p>
<p>Now, we can say that events encapsulate delegates and that delegates encapsulate methods.</p>
<p>In the next chapter, we will learn about multithreading and asynchronous processing in C#. We will understand and use threads in our program, and understand tasks, parallel classes, async, await, and much more.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Delegates are ideal for ___ because of their ability to pass a method as a parameter.
<ol>
<li>Multicast delegates</li>
<li>Built-in delegates</li>
<li>Callbacks</li>
<li>Events</li>
</ol>
</li>
</ol>
<div style="margin-left: 2em"/>
<ol start="2">
<li>What are the different ways to initiate delegates? Choose all that apply.
<ol>
<li>Anonymous methods</li>
<li>Lambda expressions</li>
<li>Named methods</li>
<li>All of the above</li>
</ol>
</li>
<li>Which method can have a derived return type than the one defined in the delegate.
<ol>
<li>Anonymous method</li>
<li>Covariance</li>
<li>Anonymous function</li>
<li>Lambda expression</li>
</ol>
</li>
<li>Which built-in delegate accepts zero or more parameters and returns void?
<ol>
<li><kbd>Action</kbd></li>
<li><kbd>Func</kbd></li>
<li><kbd>event</kbd></li>
<li><kbd>delegate</kbd></li>
</ol>
</li>
<li>Which of the following is used in the declaration of a C# event?
<ol>
<li><kbd>event</kbd></li>
<li><kbd>delegate</kbd></li>
<li><kbd>EventHandler</kbd></li>
<li><kbd>class</kbd></li>
</ol>
</li>
<li>A subscriber can notify the publisher about a change that happened to an object.
<ol>
<li>True</li>
<li>False</li>
</ol>
</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Answers</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Callbacks</strong></li>
<li><strong>All of the above</strong></li>
<li><strong>Covariance</strong></li>
<li><strong>Action</strong></li>
<li><strong>event</strong></li>
<li><strong>False</strong></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>To get a better understanding of the observer pattern, please take a look at <a href="https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern">https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern</a>.</p>
<p>The following is a good article that talks about declaring, initiating, and using delegates. Samples can also be found there: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate</a>.</p>


            </article>

            
        </section>
    </body></html>