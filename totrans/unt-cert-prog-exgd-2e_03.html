<html><head></head><body>
		<div><h1 id="_idParaDest-71"><a id="_idTextAnchor072"/><a id="_idTextAnchor073"/><em class="italic">Chapter 3</em>: Managing Scripts and Taking a Mock Test</h1>
			<p>In this chapter, we are going to continue structuring our game by applying a Singleton design pattern to our <code>GameManager</code> script. This will allow our game to move on to another scene while keeping the script managers functioning and preventing them from being wiped (thereby preserving our data). We will then make a start on other details of our script and observe how information (such as the player's lives) travels through the game's frameworks. If and when the player dies, a life is deducted. If and when the player loses all of their lives, the game over scene will be triggered.</p>
			<p>We will be extending our original code and introducing enemy points so that when we hit our enemies with bullets, the enemy will disappear as usual, but will also generate points. This scoring mechanism will be handled by a new score manager that we will be creating.</p>
			<p>We'll also be adding sound to the player's bullets, which is a straightforward task. This will introduce us to extending and tweaking our audio sources, which we'll proceed with in a later chapter.</p>
			<p>Finally, we will be quizzing ourselves with a couple of questions that suit the theme of this book, preparing you for the exam. The questions will cover what we have already learned, and if you have been following along with this book, you'll have a strong chance of passing.</p>
			<p>By the end of this chapter, we will have extended our game's framework, added more features to our game, and tested our knowledge with some Unity exam questions.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Adding a <strong class="bold">Singleton</strong> design pattern</li>
				<li>Setting up our <code>ScenesManager</code> script</li>
				<li>Creating lives for the player</li>
				<li>Scoring enemy hits</li>
				<li>Creating sounds for the player's bullets</li>
				<li>Mock test</li>
			</ul>
			<p>The next section will introduce the core exam skills that are covered in this chapter.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>The core exam skills covered in this chapter</h1>
			<p><em class="italic">Programming core interactions</em>:</p>
			<ul>
				<li>Implementing and configuring game object behavior and physics</li>
			</ul>
			<p><em class="italic">Programming for scene and environment design</em>:</p>
			<ul>
				<li>Determining scripts for implementing audio assets</li>
				<li>Identifying methods for implementing game object instantiation, destruction, and management</li>
			</ul>
			<p><em class="italic">Working in professional software development teams</em>:</p>
			<ul>
				<li>Recognizing techniques for structuring scripts for modularity, readability, and reusability</li>
			</ul>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor075"/>Technical requirements</h1>
			<p>The project content for this chapter can be found at <a href="https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_03">https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_03</a>.</p>
			<p>You can download the entirety of each chapter's project files at <a href="https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition">https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition</a>.</p>
			<p>All content for this chapter is held in the chapter's <code>unitypackage</code> file, including a <code>Complete</code> folder that holds all of the work we'll be carrying out in the chapter.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3xW4Zte">https://bit.ly/3xW4Zte</a>.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Adding a Singleton design pattern</h1>
			<p>As you will recall, back in <em class="italic">Chapter 1, Setting Up and Structuring Our Project</em>, we spoke about design patterns and how useful they are for maintaining our code. One of the design <a id="_idIndexMarker275"/>patterns we briefly covered was the Singleton pattern. Without repeating ourselves, the Singleton pattern gives us global access to code that can then be obtained at a point in our game. So, where can we see the benefits of using the Singleton design pattern? Well, we could use it so that Unity always keeps certain scripts accessible, no matter what scene we are in. We have already added a lot of structuring to our game framework and we still have a couple of manager scripts to add, such as <code>ScoreManager</code> and <code>ScenesManager</code>.</p>
			<p>Now is a good time to give all of the manager scripts global access to all other scripts in the game. Managers give a general overview of what is going on and steer which way the game needs to go without getting caught up in the details of the other scripts that are running during gameplay.</p>
			<p>In our current setup, when we run the <code>testLevel</code> scene, our <code>GameManager</code> object is in the <code>GameManager</code> script, which sets up our scene's camera and lights, is no longer present.</p>
			<p>To stop our <code>GameManager</code> game object and script from being wiped, we are going to add a Singleton design pattern so that our <code>GameManager</code> script will always be in the scene. This design pattern will also make it so that there is only one <code>GameManager</code> script (which is where this design pattern gets its name from).</p>
			<p>In the following instructions, we will extend our original <code>GameManager</code> code to work as a Singleton script. Double-click on the <code>GameManager</code> script and let's make a start:</p>
			<ol>
				<li>At the beginning of the class, we need to add a <code>static</code> variable and a <code>public static</code> property, both referring to our <code>GameManager</code> script:<pre>static GameManager instance;
public static GameManager Instance
{
  get { return instance; }
}</pre></li>
			</ol>
			<p>The reason we do this is that <code>static</code> means there is only one type of game manager. This is what we want; we don't want to have multiple instances of the same manager.</p>
			<ol>
				<li value="2">Next, we need to check and assign our <code>instance</code> variable with the <code>GameManager</code> class when the script begins with the <code>Awake</code> function.</li>
			</ol>
			<p>The <code>Awake</code> function ends with a Unity function called <code>DontDestroyOnLoad</code>. This will make sure the game object holding our <code>GameManager</code> class will not be destroyed if the scene changes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If the player dies and loses all their lives, we can move from the level scene we are on to the <code>gameOver</code> scene, but we won't wipe the <code>GameManager</code> game object from the scene as this holds the main core methods to run the game.</p>
			<ol>
				<li value="3">Add an <code>else</code> loop <a id="_idIndexMarker276"/>to prevent any possible duplicate <code>GameManager</code> game objects. We can see these two steps in the following code block:<pre>  void Awake()
  {
    if(instance == null)
    {
      instance = this;
      DontDestroyOnLoad(this);
    }
    else
    {
      Destroy(this.gameObject);
    }
    
  }</pre></li>
				<li>To make our code easier to identify, wrap the code we just typed out in the <code>Awake</code> function and put it in a method called <code>CheckGameManagerIsInTheScene</code>.</li>
				<li>Call the <a id="_idIndexMarker277"/>method from the <code>Awake</code> function.<p class="callout-heading">Tip</p><p class="callout">A similar method to <code>DontDestroyOnLoad</code> is <code>MoveGameObjectToScene</code>, which can be used to carry a single game object over to another scene. This could be useful for moving a player from one scene to another: <a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.MoveGameObjectToScene.html">https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.MoveGameObjectToScene.html</a>.</p></li>
			</ol>
			<p>That's it, our Singleton design pattern is done! The following screenshot shows a snippet of what our <code>GameManager</code> script should look like:</p>
			<div><div><img src="img/Figure_3.01_B18381.jpg" alt="Figure 3.1 – Singleton code pattern in our GameManager script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Singleton code pattern in our GameManager script</p>
			<ol>
				<li value="6">Finally, save the <code>GameManager</code> script.</li>
			</ol>
			<p>We have <a id="_idIndexMarker278"/>created a Singleton design pattern that will not be wiped away when we alternate through the scenes in our game, giving us global control of our game no matter which scene we are in.</p>
			<p>Now, we can jump into adding the <code>ScenesManager</code> script and attaching it to the same game object as <code>GameManager</code> (in its <strong class="bold">Inspector</strong> window).</p>
			<p>Setting up our ScenesManager script</p>
			<p>We will take some responsibility away from the <code>GameManager</code> script by making another <a id="_idIndexMarker279"/>manager script to be more consistent with the data and methods it holds. <code>ScenesManager</code> will take and send information to and from <code>GameManager</code>. The following diagram shows how close to <code>GameManager</code> our <code>ScenesManager</code> script is within the framework when only communicating with <code>GameManager</code>:</p>
			<div><div><img src="img/Figure_3.02_B18381.jpg" alt="Figure 3.2 – ScenesManager location in the Killer Wave UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – ScenesManager location in the Killer Wave UML</p>
			<p>The purpose of <code>ScenesManager</code>, apart from taking the workload off <code>GameManager</code>, is to deal with anything related to creating or changing a scene. This doesn't mean we only focus on adding and removing game levels; a scene can also consist of a start up logo, a title screen, a menu, and a game over screen, all of which are part of the <code>ScenesManager</code> script's responsibility.</p>
			<p>In this section, we will be setting up a scene template and two methods. The first method will be responsible for resetting the level if the player dies (<code>ResetScene()</code>); the second will be the game over screen (<code>GameOver()</code>).</p>
			<p>Let's make a start by creating a new script in the same way that we did in <a href="B18381_02_Epub.xhtml#_idTextAnchor048"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Adding and Manipulating Objects</em>. Follow these steps:</p>
			<ol>
				<li value="1">Name the script <code>ScenesManager</code>.</li>
				<li>Add the <a id="_idIndexMarker280"/>script to the <code>GameManager</code> game object. If you need further details on adding a script to a game object, check out the <em class="italic">Adding our script to a game object</em> section of the previous chapter.</li>
				<li>With our <code>GameManager</code> game object selected from the <code>GameManager</code> and <code>ScenesManager</code> scripts attached, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_3.03_B18381.jpg" alt="Figure 3.3 – GameManager game object holding two scripts (GameManager and ScenesManager)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – GameManager game object holding two scripts (GameManager and ScenesManager)</p>
			<p>Let's open the <code>ScenesManager</code> script and start coding:</p>
			<ol>
				<li value="1">Because we are obviously going to be closing and loading scenes, we are going to need to import an extra library into our <code>ScenesManager</code> script that supports these operations:<pre><strong class="bold">using UnityEngine.SceneManagement;</strong>
<strong class="bold">using UnityEngine;</strong></pre></li>
				<li>We will have a public class in our script name, followed by the usual <code>MonoBehaviour</code> being inherited:<pre><strong class="bold">public class ScenesManager : MonoBehaviour</strong>
<strong class="bold">{</strong></pre></li>
			</ol>
			<p>Now, we need <a id="_idIndexMarker281"/>to create a list of references for our scenes, as mentioned earlier. I currently have the following scenes labeled:</p>
			<ul>
				<li><code>bootUp</code>: Credits to game</li>
				<li><code>title</code>: Name of the game with an instruction to start</li>
				<li><code>shop</code>: Buy upgrades before starting the game</li>
				<li><code>level1</code>: First level</li>
				<li><code>level2</code>: Second level</li>
				<li><code>level3</code>: Final level</li>
				<li><code>gameOver</code>: Game over—delays until going back to the title scene</li>
			</ul>
			<p>We will be labeling these scenes as enumerations (which are denoted as <code>enum</code> in the C# language). These values stay consistent.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you would <a id="_idIndexMarker282"/>like to know more about enumeration, check out <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum</a>.</p>
			<ol>
				<li value="3">Enter the following code into the <code>ScenesManager</code> script:<pre>  Scenes scenes;
  public enum Scenes
  {
    bootUp,
    title,
    shop,
    level1,
    level2,
    level3,
    gameOver
  }</pre></li>
			</ol>
			<p>We will be <a id="_idIndexMarker283"/>making and adding these scenes in their respective order in the Unity Editor later on in the book. Before we do so, let's add two methods, starting with the <code>ResetScene()</code> method, which is typically used when the player dies and the current level is reloaded. The other method, <code>GameOver()</code>, is typically called when the player loses all of their lives or when the game is complete.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor077"/>Adding the ResetScene() method</h2>
			<p>The <code>ResetScene()</code> method will <a id="_idIndexMarker284"/>be called when the player loses a <a id="_idIndexMarker285"/>life but still has another remaining. In this short method, we will set its accessibility to <code>public</code> and it returns nothing (<code>void</code>).</p>
			<p>Within this method, we will refer to Unity's <code>SceneManager</code> script (not to be confused with our <code>ScenesManager</code> class), followed by Unity's <code>LoadScene</code> method. We now need to provide a parameter to tell <code>LoadScene</code> which scene we are going to load.</p>
			<p>We use Unity's <code>SceneManager</code> script again, but this time we use <code>GetActiveScene().buildIndex</code>, which basically means getting the value number of the scene. We send this scene number to <code>SceneManager</code> to load the scene again (<code>LoadScene</code>):</p>
			<pre>  public void ResetScene()
  {
    SceneManager.LoadScene(SceneManager.GetActiveScene().    buildIndex);
  }</pre>
			<p>A small <a id="_idIndexMarker286"/>but effective method, this <a id="_idIndexMarker287"/>can be called whenever we need the scene to reset. Let's now move on to the <code>GameOver()</code> method.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>Adding the GameOver() method</h2>
			<p>This method, as you may expect, is called when the player has lost all of their lives and the game <a id="_idIndexMarker288"/>ends, which means we need <a id="_idIndexMarker289"/>to move the player on to another scene.</p>
			<p>In this method, we continue adding to the <code>ScenesManager</code> script:</p>
			<pre>  public void GameOver()
  {
    SceneManager.LoadScene("gameOver");
  }
}</pre>
			<p>Similar to the previous method, we refer to this method as <code>public</code> with <code>void return</code>. Within the method, we call the same Unity function, <code>SceneManager.LoadScene</code>, but this time, we call the <code>SceneManager</code> Unity function, followed by the name of the scene we want to load by name (in this case, <code>gameOver</code>).</p>
			<p class="callout-heading">More Information</p>
			<p class="callout"><code>SceneManager.LoadScene</code> also <a id="_idIndexMarker290"/>offers a <code>LoadSceneMode</code> function, which gives us the option of using one of two properties. By default, the first property is <code>Single</code>, which closes all the scenes and loads the scene we want. The second property is <code>Additive</code>, which adds the next scene alongside the current one. This could be useful when swapping out scenes, such as a loading screen, or keeping <a id="_idIndexMarker291"/>the previous scene's settings. For more information about <code>LoadScene</code>, check out <a href="https://docs.unity3d.com/ScriptReference/SceneManagement.LoadSceneMode.html">https://docs.unity3d.com/ScriptReference/SceneManagement.LoadSceneMode.html</a>.</p>
			<p>That's our <code>GameOver()</code> method <a id="_idIndexMarker292"/>made, and when used in the same way as our <code>ResetScene()</code> method, it can be called globally. <code>GameOver()</code> can be called not only when the player loses all their lives but also when the user completes the game. It can also be used if, somehow, the game crashes, and as a default reset, we proceed to the <code>gameOver</code> scene.</p>
			<p>The next method to bring into our <code>ScenesManager</code> script is <code>BeginGame()</code>. This method is called when we need to start playing our game.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Adding the BeginGame() method</h2>
			<p>In this <a id="_idIndexMarker293"/>short section, we will add the <code>BeginGame()</code> method to our <code>ScenesManager</code> script as this will be called to start playing <a id="_idIndexMarker294"/>our game after visiting the <code>shop</code> scene, which we will cover in <a href="B18381_05_Epub.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a><em class="italic">,</em> <em class="italic">Creating a Shop Scene for Our Game</em>.</p>
			<p>With the <code>ScenesManager</code> script still open from the previous section, add the following method:</p>
			<pre>   public void BeginGame()
  {
    SceneManager.LoadScene("testLevel");
  }</pre>
			<p>The code that we have just entered makes a direct call to run the <code>testLevel</code> scene, which we play our game in already. However, as our game begins to grow, we will use more than one scene.</p>
			<p>The next thing to do is to create our scenes and add them to the Unity build menu, so let's do that next. Remember to save the <code>ScenesManager</code> script before returning to the Unity Editor.</p>
			<p>Adding scenes to our Build Settings window</p>
			<p>Our game will consist of multiple scenes through which the player will need to navigate before <a id="_idIndexMarker295"/>they can fly their spaceship through the levels. This will result in them either dying or completing each <a id="_idIndexMarker296"/>level and the game, and then being taken <a id="_idIndexMarker297"/>back to the <code>title</code> scene. This is also known as a game loop. Let's start by going back to Unity and, in the Project window, creating and adding our new scenes. Follow these steps:</p>
			<ol>
				<li value="1">Go to the <code>Assets/Scene</code> folder that we created at the beginning of the previous chapter.</li>
				<li>Inside the <strong class="bold">Scene</strong> folder, in the open space, right-click so that the dropdown appears, and then click <strong class="bold">Create</strong>, followed by <strong class="bold">Scene</strong>, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_3.04_B18381.jpg" alt="Figure 3.4 – Creating an empty scene in the Unity Editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Creating an empty scene in the Unity Editor</p>
			<ol>
				<li value="3">A scene <a id="_idIndexMarker298"/>file will appear. Rename it <code>bootUp</code>.</li>
				<li>Repeat <a id="_idIndexMarker299"/>this process for the <code>shop</code>, <code>level1</code>, <code>level2</code>, <code>level3</code>, <code>gameOver</code>, and <code>title</code> scene files.</li>
			</ol>
			<p>Once <a id="_idIndexMarker300"/>we have made all of our scenes, we need to let Unity know that we want these scenes to be recognized and applied to the project build order. This is a similar process to what we did in the last chapter when adding <code>testLevel</code> to the <strong class="bold">Build Settings</strong> window. To apply the other scenes to the list, do the following:</p>
			<ol>
				<li value="5">From the top of the Unity Editor, click on <strong class="bold">File</strong> | <strong class="bold">Build Settings</strong>.</li>
				<li>The <code>testLevel</code> in the list already. If you don't, fear not as we will be adding all our scenes to the <strong class="bold">Scenes In Build</strong> list.</li>
				<li>From <a id="_idIndexMarker301"/>the <strong class="bold">Project</strong> window, click and <a id="_idIndexMarker302"/>drag each scene into the <strong class="bold">Build Settings | Scenes</strong> <strong class="bold">in</strong> <strong class="bold">Build</strong> open space.</li>
			</ol>
			<p>Once <a id="_idIndexMarker303"/>we have added all the scenes, order them as follows:</p>
			<ul>
				<li><code>bootUp</code></li>
				<li><code>title</code></li>
				<li><code>shop</code></li>
				<li><code>testLevel</code></li>
				<li><code>level1</code></li>
				<li><code>level2</code></li>
				<li><code>level3</code></li>
				<li><code>gameOver</code><p class="callout-heading">Tip</p><p class="callout">Note that each scene automatically has a camera and a light by default in its <strong class="bold">Hierarchy</strong> window. This is fine and we will customize them later on in this book.</p></li>
			</ul>
			<p>The <strong class="bold">Build Settings</strong> window should now look as follows:</p>
			<div><div><img src="img/Figure_3.05_B18381.jpg" alt="Figure 3.5 – Build Settings current Scenes In Build list order&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Build Settings current Scenes In Build list order</p>
			<p>The <a id="_idIndexMarker304"/>reason why we <a id="_idIndexMarker305"/>are putting our scenes in this order is so that <a id="_idIndexMarker306"/>there is a logical progression in the levels. As you can see at the far right of each scene in the previous screenshot, the scenes are counted in increments.  So, the first level to load will be the <code>bootUp</code> scene.</p>
			<p>Now that we have added multiple scenes to our game, we can consider the fact that we may <a id="_idIndexMarker307"/>not want our camera <a id="_idIndexMarker308"/>and light setup methods in our <code>GameManager</code> method <a id="_idIndexMarker309"/>to run in every scene of our game. Let's briefly return to our <code>GameManager</code> script and update our <code>LightSetup</code> and <code>CameraSetup</code> methods, as well as a few other things.</p>
			<h4>Updating our GameManager script</h4>
			<p>In this <a id="_idIndexMarker310"/>section, we are going to return to the <code>GameManager</code> script and make it so that the <code>CameraSetup</code> and <code>LightSetup</code> methods are called when we are controlling our spaceship only.</p>
			<p>To update our <code>GameManager</code> script to support various scenes for our lights and camera, we need to do the following:</p>
			<ol>
				<li value="1">In the Unity Editor, navigate to <code>Assets/Script</code> from the <strong class="bold">Project</strong> window.</li>
				<li>In the <code>GameManager</code> script, scroll down to the <code>Start</code> function and remove the <code>LightSetup();</code> and <code>CameraSetup();</code> methods.</li>
				<li>Next, we will enter two static global variables at the top of the <code>GameManager</code> script with the rest of the global variables:<pre>public static int currentScene = 0;
public static int gameLevelScene = 3;
bool died = false;
public bool Died
{
 get {return died;}
 set {died = value;}
}</pre></li>
			</ol>
			<p><code>currentScene</code> is an integer that will keep the number of the current scene we are on, which we will use in the following method. The second variable, <code>gameLevelScene</code>, will hold the first level we play, which we will use later on in this chapter.</p>
			<ol>
				<li value="4">Still in <a id="_idIndexMarker311"/>the <code>GameManager</code> script, create an <code>Awake</code> function and enter the following code:<pre>void Awake()
{ 
    CheckGameManagerIsInTheScene();
    currentScene = UnityEngine.SceneManagement.SceneManager.
        GetActiveScene().buildIndex;
    LightAndCameraSetup(currentScene);
}</pre></li>
			</ol>
			<p>In the code we just entered, we store the <code>buildIndex</code> number (the numbers we have to the right of each scene in our Build Settings window from the previous section) in the <code>currentScene</code> variable. We then send the <code>currentScene</code> value to our new <code>LightandCameraSetup</code> method.</p>
			<ol>
				<li value="5">The last piece of code to add to our <code>GameManager</code> script is the <code>LightandCameraSetup</code> method, which takes an integer parameter:<pre>  void LightAndCameraSetup(int sceneNumber)
  {
    switch (sceneNumber)
    {
      //testLevel, Level1, Level2, Level3
      case 3 : case 4 :case 5: case 6:
      {
        LightSetup();
        CameraSetup();
        break;
      }
    }
  }</pre></li>
			</ol>
			<p>In the code we just wrote, we ran a <code>switch</code> statement to check the value of the <code>sceneNumber</code> variable, and if it falls into the <code>3</code>, <code>4</code>, <code>5</code>, or <code>6</code> values, we run <code>LightSetup</code> and <code>CameraSetup</code>.</p>
			<ol>
				<li value="6">Save the <code>GameManager</code> script.</li>
			</ol>
			<p>To reflect <a id="_idIndexMarker312"/>on this section, we have created a structure of empty scenes that will each serve a purpose in our game. We have also created a <code>ScenesManager</code> script that will either reset a scene when the player wins or dies and/or move to the game over scene.</p>
			<p>Now that we have our scenes in place and the start of the <code>ScenesManager</code> script has been built, we can focus on the player's life system.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/>Creating lives for the player</h1>
			<p>In this section, we are going to make it so that the player has a set number of lives. If and when <a id="_idIndexMarker313"/>the player collides with an enemy, the player will die, the scene will reset, and a life will be deducted from the player. When all the lives are gone, we will introduce the game over scene.</p>
			<p>We will be working with the following scripts in this section:</p>
			<ul>
				<li><code>GameManager</code></li>
				<li><code>SceneManager</code></li>
				<li><code>Player</code></li>
			</ul>
			<p>Let's start <a id="_idIndexMarker314"/>by revisiting the <code>GameManager</code> script and setting up the ability to give and take the player's lives:</p>
			<ol>
				<li value="1">Open the <code>GameManager</code> script and enter the following code:<pre><strong class="bold">public static int playerLives = 3;</strong></pre></li>
			</ol>
			<p>At the top of the script, just after entering the class and inheritance, enter a <code>static</code> (meaning only one) integer type labeled <code>playerLives</code>, along with the value <code>3</code>.</p>
			<p>Next, we need to create a new method for our <code>GameManager</code> script that will ensure the player loses a life. After we make this new method, the <code>Player</code> script will call it when it makes contact with an enemy.</p>
			<p>Let's continue with our <code>GameManager</code> script.</p>
			<ol>
				<li value="2">To create the <code>LifeLost</code> method, enter the following code in our <code>GameManager</code> class:<pre><strong class="bold"> public void LifeLost()</strong>
<strong class="bold">{</strong></pre></li>
			</ol>
			<p>We need this to be a <code>public</code> method so that it can be accessed from outside of the script. It's set to <code>void</code>, meaning nothing is returned from the method, and it's followed by the name of the method with empty brackets as it isn't taking any arguments.</p>
			<ol>
				<li value="3">So, within the <code>LifeLost()</code> method, we will check the player's lives with an <code>if</code> statement with the following code:<pre>    //lose life
    if (playerLives &gt;= 1)
    {
      playerLives--;
      Debug.Log("Lives left: "+playerLives);
      GetComponent&lt;ScenesManager&gt;().ResetScene();
    }</pre></li>
			</ol>
			<p>After reviewing the <code>if</code> statement code we have entered, we will make a start by adding a comment to let ourselves or other developers know what this condition is doing (<code>//lose life</code>). We will then add the <code>if</code> statement condition, checking <a id="_idIndexMarker315"/>whether the player has more than or equal to one life left. If the player does have one or more lives left, we will deduct the player's lives by 1 with the <code>--</code> operator, which is just a quicker way of saying <code>playerLives = playerLives - 1;</code>.</p>
			<p>The line of code following on from the deduction of the player's lives isn't required, but it will notify us, in the Unity Editor <strong class="bold">Console</strong> window, with an information box telling us how many lives the player has left (for debugging purposes), as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.06_B18381.jpg" alt="Figure 3.6 – Console window displaying how many lives the player has left&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Console window displaying how many lives the player has left</p>
			<p>Following on from displaying how many lives the player has left in the <code>ScenesManager</code> script, which is attached to the <code>GameManager</code> game object. We can use <code>GetComponent</code> to access the <code>ScenesManager</code> script's <code>ResetScene</code> method, which will reset our scene.</p>
			<ol>
				<li value="4">We will now enter the <code>else</code> condition, which indicates that the player has died:<pre>    else
    {
      playerLives = 3;
      GetComponent&lt;ScenesManager&gt;().GameOver();
    }
}</pre></li>
			</ol>
			<p>If our player doesn't have any more lives left, that means the <code>if</code> statement condition isn't met, so we <a id="_idIndexMarker316"/>can then offer an <code>else</code> condition. Within the scope of our <code>else</code> statement, we reset our player's lives back to <code>3</code>.</p>
			<p>We then access the <code>GameOver()</code> method from the <code>ScenesManager</code> class, which will take us from the scene we are on over to the <code>gameOver</code> scene.</p>
			<p>Lastly, all that we need to do now is to make our <code>Player</code> script call the <code>LifeLost</code> method when the player has collided with the enemy or the enemy's bullets:</p>
			<ol>
				<li value="1">Save the <code>GameManager</code> script.</li>
				<li>From the <code>Player</code> script (<code>Assets/Script</code>).</li>
				<li>Scroll down to its <code>Die</code> method.</li>
				<li>Starting from above the destroy line (<code>Destroy(this.gameObject);</code>), enter the following code:<pre><strong class="bold">GameManager.Instance.LifeLost();</strong></pre></li>
			</ol>
			<p>Note that we can call the <code>GameManager</code> script directly without finding the game object in the scene by using code such as <code>GetComponent</code> to acquire a script. This is the power of using the Singleton design pattern, calling directly to the <code>LifeLost</code> method.</p>
			<ol>
				<li value="5">Save the <code>Player</code> script.</li>
				<li>Press <strong class="bold">Play</strong> in the Unity Editor and collide with an enemy.</li>
			</ol>
			<p>The level should reset with a message in the <code>testLevel</code> to <code>gameOver</code>.</p>
			<p>The following screenshot shows the <code>testLevel</code> to the <code>gameOver</code> scene:</p>
			<div><div><img src="img/Figure_3.07_B18381.jpg" alt="Figure 3.7 – Players lives being depleted and the gameOver scene being loaded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Players lives being depleted and the gameOver scene being loaded</p>
			<p>With minimal code, we have now made it so that our player has a number of lives. We have introduced a <code>ScenesManager</code> script into our game framework that talks directly to <code>GameManager</code>, regardless of restarting and changing scenes.</p>
			<p>As a side note, you might have noticed that when we changed to the <code>gameOver</code> scene, our <code>GameManager</code> game object was carried over into the <code>gameOver</code> scene. If you recall the <em class="italic">Adding a Singleton design pattern</em> section, we set up the <code>CheckGameManagerIsInTheScene</code> method, which is called in the <code>Awake</code> function. This means that just because we are in a different scene, it doesn't mean the <code>Awake</code> function is called again.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Remember, the <code>Awake</code> function will only run when the script is active and will only run once, even if the script is attached to a game object and is carried through scenes.</p>
			<p>This is because our <code>gameOver</code> scene only carried the <code>GameManager</code> game object over to the <code>gameOver</code> scene. It wasn't activated, which means the <code>Awake</code> function wasn't called.</p>
			<p>We have <a id="_idIndexMarker318"/>our basic lives and scene structure, and we have also used the <strong class="bold">Console</strong> window to help us acknowledge the changes.</p>
			<p>Before we move on, you may notice that when the player dies, the lights get darker in the scene. The following screenshot shows what I mean:</p>
			<div><div><img src="img/Figure_3.08_B18381.jpg" alt="Figure 3.8 – Lights have darkened in our game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Lights have darkened in our game</p>
			<p>As you can see in the previous screenshot, on the left is the scene we start with, and on the right is the scene when the player has died. To fix this, we just need to make it so that we generate our lighting manually instead of it being autogenerated by Unity.</p>
			<p>To prevent our lighting from going dark between scenes, we need to do the following:</p>
			<ol>
				<li value="1">At the top of the Unity Editor, click on <strong class="bold">Window</strong> | <strong class="bold">Lighting</strong> | <strong class="bold">Settings</strong>.</li>
				<li>The <strong class="bold">Lighting Settings</strong> window will appear. At the bottom of the window, uncheck <strong class="bold">Auto Generate</strong> and click on the button next to it, <strong class="bold">Generate Lighting</strong>. Use the following screenshot for reference:</li>
			</ol>
			<div><div><img src="img/Figure_3.09_B18381.jpg" alt="Figure 3.9 – Unchecked Auto Generate box and the Generate Lighting button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Unchecked Auto Generate box and the Generate Lighting button</p>
			<ol>
				<li value="3">This will take a minute as Unity will be setting up the new light settings. Once this is done, save the Unity project and that should fix it.</li>
			</ol>
			<p>Note that <a id="_idIndexMarker319"/>we will likely need to set the lighting manually for other scenes, such as the other levels and the <code>shop</code> scene, later on in this book.</p>
			<p>Let's now turn our focus to the enemy and add some functionality so that when it is destroyed by the player, we can add a score to <code>ScoreManager</code>, which is a new script that we will be making next.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor081"/>Scoring enemy hits</h1>
			<p>As with most games, we need <a id="_idIndexMarker320"/>a scoring system to show how well the player has done at the end of the game. Typically, with side-scrolling shooter games, the player is rewarded for each kill they make. If we turn to our game framework diagram, we can see that <code>ScoreManager</code> is hooked up to <code>GameManager</code> like <code>ScenesManager</code> was:</p>
			<div><div><img src="img/Figure_3.10_B18381.jpg" alt="Figure 3.10 – Killer Wave UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Killer Wave UML</p>
			<p>Our code for adding a scoring system will once again be minimal. We also want flexibility so that different <a id="_idIndexMarker321"/>enemies are worth different points. We also want it so that when we add another enemy to our game with a different scoring point, we can avoid altering our code each time.</p>
			<p>We will be working with the following scripts in this section:</p>
			<ul>
				<li><code>EnemyWave</code></li>
				<li><code>ScoreManager</code></li>
				<li><code>ScenesManager</code></li>
				<li><code>SOActorModel</code></li>
			</ul>
			<p>Since the scoring system is an integral factor in our game, it would make sense to add a simple integer to <code>SOActorModel</code> that injects common values into our game objects. This trend will then follow on to other scripts. Let's start adding some code to our already-made scripts before we introduce <code>ScoreManager</code>.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/>Preparing the code for the ScoreManager script</h2>
			<p>If you recall <a href="B18381_01_Epub.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up and Structuring Our Project</em>, we spoke about the SOLID principles and how important it is to add to our code rather than change it, or we risk errors <a id="_idIndexMarker322"/>and our code may start mutating and <a id="_idIndexMarker323"/>eventually become unfit for purpose. In order to prepare, we will add code to the scripts that we have already made to fit our <code>ScoreManager</code> script into place. Let's start with <code>SOActorModel</code> first. Follow these steps:</p>
			<ol>
				<li value="1">Open the <code>SOActorModel</code> script from the <strong class="bold">Project</strong> window.</li>
				<li>Anywhere within our list of variables in the <code>SOActorModel</code> script, add the following code, which will be used to contain the enemy's score:<pre><strong class="bold">public int score;</strong></pre></li>
				<li>Save the <code>SOActorModel</code> script.</li>
			</ol>
			<p>Before we add more code to the other scripts to fit <code>ScoreManager</code> into our game, we need to acknowledge that we have made a change to our <code>ScriptableObject</code> template.</p>
			<p>Let's check our <code>BasicWave Enemy</code> scriptable object in the Unity Editor. Follow these steps:</p>
			<ol>
				<li value="1">From the <code>Assets/ScriptableObject</code> folder.</li>
				<li>Click once on <strong class="bold">BasicWave Enemy</strong> and you will see that the <strong class="bold">Inspector</strong> window has a <strong class="bold">Score</strong> input field.</li>
				<li>Give the <code>BasicWave Enemy</code> a value of your choice. I'm giving it a value of <code>200</code>. It really doesn't matter what value you give it as long as it's more than <code>0</code>. The following screenshot shows the <strong class="bold">BasicWave Enemy</strong> section with its updated <strong class="bold">Score</strong> value:</li>
			</ol>
			<div><div><img src="img/Figure_3.11_B18381.jpg" alt="Figure 3.11 – enemy_wave score property and value added&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – enemy_wave score property and value added</p>
			<p>We have updated the <code>BasicWave Enemy</code> scriptable object. We now need to focus on the <code>EnemyWave</code> script to create and receive this new variable.</p>
			<ol>
				<li value="4">Open the <code>EnemyWave</code> script.</li>
				<li>At the <a id="_idIndexMarker324"/>top of the script, where <a id="_idIndexMarker325"/>we have our <code>health</code>, <code>travelSpeed</code>, and other global variables, add an extra variable to the list:<pre><strong class="bold">int score;</strong></pre></li>
			</ol>
			<p>We now need to update the <code>score</code> variable from the <code>ScriptableObject</code> value.</p>
			<ol>
				<li value="6">In the <code>EnemyWave</code> script, scroll down until you find the <code>ActorStats</code> method, then add the following extra line of code:<pre><strong class="bold">score = actorModel.score;</strong></pre></li>
			</ol>
			<p>The <code>EnemyWave</code> script now has a <code>score</code> variable that is set from the value given to it by <code>SOActorModel</code>. The last thing we need to do is send the score value to <code>ScoreManager</code> when the enemy dies due to the actions of the player. Before we do that, let's create and code our <code>ScoreManager</code> script.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Setting up our ScoreManager script</h2>
			<p>The purpose <a id="_idIndexMarker326"/>of the <code>ScoreManager</code> script is to total up the score of the player during their game, concluding <a id="_idIndexMarker327"/>when they arrive at the <code>gameOver</code> scene. We could also give the <code>ScoreManager</code> script other score-related functionality, such as the ability to store our score data on the device that we are playing the game on or to send the score data to a server for an online scoreboard. For now, we will keep things simple and just collect the player's score.</p>
			<p>We can create and add our <code>ScoreManager</code> script to the game framework, as follows:</p>
			<ol>
				<li value="1">Create and attach a script called <code>ScoreManager</code> to the <code>GameManager</code> game object, similar to how we did with <code>ScenesManager</code>.</li>
			</ol>
			<p>If you can't remember how to do this, then check out the <em class="italic">Setting up our ScenesManager script</em> section of this chapter. The following screenshot shows <code>ScoreManager</code> attached to the <code>GameManager</code> game object in the <strong class="bold">Inspector</strong> window:</p>
			<div><div><img src="img/Figure_3.12_B18381.jpg" alt="Figure 3.12 – ScoreManager script added to the GameManager game object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – ScoreManager script added to the GameManager game object</p>
			<p>Next, we are going to open the <code>ScoreManager</code> script and add code that will hold and send score data. Open the <code>ScoreManager</code> script and enter the following code:</p>
			<pre><strong class="bold">using UnityEngine;</strong></pre>
			<p>By default, we require the <code>UnityEngine</code> library, as previously mentioned.</p>
			<ol>
				<li value="2">Continue <a id="_idIndexMarker328"/>by checking and <a id="_idIndexMarker329"/>entering the name of the class:<pre><strong class="bold">public class ScoreManager : MonoBehaviour</strong>
<strong class="bold">{</strong></pre></li>
			</ol>
			<p>This is a public class, with <code>ScoreManager</code> inheriting <code>MonoBehaviour</code> to increase the functionality of the script.</p>
			<ol>
				<li value="3">Next, we add our variables and properties to our script. The only value we are concerned about is <code>playerScore</code>, which is private to the script (because we don't want other classes to have access). This variable is also set to <code>static</code>, meaning we don't need duplicate references for this variable.</li>
			</ol>
			<p>Following on from this is our <code>public</code> property, which gives outside classes access to the <code>playerScore</code> variable. As you'll notice, the <code>PlayerScore</code> property returns an integer. Within this property, we use the <code>get</code> accessor to return our private <code>playerScore</code> integer. It is a good habit to keep our variables private, or you risk exposing your code to other classes, which can result in errors. The following code shows you how to complete this step:</p>
			<pre>    static int playerScore;
    public int PlayersScore 
    {
        get
        {
            return playerScore;
        }
    }</pre>
			<p class="callout-heading">Accessors</p>
			<p class="callout">To find out more about accessors, check out <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get</a>.</p>
			<ol>
				<li value="4">We will <a id="_idIndexMarker330"/>now move on to the <code>SetScore</code> method; it is public and doesn't return a value (<code>void</code>), with the <code>SetScore</code> name taking in an integer parameter named <code>incomingScore</code>. Within <a id="_idIndexMarker331"/>this method, we use <code>incomingScore</code> to add to the <code>playerScore</code> script (as its total score):<pre>  public void SetScore(int incomingScore)
    {
        playerScore += incomingScore;
    }</pre></li>
				<li>The last method to add is the <code>ResetScore</code> method. Enter the following code:<pre> public void ResetScore()
  {
    playerScore = 00000000;
  }
}</pre></li>
			</ol>
			<p>We can call this method at the beginning or end of a game to stop the score from carrying on into the next game.</p>
			<ol>
				<li value="6">Save the script.</li>
			</ol>
			<p>As mentioned earlier, we can now return to the <code>EnemyWave</code> script to send the value of the enemy's score points to the <code>ScoreManagers</code> method, <code>SetScore</code>, thereby adding them to the player's total score:</p>
			<ol>
				<li value="1">Open the <code>EnemyWave</code> script from the <code>OnTriggerEnter</code> Unity function.</li>
				<li>Within the scope of the <code>if</code> statement labeled <code>if (health &lt;= 0)</code>, enter the following line of code at the top of its scope:<pre><strong class="bold">GameManager.Instance.GetComponent&lt;ScoreManager&gt;().SetScore(score);</strong></pre></li>
			</ol>
			<p>When <a id="_idIndexMarker332"/>this particular enemy <a id="_idIndexMarker333"/>dies as a result of the player, this line of code will send the enemy's <code>score</code> value directly to the <code>playerScore</code> variable and increment it toward its total until the player loses all of their lives.</p>
			<ol>
				<li value="3">Finally, to confirm the score has totaled correctly, let's do what we did before with the <code>playerLives</code> integer in the <code>LifeLost</code> method of the <code>GameManager</code> script and add a <code>Debug.Log</code> message to the <strong class="bold">Console</strong> window.</li>
				<li>In the <code>ScenesManager</code> script under the <code>GameOver()</code> method, add the following line of code at the top within its scope:<pre>Debug.Log("ENDSCORE: " +
  GameManager.Instance.GetComponent&lt;ScoreManager&gt;
     ().PlayersScore);</pre></li>
			</ol>
			<p>This code will tell us how much the player has scored because it directly accesses <code>ScoreManager</code> and grabs the <code>PlayerScore</code> property when the game is over. The following screenshot shows an example of a totaled score:</p>
			<div><div><img src="img/Figure_3.13_B18381.jpg" alt="Figure 3.13 – Game over score value displayed in the Console window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Game over score value displayed in the Console window</p>
			<ol>
				<li value="5">Finally, save all the scripts.</li>
			</ol>
			<p>In this section, we introduced the <code>ScoreManager</code> script with its basic working structure of totaling <a id="_idIndexMarker334"/>up our end score and displaying <a id="_idIndexMarker335"/>the final count in the <strong class="bold">Console</strong> window. We have also added more code to a selection of scripts without deleting and changing any of their content. Next, we will be doing something different that doesn't involve any coding but gets us more familiar with Unity's sound components.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor084"/>Creating sounds for the player's bullets</h1>
			<p>Up until now, our game has been silent, but sound is an important factor in any game. In this section, we will <a id="_idIndexMarker336"/>be introducing our first sound component. We will <a id="_idIndexMarker337"/>make a start by creating sound effects for when our player fires a bullet.</p>
			<p>Feel free to add your own type of bullet sound if you wish. You can add sound to your player's standard bullets as follows:</p>
			<ol>
				<li value="1">In the Unity Editor, navigate to the <code>Resources</code> folder. Name the new folder <code>Sound</code>.</li>
				<li>Drag and drop the <code>Player_Bullet</code> prefab from the <strong class="bold">Project</strong> panel into the <strong class="bold">Hierarchy</strong> panel.</li>
				<li>With <code>Player_Bullet</code> still selected, click on the <strong class="bold">Add Component</strong> button in the <strong class="bold">Inspector</strong> panel.</li>
				<li>In its dropdown, start typing (and select) <code>Audio Source</code>.</li>
				<li>Drag and <a id="_idIndexMarker338"/>drop the <code>PlayerLaser.mp3</code> file into the <code>Player_Bullet</code> selected. The audio file at the bottom left needs to be dragged into the <strong class="bold">Audio Source</strong> component at the right:</li>
			</ol>
			<div><div><img src="img/Figure_3.14_B18381.jpg" alt="Figure 3.14 – Adding sound file to the Player_Bullet's Audio Source game object in the &#13;&#10;Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Adding sound file to the Player_Bullet's Audio Source game object in the Inspector window</p>
			<ol>
				<li value="6"><code>Player_Bullet</code> is instantiated, the sound will play.</li>
				<li>If the volume is too high, simply lower it in the <strong class="bold">Audio Source</strong> component of the <strong class="bold">Inspector</strong> window.<p class="callout-heading">Information</p><p class="callout">As well as the <strong class="bold">Volume</strong> option in the <strong class="bold">Audio Source</strong> component, there is <strong class="bold">Pitch</strong> to change the sound of our bullet and <strong class="bold">Stereo Pan</strong> to make the sound more dominant in the left or right speaker. Finally, because this is a two-dimensional game, we don't want the sound to be affected by how close our camera is to the bullet. So, we slide the <strong class="bold">Spatial Blend</strong> toggle all the way to the left to make sure it is not affected by its distance.</p></li>
				<li>Finally, click on <code>Player_Bullet</code> prefab and remove the bullet from the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Play the scene and start firing. You will hear laser noises, and, in the scene view, you will see speaker symbols now attached to the player's bullets.</li>
			</ol>
			<p>That brings us <a id="_idIndexMarker339"/>to the end of this short section on audio, but we will cover more on audio throughout this book. Don't forget that if you get stuck at any point, check the <code>Complete</code> folder for this chapter and compare the scenes and code to make sure nothing is missing.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor085"/>Summary</h1>
			<p>In this chapter, we have extended our game framework structure by implementing and reinforcing the <code>GameManager</code> script by extending its code. This means that it will never be deleted, regardless of scene changes. We have also introduced the score and scenes managers, which were originally planned in our game framework. These two additional managers take responsibility away from the game manager and add additional features to your game. We ensured these scripts don't mutilate our original code (removing, overflowing, or compensating for our game manager). Your game now has a working scoring system, as well as multiple scenes that can be restarted and changed with very little code. We also introduced sound, which we'll implement in more detail in later chapters.</p>
			<p>In the next chapter, we'll focus less on code-heavy content and instead concern ourselves with the art of the game. Even though we are programmers, we need to understand how to manipulate assets and how to animate with Unity's API. With just a little bit of coding, this will allow us to understand the connection between the Editor and our script. We'll also touch on some particle effects.</p>
			<p>Well done—you've done and covered a lot. Before we move on, have a go at the following questions. They resemble what you will encounter in your programmer exam.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor086"/>Mock test</h1>
			<p>This is your first mini mock test. These tests represent sections of your final Unity exam. This first mini mock test consists of just five questions. Later on in this book, we'll introduce more mini mock tests with more questions.</p>
			<p>Fortunately, you will only be tested on what we have covered so far:</p>
			<ol>
				<li value="1">You have been asked to develop a horror survival game where your player relies on a pocket torch. Here is what you've coded so far:<pre>void Start()
{
    Light playersTorch = GetComponent&lt;Light&gt;();
    playersTorch.lightMapBakeType = LightMapBakeType.    Mixed;
    playersTorch.type = LightType.Area;
    playersTorch.shadows = LightShadows.Soft;
    playersTorch.range = 5f;
}</pre></li>
			</ol>
			<p>You notice, however, that the player's torch isn't casting any light or shadows. What should you change for this code to work as desired?</p>
			<ol>
				<li>Set <code>playersTorch.lightBakeType</code> to <code>LightmapBakeType.Realtime</code>.</li>
				<li>Set <code>playersTorch.range</code> to <code>10</code>.</li>
				<li>Set <code>playersTorch.shadows</code> to <code>LightShadows.Hard</code>.</li>
				<li>Set <code>playersTorch.type</code> to <code>LightType.Point</code>.</li>
			</ol>
			<ol>
				<li value="2">You have started creating your first indie game, Super Moped Racer 64. You have coded your input controls to work with a joystick and started testing your moped around corners. You've noticed that after taking the moped around the first corner, the moped continues turning even after you've let go of the joystick.</li>
			</ol>
			<p>You've checked your code and the joystick and both seem to be working fine, suggesting the issue is with the input manager.</p>
			<p>What change should you make within the input manager?</p>
			<ol>
				<li>Increase the gravity.</li>
				<li>Set <code>Snap</code> to <code>true</code>.</li>
				<li>Increase <code>Deadzone</code>.</li>
				<li>Decrease <code>Sensitivity</code>.</li>
			</ol>
			<ol>
				<li value="3">You have started to template a game framework with pen and paper. You have drawn up several manager scripts that will all lead to the creation of a single <code>GameManager</code> script. You only require one <code>GameManager</code> script, which will always be in your scene.</li>
			</ol>
			<p>Which design pattern suits having a <code>GameManager</code> script in a persistent instance role?</p>
			<ol>
				<li>Prototype</li>
				<li>Abstract Factory</li>
				<li>Singleton</li>
				<li>Builder</li>
			</ol>
			<ol>
				<li value="4">You have been requested to create a prototype for a side-scrolling game where your player throws rocks at their enemies. The game works well and the camera moves from left to right until the level is over. To throw a rock, your code instantiates a prefab of a rock, which is then given a force (<code>Rigidbody.AddForce</code>) to launch the rock to give the illusion of the rock being thrown.</li>
			</ol>
			<p>Your lead developer says that your method is costing too much in-memory performance and wants you to store a maximum of 10 rocks from within an array of rocks using a design pattern. Once a rock is used, instead of being destroyed, it should return to the array.</p>
			<p>What design pattern is the developer referring to?</p>
			<ol>
				<li>Abstract Factory</li>
				<li>Object Pool</li>
				<li>Dependency Injection</li>
				<li>Builder</li>
			</ol>
			<p>That's the end of your first mini mock test. To check your answers, refer to the <a href="B18381_Appendix_Epub.xhtml#_idTextAnchor245"><em class="italic">Appendix</em></a> section at the back of this book. How did you do? To review any incorrect answers, I suggest flicking back through the last couple of chapters to the relevant section and refreshing your memory where needed. Sadly, exams can be a bit of a memory game. Everyone's memory is different, and the majority of people that pass these exams have failed on certain sections before passing.</p>
			<p>Either way, the more you complete these tests, the stronger you will become at them. Just stay focused and you'll get through it!</p>
		</div>
	</body></html>