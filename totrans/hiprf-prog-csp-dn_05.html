<html><head></head><body>
		<div id="_idContainer057">
			<h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor072"/>Chapter 4</em>: Memory Management</h1>
			<p>In this chapter, we will be looking at object generations and how to avoid memory issues, followed by a discussion on strong and weak references. Then, we will look at finalization and how we can suppress finalization by implementing the <strong class="source-inline">IDisposable</strong> pattern to clean up managed and unmanaged resources. Finally, we will take a high-level look at ways to avoid memory leaks. </p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li><strong class="bold">Object generations and avoiding memory issues</strong>: In this section, we learn about object generations and <strong class="source-inline">System.OutOfMemoryException</strong>. We learn how to predict out-of-memory errors before they happen by using the <strong class="source-inline">System.Runtime.MemoryFailPoint</strong> class.</li>
				<li><strong class="bold">Understanding long and short weak references</strong>: In this section, we learn about long and short weak references and how they are affected by the garbage collector.</li>
				<li><strong class="bold">Finalization</strong>: In this section, we look at how to use finalizers to clean up resources, and understand why we have no control over if and when they will run.</li>
				<li><strong class="bold">Implementing the IDisposable pattern</strong>: In this section, we look at how we can have more control over the cleanup of managed and unmanaged resources by implementing the <strong class="source-inline">IDisposable</strong> pattern.</li>
				<li><strong class="bold">Preventing memory leaks</strong>: In this section, we look at how the use of the <strong class="bold">Component Object Model</strong> (<strong class="bold">COM</strong>) and managed events can be sources that generate memory leaks and what we can do to avoid memory leaks from being generated. We will be using Microsoft Excel and JetBrains dotMemory in this section to see how leaks can be generated and to see how using a memory profiler can be very useful in identifying memory leaks and their sources.</li>
			</ul>
			<p>By the end of this chapter, you will have gained skills in the following areas:</p>
			<ul>
				<li>Understanding object generations</li>
				<li>Understanding how objects are disposed</li>
				<li>Understanding why it is best to avoid finalizers and implement <strong class="source-inline">IDisposable</strong></li>
				<li>Understanding how to prevent memory leaks arising from the use of unmanaged COM libraries and components and from using events</li>
				<li>Using anonymous methods, long weak references, and short weak references to improve garbage collection</li>
			</ul>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
			<p>To complete the steps in this chapter, there are some technical requirements, as outlined here:</p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>JetBrains dotMemory</li>
				<li>Source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04</a></li>
			</ul>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Object generations and avoiding memory issues</h1>
			<p>There are three<a id="_idIndexMarker285"/> object generations<a id="_idIndexMarker286"/> in the .NET runtime, as follows: </p>
			<ul>
				<li>Generation 0</li>
				<li>Generation 1</li>
				<li>Generation 2</li>
			</ul>
			<p>Generation 0 is the youngest generation and holds short-lived objects. Objects that are less than 80,000 bytes are generation 0 objects<a id="_idIndexMarker287"/> that get placed on the <strong class="bold">small object heap</strong> (<strong class="bold">SOH</strong>) when they are instantiated. Objects that are 80,000 bytes or larger are usually generation 2 objects and live on the <strong class="bold">large object heap</strong> (<strong class="bold">LOH</strong>). Generation 1 objects are those objects<a id="_idIndexMarker288"/> that survived generation 0 garbage collection and received a promotion to generation 1.</p>
			<p>Generation 0 is where most of the garbage <a id="_idIndexMarker289"/>collection takes place. Objects that do not get collected<a id="_idIndexMarker290"/> when they are generation 0 will get promoted to generation 1 to make room for more generation 0 objects to be added to the heap. If generation 0 and 1 become full, then generation 1 objects are promoted to generation 2, and generation 0 objects are promoted to generation 1. If generations 0, 1, and 2 become full so that no more objects can be added to the heap, you then end up with a <strong class="source-inline">System.OutOfMemoryException</strong>-type exception.</p>
			<p>We are now going to write a very simple program that will throw a <strong class="source-inline">System.OutOfMemoryException</strong>-type exception. Follow these next steps:</p>
			<ol>
				<li>Start a new .NET 6 console application project called <strong class="source-inline">CH04_OutOfMemoryExceptions</strong>. Add the following <strong class="source-inline">using</strong> statements to the <strong class="source-inline">Program.cs</strong> file:<p class="source-code">using System.Text.RegularExpressions;</p><p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.IO;</p><p class="source-code">using System.Runtime;</p><p class="source-code">using System.Text;</p></li>
				<li>Add the following method calls to the <strong class="source-inline">Main</strong> method:<p class="source-code">DataExportToCsv();</p><p class="source-code">ReadCsvBroken();</p><p class="source-code">ReadCsvPredictive();</p><p class="source-code">Console.ReadKey();</p></li>
				<li>The <strong class="source-inline">DataExportToCsv()</strong> method builds up a very large data file. <strong class="source-inline">ReadCsvBroken()</strong> reads in the <strong class="bold">comma-separated values</strong> (<strong class="bold">CSV</strong>) file, but the string limit is blown for the imported data file when the whole file is read at once. This will generate a <strong class="source-inline">System.OutOfMemoryException</strong>-type exception. The exception<a id="_idIndexMarker291"/> is avoided in the <strong class="source-inline">ReadCsvPredictive()</strong> method, as the method<a id="_idIndexMarker292"/> instantiates the <strong class="source-inline">MemoryFailPoint</strong> class to ensure that the data read of the file will not generate an exception. If the operation does generate a <strong class="source-inline">System.OutOfMemory exception</strong>-type exception, then the <strong class="source-inline">MemoryFailPoint</strong> object will raise an <strong class="source-inline">OutOfMemoryException</strong>-type exception. This saves memory, time, <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) usage, and power consumption. Finally, we wait for the user to press any key before exiting. Add the following member variable to the top of the <strong class="source-inline">Program</strong> class:<p class="source-code">private static string _filename </p><p class="source-code">= @"G:\Temp\SampleData.csv";</p></li>
				<li>This will be the file we will write to and read from. Add the following <strong class="source-inline">DataExportToCsv()</strong> method:<p class="source-code">private static void DataExportToCsv()</p><p class="source-code">{</p><p class="source-code">    int row = 0;</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">    File.Delete(_filename);</p><p class="source-code">    using (FileStream fs = new FileStream(_filename, </p><p class="source-code">    FileMode.OpenOrCreate))</p><p class="source-code">    {</p><p class="source-code">        fs.Write(Encoding.Unicode.GetBytes("Id, </p><p class="source-code">            Name, Description\n"));</p><p class="source-code">            for (int i = 0; i &lt;= 491616373; i++)</p><p class="source-code">            {</p><p class="source-code">                row = i;</p><p class="source-code">                Console.WriteLine($"Writing row {row} to </p><p class="source-code">                    CSV data. There are {491616373-row} </p><p class="source-code">                        rows remaining.");</p><p class="source-code">                fs.Write(Encoding.Unicode.GetBytes</p><p class="source-code">                  ($"{i}, Name {i}, Description {i}\n"));</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">catch (Exception ex)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine($"DataExportToCsv: </p><p class="source-code">            {ex.GetBaseException().Message}")</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>This code writes 491,616,373 lines<a id="_idIndexMarker293"/> of data to a CSV file. Add<a id="_idIndexMarker294"/> the following <strong class="source-inline">ReadCsvBroken()</strong> method:<p class="source-code">private static void ReadCsvBroken()</p><p class="source-code">{</p><p class="source-code">    int row = 0;</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        string csv = File.ReadAllText(_filename);</p><p class="source-code">    }</p><p class="source-code">    catch (OutOfMemoryException oomex)</p><p class="source-code">    {</p><p class="source-code">    Console.WriteLine($"ReadCsvBroken:</p><p class="source-code">        {oomex.GetBaseException().Message}");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">ReadCsvBroken()</strong> method tries to read the massive 44.2 <strong class="bold">gigabytes</strong> (<strong class="bold">GB</strong>) CSV file all at once. However, the file<a id="_idIndexMarker295"/> produces a string that is too big<a id="_idIndexMarker296"/> to be assigned to a <strong class="source-inline">string</strong> variable. This operation throws a <strong class="source-inline">System.OutOfMemoryException</strong>-type exception. Add the following <strong class="source-inline">ReadCsvPredictive()</strong> method:<p class="source-code">private static void ReadCsvPredictive()</p><p class="source-code">{</p><p class="source-code">    int row = 0;</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        string alphabet = "abcdefghijklmnopqrstuvwxyz";</p><p class="source-code">        using (new MemoryFailPoint(alphabet.length))</p><p class="source-code">        {</p><p class="source-code">            string alpha = alphabet;</p><p class="source-code">        }</p><p class="source-code">        FileInfo fi = new FileInfo(_filename);</p><p class="source-code">        Int length = unchecked((int)fi.length);</p><p class="source-code">        using (new MemoryFailPoint(length))</p><p class="source-code">        {</p><p class="source-code">            string csv = File.ReadAllText(_filename);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    catch (OutOfMemoryException oomex)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine($"ReadCsvPredictive: </p><p class="source-code">            {oomex.GetBaseException().Message}");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>This code uses predictive memory checking using the <strong class="source-inline">MemoryFailPoint</strong> class. We show it working<a id="_idIndexMarker297"/> for the <strong class="source-inline">alphabet</strong> string, and we show<a id="_idIndexMarker298"/> that it highlights an error and fails with an <strong class="source-inline">OutOfMemoryException</strong>-type exception when the length of the file contents is assigned to the <strong class="source-inline">length</strong> variable that is passed into the <strong class="source-inline">MemoryFailPoint</strong> constructor. We use the unchecked struct since the length of the file is a long value, and this value to too big to be assigned to an <strong class="source-inline">int</strong> data type. If we used the checked struct instead, we would have an <strong class="source-inline">ArithmeticOverflowException</strong>-type exception.</li>
				<li>Building and running the code takes hours. I recommend you build the code in <strong class="source-inline">Release</strong> mode, and then run the executable from a command window. The code will successfully build up the CSV file and save it. When the file contents are read all at once, they will generate an <strong class="source-inline">OutOfMemoryException</strong>-type exception. Then, the program will do a precheck prior to loading the file and will fail before the file read is attempted with a more detailed <strong class="source-inline">OutOfMemoryException</strong>-type exception.</li>
			</ol>
			<p>Predicting memory exceptions saves time and improves application performance, as you are not wasting CPU cycles and memory performing an operation that is ultimately going to fail.</p>
			<p>We have seen how easy<a id="_idIndexMarker299"/> it is for an application to run out of memory and how<a id="_idIndexMarker300"/> we can predict and prevent memory exceptions. So, let’s now move on to discuss strong and weak references.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Understanding long and short weak references</h1>
			<p>In the .NET runtime, there are two types of references: <strong class="bold">long weak references</strong> and <strong class="bold">short weak references</strong>. These are described in more detail here:</p>
			<ul>
				<li><strong class="bold">Long weak reference</strong>: When the <strong class="source-inline">Finalize()</strong> method has been called on an object, a long weak reference<a id="_idIndexMarker301"/> is retained in memory. You specify <strong class="source-inline">true</strong> in the <strong class="source-inline">WeakReference</strong> constructor to define a long reference. A long weak reference can be recreated, although its state can be unpredictable. A short weak reference will be applied when an object’s type does not have a <strong class="source-inline">Finalize()</strong> method. The weak reference will only remain until its target is collected sometime after the finalizer is run. You will need to cast the target property of a <strong class="source-inline">WeakReference</strong> constructor to the type of an object if you want to create a strong weak reference that will be reused. When the object is collected, the <strong class="source-inline">Target</strong> property will be <strong class="source-inline">null</strong>. If it is not <strong class="source-inline">null</strong>, then you can continue to use the object because the application has regained a strong reference to it.</li>
				<li><strong class="bold">Short weak reference</strong>: A weak reference is a managed<a id="_idIndexMarker302"/> object that will be garbage-collected the same as any other managed object. The parameterless constructor for <strong class="source-inline">WeakReference</strong> is a short weak reference. When the garbage collector reclaims a short weak reference, its target becomes <strong class="source-inline">null</strong>.</li>
			</ul>
			<p>A long weak reference<a id="_idIndexMarker303"/> protects referenced objects from garbage collection, and a short weak reference<a id="_idIndexMarker304"/> does not protect referenced objects from garbage collection. This means that when garbage collection executes, the long weak referenced objects will not be garbage-collected, but the short weak referenced objects will be garbage-collected. We will demonstrate this with a code example.</p>
			<p>Our code example will show both long and short weak references at work. Follow these next steps:</p>
			<ol>
				<li value="1">Start by adding a new .NET 6 console application called <strong class="source-inline">CH04_WeakReferences</strong>. Add the following class called <strong class="source-inline">ReferenceObject</strong>:<p class="source-code">internal class ReferenceObject</p><p class="source-code">{</p><p class="source-code">public int Id { get; set; }</p><p class="source-code">public string Name { get; set; }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class will be our reference object that we will be adding to two different object managers.</p>
			<ol>
				<li value="2">Add a new class called <strong class="source-inline">LongWeakReferenceObjectManager</strong>. Then, add the following list field:<p class="source-code">private readonly List&lt;ReferenceObject&gt; Objects </p><p class="source-code">= new List&lt;ReferenceObject&gt;();</p></li>
				<li>Our read-only <strong class="source-inline">Objects</strong> list will contain several <strong class="source-inline">ReferenceObject</strong> types. Now, add the following method to add items to the list:<p class="source-code">public void Add(ReferenceObject o)</p><p class="source-code">{</p><p class="source-code">Objects.Add(o);</p><p class="source-code">}</p></li>
				<li>This method adds a <strong class="source-inline">ReferenceObject</strong> object to the list<a id="_idIndexMarker305"/> of reference objects. Then, the next task is to add a method<a id="_idIndexMarker306"/> that will print a list of stored objects to the console, as follows:<p class="source-code">public void ListObjects()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Long Weak Reference Objects: ");</p><p class="source-code">    foreach (var reference in Objects)</p><p class="source-code">        Console.WriteLine($"- {reference.Name}");</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ListObjects()</strong> method prints out the contents of the list to the console window. That concludes our <strong class="source-inline">LongWeakReferenceObjectManager</strong> class. </p>
			<ol>
				<li value="5">Now, add a class called <strong class="source-inline">ShortWeakReferenceObjectManager</strong>. At the top of the class, add the following list field:<p class="source-code">private readonly List&lt;WeakReference&lt;ReferenceObject&gt;&gt; </p><p class="source-code">  Objects </p><p class="source-code">= new List&lt;WeakReference&lt;ReferenceObject&gt;&gt;();</p></li>
			</ol>
			<p>Notice with the list that the <strong class="source-inline">ReferenceObject</strong> object is wrapped in a <strong class="source-inline">WeakReference</strong> object.</p>
			<ol>
				<li value="6">Now, add a method to add items to the list, as follows:<p class="source-code">public void Add(ReferenceObject o)</p><p class="source-code">{</p><p class="source-code">Objects.Add(new WeakReference&lt;ReferenceObject&gt;(o));</p><p class="source-code">}</p></li>
			</ol>
			<p>This method wraps the passed-in <strong class="source-inline">ReferenceObject</strong> object in a <strong class="source-inline">WeakReference</strong> object and assigns it to the list. </p>
			<ol>
				<li value="7">We now add <a id="_idIndexMarker307"/>the <strong class="source-inline">ListObjects()</strong> method, as<a id="_idIndexMarker308"/> follows:<p class="source-code">public void ListObjects()</p><p class="source-code">{</p><p class="source-code">Console.WriteLine("Short Weak Reference Objects: ");</p><p class="source-code">foreach (var reference in Objects)</p><p class="source-code">{</p><p class="source-code">    reference.TryGetTarget(</p><p class="source-code">        out ReferenceObject referenceObject</p><p class="source-code">    );</p><p class="source-code">    if (referenceObject != null)</p><p class="source-code">        Console.WriteLine($"- {referenceObject.Name}");</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ListObjects()</strong> method prints out to the console window all the weak objects that are stored in the list. Our focus now moves to the <strong class="source-inline">Program</strong> class.</p>
			<ol>
				<li value="8">Add the following two fields to the top of the <strong class="source-inline">Program</strong> class:<p class="source-code">private static readonly StrongReferenceObjectManager </p><p class="source-code">  StrongReferences = new StrongReferenceObjectManager();</p><p class="source-code">private static readonly WeakReferenceObjectManager </p><p class="source-code">  WeakReferences = new WeakReferenceObjectManager();</p></li>
			</ol>
			<p>These are our read-only strong and weak object managers that we will use to demonstrate strong and weak references in action, with regard to the garbage collector.</p>
			<ol>
				<li value="9">Update the <strong class="source-inline">Main(string[] _)</strong> method by adding the following three method calls:<p class="source-code">TestLongWeakReferences();</p><p class="source-code">TestStrongReferences();</p><p class="source-code">TestShortWeakReferences();</p><p class="source-code">ProcessReferences();</p></li>
			</ol>
			<p>The <strong class="source-inline">TestLongWeakreferences()</strong>, <strong class="source-inline">TestStrongReferences()</strong>, and <strong class="source-inline">TestWeakReferences()</strong> methods<a id="_idIndexMarker309"/> build up our lists of strong referenced objects<a id="_idIndexMarker310"/> and weak referenced objects respectively. </p>
			<ol>
				<li value="10">Add the <strong class="source-inline">TestStrongReferences()</strong> method, as follows:<p class="source-code">private static void TestStrongReferences()</p><p class="source-code">{</p><p class="source-code">var o1 = new ReferenceObject() { </p><p class="source-code">    Id = 1, Name = "Object 1" </p><p class="source-code">};</p><p class="source-code">var o2 = new ReferenceObject() { </p><p class="source-code">    Id = 2, Name = "Object 2" </p><p class="source-code">};</p><p class="source-code">var o3 = new ReferenceObject() { </p><p class="source-code">    Id = 3, Name = "Object 3" </p><p class="source-code">};</p><p class="source-code">StrongReferences.Add(o1);</p><p class="source-code">StrongReferences.Add(o2);</p><p class="source-code">StrongReferences.Add(o3);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method adds three <strong class="source-inline">ReferenceObject</strong> objects to the <strong class="source-inline">StrongReferences</strong> list. </p>
			<ol>
				<li value="11">Next, add<a id="_idIndexMarker311"/> the <strong class="source-inline">TestWeakReferences()</strong> method, as<a id="_idIndexMarker312"/> follows:<p class="source-code">private static void TestWeakReferences()</p><p class="source-code">{</p><p class="source-code">var o1 = new ReferenceObject() { </p><p class="source-code">    Id = 1, Name = "Object 4" </p><p class="source-code">};</p><p class="source-code">var o2 = new ReferenceObject() { </p><p class="source-code">    Id = 2, Name = "Object 5" </p><p class="source-code">};</p><p class="source-code">var o3 = new ReferenceObject() { </p><p class="source-code">    Id = 3, Name = "Object 6" </p><p class="source-code">};</p><p class="source-code">WeakReferences.Add(o1);</p><p class="source-code">WeakReferences.Add(o2);</p><p class="source-code">WeakReferences.Add(o3);</p><p class="source-code">o1 = null;</p><p class="source-code">o2 = null;</p><p class="source-code">o3 = null;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method adds three weak referenced objects to the <strong class="source-inline">WeakReferences</strong> list and then sets the objects it instantiated to <strong class="source-inline">null</strong> so that they will be garbage-collected.</p>
			<ol>
				<li value="12">Finally, add the <strong class="source-inline">ProcessReferences()</strong> method, as follows:<p class="source-code">private static void ProcessReferences()</p><p class="source-code">{</p><p class="source-code">int x = 0;</p><p class="source-code">while(x &lt; 10)</p><p class="source-code">{</p><p class="source-code">    StrongReferences.ListObjects();</p><p class="source-code">    WeakReferences.ListObjects();</p><p class="source-code">    Thread.Sleep(2000);</p><p class="source-code">    GC.Collect();</p><p class="source-code">    x++;</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ProcesseReferences()</strong> method<a id="_idIndexMarker313"/> loops 10 times. During each<a id="_idIndexMarker314"/> iteration, the <strong class="source-inline">ListObjects()</strong> method is called on the <strong class="source-inline">StrongReferences</strong> and <strong class="source-inline">WeakReferences</strong> fields. The program sleeps for 2 seconds, and then the garbage collector is executed manually. </p>
			<ol>
				<li value="13">It is now time to run the program. When you run the program, you should see the following output:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B16617_Figure_4.1.jpg" alt="Figure 4.1 – Weak references’ project output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Weak references’ project output</p>
			<p>As you can see from <em class="italic">Figure 4.1</em>, on the first iteration<a id="_idIndexMarker315"/> of the loop, both strong and weak reference objects exist, and the names<a id="_idIndexMarker316"/> of those objects are printed in the console window. However, after garbage collection is called, the weak references are garbage-collected, and so, from the second iteration onward, only the strongly referenced objects remain in memory.</p>
			<p>A weakly referenced object’s lifespan is not extended as it is for strong references. This means that they can be garbage-collected once all strong references have gone out of scope.</p>
			<p>Objects that are large but cheap to rehydrate on-demand benefit from weak references.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To improve the performance of your applications, avoid using weak references on many small objects as they can take up more memory space than the objects they wrap, thus adding performance overhead. But if you are working with many large expensive objects, using cached weak references may help improve your application’s performance.</p>
			<p>That concludes<a id="_idIndexMarker317"/> our look at strong<a id="_idIndexMarker318"/> and weak references. Let’s move our focus and attention to finalization in C#.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Finalization</h1>
			<p>In C#, there is no direct way of destroying<a id="_idIndexMarker319"/> an object. The nearest thing we have is <strong class="bold">finalization</strong>. A finalizer in C# is the C# equivalent of a destructor in C++. Except in C#, you have no control over if and when it will run this down to the garbage collector to make that decision.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The terms <em class="italic">finalizer</em> and <em class="italic">destructor</em> are used interchangeably in C#. A finalizer is where the user-defined finalizer code is run. After the finalizer<a id="_idIndexMarker320"/> in an object is run, it is once again considered alive and the garbage collector will then finally collect the object. This means an object is actually marked “<strong class="source-inline">collectable</strong>” twice if it has a finalizer defined.</p>
			<p>Finalization is used by an object to release resources and perform other housekeeping operations prior to the object being garbage-collected. Cleanup operations to release unmanaged resources held by an object can be performed by overriding the protected <strong class="source-inline">Finalize()</strong> method.</p>
			<p>You have to override the <strong class="source-inline">Finalize()</strong> method for the garbage collector to mark types derived from <strong class="source-inline">Object</strong> for finalization. When you override the <strong class="source-inline">Finalize()</strong> method, an entry for the instance is placed in a finalization queue. Before reclaiming memory, the <strong class="source-inline">Finalize()</strong> method is called for each object instance in the finalization queue. Once an object’s <strong class="source-inline">Finalize()</strong> method has been run, then its memory can be reclaimed by the garbage collector.</p>
			<p>The <strong class="source-inline">Finalize()</strong> method is not called if <strong class="source-inline">GC.SupressFinalize()</strong> has been called during the disposing<a id="_idIndexMarker321"/> of the object’s resources, but the <strong class="source-inline">Finalize()</strong> method will be called automatically when<a id="_idIndexMarker322"/> an object is discovered to be inaccessible, and during <strong class="bold">application domain</strong> (<strong class="bold">AppDomain</strong>) shutdown (even if the object is accessible).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">AppDomains isolate applications from<a id="_idIndexMarker323"/> one another, but their usage is very expensive. In .NET 5+, some AppDomain <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) surface is exposed to help ease migration from older frameworks. Some functionality has been removed, and so will either do nothing or throw an exception. Microsoft has no plans to add support for adding extra AppDomains. The present advice from Microsoft to implement code isolation is to use separate processes or containers and use the <strong class="source-inline">AssemblyLoadContext</strong> class for dynamic assembly loading.</p>
			<p><strong class="source-inline">Finalize()</strong> methods only run once unless <strong class="source-inline">GC.SuppressFinalize()</strong> has not been called and <strong class="source-inline">GC.ReRegisterForFinalize()</strong> is called; then, the <strong class="source-inline">Finalize()</strong> method can be called again.</p>
			<p>When overriding <strong class="source-inline">Finalize()</strong>, there are a few things to keep in mind, as follows:</p>
			<ul>
				<li>You have no control over when the <strong class="source-inline">Finalize()</strong> method will be called.</li>
				<li>To guarantee the release of managed and unmanaged resources within your instance, implement the <strong class="source-inline">IDisposable.Dispose()</strong> method using the <strong class="source-inline">IDisposable</strong> pattern. There is no guarantee of the order in which finalizers will run. </li>
				<li>Finalizers run on an unspecified thread, and they implicitly call the <strong class="source-inline">Finalize()</strong> method on the base class.</li>
			</ul>
			<p>To avoid the need to override the <strong class="source-inline">Finalize()</strong> method and for us to ensure the cleanup of our managed and unmanaged resources, we will look at implementing the <strong class="source-inline">IDisposable</strong> pattern.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Using finalization</h2>
			<p>We are going to write a sample<a id="_idIndexMarker324"/> application that demonstrates the use of <strong class="source-inline">Finalize()</strong>. Then, we will modify the program to implement the <strong class="source-inline">IDisposable</strong> pattern and suppress the call to <strong class="source-inline">Finalize()</strong>, while ensuring the deterministic release of our managed and unmanaged resources. Follow these next steps:</p>
			<ol>
				<li value="1">Start a new .NET 6 console application called <strong class="source-inline">CH04_Finalization</strong>. Add a new internal class called <strong class="source-inline">Product</strong>. Then, add the following properties:<p class="source-code">public int Id { get; set; }</p><p class="source-code">public string Name { get; set; }</p><p class="source-code">public string Description { get; set; }</p><p class="source-code">public decimal UnitPrice { get; set; }</p></li>
				<li>We have created four properties—<strong class="source-inline">Id</strong>, <strong class="source-inline">Name</strong>, <strong class="source-inline">Description</strong>, and <strong class="source-inline">UnitPrice</strong>. Now, add the constructor, as follows:<p class="source-code">public Product()</p><p class="source-code">{</p><p class="source-code">Console.WriteLine("Product constructor.");</p><p class="source-code">}</p></li>
				<li>Our constructor writes a message to the console window so that we know we have entered the constructor. Next, add the finalizer, as follows:<p class="source-code">~Product()</p><p class="source-code">{</p><p class="source-code">Console.WriteLine("Product finalizer.");</p><p class="source-code">}</p></li>
				<li>In our finalizer, we write a message to the console window so that we know our finalizer has been called. For the last bit of code in our <strong class="source-inline">Product</strong> class, we will override the <strong class="source-inline">ToString()</strong> method, as follows:<p class="source-code">public override string ToString()</p><p class="source-code">{</p><p class="source-code">  return $"Id: {Id}, Name: {Name},</p><p class="source-code">  Description: {Description}, Unit Price: {UnitPrice}";</p><p class="source-code">}</p></li>
				<li>Our <strong class="source-inline">ToString()</strong> method returns a string<a id="_idIndexMarker325"/> that outputs the values of each of the properties of the <strong class="source-inline">Product</strong> class. For now, unless stated otherwise, the following code is to be added to the <strong class="source-inline">Program</strong> class. Add the following variable:<p class="source-code">private static Product _product;</p></li>
				<li>The <strong class="source-inline">_product</strong> variable will be used to store an instance of our <strong class="source-inline">Product</strong> class. Update the <strong class="source-inline">Main</strong> method, as follows:<p class="source-code">static void Main(string[] _)</p><p class="source-code">{</p><p class="source-code">InstantiateObject();</p><p class="source-code">PrintObjectData();</p><p class="source-code">RemoveObjectReference();</p><p class="source-code">RunGarbageCollector();</p><p class="source-code">InstantiateLocalObject();</p><p class="source-code">RunGarbageCollector();</p><p class="source-code">DisplayGeneration(_product);</p><p class="source-code">RemoveObjectReference();</p><p class="source-code">RunGarbageCollector();</p><p class="source-code">}</p></li>
				<li>As you can see, we have several methods that instantiate the object, print object data, remove object<a id="_idIndexMarker326"/> references, display object generations, and run the garbage collector. We will now add each of the methods in turn. Add the <strong class="source-inline">InitiateObject()</strong> method, as follows:<p class="source-code">private static void InstantiateObject()</p><p class="source-code">{</p><p class="source-code">  Console.WriteLine("Instantiating Product.");</p><p class="source-code">  _product = new Product()</p><p class="source-code">{</p><p class="source-code">    Id = 1,</p><p class="source-code">    Name = "Polly Parrot",</p><p class="source-code">    Description = "Cudly child's toy.",</p><p class="source-code">    UnitPrice = 7.99M</p><p class="source-code">};</p><p class="source-code">}</p></li>
				<li>In this method, we write a console window message, create a new product, and assign it to the <strong class="source-inline">_product</strong> member variable. Now, we will add the <strong class="source-inline">PrintObjectData()</strong> method, as follows:<p class="source-code">private static void PrintObjectData()</p><p class="source-code">{</p><p class="source-code">Console.WriteLine(_product.ToString());</p><p class="source-code">}</p></li>
				<li>Here, we are printing the contents of the <strong class="source-inline">Product</strong> class to the console window. Next, we will write the <strong class="source-inline">RemoveObjectReference()</strong> method, as follows:<p class="source-code">private static void RemoveObjectReference()</p><p class="source-code">{</p><p class="source-code">    _product = null;</p><p class="source-code">}</p></li>
				<li>We are setting the <strong class="source-inline">Product</strong> object to <strong class="source-inline">null</strong>. This removes references to the object and makes it eligible<a id="_idIndexMarker327"/> for garbage collection. We now add a method to call the garbage collection, as follows:<p class="source-code">private static void RunGarbageCollector()</p><p class="source-code">{</p><p class="source-code">    GC.Collect();</p><p class="source-code">}</p></li>
				<li>In this method, we call the garbage collector, as follows:<p class="source-code">private static void InstantiateLocalObject()</p><p class="source-code">{</p><p class="source-code">      var product = new Product()</p><p class="source-code">      {</p><p class="source-code">          Id = 2,</p><p class="source-code">          Name = "Cute Kittie",</p><p class="source-code">          Description = "Cudly child's toy.",</p><p class="source-code">          UnitPrice = 5.75M</p><p class="source-code">      };</p><p class="source-code">      DisplayGeneration(product);</p><p class="source-code">      _product = product;</p><p class="source-code">      GC.Collect();</p><p class="source-code">}</p></li>
				<li>In this method, we create a local object. Then, we call the method to display the current generation. We then assign<a id="_idIndexMarker328"/> the local product to the member product, followed by a call to the garbage collector. Our final method, for now, is the <strong class="source-inline">DisplayGeneration(Product product)</strong> method, as illustrated in the following code snippet:<p class="source-code">private static void DisplayGeneration(Product product)</p><p class="source-code">{</p><p class="source-code">      Console.WriteLine($"local product: </p><p class="source-code">          generation {GC.GetGeneration(product)}");</p><p class="source-code">}</p></li>
				<li>This method prints out the generation of the product passed into it. Run the code. You should see the following output:</li>
			</ol>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B16617_Figure_4.2.jpg" alt="Figure 4.2 – The finalization project output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – The finalization project output</p>
			<p>As you can see, our code demonstrates<a id="_idIndexMarker329"/> construction and finalization. We have both generation 0 and generation 2 code, and both our constructor and finalizer methods do get called. Now, we will look at implementing <strong class="source-inline">IDisposable</strong> to make the cleanup of our code more deterministic so that <strong class="source-inline">Finalize()</strong> does not need to be called.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Implementing the IDisposable pattern</h1>
			<p>In this section, we will implement<a id="_idIndexMarker330"/> a reusable <strong class="source-inline">IDisposable</strong> pattern. We will have a base class that implements <strong class="source-inline">IDisposable</strong>. This base class will provide two methods that subclasses can override. One method will be for cleaning up managed<a id="_idIndexMarker331"/> resources, and the other method will be for disposing of unmanaged resources. For us to implement the <strong class="source-inline">IDisposable</strong> pattern, proceed as follows:</p>
			<ol>
				<li value="1">Add a new class called <strong class="source-inline">DisposableBase</strong> that implements <strong class="source-inline">IDisposable</strong>, as follows:<p class="source-code">public class DisposableBase : IDisposable</p><p class="source-code">{</p><p class="source-code">      public void Dispose()</p><p class="source-code">      {</p><p class="source-code">         Dispose(true);</p><p class="source-code">      }</p><p class="source-code">      private void Dispose(bool disposing)</p><p class="source-code">      {</p><p class="source-code">          if (disposing)</p><p class="source-code">          GC.SuppressFinalize(this);</p><p class="source-code">          ReleaseManagedResources();</p><p class="source-code">          ReleaseUnmanagedResources();</p><p class="source-code">      }</p><p class="source-code">protected virtual void ReleaseManagedResources(){} </p><p class="source-code">protected virtual void ReleaseUnmanagedResources(){}</p><p class="source-code">}</p></li>
			</ol>
			<p>This class acts as a base class that can be inherited. It implements the <strong class="source-inline">IDisposable</strong> interface and calls two virtual methods called <strong class="source-inline">ReleaseManagedResources()</strong> and <strong class="source-inline">ReleaseUnmanagedResources()</strong> that will be overridden in the subclass.</p>
			<ol>
				<li value="2">Move the code from <strong class="source-inline">Main</strong> into a new <a id="_idIndexMarker332"/>method called <strong class="source-inline">Finalization()</strong>. Then, modify <strong class="source-inline">Main</strong>, as follows:<p class="source-code">static void Main(string[] _)</p><p class="source-code">{</p><p class="source-code">      Finalization();</p><p class="source-code">      Disposing();</p><p class="source-code">}</p></li>
			</ol>
			<p>We are calling two methods. The <strong class="source-inline">Finalization()</strong> method demonstrates using finalization to clean up resources that you have no control over when finalization will be called by the garbage collector. <strong class="source-inline">Disposing()</strong> demonstrates the determined disposing of managed and unmanaged resources, with finalization being suppressed so that it is not called by the garbage collector. Your <strong class="source-inline">Finalization()</strong> method should look like this:</p>
			<p class="source-code">private static void Finalization()</p>
			<p class="source-code">{</p>
			<p class="source-code">      Console.WriteLine("--- Finalization ---");</p>
			<p class="source-code">      InstantiateObject("Finalization");</p>
			<p class="source-code">      PrintObjectData();</p>
			<p class="source-code">      RemoveObjectReference();</p>
			<p class="source-code">      RunGarbageCollector();</p>
			<p class="source-code">      InstantiateLocalObject("Finalization");</p>
			<p class="source-code">      RunGarbageCollector();</p>
			<p class="source-code">      DisplayGeneration(_product);</p>
			<p class="source-code">      RemoveObjectReference();</p>
			<p class="source-code">      RunGarbageCollector();</p>
			<p class="source-code">}</p>
			<p>We are passing <strong class="source-inline">“Finalization”</strong> into the <strong class="source-inline">InstantiateObject(string cleanUpMethod)</strong> and <strong class="source-inline">InstantiateLocalObject(string cleanUpMethod)</strong> methods so that we know the objects being finalized<a id="_idIndexMarker333"/> were instantiated in our <strong class="source-inline">Finalization()</strong> method.</p>
			<ol>
				<li value="3">Add a new method called <strong class="source-inline">Disposing()</strong>, as follows:<p class="source-code">private static void Disposing()</p><p class="source-code">{</p><p class="source-code">Console.WriteLine("--- Disposing ---");</p><p class="source-code">InstantiateObject("Disposing");</p><p class="source-code">PrintObjectData();</p><p class="source-code">DisposeOfObject();</p><p class="source-code">InstantiateLocalObject("Disposing");</p><p class="source-code">DisplayGeneration(_product);</p><p class="source-code">DisposeOfObject();</p><p class="source-code">RunGarbageCollector();</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">Disposing()</strong> method, we write a message to the console identifying that the <strong class="source-inline">Disposing()</strong> method is running. We then call <strong class="source-inline">InstantiateObject(“Disposing”)</strong>. Next, we print the object data and dispose of the object. Then, we instantiate a local object that will get assigned to the member variable. The generations of the local and member variables are printed to the console window, and then we dispose of the object and call garbage collection.</li>
				<li>Add the <strong class="source-inline">DisposeofObject()</strong> method, as follows:<p class="source-code">private static void DisposeOfObject()</p><p class="source-code">{</p><p class="source-code">      _product.Dispose();</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">DisposeOfObject()</strong> method<a id="_idIndexMarker334"/> calls the <strong class="source-inline">Dispose()</strong> method on the <strong class="source-inline">_product</strong> object to free up resources. Update the <strong class="source-inline">Product</strong> class, as follows:<p class="source-code">private string _cleanUpMethod;</p><p class="source-code">public Product(string cleanUpMethod)</p><p class="source-code">{</p><p class="source-code">  Console.WriteLine("Product constructor.");</p><p class="source-code">  _cleanUpMethod = cleanUpMethod;</p><p class="source-code">}</p><p class="source-code">~Product()</p><p class="source-code">{</p><p class="source-code">  Console.WriteLine($"Product destructor: {_</p><p class="source-code">    cleanUpMethod}.");</p><p class="source-code">}</p></li>
				<li>We are storing the name of the cleanup method we are using so that when the finalizer is called, we will know the method of cleanup the object uses. Modify the <strong class="source-inline">InstantiateObject()</strong> method, as follows:<p class="source-code">private static void InstantiateObject(string </p><p class="source-code">    cleanUpMethod)</p><p class="source-code">{</p><p class="source-code">Console.WriteLine("Instantiating Product.");</p><p class="source-code">_product = new Product(cleanUpMethod)</p><p class="source-code">{</p><p class="source-code">           Id = 1,</p><p class="source-code">           Name = "Polly Parrot",</p><p class="source-code">           Description = "Cudly child's toy.",</p><p class="source-code">           UnitPrice = 7.99M</p><p class="source-code">};</p><p class="source-code">}</p></li>
				<li>We are assigning the method<a id="_idIndexMarker335"/> of cleanup to the <strong class="source-inline">Product</strong> object. Do the same with the <strong class="source-inline">InstantiateLocalObject()</strong> method so that the code looks like this:<p class="source-code">private static void InstantiateLocalObject(string </p><p class="source-code">    cleanUpMethod)</p><p class="source-code">{</p><p class="source-code">var product = new Product(cleanUpMethod)</p><p class="source-code">{</p><p class="source-code">    Id = 2,</p><p class="source-code">    Name = "Cute Kittie",</p><p class="source-code">    Description = "Cudly child's toy.",</p><p class="source-code">    UnitPrice = 5.75M</p><p class="source-code">};</p><p class="source-code">DisplayGeneration(product);</p><p class="source-code">_product = product;</p><p class="source-code">}</p></li>
				<li>Again, we are assigning the method of cleanup to the <strong class="source-inline">Product</strong> object. Update <strong class="source-inline">Product</strong> to inherit from <strong class="source-inline">DisposableBase</strong>. Then, add the <strong class="source-inline">ReleaseManagedResources()</strong> method to the <strong class="source-inline">Product</strong> class, as follows:<p class="source-code">protected override void ReleaseManagedResources()</p><p class="source-code">{</p><p class="source-code">base.ReleaseManagedResources();</p><p class="source-code">Console.WriteLine("Releasing managed resources.");</p><p class="source-code">}</p></li>
				<li>This method will be used to release managed<a id="_idIndexMarker336"/> resources. Now, add the <strong class="source-inline">ReleaseUnmanagedResources()</strong> method to the <strong class="source-inline">Product</strong> class, as follows:<p class="source-code">protected override void ReleaseUnmanagedResources()</p><p class="source-code">{</p><p class="source-code">base.ReleaseUnmanagedResources();</p><p class="source-code">Console.WriteLine("Releasing unmanaged resources.");</p><p class="source-code">}</p></li>
			</ol>
			<p>This method will be used for cleaning up unmanaged resources.</p>
			<ol>
				<li value="11">Run the code and you should see the output, as shown here: </li>
			</ol>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B16617_Figure_4.3.jpg" alt="Figure 4.3 – The output of finalization and disposing code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – The output of finalization and disposing code</p>
			<p>As you can see, the finalization code calls the finalizer, but the methods used for releasing managed and unmanaged<a id="_idIndexMarker337"/> resources explicitly do not get called. Objects also survive the generation 0 garbage collection. Conversely, the disposing code explicitly releases the managed and unmanaged code, and finalization being suppressed is not called by the garbage collector. No objects in our example survive generation 0 garbage collection.</p>
			<p>Another way to implicitly call <strong class="source-inline">Dispose()</strong> on disposable classes is to use a <strong class="source-inline">using</strong> statement. Here is an example, as can be seen in the <strong class="source-inline">Program</strong> class:</p>
			<pre class="source-code">private static void UsingDispose()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      Console.WriteLine("--- UsingDispose() ---");</pre>
			<pre class="source-code">      using (var product = new Product("using")</pre>
			<pre class="source-code">          {</pre>
			<pre class="source-code">              Id = 2,</pre>
			<pre class="source-code">              Name = "Cute Kittie",</pre>
			<pre class="source-code">              Description = "Cudly child's toy.",</pre>
			<pre class="source-code">              UnitPrice = 5.75M</pre>
			<pre class="source-code">          }</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          DisplayGeneration(product);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">using</strong> statement is used with disposable objects. When the code block completes, the object is automatically disposed of. The object’s generation is 0. Add a call to <strong class="source-inline">UsingDispose()</strong> in the <strong class="source-inline">Main</strong> method.</p>
			<p>Well, you have seen how to use finalization<a id="_idIndexMarker338"/> and implement the <strong class="source-inline">IDisposable</strong> pattern in relation to the garbage collector. Now, let’s look at how we can avoid memory leaks in C#.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Preventing memory leaks</h1>
			<p>In this section, we will understand<a id="_idIndexMarker339"/> the issues around COM objects and what can lead to memory leaks using COM objects. We will look at interoping with the Excel COM library for our example code. We will see how instances of Excel are kept alive after our code exits. By using Windows Task Manager, we will be able to see instances of Excel being generated. Our Excel code will be developed in such a way as to avoid memory leaks and ensure that every Excel instance is closed when our code has completed running so that no instances of Excel remain in memory.</p>
			<p>We will then move on to look at how using events can be a common source of memory leaks at runtime and how we can avoid them. Using JetBrains dotMemory, we will profile a runtime build executable of our program code. As the code is running, we will generate snapshots. As the profiler runs, you will see the memory usage gradually climbing. Clicking on the snapshots will display detailed memory information for our running profile. We will also be able to see if we have any memory leaks, and will see that we have event-based memory leaks. In this section, we will also be looking at anonymous methods and weak references.</p>
			<p>The outcome of this section will be that you understand how COM and the use of events, if not handled correctly, can introduce memory exceptions, and you will see how you can write your code so that no memory exceptions are generated.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Understanding the dangers of using Marshal.ReleaseComObject</h2>
			<p>The Visual Studio team ran into problems<a id="_idIndexMarker340"/> with Visual Studio 2010. Their problems arose due to rewriting native C++ components in managed C# code. The components that were rewritten as managed C# code were the window manager, command bars, and text editor.</p>
			<p>With the release of Visual Studio 2010, there were two extension enablers—the existing extension mechanism that uses COM interfaces for older extensions, and a new managed programming model.</p>
			<p>In order for the <strong class="bold">Common Language Runtime</strong> (<strong class="bold">CLR</strong>) to make COM objects appear as regular managed objects, COM<a id="_idIndexMarker341"/> objects are wrapped in an object called a <strong class="source-inline">RuntimeCallableWrapper</strong> or <strong class="bold">RCW</strong>. An RCW acts as a bridge between the worlds<a id="_idIndexMarker342"/> of COM and managed code.</p>
			<p>All COM components<a id="_idIndexMarker343"/> must, at the very minimum, implement the <strong class="source-inline">IUnknown</strong> interface. When an object that implements the <strong class="source-inline">IUnknown</strong> interface enters the managed runtime, it is wrapped in an RCW. An RCW is, therefore, a regular managed object that references native code that implements the <strong class="source-inline">IUnknown</strong> interface.</p>
			<p>There are two types of objects that can reference an RCW in a managed .NET computer program: COM objects and managed objects. This is the point at which issues can start to present themselves.</p>
			<p>At this point, we will now consider a typical scenario that will result in memory issues between COM objects and managed objects.</p>
			<p>The <strong class="source-inline">DatabaseSearch</strong> component<a id="_idIndexMarker344"/> begins the <strong class="source-inline">Find</strong> operation by asking the <strong class="bold">global service provider</strong> (<strong class="bold">GSP</strong>) for the <strong class="source-inline">DatabaseManager</strong> service. A valid instance of <strong class="source-inline">IDatabaseManager</strong> is returned to the <strong class="source-inline">DatabaseSearch</strong> component. The <strong class="source-inline">DatabaseManager</strong> component returned to the <strong class="source-inline">DatabaseSearch</strong> component is a native COM component. Because the <strong class="source-inline">DatabaseManager</strong> component is a native COM component, it is wrapped in an RCW by the runtime. The <strong class="source-inline">DatabaseSearch</strong> component does not know or care whether the <strong class="source-inline">DatabaseManager</strong> component is a native COM component or managed code component because all it sees is the <strong class="source-inline">IDatabaseManager</strong> interface. The <strong class="source-inline">Find</strong> operation continues with the <strong class="source-inline">DatabaseSearch</strong> component making various calls through <strong class="source-inline">IDatabaseManager</strong> to complete its task. Once the <strong class="source-inline">Find</strong> operation is completed, it is exited. Since <strong class="source-inline">IDatabaseManager</strong> is an RCW, it has the same lifetime semantics as managed objects. As a result, the <strong class="source-inline">IDatabaseManager</strong> component will be cleaned up when the garbage collector runs. The garbage collector may not run for a long time if there is not a lot of memory pressure, and there is the possibility that it may not even run. At this point, we end up with a native and managed memory clash because of the different ways in which they both manage system memory. The managed <strong class="source-inline">DatabaseSearch</strong> component is finished with the <strong class="source-inline">DatabaseManager</strong> component until it needs it again. If there are no references to the <strong class="source-inline">DatabaseManager</strong> component, then this would be a good time for the garbage collector to run and remove <strong class="source-inline">DatabaseManager</strong>. Any component written in native code would, as soon as the <strong class="source-inline">Find</strong> method is exited, call <strong class="source-inline">Release</strong> on <strong class="source-inline">IDatabaseManager</strong>. This would indicate that the reference to <strong class="source-inline">IDatabaseManager</strong> is no longer needed. Since the final <strong class="source-inline">Release</strong> is not being called until the next garbage collection, it appears that there is a memory leak with <strong class="source-inline">IDatabaseManager</strong>. This is an example<a id="_idIndexMarker345"/> of non-deterministic finalization. The inability to determine when an object should be garbage-collected is known as non-deterministic finalization. The <strong class="source-inline">Finalize()</strong> method is executed on a special<a id="_idIndexMarker346"/> thread allocated by the garbage collector whenever the object it belongs to is being garbage-collected and finalization has not been suppressed when there are non-managed resources to be disposed of.</p>
			<p>This scenario that we have looked at would result in expensive objects being reported as leaked objects, and this would be during application shutdown.</p>
			<p>The natural solution would be to call <strong class="source-inline">Marshal.ReleaseComObject(object)</strong>. This call would be made as soon as the expensive object is no longer needed. In our scenario, it would be when <strong class="source-inline">DatabaseManager</strong> is no longer needed. This call causes the RCW to be released, and the internal reference count is decremented by one. At this point, the underlying COM object is usually released.</p>
			<p>However, calling <strong class="source-inline">Marshal.ReleaseComObject(object)</strong> can be dangerous.</p>
			<p>Consider that as part of a migration away from COM, <strong class="source-inline">DatabaseManager</strong> has been written in managed code. The <strong class="source-inline">DatabaseSearch</strong> managed component requests the <strong class="source-inline">DatabaseManager</strong> component via the GSP. An <strong class="source-inline">IDatabaseManager</strong> instance is returned to the <strong class="source-inline">DatabaseSearch</strong> component. The instance returned is an RCW that wraps a COM object. As a result, we have double<a id="_idIndexMarker347"/> wrapping that consists of an RCW wrapped around a <strong class="bold">COM Callable Wrapper</strong> (<strong class="bold">CCW</strong>). The CLR can easily deal with these scenarios, and so this is not a problem. It is when the <strong class="source-inline">Find</strong> operation exits that problems arise. The <strong class="source-inline">DatabaseSearch</strong> component still calls <strong class="source-inline">Marshall.ReleaseComObject(object)</strong> for the RCW of <strong class="source-inline">DatabaseManager</strong> when terminating. </p>
			<p>This results in an <strong class="source-inline">ArgumentException</strong>-type exception being raised. The exception message generated is <strong class="source-inline">“The object’s type must be _ComObject or derived from _ComObject.”</strong> When this happens, remove the call to <strong class="source-inline">Marshal.ReleaseComObject(object)</strong>. An alternative is to call <strong class="source-inline">Marshal.IsComObject</strong> before <strong class="source-inline">ReleaseComObject</strong> is called.</p>
			<p>Calling <strong class="source-inline">Marshal.IsComObject</strong> causes further problems. The <strong class="source-inline">DatabaseManager</strong> RCW has been declared as being no longer needed, but the problem is that the <strong class="source-inline">DatabaseManager</strong> RCW is still a valid object, meaning that it may still be reachable by managed objects. The next time the object is accessed, if reachable from managed code, an <strong class="source-inline">InvalidComObjectException</strong>-type exception will be raised by the CLR, stating: <strong class="source-inline">“COM object that has been separated from its underlying RCW cannot be used.”</strong></p>
			<p>If the COM components used by our <strong class="source-inline">DatabaseManager</strong> RCW are cached by managed code instead of being returned<a id="_idIndexMarker348"/> to the GSP each time our <strong class="source-inline">DatabaseManager</strong> component is requested, our cached COM components will be checked first. This is done to avoid costly calls across the boundary between managed and unmanaged code. If several components then request the same COM component, they will each receive the same RCW. </p>
			<p>The problem here is that the component calling the RCW that has had <strong class="source-inline">ReleaseComObject</strong> called will often be blamed as the component that generated the exception. But this is not the case—it is the component that called <strong class="source-inline">ReleaseComObject</strong> that is the component at fault, which in our scenario would be the <strong class="source-inline">DatabaseSearch</strong> component.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is recommended by Microsoft developers, especially those on the Visual Studio team, that unless you are 100% certain that there are no managed code items that have access to the RCW, you do not call <strong class="source-inline">Marshal.ReleaseComObject</strong>.</p>
			<p>We will delve deeper into what we have just been discussing by looking at an Excel example.</p>
			<h3>Using the Microsoft Excel 16.0 Object Library in .NET 6</h3>
			<p>We are going to be looking at COM<a id="_idIndexMarker349"/> interoperability in .NET 6 in this section, by referencing<a id="_idIndexMarker350"/> the Microsoft Excel 16.0 Object Library. This library is a COM library. You will see how to use Excel to create a new application, modify it, and save it. When the first example is run a few times, you will see that your code does not fail. But in Task Manager, each time the method is run, another instance of Excel will remain open, as seen in Windows Task Manager. Then, we will move on to see how we can correctly dispose of COM objects<a id="_idIndexMarker351"/> so that instances of Excel <a id="_idIndexMarker352"/>are not kept open when our applications complete. Let’s start by viewing what happens when we don’t release Excel COM objects.</p>
			<h4>Investigating what happens when Excel COM objects are not released</h4>
			<p>In this section, we will create<a id="_idIndexMarker353"/> a spreadsheet, add data to it, and then save the file. This will reveal memory issues that arise from using Excel and not cleaning up properly after ourselves when we have finished using Excel. We will also see how to use Excel and clean up after ourselves so that we prevent memory issues through using Excel.</p>
			<p>Add a COM reference to the <strong class="source-inline">CH04_PreventingMemoryLeaks</strong> project for the <em class="italic">Microsoft Excel 16.0 Object Library</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you add a COM reference to your project, you will have IntelliSense available to you. But when you come to run your successfully compiled program, when it attempts to create an Excel application, it will raise a <strong class="source-inline">FileNotFoundException</strong>-type exception. Therefore, you need to set the values for <strong class="source-inline">EmbedInteropTypes</strong> and <strong class="source-inline">Private</strong> to <strong class="source-inline">true</strong>.</p>
			<p>Since a <strong class="source-inline">FileNotFoundException</strong>-type exception is the last thing we need, edit your project file and then update the <strong class="source-inline">COMReference</strong> section, as follows:</p>
			<pre class="source-code">&lt;ItemGroup&gt;</pre>
			<pre class="source-code">      &lt;COMReference Include="Microsoft.Office.Excel.dll"&gt;</pre>
			<pre class="source-code">          &lt;WrapperTool&gt;tlbimp&lt;/WrapperTool&gt;</pre>
			<pre class="source-code">          &lt;VersionMinor&gt;9&lt;/VersionMinor&gt;</pre>
			<pre class="source-code">          &lt;VersionMajor&gt;1&lt;/VersionMajor&gt;</pre>
			<pre class="source-code">          &lt;Guid&gt;00020813-0000-0000-c000-000000000046&lt;/Guid&gt;</pre>
			<pre class="source-code">          &lt;Lcid&gt;0&lt;/Lcid&gt;</pre>
			<pre class="source-code">          &lt;Isolated&gt;false&lt;/Isolated&gt;</pre>
			<pre class="source-code">          <strong class="bold">&lt;EmbedInteropTypes&gt;True&lt;/EmbedInteropTypes&gt;</strong></pre>
			<pre class="source-code">      <strong class="bold">    &lt;Private&gt;true&lt;/Private&gt;</strong></pre>
			<pre class="source-code">    &lt;/COMReference&gt;</pre>
			<pre class="source-code">  &lt;/ItemGroup&gt;</pre>
			<p>This will ensure that we don’t experience<a id="_idIndexMarker354"/> the <strong class="source-inline">FileNotFoundException</strong>-type exception. Add a new <strong class="source-inline">UsingExcel</strong> class to the project, and then add the following <strong class="source-inline">using</strong> statements:</p>
			<pre class="source-code">using Microsoft.Office.Interop.Excel;</pre>
			<pre class="source-code">using System;</pre>
			<pre class="source-code">using System.Diagnostics;</pre>
			<pre class="source-code">using System.IO;</pre>
			<pre class="source-code">using System.Runtime.InteropServices;</pre>
			<pre class="source-code">using Excel = Microsoft.Office.Interop.Excel;</pre>
			<p>Now, add the <strong class="source-inline">RunExcelExamples()</strong> method, as follows:</p>
			<pre class="source-code">public void RunExcelExamples()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      for (int i = 0; i &lt; 10; i++)</pre>
			<pre class="source-code">          NotReleasingExcelComObjects();</pre>
			<pre class="source-code">      for (int i = 0; i &lt; 10; i++)</pre>
			<pre class="source-code">          ReleasingExcelComObjects();</pre>
			<pre class="source-code">}</pre>
			<p>This method calls two methods. It calls each of these methods 10 times and then exits. Let’s add the <strong class="source-inline">NotReleasingExcelComObjects()</strong> method, as follows:</p>
			<pre class="source-code">private static void NotReleasingExcelComObjects()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      string filename = @"C:\Temp\BucketList.xlsx";</pre>
			<pre class="source-code">      Excel.Application application = new Excel.Application();</pre>
			<pre class="source-code">      application.Visible = false;</pre>
			<pre class="source-code">      Excel.Workbook workbook = application.Workbooks.Add();</pre>
			<pre class="source-code">      Excel.Sheets sheets = workbook.Sheets;</pre>
			<pre class="source-code">      Excel.Worksheet worksheet =(Worksheet)sheets</pre>
			<pre class="source-code">      .Add(sheets[1], Type.Missing, Type.Missing, </pre>
			<pre class="source-code">            Type.Missing);</pre>
			<pre class="source-code">      worksheet.Range["A1"].Value = "Bucket List";</pre>
			<pre class="source-code">      worksheet.Range["A2"].Value = "Visit New Zealand";</pre>
			<pre class="source-code">      worksheet.Range["A1"].Value = "Visit Australia";</pre>
			<pre class="source-code">      if (File.Exists(filename))</pre>
			<pre class="source-code">          File.Delete(filename);</pre>
			<pre class="source-code">      workbook.SaveAs(filename);</pre>
			<pre class="source-code">      workbook.Close();</pre>
			<pre class="source-code">      application.Quit();</pre>
			<pre class="source-code">}</pre>
			<p>This method declares a <strong class="source-inline">filename</strong> string. It then instantiates a new Excel application that is not visible. It then<a id="_idIndexMarker355"/> adds a column header called “<strong class="source-inline">Bucket List”</strong>, and adds two items to that bucket list column in the rows below. It then checks if the file exists. If the file does exist, then it is deleted. The workbook is then saved and closed, and the Excel application is exited. Comment out the following lines from the <strong class="source-inline">RunExcelExamples()</strong> method:</p>
			<pre class="source-code">      for (int i = 0; i &lt; 10; i++)</pre>
			<pre class="source-code">          ReleasingExcelComObjects();</pre>
			<p>If you then save your project and run it, you will find that once the program exits, you are left with multiple Excel processes. Each of these processes takes up memory. The following screenshot shows Excel processes that remain in memory after our program exits:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B16617_Figure_4.4.jpg" alt="Figure 4.4 – Windows Task Manager displaying Excel processes no longer in use using up memory&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Windows Task Manager displaying Excel processes no longer in use using up memory</p>
			<p>As you can see, these Excel processes<a id="_idIndexMarker356"/> that remain in memory after our program finishes are using up 367.6 <strong class="bold">megabytes</strong> (<strong class="bold">MB</strong>) of RAM, which is the combined sum of all Excel processes’ RAM. If this program in its current form were to be run multiple times, you would eventually run out of memory, as the Excel processes left running in memory constitute a memory leak. Each time the program runs, you are using up another 367 MB of RAM, or thereabouts. Eventually, the amount of memory available will not be enough, and you will end up with an out-of-memory exception.</p>
			<p>The following screenshot shows the display in Task Manager after the program has been run once:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B16617_Figure_4.5.jpg" alt="Figure 4.5 – Windows Task Manager after the program has been run once&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Windows Task Manager after the program has been run once</p>
			<p>From <em class="italic">Figure 4.5</em>, we can see that<a id="_idIndexMarker357"/> we are using 7.4 GB (793 MB), with 8.5 GB RAM still available to us. Run the program through a number of times continually. Each time the program is run, you will see the compressed memory rise and the available memory fall. At no point does the memory appear to be reclaimed, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B16617_Figure_4.6.jpg" alt="Figure 4.6 – Windows Task Manager displaying increased memory usage and diminished available memory after multiple program runs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Windows Task Manager displaying increased memory usage and diminished available memory after multiple program runs</p>
			<p>After multiple continuous runs<a id="_idIndexMarker358"/> of our program, we can see that our <strong class="bold">In use (Compressed)</strong> memory has gone from 7.4 GB (793 MB) to 10.9 GB (799 MB) and our available memory has gone from 8.5 GB to 4.9 GB. This is clearly a problem that needs to be addressed, but how? </p>
			<p>This is where the <strong class="source-inline">ReleasingExcelComObjects()</strong> method shown here comes in:</p>
			<pre class="source-code">[System.Diagnostics.CodeAnalysis SuppressMessage</pre>
			<pre class="source-code">  ("Interoperability","CA1416:Validate platform compatibility",</pre>
			<pre class="source-code">    Justification = "Windows only code.")]</pre>
			<pre class="source-code">private static void ReleasingExcelComObjects()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      Excel.Application application = null;</pre>
			<pre class="source-code">      Excel.Workbooks workbooks = null;</pre>
			<pre class="source-code">      Excel.Workbook workbook = null;</pre>
			<pre class="source-code">      Excel.Sheets worksheets = null;</pre>
			<pre class="source-code">      Excel.Worksheet worksheet = null;</pre>
			<pre class="source-code">      Excel.Range range = null;</pre>
			<pre class="source-code">      Try</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          string filename = @"C:\Temp\BucketList.xlsx";</pre>
			<pre class="source-code">          application = new Excel.Application();</pre>
			<pre class="source-code">          application.Visible = false;</pre>
			<pre class="source-code">          workbooks = application.Workbooks;</pre>
			<pre class="source-code">          workbook = workbooks.Add();</pre>
			<pre class="source-code">          worksheets = workbook.Sheets;</pre>
			<pre class="source-code">          worksheet = (Worksheet)worksheets.Add(worksheets[1], </pre>
			<pre class="source-code">              Type.Missing, Type.Missing, Type.Missing);</pre>
			<pre class="source-code">          range = worksheet.Range["A1"];</pre>
			<pre class="source-code">          range.Value = "Bucket List";</pre>
			<pre class="source-code">          range = worksheet.Range["A2"];</pre>
			<pre class="source-code">          range.Value = "Visit New Zealand";</pre>
			<pre class="source-code">          range = worksheet.Range["A3"];</pre>
			<pre class="source-code">          range.Value = "Visit Australia";</pre>
			<pre class="source-code">          if (File.Exists(filename))</pre>
			<pre class="source-code">              File.Delete(filename);</pre>
			<pre class="source-code">          workbook.SaveAs(filename);</pre>
			<pre class="source-code">          workbook.Close();</pre>
			<pre class="source-code">          application.Quit();</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      Finally</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          if (range != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(range);</pre>
			<pre class="source-code">          if (worksheet != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(worksheet);</pre>
			<pre class="source-code">          if (worksheets != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(worksheets);</pre>
			<pre class="source-code">          if (workbook != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(workbook);</pre>
			<pre class="source-code">          if (workbooks != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(workbooks);</pre>
			<pre class="source-code">          if (application != null) </pre>
			<pre class="source-code">              Marshal.FinalReleaseComObject(application);</pre>
			<pre class="source-code">          range = null;</pre>
			<pre class="source-code">          worksheet = null;</pre>
			<pre class="source-code">          worksheets = null;</pre>
			<pre class="source-code">          workbook = null;</pre>
			<pre class="source-code">          worksheets = null;</pre>
			<pre class="source-code">          application = null;</pre>
			<pre class="source-code">          GC.Collect();</pre>
			<pre class="source-code">          GC.WaitForPendingFinalizers();</pre>
			<pre class="source-code">          Process[] processes = </pre>
			<pre class="source-code">              Process.GetProcessesByName("EXCEL");</pre>
			<pre class="source-code">          foreach (Process process in processes)</pre>
			<pre class="source-code">              process.Kill();</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">}</pre>
			<p>This rather lengthy method<a id="_idIndexMarker359"/> does what we need Excel to do—it releases the Excel COM objects, sets the managed objects to <strong class="source-inline">null</strong>, runs the garbage collector, and then terminates all running Excel processes. If you uncomment the code in the <strong class="source-inline">RunExcelExamples()</strong> method and then run the code once, you will see that we no longer have any Excel processes running in memory once our code has finished running. You will also see if you look at the <strong class="bold">Performance</strong> tab of Windows Task Manager that we have reclaimed our memory. </p>
			<p>We have managed to fix our memory leak by terminating COM components and setting managed objects to <strong class="source-inline">null</strong> to remove managed references. Then, we killed all processes called <strong class="source-inline">EXCEL</strong>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Be careful when using the <strong class="source-inline">process.Kill()</strong> method to kill off all processes for<a id="_idIndexMarker360"/> a given name such as <strong class="source-inline">EXCEL</strong>. There may be other programs that also use that process that could be badly impacted by such termination. You should run such code in an isolated environment if doing batch processing on a server, or schedule such operations for a time when you can guarantee that other processes will not be affected by running such code.</p>
			<p>It is now time to look at how using events can be a source of memory leaks.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>How using events can be a source of memory leaks</h2>
			<p>In this section, we will look<a id="_idIndexMarker361"/> at how the use of events in your computer programs<a id="_idIndexMarker362"/> can be a source of memory leaks. We will demonstrate this using a very simple Windows Forms application that we will write. Then, we will analyze our memory usage using JetBrains dotMemory. There will be two methods employed to show events in use. One method will generate a memory leak, while the other won’t generate a memory leak.</p>
			<p>So, how can using events generate memory leaks?</p>
			<p>Unless you are using anonymous methods, subscribing to an event holds a reference to the class that holds that event until such time as the event is unsubscribed from. Consider the following class:</p>
			<pre class="source-code">internal class EventSubscriber</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      public EventSubscriber(Control control)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          Control.TextChanged += OnTextChanged</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      private void OnTextChanged(</pre>
			<pre class="source-code">          object sender, </pre>
			<pre class="source-code">          EventArgs eventArgs</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">          Text ((Control)sender).Text;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">}</pre>
			<p>If the control outlives the <strong class="source-inline">EventSubscriber</strong> class, then all instances of <strong class="source-inline">EventSubscriber</strong> will not be deallocated by the garbage collector. The end result is a memory leak. Here are some different ways to avoid event-based memory leaks:</p>
			<ol>
				<li value="1">Subscribe to anonymous methods.</li>
				<li>Unsubscribe from events when you are finished with them.</li>
				<li>Implement the weak-handler pattern.</li>
			</ol>
			<p>Before we look at each<a id="_idIndexMarker363"/> of these ways of avoiding memory leaks, we will write<a id="_idIndexMarker364"/> our Windows Forms application that demonstrates a way to avoid memory leaks and a way to generate memory leaks. Follow these steps:</p>
			<ol>
				<li value="1">Start a new .NET Core Windows Forms project, and then change the target framework from .NET Core 3.1 to .NET 5 in the project settings.</li>
				<li>Rename <strong class="source-inline">Form1</strong> to <strong class="source-inline">MainForm</strong>.</li>
				<li>Add a label called <strong class="source-inline">InformationLabel</strong> with the text <strong class="source-inline">“Information”</strong>, a button called <strong class="source-inline">RaiseEventsButton</strong> with the text <strong class="source-inline">“Raise Events”</strong>, and another label called <strong class="source-inline">ProgressLabel</strong> with the text <strong class="source-inline">“Progress:”</strong>. You can lay the components out and style them according to your preference.</li>
				<li>Double-click on the <strong class="source-inline">RaiseEventsButton</strong> button. This will generate a click event handler method.</li>
				<li>Add a class to the project called <strong class="source-inline">EventOne</strong>. You will need the following <strong class="source-inline">using</strong> statements:<p class="source-code">using System;</p><p class="source-code">using System.Threading;</p></li>
				<li>Add the following code to the top of the <strong class="source-inline">EventOne</strong> class:<p class="source-code">public event EventHandler OnEventRaised;</p><p class="source-code">private static int _count;</p><p class="source-code">public static int Count { get { return _count; } }</p></li>
				<li>These elements are needed to handle the event and keep a count of how many instances are still being kept alive. Add the constructor, as follows:<p class="source-code">public EventOne()</p><p class="source-code">{</p><p class="source-code">      Interlocked.Increment(ref _count);</p><p class="source-code">}</p></li>
				<li>The constructor<a id="_idIndexMarker365"/> code increments the _<strong class="source-inline">count</strong> member variable<a id="_idIndexMarker366"/> in an atomic and thread-safe manner for each instance of the class. Add the <strong class="source-inline">RaiseEvent(EventArgs e)</strong> method, as follows:<p class="source-code">public void RaiseEvent(EventArgs e)</p><p class="source-code">{</p><p class="source-code">      EventHandler eventHandler = OnEventRaised;</p><p class="source-code">            if (eventHandler != null)</p><p class="source-code">                  eventHandler(this, e);</p><p class="source-code">}</p></li>
				<li>This method is called by the clients and is responsible for firing the event upon request. Now, add the finalizer, as follows:<p class="source-code">~EventOne()</p><p class="source-code">{</p><p class="source-code">      Interlocked.Decrement(ref _count);</p><p class="source-code">}</p></li>
				<li>The finalizer decrements the _<strong class="source-inline">count</strong> member variable in a thread-safe manner each time an instance of the class is terminated and collected by the garbage collector. Add a new <strong class="source-inline">EventTwo</strong> class to the project. You will need the following <strong class="source-inline">using</strong> statements:<p class="source-code">using System;</p><p class="source-code">using System.Threading;</p><p class="source-code">using System.Windows.Forms;</p></li>
				<li>Add the following code to the top of the <strong class="source-inline">EventTwo</strong> class:<p class="source-code">private static int _count;</p><p class="source-code">public static int Count { get { return _count; } }</p><p class="source-code">public string Text { get; private set; }</p></li>
				<li>The code stores the count<a id="_idIndexMarker367"/> of the number of alive instances and the current<a id="_idIndexMarker368"/> text of the subscribed control. Add the following constructor:<p class="source-code">public EventTwo(Control control)</p><p class="source-code">{</p><p class="source-code">      Interlocked.Increment(ref _count);</p><p class="source-code">      control.TextChanged += OnTextChanged;</p><p class="source-code">}</p></li>
				<li>The constructor takes a Windows Forms control as a parameter. It increments the <strong class="source-inline">_count</strong> member variable by one in a thread-safe manner. It then subscribes to the <strong class="source-inline">TextChanged</strong> event that is handled by the <strong class="source-inline">OnTextChanged</strong> method. Add the <strong class="source-inline">OnTextChanged</strong> method, as follows:<p class="source-code">private void OnTextChanged(object sender, EventArgs </p><p class="source-code">    eventArgs)</p><p class="source-code">{</p><p class="source-code">      Text = ((Control)sender).Text;</p><p class="source-code">}</p></li>
				<li>This method is fired when the <strong class="source-inline">Text</strong> property of the subscribed control is changed. It takes the <strong class="source-inline">Text</strong> content of the control and assigns it to the <strong class="source-inline">Text</strong> property of the <strong class="source-inline">EventTwo</strong> class. Add the <strong class="source-inline">Finalizer()</strong> method, as follows:<p class="source-code">~EventTwo()</p><p class="source-code">{</p><p class="source-code">      Interlocked.Decrement(ref _count);</p><p class="source-code">}</p></li>
				<li>The finalizer decrements the <strong class="source-inline">_count</strong> member variable<a id="_idIndexMarker369"/> by one in a thread-safe manner each time an instance is garbage-collected. We now have in place the two classes that our form will<a id="_idIndexMarker370"/> use for raising events. Switch back to the <strong class="source-inline">MainForm</strong> class.</li>
				<li>At the top of the <strong class="source-inline">MainForm</strong> class, add the following member variables:<p class="source-code">private int _eventsGeneratedCount;</p><p class="source-code">private int _eventSubscriberCount;</p></li>
				<li>These two values will store the number of events that have been generated. Add the <strong class="source-inline">SetTitleText()</strong> method, as follows:<p class="source-code">private void SetTitleText()</p><p class="source-code">{</p><p class="source-code">      Text = $"{_eventsGeneratedCount}/{EventOne.Count} – </p><p class="source-code">          {_eventSubscriberCount}/{EventTwo.Count}";</p><p class="source-code">}</p></li>
				<li>This method sets the control’s <strong class="source-inline">Text</strong> property for each method that raises events. The text displays the number of events raised and the number of events still alive for the non-memory leak method, and the same again for the memory leak method. Add the <strong class="source-inline">SetInformationLabelText()</strong> method, as follows:<p class="source-code">private void SetInformationLabelText()</p><p class="source-code">{</p><p class="source-code">      StringBuilder sb = new StringBuilder();</p><p class="source-code">      sb.AppendLine($"Raised Events (No Memory Leak):</p><p class="source-code">          {_eventsGeneratedCount},  Alive Events: </p><p class="source-code">            {EventOne.Count}");</p><p class="source-code">      sb.AppendLine($"Raised Events (Memory Leak): </p><p class="source-code">          {_eventSubscriberCount},  Alive Events: </p><p class="source-code">            {EventTwo.Count}");</p><p class="source-code">      InformationLabel.Text = sb.ToString();</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">SetInformationLabelText()</strong> method updates the <strong class="source-inline">InformationLabel</strong> text to display<a id="_idIndexMarker371"/> the number of events raised in<a id="_idIndexMarker372"/> each method and the number of events remaining in memory once both methods have finished executing. Add the <strong class="source-inline">RaiseEvent</strong> method, as follows:<p class="source-code">private void RaiseEvent(object sender, EventArgs e)</p><p class="source-code">{</p><p class="source-code">      ProgressLabel.Text = $"Event Raised: </p><p class="source-code">          {DateTime.Now}";</p><p class="source-code">      ProgressLabel.Invalidate();</p><p class="source-code">      ProgressLabel.Update();</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">RaiseEvent</strong> method updates the <strong class="source-inline">ProgressLabel.Text</strong> property, but so that it is updated in real time, it is necessary to call the <strong class="source-inline">Invalidate()</strong> and <strong class="source-inline">Update()</strong> methods. Now, add the <strong class="source-inline">MemoryLeakMethod</strong> method, as follows:<p class="source-code">private void MemoryLeakMethod(EventArgs e)</p><p class="source-code">{</p><p class="source-code">      int count = 10000;</p><p class="source-code">      for (int x = 0; x &lt; count; x++)</p><p class="source-code">      {</p><p class="source-code">            var eventTwo = new EventTwo(this);</p><p class="source-code">      }</p><p class="source-code">      _eventTwoCount += count;</p><p class="source-code">}</p></li>
				<li>This method declares a count<a id="_idIndexMarker373"/> of 10,000 items. It then loops<a id="_idIndexMarker374"/> through 10,000 iterations. A new <strong class="source-inline">EventTwo</strong> object is subscribed to with the reference to <strong class="source-inline">MainForm</strong> passed in. Once the loop completes, the <strong class="source-inline">_eventTwoCount</strong> variable is incremented by 10,000. Next, we will add the <strong class="source-inline">NoMemoryLeakedMethod</strong> method, as follows:<p class="source-code">private void NoMemoryLeakMethod(EventArgs e)</p><p class="source-code">{</p><p class="source-code">      int count = 10000;</p><p class="source-code">      for (int x = 0; x &lt; count; x++)</p><p class="source-code">      {</p><p class="source-code">      EventOne eventOne = new EventOne();</p><p class="source-code">      eventOne.OnEventRaised += RaiseEvent;</p><p class="source-code">      eventOne.RaiseEvent(e);</p><p class="source-code">      }</p><p class="source-code">      _eventOneCount += count;</p><p class="source-code">}</p></li>
				<li>This method declares a count of 10,000. It iterates 10,000 times. During that 10,000 times, it instantiates a new <strong class="source-inline">EventOne</strong> object, adds an event handler called <strong class="source-inline">RaisedEvent</strong>, and then raises the event. Once, the loop has completed, the <strong class="source-inline">_eventOneCount</strong> variable is incremented by 10,000. Update the click event handler with the following code:<p class="source-code">NoMemoryLeakMethod(e);</p><p class="source-code">MemoryLeakMethod(e);</p><p class="source-code">SetInformationLabelText();</p><p class="source-code">SetTitleText();</p></li>
				<li>Change the build mode to <strong class="source-inline">Release</strong> and build the project.</li>
				<li>Open <strong class="bold">JetBrains dotMemory</strong>. Select <strong class="bold">Local</strong> | <strong class="bold">.NET Core Application</strong>, select an executable<a id="_idIndexMarker375"/> generated by the build<a id="_idIndexMarker376"/> process, then check the <strong class="bold">Collect memory allocation and traffic from start</strong> box. Your screen should look like this: </li>
			</ol>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B16617_Figure_4.7.jpg" alt="Figure 4.7 – The JetBrains dotMemory configuration screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – The JetBrains dotMemory configuration screen</p>
			<ol>
				<li value="25">Click on the <strong class="bold">Run</strong> button. This<a id="_idIndexMarker377"/> will start your application and profiling<a id="_idIndexMarker378"/> session, as shown in the next two screenshots: </li>
			</ol>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B16617_Figure_4.8.jpg" alt="Figure 4.8 – JetBrains dotMemory profiling our Windows Forms application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – JetBrains dotMemory profiling our Windows Forms application</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B16617_Figure_4.9.jpg" alt="Figure 4.9 – Our Windows Forms application before any events have been run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Our Windows Forms application before any events have been run</p>
			<ol>
				<li value="26">Click on the <strong class="bold">Raise Events</strong> button a few times. Each time you click on the button, the memory profile <a id="_idIndexMarker379"/>should change and the memory usage<a id="_idIndexMarker380"/> should increase, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B16617_Figure_4.10.jpg" alt="Figure 4.10 – Our Windows Forms application showing 50,000 alive events, &#13;&#10;indicating we have a memory leak&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Our Windows Forms application showing 50,000 alive events, indicating we have a memory leak</p>
			<ol>
				<li value="27">As you can see, we have a memory leak. Our <strong class="source-inline">NoMemoryLeakMethod</strong> method does not generate a memory leak. As you can see, after 50,000 raised events, the objects kept alive in memory is 0. But our <strong class="source-inline">MemoryLeakMethod</strong> method does produce a memory leak. Out of 50,000 raised events, 50,000 objects remain alive.</li>
				<li>Run the program a few more times, and pay attention to what is going on in dotMemory. When you see a point of interest, click on the area and then click on <strong class="bold">Get Snapshot</strong>. This will take a snapshot of that moment in time that users can analyze to see if there are any<a id="_idIndexMarker381"/> issues. You should end up with<a id="_idIndexMarker382"/> something similar to this: </li>
			</ol>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B16617_Figure_4.11.jpg" alt="Figure 4.11 – JetBrains dotMemory profile of our Windows Forms application &#13;&#10;when events are raised and snapshots are taken&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – JetBrains dotMemory profile of our Windows Forms application when events are raised and snapshots are taken</p>
			<ol>
				<li value="29">Click on any one<a id="_idIndexMarker383"/> of your snapshots. You should<a id="_idIndexMarker384"/> see an output like this: </li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B16617_Figure_4.12.jpg" alt="Figure 4.12 – A memory leak has been identified with the EventTwo class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – A memory leak has been identified with the EventTwo class</p>
			<ol>
				<li value="30">JetBrains dotMemory has detected a memory leak in the <strong class="source-inline">EventTwo</strong> class. This is because the class subscribes to an event of another object, but never unsubscribes from it. However, you will see that all the objects for the <strong class="source-inline">EventOne</strong> class have been finalized.</li>
			</ol>
			<p>You have seen how to use events<a id="_idIndexMarker385"/> in such a way that generates memory<a id="_idIndexMarker386"/> leaks and in such a way that all objects are finalized and a memory leak is prevented. Let’s revisit the three ways to prevent memory leaks when using events, as follows:</p>
			<ol>
				<li value="1">Subscribe to anonymous methods.</li>
				<li>Unsubscribe from events when you are finished with them.</li>
				<li>Implement the weak-handler pattern.</li>
			</ol>
			<p>Let’s take a look at subscribing to anonymous methods and then unsubscribing</p>
			<h3>Using local methods</h3>
			<p>Prior to C# 7.0, you would <a id="_idIndexMarker387"/>use anonymous methods as a way of handling events such that you avoid introducing memory leaks. As of C# 7.0, you can use local methods. In this example, we will handle events using local methods. Follow these next steps:</p>
			<ol>
				<li value="1">Load the <strong class="source-inline">CH04_PreventingMemoryLeaks</strong> project.</li>
				<li>Add a class called <strong class="source-inline">Website</strong>, as follows:<p class="source-code">internal class Website</p><p class="source-code">{</p><p class="source-code">      public event EventHandler&lt;EventArgs&gt; Login;</p><p class="source-code">      public event EventHandler&lt;EventArgs&gt; Logout;</p><p class="source-code">}</p></li>
				<li>This class has<a id="_idIndexMarker388"/> two events for logging in and logging out of a website. Add a new class called <strong class="source-inline">AnonymousEventSubscription</strong>. Add the <strong class="source-inline">Login()</strong> method, as follows:<p class="source-code">public void Login()</p><p class="source-code">{</p><p class="source-code">      Website website = new Website();</p><p class="source-code">      void LoginHandler(object sender, EventArgs args)</p><p class="source-code">      {</p><p class="source-code">          Debug.WriteLine("Anonymous login event handler </p><p class="source-code">            using a local method.");</p><p class="source-code">          website.Login -= LoginHandler;</p><p class="source-code">      };</p><p class="source-code">      website.Login += LoginHandler;</p><p class="source-code">      LoginHandler(this, new EventArgs());</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">Login()</strong> method instantiates a new <strong class="source-inline">Website</strong> object. It then has a local method called <strong class="source-inline">LoginHandler</strong> that writes a message to the debug window and then unsubscribes from the <strong class="source-inline">Website.Login</strong> event. Then, outside of the local method, it subscribes to the <strong class="source-inline">Website.Login</strong> event and raises the event. Let’s add the <strong class="source-inline">Logout()</strong> method, as follows:<p class="source-code">public void Logout()</p><p class="source-code">{</p><p class="source-code">      Website website = new Website();</p><p class="source-code">      void LogoutHandler(object sender, EventArgs args)</p><p class="source-code">      {</p><p class="source-code">          Debug.WriteLine("Anonymous logout event handler </p><p class="source-code">            using a local method.");</p><p class="source-code">          website.Logout -= LogoutHandler;</p><p class="source-code">      };</p><p class="source-code">      website.Logout += LogoutHandler;</p><p class="source-code">      LogoutHandler(this, new EventArgs());</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">Logout()</strong> method<a id="_idIndexMarker389"/> instantiates a new <strong class="source-inline">Website</strong> object. It then has a local method called <strong class="source-inline">LogoutHandler</strong> that writes a message to the debug window and then unsubscribes from the <strong class="source-inline">Website.Logout</strong> event. Then, outside of the local method, it adds the event handler for the <strong class="source-inline">Website.Logout</strong> event, and then raises the event. </li>
				<li>In the <strong class="source-inline">Main</strong> method, comment out the <strong class="source-inline">RunExcelExamples()</strong> line. Then, add the <strong class="source-inline">UseAnonymousEventSubscription()</strong> method call, as follows:<p class="source-code">private static void UseAnonymousEventSubscriptions()</p><p class="source-code">{</p><p class="source-code">      for (int x = 0; x &lt; 1000000; x++)</p><p class="source-code">      {</p><p class="source-code">          AnonymousEventSubscription aes = new </p><p class="source-code">            AnonymousEventSubscription();</p><p class="source-code">          aes.Login();</p><p class="source-code">          aes.Logout();</p><p class="source-code">      }</p><p class="source-code">}</p></li>
				<li>This code runs<a id="_idIndexMarker390"/> through 1,000,000 iterations. For each iteration, a new <strong class="source-inline">AnonymousEventSubscription</strong> is instantiated, with calls to <strong class="source-inline">Login()</strong> and <strong class="source-inline">Logout()</strong> made. These two calls will each have a subscription to an event, an event executed via a local method, and, as the local method is executed, the event it will be unsubscribed from.</li>
				<li>If you build and run the code, you should see the following lines printed 1,000,000 times in your debug window: </li>
			</ol>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B16617_Figure_4.13.jpg" alt="Figure 4.13 – The debug window showing events firing for Login and Logout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – The debug window showing events firing for Login and Logout</p>
			<ol>
				<li value="9">If you perform a release build and run dotMemory, you will see that we have no memory leak, considering we have just generated 2,000,000 event subscriptions and unsubscriptions—that is, 1,000,000 for <strong class="source-inline">Login()</strong> and 1,000,000 for <strong class="source-inline">Logout()</strong>.</li>
			</ol>
			<p>We have seen how to effectively use anonymous events using local methods without causing memory leaks. Now, let’s look at our final topic of the chapter—weak references.</p>
			<h3>Using weak reference events</h3>
			<p>We use the weak reference<a id="_idIndexMarker391"/> event pattern to allow an object to be garbage-collected if its only remaining link is an event handler. We will implement the weak reference event pattern in this section in the <strong class="source-inline">CH04_PreventingMemoryLeaks</strong> project. Follow these next steps:</p>
			<ol>
				<li value="1">In the Package Manager Console, type the following: <strong class="source-inline">install-package WeakEventListener</strong>. The <strong class="source-inline">System.Windows.WeakEventManager</strong> package only works with .NET 4.8 and older, which is why we install this package.</li>
				<li>Add the following <strong class="source-inline">SampleClass</strong> class:<p class="source-code">internal class SampleClass</p><p class="source-code">{</p><p class="source-code">      public event EventHandler&lt;EventArgs&gt; RaiseEvent;</p><p class="source-code">      public void DoSomething()</p><p class="source-code">      {</p><p class="source-code">          OnRaiseEvent();</p><p class="source-code">      }</p><p class="source-code">      protected virtual void OnRaiseEvent()</p><p class="source-code">      {</p><p class="source-code">          RaiseEvent?.Invoke(this, EventArgs.Empty);</p><p class="source-code">      }</p><p class="source-code">}</p></li>
				<li>In this class, we declare an event called <strong class="source-inline">RaiseEvent</strong>. The <strong class="source-inline">DoSomething()</strong> method calls the <strong class="source-inline">OnRaiseEvent()</strong> method. The <strong class="source-inline">OnRaiseEvent()</strong> method checks if the event is <strong class="source-inline">null</strong>; if it is not <strong class="source-inline">null</strong>, then the event is invoked. Add a new class called <strong class="source-inline">UsingWeakreferences</strong>. You will need the following references:<p class="source-code">using System;</p><p class="source-code">using System.Diagnostics;</p><p class="source-code">using WeakEventListener;</p></li>
				<li>Add the <strong class="source-inline">RaiseWeakReferenceEvents()</strong> method, as follows:<p class="source-code">public void RaiseWeakReferenceEvents()</p><p class="source-code">{</p><p class="source-code">      bool isOnEventTriggered = false;</p><p class="source-code">      bool isOnDetachTriggered = false;</p><p class="source-code">      SampleClass sample = new SampleClass();</p><p class="source-code">      WeakEventListener&lt;SampleClass, object, EventArgs&gt; </p><p class="source-code">        weak = new WeakEventListener&lt;SampleClass, object, </p><p class="source-code">                EventArgs&gt;(sample);</p><p class="source-code">      weak.OnEventAction = (instance, source, eventArgs) </p><p class="source-code">        =&gt; { isOnEventTriggered = true; };</p><p class="source-code">      weak.OnDetachAction = (listener) =&gt;</p><p class="source-code">        {isOnDetachTriggered = true; };</p><p class="source-code">      sample.Raisevent += weak.OnEvent;</p><p class="source-code">      sample.DoSomething();</p><p class="source-code">      Debug.Assert(isOnEventTriggered);</p><p class="source-code">      weak.Detach();</p><p class="source-code">      Debug.Assert(isOnDetachTriggered);</p><p class="source-code">}</p></li>
				<li>We have two variables that are <strong class="source-inline">true</strong> when an event has been triggered and when it has been detached. We instantiate a new <strong class="source-inline">SampleClass</strong> class instance. Then we declare a <strong class="source-inline">WeakEventListener</strong> package that references the <strong class="source-inline">SampleClass</strong> class. Anonymous methods are used to handle the <strong class="source-inline">OnEventAction</strong> and <strong class="source-inline">OnDetachAction</strong> methods. The <strong class="source-inline">WeakReferenceListener.OnEvent</strong> method is then assigned as the handler for the <strong class="source-inline">SampleClass.RaiseEvent</strong> event. We then call the <strong class="source-inline">DoSomething()</strong> method that raises the event. Then, we assert that the event has been triggered, detach the event, and then assert that the event has been detached.</li>
				<li>Make sure the<a id="_idIndexMarker392"/> project is set to <strong class="bold">Debug</strong> mode, and then step through the code. It should work as expected, with the event being correctly triggered and detached.</li>
			</ol>
			<p>Let’s now summarize what we have learned in this chapter. </p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Summary</h1>
			<p>We looked at object generations and saw how easy it was to generate a <strong class="source-inline">System.OutOfMemoryException</strong>-type exception. We saw how we can use predictive out-of-memory exception checking to save time by preventing the running of code that will cause this exception.</p>
			<p>Then, we moved on to discuss long weak references and short weak references. We learned that strong references are not garbage-collected, and weak references are garbage-collected.</p>
			<p>We then looked at finalization and saw how the <strong class="source-inline">Finalize()</strong> method will be called on objects that are not disposed of, and that we have no control over when the <strong class="source-inline">Finalize()</strong> method will run. Then, we looked at how to implement the <strong class="source-inline">IDisposable</strong> pattern and suppress the need for garbage collection to call <strong class="source-inline">Finalize()</strong>.</p>
			<p>Finally, we looked at the various ways to prevent memory leaks, such as properly disposing of managed resources and unmanaged resources. We also saw how to correctly handle events so that we do not cause memory leaks.</p>
			<p>With what you have learned in this chapter, you will be able to overcome out-of-memory exceptions, improve memory performance, and improve garbage collection in your applications, and you will be to correctly use events and event handlers without generating memory leaks and will be able to effectively release COM objects and allocated memory. This will lead to better quality and more stable programs that make good use of memory.</p>
			<p>In the next chapter, we will be looking at application profiling.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Questions</h1>
			<ol>
				<li value="1">How many object generations are there?</li>
				<li>Which sized objects get placed on the SOH?</li>
				<li>Which sized objects get placed on the LOH?</li>
				<li>What is a strong reference?</li>
				<li>What is a weak reference?</li>
				<li>How can we clean up objects without having to rely on finalization?</li>
				<li>How do we avoid memory leaks when using events?</li>
				<li>Which method do we use to release COM objects?</li>
				<li>How do we prevent memory leaks when allocating memory?</li>
			</ol>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Further reading</h1>
			<ul>
				<li>Weak references: <a href="https://www.youtube.com/watch?v=2WcDhh8lvJs">https://www.youtube.com/watch?v=2WcDhh8lvJs</a></li>
				<li><strong class="source-inline">ComWrappers</strong> class: https://docs.microsoft.com/ dotnet/api/system.runtime.interopservices.comwrappers?view=net-5.0</li>
				<li><em class="italic">Marshal.ReleaseComObject Considered Dangerous</em>: <a href="https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/">https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/</a></li>
				<li><em class="italic">WeakEventManager Class:</em> https://docs.microsoft.com /dotnet/api/system.windows.weakeventmanager?view=net-5.0</li>
				<li><em class="italic">Weak Event Patterns</em>: <a href="https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8">https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8</a></li>
				<li><em class="italic">How to properly release Excel COM objects</em>: <a href="https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/">https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/</a></li>
				<li><em class="italic">Understanding and Avoiding Memory Leaks with Event Handlers and Event Aggregators</em>: <a href="https://www.markheath.net/post/understanding-and-avoiding-memory-leaks">https://www.markheath.net/post/understanding-and-avoiding-memory-leaks</a></li>
				<li>Why and how to avoid event handler memory leaks: <a href="https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks">https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks</a></li>
				<li><em class="italic">.NET Framework technologies unavailable on .NET Core and .NET 5+:</em> <a href="https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable">https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable</a></li>
			</ul>
		</div>
	</body></html>