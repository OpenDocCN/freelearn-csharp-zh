<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Continuing the Space Shooter"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Continuing the Space Shooter</h1></div></div></div><p>This chapter continues from the previous one in creating a twin-stick space shooter game. At this stage, we have a working game. At least, the gamer can control a spaceship using two axes: movement and rotation. WASD keys on the keyboard control movement (up, down, left, and right) and the mouse cursor controls rotation—the spaceship always rotates to face the cursor. In addition to player controls, the level features enemy characters that spawn at regular intervals, fly around the level, and move toward the player with hostile intent. Finally, both the player and enemies support a Health component, which means both are susceptible to damage and can be destroyed. Right now, however, the player lacks two important features: it cannot fire a weapon and it cannot increase the score. This chapter tackles these issues and more. Firing weapons, as we'll see, represents a particularly interesting problem. Overall, this chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Weapons and spawning ammo</li><li class="listitem" style="list-style-type: disc">Memory management and pooling</li><li class="listitem" style="list-style-type: disc">Sound and audio</li><li class="listitem" style="list-style-type: disc">Scoring</li><li class="listitem" style="list-style-type: disc">Debugging and testing</li><li class="listitem" style="list-style-type: disc">Building and distribution</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The completed project so far can be found in the book's companion files in the <code class="literal">Chapter04/Start</code> folder. You can start here and follow along with this chapter if you don't have your own project already.</p></div></div><div class="section" title="Guns and gun turrets"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Guns and gun turrets</h1></div></div></div><p>Let's start tackling <a id="id235" class="indexterm"/>weapons in detail. Specifically, the level contains a <a id="id236" class="indexterm"/>player and enemy ships. The player must shoot enemies but, right now, cannot do so. See <span class="emphasis"><em>Figure 4.1</em></span>. On thinking carefully about weapons, we identify three main concepts or things that need development. First, there's the spawner or generator—the object that actually fires ammo in the scene when the fire button is pressed. Second, there's the ammo itself that, once generated, travels through the level on its own. Third, there's the ability for ammo to collide with other objects and damage them.</p><div class="mediaobject"><img src="graphics/B05118_04_01.jpg" alt="Guns and gun turrets"/><div class="caption"><p>Figure 4.1: The game so far</p></div></div><p>Tackling each area in order, we <a id="id237" class="indexterm"/>begin with turrets—the points where bullets are spawned and fired. For this game, the player will have only one turret, but ideally, the game should support the addition of more, if desired, allowing the player to dual-fire or <a id="id238" class="indexterm"/>more! To create the first turret, add a new empty game object to the scene by selecting <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu. Name this <code class="literal">Turret</code>. Then, position the <code class="literal">Turret</code> object to the front of the spaceship, making sure that the blue forward vector arrow is pointing ahead in the direction that ammo will be fired. Finally, make the turret a child of the spaceship by dragging and dropping it in the <span class="strong"><strong>Hierarchy</strong></span> panel. See <span class="emphasis"><em>Figure 4.2</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_02.jpg" alt="Guns and gun turrets"/><div class="caption"><p>Figure 4.2:Positioning a Turret object as a child of the spaceship</p></div></div><p>Creating a <code class="literal">Turret</code> object for the ammo as a spawn location is a splendid beginning, but for ammo to actually be <a id="id239" class="indexterm"/>fired, we'll need an ammo object. Specifically, we'll <a id="id240" class="indexterm"/>create an <code class="literal">Ammo</code> prefab that can be instantiated as ammo, when needed. We'll do this next.</p></div></div>
<div class="section" title="Ammo prefabs"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Ammo prefabs</h1></div></div></div><p>When the player presses <a id="id241" class="indexterm"/>the fire button, the spaceship should shoot ammo objects in the scene. These objects will be based on an <code class="literal">Ammo</code> <a id="id242" class="indexterm"/>prefab. Let's create this prefab now. To start, we'll configure the texture to be used as an ammo graphic. Open the <code class="literal">Textures</code> folder in the <span class="strong"><strong>Project</strong></span> panel, and select the <code class="literal">Ammo</code> texture. This texture features several different versions of an ammo sprite, aligned in a row side by side. See <span class="emphasis"><em>Figure 4.3</em></span>. When ammo is fired, we don't want to show the complete texture; instead, we want to show either just one of the images or the images played as an animation sequence, frame by frame.</p><div class="mediaobject"><img src="graphics/B05118_04_03.jpg" alt="Ammo prefabs"/><div class="caption"><p>Figure 4.3: Preparing to create an Ammo prefab</p></div></div><p>Presently, Unity recognizes the texture (and each ammo element) as a complete unit. We can use Sprite Editor, however, to separate each part. To do this, select the <span class="strong"><strong>Texture</strong></span> in the project (if it's not already <a id="id243" class="indexterm"/>selected), and then (from the <span class="strong"><strong>Object Inspector</strong></span>) change <a id="id244" class="indexterm"/>the <span class="strong"><strong>Sprite Mode</strong></span> drop-down from <span class="strong"><strong>Single</strong></span> to <span class="strong"><strong>Multiple</strong></span>. This signifies that more than one sprite is contained within the texture space. See <span class="emphasis"><em>Figure 4.4</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_04.jpg" alt="Ammo prefabs"/><div class="caption"><p>Figure 4.4: Select multiple sprites for textures featuring more than one sprite</p></div></div><p>Click on the <span class="strong"><strong>Apply</strong></span> button, and then click on the <span class="strong"><strong>Sprite Editor</strong></span> button from the <span class="strong"><strong>Object Inspector</strong></span>. This opens the Sprite Editor, allowing you to separate each sprite. To do this, click and drag your mouse to select each sprite, making sure that the <span class="strong"><strong>Pivot</strong></span> is aligned to the object <a id="id245" class="indexterm"/>
<span class="strong"><strong>Center</strong></span>. See <span class="emphasis"><em>Figure 4.5</em></span>. Then, click on <span class="strong"><strong>Apply</strong></span> to accept the changes.</p><div class="mediaobject"><img src="graphics/B05118_04_05.jpg" alt="Ammo prefabs"/><div class="caption"><p>Figure 4.5: Separating multiple sprites in the Sprite Editor</p></div></div><p>After accepting the changes in the Sprite Editor, Unity automatically cuts the relevant sprites into separate units, each of which can now be selected as a separate object in the <span class="strong"><strong>Project</strong></span> panel. Click on the right arrow at the side of the texture, and all sprites within will expand outwards. See <span class="emphasis"><em>Figure 4.6</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_06.jpg" alt="Ammo prefabs"/><div class="caption"><p>Figure 4.6: Expand all sprites within a texture</p></div></div><p>Now, drag and drop one of the sprites from the <span class="strong"><strong>Project</strong></span> panel to the <span class="strong"><strong>Scene</strong></span> via the <span class="strong"><strong>Hierarchy</strong></span> panel. On doing this, it will be added as a sprite object. This represents the beginning of our <code class="literal">Ammo</code> prefab. The sprite itself may not initially be oriented to face upward at the game <a id="id246" class="indexterm"/>camera. If so, rotate the sprite by <span class="strong"><strong>90</strong></span> degrees until it looks correct. See <span class="emphasis"><em>Figure 4.7</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_07.jpg" alt="Ammo prefabs"/><div class="caption"><p>Figure 4.7: Aligning the ammo sprite</p></div></div><p>Now create a new, empty game object in the scene (<span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu) and rename it <code class="literal">Ammo</code>. Make this new object a parent of <code class="literal">Ammo_Sprite</code> and ensure that its local forward vector is pointing in the direction that the ammo should travel. We'll soon reuse the <code class="literal">Mover</code> script (created in the previous chapter) on the ammo to make it move.</p><div class="mediaobject"><img src="graphics/B05118_04_08.jpg" alt="Ammo prefabs"/><div class="caption"><p>Figure 4.8: Building an ammo object</p></div></div><p>Drag and drop the <code class="literal">Mover.cs</code> script from the <span class="strong"><strong>Project</strong></span> panel to the <code class="literal">Ammo</code> parent object via the <span class="strong"><strong>Hierarchy</strong></span> panel in order to add it as a component. Then, select the <code class="literal">Ammo</code> object and, from the <span class="strong"><strong>Object Inspector</strong></span>, change the ammo's <span class="strong"><strong>Max Speed</strong></span> in the <span class="strong"><strong>Mover</strong></span> component to <code class="literal">7</code>. Finally, add a <span class="strong"><strong>Box Collider</strong></span> to the object to approximate its volume (<span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Box Collider</strong></span> from the application menu), and then test this all in the viewport by pressing play on the <a id="id247" class="indexterm"/>toolbar. The <code class="literal">Ammo</code> object should shoot forward as though fired from a weapon. If it moves up or down incorrectly, then make sure that the parent object is rotated so that its blue forward vector really is pointing forward. See <span class="emphasis"><em>Figure 4.9</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_09.jpg" alt="Ammo prefabs"/><div class="caption"><p>Figure 4.9: Moving forward with an Ammo prefab (Mover and Collider)</p></div></div><p>Next, add a <span class="strong"><strong>Rigidbody</strong></span> component to the ammo to make it part of the Unity physics system. To do this, select the <code class="literal">Ammo</code> object and navigate to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Rigidbody</strong></span> from the application menu. Then, from the <span class="strong"><strong>Rigidbody</strong></span> component in the <span class="strong"><strong>Inspector</strong></span>, disable the <span class="strong"><strong>Use Gravity</strong></span> checkbox to prevent the ammo from falling to the ground during gameplay. For our purposes, gravity need not apply to the ammo as it should simply travel along and eventually be destroyed. This highlights an important point in game <a id="id248" class="indexterm"/>development generally: real-world physics need not apply to every object accurately. We only need enough physics to make objects appear correct to the player when they're looking. See <span class="emphasis"><em>Figure 4.10</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_10.jpg" alt="Ammo prefabs"/><div class="caption"><p>Figure 4.10: Removing gravity from the Ammo object</p></div></div><p>In addition to adding a <code class="literal">Mover</code> script and physics components, we also need the ammo to behave distinctly. Specifically, it should damage the objects with which it collides, and it should also destroy or disable itself on collision. To achieve this, a new script file must be created, <code class="literal">Ammo.cs</code>. The entire code for this is included in <span class="emphasis"><em>Code Sample 4.1</em></span> as follows:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class Ammo : MonoBehaviour
{
  public float Damage = 100f;
  public float LifeTime = 2f;
  //------------------------------
  void OnEnable()
  {
    CancelInvoke();
    Invoke("Die", LifeTime);
  }
  //------------------------------
  // Update is called once per frame
  void OnTriggerEnter(Collider Col)
  {
    //Get health component
      <span class="strong"><strong>Health H = Col.gameObject.GetComponent&lt;Health&gt;();</strong></span>

    if(H == null)return;

    H.HealthPoints -= Damage;
  }
  //------------------------------
  void Die()
  {
    gameObject.SetActive(false);
  }

  //------------------------------
}
//------------------------------</pre></div><div class="section" title="Code Sample 4-1"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec19"/>Code Sample 4-1</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Ammo</code> <a id="id249" class="indexterm"/>class should be attached to the <code class="literal">Ammo</code> prefab object and will be instantiated for all ammo objects created. Its main purpose is to damage any objects with which it collides.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">OnTriggerEnter</code> function is invoked for the ammo when it enters a trigger attached to a movable unit, such as the player or enemies. Specifically, it retrieves the <code class="literal">Health</code> component attached to the object, if it has one, and reduces its health by the <code class="literal">Damage</code> amount. The <code class="literal">Health</code> component was created in the previous chapter.</li><li class="listitem" style="list-style-type: disc">Notice that each ammo object will have a Lifetime. This represents the amount of time in seconds for which the ammo should remain alive and active after it is fired and generated in the scene. After the lifetime expires, the ammo should either be destroyed entirely or deactivated (more on this shortly).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Invoke</code> function is used to deactivate the ammo object after the <code class="literal">LifeTime</code> interval. This happens during the <code class="literal">OnEnable</code> event. This is called automatically by Unity each time an object is activated (that is, changed from being disabled to enabled).</li></ul></div><p>Now, drag and drop the <code class="literal">Ammo</code> script file from the <code class="literal">Scripts</code> folder in the <span class="strong"><strong>Project</strong></span> panel to the <code class="literal">Ammo</code> object, and then finally, drag and drop the whole <code class="literal">Ammo</code> object in the <span class="strong"><strong>Scene</strong></span> back to the <span class="strong"><strong>Project</strong></span> panel in <a id="id250" class="indexterm"/>the <code class="literal">Prefabs</code> folder in order to create a new <code class="literal">Ammo</code> prefab. See <span class="emphasis"><em>Figure 4.11</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_11.jpg" alt="Code Sample 4-1"/><div class="caption"><p>Figure 4.11: Creating an Ammo prefab</p></div></div><p>Congratulations! You've now created an <code class="literal">Ammo</code> prefab, which can be spawned from weapon points to attack enemies directly. This is good, but we've still not handled the spawning process itself and we'll address this next.</p></div></div>
<div class="section" title="Ammo spawning"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Ammo spawning</h1></div></div></div><p>The <code class="literal">Ammo</code> prefab created <a id="id251" class="indexterm"/>so far presents us with a technical problem that, if not taken seriously, has the potential to cause some serious performance <a id="id252" class="indexterm"/>penalties for our game. Specifically, when the spaceship weapon is fired, we'll need to generate ammo that launches into the scene and destroys the enemies on collision. This is fine in general, but the problem is that the player could potentially press the fire button many times in quick succession and could even hold down the fire button for long periods of time, and thereby spawn potentially hundreds of ammo prefabs. We could, of course, use the <code class="literal">Instantiate</code> function seen already to generate these prefabs dynamically, but this is problematic because instantiate is computationally expensive. When used to generate many items in succession, it will typically cause a nightmarish slowdown that'll reduce the FPS to unacceptable levels. We need to avoid this!</p><p>The solution is <a id="id253" class="indexterm"/>known as <span class="strong"><strong>Pooling</strong></span>, <span class="strong"><strong>Object Pooling</strong></span>, or <span class="strong"><strong>Object Caching</strong></span>. In essence, it means <a id="id254" class="indexterm"/>that we must spawn a large and recyclable batch of ammo objects at <a id="id255" class="indexterm"/>the level startup (a pool of objects) that initially, begin hidden or deactivated, and we simply activate the objects as and when needed (when the player fires a weapon). When the ammo collides with an enemy or when its lifetime <a id="id256" class="indexterm"/>expires, we don't destroy the object entirely, we simply deactivate it again, returning it to the pool for reuse later if needed. In this way, we avoid all calls to <code class="literal">Instantiate</code> and simply recycle all ammo objects that we have. To get started with coding this functionality, we'll make an <code class="literal">AmmoManager</code> class. This class will be responsible for two features: first, generating a pool of ammo objects at scene startup, and second, giving us a valid and available ammo object from the pool on demand, such as on weapon-fire. Consider the following <code class="literal">AmmoManager</code> <span class="emphasis"><em>Code Sample 4.2</em></span> to achieve this:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
//------------------------------
public class AmmoManager : MonoBehaviour
{
  //------------------------------
  //Reference to ammo prefab
  public GameObject AmmoPrefab = null;

  //Ammo pool count
  public int PoolSize = 100;

  public Queue&lt;Transform&gt; AmmoQueue = new Queue&lt;Transform&gt;();

  //Array of ammo objects to generate
  private GameObject[] AmmoArray;

  public static AmmoManager AmmoManagerSingleton = null;
  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    if(AmmoManagerSingleton != null)
    {
      Destroy(GetComponent&lt;AmmoManager&gt;());
      return;
    }

    AmmoManagerSingleton = this;
    AmmoArray = new GameObject[PoolSize];

    for(int i=0; i&lt;PoolSize; i++)
    {
      AmmoArray[i] = Instantiate(AmmoPrefab, Vector3.zero, Quaternion.identity) as GameObject;
      Transform ObjTransform = AmmoArray[i].GetComponent&lt;Transform&gt;();
      ObjTransform.parent = GetComponent&lt;Transform&gt;();
      AmmoQueue.Enqueue(ObjTransform);
      AmmoArray[i].SetActive(false);
    }
  }
  //------------------------------
  public static Transform SpawnAmmo(Vector3 Position, Quaternion Rotation)
  {
    //Get ammo
    Transform SpawnedAmmo = AmmoManagerSingleton.AmmoQueue.Dequeue();

    SpawnedAmmo.gameObject.SetActive(true);
    SpawnedAmmo.position = Position;
    SpawnedAmmo.localRotation = Rotation;

    //Add to queue end
    AmmoManagerSingleton.AmmoQueue.Enqueue(SpawnedAmmo);

    //Return ammo
    return SpawnedAmmo;
  }
  //------------------------------
}
//------------------------------</pre></div><div class="section" title="Code Sample 4.2"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Code Sample 4.2</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AmmoManager</code> <a id="id257" class="indexterm"/>features an <code class="literal">AmmoArray</code> member variable, which holds a complete list (sequential array of references) of all ammo objects to be generated at startup (during the <code class="literal">Awake</code> event).</li><li class="listitem" style="list-style-type: disc"><code class="literal">AmmoArray</code> will be sized to <code class="literal">PoolSize</code>. This refers to the total number of ammo objects to be generated. The <code class="literal">Awake</code> function generates the ammo objects at the beginning of the level, and these are added to the queue with <code class="literal">Enqueue</code>.</li><li class="listitem" style="list-style-type: disc">Once generated, each ammo object is deactivated with <code class="literal">SetActive(false)</code> and is held in the pool until needed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AmmoManager</code> uses the <code class="literal">Queue</code> class from the <code class="literal">Mono</code> library to manage how specific ammo objects are selected from the pool to be activated when fire is pressed. The queue works as a <span class="strong"><strong>First-In-First-Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) object. That is, ammo objects <a id="id258" class="indexterm"/>are added to the queue one at a time and can be removed when selected to be activated. The object removed from the queue is always the object at the front. More information on the <code class="literal">Queue</code> class can be found online at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx">https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Enqueue</code> function of the <code class="literal">Queue</code> object is called during <code class="literal">Awake</code> to add objects initially to the queue, one by one, as they are generated.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">SpawnAmmo</code> <a id="id259" class="indexterm"/>function should be called to generate a new item of ammo in the scene. This function does not rely on the <code class="literal">Instantiate</code> function but uses the <code class="literal">Queue</code> object instead. It removes the first ammo object from the queue, activates it, and then adds it to the end of the queue again behind all the other ammo objects. In this way, a cycle of generation and regeneration happens, allowing all ammo objects to be recycled.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AmmoManager</code> is coded as a singleton object, meaning that one, and only one, instance of the object should exist in the scene at any one time. This functionality is achieved through the static member, <code class="literal">AmmoManagerSingleton</code>. For more information on singleton objects, refer to <span class="emphasis"><em>Mastering Unity Scripting</em></span> by <span class="emphasis"><em>Packt Publishing</em></span> at <a class="ulink" href="https://www.packtpub.com/game-development/mastering-unity-5x-scripting">https://www.packtpub.com/game-development/mastering-unity-5x-scripting</a>.</li></ul></div><p>To use this class, create a new <code class="literal">GameObject</code> in the scene called <code class="literal">AmmoManager</code> by selecting <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu. Then, drag and drop the <code class="literal">AmmoManager</code> script from the <span class="strong"><strong>Project</strong></span> panel to select the object in the scene. Once created, drag and drop the <code class="literal">Ammo</code> prefab from the <code class="literal">Prefabs</code> folder to the <span class="strong"><strong>Ammo Prefab</strong></span> slot for the <span class="strong"><strong>Ammo Manager</strong></span> component in the <span class="strong"><strong>Object Inspector</strong></span>. See <span class="emphasis"><em>Figure 4.12</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_12.jpg" alt="Code Sample 4.2"/><div class="caption"><p>Figure 4.12: Adding the Ammo Manager to an object</p></div></div><p>Now, the scene features an <code class="literal">AmmoManager</code> object to hold an ammo pool, offscreen and hidden. However, still nothing about our existing functionality actually connects a fire button press from the gamer with the generation of ammo in the scene. That is, we have no code to actually <a id="id260" class="indexterm"/>make the ammo visible and working! This connection should now be made via the <code class="literal">PlayerController</code> script that we started in the previous chapter. This class should now be amended to handle ammo generation. The recoded <code class="literal">PlayerController</code> class is included in the following <span class="emphasis"><em>Code Sample 4.3</em></span>. The amendments are highlighted:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class PlayerController : MonoBehaviour
{
  //------------------------------
  private Rigidbody ThisBody = null;
  private Transform ThisTransform = null;

  public bool MouseLook = true;
  public string HorzAxis = "Horizontal";
  public string VertAxis = "Vertical";
  <span class="strong"><strong>public string FireAxis = "Fire1";</strong></span>

  public float MaxSpeed = 5f;
  <span class="strong"><strong>public float ReloadDelay = 0.3f;</strong></span>
  <span class="strong"><strong>public bool CanFire = true;</strong></span>

  <span class="strong"><strong>public Transform[] TurretTransforms;</strong></span>
  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    ThisBody = GetComponent&lt;Rigidbody&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //Update movement
    float Horz = Input.GetAxis(HorzAxis);
    float Vert = Input.GetAxis(VertAxis);
    Vector3 MoveDirection = new Vector3(Horz, 0.0f, Vert);
    ThisBody.AddForce(MoveDirection.normalized * MaxSpeed);

    //Clamp speed
    ThisBody.velocity = new Vector3(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed),
    Mathf.Clamp(ThisBody.velocity.y, -MaxSpeed, MaxSpeed),
    Mathf.Clamp(ThisBody.velocity.z, -MaxSpeed, MaxSpeed));

    //Should look with mouse?
    if(MouseLook)
    {
      //Update rotation - turn to face mouse pointer
      Vector3 MousePosWorld = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, 0.0f));
      MousePosWorld = new Vector3(MousePosWorld.x, 0.0f, MousePosWorld.z);

      //Get direction to cursor
      Vector3 LookDirection = MousePosWorld - ThisTransform.position;

      //FixedUpdate rotation
      ThisTransform.localRotation = Quaternion.LookRotation(LookDirection.normalized,Vector3.up);
    }

    //Check fire control
    if(Input.GetButtonDown(FireAxis) &amp;&amp; CanFire)
    {
      foreach(Transform T in TurretTransforms)
        AmmoManager.SpawnAmmo(T.position, T.rotation);

      CanFire = false;
      Invoke ("EnableFire", ReloadDelay);
    }
  }
  //------------------------------
  <span class="strong"><strong>void EnableFire()</strong></span>
  {
    CanFire = true;
  }
  //------------------------------
  public void Die()
  {
    Destroy(gameObject);
  }
}
//------------------------------</pre></div></div><div class="section" title="Code Sample 4.3"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Code Sample 4.3</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PlayerController</code> <a id="id261" class="indexterm"/>now features a <code class="literal">TurretTransform</code> array variable, listing all child empties being used as turret spawn locations.</li><li class="listitem" style="list-style-type: disc">During the <code class="literal">Update</code> function, <code class="literal">PlayerController</code> checks for fire button presses. If detected, the code cycles through all turrets and spawns one ammo object at each turret location.</li><li class="listitem" style="list-style-type: disc">Once ammo is fired, <code class="literal">ReloadDelay</code> is engaged (set to <code class="literal">true</code>). This means that the delay must first expire before new ammo can be fired again later.</li></ul></div><p>After adding this code to <code class="literal">PlayerController</code>, select the <code class="literal">Player</code> object in the scene and then drag and drop the <code class="literal">Turret</code> empty object on to the <code class="literal">TurretTransform</code> slot. This example uses only one turret, but you could add more if desired. See <span class="emphasis"><em>Figure 4.13</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_13.jpg" alt="Code Sample 4.3"/><div class="caption"><p>Figure 4.13: Configuring TurretTransform for spawning ammo</p></div></div><p>Now you're ready to play test and fire ammo. By playing the scene and pressing fire on the keyboard or mouse (left-click), ammo will be generated. Excellent! However, on testing this, you may notice two main problems. First, the ammo appears too big or too small. Second, the ammo sometimes bounces, flips, or reacts to the player spaceship. Let's fix these in turn.</p><p>If the ammo appears <a id="id262" class="indexterm"/>wrongly-sized, you can simply change the scale of the prefab. Select the <code class="literal">Ammo</code> prefab in the <span class="strong"><strong>Project</strong></span> panel, and from the <span class="strong"><strong>Object Inspector</strong></span>, enter a new scale in the <span class="strong"><strong>Transform</strong></span> component. See <span class="emphasis"><em>Figure 4.14</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_14.jpg" alt="Code Sample 4.3"/><div class="caption"><p>Figure 4.14: Changing the Ammo prefab scale</p></div></div><p>If the ammo appears to bounce or react to the player spaceship, then we'll need to make the ammo immune or unresponsive to the player. To achieve this, we can use physics layers. In short, both the player spaceship and ammo should be added to a single layer, and all objects on <a id="id263" class="indexterm"/>this layer should be defined as immune to each other in terms of physical reactions. First, select the <code class="literal">Player</code> object in the scene. Then, from the <span class="strong"><strong>Object Inspector</strong></span>, click on the <span class="strong"><strong>Layer</strong></span> drop-down, and choose <span class="strong"><strong>Add Layer</strong></span> from the context menu. See <span class="emphasis"><em>Figure 4.15</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_15.jpg" alt="Code Sample 4.3"/><div class="caption"><p>Figure 4.15: Creating a new layer for Physics exclusions</p></div></div><p>Name the layer <code class="literal">Player</code>. This is to indicate that all objects attached to the layer are associated with the <code class="literal">Player</code>. See <span class="emphasis"><em>Figure 4.16</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_16.jpg" alt="Code Sample 4.3"/><div class="caption"><p>Figure 4.16: Creating layers</p></div></div><p>Now, assign both the <code class="literal">Player</code> object in the scene and <code class="literal">Ammo</code> prefab in the <span class="strong"><strong>Project</strong></span> panel to the newly created <span class="strong"><strong>Player</strong></span> layer. Select each, and simply click on the <span class="strong"><strong>Layer</strong></span> drop-down, selecting the <span class="strong"><strong>Player</strong></span> <a id="id264" class="indexterm"/>option. See <span class="emphasis"><em>Figure 4.17</em></span>. If prompted with a pop-up dialog, choose to change children also. This makes sure that all child objects are also associated with the same <span class="strong"><strong>Layer</strong></span> as the parent.</p><div class="mediaobject"><img src="graphics/B05118_04_17.jpg" alt="Code Sample 4.3"/><div class="caption"><p>Figure 4.17: Assigning Player and Ammo to the Player layer</p></div></div><p>Both <span class="strong"><strong>Player</strong></span> and <span class="strong"><strong>Ammo</strong></span> have now been assigned to the same layer. From here, we can make all objects in the same layer immune from each other insofar as <span class="strong"><strong>Physics</strong></span> applies. To do this, navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Physics</strong></span> from the application menu. See <span class="emphasis"><em>Figure 4.18</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_18.jpg" alt="Code Sample 4.3"/><div class="caption"><p>Figure 4.18: Accessing Physics options</p></div></div><p>The global <span class="strong"><strong>Physics</strong></span> settings appear in the <span class="strong"><strong>Object Inspector</strong></span>. At the bottom of the <span class="strong"><strong>Inspector</strong></span>, the <span class="strong"><strong>Layer </strong></span>
<a id="id265" class="indexterm"/>
<span class="strong"><strong>Collision Matrix</strong></span> displays how layers affect each other. Intersecting layers with a check mark can and will affect each other. For this reason, remove the check mark for the <span class="strong"><strong>Player</strong></span> layer to prevent collisions occurring between objects on this layer. See <span class="emphasis"><em>Figure 4.19</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_19.jpg" alt="Code Sample 4.3"/><div class="caption"><p>Figure 4.19: Setting the Layer Collision Matrix for improved collisions</p></div></div><p>With the <span class="strong"><strong>Layer Collision Matrix</strong></span> set from the <span class="strong"><strong>Object Inspector</strong></span>, test run the game so far by pressing play on the toolbar. When you do this and press fire, ammo will issue from the turrets and no longer react to the player spaceship. The ammo should, however, collide with, and <a id="id266" class="indexterm"/>destroy, the enemies. See <span class="emphasis"><em>Figure 4.20</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_20.jpg" alt="Code Sample 4.3"/><div class="caption"><p>Figure 4.20: Destroying enemies by shooting guns!</p></div></div><p>Excellent work! We now have a spaceship that can fire weapons and destroy enemies, and the physics works as expected. Maybe you'd like to customize player controls a little or perhaps you want to <a id="id267" class="indexterm"/>use a gamepad. The next section will explore this issue further.</p></div></div>
<div class="section" title="User controls"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>User controls</h1></div></div></div><p>Maybe you don't like the <a id="id268" class="indexterm"/>default controls and key combinations associated with the input axes—<span class="strong"><strong>Horizontal</strong></span>, <span class="strong"><strong>Vertical</strong></span>, and <span class="strong"><strong>Fire1</strong></span>. Maybe you want to change them. These input axes are read using the <code class="literal">Input.GetAxis</code> function (shown earlier) and are specified by human readable names, but it's not immediately clear how Unity maps specific input buttons and devices to these virtual axes. Here, we'll see briefly how to customize these. To get started, let's access the <span class="strong"><strong>Input</strong></span> settings by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Input</strong></span> from the application menu. See <span class="emphasis"><em>Figure 4.21</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_21.jpg" alt="User controls"/><div class="caption"><p>Figure 4.21: Accessing the Input menu</p></div></div><p>On selecting this option, a collection of custom-defined input axes appear as a list in the <span class="strong"><strong>Object Inspector</strong></span>. See <span class="emphasis"><em>Figure 4.22</em></span>. This defines all axes used by the input system. The <span class="strong"><strong>Horizontal</strong></span> and <span class="strong"><strong>Vertical</strong></span> axes should be listed here.</p><div class="mediaobject"><img src="graphics/B05118_04_22.jpg" alt="User controls"/><div class="caption"><p>Figure 4.22: Exploring the input axes</p></div></div><p>By expanding each axis in the <span class="strong"><strong>Object Inspector</strong></span>, you can easily customize how user input is mapped, that is, how specific keys and controls on hardware devices, such as a keyboard and mouse, will <a id="id269" class="indexterm"/>map to an axis. The <span class="strong"><strong>Horizontal</strong></span> axis, for example, is defined twice. For the first definition, <span class="strong"><strong>Horizontal</strong></span> is mapped to the <code class="literal">left</code>, <code class="literal">right</code>, and <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>D</em></span> keys on the keyboard. Right and <span class="emphasis"><em>D</em></span> are mapped as <span class="strong"><strong>Positive Button</strong></span> because, when pressed, they produce positive floating-point values from the <code class="literal">Input.GetAxis</code> function (0-1). Left and <span class="emphasis"><em>A</em></span> are mapped as <span class="strong"><strong>Negative Button</strong></span> because, when pressed, they result in negative floating-points values for <code class="literal">Input.GetAxis</code>. This makes it easy to move objects left and right using negative and positive numbers. See <span class="emphasis"><em>Figure 4.23</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_23.jpg" alt="User controls"/><div class="caption"><p>Figure 4.23: Configuring an Input axis</p></div></div><p>Notice that <span class="strong"><strong>Horizontal</strong></span> is defined twice in the <span class="strong"><strong>Object Inspector</strong></span>—once near the top of the list and once near the bottom. These two definitions are accumulative and not contradictory—they stack atop one another. They allow you to map multiple devices to the same axis, giving you cross-platform and multidevice control over your games. By default, <span class="strong"><strong>Horizontal</strong></span> is <a id="id270" class="indexterm"/>mapped in the first definition to the <code class="literal">left</code>, <code class="literal">right</code>, <span class="emphasis"><em>A</em></span>, and <span class="emphasis"><em>D</em></span> keys on the keyboard, and in the second definition, to joystick motion. Both definitions are valid and work together. You can have as many definitions for the same axis as you need, depending on the controls you need to support. See <span class="emphasis"><em>Figure 4.24</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_24.jpg" alt="User controls"/><div class="caption"><p>Figure 4.24: Defining two horizontal axes</p></div></div><p>For this project, the controls will remain at their defaults, but go ahead and change or add additional controls if you <a id="id271" class="indexterm"/>want to support different configurations. More information on player input and customizing controls can be found in the <a id="id272" class="indexterm"/>online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/class-InputManager.html">http://docs.unity3d.com/Manual/class-InputManager.html</a>.</p></div>
<div class="section" title="Scores and scoring &#x2013; UI and text objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Scores and scoring – UI and text objects</h1></div></div></div><p>Let's move on to the <a id="id273" class="indexterm"/>scoring system and, in creating this, we'll create <code class="literal">GameController</code>. <code class="literal">GameController</code> is simply a script or class that manages all game-wide and overarching behavior. This includes the score because, for this game, the score refers to one single and global number representing the achievements and progress of the player. Before jumping into the implementation, start by creating a simple GUI to display the game score. GUI <a id="id274" class="indexterm"/>is an acronym for Graphic User Interface, and this refers to all the 2D graphical elements that sit atop the game window and provide information to the player. To create this, create a new GUI canvas object by <a id="id275" class="indexterm"/>selecting <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Canvas</strong></span> from the application menu. See <span class="emphasis"><em>Figure 4.25</em></span>. More details on GUIs can be found in the next two chapters.</p><div class="mediaobject"><img src="graphics/B05118_04_25.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.25: Adding a Canvas object to the scene</p></div></div><p>The <code class="literal">Canvas</code> object defines the total surface or area in which the GUI lives, including all buttons, text, and other widgets. On being generated in the scene, <code class="literal">Canvas</code> also features in the <span class="strong"><strong>Hierarchy</strong></span> panel. Initially, the <code class="literal">Canvas</code> object may be too large or too small to be seen clearly in the viewport, so select the <code class="literal">Canvas</code> object in the <span class="strong"><strong>Hierarchy</strong></span> panel and press the <span class="emphasis"><em>F</em></span> key on the keyboard to <a id="id276" class="indexterm"/>focus the object. It should appear as a large <a id="id277" class="indexterm"/>vertically-aligned rectangle. See <span class="emphasis"><em>Figure 4.26</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_26.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.26: Examining the Canvas object in the viewport</p></div></div><p>The <code class="literal">Canvas</code> <a id="id278" class="indexterm"/>object is not visible itself in the <span class="strong"><strong>Game</strong></span> tab. Rather, it acts simply as a container. Even so, it strongly influences how contained objects appear on the screen in terms of size, position, and scale. For this reason, before adding objects and refining the design of an interface, it's helpful to configure your <code class="literal">Canvas</code> object first. To do this, select the <code class="literal">Canvas</code> object in the scene, and from the <span class="strong"><strong>Object Inspector</strong></span>, click on the <span class="strong"><strong>UI Scale Mode</strong></span> drop-down option from the <span class="strong"><strong>Canvas Scaler</strong></span> component. From the drop-down list, choose the <span class="strong"><strong>Scale With Screen Size</strong></span> option and enter an HD resolution in the <span class="strong"><strong>Reference Resolution</strong></span> field, that is, specify <code class="literal">1920</code> for the <span class="strong"><strong>X</strong></span> field and <code class="literal">1080</code> for the <span class="strong"><strong>Y</strong></span> field. See <span class="emphasis"><em>Figure 4.27</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_27.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.27: Adjusting the Canvas Scaler component</p></div></div><p>By adjusting the <span class="strong"><strong>Canvas Scaler</strong></span> to <span class="strong"><strong>Scale With Screen Size</strong></span>, the user interface for the game will automatically stretch and shrink (up- and down-scale) to fit the target resolution, ensuring that each element is scaled to the same proportions, maintaining the overall <a id="id279" class="indexterm"/>look and feel. This is a quick and easy method to create a UI once and have it adjust size to fit nearly any resolution. It may not always be the best solution to maintaining the highest quality graphical fidelity, but it's functional and suitable in many cases. In any case, before proceeding with the UI design, it's helpful to see both the <span class="strong"><strong>Scene</strong></span> viewport and <span class="strong"><strong>Game</strong></span> tab side by side in the interface (or across two monitors, if you have a multi-monitor configuration). This allows us to build the interface in the <span class="strong"><strong>Scene</strong></span> viewport, and then preview its effects in the <span class="strong"><strong>Game</strong></span> tab. You can rearrange the <span class="strong"><strong>Scene</strong></span> and <span class="strong"><strong>Game</strong></span> tabs simply by dragging and dropping the <span class="strong"><strong>Game</strong></span> tab beside the <span class="strong"><strong>Scene</strong></span> tab in the <span class="strong"><strong>Unity Editor</strong></span>. See <span class="emphasis"><em>Figure 4.28</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_28.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.28: Docking the Scene and Game tabs side by side</p></div></div><p>Next, let's add the text widget to the GUI to display the game score. To do this, select the <code class="literal">Canvas</code> object in the <span class="strong"><strong>Hierarchy</strong></span> panel, and then right-click on that object (in the <span class="strong"><strong>Hierarchy</strong></span> panel) to display a context menu. From here, select <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Text</strong></span>. This creates a new text object as a child of the <code class="literal">Canvas</code> object as opposed to a top-level object with no parent. See <span class="emphasis"><em>Figure 4.29</em></span>. The <code class="literal">Text</code> object is useful to draw text onscreen with a specific color, size, and font setting.</p><div class="mediaobject"><img src="graphics/B05118_04_29.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.29: Creating a text object for the UI</p></div></div><p>By default, the <code class="literal">Text</code> object may not initially appear visible in either the scene or viewport, even though it's listed as an object in the <span class="strong"><strong>Hierarchy</strong></span> panel. However, look more closely in the <a id="id280" class="indexterm"/>
<span class="strong"><strong>Scene</strong></span> and you're likely to see very small and dark text, which appears both in the <span class="strong"><strong>Canvas</strong></span> and <span class="strong"><strong>Game</strong></span> tab. See <span class="emphasis"><em>Figure 4.30</em></span>. By default, new text objects feature black text at a small font size. For this project, these settings will need to be changed.</p><div class="mediaobject"><img src="graphics/B05118_04_30.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.30: Newly created text objects can sometimes be difficult to see</p></div></div><p>Select the <code class="literal">Text</code> object in the <span class="strong"><strong>Hierarchy</strong></span> panel, if it's not already selected, and from the <span class="strong"><strong>Object Inspector</strong></span> (in the <span class="strong"><strong>Text</strong></span> component), change the text <span class="strong"><strong>Color</strong></span> to white and <span class="strong"><strong>Font Size</strong></span> to <code class="literal">20</code>. See <span class="emphasis"><em>Figure 4.31</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_31.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.31: Changing text size and color</p></div></div><p>The text, however, still appears too small even after changing its size. If you increase the size further, however, the text may disappear from view. This happens because each <code class="literal">Text</code> object has a rectangular boundary defining its limits, and when the font size increases beyond what can fit in the boundary, the text is automatically hidden altogether. To fix this, we'll increase <a id="id281" class="indexterm"/>the text boundary. To do this, switch to the <span class="strong"><strong>Rect Transform</strong></span> tool with <span class="emphasis"><em>T</em></span> or select the tool from the toolbar. See <span class="emphasis"><em>Figure 4.32</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_32.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.32: Selecting the Rect Transform tool</p></div></div><p>On activating the <span class="strong"><strong>Rect Transform</strong></span> tool, a clearly defined boundary will be drawn around the selected <code class="literal">Text</code> object in the <span class="strong"><strong>Scene</strong></span> viewport, indicating its rectangular extents. Let's increase the boundary size to <a id="id282" class="indexterm"/>accommodate larger text. To do this, simply click and drag on the boundary edges with the mouse to extend them as needed. See <span class="emphasis"><em>Figure 4.33</em></span>. This will increase the boundary size and now you can increase <span class="strong"><strong>Font Size</strong></span> to improve text readability.</p><div class="mediaobject"><img src="graphics/B05118_04_33.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.33: Adjust the text rectangle to support larger font sizes</p></div></div><p>In addition to setting the text boundary size, the text can also be vertically aligned to the boundary center. Simply click on the center alignment button for the vertical group. For horizontal alignment, the text should remain left-aligned to allow for the score display. See <span class="emphasis"><em>Figure 4.34</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_34.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.34: Aligning text within the boundary</p></div></div><p>Although the text is <a id="id283" class="indexterm"/>now aligned vertically within its containing boundary, we'll still need to align it as a whole to the canvas container to ensure that it remains on screen at the same position and orientation, even if the <span class="strong"><strong>Game</strong></span> window is resized and realigned. To do this, we'll use <span class="strong"><strong>Anchors</strong></span>. To start, use the transform tool (<span class="emphasis"><em>W</em></span>) to reposition the <code class="literal">Text</code> object to the top right corner of the screen at the location where the <span class="strong"><strong>Score</strong></span> should appear. The object will automatically move within a 2D plane as opposed to 3D space. As you move the <code class="literal">Text</code> object in the <span class="strong"><strong>Scene</strong></span> viewport, check its appearance in the <span class="strong"><strong>Game</strong></span> tab to ensure that it looks correct and appropriate. See <span class="emphasis"><em>Figure 4.35</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_35.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.35: Positioning the Score text within the Game tab</p></div></div><p>To secure the position of the <code class="literal">Text</code> object on screen (preventing it from sliding or moving), even if the <a id="id284" class="indexterm"/>
<span class="strong"><strong>Game</strong></span> tab is resized by the user, we can set the object's anchor position to the top right corner of the screen. This ensures that the text is always positioned as a constant, proportional offset from its anchor. To do this, click on the<span class="strong"><strong> Anchor Presets</strong></span> button in the <span class="strong"><strong>Rect Transform</strong></span> component in the <span class="strong"><strong>Object Inspector</strong></span>. When you do this, a preset menu appears from which you can choose a range of alignment locations. Each preset is graphically presented as a small diagram, including a red dot at the location of anchor alignment. Select the top right preset. See <span class="emphasis"><em>Figure 4.36</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_36.jpg" alt="Scores and scoring – UI and text objects"/><div class="caption"><p>Figure 4.36: Aligning the Text object to the screen</p></div></div><p>Excellent work! The <a id="id285" class="indexterm"/>
<code class="literal">Text</code> object is now created and ready to use. Of course, in play mode, the text remains unchanged and doesn't display a real score. That's because we need to add some code. However, overall, the <code class="literal">Text</code> object is in place and we can move on.</p></div>
<div class="section" title="Working with scores &#x2013; scripting with text"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Working with scores – scripting with text</h1></div></div></div><p>To display a score in the <a id="id286" class="indexterm"/>GUI, we'll first need score functionality, that is, code to <a id="id287" class="indexterm"/>create a score system. Essentially, the score functionality will be added to a general, overarching <code class="literal">GameController</code> class, responsible for all game-wide logic and features. The code for <code class="literal">GameController</code> and its score feature set is included in <span class="emphasis"><em>Code Sample 4.4</em></span>, as follows. This file should be added to the <code class="literal">Scripts</code> folder of the project.</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
<span class="strong"><strong>using UnityEngine.UI;</strong></span>
//------------------------------
public class GameController : MonoBehaviour
{
  //Game score
  public static int Score;

  //Prefix
  public string ScorePrefix = string.Empty;

  //Score text object
  public Text ScoreText = null;

  //Game over text
  public Text GameOverText = null;

  public static GameController ThisInstance = null;
  //------------------------------
  void Awake()
  {
    ThisInstance = this;
  }
  //------------------------------
  void Update()
  {
    //Update score text
    if(ScoreText!=null)
      ScoreText.text = ScorePrefix + Score.ToString();
  }
  //------------------------------
  public static void GameOver()
  {
    if(ThisInstance.GameOverText!=null)
    ThisInstance.GameOverText.gameObject.SetActive(true);
  }
  //------------------------------
}</pre></div><div class="section" title="Code Sample 4.4"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Code Sample 4.4</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">GameController</code> class uses the <code class="literal">UnityEngine.ui</code> namespace. This is important <a id="id288" class="indexterm"/>because it includes access to all the UI classes and objects in Unity. If you don't include this namespace in your source files, then you cannot use UI objects from that script.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">GameController</code> class features two text public members, namely, <code class="literal">ScoreText</code> and <code class="literal">GameOverText</code>. These refer to two text objects, both of which are optional insofar as the <code class="literal">GameController</code> code will work just fine, even if the members are null. <code class="literal">ScoreText</code> is a reference to a text GUI object to display score text, and <code class="literal">GameOverText</code> is to display any message when a game-over condition occurs.</li></ul></div><p>To use the <code class="literal">GameController</code> code, create a new, empty object in the scene named <code class="literal">GameController</code>. Then, drag and drop the <code class="literal">GameController</code> script file to that object. Once added, drag and drop the <code class="literal">ScoreText</code> object to the <span class="strong"><strong>Score Text</strong></span> field for <code class="literal">GameController</code> in the <span class="strong"><strong>Object Inspector</strong></span>. See <span class="emphasis"><em>Figure 4.37</em></span>. In the <span class="strong"><strong>Score Prefix</strong></span> field, enter the text that should prefix the <code class="literal">Score</code> itself. The score, on its own, is simply a number (such as 1,000). The prefix allows you to add text to the front of this score, indicating to the player what the numbers mean.</p><div class="mediaobject"><img src="graphics/B05118_04_37.jpg" alt="Code Sample 4.4"/><div class="caption"><p>Figure 4.37: Creating a GameController to maintain the game score</p></div></div><p>Now, take the game for a test run and you'll see the score display at the top right corner of the <code class="literal">Game</code> tab using the GUI text object. This is fine, but the score always remains at <code class="literal">0</code> right now. This is because we have no code, yet, to increase the score. For our game, the score should increase when an <code class="literal">Enemy</code> object is destroyed. To achieve this, we'll create a new script file, <code class="literal">ScoreOnDestroy</code>. This is included in <span class="emphasis"><em>Code Sample 4.5</em></span>, as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------
public class ScoreOnDestroy : MonoBehaviour
{
  //------------------------------
  public int ScoreValue = 50;
  //------------------------------
  void OnDestroy()
  {
    GameController.Score += ScoreValue;
  }
  //------------------------------
}
//------------------------------</pre></div><p>The script should be attached to any object that assigns you points when it's destroyed, such as the enemies. The total number of points assigned is specified by <code class="literal">ScoreValue</code>. To attach the script to the <a id="id289" class="indexterm"/>enemy prefab, select the <code class="literal">Prefabs</code> in the <span class="strong"><strong>Project</strong></span> panel, and from the <span class="strong"><strong>Object Inspector</strong></span>, click on the <span class="strong"><strong>Add Component</strong></span> button. Then type <code class="literal">ScoreOnDestroy</code> in the search field to add the component to the prefab. Once added, specify the total number of points to be allocated for destroying an enemy. For this game, a value of 50 points is assigned. See <span class="emphasis"><em>Figure 4.38</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_38.jpg" alt="Code Sample 4.4"/><div class="caption"><p>Figure 4.38: Adding a Score component to the Enemy prefab</p></div></div><p>Great work! You now have destroyable enemies that assign you points on destruction. This means that you can finally have an in-game score and could even extend gameplay to include high-score features and leaderboards. This also means that our game is almost finished and ready to build. Next, we'll add some final touches.</p></div></div>
<div class="section" title="Polishing"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Polishing</h1></div></div></div><p>In this section, we'll <a id="id290" class="indexterm"/>add the final touches to the game. First on the agenda is to fix the game background! Until now, the background has simply displayed the default background color associated with the game camera. However, as the game is set in space, we should display a space background. To do this, create a new <span class="strong"><strong>Quad</strong></span> object in the <span class="strong"><strong>Scene</strong></span> that'll display a space image. Navigate to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Quad</strong></span> from the menu. Then rotate the object and move it downward so that it displays a flat, vertically-aligned backdrop. You may need to scale the object to look correct. See <span class="emphasis"><em>Figure 4.39</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_39.jpg" alt="Polishing"/><div class="caption"><p>Figure 4.39: Creating a backdrop for the level and building a Quad</p></div></div><p>Now, drag and drop the space texture from the <span class="strong"><strong>Project</strong></span> panel to <span class="strong"><strong>Quad</strong></span> in the <span class="strong"><strong>Scene</strong></span> to apply it as a material. Once assigned, select the <span class="strong"><strong>Quad</strong></span> and change the <span class="strong"><strong>Tiling</strong></span> settings from the material properties in the <span class="strong"><strong>Object Inspector</strong></span>. Increase the <span class="strong"><strong>X</strong></span> and <span class="strong"><strong>Y</strong></span> tiling to <code class="literal">3</code>. See <span class="emphasis"><em>Figure 4.40</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_40.jpg" alt="Polishing"/><div class="caption"><p>Figure 4.40: Configuring the texture tiling</p></div></div><p>If texture tiling seems broken for you, then be sure to check the Texture Importing settings. To do this, select the texture in the <span class="strong"><strong>Project</strong></span> panel, and from the <span class="strong"><strong>Object Inspector</strong></span>, ensure that <a id="id291" class="indexterm"/>
<span class="strong"><strong>Texture Type</strong></span> is set to <span class="strong"><strong>Texture</strong></span> and the <span class="strong"><strong>Wrap Mode</strong></span> is set to <span class="strong"><strong>Repeat</strong></span>. See <span class="emphasis"><em>Figure 4.41</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_41.jpg" alt="Polishing"/><div class="caption"><p>Figure 4.41: Configuring a texture for seamless tiling</p></div></div><p>Now the level has a suitable background. Let's add some background music, which will play on a loop. To do this, first select the music track in the <span class="strong"><strong>Project</strong></span> panel in the <code class="literal">Audio</code> folder. When selected, make sure that the music <span class="strong"><strong>Load Type</strong></span>, from the <span class="strong"><strong>Object Inspector</strong></span>, is set to <span class="strong"><strong>Streaming</strong></span> and <span class="strong"><strong>Preload Audio Data</strong></span> is disabled. See <span class="emphasis"><em>Figure 4.42</em></span>. This improves loading times as Unity will not need to load all music data to memory as the scene begins.</p><div class="mediaobject"><img src="graphics/B05118_04_42.jpg" alt="Polishing"/><div class="caption"><p>Figure 4.42: Configuring audio data ready for playback</p></div></div><p>Next, create a new, empty <span class="strong"><strong>GameObject</strong></span> in the scene named <code class="literal">Music</code>, and then drag and drop the <code class="literal">Music</code> track from the <span class="strong"><strong>Project</strong></span> panel to the <code class="literal">Music</code> object, adding it as an <span class="strong"><strong>Audio Source</strong></span> component. <span class="strong"><strong>Audio </strong></span>
<a id="id292" class="indexterm"/>
<span class="strong"><strong>Source</strong></span> components play sound effects and music. See <span class="emphasis"><em>Figure 4.43</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_43.jpg" alt="Polishing"/><div class="caption"><p>Figure 4.43: Creating a GameObject with an AudioSource component</p></div></div><p>From the <span class="strong"><strong>Audio Source</strong></span> component in the <span class="strong"><strong>Object Inspector</strong></span>, enable the <span class="strong"><strong>Play On Awake</strong></span> and <span class="strong"><strong>Loop</strong></span> checkboxes to ensure that the music is played from the level beginning and loops endlessly for as long as the game is running. The <span class="strong"><strong>Spatial Blend</strong></span> field should be set to <code class="literal">0</code>, meaning 2D. In short, 2D sounds have a consistent volume throughout the level regardless of the player's position. This is because 2D sounds are not spatially located. 3D sounds, in contrast, are used for gunshots, footsteps, explosions, and other sounds that exist in 3D space and whose volume should change based on how close the player is standing to them when they play. See <span class="emphasis"><em>Figure 4.44</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_44.jpg" alt="Polishing"/><div class="caption"><p>Figure 4.44: Looping a music track</p></div></div><p>Now, let's take the game for <a id="id293" class="indexterm"/>a test run! Click on the play button on the toolbar and test it out. If the music doesn't play, check that the <span class="strong"><strong>Mute Audio</strong></span> button is not enabled from the <span class="strong"><strong>Game</strong></span> tab. See <span class="emphasis"><em>Figure 4.45</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_45.jpg" alt="Polishing"/><div class="caption"><p>Figure 4.45: Playing a game – disabling Mute Audio, if necessary</p></div></div></div>
<div class="section" title="Testing and diagnosis"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Testing and diagnosis</h1></div></div></div><p>With practically all <a id="id294" class="indexterm"/>games, you'll need to spend considerable time testing and debugging heavily to reduce bugs and errors as much as humanly possible. With <a id="id295" class="indexterm"/>this sample program, very little debugging and testing has been required by you, but that's not because the game is simple. It's because I've already prechecked and pretested most of the code and functionality before presenting the material to you in this book, ensuring that you get a smooth learning experience. For your own projects, however, you'll need to do lots of testing. One way to get started is using the <span class="strong"><strong>Stats</strong></span> panel. To open this, click on the <span class="strong"><strong>Stats</strong></span> button on the <span class="strong"><strong>Game</strong></span> tab. See <span class="emphasis"><em>Figure 4.46</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_46.jpg" alt="Testing and diagnosis"/><div class="caption"><p>Figure 4.46: Viewing game performance information via the Stats panel</p></div></div><p>More details on the <a id="id296" class="indexterm"/>
<span class="strong"><strong>Stats</strong></span> panel are included in <a class="link" href="ch02.html" title="Chapter 2. Project A – the Collection Game Continued">Chapter 2</a>, <span class="emphasis"><em>Project A – the Collection Game Continued</em></span> of this book, and more information can be found online in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/RenderingStatistics.html">http://docs.unity3d.com/Manual/RenderingStatistics.html</a>.</p><p>Another debugging tool is the <span class="strong"><strong>Profiler</strong></span>. This is useful when the <span class="strong"><strong>Stats</strong></span> panel has already helped you identify a general problem, such as a low FPS, and you want to dig deeper to find where the problem might be located. More details on <span class="strong"><strong>Profiler</strong></span> are included later in <a class="link" href="ch06.html" title="Chapter 6. Continuing the 2D Adventure">Chapter 6</a>, <span class="emphasis"><em>Continuing the 2D Adventure</em></span> but a short introduction is worth including here. To access the <span class="strong"><strong>Profiler</strong></span> tool, select <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Profiler</strong></span> from the application menu. This displays the <span class="strong"><strong>Profiler</strong></span> window. See <span class="emphasis"><em>Figure 4.47</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_47.jpg" alt="Testing and diagnosis"/><div class="caption"><p>Figure 4.47: Accessing the Profiler window</p></div></div><p>With the <span class="strong"><strong>Profiler</strong></span> window open, click on play on the toolbar to play test your game. When you do this, the <span class="strong"><strong>Profiler</strong></span> window fills with color-coded performance data in a graph. See <span class="emphasis"><em>Figure 4.48</em></span>. Green represents the performance of rendering (graphical) data. Reading and <a id="id297" class="indexterm"/>understanding the graph requires some experience, but as a <a id="id298" class="indexterm"/>general rule, watch out for mountains and peaks, that is, watch out for sharp fluctuations in the graph (sharp ups and downs) as this could indicate a problem, especially when it roughly coincides with frame rate drops.</p><div class="mediaobject"><img src="graphics/B05118_04_48.jpg" alt="Testing and diagnosis"/><div class="caption"><p>Figure 4.48: During gameplay, the Profiler populates with data</p></div></div><p>If you want to investigate further, simply pause the game, and then click in the graph. The horizontal axis (<span class="emphasis"><em>X</em></span> axis) represents the most recent frames, and the vertical axis represents workload. When <a id="id299" class="indexterm"/>you click in the graph, a line marker is added to indicate <a id="id300" class="indexterm"/>the frame under investigation. Beneath the graph, a list of all main processes for that frame are presented, typically ordered from top to bottom by the heaviness of their workload and proportion of frame time for which the process accounted. Heavier processes are listed at the top. See <span class="emphasis"><em>Figure 4.49</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_49.jpg" alt="Testing and diagnosis"/><div class="caption"><p>Figure 4.49: Investigating performance data with the Profiler</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>More information on the <a id="id301" class="indexterm"/>
<span class="strong"><strong>Profiler</strong></span> can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Profiler.html">http://docs.unity3d.com/Manual/Profiler.html</a>.</p></div></div></div>
<div class="section" title="Building"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Building</h1></div></div></div><p>Now, finally, we're <a id="id302" class="indexterm"/>ready to build our game to a standalone form ready to send off to friends, family, and testers! The process to do this is the same as detailed in <a class="link" href="ch02.html" title="Chapter 2. Project A – the Collection Game Continued">Chapter 2</a>, <span class="emphasis"><em>Project A – the Collection Game Continued</em></span>, to build the coin collection game. From the application menu, choose <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Build Settings</strong></span>. From the build dialog, add our level to the level list by simply clicking on the <span class="strong"><strong>Add Current</strong></span> button. Otherwise, drag and drop the level from the <span class="strong"><strong>Project</strong></span> panel to the level list. See <span class="emphasis"><em>Figure 4.50</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_50.jpg" alt="Building"/><div class="caption"><p>Figure 4.50: Preparing to build the space shooter</p></div></div><p>For this game, the target platform will be Windows. Consequently, select the <span class="strong"><strong>PC, Mac &amp; Linux Standalone</strong></span> option from the <span class="strong"><strong>Platform</strong></span> list, if it's not selected already. If the <span class="strong"><strong>Switch Platform</strong></span> button (at the bottom left) is not disabled, then you will need to press this button, confirming to Unity that it should build for the selected platform as opposed to a different platform. Then, click on the <span class="strong"><strong>Build And Run</strong></span> button. On clicking this, Unity prompts you to select a folder on your computer where the built file will be output and saved. Once generated, double-click the executable to run it and test. See <span class="emphasis"><em>Figure 4.51</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_04_51.jpg" alt="Building"/><div class="caption"><p>Figure 4.51: Test running the game as a standard Windows executable</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Summary</h1></div></div></div><p>Great work! We're really on a roll now, having completed two solid Unity projects. The first project was a coin collection game and the second was a twin-stick shooter. Both are, ultimately, simple games in that they don't rely on advanced mechanics or display sophisticated features. However, even very sophisticated games, when boiled down to their fundamental ingredients, can be found to rest on a similar foundation of essential concepts such as the ones that we've covered so far. That's why our projects are so critical to understanding Unity in a deep way. Next, we'll move on to creating a more 2D-focused game, considering interfaces, sprites, and physics, and lots more!</p></div></body></html>