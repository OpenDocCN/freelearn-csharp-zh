<html><head></head><body>
		<div id="_idContainer108">
			<h1 id="_idParaDest-128"><em class="italic"><a id="_idTextAnchor128"/>Chapter 8</em>: Testing in Solution Architecture</h1>
			<p>In the previous chapter, we learned about how to secure an <strong class="bold">ASP.NET</strong> web solution. We also highlighted some key security recommendations to protect our web <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>), along with security best practices when it comes to hosting on <strong class="bold">Azure</strong>.</p>
			<p>In this chapter, we will become familiar with the most common testing types you need to know, and when to use them.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Highlighting key testing principles</li>
				<li>Learning about the main types of software testing</li>
				<li>Exploring testing in Azure</li>
			</ul>
			<p>By the end of this chapter, you will have learned about the various types of software testing that we can apply to test our software solution, with the aim of finding errors and then fixing them. We will also learn how to check whether the software works properly and whether it meets the requirements defined during the early stages of a project. We will also explore the testing mechanism offered by <strong class="bold">Azure DevOps</strong>.</p>
			<p>Moving on to the next section, let's take a look at the key principles of software testing.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor129"/>Highlighting key testing principles</h1>
			<p>The main<a id="_idIndexMarker525"/> objective of conducting software testing is to eliminate possible bugs and to enhance the overall quality of the software in terms of many aspects, such as performance, <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>), and security.</p>
			<p>But before starting any testing activities, there must be some guidelines or principles in place to make sure that the outcome of these activities is aligned with the main objectives of testing. Here, in this section, we will highlight some of the key principles of software testing that we need to consider in our software solution, as follows:</p>
			<ul>
				<li>All test cases<a id="_idIndexMarker526"/> should be prepared based on customer requirements; otherwise, we will be testing against the wrong requirements. Each feature or function in a system should be tested with one or multiple test cases.</li>
				<li>Some types of software testing<a id="_idIndexMarker527"/> such as <strong class="bold">performance testing</strong> and <strong class="bold">acceptance testing</strong> should be<a id="_idIndexMarker528"/> performed <a id="_idIndexMarker529"/>by <strong class="bold">subject-matter experts</strong> (<strong class="bold">SMEs</strong>) such as <strong class="bold">quality assurance</strong> (<strong class="bold">QA</strong>) engineers <a id="_idIndexMarker530"/>or senior developers.</li>
				<li>Plan to start testing the basic functionalities first, then extend to testing the advanced features.</li>
				<li>It is <a id="_idIndexMarker531"/>recommended to start testing at the early stages of a project as, in this case, the cost of fixing defects is way less than when testing during later stages of the project.</li>
				<li><strong class="bold">Defect clustering</strong> is based on <a id="_idIndexMarker532"/>the <strong class="bold">Pareto</strong> principle, which states that 80% of <a id="_idIndexMarker533"/>defects are caused by 20% of the system features. This means that during testing, a large number of defects detected are related to a small number of features.</li>
				<li>It is not recommended to repeat the same test cases over and over because, after a certain time, we won't find any new defects. The best practice is to adjust the test cases, with the aim of finding new defects.</li>
				<li>Testing is context-dependent, which means we need to apply specific methodologies and techniques based on the context of the system we are testing. For instance, testing a <strong class="bold">content management system</strong> (<strong class="bold">CMS</strong>) is different from testing an <strong class="bold">iOS</strong> e-commerce app.</li>
			</ul>
			<p>Let's start exploring the various types of testing.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor130"/>Exploring the main types of software testing</h1>
			<p>One of the major reasons for <a id="_idIndexMarker534"/>failure in software projects is a lack of product quality. Software testing is an integral part of the project life cycle, helping to ensure that a product is error-/defect-free and, in the same way, verifying the functionalities implemented to make sure they match the requirements defined with the client. There are two main categories of software testing, outlined as follows: </p>
			<ul>
				<li><strong class="bold">Functional testing</strong>: This is<a id="_idIndexMarker535"/> used to validate each feature and function of the system<a id="_idIndexMarker536"/> to verify all functionalities.</li>
				<li><strong class="bold">Non-functional testing</strong>: This is <a id="_idIndexMarker537"/>used to validate non-functional aspects of the <a id="_idIndexMarker538"/>system, such as performance, usability, and compliance. </li>
			</ul>
			<p>Here is a diagram showing the different types of testing we will discuss in this chapter:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_8.01_B17366.jpg" alt="Figure 8.1: Types of testing"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1: Types of testing</p>
			<p>We will look at all the different types of testing shown in the preceding diagram in the upcoming sections.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor131"/>Unit testing</h2>
			<p><strong class="bold">Unit testing</strong> is a type of <a id="_idIndexMarker539"/>testing performed to test every individual function or<a id="_idIndexMarker540"/> module of a system. Usually, it is performed by .NET developers who are working on a product because it requires some coding skills. That's why it is considered a low-level type of testing since it is targeting the behavior of the code only.</p>
			<p>Here is a diagram showing the unit-test level as an integral part of the entire testing life cycle:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/Figure_8.02_B17366.jpg" alt="Figure 8.2: Unit-test level in the testing life cycle"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2: Unit-test level in the testing life cycle</p>
			<p>In the preceding diagram, unit testing represents the first type of testing that should be conducted before starting any other testing activity, as the cost of fixing defects becomes higher at later levels of testing.</p>
			<p>Here are some<a id="_idIndexMarker541"/> benefits of unit testing:</p>
			<ul>
				<li>Unit tests allow us to fix defects at the early stages of the development cycle. This will save time and costs to fix the same defects later on during the acceptance-testing stage.</li>
				<li>It helps to document the source code.</li>
				<li>It allows the developers to refactor the code and reuse available functions to eliminate any repetition in the API.</li>
				<li>Unit testing is essential for testing dependencies if we are making changes to the API.</li>
				<li>It helps reduce code complexity.</li>
			</ul>
			<p>For more details on automating unit tests, see the list of testing tools<a id="_idIndexMarker542"/> recommended by Microsoft: <a href="https://docs.microsoft.com/en-us/dotnet/core/testing/#testing-tools&#13;">https://docs.microsoft.com/en-us/dotnet/core/testing/#testing-tools.</a></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor132"/>Integration testing</h2>
			<p><strong class="bold">Integration testing</strong> is<a id="_idIndexMarker543"/> intended to test two or more modules of a solution to <a id="_idIndexMarker544"/>verify whether they work well together. For example, it can involve testing the behavior of the integration between the system we are building and <strong class="bold">Azure Active Directory</strong>, to verify the authentication mechanism.</p>
			<p>Another example of this type of testing is when we need to verify the interaction between our system and the database layer. Integration testing should be performed after completing the development of two modules that are subject to the testing we are conducting.</p>
			<p>In the following diagram, we are showing that integration testing should target only the integration part between <strong class="bold">Module A</strong> and <strong class="bold">Module B</strong>:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/Figure_8.03_B17366.jpg" alt="Figure 8.3: Integration testing for two modules"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: Integration testing for two modules</p>
			<p>Here are some benefits<a id="_idIndexMarker545"/> of integration testing:</p>
			<ul>
				<li>Integration testing helps to ensure that the integrated modules are working properly as expected.</li>
				<li>It allows for simulating the transition between various modules in the system.</li>
				<li>It also helps to detect<a id="_idIndexMarker546"/> errors that may occur in the interaction of the modules.</li>
			</ul>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor133"/>Regression testing</h2>
			<p>It is normal to test new changes that we perform on a system, such as modifying an existing feature or<a id="_idIndexMarker547"/> adding a new one. However, this is not enough, because in most cases, the code we change or add will have a direct or indirect impact on other functionalities, and probably on other<a id="_idIndexMarker548"/> features in the system too. This is why we need to conduct <strong class="bold">regression testing</strong> to make sure that the new code didn't cause any new defects.</p>
			<p>In the following diagram, we are showing the three main steps of regression testing: </p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/Figure_8.04_B17366.jpg" alt="Figure 8.4: Main steps of regression testing"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4: Main steps of regression testing</p>
			<p>Here are some benefits<a id="_idIndexMarker549"/> of regression testing:</p>
			<ul>
				<li>Regression testing ensures that existing features remain untouched in case of a change to a module or code.</li>
				<li>Automated regression testing helps implement <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>), which saves time and costs.</li>
				<li>It allows for the detection of defects caused by changes in the system environment.</li>
				<li>It increases client trust and satisfaction, which may lead to expanding business.</li>
			</ul>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/>Smoke testing</h2>
			<p><strong class="bold">Smoke testing</strong> is a<a id="_idIndexMarker550"/> technique that was adopted in the plumbing industry, where they usually used white smoke to identify any leaks in pipes. </p>
			<p>Today, the concept of <a id="_idIndexMarker551"/>smoke testing is used in software development to verify the basic functionality of a build. If a test fails, the build is considered unstable, and the system is not ready to perform any other type of testing activity.</p>
			<p>The following diagram shows the main stages of smoke testing:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/Figure_8.05_B17366.jpg" alt="Figure 8.5: The life cycle of smoke testing"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5: The life cycle of smoke testing</p>
			<p>In the preceding diagram, we can see that the testing procedure starts by creating a new build with a version number. After that, we need to prioritize the test cases and decide what to test exactly to certify the new build before moving to functional testing. If the smoke testing fails, then we need to fix the defects and start over by creating a new build.</p>
			<p>Here are some benefits<a id="_idIndexMarker552"/> of smoke testing:</p>
			<ul>
				<li>It helps to detect show-stopping issues in the early stages before starting any other type of testing.</li>
				<li>It improves the efficiency <a id="_idIndexMarker553"/>of the QA team by detecting defects that may take longer to be detected if they want to run functional testing.</li>
			</ul>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/>End-to-end testing</h2>
			<p><strong class="bold">End-to-end</strong> (<strong class="bold">E2E</strong>) <strong class="bold">testing</strong> is <a id="_idIndexMarker554"/>considered the full-fledged testing of an <a id="_idIndexMarker555"/>application. It is typically convenient to test the functionalities of the entire system; it is important to replicate the production environment to conduct this type of testing, and the testing scenarios should imitate the user behavior. The main goal of this type of testing is to certify that the different user flows are functioning properly with no errors and as per the requirements.</p>
			<p>In the following diagram, we show the three main steps<a id="_idIndexMarker556"/> of the E2E testing process:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/Figure_8.06_B17366.jpg" alt="Figure 8.6: The three main steps of E2E testing"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: The three main steps of E2E testing</p>
			<p>In the preceding diagram, the user functions represent the actions performed in a particular functionality in the system, and the conditions represent the various input data and sequences that can be applied to each user function. As for the test cases, these are created based on the previous two actions—that is, the user functions along with the conditions.</p>
			<p>Here are some major benefits<a id="_idIndexMarker557"/> of E2E testing:</p>
			<ul>
				<li>It helps ensure complete readiness and the health of the system.</li>
				<li>It allows us to test the full system from a user's perspective.</li>
				<li>It helps to test real-life scenarios that can be applied by end users.</li>
			</ul>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/>User interface testing</h2>
			<p>The term <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) speaks for itself. <strong class="bold">UI testing</strong> is performed to test an application's <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>), with the aim of making sure that the UI of the application is <a id="_idIndexMarker558"/>developed as per the requirements and<a id="_idIndexMarker559"/> is user-friendly.</p>
			<p>In the following diagram, we can see that the business layer and the data layer can be tested using unit tests. As for the UI, the only way to test it is through UI testing:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/Figure_8.07_B17366.jpg" alt="Figure 8.7: UI testing"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7: UI testing</p>
			<p>Here are some major benefits<a id="_idIndexMarker560"/> of UI testing:</p>
			<ul>
				<li>It helps to check the alignment of UI elements, along with checking the font style, the color, and the clarity of the text displayed.</li>
				<li>It allows us to check whether a product is rendering correctly on all devices and screens that are supposed to be supported.</li>
				<li>It helps to check error <a id="_idIndexMarker561"/>messages, along with warning messages.</li>
			</ul>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor137"/>Acceptance testing</h2>
			<p><strong class="bold">Acceptance testing</strong> (also known as <strong class="bold">user acceptance testing</strong>, or <strong class="bold">UAT</strong>) is considered the last phase of<a id="_idIndexMarker562"/> testing and is usually performed by the key users of the client to verify that all business requirements have been developed and that <a id="_idIndexMarker563"/>the system is working properly <a id="_idIndexMarker564"/>and efficiently as expected by the end users. Typically, acceptance testing is conducted based on test cases that are generated from user cases prepared during the analysis phase of a project.</p>
			<p>In the following diagram, we show that UAT is the last testing phase before moving to a production environment:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/Figure_8.08_B17366.jpg" alt="Figure 8.8: UAT in the project life cycle"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8: UAT in the project life cycle</p>
			<p>Here are some benefits of UAT:</p>
			<ul>
				<li>It helps to validate that all <a id="_idIndexMarker565"/>business requirements defined at the beginning of a project are correctly implemented and working properly without any errors.</li>
				<li>It allows for the fixing of detected defects during development rather than in a production environment, which is less costly, especially in the case of solutions with online payment.</li>
				<li>It helps to increase users' trust in the new system before the go-live stage.</li>
			</ul>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor138"/>Performance testing</h2>
			<p><strong class="bold">Performance testing</strong> is non-functional testing that is often used to check whether a system is working properly as <a id="_idIndexMarker566"/>per the performance requirements <a id="_idIndexMarker567"/>defined by the client and the standards.</p>
			<p>The following four main elements<a id="_idIndexMarker568"/> are considered when carrying out performance testing:</p>
			<ul>
				<li><strong class="bold">Bottlenecks</strong> are major issues that bring down a system.</li>
				<li>The <strong class="bold">load time</strong> needed to load a page or a form.</li>
				<li>The <strong class="bold">response time</strong> of triggering an action or completing a process.</li>
				<li><strong class="bold">Scalability</strong> is the ability of a system to handle a large number of requests without crashing.</li>
			</ul>
			<p>The following diagram shows us the four main elements of carrying out performance testing:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/Figure_8.09_B17366.jpg" alt="Figure 8.9: Performance-testing elements"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9: Performance-testing elements</p>
			<p>Here are some benefits of <a id="_idIndexMarker569"/>performance testing:</p>
			<ul>
				<li>It helps to measure the response time, accuracy, and stability of the system.</li>
				<li>It allows for the detection of issues that reduce the response time of the application or the overall hardware usage.</li>
				<li>It helps improve the load time of pages and increases user satisfaction.</li>
			</ul>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor139"/>Stress testing</h2>
			<p><strong class="bold">Stress testing</strong> is a type of <a id="_idIndexMarker570"/>non-functional testing that certifies the stability and <a id="_idIndexMarker571"/>reliability of a system. The main target of stress testing is to measure the strength and error-handling capabilities of the system when it is under an extremely heavy load of requests that is way beyond the normal operating situation of the system. Its purpose is to understand how the system behaves under this heavy load.</p>
			<p>The following diagram describes the steps of stress testing:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/Figure_8.10_B17366.jpg" alt="Figure 8.10: Stress-testing main steps"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10: Stress-testing main steps</p>
			<p>Initially, the stress-testing process starts by planning and deciding on the test cases. After that, we should create scripts and execute them in an automated process. The results of the stress test should be analyzed carefully to identify the root cause of any issues. At the end, we need to fix issues by optimizing the code and then rerunning the whole stress-testing process until we have a stable build. </p>
			<p>Here are some benefits<a id="_idIndexMarker572"/> of stress testing:</p>
			<ul>
				<li>It allows us to check and handle error messages that may occur.</li>
				<li>It helps to check whether the data was saved correctly before any failure was caused by a heavy load of requests.</li>
			</ul>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/>Compliance testing</h2>
			<p><strong class="bold">Compliance testing</strong> (also known<a id="_idIndexMarker573"/> as <strong class="bold">conformance testing</strong>) is a type of audit-testing technique usually <a id="_idIndexMarker574"/>performed to verify whether a product meets a set of external and<a id="_idIndexMarker575"/> internal standards before deciding whether the system is ready to be released or not.</p>
			<p>The internal standards are typically set by the organization. For example, a website should be designed for various devices and screens, therefore it should provide a responsive UI.</p>
			<p>As for external standards, these are regulations that are set by a worldwide consortium or a third-party organization that <a id="_idIndexMarker576"/>specializes in this type of testing. An<a id="_idIndexMarker577"/> example of an external standard is the <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>) or the <strong class="bold">Web Content Accessibility Guidelines</strong> (<strong class="bold">WCAG</strong>). </p>
			<p>The following diagram shows the main system attributes that are usually assessed by compliance testing:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/Figure_8.11_B17366.jpg" alt="Figure 8.11: System attributes assessed by compliance testing"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: System attributes assessed by compliance testing</p>
			<p>As shown in the <a id="_idIndexMarker578"/>preceding diagram, each attribute is contributing to the overall compliance of the system. So, let's get to know each of these attributes, as follows:</p>
			<ul>
				<li><strong class="bold">Robustness</strong>: This shows the ability of a system to function normally in the case of disturbance.</li>
				<li><strong class="bold">Performance</strong>: This represents the time needed by a system to complete a single task. Compliance testing should measure the performance of the main functions in the system and certify that they are performing well, based on predefined testing criteria.</li>
				<li><strong class="bold">Interoperability</strong>: This shows the ability of a system to exchange information with other third-party systems. Moreover, it shows how well different functions in the system are interacting together to complete a process.</li>
				<li><strong class="bold">Functions</strong>: This assesses the interfaces and functionalities provided by a system, along with confirming whether the requirements defined at the early stages of the project are met.</li>
				<li><strong class="bold">Behavior of system</strong>: This <a id="_idIndexMarker579"/>assesses the behavior of a system with the environment in which it is hosted. It also assesses how the system behaves after executing every user story defined previously.</li>
			</ul>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/>Disaster recovery testing</h2>
			<p>A <strong class="bold">disaster recovery plan</strong> (<strong class="bold">DRP</strong>) should<a id="_idIndexMarker580"/> be considered for <a id="_idIndexMarker581"/>enterprise solutions and mission-critical <a id="_idIndexMarker582"/>systems. It consists of a set of detailed guidelines and strategies that should be implemented to handle unplanned incidents that would disrupt the normal operations of a system. A good DRP should enable us to recover quickly from disruptive events such as cyber-attacks, power outages, hardware outages, or any other incidents. It should ensure the continuity of business processes and minimize damage as much as possible.</p>
			<p>DR testing is the process of certifying a DRP by evaluating each step in the process to make sure that it will work as expected when an incident occurs.</p>
			<p>So far, we have explored the main testing types and techniques, such as unit testing, smoke testing, performance testing, and acceptance testing. It is essential to know each of these testing types and when to use them to deliver high-quality software products. We should ensure that a product meets standards and requirements, all the way from coding to business functionalities of the product as a whole. Applying different testing types between functional and non-functional tests will boost quality, to achieve exceptional results.</p>
			<p>In the next section, we are going to explore the capabilities of test plans in Azure.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor142"/>Exploring testing in Azure</h1>
			<p>Manual testing can <a id="_idIndexMarker583"/>be a key testing technique to deliver a great UX and to certify a product before the go-live stage. <strong class="bold">Azure Test Plans</strong>, along with <strong class="bold">Visual Studio 2019</strong>, offers the features we <a id="_idIndexMarker584"/>need to manage our testing efforts, from manual and exploratory testing to load and stress testing.</p>
			<p>The starting point is to<a id="_idIndexMarker585"/> create a test plan made up of configurations, test suites, and<a id="_idIndexMarker586"/> test cases that can be broken down into shared test steps, and use the parameters that will allow us to repeat a test but with different input data.</p>
			<p>Use the following link to sign in to Azure DevOps: <a href="https://azure.microsoft.com/en-us/services/devops/">https://azure.microsoft.com/en-us/services/devops/</a>.</p>
			<p>After successful login, you can see <strong class="bold">Test Plans</strong> in the menu on the left side, as per the following screenshot:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/Figure_8.12_B17366.jpg" alt="Figure 8.12: Test Plans in Azure DevOps"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12: Test Plans in Azure DevOps</p>
			<p>After creating a test plan, we need to set the configurations upon which we intend to run our tests—for example, we can specify the operating system and browser configurations if we are testing a web application. Test configurations can be assigned to an entire test plan or individual test suites, and even test cases. If we assigned the configurations to a test plan, this would ensure that all created test cases are automatically assigned to those configurations. </p>
			<p>When you<a id="_idIndexMarker587"/> click on <strong class="bold">Test Plans</strong>, a sliding submenu will be opened, showing more<a id="_idIndexMarker588"/> capabilities where we can create new test plans, set parameters, and modify configurations, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/Figure_8.13_B17366.jpg" alt="Figure 8.13: Configurations under Test Plans"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13: Configurations under Test Plans</p>
			<p>With our test configurations set, we can now start creating test suites, which are collections of test cases.</p>
			<p>There are three different types of test suites, outlined as follows: </p>
			<ul>
				<li><strong class="bold">Static test suite</strong>: This is a<a id="_idIndexMarker589"/> logical container where we can add any <a id="_idIndexMarker590"/>test case we like.</li>
				<li><strong class="bold">Requirement-based test suite</strong>: This<a id="_idIndexMarker591"/> is where we associate our<a id="_idIndexMarker592"/> test case to a work item to define its acceptance criteria.</li>
				<li><strong class="bold">Query-based test suite</strong>: This <a id="_idIndexMarker593"/>is where we create a work-item <a id="_idIndexMarker594"/>query to select which test cases to include. Any test case that meets the query criteria will be added automatically to the test suite.</li>
			</ul>
			<p>After we define our test suite, we need to start creating a test case and assigning it to the test team. Creating a test case is a very straightforward process. The main element is the steps to execute in any expected results. Steps that are repeated often can be extracted as shared steps to ease test maintenance. After preparing the test cases, we are ready to start the test run manually. Note that from the <strong class="bold">Runs</strong> page, we can review all our previous test runs, along with their results.</p>
			<p>Up to now, we have learned about manual testing in Azure, which has its benefits. But when we develop more features and our source code grows in size, testing all functionalities manually can become repetitive and time-consuming. Therefore, Azure offers us a mechanism to automate our tests in order to eliminate the burden of manual testing and to allow QA engineers to focus on delivering better quality and an improved <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>). </p>
			<p>With Azure DevOps, we can automate our tests from Azure Test Plans by using Azure pipelines. There are many types of testing that we can automate with Azure pipelines, such as unit testing, security testing, and code-coverage testing, which calculates the percentage of code that's covered by unit tests.</p>
			<p>Here are some key recommendations<a id="_idIndexMarker595"/> when using Azure Test Plans for testing:</p>
			<ul>
				<li>Make sure the testing is serving a purpose and has a positive impact on the product, and try not to test for the sake of testing.</li>
				<li>Keep the tests straightforward, focused, and short. Tests should run quickly, especially if they are triggered on the build or release of a product. </li>
			</ul>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor143"/>Summary</h1>
			<p>In this chapter, we explored some key principles that outline fundamental guidelines required to conduct proper testing. We also learned about the essential testing types that we must know as solution architects. Being aware of each of these testing types will help us decide which functional and non-functional tests we should apply to ensure high-quality software products and to deliver products that meet requirements. In the last section of this chapter, we explored the capabilities of test plans in Azure DevOps, along with the key benefits.</p>
			<p>In the next chapter, we will dig deep into architecting modern web applications with <strong class="bold">ASP.NET Core</strong> and <strong class="bold">Microsoft Azure</strong>.</p>
		</div>
	</body></html>