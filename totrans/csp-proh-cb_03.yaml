- en: Chapter 3. Object-Oriented Programming in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to the foundation of C# and **object-oriented
    programming** (**OOP**). In this chapter, you will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During your career as a creator of software, you will hear the term OOP many
    times. This design philosophy allows for objects to exist independently and can
    be reused by different sections of code. This is all made possible by what we
    refer to as the four pillars of OOP, namely inheritance, encapsulation, abstraction,
    and polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to grasp this, you need to start thinking of objects (which are basically
    instantiated classes) that perform a specific task. Classes need to adhere to
    the SOLID design principle. This principle is explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility** **principle** (**SRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov substitution** **principle** (**LSP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start off with an explanation of the four pillars of OOP, after which
    we will have a look at the SOLID principle in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, inheritance is usually associated with the end of things.
    In OOP, however, it is associated with the beginning of something new and better.
    When we create a new class, we can take an already existing class and have our
    new class inherit from it. This means that our new object will have all the features
    of the inherited class, as well as the additional features added to the new class.
    This is at the root of inheritance. We call a class that inherits from another
    a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate the concept of inheritance, we will create a few classes that
    inherit from another to form new, more feature-rich objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class library by right-clicking on your solution and selecting
    **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter3`:![How to do it…](img/B05391_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your new class library will be added to your solution with a default name `Class1.cs`,
    which we renamed to `Recipes.cs` in order to distinguish the code properly. You
    can, however, rename your class to whatever you like if it makes more sense to
    you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To rename your class, simply click on the class name in the **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to confirm the renaming of all references to the
    code element **Class1** in the project. Just click on **Yes**:![How to do it…](img/B05391_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s create a new class called `SpaceShip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `SpaceShip` class will contain a few methods that describe the basics of
    a spaceship. Go ahead and add these methods to your `SpaceShip` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the `SpaceShip` class forms part of all other intergalactic vessels,
    it becomes the blueprint for every other vessel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we want to create a `Destroyer` class. To accomplish this, we will create
    a `Destroyer` class and use a colon after the class name to indicate that we want
    to inherit from another class (the `SpaceShip` class). Therefore, the following
    needs to be added when creating the `Destroyer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also say that the `Destroyer` class is derived from the `SpaceShip` class.
    The `SpaceShip` class is therefore the base class of all other intergalactic vessels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add a few methods to the `Destroyer` class that are unique to a destroyer.
    These methods belong only to the `Destroyer` class and not to the `SpaceShip`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a third class called `Annihilator`. This is the most powerful
    intergalactic vessel and is used to wage war on planets. Let the `Annihilator`
    class inherit from the `Destroyer` class by creating the class and marking it
    as derived from the `Destroyer` class as follows `Annihilator : Destroyer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a few methods to the `Annihilator` class that only belong to this
    type of `SpaceShip` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the console application, add a reference to the `Chapter3` class library
    by right-clicking on **References** under the **CodeSamples** project and selecting
    **Add Reference** from the context menu:![How to do it…](img/B05391_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Reference Manager** window, select the `Chapter3` solution under **Projects**
    | **Solutions**. This will allow you to use the classes we just created in your
    console application:![How to do it…](img/B05391_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we see now is that when we create a new instance of the `SpaceShip` class,
    only the methods defined in that class are available to us. This is because the
    `SpaceShip` class does not inherit from any other class:![How to do it…](img/B05391_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and create the `SpaceShip` class with its methods in the console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see that these are the only methods available to us when instantiating
    a new instance of this class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, create a new instance of the `Destroyer` class. You will notice that the
    `Destroyer` class contains more methods than what we defined when we created the
    class. This is because the `Destroyer` class is inheriting the `SpaceShip` class
    and therefore inherits the methods of the `SpaceShip` class:![How to do it…](img/B05391_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and create the `Destroyer` class with all its methods in the console
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, create a new instance of the `Annihilator` class. This class contains
    all the methods of the `Destroyer` class as well as the methods from the `SpaceShip`
    class. This is because `Annihilator` inherits from `Destroyer`, which, in turn,
    inherits from `SpaceShip`:![How to do it…](img/B05391_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and create the `Annihilator` class with all its methods in the console
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see that inheritance allowed us to easily extend our classes by reusing
    functionality that already exists within another class created earlier. You also
    need to be aware though that any changes to the `SpaceShip` class will be inherited
    up the stack to the top-most derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a very powerful feature of C#, which allows developers to write
    less code and reuse working and tested methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With abstraction, we take from the object we want to create the basic functionality
    that all objects derived from the abstracted object must have. To explain this
    in simple terms, we abstract the common functionality and put it in a single class
    that will be used to provide this shared functionality to all classes that inherit
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To explain abstraction, we will use abstract classes. Imagine that you are dealing
    with trainee space astronauts who need to progress through the ranks as they get
    trained. The truth is that once you as trainee learn a new skill, that skill is
    learned and will remain with you even though you learn more advanced ways to do
    things. You must also implement all the previous skills learned in the new object
    you create. Abstract classes demonstrate this concept very nicely.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an abstract class called `SpaceCadet`. This is the first type of astronaut
    you can be when starting with training. The abstract class and its members are
    defined using the `abstract` keyword. A thing to note is that abstract classes
    cannot be instantiated. The members represent the skills that `SpaceCadet` will
    have, such as negotiation and basic weapons training:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create another abstract class called `SpacePrivate`. This abstract class
    inherits from the `SpaceCadet` abstract class. What we are basically saying is
    that when a space cadet is trained as a space private, they will still have all
    the skills learned as a space cadet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To demonstrate this, create a class called `LabResearcher` and inherit the
    `SpaceCadet` abstract class. Inheriting from the abstract class is done by defining
    a colon and abstract class name after the newly created class name. This tells
    the compiler that the `LabResearcher` class inherits from the `SpaceCadet` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we are inheriting an abstract class, the compiler will underline the
    `LabResearcher` class name to warn us that the derived class does not implement
    any of the methods in the `SpaceCadet` abstract class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you hover your mouse over the squiggly line, you will see that the lightbulb
    tip provides us with the issues discovered:![How to do it…](img/B05391_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio does a great job of providing a solution to the issues discovered.
    By typing *Ctrl* + *.* (Control key and dot), you can let Visual Studio show you
    some potential fixes (in this case, only one fix) for the issues identified:![How
    to do it…](img/B05391_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After Visual Studio has added the required methods, you will see that these
    are the same methods defined in the `SpaceCadet` abstract class. Abstract classes,
    therefore, require the classes inheriting from the abstract class to implement
    the methods defined in the abstract class. You will also notice that the methods
    added to the `LabResearcher` class contain no implementation and will throw an
    exception if used as is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a class called `PlanetExplorer` and make this class inherit from
    the `SpacePrivate` abstract class. You will remember that the `SpacePrivate` abstract
    class inherited from the `SpaceCadet` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visual Studio will once again warn you that your new class does not implement
    the methods of the abstract class that you are inheriting from. Here, however,
    you will notice that the lightbulb tip informs you that you are not implementing
    any of the methods in the `SpacePrivate` and `SpaceCadet` abstract classes. This
    is because the `SpacePrivate` abstract class is inheriting from the `SpaceCadet`
    abstract class:![How to do it…](img/B05391_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fix the issues identified, type *Ctrl* + *.* (Control key and dot) and let
    Visual Studio show you some potential fixes (in this case, only one fix) for the
    issues identified:![How to do it…](img/B05391_03_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the fixes have been added to your code, you will see that the `PlanetExplorer`
    class contains all the methods in the `SpacePrivate` and `SpaceCadet` abstract
    classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstraction has allowed us to define a common set of functionality that is to
    be shared among all the classes that derive from the abstract classes. The difference
    between inheriting from the abstract class and a normal class is that with an
    abstract class, you have to implement all the methods defined in that abstract
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the class easy to version and change. If you need to add new functionality,
    you can do so by adding that functionality to the abstract class without breaking
    any of the existing code. Visual Studio will require that all inherited classes
    implement the new method defined in the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: You can, therefore, be assured that the change applied will be implemented in
    all your classes that derive from the abstract classes in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is encapsulation? Simply put, it is hiding the inner workings of a class
    that aren''t necessary for the implementation of that class. Think of encapsulation
    as follows: most people who own a car know that it runs on gas. They don''t need
    to know the inner workings of an internal combustion engine to be able to use
    a car. They only need to know that they need to fill it up with gas when it is
    close to empty and that they need to check the oil and tyre pressure. Even then,
    it is usually not done by the car owner. This is true for classes and encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: The owner of the class is the one who uses it. The inner workings of that class
    need not be exposed to the developer using the class. The class is, therefore,
    like a black box. You know that the class will be consistent in its functionality,
    given the correct set of parameters. How exactly the class gets to the output
    is of no concern to the developer as long as the input is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate the concept of encapsulation, we will create a class that is somewhat
    complex in its inner workings. We need to calculate the **thrust to weight ratio**
    (**TWR**) of a space shuttle to determine whether it will be able to take off
    vertically. It needs to exert more thrust than its weight to counteract gravity
    and get into a stable orbit. This also depends on which planet the shuttle takes
    off from, because different planets exert different gravitational forces on objects
    on their surface. In simple terms, the TWR must be greater than one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new class called `LaunchSuttle`. Then, add the following private variables
    to the class for engine thrust; the mass of the shuttle; the local gravitational
    acceleration; the constant values for the gravity of the Earth, Moon, and Mars
    (these are constants because they will never change); the universal gravitational
    constant; and an enumerator for the planet we are dealing with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To our class, we will add three overloaded constructors that are essential to
    perform the calculation of the TWR based on the known facts at the time of instantiation
    (we assume that we will always know the engine thrust capability and mass of the
    shuttle). We will pass the gravitational acceleration for the first constructor.
    This is useful if we know beforehand what that value will be. For example, the
    gravitational acceleration of the Earth is 9.81 m/s².
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second constructor will use the `Planet` enumerator to calculate the TWR
    that uses the constant variable values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The third constructor will use the radius and mass of the planet to calculate
    the gravitational acceleration when those values are knows to return the TWR:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to use the second overloaded constructor that passes the `Planet`
    enumerator as a parameter to the class, we need to create another method that
    has been scoped as `private` to calculate the gravitational acceleration. We also
    need to set the `_LocalGravitationalAcceleration` variable to the specific constant
    that matches the enumerator value. This method is something that the user of the
    class does not need to see in order to use the class. It is, therefore, scoped
    as `private` in order to hide that functionality from the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Of the following methods, only one is defined as public and will, therefore,
    be visible to the user of the class. Create the private methods to set the universal
    gravitational constant, to calculate the TWR, and to calculate the gravitational
    acceleration. These are all scoped as private, because the developer does not
    need to know what these methods do in order to use the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in your console application, create the following variables with their
    known vales:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of the `LaunchShuttle` class and pass it the values needed
    to calculate the TWR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you use the dot operator on the `NasaShuttle1` variable, you will notice
    that IntelliSense only shows the `TWR` method. The class exposes nothing of the
    inner workings of how it gets to the calculated TWR value. The only thing that
    the developer knows is that the `LaunchShuttle` class will consistently return
    the correct TWR value, given the same input parameters:![How to do it…](img/B05391_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test this, create two more instances of the `LaunchShuttle` class and call
    a different constructor each time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run your console application, you will see that the same value is returned
    for the TWR. The value indicates that a shuttle weighing 16.12 tons with a rocket
    that puts out 220 kilonewtons of thrust will be able to lift off the surface of
    the Earth (if only just):![How to do it…](img/B05391_03_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class uses the scoping rules to hide certain functionality inside the class
    from the developer using the class. As mentioned earlier, the developer does not
    need to know how the calculations are done to return the value for the TWR. This
    all aids in making the class more useful and easy to implement. Here is a list
    of the various scopes available in C#, along with their uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Public`: This is used with variables, properties, types, and methods and is
    visible anywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Private`: This is used with variables, properties, types, and methods and
    is visible only in the block where they are defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protected`: This is used with variables, properties, and methods. Don''t think
    of this in terms of public or private. The protected scope is only visible inside
    the class in which it is used, as well as in any inherited classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Friend`: This is used with variables, properties, and methods and can only
    be used by code in the same project or assembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protected Friend`: This is used with variables, properties, and methods and
    is a combination (as the name suggests) of the protected and friend scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism is a concept that is quite easy to grasp once you have looked at
    and understood the other pillars of OOP. Polymorphism literally means that something
    can have many forms. This means that from a single interface, you can create multiple
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: There are two subsections to this, namely static and dynamic polymorphism. With
    static polymorphism, you are dealing with the overloading of methods and functions.
    You can use the same method, but perform many different tasks.
  prefs: []
  type: TYPE_NORMAL
- en: With dynamic polymorphism, you are dealing with the creation and implementation
    of abstract classes. These abstract classes act as a blueprint that tells you
    what a derived class should implement. The following section looks at both.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin by illustrating the use of an abstract class, which is an example
    of dynamic polymorphism. We will then create overloaded constructors as an example
    of static polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an abstract class called `Shuttle` and give it a member called `TWR`,
    which is the calculation of the TWR of the shuttle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a class called `NasaShuttle` and have it inherit from the abstract
    class `Shuttle`, by putting the abstract class name after a colon at the end of
    the `NasaShuttle` class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visual Studio will underline the `NasaShuttle` class because you have told the
    compiler that the class inherits from an abstract class, but you have not yet
    implemented the members of that abstract class:![How to do it…](img/B05391_03_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fix the issues identified, type *Ctrl* + *.* (Control key and dot) and let
    Visual Studio show you some potential fixes (in this case, only one fix) for the
    issues identified:![How to do it…](img/B05391_03_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visual Studio then adds the missing implementation to your `NasaShuttle` class.
    By default, it will add it as not implemented, because you are required to provide
    implementation for the abstract member you overrode in the abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another class called `RoscosmosShuttle` and inherit from the same `Shuttle`
    abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visual Studio will underline the `RoscosmosShuttle` class because you have told
    the compiler that the class inherits from an abstract class, but you have not
    yet implemented the members of that abstract class:![How to do it…](img/B05391_03_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fix the issues identified, type *Ctrl* + *.* (Control key and dot) and let
    Visual Studio show you some potential fixes (in this case, only one fix) for the
    issues identified:![How to do it…](img/B05391_03_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The overridden method is then added to the `RoscosmosShuttle` class as not
    implemented. You have just seen an example of dynamic polymorphism in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see an example of static polymorphism, create the following overloaded constructor
    for `NasaShuttle`. The constructor name stays the same, but the signature of the
    constructor changes, which makes it overloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism is something you will easily be using already by simply applying
    good object oriented principles to the design of your classes. With the abstract
    `Shuttle` class, we saw that the class took on the shape of the `NasaShuttle`
    class and the `RoscosmosShuttle` class when it was used to derive those new classes
    from its abstraction. The constructor of the `NasaShuttle` class was then overridden
    to provide the same method name, but implemented using different signatures.
  prefs: []
  type: TYPE_NORMAL
- en: This is at the heart of polymorphism. Most likely, you have been using it without
    knowing about it.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about SOLID principles, we will start off with the SRP. Here, we
    are actually saying that a class has a specific task that it needs to fulfil and
    it should not do anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will create a new class and write code to log an error to the database when
    an exception is thrown on adding more troops to the star ship, causing it to be
    over capacity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new class called `StarShip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To your class, add a new method that will set the maximum troop capacity of
    the `StarShip` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this method, add a `trycatch` clause that will attempt to set the maximum
    troop capacity, but for some reason, it will fail. Upon failure, it will write
    the error to the log table inside the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have code that looks like the preceding one, you are in contravention
    of the SRP. The `StarShip` class is no longer responsible for just itself and
    things that have to do with star ships. It now has to fulfill the role of logging
    errors to the database too. You see the problem here is that the database-logging
    code does not belong in the `catch` clause of the `SetMaximumTroopCapacity` method.
    A better approach would be to create a separate `DatabaseLogging` class with methods
    to create connections and write exceptions to the appropriate log table. You will
    also find that you are going to have to write that logging code in multiple places
    (in every `catch` clause). If you are finding that you are repeating code (by
    copying and pasting from other areas), you probably need to put that code into
    a common class, and you have likely broken the SRP rule.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating classes, we need to ensure that the class prohibits any breaking
    modifications by needing to change internal code. We say that such a class is
    closed. If we need to change it somehow, we can do so by extending the class.
    This extensibility is where we say that the class is open for extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will create a class that determines the skills of a trooper by looking at
    the class of trooper. We will show you the way many developers create such a class
    and the way it can be created using the open/closed principle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a class called `StarTrooper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To this class, add an enumerator called `TrooperClass` to identify the type
    of trooper we want to return the skills of. Also, create a `List<string>` variable
    to contain the skills of the specific trooper class. Finally, create a method
    called `GetSkills` that returns the specific set of skills for the given trooper
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is quite straightforward, but the implementation of the code is something
    we see a lot. Sometimes, instead of a `switch` statement, you will see a whole
    lot of `if` `else` statements. While the functionality of the code is clear, it
    is not easy to add another class of trooper to the `StarTrooper` class without
    changing code. Assume that you now have to add an additional `Engineer` class
    to the `StarTrooper` class. You would have to modify the `TrooperClass` enumeration
    and the code in the `switch` statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This changing of code can cause you to introduce bugs into code that was previously
    working fine. We now see that the `StarTrooper` class is not closed and can''t
    be extended easily to accommodate additional `TrooperClass` objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The solution to this problem is inheritance. Instead of having to change code,
    we extend it. Start off by rewriting the above `StarTrooper` class and create
    a `Trooper` class. The `GetSkills` method is declared as `virtual`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can easily create derived classes for the `Soldier`, `Medic`, and `Scientist`
    trooper classes available. Create the following derived classes that inherit from
    the `Trooper` class. You can see that the `override` keyword is used when creating
    the `GetSkills` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code becomes extremely easy to implement when extending the class to add
    an additional class of `Trooper`. If we now want to add the `Engineer` class,
    we would simply override the `GetSkills` method after inheriting from the `Trooper`
    class created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classes derived from the `Trooper` class are extensions of the `Trooper`
    class. We can say that each class is closed, because modifying it does not necessitate
    changing the original code. The `Trooper` class is also extensible because we
    have been able to easily extend the class by creating derived classes from it.
  prefs: []
  type: TYPE_NORMAL
- en: Another by-product of this design is smaller, more manageable code that is easier
    to read and understand.
  prefs: []
  type: TYPE_NORMAL
