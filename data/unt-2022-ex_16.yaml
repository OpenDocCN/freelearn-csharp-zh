- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Enhancing the FPS Game with Audio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音频增强FPS游戏
- en: In [*Chapter 11*](B18347_11.xhtml#_idTextAnchor212), we transformed a gray-boxed
    prototype environment by replacing modular Prefabs with high-quality 3D models,
    preserved Prefabs with extra behavior in Prefab Mode, and applied new materials.
    We also added objects to the environment by painting Prefabs, telling surface
    stories by placing wear-and-tear decals, and implementing lighting and shadow
    setups for real-time and baked lighting.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B18347_11.xhtml#_idTextAnchor212)中，我们通过用高质量的3D模型替换模块化预制体、在预制体模式下保留具有额外行为的预制体以及应用新材料，将一个灰盒原型环境进行了转换。我们还通过绘制预制体添加了环境中的对象，通过放置磨损贴图讲述表面故事，并实现了实时和烘焙光照的灯光和阴影设置。
- en: To improve the player experience, we have to work on the sound design aspect
    of our game. Until now, we haven’t given much attention to audio and **sound effects**
    (**SFX**). Let’s change that now by developing an audio manager and reusable audio
    player components system. This will allow us to easily add audio and SFX to our
    game, even for designers and artists who may not have much experience with coding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升玩家体验，我们必须关注我们游戏的声音设计方面。到目前为止，我们并没有过多关注音频和**声音效果**（**SFX**）。现在让我们通过开发音频管理器和可重用的音频播放组件系统来改变这一点。这将使我们能够轻松地将音频和SFX添加到我们的游戏中，即使对于可能没有太多编码经验的设计师和艺术家来说也是如此。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Adding audio using the Audio Mixer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用音频混音器添加音频
- en: Building an immersive soundscape with music, SFX, and ambiance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用音乐、音效和氛围构建沉浸式声音景观
- en: Enhancing the audio experience with footsteps and reverb zones
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚步声和混响区域增强音频体验
- en: Deeper SOLID refactoring
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入的SOLID重构
- en: By the end of this chapter, you’ll be able to code an audio manager and its
    components to play game music and SFX through an Audio Mixer. You will also gain
    an understanding of the differences between playing 2D and 3D sound and how to
    reuse audio playing components to create new sound behavior, such as footstep
    sounds. Additionally, you will learn how to add effects zones to your game’s level.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够编写音频管理器和其组件的代码，通过音频混音器播放游戏音乐和音效。您还将了解播放2D和3D声音之间的差异以及如何重用音频播放组件来创建新的声音行为，例如脚步声。此外，您还将学习如何为游戏关卡添加效果区域。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上下载完整项目[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Adding audio using the Audio Mixer
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音频混音器添加音频
- en: In any interactive experience, sound is pivotal in enveloping the player in
    the game world. This section will introduce different ways to play audio using
    Unity’s audio tooling. You’ll learn how to elevate your game’s audio experience
    by effectively utilizing music, both 2D and 3D SFX, ambient noise, and reverb
    zones.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何交互式体验中，声音在将玩家包围在游戏世界中起着至关重要的作用。本节将介绍使用Unity的音频工具播放音频的不同方法。您将学习如何通过有效利用音乐、2D和3D音效、环境噪声和混响区域来提升您游戏音频体验。
- en: Let’s get started by defining what sound design is.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义声音设计是什么开始。
- en: Sound design 101 for games
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏声音设计101
- en: Good sound design can significantly enhance the player’s experience and immersion
    in the game. Play your favorite game but turn off the sound, and you’ll see quite
    quickly that the experience is not the same!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的声音设计可以显著增强玩家的游戏体验和沉浸感。玩您最喜欢的游戏，但关闭声音，您会很快发现体验完全不同！
- en: Several audio concepts come together to form the foundation of sound design
    in creating the atmosphere for an immersive world. While I’ll be introducing sound
    design components, just know it’s more art than technical in bringing all the
    concepts together – this is the job of a sound designer!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 几个音频概念结合在一起，构成了在创建沉浸式世界氛围时声音设计的基石。虽然我将介绍声音设计组件，但请知道这更多的是艺术而非技术，将所有概念结合在一起——这是声音设计师的工作！
- en: 'We’ll be implementing audio scripts that will enable us to add the following
    elements of sound design:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现音频脚本，使我们能够添加以下声音设计元素：
- en: '**Music/background music**: Set the mood with music! Also, changes in music
    at the right moments of gameplay can be impactful to the player.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音乐/背景音乐**：用音乐设定氛围！此外，在游戏玩法中的正确时刻改变音乐对玩家可能产生重大影响。'
- en: '**SFX**: Every time the player swings their sword, picks up a coin, bumps into
    a crate, or defeats an enemy, SFX is crucial for player immersion and enhancing
    the gameplay experience.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SFX**：每当玩家挥舞剑、捡起硬币、撞到箱子或击败敌人时，SFX对于玩家的沉浸感和增强游戏体验至关重要。'
- en: '**Ambience or atmosphere**: The environmental sounds, or background noise,
    you hear that sets the scene and lets you know you are in a real living place.
    Generally, 3D audio changes based on the player’s position and orientation to
    an audio source in the environment, which can greatly enhance immersion.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境或氛围**：你听到的环境声音，或背景噪音，它设定了场景，让你知道你在一个真实的居住地。通常，3D音频会根据玩家在环境中的位置和朝向音频源的变化而变化，这可以极大地增强沉浸感。'
- en: '**Character dialogue**: Yes, dialogue is sound design too. The style of their
    voice can further define a character. Voice can also be used to drive a story-driven
    narrative.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色对话**：是的，对话也是声音设计的一部分。他们的声音风格可以进一步定义一个角色。声音也可以用来推动以故事驱动的叙事。'
- en: '**UI feedback**: *Clicks*, *boops*, and *beeps* on button presses and changes
    in the UI when the player is interacting provide a satisfying feedback experience
    that you don’t want to omit from your overall sound design.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI反馈**：当玩家与UI交互时，按钮按下和变化的*点击声*、*嘟嘟声*和*哔哔声*提供了一个令人满意的反馈体验，你不想从整体声音设计中省略。'
- en: Gathering all of the preceding sound design elements together into a cohesive
    audio soundscape for a game experience is another job performed by the sound designer,
    and it is called audio mixing. **Audio mixing** allows for further engineering
    of the audio experience and can include additional audio tooling such as filters,
    effects, and reverb zones.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有先前的声音设计元素汇集在一起，为游戏体验创建一个连贯的音频声音景观，这是声音设计师完成的另一项工作，这被称为音频混音。**音频混音**允许进一步工程化音频体验，并可以包括额外的音频工具，如过滤器、效果和混响区域。
- en: Additional reading | Unity documentation
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: When it comes to audio, there are many factors to consider, such as formats,
    file size, compression quality, looping capabilities, and runtime performance
    – for starters. While a deep dive into the technical aspects of varying audio
    formats is not within the scope of this chapter, rest assured that I won’t shy
    away from pointing out crucial format details wherever necessary in the upcoming
    sections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到音频时，有许多因素需要考虑，例如格式、文件大小、压缩质量、循环能力和运行时性能——仅举几个例子。虽然深入探讨不同音频格式的技术细节超出了本章的范围，但请放心，我将在接下来的部分中
    wherever necessary 指出关键格式细节。
- en: 'You can read more about audio here: [https://docs.unity3d.com/2022.3/Documentation/Manual/Audio.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Audio.xhtml).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于音频的信息：[https://docs.unity3d.com/2022.3/Documentation/Manual/Audio.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Audio.xhtml)。
- en: Now that we understand sound design, we’ll put on our *audio developer hat*
    and add audio to our 3D FPS game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了声音设计，我们将戴上**音频开发者**的帽子，并将音频添加到我们的3D第一人称射击游戏中。
- en: Adding audio to the game
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加游戏音频
- en: We’ll start by adding an Audio Mixer. Even though I mentioned audio mixing last
    in the previous section, we’ll add the capability to mix our game audio first
    and patch every audio component through it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个音频混音器。尽管我在上一节中最后提到了音频混音，但我们将首先添加混合游戏音频的能力，并将每个音频组件都通过它进行连接。
- en: Working with the Audio Mixer
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用音频混音器
- en: The **Audio Mixer** asset will allow us to set levels for each sound element
    we define independently – tailoring our game’s soundscape. It will also allow
    us to change levels when required in gameplay and provides a convenient way for
    the player to adjust levels to their taste via UI controls.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**音频混音器**资产将使我们能够独立地为每个定义的声音元素设置音量级别——定制我们游戏的声音景观。它还允许我们在游戏过程中根据需要更改音量，并为玩家提供了一个方便的通过UI控件调整音量的方式。'
- en: Additional reading | Unity documentation
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'You can read more about the Audio Mixer here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioMixer.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioMixer.xhtml).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于音频混音器的信息：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioMixer.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioMixer.xhtml)。
- en: To add an Audio Mixer, we’ll first have to ensure we have our project open in
    Unity and have our habitat interior level design scene from [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187),
    open (e.g., `Habitat` `Interior 1`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加音频混音器，我们首先必须确保我们在Unity中打开了我们的项目，并且打开了来自[*第10章*](B18347_10.xhtml#_idTextAnchor187)的栖息地内部级别设计场景（例如，`Habitat`
    `Interior 1`）。
- en: 'We can now create a new `AudioMixer 1` in a new `Assets/Audio` folder (using
    the **Create** | **Audio Mixer** menu). Once you’ve created **AudioMixer 1**,
    double-clicking on it (in the **Project** window) will open the **Audio Mixer**
    window, as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在新的`Assets/Audio`文件夹中创建一个新的`AudioMixer 1`（使用**创建** | **音频混合器**菜单）。一旦创建了**AudioMixer
    1**，双击它（在**项目**窗口中）将打开**音频混合器**窗口，如图所示：
- en: '![Figure 12.1 – Audio Mixer setup](img/B18347_12_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 音频混合器设置](img/B18347_12_01.jpg)'
- en: Figure 12.1 – Audio Mixer setup
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 音频混合器设置
- en: With the **Audio Mixer** window open, we can now add groups for the channels
    of audio we’ll want to mix the levels for.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开**音频混合器**窗口的情况下，我们现在可以为我们将要混合级别的音频通道添加组。
- en: 'Add the following groups (see *Figure 12**.1* for reference) by clicking the
    big plus sign (**+**) to the right of the **Groups** heading. Note that when the
    group first appears, the field is highlighted so that you can give it a name right
    away:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**组**标题右侧的大加号（**+**）添加以下组（参见*图12.1*以供参考）。请注意，当组首次出现时，字段会被高亮显示，这样你就可以立即给它命名：
- en: '**Music**: The level at which the game’s music will be played is set with this
    group'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音乐**：游戏音乐播放的级别是通过这个组设置的'
- en: '**SFX**: The game’s SFX level will be set with this group'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SFX**：游戏的SFX级别将通过这个组设置'
- en: '**Ambient** [sound]: All of the environmental ambiance and noise will be set
    with this group'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境音**[声音]：所有环境音和噪音将通过这个组设置'
- en: Tip
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In **Play Mode**, there is a toggle button called **Edit in Play Mode** in the
    **Audio Mixer** window. This toggle, when enabled, allows us to adjust or mix
    audio levels while playtesting.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在**播放模式**中，**音频混合器**窗口中有一个名为**在播放模式下编辑**的切换按钮。当启用此切换时，它允许我们在游戏测试时调整或混合音频级别。
- en: In *Figure 12**.1*, you can see I left all the levels at zero except for the
    `-16` to see how loud that sounds during gameplay – it should be lower so as not
    to drown out the SFX.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.1*中，你可以看到我将所有级别都设置为零，除了`-16`，以查看在游戏过程中这个级别听起来有多响——它应该更低，以免盖过SFX。
- en: Okay, that was easy! We’ll continue coding our way through creating the audio
    system with components for playing the different sound elements in the following
    sections. It all starts with an audio manager class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很简单！我们将在接下来的章节中继续编码，创建具有播放不同声音元素组件的音频系统。一切从音频管理类开始。
- en: Creating a simple audio manager
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的音频管理器
- en: Following what should be a recognizable code architecture at this point in the
    book, introduced in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041), section *SOLID
    principles and design patterns*, we’ll create an audio manager class by following
    SOLID principles. Specifically, we’ll rely on the SOLID **open-closed principle**
    (**OCP**) and polymorphism, and also introduce an interface for our different
    types of audio player components responsible for playing the different kinds of
    sounds in the game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本书此阶段应能识别的代码架构，在[*第2章*](B18347_02.xhtml#_idTextAnchor041)中介绍了SOLID原则和设计模式，我们将遵循SOLID原则创建一个音频管理类。具体来说，我们将依赖SOLID
    **开闭原则**（**OCP**）和多态性，并为负责在游戏中播放不同类型声音的不同类型的音频播放器组件引入一个接口。
- en: 'Now, let us create a C# script in a new `Assets/Scripts/Audio` folder named
    `AudioManager`. We’ll start by adding the necessary variable declarations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在新的`Assets/Scripts/Audio`文件夹中创建一个名为`AudioManager`的C#脚本。我们将从添加必要的变量声明开始：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we can see the groundwork for implementing the Audio Mixer groups we configured
    in the previous section. We’ve also declared some `AudioSource` variables for
    sound playback – these will be explained as we add to the code while implementing
    the play audio functionality in the following *Building an immersive soundscape
    with music, SFX, and* *ambiance* subsections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到实现我们在上一节中配置的音频混合器组的准备工作。我们还声明了一些`AudioSource`变量用于声音播放——这些将在我们添加代码并实现以下*构建具有音乐、SFX和*
    *环境音* *的沉浸式声音景观* *子节中的播放音频功能时进行解释。
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I’m just going to assume by now that you know that if we have a class inheriting
    from **MonoBehaviour**, we need a **using UnityEngine;** statement at the top
    of the C# script. As you should also know, this **using** statement is already
    there from the default script template. :)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在假设你已经知道，如果我们有一个从**MonoBehaviour**继承的类，我们需要在C#脚本顶部添加一个**using UnityEngine;**语句。正如你也应该知道的，这个**using**语句已经存在于默认脚本模板中。
    :)
- en: Again, one of the key functions the `AudioManager` class will handle for us
    is setting the Audio Mixer group for the type of audio we want to play. This will
    ensure sound designers can use the Audio Mixer to set the initial audio playback
    levels of the game (i.e., designing the soundscape).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`AudioManager`类将为我们处理的关键功能之一是设置我们想要播放的音频类型的音频混音器组。这将确保声音设计师可以使用音频混音器来设置游戏（即，设计声音景观）的初始音频播放级别。
- en: 'Now, add the following code to the `AudioManager` class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`AudioManager`类中：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: switch expression (C#)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: switch表达式（C#）
- en: 'You can read more about pattern-matching expressions using the **switch** keyword
    here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于使用**switch**关键字进行模式匹配表达式的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression)。
- en: Here, we’ve created an `AudioType` enum that we’ll use to map an audio player
    component to an Audio Mixer group. We’ve added the `GetAudioMixerGroup()` method
    to get the appropriate Audio Mixer group by using a `switch` expression and passing
    in an `AudioType` enum. This will all become clearer in the next section when
    we create our first audio player component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`AudioType`枚举，我们将使用它将音频播放器组件映射到音频混音器组。我们已经添加了`GetAudioMixerGroup()`方法，通过使用`switch`表达式并传递一个`AudioType`枚举来获取适当的音频混音器组。所有这些将在我们创建第一个音频播放器组件的下一节中变得更加清晰。
- en: Discards (C#)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 抛弃（C#）
- en: 'Note that the compiler will generate a warning if the switch expression in
    the preceding code doesn’t handle all possible input values. In that case, we
    could use the following discard pattern so all possible input values are handled
    – avoiding a console warning: _ => throw new ArgumentOutOfRangeException(nameof(AudioType),
        $"Not expected audioType value: {audioType}"),'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，如果前面代码中的switch表达式没有处理所有可能的输入值，编译器将生成一个警告。在这种情况下，我们可以使用以下抛弃模式来处理所有可能的输入值，从而避免控制台警告：_
    => throw new ArgumentOutOfRangeException(nameof(AudioType), $"Not expected audioType
    value: {audioType}"),'
- en: The underscore (**_**) is a placeholder variable that won’t hold a value and
    is not intended to be used.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线（**_**）是一个占位符变量，它不会保留任何值，也不打算使用。
- en: 'You can read more about discards here: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于抛弃的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards)。
- en: With the `AudioManager` class we have coded up until now, we are ready to start
    making the audio player components! But before we do that, we’ll need to have
    a way to access `AudioManager` to call on its methods. So, we’ll continue to use
    the Singleton pattern for our managers – go ahead and add the required code for
    it now.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现在编写的`AudioManager`类中，我们准备开始制作音频播放器组件！但在我们这样做之前，我们需要一种方法来访问`AudioManager`以调用其方法。所以，我们将继续使用Singleton模式来处理我们的管理器
    – 现在就添加所需的代码吧。
- en: 'As a reminder, here it is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这里就是：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To add the `AudioManager` script, a class derived from `MonoBehaviour`, to our
    project, create a new GameObject named `AudioManager` in the `AudioManager` script
    to it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`AudioManager`脚本添加到我们的项目中，创建一个新的名为`AudioManager`的GameObject，并在`AudioManager`脚本中将其添加到该GameObject中。
- en: We can now assign the `AudioMixerGroup` fields by clicking and dragging the
    group from the **Audio Mixer** window or using the field’s **Object Picker** window
    (the small circle icon at the right side of the field), using *Figure 12**.2*
    as a guide.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过点击和拖动从**音频混音器**窗口或使用字段的**对象选择器**窗口（字段右侧的小圆圈图标）来分配`AudioMixerGroup`字段，使用*图12**.2*作为指南。
- en: '![Figure 12.2 – AudioManager mixer groups assignment](img/B18347_12_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – `AudioManager`混音组分配](img/B18347_12_02.jpg)'
- en: Figure 12.2 – AudioManager mixer groups assignment
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – `AudioManager`混音组分配
- en: Done! Well, we don’t actually have any methods to play sound in our audio manager…
    yet…
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！嗯，实际上我们还没有在我们的音频管理器中添加任何播放声音的方法……
- en: The audio manager foundation for the game is in place, so we can now begin writing
    the individual components to play the different types of audio needed in the game.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的音频管理器基础已经就绪，因此我们现在可以开始编写单个组件来播放游戏中需要的不同类型的音频。
- en: Building an immersive soundscape with music, SFX, and ambiance
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音乐、SFX和氛围构建沉浸式声音景观
- en: We’ll cover writing audio player components for what I consider the most common
    scenarios for the type of game audio we’ll need. We’ll have components for playing
    music, SFX, and ambient sounds. We’ll also cover playing the sound in 2D or 3D
    space, as required or desired, for each type of audio player component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖为我认为最常见场景编写的音频播放器组件。我们将有播放音乐、音效和环绕声的组件。我们还将介绍在 2D 或 3D 空间中播放声音，根据需要或愿望，为每种类型的音频播放器组件。
- en: Everything that plays sound in Unity requires an `AudioSource` component (think
    of it as a speaker, and you can have many), and the scene requires a single `AudioListener`
    (think of it as the microphone). By default, our main camera in the scene comes
    with the `AudioListener` component already added – so we’re good; there is nothing
    further to do there.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中播放声音的所有内容都需要一个 `AudioSource` 组件（将其视为扬声器，您可以有多个），场景需要一个单独的 `AudioListener`（将其视为麦克风）。默认情况下，场景中的主相机已经添加了
    `AudioListener` 组件——所以没问题；那里没有其他需要做的事情。
- en: Additional reading | Unity documentation
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'You can read more about the Audio Listener here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioListener.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioListener.xhtml).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于音频监听器的信息：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioListener.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioListener.xhtml).
- en: As seen in the `AudioManager` implementation, it’s important to note that we
    are ensuring all audio player components direct audio playback through `AudioManager`
    so that the correct Audio Mixer group is used. This design is intentional, so
    anyone adding an audio player component (developer, designer, artist, etc.) won’t
    have to remember to set the correct mixer group for the specific component type.
    This will be super simple to accomplish because – you guessed it – we’ll use an
    interface (as we’ll soon see when coding our audio player components).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 `AudioManager` 实现中所示，请注意，我们确保所有音频播放器组件都通过 `AudioManager` 进行音频播放，以便使用正确的音频混音器组。这种设计是有意为之的，因此任何添加音频播放器组件的人（开发者、设计师、艺术家等）都不必记住为特定组件类型设置正确的混音器组。这将非常简单，因为——您猜对了——我们将使用一个接口（正如我们将在编写音频播放器组件时很快看到的）。
- en: Project audio files
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 项目音频文件
- en: The audio files that will be used in the following sections are all either public
    domain or **Creative Commons Zero** (**CC0**) ([https://creativecommons.org/publicdomain/zero/1.0/deed.en](https://creativecommons.org/publicdomain/zero/1.0/deed.en))
    and are available from the **Audio-Assets** folder in the GitHub repo, from the
    individual Unity project assets folders, or from the original download links provided
    in the corresponding sections.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下文将使用的音频文件都是公共领域或**Creative Commons Zero**（**CC0**）([https://creativecommons.org/publicdomain/zero/1.0/deed.en](https://creativecommons.org/publicdomain/zero/1.0/deed.en))，并且可以从
    GitHub 仓库中的**Audio-Assets**文件夹、单个 Unity 项目资源文件夹或相应部分提供的原始下载链接中获取。
- en: 'The GitHub repo audio assets for this chapter can be found here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Audio-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Audio-Assets).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本章 GitHub 仓库中的音频资源可以在这里找到：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Audio-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Audio-Assets).
- en: Okay, on to our first audio player component. Time to play some sweet music!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来是我们的第一个音频播放器组件。是时候播放一些美妙的音乐了！
- en: Playing music
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放音乐
- en: We’ll delve into the technical aspects of incorporating music into your games.
    A music composer is responsible for creating impactful soundtracks that resonate
    with your audience and become synonymous with your game’s identity. Therefore,
    I highly recommend partnering with a composer for your projects to achieve this
    level of quality.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入研究将音乐融入您游戏的技术方面。音乐作曲家负责创建与您的观众产生共鸣并成为您游戏身份象征的音轨。因此，我强烈建议您与作曲家合作，以实现这一级别的质量。
- en: However, if you are looking for a more budget-friendly option, you can use sourced
    music, where composers create pre-made soundtracks in different genres that can
    be purchased and used in your project (sometimes, as in our case here, even for
    free).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您正在寻找一个更经济实惠的选项，您可以使用来源音乐，作曲家为不同流派创建预制的配乐，这些配乐可以购买并在您的项目中使用（有时，就像我们在这里的情况一样，甚至可以免费使用）。
- en: But, before we can assign any music clips to an audio player component, we first
    have to create one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们可以将任何音乐片段分配给音频播放器组件之前，我们首先必须创建一个。
- en: Warning!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！
- en: The **AudioPlayerMusic** class introduced next will not follow the SOLID OCP.
    This is intentional. We will instead use this initially coded approach as an example
    to be refactored for the remainder of the audio player components. Hopefully,
    it will serve as a reinforcement learning opportunity to solidify knowledge.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个将要介绍的 **AudioPlayerMusic** 类不会遵循 SOLID OCP。这是故意的。我们将最初编写的这种方法作为示例，用于重构其余的音频播放组件。希望这能作为一个强化学习的机会，以巩固知识。
- en: 'We’re starting with playing music, so create a new C# script named `AudioPlayerMusic`
    in a new `Assets/Scripts/Audio` folder with the following fields and methods declared:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从播放音乐开始，因此在一个新的 `Assets/Scripts/Audio` 文件夹中创建一个名为 `AudioPlayerMusic` 的新 C#
    脚本，并声明以下字段和方法：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s have a look at what we did here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在这里做了什么：
- en: '`_musicClip`: An audio clip holds the audio data representing the sound to
    be played, which supports many popular audio file formats (`.wav`, `.mp3`, and
    `.ogg` being the most used). In the **Inspector** window, this variable will be
    assigned a reference to an audio file asset from the **Project** window folder
    for our game’s music to be played.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_musicClip`：音频剪辑包含要播放的声音的音频数据，它支持许多流行的音频文件格式（`.wav`、`.mp3` 和 `.ogg` 是最常用的）。在
    **Inspector** 窗口中，这个变量将被分配一个从 **Project** 窗口文件夹中音频文件资产的引用，用于播放我们游戏的音乐。'
- en: Additional reading | Unity documentation
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'You can read more about audio clips here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于音频剪辑的信息：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml)。
- en: '`_playOnStart`: This variable is a simple Boolean flag we’ll set in the **Inspector**
    to tell this audio player component to start playing when the game begins or not.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_playOnStart`：这个变量是一个简单的布尔标志，我们将在 **Inspector** 中设置，以告诉这个音频播放组件在游戏开始时开始播放或不播放。'
- en: '`Start()`: We evaluate the value of `_playOnStart` in the `Start()` Unity message
    event method and call `Play()` if `true`. Simple.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start()`：我们在 `Start()` Unity 事件方法中评估 `_playOnStart` 的值，如果为 `true` 则调用 `Play()`。很简单。'
- en: '`Play()`: This is where the magic happens, where we tell `AudioManager` to
    start playing our lovely music’s audio clip.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Play()`：这是魔法发生的地方，我们告诉 `AudioManager` 开始播放我们可爱的音乐音频剪辑。'
- en: As you can see, we call a `PlayMusic()` method in the `AudioManager` Singleton
    instance. However, the method doesn’t yet exist. Let’s fix this now to complete
    the playing music functionality.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在 `AudioManager` 单例实例中调用了一个 `PlayMusic()` 方法。然而，这个方法还不存在。让我们现在修复它以完成播放音乐的功能。
- en: Adding the PlayMusic() method to AudioManager
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 PlayMusic() 方法添加到 AudioManager
- en: 'Now, add the `PlayMusic()` method to the `AudioManager` class as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `PlayMusic()` 方法添加到 `AudioManager` 类中，如下所示：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`AudioManager` will play the music directly by adding `AudioSource` to the
    GameObject it resides with:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioManager` 将直接通过向其所在的 GameObject 添加 `AudioSource` 来播放音乐：'
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, following the architecture we established, set the appropriate mixer group,
    the music clip passed in as a parameter to the `_audioSourceMusic` audio source,
    and the remaining properties set the music to play in 2D space and on an infinite
    loop.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据我们建立的架构，设置适当的混音组，将作为参数传入 `_audioSourceMusic` 音频源的音剪辑，其余属性设置音乐在 2D 空间和无限循环中播放。
- en: 'The `_audioSourceMusic` properties for playing music are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`_audioSourceMusic` 播放音乐的属性如下：'
- en: '`spatialBlend = 0f`: Based on the player’s position in the environment, we
    don’t want the music to be heard differently, so setting the spatial blend property
    to `0f` makes it a full 2D sound.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spatialBlend = 0f`：基于玩家在环境中的位置，我们不想让音乐被听到不同的效果，因此将空间混合属性设置为 `0f` 使其成为全 2D
    声音。'
- en: Tip
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When adding 2D audio sources to the scene, note that their transform position
    in world space won’t matter; the audio listener always hears them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当向场景添加 2D 音频源时，请注意，它们在全局空间中的变换位置无关紧要；音频监听器总是听到它们。
- en: '`loop = true`: This one is pretty clear – does `loop` equal `true`? Yup. Then
    play the audio clip in a loop forever! Otherwise, play it once.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop = true`：这个很简单——`loop` 是否等于 `true`？是的。那么就循环播放音频剪辑，永远循环！否则，只播放一次。'
- en: The remaining properties for an `AudioSource` component will be set to their
    default values, which will all be just fine for background music.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioSource` 组件的其余属性将设置为它们的默认值，这对于背景音乐来说都很好。'
- en: Additional reading | Unity documentation
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'You can learn more about **AudioSource** here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于 **AudioSource** 的信息：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml)。
- en: Finally, the music is played using the `Play()` method on `_audioSourceMusic`.
    All that remains to get the music playing in our game is to add `AudioPlayerMusic`
    to our scene.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `_audioSourceMusic` 上的 `Play()` 方法播放音乐。要让音乐在我们的游戏中播放，我们只需将 `AudioPlayerMusic`
    添加到场景中即可。
- en: Implementing AudioPlayerMusic
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 AudioPlayerMusic
- en: Implementing our music audio player component means adding the `AudioPlayerMusic`
    script to our scene (no surprise here).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的音乐音频播放器组件意味着将 `AudioPlayerMusic` 脚本添加到我们的场景中（这里没有惊喜）。
- en: In the `AudioPlayerMusic` as a sibling component to the `AudioManager` component
    on the `AudioManager` object in the **Hierarchy**. *Figure 12**.3* shows our final
    music audio player component setup.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AudioPlayerMusic` 作为 `AudioManager` 对象上的 `AudioManager` 组件的兄弟组件。*图 12.3*
    展示了我们的最终音乐音频播放器组件设置。
- en: '![Figure 12.3 – Adding AudioPlayerMusic to the AudioManager object](img/B18347_12_03.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 将 AudioPlayerMusic 添加到 AudioManager 对象](img/B18347_12_03.jpg)'
- en: Figure 12.3 – Adding AudioPlayerMusic to the AudioManager object
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 将 AudioPlayerMusic 添加到 AudioManager 对象
- en: We can see in the preceding figure that the audio clip for the music is already
    assigned to the `Arpent` audio file to our project now and make that assignment.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的图中看到，音乐音频片段已经分配给我们的项目中的 `Arpent` 音频文件，并完成该分配。
- en: If you haven’t yet imported the audio assets from the project GitHub repo, refer
    back to the *Building an immersive soundscape with music, SFX, and ambiance* section
    and do that now. We’ll need the audio files for the next step and the following
    sections.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未从项目 GitHub 仓库导入音频资源，请参阅 *使用音乐、SFX 和氛围构建沉浸式声音景观* 部分，并现在执行该操作。我们接下来需要音频文件以及以下部分。
- en: The music file we’ll be using for our game is `Arpent.mp3` and comes from FreePD
    ([https://freepd.com/music/Arpent.mp3](https://freepd.com/music/Arpent.mp3)).
    The music is licensed CC0, meaning we can use it for free.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在游戏中使用的音乐文件是 `Arpent.mp3`，来自 FreePD ([https://freepd.com/music/Arpent.mp3](https://freepd.com/music/Arpent.mp3))。音乐受
    CC0 许可，这意味着我们可以免费使用。
- en: Ensure the `Arpent.mp3` file is imported to the `Assets/Audio/Music` folder.
    Then, with the file selected in the **Project** window, let’s adjust the import
    settings in the **Inspector** window to something appropriate for what is generally
    a longer music clip – you can see in the **Inspector** window in the following
    figure that the music file is nearly three minutes long (**2:42.064** to be exact).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `Arpent.mp3` 文件导入到 `Assets/Audio/Music` 文件夹中。然后，在 **项目** 窗口中选中该文件，让我们在 **检查器**
    窗口中调整导入设置，以适应通常较长的音乐片段——您可以在以下图中的 **检查器** 窗口中看到音乐文件几乎有三分钟长（确切地说为 **2:42.064**）。
- en: '![Figure 12.4 – Audio clip import Inspector settings](img/B18347_12_04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 音频片段导入检查器设置](img/B18347_12_04.jpg)'
- en: Figure 12.4 – Audio clip import Inspector settings
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 音频片段导入检查器设置
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You’ll have noticed by now that when we select assets in the **Project** window,
    the **Inspector** will adjust to the type of asset chosen, so the import settings
    will look different.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您可能已经注意到，当我们选择 **项目** 窗口中的资源时，**检查器** 会根据所选资源的类型进行调整，因此导入设置看起来会有所不同。
- en: 'Settings to note that we’ve changed here are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此处更改的设置如下：
- en: '**Load In Background**: Enabling loading the audio file in the background for
    lengthy or high-quality music files ensures the game runs smoothly since asynchronous
    loading (i.e., not blocking the main thread) eliminates frame drops and the possibility
    of stuttering'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台加载**：对于较长的或高质量的音乐文件，启用在后台加载音频文件可以确保游戏运行顺畅，因为异步加载（即不阻塞主线程）消除了帧降和卡顿的可能性'
- en: '**Load Type**: For longer music files, it’s advised to set this to **Streaming**
    so all of the audio data is not loaded into memory all at once'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载类型**：对于较长的音乐文件，建议将其设置为 **流式传输**，这样所有音频数据就不会一次性加载到内存中'
- en: '`70`% is generally a good balance for music – file size versus quality'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`70`% 通常对于音乐来说是一个良好的平衡点——文件大小与质量'
- en: Audio Clip Import Settings | Unity documentation
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 音频片段导入设置 | Unity 文档
- en: 'You can learn more about audio clip **Inspector** options here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于音频剪辑**检查器**选项的信息：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml)。
- en: When you’ve made these changes, clicking the `AudioPlayerMusic` component by
    selecting the `AudioManager` object in the `Arpent` music file to the **Music
    Clip** field, and we’re done!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这些更改后，通过选择`AudioManager`对象并将`Arpent`音乐文件中的`AudioPlayerMusic`组件拖到**音乐剪辑**字段，我们就完成了！
- en: 'Save your scene and enter Play Mode to hear music play when the game starts.
    If you don’t hear anything, you may need to toggle the *mute audio* icon in the
    **Game** view, as seen here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的场景并进入播放模式，以在游戏开始时听到音乐播放。如果你什么也听不到，你可能需要切换**游戏**视图中的**静音音频**图标，如下所示：
- en: '![Figure 12.5 – Game mute audio toggle](img/B18347_12_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 游戏静音音频切换](img/B18347_12_05.jpg)'
- en: Figure 12.5 – Game mute audio toggle
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 游戏静音音频切换
- en: We’ve started on our journey of audio immersion and exploration in Unity! Hearing
    music playing is a nice way of establishing the mood and setting the stage for
    our gameplay. Game sound designers carefully choose music tracks to create the
    desired emotional and thematic tone, evoking wonder, mystery, or the unknown to
    establish an expansive and intriguing atmosphere. Upon hearing the *Arpent* music
    track, I realized it would be a perfect fit for the sci-fi environment and the
    player’s exploration of the habitat station for this level.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Unity中开始了音频沉浸和探索之旅！听到音乐播放是一种很好的方式，可以确立游戏氛围并为我们的游戏设定舞台。游戏音效设计师会仔细选择音乐曲目，以创造所需的情感和主题基调，唤起惊奇、神秘或未知，从而营造一种广阔而引人入胜的氛围。当我听到*Arpent*音乐曲目时，我意识到它非常适合科幻环境和玩家在这个关卡中对栖息站进行探索。
- en: But as great as playing music is, I’m sure you already know that a game is nothing
    without sound effects!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但尽管播放音乐很棒，我相信你已经知道，没有音效的游戏什么都不是！
- en: Playing SFX
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放SFX
- en: Tell me, would a particular series of sci-fi movies (set in a galaxy far away)
    be complete without its iconic sound of laser swords humming then cutting through
    the air and clashing? The answer is no… no, it wouldn’t.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我，一部特定的科幻电影系列（设定在遥远的星系中）如果没有其标志性的激光剑嗡嗡声和切割空气以及碰撞的声音会完整吗？答案是肯定的……不会的。
- en: SFX are the unsung heroes of game development – only 50% of the game is complete
    without them (no, you cannot argue this). So, what are we waiting for… these SFX
    aren’t going to play themselves!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: SFX是游戏开发中的无名英雄——没有它们，游戏只有50%是完整的（不，你不能争辩这一点）。那么，我们还在等什么呢……这些SFX不会自己播放！
- en: SOLID refactoring with the IPlaySound interface
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用IPlaySound接口进行SOLID重构
- en: 'We’re going to refactor for SOLID principles now. Specifically, `AudioManager`
    will be closed for modification, adhering to the OCP. For the *open* part, we’ll
    pass in the type of audio player object – this is also the polymorphism part –
    each with its own implementation (i.e., modification) to play sound, and the audio
    player types implement an interface: `IPlaySound`. The interface ensures we have
    a consistent public method to call on each different audio player object type
    we implement.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将根据SOLID原则进行重构。具体来说，`AudioManager`将关闭修改，遵循OCP原则。对于**开放**部分，我们将传入音频播放器对象的类型——这也是多态的部分——每个都有其自己的实现（即修改）来播放声音，并且音频播放器类型实现了一个接口：`IPlaySound`。该接口确保我们有一个一致的公共方法可以调用我们实现的每个不同的音频播放器对象类型。
- en: We are making an exception to the *closed-for-modification* principle by allowing
    the use of the `AudioType` enum. This decision is based on making it easier for
    developers and designers to add audio player components. By simplifying the process
    and preventing potential mistakes, we aim to save time and eliminate the need
    for manual assignment of audio groups. The trade-off is that we’ll need to modify
    `AudioManager` whenever a new mixer group is added, which I’m okay with.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过允许使用`AudioType`枚举来对**关闭修改**原则进行例外处理。这个决定是基于让开发者和设计师更容易添加音频播放器组件。通过简化流程并防止潜在的错误，我们旨在节省时间并消除手动分配音频组的需求。权衡是，每次添加新的混音组时，我们都需要修改`AudioManager`，但我对此表示接受。
- en: 'With all that explanation out of the way, let’s look at the `IPlaySound` interface.
    Create a new C# script named `IPlaySound` in the `Assets/Scripts/Audio` folder
    with the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释清楚这一切之后，让我们来看看`IPlaySound`接口。在`Assets/Scripts/Audio`文件夹中创建一个新的C#脚本，命名为`IPlaySound`，代码如下：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the breakdown of the interface declarations:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是界面声明的分解：
- en: '`using AudioType`: Sometimes, we must distinguish a type name shared across
    namespaces. We defined that `AudioManger.AudioType` and `AudioType` exist in `UnityEngine`.
    So, we need to tell the script which one we want. To do that, we use an alias:
    `using AudioType =` `AudioManager.AudioType;`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using AudioType`: 有时，我们必须区分跨命名空间共享的类型名称。我们定义了`AudioManger.AudioType`和`AudioType`存在于`UnityEngine`中。因此，我们需要告诉脚本我们想要哪一个。为此，我们使用别名：`using
    AudioType =` `AudioManager.AudioType;`。'
- en: The using alias (C#)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: using别名 (C#)
- en: 'You can learn more about the **using** alias here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#usingalias](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#usingalias)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于**using**别名的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#usingalias](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#usingalias)
- en: '`PlayAudioType`: This property will get the default value we assign from our
    `AudioType` enum. We will set `AudioMixerGroup` based on this value for the specific
    type of audio player component we’re making – and avoid any assignment mistakes
    in the **Inspector**.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayAudioType`: 此属性将获取我们从`AudioType`枚举分配的默认值。我们将根据此值设置`AudioMixerGroup`，以针对我们制作的特定类型的音频播放组件——并在**检查器**中避免任何分配错误。'
- en: '`PlaySound()`: Exactly as its name states, the implementing class will use
    this method to play the audio clip.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlaySound()`: 正如其名所示，实现类将使用此方法来播放音频剪辑。'
- en: And that’s all we need for our interface. Our audio manager class can now implement
    multiple audio players without modification, following the SOLID OCP, by passing
    each different audio player class by the interface type. The audio player classes
    that implement the interface will provide unique play functionality.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们所需要的接口。现在，我们的音频管理类可以通过接口类型传递每个不同的音频播放类而不做任何修改，遵循SOLID OCP原则。通过接口类型传递每个不同的音频播放类，实现接口的音频播放类将提供独特的播放功能。
- en: 'Let’s see our first example by writing the play SFX component. Create a new
    script named `AudioPlayerSFX` in the `Assets/Scripts/Audio` folder with the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写播放SFX组件的示例来看看。在`Assets/Scripts/Audio`文件夹中创建一个名为`AudioPlayerSFX`的新脚本，并使用以下代码：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we added the `IPlaySound` interface to the `AudioPlayerSFX` class declaration
    to conform to our audio player component design.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`AudioPlayerSFX`类声明中添加了`IPlaySound`接口，以符合我们的音频播放组件设计。
- en: 'Next, we have these core variables and methods that will be common to all the
    audio player components since they are all considered required for playing sound:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有这些核心变量和方法，它们将适用于所有音频播放组件，因为它们都被认为是播放声音所必需的：
- en: '`_audioClip`: Every audio player component needs a clip to play. This variable
    refers to the audio clip asset assigned via the **Inspector** and then played.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_audioClip`: 每个音频播放组件都需要一个剪辑来播放。此变量指的是通过**检查器**分配并播放的音频剪辑。'
- en: '`_volume`: Not every audio file will have the same levels for its playback,
    or, for some sounds in the game, they may satisfy the sound design by playing
    at a lower volume; set with this variable in the **Inspector**.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_volume`: 并非每个音频文件在播放时都会拥有相同的音量级别，或者，对于游戏中的一些声音，它们可能通过降低音量来满足音效设计；通过此变量在**检查器**中设置。'
- en: '`Play()`: The public method we’ll call to start playing the assigned audio
    clip using the `AudioManager` Singleton instance’s `PlayAudio()` method (which
    we’ll be adding in the next section).'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Play()`: 我们将调用的公共方法，用于使用`AudioManager`单例实例的`PlayAudio()`方法（我们将在下一节中添加）开始播放分配的音频剪辑。'
- en: When calling the audio manager’s `PlayAudio()` method, note that we’re passing
    in `this` as the parameter. The `this` keyword refers to the current class instance
    – in this case, `AudioPlayerSFX`, but the parameter type we will use for declaring
    `PlayAudio()` will be `IPlaySound`. This is the magic of polymorphism. We’ll pass
    in `this` as the type parameter, representing any number of different classes
    for unique audio player functionality, but all accessible as `IPlaySound`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用音频管理器的`PlayAudio()`方法时，请注意我们传递的是`this`作为参数。`this`关键字指的是当前类实例——在这种情况下，`AudioPlayerSFX`，但我们将使用的参数类型用于声明`PlayAudio()`将是`IPlaySound`。这就是多态的魔力。我们将`this`作为类型参数传递，代表任何数量的不同类，以实现独特的音频播放功能，但所有这些都可以作为`IPlaySound`访问。
- en: this (C#)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: this (C#)
- en: 'You can read more about the **this** keyword for class instances here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于`this`关键字的用法：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this)
- en: 'Now, implement the `IPlaySound` interface’s public properties and methods (remember,
    interface declarations must be `public`):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实现`IPlaySound`接口的公共属性和方法（记住，接口声明必须是`public`）：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Without repeating the interface details again here, let’s delve into the assignments:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不再重复接口的细节，让我们深入了解分配：
- en: '`PlayAudioType`: Here is where we pre-assign the `AudioType` value for the
    Audio Mixer group we want this audio player component to use.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayAudioType`: 这里是我们为想要使用的音频混音组预分配`AudioType`值的地方，以便这个音频播放器组件使用。'
- en: '`PlaySound()`: Here is where we actually play the sound with the audio-playing
    code specific to this type of audio player component, using the referenced audio
    source. In the case of SFX, we’ll use the `PlayOneShot()` method because it allows
    playing multiple sounds on a single `AudioSource` component.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlaySound()`: 这里是我们实际上使用针对此类音频播放器组件的特定音频播放代码以及引用的音频源来播放声音的地方。在音效的情况下，我们将使用`PlayOneShot()`方法，因为它允许在单个`AudioSource`组件上播放多个声音。'
- en: Note that the `AudioSource` component being passed in here will be added to
    the `AudioManager` object for the 2D SFX. So, there is no need to add an `AudioSource`
    component to the objects with this audio player component added. You’ll see how
    this works in the next section when we add to `AudioManager`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里传递的`AudioSource`组件将被添加到用于2D音效的`AudioManager`对象中。因此，没有必要在添加了此音频播放器组件的对象上添加`AudioSource`组件。你将在下一节中看到它是如何工作的，当我们向`AudioManager`添加内容时。
- en: Additional reading | Unity documentation
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'You can read more about **PlayOneShot()** here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayOneShot.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayOneShot.xhtml)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于**PlayOneShot()**的信息：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayOneShot.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayOneShot.xhtml)
- en: 'To provide some additional clarity to this architecture, now that you’ve seen
    the code and how the method calls are set, let’s look at a `AudioPlayerSFX` and
    `AudioManager` relationship:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一些关于这个架构的额外清晰度，既然你已经看到了代码和方法调用是如何设置的，让我们看看`AudioPlayerSFX`和`AudioManager`之间的关系：
- en: '![Figure 12.6 – Audio architecture UML class diagram](img/B18347_12_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 音频架构UML类图](img/B18347_12_06.jpg)'
- en: Figure 12.6 – Audio architecture UML class diagram
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 音频架构UML类图
- en: The code calls on the audio manager – `AudioManager.PlayAudio()` – to assign
    the correct Audio Mixer group. It then uses the interface to call back to its
    specific play sound function (with the audio source responsible for playing the
    sound) – `IPlaySound.PlaySound()`. It’ll become even clearer as we implement additional
    audio player components in the subsequent sections, each with a unique play sound
    function for playing 3D SFX and ambient sounds.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用音频管理器 – `AudioManager.PlayAudio()` – 来分配正确的音频混音组。然后它使用接口调用回其特定的播放声音功能（带有负责播放声音的音频源）
    – `IPlaySound.PlaySound()`。随着我们在后续章节中实现额外的音频播放器组件，每个组件都有独特的播放声音功能来播放3D音效和环境声音，这会变得更加清晰。
- en: This finishes up our audio player component for playing SFX, but it’s not done
    yet because it won’t play anything with the audio manager’s `PlayAudio()` method
    not existing. Let’s solve this problem now by updating our audio manager.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的SFX播放音频播放器组件，但还没有完成，因为如果没有`AudioManager`的`PlayAudio()`方法，它将无法播放任何声音。让我们现在通过更新我们的音频管理器来解决这个问题。
- en: Updating AudioManager
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新AudioManager
- en: Bringing it all together now, we’re adding in the `AudioManager.PlayAudio()`
    method to set the assigned mixer group and call back to the passed-in component’s
    specific `PlaySound()` functionality to play the audio – in this case, an SFX.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有这些放在一起，我们正在添加`AudioManager.PlayAudio()`方法来设置分配的混音组，并回调到传递的组件的特定`PlaySound()`功能来播放音频
    – 在这种情况下，是音效。
- en: 'Now, open the `AudioManager` script and add the following method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`AudioManager`脚本并添加以下方法：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`PlayAudio()` will be closed for modification so its structure is suitable
    for any number of audio player components that implement the `IPlaySound` interface.
    As such, we’ve made the second argument in the method signature, `source`, have
    a default value of `null`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayAudio()`将关闭修改，因此其结构适合任何数量的实现`IPlaySound`接口的音频播放组件。因此，我们在方法签名中的第二个参数`source`具有默认值`null`。'
- en: For playing 2D sounds, we’re not going to require every object in the scene
    that will play a sound to have `AudioSource` attached to it. Having too many `AudioSource`
    components in the scene can potentially lead to performance issues related to
    memory usage, processing overhead, and audio clipping if too many of those audio
    sources are playing simultaneously (see the *Optimization note* information that
    follows because Unity limits the number of audio sources that can play simultaneously).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于播放2D声音，我们不会要求场景中每个将要播放声音的对象都附加`AudioSource`组件。场景中过多的`AudioSource`组件可能会导致与内存使用、处理开销和音频削波相关的性能问题，如果同时播放太多的这些音频源（请参阅随后的*优化注意事项*信息，因为Unity限制了可以同时播放的音频源数量）。
- en: For an audio source with a `null` value, we’re first going to assume it’s a
    2D sound that will be played – 3D sounds will have their own audio source passed
    in. We’ll use a `private` property to get an instance of `AudioSource` for playing
    the audio clip (using a property getter) instead of using a `private` method to
    return (i.e., `get`) the `AudioSource` reference in the class requiring it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有`null`值的音频源，我们首先假设它是一个将要播放的2D声音 - 3D声音将会有自己的音频源传入。我们将使用一个`private`属性来获取播放音频片段的`AudioSource`实例（使用属性获取器）而不是使用`private`方法来返回（即`get`）类中所需的`AudioSource`引用。
- en: 'Let’s go ahead and add the `AudioSourcePlaySFX` property to `AudioManager`
    now so we have a valid audio source component added to the scene for playing our
    2D sounds:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加`AudioSourcePlaySFX`属性到`AudioManager`中，这样我们就有了一个有效的音频源组件添加到场景中用于播放我们的2D声音：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For this property, you can see we have a getter defined. It evaluates the `private`
    member `_audioSource2D` (previously added) to see whether it already has an `AudioSource`
    component assigned to it, and if not, uses the `AddComponent()` method to add
    one to the scene (as a sibling on the same GameObject as `AudioManager`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个属性，我们可以看到我们定义了一个获取器。它评估了`private`成员`_audioSource2D`（之前已添加）以查看它是否已经分配了一个`AudioSource`组件，如果没有，则使用`AddComponent()`方法将一个组件添加到场景中（作为与`AudioManager`相同的GameObject的兄弟节点）。
- en: It then sets the `spatialBlend` value to ensure 2D playback of the sound and
    returns the new `AudioSource` to have its mixer group assigned and then passed
    back to the audio player component for playing the sound. Whew!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将`spatialBlend`值设置为确保声音的2D播放，并返回新的`AudioSource`以便为其分配混音组，然后将其传递回音频播放组件以播放声音。哇！
- en: Optimization note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 优化注意事项
- en: Note that for the **AudioSource** component that plays the SFX sounds, we have
    a limit to the number of audio clips that can be played simultaneously. **AudioSource**
    supports 32 voices, and each audio clip consumes 2 voices to play. Using the **PlayOneShot()**
    method, we can play several audio clips up to this limit, at which point it will
    start clipping. You may have already guessed that we can support additional audio
    clips by object pooling the **AudioSource** object via the **AudioManager** component.
    Refer back to [*Chapter 6*](B18347_06.xhtml#_idTextAnchor116).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于播放SFX声音的**AudioSource**组件，我们对可以同时播放的音频片段数量有限制。**AudioSource**支持32个声音，每个音频片段播放需要2个声音。使用**PlayOneShot()**方法，我们可以播放多达这个限制的音频片段，此时它将开始削波。你可能已经猜到了，我们可以通过通过**AudioManager**组件对象池化**AudioSource**对象来支持更多的音频片段。请参阅[*第6章*](B18347_06.xhtml#_idTextAnchor116)。
- en: Great, all our audio playback needs should be satisfied per our architecture
    at this point. Let’s see how to implement playing SFX in our scene now before
    moving on to making additional audio player components.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，到目前为止，我们根据我们的架构满足了所有的音频播放需求。现在让我们看看如何在添加额外的音频播放组件之前，在我们的场景中实现播放SFX。
- en: Implementing AudioPlaySFX – Unity event
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现AudioPlaySFX – Unity事件
- en: 'To add our first SFX to the game, let’s revisit something you’re already familiar
    with: our health pickup. Having followed along in the previous chapters – such
    as [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187), section *Recharging aka healing*
    – you should have one in your scene already. Find and select it. Now, let’s add
    the `AudioPlayerSFX` component to the root GameObject. As seen in the following
    figure, it’s added just below the `Destroyer (``Script)` component.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的第一个 SFX 添加到游戏中，让我们回顾一下您已经熟悉的内容：我们的健康恢复。在跟随前几章（例如 [*第 10 章*](B18347_10.xhtml#_idTextAnchor187)，*充电即恢复*
    部分）之后，您应该在场景中已经有了它。找到并选择它。现在，让我们将 `AudioPlayerSFX` 组件添加到根 GameObject。如图所示，它被添加在
    `Destroyer (Script)` 组件的下方。
- en: '![Figure 12.7 – Health pickup SFX](img/B18347_12_07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 健康恢复 SFX](img/B18347_12_07.jpg)'
- en: Figure 12.7 – Health pickup SFX
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 健康恢复 SFX
- en: Assign `AudioPlayerSFX` to play a sound when `OnHealEvent` is triggered from
    the preceding `PickupHeal` component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `AudioPlayerSFX` 分配为在从前面的 `PickupHeal` 组件触发 `OnHealEvent` 时播放声音。
- en: On the `PickupHeal (Script)` component, click the plus (`UnityEvent` field.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PickupHeal (Script)` 组件上，点击加号（`UnityEvent` 字段）。
- en: Click and drag the `AudioPlayerSFX` component (by its title bar) to the new
    entry.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动 `AudioPlayerSFX` 组件（通过其标题栏）到新条目。
- en: In the function selector dropdown, select **AudioPlayerSFX** | **Play()**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数选择下拉菜单中，选择 **AudioPlayerSFX** | **Play()**。
- en: Okay, it’s all wired up, but we’re missing something… what sound will we play?!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所有线路都已经连接好了，但我们还缺少一些东西……我们将播放什么声音？!
- en: Assigning the audio clip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配音频剪辑
- en: The sound file we’ll be using for our health pickup is `item-pickup-v1.wav`.
    It comes from the Freesound website (https://freesound.org/people/DeltaCode/sounds/678384/)
    and is licensed CC0, which means we can use it for free.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于健康恢复的声音文件是 `item-pickup-v1.wav`。它来自 Freesound 网站（https://freesound.org/people/DeltaCode/sounds/678384/），并受
    CC0 许可，这意味着我们可以免费使用它。
- en: Ensure the `item-pickup-v1.wav` file is imported to the `Assets/Audio/SFX` folder.
    Unlike with the music audio file, we’ll use the default import settings values
    for this sound file. Return to the `AudioPlayerSFX` component on the healing pickup,
    then click and drag the `item-pickup-v1` file to the **Audio Clip** field. At
    the top of the **Inspector**, click **Apply All** in the **Prefab** | **Overrides**
    dropdown to ensure all the health pickup instances in the level are updated to
    include playing the SFX.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `item-pickup-v1.wav` 文件已导入到 `Assets/Audio/SFX` 文件夹。与音乐音频文件不同，我们将为此声音文件使用默认的导入设置值。返回到健康恢复的
    `AudioPlayerSFX` 组件，然后点击并拖动 `item-pickup-v1` 文件到 **Audio Clip** 字段。在 **Inspector**
    的顶部，点击 **Prefab** | **Overrides** 下拉菜单中的 **Apply All**，以确保关卡中所有健康恢复实例都更新为包含播放
    SFX。
- en: Playtest the level, adjust the `AudioPlayerSFX` component as needed, and take
    notice of the 2D sound playback. Next, we’ll play SFX in 3D space so you can hear
    the difference.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 测试关卡，根据需要调整 `AudioPlayerSFX` 组件，并注意 2D 声音播放。接下来，我们将在 3D 空间中播放 SFX，以便您能听到区别。
- en: Playing SFX for UI feedback
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 播放 UI 反馈 SFX
- en: Adding SFX to button clicks is also an essential aspect of game sound design.
    It significantly enhances the game’s overall polish and improves player satisfaction.
    It may seem like a small detail, but it can substantially affect how players perceive
    and interact with your game UI. For a UI button, use the **AudioPlayerSFX** component
    and wire up the **Play()** method to the button’s **On Click()** event in the
    **Inspector**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SFX 添加到按钮点击也是游戏声音设计的一个重要方面。它显著提升了游戏的整体品质并提高了玩家的满意度。这看似是一个小细节，但它可以极大地影响玩家对您的游戏
    UI 的感知和交互。对于 UI 按钮，使用 **AudioPlayerSFX** 组件，并将 **Play()** 方法连接到 **Inspector**
    中的按钮的 **On Click()** 事件。
- en: Now that we have created an audio player component with our refactored approach,
    the remainder will follow the same setup, so we’ll just bang the rest of these
    out.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用重构方法创建了一个音频播放器组件，其余部分将遵循相同的设置，所以我们只需完成剩下的部分。
- en: Playing SFX 3D
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩转 SFX 3D
- en: Unlike with the `AudioPlayerSFX` component, where we did not add an `AudioSource`
    component to the GameObject for playing the 2D sound, we will add one here because
    we want a “speaker in 3D space” to emanate the sound. The player, via the `AudioListener`
    component on the `Player` object, will hear the sound as you naturally would in
    a real-world environment – whichever “ear” is turned toward the source of the
    sound will hear it. Hearing sounds in 3D space further builds on the player’s
    immersion in your game world, so we definitely want to take advantage of 3D audio!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `AudioPlayerSFX` 组件不同，我们没有为播放2D声音的 GameObject 添加 `AudioSource` 组件，这里我们将添加一个，因为我们想要一个“3D空间中的扬声器”来发出声音。玩家将通过
    `Player` 对象上的 `AudioListener` 组件听到声音，就像在现实世界中自然听到的那样——无论哪个“耳朵”朝向声音源，都会听到。在3D空间中听声音进一步增强了玩家对游戏世界的沉浸感，所以我们肯定想利用3D音频！
- en: Noting the preceding information concerning `AudioSource`, we’ll ensure the
    developer/designer adding a “play 3D sound effect” component to an object configures
    an audio source for this sound by requiring the `AudioSource` component to be
    added as a sibling.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到关于 `AudioSource` 的先前信息，我们将确保添加“播放3D音效”组件到对象的开发者/设计师配置了用于此声音的音频源，通过要求添加 `AudioSource`
    组件作为兄弟组件。
- en: 'Now, create a new script named `AudioPlayerSFX3D` in the `Assets/Scripts/Audio`
    folder, and start with the following code for the audio source requirements:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `Assets/Scripts/Audio` 文件夹中创建一个名为 `AudioPlayerSFX3D` 的新脚本，并从以下音频源要求代码开始：
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is what we did here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这里所做的工作：
- en: '`[RequireComponent]`: By decorating the class with this attribute, we require
    that a sibling component exist on this GameObject. Specifically, we need an `AudioSource`
    component because this will be a 3D sound.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[RequireComponent]`：通过将此属性装饰到类上，我们要求在此 GameObject 上存在一个兄弟组件。具体来说，我们需要一个 `AudioSource`
    组件，因为这将是一个3D声音。'
- en: '`OnValidate()`: We can use this Unity message event to pre-assign the `_audioSource`
    variable with the `AudioSource` instance added by the `RequireComponent` attribute.
    `OnValidate()` only runs in the Editor and is called when the script is loaded
    or a value changes in the **Inspector**.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnValidate()`：我们可以使用这个 Unity 消息事件来预先分配 `_audioSource` 变量，该变量由 `RequireComponent`
    属性添加的 `AudioSource` 实例。`OnValidate()` 只在编辑器中运行，当脚本被加载或值发生变化时在 **Inspector** 中调用。'
- en: '`IPlaySound`: Don’t forget to add the interface! We’re required to implement
    the interface for all our audio player components.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPlaySound`：别忘了添加接口！我们需要为所有音频播放器组件实现接口。'
- en: Additional reading | Unity documentation
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'You can read more about **OnValidate()** here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnValidate.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnValidate.xhtml)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 **OnValidate()** 的信息：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnValidate.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnValidate.xhtml)
- en: Let’s continue by borrowing from the `AudioPlayerSFX` class; we’ll also have
    `_audioClip` and `_volume` serialized private member variables. To those, we’ll
    add an additional field for assigning the 2D to 3D sound ratio with a `_blend2Dto3D`
    variable (which we’ll use to assign to the `AudioSource.spatialBlend` property).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续借鉴 `AudioPlayerSFX` 类；我们还将有 `_audioClip` 和 `_volume` 序列化的私有成员变量。对于这些，我们将添加一个额外的字段来分配2D到3D声音比率的
    `_blend2Dto3D` 变量（我们将用它来分配给 `AudioSource.spatialBlend` 属性）。
- en: 'So, add the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，添加以下代码：
- en: '[PRE12]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Play()` method here is only slightly different from the previous `AudioPlayerSFX`
    implementation of `Play()` in that we’re now passing the audio source reference
    to `AudioManager`. As a reminder, we need to do this because we want to assign
    playback to the correct Audio Mixer group before playing the sound.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `Play()` 方法与之前 `AudioPlayerSFX` 实现的 `Play()` 方法略有不同，我们现在将音频源引用传递给 `AudioManager`。提醒一下，我们需要这样做，因为我们想在播放声音之前将播放分配给正确的音频混音组。
- en: 'Speaking of playing the sound, now, implement the `IPlaySound` interface public
    properties and methods:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 说到播放声音，现在，实现 `IPlaySound` 接口的公共属性和方法：
- en: '[PRE13]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ve set `PlayAudioType` to play the sound using the SFX mixer group while
    the `PlaySound()` method remains largely the same – except we’re setting the `source.spatialBlend`
    value before using `PlayOneShot()` to play the audio clip at the transform position
    of this object (in 3D space) and at the set volume level.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `PlayAudioType` 设置为使用 SFX 混音组播放声音，而 `PlaySound()` 方法保持基本不变——除了我们在使用 `PlayOneShot()`
    播放音频剪辑之前，设置了 `source.spatialBlend` 的值，以在对象的变换位置（在 3D 空间）和设定的音量级别播放音频。
- en: PlayClipAtPoint() | Unity documentation
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: PlayClipAtPoint() | Unity 文档
- en: Those of you familiar with the Unity scripting API may wonder why I didn’t just
    use the **AudioSource.PlayClipAtPoint(_audioClip, transform.position, _volume)**
    static method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 Unity 脚本 API 的你来说，可能会 wonder 为什么我没有直接使用 **AudioSource.PlayClipAtPoint(_audioClip,
    transform.position, _volume)** 静态方法。
- en: Well, the reason falls back to the primary goal of implementing the **AudioManager**
    class the way we did – and that is to ensure the Audio Mixer groups are being
    utilized for all the distinct audio player components. While **PlayClipAtPoint()**
    does play an audio clip at a position in 3D world space, it does not work with
    the Audio Mixer, which ruled it out as an option.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，原因归结于实现 **AudioManager** 类的主要目标——那就是确保音频混音组被用于所有不同的音频播放组件。虽然 **PlayClipAtPoint()**
    方法确实可以在 3D 世界空间中的某个位置播放音频剪辑，但它不与音频混音器协同工作，因此排除了这个选项。
- en: 'You can read more about **AudioSource.PlayClipAtPoint()** here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayClipAtPoint.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayClipAtPoint.xhtml)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 **AudioSource.PlayClipAtPoint()** 的信息：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayClipAtPoint.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayClipAtPoint.xhtml)
- en: '`AudioPlayerSFX3D.Play()` now calls `AudioManager.Instance.PlayAudio()` with
    the added `_audioSource` parameter. The passed-in audio source is modified in
    `AudioManager` and passed back to the interface implemented `PlaySound()` method
    to use the audio player component’s specific functionality to play the sound.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioPlayerSFX3D.Play()` 现在调用 `AudioManager.Instance.PlayAudio()` 并添加 `_audioSource`
    参数。传入的音频源在 `AudioManager` 中被修改，并传递回实现 `PlaySound()` 方法的接口，以使用音频播放组件的特定功能来播放声音。'
- en: Note on code architecture
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码架构的说明
- en: The relationship between **AudioManager** and the **AudioPlayerSFX3D** class
    may seem cyclical since we’ve implemented playing the sound with the interface
    and not within **AudioManager**. This is an okay trade-off in the architecture
    for me here because I’ve prioritized composition, ease of use, and eliminating
    errors for **Inspector** assignments in Unity. Doing things in Unity sometimes
    means developing novel approaches and compromises to otherwise “standard approaches”
    to C# OOP software development. I came to terms with that long ago. :)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用接口而不是在 **AudioManager** 中实现播放声音，因此 **AudioManager** 和 **AudioPlayerSFX3D**
    类之间的关系可能看起来是循环的。在这里，我认为这种架构上的权衡是可以接受的，因为我优先考虑了组合、易用性和消除 Unity 中 **Inspector**
    分配的错误。在 Unity 中做事有时意味着开发新颖的方法和妥协，以适应其他“标准方法”的 C# OOP 软件开发。我早就接受了这一点。 :)
- en: We’ll now follow through with the new 3D audio player component by looking at
    an implementation again.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过再次查看实现来跟进新的 3D 音频播放组件。
- en: Implementing AudioPlaySFX3D – Animation event
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 AudioPlaySFX3D – 动画事件
- en: Much like how we revisited an object we previously created for playing SFX (the
    health pickup), we’ll do the same here and add a 3D SFX to the door-opening animation
    we created in [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187). The following
    figure shows the sliding door Prefab – we’ll add the 3D sound effect when it slides
    open.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们回顾了之前创建用于播放 SFX 的对象（健康恢复）一样，我们在这里也会做同样的事情，并将 3D SFX 添加到我们在 [*第 10 章*](B18347_10.xhtml#_idTextAnchor187)
    中创建的开门动画中。以下图显示了滑动门 Prefab——我们将在它滑动打开时添加 3D 声效。
- en: '![Figure 12.8 – Sliding door 3D SFX](img/B18347_12_08.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 滑动门 3D 特效](img/B18347_12_08.jpg)'
- en: Figure 12.8 – Sliding door 3D SFX
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 滑动门 3D 特效
- en: Because the door does not have a component with an exposed `UnityEvent` being
    invoked, as with the health pickup, we have to trigger the sound playing differently.
    We’ll still use an event, but this event is one we’ll add to the door-opening
    animation directly.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于门没有具有公开 `UnityEvent` 的组件被调用，就像健康恢复一样，我们必须以不同的方式触发声音播放。我们仍然会使用一个事件，但这个事件是我们将直接添加到开门动画中的。
- en: 'Follow these steps to add the 3D SFX to the sliding door animation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将 3D SFX 添加到滑动门动画中：
- en: Open the `Door_Triggered` Prefab for editing.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Door_Triggered` Prefab 进行编辑。
- en: Add the `AudioPlayerSFX3D` component to the same object as the `Animator` component.
    As seen in *Figure 12**.8*, it’s added just below the `Animator` component on
    the `Sliding_Door_01` child object.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AudioPlayerSFX3D** 组件添加到与 **Animator** 组件相同的对象上。如图 *12**.8 所示，它被添加在 `Sliding_Door_01`
    子对象上的 `Animator` 组件下方。
- en: Now, while `Sliding_Door_01` is still selected in the **Hierarchy** window,
    open the **Animation** window by going to **Window** | **Animation** | **Animation**
    (or press *Ctrl*/*Cmd* + *6*).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **Hierarchy** 窗口中仍然选择 `Sliding_Door_01`，通过转到 **Window** | **Animation**
    | **Animation**（或按 *Ctrl*/*Cmd* + *6*）打开 **Animation** 窗口。
- en: Using the following **Animation** window figure as a reference, scrub the timeline
    a frame or two ahead, then click the **Add Event** button. This will add an **Animation
    Event** check mark to the timeline and select it (it will be blue when selected
    and white when not).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 **Animation** 窗口图作为参考，将时间轴向前滚动一帧或两帧，然后点击 **Add Event** 按钮。这将向时间轴添加一个 **Animation
    Event** 复选标记并选择它（当选中时为蓝色，未选中时为白色）。
- en: '![Figure 12.9 – Adding an animation event](img/B18347_12_09.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – 添加动画事件](img/B18347_12_09.jpg)'
- en: Figure 12.9 – Adding an animation event
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 添加动画事件
- en: When **Animation Event** is selected, the **Inspector** window will show a **Function**
    drop-down menu so that we can choose a method to invoke for the event.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择 **Animation Event** 时，**Inspector** 窗口将显示一个 **Function** 下拉菜单，以便我们可以选择用于事件的调用方法。
- en: Select **AudioPlayerSFX3D** | **Methods** | **Play()** in the **Function** drop-down.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Function** 下拉菜单中选择 **AudioPlayerSFX3D** | **Methods** | **Play()**。
- en: Animation event | Unity documentation
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 动画事件 | Unity 文档
- en: The **AudioPlaySFX3D** component must be on the same object as the **Animator**
    component to select **Play()** in the **Function** drop-down from the **Animation**
    timeline.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**AudioPlaySFX3D** 组件必须与 **Animator** 组件位于同一对象上，才能在 **Animation** 时间轴的 **Function**
    下拉菜单中选择 **Play()**。'
- en: 'Additional reading | *Using Animation Events*: [https://docs.unity3d.com/2022.3/Documentation/Manual/script-AnimationWindowEvent.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/script-AnimationWindowEvent.xhtml)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '额外阅读 | *使用动画事件*: [https://docs.unity3d.com/2022.3/Documentation/Manual/script-AnimationWindowEvent.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/script-AnimationWindowEvent.xhtml)'
- en: Save the Prefab (or apply overrides) because we’re done wiring up the sliding
    door for playing the 3D SFX!
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 Prefab（或应用覆盖），因为我们已经完成了滑动门播放 3D SFX 的接线！
- en: Hold on a second, don’t jump the gun and start entering Play Mode to test it
    out just yet… we still need to assign the sound the door will play when sliding
    open!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，不要急于跳过并开始进入 Play 模式来测试它……我们还需要分配门滑动打开时将播放的声音！
- en: Assigning the audio clip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配音频剪辑
- en: 'I was somehow tempted to grab the sound of the *Star Trek: The Next Generation*
    Enterprise NCC-1701-D’s sliding door opening sound, but yeah, copyright laws and
    all. ;)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知为何想要抓取 *《星际迷航：下一代》* 企业号 NCC-1701-D 的滑动门开启声音，但好吧，版权法和其他一切。 ;)
- en: 'Not to worry, Freesound is to the rescue again! The sound file we’ll be using
    for our sliding doors is `cua-ien-tu-mo.wav` (in Vietnamese, *của điện tử mở*
    or “open electronics”), which you can download here: https://freesound.org/people/SieuAmThanh/sounds/511540/.
    It is also licensed CC0.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不必担心，Freesound 再次伸出援手！我们将用于滑动门的音频文件是 `cua-ien-tu-mo.wav`（在越南语中，*của điện tử
    mở* 或“打开电子”），您可以从这里下载：https://freesound.org/people/SieuAmThanh/sounds/511540/。它也获得了
    CC0 许可。
- en: Ensure the `cua-ien-tu-mo.wav` file is imported to the `Assets/Audio/SFX` folder
    and go back to the `AudioPlayerSFX3D` component by opening the `Door_Triggered`
    Prefab again. Click and drag the `cua-ien-tu-mo` file to the **Audio Clip** field,
    then click **Save**.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `cua-ien-tu-mo.wav` 文件已导入到 `Assets/Audio/SFX` 文件夹，然后通过再次打开 `Door_Triggered`
    Prefab 返回到 `AudioPlayerSFX3D` 组件。点击并拖动 `cua-ien-tu-mo` 文件到 **Audio Clip** 字段，然后点击
    **Save**。
- en: Playtest the level, adjust the `AudioPlayerSFX3D` component as needed, and take
    notice of the 3D sound playback.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 测试关卡，根据需要调整 **AudioPlayerSFX3D** 组件，并注意 3D 声音播放。
- en: 3D Sound Settings | Unity documentation
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 3D Sound Settings | Unity 文档
- en: Use the **3D Sound Settings** section of the **AudioSource** component to adjust
    the sound as desired for the spatial effect you’re looking for. The parameters
    in this section are applied proportionally to the **Spatial** **Blend** parameter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **AudioSource** 组件的 **3D Sound Settings** 部分来调整声音，以实现所需的空間效果。本节中的参数按比例应用于
    **Spatial** **Blend** 参数。
- en: 'You can learn more about audio source properties here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于音频源属性的信息：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml)。
- en: The next audio player component we’ll tackle is also for 3D sound – in the next
    section, let’s make an audio player for ambient sounds.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的下一个音频播放器组件也是用于3D声音——在下一节中，让我们制作一个用于环境声音的音频播放器。
- en: Playing ambient sound
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放环境声音
- en: Adding ambient 3D sounds to a game’s environment is essential for defining the
    setting, bringing it to life, and enhancing the player’s sensory experience. While
    adding ambient sound to our environment, let’s keep in mind that it’s crucial
    to match the sounds to the setting, layer different sound elements to create the
    soundscape, and change or vary the sound – interactively or not.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏环境中添加环境3D声音对于定义场景、使其生动起来以及增强玩家的感官体验至关重要。在向我们的环境中添加环境声音时，让我们记住，匹配声音与场景至关重要，分层不同的声音元素以创建声音景观，并改变或变化声音——无论是交互式还是非交互式。
- en: We first need our ambient audio player component to get started adding ambient
    sounds to our level. Because ambient sound is 3D in nature, we’ll again take the
    same approach as our 3D SFX and rely on an audio source added to our object to
    produce its sound.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要我们的环境音频播放器组件来开始向我们的级别添加环境声音。因为环境声音本质上是3D的，所以我们再次采取与我们的3D SFX相同的方法，并依赖于添加到我们的对象中的音频源来产生其声音。
- en: We’ll use `Play()` on the `AudioSource` component directly this time because
    other methods, such as `PlayOneShot()`, cannot trigger looping sounds. However,
    there are some limitations to using `AudioSource.Play()`. It only allows one audio
    clip to be played simultaneously with an audio source. Calling `Play()` on an
    audio source that is already playing will stop the audio source and start the
    clip again. But we only care about the ability to loop the audio for playing ambient
    sounds in the environment so these limitations are not an issue here.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次将直接在`AudioSource`组件上使用`Play()`方法，因为其他方法，如`PlayOneShot()`，无法触发循环声音。然而，使用`AudioSource.Play()`也有一些限制。它只允许一个音频剪辑与音频源同时播放。在已经播放的音频源上调用`Play()`将停止音频源并重新开始剪辑。但我们对在环境中播放环境声音的循环播放能力更感兴趣，所以这些限制在这里不是问题。
- en: 'Let’s take care of setting up the `AudioSource` component right away. Create
    a new script named `AudioPlayerAmbient` in the `Assets/Scripts/Audio` folder and
    add the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即处理设置`AudioSource`组件。在`Assets/Scripts/Audio`文件夹中创建一个新的脚本名为`AudioPlayerAmbient`，并添加以下代码：
- en: '[PRE14]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we’ll need the **Inspector** field to assign the audio clip for the ambient
    sound to play on this object and the required play methods. Add the following
    code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要**检查器**字段来分配音频剪辑，以便在这个对象上播放环境声音以及所需的播放方法。添加以下代码：
- en: '[PRE15]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The specifics related to the methods added to play ambient sounds are as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加环境声音相关的方法的具体细节如下：
- en: '`Start()`: Ambient sounds always play! (That’s a rule I just came up with.)
    So, we’ll start playing the ambient sound when the level begins. Note that because
    this is a 3D sound and configured with its specific audio source attached to the
    3D object in the environment, the player will only hear it when they are within
    range.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start()`：环境声音总是播放！（这是我刚刚制定的一条规则。）因此，当级别开始时，我们将开始播放环境声音。请注意，因为这是一个3D声音，并且配置了特定的音频源附加到环境中的3D对象，所以玩家只有在范围内才能听到它。'
- en: '`Play()`: Similar to what we did before, we’re calling the audio manager `PlayAudio()`
    method and passing in the ambient sound’s `AudioSource` component to modify it
    and assign the correct Audio Mixer group for playback.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Play()`：与之前所做类似，我们调用音频管理器的`PlayAudio()`方法，并传入环境声音的`AudioSource`组件来修改它，并分配正确的音频混音组进行播放。'
- en: 'Again, implement the `IPlaySound` interface’s public properties and methods
    so the audio manager knows which Audio Mixer group to use:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，实现`IPlaySound`接口的公共属性和方法，以便音频管理器知道使用哪个音频混音组：
- en: '[PRE16]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is an ambient sound, so we must set `PlayAudioType` to `Ambient` and then
    play the audio clip indefinitely for this audio player component’s specific `PlaySound()`
    method functionality, like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个环境声音，因此我们必须将`PlayAudioType`设置为`Ambient`，然后无限期地播放音频剪辑，以便为这个音频播放器组件的特定`PlaySound()`方法功能，如下所示：
- en: Set `source.clip` to the `_audioClip` value (set in the **Inspector**).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`source.clip`设置为`_audioClip`值（在**检查器**中设置）。
- en: Set `spatialBlend = 1f` much like how we enforced music to play in 2D (`0f`)
    within the `AudioPlayerMusic` component. Here, we’ll enforce the audio to play
    as a fully 3D sound.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `spatialBlend` 设置为 `1f`，就像我们在 `AudioPlayerMusic` 组件中强制音乐在 2D 中播放（`0f`）一样。在这里，我们将强制音频以完全
    3D 声音播放。
- en: Set `source.loop` to `true`. This is because ambient sounds continuously loop
    indefinitely!
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `source.loop` 设置为 `true`。这是因为环境声音会无限循环！
- en: Play the sound using `source.Play()` because we cannot use `PlayOneShot()` for
    a looping sound.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `source.Play()` 播放声音，因为我们不能为循环声音使用 `PlayOneShot()`。
- en: Okay, these various audio-playing components have really come together! In the
    next section, let’s continue providing example implementations for each with an
    ambient sound.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这些各种音频播放组件真的已经整合在一起了！在下一节中，我们将继续为每个组件提供示例实现，包括环境声音。
- en: Implementing PlayAmbientSound
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 PlayAmbientSound
- en: First things first, we need to identify something in our environment to use
    as an example ambient sound implementation. Let’s look at the models provided
    by Polypix Studios for an answer… I see we have a 3D model Prefab asset imported
    to the `Assets/Polypix 3D Assets/Prefabs` folder called **Ventilation 1**.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的环境中识别一些内容，用作示例环境声音实现的例子。让我们看看 Polypix 工作室提供的模型以获得答案……我看到我们有一个名为 **通风
    1** 的 3D 模型预制件资产被导入到 `Assets/Polypix 3D Assets/Prefabs` 文件夹中。
- en: Let’s use this as a ventilation shaft inlet somewhere on our level. These types
    of things generally have something running – making noise – that pulls and circulates
    the air. A perfect environmental audio addition!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的场景中某个位置使用这个作为通风管道入口。这类事物通常会有一些东西在运行——制造噪音——这会拉动并循环空气。这是一个完美的环境音频添加！
- en: Art assets
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术资源
- en: 'The art assets used in this section are available from the GitHub project files
    repo. The **Ventilation 1** Prefab, in particular, is available from the **Art-Assets**
    folder included in the **3DArtwork.zip** file (or from the Unity project files
    directly): [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中使用的艺术资源可以从 GitHub 项目文件仓库获取。特别是，**通风 1** 预制件可以从包含在 **3DArtwork.zip** 文件中的
    **Art-Assets** 文件夹（或直接从 Unity 项目文件中）获取：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets)。
- en: Add the `Ventilation 1` Prefab from the `Assets/Polypix 3D Assets/Prefabs` folder
    to the level somewhere – by dragging it in from the **Project** window – to give
    a lovely ambiance to one of the habitation station’s rooms. In *Figure 12**.10*,
    I’ve added it to a rather sparse-looking room that needs some interest.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Assets/Polypix 3D Assets/Prefabs` 文件夹中的 **通风 1** 预制件拖放到场景中的某个位置，以给居住站的一个房间增添一些氛围。在
    *图 12*.10 中，我已经将它添加到一个看起来相当空旷的房间中，需要一些趣味性。
- en: '![Figure 12.10 – Ventilation ambient sound](img/B18347_12_10.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 通风环境声音](img/B18347_12_10.jpg)'
- en: Figure 12.10 – Ventilation ambient sound
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 通风环境声音
- en: With the ventilation shaft inlet added to the scene, let’s add the ambient 3D
    sound audio player component.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中添加通风管道入口后，让我们添加环境 3D 声音音频播放器组件。
- en: Open the `Ventilation 1` Prefab in Prefab Edit Mode.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预制件编辑模式下打开 `Ventilation 1` 预制件。
- en: Use your preferred method to add the `AudioPlayerAmbient` component to the root
    object.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的方法将 `AudioPlayerAmbient` 组件添加到根对象。
- en: An `AudioSource` component will automatically be added when we add the audio
    player component (due to the `RequireComponent` attribute).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们添加音频播放器组件时，会自动添加 `AudioSource` 组件（由于 `RequireComponent` 属性）。
- en: Unlike the previous audio player components, where we provided fields for `AudioSource`
    component to tailor the sound to the proper environmental audio effect for its
    location.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前提供的音频播放器组件不同，我们为 `AudioSource` 组件提供了字段，以根据其位置的环境音频效果调整声音。
- en: Before we continue configuring the audio source, it would help to have a sound
    to play so we can make the proper adjustments.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续配置音频源之前，有一个可以播放的声音会很有帮助，这样我们就可以做出适当的调整。
- en: The sound file we’ll use for our ventilation shaft inlet is `metro-subway-hallway-corner-noise-heavy-ventilation-rumble.flac`
    (no, I didn’t name it!). It comes from Freesound ([https://freesound.org/people/kyles/sounds/455811/](https://freesound.org/people/kyles/sounds/455811/))
    and is licensed CC0 (still free to use).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于通风管道入口的声音文件是 `metro-subway-hallway-corner-noise-heavy-ventilation-rumble.flac`（不，我没有命名它！）它来自
    Freesound ([https://freesound.org/people/kyles/sounds/455811/](https://freesound.org/people/kyles/sounds/455811/))，并授权
    CC0（仍然可以免费使用）。
- en: Ensure the `metro-subway-hallway-corner-noise-heavy-ventilation-rumble.flac`
    file is imported to the `Assets/Audio/Ambient` folder. We’ll make a few changes
    to the import settings values for this sound file.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`metro-subway-hallway-corner-noise-heavy-ventilation-rumble.flac`文件导入到`Assets/Audio/Ambient`文件夹。我们将为此声音文件调整一些导入设置值。
- en: 'Referring back to *Figure 12**.4* for an import settings reference, set the
    following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图12.4的导入设置，设置以下内容：
- en: '**Force To Mono** = true, **Normalize** = true: Disregard the L/R stereo channels
    of the sound file (combine them) and set the audio levels to a normalized value.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制单声道** = true，**归一化** = true：忽略声音文件的L/R立体声通道（将它们合并）并将音频级别设置为归一化值。'
- en: '**Load In Background** = true: Loads the larger-sized audio file without causing
    the main thread to lag. Sound will start playing once the file is loaded (which
    may not be at the start of the scene being loaded).'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在后台加载** = true：加载较大的音频文件而不会导致主线程延迟。一旦文件加载（可能不在加载的场景开始时），声音就会开始播放。'
- en: '**Load Type** = **Streaming**: Decode audio with minimal memory use from disk
    and using a separate CPU thread.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载类型** = **流式传输**：从磁盘以最小内存使用量解码音频，并使用单独的CPU线程。'
- en: '`30`: Balance playback quality and file size by adjusting the compression slider
    for a compressed clip. Keep the file small for distribution while maintaining
    playback quality.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`30`：通过调整压缩滑块来平衡播放质量和文件大小，以压缩剪辑。为了分发而保持文件小，同时保持播放质量。'
- en: Return to the `AudioPlayerAmbient` component on the ventilation shaft inlet,
    then click and drag the `metro-subway-hallway-corner-noise-heavy-ventilation-rumble`
    file to the `Ventilation 1` Prefab (by clicking **Save** in Prefab Edit Mode,
    or at the top of the **Inspector**, click **Apply All** in the **Prefab** | **Overrides**
    dropdown).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 返回通风管道入口处的`AudioPlayerAmbient`组件，然后点击并拖动`metro-subway-hallway-corner-noise-heavy-ventilation-rumble`文件到`Ventilation
    1`预制件（在预制件编辑模式中点击**保存**，或在**检查器**顶部，在**预制件** | **覆盖**下拉菜单中点击**应用所有**）。
- en: Before we playtest the level with the ambient sound playing, let’s review the
    3D sound settings that affect how ambient sound can be heard in the environment.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们播放带有环境声音的关卡测试之前，让我们回顾一下影响环境声音在环境中听到的3D声音设置。
- en: 3D ambient sound settings
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3D环境声音设置
- en: It’s time to put our sound designer hat on! When we added the audio player component
    to the ventilation shaft inlet Prefab, I mentioned we’d tailor the sound directly
    using the audio source properties.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候戴上我们的声音设计师帽子了！当我们向通风管道入口预制件添加音频播放组件时，我提到我们将直接使用音频源属性来调整声音。
- en: Referring to the `270` to influence how the sound is distributed in 3D space.
    Lower values create more directional sound (heard only in front of the source),
    whereas higher values produce more omnidirectional sound (can be heard from wider
    angles). A value of `360` would make it seem like the sound is coming from everywhere
    around the listener.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图12.4中的`270`来影响声音在3D空间中的分布。较低的值创建更多方向性声音（仅在源前方听到），而较高的值产生更多全向声音（可以从更宽的角度听到）。`360`的值会使声音似乎从听众周围的所有方向传来。
- en: Tip | Open the Properties window
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 | 打开属性窗口
- en: In the **Inspector**, right-clicking on the **AudioSource** component title,
    then clicking **Properties…** will open it in a floating **Properties** window.
    You can do this for objects, components, and file assets from most windows in
    the Unity Editor.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**中，右键单击**AudioSource**组件标题，然后单击**属性…**将在浮动**属性**窗口中打开它。您可以在Unity编辑器的大多数窗口中为此执行对象、组件和文件资产。
- en: Playtest the level, adjust the **Spread** value of the audio source as desired,
    and take notice of the ambient sound’s playback.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 播放测试关卡，根据需要调整音频源的**扩散**值，并注意环境声音的播放。
- en: In this section, we learned how to create components to play audio for different
    auditory experiences and implement them on objects in our environment. In the
    next section, we’ll add to immersion in the environment by adding footstep sounds
    to the player.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建组件以播放不同的听觉体验，并将它们应用于我们环境中的对象。在下一节中，我们将通过为玩家添加脚步声来增强环境的沉浸感。
- en: Enhancing the audio experience with footsteps and reverb zones
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过脚步声和混响区域增强音频体验
- en: Creating an immersive and enjoyable gaming experience requires paying close
    attention to sound design. Even seemingly simple elements, such as footstep sounds,
    play a significant role in grounding characters in their environment and conveying
    a sense of physicality and presence.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个沉浸式和令人愉悦的游戏体验需要密切关注音效设计。即使是看似简单的元素，如脚步音效，也在将角色定位在环境中以及传达一种物理感和存在感方面发挥着重要作用。
- en: With footsteps in particular, it’s crucial to have a variety of footstep sounds
    to randomize them and adjust tempo or cadence based on the player’s speed to prevent
    auditory fatigue and repetition (you could even take it so far as to have different
    sounds for each surface type the player walks on).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在脚步声中，拥有多种脚步音效以随机化它们，并根据玩家的速度调整节奏或拍子，以防止听觉疲劳和重复（你甚至可以进一步到为玩家行走的每种表面类型提供不同的声音）。
- en: Optimizing how continuously randomized audio clips are played back is also essential
    to ensure the process doesn’t negatively impact the game’s performance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 优化连续随机播放的音效剪辑也是确保这个过程不会对游戏性能产生负面影响的关键。
- en: With our footstep sounds implementation, we will address all these factors.
    Considering the audio player components and manager code we’ve already written,
    the implementation is more straightforward than you may think.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的脚步音效实现，我们将解决所有这些因素。考虑到我们已经编写的音频播放器组件和管理器代码，实现起来比你想象的要简单。
- en: Reusing audio player code
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复使用音频播放器代码
- en: Nothing could be simpler than starting with one of our existing audio player
    components to play the footstep sounds! So, we’ll rely on `AudioPlayerSFX` for
    the footsteps and not create footstep sounds with a new direct implementation
    of the `IPlaySound` interface. I mean, we could, but we’d just be duplicating
    the functionality that `AudioPlayerSFX` already provides. For those of you keeping
    track, the cards in play here are code reuse, **don’t repeat yourself** (**DRY**),
    **keep it simple, silly** (**KISS**), and let’s also claim the single responsibility
    card.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比从我们现有的音频播放器组件开始播放脚步音效更简单了！所以，我们将依赖`AudioPlayerSFX`来处理脚步音效，而不是通过新的`IPlaySound`接口的直接实现来创建脚步音效。我的意思是，我们可以这样做，但那只会重复`AudioPlayerSFX`已经提供的功能。对于那些跟踪的人来说，这里的牌是代码重用、**不要重复自己**（**DRY**）、**保持简单，傻瓜**（**KISS**），我们还可以声称单责任牌。
- en: This time, instead of requiring a built-in component provided by the Unity game
    engine, we’ll require our own `AudioPlayerSFX` component to be added to the GameObject
    that we’re adding a new play footstep sounds component to.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不会要求使用Unity游戏引擎提供的内置组件，而是要求将我们自己的`AudioPlayerSFX`组件添加到我们添加新播放脚步音效组件的GameObject中。
- en: 'Let’s see this implementation by creating a new `AudioPlayerFootsteps` script
    in the `Assets/Scripts/Audio` folder with the following initial code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`Assets/Scripts/Audio`文件夹中创建一个新的`AudioPlayerFootsteps`脚本来查看这个实现，以下是其初始代码：
- en: '[PRE17]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember, the `RequireComponent` attribute forces a composition pattern by combining
    components to implement the desired functionality. So, as mentioned previously,
    we’ve required the `AudioPlayerSFX` component and pre-assigned the reference to
    the `_playerSFX` variable in the `OnValidate()` method.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`RequireComponent`属性通过组合组件来强制执行组合模式，以实现所需的功能。因此，正如之前提到的，我们已经要求了`AudioPlayerSFX`组件，并在`OnValidate()`方法中预先分配了`_playerSFX`变量的引用。
- en: 'We also declare these variables:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了以下变量：
- en: '`_walkInterval`: This variable value should match the cadence, or speed, of
    the player walking – in other words, the time between the footstep sound playing'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_walkInterval`：这个变量的值应该与玩家的步伐或速度相匹配——换句话说，就是脚步音效播放之间的时间'
- en: '`_timerStep`: This variable will hold the current interval for footstep sounds
    to play (spoiler alert: we’ll have different values assigned based on whether
    the player is walking or sprinting)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_timerStep`：这个变量将保存播放脚步音效的当前间隔（剧透：我们将根据玩家是行走还是冲刺来分配不同的值）'
- en: 'Okay, we have the base boilerplate code in place. Let’s add our footstep audio
    clips list variable and an update loop to play a random footstep sound from the
    list at the assigned time interval:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经有了基本的模板代码。现在让我们添加我们的脚步音效剪辑列表变量和一个更新循环，以便在指定的时间间隔内从列表中播放一个随机的脚步音效：
- en: '[PRE18]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here, we’ve done precisely what’s needed:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正好做了需要做的事情：
- en: '`_footstepSounds`: Here, we have our `AudioClip[]` array of footstep sound
    file assets that will be randomly selected and played at the set time interval.
    Refer to *Figure 12**.11* for a sneak peek at this **Inspector** assignment.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_footstepSounds`：在这里，我们有我们的脚步声文件资源`AudioClip[]`数组，这些声音将在设定的时间间隔内随机选择并播放。参考*图12**.11*查看此**检查器**分配的预览。'
- en: '`Update()`: The update loop will keep our `_timeStep` variable current with
    its new time. Then, we’ll evaluate to see whether `_timeStep` has expired to play
    the following randomly selected clip. We finish up by resetting `_timeStep` to
    delay the next play at intervals.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()`：更新循环将保持我们的`_timeStep`变量与新的时间同步。然后，我们将评估`_timeStep`是否已过期以播放下一个随机选择的剪辑。最后，我们将重置`_timeStep`以在间隔中延迟下一次播放。'
- en: 'Looking good! Optionally, we can do a bit better for code readability, and
    that would be with a quick refactor extracting the code that gets a random footstep
    sound into a local function, like so:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！可选地，我们可以通过快速重构将获取随机脚步声的代码提取到本地函数中，如下所示：
- en: '[PRE19]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The line of code for playing the SFX would now look like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 播放SFX的代码行现在看起来是这样的：
- en: '[PRE20]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s, again, a quick, optional refactor that doesn’t change the functionality.
    Still, one that makes for better code readability – and anything that helps code
    readability is worth the little bit of extra work for clarity (for someone else
    looking at your code or yourself in six months), and if it requires a bit more,
    add a code comment!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个快速的可选重构，它不会改变功能。然而，它使代码可读性更好——任何有助于代码可读性的东西都值得花一点额外的工作来提高清晰度（无论是别人查看你的代码还是六个月后的你自己），如果需要更多，可以添加代码注释！
- en: Complete code for the audio player components
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 音频播放组件的完整代码
- en: 'Don’t forget, at any time, if you need to see the completed code for these
    sections, you can find it at the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，在任何时候，如果你需要查看这些部分的完成代码，你可以在GitHub仓库中找到它：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio)
- en: The `AudioPlayerFootsteps` component doesn’t play sound itself. As we know,
    it uses `PlaySoundSFX.Play()` and passes an audio clip as the parameter. The only
    problem is that `Play()` doesn’t currently accept a parameter! Let’s fix that
    now by adding a method overload.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioPlayerFootsteps`组件本身不播放声音。正如我们所知，它使用`PlaySoundSFX.Play()`并将音频剪辑作为参数传递。唯一的问题是`Play()`目前不接受参数！现在让我们通过添加方法重载来修复这个问题。'
- en: Adding a method overload to AudioPlayerSFX
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为AudioPlayerSFX添加方法重载
- en: So, now, we’ll overload the `Play()` method in `AudioPlayerSFX` to add the required
    `AudioClip` parameter for the current audio clip for the footstep we want to play
    (well, that was randomly selected for us to play).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们将重载`AudioPlayerSFX`中的`Play()`方法，为当前要播放的脚步声添加所需的`AudioClip`参数（好吧，那是我们随机选择来播放的）。
- en: 'In `AudioPlayerSFX`, add the following method with its code:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AudioPlayerSFX`中添加以下方法和其代码：
- en: '[PRE21]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We already have a `Play()` method without a parameter, so we’re overloading
    the `Play()` method now by declaring another with the same method name but with
    a different method signature (because we’ve added the `AudioClip` parameter).
    Now, when `Play()` is called, the one that matches the method signature will be
    the specific method executed – either with the passed-in audio clip or without.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了不带参数的`Play()`方法，所以现在我们通过声明另一个具有相同方法名但不同方法签名的`Play()`方法来重载`Play()`方法（因为我们已经添加了`AudioClip`参数）。现在，当调用`Play()`时，匹配方法签名的将是执行的具体方法——要么是带有传入的音频剪辑，要么不带。
- en: Tip
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Avoid frequent clip changes: It’s important to remember that repeatedly changing
    an **AudioSource** clip can be less efficient than using multiple audio sources
    or the **AudioSource.PlayOneShot()** method. In such cases, it’s recommended to
    use the **PlayOneShot()** method, as it allows you to play a clip without changing
    the audio source’s main clip.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 避免频繁更改剪辑：重要的是要记住，反复更改**AudioSource**剪辑可能不如使用多个音频源或**AudioSource.PlayOneShot()**方法高效。在这种情况下，建议使用**PlayOneShot()**方法，因为它允许你播放剪辑而不更改音频源的主要剪辑。
- en: We can now move on to adding the footstep sounds to our player character in
    the next section.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到下一节，为我们的玩家角色添加脚步声。
- en: Implementing AudioPlayerFootsteps
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现AudioPlayerFootsteps
- en: Okay, this will be our fifth implementation of an audio player component, so
    there’s no reason to delay. Let’s go right ahead and add to `PlayerCapsule`. Since
    we’ll be requiring some of the other components already on the `PlayerCapsule`
    object in the next section (such as `CharacterController` and `PlayerInput`),
    we’ll want to add `AudioPlayerFootsteps` right to the root of this object.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这将是我们第五次实现音频播放组件，所以没有必要拖延。让我们直接添加到 `PlayerCapsule`。由于在下一节中我们将需要 `PlayerCapsule`
    对象上的一些其他组件（例如 `CharacterController` 和 `PlayerInput`），我们希望将 `AudioPlayerFootsteps`
    直接添加到该对象的根目录。
- en: Now that we’ve added `AudioPlayerFootsteps`, you should have seen `AudioPLayerSFX`
    added, thanks to the `RequireComponent` attribute, so that takes care of the ability
    to play sound through the SFX Audio Mixer channel. All that’s left to do to get
    something playing is to add the sound files to the `_footstepSounds` array in
    the **Inspector**.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了 `AudioPlayerFootsteps`，你应该已经看到了由于 `RequireComponent` 属性的添加，`AudioPLayerSFX`
    也被添加了，这样就可以通过 SFX 音频混音器通道播放声音。剩下要做的就是将声音文件添加到 **检查器** 中的 `_footstepSounds` 数组。
- en: The sound files we’ll use this time come from the Unity Asset Store. We’ll use
    `Classic Footstep SFX (Free)` by Matthew Anett ([https://assetstore.unity.com/packages/audio/sound-fx/classic-footstep-sfx-173668](https://assetstore.unity.com/packages/audio/sound-fx/classic-footstep-sfx-173668)).
    From its name, you can see that we can use it freely in our projects. Yay!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次使用的声音文件来自 Unity 资产商店。我们将使用 Matthew Anett 的 `Classic Footstep SFX (Free)`
    ([https://assetstore.unity.com/packages/audio/sound-fx/classic-footstep-sfx-173668](https://assetstore.unity.com/packages/audio/sound-fx/classic-footstep-sfx-173668))。从其名称中，你可以看出我们可以在我们的项目中自由使用它。太好了！
- en: Ensure the `Classic Footstep SFX (Free)` package is imported to your project.
    By default, this will be the `Assets/Classic Footstep SFX` folder. Unlike with
    the other audio files, since this is a package, the import settings are already
    set for us by the author, so we’re all set to start using them.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `Classic Footstep SFX (Free)` 软件包导入到你的项目中。默认情况下，这将是在 `Assets/Classic Footstep
    SFX` 文件夹。与其他音频文件不同，由于这是一个软件包，导入设置已经由作者设置好了，所以我们已经准备好开始使用它们。
- en: 'Follow these steps to assign the provided footstep sound files to the `AudioPlayerFootsteps`
    component’s `_footstepSounds` array field:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将提供的脚步声文件分配给 `AudioPlayerFootsteps` 组件的 `_footstepSounds` 数组字段：
- en: Return to the `AudioPlayerFootsteps` component on `PlayerCapsule` and lock the
    **Inspector** window (using the little *lock* icon at the top-right of the **Inspector**
    tab). By locking the window, no matter what we select, the **Inspector** will
    stay on this window, which is essential for selecting multiple objects in the
    **Project** window to be assigned to a component field.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `PlayerCapsule` 上的 `AudioPlayerFootsteps` 组件，并锁定 **检查器** 窗口（使用 **检查器** 标签右上角的那个小
    *锁* 图标）。通过锁定窗口，无论我们选择什么，**检查器** 都将保持在当前窗口，这对于在 **项目** 窗口中选择多个对象以分配给组件字段是至关重要的。
- en: With the `Assets/Classic Footstep SFX/Floor` folder in the **Project** window.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 窗口中的 `Assets/Classic Footstep SFX/Floor` 文件夹。
- en: While within the `Floor_step0`), then hold *Shift* and click on the last sound
    file, or any range of files to select them.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Floor_step0` 内时，然后按住 *Shift* 键并点击最后一个声音文件，或者选择任何文件范围。
- en: With the sound files selected, click and drag (from anywhere in the selection)
    to the **Footstep Sounds** field label, and you’ll see the mouse cursor change
    from an arrow to an arrow with a box and a plus sign. Releasing the mouse button
    while hovering over the field name will populate the array with all the sound
    files in the selection.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择声音文件后，点击并拖动（从选择中的任何位置）到 **脚步声** 字段标签，你会看到鼠标光标从箭头变为带有框和加号的箭头。在悬停于字段名称上释放鼠标按钮，将填充数组中的所有选择的声音文件。
- en: You can unlock the **Inspector** window now and check the assignment of the
    sound files by expanding the array (with the arrow to the left of the **Footstep
    Sounds** field label) as seen in *Figure 12**.11*. Note that I’ve only shown five
    assigned for brevity in the figure.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以解锁 **检查器** 窗口，通过展开数组（在 **脚步声** 字段标签左侧的箭头）来检查声音文件的分配，如图 *图 12*.11* 所示。请注意，为了简洁起见，我在图中只展示了五个分配的例子。
- en: '![Figure 12.11 – AudioPlayerFootsteps component assignments](img/B18347_12_11.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – AudioPlayerFootsteps 组件分配](img/B18347_12_11.jpg)'
- en: Figure 12.11 – AudioPlayerFootsteps component assignments
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – AudioPlayerFootsteps 组件分配
- en: If you try to use the `AudioPlayerFootsteps` code as it sits now, you’re going
    to be hearing footsteps all the darn time because there are no conditional statements
    to tell us when we should not play footsteps! That just won’t do, so let’s modify
    `AudioPlayerFootsteps` with a conditional check.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用现在的 `AudioPlayerFootsteps` 代码，你将一直听到脚步声，因为没有条件语句告诉我们何时不应该播放脚步声！这样是不行的，所以让我们通过条件检查来修改
    `AudioPlayerFootsteps`。
- en: 'First, we need a reference to the player character controller… so add a new
    field to `AudioPlayerFootsteps` to hold the reference (you’ll have to set the
    reference in the **Inspector** for this field manually, so don’t forget to – you
    inevitably will fail, I know I do):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个对玩家角色控制器的引用……因此，在 `AudioPlayerFootsteps` 中添加一个新的字段来保存这个引用（你将不得不手动在
    **Inspector** 中设置这个字段的引用，所以别忘了——我知道我肯定会忘记）：
- en: '[PRE22]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now evaluate “Is the player grounded or moving?” by adding the following
    `if` statement:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过添加以下 `if` 语句来评估“玩家是否在地面上或正在移动？”：
- en: '[PRE23]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using `return`, we short-circuit the `Update()` method so it doesn’t continue
    and, therefore, doesn’t play any footstep sounds. Groovy.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `return`，我们短路 `Update()` 方法，使其不会继续执行，因此不会播放任何脚步声。太棒了。
- en: At this stage, playtesting will give us our footstep sounds only while walking.
    However, we can also have the player sprint by holding the *Shift* key while moving
    forward. The problem we currently face is that the interval for the footstep sounds
    is consistent, resulting in sprinting sounding identical to walking. We can quickly
    solve this problem by adding a condition for a second interval, specifically for
    sprinting.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，测试游戏将只在行走时给我们脚步声。然而，我们也可以让玩家在向前移动时按住 *Shift* 键来冲刺。我们目前面临的问题是脚步声的间隔是一致的，导致冲刺听起来和行走一样。我们可以通过添加一个条件来快速解决这个问题，特别是为冲刺添加第二个间隔。
- en: Implementing sprinting
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现冲刺
- en: Okay, that setup made it sound like this would be difficult. It is not. It’s
    barely inconvenient because we’ll tap directly into the **Player** **Input** functionality.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个设置听起来好像会很困难。其实并不难。这几乎只是不方便，因为我们将直接访问 **Player** **Input** 功能。
- en: When we provide input – by pressing keys or using a gamepad – the Input System
    processes those keys through the **Player Input** component, which, in turn, sends
    out message events. So, all we have to do is add a method handler (i.e., listener)
    for the one sent when the player wants to start sprinting. In *Figure 12**.12*,
    that’s **OnSprint**, and we can see it listed right on the **Player Input** component
    in the box just under **Behavior**.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提供输入——通过按键或使用游戏手柄——输入系统会通过 **Player Input** 组件处理这些键，该组件反过来会发送消息事件。所以，我们只需要添加一个方法处理程序（即监听器）来处理当玩家想要开始冲刺时发送的那个。在
    *图 12**.12 中，那是 **OnSprint**，我们可以看到它在 **Player Input** 组件的 **Behavior** 下方的小框中列出。
- en: '![Figure 12.12 – Player Input SendMessage() to GameObject list](img/B18347_12_12.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 向 GameObject 列表发送 Player Input SendMessage()](img/B18347_12_12.jpg)'
- en: Figure 12.12 – Player Input SendMessage() to GameObject list
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 向 GameObject 列表发送 Player Input SendMessage()
- en: 'Adding the ability to respond to the player sprinting is now just a matter
    of updating the `AudioPlayerFootsteps` class with the required code. Add the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对玩家冲刺的响应能力现在只是更新 `AudioPlayerFootsteps` 类所需的代码。添加以下内容：
- en: '[PRE24]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We add a new variable to assign the time interval for sprinting in the `_sprintInterval`
    and a related Boolean variable to evaluate whether the player is currently sprinting
    or not, with `_isSprinting`. Then, `OnSprint()` will set `_isSprinting` to `true`
    or `false` depending on `value.isPressed` passed in from the Input System.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `_sprintInterval` 中添加一个新的变量来分配冲刺的时间间隔，并添加一个相关的布尔变量来评估玩家是否正在冲刺，即 `_isSprinting`。然后，`OnSprint()`
    将根据从输入系统传入的 `value.isPressed` 将 `_isSprinting` 设置为 `true` 或 `false`。
- en: 'All we need to do now is assign the proper step interval to the `_currentStepInterval`
    variable that will be used along with the `_timerStep` variable for playing footsteps
    at the correct time interval. Do so by making the following changes to the `Update()`
    method:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的只是将适当的步进间隔分配给 `_currentStepInterval` 变量，该变量将与 `_timerStep` 变量一起用于在正确的时间间隔播放脚步声。通过修改
    `Update()` 方法来实现这一点：
- en: '[PRE25]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And that wraps up footstep sounds! Playtesting now should produce footsteps
    matching the player while walking or sprinting. This is precisely the attention
    to detail that sets your games apart from the field – players notice and appreciate
    an indie developer’s efforts with things like this.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了脚步声的设置！现在进行测试应该会产生与玩家行走或冲刺时匹配的脚步声。这正是将您的游戏与其他游戏区分开来的细致入微之处——玩家会注意到并欣赏独立开发者在这类事情上的努力。
- en: One additional attention to immersive sound details in your level that you can
    quickly add to the production value of your game soundscape is reverb zones, and
    the next section will show the simple steps to add one.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的关卡中，您可以通过快速添加混响区域来增加沉浸式声音细节，从而提高游戏声音景观的制作价值，下一节将展示添加混响区域的简单步骤。
- en: Adding reverb zones
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加混响区域
- en: Reverb zones simulate the acoustics of sound in different spaces, whether echoing
    in a large warehouse or dampening in a small storage room, adding depth to the
    soundscape and enhancing the game’s atmosphere as the player moves between different
    areas in a level.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 混响区域模拟不同空间中声音的声学特性，无论是大仓库中的回声还是小储藏室中的衰减，都能为声音景观增添深度，并在玩家在关卡的不同区域移动时增强游戏氛围。
- en: Additionally, simulating the acoustic properties can assist in storytelling
    and subtly guide player emotions and expectations, which is just another tool
    game designers can use to build more immersive and believable gaming experiences.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模拟声学特性可以帮助叙事并微妙地引导玩家的情绪和期望，这是游戏设计师可以利用的另一个工具，以构建更沉浸和逼真的游戏体验。
- en: 'Find some key areas in your level where you feel the acoustics would be affected
    by the scale of the space. Using *Figure 12**.13*, we’ll use the following example
    to add a reverb zone to one of the larger rooms of the level:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的关卡中找到一些关键区域，您觉得声学特性会受到空间规模的影响。使用*图12*.13，我们将以下示例添加到关卡中较大的房间之一：
- en: Add an empty GameObject to the scene and position it in the center of a large
    room.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个空的游戏对象并将其放置在大房间中央。
- en: Rename the GameObject `Reverb Zone` (optionally, parent it to an object to organize
    all zones in the **Hierarchy**).
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象重命名为`混响区域`（可选，将其作为父对象以组织**层次结构**中的所有区域）。
- en: Add an `AudioReverbZone` component to the `Reverb` `Zone` object.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`AudioReverbZone`组件添加到`混响``区域`对象中。
- en: Additional reading | Unity documentation
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的阅读 | Unity文档
- en: 'You can read more about reverb zones here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioReverbZone.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioReverbZone.xhtml)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于混响区域的信息：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioReverbZone.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioReverbZone.xhtml)
- en: Choose an appropriate **ReverbPreset** option. Or, select **User** and customize
    the property sliders underneath to your desired effect. In the following figure,
    you can see I chose the **Hangar** preset.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个合适的**混响预设**选项。或者，选择**用户**并自定义下方的属性滑块以达到您想要的效果。在下面的图中，你可以看到我选择了**机库**预设。
- en: '![Figure 12.13 – Reverb zone placement and settings](img/B18347_12_13.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 – 混响区域放置和设置](img/B18347_12_13.jpg)'
- en: Figure 12.13 – Reverb zone placement and settings
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 混响区域放置和设置
- en: And that’s all that’s required to add the reverb zone to our level – playtest
    and adjust the zone properties to your liking. However, we’ll want to ensure that
    the music playback isn’t affected by the reverb zone (that wouldn’t make sense
    for the music to be affected by the environmental changes, would it?).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是添加混响区域到我们关卡所需的所有内容——进行测试并调整区域属性以符合您的喜好。然而，我们希望确保音乐播放不受混响区域的影响（音乐受到环境变化的影响似乎并不合理，对吧？）。
- en: We can do this very easily in our code – we *have to* because we don’t have
    a resident `AudioSource` sitting on a GameObject in our scene for playing music;
    we’re adding it via code.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码中非常容易地做到这一点——我们必须这样做，因为我们场景中没有驻留的`AudioSource`位于游戏对象上以播放音乐；我们是通过代码添加的。
- en: 'So, in our `AudioManager` script, in the `PlayMusic()` method, simply add this
    line to the list of audio source music settings we assign:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的`AudioManager`脚本中，在`PlayMusic()`方法中，只需将此行添加到我们分配给音频源音乐设置的列表中即可：
- en: '[PRE26]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That’s it! Our music playback will no longer be affected by the reverb zone,
    while the remainder of the playing sounds, especially the footstep sounds, will
    be.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们的音乐播放将不再受混响区域的影响，而剩余的播放声音，尤其是脚步声，将会受到影响。
- en: This brings us to the end of adding audio to our game. In this section, we learned
    how to create varying audio playback components that route through an audio manager
    class to establish the rules for how sound is played with this system.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了为游戏添加音频的结束。在本节中，我们学习了如何创建不同的音频播放组件，这些组件通过音频管理类路由，以建立如何使用此系统播放声音的规则。
- en: We now have an audio toolset at our disposal to handle most use cases for the
    different types of audio playback a game requires. You can now revisit the earlier
    projects in the book to add your own sound design and level up the gameplay experience
    for the player. Have fun while wearing your sound designer hat!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个音频工具集，可以处理游戏所需的多种类型的音频播放用例。你现在可以回顾书中早些时候的项目，添加你自己的声音设计，并提升玩家的游戏体验。戴着你的声音设计师帽子，享受乐趣吧！
- en: Next, we’ll have a quick look at how we can refactor our audio player components
    to better adhere to the SOLID principles.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将快速查看我们如何重构我们的音频播放组件，以更好地遵循SOLID原则。
- en: Deeper SOLID refactoring
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更深入的SOLID重构
- en: We can take the OCP of the SOLID principles further by using an abstract base
    class that all audio player classes derive from. This can add further required
    implementations and default behavior and would then be a classic **object-oriented
    programming** (**OOP**) inheritance example.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用所有音频播放类都从中派生的抽象基类来进一步扩展SOLID原则中的OCP（开闭原则）。这可以添加更多必需的实现和默认行为，然后将成为一个经典的**面向对象编程**（**OOP**）继承示例。
- en: OOP SOLID principles reminder
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: OOP SOLID原则提醒
- en: In OOP, the derived class inherits all base class members and can also add its
    members. However, it’s essential to keep the *Liskov substitution* principle of
    the SOLID principles in mind when using derived classes. The *L* principle states
    that objects of a base class should be replaceable with objects of a derived class
    without changing the correctness of the program. In simpler terms, any program
    that uses a base class reference should be able to use any derived classes without
    knowing it. For OOP, this is polymorphism, which allows us to write more general
    code that works with any audio-playing class.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中，派生类继承所有基类成员，也可以添加自己的成员。然而，在使用派生类时，必须牢记SOLID原则中的*Liskov替换*原则。L原则指出，基类的对象应该可以用派生类的对象替换，而不会改变程序的正确性。用简单的话说，任何使用基类引用的程序都应该能够使用任何派生类，而无需知道它。对于OOP，这是多态，它允许我们编写更通用的代码，该代码可以与任何音频播放类一起工作。
- en: 'Let’s take a look at how we might write an abstract base class that the audio-playing
    classes in our project could inherit from:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何编写一个抽象基类，我们的项目中的音频播放类可以从中继承：
- en: '[PRE27]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is what we did:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们所做的事情：
- en: '`_audioClip`: The field is marked protected, which means inherited classes
    can access it. Makes things pretty easy, eh?'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_audioClip`: 该字段被标记为受保护的，这意味着继承类可以访问它。这使得事情变得相当简单，对吧？'
- en: '`abstract PlayAudioType` (property): This abstract property ensures that each
    derived class will define its own `AudioType` value. This is a good use of an
    abstract property because it enforces each audio-playing class to specify its
    own `AudioType` value.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract PlayAudioType`（属性）：这个抽象属性确保每个派生类都将定义自己的`AudioType`值。这是一个很好的使用抽象属性的方式，因为它强制每个音频播放类指定自己的`AudioType`值。'
- en: '`PlaySound()`: The method provides a default implementation for playing a sound
    that all inheriting classes can share. Because we included the `virtual` keyword
    in the method signature, if a derived class needs a different behavior, it can
    override this method. We must also define `PlaySound()` – and `PlayAudioType`
    – because we must implement the `IPlaySound` interface!'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlaySound()`: 该方法为播放声音提供了一个默认实现，所有继承类都可以共享。因为我们包括了方法签名中的`virtual`关键字，如果派生类需要不同的行为，它可以覆盖此方法。我们还必须定义`PlaySound()`和`PlayAudioType`，因为我们必须实现`IPlaySound`接口！'
- en: '`Play()`: The method provides a way to play the specified `AudioClip`. Here,
    we’re delegating the play functionality to the `AudioManager` instance, adhering
    to our pattern and assigning the `AudioMixerGroup` group accordingly for the `AudioType`
    value. Note it’s also `virtual`, so it can be overridden by inheriting classes
    if a different behavior is needed.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Play()`: 该方法提供了一种播放指定`AudioClip`的方式。在这里，我们将播放功能委托给`AudioManager`实例，遵循我们的模式，并根据`AudioType`值分配相应的`AudioMixerGroup`组。注意它也是`virtual`的，因此如果需要不同的行为，继承类可以覆盖它。'
- en: The `AudioPlayerBase` abstract base class provides a good foundation for creating
    specific audio-playing classes – as many different kinds as needed. We’ve enforced
    a consistent interface for our classes to provide default implementations for
    behavior while allowing for customization by the inheriting classes. Yay!
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioPlayerBase`抽象基类为创建特定音频播放类提供了一个良好的基础——需要多少种就创建多少种。我们为我们的类强制执行了一致的接口，以提供行为默认实现，同时允许继承类进行定制。太棒了！'
- en: Now that you’ve seen how we can approach an abstract base class that all our
    audio-playing classes can derive from, go ahead and try the refactor yourself!
    The project code on the GitHub link for the chapter has already provided an example
    of a refactored `AudioPlayerSFX3D_Derived` component that inherits from the `AudioPlayerBase`
    abstract base class, so you can use that as a reference (give it an honest try,
    no peeking).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了我们如何处理所有音频播放类都可以从中派生的抽象基类，那么就自己动手尝试重构吧！GitHub链接上的项目代码已经提供了一个重构后的`AudioPlayerSFX3D_Derived`组件示例，该组件继承自`AudioPlayerBase`抽象基类，你可以将其作为参考（诚实地尝试，不要偷看）。
- en: AudioPlayerBase completed code
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: AudioPlayerBase 完整代码
- en: 'To view the completed code for the **AudioPlayerBase** class and an example
    of an inherited class, visit the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`AudioPlayerBase`类的完整代码和一个继承类示例，请访问以下GitHub仓库：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio)
- en: In this section, we learned how to refactor our code to be more aligned with
    the SOLID programming principles. While our code is pretty complete already (I’m
    sure someone could always think of more types of audio player components to extend),
    this refactor makes it even easier to extend upon the code to add additional audio
    player component types without having to modify the manager class.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何重构我们的代码以更符合SOLID编程原则。虽然我们的代码已经相当完整了（我相信总有人会想到更多类型的音频播放器组件来扩展），但这次重构使得在无需修改管理器类的情况下扩展代码以添加额外的音频播放器组件类型变得更加容易。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this “audio chapter,” we extensively covered adding audio to our game by
    introducing an audio manager and individual reusable audio player components.
    We used the audio manager as a fool-proof implementation for designers and developers
    alike to target the appropriate mixer group for setting playback levels for the
    game’s soundscape.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个“音频章节”中，我们详细介绍了通过引入音频管理器和可重用的音频播放器组件来为我们的游戏添加音频。我们使用音频管理器作为对设计师和开发者都适用的错误预防实现，以便为目标游戏声音场景设置播放级别选择合适的混音组。
- en: We continued by coding individual audio components for sound playback of the
    different types of audio common in most games – music, SFX, and ambient sound.
    We created these reusable audio player components following SOLID programming
    principles so we can extend additional types of audio components without modifying
    the manager class. We finished with a footsteps sound example showing how we can
    compose components for a simple implementation and also quickly add an environmental
    audio effect with reverb zones.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续编写单个音频组件，用于播放大多数游戏中常见的不同类型音频——音乐、音效（SFX）和环境声音。我们遵循SOLID编程原则创建了这些可重用的音频播放器组件，这样我们就可以在不修改管理器类的情况下扩展额外的音频组件类型。我们以脚步声示例结束，展示了如何为简单实现组合组件，以及如何快速添加带有混响区域的环保音频效果。
- en: In the next chapter, we’ll continue to flesh out the game by adding an intelligent
    non-player character (NPC). We’ll accomplish this by, again, refactoring our previous
    2D code for 3D usage as well as introducing cutting-edge technology for dynamic
    enemies utilizing sensors, a behavior tree, and machine learning (AI) techniques.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续完善游戏，通过添加一个智能非玩家角色（NPC）来实现。我们将通过再次重构我们之前的2D代码以适应3D使用，以及引入利用传感器、行为树和机器学习（AI）技术的尖端技术来动态生成敌人。
