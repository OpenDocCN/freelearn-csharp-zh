- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Background Functions in Practice
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的后台函数
- en: When you start working with cloud computing, especially while working with **Platform
    as a Service** (**PaaS**), one of the challenges you may encounter is how to enable
    background work if your solution is based on instances that require a request
    before processing. One of the answers to this problem is the use of serverless
    to process this background job. In Azure, you will find Azure Functions triggers
    that can help you with this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用云计算时，尤其是在使用**平台即服务**（**PaaS**）时，你可能会遇到的一个挑战是如何在基于需要请求处理实例的解决方案中启用后台工作。解决这个问题的一个答案就是使用无服务器来处理这个后台任务。在Azure中，你会发现Azure
    Functions触发器可以帮助你完成这项工作。
- en: 'In this chapter, we will discuss three of them: the timer trigger, Blob storage
    trigger, and queue storage trigger. It is important to mention that we covered
    their basics in [*Chapter 1*](Chapter_1.xhtml#_idTextAnchor022)*, Demystifying
    Serverless Applications*, but we will start to implement them now.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论其中三个：定时触发器、Blob存储触发器和队列存储触发器。重要的是要提到，我们在[*第1章*](Chapter_1.xhtml#_idTextAnchor022)*，揭秘无服务器应用程序*中介绍了它们的基础知识，但现在我们将开始实施它们。
- en: Together with their implementation, we will present an alternative to the publication
    of Azure Functions inside Visual Studio. We will also check how to monitor these
    functions. Understanding the advantages and disadvantages and when these functions
    are a good approach to be used will be discussed in the chapter. We will also
    see them working using the car-sharing example as a basis for understanding the
    purpose of each trigger better. Let’s go!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍Azure Functions在Visual Studio内部发布的替代方案，同时也会检查如何监控这些函数。在章节中，我们将讨论这些函数的优点和缺点，以及何时使用这些函数是一个好的方法。我们还将使用拼车示例来展示它们的工作情况，以便更好地理解每个触发器的目的。让我们开始吧！
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the Visual Studio 2022 free *Community edition* or Visual
    Studio Code. You will also need an Azure account to create the sample environment.
    You can find the sample code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要Visual Studio 2022免费**社区版**或Visual Studio Code。你还需要一个Azure账户来创建示例环境。你可以在这个章节的[https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp)找到示例代码。
- en: Timer trigger
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时触发器
- en: 'It is not uncommon to need to process a task from time to time, at a specific
    moment of the day. A timer trigger will certainly help you with this. This function
    is based on the `NCRONTAB` expression, which is like a `CRON` expression:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要不时地在一天中的特定时刻处理一个任务，这是很常见的。定时触发器肯定会帮助你完成这项工作。这个函数基于`NCRONTAB`表达式，类似于`CRON`表达式：
- en: '`{second} {minute} {hour} {day} {month} {day-of-week}`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`{second} {minute} {hour} {day} {month} {day-of-week}`'
- en: 'If you consider this expression, you will be able to schedule different moments
    to trigger the function. Let’s check the following table to understand it better:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑这个表达式，你将能够安排不同的时刻来触发函数。让我们查看以下表格以更好地理解它：
- en: '| **Second** | **Minute** | **Hour** | **Day** | **Month** | **Day of the Week**
    | **Result** | **Meaning** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **秒** | **分** | **时** | **日** | **月** | **星期** | **结果** | **含义** |'
- en: '| * | * | * | * | * | * | * * * * * * | Every second |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| * | * | * | * | * | * | * * * * * * | 每秒 |'
- en: '| 0 | * | * | * | * | * | 0 * * * * * | Every minute |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 0 | * | * | * | * | * | 0 * * * * * | 每分钟 |'
- en: '| */5 | * | * | * | * | * | */5 * * * * * | Every five seconds |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| */5 | * | * | * | * | * | */5 * * * * * | 每五秒 |'
- en: '| 0 | 0 | 1 | * | * | 1-5 | 0 0 1 * * 1-5 | At 1:00 AM, from Monday to Friday
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | * | * | 1-5 | 0 0 1 * * 1-5 | 在周一至周五的凌晨1点 |'
- en: '| 5,10,20 | * | * | * | * | * | 5,10,20 * * * * * | At 5, 10, and 20 seconds
    past the minute |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 5,10,20 | * | * | * | * | * | 5,10,20 * * * * * | 在每分钟的5、10和20秒 |'
- en: There are some important tips related to the `NCRONTAB` expression. First, you
    may consider days of the week from Sunday (`0`) to Saturday (`6`). The `*` operator
    represents all values at the moment defined, while `-` is the range operator.
    If you want to express an interval, you may use the `/` operator, and if you want
    to define a set of values, the `,` operator must be used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与`NCRONTAB`表达式相关的一些重要提示。首先，你可以考虑从星期日（`0`）到星期六（`6`）的星期几。`*`运算符代表在当前定义的所有值，而`-`是范围运算符。如果你想表示一个间隔，你可以使用`/`运算符，而如果你想定义一组值，则必须使用`,`运算符。
- en: 'The following code is an example of a timer trigger and the way you define
    its schedule:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个定时器触发示例以及定义其计划的方式：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are some websites where you can interpret the `NCRONTAB` expression you
    have designed. You can check this out at https://crontab.cronhub.io/.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些网站可以帮助你解释你设计的`NCRONTAB`表达式。你可以在 https://crontab.cronhub.io/ 上查看。
- en: The following figure shows the result of the preceding timer trigger code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面定时器触发代码的结果。
- en: '![Figure 5.1: Timer trigger function in execution](img/B31916_05_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：执行中的定时器触发功能](img/B31916_05_01.png)'
- en: 'Figure 5.1: Timer trigger function in execution'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：执行中的定时器触发功能
- en: This flexibility enables you to define a solid structure of jobs to run your
    microservices. On the other hand, if you want to debug a specific function, you
    may use the `RunOnStartup` parameter set to `true`. It is important to mention,
    though, that this parameter must not be used in production
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性使你能够定义一个稳固的工作结构来运行你的微服务。另一方面，如果你想调试特定的函数，你可以使用设置为`true`的`RunOnStartup`参数。不过，重要的是要提到，这个参数在生产环境中不应使用。
- en: 'There is a possibility to manually trigger non-HTTP functions. Please check
    this link to do so: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-manually-run-non-http](https://learn.microsoft.com/en-us/azure/azure-functions/functions-manually-run-non-http).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能手动触发非 HTTP 函数。请查看此链接以进行操作：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-manually-run-non-http](https://learn.microsoft.com/en-us/azure/azure-functions/functions-manually-run-non-http)。
- en: Now you understand how timer trigger functions work, let’s check a way you can
    publish them using Visual Studio.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了定时器触发功能的工作原理，让我们看看如何使用 Visual Studio 发布它们。
- en: Publishing your functions
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布你的函数
- en: As you are developing your Azure functions in Visual Studio, it is useful to
    know that the IDE enables you to publish your code to Azure in small steps. Let’s
    check how to do so.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Visual Studio 中开发 Azure 函数时，了解 IDE 允许你分步骤将代码发布到 Azure 是有用的。让我们看看如何做到这一点。
- en: The first step is to right-click the project you want to publish. As soon as
    you do this, you will find the **Publish…** action to start the process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是右键单击你想要发布的项目。一旦这样做，你将找到**发布…**操作来启动此过程。
- en: '![Figure 5.2: Publishing an Azure function project](img/B31916_05_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：发布 Azure 函数项目](img/B31916_05_02.png)'
- en: 'Figure 5.2: Publishing an Azure function project'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：发布 Azure 函数项目
- en: Once you decide to publish, you will be prompted to decide where to publish
    the function. Besides Azure, you might want to publish the function in a Docker
    container registry or a folder. You may also want to use a pre-made profile, so
    there is also an option to import the profile. For this demo, the **Azure** option
    will be selected.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定发布，你将需要决定将函数发布到何处。除了 Azure，你可能还希望将函数发布到 Docker 容器注册库或文件夹中。你可能还希望使用预制的配置文件，因此还有一个选项可以导入配置文件。对于这个演示，将选择**Azure**选项。
- en: '![Figure 5.3: Publishing on Azure](img/B31916_05_03.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：在 Azure 上发布](img/B31916_05_03.png)'
- en: 'Figure 5.3: Publishing on Azure'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：在 Azure 上发布
- en: After the selection of **Azure**, you need to decide where in Azure you will
    have your function running. As we saw in [*Chapter 1*](Chapter_1.xhtml#_idTextAnchor022)*,
    Demystifying Serverless Applications*, Azure functions can run in different operating
    systems and different container solutions. For this demo, we will select the Windows
    operating system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择**Azure**之后，你需要决定你的函数将在 Azure 的哪个位置运行。正如我们在[*第 1 章*](Chapter_1.xhtml#_idTextAnchor022)*，揭秘无服务器应用程序*中看到的，Azure
    函数可以在不同的操作系统和不同的容器解决方案中运行。对于这个演示，我们将选择 Windows 操作系统。
- en: '![Figure 5.4: Selecting Azure Function App for Windows](img/B31916_05_04.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：选择 Windows 的 Azure 函数应用](img/B31916_05_04.png)'
- en: 'Figure 5.4: Selecting Azure Function App for Windows'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：选择 Windows 的 Azure 函数应用
- en: After connecting Visual Studio to your Azure account, all the function instances
    available for deployment will be presented to you. However, if you don’t have
    any instances, you will also be given the opportunity to create a new instance,
    by selecting the **Create new** button.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Visual Studio 连接到你的 Azure 账户后，所有可用于部署的函数实例都将呈现在你面前。然而，如果你没有任何实例，你也将有机会通过选择**创建新实例**按钮来创建一个新的实例。
- en: '![Figure 5.5: Creating the Azure Function App on the Visual Studio interface](img/B31916_05_05.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：在 Visual Studio 界面上创建 Azure 函数应用](img/B31916_05_05.png)'
- en: 'Figure 5.5: Creating the Azure Function App on the Visual Studio interface'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：在 Visual Studio 界面上创建 Azure 函数应用
- en: The creation will take a few minutes, but then your Azure function can be published
    on Azure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建过程需要几分钟，然后您的 Azure 函数就可以在 Azure 上发布了。
- en: '![Figure 5.6: Azure Function App ready](img/B31916_05_06.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：准备就绪的 Azure Function App](img/B31916_05_06.png)'
- en: 'Figure 5.6: Azure Function App ready'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：准备就绪的 Azure Function App
- en: The current wizard available in Visual Studio is very useful. It not only helps
    you publish in a single step but also creates a YML file for you, to be used together
    with GitHub Actions. For this demo, we will use the basic option that generates
    a `.pubxml` file, but you may consider GitHub Actions as the best opportunity
    for real-life scenarios.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 中当前可用的向导非常有用。它不仅可以帮助您一步完成发布，还会为您创建一个 YML 文件，以便与 GitHub Actions
    一起使用。对于这个演示，我们将使用生成 `.pubxml` 文件的基本选项，但您可以考虑 GitHub Actions 作为现实场景中的最佳选择。
- en: '![Figure 5.7: Methods available for publishing](img/B31916_05_07.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：可用的发布方法](img/B31916_05_07.png)'
- en: 'Figure 5.7: Methods available for publishing'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：可用的发布方法
- en: Once you finish the wizard, you will have the publishing profile ready to start
    publishing the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成向导，您将拥有准备就绪的发布配置文件，可以开始发布应用程序。
- en: '![Figure 5.8: Publishing profiler](img/B31916_05_08.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：发布分析器](img/B31916_05_08.png)'
- en: 'Figure 5.8: Publishing profiler'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：发布分析器
- en: By clicking the **Publish** button, the process will start running and, after
    a few moments, your Azure Function App will be published.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 **发布** 按钮，过程将开始运行，几分钟后，您的 Azure Function App 将被发布。
- en: '![Figure 5.9: Function App published](img/B31916_05_09.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：已发布的 Function App](img/B31916_05_09.png)'
- en: 'Figure 5.9: Function App published'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：Function App 已发布
- en: It is important to mention that you will need to do this complete process only
    once. After that, the new deployments needed will be a lot easier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，您只需要完成这个完整过程一次。之后，所需的新部署将会容易得多。
- en: Monitoring your functions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控您的函数
- en: The process for deploying functions presented in the last section is not exclusive
    to timer trigger functions. The same happens when it comes to monitoring your
    functions. In Azure, there are some alternative ways to check whether your Azure
    function is running properly. Let’s explore them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上节中介绍的部署函数的过程不仅限于定时器触发函数。在监控您的函数时也是如此。在 Azure 中，有一些其他方法可以检查您的 Azure 函数是否正常运行。让我们来探索一下。
- en: The easiest way to monitor whether a function is running properly is by checking
    the number of invocations made by it. The **Invocations** tab is available in
    the Function App, and it will give you basic details about the execution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 监控函数是否正常运行的最简单方法是通过检查其调用的次数。**调用次数**选项卡在 Function App 中可用，它将为您提供关于执行的基本详细信息。
- en: '![Figure 5.10: Function invocations](img/B31916_05_10.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：函数调用](img/B31916_05_10.png)'
- en: 'Figure 5.10: Function invocations'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：函数调用
- en: However, you may want to obtain detailed information about each execution. In
    this case, the best option to get this kind of information is by accessing the
    logs retained by Azure Monitor.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能希望获取每个执行的详细信息。在这种情况下，获取此类信息的最佳选项是通过访问 Azure Monitor 保留的日志。
- en: '![Figure 5.11: Azure Monitor logs](img/B31916_05_11.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11：Azure Monitor 日志](img/B31916_05_11.png)'
- en: 'Figure 5.11: Azure Monitor logs'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：Azure Monitor 日志
- en: Using Azure Monitor logs will result in a cost increase. Please check the best
    alternative for storing logs at [https://docs.azure.cn/en-us/azure-monitor/logs/cost-logs](https://docs.azure.cn/en-us/azure-monitor/logs/cost-logs).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure Monitor 日志会导致成本增加。请检查在 [https://docs.azure.cn/en-us/azure-monitor/logs/cost-logs](https://docs.azure.cn/en-us/azure-monitor/logs/cost-logs)
    存储日志的最佳替代方案。
- en: The logs stored by Azure Monitor will also give you two other views. The Application
    Insights **Performance** view helps you analyze performance and errors that may
    happen in the Azure functions you develop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Monitor 存储的日志也将为您提供另外两个视图。Application Insights 的 **性能** 视图可以帮助您分析您开发的
    Azure 函数中可能发生的性能和错误。
- en: '![Figure 5.12: Application Insights Performance view](img/B31916_05_12.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12：Application Insights 性能视图](img/B31916_05_12.png)'
- en: 'Figure 5.12: Application Insights Performance view'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：Application Insights 性能视图
- en: There is also a **Live metrics** view of the function running, which may be
    useful for debugging or understanding behaviors in production.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 函数运行时还有一个 **实时指标** 视图，这可能对调试或了解生产中的行为很有用。
- en: '![Figure 5.13: Application Insights Live metrics view](img/B31916_05_13.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13：Application Insights 实时指标视图](img/B31916_05_13.png)'
- en: 'Figure 5.13: Application Insights Live metrics view'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：Application Insights 实时指标视图
- en: These options make Azure Functions an excellent alternative for processing your
    background work, as the observability provided is very good.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项使 Azure Functions 成为处理您后台工作的绝佳替代方案，因为它提供的可观察性非常好。
- en: Advantages, disadvantages, and when to use Azure timer triggers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 定时器触发的优势、劣势以及何时使用
- en: As we saw before, Azure timer triggers provide a great way to execute functions
    at regular intervals without the need for manual intervention. Their simplicity
    in setup and configuration helps you create functions that will run regularly,
    such as data synchronization, cleanup operations, and scheduled reports.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，Azure 定时器触发器提供了一种在无需人工干预的情况下定期执行函数的绝佳方式。它们在设置和配置上的简单性有助于您创建定期运行的函数，例如数据同步、清理操作和计划报告。
- en: However, since the function will run exactly when you schedule it, if there
    is no job to be done at that moment, this execution will result in resource wastage,
    which basically means spending money unnecessarily. So, you must properly define
    the execution of the timer trigger function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于函数将在您计划的时间运行，如果那时没有工作要做，这种执行将导致资源浪费，这基本上意味着不必要地花钱。因此，您必须正确定义定时器触发函数的执行。
- en: Based on the preceding information, scheduled actions that cannot depend on
    human manual intervention, such as backups, routine maintenance tasks, and periodic
    data processing, are great use cases for this kind of function. Even though it
    is important to define a way to monitor and report these executions, you can still
    make the most of this option.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的信息，不能依赖人工手动干预的预定操作，如备份、常规维护任务和定期数据处理，是这类函数的绝佳用例。尽管定义一种监控和报告这些执行的方法很重要，但您仍然可以充分利用这个选项。
- en: Car-sharing timer trigger example
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汽车共享定时器触发示例
- en: The car-sharing solution is an event-driven application. This means that there
    is no need for a timer trigger for this application when it comes to its basic
    flow of work. However, let’s imagine a routine for processing billing. Considering
    the business rules of this company, there is no way to process bills on Sundays,
    and considering the cash flow on the other days, the billing can be processed
    once an hour.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车共享解决方案是一个事件驱动型应用。这意味着在处理其基本工作流程时，不需要为该应用设置定时器触发器。然而，让我们想象一个处理账单的常规流程。考虑到这家公司的业务规则，周日无法处理账单，而考虑到其他日子现金流的情况，账单可以每小时处理一次。
- en: 'Based on this scenario, a timer trigger function can be a great choice to solve
    this problem, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个场景，定时器触发函数可以是一个很好的选择来解决这个问题，如下所示：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that no matter whether you have billing to process or not, the execution
    of the function will happen every single hour, between 8:00 AM and 5:59 PM, from
    Monday through Saturday. It is important to mention that Azure Functions will
    respect UTC time, so you should consider your location when defining the correct
    `CRON` expression to be used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论是否有账单要处理，函数的执行将在每天早上8:00至下午5:59之间，从周一到周六每小时发生一次。重要的是要提到，Azure Functions
    将尊重协调世界时（UTC），因此在定义正确的 `CRON` 表达式时，您应该考虑您的位置。
- en: Blob trigger
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blob 触发器
- en: Azure Blob Storage is a service provided by Microsoft Azure for storing large
    amounts of unstructured data, such as images, videos, logs, and backups. It is
    optimized for storing binary data in a highly scalable and cost-effective way.
    **Blob** stands for **Binary Large Object**, highlighting its ability to handle
    massive volumes of data efficiently, making it an ideal solution for applications
    that require durable, scalable storage.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Blob Storage 是由 Microsoft Azure 提供的一种服务，用于存储大量非结构化数据，如图像、视频、日志和备份。它优化了以高度可扩展和成本效益的方式存储二进制数据。**Blob**
    代表 **Binary Large Object**，突出了其高效处理大量数据的能力，使其成为需要耐用、可扩展存储的应用的理想解决方案。
- en: The great thing about this service is that it is highly scalable, secure, and
    accessible from anywhere in the world via HTTP or HTTPS. Also, it enables integration
    with other Azure services, such as Azure Functions. This connector enables a variety
    of possible solutions for automating processes since it is possible to execute
    a function for each change made in a specific blob storage.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务的优点是它具有高度的可扩展性、安全性和全球任何地方通过 HTTP 或 HTTPS 访问的便捷性。此外，它还支持与其他 Azure 服务，如 Azure
    Functions 的集成。这个连接器通过为特定 Blob 存储中每个更改执行函数，实现了各种可能的自动化流程解决方案。
- en: The focus of this book is not to go further into Blob Storage options, but it
    is useful to know that the service provides different access tiers, such as hot,
    cool, and archive, which vary according to access needs, each with its own pricing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本书重点不在于深入探讨 Blob 存储选项，但了解该服务提供不同的访问层级是有用的，例如热、冷和存档，这些层级根据访问需求而变化，每个层级都有自己的定价。
- en: When you start creating a Blob storage trigger function, one of the things that
    you will be asked to define is where the storage will run. For debugging, you
    will have the possibility to use **Storage Azurite emulator**, which is a local
    emulator for Azure Storage. Azurite is available with Visual Studio. Based on
    your edition of Vision Studio, it will be placed in a specific folder. After you
    find the executable, you may run it using Admin access.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始创建 Blob 存储触发函数时，您将被要求定义存储将运行的位置。对于调试，您将有机会使用 **Storage Azurite 模拟器**，这是一个
    Azure 存储的本地模拟器。Azurite 与 Visual Studio 一起提供。根据您的 Visual Studio 版本，它将被放置在特定的文件夹中。找到可执行文件后，您可以使用管理员权限运行它。
- en: '![Figure 5.14: Azurite execution](img/B31916_05_14.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14：Azurite 执行](img/B31916_05_14.png)'
- en: 'Figure 5.14: Azurite execution'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14：Azurite 执行
- en: Another important tool to be used while creating Blob storage trigger functions
    is Microsoft Azure Storage Explorer. With these two tools, the process of creating
    Blob storage trigger functions will be very easy. The following figure shows how
    Visual Studio enables you to select Azurite as the default emulator for your project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Blob 存储触发函数时，另一个重要的工具是 Microsoft Azure Storage Explorer。有了这两个工具，创建 Blob
    存储触发函数的过程将会非常简单。以下图示展示了 Visual Studio 如何使您能够将 Azurite 设置为项目的默认模拟器。
- en: '![Figure 5.15: Connecting a Blob storage trigger to Azure](img/B31916_05_15.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15：将 Blob 存储触发器连接到 Azure](img/B31916_05_15.png)'
- en: 'Figure 5.15: Connecting a Blob storage trigger to Azure'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：将 Blob 存储触发器连接到 Azure
- en: Advantages, disadvantages, and when to use Blob storage triggers
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blob 存储触发器的优缺点及适用场景
- en: When it comes to advantages regarding the usage of Blob storage triggers, the
    possibility of handling large volumes of data efficiently can surely be mentioned.
    Besides that, the possibility to scale the processing no matter the number of
    incoming triggers is also a good reason why you should consider this kind of trigger
    to process data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 Blob 存储触发器的使用优势时，能够高效处理大量数据的能力当然可以提及。除此之外，无论传入触发器的数量如何，都有可能进行处理的扩展性也是您应该考虑此类触发器来处理数据的好理由。
- en: On the other hand, pricing can be a problem since, in some cases, the pricing
    model is based on the number of executions and the amount of data processed, so
    do not forget to analyze the best way to allocate this kind of Azure function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，定价可能成为问题，因为在某些情况下，定价模式基于执行次数和数据处理量，所以不要忘记分析分配此类 Azure 函数的最佳方式。
- en: It is also important to mention that, depending on the app plan you have defined
    for the Azure function, you may experience some delay between the uploading or
    updating of the file and the function processing. To avoid it, you may consider
    an App Service plan with Always On enabled, although this will obviously increase
    the cost of the solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，根据您为 Azure 函数定义的应用计划，您可能会在文件上传或更新与函数处理之间经历一些延迟。为了避免这种情况，您可以考虑启用 Always
    On 的 App Service 计划，尽管这显然会增加解决方案的成本。
- en: To finish, it is important to mention that the initial Blob storage trigger
    function implementation was based on pooling. Pooling refers to a periodic scan
    of the entire container, typically processing up to 10,000 blobs per batch. In
    this approach, each file has up to five retry attempts by default. If all retries
    fail, the function creates a poison message and moves it to the `webjobs-blobtrigger-poison`
    queue. To avoid such scenarios and improve reliability, you can implement a Blob
    storage trigger using Event Grid instead. We will cover this in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要提到，最初的 Blob 存储触发函数实现是基于池化的。池化指的是对整个容器进行周期性扫描，通常每批处理高达 10,000 个 Blob。在此方法中，每个文件默认有最多五次重试尝试。如果所有重试都失败，函数将创建一个毒丸消息并将其移动到
    `webjobs-blobtrigger-poison` 队列。为了避免此类场景并提高可靠性，您可以使用 Event Grid 实现一个 Blob 存储触发器。我们将在下一节中介绍这一点。
- en: Based on this information, you can use a Blob storage trigger in applications
    where you have software requirements such as image processing, data analysis,
    and real-time or batch processing. In this kind of application, you generally
    need to react quickly and automatically to new or updated blobs. In these cases,
    the scalability and adaptability of Azure Functions will help you meet your demands.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，您可以在需要图像处理、数据分析、实时或批量处理等软件要求的应用程序中使用 Blob 存储触发器。在这种类型的应用中，通常需要快速且自动地对新或更新的
    Blob 做出反应。在这些情况下，Azure Functions 的可扩展性和适应性将帮助您满足您的需求。
- en: Blob trigger implementation using Event Grid
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件网格实现的 Blob 触发实现
- en: The idea behind using Event Grid to implement Blob trigger events is to reduce
    latency. Besides, if you decide to define your functions using the Flex Consumption
    plan, this is the only option you will have.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件网格实现 Blob 触发事件背后的想法是减少延迟。此外，如果您决定使用 Flex 消费计划来定义您的函数，这将是你唯一的选择。
- en: To do so, while creating the function, select the **Blob Trigger (using Event
    Grid)** option. With this option, Visual Studio will create a different code for
    the Azure function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，在创建函数时，选择 **Blob 触发（使用事件网格）** 选项。使用此选项，Visual Studio 将为 Azure 函数创建不同的代码。
- en: '![Figure 5.16: Creating a Blob trigger function using Event Grid](img/B31916_05_16.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16：使用事件网格创建 Blob 触发函数](img/B31916_05_16.png)'
- en: 'Figure 5.16: Creating a Blob trigger function using Event Grid'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：使用事件网格创建 Blob 触发函数
- en: It is important to mention that this function will run better on Azure than
    locally. For this, you need to create a **general-purpose v2** storage account,
    which is mandatory for the event subscription.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，此函数在 Azure 上的运行效果会比本地更好。为此，您需要创建一个 **通用 v2** 存储账户，这对于事件订阅是强制性的。
- en: '![Figure 5.17: Review of the creation of the storage account](img/B31916_05_17.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17：存储账户创建的回顾](img/B31916_05_17.png)'
- en: 'Figure 5.17: Review of the creation of the storage account'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：存储账户创建的回顾
- en: In the same way that we have the prerequisite for Azure Storage, the function
    app for running this kind of trigger should consider using the Flex Consumption
    plan, as we can see in the following figure. The advantage of this Consumption
    plan, according to Microsoft, is that it reduces cold starts with always-ready
    instances, supports VNets, and scales automatically, even in high load periods.
    On the other hand, at the time of writing this book, this option was not available
    in all regions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Azure 存储中有所要求，运行此类触发的函数应用应考虑使用 Flex 消费计划，正如以下图所示。根据微软的说法，这种消费计划的优势在于它通过始终准备好的实例减少了冷启动，支持虚拟网络，并在高负载期间自动扩展。另一方面，在撰写本书时，此选项并非在所有地区都可用。
- en: '![Figure 5.18: Flex Consumption plan](img/B31916_05_18.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18：Flex 消费计划](img/B31916_05_18.png)'
- en: 'Figure 5.18: Flex Consumption plan'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：Flex 消费计划
- en: After the creation of the Azure function app, you may use the steps presented
    previously to publish the function. The name used for the function app in this
    example was `flexfunction`. It is worth noting that Flex Consumption plans are
    for Linux-based operating systems.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Azure 函数应用之后，您可以使用之前提供的步骤来发布该函数。本例中用于函数应用的名称为 `flexfunction`。值得注意的是，Flex
    消费计划适用于基于 Linux 的操作系统。
- en: 'The following code shows the published function. Notice that the `Connection`
    parameter is `"ConnectionStringName"` in this example. Also, notice that the name
    of the function is `SampleFunction`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了已发布的函数。请注意，在此示例中，`Connection` 参数是 `"ConnectionStringName"`。同时，请注意函数的名称是
    `SampleFunction`：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will need this information to set the Azure function. `"ConnectionStringName"`
    needs to be defined in the settings of the function app as an environment variable,
    as you can see in the following figure. The content of this configuration is the
    connection string of the created storage account.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要此信息来设置 Azure 函数。`"ConnectionStringName"` 需要在函数应用的设置中定义为环境变量，如图所示。此配置的内容是创建的存储账户的连接字符串。
- en: '![Figure 5.19: Defining the connection between the function app and the storage
    account](img/B31916_05_19.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19：定义函数应用和存储账户之间的连接](img/B31916_05_19.png)'
- en: 'Figure 5.19: Defining the connection between the function app and the storage
    account'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：定义函数应用和存储账户之间的连接
- en: 'After that, you will have all the information needed to define the event that
    will be triggered in the function app. Notice that the event happens in the storage
    account and Event Grid triggers the function. To do this, a webhook is created.
    The definition of the URL of the webhook can be seen here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将拥有定义函数应用中将要触发的事件所需的所有信息。请注意，事件发生在存储账户中，Event Grid 触发函数。为此，创建了一个 webhook。webhook
    URL 的定义可以在此处查看：
- en: '| **Part** | **Template** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **部分** | **模板** |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Base function app URL | https://<FUNCTION_APP_NAME>.azurewebsites.net |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 基础函数应用 URL | https://<FUNCTION_APP_NAME>.azurewebsites.net |'
- en: '| Blob-specific path | /runtime/webhooks/blobs |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| Blob 特定路径 | /runtime/webhooks/blobs |'
- en: '| Function query string | ?functionName=Host.Functions.<FUNCTION_NAME> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 函数查询字符串 | ?functionName=Host.Functions.<FUNCTION_NAME> |'
- en: '| Blob extension access key | &code=<BLOB_EXTENSION_KEY> |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Blob 扩展访问密钥 | &code=<BLOB_EXTENSION_KEY> |'
- en: The blob extension access key can be found in the **App Keys** section of the
    function app. There is a specific system key for `blobs_extension`. Once you have
    the key, you can use it to create a new event in Azure Storage, as you can see
    in the next figure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Blob 扩展访问密钥可以在函数应用的 **App Keys** 部分找到。对于 `blobs_extension` 有一个特定的系统密钥。一旦您有了密钥，您就可以使用它来在
    Azure 存储中创建一个新事件，如图中所示。
- en: '![Figure 5.20: Subscribing to an event in Blob Storage](img/B31916_05_20.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20: 在 Blob 存储中订阅事件](img/B31916_05_20.png)'
- en: 'Figure 5.20: Subscribing to an event in Blob Storage'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5.20: 在 Blob 存储中订阅事件'
- en: It is important to mention that your Azure subscription may not have enabled
    the resource provider for Event Grid and an error may occur with this disabled
    while creating the subscription. To enable the resource provider, you need to
    go to your subscription account and register it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是提到，您的 Azure 订阅可能尚未启用 Event Grid 资源提供者，并且在此禁用的情况下创建订阅时可能会发生错误。要启用资源提供者，您需要转到您的订阅账户并注册它。
- en: '![Figure 5.21: Registering the Microsoft.EventGrid resource provider](img/B31916_05_21.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21: 注册 Microsoft.EventGrid 资源提供者](img/B31916_05_21.png)'
- en: 'Figure 5.21: Registering the Microsoft.EventGrid resource provider'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.21: 注册 Microsoft.EventGrid 资源提供者](img/B31916_05_21.png)'
- en: After this configuration, by simply uploading files to the defined container,
    the function will be triggered for each file uploaded, in a low-latency model.
    You can monitor each trigger using the function’s **Invocations** panel. Notice,
    in the figure, that the function was triggered four times in the same second in
    the last calls, showing the capacity of the trigger function to handle a greater
    number of files at the same time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置之后，只需简单地将文件上传到定义的容器中，对于每个上传的文件，函数都会被触发，以低延迟模式。您可以使用函数的 **调用** 面板监控每个触发器。请注意，在图中，函数在最后几次调用中在同一秒内触发了四次，显示了触发函数处理大量文件的能力。
- en: '![Figure 5.22: Monitoring triggers](img/B31916_05_22.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22: 监控触发器](img/B31916_05_22.png)'
- en: 'Figure 5.22: Monitoring triggers'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.22: 监控触发器](img/B31916_05_22.png)'
- en: It is worth noting that this example requires different components that may
    create additional costs. So, you must pay attention not to let this demo run in
    your Azure account if you are just trying this option. On the other hand, this
    will decrease the latency between the arrival of a file and its processing, so
    you may consider it a good approach for real-life applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，此示例需要不同的组件，可能会产生额外的成本。因此，如果您只是尝试此选项，请务必注意不要让此演示在您的 Azure 账户中运行。另一方面，这将减少文件到达和处理之间的延迟，因此您可以考虑将其作为实际应用的不错方法。
- en: Car-sharing Blob storage trigger example
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享汽车 Blob 存储触发器示例
- en: Considering the car-sharing use case that we are presenting in this book, it
    is worth mentioning that one of the services that may be included in this solution
    is to analyze the driver’s license. To do so, in the frontend application, there
    will be a user interface to upload this important document to the business logic
    of the application. However, as this file is important, storing information like
    this needs to be well designed. A good option is to only extract the information
    needed with the uploaded image and then create a hash of this information, so
    you can delete the file uploaded by the user.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在本书中展示的共享汽车用例，值得提到的是，可能包含在此解决方案中的服务之一是分析驾驶执照。为此，在前端应用程序中，将有一个用户界面用于将此重要文件上传到应用程序的业务逻辑。然而，由于此文件很重要，存储此类信息需要精心设计。一个好的选择是仅提取上传图像中所需的信息，然后创建该信息的哈希值，这样您就可以删除用户上传的文件。
- en: To do so, you may create a function dedicated to processing driver’s license
    photos. Using a Blob storage trigger to do so may be a good idea.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你可以创建一个专门处理驾照照片的函数。使用 Blob 存储触发器来完成这个任务可能是个好主意。
- en: 'It is important to mention that this example needs to update the `Program.cs`
    file. Instead of directly using the `FunctionsApplication` class, we will use
    `HostBuilder` here, configuring the Azure Functions application with the `ConfigureFunctionsWebApplication`
    method. It is worth mentioning that in Azure Functions with .NET 8, `ConfigureFunctionsWebApplication()`
    enables ASP.NET Core integration, while the default `ConfigureFunctionsWorkerDefaults()`
    is used for the isolated worker model, offering greater flexibility and control
    over .NET versions and dependencies:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，这个示例需要更新 `Program.cs` 文件。在这里，我们不会直接使用 `FunctionsApplication` 类，而是使用
    `HostBuilder`，通过 `ConfigureFunctionsWebApplication` 方法配置 Azure Functions 应用程序。值得注意的是，在
    .NET 8 的 Azure Functions 中，`ConfigureFunctionsWebApplication()` 启用了 ASP.NET Core
    集成，而默认的 `ConfigureFunctionsWorkerDefaults()` 用于隔离工作模型，提供了对 .NET 版本和依赖项的更大灵活性和控制：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `AddUserSecrets` method adds user secrets to the configuration, which is
    useful for storing sensitive information such as API keys or connection strings.
    In this case, we are storing the connection with Blob Storage. The `ProcessDriversLicensePhoto`
    type is used to identify the assembly containing the user secrets. The `optional:
    true` parameter means that the application will not fail if the user secrets file
    is not found, and `reloadOnChange: false` indicates that the configuration will
    not automatically reload if the user secrets file changes.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddUserSecrets` 方法将用户密钥添加到配置中，这对于存储敏感信息（如 API 密钥或连接字符串）非常有用。在这种情况下，我们正在存储与
    Blob 存储的连接。`ProcessDriversLicensePhoto` 类型用于识别包含用户密钥的程序集。`optional: true` 参数意味着如果找不到用户密钥文件，应用程序不会失败，而
    `reloadOnChange: false` 表示如果用户密钥文件发生变化，配置不会自动重新加载。'
- en: 'Once you have defined `Program.cs`, you may create the Azure function to process
    Blob Storage. The function itself is quite simple to define, as you can see in
    the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了 `Program.cs`，你就可以创建一个 Azure 函数来处理 Blob 存储。函数本身定义起来相当简单，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `BlobTrigger` attribute defines where in Blob Storage the files will be
    uploaded, in this case, in the `drivers-license` folder, where `{name}` is a placeholder
    for the blob’s name, which will be passed as a string in the `name` parameter.
    The stream of the file will be obtained by the `myBlob` parameter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlobTrigger` 属性定义了文件将在 Blob 存储的哪个位置上传，在本例中是在 `drivers-license` 文件夹中，其中 `{name}`
    是 blob 名称的占位符，它将被作为字符串传递给 `name` 参数。文件的流将通过 `myBlob` 参数获得。'
- en: Queue storage trigger
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列存储触发器
- en: The principle of a queue is fairly well known since this is a data structure
    where you want to control the data so that first in will be first out. When we
    talk about the queue storage trigger in Azure Functions, we have the possibility
    to manage queues asynchronously and totally decoupled, making its usage extremely
    powerful.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的原则相当为人所熟知，因为这是一种你想要控制数据以便“先进先出”的数据结构。当我们谈论 Azure Functions 中的队列存储触发器时，我们有机会异步且完全解耦地管理队列，这使得其使用非常强大。
- en: The great power that we have in this scenario is the ability to handle large
    amounts of messages efficiently. Azure Functions has the capability to scale automatically,
    and it guarantees that each task will be processed properly with reliability and
    fault tolerance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们拥有的强大能力是高效处理大量消息的能力。Azure Functions 具有自动扩展的能力，并保证每个任务都将得到可靠和容错的处理。
- en: Considering this approach, it is worth noting that serverless applications will
    always focus the development on what is essentially needed – the business logic
    to make that service work. That is why serverless applications are a great way
    to implement microservices since the necessity of handling infrastructure will
    be less needed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种方法，值得注意的是，无服务器应用程序将始终专注于开发最本质的需求——使该服务工作的业务逻辑。这就是为什么无服务器应用程序是实现微服务的好方法，因为处理基础设施的需求将减少。
- en: Advantages, disadvantages, and when to use queue storage triggers
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列存储触发器的优缺点及适用场景
- en: If you have a use case where you must control a queue of data, a queue storage
    trigger function will be one of the good options to select. The fact that this
    approach can handle large volumes of messages efficiently is truly an advantage.
    In this case, you only need to focus on the business logic for the service that
    will be implemented.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个必须控制数据队列的使用场景，队列存储触发器将是选择的好选项之一。这种方法能够高效地处理大量消息，这确实是一个优势。在这种情况下，你只需要关注将要实施的服务业务逻辑。
- en: However, the pricing model is based on the number of executions and the amount
    of data processed, so you must be aware of it and not be surprised by the costs
    related to the solution. It is also worth noting that high load or transient errors
    may occur and, as a developer, you must implement retries and error-handling mechanisms
    to ensure your solution is well implemented.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，定价模型基于执行次数和数据处理量，因此你必须对此有所了解，不要对解决方案相关的成本感到惊讶。还值得注意的是，可能会出现高负载或瞬态错误，作为开发者，你必须实现重试和错误处理机制，以确保你的解决方案得到良好实施。
- en: Queue storage triggers may be a good solution when you must deliver a reliable
    and efficient solution for processing queued tasks, considering all we have discussed.
    For instance, if you need order processing, background job scheduling, or event
    event-driven notifications, this kind of solution can be a good approach. Now,
    let’s check a scenario in the car-sharing example where a queue storage trigger
    could be a good solution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们讨论的所有内容，队列存储触发器可能是当你必须提供一个可靠且高效的解决方案来处理队列任务时的一个好选择。例如，如果你需要进行订单处理、后台作业调度或事件驱动的通知，这种解决方案可以是一个好的方法。现在，让我们检查一个场景，在汽车共享示例中，队列存储触发器可能是一个好的解决方案。
- en: Car-sharing queue storage trigger example
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汽车共享队列存储触发器示例
- en: Considering the car-sharing use case, one of the services that may be created
    using a queue storage trigger is the `My_Best_Matches` microservice. According
    to the car-sharing example specification described in [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038),
    *Demystifying Microservices Applications*, all routes’ changes are sent to both
    the `My_Best_Matches` and `Route-Choosing` microservices.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到汽车共享用例，可能使用队列存储触发器创建的服务之一是 `My_Best_Matches` 微服务。根据 *第 2 章* 中描述的汽车共享示例规范，*揭秘微服务应用程序*，所有路线的变化都发送到
    `My_Best_Matches` 和 `Route-Choosing` 微服务。
- en: 'Considering this scenario, let’s suppose that the routes’ changes are queued
    as JSON components in an Azure Storage queue. This JSON will indicate that there
    is a new match to be processed by `My_Best_Matches` microservice:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个场景，假设路线的变化以 JSON 组件的形式排队在 Azure 存储队列中。这个 JSON 将指示有一个新的匹配项需要由 `My_Best_Matches`
    微服务进行处理：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you have this code running, using the local storage emulator, you can place
    a message in the `new-match` queue.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了这段代码，使用本地存储模拟器，你可以在 `new-match` 队列中放置一个消息。
- en: '![Figure 5.23: Placing a message in the queue](img/B31916_05_23.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23：将消息放入队列](img/B31916_05_23.png)'
- en: 'Figure 5.23: Placing a message in the queue'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23：将消息放入队列
- en: The message placed in the queue will be automatically processed by the function
    and then deleted from the storage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 放入队列的消息将被函数自动处理，然后从存储中删除。
- en: '![Figure 5.24: Azure function output](img/B31916_05_24.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.24：Azure 函数输出](img/B31916_05_24.png)'
- en: 'Figure 5.24: Azure function output'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24：Azure 函数输出
- en: Considering this scenario, this message could be used to send an email to both
    the car holder and car seeker, indicating that there is a new match for them and
    that they can interact with the system to define whether or not they will accept
    the proposed route.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个场景，这条消息可以用来向车主和寻车者发送电子邮件，表明他们有一个新的匹配项，并且他们可以与系统交互，以确定是否接受提出的路线。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed the implementation of three important Azure trigger functions
    to implement background services – timer triggers, Blob storage triggers, and
    queue storage triggers. Tasks such as processing routines, images, data, and orders
    can be easily implemented using this serverless technology.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了实现三个重要的 Azure 触发函数以实现后台服务——定时触发器、Blob 存储触发器和队列存储触发器。可以使用这种无服务器技术轻松实现处理例程、图像、数据和订单等任务。
- en: While presenting these kinds of functions, the chapter explained how to publish
    and monitor functions. It also presented a more efficient way to implement blob
    trigger functions, using Event Grid as a basis, and reducing the latency between
    the file upload and the start of the processing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍这些类型的函数时，本章解释了如何发布和监控函数。它还介绍了一种更有效的方法来实现 blob 触发函数，即以 Event Grid 为基础，并减少文件上传和开始处理之间的延迟。
- en: The chapter also explained how Azure Functions can be a great approach to implementing
    microservices. To do so, it presented three examples related to the car-sharing
    use case where the usage of this kind of solution will let developers focus on
    what really matters when it comes to software development – coding the business
    logic of the solution that is being developed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还解释了 Azure Functions 如何成为实现微服务的一个很好的方法。为此，它提供了三个与汽车共享用例相关的示例，其中使用此类解决方案将使开发者能够专注于软件开发真正重要的事情——编写正在开发的解决方案的业务逻辑代码。
- en: Now, let’s move on to the next chapter, which will discuss how to enable IoT
    solutions using Azure Functions as a basis.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入下一章，本章将讨论如何以 Azure Functions 为基础启用 IoT 解决方案。
- en: Questions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of the timer trigger function?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定时触发函数的目的是什么？
- en: The timer trigger function is designed to execute code on a schedule, defined
    using `NCRONTAB` expressions. It allows developers to run background jobs at regular
    intervals without requiring manual initiation or HTTP requests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 定时触发函数旨在根据使用 `NCRONTAB` 表达式定义的计划执行代码。它允许开发者定期运行后台作业，而无需手动启动或 HTTP 请求。
- en: This is useful for scenarios such as data synchronization, cleanup operations,
    report generation, and periodic billing. It helps automate repetitive tasks, especially
    those that shouldn’t depend on human interaction to be performed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于数据同步、清理操作、报告生成和定期计费等场景非常有用。它有助于自动化重复性任务，特别是那些不应依赖于人工交互来执行的任务。
- en: What is the purpose of the blob trigger function?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: blob 触发函数的目的是什么？
- en: The blob trigger function responds automatically whenever a file is added or
    modified in a specific Azure Blob Storage container. It enables event-driven processing
    for unstructured data such as images, logs, or documents.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当在特定的 Azure Blob Storage 容器中添加或修改文件时，blob 触发函数会自动响应。它为图像、日志或文档等非结构化数据启用事件驱动处理。
- en: This trigger is ideal for automating workflows involving data ingestion, file
    processing, image analysis, or document transformation. It supports scalability
    and integration with Event Grid to reduce latency in high-performance scenarios.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此触发器非常适合自动化涉及数据摄取、文件处理、图像分析或文档转换的工作流。它支持可伸缩性和与 Event Grid 的集成，以减少高性能场景中的延迟。
- en: What is the purpose of the queue trigger function?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列触发函数的目的是什么？
- en: The queue trigger function executes when a new message is added to Azure Queue
    Storage. It enables the asynchronous processing of tasks, decoupling producers
    from consumers in distributed systems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Azure Queue Storage 中添加新消息时，队列触发函数会执行。它使分布式系统中的生产者和消费者能够异步处理任务，解耦生产者和消费者。
- en: This approach ensures reliable and scalable handling of queued tasks such as
    background processing, order handling, or notifications, allowing developers to
    focus on business logic while Azure Functions handles infrastructure concerns.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保了可靠和可伸缩地处理队列任务，如后台处理、订单处理或通知，使开发者能够专注于业务逻辑，同时 Azure Functions 处理基础设施问题。
- en: What is the difference between the blob and queue trigger functions?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: blob 触发函数和队列触发函数之间有什么区别？
- en: The blob trigger function reacts to file changes in Azure Blob Storage, typically
    processing binary or unstructured data. It is event-driven and suited for scenarios
    such as file uploads, media processing, or document handling.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: blob 触发函数对 Azure Blob Storage 中的文件更改做出反应，通常处理二进制或非结构化数据。它是事件驱动的，适用于文件上传、媒体处理或文档处理等场景。
- en: In contrast, the queue trigger function is designed to process text-based messages
    from Azure Queue Storage. It is better suited for managing workflows, job scheduling,
    and message-driven integrations, where you need explicit control over task order
    and execution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，队列触发函数旨在处理来自 Azure Queue Storage 的基于文本的消息。它更适合于管理工作流、作业调度和基于消息的集成，在这些场景中，您需要显式控制任务顺序和执行。
- en: How can we reduce the latency between the file upload and the start of processing
    in a blob trigger function?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何减少文件上传和 blob 触发函数开始处理之间的延迟？
- en: To reduce latency in a blob trigger function, it’s recommended to use Event
    Grid-based blob triggers instead of polling-based triggers. Event Grid enables
    near-real-time processing by pushing events as they occur.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少 blob 触发函数的延迟，建议使用基于 Event Grid 的 blob 触发器而不是基于轮询的触发器。Event Grid 通过在事件发生时推送事件，实现了近乎实时的处理。
- en: Additionally, using the Flex Consumption plan or an App Service plan with Always
    On enabled helps minimize cold start times. However, these approaches may increase
    cost, so they should be evaluated based on application requirements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 Flex Consumption 计划或启用 Always On 的 App Service 计划有助于最小化冷启动时间。然而，这些方法可能会增加成本，因此应根据应用需求进行评估。
- en: List different ways to monitor an Azure function.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出监控 Azure 函数的不同方法。
- en: Azure functions can be monitored using several built-in tools. The **Invocation**
    tab in the Azure portal provides basic metrics, such as the number of executions
    and execution status.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数可以使用几个内置工具进行监控。Azure 门户中的**调用**选项卡提供基本指标，例如执行次数和执行状态。
- en: For deeper insights, Azure Monitor logs and Application Insights (**Performance**
    and **Live Metrics** views) offer advanced telemetry, performance tracking, and
    real-time diagnostics. These tools help identify errors, analyze trends, and debug
    runtime behavior effectively.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更深入的见解，Azure Monitor 日志和 Application Insights（**性能**和**实时指标**视图）提供高级遥测、性能跟踪和实时诊断。这些工具有助于识别错误、分析趋势和有效地调试运行时行为。
- en: Further reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Azure Functions timer trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions timer 触发器：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer)
- en: 'Azurite: [https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite](https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azurite：[https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite](https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite)
- en: 'Microsoft Azure Storage Explorer: [https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer](https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure Storage Explorer：[https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer](https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer)
- en: 'Azure Functions blob trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob-trigger)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions blob 触发器：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob-trigger)
- en: 'Azure Functions blob trigger with Event-Grid: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions blob 触发器与 Event Grid：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger)
- en: 'Azure Queue storage trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Queue 存储触发器：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue)
- en: 'Azure storage considerations: [https://learn.microsoft.com/en-us/azure/azure-functions/storage-considerations](https://learn.microsoft.com/en-us/azure/azure-functions/storage-considerations)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 存储注意事项：[https://learn.microsoft.com/en-us/azure/azure-functions/storage-considerations](https://learn.microsoft.com/en-us/azure/azure-functions/storage-considerations)
- en: Join our community on Discord
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI 生成的内容可能不正确。](img/B31916_Discord-QR-Code.png)'
