- en: World Space UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discovered how to interact with game objects in
    the world space scene. Not only can these objects can be balls and toys, or tools
    and weapons, but they can be buttons you interact with and other user interface
    widgets. Furthermore, Unity includes a user interface canvas system for building
    menus and other UI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphical user interface** (**GUI**) or just UI, usually refers to on-screen
    two-dimensional graphics, which overlay the main gameplay and present information
    to the user with status messages, gauges, and input controls such as menus, buttons,
    sliders, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity, UI elements always reside on a **canvas**. The Unity manual describes
    the `canvas` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `canvas` component represents the abstract space in which the UI is laid
    out and rendered. All UI elements must be children of a `GameObject` that has
    a `canvas` component attached.
  prefs: []
  type: TYPE_NORMAL
- en: In conventional video games, UI objects are usually rendered in a **screen space**
    canvas as an overlay. The screen space UI is analogous to a piece of cardboard
    pasted on your TV or monitor, overlaying the game action behind it.
  prefs: []
  type: TYPE_NORMAL
- en: However, that doesn't work in VR. If you attempt to use screen space for UI
    in virtual reality, you'll run into issues. Since there are two stereographic
    cameras, you need separate views for each eye. While conventional games may co-opt
    the edges of the screen for UI, *virtual reality has no screen edges*!
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, in VR, we use various approaches that place the user interface elements
    in **World Space** rather than screen space. In this chapter, I characterize a
    number of these types. We''ll define these types in detail and show you examples
    of them throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visor heads-up display**: In a visor **heads-up display** (**HUD**), the
    user interface canvas appears at the same spot in front of your eyes regardless
    of your head movement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reticle cursors**: Similar to visor HUD, a crosshair or a pointer cursor
    is used to choose things in the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windshield HUD**: This is a pop-up panel floating in 3D space like a windshield
    in a cockpit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game element UI**: The canvas is in the scene as a part of the gameplay,
    like a scoreboard in a stadium'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Info bubble**: This is a UI message that is attached to objects in the scene,
    like a thought bubble hovering over a character''s head'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-game dashboard**: This is a control panel that is a part of the gameplay,
    usually at waist or desk height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrist-based menu palette**: With two-handed input controllers, one hand can
    hold a menu palette while the other makes selections and uses the selected tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences in these UI techniques basically comes down to where and when
    you display the canvas and how the user interacts with it. In this chapter, we're
    going to try each of these in turn. Along the way, we'll also continue to explore
    user input with head movement and gestures as well as button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some of the exercises in this chapter use the scene completed in [Chapter
    4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based Control*, but are
    separate and not directly required by the other chapters in this book. If you
    decide to skip any of it or not save your work, that's OK.
  prefs: []
  type: TYPE_NORMAL
- en: Studying VR design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the implementation details, I would like to introduce the
    topic of designing 3D user interfaces and VR experiences. A lot of work has been
    done over the past few decades, and more so in the past few years.
  prefs: []
  type: TYPE_NORMAL
- en: 'With consumer VR devices so readily available, and powerful development tools
    like Unity, it''s not surprising there are many people inventing and trying new
    things, innovating continuously, and producing really excellent VR experiences.
    You are probably one of them. But the context of today''s VR is not a vacuum.
    There is a history of research and development that feeds into present-day work. 
    The book *3D User Interfaces: Theory and Practice* (Bowman et al), for example,
    is a classic academic survey of 3D user interaction for consumer, industrial,
    and scientific applications and research. Originally published in 2004, the second
    edition was published in 2017 (LaViola et al) and is an up-to-date review of academic
    theory and practical principles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Current writings for VR design are more accessible. An easy to read but practical
    introduction to VR user experience design is the Medium article *Get started with
    VR: user experience design* ([https://medium.com/vrinflux-dot-com/get-started-with-vr-user-experience-design-974486cf9d18](https://medium.com/vrinflux-dot-com/get-started-with-vr-user-experience-design-974486cf9d18))
    by Adrienne Hunter, co-creator of the popular VR physics package, NewtonVR. She
    identifies some important core principles, including It''s like theatre in the
    round, drawing attention with to objects, lighting, and audio cues, and designing
    space for height and accessibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another great article is *Practical VR: A Design Cheat Sheet* ([https://virtualrealitypop.com/practical-vr-ce80427e8e9d](https://virtualrealitypop.com/practical-vr-ce80427e8e9d)).
    This is intended to be a living primer with VR design guidelines, process, tools
    and other resources the author intends to maintain and update.'
  prefs: []
  type: TYPE_NORMAL
- en: One of my favorite studies of design for VR is the *VR Interface Design Pre-Visualization
    Methods* produced by Mike Algers as a grad student in 2015\. His inspiring video
    at [https://vimeo.com/141330081](https://vimeo.com/141330081) presents an easily
    digestible thesis of design principles, especially for seated VR experiences,
    based on established ergonomics of workspaces and visual perception. We'll use
    some of these ideas in this chapter. Algers also explores button design for VR,
    mockup workflows, and concepts for VR operating system design. (Algers presently
    works in the Google VR development group.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In his thesis, Algers establishes a set of comfort zones radially around the
    user''s first-person location, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1367a872-18be-41e7-bed9-9af40d410cbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Anything closer than 0.5 m is too close for comfort; you might have to cross
    your eyes just to focus and follow objects at that range. Beyond 20 m is too far
    way to have meaningful interactions, and is also too far for depth perception
    with parallax. Your Peripheral Zones (77–102 degrees) should not contain primary
    content and interactions but can have secondary ones. Behind you he calls the
    Curiosity Zone, you''d need to stretch (or swivel your chair or turn around) to
    see what''s going on there so it''d better be important yet not imperative. The
    Main Content Zone is your normal workspace. Then, accounting for arm reach (forward,
    up, and down) and other normal human movement in a workspace, Algers defines the
    optimal virtual work zone for seated VR experience as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f360026f-0430-439e-b914-449282c0f156.png)'
  prefs: []
  type: TYPE_IMG
- en: For standing and room-scale VR, the workspace is different. When standing, it
    may be much easier (and expected) to be able to turn around to access things all
    around you. With room-scale, you can walk around (and jump, duck, and crawl, for
    that matter). Alex Schwartz and Devin Reimer of Owlchemy Labs (since acquired
    by Google), in their talk at Oculus Connect 2 ( [https://www.youtube.com/watch?v=hjc7AJwZ4DI](https://www.youtube.com/watch?v=hjc7AJwZ4DI)), discuss
    the challenges of designing standing VR experiences for their popular Job Simulator,
    including accommodation for real-world ergonomics and varied height experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other great resources on designing for virtual reality include:'
  prefs: []
  type: TYPE_NORMAL
- en: Oculus's series of articles on VR design best practices, including on user input
    ([https://developer.oculus.com/design/latest/concepts/bp-userinput/](https://developer.oculus.com/design/latest/concepts/bp-userinput/))
    which includes recommendations on movement, button mapping, menus, and using your
    hands in VR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leap Motion (we do not cover its hand-recognition technology in this book) has
    some great writings on VR design, which can be found at [https://developer.leapmotion.com/explorations](https://developer.leapmotion.com/explorations),
    including very good articles on interactive design ([http://blog.leapmotion.com/building-blocks-deep-dive-leap-motion-interactive-design/](http://blog.leapmotion.com/building-blocks-deep-dive-leap-motion-interactive-design/))
    and user Interface Design ([http://blog.leapmotion.com/beyond-flatland-user-interface-design-vr/](http://blog.leapmotion.com/beyond-flatland-user-interface-design-vr/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google has produced a number of seminal examples, including *Daydream Labs:
    Lessons Learned from VR Prototyping - Google I/O 2016* ([https://www.youtube.com/watch?v=lGUmTQgbiAY](https://www.youtube.com/watch?v=lGUmTQgbiAY))
    and Daydream Elements ([https://developers.google.com/vr/elements/overview](https://developers.google.com/vr/elements/overview)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, this just scratches the surface; more is being published every day.
    Google it. A curated, living list of resources on user Interface Design and user
    experience in virtual reality can be found at The UX of VR site ([https://www.uxofvr.com/](https://www.uxofvr.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Have fun reading and watching videos. Meanwhile, let's get back to work. It's
    time to implement some VR UI ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: A reusable default canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity's UI canvas provides lots of options and parameters to accommodate the
    kinds of graphical layout flexibility that we have come to expect not only in
    games but also from web and mobile apps. With this flexibility comes additional
    complexity. To make our examples in this chapter easier, we'll first build a reusable
    prefab canvas that has our preferred default settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new canvas and change its Render Mode to world space as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to GameObject | UI | Canvas
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the canvas as `DefaultCanvas`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Render Mode to World Space
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Rect Transform component defines the grid system on the canvas itself,
    like the lines on a piece of graph paper. It is used for the placement of UI elements
    on the canvas. Set it to a convenient `640 x 480`, with a `0.75` aspect ratio.
    The `Rect Transform` component''s width and height are different from the world
    space size of the canvas in our scene. Let''s configure the `Rect Transform` component
    using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In `Rect Transform`, set the Width to `640` and the Height to `480`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Scale, set X, Y, Z to (`0.00135`, `0.00135`, `0.00135`). This is the size
    for one of our pixels in world space units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, position the canvas centered on the ground plane one unit above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (`0.325` is half of `0.75`). In Rect Transform, set Pos X, Pos Y, Pos Z to (`0`,
    `1.325`, `0`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will add an empty `Image` element (with a white background) to help
    us visualize the otherwise transparent canvas and provide an opaque background
    for the canvas when we need one (we can also use a `Panel` UI element):'
  prefs: []
  type: TYPE_NORMAL
- en: With `DefaultCanvas` selected, navigate to GameObject | UI | Image (ensure that
    it's created as a child of `DefaultCanvas`; if not, move it under `DefaultCanvas`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the Image selected, on the upper left of its Rect Transform pane, there
    is an anchor presets button (shown in the following screenshot). Selecting it
    opens the anchor presets dialog box. Press and hold the *Alt* key to see the stretch
    and position options and choose the one in the bottom-right corner (stretch-stretch).
    Now, the (blank) image is stretched to fill the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30581c97-e971-45aa-b2c7-659a16919233.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Double-check your Image settings based on the default properties for the `Image`
    child of the `DefaultCanvas` as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a4dd46fa-cc81-4550-975d-d633cb720423.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a `Text` element with useful default settings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With `DefaultCanvas` selected, navigate to GameObject | UI | Text (ensure that
    it's created as a child of `DefaultCanvas` (if not, move it under `DefaultCanvas`).
    The words `New Text` should appear on the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Text selected, set Alignment to Center Align and Middle Align and set
    Vertical Overflow to Overflow. Set the Scale to (`4`, `4`, `4`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its anchor presets button to (stretch - stretch) using the widget on the
    upper left of its Rect Transform pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-check your Text settings based on the default properties for the `Text`
    child of the `DefaultCanvas` as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/557031b9-4219-4617-b50e-58112722f0fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Increase the pixel resolution to give cleaner text fonts by keeping `DefaultCanvas`
    selected and setting the Canvas Scaler | Dynamic Pixels Per Unit to `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, save your work as a prefab asset that you can reuse throughout the
    chapter in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, in Project Assets, create a new folder named `Prefabs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `DefaultCanvas` object into the `Project Assets/Prefabs` folder to
    create a prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `DefaultCanvas` instance in the Hierarchy panel now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OK, glad we got that out of the way! Now we can use the `DefaultCanvas` prefab
    with different VR user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: A canvas has a `Rect Transform` component, which defines the grid system on
    the canvas itself, like the lines on a piece of graph paper. It is used for the
    placement of UI elements on the canvas. This is different from the size and position
    of a canvas object in world space.
  prefs: []
  type: TYPE_NORMAL
- en: Visor HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heads-up display, or HUD, is a floating canvas in your field of view that
    overlays the gameplay scene. In VR vernacular, there are two variations of HUDs.
    I'll call these variations the *visor HUD* and the *windshield HUD*. This section
    looks at the first one.
  prefs: []
  type: TYPE_NORMAL
- en: In visor HUD, the UI canvas is attached to the camera. It doesn't appear to
    respond to your head movement. When you move your head, it appears to be *stuck
    to your face*. Let's look at a nicer way of visualizing it. Suppose you're wearing
    a helmet with a visor, and the UI appears projected onto the surface of that visor.
    There may be contexts where this is OK in virtual reality, but it is likely to
    break the sense of immersion. So, it should generally only be used either when
    the visor is a part of the gameplay, or if the intent is to take you out of the
    scene, such as the utility menus for the hardware or the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a visor HUD with a welcome message as follows, and see for ourselves
    how it feels:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy panel, unfold the `MeMyselfEye` object and then drill down
    to the `Main Camera` object (for OpenVR that might be  `[CameraRig]/Camera (head)`;
    for Daydream, it may be  `Player/Main Camera/`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Project panel, drag the `DefaultCanvas` prefab onto the camera object
    so that it becomes a child of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy panel, with the canvas selected, rename the canvas to `VisorCanvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel for the canvas, change the `Rect Transform` component's
    Pos X, Pos Y, Pos Z to (`0`, `0`, `1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold `VisorCanvas` and select the child `Text` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, change the text from Default Text to Welcome! My reality
    is your reality. (You can enter line breaks in the input text area.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the text color to something bright, such as green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the `Image` object so that only the text shows by unchecking its Enable
    checkbox in Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene, and try it in VR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a capture of the Rift screen with the `VisorCanvas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/512268e3-f19f-45ff-b3d6-ecd174a0e94a.png)'
  prefs: []
  type: TYPE_IMG
- en: In VR, when you move your head around, the text follows along as if it's attached
    to a visor in front of your face.
  prefs: []
  type: TYPE_NORMAL
- en: A visor HUD canvas and reticle cursor canvas are set as a child object of the
    camera.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and either disable `VisorCanvas` or just delete it (in the Hierarchy
    panel, right-click on it and click on Delete) because we're going to display the
    welcome message in a different way in a later section. Next, we'll look at a different
    application of this technique.
  prefs: []
  type: TYPE_NORMAL
- en: The reticle cursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variant of the visor HUD that is essential in first-person shooter games
    is a *reticle* or crosshair cursor. The analogy here is that you''re looking through
    a gun-sight or an eyepiece (rather than a visor) and your head movement is moving
    in unison with the gun or turret itself. You can do this with a regular game object
    (for example, Quad + texture image), but this chapter is about UI. So, let''s
    use our canvas, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find your Main Camera object in the Hierarchy panel as we did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Project panel, drag the `DefaultCanvas` prefab onto the camera object
    so that it becomes a child of the camera. Name it `ReticleCursor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Rect Transform component's Pos X, Pos Y, Pos Z to (`0`, `0`, `1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete its child objects: `Image` and `Text`. This will *break* the prefab association;
    that's OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a raw image child by selecting it from the main menu bar, navigating through
    GameObject | UI | Raw Image and making sure that it's a child of `ReticleCursor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Raw Image panel's Rect Transform, set Pos X, Pos Y, Pos Z to (`0`, `0`,
    `0`) and the Width and Height to (`22`, `22`). Then, choose a noticeable Color
    such as red in the Raw Image (Script) properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene and try it in VR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you'd like a nicer-looking reticle, in the Raw Image (Script) properties,
    populate the Texture field with a cursor image. For example, click on the tiny
    *circle* icon on the far right of the Texture field. This opens the Select Texture
    dialog. Find and select a suitable one, such as the `Crosshair` image. (A copy
    of `Crosshair.gif` is included with this book.) Just be sure to change the Width
    and Height to the size of your image (`Crosshair.gif` is 22 x 22 in size) and
    ensure that the Anchor is set to middle-center.
  prefs: []
  type: TYPE_NORMAL
- en: We set the canvas position Pos Z to `1.0` so that the reticle floats in front
    of you at a 1-meter distance. A fixed distance cursor is fine in many UI situations,
    like when you're picking something from a flat canvas that is also at a fixed
    distance from you.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is world space. If another object is between you and the reticle,
    the reticle will be obfuscated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if you look at something much farther away, you''ll refocus your eyes
    and have trouble viewing the cursor at the same time. To emphasize this problem,
    try moving the cursor closer. For example, if you change the Pos Z of the `ReticleCursor`
    to `0.5` or less, you might have to go cross-eyed to see it! To compensate for
    these issues, we can ray cast and move the cursor to the actual distance of the
    object that you''re looking at, resizing the cursor accordingly so that it appears
    to stay the same size. Here''s a cheap version of this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: With `ReticleCursor` selected, click on Add Component | New Script, name it
    `CursorPositioner` and click on Create and Add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the script in MonoDevelop by double-clicking on the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the `CursorPositioner.cs` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Rect Transform component's Pos Z is found in the script in `transform.localPosition`.
    This script changes it to `hit.distance` if it's less than the given Pos Z. Now,
    you can also move the reticle to a more comfortable distance, such as Pos Z =
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An excellent tutorial by `@eVRydayVR` shows how to implement both distance
    and size compensated world space reticles. You can visit [https://www.youtube.com/watch?v=LLKYbwNnKDg](https://www.youtube.com/watch?v=LLKYbwNnKDg),
    which is a video titled Oculus Rift DK2 - Unity Tutorial: Reticle.'
  prefs: []
  type: TYPE_NORMAL
- en: We just implemented our own cursor reticle, but many VR SDKs now also provide
    cursors. For example, in Google VR, the `GvrReticlePointer.cs` script is a more
    thorough implementation. Another example, the Oculus OVR package, includes a `Cursor_Timer`
    prefab you can use as a Loading... indicator cursor.
  prefs: []
  type: TYPE_NORMAL
- en: The windshield HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *heads-up display*, or HUD, originates from its use in aircrafts, where
    a pilot is able to view information with their head positioned in such a way that
    they are looking forward rather down at their instrument panels. Owing to this
    usage, I'll refer it as *windshield HUD*. Like visor HUD, the information panel
    overlays the gameplay, but it isn't attached to your head. Instead, you can think
    of it as being attached to your seat while you are in a cockpit or at the dentist.
  prefs: []
  type: TYPE_NORMAL
- en: A visor HUD is like the UI canvas—it is attached to your head. A windshield
    HUD is like it's attached to a glass dome around you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple windshield HUD by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Project panel, drag the `DefaultCanvas` prefab onto the `MeMyselfEye`
    object in the Hierarchy panel so that it becomes an immediate child of `MeMyselfEye` (not
    under the camera this time).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it to `WindshieldCanvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `WindshieldCanvas` selected, set the Rect Transform component's Pos X,
    Pos Y, Pos Z to (`0`, `1.4`, `1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we'll set the Text component. With Text under `WindshieldCanvas` selected,
    change the text to Welcome! My reality is your reality. Also, change the color
    to something bright, such as green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, we'll make the panel translucent. Select the image from Image under
    `WindshieldCanvas` and select its color swatch. Then in the Color dialog, modify
    the `Alpha ("A")` channel from `255` to about `115`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s pretty straightforward. When you view it in VR, the canvas starts out
    just in front of you, but as you look around, its position seems to remain stationary
    and relative to the other objects in the scene, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88d319a4-a884-45a7-9cfa-910a8123244b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we''ll see in the next chapter, [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml),
    *Locomotion and Comfort*, when a first-person character moves through the scene,
    the HUD canvas will stay in front of you, at the same relative position to your
    body object, `MeMyselfEye`. You can try it now in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `MeMyselfEye` in Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then in the Scene window, using the Move gizmo, move the `MeMyselfEye` position.
    In VR, you'll see the HUD follows along like it's part of your body or a spaceship's
    cockpit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might have realized that it's possible for objects in the scene to obfuscate
    the HUD panel since they're all occupying the same world space. If you need to
    prevent this, you have to ensure that the canvas is always rendered last so that
    it appears in front of any other objects regardless of its position in 3D space.
    In a conventional monoscopic game, you can do this by adding a second camera for
    the UI and changing its render priority. In stereoscopic VR, you have to accomplish
    this differently, possibly by writing a custom shader for your UI object or doing
    per-layer occlusion culling. This is an advanced topic; see the *World Space canvas
    on top of everything*? discussion thread for details: [https://answers.unity.com/questions/878667/world-space-canvas-on-top-of-everything.html](https://answers.unity.com/questions/878667/world-space-canvas-on-top-of-everything.html).
  prefs: []
  type: TYPE_NORMAL
- en: A variant of this HUD is to turn the canvas so that it's always facing you,
    while its position in 3D space is fixed. See the *Info bubble* section of this
    chapter to learn how to code this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For kicks, let''s write a script that removes the welcome message canvas after
    15 seconds, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With `WindshieldCanvas` selected, click on Add Component | New Script, name
    the script as `DestroyTimeout`, and click on Create and Add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the script in MonoDevelop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the `DestroyTimeout.cs` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `WindshieldCanvas` will disappear after the timer runs out when the game
    starts up.
  prefs: []
  type: TYPE_NORMAL
- en: A windshield HUD canvas is set as a child object of the first-person avatar,
    a sibling object of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we start to move further towards a first-person experience.
    Imagine sitting in a car or the cockpit of an aircraft. The HUD is projected on
    the windshield in front of you, but you're free to move your head to look around.
    In the scene's Hierarchy panel, there's a first-person object (`MeMyselfEye`)
    that contains the camera rig, possibly your avatar body, and the other furnishings
    surrounding you. When the vehicle moves in the game, the entire cockpit moves
    in unison, including the camera rig and the windshield. We'll work with this more
    later in this chapter and [Chapter 7](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml),
    *Playing with Physics and Fire*.
  prefs: []
  type: TYPE_NORMAL
- en: The game element UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Ethan gets killed in the Diorama scene from [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control*, the score value in the `GameController` object''s `KillTarget`
    script is updated, but we don''t show the current score to the player (set up
    in that chapter). We''ll do this now, adding a scoreboard into the scene at the
    top-left corner of the backdrop `PhotoPlane` image:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Project panel, drag the `DefaultCanvas` prefab directly into the Scene
    view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it `ScoreBoard`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `ScoreBoard` selected, set the Rect Transform component's Pos X, Pos Y, Pos
    Z to (`-2.8`, `7`, `4.9`) and the Width and Height to (`3000`, `480`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Text under `ScoreBoard` selected, set the Font Size to `100` and choose
    a noticeable color such as red for the Text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the Score: 0 sample string for Text'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable Image under `ScoreBoard` by unchecking the Enable check box or deleting
    it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have added another canvas to the scene, sized and placed it where we want,
    and formatted the text for display. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21c97363-120f-4523-86bb-e4315d89b258.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to update the `KillTarget.cs` script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may be using the UnityEngine UI classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a public variable for `scoreText`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a line to `Start()` to initialize the score text:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And add a line to `Update()` to change the score text when the score changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After saving the script file, go back into the Unity editor, select `GameController`
    in the Hierarchy panel, and then drag and drop the Text object under `ScoreBoard`
    from Hierarchy onto the Score Text field in Kill Target (Script).
  prefs: []
  type: TYPE_NORMAL
- en: Run the scene in VR. Each time you kill Ethan (by staring at him), your score
    will be updated on the `ScoreBoard` on the upper left of `PhotoPlane`.
  prefs: []
  type: TYPE_NORMAL
- en: A game element UI canvas is a part of the scene like any other game object.
  prefs: []
  type: TYPE_NORMAL
- en: This was an example of using an object that's a part of the scene for information
    display. Our example is pretty simplistic. You might want to make a nicer modeled
    scoreboard, like the one you'd see in a stadium or something. The point is, it's
    a part of the scene and to see the message you might have to actually turn your
    head and, well, look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Using TextMeshPro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make a billboard glow like a neon sign, you can use TextMesh Pro which presently
    comes included free with Unity. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: With `ScoreBoard` selected in Hierarchy, create a new `TextMesh` text element
    (right-click UI | TextMeshPro - Text).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This replaces our standard UI text element, so disable the `Text` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the TMP text, set its Font Asset to Bangers SDF.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For its Material Preset, use Bangers SDF Glow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll to Glow settings to adjust the colors and other settings as you desire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can even write a script that cyclically modifies the glow settings to make
    a flashing, glowing sign!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to try this, be sure to update the GameController''s `KillTarget`
    script to use the TMP object rather than the UI one. `Modify KillTarget.cs` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may be using the UnityEngine TextMesh Pro classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the data type of the `scoreText` variable with `TMP_Text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Drag the TMP text item onto the slot in the Inspector. The rest of the script
    is unchanged since `TMP_Text` has a `text` property just as the UI text one has.
  prefs: []
  type: TYPE_NORMAL
- en: '**TextMesh Pro** is a great tool for text formatting and layout in Unity. It
    is a replacement for Unity''s UI Text, with added advanced text rendering, custom
    shaders, typographic controls such as paragraph spacing and kerning, and a lot
    more. It was a third-party plugin and is now included free with Unity. Documentation
    can be found here: [http://digitalnativestudios.com/textmeshpro/docs/.](http://digitalnativestudios.com/textmeshpro/docs/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the scoreboard text using a glow effect with TextMesh
    Pro and its Inspector settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47a19eb5-82ed-4e7b-8838-cb785582e14e.png)'
  prefs: []
  type: TYPE_IMG
- en: Info bubble
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a comic book, when a character says something, it's shown in a *speech bubble*.
    In many online social VR worlds, participants are represented by avatars and,
    hovering above someone's avatar, their name is displayed. I'll call this type
    of user interface an *info bubble*.
  prefs: []
  type: TYPE_NORMAL
- en: Info bubbles are located in world space at a specific 3D position, but the canvas
    should always be facing the camera. We can ensure this with a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll display the X, Z location of the `WalkTarget` object
    (set up in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*), controlled by the `LookMoveTo.cs` script. To add the info bubble, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Project window, drag the `DefaultCanvas` prefab directly into the Hierarchy
    window so that it's a child of `WalkTarget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it to `InfoBubble`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `InfoBubble` selected, set the Rect Transform component's Pos X, Pos Y,
    Pos Z to (`0`, `0.2`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Text under `InfoBubble` selected, set the Rect Transform component's Pos
    X, Pos Y, Pos Z to (`0`, `0`, `0`) and Right and Bottom to `0`, `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Image under `InfoBubble` selected, set Scale to (`0.7`, `0.2`, `1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the `X:00.00`, `Z:00.00` sample string for Text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the canvas and text look roughly the right size and position and
    adjust the text as you please. (In my scene, there's a cube at the origin so I
    temporarily disable it to see the WalkTarget also at the origin.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will modify the `LookMoveTo.cs` script to show the current `WalkTarget` X,
    Z position. Open the script in the MonoDevelop editor and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The line `using UnityEngine.UI;` states that this script will need access to
    the Unity UI API. We defined a `public Transform infoBubble` variable, which will
    be set to the `WalkTarget/InfoBubble` object. We also defined a `private Text
    infoText` variable, which gets set to the `InfoBubble` object's Text object. The
    script assumes that the given `InfoBubble` has a child Text UI object.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the overuse of the word *text* can be confusing. The `infoText`
    *text* object has a *text* component, which has a *text* string property! You
    can see what I mean in Unity editor. If you examine the Inspector panel while
    `InfoBubble/Text` is selected, you'll see that it contains a Text (Script) component,
    which has a Text field. This Text field is where we write our messages. So in
    `Setup()`, we find the `WalkTarget/InfoBubble/Text` object, assigning the Text
    object to `infoText`, and then in `Update()`, we set the string value of `infoText.text`
    so that the score is shown on the bubble canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in `Update()`, we transformed the `infoBubble` canvas so that it's always
    facing us using `infoBubble.LookAt()` and passing it the camera position. The
    result of `LookAt()` has the canvas facing away from us. So, we also need to rotate
    it around the *y *axis by 180 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and drag the `InfoBubble` object from Hierarchy onto the Info
    Bubble slot in the Look Move To (Script) component. If you don't assign the `InfoBubble`
    canvas, the script will still run because we test for `null` objects before we
    reference them.
  prefs: []
  type: TYPE_NORMAL
- en: An info bubble UI canvas is attached to other game objects, moving when they
    move and always facing the camera (like a billboard).
  prefs: []
  type: TYPE_NORMAL
- en: Run the scene in VR and you'll see that `WalkTarget` has a little info bubble
    telling us about its X, Z position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra challenge: Want to try something else? Implement a health meter bar for
    Ethan. Use the `countDown` variable in the `KillTarget` script to determine his
    percentage of health and to display a health meter (horizontal bar) above his
    head when it''s not at 100 percent.'
  prefs: []
  type: TYPE_NORMAL
- en: Info bubbles are useful when you need to display UI messages that belong to
    specific objects in the scene and may move in concert with the objects.
  prefs: []
  type: TYPE_NORMAL
- en: An in-game dashboard with input events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An in-game dashboard or control panel is a UI display that is integrated into
    the game itself. A typical scenario is an automobile or a spaceship, where you
    are seated in a cockpit. At waist level (desk level) is a panel with a set of
    controls, gauges, information displays, and so on. Dashboards generally feel more
    natural in a seated VR experience.
  prefs: []
  type: TYPE_NORMAL
- en: A few pages back, we discussed windshield HUDs. Dashboards are pretty much the
    same thing. One difference is that the dashboard may be more obviously part of
    the level environment and not simply an auxiliary information display or a menu.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, dashboards can be a very effective mechanism to control VR motion sickness.
    Researchers have found that when a VR user has a better sense of being grounded
    and has a consistent *horizon line* in view, he's much less likely to experience
    nausea while moving around a virtual space. In contrast, being a floating one-dimensional
    eyeball with no sense of self or grounding is asking for trouble! (See the *Oculus
    Best Practices* for this, and other great tips, by visiting [https://developer.oculus.com/documentation/intro-vr/latest/concepts/bp_intro/](https://developer.oculus.com/documentation/intro-vr/latest/concepts/bp_intro/)).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll make a simple dashboard with Start/Stop buttons. For
    now, the buttons will operate a water hose in the scene to help fend off the zombies.
    (*Why not?*) Like other examples in this chapter, this project uses the scene
    created in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project is a bit more complicated than you might expect. However, if you''ve
    ever had to build anything in Minecraft, you know that even the simple things
    may require assembling multiple parts. Here''s what we will do:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a dashboard canvas with two functional buttons—Start and Stop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a water hose to the scene and wire it to the buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a simple version of the script that activates the buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlight a button by looking at it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the script to activate the button only if it's highlighted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dashboard with buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a dashboard with a Start and a Stop button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Project window, drag the `DefaultCanvas` prefab onto the `MeMyselfEye`
    object in the Hierarchy panel so that it becomes a child.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it to `Dashboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `Dashboard` selected, set the Rect Transform component's Pos X, Pos Y,
    Pos Z to (`0`, `0.6`, `0.6`) and its Rotation to (`60`, `0`, `0`). Feel free to
    adjust the position for preferred comfort zone and your specific VR device camera
    rig.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable or delete the Text child object of `Dashboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This places the dashboard 1 m below your eyes and a little out in front.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a *work-in-progress* look, if you''d like, I''ve included an image sketch
    of a vehicle dashboard that you can use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `DashboardSketch.png` file into your Project (such as the `Assets/Textures`
    folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new GameObject | UI | Raw Image as a child of `Dashboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `DashboardSketch` texture from the Project panel onto the Texture field
    of the Raw Image component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Rect Transform component's Pos X, Pos Y, Pos Z to (`0`,`0`,`0`), Width
    to `140`, and Height to `105`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should be Anchored at middle-center (`0.5`,`0.5`) in X, Y, and Pivot, with
    Rotation (`0`,`0`,`0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Scale to (`4.5`,`4.5`,`4.5`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add the Start and Stop buttons. They can go anywhere you''d like
    on the canvas, but the sketch has two nice spaces predefined for them:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new GameObject | UI | Button as a new child of `Dashboard`. Name it `StartButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Rect Transform component's X, Y, Z to (`-48`, `117`, `0`), the Width and Height
    to (`60`, `60`), and Anchored to center-middle (`0.5`). No Rotation and Scale
    of `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the button's Image (Script) component pane, for Source Image, click on the
    tiny circle on the far right to open the Select Sprite picker and choose `ButtonAcceleratorUpSprite`
    (which you may have imported into the `Assets/Standard Assets/CrossPlatformInput/Sprites`
    folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the button's Button (Script) component pane, for the Normal Color, I used
    RGB (`89`,`154`,`43`) and set Highlighted Color to (`105`, `255`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, create another button named `StopButton` with the Rect Transform
    component's X, Y, Z (`52`, `118`, `0`) and set the Width and Height to (`60`,
    `60`). For Source Image, select `ButtonBrakeOverSprite`, then choose the Normal
    Color (`236`, `141`, `141`) and Highlighted Color (`235`, `45`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7764fc8-bada-442a-8b09-1a9c2bd69425.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One last thing. If you''re using the `ReticleCursor` that was created earlier
    in this chapter with the `CursorPositioner.cs` script, we want the dashboard itself
    to have a collider for the script. We can achieve this by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With `Dashboard` selected, right-click for options, and navigate to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3D Object | Plane.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set its Position to (`0`,`0`,`0`), Rotation to (`270`,`0`,`0`), and Scale to
    (`64`,`1`,`48`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable its Mesh Renderer (but leave its Mesh Collider enabled).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the dashboard has a plane child that isn't rendered, but its collider will
    be detected when `CursorPositioner` does its ray cast. We do this to see your
    gaze on this dashboard panel rather than the ground below even when not looking
    directly at a button.
  prefs: []
  type: TYPE_NORMAL
- en: Having a single toggle button with pressed and released states might be better
    than separate Start and Stop buttons. When you're done with this chapter, go ahead
    and figure out how to do it!
  prefs: []
  type: TYPE_NORMAL
- en: We just created a world space canvas that should appear in VR at waist or desk
    level. We decorated it with a dashboard sketch and added two UI buttons. Now,
    we'll wire up the buttons to specific events.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the water hose to the buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first give the buttons something to do, such as the action of turning
    on a water hose. If we aim it strategically, it might even fend off rogue zombies.
    Coincidentally, the Unity Particle Systems under Standard Assets which we imported
    earlier has a water hose that we can use. Add it to the scene as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done so already, import the Particle Systems standard asset from
    the main menu bar by navigating to Assets | Import Package | ParticleSystems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project window, find the `Assets/Standard Assets/Particle Systems/Prefabs/Hose`
    prefab and drag it into the Hierarchy window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Transform component's X, Y, Z to (`-3`, `0`, `1.5`) and Rotation to
    (`340`, `87`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that Hose is enabled (check its Enable checkbox).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the Hose in Hierarchy so that you can see its child WaterShower particle
    system. Select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, in the Particle System properties pane, look for Play On Awake
    and uncheck it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the Hose object in Hierarchy has a `WaterShower` child object. This
    is the actual particle system that we will control with the buttons. It should
    start as *off*.
  prefs: []
  type: TYPE_NORMAL
- en: The Hose prefab itself comes with mouse-driven script that we don't want to
    use,
  prefs: []
  type: TYPE_NORMAL
- en: 'so disable it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With Hose selected, disable (uncheck) its Hose (Script).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, disable (uncheck) the Simple Mouse Rotator (Script) component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will wire up `StartButton` to the WaterShower particle system by telling
    the buttons to listen for the `OnClick()` events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unfold the Hose in Hierarchy so that you can see its child WaterShower particle
    system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Hierarchy, select `StartButton` (under `MeMyselfEye/Dashboard`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that in the Inspector, the On Click() pane of the `Button` component is
    empty. Click on the *Plus* (+) icon on the lower right of that pane to reveal
    a new field labeled None (Object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the WaterShower particle system from Hierarchy onto the None (Object) field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Its function selector, the default value, is No Function. Change it to ParticleSystem
    | Play().
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OK. The steps are similar for the `StopButton`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select `StopButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the *Plus* (+) icon on the lower right of it's On Click() pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the WaterShower from Hierarchy onto the None (Object) field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Its function selector, the default value, is No Function. Change it to ParticleSystem
    | Stop().
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Start and Stop buttons *listen for* `OnClick()` *events*, and when one comes,
    it will
  prefs: []
  type: TYPE_NORMAL
- en: call the WaterShower particle system's `Play()` and `Stop()` functions respectively.
    To make it work, we need to press the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Activating buttons from the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we give the user a way to press the buttons, let''s see how we can do
    this from a script. Create a new script on `GameController`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With `GameController` selected in Hierarchy, press Add Component | New Script
    to create a script named `ButtonExecuteTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the script in MonoDevelop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following script, we turn the hose on and off in five-second intervals,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The script manages a Boolean `isOn` value, which says if the hose is on or off.
    And it has a timer which counts down from 5 seconds on each update. We use the
    `private` keyword for variables that are only used within this script, whereas
    the `public` ones can be viewed and modified via the Unity editor and other scripts.
    For `startButton` and `stopButton`,  you'll drag and drop them in the Unity editor.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, we use the `UnityEngine.UI`. As we saw in the previous chapter, *Events*
    are a way for different components to talk to one another. When an event occurs,
    such as a button press, a function in another script may get called. In our case,
    we're going to trigger an event corresponding to the start button press, and another
    corresponding to the stop button press, as we set up in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and click on Play. The hose should turn on and off every five
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have tested the event system connection between the button clicks
    and the hose, we can disable this script before moving on to the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: With `GameController` selected,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the `ButtonExecuteTest` component by unchecking its Enable checkbox,
    or remove the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breaking down a complex feature into bite-sized pieces and testing them separately
    is an excellent implementation strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Look to highlight a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Meanwhile, let''s detect when the user is looking at a button and highlight
    it. Although Button is a Unity UI object, it needs to be detected with a ray cast.
    There may be other ways to accomplish this, as discussed later in this chapter,
    but here we will add a game object sphere to each button and cast a ray to detect
    it. First, add the spheres by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy panel, select `StartButton` (under `MeMyselfEye/Dashboard`),
    right-click for options, and navigate to 3D Object | Sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Transform component's Scale to (`52`, `52`, `52`) so that it fits the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: button size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Disable the sphere's Mesh Renderer by unchecking the Mesh Renderer checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, repeat these steps for `StopButton`. A shortcut is to duplicate the sphere,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the Sphere and choose Duplicate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the duplicated item (`Sphere (1)`) into `StopButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset it Position to (`0`,`0`,`0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a new script on `StartButton`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With `StartButton` selected, navigate to Add Component | New Script to create
    a script named `RespondToGaze`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the script for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following `RespondToGaze.cs` script, we tell the button to become highlighted
    when you look at it, using the child Sphere object''s collider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this script, on each update, we cast a ray from the camera. If it hits this
    button's sphere collider, then the hit object's parent should be this button.
    So (after checking that the hit object has a parent), we compare the parent gameObject
    to this button's gameObject.
  prefs: []
  type: TYPE_NORMAL
- en: If the gaze has selected this button, we trigger the button's Select to make
    it highlight. The highlighting is done within Unity's `EventSystem`. While the
    EventSystem has all this implemented for mouse clicks and screen touches, we have
    to manually tell the button it's been selected by calling `button.Select()`.
  prefs: []
  type: TYPE_NORMAL
- en: Unhighlighting the button is not so obvious. The EventSystem maintains a currently
    selected object across your runtime scene. We clear it by passing null to `SetSelectedGameObject()`.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and *Play*. When you gaze at a button, it should highlight,
    and when you gaze away from it, it should remove the highlight.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also an example of a reusable component script. We just wrote and tested
    it for the StartButton. We can use the same script for the StopButton:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the StopButton from the Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the RespondToGaze script from the Project Assets onto the button, or
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add Component | Scripts | RespondToGaze.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the project one more time. Both buttons should highlight when you gaze
    at them.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using  Google VR for Cardboard or Daydream, you can include the `GvrEventSystem`
    prefab in your scene. Then this `RespondToGaze` script becomes unnecessary and
    redundant. The `Daydream` component already supports gaze-based select, highlight,
    and clicking with the input controller. But I encourage you to follow along with
    this project nonetheless to experience how this functionality can be implemented. If
    so, temporarily disable `GvrEventSystem` in your scene.
  prefs: []
  type: TYPE_NORMAL
- en: Looking and then clicking to select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes to make to the `RespondToGaze.cs` script are pretty simple. At
    top of the class, add the following public variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of `Update()`, make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the controller `"Fire1"` button is pressed, it will trigger a click of
    the UI button.
  prefs: []
  type: TYPE_NORMAL
- en: The component gives you the option to enable highlights and/or clicking with
    the input controller. You can also choose the logical input button that will trigger
    the click events.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an in-game dashboard with buttons that respond to user input, which
    controls the behavior of an object (water hose) in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Looking and starting to select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of using a clicker, we can use a time-based selection to click on the
    button. To make this work, we'll keep a countdown timer while staring at a button,
    much like the one that we used to kill Ethan in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `RespondToGaze.cs` script. At top of the class, add the following
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Update()`, make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, not only will a button click get involved on `Input.GetButtonDown`, but
    also if you gaze at the button long enough (when `timedClick` is `true`). We begin
    a timer when the button is selected (highlighted) and count up. When the timer
    expires the click event is invoked. If the button is deselected before then, the
    timer is reset to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '*Does it work for you? Woohoo!*'
  prefs: []
  type: TYPE_NORMAL
- en: So this was a relatively complex project. The goal was to create a dashboard
    with buttons that turn a hose on and off. We broke it down into discrete steps,
    added the objects and components a step at a time, and tested each step to make
    sure that it worked as expected before moving on. If you tried to implement this
    all at once or blew through it without testing, things can (and will) go wrong,
    and it'll be much harder to figure out where the problem cropped up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra challenge: This feature can be further enhanced for different purposes.
    For example, it can be used to give the user the information that the countdown
    is running, perhaps by animating a spinner cursor. Also, further feedback can
    be given when the click event is executed. For example, the Button UI object has
    a Transition option called Animation that might be helpful. Also, consider audio
    cues.'
  prefs: []
  type: TYPE_NORMAL
- en: Pointing and clicking with VR components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, while Unity provides UI elements such as canvas text, buttons,
    and other controls that are specially tuned for conventional screen space UI and
    mobile app, using them in World Space and tying them together with VR user input
    can get pretty involved. World space interactions assume some physics, colliders,
    and ray casts to detect interaction events.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, VR device-specific toolkits may provide components that take care
    of some of this work already. As we saw in previous chapters, device manufacturers
    provide toolkits built atop their Unity SDK with convenient scripts, prefabs,
    and demo scenes that illustrate how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''re looking for components that let you design scenes using
    Unity UI elements on a canvas, take advantage of all their EventSystem interactivity
    goodness, use world space 3D models, and input controllers or laster pointers.
    For example, consider these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Oculus Rift and GearVR: OVRInputModule; see [https://developer.oculus.com/blog/unitys-ui-system-in-vr/](https://developer.oculus.com/blog/unitys-ui-system-in-vr/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SteamVR: Steam InteractionSystem; see the `/Assets/SteamVR/InteractionSystem/`
    folder after installing the SteamVR package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Daydream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VRTK open source toolkit: [https://github.com/thestonefox/VRTK](https://github.com/thestonefox/VRTK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, you might consider purchasing a package from the Unity Asset Store.
    The Curved UI package ($25), for example, lets you make VR-ready curved canvases
    and supports Vive, Oculus Touch, Daydream controllers, and gaze input, as depicted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12341f9a-bccd-4c4e-a2cd-9176aa8aecb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Unity UI and SteamVR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced the SteamVR InteractionSystem in Chapter 5, *Handy Interactables*.
    It is intended as an example of how to use the SteamVR SDK but includes some very
    useful components and demo scenes. Using the Interaction System, it's very easy
    to convert your Dashboard into a control panel you can operate directly with your
    positionally tracked hand controllers.
  prefs: []
  type: TYPE_NORMAL
- en: The Interaction System includes its own `Player` camera rig which replaces the
    default `[CameraRig]` we have been using. It includes a VRCamera, two hands (Hand1
    and Hand2), and other useful objects.
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `Assets/SteamVR/InteractionSystem/Core/Prefabs` folder in the Project
    window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Player` prefab as a child of `MyMyselfEye` into your scene Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete or disable the `[CameraRig]` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make the `StartButton` and `StopButton` interactable, add the `Interactable`
    component. Also add the UI `Element` component to handle OnHandClick events, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `StartButton` object in Hierarchy (child of `Dashboard`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Inspector, select Add Component | Scripts | Valve.VR.InteractionSystem |
    Interactable (tip: use the Search field for "Interactable").'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add Component | Scripts | Valve.VR.InteractionSystem | UI Element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector on the UI Element component, press the "+" to add an On Hand Click
    handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `WaterShower` particle system (child of `Hose` object) from Hierarchy
    onto the GameObject field, like we did for the standard Button OnClick event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the ParticleSystem | Play() function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, disable the `RespondToGaze` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, repeat these steps for the `StopButton`, but choose function ParticleSystem
    | Stop().
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also need to move the `Dashboard` closer to yourself so the buttons
    are within comfortable reach when you''re in VR. When you press Play you can now
    reach to touch a button; it highlights. Pull the trigger to press it, as shown
    in the screenshot, and it turns on the hose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29dd7a02-8acd-461d-bc37-21feaf308d48.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Unity UI and Daydream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now take a look at how to do this on a mobile VR device using Google Daydream.
    In this case, we won't actually reach out and press the button but use the 3DOF
    hand controller laser pointer. The solution is as simple as replacing the `GvrReticlePointer`
    (if you had been using it) with a `GvrControllerPointer`.
  prefs: []
  type: TYPE_NORMAL
- en: Under your MeMyselfEye `GVR Camera Rig/ Player / Main Camera /`, if there is
    a GvrReticlePointer, disable it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the GvrControllerPointer in the `GoogleVR/Prefabs/Controller/` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the prefab under Player (as a sibling of Main Camera).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then set up the Dashboard canvas to accept raycasts:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Dashboard object in Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the GvrPointerGraphicRaycaster component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play. You can now use the Daydream controller to press the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Explore the component options for the GvrControllerPointer, its child Laser
    object, and other Gvr object provided with the package. There's some pretty interesting
    and useful configurations available, including settings for laser color, end color,
    and max distance. There's even a checkbox to Draw Debug Rays in the Editor Scene
    window during Play mode.
  prefs: []
  type: TYPE_NORMAL
- en: Building a wrist-based menu palette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some VR applications, designed for two-handed setups such as Oculus Rift, HTC
    Vive, and Windows MR, give you a virtual menu palette attached to one wrist while
    the other hand selects buttons or items from it. Let's see how that is done. *This
    scenario will assume you have a two hand controller VR system.* We'll describe
    it using the SteamVR camera rig, involving attaching the controls to your left
    hand and selecting them with your right.
  prefs: []
  type: TYPE_NORMAL
- en: Converting our dashboard control panel into a wrist palette is not too difficult.
    We just need to scale it appropriately and attach it to the hand controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given you''ve built the scene up to the point described in the previous *Using
    Unity UI and SteamVR *section, including the SteamVR `Player` rig (instead of
    `[CameraRig]`), we''ll duplicate and repurpose the `Dashboard` to use it on your
    left wrist:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, right-click the Dashboard and Duplicate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new one to "Palette".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the old Dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Palette as a child of the Player/Hand1 object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we''ll modify the Palette graphics as follows. Feel free to change for
    what works for you:'
  prefs: []
  type: TYPE_NORMAL
- en: On the Palette itself, set its Pos X,Y,Z to (0, 0.1, -0.1); Rotation to (90,
    -150, -115); Scale (X,Y,Z) to 0.0005;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the Palette and disable or delete the Raw Image object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the Image child object (if it's missing, create a new Image with Anchor
    Presets to stretch-stretch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Image Scale (X,Y,Z) to 0.5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Image Color Alpha to 75 so it's translucent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the Text child object. Set its Rect Transform Top to 100, Font Size to
    18, and Text to "Hose".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the StartButton Pos Y to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the StopButton Pos Y to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it! All of the click wiring we set up for the Dashboard works without
    change. Shown here is a screenshot of using the Palette attached to the left-hand
    controller, and selecting the start button on it with the right-hand controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/453a125e-8442-4dd8-9ef4-8d35a931515e.png)'
  prefs: []
  type: TYPE_IMG
- en: Naturally, the palette can be extended with other buttons and input controls.
    If you had multiple panels arranged as the sides of cube (like the TiltBrush menu),
    you could use the thumb pad to scroll or rotate between the various menus.  And
    that's how it's done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, user interfaces that are based on a canvas object and the event system
    include buttons, text, images, sliders, and input fields, which can be assembled
    and wired to objects in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we took a close look at various world space UI techniques and
    how they can be used in virtual reality projects. We considered ways in which
    UI for VR differs from UI for conventional video games and desktop applications.
    Also, we implemented over a half-dozen of them, demonstrating how each can be
    constructed, coded, and used in your own projects. Our C# scripting got a little
    more advanced, probing deeper into the Unity Engine API and modular coding techniques.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a broader vocabulary to approach UI in your VR projects. Some of
    the examples in this chapter can be directly applicable in your own work. However,
    not all need to be home-grown. VR UI tools are increasingly being provided in
    VR headset SDKs, open source VR middleware projects, and third-party Unity Assets
    Store packages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add a first-person character controller to our
    scene. We'll learn about avatars and methods to control navigation in VR so that
    we can comfortably move around inside the virtual world. Also, we'll learn about
    managing one of the negative aspects of virtual reality experiences—VR motion
    sickness.
  prefs: []
  type: TYPE_NORMAL
