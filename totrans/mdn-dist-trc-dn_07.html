<html><head></head><body>
<div id="_idContainer096">
<h1 class="chapter-number" id="_idParaDest-116"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.2.1">Adding Custom Metrics</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we looked into manual distributed tracing instrumentation, which should help us debug individual operations or analyze service usage with ad hoc queries. </span><span class="koboSpan" id="kobo.3.2">Here, we’ll talk about metrics. </span><span class="koboSpan" id="kobo.3.3">First, we’ll learn when to use them, understand cardinality requirements, and then see how traces and metrics complement each other. </span><span class="koboSpan" id="kobo.3.4">We’ll explore the metrics API’s evolution in .NET and then spend most of this chapter talking about OpenTelemetry metrics. </span><span class="koboSpan" id="kobo.3.5">We’ll cover </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">instruments</span></strong><span class="koboSpan" id="kobo.5.1"> such as counters, gauges, and histograms, and learn about each of them </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">in depth.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">The benefits, limitations, and evolution of metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">in .NET</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">How and when to use </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">different counters</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">How to record and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">use gauges</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">How to record value distribution </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">with histograms</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">By the end of this chapter, you should be able to pick the right instrument for each scenario and implement and use it in your applications to analyze performance, health, </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">and usage.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">The code for this chapter is available in this book’s repository on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter7"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter7</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">To run the samples and perform analysis, we’ll need the </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">following tools:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">.NET SDK 7.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">or later</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">docker-compose</span></strong></span></li>
</ul>
<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.31.1">Metrics in .NET – past and present</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Even though we </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.33.1">are focusing on distributed tracing in this book, learning about metrics is important to understand when and how to use them to </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">improve observability.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Metrics allow us to report data that’s been aggregated over a certain period and set of attributes (that is, dimensions or tags). </span><span class="koboSpan" id="kobo.35.2">A metric can be represented as a set of time series where each series measures the change of one indicator with a unique combination of attribute values over time. </span><span class="koboSpan" id="kobo.35.3">Examples include CPU utilization for a given service instance or HTTP request latency for a given route, HTTP method, response code, </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">and instance.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">The key difference between traces and metrics is aggregation – traces capture individual operations with detailed attributes. </span><span class="koboSpan" id="kobo.37.2">Traces answer questions such as “</span><em class="italic"><span class="koboSpan" id="kobo.38.1">What happened with this specific request?</span></em><span class="koboSpan" id="kobo.39.1">” and “</span><em class="italic"><span class="koboSpan" id="kobo.40.1">Why did it happen?</span></em><span class="koboSpan" id="kobo.41.1">” Metrics, on the other hand, tell us what happens in the system or specific parts of it, how common a failure is, how widespread the performance issue is, and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">Before diving into the use cases, benefits, and APIs of metrics, we first need to learn about the main limitation of metrics – </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">low </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.45.1">cardinality</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.47.1">Cardinality</span></h2>
<p><span class="koboSpan" id="kobo.48.1">Cardinality</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.49.1"> represents number of combinations of unique attributes </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.50.1">or number of time series. </span><span class="koboSpan" id="kobo.50.2">Adding a new attribute causes a combinatorial explosion of a time-series number, which leads to the combinatorial growth of a </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">metric’s volume.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.52.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.53.1">Metrics should have low cardinality, but “low” and “high” are relative – their definition depends on the budget, backend limits, and local </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">memory consumption.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">For example, a relatively big Prometheus instance can support millions of active time series. </span><span class="koboSpan" id="kobo.55.2">If we have 1,000 instances of a service running, and the service exposes four HTTP routes with three methods each and returns five different status codes, we’re going to report 1,000 (instances) * 4 (routes) * 3 (methods) * 5 (status codes) = 60K time series of an HTTP server’s request duration metric (at worst). </span><span class="koboSpan" id="kobo.55.3">If we try to include something such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">customer_id</span></strong><span class="koboSpan" id="kobo.57.1"> attribute and have 1,000 active customers, we’ll start reporting 60M time series for the HTTP server request duration </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">metric only.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">We can still do this by scaling Prometheus horizontally, so reporting a few high-cardinality attributes is still feasible </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">when justified.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.61.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.62.1">Metrics are aggregated in memory before they are exported, so metrics with high cardinality may affect </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">application performance.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">There are no</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.65.1"> limits in terms of attribute cardinality in .NET, but the </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.66.1">OpenTelemetry SDK has configurable limits on the maximum number of metrics and the number of attribute combinations </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">per metric.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.68.1">When to use metrics</span></h2>
<p><span class="koboSpan" id="kobo.69.1">Resource </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.70.1">consumption, low-level communication details, or the number of open connections are best represented by metrics. </span><span class="koboSpan" id="kobo.70.2">In other cases, we have a choice and can report telemetry as metrics, spans, or events. </span><span class="koboSpan" id="kobo.70.3">For example, if we want to measure number of incoming HTTP requests by route, we can query spans that are filtered by service, route, and timestamp. </span><span class="koboSpan" id="kobo.70.4">Should we also report metrics for it? </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">Let’s see.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Metrics are implemented and optimized under the assumption of low cardinality, which enables several </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">important </span></span><span class="No-Break"><a id="_idIndexMarker411"/></span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.75.1">Predictable costs and limited resource consumption</span></strong><span class="koboSpan" id="kobo.76.1">: The metrics’ volume does not grow much as load increases – we only get a new set of time series when the service scales up adding </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">new instances.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.78.1">Low performance impact</span></strong><span class="koboSpan" id="kobo.79.1">: Reporting a single measurement can be done without </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">allocating memory.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">Unbiased usage and performance data</span></strong><span class="koboSpan" id="kobo.82.1">: Metrics are recorded regardless of sampling decisions. </span><span class="koboSpan" id="kobo.82.2">Metrics don’t always report exact data, but we can control their precision by configuring collection intervals and </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">histogram boundaries.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.84.1">Fast and cheap(er) queries</span></strong><span class="koboSpan" id="kobo.85.1">: While observability backends store metrics in different ways and their pricing options vary, metrics are much more compact, which usually </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.86.1">leads to faster ingestion and </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">cheaper queries.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.88.1">Metrics work best when we use them to monitor service health and </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">usage regularly.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">When you want to instrument some operation and are in doubt about which signal to use, the following strategy can help: if you need unbiased data or want to create an alert or a chart on a dashboard, use metrics. </span><span class="koboSpan" id="kobo.90.2">Otherwise, start with tracing and ad hoc queries. </span><span class="koboSpan" id="kobo.90.3">If you find yourself running a lot of similar queries over traces, then add a metric to optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">such queries.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Assuming your tracing backend does not support rich queries, you probably want to be more proactive </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.93.1">in adding metrics. </span><span class="koboSpan" id="kobo.93.2">And if your backend is optimized for high-cardinality data and ad hoc analysis, you might not need </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">metrics much.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Now that we have a rough idea of when we need metrics, let’s dive </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">into instrumentation.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.97.1">Reporting metrics</span></h2>
<p><span class="koboSpan" id="kobo.98.1">There are a few</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.99.1"> different metrics (and counters) APIs in .NET – let’s take a look at them and learn when to </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">use them.</span></span></p>
<h3><span class="koboSpan" id="kobo.101.1">Performance counters</span></h3>
<p><span class="koboSpan" id="kobo.102.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">System.Diagnostics.PerformanceCounter</span></strong><span class="koboSpan" id="kobo.104.1"> class and its friends implement </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.105.1">Windows performance counters. </span><span class="koboSpan" id="kobo.105.2">They don’t support dimensions. </span><span class="koboSpan" id="kobo.105.3">These limitations make performance counters an unlikely choice for a modern distributed system </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">monitoring story.</span></span></p>
<h3><span class="koboSpan" id="kobo.107.1">Event counters</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">System.Diagnostics.Tracing.EventCounter</span></strong><span class="koboSpan" id="kobo.109.1"> is a cross-platform implementation </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.110.1">of a counter, which represents a single time series – we saw it in action in </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.111.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.112.1">, </span><em class="italic"><span class="koboSpan" id="kobo.113.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.114.1">, and </span><a href="B19423_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.115.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.116.1">, </span><em class="italic"><span class="koboSpan" id="kobo.117.1">Low-Level Performance Analysis with Diagnostic Tools</span></em><span class="koboSpan" id="kobo.118.1">, where we collected counters coming from .NET with </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">dotnet-counters</span></strong><span class="koboSpan" id="kobo.120.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">dotnet-monitor</span></strong><span class="koboSpan" id="kobo.122.1">. </span><span class="koboSpan" id="kobo.122.2">OpenTelemetry can listen to them too, converting them into OpenTelemetry metrics and enriching them with </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">resource attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">If you want to report a metric that does not need any dimensions except static context and want to be able to dynamically turn this metric on and off using diagnostics tools, event counters would be a </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">good choice.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">We’re not</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.127.1"> going to dive into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">EventCounter</span></strong><span class="koboSpan" id="kobo.129.1"> API, so please refer to the .NET documentation (</span><a href="https://learn.microsoft.com/dotnet/core/diagnostics/event-counters"><span class="koboSpan" id="kobo.130.1">https://learn.microsoft.com/dotnet/core/diagnostics/event-counters</span></a><span class="koboSpan" id="kobo.131.1">) to find </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">out more.</span></span></p>
<h3><span class="koboSpan" id="kobo.133.1">OpenTelemetry metrics</span></h3>
<p><span class="koboSpan" id="kobo.134.1">The APIs we’re </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.135.1">going to focus on are available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">System.Diagnostics.Metrics</span></strong><span class="koboSpan" id="kobo.137.1"> namespace in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">System.Diagnostics.DiagnosticSource</span></strong><span class="koboSpan" id="kobo.139.1"> NuGet package. </span><span class="koboSpan" id="kobo.139.2">These APIs follow OpenTelemetry’s metrics specification and terminology, except the term “tags” is used instead of “attributes.” </span><span class="koboSpan" id="kobo.139.3">There is no shim </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">for metrics.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">The metrics API supports recording multi-dimensional data using the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">following instruments:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.143.1">Counter</span></strong><span class="koboSpan" id="kobo.144.1">: Represents a value that increments over time – for example, the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">open connections</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.146.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.147.1">: Represents an additive value that increments or decrements over time – for example, the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">active connections</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.149.1">Gauge</span></strong><span class="koboSpan" id="kobo.150.1">: Represents a current value – for example, the sequence number of the last message received from the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">messaging queue</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.152.1">Histogram</span></strong><span class="koboSpan" id="kobo.153.1">: Represents a distribution of value – for example, HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">request latency</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.155.1">Instruments can be created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Meter</span></strong><span class="koboSpan" id="kobo.157.1"> class. </span><span class="koboSpan" id="kobo.157.2">So, first, we need an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">Meter</span></strong><span class="koboSpan" id="kobo.159.1">, which we can create using a name and optional instrumentation version: </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Meter meter = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">new ("sample")</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">The name of </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Meter</span></strong><span class="koboSpan" id="kobo.165.1"> can match the application name, namespace, class, or anything else that makes sense in your case. </span><span class="koboSpan" id="kobo.165.2">It’s used to enable metrics, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">following example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.167.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
using var meterProvider = Sdk.CreateMeterProviderBuilder()
</span><strong class="bold"><span class="koboSpan" id="kobo.169.1">  .AddMeter("queue.*")</span></strong><span class="koboSpan" id="kobo.170.1">
  .AddOtlpExporter()
  .Build()!;</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Program.cs"><span class="koboSpan" id="kobo.171.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.172.1">Here, we enabled all metrics coming from any </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">Meter</span></strong><span class="koboSpan" id="kobo.174.1"> whose name starts with </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">queue.</span></strong><span class="koboSpan" id="kobo.176.1"> (we can use an exact match </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">or wildcards).</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Meter</span></strong><span class="koboSpan" id="kobo.179.1"> is disposable. </span><span class="koboSpan" id="kobo.179.2">In some cases, when you use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Meter</span></strong><span class="koboSpan" id="kobo.181.1"> instance for the application’s</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.182.1"> lifetime, you can make </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Meter</span></strong><span class="koboSpan" id="kobo.184.1"> instances static; otherwise, make sure to dispose of them to disable all </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">nested instruments.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.186.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.187.1">We can listen to metrics directly, without OpenTelemetry, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">System.Diagnostics.Metrics.MeterListener</span></strong><span class="koboSpan" id="kobo.189.1"> class. </span><span class="koboSpan" id="kobo.189.2">It can subscribe to specific instruments and record their measurements. </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">MeterListener</span></strong><span class="koboSpan" id="kobo.191.1"> is used by OpenTelemetry, so you might find it useful to </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">debug instrumentation.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">Now that we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Meter</span></strong><span class="koboSpan" id="kobo.195.1"> instance and configured OpenTelemetry to export metrics, we can create instruments using factory methods on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">Meter</span></strong><span class="koboSpan" id="kobo.197.1"> class; for </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">meter.CreateCounter&lt;long&gt;("connections.open")</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">We’ll see how to create instruments later in this chapter, but for now, here’s a list of common </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">instrument properties:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.203.1">A type parameter</span></strong><span class="koboSpan" id="kobo.204.1"> represents </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.205.1">a value type that must be a primitive number (</span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">byte</span></strong><span class="koboSpan" id="kobo.207.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">short</span></strong><span class="koboSpan" id="kobo.209.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">int</span></strong><span class="koboSpan" id="kobo.211.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">long</span></strong><span class="koboSpan" id="kobo.213.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">float</span></strong><span class="koboSpan" id="kobo.215.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">double</span></strong><span class="koboSpan" id="kobo.217.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">decimal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.221.1">The instrument name</span></strong><span class="koboSpan" id="kobo.222.1"> represents a unique exported metric name; it’s a required property. </span><span class="koboSpan" id="kobo.222.2">OpenTelemetry limits the instrument name to 63 characters and has other limitations. </span><span class="koboSpan" id="kobo.222.3">We’ll talk about it more in </span><a href="B19423_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.223.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.224.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.225.1">Best Practices</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.227.1">A unit</span></strong><span class="koboSpan" id="kobo.228.1"> represents an optional value unit following Unified Code for Units and </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">Measure (</span></span><a href="https://unitsofmeasure.org/"><span class="No-Break"><span class="koboSpan" id="kobo.230.1">https://unitsofmeasure.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.231.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">The description</span></strong><span class="koboSpan" id="kobo.233.1"> is an optional free-form piece of text that briefly describes </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">the instrument.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.235.1">We can create multiple instances of instruments with the same name in the process – the OpenTelemetry SDK aggregates data coming from them into one value. </span><span class="koboSpan" id="kobo.235.2">Instruments are de facto identified by their name, unit, and combination of resource attributes. </span><span class="koboSpan" id="kobo.235.3">So, measurements from multiple instrument instances that share the same identity are aggregated together. </span><span class="koboSpan" id="kobo.235.4">Let’s </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.236.1">explore instruments one by one and learn how to use them, starting </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">with counters.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.238.1">Using counters</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.239.1">Counter</span></strong><span class="koboSpan" id="kobo.240.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.241.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.242.1"> represent </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.243.1">additive values – values that it </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.244.1">makes sense to sum up. </span><span class="koboSpan" id="kobo.244.2">For example, the sum of incoming request counts with different HTTP methods makes sense, but the sum of CPU utilization across different cores </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">does not.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">On the instrumentation side, the only difference between </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">Counter</span></strong><span class="koboSpan" id="kobo.248.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.250.1"> is that the former increases monotonically (or stays the same), while the latter can decrease. </span><span class="koboSpan" id="kobo.250.2">For example, the number of open and closed connections should be represented by </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">Counter</span></strong><span class="koboSpan" id="kobo.252.1">, while the number of active connections should be represented </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">by </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.254.1">UpDownCounter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">Both kinds of counters can be synchronous </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">and asynchronous:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.258.1">Synchronous</span></strong><span class="koboSpan" id="kobo.259.1"> counters report </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.260.1">a delta of value when</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.261.1"> change happens. </span><span class="koboSpan" id="kobo.261.2">For example, once we successfully initiate a new connection, we can increment counters for both open and active connections. </span><span class="koboSpan" id="kobo.261.3">Once we’ve finished terminating a connection, we decrement the number of active </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">connections only.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.263.1">Asynchronous</span></strong><span class="koboSpan" id="kobo.264.1"> (that is, </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">observable</span></strong><span class="koboSpan" id="kobo.266.1">) counters are reported in a callback that’s initiated </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.267.1">periodically </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.268.1">by the OpenTelemetry SDK. </span><span class="koboSpan" id="kobo.268.2">Such instruments return a value at call time. </span><span class="koboSpan" id="kobo.268.3">For example, when reporting the in-memory queue length, we can either use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.270.1"> instrument and increment it when the item is </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.271.1">enqueued and decrement when dequeued or create </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">ObservableUpDownCounter</span></strong><span class="koboSpan" id="kobo.273.1"> and return the queue’s length in </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">a callback.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.275.1">Let’s instrument in-memory queue processing and learn about each instrument as </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">we go.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.277.1">The Counter class</span></h2>
<p><span class="koboSpan" id="kobo.278.1">A</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.279.1"> synchronous </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.280.1">counter is implemented in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">System.Diagnostics.Metrics.Counter</span></strong><span class="koboSpan" id="kobo.282.1"> class. </span><span class="koboSpan" id="kobo.282.2">We’ll use it to keep track of the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">enqueued items:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.284.1">Producer.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
private static Meter Meter = new("queue.producer");
private static Counter&lt;long&gt; EnqueuedCounter =
  Meter.CreateCounter&lt;long&gt;("queue.enqueued.count",
    "{count}",
    "Number of enqueued work items");</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs"><span class="koboSpan" id="kobo.286.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs</span></a></p>
<p><span class="koboSpan" id="kobo.287.1">Here, we created an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">Meter</span></strong><span class="koboSpan" id="kobo.289.1"> class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">queue.producer</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">It’s static here because we never need to disable corresponding instruments. </span><span class="koboSpan" id="kobo.291.3">Then, we created a static counter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">queue.enqueue.count</span></strong><span class="koboSpan" id="kobo.293.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">long</span></strong><span class="koboSpan" id="kobo.295.1"> type parameter, with the unit set </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">{count}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">We also need to increment it every time an item is enqueued. </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Counter</span></strong><span class="koboSpan" id="kobo.301.1"> exposes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">Add</span></strong><span class="koboSpan" id="kobo.303.1"> method to record a positive delta; it has several overloads to pass zero or more attributes. </span><span class="koboSpan" id="kobo.303.2">In our sample, we have multiple queues and pass </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">queue names:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.305.1">Producer.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
EnqueuedCounter.Add(1,
  new KeyValuePair&lt;string, object?&gt;("queue", _queueName))</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs"><span class="koboSpan" id="kobo.307.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs</span></a></p>
<p><span class="koboSpan" id="kobo.308.1">Let’s run the sample application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">metrics$ docker-compose up --build</span></strong><span class="koboSpan" id="kobo.310.1"> and open the metrics endpoint on OpenTelemetry Collector at </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">http://localhost:8889/metrics</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">We should see </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">queue_enqueued_count_total</span></strong><span class="koboSpan" id="kobo.314.1"> among other metrics in the Prometheus </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">exposition format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
# HELP queue_enqueued_count_total Number of enqueued work items
# TYPE queue_enqueued_count_total counter
queue_enqueued_count_total{job="metrics ",queue="add"} 323
queue_enqueued_count_total{job="metrics ",queue="remove"} 323</span></pre>
<p><span class="koboSpan" id="kobo.317.1">Here, we </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.318.1">can see </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.319.1">the description, along with the instrument’s type, followed by a list of all attribute combinations and the latest reported </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">counter values.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">We can also visualize this counter in Prometheus (at </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">http://localhost:9090</span></strong><span class="koboSpan" id="kobo.323.1">). </span><span class="koboSpan" id="kobo.323.2">Usually, we are interested in rates or trends, and not the absolute value of a counter. </span><span class="koboSpan" id="kobo.323.3">For example, the rate at which items are enqueued would be a good indication of producer load </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">and performance.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">We can get this by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">sum by (queue) (rate(queue_enqueued_count_total[1m]))</span></strong><span class="koboSpan" id="kobo.327.1"> query – Prometheus calculates the rate per second (and averages it over 1 minute), then sums up values by grouping them by queue name across application instances. </span><span class="koboSpan" id="kobo.327.2">The corresponding chart is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.328.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.329.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.331.1"><img alt="Figure 7.1 – Enqueue rate per second grouped by queue name" src="image/Figure_7.01_B19423.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.332.1">Figure 7.1 – Enqueue rate per second grouped by queue name</span></p>
<p><span class="koboSpan" id="kobo.333.1">Here, we can see that we enqueue items at around 16 items per second to each queue. </span><span class="koboSpan" id="kobo.333.2">Instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">sum</span></strong><span class="koboSpan" id="kobo.335.1">, we could use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">min</span></strong><span class="koboSpan" id="kobo.337.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">max</span></strong><span class="koboSpan" id="kobo.339.1"> operators to see whether there are application instances that </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">stand out.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Counters, along with other instruments, expose an </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Enabled</span></strong><span class="koboSpan" id="kobo.343.1"> flag, which indicates whether there are any listeners for this instrument. </span><span class="koboSpan" id="kobo.343.2">Meters are not enabled by default and the specific instrument could be disabled, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Enabled</span></strong><span class="koboSpan" id="kobo.345.1"> flag should be used to guard any additional work necessary for metric reporting. </span><span class="koboSpan" id="kobo.345.2">It’s really important for native instrumentations, where end users of such libraries may or may not have metrics enabled and the </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.346.1">goal is </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.347.1">to have zero performance impact when metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">are disabled.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">Other properties that are exposed on the instruments include </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Name</span></strong><span class="koboSpan" id="kobo.351.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Unit</span></strong><span class="koboSpan" id="kobo.353.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Description</span></strong><span class="koboSpan" id="kobo.355.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">Meter</span></strong><span class="koboSpan" id="kobo.357.1">, which we used to create </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">this instrument.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.359.1">The UpDownCounter class</span></h2>
<p><span class="koboSpan" id="kobo.360.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">System.Diagnostics.Metrics.UpDownCounter</span></strong><span class="koboSpan" id="kobo.362.1"> class is very similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Counter</span></strong><span class="koboSpan" id="kobo.364.1"> in</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.365.1"> terms </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.366.1">of the API. </span><span class="koboSpan" id="kobo.366.2">You can create one with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">CreateUpDownCounter</span></strong><span class="koboSpan" id="kobo.368.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Meter</span></strong><span class="koboSpan" id="kobo.370.1"> instance by providing an instrument name, along with an optional unit and description. </span><span class="koboSpan" id="kobo.370.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.372.1"> class exposes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Add</span></strong><span class="koboSpan" id="kobo.374.1"> method, which takes a delta of the measured value and zero or more tags. </span><span class="koboSpan" id="kobo.374.2">It also exposes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">Enabled</span></strong><span class="koboSpan" id="kobo.376.1"> flag and the properties the instrument was created with, such as its name, unit, </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">and description.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">On the consumption side, however, </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.380.1"> is different. </span><span class="koboSpan" id="kobo.380.2">It’s not monotonic and maps</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.381.1"> to</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.382.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">gauge</span></strong><span class="koboSpan" id="kobo.384.1"> type in Prometheus. </span><span class="koboSpan" id="kobo.384.2">We’ll learn more about it in </span><em class="italic"><span class="koboSpan" id="kobo.385.1">The ObservableUpDownCounter </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.386.1">class</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.387.1"> section.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.388.1">The ObservableCounter class</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">System.Diagnostics.Metrics.ObservableCounter</span></strong><span class="koboSpan" id="kobo.390.1"> implements an asynchronous</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.391.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">Counter</span></strong><span class="koboSpan" id="kobo.393.1">. </span><span class="koboSpan" id="kobo.393.2">There is no difference </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.394.1">between synchronous and asynchronous counters on the consumption side. </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">ObservableCounter</span></strong><span class="koboSpan" id="kobo.396.1"> just provides a more convenient way to record counters in a callback </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">executed periodically.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">For example, the number of completed (by the thread pool) tasks (</span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">process.runtime.dotnet.thread_pool.completed_items.count</span></strong><span class="koboSpan" id="kobo.400.1">) available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">OpenTelemetryInstrumentation.Runtime</span></strong><span class="koboSpan" id="kobo.402.1"> NuGet package is implemented as </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">ObservableCounter</span></strong><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">On every call, it returns the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">ThreadPool.CompletedWorkItems</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">We can create an observable counter with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">CreateObservableCounter</span></strong><span class="koboSpan" id="kobo.409.1"> method: </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Meter.CreateObservableCounter&lt;long&gt;("my.counter", GetValue)</span></strong><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">Here, in addition to the name, we pass a lambda function – </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">GetValue</span></strong><span class="koboSpan" id="kobo.413.1"> – which returns the current value of </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">the counter.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">It’s executed when metrics are about to be exported. </span><span class="koboSpan" id="kobo.415.2">In our application, this happens every 5 seconds, while the default period for the OTLP exporter is 60 seconds. </span><span class="koboSpan" id="kobo.415.3">We configured it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">OTEL_METRIC_EXPORT_INTERVAL</span></strong><span class="koboSpan" id="kobo.417.1"> environment variable, but it’s also possible to set it explicitly with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">PeriodicExportingMetricReaderOptions.ExportIntervalMilliseconds</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.419.1"> property:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">ExplicitConfiguration.cs</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.421.1">AddOtlpExporter((exporterOptions, readerOptions) =&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.422.1">  readerOptions.PeriodicExportingMetricReaderOptions</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.423.1">    .ExportIntervalMilliseconds = 5000)</span></strong></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/ExplicitConfiguration.cs"><span class="koboSpan" id="kobo.424.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/ExplicitConfiguration.cs</span></a></p>
<p><span class="koboSpan" id="kobo.425.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">ExportIntervalMilliseconds</span></strong><span class="koboSpan" id="kobo.427.1"> property controls how frequently counter values are collected, so it controls the precision and volume of individual </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">time series.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">This configuration does not affect pull-based exporters such as Prometheus, where it’s controlled externally (for example, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">scrape_interval</span></strong><span class="koboSpan" id="kobo.431.1"> parameter on the Prometheus instance). </span><span class="koboSpan" id="kobo.431.2">In our sample application, we have the OTLP exporter, which is push-based and sends metrics to OpenTelemetry Collector. </span><span class="koboSpan" id="kobo.431.3">Collector then exposes metrics on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">http://localhost:8889/metrics</span></strong><span class="koboSpan" id="kobo.433.1"> endpoint, where Prometheus scrapes </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">them from.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ObservableCounter</span></strong><span class="koboSpan" id="kobo.437.1">, we can only record data using the callback provided at start time, and there are several overloads of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">CreateObservableCounter</span></strong><span class="koboSpan" id="kobo.439.1"> method that allow us to report the metric’s value, along with its attributes (via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">Measurement</span></strong><span class="koboSpan" id="kobo.441.1"> struct) or </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.442.1">as a </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.443.1">list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Measurement</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1"> instances.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">There are several important things to know about </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">the callback:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.448.1">Unlike the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Counter.Add</span></strong><span class="koboSpan" id="kobo.450.1"> method, it reports an absolute value of </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the counter.</span></span></li>
<li><span class="koboSpan" id="kobo.452.1">It should finish in a reasonable amount of time. </span><span class="koboSpan" id="kobo.452.2">We can configure the timeout similarly to the export interval with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">OTEL_METRIC_EXPORT_TIMEOUT</span></strong><span class="koboSpan" id="kobo.454.1"> environment variable or the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">PeriodicExportingMetricReaderOptions.ExportTimeoutMilliseconds</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.456.1"> property.</span></span></li>
<li><span class="koboSpan" id="kobo.457.1">The callback should not return multiple measurements for the same set of attributes. </span><span class="koboSpan" id="kobo.457.2">The OpenTelemetry SDK’s behavior is not defined for </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">this case.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.459.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.460.1">These requirements are from the OpenTelemetry specification. </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">MeterListener</span></strong><span class="koboSpan" id="kobo.462.1"> does not enforce any </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">To unsubscribe from observable counters, we must dispose of the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Meter</span></strong><span class="koboSpan" id="kobo.466.1"> instance. </span><span class="koboSpan" id="kobo.466.2">So, if the counter relies on any instance data and belongs to an object with a limited lifetime, we must create </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">Meter</span></strong><span class="koboSpan" id="kobo.468.1"> as an instance variable and dispose of it, along with the object it </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.469.1">belongs to. </span><span class="koboSpan" id="kobo.469.2">Let’s see an example of </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.470.1">this </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">ObservableUpDownCounter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.474.1">The ObservableUpDownCounter class</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">System.Diagnostics.Metrics.ObservableUpDownCounter</span></strong><span class="koboSpan" id="kobo.476.1"> represents an asynchronous</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.477.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">Its </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.480.1">creation is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">ObservableCounter</span></strong><span class="koboSpan" id="kobo.482.1">, but its consumption side </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">matches </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">UpDownCounter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">We’ll use it to report queue length – it should give us a good indication of processor throughput and whether it processes items </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">fast enough.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">The queue length is not monotonic – it can go up and down, so a regular counter would not work. </span><span class="koboSpan" id="kobo.488.2">We could track it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.490.1">: we could increment it when enqueueing an item and decrement when dequeuing. </span><span class="koboSpan" id="kobo.490.2">But if we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">ObservableUpDownCounter</span></strong><span class="koboSpan" id="kobo.492.1">, we’ll achieve the same more frugally by only returning the queue length every </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">few seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">In a more complicated case of a distributed queue, we might not be able to instrument both the producer and consumer and would need to periodically get the current distributed queue length with a network call to the broker (be careful if you decide to do this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">counter callback).</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">Let’s implement the queue length counter. </span><span class="koboSpan" id="kobo.496.2">First, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Processor</span></strong><span class="koboSpan" id="kobo.498.1"> class is disposable, so we should assume it can die before the application ends. </span><span class="koboSpan" id="kobo.498.2">It’s important to disable all the instruments when this happens – we need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">Meter</span></strong><span class="koboSpan" id="kobo.500.1"> as an instance variable and create </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">the counter:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.502.1">Processor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
_queueNameTag = new KeyValuePair&lt;string, object?&gt;("queue",
   queueName);
_meter = new Meter("queue.processor");
_queueLengthCounter = _meter
  </span><strong class="bold"><span class="koboSpan" id="kobo.504.1">.CreateObservableUpDownCounter(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.505.1">    "queue.length",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.506.1">    () =&gt; new Measurement&lt;int&gt;(queue.Count, _queueNameTag),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.507.1">    "{items}",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.508.1">    "Queue length");</span></strong></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs"><span class="koboSpan" id="kobo.509.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.510.1">Here, we created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">ObservableUpDownCounter</span></strong><span class="koboSpan" id="kobo.512.1"> instance with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">queue.length</span></strong><span class="koboSpan" id="kobo.514.1"> name and configured it to report the length in a callback, along with the queue name attribute. </span><span class="koboSpan" id="kobo.514.2">The last thing we need to do is to dispose of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Meter</span></strong><span class="koboSpan" id="kobo.516.1"> instance, along with the processor, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">_meter.Dispose()</span></strong><span class="koboSpan" id="kobo.518.1"> method. </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">That’s it!</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">Start the sample application (unless it’s still running) with </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">metrics$ docker-compose up --build</span></strong><span class="koboSpan" id="kobo.522.1"> and </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.523.1">check </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.524.1">out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">queue_length</span></strong><span class="koboSpan" id="kobo.526.1"> metric (at </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">http://localhost:8889/metrics</span></strong><span class="koboSpan" id="kobo.528.1">). </span><span class="koboSpan" id="kobo.528.2">You should see it, among </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">other metrics:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
# HELP queue_length Queue length
# TYPE queue_length gauge
queue_length{job="metrics",queue="add"} 2
queue_length{job="metrics",queue="remove"} 0
queue_length{job="metrics",queue="update"} 157</span></pre>
<p><span class="koboSpan" id="kobo.531.1">As you can see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">UpDownCounter</span></strong><span class="koboSpan" id="kobo.533.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">ObservableUpDownCounter</span></strong><span class="koboSpan" id="kobo.535.1"> are both mapped to gauge Prometheus – we’ll learn more about gauges in the </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">We can visualize this metric in the Prometheus UI (at </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">http://localhost:9090</span></strong><span class="koboSpan" id="kobo.539.1">) with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">avg by (queue) (queue_length)</span></strong><span class="koboSpan" id="kobo.541.1"> query, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.542.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.543.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.545.1"><img alt="Figure 7.2 – Average queue length per queue" src="image/Figure_7.02_B19423.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.546.1">Figure 7.2 – Average queue length per queue</span></p>
<p><span class="koboSpan" id="kobo.547.1">By looking at this chart, we can say that </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.548.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">update</span></strong><span class="koboSpan" id="kobo.550.1"> queue grows linearly while the other queues remain almost empty. </span><span class="koboSpan" id="kobo.550.2">We don’t need any complicated queries here because we’re </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.551.1">interested in absolute values as we expect</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.552.1"> the queue length to always </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">be small.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">Let’s learn about other instruments – gauges and histograms – and investigate what happens with the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.555.1">update</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1"> queue.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.557.1">Using an asynchronous gauge</span></h1>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">System.Diagnostics.Metrics.ObservableGauge</span></strong><span class="koboSpan" id="kobo.559.1"> represents the current value of a </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.560.1">non-additive metric. </span><span class="koboSpan" id="kobo.560.2">There is only an asynchronous version </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">The key difference with </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">ObservableUpdownCounter</span></strong><span class="koboSpan" id="kobo.564.1"> is that the counter is additive. </span><span class="koboSpan" id="kobo.564.2">For example, with counters, if we have multiple metric points for the same counter name, at the same timestamp, and with the same attributes, we can just add them up. </span><span class="koboSpan" id="kobo.564.3">For gauge, aggregation makes no sense and OpenTelemetry uses the last </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">reported value.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">When exported to Prometheus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">ObservableGauge</span></strong><span class="koboSpan" id="kobo.568.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">ObservableUpdownCounter</span></strong><span class="koboSpan" id="kobo.570.1"> are the same, but their OTLP definitions (over-the-wire formats) </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">are different.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.572.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.573.1">You can get an idea of the internal representation of metric points on the OpenTelemetry side by enabling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">ConsoleExporter</span></strong><span class="koboSpan" id="kobo.575.1"> output or looking into the OpenTelemetry documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">at </span></span><a href="https://opentelemetry.io/docs/reference/specification/overview/#metrics-data-model-and-sdk"><span class="No-Break"><span class="koboSpan" id="kobo.577.1">https://opentelemetry.io/docs/reference/specification/overview/#metrics-data-model-and-sdk</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.578.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">ObservableGauge</span></strong><span class="koboSpan" id="kobo.581.1"> to report a sequence number for the last processed item. </span><span class="koboSpan" id="kobo.581.2">It’s useful with distributed queues, where the sequence number (or offset) represents the unique and ordered position of the item in </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">By looking at sequence number trends, we can estimate how many items are processed and how fast they are processed. </span><span class="koboSpan" id="kobo.583.2">For example, if the processor is stuck trying to process an invalid work </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.584.1">item, we’d see that the sequence number is </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">not increasing.</span></span></p>
<p><span class="koboSpan" id="kobo.586.1">Adding up sequence numbers from different queues make no sense, so it should be an </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">ObservableGauge</span></strong><span class="koboSpan" id="kobo.588.1">, which we can create using a </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">familiar API:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.590.1">Processor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
_sequenceNumberGauge = _meter
  .CreateObservableGauge(
    "processor.last_sequence_number",
    () =&gt; new Measurement&lt;long&gt;(_seqNo, _queueNameTag),
    null,
    "Sequence number of the last dequeued item");</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs"><span class="koboSpan" id="kobo.592.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.593.1">In the callback, we return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">_seqNo</span></strong><span class="koboSpan" id="kobo.595.1"> instance variable, which we update after dequeuing the work item. </span><span class="koboSpan" id="kobo.595.2">The only thing we need here is thread safety; we don’t need precision since data is </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">collected periodically.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">We can report values with zero or more attributes or multiple measurements at once, so long as they have </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">different attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">If we run the sample application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">metrics$ docker-compose up --build</span></strong><span class="koboSpan" id="kobo.601.1">, we can check the sequence number in Prometheus with a query such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">delta(processor_last_sequence_number[1m])</span></strong><span class="koboSpan" id="kobo.603.1">. </span><span class="koboSpan" id="kobo.603.2">It returns the delta per minute and is </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.604.1">shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.605.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.606.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.608.1"><img alt="Figure 7.3 – Sequence number delta per minute" src="image/Figure_7.03_B19423.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.609.1">Figure 7.3 – Sequence number delta per minute</span></p>
<p><span class="koboSpan" id="kobo.610.1">As we can see, after the application starts, the delta stabilizes around 3,000 items per minute </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.611.1">in the </span><strong class="bold"><span class="koboSpan" id="kobo.612.1">add</span></strong><span class="koboSpan" id="kobo.613.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.614.1">remove</span></strong><span class="koboSpan" id="kobo.615.1"> queues, and 2,500 items in the </span><strong class="bold"><span class="koboSpan" id="kobo.616.1">update</span></strong><span class="koboSpan" id="kobo.617.1"> queue. </span><span class="koboSpan" id="kobo.617.2">This</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.618.1"> correlates with what we saw with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">queue_length</span></strong><span class="koboSpan" id="kobo.620.1"> counter – the </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">update</span></strong><span class="koboSpan" id="kobo.622.1"> queue is not processed fast enough. </span><span class="koboSpan" id="kobo.622.2">By looking at metrics, we can’t say why, but there is one that can cast some light on it – the processing duration. </span><span class="koboSpan" id="kobo.622.3">Let’s take a look </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">at it.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.624.1">Using histograms</span></h1>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">System.Diagnostics.Metrics.Histogram</span></strong><span class="koboSpan" id="kobo.626.1"> represents a distribution of values – for example, the operation </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.627.1">duration or payload size. </span><span class="koboSpan" id="kobo.627.2">Histograms can only be reported synchronously as each measurement is important. </span><span class="koboSpan" id="kobo.627.3">As we saw in </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.628.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.629.1">, </span><em class="italic"><span class="koboSpan" id="kobo.630.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.631.1">, they allow us to calculate percentiles at </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">query time.</span></span></p>
<p><span class="koboSpan" id="kobo.633.1">We’ll use a histogram to record the processing duration in </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">our example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.635.1">Processor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.636.1">
_processingDurationHistogram = _meter
  .CreateHistogram&lt;double&gt;(
    "processor.processing.duration",
    "ms",
    "Item processing duration");</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs"><span class="koboSpan" id="kobo.637.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.638.1">Every time we process an item from the queue, we should measure and record the time </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">it took:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.640.1">Processor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.641.1">
Stopwatch? </span><span class="koboSpan" id="kobo.641.2">duration = _processingDurationHistogram
  .Enabled ? </span><span class="koboSpan" id="kobo.641.3">Stopwatch.StartNew() : null;
var status = await Process(item);
if (duration != null)
  _processingDurationHistogram.Record(
    duration.Elapsed.TotalMilliseconds,
    _queueNameTag,
    new KeyValuePair&lt;string, object?&gt;("status",
      StatusToString(status)));</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs"><span class="koboSpan" id="kobo.642.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.643.1">Here, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">Enabled</span></strong><span class="koboSpan" id="kobo.645.1"> flag – when metrics are not enabled, it prevents us from allocating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">Stopwatch</span></strong><span class="koboSpan" id="kobo.647.1"> object on </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">the heap.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">The recording method has multiple overloads to report zero or more attributes associated with this value. </span><span class="koboSpan" id="kobo.649.2">Here, we report the queue name and the processing status. </span><span class="koboSpan" id="kobo.649.3">The status has low cardinality – it’s an </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">enum</span></strong><span class="koboSpan" id="kobo.651.1"> with a </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">few values.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">We also want to stay as efficient as possible, so we implemented the optimal and non-allocating </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">StatusToString</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">Let’s run the application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">metrics$ docker-compose up --build</span></strong><span class="koboSpan" id="kobo.658.1"> and check out how the histogram looks in Prometheus exposition format (at </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">http://localhost:8889/metrics</span></strong><span class="koboSpan" id="kobo.660.1">). </span><span class="koboSpan" id="kobo.660.2">You should see a set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">processor_processing_duration_milliseconds_bucket</span></strong><span class="koboSpan" id="kobo.662.1"> points for each queue, status, </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">and bucket.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">For example, this is </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.665.1">what I see for the </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">add</span></strong><span class="koboSpan" id="kobo.667.1"> queue with a status of </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">Ok</span></strong><span class="koboSpan" id="kobo.669.1"> (attributes and some buckets have been omitted </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">for brevity):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
processor_processing_duration_milliseconds_bucket{le="0"} 0
...
</span><span class="koboSpan" id="kobo.671.2">processor_processing_duration_milliseconds_bucket{le="50"} 27
processor_processing_duration_milliseconds_bucket{le="75"} 52
processor_processing_duration_milliseconds_bucket{le="100"} 67
processor_processing_duration_milliseconds_bucket{le="250"} 72
...
</span><span class="koboSpan" id="kobo.671.3">processor_processing_duration_milliseconds_bucket{le="+Inf"} 72
processor_processing_duration_milliseconds_sum
  4145.833300000001
processor_processing_duration_milliseconds_count 72</span></pre>
<p><span class="koboSpan" id="kobo.672.1">Each bucket is identified by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">le</span></strong><span class="koboSpan" id="kobo.674.1"> attribute – the inclusive upper boundary. </span><span class="koboSpan" id="kobo.674.2">There were 27 measurements smaller than or equal to 50 milliseconds, 52 measurements that were smaller than 75 milliseconds, and so on. </span><span class="koboSpan" id="kobo.674.3">Overall, there were 72 measurements, and the sum of all durations was around </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">4,146 milliseconds.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">OTLP format defines a few more interesting properties that we can’t </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">see here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.678.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">min</span></strong><span class="koboSpan" id="kobo.680.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">max</span></strong><span class="koboSpan" id="kobo.682.1"> values for each bucket – they are not supported by Prometheus but show</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.683.1"> up in </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">OTLP data.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.685.1">Exemplars</span></strong><span class="koboSpan" id="kobo.686.1">, which represent examples of traces in a bucket. </span><span class="koboSpan" id="kobo.686.2">We could use them to easily navigate from metrics to traces and investigate long processing operations in higher histogram buckets. </span><span class="koboSpan" id="kobo.686.3">They are not implemented in OpenTelemetry for .</span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">NET yet.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.688.1">The bucket boundaries we can see here are the default ones. </span><span class="koboSpan" id="kobo.688.2">They are static and work best if the measured value is well within the [0, 10000] range. </span><span class="koboSpan" id="kobo.688.3">If we start to measure values in the [10,000, 20,000] range, every measurement would be in the last two buckets, making the percentile calculation invalid. </span><span class="koboSpan" id="kobo.688.4">In this case, we should set explicit boundaries for</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.689.1"> corresponding histograms with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">MeterProviderBuilder.AddView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.691.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">In the future, OpenTelemetry will allow us to use exponential histograms with dynamic boundaries adjusted </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">to data.</span></span></p>
<p><span class="koboSpan" id="kobo.694.1">Note that we also have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">processor_processing_duration_milliseconds_sum</span></strong><span class="koboSpan" id="kobo.696.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">processor_processing_duration_milliseconds_count</span></strong><span class="koboSpan" id="kobo.698.1"> metrics, so by reporting only the histogram, we get percentiles, averages, and </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">measurement counters.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">We can get the median processing time with the </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">following query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.702.1">
histogram_quantile(0.5, sum(rate(processor_processing_duration_milliseconds_bucket{status="Ok"}[1m])) by (le, queue))</span></pre>
<p><span class="koboSpan" id="kobo.703.1">This should produce the chart shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.704.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.705.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.707.1"><img alt="Figure 7.4 – Median processing time per queue" src="image/Figure_7.04_B19423.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.708.1">Figure 7.4 – Median processing time per queue</span></p>
<p><span class="koboSpan" id="kobo.709.1">Here, we can see </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.710.1">that the median processing time for the </span><strong class="bold"><span class="koboSpan" id="kobo.711.1">add</span></strong><span class="koboSpan" id="kobo.712.1"> queue is around 61 milliseconds, 48 milliseconds for the </span><strong class="bold"><span class="koboSpan" id="kobo.713.1">remove</span></strong><span class="koboSpan" id="kobo.714.1"> queue, and 75 milliseconds for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.715.1">update</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1"> queue.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">Let’s also check the processing rate using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">sum by (queue) (rate(processor_processing_duration_milliseconds_count[1m]))</span></strong><span class="koboSpan" id="kobo.719.1"> query, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.720.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.721.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.723.1"><img alt="Figure 7.5 – Processing rate per queue" src="image/Figure_7.05_B19423.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.724.1">Figure 7.5 – Processing rate per queue</span></p>
<p><span class="koboSpan" id="kobo.725.1">Items from the </span><strong class="bold"><span class="koboSpan" id="kobo.726.1">update</span></strong><span class="koboSpan" id="kobo.727.1"> queue are processed at a rate of about 14 items per second; the enqueue rate is ~16 items per second, as we saw in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.728.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.729.1">.1</span></em><span class="koboSpan" id="kobo.730.1">. </span><span class="koboSpan" id="kobo.730.2">This should explain why the </span><strong class="bold"><span class="koboSpan" id="kobo.731.1">update</span></strong><span class="koboSpan" id="kobo.732.1"> queue </span><a id="_idIndexMarker462"/><span class="No-Break"><span class="koboSpan" id="kobo.733.1">is growing:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.734.1">Processing takes too much time – we should try to optimize it so that it targets at least 60 milliseconds to be able to process 16 items </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">per second.</span></span></li>
<li><span class="koboSpan" id="kobo.736.1">If optimization is not possible (or is not enough), we know that we need to process an extra 2-3 items per second, so we need ~20% more </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">processor instances.</span></span></li>
<li><span class="koboSpan" id="kobo.738.1">We could also implement backpressure on the producer side and throttle </span><strong class="bold"><span class="koboSpan" id="kobo.739.1">update</span></strong><span class="koboSpan" id="kobo.740.1"> requests to decrease the enqueue rate on </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">the processor.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.742.1">With just a small set of metrics, we were able to narrow down the problem to a specific area. </span><span class="koboSpan" id="kobo.742.2">If it was a</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.743.1"> production incident, we’d be able to quickly mitigate it by scaling the number of processors up and then investigating </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">other options.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.745.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.746.1">In this chapter, we explored metrics in .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">and OpenTelemetry.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">Metrics allow us to collect aggregated multi-dimensional data. </span><span class="koboSpan" id="kobo.748.2">They produce unbiased telemetry with a predictable volume at any scale and allow us to monitor system health, performance, </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">and usage.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">Metrics can’t have high-cardinality attributes, so we can’t use them to detect problems that happen in specific and narrow cases – for this, we need distributed tracing or events. </span><span class="koboSpan" id="kobo.750.2">.NET provides an OpenTelemetry metrics implementation that consists of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">Meter</span></strong><span class="koboSpan" id="kobo.752.1"> class, which can create specific instruments: counters, gauges, </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">and histograms.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">Counters are used to report additive values and can be synchronous or asynchronous. </span><span class="koboSpan" id="kobo.754.2">Gauges report current, non-additive values asynchronously, while histograms report </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">value distribution.</span></span></p>
<p><span class="koboSpan" id="kobo.756.1">With this, you should be able to identify scenarios where metrics are beneficial, choose appropriate instruments, and efficiently report metrics in your application. </span><span class="koboSpan" id="kobo.756.2">You should also be able to configure OpenTelemetry, and, most importantly, start detecting and monitoring </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">performance issues.</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">In the next chapter, we’re going to look at structured logs and events and learn how to write and consume them efficiently using .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">and OpenTelemetry.</span></span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.760.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.761.1">Let’s say you want to track the number of meme downloads (from our meme sample applications). </span><span class="koboSpan" id="kobo.761.2">Which telemetry signals would you </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">choose? </span><span class="koboSpan" id="kobo.762.2">Why?</span></span></li>
<li><span class="koboSpan" id="kobo.763.1">When reporting HTTP request duration, would you report it as a span, metric, </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">or both?</span></span></li>
<li><span class="koboSpan" id="kobo.765.1">How would you monitor the number of active application instances and </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">the uptime?</span></span></li>
</ol>
</div>
</body></html>