- en: Chapter 2. Looking at Multithreaded Classes – BackgroundWorker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 查看多线程类 – BackgroundWorker
- en: C# offers a variety of ways to create and control threads in our applications.
    There are the `Thread` and `ThreadPool` classes, the **Task Parallel Library**
    (**TPL**), the `Async` methods, and the `BackgroundWorker` component. The `BackgroundWorker`
    is the original way of doing multiple things at once in C# and, to many, it has
    become passé and `Tasks` and `Threads` are now the preferred method. But for simple
    multithreaded needs, `BackgroundWorker` is an extremely handy and easy-to-use
    way to accomplish multiple things at once.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了多种在应用程序中创建和控制线程的方法。有 `Thread` 和 `ThreadPool` 类、**任务并行库** (**TPL**)、`Async`
    方法以及 `BackgroundWorker` 组件。`BackgroundWorker` 是在 C# 中同时做很多事情的原始方式，对许多人来说，它已经过时了，现在
    `Tasks` 和 `Threads` 是首选方法。但对于简单的多线程需求，`BackgroundWorker` 是一种极其方便且易于使用的实现同时做很多事情的方式。
- en: 'In this chapter, we will study this component in detail, and we will begin
    developing multithreaded applications that take full advantage of multiprocessing.
    After reading this and following the exercises, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细研究这个组件，并将开始开发充分利用多处理的多线程应用程序。阅读本章并完成练习后，我们将：
- en: Develop applications that are able to execute tasks in the background while
    keeping alive the graphical user interface, offering the user a more real-life
    experience
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发能够在后台执行任务的同时保持图形用户界面活跃的应用程序，为用户提供更真实的生活体验
- en: Learn to create independent threads using a simple component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用简单组件创建独立线程
- en: Understand the differences between synchronous and asynchronous execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同步和异步执行之间的区别
- en: Develop applications that are able to show the progress of their many concurrent
    running tasks in the graphical user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发能够在图形用户界面中显示许多并发运行任务进度的应用程序
- en: Learn to start and cancel background tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何启动和取消后台任务
- en: Develop applications capable of launching multiple background tasks when necessary
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发在必要时能够启动多个后台任务的应用程序
- en: Getting started with the BackgroundWorker component
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BackgroundWorker 组件入门
- en: Since the introduction of .NET 2.0 (C# 2005), a new component has become a part
    of Visual C# that simplifies the execution of tasks in independent threads, separated
    from the main thread. It is the `BackgroundWorker` component (`System.ComponentModel.BackgroundWorker`),
    and it allows us to begin working with many threads and taking advantage of parallelism
    with very little effort.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 .NET 2.0 (C# 2005) 的引入以来，一个新的组件已经成为 Visual C# 的一部分，它简化了在独立线程中执行任务的过程，这些线程与主线程分离。它是
    `BackgroundWorker` 组件 (`System.ComponentModel.BackgroundWorker`)，它允许我们以非常少的努力开始使用多个线程并利用并行性。
- en: One of the main advantages of components in C# and the .NET working environment
    is the possibility to define their properties, values, and events in design time
    without the need to write lots of code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C# 和 .NET 工作环境中的组件的主要优势之一是，在设计时可以定义它们的属性、值和事件，而无需编写大量代码。
- en: 'Unfortunately, the `BackgroundWorker` component is not a **Windows Presentation
    Foundation** (**WPF**) component. As you can see in the following screenshot,
    in a Windows Form application, it is available in **Toolbox** under **Components**:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`BackgroundWorker` 组件不是一个 **Windows Presentation Foundation** (**WPF**)
    组件。正如您在下面的屏幕截图中所见，在一个 Windows Form 应用程序中，它位于 **工具箱** 下的 **组件** 中：
- en: '![Getting started with the BackgroundWorker component](img/8321EN_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![使用BackgroundWorker组件入门](img/8321EN_02_01.jpg)'
- en: 'In a WPF application, it is not available, as shown:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中，它不可用，如下所示：
- en: '![Getting started with the BackgroundWorker component](img/8321EN_02_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![使用BackgroundWorker组件入门](img/8321EN_02_02.jpg)'
- en: 'This does not mean that it is not available in WPF. It just means that you
    will need to implement it completely in code instead of being able to manipulate
    it in the **Designer** view. To declare a `BackgroundWorker` instance in WPF,
    we simply add the following `using` statement:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着它在 WPF 中不可用。这只意味着您将需要完全通过代码来实现它，而不是能够在 **设计器** 视图中操作它。要在 WPF 中声明一个 `BackgroundWorker`
    实例，我们只需添加以下 `using` 语句：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Historically, multithreaded programming terrified developers because of the
    extreme complexity of the code needed to initialize, coordinate, stop, and free
    those threads.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，多线程编程因为初始化、协调、停止和释放这些线程所需的代码极端复杂，让开发者感到恐惧。
- en: The easiest way to begin experimenting with multithreading in .NET and learn
    the basic principles is to use the `BackgroundWorker` component. It allows us
    to define certain properties in design time (in Windows Forms) and introduce the
    code for the `DoWork` event handler. It represents an easy and rapid way to generate
    a new thread, independent of the main thread (the one that runs the main application's
    flow), and without having to use more flexible or more complicated methods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中开始实验多线程并学习基本原理的最简单方法是使用`BackgroundWorker`组件。它允许我们在设计时（在Windows Forms中）定义某些属性，并为`DoWork`事件处理器引入代码。它代表了一种简单且快速的方法来生成一个新的线程，独立于主线程（运行主应用程序流程的那个线程），而且无需使用更灵活或更复杂的方法。
- en: The work to be done and run in a new thread is programmed in the `DoWork` event
    handler of `BackgroundWorker`. To understand how it works, let's look at an example
    to see it in action and experience the difference between the code running in
    the same thread (the application's main thread) and in another thread.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在新线程中执行和运行的工作是在`BackgroundWorker`的`DoWork`事件处理器中编程的。为了理解它是如何工作的，让我们看一个例子来观察它的实际操作，并体验在同一个线程（应用程序的主线程）和另一个线程中运行代码之间的差异。
- en: Imagine that we must create a CodeBreaker application. There is a code of four
    Unicode characters, and we want to break it by a brute-force attack. Therefore,
    we must loop through each Unicode character until we have a match, then move on
    to the next character, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们必须创建一个CodeBreaker应用程序。有一个由四个Unicode字符组成的代码，我们希望通过暴力攻击来破解它。因此，我们必须遍历每个Unicode字符，直到我们找到一个匹配项，然后继续到下一个字符，依此类推。
- en: However, as the application will take some time to break the code, we do not
    want to get caught by a guard during the hacking process. Therefore, we will add
    some pictures that will simulate a Fishes game, present in the *How to do it*
    section under the *Simple example without a BackgroundWorker object* section.
    We must be able to hide our hacking application and show the Fishes game by clicking
    on a button.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于应用程序破解代码需要一些时间，我们不希望在黑客过程中被守卫抓住。因此，我们将添加一些图片来模拟*How to do it*部分下的*Simple
    example without a BackgroundWorker object*部分中的Fishes游戏。我们必须能够通过点击按钮来隐藏我们的黑客应用程序并显示Fishes游戏。
- en: 'First, we are going to build a new C# application, and we will program a classic
    linear programming loop with some processing in order to run the code in the same
    thread (the application''s main thread):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建一个新的C#应用程序，并编写一个经典的线性编程循环，其中包含一些处理，以便在同一个线程（应用程序的主线程）中运行代码：
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need a computer with at least two cores or two microprocessors installed
    in order to achieve significant results for the forthcoming experiments, and for
    the examples in the rest of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在即将进行的实验中获得显著的结果，以及本书其余部分的示例，我们需要一台至少安装了两个核心或两个微处理器的计算机。
- en: Simple example without a BackgroundWorker object
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有BackgroundWorker对象的简单示例
- en: We will start this WPF chapter by first creating a single thread version of
    our CodeBreaking application. This will give us a starting point and show us the
    limitations of running everything on a single thread. We will then refactor our
    application to use two threads, and then many threads, to show the improved performance
    and capabilities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过创建一个单线程版本的我们的CodeBreaking应用程序来开始这个WPF章节。这将为我们提供一个起点，并展示在单个线程上运行所有内容的局限性。然后我们将重构我们的应用程序以使用两个线程，然后是许多线程，以展示改进的性能和能力。
- en: As mentioned before, we will be doing all of this in a WPF application instead
    of Windows Forms. This will require us to work with the `BackgroundWorker` component
    entirely in code instead of being able to use it at design time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在一个WPF应用程序中完成所有这些，而不是Windows Forms。这将要求我们完全在代码中与`BackgroundWorker`组件一起工作，而不是能够在设计时使用它。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: How to do it
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The following are the steps that we need to perform:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要执行的步骤：
- en: Create a new WPF application C# project in Visual Studio (**File** | **New**
    | **Project** | **Visual C#** | **WPF Application**).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建一个新的 WPF 应用程序 C# 项目（**文件** | **新建** | **项目** | **Visual C#**
    | **WPF 应用程序**）。
- en: The IDE will create a very simple application with `MainWindow.xaml` and `MainWindow.xaml.cs`
    files. We will name our project `CodeBreaker`:![How to do it](img/8321EN_02_03.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE 将创建一个包含 `MainWindow.xaml` 和 `MainWindow.xaml.cs` 文件的一个非常简单的应用程序。我们将命名我们的项目为
    `CodeBreaker`：![如何操作](img/8321EN_02_03.jpg)
- en: 'Open `MainWindow.xaml` in the designer, and add the following controls:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计器中打开 `MainWindow.xaml`，并添加以下控件：
- en: Two images showing a skull and an agent (`imgSkull` and `imgAgent`).
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个显示骷髅和特工的图片（`imgSkull` 和 `imgAgent`）。
- en: Three images showing three fish (`imgFish1`, `imgFish2`, and `imgFish3`).
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个显示三只鱼的图片（`imgFish1`、`imgFish2` 和 `imgFish3`）。
- en: Four textblock elements with their `Text` property set to `"#1"`,`"#2"`,`"#3"`,
    and `"#4"` (`txtNumber1`, `txtNumber2`, `txtNumber3`, and `txtNumber4` respectively).
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个文本块元素，它们的 `Text` 属性设置为 `"#1"`、`"#2"`、`"#3"` 和 `"#4"`（分别对应 `txtNumber1`、`txtNumber2`、`txtNumber3`
    和 `txtNumber4`）。
- en: Four labels with their `Text` property set to `"*"` (`txtOutput1`, `txtOutput2`,
    `txtOutput3`, and `txtOutput4`).
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个标签，它们的 `Text` 属性设置为 `"*"`（分别对应 `txtOutput1`、`txtOutput2`、`txtOutput3` 和 `txtOutput4`）。
- en: One textblock element with its `Text` property set to `"CodeBreaker (Single-threaded)"`.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本块元素，其 `Text` 属性设置为 `"CodeBreaker (Single-threaded)"`。
- en: One textblock with its `Text` property set to `"Fishes Game!!!"`.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本块，其 `Text` 属性设置为 `"Fishes Game!!!"`。
- en: One button with its `Text` property set to `"Start"` (`btnStart`). This is the
    button that will run the main loop, which will find the code.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本属性设置为 `"Start"` 的按钮（`btnStart`）。这是将运行主循环的按钮，该循环将找到代码。
- en: One button showing with its `Text` property set to `"Hide"` (`btnHide`). This
    button must hide all the controls related to the CodeBreaker and show the Fishes
    game. You will click on this button when the guard is coming!
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本属性设置为 `"Hide"` 的按钮（`btnHide`）。此按钮必须隐藏与代码破解器相关的所有控件，并显示鱼游戏。当守卫到来时，你会点击此按钮！
- en: One button with its `Text` property set to `"Game over"` (`btnGameOver`). This
    button must hide all the controls related to the Fishes game and show the CodeBreaker
    again. You will click on this button when the guard has gone and you will feel
    safe to continue breaking the code!
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本属性设置为 `"Game over"` 的按钮（`btnGameOver`）。此按钮必须隐藏与鱼游戏相关的所有控件，并再次显示代码破解器。当守卫离开且你感到安全时，你会点击此按钮继续破解代码！
- en: 'The controls mentioned here are shown in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里提到的控件在以下屏幕截图中显示：
- en: '![How to do it](img/8321EN_02_04.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_02_04.jpg)'
- en: 'In the `MainWindow.xaml.cs` code file, add the following line in the `public
    partial class MainWindow : Window` definition to declare two private variables:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `MainWindow.xaml.cs` 代码文件中，在 `public partial class MainWindow : Window` 定义中添加以下行以声明两个私有变量：'
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following method, `SimulateCodeGeneration`, to our `MainWindow` class.
    This will simulate the code that must be broken:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的 `MainWindow` 类中添加以下方法，`SimulateCodeGeneration`，这将模拟必须被破解的代码：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following procedure, `setFishesVisibility`. This will change the visibility
    of the controls related to the Fishes game:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下过程，`setFishesVisibility`。这将改变与鱼游戏相关的控件的可视性：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following procedure, `setCodeBreakerVisibility`. This will change the
    visibility of the controls related to the CodeBreaking procedure:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下过程，`setCodeBreakerVisibility`。这将改变与代码破解过程相关的控件的可视性：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following procedure, `showFishes`. This will show the Fishes game and
    will hide everything related to the CodeBreaking procedure:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下过程，`showFishes`。这将显示鱼游戏并隐藏与代码破解过程相关的所有内容：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following procedure, `showCodeBreaker`. This will hide the Fishes game
    (implying you do not want to play), and will show everything related to the CodeBreaking
    procedure. You need this in order to break the code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下过程，`showCodeBreaker`。这将隐藏鱼游戏（意味着你不想玩），并显示与代码破解过程相关的所有内容。你需要这个来破解代码：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following function, `checkCodeChar`. This will return `true` if the
    received character and position matches the one in the code. This will help us
    in our simulation, and we can then replace it with a real decoder:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，`checkCodeChar`。如果接收到的字符和位置与代码中的匹配，则返回 `true`。这将有助于我们的模拟，然后我们可以将其替换为真正的解码器：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code in the MainWindow constructor (after `InitializeComponent()`):'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MainWindow 构造函数中添加以下代码（在 `InitializeComponent()` 之后）：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the `Click` event in the button `butGameOver` and enter the following
    code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮`butGameOver`的`Click`事件中打开，并输入以下代码：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open the `Click` event in the button `butHide`, and enter the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮`butHide`的`Click`事件中打开，并输入以下代码：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the `Click` event in the button `butStart`, and enter the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮`butStart`的`Click`事件中打开，并输入以下代码：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Build and run the application:![How to do it](img/8321EN_02_05.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和运行应用程序：![如何操作](img/8321EN_02_05.jpg)
- en: Click on the **Start** button. While the loop is running and the code is being
    broken by brute force, try clicking on the **Hide** button. You won't be able
    to.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始**按钮。当循环正在运行并且代码正在通过暴力破解时，尝试点击**隐藏**按钮。您将无法做到。
- en: How does it work?
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: If a guard comes past when you are trying to break the code, you will be caught
    because there is no way to stop the CodeBreaking once it starts until it completes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您试图破解代码时，如果守卫经过，您将被抓住，因为一旦开始破解代码，就无法停止，直到它完成。
- en: Why? Because we do not have a multithreaded application, we lose control over
    the graphical user interface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为我们没有多线程应用程序，我们失去了对图形用户界面的控制。
- en: The code programmed in the `btnStart` click event handler runs in the main thread.
    Therefore, when the user clicks on this button, he or she loses control over the
    UI and cannot click on the other button to hide the CodeBreaker-related controls
    because the thread is processing the `btnStart` click method. Until this method
    finishes, nothing else can be processed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`btnStart`点击事件处理器中编写的代码在主线程中运行。因此，当用户点击此按钮时，他将失去对UI的控制，无法点击其他按钮来隐藏与CodeBreaker相关的控件，因为线程正在处理`btnStart`点击方法。直到此方法完成，其他任何操作都无法处理。
- en: The code is quite simple. It generates the 65,536 Unicode characters four times,
    and calls the `checkCodeChar` function in order to determine whether it is part
    of the code or not. It tries to display the progress showing each tested character
    in the window, but as it is a single-threaded application, it fails in this objective.
    Again, as the loop is run in the main thread of the process created when the application
    is executed, we lose control over the UI. We cannot move the window, change its
    size, or push a button. The main thread is processing the intensive loop and consuming
    all the processing time of a single core. Hence, it cannot show information in
    the main window.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单。它四次生成65,536个Unicode字符，并调用`checkCodeChar`函数以确定它是否是代码的一部分。它试图在窗口中显示进度，显示每个测试的字符，但作为一个单线程应用程序，它在这个目标上失败了。同样，由于循环是在应用程序执行时创建的进程的主线程中运行的，我们失去了对UI的控制。我们无法移动窗口，更改其大小，或按按钮。主线程正在处理密集的循环，消耗单个核心的所有处理时间。因此，它无法在主窗口中显示信息。
- en: For this reason, when the guard comes, you are dead. Hence, let's create a multithreaded
    application and save human lives!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当守卫来时，您就死了。因此，让我们创建一个多线程应用程序，拯救人类生命！
- en: WPF example with an asynchronous BackgroundWorker
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有异步BackgroundWorker的WPF示例
- en: A loop like the one used in the previous example is an ideal task to run in
    an independent thread. That way, we could keep control over the UI and have the
    possibility of canceling the job, displaying its progress, hiding the CodeBreaker
    controls, and displaying our Fishes game. Hence, we can avoid being shot by the
    guard (death or jail).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 像前一个示例中使用的那种循环是运行在独立线程中的理想任务。这样，我们可以保持对UI的控制，并有可能取消作业，显示其进度，隐藏CodeBreaker控件，并显示我们的鱼游戏。因此，我们可以避免被守卫射杀（死亡或监禁）。
- en: In this section, we will see how to use the `BackgroundWorker` component in
    a simple way to create a second concurrent thread in our application, which will
    allow the user to perform other actions while the CodeBreaking process is being
    performed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以简单的方式了解如何使用`BackgroundWorker`组件在我们的应用程序中创建第二个并发线程，这将使用户在执行CodeBreaking过程的同时能够执行其他操作。
- en: We will first do this in an asynchronous way and then in a synchronous way in
    the next chapter. The differences will be shown; in the asynchronous method, we
    will be able to take advantage of concurrent processing with two threads, but
    we will lose visibility as to the status of the second thread. We will not know
    where it is in the CodeBreaking process and when it is completed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先以异步方式完成这项工作，然后在下一章中以同步方式完成。差异将会展示；在异步方法中，我们将能够利用两个线程的并发处理，但我们将失去对第二个线程状态的可见性。我们将不知道它在CodeBreaking过程中的位置以及何时完成。
- en: How to do it
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now, let''s make some changes to the application. We will process the CodeBreaking
    loop using a `BackgroundWorker` component in order to run the code in an independent
    thread:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对应用程序做一些修改。我们将使用`BackgroundWorker`组件来处理破解循环，以便在独立的线程中运行代码：
- en: Open the project, `CodeBreaker`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目，`CodeBreaker`。
- en: Add a `BackgroundWorker` object to the `MainWindow` (`bakCodebreaker`) class.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`BackgroundWorker`对象添加到`MainWindow`（`bakCodebreaker`）类中。
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, register the `DoWork` event handler in the constructor of the `MainWindow`
    class.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`MainWindow`类的构造函数中注册`DoWork`事件处理器。
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, add the `DoWork` event handler method and paste the same code entered
    previously in the `Click` event in the button, `btnStart` (this is the code that
    is going to be run when the `BackgroundWorker` object is started):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加`DoWork`事件处理器方法，并将之前在按钮`btnStart`的`Click`事件中输入的相同代码粘贴到该事件中（这是当`BackgroundWorker`对象启动时要运行的代码）：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, comment out the following lines of code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，注释掉以下代码行：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must comment out these lines of code because, as the `BackgroundWorker`
    object creates a new thread in which the loop is going to run, it cannot make
    changes to the user interface. There are mechanisms to do that, and we will learn
    them later.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您必须注释掉这些代码行，因为当`BackgroundWorker`对象创建一个新线程，其中循环将要运行时，它无法更改用户界面。有机制可以做到这一点，我们将在以后学习。
- en: 'Open the `Click` event in the button `btnStart`, and enter the following code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮`btnStart`的`Click`事件中打开，并输入以下代码：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Build and run the application.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Click on the **Start** button. While the loop is running and the code is being
    broken by brute force in a new thread created by the `BackgroundWorker` component,
    try to click on the **Hide** button. It works, and while the CodeBreaker code
    is still working in the background, you will see the Fishes game being displayed
    in the window, as shown in the following screenshot:![How to do it](img/8321EN_02_06.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始**按钮。当循环正在运行，并且`BackgroundWorker`组件创建的新线程正在通过暴力破解代码时，尝试点击**隐藏**按钮。它有效，并且当CodeBreaker代码仍在后台工作时，您将看到鱼游戏在窗口中显示，如下面的截图所示：![如何操作](img/8321EN_02_06.jpg)
- en: Move the window, change its size, maximize it, and do anything else you want
    to. While you do these operations, the code programmed in the `DoWork` event will
    keep on executing in another thread.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动窗口，更改其大小，最大化它，并执行您想要的任何其他操作。当您执行这些操作时，`DoWork`事件中编写的代码将在另一个线程中继续执行。
- en: How does it work?
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: We can click on the **Hide** button, and the window shows the three fish with
    the **Game Over** button, but the program continues processing the CodeBreaker
    in the other thread (the `DoWork` method of `BackgroundWorker`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击**隐藏**按钮，窗口将显示带有**游戏结束**按钮的三条鱼，但程序继续在另一个线程（`BackgroundWorker`的`DoWork`方法）中处理CodeBreaker。
- en: The code programmed in the `DoWork` event handler runs in an independent thread.
    Therefore, when the user clicks on the **Start** button, a new thread is created,
    and he or she does not lose control over the UI. While the CodeBreaker is running,
    the user can move the mouse cursor over other buttons, change the window size,
    and use other user interface components similar to the buttons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DoWork`事件处理器中编写的代码在一个独立的线程中运行。因此，当用户点击**开始**按钮时，会创建一个新线程，用户不会失去对UI的控制。当CodeBreaker运行时，用户可以将鼠标光标移至其他按钮上，更改窗口大小，并使用与按钮类似的其他用户界面组件。
- en: However, we cannot see the progress of the code being broken. We will fix this
    issue shortly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法看到正在破解的代码的进度。我们将很快解决这个问题。
- en: How does it work without blocking the UI?
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何在不阻塞UI的情况下工作的？
- en: After calling the `RunWorkerAsync()` method of `BackgroundWorker`, the advantage
    of threading begins by running the code programmed in the `DoWork` event handler
    in a new independent thread. This mechanism is known as **asynchronous execution**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`BackgroundWorker`的`RunWorkerAsync()`方法后，线程的优势开始显现，`DoWork`事件处理器中编写的代码将在一个新的独立线程中运行。这种机制被称为**异步执行**。
- en: When an asynchronous method is called, it runs in an independent way and the
    program flow goes on with the instruction after the method call, even though the
    code has not finished its execution. The code in the asynchronous method runs
    concurrently with the main program flow.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用异步方法时，它以独立的方式运行，程序流程继续执行方法调用之后的指令，即使代码尚未完成执行。异步方法中的代码与主程序流程并发运行。
- en: We are going to run our last example step-by-step in order to understand the
    asynchronous execution and how the main thread's code goes on running.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步运行最后一个示例，以便理解异步执行以及主线程代码是如何继续运行的。
- en: How to do it
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'The following are the steps that need to be followed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要遵循的步骤：
- en: Open the project `CodeBreaker`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目 `CodeBreaker`。
- en: Define a breakpoint in the line `bakCodebreaker.RunWorkerAsync();` in the `Click`
    event code of `btnStart`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`btnStart`的`Click`事件代码中的`bakCodebreaker.RunWorkerAsync();`行上设置一个断点。
- en: Define a breakpoint in the line `showFishes();` in the `Click` event code of
    `btnHide`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`btnHide`的`Click`事件代码中的`showFishes();`行上设置一个断点。
- en: Press *F5* or navigate to **Debug** | **Start Debugging** in the main menu.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F5* 或在主菜单中导航到 **调试** | **开始调试**。
- en: Click on the **Start** button. The line with the breakpoint defined is shown
    highlighted as the next statement that will be executed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **开始** 按钮。定义了断点的行将突出显示为下一个将要执行的语句。
- en: Press *F10* or navigate to **Debug** | **Step Over** in the main menu a few
    times. As you can see, the next statement that will be executed in the main thread
    is not in the **DoWork** event handler of `BackgroundWorker`. It remains in the
    `Click` event code of `btnStart`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按下 *F10* 或在主菜单中导航到 **调试** | **单步跳过** 几次。正如你所看到的，主线程中即将执行的下一个语句不在`BackgroundWorker`的**DoWork**事件处理器中。它保持在`btnStart`的`Click`事件代码中。
- en: Now, click on the **Hide** button.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 **隐藏** 按钮。
- en: Press *F10* or navigate to **Debug** | **Step Over** in the main menu a few
    times. As you can see, the thread created by `BackgroundWorker` keeps running
    while the next statement that will be executed in the main thread is not in the
    `DoWork` event handler of `BackgroundWorker`. It remains in the `Click` event
    code of `btnHide`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F10* 或在主菜单中导航到 **调试** | **单步跳过** 几次。正如你所看到的，由`BackgroundWorker`创建的线程在主线程中即将执行的下一个语句不在`BackgroundWorker`的`DoWork`事件处理器中时仍然在运行。它保持在`btnHide`的`Click`事件代码中。
- en: How does it work?
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: Running the application step by step, we could not enter the code in the `DoWork`
    event handler of `BackgroundWorker`. However, the code was running because the
    CodeBreaker thread did its job. It happened because the `BackgroundWorker` object
    starts an asynchronous execution of the code in another thread. Therefore, the
    main thread continues with its next statements as if the `RunWorkerAsync()`method
    had completed successfully. Hence, that method does not execute code in a linear,
    synchronous way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步运行应用程序时，我们无法进入`BackgroundWorker`的`DoWork`事件处理器中的代码。然而，代码正在运行，因为CodeBreaker线程完成了它的任务。这是因为`BackgroundWorker`对象在另一个线程中启动了代码的异步执行。因此，主线程继续执行其下一个语句，就像`RunWorkerAsync()`方法已成功完成一样。因此，该方法不是以线性、同步的方式执行代码。
- en: The execution flow in the main thread is synchronous. The main thread and the
    one created by `BackgroundWorker` run concurrently.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程中的执行流程是同步的。主线程和由`BackgroundWorker`创建的线程是并发运行的。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Nevertheless, not everything that shines is gold. Asynchronous code execution
    brings many new headaches to programmers because it ends with many implicit warranties
    related to synchronous and linear code execution. We will be talking about them
    and will provide simple solutions for the most common problems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有闪光的东西都是金子。异步代码执行给程序员带来了许多新的烦恼，因为它结束了与同步和线性代码执行相关的许多隐含保证。我们将讨论这些问题，并提供针对最常见问题的简单解决方案。
- en: When we worked with a single thread, we used to be the only owners of all the
    available elements in the programming context, the instances, the variables, the
    collections, the arrays, the controls that compose the graphical user interface,
    the components, and so on. However, when we work with multiple threads and asynchronous
    execution, we are sharing this world, in many ways, with strangers. Hence, there
    may be some code that runs concurrently, affecting the values for some variables,
    or accomplishing changes in the instances of the objects that we were going to
    work on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用单个线程时，我们曾是编程上下文中所有可用元素的唯一所有者，包括实例、变量、集合、数组、构成图形用户界面的控件、组件等等。然而，当我们使用多个线程和异步执行时，我们在很多方面与陌生人共享这个世界。因此，可能有一些代码是并发运行的，影响某些变量的值，或者在我们将要工作的对象实例中实现更改。
- en: For this reason, a paradigm shift in the way we approach our code is needed.
    We must stop thinking that we are alone with our code. The same thing happened
    when home computers were not connected to a network, some decades ago. They did
    not use a hard drive, and the user was the complete and unique owner of everything
    that was executed. Things such as memory swapping did not take place then. On
    the other side, nowadays, it would be difficult to find a modern computer without
    some kind of Internet connection. The antivirus, antispyware, anti-malware, and
    many other anti-threats that could interrupt the digital ecosystem harmony appeared.
    Therefore, every action in an application on a website is accompanied by those
    "anti-" whatever threat.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要在处理代码的方式上发生范式转变。我们必须停止认为我们与代码是孤立的。几十年前，当家用电脑没有连接到网络时，情况也是如此。那时它们没有使用硬盘，用户是执行的一切的完整和唯一所有者。那时的内存交换等事情并没有发生。另一方面，如今，很难找到没有某种互联网连接的现代电脑。出现了许多可以中断数字生态系统和谐的防病毒、反间谍软件、反恶意软件等反威胁。因此，网站上应用程序的每个动作都伴随着那些“反”任何威胁。
- en: The same happens with multithreading and asynchronous execution. New threats
    appear and they can make the most perfectly designed code for a single thread
    produce completely unexpected and incomprehensible results when executed in a
    multithreading environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程和异步执行也是如此。新线程出现，它们可以使为单线程设计的最完美的代码在多线程环境中执行时产生完全不可预期和难以理解的结果。
- en: Many techniques must be applied in order to avoid the different problems related
    to concurrent programming. We are going to analyze them with concrete examples
    through this book, case by case.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与并发编程相关的不同问题，必须应用许多技术。我们将通过这本书逐个具体案例分析它们。
- en: WPF example with a synchronous BackgroundWorker
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用同步BackgroundWorker的WPF示例
- en: We are used to synchronous execution when we work with a single thread. This
    mechanism executes the next instruction once the current instruction processing
    is completed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用单线程工作时，我们习惯于同步执行。这种机制会在当前指令处理完成后执行下一个指令。
- en: When a synchronous method is called, it runs on the same thread and the program
    flow goes into the method's code. Once it returns from the method with or without
    a result, it goes on with the instruction next to the method call. There is no
    code in the method left for later execution, because it finishes when it returns
    the control to the caller. The main program has to wait for the method to complete
    its execution in order to go on with the next set of instructions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用同步方法时，它在同一线程上运行，程序流程进入方法代码。一旦它从方法返回，无论是否有结果，它将继续执行方法调用旁边的指令。方法中没有代码可以稍后执行，因为它在将控制权返回给调用者时就已经完成了。主程序必须等待方法完成执行，才能继续执行下一组指令。
- en: This is what happens when you debug a single-threaded application, step-by-step.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当你逐步调试单线程应用程序时会发生的情况。
- en: In a single-threaded application, the synchronous execution takes place as we
    observed in classic linear programming. When a line of code executes, nothing
    else runs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程应用程序中，同步执行就像我们在经典线性编程中观察到的那样进行。当一行代码执行时，没有其他代码运行。
- en: However, in a multithreaded application, such as the ones using one or more
    `BackgroundWorker` controls, asynchronous execution comes into the picture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在多线程应用程序中，例如使用一个或多个`BackgroundWorker`控件的应用程序，异步执行就出现了。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must master this important change in the way methods are called and new independent
    threads are created on the fly, in order to get used to parallel and concurrent
    programming in C#.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须掌握方法调用方式的重要变化，以及动态创建新的独立线程，以便适应C#中的并行和并发编程。
- en: Showing progress
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示进度
- en: Users may get impatient when processes are delayed for more than a few seconds.
    In such cases, they need to know how long it will take them to finish. A good
    evidence of this is the replacement of messages such as *Hold on…* by animated
    dialog boxes with progress bars, entertaining the users while they wait for the
    process and showing them an approximate time required to finish the task.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程延迟超过几秒钟时，用户可能会变得不耐烦。在这种情况下，他们需要知道完成所需的时间。一个很好的例子是，用带有进度条的动画对话框替换了诸如“请稍等…”之类的消息，在用户等待进程的同时娱乐他们，并显示完成任务所需的近似时间。
- en: Reporting progress is one of the main problems when we work with only one thread
    and make intensive use of the processing power. Now, we will make changes to the
    application to show the code as it is being decoded and report the decoding progress
    for each character. This way, you will be able to decide whether to hide the CodeBreaker
    when the guard is coming or wait for the process to finish.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仅使用一个线程并大量使用处理能力时，报告进度是我们面临的主要问题之一。现在，我们将对应用程序进行修改，以显示代码的解码过程，并为每个字符报告解码进度。这样，你将能够决定是否在守卫到来时隐藏代码破解器，还是等待过程完成。
- en: As we work in the same thread that updates the user interface, if we send orders
    to make changes in a control to show any kind of progress, it will probably show
    the update whenever the main thread retrieves control (usually, when the process
    has already finished). Hence, as it is not useful to watch when the process has
    finished, it is necessary to update the progress report regularly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在更新用户界面的同一线程中工作，如果我们发送命令以更改控件以显示任何类型的进度，它可能会在主线程检索控制时显示更新（通常，当过程已经完成时）。因此，由于在过程完成时观察没有用，有必要定期更新进度报告。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a rule, we cannot make calls to a control since the thread used is different
    from the one that created it. If that happened, an `InvalidOperationException`
    would be raised. In order to make these calls safely, we must use delegates and
    asynchronous calls, known as **callbacks**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规则，我们不能调用一个控件，因为使用的线程与创建它的线程不同。如果发生这种情况，将引发`InvalidOperationException`。为了安全地调用这些操作，我们必须使用委托和异步调用，即所谓的**回调**。
- en: The `BackgroundWorker` component offers a straightforward way to report progress
    and simplifies updating any control in the user interface that shows this progress,
    without any need to use delegates or asynchronous calls (callbacks). The last
    two are indeed much more complex ways to achieve the same results.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundWorker`组件提供了一种简单的方法来报告进度，并简化了更新显示此进度的任何用户界面控件，而无需使用委托或异步调用（回调）。后两者确实是实现相同结果更为复杂的方法。'
- en: In order to show the progress of an operation using the `BackgroundWorker` component,
    we must assign the `true` value to its `WorkerReportsProgress` property. Its type
    is `bool`, and it tells whether the code executed in the new thread will report
    some kind of progress or not. If the value is `true`, the `BackgroundWorker` component
    will trigger the `ProgressChanged` event handler.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`BackgroundWorker`组件显示操作的进度，我们必须将其`WorkerReportsProgress`属性设置为`true`。其类型为`bool`，它表示在新线程中执行代码是否会报告某种进度。如果值为`true`，则`BackgroundWorker`组件将触发`ProgressChanged`事件处理程序。
- en: This event facilitates updating the user interface. Therefore, it allows changes
    to control values, without having to consider the problems generated when we want
    to do it from a thread different from the one that created the control (the application's
    main thread).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件有助于更新用户界面。因此，它允许更改控件值，而无需考虑当我们想要从创建控件的线程（应用程序的主线程）之外执行时产生的问题。
- en: We are going to make some changes to our second example to take advantage of
    the features offered by the `BackgroundWorker` component to report progress in
    the user interface without delegates or callbacks. This way, we will be safe from
    the guards.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对第二个示例进行一些修改，以利用`BackgroundWorker`组件提供的功能，在用户界面中报告进度而不使用委托或回调。这样，我们将安全地避开守卫。
- en: How to do it
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The following are the steps that need to be followed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要遵循的步骤：
- en: Open the project `CodeBreaker`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目`CodeBreaker`。
- en: Add four `ProgressBar` controls to `frmMain` (`pgbProgressChar1`, `pgbProgressChar2`,
    `pgbProgressChar3`, and `pgbProgressChar4`).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`frmMain`添加四个`ProgressBar`控件（`pgbProgressChar1`、`pgbProgressChar2`、`pgbProgressChar3`和`pgbProgressChar4`）。
- en: 'Register the `ProgressChanged` event handler in the `MainWindow` constructor:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`构造函数中注册`ProgressChanged`事件处理程序：
- en: '[PRE17]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Set the `WorkerReportsProgress` property of `bakCodebreaker` to true.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bakCodebreaker`的`WorkerReportsProgress`属性设置为`true`。
- en: 'Add the following lines of code to the `setCodeBreakerVisibility` procedure.
    This will change the visibility of the new controls related to the progress of
    the CodeBreaking procedure:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`setCodeBreakerVisibility`过程。这将改变与代码破解过程进度相关的新控件的可视性：
- en: '[PRE18]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following lines of code in the form class declaration to declare a
    new private variable:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单类声明中添加以下代码行以声明一个新的私有变量：
- en: '[PRE19]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code in the form constructor (after `InitializeComponent()`):'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单构造函数中（在 `InitializeComponent()` 之后）添加以下代码：
- en: '[PRE20]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add a new class file to the project and call it `CodeBreakerProgress`. The new
    `CodeBreakerProgress` class will have properties that will help provide many values
    related to the progress to update the user interface. Add the following code to
    the class.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新类文件添加到项目中，并将其命名为 `CodeBreakerProgress`。新的 `CodeBreakerProgress` 类将具有帮助提供许多与进度相关的值的属性。将以下代码添加到该类中。
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the `DoWork` event in `bakCodebreaker` of `BackgroundWorker`, and enter
    the following code at the beginning, before the `for` loop:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BackgroundWorker` 的 `bakCodebreaker` 中的 `DoWork` 事件，并在 `for` 循环之前输入以下代码：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, in the same event, add the following code before the `if (checkCodeChar(lcChar,
    liCharNumber))` line:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在相同的事件中，在 `if (checkCodeChar(lcChar, liCharNumber))` 行之前添加以下代码：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, in the same event, add the following code before the `break;` line:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在相同的事件中，在 `break;` 行之前添加以下代码：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open the `ProgressChanged` event in the `bakCodebreaker` of `BackgroundWorker`
    and enter the following code (this is the code that will be run when the `ReportProgress`
    method is called):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BackgroundWorker` 的 `bakCodebreaker` 中的 `ProgressChanged` 事件，并输入以下代码（这是在调用
    `ReportProgress` 方法时运行的代码）：
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Build and run the application.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Click on the **Start** button and you will see the progress bars filling up,
    showing how the process advances from 0 to 65,535 Unicode characters and the characters
    being tested. This is shown in the following screenshot. Now you have more information
    to decide whether to hide the application or not.![How to do it](img/8321EN_02_07.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **开始** 按钮，你会看到进度条正在填充，显示过程如何从 0 进展到 65,535 个 Unicode 字符以及正在测试的字符。这在上面的屏幕截图中显示。现在你有了更多信息来决定是否隐藏应用程序。![如何操作](img/8321EN_02_07.jpg)
- en: While the code is being broken, the UI can be used because the CodeBreaking
    is being done in a separate thread.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码正在被破解时，UI 可以继续使用，因为破解代码是在一个独立的线程中进行的。
- en: If the CodeBreaking runs too fast on your system, to see what is going on, add
    the following line before the `if (checkCodeChar(lcChar, liCharNumber))` statement.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在你的系统上破解代码运行得太快，为了查看发生了什么，在 `if (checkCodeChar(lcChar, liCharNumber))` 语句之前添加以下行。
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will add a 1-millisecond wait between each character being checked.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每个字符被检查之间添加 1 毫秒的等待时间。
- en: How does it work?
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: The code programmed in the loop reports the progress only if the percentage
    completed increased by a unit or more. Otherwise, we would be triggering 65,536
    events in order to report only 100 different percentages. That would not make
    sense and add extra burdensome processing. That would be very inefficient and
    would make the loop take longer to complete its execution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中编写的代码仅在完成百分比增加一个单位或更多时才报告进度。否则，我们将会触发 65,536 个事件来报告只有 100 个不同的百分比。这没有意义，并且会增加额外的处理负担。这将非常低效，并且会使循环执行时间更长。
- en: Canceling a BackgroundWorker thread
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消 BackgroundWorker 线程
- en: Executing a time-consuming process in an independent thread allows us to work
    concurrently while showing its progress. One of the advantages of doing this is
    the possibility of allowing the user to go on using the controls in the graphical
    user interface without the restrictions of single-threaded applications. For example,
    perhaps he or she wants to cancel the CodeBreaking process instead of letting
    it finish.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在独立的线程中执行耗时过程允许我们在显示其进度的同时并发工作。这样做的一个优点是，允许用户在图形用户界面中继续使用控件，而不会受到单线程应用程序的限制。例如，他或她可能想要取消破解过程，而不是让它完成。
- en: The `BackgroundWorker` component simplifies the task of canceling the execution
    of the code running in the thread it creates without a lot of programming effort.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundWorker` 组件简化了取消它创建的线程中运行的代码执行的任务，而无需大量的编程工作。'
- en: To do this, we must assign the `true` value to the `WorkerSupportsCancellation`
    property of `BackgroundWorker`. It is a `bool` value and tells whether the code
    executed in the new thread will support cancellation through a call to the `CancelAsync()`
    method of `BackgroundWorker`. This method simply assigns the `true` value to the
    `BackgroundWorker` property `CancellationPending`. Hence, the code being executed
    in the `DoWork` event handler must regularly check this property's value to determine
    whether it has to go on working or not.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须将`BackgroundWorker`的`WorkerSupportsCancellation`属性赋值为`true`。这是一个`bool`值，表示新线程中执行的代码是否可以通过调用`BackgroundWorker`的`CancelAsync()`方法来支持取消。此方法简单地将`true`值赋给`BackgroundWorker`的`CancellationPending`属性。因此，在`DoWork`事件处理器中执行的代码必须定期检查此属性值，以确定是否需要继续工作。
- en: Hiding the CodeBreaking does not stop the CodeBreaking process. So, we can still
    get caught if someone hacks into our computer and sees the process. Therefore,
    it is very important to provide the application with a fast cancellation procedure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏`CodeBreaking`并不会停止`CodeBreaking`过程。因此，如果有人黑入我们的电脑并看到这个过程，我们仍然可能被发现。因此，提供快速取消程序给应用程序非常重要。
- en: How to do it
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We are going to make some changes to our example to allow the user to cancel
    the loop at any time without delegates or callbacks, using the features provided
    by the `BackgroundWorker` component:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对示例进行一些修改，以便用户可以在任何时候取消循环，而不需要使用代理或回调，利用`BackgroundWorker`组件提供的功能：
- en: Open the project `CodeBreaker`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目`CodeBreaker`。
- en: Set the `WorkerSupportsCancellation` property of `bakCodebreaker` to `true`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bakCodebreaker`的`WorkerSupportsCancellation`属性设置为`true`。
- en: Add a button control `btnStop`. Set its `Text` property to `"Stop"`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个按钮控件`btnStop`。将其`Text`属性设置为`"Stop"`。
- en: 'Add the following line of code to the procedure, `setCodeBreakerVisibility`.
    It will change the visibility of the new button:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setCodeBreakerVisibility`过程添加以下代码行。它将改变新按钮的可见性：
- en: '[PRE27]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Open the `DoWork` event in `bakCodebreaker` and enter the following code before
    the line `lcChar = (char)(i)` in the beginning of the `for` loop (the code now
    adds support for a premature cancellation):'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bakCodebreaker`的`DoWork`事件中打开代码，并在`for`循环开始处的`lcChar = (char)(i)`之前输入以下代码（现在的代码添加了对提前取消的支持）：
- en: '[PRE28]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open the `Click` event in the button `btnStart` and add the following lines
    of code at the beginning (the code now disables the **Start** button and enables
    the **Stop** button):'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮`btnStart`的`Click`事件中打开代码，并在开始处添加以下几行代码（现在的代码禁用了**Start**按钮并启用了**Stop**按钮）：
- en: '[PRE29]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Set the `IsEnabled` property of the `btnStop` button to `false` in the constructor.
    Hence, the button will be disabled when the application starts.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中将`btnStop`按钮的`IsEnabled`属性设置为`false`。因此，当应用程序启动时，按钮将被禁用。
- en: 'Open the `Click` event in the `btnStop` button and enter the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`btnStop`按钮的`Click`事件中打开代码，并输入以下代码：
- en: '[PRE30]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Build and run the application.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Click on the **Start** button. Now click on the **Stop** button. The CodeBreaker
    will cancel its execution. The thread created by the `BackgroundWorker` component
    will stop running. The result is shown in the following screenshot:![How to do
    it](img/8321EN_02_08.jpg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Start**按钮。现在点击**Stop**按钮。CodeBreaker将取消其执行。由`BackgroundWorker`组件创建的线程将停止运行。结果如下截图所示：![如何操作](img/8321EN_02_08.jpg)
- en: Now, click on the **Start** button and let the CodeBreaking complete.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**Start**按钮并让CodeBreaking完成。
- en: How does it work?
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: Earlier, you could avoid the guards, and now you are able to stop the CodeBreaking
    in case spies hack your system!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你可以避开守卫，现在你能够停止`CodeBreaking`，以防间谍黑入你的系统！
- en: We can now develop an application that is able to execute a time-consuming task
    in the background, while keeping the graphical user interface alive. This offers
    the user a more real-life experience and we can offer the user the possibility
    of starting and stopping the process whenever they want to. We have done all of
    this using the `BackgroundWorker` component features.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开发一个能够在后台执行耗时任务的应用程序，同时保持图形用户界面活跃。这为用户提供了一个更真实的生活体验，我们可以为用户提供随时开始和停止进程的可能性。我们使用`BackgroundWorker`组件的功能完成了所有这些。
- en: However, the application has a defect. When we click on the **Start** button
    and let the process finish, the **Stop** button will not be shown disabled. Additionally,
    we cannot see the final code on the screen. We must create a remedy for this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用程序存在缺陷。当我们点击 **开始** 按钮并让过程完成时，**停止** 按钮不会被显示为禁用状态。此外，我们无法在屏幕上看到最终的代码。我们必须为此创建一个补救措施。
- en: Working with multiple BackgroundWorker components
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多个 BackgroundWorker 组件一起工作
- en: We can work with many `BackgroundWorker` components in order to run many concurrent
    threads. Usually, we will use the `Thread` class to run many threads at once,
    but the `BackgroundWorker` class provides us an easy way to do this as well. As
    we learned in the previous chapter, the performance results will depend upon the
    number of cores or processors available in the computer in which we run the application
    and how busy each core is with other threads of execution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用许多 `BackgroundWorker` 组件来运行多个并发线程。通常，我们会使用 `Thread` 类一次性运行多个线程，但 `BackgroundWorker`
    类也为我们提供了这样做的一种简单方法。正如我们在上一章所学到的，性能结果将取决于我们运行应用程序的计算机中可用的核心或处理器的数量以及每个核心被其他执行线程占用的繁忙程度。
- en: Using the real algorithms, the process of breaking the four Unicode characters
    code is very intensive and requires more time than expected. Breaking the code
    must take the minimum time possible. So far, we have been using multithreading
    to have a more responsive application, but now, we must make execution of the
    CodeBreaking process much faster.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用真实算法，破解四个 Unicode 字符代码的过程非常密集，所需时间比预期更长。破解代码必须尽可能快地完成。到目前为止，我们一直在使用多线程来使应用程序更响应，但现在，我们必须使破解过程的执行速度更快。
- en: We are going to take the code presented in our previous examples and divide
    it into four `BackgroundWorker` components. With this example, we will learn how
    multiple `BackgroundWorker` components coexist and create new independent threads,
    and hence achieve an incredible performance enhancement.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把之前示例中的代码分成四个 `BackgroundWorker` 组件。通过这个示例，我们将学习多个 `BackgroundWorker` 组件如何共存并创建新的独立线程，从而实现令人难以置信的性能提升。
- en: How does it work?
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: 'The steps that need to be followed are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要遵循的步骤如下：
- en: Open the project `CodeBreaker`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CodeBreaker` 项目。
- en: Add three new `BackgroundWorker` components (`bakCodeBreaker2`, `bakCodeBreaker3`,
    and `bakCodeBreaker4`) to create four independent threads. This is done in the
    declaration section of the `MainWindow` class. Next, set the `True` value for
    their properties `WorkerReportsProgress` and `WorkerSupportsCancellation` in the
    class constructor.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个新的 `BackgroundWorker` 组件（`bakCodeBreaker2`、`bakCodeBreaker3` 和 `bakCodeBreaker4`）以创建四个独立的线程。这是在
    `MainWindow` 类的声明部分中完成的。接下来，在类构造函数中将它们的属性 `WorkerReportsProgress` 和 `WorkerSupportsCancellation`
    设置为 `True`。
- en: 'Add a new class to the project and call it `CodeBreakerParameters`. The `CodeBreakerParameters`
    class will have properties that will help provide many values that will be available
    as parameters for the four `BackgroundWorker` components:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新的类，并将其命名为 `CodeBreakerParameters`。`CodeBreakerParameters` 类将具有一些属性，这些属性将帮助提供许多值，这些值将作为四个
    `BackgroundWorker` 组件的参数可用：
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Again, add another new class file. This one will be called `CodeBreakerResult`.
    The new `CodeBreakerResult` class will have properties that help in providing
    many values as parameters for the four `BackgroundWorker` components'' `RunWorkerCompleted`
    events:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，添加另一个新的类文件。这个类将被命名为 `CodeBreakerResult`。新的 `CodeBreakerResult` 类将具有一些属性，这些属性有助于为四个
    `BackgroundWorker` 组件的 `RunWorkerCompleted` 事件提供许多值：
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open the `Click` event in the `btnStart` button and add the following lines
    of code before the line `bakCodebreaker.RunWorkerAsync();` (now the code will
    set the parameters for the four `BackgroundWorker` components and will run them
    asynchronously):'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `btnStart` 按钮的 `Click` 事件中打开，并在 `bakCodebreaker.RunWorkerAsync();` 行之前添加以下代码行（现在代码将为四个
    `BackgroundWorker` 组件设置参数，并将它们异步运行）：
- en: '[PRE33]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, in the same aforementioned event, remove the line `bakCodebreaker.RunWorkerAsync();`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一上述事件中，删除行 `bakCodebreaker.RunWorkerAsync();`。
- en: 'Open the `Click` event in the `btnStop` button and add the following lines
    of code (now the code will cancel the four `BackgroundWorker` components, `bakCodebreaker`
    and the three `BackgroundWorker` components added in the following lines):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `btnStop` 按钮的 `Click` 事件中打开，并添加以下代码行（现在代码将取消四个 `BackgroundWorker` 组件，即 `bakCodebreaker`
    和以下行中添加的三个 `BackgroundWorker` 组件）：
- en: '[PRE34]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we will create generic procedures to handle the following programmed events
    of `BackgroundWorker` components, receiving the same parameters as the corresponding
    event handler:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建通用的过程来处理 `BackgroundWorker` 组件的以下程序化事件，接收与相应事件处理器相同的参数：
- en: '`DoWorkProcedure` for the `DoWork` event'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoWorkProcedure` 用于 `DoWork` 事件'
- en: '`RunWorkerCompletedProcedure` for the `RunWorkerCompleted` event'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RunWorkerCompletedProcedure` 用于 `RunWorkerCompleted` 事件'
- en: '`ProgressChangedProcedure` for the `ProgressChanged` event'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressChangedProcedure` 用于 `ProgressChanged` 事件'
- en: 'Paste the `DoWork` event handler code of `bakCodebreaker` in a new private
    procedure and then make the following changes as shown:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `bakCodebreaker` 的 `DoWork` 事件处理器代码粘贴到一个新的私有过程中，然后按照以下所示进行更改：
- en: '[PRE35]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following variable definitions at the beginning:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开头添加以下变量定义：
- en: '[PRE36]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Replace the line `int liTotal = (int)e.Argument`; with the following (now the
    event handler procedure needs more parameters, and so we create a class to manage
    them):'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行 `int liTotal = (int)e.Argument;` 替换为以下（现在事件处理器过程需要更多的参数，因此我们创建了一个类来管理它们）：
- en: '[PRE37]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace the line that defines the first loop with the following (now the loop
    takes into account the parameters received through a `CodeBreakerParameters` instance):'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将定义第一个循环的行替换为以下（现在循环考虑了通过 `CodeBreakerParameters` 实例接收到的参数）：
- en: '[PRE38]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Replace the pending cancellation check with the following line (we use the
    `sender` parameter typecast because the same procedure is employed by the four
    `BackgroundWorker` components):'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将挂起的取消检查替换为以下行（我们使用 `sender` 参数类型转换，因为四个 `BackgroundWorker` 组件都使用了相同的程序）：
- en: '[PRE39]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Replace the call to the `ReportProgress` method by the following line (again,
    we use the `sender` parameter typecasted for generalization):'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对 `ReportProgress` 方法的调用替换为以下行（再次，我们使用 `sender` 参数类型转换以进行泛化）：
- en: '[PRE40]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Replace the call to the `ReportProgress` method when the `checkCodeChar` function
    returns `true` with the following line:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `checkCodeChar` 函数返回 `true` 时，替换对 `ReportProgress` 方法的调用为以下行：
- en: '[PRE41]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Replace the line `e.Result = lsBrokenCode;` with the following lines (now we
    must return more than one result; therefore, we use an instance of the `CodeBreakerResult`
    class created earlier):'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行 `e.Result = lsBrokenCode;` 替换为以下行（现在我们必须返回多个结果；因此，我们使用之前创建的 `CodeBreakerResult`
    类的实例）：
- en: '[PRE42]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Enter the following code to create the new `RunWorkerCompleted` procedure:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以创建新的 `RunWorkerCompleted` 过程：
- en: '[PRE43]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Enter the following code to create the new `ProgressChangedProcedure` procedure:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以创建新的 `ProgressChangedProcedure` 过程：
- en: '[PRE44]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you have to program the code for the three additional event handlers of
    the four `BackgroundWorker` components. As we have used procedures, we will use
    the same code for the four `BackgroundWorker` components:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你必须为四个 `BackgroundWorker` 组件的三个附加事件处理器编写代码。因为我们使用了过程，所以我们将为四个 `BackgroundWorker`
    组件使用相同的代码：
- en: 'Add the following code in the four `BackgroundWorker` components'' `DoWork`
    event handlers:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在四个 `BackgroundWorker` 组件的 `DoWork` 事件处理器中添加以下代码：
- en: '[PRE45]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following code in the four `BackgroundWorker` components'' `ProgressChanged`
    event handlers:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在四个 `BackgroundWorker` 组件的 `ProgressChanged` 事件处理器中添加以下代码：
- en: '[PRE46]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the following code in the four `BackgroundWorker` components'' `RunWorkerCompleted`
    event handlers:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在四个 `BackgroundWorker` 组件的 `RunWorkerCompleted` 事件处理器中添加以下代码：
- en: '[PRE47]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Build and run the application.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Click on the **Start** button and let the process finish. You will see that
    all four characters are being decoded at the same time concurrently. If you have
    a machine with four cores in it, you will see all four cores being utilized simultaneously
    and much improved performance:![How does it work?](img/8321EN_02_09.jpg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **开始** 按钮，让过程完成。你会看到所有四个字符都在同时并发解码。如果你有一台具有四个核心的机器，你会看到所有四个核心都在同时使用，性能得到了显著提升：![如何工作？](img/8321EN_02_09.jpg)
- en: 'And here is how it looks once it is completed:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成后，它看起来是这样的：
- en: '![How does it work?](img/8321EN_02_10.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何工作？](img/8321EN_02_10.jpg)'
- en: How does it work?
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作？
- en: Now, your CodeBreaking procedure is very fast! Each character of the code is
    being decoded in parallel.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的代码破解过程非常快！代码的每个字符都在并行解码。
- en: As we have seen, it is easy to split a process into many threads using the features
    provided by the `BackgroundWorker` component. The results of the execution of
    the previous example will depend on the number of cores or processors available
    in the computer. The ideal situation is to start as many `BackgroundWorker` components
    as the number of cores available. This way, we can achieve the best performance
    for each thread and take the CPU usage to around 95 percent. Of course this will
    vary and we will not always know the number of cores on a target machine. As we
    will see in future chapters, there are ways to use the **Task Parallel Library**
    (**TPL**) to achieve maximum concurrency on machines when we do not know the number
    of cores on a machine ahead of time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，使用`BackgroundWorker`组件提供的功能将一个过程拆分为许多线程是很容易的。前一个示例的执行结果将取决于计算机中可用的核心或处理器的数量。理想的情况是启动与可用核心数量相同的`BackgroundWorker`组件。这样，我们可以为每个线程实现最佳性能，并将CPU使用率提高到约95%。当然，这会有所变化，我们并不总是知道目标机器上的核心数量。正如我们将在未来的章节中看到的，当我们在事先不知道机器上的核心数量时，有方法可以使用**任务并行库**（**TPL**）在机器上实现最大并发性。
- en: Now, we do not need to run many instances of an application to take advantage
    of parallel processing capabilities. Using the `BackgroundWorker` component and
    everything we have learned so far, we can quite easily split a process into many
    threads.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不需要运行许多应用程序实例来利用并行处理能力。使用`BackgroundWorker`组件以及我们迄今为止所学的一切，我们可以相当容易地将一个过程拆分为许多线程。
- en: However, we had to make some important changes to the code because we needed
    to generalize the behavior of four `BackgroundWorker` components without writing
    the same piece of code four times. This is called **refactoring** and should also
    be done when developing software to minimize redundant code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不得不对代码进行一些重要的修改，因为我们需要泛化四个`BackgroundWorker`组件的行为，而不必四次编写相同的代码。这被称为**重构**，并且在开发软件时也应该进行，以最小化冗余代码。
- en: We created new classes to pass parameters and obtain results because we needed
    many parameters and many results. As you can see, with typecasting, C# offers
    us excellent alternatives to generalize the code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了新的类来传递参数和获取结果，因为我们需要许多参数和许多结果。正如你所见，通过类型转换，C#为我们提供了泛化代码的极好替代方案。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The key was the `sender` parameter. Remember that this parameter, available
    in the event handlers, offers a reference to the component (the `BackgroundWorker`)
    that triggers the event. Typecasting the `sender` parameter to a `BackgroundWorker`
    component, we could generalize the code in the different event handlers and create
    procedures for each one.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于`sender`参数。请记住，这个参数在事件处理器中可用，它提供了一个指向触发事件的组件（即`BackgroundWorker`）的引用。将`sender`参数类型转换为`BackgroundWorker`组件，我们可以在不同的事件处理器中泛化代码，并为每个事件创建过程。
- en: There were many changes. But once the code patterns are practiced and learned,
    it will be easier to work with concurrent programming structures. This will be
    especially important when working with the TPL.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多变化。但一旦代码模式被练习和学习，与并发编程结构一起工作将变得更加容易。这在使用TPL时尤为重要。
- en: As of now, the application uses four `BackgroundWorker` components, and hence
    four independent threads not including the main thread. It does not give the user
    a message about the end of the CodeBreaking global process.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，应用程序使用了四个`BackgroundWorker`组件，因此有四个独立的线程，不包括主线程。它不会给用户关于CodeBreaking全局过程结束的消息。
- en: Exploring other examples
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索其他示例
- en: Try adding another `BackgroundWorker` to show a message box telling the user
    the process has finished, or disabling the **Stop** button and enabling the **Start**
    button, when the four `BackgroundWorker` components complete their work. You can
    use the `IsBusy()` function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加另一个`BackgroundWorker`来显示一个消息框，告诉用户过程已完成，或者当四个`BackgroundWorker`组件完成其工作后，禁用**停止**按钮并启用**开始**按钮。你可以使用`IsBusy()`函数。
- en: You can use the **Process Explorer** to view the running threads for the example
    and monitor its activities. You can download and install **Process Explorer**
    from [http://download.cnet.com/Process-Explorer/3000-2094_4-10223605.html](http://download.cnet.com/Process-Explorer/3000-2094_4-10223605.html),
    if you do not already have it loaded. This is a very handy utility and will allow
    you to really dissect what is happening with the different threads in your application.
    The following is a sample of Process Explorer running alongside our `CodeBreaker`
    application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**进程资源管理器**来查看示例的运行线程并监控其活动。如果您还没有安装，可以从[http://download.cnet.com/Process-Explorer/3000-2094_4-10223605.html](http://download.cnet.com/Process-Explorer/3000-2094_4-10223605.html)下载并安装**进程资源管理器**。这是一个非常实用的工具，将允许您真正剖析应用程序中不同线程的情况。以下是在我们的`CodeBreaker`应用程序旁边运行的进程资源管理器的示例。
- en: Apply all the things we have learned in the previous chapter. Also, use the
    Windows Task Manager. You will have a better understanding of the differences
    between multiple processes and multithreaded applications when monitoring the
    application running concurrently with the four `BackgroundWorker` threads, in
    a computer with a quad-core microprocessor and using the Process Explorer.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们在上一章中学到的所有知识。此外，使用Windows任务管理器。当您在具有四核微处理器的计算机上使用进程资源管理器监控与四个`BackgroundWorker`线程同时运行的应用程序时，您将更好地理解多个进程和多线程应用程序之间的差异。
- en: 'Before the **Start** button is pressed, these are the threads and information
    you should see for this application:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下**开始**按钮之前，您应该看到以下线程和信息：
- en: '![Exploring other examples](img/8321EN_02_11.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![探索其他示例](img/8321EN_02_11.jpg)'
- en: 'After the **Start** button is pressed, these are the threads and information
    you should see for this application:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下**开始**按钮之后，您应该看到以下线程和信息：
- en: '![Exploring other examples](img/8321EN_02_12.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![探索其他示例](img/8321EN_02_12.jpg)'
- en: Monitor the application using one, two, three, and four threads running concurrently.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个、两个、三个和四个线程同时监控应用程序。
- en: Enhance the application using the patterns we have learned in the previous example
    using only one `BackgroundWorker` component. Change the code to add the possibility
    to start and stop the threads running in each `BackgroundWorker` component.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在上一个示例中学到的模式来增强应用程序，仅使用一个`BackgroundWorker`组件。修改代码以添加在每个`BackgroundWorker`组件中启动和停止线程的可能性。
- en: Monitor the application starting and stopping one, two, three, and four threads
    running concurrently, and pay attention to what happens with the threads' activities
    and CPU usage in the Process Explorer.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 监控应用程序启动和停止一个、两个、三个和四个线程同时运行，并注意在进程资源管理器中线程活动以及CPU使用情况的变化。
- en: Run the application in different computers with different microprocessors and
    use the Process Explorer to monitor their behavior and measure their performance.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同计算机上运行应用程序，这些计算机拥有不同的微处理器，并使用进程资源管理器来监控它们的行为并测量它们的性能。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We learned a lot in this chapter about working with threads using the `BackgroundWorker`
    component. Specifically, we covered the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用`BackgroundWorker`组件来处理线程。具体来说，我们涵盖了以下内容：
- en: Developing applications that are able to create background threads using the
    `BackgroundWorker` component and showing the progress of execution by taking advantage
    of the methods provided by this component
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发能够使用`BackgroundWorker`组件创建后台线程并利用该组件提供的方法显示执行进度的应用程序
- en: Programming the threads' code to be executed by `BackgroundWorker`
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程`BackgroundWorker`组件的代码以供执行
- en: Understanding the differences between synchronous and asynchronous execution
    and how they are related to threads
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同步和异步执行之间的差异以及它们与线程的关系
- en: Reporting the progress of multiple threads in the user interface
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户界面中报告多个线程的进度
- en: Starting and canceling threads created using `BackgroundWorker` instances
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BackgroundWorker`实例启动和取消创建的线程
- en: Launching multiple threads using many `BackgroundWorker` components
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个`BackgroundWorker`组件启动多个线程
- en: Creating the various event handlers of the `BackgroundWorker` component in code
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中创建`BackgroundWorker`组件的各种事件处理器
- en: Now that we've learned a simple way to create many threads in a C# application
    using the `BackgroundWorker` component, we're ready to do these things using a
    much more flexible but more complex technique—the `Thread` class—which is the
    topic of the next chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了使用`BackgroundWorker`组件在C#应用程序中创建多个线程的简单方法，我们现在准备使用一种更加灵活但更复杂的技巧——`Thread`类，这是下一章的主题。
