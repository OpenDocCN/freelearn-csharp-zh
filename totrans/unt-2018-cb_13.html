<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Navigation Meshes and Agents</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following:</p>
<ul>
<li>NPC to travel to destination while avoiding obstacles</li>
<li>NPC to seek or flee from a moving object</li>
<li>Point-and-click move to object</li>
<li>Point-and-click move to tile</li>
<li>Point-and-click raycast with user-defined higher-cost Navigation Areas</li>
<li>NPC to follow waypoints in sequence</li>
<li>Controlling object group movement through flocking</li>
<li>Creating a movable NavMesh Obstacle</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Unity provides <strong>Navigation Meshes</strong> and Artificial Intelligence (<span>AI</span>) Agents that can plan pathways and move objects along those calculated paths. <strong>Pathfinding</strong> is a classic AI task, and Unity has provided game developers with fast and efficient <strong>Pathfinding</strong> components that work out of the box.</p>
<p>Having objects that can automatically plot and follow paths from their current location to a desired destination point (or a moving object) provides the components to many different kinds of interactive game characters and mechanics. For example, we can create point-and-click games by clicking on a location or object, towards which we wish one or more characters to travel. Or, we can have enemies that "wake up" when our player's character is nearby, and move towards <span>(seek)</span><span> </span><span>our player, perhaps then going into combat or dialogue mode once they are within a short distance of our player's character.</span></p>
<p class="mce-root"/>
<p><span>Or, objects can collectively flock together, moving as a swarm towards a common destination.</span></p>
<p>This chapter explores ways to exploit Unity's navigation-based AI components to control game character <strong>Pathfinding</strong> and movement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The big picture</h1>
                </header>
            
            <article>
                
<p>At the core of Unity's navigation system are two concepts/components:</p>
<ul>
<li><strong>Navigation Meshes</strong></li>
<li><strong>Navigation Mesh Agents</strong></li>
</ul>
<p>A Navigation <strong>Mesh</strong> defines the areas of the world that are navigable. It is usually represented as a set of polygons (2D shapes), so that a path to a destination is plotted as the most efficient sequence of adjacent polygons to follow, taking into account the need to avoid non-navigable obstacles.</p>
<p>The <strong>Agent</strong> is the object that needs to calculate (plot) a path through the mesh from its current position to its desired destination position. <strong>NavMesh Agents</strong> have properties such as a stopping distance, so they aim to arrive at a point a certain distance from the target coordinates, and auto braking, so they gradually slow down as they get close to their destination.</p>
<p>A <strong>Navigation Mesh</strong> can be made up of <strong>Areas</strong> that have different "costs." The default cost for an area is 1. However, to make a more realistic path calculation by AI Agent controlled characters, we might want to model the additional effort it takes to travel through water, or mud, or up a steep slope. Therefore, Unity allows us to define custom Areas, with names that we choose (such as Water or Mud), and associated costs, such as 2 (that is, water is twice as tiring to travel through).</p>
<p>Different navigable areas can be connected via <strong>NavMesh Links:</strong></p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/class-NavMeshLink.html">https://docs.unity3d.com/Manual/class-NavMeshLink.html</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Run-Time Nav Mesh Obstacles</h1>
                </header>
            
            <article>
                
<p>The most efficient way for games to work with <strong>Navigation Meshes</strong> is to pre-calculate the costs of polygons in the game world; this is known as <strong>Baking</strong> and is performed at <strong>Design-Time</strong>, before we run the game.</p>
<p class="mce-root"/>
<p>However, sometimes there will be features in the game that we wish to use to influence navigation decisions and route planning differently at different times in the game, that is, dynamic Run-Time navigation obstacles. Unity provides a <strong>NavMesh Obstacle</strong> component, which can be added to GameObjects, and has features such as "carving out" (temporarily removing) areas of a <strong>NavMesh</strong> to force AI-Agents to recalculate paths that avoid areas blocked by GameObjects with <strong>NavMesh Obstacle</strong> components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Source of further information about Unity and AI navigation</h1>
                </header>
            
            <article>
                
<p>Some <strong>NavMesh</strong> features (such as <strong>NavMesh Links</strong> and dynamic mesh baking at <strong>Run-Time</strong>) are not part of the standard Unity installation and require additional installation. Learn more about these components, their APIs, and how to install them here:</p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html" target="_blank"><span class="URLPACKT">https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html</span></a></li>
<li><a href="https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html" target="_blank"><span class="URLPACKT">https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html</span></a></li>
</ul>
<p>Learn more about Unity <strong>NavMeshes</strong> from the Unity Technologies tutorial, which is available here:</p>
<ul>
<li><a href="http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes" target="_blank"><span class="URLPACKT">http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes</span></a></li>
</ul>
<p>Learn lots about computer-controlled moving GameObjects from the classic paper entitled <strong>Steering Behaviors For Autonomous Characters</strong> by Craig W. Reynolds, presented at the GDC-99 (Game Developer's Conference):</p>
<ul>
<li><a href="http://www.red3d.com/cwr/steer/gdc99/" target="_blank"><span class="URLPACKT">http://www.red3d.com/cwr/steer/gdc99/</span></a></li>
</ul>
<p>While the Unity development community have been asking for 2D <strong>NavMeshes</strong> for some years now, they've not yet been released as a core feature. There is a lot of online information about how to write your own <strong>Pathfinding</strong> system that would work in 2D. A good thread with plenty of links can be found at <strong>TIGForums</strong>:</p>
<ul>
<li><a href="https://forums.tigsource.com/index.php?topic=46325.0" target="_blank"><span class="URLPACKT">https://forums.tigsource.com/index.php?topic=46325.0</span></a></li>
</ul>
<p class="mce-root"/>
<p>In this chapter, you'll learn how to add <strong>NavMesh Agents</strong> to control characters and how to work with your game environment to specify and bake <strong>Navigation Meshes</strong> for a scene. Some recipes explore how to create point-and-click style games, where you indicate where you want a character to navigate to by clicking on an object or point in the game world.</p>
<p>You'll create "swarms" of objects that move and flock together, and you'll <span>also</span><span> </span><span>learn to add</span> <strong>NavMesh Obstacle</strong> <span>components to moving GameObjects, forcing AI agents to dynamically recalculate their paths at</span> <strong>Run-Time</strong> <span>due to </span><span>objects</span><span> </span><span>moving in their way.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NPC to travel to destination while avoiding obstacles</h1>
                </header>
            
            <article>
                
<p>The introduction of Unity's <strong>NavMeshAgent</strong> has greatly simplified the coding for NPC (Non-Player Character) and enemy agent behaviors. In this recipe, we'll add some wall obstacles<span> </span><span>(scaled cubes)</span><span>, and generate a</span> <strong>NavMesh</strong><span> so that Unity knows not to try to walk through walls. We'll then add a</span> <strong>NavMeshAgent</strong> <span>component to our NPC GameObject, and tell it to head to a stated destination location by intelligently planning and following a path, while avoiding the wall obstacles.</span></p>
<p>When the <span class="packt_screen">Navigation</span> panel is visible, then the <span class="packt_screen">Scene</span> panel displays the blue-shaded walkable areas, as well as unshaded, non-walkable areas at the edge of the terrain and around each of the two wall objects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/048040cc-d5f7-4f63-a674-d305ba4c62e6.png" style="width:31.42em;height:11.75em;"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The required <span class="packt_screen">Terrain Texture</span><span class="packt_screen">SandAlbedo</span> can be found in the 15_01<span> </span><span>folder</span><span>. Alternatively, you can go to </span><span class="packt_screen">Assets |</span><span class="packt_screen">Import Package | Environments</span><span>, deselect everything, and then locate and tick this asset:</span> <span class="packt_screen">Assets/Environment/TerrainAssets/SurfaceTextures/SandAlbedo.psd</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To make an NPC to travel to a destination while avoiding obstacles, follow these steps:</p>
<ol>
<li>Create a new, empty 3D project.</li>
<li>Create a new 3D <span class="packt_screen">Terrain</span>, choose menu: <span class="packt_screen">Create | 3D Object | Terrain</span>. With this new <span class="packt_screen">Terrain</span> GameObject selected in the <span class="packt_screen">Hierarchy</span>, in its <span class="packt_screen">Inspector</span> properties set its size to <span class="packt_screen">30 x 20</span>, and its position to <span class="packt_screen">(-15, 0, -10</span>) so we have this GameObject centered at (<span class="packt_screen">0,0,0</span>).</li>
<li>Texture paint this terrain with the <span class="packt_screen">SandAlbedo</span> texture.</li>
<li>Create a 3D <span class="packt_screen">Capsule</span> named <span class="packt_screen">Capsule-destination</span> at (<span class="packt_screen">-12, 0, 8</span>). This will be the target destination for our NPC self-navigating GameObject.</li>
<li>Create a sphere named <span class="packt_screen">Sphere-arrow</span> that is positioned at (<span class="packt_screen">2, 0.5, 2</span>). Scale it to (<span class="packt_screen">1,1,1</span>).</li>
<li>Create a second sphere named <span class="packt_screen">Sphere-small</span>. Scale it to (<span class="packt_screen">0.5, 0.5, 0.5</span>).</li>
<li>In the <span class="packt_screen">Hierarchy</span>, child <span class="packt_screen">Sphere-small</span> to <span class="packt_screen">Sphere-arrow</span> and position it at (<span class="packt_screen">0, 0, 0.5</span>):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a5fbaa0f-cc6c-4038-b19c-0245d10cd029.png" style="width:26.42em;height:11.58em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="8">
<li>In the Inspector panel, add a new <span class="packt_screen">NavMeshAgent</span> to <span class="packt_screen">Sphere-arrow</span>. Do this by choosing menu: <span class="packt_screen">Add Component | Navigation | Nav Mesh Agent</span>.</li>
<li>Set the <span class="packt_screen">Stopping Distance</span> property of the <span class="packt_screen">NavMeshAgent</span> component to <span class="packt_screen">2</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fce3dcbe-0bba-4392-9583-b76fd15ba6dc.png" style="width:28.83em;height:14.67em;"/></p>
<ol start="10">
<li>Create the <kbd>ArrowNPCMovement</kbd> C# script-class, and add an instance-object to the <span class="packt_screen">Sphere-arrow</span> GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEngine.AI;<br/><br/>public class ArrowNPCMovement : MonoBehaviour {<br/> public GameObject targetGo;<br/> private NavMeshAgent navMeshAgent;<br/><br/>void Start() {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> HeadForDestintation();<br/> }<br/><br/>private void HeadForDestintation () {<br/> Vector3 destination = targetGo.transform.position;<br/> navMeshAgent.SetDestination (destination);<br/> }<br/> }</pre>
<ol start="11">
<li>Ensure that <span class="packt_screen">Sp</span><span class="packt_screen">here-arrow</span> is selected in the <span class="packt_screen">Inspector</span> panel. For the <span class="packt_screen">ArrowNPCMovement</span> scripted component, drag <span class="packt_screen">Capsule-destination</span> over the <span class="packt_screen">Target Go</span> variable.</li>
<li>Create a 3D <span class="packt_screen">Cube</span> named <span class="packt_screen">Cube-wall</span> at <span class="packt_screen">(-6, 0, 0</span>), and scale it to (<span class="packt_screen">1, 2, 10</span>).</li>
<li>Create another 3D <span class="packt_screen">Cube</span> named <span class="packt_screen">Cube-wall2</span> at <span class="packt_screen">(-2, 0, 6</span>), and scale it to (<span class="packt_screen">1, 2, 7</span>).</li>
<li>Display the <span class="packt_screen">Navigation</span> panel by choosing menu: <span class="packt_screen">Window | Navigation</span>.</li>
</ol>
<div class="packt_infobox">A great place to dock the <span class="packt_screen">Navigation</span> panel is next to the <span class="packt_screen">Inspector</span> panel since you will never be using the <span class="packt_screen">Inspector</span> and <span class="packt_screen">Navigation</span> panels at the same time.</div>
<ol start="15">
<li>In the <span class="packt_screen">Hierar</span><span class="packt_screen">chy</span> panel, select both of the <span class="packt_screen">Cube-wall</span> objects (we select the objects that are not supposed to be a part of the walkable parts of our scene), and then in the <span class="packt_screen">Navigation</span> panel, click the <strong>Object</strong> button and check the <span class="packt_screen">Navigation Static</span> checkbox:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a6c23855-9001-4ce4-a621-e9d37cc79a66.png" style="width:42.25em;height:13.42em;"/></p>
<ol start="16">
<li>In the Inspector,<span> c</span><span>lick</span> <span>on t</span><span>he </span><span class="packt_screen">Bake</span><span> button at the top for baking options. Then, </span><span>click on the </span><span class="packt_screen">Bake</span><span> button </span>at the bottom-right to create your Navigation Mesh asset:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c2537923-7f65-4e30-a5ef-9379e266c76a.png" style="width:42.25em;height:12.50em;"/></p>
<ol start="17">
<li>When the <span class="packt_screen">Navigation</span> panel is displayed, you'll see a blue tint on the parts of the <span class="packt_screen">Scene</span> that are areas for a <span class="packt_screen">NavMeshAgent</span> to consider for its navigation paths.</li>
<li>Now, run your game. You will see the <span class="packt_screen">Sphere-arrow</span> GameObject automatically move towards the <span class="packt_screen">Capsule-destination</span> GameObject, following a path that avoids the two wall objects.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">NavMeshAgent</span> component that we added to <span class="packt_screen">Sphere-arrow</span> <span>GameObject</span><span> </span><span>does most of the work for us.</span> <span class="packt_screen">NavMeshAgents</span> <span>need two things:</span></p>
<ul>
<li>A destination location to head towards</li>
<li><span class="packt_screen">ANavMesh</span> component of the terrain with walkable/non-walkable areas, so that it can plan a path by avoiding obstacles</li>
</ul>
<p>We created two obstacles (the <span class="packt_screen">Cube-wall</span> objects), and these were selected when we created the <span class="packt_screen">NavMesh</span> for this scene in the <span class="packt_screen">Navigation</span> panel. When the <span class="packt_screen">Navigation</span> panel is displayed, at the same time in the <span class="packt_screen">Scene</span> panel (and the <span class="packt_screen">Game</span> panel with <span class="packt_screen">Gizmos</span> enabled), we see walkable areas forming a <span>blue </span><span>navigation mesh.</span></p>
<p>Note: The blue areas are the default <span class="packt_screen">NavMesh Area</span>. See, later in this chapter, a recipe for different, custom named, costed, color-coded <span class="packt_screen">NavMesh Areas</span>.</p>
<p>The location for our NPC object to travel towards is the position of the <span class="packt_screen">Capsule-destination</span> GameObject at <span class="packt_screen">(-12, 0, 8</span>); but, of course we could just move this object in the <span class="packt_screen">Scene</span> panel at <span class="packt_screen">Design-Time</span>, and its new position would be the destination when we run the game.</p>
<p>The <kbd>ArrowNPCMovement</kbd><span> </span><span>C# script class </span><span>has two variables: one is a reference to the destination GameObject, and the second is a reference to the</span> <span class="packt_screen">NavMeshAgent</span> <span>component of the GameObject, in which our instance of the</span> <kbd>ArrowNPCMovement</kbd> <span>class is also a component. When the scene starts</span><span>, the</span> <span class="packt_screen">NavMeshAgent</span> <span>sibling component is found</span><span> via the </span><kbd>Start()</kbd><span> method</span><span>, and the</span> <kbd>HeadForDestination()</kbd> <span>method is called, which sets the destination of the</span> <span class="packt_screen">NavMeshAgent</span> <span>to the position of the destination GameObject.</span></p>
<p>Once the <span class="packt_screen">NavMeshAgent</span> has a target to head towards, it will plan a path there and will keep moving until it arrives (or gets within the <span class="packt_screen">Stopping Distance</span> if that parameter has been set to a distance greater than zero).</p>
<p>In the <span class="packt_screen">Scene</span> panel, if you select the GameObject that contains the <span class="packt_screen">NavMeshAgent</span> and choose the <span class="packt_screen">Show Avoidance Gizmo</span>, then you can see the candidate local target positions the agent is considering. The lighter the squares are, the better a position ranks.</p>
<p class="mce-root"/>
<p>The darker red the squares are, the less desirable the position; so, dark red squares indicate positions to avoid, since they might, for instance, cause the agent to collide with a <span class="packt_screen">NavMesh Static</span> obstacle:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e9d87d2-7baf-448c-afca-5c874029bf90.png" style="width:26.25em;height:17.50em;"/></p>
<p>Ensure that the object with the <span class="packt_screen">NavMeshAgent</span> component is selected in the <span class="packt_screen">Hierarchy</span> panel at <strong>Run-Time</strong> to be able to see this navigation data in the <span class="packt_screen">Scene</span> panel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NPC to seek or flee from a moving object</h1>
                </header>
            
            <article>
                
<p>Rather than a destination that is fixed when the scene starts, let's allow the <span class="packt_screen">Capsule-destination</span> object to be moved by the player while the scene is running. In every frame, we'll get our NPC arrow to reset the <span class="packt_screen">NavMeshAgent's</span> destination to wherever <span class="packt_screen">Capsule-destination</span> has been moved to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To make an NPC seek or flee from a moving object, follow these steps:</p>
<ol>
<li>In the <span class="packt_screen">Inspector,</span> add a <span class="packt_screen">Rigid Body Physics</span> component to <span class="packt_screen">GameObject Capsule-destination</span>.</li>
<li>In the Inspector, for the <span class="packt_screen">Capsule-destination</span> GameObject, check the <span class="packt_screen">Freeze Position</span> constraint for the Y axis in the <span class="packt_screen">Constraints</span> options of the <span class="packt_screen">RigidBody</span> component. This will prevent the object moving in the Y-axis due to collisions when being moved.</li>
<li>Create the <kbd>SimplePlayerControl</kbd> C# script-class, and add an instance-object as a component to the <span class="packt_screen">Capsule-destination</span> GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/> public class SimplePlayerControl : MonoBehaviour {<br/> public float speed = 1000;<br/> private Rigidbody rigidBody;<br/><span> private </span>Vector3 <span>newVelocity</span><span>;<br/><br/></span> private void Start() {<br/> rigidBody = GetComponent&lt;Rigidbody&gt;();<br/> }<br/><br/> void Update() {<br/>   float xMove = Input.GetAxis("Horizontal") * speed * Time.deltaTime;<br/>   float zMove = Input.GetAxis("Vertical") * speed * Time.deltaTime;<br/>   newVelocity = new Vector3(xMove, 0, zMove);<br/> }<br/><br/> void FixedUpdate() {<br/>   rigidBody.velocity = newVelocity;<br/> }<br/>}</pre>
<ol start="4">
<li>Update the <kbd>ArrowNPCMovement</kbd> C# script-class so that we call the <kbd>HeadForDestintation()</kbd> method every frame, that is, from <kbd>Update()</kbd>, rather than just once in <kbd>Start()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void Start() {<br/>     navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> }<br/><br/> private void Update() {<br/>     HeadForDestintation();<br/> } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>SimplePlayerControl</kbd><span> </span><span>script-class </span><span>detects arrow key presses and translates them into a force to apply to move the</span> <span class="packt_screen">Capsule-destination</span><span> </span><span>GameObject</span><span> </span><span>in the desired direction.</span></p>
<p>The <kbd>Update()</kbd> method of the <kbd>ArrowNPCMovement</kbd><span> script-class </span>makes the <span class="packt_screen">NavMeshAgent</span> update its path <strong>every</strong> frame, based on the current position of the <span class="packt_screen">Capsule-destination</span> GameObject. As the user moves <span class="packt_screen">Capsule-destination</span>, so the <span class="packt_screen">NavMeshAgent</span> calculates a new path to the object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>Here are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a Debug Ray to show a source-to-destination line</h1>
                </header>
            
            <article>
                
<p>It's useful to use a visual <span class="packt_screen">Debug Ray</span> to show us the straight line from the NPC with the <span class="packt_screen">NavMeshAgent</span> to the current destination it is trying to navigate towards. Since this is a common thing we may wish to do for many games, it's useful to create a static method in a general-purpose class, and then the ray can be drawn with a single statement.</p>
<p>To use a <span class="packt_screen">Debug Ray</span> to draw a source-to-destination line, follow these steps:</p>
<ol>
<li>Create a <kbd>UsefulFunctions.cs</kbd> C# script-class, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class UsefulFunctions : MonoBehaviour {<br/> public static void DebugRay(Vector3 origin, Vector3 destination, Color c) {<br/> Vector3 direction = destination - origin;<br/> Debug.DrawRay(origin, direction, c);<br/> }<br/> }</pre>
<ol start="2">
<li>Now, add a statement at the end of the <kbd>HeadForDestination()</kbd> method in the <kbd>NPCMovement</kbd> C# script-class:</li>
</ol>
<pre style="padding-left: 60px">private void HeadForDestintation () {<br/>Vector3 destination = targetGo.transform.position;<br/>navMeshAgent.SetDestination (destination);<br/>// show yellow line from source to target<br/> UsefulFunctions.DebugRay(transform.position, destination, Color.yellow);<br/> }</pre>
<p>We can now see a yellow line in the <span class="packt_screen">Scene</span> panel when the scene is running. We can also see this in the <span class="packt_screen">Game</span> panel if the <span class="packt_screen">Gizmos</span> option is selected (top-right of the <span class="packt_screen">Game</span> panel title bar):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/37bd623b-435e-468e-9e93-6040dfc9c966.png" style="width:29.92em;height:12.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constantly updating NavMeshAgent destination to flee from Player's current location</h1>
                </header>
            
            <article>
                
<p>There are times when we want an AI-controlled NPC character to move <strong>away</strong> from another character, rather than go towards it. For example, an enemy with very low health might run away, and so gain time to regain its health before fighting again. Or, a wild animal might flee from any other character moving near it.</p>
<p>To instruct our <span class="packt_screen">NavMeshAgent</span> to flee from the player's location, we need to replace the <kbd>ArrowNPCMovement</kbd><span> </span><span>C# script class </span><span>with the following:</span></p>
<pre> using UnityEngine;<br/> using UnityEngine.AI;<br/><br/> public class ArrowNPCMovement : MonoBehaviour {<br/> public float runAwayDistance = 10;<br/> public GameObject targetGO;<br/> private NavMeshAgent navMeshAgent;<br/><br/>void Start() {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> }<br/><br/>void Update() {<br/> Vector3 targetPosition = targetGO.transform.position;<br/> float distanceToTarget = Vector3.Distance(transform.position, targetPosition);<br/> if (distanceToTarget &lt; runAwayDistance)<br/> FleeFromTarget(targetPosition);<br/> }<br/><br/>private void FleeFromTarget(Vector3 targetPosition) {<br/> Vector3 destination = PositionToFleeTowards(targetPosition);<br/> HeadForDestintation(destination);<br/> }<br/><br/>private void HeadForDestintation (Vector3 destinationPosition) {<br/> navMeshAgent.SetDestination (destinationPosition);<br/> }<br/><br/>private Vector3 PositionToFleeTowards(Vector3 targetPosition) {<br/> transform.rotation = Quaternion.LookRotation(transform.position - targetPosition);<br/> Vector3 runToPosition = targetPosition + (transform.forward * runAwayDistance);<br/> return runToPosition;<br/> }<br/> }</pre>
<p>There is a public variable, <kbd>runAwayDistance</kbd>. When the distance to the enemy is less than the value of this <kbd>runAwayDistance</kbd> variable, then we'll instruct the computer-controlled object to flee in the opposite direction.</p>
<p>The <kbd>Start()</kbd> method caches a reference to the <span class="packt_screen">NavMeshAgent</span> component.</p>
<p>The <kbd>Update()</kbd> method calculates whether the distance to the enemy is within <kbd>runAwayDistance</kbd>, and if so, it calls the <kbd>FleeFromTarget(...)</kbd> method, which passes the location of the enemy as a parameter.</p>
<p>The <kbd>FleeFromTarget(...)</kbd> method calculates a point that is the <kbd>runAwayDistance</kbd> in Unity units away from the Player's cube, in a direction that is directly away from the computer-controlled object. This is achieved by subtracting the enemy position vector from the current transform's position.</p>
<p class="mce-root"/>
<p>Finally, the <kbd>HeadForDestintation(...)</kbd> method is called, passing the flee-to position, which results in the <span class="packt_screen">NavMeshAgent</span> being told to set the location as its new destination.</p>
<p>Unity units are arbitrary, since they are just numbers on a computer. However, in most cases, it simplifies things to think of distances in terms of meters (1 Unity unit = 1 meter), and mass in terms of kilograms (1 Unity unit = 1 kilogram). Of course, if your game is based on a microscopic world, or pan-galactic space travel, then you need to decide what each Unity unit corresponds to for your game context. For further discussion of units in Unity, check out this post about Unity measurements: <span class="URLPACKT"><a href="http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487" target="_blank">http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487</a></span>.</p>
<p>The <span class="packt_screen">Debug Ray</span> shows the point the NPC is aiming for, whether it be to flee away from the player's character, or to catch up and maintain a constant distance from it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/875ba89b-7b33-43f8-a4d6-0eae3ae64f5a.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maintain constant distance from target ("lurking" mode!)</h1>
                </header>
            
            <article>
                
<p>It is simple to adapt the previous code to have an NPC try to maintain a constant distance from a target object. It involves always moving towards a point that is <kbd>runAwayDistance</kbd> away from the target, regardless of whether this point is towards or away from the target.</p>
<p>Just remove the <kbd>If</kbd> statement in the <kbd>Update()</kbd> method:</p>
<pre>void Update() {<br/> Vector3 targetPosition = targetGO.transform.position;<br/> float distanceToTarget = Vector3.Distance(transform.position, targetPosition);<br/> FleeFromTarget(targetPosition);<br/> }</pre>
<p>However, with this variation, it might be better to have the method named something like <kbd>MoveTowardsConstantDistancePoint()</kbd> rather than <kbd>FleeFromTarget()</kbd>, since our NPC is sometimes fleeing and sometimes following.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Point-and-click move to object</h1>
                </header>
            
            <article>
                
<p>Another way to choose the destination for our <span class="packt_screen">Sphere-arrow</span> GameObject is by the user clicking on an object on the screen, and then the <span class="packt_screen">Sphere-arrow</span> GameObject moving to the location of the clicked object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e088434d-ad3e-48e6-a2aa-1f47e15c30ea.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe adds to the first recipe in this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create an object-based point-and-click mini-game, do the following:</p>
<ol>
<li>In the <span class="packt_screen">Inspector,</span> add the <span class="packt_screen">Player</span> Tag to the <span class="packt_screen">Sphere-arrow</span> GameObject.</li>
<li>Delete the two 3D <span class="packt_screen">Cubes</span> and the 3D <span class="packt_screen">Capsule-destination</span> from the scene.</li>
<li>Create a <kbd>ClickMeToSetDestination</kbd> C# script-class containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class ClickMeToSetDestination : MonoBehaviour<br/> {<br/> private UnityEngine.AI.NavMeshAgent playerNavMeshAgent;<br/><br/>void Start() {<br/> GameObject playerGO = GameObject.FindGameObjectWithTag("Player");<br/> playerNavMeshAgent = playerGO.GetComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();<br/> }<br/><br/>private void OnMouseDown() {<br/> playerNavMeshAgent.SetDestination(transform.position);<br/> }<br/> }</pre>
<ol start="4">
<li>Add instance-objects of the <kbd>ClickMeToSetDestination</kbd> C# script-class as components to your 3D <span class="packt_screen">Cube</span>, <span class="packt_screen">Sphere,</span> and Cylinder.</li>
<li>Run the <span class="packt_screen">Scene</span>. When you click on one of the 3D objects, the <span class="packt_screen">Sphere-arrow</span> GameObject should navigate towards the clicked object.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>OnMouseDown()</kbd> method of the <kbd>ClickMeToSetDestination</kbd><span> C# script-class</span> changes the destination of the <span class="packt_screen">NavMeshAgent</span> in the <span class="packt_screen">Sphere-arrow</span> GameObject to be the position of the clicked 3D object.</p>
<p>The <kbd>Start()</kbd> method of the <kbd>ClickMeToSetDestination</kbd><span> </span><span>C# script-class </span><span>gets a reference to the</span> <span class="packt_screen">NavMeshAgent</span> <span>component of the GameObject tagged</span> <span class="packt_screen">Player</span> <span>(that is, the</span> <span class="packt_screen">Sphere-arrow</span> <span>GameObject).</span></p>
<p>Each time a different object is clicked, the <span class="packt_screen">NavMeshAgent</span> inside the <span class="packt_screen">Sphere-arrow</span> GameObject is updated to make the GameObject move towards the position of the clicked object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>There are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a mouse-over yellow highlight</h1>
                </header>
            
            <article>
                
<p>A good UX (<strong>User Experience</strong>) feedback technique is to visually indicate to the user when an object can be interacted with via the mouse. A common way to do this is to present an audio or visual effect when the mouse is moved over an interactable object.</p>
<p>We can create a <span class="packt_screen">Material</span> with a yellow color, which can make an object appear yellow while the mouse is over it, and then return to its original material when the mouse is moved away.</p>
<p>Create the <kbd>MouseOverHighlighter</kbd><span> </span><span>C# <kbd>script-class</kbd> </span><span>with the following contents. Then, add an instance-object as a component to each of the three 3D GameObjects:</span></p>
<pre>using UnityEngine;<br/><br/>public class MouseOverHighlighter : MonoBehaviour<br/> {<br/> private MeshRenderer meshRenderer;<br/> private Material originalMaterial;<br/><br/>void Start() {<br/> meshRenderer = GetComponent&lt;MeshRenderer&gt;();<br/> originalMaterial = meshRenderer.sharedMaterial;<br/> }<br/><br/>void OnMouseOver() {<br/> meshRenderer.sharedMaterial = NewMaterialWithColor(Color.yellow);<br/> }<br/><br/>void OnMouseExit() {<br/> meshRenderer.sharedMaterial = originalMaterial;<br/> }<br/><br/>private Material NewMaterialWithColor(Color newColor) {<br/> Shader shaderSpecular = Shader.Find("Specular");<br/> Material material = new Material(shaderSpecular);<br/> material.color = newColor;<br/><br/>return material;<br/> }<br/> }</pre>
<p>Now, when running the game, when your mouse is over one of the three objects, that object will be highlighted yellow. If you click on the mouse button when the object is highlighted, the <span class="packt_screen">Sphere-arrow</span> GameObject will make its way up to (but stop just before) the clicked object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Point-and-click move to tile</h1>
                </header>
            
            <article>
                
<p>Rather than clicking specific objects to indicate the target for our AI-controlled agent, we can create a grid of 3D <span class="packt_screen">Plane</span> (tile) objects to allow the player to click any tile to indicate a destination for the AI-controller character. So, any location can be clicked, rather than only one of a few specific objects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/75c0c4bd-eb2c-4547-bf06-7f611705fb5d.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p>For this recipe, we have prepared a red-outlined black square <span class="packt_screen">Texture</span> image named <span class="packt_screen">square_outline.png</span> in a folder named <span class="packt_screen">Textures</span> in the <kbd>15_04</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a point-and-click game making GameObjects to a selected tile, do the following:</p>
<ol>
<li>Delete your 3D <span class="packt_screen">Cube</span>, <span class="packt_screen">Sphere,</span> and <span class="packt_screen">Cylinder</span> GameObjects from the scene.</li>
<li>Create a new 3D <span class="packt_screen">Plane</span> object, scaled to (<span class="packt_screen">0.1, 0.1, 0.1</span>).</li>
<li>Create a new <span class="packt_screen">Material</span> with the <span class="packt_screen">Texture</span> image <span class="packt_screen">square_outline.png</span> provided (black square with a red outline). Apply this <span class="packt_screen">Material</span> to your 3D <span class="packt_screen">Plane</span>.</li>
<li>Add an instance-object of the <kbd>ClickMeToSetDestination</kbd> script-class as a component to your 3D <span class="packt_screen">Plane</span>.</li>
<li>In the <span class="packt_screen">Project</span> panel, create a new empty Prefab named <span class="packt_screen">tile</span>.</li>
</ol>
<ol start="6">
<li>Populate your Prefab <span class="packt_screen">tile</span> with the properties of your 3D <span class="packt_screen">Plane</span> GameObject by dragging the plane GameObject over your Prefab <span class="packt_screen">tile</span> (it should change from white to blue to indicate the Prefab now has the properties of your GameObject).</li>
<li>Delete your 3D <span class="packt_screen">Plane</span> GameObject from the scene.</li>
<li>Create a new <kbd>TileManager</kbd> C# script-class containing the following, and add an instance-object as a component to the <span class="packt_screen">Main Camera</span> GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class TileManager : MonoBehaviour {<br/> public int rows = 50;<br/> public int cols = 50;<br/> public GameObject prefabClickableTile;<br/><br/>void Start () {<br/> for (int r = 0; r &lt; rows; r++) {<br/> for (int c = 0; c &lt; cols; c++) {<br/> float y = 0.01f;<br/> Vector3 pos = new Vector3(r - rows/2, y, c - cols/2);<br/> Instantiate(prefabClickableTile, pos, Quaternion.identity);<br/> }<br/> }<br/> }<br/> }</pre>
<ol start="9">
<li>Select the <span class="packt_screen">Main Camera</span> in the <span class="packt_screen">Hierarchy</span>, and in the <span class="packt_screen">Inspector</span> for the <span class="packt_screen">Tile Manager (Script)</span> component, populate the <span class="packt_screen">Prefab Clickable Tile</span> public property with your Prefab <span class="packt_screen">tile</span> from the <span class="packt_screen">Project</span> panel.</li>
<li>Run the scene. You should now be able to click on any of the small square tiles to set the destination of the <span class="packt_screen">NavMeshAgent</span> controlled <span class="packt_screen">Sphere-arrow</span> GameObject.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You created a Prefab, containing the properties of a 3D <span class="packt_screen">Plane</span> named <span class="packt_screen">tile</span>, which contained a component instance-object of the <kbd>ClickMeToSetDestination</kbd><span> </span><span>C# script-class</span><span>.</span></p>
<p>The <kbd>TileManager</kbd> script class loops to create 50 x 50 instances of this <span class="packt_screen">tile</span> Gameobject in the <span class="packt_screen">Scene</span>.</p>
<p>When you run the game, if you click on the mouse button when the mouse pointer is over a tile, the NavMeshAgent inside the <span class="packt_screen">Sphere-arrow</span> <span>GameObject</span><span> </span><span>is set to that tile's position. So, the</span> <span class="packt_screen">Sphere-arrow</span> <span>GameObject will move towards, but stop just before reaching, the clicked tile position.</span></p>
<p>The <strong>Y</strong> value of <span class="packt_screen">0.01</span> means the plane will be just above the <span class="packt_screen">Terrain</span>, so we avoid any kind of Moire interference pattern due to meshes at the same location. By subtracting <kbd>rows/2</kbd> and <kbd>cols/2</kbd> for the <strong>X</strong> and <strong>Z</strong> positions, we center our grid of tiles at (<span class="packt_screen">0, Y, 0</span>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>There are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Yellow debug-ray to show destination of AI-agent</h1>
                </header>
            
            <article>
                
<p>We can show a debug ray from a moving object to its destination tile by creating the <kbd>MouseOverHighlighter</kbd><span> </span><span>C# script-class </span><span>with the following contents. We then add an instance-object as a component to the </span><span class="packt_screen">NavMeshAgent </span><span>controlled</span> <span class="packt_screen">Sphere-arrow</span> <span>GameObject:</span></p>
<pre>using UnityEngine;<br/> using UnityEngine.AI;<br/><br/>public class DebugRaySourceDestination : MonoBehaviour {<br/> void Update() {<br/> Vector3 origin = transform.position;<br/> Vector3 destination = GetComponent&lt;NavMeshAgent&gt;().destination;<br/> Vector3 direction = destination - origin;<br/> Debug.DrawRay(origin, direction, Color.yellow);<br/> }<br/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Point-and-click Raycast with user-defined higher-cost Navigation Areas</h1>
                </header>
            
            <article>
                
<p>Rather than indicating a desired destination by clicking an object or tile, we can use Unity's built-in <kbd>Physics.Raycast(...)</kbd> method to identify which Vector3 (x,y,z) position relates to the object surface in the game.</p>
<p>This involves translating from the 2D (x,y) screen position to an imagined 3D "ray" from the user's point of view, through the screen, into the game world, and identifying which object (polygon) it <strong>hits</strong> first.</p>
<p>This recipe uses <kbd>Physics.Raycast</kbd> to set the position of the location clicked on as the new destination for a <span class="packt_screen">NavMeshAgent</span> controller object. The actual route followed can be influenced by defining <span class="packt_screen">Navigation Mesh Areas</span> of different costs. For example, walking through mud or swimming through water can have a higher cost, since they would take longer, so the AI <span class="packt_screen">NavMeshAgent</span> can calculate the lowest-cost route, which may not be the shortest distance route in the scene:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/baf3c66d-d516-42c3-aff4-84fb0eb05523.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a point-and-click game using a <span class="packt_screen">Raycast</span>, do the following:</p>
<ol>
<li>Remove the <span class="packt_screen">Tile Manager (Script)</span> component from the <span class="packt_screen">Main Camera</span> GameObject.</li>
<li>Create a new 3D <span class="packt_screen">Sphere</span>, named <span class="packt_screen">Sphere-destination</span>, scaled to (0.5, 0.5, 0.5).</li>
<li>Create a new <span class="packt_screen">Material</span> that is red in color, and assign this material to the <span class="packt_screen">Sphere-destination</span> GameObject.</li>
</ol>
<ol start="4">
<li>Create a new <kbd>MoveToClickPoint</kbd> C# script-class containing the following, and add an instance-object as a component to the Sphere-arrow GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEngine.AI;<br/><br/>public class MoveToClickPoint : MonoBehaviour {<br/> public GameObject sphereDestination;<br/> private NavMeshAgent navMeshAgent;<br/> private RaycastHit hit;<br/><br/>void Start() {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> sphereDestination.transform.position = transform.position;<br/> }<br/><br/>void Update() {<br/> Ray rayFromMouseClick = Camera.main.ScreenPointToRay(Input.mousePosition);<br/><br/>if (FireRayCast(rayFromMouseClick)){<br/> Vector3 rayPoint = hit.point;<br/> ProcessRayHit(rayPoint);<br/> }<br/> }<br/><br/>private void ProcessRayHit(Vector3 rayPoint) {<br/> if(Input.GetMouseButtonDown(0)) {<br/> navMeshAgent.destination = rayPoint;<br/> sphereDestination.transform.position = rayPoint;<br/> }<br/> }<br/><br/>private bool FireRayCast(Ray rayFromMouseClick) {<br/> return Physics.Raycast(rayFromMouseClick, out hit, 100);<br/> }<br/> }</pre>
<ol start="5">
<li>Select the Sphere-arrow GameObject in the <span class="packt_screen">Hierarchy</span>, and in the <span class="packt_screen">Inspector</span> for the <span class="packt_screen">MoveToClickPoint (Script)</span> component, populate the <span class="packt_screen">Sphere Destination</span> public property with your red <span class="packt_screen">Sphere-destination</span> GameObject.</li>
</ol>
<ol start="6">
<li>Run the scene. You should now be able to click anywhere on the <span class="packt_screen">Terrain</span> to set the destination of the <span class="packt_screen">NavMeshAgent</span> controlled <span class="packt_screen">Sphere-arrow</span> GameObject. As you click, the red <span class="packt_screen">Sphere-destination</span> GameObject should be positioned at this new destination point, towards which the <span class="packt_screen">Sphere-arrow</span> GameObject will navigate.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You created a small red 3D <span class="packt_screen">Sphere</span> named <span class="packt_screen">Sphere-destination</span>.</p>
<p>There is one public variable for the <kbd>MoveToClickPoint</kbd> scripted component of the Sphere-arrow GameObject. This public <kbd>sphereDestination</kbd> variable has been linked to the red <span class="packt_screen">Sphere-destination</span> GameObject in the scene.</p>
<p>There are two private variables:</p>
<ul>
<li><kbd>navMeshAgent</kbd>: This will be set to refer to the <span class="packt_screen">NavMeshAgent</span> component of the Sphere-arrow GameObject, so its destination can be reset when appropriate.</li>
<li><kbd>hit</kbd>: This is a <kbd>RaycastHit</kbd> object, which is passed in as the object to be set by <kbd>Physics.Raycast(...)</kbd>. Various properties of this object are set after a <span class="packt_screen">Raycast</span> has been created, including the position in the scene where the <span class="packt_screen">Raycast</span> hit the surface of an object.</li>
</ul>
<p>The <kbd>Start()</kbd> method caches a reference to the <span class="packt_screen">NavMesh</span> component of the Sphere-arrow GameObject, and also moves the <span class="packt_screen">Sphere-destination</span> <span>GameObject</span><span> </span><span>to the current object's location.</span></p>
<p>Each frame, in the <kbd>Update()</kbd><span> </span><span>method</span><span>, a Ray is created based on the</span> <span class="packt_screen">Main Camera</span> <span>and the (2,y) point clicked on the screen. This</span> <span class="packt_screen">Ray</span> <span>is passed as a parameter to the </span><kbd>FireRayCast(...)</kbd><span> </span><span>method</span><span>. If that method returns true, then the position of the object hit is extracted and passed to the </span><kbd>ProcessRayHit(...)</kbd><span> </span><span>method</span><span>.</span></p>
<p>The <kbd>FireRayCast(...)</kbd> method receives a Ray object. It uses <kbd>Phyics.Raycast(...)</kbd> to determine whether the <span class="packt_screen">Raycast</span> collides with part of an object in the scene. If the <span class="packt_screen">Raycast</span> hits something, the properties of the <kbd>RaycastHit hit</kbd> object are updated. A true/false for whether <kbd>Physics.Raycast(...)</kbd> hit a surface is returned by this method.</p>
<p class="mce-root"/>
<p>Each time the user clicks on the screen, the corresponding object in the scene is identified with the <span class="packt_screen">Raycast</span>, the red sphere is moved there, and the <span class="packt_screen">NavMeshAgent</span> begins to navigate towards that location.</p>
<p>Learn more about the Unity <span class="packt_screen">Raycast</span> C# script-class at <a href="https://docs.unity3d.com/ScriptReference/RaycastHit.html." target="_blank"><span class="URLPACKT">https://docs.unity3d.com/ScriptReference/RaycastHit.html.</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>Here are some details that you won't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More intelligent pathfinding by setting different costs for custom-defined navigation areas such as Mud and Water</h1>
                </header>
            
            <article>
                
<p>We can create objects whose meshes are defined as more expensive for <span class="packt_screen">NavMeshAgents</span> to travel across, helping AI-agent behavior be more realistic in terms of choosing faster paths that avoid Water, Mud, and so on.</p>
<p>To create a custom <span class="packt_screen">NavMesh Area</span> (we'll pretend it's mud) with a higher travelling cost, do the following:</p>
<ol>
<li>In the <span class="packt_screen">Navigation</span> panel, reveal the areas by clicking the <span class="packt_screen">Areas</span> button. Then, define a new area named <span class="packt_screen">Mud</span> with a cost of <span class="packt_screen">2</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d0a0568-05f0-4116-aff1-f59577632589.png" style="width:19.50em;height:9.58em;"/></p>
<ol start="2">
<li>Create a new 3D <span class="packt_screen">Cylinder</span> named <span class="packt_screen">Cylinder-mud</span>, positioned at (<span class="packt_screen">0, -4.9, 0</span>) and scaled to (<span class="packt_screen">5,5,5</span>).</li>
<li>Ensure the <span class="packt_screen">Cylinder-mud</span> GameObject is selected in the Hierarchy, and that the <span class="packt_screen">Navigation</span> panel is displayed.</li>
</ol>
<ol start="4">
<li>In the <span class="packt_screen">Navigation</span> panel, click the <span class="packt_screen">Object</span> button, check <span class="packt_screen">Navigation Static</span>, and choose <span class="packt_screen">Mud</span> from the <span class="packt_screen">Navigation Area</span> drop-down list:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c68362d4-149c-45df-9624-ac853d490a85.png" style="width:27.92em;height:12.00em;"/></p>
<ol start="5">
<li>Now, click the <span class="packt_screen">Bake</span> button to show the <span class="packt_screen">Navigation</span><span class="packt_screen">Bake</span> sub-panel, and then in this sub-panel click the <span class="packt_screen">Bake</span> button to regenerate the <span class="packt_screen">Navigation Mesh</span> with the new object.</li>
</ol>
<p>Now, if you click to move the Sphere-arrow GameObject near the edge of the <span class="packt_screen">Cylinder-mud</span> area, then, say, click on the opposite side, you'll see the <span class="packt_screen">NavMeshAgent</span> make the Sphere-arrow GameObject follow a semi-circular (lowest cost) path around the edge of the <span class="packt_screen">Cylinder-mud</span> area, rather than follow a direct line (as the crow flies) path <em>through</em> the higher cost mud area:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3c20833a-cb82-4d40-9e15-d446f2ce068a.png" style="width:47.17em;height:13.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving UX by updating a "gaze" cursor each frame</h1>
                </header>
            
            <article>
                
<p>It's nice to know where our destination will be set to <strong>before</strong> we click the mouse. So, let's add a yellow sphere to show the 'candidate' destination for where our <span class="packt_screen">Raycast</span> is hitting a surface, updated each frame as we move the mouse.</p>
<p>So, we need to create a second, yellow sphere. We also need to create a <span class="packt_screen">Layer</span> to ignore; otherwise, if we move the yellow sphere to the point where a <span class="packt_screen">Raycast</span> hits a surface, then in the next frame our <span class="packt_screen">Raycast</span> will hit the surface of our yellow sphere - moving it closer and closer to us each frame!</p>
<p>To improve UX by updating a "gaze" cursor each frame, do the following:</p>
<ol>
<li>Create a new yellow <span class="packt_screen">Material</span> named <span class="packt_screen">m_yellow</span>.</li>
<li>Create a second 3D <span class="packt_screen">Sphere</span>, named <span class="packt_screen">Sphere-destination-candidate</span> and textured with <span class="packt_screen">m_yellow</span>.</li>
<li>Create a new Layer, <span class="packt_screen">UISpheres</span>.</li>
<li>Set the <span class="packt_screen">Layer</span> for both <span class="packt_screen">Sphere-destination</span> and <span class="packt_screen">Sphere-destination-candidate</span> GameObjects to <span class="packt_screen">Layer</span><span class="packt_screen">UISpheres</span>.</li>
<li>Modify the <kbd>MoveToClickPoint</kbd> C# script-class as follows to add a new public variable, <kbd>sphereDestinationCandidate</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public class MoveToClickPoint : MonoBehaviour {<br/>public GameObject sphereDestination;<br/>public GameObject sphereDestinationCandidate;</pre>
<ol start="6">
<li>Modify the <kbd>MoveToClickPoint</kbd> C# script-class as follows to add an <span class="packt_screen">Else-clause</span> <strong>to the logic in the</strong> <kbd>ProcessRayHit(...)</kbd><strong> method, so that if the mouse is</strong> not clicked, then the yellow <span class="packt_screen">sphereDestinationCandidate</span> object is moved to where the <span class="packt_screen">Raycast</span> hit a surface:</li>
</ol>
<pre style="padding-left: 60px">private void ProcessRayHit(Vector3 rayPoint) {<br/> if(Input.GetMouseButtonDown(0)) {<br/> navMeshAgent.destination = rayPoint;<br/> sphereDestination.transform.position = rayPoint;<br/> } else {<br/> sphereDestinationCandidate.transform.position = rayPoint;<br/> }<br/> }</pre>
<ol start="7">
<li>Modify the <kbd>MoveToClickPoint</kbd> C# script-class as follows, so that a <kbd>LayerMask</kbd> is created to ignore <span class="packt_screen">Layer UISpheres</span>, and passed as a parameter when <kbd>Physics.Raycast(...)</kbd> is invoked:</li>
</ol>
<pre style="padding-left: 60px">private bool FireRayCast(Ray rayFromMouseClick) {<br/> LayerMask layerMask = ~LayerMask.GetMask("UISpheres");<br/> return Physics.Raycast(rayFromMouseClick, out hit, 100, layerMask.value);<br/> }</pre>
<ol start="8">
<li>Select the Sphere-arrow GameObject in the <span class="packt_screen">Hierarchy</span>, and in the <span class="packt_screen">Inspector</span> for the <span class="packt_screen">MoveToClickPoint (Script)</span> component, populate the <span class="packt_screen">Sphere Destination Candidate</span> public property with your yellow <span class="packt_screen">Sphere-destination-candidate</span> GameObject.</li>
<li>Run the scene. You should now be able to click anywhere on the <span class="packt_screen">Terrain</span> to set the destination of the <span class="packt_screen">NavMeshAgent</span> controlled <span class="packt_screen">Sphere-arrow</span> GameObject. As you click, the red <span class="packt_screen">Sphere-destination</span> GameObject should be positioned at this new destination point, towards which the <span class="packt_screen">Sphere-arrow</span> GameObject will navigate.</li>
</ol>
<div class="packt_infobox">We have set a <kbd>LayerMask</kbd> using the <kbd>~LayerMask.GetMask("UISpheres") </kbd>statement<span>, which means every layer apart from the named one. This is passed to the</span> <kbd>Raycast(...)</kbd> <span>method, so that our red and yellow</span> <span class="packt_screen">Spheres</span> <span>are ignored when casting the ray and looking to see which surface the ray hits first.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NPC NavMeshAgent to follow waypoints in a sequence</h1>
                </header>
            
            <article>
                
<p>Waypoints are often used as a guide to make autonomously moving NPCs and enemies follow a path in a general way, but be able to respond with other directional behaviors, such as flee or seek, if friends/predators/prey are sensed nearby. The waypoints are arranged in a sequence, so that when the character reaches or gets close to a waypoint, it will then select the next waypoint in the sequence as the target location to move towards. This recipe demonstrates an arrow object moving towards a waypoint, and then when it gets close enough, it will choose the next waypoint in the sequence as the new target destination. When the last waypoint has been reached, it again starts heading towards the first waypoint.</p>
<p>Since Unity's <span class="packt_screen">NavMeshAgent</span> has simplified coding NPC behavior, our work in this recipe <span>basically</span><span> </span><span>becomes finding the position of the next waypoint and then telling the</span> <span class="packt_screen">NavMeshAgent</span> <span>that this waypoint is its new destination:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b2a12d87-0083-436f-9144-ade4dbd9850d.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe adds to the first recipe in this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p>For this recipe, we have prepared the yellow brick texture image that you need in a folder named <span class="packt_screen">Textures</span> in the <kbd>1362_08_06</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To instruct an object to follow a sequence of waypoints, follow these steps:</p>
<ol>
<li>Replace the contents of the <kbd>ArrowNPCMovement</kbd> C# script class with the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEngine.AI;<br/><br/>public class ArrowNPCMovement : MonoBehaviour {<br/> private GameObject targetGo = null;<br/> private WaypointManager waypointManager;<br/> private NavMeshAgent navMeshAgent;<br/><br/>void Start () {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> waypointManager = GetComponent&lt;WaypointManager&gt;();<br/> HeadForNextWayPoint();<br/> }<br/><br/>void Update () {<br/> float closeToDestinaton = navMeshAgent.stoppingDistance * 2;<br/> if (navMeshAgent.remainingDistance &lt; closeToDestinaton) {<br/> HeadForNextWayPoint ();<br/> }<br/> }<br/><br/>private void HeadForNextWayPoint () {<br/> targetGo = waypointManager.NextWaypoint (targetGo);<br/> navMeshAgent.SetDestination (targetGo.transform.position);<br/> }<br/> }</pre>
<ol start="2">
<li>Create a new 3D <span class="packt_screen">Capsule</span> object named <span class="packt_screen">Capsule-waypoint-0</span> at <span class="packt_screen">(-12, 0, 8</span>).</li>
<li>Copy <span class="packt_screen">Capsule-waypoint-0</span>, name the copy <span class="packt_screen">Capsule-waypoint-3</span>, and position this copy at (<span class="packt_screen">8, 0, -8</span>).</li>
</ol>
<div class="packt_infobox">We are going to add some intermediate waypoints numbered 1 and 2 later on. This is why our second waypoint here is numbered 3, in case you were wondering.</div>
<ol start="4">
<li>Create the <kbd>WaypointManager</kbd> C# script class with the following contents, and add an instance-object as a component to the Sphere-arrow GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/> public class WaypointManager : MonoBehaviour {<br/> public GameObject wayPoint0;<br/> public GameObject wayPoint3;<br/><br/>public GameObject NextWaypoint(GameObject current) {<br/> if(current == wayPoint0)<br/> return wayPoint3;<br/><br/>return wayPoint0;<br/> }<br/> }</pre>
<ol start="5">
<li>Ensure that <span class="packt_screen">Sphere-arrow</span> is selected in the Inspector for the <kbd>WaypointManager</kbd> scripted component. Drag <span class="packt_screen">Capsule-waypoint-0</span> and <span class="packt_screen">Capsule-waypoint-3</span> over the public variable projectiles called <span class="packt_screen">Way Point 0</span> and <span class="packt_screen">Way Point 3</span>, respectively.</li>
<li>Now, run your game. The arrow object will first move towards one of the waypoint capsules, then when it gets close to it, it will slow down, turn around, head towards the other waypoint capsule, and keep doing that continuously.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">NavMeshAgent</span> component that we added to the <span class="packt_screen">Sphere-arrow</span> GameObject does most of the work for us. <span class="packt_screen">NavMeshAgent</span> needs two things:</p>
<ul>
<li>A destination location to head towards</li>
<li>A <span class="packt_screen">NavMesh</span>, so that it can plan a path and avoid obstacles</li>
</ul>
<p>We created two possible waypoints as the locations for our NPC to move towards: <span class="packt_screen">Capsule-waypoint-0</span> and <span class="packt_screen">Capsule-waypoint-3</span>.</p>
<p>The C# script class called <kbd>WaypointManager</kbd> has one job: to return a reference to the next waypoint that our NPC should head towards. There are two variables, <kbd>wayPoint0</kbd> and <kbd>wayPoint3</kbd>, which reference the two waypoint GameObjects in our scene. The <kbd>NextWaypoint(...)</kbd> method takes a single parameter named current, which is a reference to the current waypoint that the object is moving towards (or <kbd>null</kbd>). This method's task is to return a reference to the next waypoint that the NPC should travel towards. The logic for this method is simple: if current refers to waypoint0, then we'll return <kbd>waypoint3</kbd>; otherwise, we'll return <kbd>waypoint0</kbd>. Note that if we pass this method <kbd>null</kbd>, then we'll get <kbd>waypoint0</kbd> back (so, it is our default first waypoint).</p>
<p>The <kbd>ArrowNPCMovement</kbd><span> </span><span>C# script class </span><span>has three variables. One is a reference to the destination GameObject named</span> <kbd>targetGo</kbd><span>. The second is a reference to the</span> <kbd>NavMeshAgent</kbd> <span>component of the GameObject in which our instance of the class called</span> <kbd>ArrowNPCMovement</kbd> <span>is also a component. The third variable, called</span> <kbd>waypointManager</kbd><span>, is a reference to the sibling scripted component, an instance of our</span> <kbd>WaypointManager</kbd> <span>script class.</span></p>
<p>When the scene starts via the <kbd>Start()</kbd> method, the <span class="packt_screen">NavMeshAgent</span> and <span class="packt_screen">WaypointManager</span> sibling components are found, and the <kbd>HeadForDestination()</kbd> method is called.</p>
<p>The <kbd>HeadForDestination()</kbd> method first sets the variable called <kbd>targetGO</kbd> to refer to the GameObject that is returned by a call to the <kbd>NextWaypoint(...)</kbd> of the scripted component called <span class="packt_screen">WaypointManager</span> (that is, <kbd>targetGo</kbd> is set to refer to either <span class="packt_screen">Capsule-waypoint-0</span> or <span class="packt_screen">Capsule-waypoint-3</span>). Next, it instructs the <kbd>NavMeshAgent</kbd> to make its destination the position of the <kbd>targetGO</kbd> GameObject.</p>
<p>Each frame method called <kbd>Update()</kbd> is called. A test is made to see whether the distance from the NPC arrow object is close to the destination waypoint. If the distance is smaller than twice the stopping distance set in our <span class="packt_screen">NavMeshAgent</span>, then a call is made to <kbd>WaypointManager.NextWaypoint(...)</kbd> to update our target destination to be the next waypoint in the sequence.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Here are some details that you won't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with arrays of waypoints</h1>
                </header>
            
            <article>
                
<p>Having a separate <kbd>WaypointManager</kbd><span> </span><span>C# script-class </span><span>to simply swap between</span> <span class="packt_screen">Capsule-waypoint-0</span> <span>and</span> <span class="packt_screen">Capsule-waypoint-3</span> <span>may have seemed to be a bit heavy duty and a case of over-engineering, but this was actually a very good move. An instance-object of the </span><kbd>WaypointManager</kbd><span> </span><span>script-class</span><span> </span><span>has the job of returning the next waypoint. It is now very straightforward to add the more sophisticated approach of having an array of waypoints, without us having to change any code in the </span><kbd>ArrowNPCMovement</kbd><span> </span><span>C# script-class</span><span>. We can choose a random waypoint to be the next destination; for example, see the </span><em>Choosing destinations - find nearest (or a random) spawnpoint<span> </span></em><span>recipe in</span> <span class="KeyPACKT"><a href="eb0ea442-6350-4a86-9e16-708b80d8762f.xhtml" target="_blank">Chapter 14</a>, <em>Choosing and Controlling Positions</em></span><span>. Or, we can have an array of waypoints and choose the next one in the sequence.</span></p>
<p>To improve our game so that it works with an array of waypoints to be followed <span>in sequence</span><span>, we need to do the following:</span></p>
<ol>
<li>Copy <span class="packt_screen">Capsule-waypoint-0</span>, name the copy <span class="packt_screen">Capsule-waypoint-1</span>, and position this copy at (<span class="packt_screen">0, 0, 8</span>).</li>
<li>Make four more copies (named <span class="packt_screen">Capsule-waypoint-1, 2, 4, 5</span>), and position them as follows:
<ul>
<li><span class="packt_screen">Capsule-waypoint-1</span>: Position = (<span class="packt_screen">-2, 0, 8</span>)</li>
<li><span class="packt_screen">Capsule-waypoint-2</span>: Position = (<span class="packt_screen">8, 0, 8</span>)</li>
<li><span class="packt_screen">Capsule-waypoint-4</span>: Position = <span class="packt_screen">(-2, 0, -8</span>)</li>
<li><span class="packt_screen">Capsule-waypoint-5</span>: Position = <span class="packt_screen">(-12, 0, -8</span>)</li>
</ul>
</li>
<li>Replace the <kbd>WaypointManager</kbd> C# script-class with the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System;<br/><br/>public class WaypointManager : MonoBehaviour {<br/> public GameObject[] waypoints;<br/><br/>public GameObject NextWaypoint (GameObject current) {<br/> if( waypoints.Length &lt; 1)<br/> Debug.LogError ("WaypointManager:: ERROR - no waypoints have been added to array!");<br/><br/>int currentIndex = Array.IndexOf(waypoints, current);<br/> int nextIndex = (currentIndex + 1) % waypoints.Length;<br/><br/>return waypoints[nextIndex];<br/> }<br/> }</pre>
<ol start="4">
<li>Ensure that <span class="packt_screen">Sphere-</span><span class="packt_screen">arrow</span> is selected. In the <span class="packt_screen">Inspector</span> panel for the <kbd>WaypointManager</kbd> scripted component, set the size of the Waypoints array to 6. Now, drag in all six capsule waypoint objects called <span class="packt_screen">Capsule-waypoint-0/1/2/3/4/5</span>.</li>
<li>Run the game. Now, the <span class="packt_screen">Sphere-arrow</span> GameObject will first move towards waypoint 0 (top left), and then follow the sequence around the terrain.</li>
<li>Finally, you can make it look as if the <span class="packt_screen">Sphere</span> is following a yellow brick road. Import the provided yellow brick texture, add this to your terrain, and paint the texture to create an oval-shaped path between the waypoints. You may also uncheck the <span class="packt_screen">Mesh Renderer</span> component for each waypoint capsule, so that the user does not see any of the waypoints, just the arrow object following the yellow brick road.</li>
</ol>
<p>In the <kbd>NextWaypoint(...)</kbd> method, first we check in case the array is empty, in which case an error is logged. Next, the array index for the current <kbd>waypoint</kbd> GameObject is found (if present in the array). Finally, the array index for the next waypoint is calculated using a modulus operator to support a cyclic sequence, returning to the beginning of the array after the last element has been visited.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Increased flexibility with a WayPoint class</h1>
                </header>
            
            <article>
                
<p>Rather than forcing a GameObject to follow a single rigid sequence of locations, we can make things more flexible by defining a <kbd>WayPoint</kbd> class where each waypoint GameObject has an array of possible destinations, and each of these has its own array. In this way, a digraph (directed graph) can be implemented, of which a linear sequence is just one possible instance.</p>
<p>To improve our game and make it work with a digraph of waypoints, do the following:</p>
<ol>
<li>Remove the scripted <kbd>WayPointManager</kbd> component from the <span class="packt_screen">Sphere-arrow</span> GameObject.</li>
<li>Replace the <kbd>ArrowNPCMovement</kbd> C# script-class with the following code:</li>
</ol>
<pre style="padding-left: 60px"> using UnityEngine;<br/> using System.Collections;<br/><br/> public class ArrowNPCMovement : MonoBehaviour {<br/> public Waypoint waypoint;<br/> private bool firstWayPoint = true;<br/> private NavMeshAgent navMeshAgent;<br/><br/> void Start (){<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> HeadForNextWayPoint();<br/> }<br/><br/> void Update () {<br/> float closeToDestinaton = navMeshAgent.stoppingDistance * 2;<br/> if (navMeshAgent.remainingDistance &lt; closeToDestinaton){<br/> HeadForNextWayPoint ();<br/> }<br/> }<br/><br/> private void HeadForNextWayPoint (){<br/> if(firstWayPoint)<br/> firstWayPoint = false;<br/> else<br/> waypoint = waypoint.GetNextWaypoint();<br/><br/> Vector3 target = waypoint.transform.position;<br/> navMeshAgent.SetDestination (target);<br/> }<br/> }</pre>
<ol start="3">
<li>Create a new <kbd>WayPoint</kbd> C# script-class containing the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>public class Waypoint: MonoBehaviour {<br/>public Waypoint[] waypoints;<br/><br/>public Waypoint GetNextWaypoint () {<br/>return waypoints[ Random.Range(0, waypoints.Length) ];<br/> }<br/> }</pre>
<ol start="4">
<li>Select all six GameObjects called <span class="packt_screen">Capsule-waypoint -0/1/2/3/4/5</span> and add to them an instance-object component of the <kbd>WayPoint</kbd> C# class.</li>
<li>Select the <span class="packt_screen">Sphere-arrow</span> GameObject and add to it an instance-object component of the <kbd>WayPoint</kbd> C# class.</li>
<li>Ensure that the <span class="packt_screen">Sphere-arrow</span> GameObject is selected. In the <span class="packt_screen">Inspector</span> panel for the ArrowNPCMovement scripted component, drag <span class="packt_screen">Capsule-waypoint-0</span> into the <kbd>Waypoint</kbd> public variable slot.</li>
</ol>
<ol start="7">
<li>Now, we need to link <span class="packt_screen">Capsule-waypoint-0</span> to <span class="packt_screen">Capsule-waypoint-1</span>, <span class="packt_screen">Capsule-waypoint-1</span> to <span class="packt_screen">Capsule-waypoint -2</span>, and so on. Select <span class="packt_screen">Capsule-waypoint-0</span>, set its <span class="packt_screen">Waypoints</span> array size to <span class="packt_screen">1</span>, and drag in <span class="packt_screen">Capsule-waypoint-1</span>. Next, select <span class="packt_screen">Capsule-waypoint-1</span>, set its <span class="packt_screen">Waypoints</span> array size to <span class="packt_screen">1</span>, and drag in <span class="packt_screen">Capsule-waypoint-2</span>. Continue in this way until you finally link <span class="packt_screen">Capsule-waypoint-5</span> back to <span class="packt_screen">Capsule-waypoint-0</span>.</li>
</ol>
<p>You now have a much more flexible game architecture, allowing GameObjects to randomly select one of several different paths at each waypoint reached. In this recipe variation, we have implemented a waypoint sequence, since each waypoint has an array of just one linked waypoint. However, if you change the array size to 2 or more, you will then be creating a graph of linked waypoints, adding random variations in the sequence of waypoints that a computer controlled character follows for any given run of your game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling object group movement through flocking</h1>
                </header>
            
            <article>
                
<p>A realistic, natural-looking flocking behavior (for example birds, antelope, or bats) can be created through creating collections of objects with the following four simple rules:</p>
<ul>
<li><strong>Separation</strong>: Avoid getting too close to neighbors</li>
<li><strong>Avoid obstacles</strong>: Turn away from an obstacle immediately ahead</li>
<li><strong>Alignment</strong>: Move in the general direction the flock is heading</li>
<li><strong>Cohesion</strong>: Move towards a location in the middle of the flock</li>
</ul>
<p>Each member of the flock acts independently, but needs to know about the current heading and location of the members of its flock. This recipe shows you how to create a scene with two flocks of cubes: one flock of green cubes and one flock of yellow cubes.</p>
<p>To keep things simple, we'll not worry about separation in our recipe:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3900a762-31ec-41ad-8a49-9d631f9d5401.png" style="width:31.50em;height:13.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe builds upon the player-controlled 3D cube Unity project that you created in the first recipe. So, make a copy of this project, open it, and then follow the steps for this recipe.</p>
<p>The required script to control movement of the red Cube (<kbd>PlayerControl.cs</kbd>) is provided in the <kbd>15_07</kbd><span> folder</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To make a group of objects flock together, please follow these steps:</p>
<ol>
<li>Create a <span class="packt_screen">Material</span> in the <span class="packt_screen">Project</span> panel and name it <span class="packt_screen">m_green</span> with the <span class="packt_screen">Main Color</span> tinted green.</li>
<li>Create a <span class="packt_screen">Material</span> in the <span class="packt_screen">Project</span> panel and name it <span class="packt_screen">m_yellow</span> with <span class="packt_screen">Main Color</span> tinted yellow.</li>
<li>Create a 3D <span class="packt_screen">Cube</span> GameObject named <span class="packt_screen">Cube-drone</span> at (0,0,0). Drag the <span class="packt_screen">m_yellow</span> Material into this object.</li>
<li>Add a <span class="packt_screen">Navigation | NavMeshAgent</span> component to <span class="packt_screen">Cube-drone</span>. Set the <span class="packt_screen">Stopping Distance</span> property of the <span class="packt_screen">NavMeshAgent</span> component to <span class="packt_screen">2</span>.</li>
<li>Add a <span class="packt_screen">Physics RigidBody</span> component to <span class="packt_screen">Cube-drone</span> with the following properties:
<ul>
<li><span class="packt_screen">Mass</span> is 1</li>
<li><span class="packt_screen">Drag</span> is 0</li>
<li><span class="packt_screen">Angular Drag</span> is 0.05</li>
<li><span class="packt_screen">Use Gravity</span> and <span class="packt_screen">Is Kinematic</span> are both unchecked</li>
<li><span class="packt_screen">Constraints Freeze Position:</span> check the<span class="packt_screen"> </span>Y-axis</li>
</ul>
</li>
<li>Create the following <kbd>Drone</kbd> C# script-class, and add an instance-object as a component to the <span class="packt_screen">Cube-drone</span> GameObject:</li>
</ol>
<pre style="padding-left: 60px"> using UnityEngine;<br/> using UnityEngine.AI;<br/><br/> public class Drone : MonoBehaviour {<br/> private NavMeshAgent navMeshAgent;<br/><br/> void Start() {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> }<br/><br/> public void SetTargetPosition(Vector3 swarmCenterAverage, Vector3 swarmMovementAverage) {<br/> Vector3 destination = swarmCenterAverage + swarmMovementAverage;<br/> navMeshAgent.SetDestination(destination);<br/> }<br/> }</pre>
<ol start="7">
<li>Create a new empty <strong>Prefab</strong> named <span class="packt_screen">dronePrefabYellow</span>, and from the <span class="packt_screen">Hierarchy</span> panel, drag your <span class="packt_screen">Cube-boid</span> GameObject into this Prefab.</li>
<li>Now, drag the <span class="packt_screen">m_green</span> Material into the <span class="packt_screen">Cube-boid</span> GameObject.</li>
<li>Create a new empty <span class="packt_screen">Prefab</span> named <span class="packt_screen">dronePrefabGreen</span>, and from the <span class="packt_screen">Hierarchy</span> panel, drag your <span class="packt_screen">Cube-drone</span> GameObject into this Prefab.</li>
<li>Delete the <span class="packt_screen">Cube-drone</span> GameObject from the <span class="packt_screen">Scene</span> panel.</li>
<li>Create the following <kbd>Swarm</kbd> C# script-class, and add an instance-object as a component to the <span class="packt_screen">Main Camera</span>:</li>
</ol>
<pre style="padding-left: 90px">using UnityEngine;<br/> using System.Collections.Generic;<br/><br/>public class Swarm : MonoBehaviour {<br/> public int droneCount = 20;<br/> public GameObject dronePrefab;<br/><br/>private List&lt;Drone&gt; drones = new List&lt;Drone&gt;();<br/><br/>void Awake() {<br/> for (int i = 0; i &lt; droneCount; i++)<br/> AddDrone();<br/> }<br/><br/>void FixedUpdate() {<br/> Vector3 swarmCenter = SwarmCenterAverage();<br/> Vector3 swarmMovement = SwarmMovementAverage();<br/><br/>foreach(Drone drone in drones )<br/> drone.SetTargetPosition(swarmCenter, swarmMovement);<br/> }<br/><br/>private void AddDrone()<br/> {<br/> GameObject newDroneGo = Instantiate(dronePrefab);<br/> Drone newDrone = newDroneGo.GetComponent&lt;Drone&gt;();<br/> drones.Add(newDrone);<br/> }<br/><br/>private Vector3 SwarmCenterAverage() {<br/> Vector3 locationTotal = Vector3.zero;<br/> foreach(Drone drone in drones )<br/> locationTotal += drone.transform.position;<br/><br/>return (locationTotal / drones.Count);<br/> }<br/><br/>private Vector3 SwarmMovementAverage() {<br/> Vector3 velocityTotal = Vector3.zero;<br/> foreach(Drone drone in drones )<br/> velocityTotal += drone.GetComponent&lt;Rigidbody&gt;().velocity;<br/><br/>return (velocityTotal / drones.Count);<br/> }<br/> }</pre>
<ol start="12">
<li>With <span class="packt_screen">Main Camera</span> selected in the <span class="packt_screen">Hierarchy</span> panel, drag <span><span class="packt_screen">dronePrefabYellow</span></span> from the <span class="packt_screen">Project</span> panel over the <span class="packt_screen">Drone Prefab</span> public variable.</li>
<li>With <span class="packt_screen">Main Camera</span> selected in the <span class="packt_screen">Hierarchy</span> panel, add a second instance-object of the <kbd>Swarm</kbd> script-class to this GameObject, and then drag <span><span><span class="packt_screen">dronePrefabGreen</span></span></span> from the <span class="packt_screen">Project</span> panel over the <span class="packt_screen">Drone Prefab</span> public variable.</li>
<li>Create a new 3D <span class="packt_screen">Cube</span> named <span class="packt_screen">wall-left</span> with the following properties:
<ul>
<li><span class="packt_screen">Position</span>: (-15, 0.5, 0)</li>
<li><span class="packt_screen">Scale</span>: (1, 1, 20)</li>
</ul>
</li>
</ol>
<ol start="15">
<li>Duplicate the <span class="packt_screen">wall-left</span> object by naming the new object <span class="packt_screen">wall-right</span>, and change the position of wall-right to (15, 0.5, 0).</li>
<li>Create a new 3D <span class="packt_screen">Cube</span> named <span class="packt_screen">wall-top</span> with the following properties:
<ul>
<li><span class="packt_screen">Position</span>: (0, 0.5, 10)</li>
<li><span class="packt_screen">Scale</span>: (31, 1, 1)</li>
</ul>
</li>
<li>Duplicate the <span class="packt_screen">wall-top</span> object by naming the new object <span class="packt_screen">wall-bottom</span>, and change the position of wall-bottom to (0, 0.5, -10).</li>
<li>Create a new 3D <span class="packt_screen">Sphere</span> named <span class="packt_screen">Sphere-obstacle</span> with the following properties:
<ul>
<li><span class="packt_screen">Position</span>: (5, 0, 3)</li>
<li><span class="packt_screen">Scale</span>: (10, 3, 3)</li>
</ul>
</li>
<li>In the <span class="packt_screen">Hierarchy</span> panel, select the <span class="packt_screen">Sphere-obstacle</span> GameObject. Then in the <span class="packt_screen">Navigation</span> panel, check the <span class="packt_screen">Navigation Static</span> checkbox. Then, click on the <span class="packt_screen">Bake</span> button at the bottom of the <span class="packt_screen">Navigation</span> panel.</li>
<li>Finally, create a red 3D <span class="packt_screen">Cube</span> for the player to control, making it red by adding <span class="packt_screen">Material</span><span class="packt_screen">m_red</span> to it and making it large by setting its scale to (3,3,3). Now, add an instance-object of the <kbd>PlayerControl</kbd> C# script-class provided as a component to this GameObject.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The Swarm class contains three variables:</p>
<ol>
<li><kbd>droneCount</kbd>: It is an integer referencing the number of the Swarm class members created</li>
<li><kbd>dronePrefab</kbd>: It references the Prefab to be cloned to create swarm members</li>
<li><kbd>drones</kbd>: A list of objects that reference drones; a list of all the scripted <kbd>Drone</kbd> components inside all the <kbd>Swarm</kbd> objects that have been created</li>
</ol>
<p>Upon creation, as the scene starts, the Swarm script class's <kbd>Awake()</kbd> method loops to create <kbd>droneCount</kbd> swarm members by repeatedly calling the <kbd>AddDrone()</kbd> method. This method instantiates a new GameObject from the prefab, and then sets the <kbd>newDrone</kbd> variable to be a reference to the Drone scripted object inside the new <kbd>Swarm</kbd> class member. In each frame, the <kbd>FixedUpdate()</kbd> method loops through the list of <kbd>Drone</kbd> objects by calling their <kbd>SetTargetPosition(...)</kbd> method, and passes in the <kbd>Swarm</kbd> center location and the average of all the swarm member velocities.</p>
<p>The rest of this <kbd>Swarm</kbd> class is made up of two methods: one (<kbd>SwarmCenterAverage</kbd>) returns a <kbd>Vector3</kbd> object representing the average position of all the <kbd>Drone</kbd> objects, and the other (<kbd>SwarmMovementAverage</kbd>) returns a <kbd>Vector3</kbd> object representing the average velocity (movement force) of all the <kbd>Drone</kbd> objects:</p>
<ol>
<li><kbd>SwarmMovementAverage()</kbd>:
<ol>
<li>What is the general direction that the swarm is moving in?</li>
<li>This is known as alignment: a swarm member attempting to move in the same direction as the swarm average</li>
</ol>
</li>
<li><kbd>SwarmCenterAverage()</kbd>:
<ol>
<li>What is the center position of the swarm?</li>
<li>This is known as cohesion: a swarm member attempting to move towards the center of the swarm</li>
</ol>
</li>
</ol>
<p>The core work is undertaken by the <kbd>Drone</kbd> class. Each drone's <kbd>Start(...)</kbd> method finds and caches a reference to its <span class="packt_screen">NavMeshAgent</span> component.</p>
<p>Each drone's <kbd>UpdateVelocity(...)</kbd> method takes as input two <kbd>Vector3</kbd> arguments: <kbd>swarmCenterAverage</kbd> and <kbd>swarmMovementAverage</kbd>. This method then calculates the desired new velocity for this <kbd>Drone</kbd> by simply adding the two vectors, and then uses the result (a <kbd>Vector3</kbd> location) to update the <span class="packt_screen">NavMeshAgent's</span> target location.</p>
<p>Most of the flocking models in modern computing owe much to the work of Craig Reynolds in the 1980s. Learn more about Craig and his boids program at <span class="URLPACKT"><a href="http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)" target="_blank">http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a movable NavMesh Obstacle</h1>
                </header>
            
            <article>
                
<p>Sometimes, we want a moving object to slow down or prevent an AI <span class="packt_screen">NavMeshAgent </span>controlled character passing through an area of our game. Or, perhaps we want something like a door or drawbridge to sometimes permit travel, and not at other times. We can't "bake" these objects into the <span class="packt_screen">NavMesh</span> at <span class="packt_screen">Design-Time</span>, since we want to change them during <span class="packt_screen">Run-Time</span>.</p>
<p>While computationally more expensive (that is, they slow down your game more that static non-navigable objects), <span class="packt_screen">NavMesh Obstacles</span> are components that can be added to GameObjects, and these components can be enabled and disabled like any other component.</p>
<p>A special property of <span class="packt_screen">NavMesh Obstacles</span> is that they can be set to "carve out" areas of the <span class="packt_screen">NavMesh</span>, causing <span class="packt_screen">NavMeshAgents</span> to then recalculate routes that avoid these carved out parts of the mesh.</p>
<p>In this recipe, you'll create a player-controlled red <span class="packt_screen">Cube</span>, which you can move to obstruct an AI <span class="packt_screen">NavMeshAgent </span>controlled character. Also, if your cube stays in one place for a half-second or longer, it will carve out part of the <span class="packt_screen">NavMesh</span> around it, and so cause the <span class="packt_screen">NavMeshAgent</span> to stop bumping into the obstacle, and calculate and follow a path that avoids it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/78f156e6-4080-48b0-8eb5-8b829f2dbba4.png" style="width:18.33em;height:9.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe adds to the first recipe in this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p>The required script to control the movement of the red Cube (<kbd>PlayerControl.cs</kbd>) is provided in the <kbd>15_08</kbd><span> </span><span>folder</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a movable <span class="packt_screen">NavMesh Obstacle</span>, please follow these steps:</p>
<ol>
<li>Create a <span class="packt_screen">Material</span> in the <span class="packt_screen">Project</span> panel, and name it <span class="packt_screen">m_green</span> with the <span class="packt_screen">Main Color</span> tinted green.</li>
<li>Create a red 3D <span class="packt_screen">Cube</span> for the player to control, named <span class="packt_screen">Cube-player</span>, making it red by added <span class="packt_screen">Material m_red</span> to it and making it large by setting its scale to (3,3,3).</li>
<li>Add an instance of the provided <kbd>PlayerControl</kbd> C# script-class as a component to this GameObject.</li>
</ol>
<ol start="4">
<li>In the <span class="packt_screen">Inspector,</span> add a <span class="packt_screen">Navigation | NavMesh Obstacle</span> component to <span class="packt_screen">Cube-player</span> and check its <span class="packt_screen">Carve</span> property.</li>
<li>Run the game. You can move the player-controlled red <span class="packt_screen">Cube</span> to get in the way of the moving Sphere-arrow GameObject. After the <span class="packt_screen">NavMesh Obstacles Time-to-stationary</span> time of half a second, if you have <span class="packt_screen">Gizmos</span> displayed, you'll see the carving out of the <span class="packt_screen">NavMesh</span>, so that the area occupied by <span class="packt_screen">Cube-player</span>, and a little way around it, is removed from the <span class="packt_screen">NavMesh</span>, and the Sphere-arrow GameObject will then recalculate a new route, avoiding the carved out area where <span class="packt_screen">Cube-player</span> is located.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>At <span class="packt_screen">Run-Time</span>, the AI <span class="packt_screen">NavMeshAgent </span>controlled Sphere-arrow GameObject heads towards the destination point, but stops when the player-controlled red <span class="packt_screen">Cube</span> is in its way. Once the <span class="packt_screen">Cube</span> is stationary for 0.5 seconds or more, the <span class="packt_screen">NavMesh</span> is carved out, so that the AI <span class="packt_screen">NavMeshAgent </span>controlled <strong>Sphere-arrow</strong> GameObject no longer even attempts to plan a path through the space occupied by the cube, and recalculates a new path completely avoiding the obstacle, even if it means back-tracking and heading away from the target for part of its path.</p>


            </article>

            
        </section>
    </body></html>