["```cs\n    using UnityEngine;\n\n    public class PictureInPicture: MonoBehaviour {\n      public enum hAlignment{left, center, right};\n      public enum vAlignment{top, middle, bottom};\n      public hAlignment horAlign = hAlignment.left;\n      public vAlignment verAlign = vAlignment.top;\n      public enum UnitsIn{pixels, screen_percentage};\n      public UnitsIn unit = UnitsIn.pixels;\n      public int width = 50;\n      public int height= 50;\n      public int xOffset = 0;\n      public int yOffset = 0;\n      public bool  update = true;\n      private int hsize, vsize, hloc, vloc;\n\n      void Start (){\n        AdjustCamera ();\n      }\n\n      void Update (){\n        if(update)\n        AdjustCamera ();\n      }\n\n      void AdjustCamera(){\n        int sw = Screen.width;\n        int sh = Screen.height;\n        float swPercent = sw * 0.01f;\n        float shPercent = sh * 0.01f;\n        float xOffPercent = xOffset * swPercent;\n        float yOffPercent = yOffset * shPercent;\n        int xOff;\n        int yOff;\n        if(unit == UnitsIn.screen_percentage){\n          hsize = width * (int)swPercent;\n          vsize = height * (int)shPercent;\n          xOff = (int)xOffPercent;\n          yOff = (int)yOffPercent;\n        } else {\n          hsize = width;\n          vsize = height;\n          xOff = xOffset;\n          yOff = yOffset;\n        }\n\n        switch (horAlign) {\n          case hAlignment.left:\n          hloc = xOff;\n          break;\n          case hAlignment.right:\n          int justfiedRight = (sw - hsize);\n          hloc = (justfiedRight - xOff);\n          break;\n          case hAlignment.center:\n          float justifiedCenter = (sw * 0.5f) - (hsize * 0.5f);\n          hloc = (int)(justifiedCenter - xOff);\n          break;\n        }\n\n        switch (verAlign) {\n          case vAlignment.top:\n          int justifiedTop = sh - vsize;\n          vloc = (justifiedTop - (yOff));\n          break;\n          case vAlignment.bottom:\n          vloc = yOff;\n          break;\n          case vAlignment.middle:\n          float justifiedMiddle = (sh * 0.5f) - (vsize * 0.5f);\n          vloc = (int)(justifiedMiddle - yOff);\n          break;\n        }\n\n        GetComponent<Camera>().pixelRect = new Rect(hloc,vloc,hsize,vsize);\n      }\n    }\n    ```", "```cs\nGetComponent<Camera>().pixelRect = new Rect(hloc,vloc,hsize,vsize);\n```", "```cs\n    using UnityEngine;\n\n    public class CameraSwitch : MonoBehaviour {\n      public GameObject[] cameras;\n      public string[] shortcuts;\n      public bool  changeAudioListener = true;\n      void  Update (){\n        if (Input.anyKeyDown) {\n          for (int i=0; i<cameras.Length; i++) {\n            if (Input.GetKeyDown (shortcuts [i]))\n              SwitchCamera (i);\n          }\n        }\n      }\n\n    void  SwitchCamera (int indexToSelect){\n      for (int i = 0; i<cameras.Length; i++){\n        // test whether current array index matches camera to make active\n          bool cameraActive = (i == indexToSelect);\n          cameras[i].GetComponent<Camera>().enabled = cameraActive;\n\n        if (changeAudioListener)\n              cameras[i].GetComponent<AudioListener>().enabled = cameraActive;\n          }\n        }\n    }\n    ```", "```cs\nGameObject.Find(\"Switchboard\").GetComponent(\"CameraSwitch\").SwitchCamera(1);\n```", "```cs\n    using UnityEngine;\n    using UnityEngine.UI;\n    using System.Collections;\n\n    public class ScreenTexture : MonoBehaviour {\n      public GameObject photoGUI;\n      public GameObject frameGUI;\n      public float ratio = 0.25f;\n\n      void  Update (){\n        if (Input.GetKeyUp (KeyCode.Mouse0))\n          StartCoroutine(CaptureScreen());\n      }\n\n      IEnumerator  CaptureScreen (){\n        photoGUI.SetActive (false);\n        int sw = Screen.width;\n        int sh = Screen.height;\n        RectTransform frameTransform = frameGUI.GetComponent<RectTransform> ();\n        Rect framing = frameTransform.rect;\n        Vector2 pivot = frameTransform.pivot;\n        Vector2 origin = frameTransform.anchorMin;\n        origin.x *= sw;\n        origin.y *= sh;\n        float xOffset = pivot.x * framing.width;\n        origin.x += xOffset;\n        float yOffset = pivot.y * framing.height;\n        origin.y += yOffset;\n        framing.x += origin.x;\n        framing.y += origin.y;\n        int textWidth = (int)framing.width;\n        int textHeight = (int)framing.height;\n        Texture2D texture = new Texture2D(textWidth,textHeight);\n        yield return new WaitForEndOfFrame();\n        texture.ReadPixels(framing, 0, 0);\n        texture.Apply();\n        photoGUI.SetActive (true);\n        Vector3 photoScale = new Vector3 (framing.width * ratio, framing.height * ratio, 1);\n        photoGUI.GetComponent<RectTransform> ().localScale = photoScale;\n        photoGUI.GetComponent<RawImage>().texture = texture;\n      }\n    }\n    ```", "```cs\n    using UnityEngine;\n    using System.Collections;\n    using UnityStandardAssets.ImageEffects;\n\n    public class TelescopicView : MonoBehaviour{\n      public float zoom = 2.0f;\n      public float speedIn = 100.0f;\n      public float speedOut = 100.0f;\n      private float initFov;\n      private float currFov;\n      private float minFov;\n      private float addFov;\n      private VignetteAndChromaticAberration v;\n      public float vMax = 10.0f;\n\n      void Start(){\n        initFov = Camera.main.fieldOfView;\n        minFov = initFov / zoom;\n        v = this.GetComponent<VignetteAndChromaticAberration>() as VignetteAndChromaticAberration;\n      }\n      void Update(){\n        if (Input.GetKey(KeyCode.Mouse0))\n          ZoomView();\n        else\n          ZoomOut();\n        float currDistance = currFov - initFov;\n        float totalDistance = minFov - initFov;\n        float vMultiplier = currDistance / totalDistance;\n        float vAmount = vMax * vMultiplier;\n        vAmount = Mathf.Clamp (vAmount,0,vMax);\n        v.intensity = vAmount;\n      }\n\n      void ZoomView(){\n        currFov = Camera.main.fieldOfView;\n        addFov = speedIn * Time.deltaTime;\n\n        if (Mathf.Abs(currFov - minFov) < 0.5f)\n          currFov = minFov;\n        else if (currFov - addFov >= minFov)\n          currFov -= addFov;\n\n        Camera.main.fieldOfView = currFov;\n      }\n\n      void ZoomOut(){\n        currFov = Camera.main.fieldOfView;\n        addFov = speedOut * Time.deltaTime;\n\n        if (Mathf.Abs(currFov - initFov) < 0.5f)\n          currFov = initFov;\n        else if (currFov + addFov <= initFov)\n          currFov += addFov;\n\n        Camera.main.fieldOfView = currFov;\n      }\n    }\n    ```", "```cs\n    using UnityEngine;\n    using UnityEngine.UI;\n    using System.Collections;\n\n    public class MiniMap : MonoBehaviour\n    {\n      public Transform target;\n      public GameObject marker;\n      public GameObject mapGUI;\n      public float height = 10.0f;\n      public float distance = 10.0f;\n      public bool rotate = true;\n      private Vector3 camAngle;\n      private Vector3 camPos;\n      private Vector3 targetAngle;\n      private Vector3 targetPos;\n      private Camera cam;\n\n      void Start(){\n        cam = GetComponent<Camera> ();\n        camAngle = transform.eulerAngles;\n        targetAngle = target.transform.eulerAngles;\n        camAngle.x = 90;\n        camAngle.y = targetAngle.y;\n        transform.eulerAngles = camAngle;\n      }\n\n      void Update(){\n        targetPos = target.transform.position;\n        camPos = targetPos;\n        camPos.y += height;\n        transform.position = camPos;\n        cam.orthographicSize = distance;\n        Vector3 compassAngle = new Vector3();\n        compassAngle.z = target.transform.eulerAngles.y;\n\n        if (rotate) {\n          mapGUI.transform.eulerAngles = compassAngle;\n          marker.transform.eulerAngles = new Vector3();\n        } else {\n          marker.transform.eulerAngles = -compassAngle;\n        }\n\n      }\n    }\n    ```"]