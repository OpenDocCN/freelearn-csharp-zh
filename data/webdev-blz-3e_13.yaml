- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: In this chapter, we will take a look at testing. Writing tests for our projects
    will help us develop things rapidly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨测试。为我们的项目编写测试将帮助我们快速开发。
- en: We can run tests to ensure we haven’t broken anything with the latest change.
    Also, we don’t have to invest our time in testing components manually since it
    is all done by the tests. Testing will improve the quality of the product since
    we’ll know that things that worked earlier still function as they should.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行测试以确保我们没有在最新的更改中破坏任何东西。此外，我们不必在测试组件上投入时间，因为所有这些都由测试完成。测试将提高产品的质量，因为我们知道之前工作正常的东西仍然按预期工作。
- en: But writing tests for UI elements isn’t always easy; the most common way is
    to spin up the site, use tools that click on buttons, and then read the output
    to determine whether things work. The upside of this method is that we can test
    our site on different browsers and devices. The downside is that it usually takes
    a lot of time to do these tests. We need to spin up the website, start a web browser,
    verify the test, close the web browser, and repeat for the next test.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但为 UI 元素编写测试并不总是容易；最常见的方法是启动网站，使用点击按钮的工具，然后读取输出以确定是否正常工作。这种方法的优势在于我们可以测试我们的网站在不同的浏览器和设备上。缺点是通常需要花费大量时间来完成这些测试。我们需要启动网站，打开浏览器，验证测试，关闭浏览器，然后为下一个测试重复此过程。
- en: We can use this method in Blazor as well (as with any ASP.NET site), but with
    Blazor, we have other opportunities when it comes to testing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 Blazor 中使用这种方法（就像任何 ASP.NET 网站一样），但与 Blazor 一起，我们在测试方面还有其他机会。
- en: Steve Sanderson created an embryo of a test framework for Blazor that Microsoft
    MVP Egil Hansen picked up and continued the development of.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Steve Sanderson 为 Blazor 创建了一个测试框架的雏形，Microsoft MVP Egil Hansen 接手并继续了其开发。
- en: Egil’s framework is called **bUnit** and has become an industry standard in
    the Blazor community for testing Blazor components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Egil 的框架被称为 **bUnit**，并已成为 Blazor 社区中测试 Blazor 组件的行业标准。
- en: 'This chapter covers the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: What is bUnit?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 bUnit？
- en: Setting up a test project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试项目
- en: Mocking the API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟 API
- en: Writing tests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试
- en: '`Blazm` extension'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blazm` 扩展'
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure you have read the previous chapters or use the `Chapter12` folder
    as a starting point.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经阅读了前面的章节或使用 `Chapter12` 文件夹作为起点。
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter13).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此章结果的源代码在 [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter13)
    找到。
- en: If you are jumping into this chapter using the code from GitHub, make sure you
    have added the `Auth0` account information in the settings files. You can find
    the instructions in *Chapter 8*, *Authentication and Authorization*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 GitHub 上的代码跳转到本章，请确保你已在设置文件中添加了 `Auth0` 账户信息。你可以在 *第 8 章*，*身份验证和授权* 中找到说明。
- en: What is bUnit?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 bUnit？
- en: As mentioned in the introduction, some tests spin up web browsers to test pages/components,
    but bUnit takes another approach.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，一些测试会启动浏览器来测试页面/组件，但 bUnit 采用另一种方法。
- en: bUnit is made specifically for Blazor. It can define and set up tests using
    C# or Razor syntax. It can mock JavaScript interop as well as Blazor’s authentication
    and authorization. To make our components more testable, sometimes we need to
    think about these things from the beginning or make minor changes to our code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: bUnit 是专门为 Blazor 定制的。它可以使用 C# 或 Razor 语法定义和设置测试。它还可以模拟 JavaScript 互操作以及 Blazor
    的身份验证和授权。为了使我们的组件更容易测试，有时我们需要从开始就考虑这些事情，或者对我们的代码进行一些小的修改。
- en: bUnit doesn’t rely on a web browser but renders the output internally and exposes
    it to us so that we can test against predefined outputs. This is also a limitation
    – we are not testing the real site; we are testing the component, so think of
    this as unit tests, not integration tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: bUnit 不依赖于浏览器，而是在内部渲染输出并将其暴露给我们，以便我们可以针对预定义的输出进行测试。这也是一个限制——我们不是在测试真实网站；我们是在测试组件，所以将其视为单元测试，而不是集成测试。
- en: It’s time for us to get our hands dirty, so let’s create a test project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让我们动手实践了，让我们创建一个测试项目。
- en: Setting up a test project
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测试项目
- en: 'To be able to run tests, we need a test project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够运行测试，我们需要一个测试项目：
- en: 'To install the **bUnit** templates, open PowerShell and run the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装 **bUnit** 模板，打开PowerShell并运行以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Check which is the latest version of the templates on the bUnit web page: [https://bunit.dev/](https://bunit.dev/).'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查bUnit网页上的模板的最新版本：[https://bunit.dev/](https://bunit.dev/)。
- en: In Visual Studio, right-click the **MyBlog** solution and choose **Add** | **New
    Project**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，右键单击 **MyBlog** 解决方案，然后选择 **添加** | **新建项目**。
- en: Search for **bUnit**, select **bUnit Test Project** in the results, and then
    click **Next**. Sometimes, it takes time to find a template, and we can also change
    the **Project Type** dropdown to **bUnit** to find the template. We might need
    to reboot Visual Studio to find it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 **bUnit**，在结果中选择 **bUnit Test Project**，然后点击 **下一步**。有时，找到模板需要一些时间，我们也可以将
    **项目类型** 下拉菜单更改为 **bUnit** 来找到模板。我们可能需要重新启动Visual Studio才能找到它。
- en: Name the project `MyBlog.Tests`, leave the location as is, and click **Next**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `MyBlog.Tests`，保留位置不变，然后点击 **下一步**。
- en: 'Select **xUnit** as the unit test framework and target framework: **.NET 8.0**,
    and click **Create**.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **xUnit** 作为单元测试框架和目标框架：**.NET 8.0**，然后点击 **创建**。
- en: Great! We now have a test project. Before we mock the API, let’s look at the
    different methods available to us so we can get a feel for how bUnit works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在有一个测试项目。在我们模拟API之前，让我们看看我们可用的不同方法，这样我们就可以了解bUnit是如何工作的。
- en: 'In `MyBlog.Tests`, we should have the following four files:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MyBlog.Tests` 中，我们应该有以下四个文件：
- en: '`_Imports.razor` contains the namespaces that we want all of our Razor files
    to have access to.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_Imports.razor` 包含我们希望所有Razor文件都能访问的命名空间。'
- en: '`Counter.razor` is a copy of the same `Counter` components we get by default
    in the Blazor template.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter.razor` 是我们在Blazor模板中默认获得的相同 `Counter` 组件的副本。'
- en: '`CounterCSharpTest.cs` contains tests written in C#.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CounterCSharpTest.cs` 包含用C#编写的测试。'
- en: '`CounterRazorTest.razor` contains tests written in Razor.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CounterRazorTest.razor` 包含用Razor编写的测试。'
- en: 'Let’s start with the `CounterCSharpTest.cs` file, which contains two tests:
    one that checks that the counter starts at `0` and one that clicks the button
    and verifies the counter is now `1`. These two simple tests make sense for testing
    the `Counter` component.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `CounterCSharpTest.cs` 文件开始，它包含两个测试：一个检查计数器是否从 `0` 开始，另一个点击按钮并验证计数器现在是
    `1`。这两个简单的测试对于测试 `Counter` 组件是有意义的。
- en: 'The `CounterStartsAtZero` test looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`CounterStartsAtZero` 测试看起来像这样：'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s break this down. The `Fact` attribute tells the test runner that this
    is a *normal* test with no parameters. We can also use the `Theory` attribute
    to tell the test runner that the `test` method needs parameter values, but we
    don’t need parameters for this use case.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。`Fact` 属性告诉测试运行器这是一个 *正常* 测试，没有参数。我们也可以使用 `Theory` 属性告诉测试运行器 `test`
    方法需要参数值，但在这个用例中我们不需要参数。
- en: First, we arrange the test. Simply put, we set up everything we need to do the
    test. Egil uses `cut` as the component’s name, which stands for **component under
    testing**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们安排测试。简单来说，我们设置进行测试所需的一切。Egil使用 `cut` 作为组件的名称，这代表 **待测试组件**。
- en: 'In this case, we run the `RenderComponent` method and pass in the component
    type, which is the `Counter` component. Next, we assert whether the component
    outputs the correct thing or not. We use the `Find` method to find the first paragraph
    tag and then verify that the HTML looks like `<p>Current count: 0</p>`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们运行 `RenderComponent` 方法，并传入组件类型，即 `Counter` 组件。接下来，我们断言组件是否输出了正确的内容。我们使用
    `Find` 方法找到第一个段落标签，然后验证HTML看起来像 `<p>Current count: 0</p>`。'
- en: 'The second test is a bit more advanced, and it looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试稍微复杂一些，看起来像这样：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As with the previous test, we start arranging by rendering our `Counter` component.
    The next step is acting, where we click the button. We look for the button and
    then click the button in our `Counter` component. There is only one button, so
    in this case, it’s safe to look for the button this way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的测试一样，我们通过渲染我们的 `Counter` 组件开始安排。下一步是执行，我们点击按钮。我们寻找按钮，然后在 `Counter` 组件中点击按钮。只有一个按钮，所以在这种情况下，以这种方式寻找按钮是安全的。
- en: Then it’s time to assert again, and we check the markup in the same way as the
    previous test, but we look for `1` instead of `0`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是再次断言的时候了，我们以与上一个测试相同的方式检查标记，但这次我们寻找的是 `1` 而不是 `0`。
- en: 'There is also another alternative where we can write out tests with Razor syntax.
    If we look at the `CounterRazorTests.razor` files, we can see the exact same tests
    but with different syntax:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还有一种替代方案，我们可以使用 Razor 语法编写测试。如果我们查看 `CounterRazorTests.razor` 文件，我们可以看到完全相同的测试，但语法不同：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is really only the way we render the component that differs. This does the
    same thing and is only a matter of preference. I prefer using the Razor version;
    it is easier to read, and it’s also easier to add parameters to our component
    while testing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，只是我们渲染组件的方式不同。这做的是同样的事情，只是个人偏好的问题。我更喜欢使用 Razor 版本；它更容易阅读，并且在测试时添加参数到我们的组件也更简单。
- en: 'Now, let’s run the tests and see whether they pass:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行测试并查看它们是否通过：
- en: In Visual Studio, bring up **Test Explorer** by searching for it using *Ctrl*
    + *Q*. We can also find it in **View** | **Test Explorer**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，通过使用 *Ctrl* + *Q* 搜索来调出 **Test Explorer**。我们也可以在 **视图** |
    **测试资源管理器** 中找到它。
- en: 'Click **Run All Test** in the view. Test Explorer should look like *Figure
    13.1*:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中点击 **运行所有测试**。测试资源管理器应该看起来像 *图 13.1*：
- en: '![Figure 13.1 – Visual Studio Test Explorer ](img/B21849_13_01.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – Visual Studio 测试资源管理器](img/B21849_13_01.png)'
- en: 'Figure 13.1: Visual Studio Test Explorer'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：Visual Studio 测试资源管理器
- en: Wonderful! Now, our first test is running and hopefully passing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们的第一个测试正在运行，并且希望它能通过。
- en: Next, we will take a look at mocking the API.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看如何模拟 API。
- en: Mocking the API
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 API
- en: There are different ways to test our application. Testing the API is beyond
    the scope of this book, but we still need to test the components, which are dependent
    on the API. We could spin up the API and test against the API, but in this case,
    we are only interested in testing the Blazor component.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的应用程序有不同的方法。API 测试超出了本书的范围，但我们仍然需要测试组件，这些组件依赖于 API。我们可以启动 API 并针对 API 进行测试，但在这个情况下，我们只对测试
    Blazor 组件感兴趣。
- en: We can then mock the API or create a fake copy of the API that doesn’t read
    from the database but reads from a predefined dataset. This way, we always know
    what the output should be.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以模拟 API 或创建一个不读取数据库但读取预定义数据集的 API 的假副本。这样，我们总能知道输出应该是什么。
- en: Luckily, the interface we created for our API is just what we need to create
    a mock API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们为 API 创建的接口正是我们创建模拟 API 所需要的。
- en: We won’t implement 100% of the tests for the project, so we don’t have to mock
    all the methods. Please feel free to implement tests for all methods as an exercise
    at the end of the chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会实现项目中所有测试的 100%，因此我们不需要模拟所有方法。请随意在章节末尾作为练习实现所有方法的测试。
- en: 'There are two ways we can implement the mock API. We could spin up an in-memory
    database, but to keep things simple, we will choose the other option and generate
    posts when we ask for them:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以实现模拟 API。我们可以启动一个内存数据库，但为了保持简单，我们将选择另一种选项，在请求时生成帖子：
- en: In the `MyBlog.Tests` project, add a project reference to the `SharedComponents`
    and `BlazorWebApp` project.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MyBlog.Tests` 项目中，将项目引用添加到 `SharedComponents` 和 `BlazorWebApp` 项目。
- en: Create a new class called `BlogApiMock.cs`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `BlogApiMock.cs` 的新类。
- en: 'Add the following namespaces:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下命名空间：
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the `IBlogApi` interface; the class should look like this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `IBlogApi` 接口；类应该看起来像这样：
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we will implement each of the methods so we can get data.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将实现每个方法，以便我们可以获取数据。
- en: 'For `BlogPost`, add the following code in the class:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `BlogPost`，在类中添加以下代码：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we run the GetBlogPostAsync method, we create a blog post and fill it with
    predefined information we can use later in our tests. The same thing goes for
    getting a list of blog posts.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行 `GetBlogPostAsync` 方法时，我们创建一个博客文章并填充我们可以稍后用于测试的预定义信息。对于获取博客文章列表也是同样的情况。
- en: We also say that we have a total of `10` blog posts in the database.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还声称数据库中总共有 `10` 篇博客文章。
- en: 'For categories, add the following code:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于类别，添加以下代码：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we do the same thing: we create categories named `Category` followed
    by a number.'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们做同样的事情：我们创建名为 `Category` 后跟数字的类别。
- en: 'For comments, add the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于注释，添加以下内容：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we create a comment.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们创建一个评论。
- en: 'The same thing goes for tags; add the following code:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于标签也是同样的情况；添加以下代码：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will not add tests for other methods in the API. We do need to add them
    to the mock class to fulfill the interface:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不会为 API 中的其他方法添加测试。但我们确实需要将它们添加到模拟类中，以满足接口：
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We now have a mock API that does the same thing repeatedly so we can make reliable
    tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模拟 API，它反复执行相同的事情，这样我们就可以进行可靠的测试。
- en: Writing tests
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: 'It’s time to write some tests. As I mentioned earlier in the chapter, we won’t
    create tests for the entire site; we will leave that to you to finish later if
    you want to. This is just to get a feel for how to write tests:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写一些测试了。如我之前在本章中提到的，我们不会为整个网站创建测试；如果你愿意，我们可以留到稍后由你来完成。这只是为了让你了解如何编写测试：
- en: In the `MyBlog.Tests` project, create a new folder called `Pages`. This is just
    so we can keep a bit of a structure (the same folder structure as the project
    we are testing).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyBlog.Tests`项目中，创建一个名为`Pages`的新文件夹。这样做只是为了保持一定的结构（与我们要测试的项目相同的文件夹结构）。
- en: Select the `Pages` folder and create a new Razor component called `HomeTest.razor`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Pages`文件夹，创建一个名为`HomeTest.razor`的新Razor组件。
- en: 'In the `_Imports` file, add the following namespaces:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_Imports`文件中，添加以下命名空间：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `HomeTest.razor` file, inherit from `TestContext` by adding the following
    code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HomeTest.razor`文件中，通过添加以下代码继承`TestContext`：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will add the test. Add the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加测试。添加以下代码：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We give our test a display name so we understand what it does. The test is pretty
    simplistic; we know we have `10` blog posts from the mock API. We also know that
    each blog post is rendered within an `article` tag. We find all `article` tags
    and make sure we have `10` in total.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们给我们的测试起一个显示名称，这样我们就能理解它做什么。这个测试相当简单；我们知道从模拟API中有`10`篇博客文章。我们还知道每篇博客文章都在`article`标签内渲染。我们找到所有的`article`标签，并确保总共有`10`个。
- en: Since we are using injection, we need to configure dependency injection, which
    we can do in the constructor.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在使用注入，我们需要配置依赖注入，这可以在构造函数中完成。
- en: 'We need to add the `HomeTest` method:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加`HomeTest`方法：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method will run when the class is created, and here, we declare that if
    the components ask for an instance of `BlogApi`, it will return an instance of
    our mock API.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当类创建时，此方法将运行，在这里我们声明如果组件请求`BlogApi`的实例，它将返回我们的模拟API的实例。
- en: This works the same way as with Blazor Server, where we return an API that talks
    directly to the database, and with Blazor WebAssembly, where we return an instance
    of the API that talks to a web API.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与Blazor Server中的方式相同，在那里我们返回一个直接与数据库通信的API，以及与Blazor WebAssembly相同，在那里我们返回一个与Web
    API通信的API实例。
- en: In this case, it will return our mock API, which returns data that is easy to
    test. Now, we need to run the actual test.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，它将返回我们的模拟API，该API返回易于测试的数据。现在，我们需要运行实际测试。
- en: 'Delete the default tests:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除默认测试：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In Visual Studio, bring up Test Explorer by searching for it using *Ctrl* +
    *Q*. We can also find it in **View** | **Test Explorer**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，通过使用*Ctrl* + *Q*搜索来打开测试资源管理器。我们也可以在**视图** | **测试资源管理器**中找到它。
- en: 'Run our tests to see whether we get a green light, as shown in *Figure 13.2*:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行我们的测试，看看是否得到绿色信号，如图*图13.2*所示：
- en: '![](img/B21849_13_02.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21849_13_02.png)'
- en: 'Figure 13.2: Test Explorer with IndexTest'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：带有IndexTest的测试资源管理器
- en: Now, we have a test that checks that 10 posts are rendered.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个检查10篇帖子是否渲染的测试。
- en: bUnit is an excellent framework for testing, and the fact that it is explicitly
    written for Blazor so that it takes advantage of Blazor’s power makes it amazing
    to work with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: bUnit是一个优秀的测试框架，而且它专门为Blazor编写，因此能够充分利用Blazor的强大功能，这使得它非常易于使用。
- en: Now, we have a simplistic test for our blog, but bUnit has support for more
    advanced features, such as authentication.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对我们的博客有一个简单的测试，但bUnit支持更高级的功能，如身份验证。
- en: Authentication
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: Using bUnit, we can test authentication and authorization.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用bUnit，我们可以测试身份验证和授权。
- en: It is, however, not the components themselves that are doing the authentication.
    We added `AuthorizeRouteView` to `App.razor` in *Chapter 8*, *Authentication and
    Authorization*, so testing that in individual components won’t make a difference.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，进行身份验证的不是组件本身。我们在*第8章*，*身份验证和授权*中向`App.razor`添加了`AuthorizeRouteView`，所以在单个组件中测试这一点不会有任何区别。
- en: But we can use `AuthorizeView`, for example, and we have it in our blog in the
    `LoginStatus` component, which displays a login link when we are not authorized
    and a logout link when we are authorized. Please feel free to add these tests
    as we did in the previous section, or use them as a reference.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以使用`AuthorizeView`，例如，我们已经在我们的博客中的`LoginStatus`组件中有了它，当未授权时显示登录链接，当授权时显示注销链接。请随意添加这些测试，就像我们在上一节中做的那样，或者作为参考。
- en: 'We can use the `AddTestAuthorization` method to authorize our tests like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`AddTestAuthorization`方法来授权我们的测试，如下所示：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This method adds `TestAuthorization` but is not authorized. The page will then
    display a link with the text `Log in`. To test when the user is authorized, we
    just set the user as authorized:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法添加了`TestAuthorization`但并未授权。随后页面将显示一个带有文本`登录`的链接。为了测试用户是否已授权，我们只需将用户设置为已授权：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can add claims, roles, and much more. The user we utilize for testing does
    not correlate with the users or roles in the database; the authorization is mocked
    by bUnit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加声明、角色以及更多内容。我们用于测试的用户与数据库中的用户或角色无关；授权由bUnit模拟。
- en: Authentication and authorization could be tricky to test, but using bUnit is
    really simple. Testing JavaScript is a bit harder, but bUnit has a solution for
    that as well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权可能很难测试，但使用bUnit确实很简单。测试JavaScript可能有点困难，但bUnit也有相应的解决方案。
- en: Testing JavaScript
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试JavaScript
- en: Testing JavaScript is not supported by bUnit, which is understandable. We can,
    however, test the interop ourselves.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: bUnit不支持测试JavaScript，这是可以理解的。然而，我们可以自己测试互操作性。
- en: In this book, we have used the .NET 5 syntax for our JavaScript. In our `SharedComponents\ReusableComponents\BlogButton.razor`
    component, we make a JavaScript interop to confirm the deletion of an item.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用了.NET 5语法来编写JavaScript。在我们的`SharedComponents\ReusableComponents\BlogButton.razor`组件中，我们进行JavaScript互操作以确认删除项。
- en: 'The JavaScript call looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript调用看起来像这样：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We make sure that we load the JavaScript module and then execute the `showConfirm`
    method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保加载JavaScript模块，然后执行`showConfirm`方法。
- en: JavaScript testing in bUnit can be done in two modes – `strict` and `loose`.
    The default value is `strict`, so we need to specify every module and every method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在bUnit中，JavaScript测试可以以两种模式进行——`严格`和`宽松`。默认值是`严格`，因此我们需要指定每个模块和每个方法。
- en: If we choose `loose`, all methods will just return the default value. For a
    Boolean, it would return `false`, for example.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择`宽松`，所有方法都将返回默认值。例如，对于布尔值，它将返回`false`。
- en: 'To test the preceding JavaScript call, we can do that by adding something like
    this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试前面的JavaScript调用，我们可以通过添加类似以下内容来实现：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We set up a module with the same path to JavaScript as before. Then, we specify
    the method and any parameters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个与之前相同的路径到JavaScript的模块。然后，我们指定方法和任何参数。
- en: 'Lastly, we specify what the result should be. In this case, we return `true`,
    which would return from JavaScript if we want to delete the item. We could also
    verify whether the JavaScript method is being called. A complete example for testing
    this in the `ItemList` component would look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指定结果应该是什么。在这种情况下，我们返回`true`，这将返回JavaScript，如果我们想删除项。我们还可以验证JavaScript方法是否被调用。在`ItemList`组件中测试此功能的完整示例如下：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Great job! We now have tests in our project. Even though we aren’t covering
    all the components, we should have all the building blocks to complete the tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们现在在我们的项目中有了测试。尽管我们没有涵盖所有组件，但我们应该有完成测试的所有构建块。
- en: 'If you want to learn more about bUnit, check out the following link: [https://bunit.dev/docs/getting-started/index.html](https://bunit.dev/docs/getting-started/index.html).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于bUnit的信息，请查看以下链接：[https://bunit.dev/docs/getting-started/index.html](https://bunit.dev/docs/getting-started/index.html)。
- en: Their documentation is fantastic.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的文档非常出色。
- en: 'It is good to know that it is also possible to use other testing frameworks.
    We use a combination of Playwright tests and bUnit but we test completely different
    things. You can find Playwright here: [https://playwright.dev/dotnet/docs/intro](https://playwright.dev/dotnet/docs/intro).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好知道也可以使用其他测试框架。我们结合使用Playwright测试和bUnit，但测试的内容完全不同。你可以在[https://playwright.dev/dotnet/docs/intro](https://playwright.dev/dotnet/docs/intro)找到Playwright。
- en: Before we summarize this chapter, we have one more thing to talk about.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结本章之前，我们还有一件事要讨论。
- en: Blazm extension
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazm扩展
- en: There are things that are a bit tedious when developing Blazor applications.
    We have done many of those things throughout the book. I tend to spell things
    wrong when I code, and when creating an isolated CSS or JavaScript file, I tend
    to get the name wrong from time to time and even get the file extension wrong.
    So, I thought, is there a better way to do this?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Blazor应用程序时，有些事情做起来有点繁琐。我们在整本书中做了很多这样的事情。我编写代码时容易拼错单词，在创建独立的CSS或JavaScript文件时，我有时会拼错文件名，甚至文件扩展名也会出错。所以，我想，有没有更好的方法来做这件事？
- en: Yes, there is!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有！
- en: I built a Visual Studio extension that will add some very nice features to Visual
    Studio.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我开发了一个Visual Studio扩展，它将为Visual Studio添加一些非常棒的功能。
- en: But why in the world have I waited so long to talk about this!? Well, it’s important
    to learn the “real” way first, then take the shortcuts.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但我究竟为什么要等这么久才谈论这个呢！？好吧，首先学习“真正的”方法很重要，然后才走捷径。
- en: 'You can check out the extension here: [https://marketplace.visualstudio.com/items?itemName=EngstromJimmy.BlazmExtension](https://marketplace.visualstudio.com/items?itemName=EngstromJimmy.BlazmExtension)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看扩展：[https://marketplace.visualstudio.com/items?itemName=EngstromJimmy.BlazmExtension](https://marketplace.visualstudio.com/items?itemName=EngstromJimmy.BlazmExtension)
- en: 'It can help us add a code-behind file and isolated CSS and JavaScript files.
    It can also help us move namespaces into the `_imports` file and much more. But
    it can also help us generate tests, not the whole way, but it will help us on
    the way. Do you remember the `Alerts` component we used in *Chapter 4*? We can
    right-click that component and choose `Generate` **bUnit test**, and then as **Razor
    syntax**. It will generate the code to the clipboard so we can paste it where
    we want it. It will automatically give us this code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以帮助我们添加代码后文件和隔离的CSS和JavaScript文件。它还可以帮助我们将命名空间移动到`_imports`文件，以及更多。但它还可以帮助我们生成测试，不是全部，但会在路上帮助我们。你还记得我们在*第4章*中使用的`Alerts`组件吗？我们可以右键单击该组件并选择`Generate`
    **bUnit测试**，然后使用**Razor语法**。它将生成代码到剪贴板，我们可以将其粘贴到我们想要的位置。它将自动给我们以下代码：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result is not perfect as we can see, but it gives us something to stand
    on. If we were to write a test for the `Alert` component, it would look something
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不完美，正如我们所见，但它给了我们一个立足点。如果我们为`Alert`组件编写一个测试，它可能看起来像这样：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We had to clean up some namespaces and add an assertion. It’s pretty neat if
    you ask me, but then again, I am pretty biased on this topic. I really hope this
    extension will help you, and I would love for you to give it a five-star review
    if you enjoy it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不清理一些命名空间并添加一个断言。如果你问我，这很整洁，但话又说回来，我对这个话题确实有些偏见。我真的希望这个扩展能帮到你，如果你喜欢它，我非常希望你能给它一个五星好评。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at testing our application. We looked at how we can
    mock an API to make reliable tests. We also covered how to test JavaScript interop
    as well as authentication.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了测试我们的应用程序。我们讨论了如何模拟API以进行可靠的测试。我们还涵盖了如何测试JavaScript互操作以及认证。
- en: Tests can speed up our development and, most importantly, build quality. With
    bUnit combined with dependency injection, it is easy to build tests that can help
    us test our components.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以加快我们的开发速度，最重要的是，提高质量。结合bUnit和依赖注入，构建帮助我们测试组件的测试变得容易。
- en: Since we can test every component by itself, we don’t have to log in, navigate
    to a specific place on our site, and then test the entire page, as many other
    testing frameworks would have us do.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以单独测试每个组件，所以我们不必登录，导航到我们网站上的特定位置，然后测试整个页面，正如许多其他测试框架所要求的那样。
- en: 'Now, our site contains reusable components, authentication, APIs, Blazor Server,
    Blazor WebAssembly, authentication, shared code, JavaScript interop, state management,
    and tests. We only have one more thing to do: ship it!'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的网站包含可重用组件、认证、API、Blazor Server、Blazor WebAssembly、认证、共享代码、JavaScript互操作、状态管理和测试。我们只剩下一件事要做：发布它！
- en: In the next chapter, *Chapter 14*, *Deploying to Production*, it’s time to ship.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，*第14章*，*部署到生产环境*，是时候发布了。
