- en: '*Chapter 15*: Parallel Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to take advantage of the multiple CPU cores
    that are available in today’s modern computers. You will learn how to process
    your code by distributing the work between processes concurrently, as well as
    how to use the **Task Parallel Library** (**TPL**) and **Parallel LINQ** (**PLINQ**)
    to run code in parallel. Throughout this book, you will learn how to use parallel
    data structures and use the Visual Studio debugger to diagnose tasks and parallel
    stacks. You will also learn about the Concurrency Visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Task Parallel Library (TPL)**: In this section, we will compare
    parallel and non-parallel code and its effect on CPU core utilization using *perfmon*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Parallel LINQ (PLINQ)**: In this section, we will look at PLINQ and
    how it can be used to execute LINQ statements with varying degrees of parallelism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programming parallel data structures**: In this section, we will review some
    of the thread-safe collections you can use for programming parallel data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benchmarking with BenchmarkDotNet**: In this section, we will look at benchmarking
    our parallel code and find that, in some instances, it can be faster than non-parallel
    code, and at other times, it can be slower.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Func` and `Action` delegates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use TPL and PLINQ for parallel programming tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program parallel data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagnose issues with tasks and parallel data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lambda expressions in TPL and PLINQ queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book’s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH15](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH15)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concurrency Visualizer for Visual Studio 2022: [https://marketplace.visualstudio.com/items?itemName=Diagnostics.DiagnosticsConcurrencyVisualizer2022#overview](https://marketplace.visualstudio.com/items?itemName=Diagnostics.DiagnosticsConcurrencyVisualizer2022#overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Task Parallel Library (TPL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be working with TPL to enhance the performance of our
    programs by making use of the available processor power on a machine.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to write threads and execute them in [*Chapter 14*](B16617_14_Final_SB_Epub.xhtml#_idTextAnchor254),
    *Multi-Threaded Programming*. When multiple threads are running on a single processor,
    providing the illusion that they are running in parallel, they are running concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: When threads run concurrently, the processor uses a scheduling algorithm and/or
    interrupts to determine the switching and prioritization between threads. Parallel
    programming, however, runs different threads on different processors so that threads
    execute in parallel to each other with a reduced need for switching and thread
    interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, TPL is used to run tasks in parallel. Tasks are run in
    parallel by running each task against a separate core of the computer’s processor.
    So, for example, say your computer has four cores and you have four tasks. Each
    task would run on a separate core, and each task would be run parallel to the
    other three. This helps improve the overall performance of the code as you can
    have as many tasks executing in parallel as you have processor cores.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you have a big dataset that needs to process many records and store
    them in a variable, you can partition the task so that the records are split into
    different threads running on different processors. These are then synced backed
    together and stored in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Code that cannot be parallelized will slow down parallel tasks, as will code
    that must be partitioned and scheduled by the task scheduler. It is always a good
    idea to profile your code to see if the methods you are employing will speed up
    or slow things down.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way to see the value in parallel programming is to compare a thread
    running on a single processor against the same code split between different processors.
    Let’s write some code for this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new console application and call it `CH15_ParallelProgramming`. Then,
    check the checkbox that says **do not use top-level statements**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `using` statement gives us access to TPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Main` method in the `Program` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method calls the `RunSingleProcessorExample` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `RunSingleProcessorExample` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method creates a new thread and assigns it the `SingleProcessorExample`
    method, which it will invoke. The method is then invoked using the `Start` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add `SingleProcessorMethod`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method writes the value of the `for` loop index to the console window 1
    million times and then pauses until it receives a user keypress.
  prefs: []
  type: TYPE_NORMAL
- en: Type `Performance Monitor` into your task bar’s search area and open it. Then,
    remove the existing counter, and then add a counter to view the processor time
    for all the processors on your computer. If you need to, you can change the thickness
    of the lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clear out the **Performance Monitor** screen and then run the console app.
    You should see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Performance Monitor with our console application running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – Performance Monitor with our console application running
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, processor instance 1 is the most utilized processor. What we
    need to do is modify the program to utilize all available processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the method call in the `Main` method and add the following code
    after the commented-out method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code uses a parallel `for` loop to process the `MultipleProcessorExample`
    method 1 million times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code again. You should see the following in Performance Monitor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Performance Monitor showing all our processors being used by
    our modified program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – Performance Monitor showing all our processors being used by our
    modified program
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with very minimal code, you can go from utilizing a single processor
    to utilizing all the processors using TPL. In previous chapters, you learned how
    to use *BenchmarkDotNET* to benchmark the performance of different variations
    of the same code. When deciding whether to turn your single processor code into
    multiple processor code, it’s a good idea to benchmark. There is an overhead to
    using parallel code, so you need to ensure that parallel code will improve your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to use PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Using Parallel LINQ (PLINQ)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to convert your sequential LINQ queries
    into parallel LINQ using PLINQ. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls the `GetProductNames` method and stores the results
    in the `productNames` variable. A LINQ statement is then performed on the `productNames`
    list to extract a list of all product names greater than eight characters in length.
    The result of this LINQ statement is then stored in the `names` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is identical to the preceding code, except we have modified
    it so that it operates in parallel across multiple processors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the only change to the LINQ statement to get it to execute
    as parallel LINQ is to add the `AsParallel()` method call. The rest of the code
    stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the data to be returned from the PLINQ statement, then suffix the
    `AsParallel()` call with the `AsOrdered()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will return a list of product names whose lengths are greater
    than `8` in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: 'PLINQ utilizes all the processors on the executing computer. However, you can
    limit the number of processors that are used by PLINQ using the `WithDegreeOfParallelism`
    call, passing in the number of processors you want to limit PLINQ being executed
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code has been limited to running on only two processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some performance considerations when using PLINQ:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use PLINQ on single-core computers. This would result in slower performance
    than using standard LINQ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsOrdered()` will slow PLINQ down. Only use it if you need to. Benchmark alternative
    ordering techniques to see which is quickest, and then implement the quickest
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employ production-sized datasets when developing and testing your PLINQ code.
    This will reveal performance issues sooner rather than later!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using PLINQ on small collections since this could provide less performance.
    This is because PLINQ has been optimized for large datasets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will consider some data structures that are suitable
    for parallel programming.
  prefs: []
  type: TYPE_NORMAL
- en: Programming parallel data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we do parallel programming, we should always consider that we are using
    threads. Therefore, we should use data structures that are thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: For types that implement the `IProducerConsumerCollection<T>` interface, you
    should use the generic `BlockingCollection<T>` class, which provides bounding
    and blocking functionality. Use the `ConcurrentDictionary<TKey, TValue>` class
    for thread-safe dictionaries. For thread-safe FIFO queues, use the `ConcurrentQueue<T>`
    class. Use the `ConcurrentStack<T>` class for LIFO stacks. For a thread-safe implementation
    of a collection of elements, use the `ConcurrentBag<T>` class. Finally, for types
    to be used in a `BlockingCollection`, implement the `IProducerConsumerCollection<T>`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about thread-safe collections on the Microsoft Docs website:
    [https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at benchmarking loops, LINQ, and PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking with BenchmarkDotNet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will benchmark some methods to determine which method gives
    us the best performance. Keep in mind that there is some initial expense when
    running code in parallel. So, sometimes, parallel code may not be the best option
    for improving code performance. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the code in the `Main` method and add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a class called `Benchmarks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `NuGet` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BenchmarkDotNet`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LinqOptimizer.Csharp`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `using` statements for each of the `NuGet` packages to the `Benchmarks`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to set up our benchmarks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are declaring an array that’s a short data type. The array is then
    initialized and filled with values. This array will be used by two of the following
    six methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `StandardForLoopExample` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code uses a standard `foreach` loop to loop through the values
    in the data array and then writes the value of the array at the given index to
    the console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ParallelForLoopExample` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code does the same as the preceding code but executes the code
    using PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UrlDownloader1` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates an array of URLs and downloads their content using
    a `foreach` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UrlDownloader2` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates an array of URLs and downloads them as a set of tasks.
    The code waits for all the tasks to complete before the content is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Urldownloader3` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses a `Parallel.ForeEach` loop to download the contents
    of URLs stored in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that your project is set to Release mode, and then run your program.
    The program will take some time to execute. However, once it has finished executing,
    you should see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.3 – BenchmarkDotNet results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – BenchmarkDotNet results
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `ForEachLoop` examples, we can see that the standard `foreach`
    loop executed faster than our `Parallel.ForEach` loop. And so, in this example,
    using parallel code was slightly slower than using non-parallel code. But if the
    dataset was much larger and the data type was more complex, then the results could
    show that parallel code performs faster.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at our `UrlDownloader` methods, `UrlDownloader4` uses the `Parallel.ForEach`
    loop, which is much faster than the two methods that use the `foreach` loop and
    `foreach` with lambda methods. However, the method that creates an array of tasks
    and waits for them all to complete is slightly faster than the `Parallel.ForEach`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: From these test results, we can see that we have different ways to perform the
    same actions, and each method’s processing speed is different. In some cases,
    we have seen that parallel code is slower than non-parallel code, while in others,
    we have seen that parallel code is faster than non-parallel code.
  prefs: []
  type: TYPE_NORMAL
- en: When performance is an issue, you can use BenchmarkDotNet to test the efficiency
    of different approaches to the same task. Then, you can choose the most efficient
    option for the problem that you are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use lambda expressions with TPL and
    LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Using lambda expressions with TPL and LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several methods in TPL that take a `System.Func<TResult>` or `System.Action`
    delegate as an input parameter. These can be used to pass custom logic into a
    task, query, or parallel loop. Inline blocks can be used when creating delegates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `Func` delegates to encapsulate methods that return a value and use `Action`
    delegates to encapsulate methods that do not return values. Let’s review the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how to use the `Parallel.ForEach` method and a thread-local
    state. We expect the code to execute in parallel and sum up all the values stored
    in the `int` array. Each thread of the `Parallel.For` loop maintains a local addition
    variable. This addition variable is set to `0` when each thread is initialized.
    With each iteration, the addition is incremented with the number value. Once the
    thread has completed its task, the local sum for that thread is safely added to
    the global sum. The global sum is then printed out once the loop is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code also demonstrates how to use lambda expressions to express
    both `Func` and `Action` delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at some parallel debugging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel debugging and profiling tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at three parallel application debugging and profiling
    tools. These are the `CH15_ParallelProgrammingDebuggingAndProfilingSample` project
    for this. We will be using this project as we work through the next three sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Parallel Stacks window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the program until it is paused by the debugger. Then, from the **Visual
    Studio** menu, select **Debug** | **Windows** | **Parallel Tasks**. This will
    display the **Parallel Tasks** window. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – The Parallel Stacks thread view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – The Parallel Stacks thread view
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our main thread is initiated via our `Program.Main` method.
    We can see that the debugger is paused in `Program.MethodC`. There are four threads
    – one each for methods A, B, and C, and a fourth in external code. There are also
    five threads running – these are external code threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hover over the methods, you will see the following popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – The Parallel Stacks thread view with the Thread and Stack Frame
    view displayed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – The Parallel Stacks thread view with the Thread and Stack Frame
    view displayed
  prefs: []
  type: TYPE_NORMAL
- en: 'By hovering over each method group, you get to see a table of threads and their
    stack frames. These stack frames provide the method name and line number. The
    active stack frame of the current thread is identified by the yellow arrow. If
    you right-click while hovering over the stack frame, you can select what details
    to show, including parameter values, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – The Thread and Stack Frame view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – The Thread and Stack Frame view
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see the values of each of the parameters of our thread methods.
    Next, we will look at the **Tasks** window.
  prefs: []
  type: TYPE_NORMAL
- en: The Tasks window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To view the **Tasks** window, from the **Parallel Tasks** tab, select **Tasks**
    from the dropdown. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – The Tasks view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 – The Tasks view
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows the async logical stacks. If you hover over
    each method, you will see the following window pop up, as you did with the threads
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – The Thread and Stack Frame view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – The Thread and Stack Frame view
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Visual Studio** menu, select **Debug** | **Windows** | **Tasks**.
    You should see the following pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – The Tasks pane'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.9 – The Tasks pane
  prefs: []
  type: TYPE_NORMAL
- en: This view shows you the various tasks and their states, along with other information.
    You can right-click on the columns to customize what columns you want to see.
    Clicking on a line should take you to the source location for you to view the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the Concurrency Visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: The Concurrency Visualizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Concurrency Visualizer is a command-line utility that allows you to collect
    traces from the command line. These can be viewed in the Concurrency Visualizer
    for Visual Studio 2022, which can be used on computers that don’t have Visual
    Studio installed. Web projects are not supported by the Concurrency Visualizer;
    it relies on Windows event tracing.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `CVCollectionCmd.exe` is installed in `C:\Program Files\Microsoft
    Visual Studio\2022\Preview\Common7\IDE\Extensions\rf2nfg00.o0t` and/or `C:\Program
    Files\Microsoft Visual Studio\2022\Community\Common7\IDE\Extensions\rf2nfg00.o0t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin collecting a trace, you can use a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This will start our application and log trace data to the location specified
    by the `/outdir` command-line argument. Several files will be generated by the
    tool. They will have `.etl` and `.cvtrace` file extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Visual Studio** menu, select **Analyze** | **Concurrency Visualizer**
    | **Open Trace** to view the generated trace file. You should see something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – The Contextual Visualizer Utilization tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.10 – The Contextual Visualizer Utilization tab
  prefs: []
  type: TYPE_NORMAL
- en: 'This screen shows the number of logical cores that are being utilized by the
    program you have traced. As you can see, my computer has 16 logical cores. Out
    of those 16, only 12 are being utilized. Clicking on the **Threads** tab gives
    you the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – The Contextual Visualizer Threads tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.11 – The Contextual Visualizer Threads tab
  prefs: []
  type: TYPE_NORMAL
- en: 'This screen gives us a good, detailed breakdown of the threads that were used,
    their functionality, and the time they took to execute. Clicking on the **Cores**
    tab will display the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – The Contextual Visualizer Cores tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_15.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.12 – The Contextual Visualizer Cores tab
  prefs: []
  type: TYPE_NORMAL
- en: This view shows the logical cores and their usage by the main thread and worker
    thread. You will see the thread ID, its name, the number of cross-core context
    switches, total context switches, and the percent of context switches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft provides a more detailed look into the Concurrency Visualizer. I have
    just provided you with a brief overview of the tool and how to use it. If you
    would like to learn more about how to use this tool, then you can view Microsoft’s
    documentation at [https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer?view=vs-2022).
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve reached the end of this chapter. Now, let’s summarize what
    we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to use TPL and PLINQ to execute code in parallel.
    At this point, we understand that the main difference between TPL and PLINQ is
    that TPL does not efficiently utilize all the cores on a computer, whereas PLINQ
    does.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how we can view the computer’s CPU utilization. Using PLINQ enables
    us to utilize all the cores of a CPU efficiently to improve code performance.
    However, when benchmarking parallel code, we saw that it is sometimes faster than
    non-parallel code, while other times, it is faster. Therefore, it pays to benchmark
    your code to see what method works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: We also reviewed a piece of code that demonstrates the use of lambda expressions
    for expressing both `Func` and `Action` delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at debugging parallel applications with a code sample that
    employed the Parallel Tasks window, the Tasks pane, and the Concurrency Visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at asynchronous programming. But before we
    do, try and answer the questions to see how well you have retained what you have
    read. Then, check out the *Further reading* section to enhance your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What does TPL stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does PLINQ stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Windows program can you use to view CPU core usage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is parallel code always faster than non-parallel code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you measure the code performance of parallel methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lambda Expressions in PLINQ and TPL*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Task Parallel Library (TPL)*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to PLINQ*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parallel Diagnostic Tools*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/parallel-diagnostic-tools](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/parallel-diagnostic-tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugging Async Code: Parallel Stacks for Tasks*: [https://devblogs.microsoft.com/visualstudio/debugging-async-code-parallel-stacks-for-tasks/](https://devblogs.microsoft.com/visualstudio/debugging-async-code-parallel-stacks-for-tasks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Walkthrough: Debugging a Parallel Application in Visual Studio (C#, Visual
    Basic, C++)*: [https://docs.microsoft.com/en-us/visualstudio/debugger/walkthrough-debugging-a-parallel-application?view=vs-2022&tabs=csharp#main](https://docs.microsoft.com/en-us/visualstudio/debugger/walkthrough-debugging-a-parallel-application?view=vs-2022&tabs=csharp#main)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
