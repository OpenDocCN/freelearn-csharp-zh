- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building and Executing Expressions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和执行表达式
- en: Expressions in C# are not just great to use as a means of capturing metadata
    and reason about code; you can also generate expression trees, either based on
    code represented as lambdas, as we saw in [*Chapter 7*](B19418_07.xhtml#_idTextAnchor118),
    *Reasoning about Expressions*, or by programmatically adding the different expression
    node types yourself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的表达式不仅非常适合用作捕获元数据和推理代码的手段；你还可以根据代码表示为lambda表达式生成表达式树，正如我们在[*第7章*](B19418_07.xhtml#_idTextAnchor118)中看到的，*推理表达式*，或者通过程序化地添加不同的表达式节点类型自己生成。
- en: The expressions that you build can then be executed. And with the breadth of
    capabilities offered with expressions, they’re almost as powerful as generating
    intermediate language code, as we saw in [*Chapter 6*](B19418_06.xhtml#_idTextAnchor098),
    *Dynamic Proxy Generation*. Since every expression is code that sits inside the
    specific expression that is executed and performs the task of the expression,
    you can’t expect the same level of performance as with generating intermediate
    language that runs natively on the .NET runtime. So, it depends on your use case
    whether or not you should pick expression generation over proxy generation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的表达式可以随后执行。由于表达式提供的功能范围很广，它们几乎和生成中间语言代码一样强大，正如我们在[*第6章*](B19418_06.xhtml#_idTextAnchor098)中看到的，*动态代理生成*。因为每个表达式都是位于执行的具体表达式内部的代码，并执行表达式的任务，所以你不能期望其性能与在.NET运行时本地运行的中间语言相同。因此，是否选择表达式生成而不是代理生成取决于你的用例。
- en: In this chapter, we will look into how we can leverage expressions to express
    our intent and execute them, and hopefully get some inspiration as to what they
    can be useful for.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用表达式来表达我们的意图并执行它们，并希望从中获得一些灵感，了解它们可能有什么用。
- en: 'We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Creating your own expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的表达式
- en: Creating expressions as delegates and executing them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表达式作为委托创建并执行
- en: Creating a query engine
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建查询引擎
- en: From this chapter, you should understand how expression trees are constructed
    and how you can leverage them to generate logic dynamically that can then be executed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你应该理解表达式树是如何构建的，以及你如何可以利用它们生成可以随后执行的动态逻辑。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter8](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter8))
    and it builds on top of the **Fundamentals** code that is found here: [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在GitHub上找到([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter8](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter8))，它基于这里找到的**基础知识**代码：[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)。
- en: Creating your own expressions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的表达式
- en: Expressions are pretty much as powerful and capable as the .NET runtime. That
    means that we can express all operations that the intermediate language holds
    and eventually the runtime executes. Constructs are very different from the intermediate
    language, as we saw in [*Chapter 7*](B19418_07.xhtml#_idTextAnchor118), *Reasoning
    about Expressions*. They’re all focused around a tree structure with left and
    right expressions representing the nodes in the tree.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式几乎和.NET运行时一样强大和有能力。这意味着我们可以表达中间语言所包含的所有操作，最终由运行时执行。构造与中间语言非常不同，正如我们在[*第7章*](B19418_07.xhtml#_idTextAnchor118)中看到的，*推理表达式*。它们都围绕一个树结构，左右表达式代表树中的节点。
- en: With expressions, we don’t necessarily need to limit ourselves to using them
    as a means to filter data, but we could in fact use them to hold logic that performs
    operations. Since they are just as powerful as the intermediate language, we could
    go and generate very complex expression trees.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式，我们不一定需要将它们限制为仅用作过滤数据的一种手段，实际上我们可以使用它们来持有执行操作的逻辑。由于它们的强大程度与中间语言相当，我们可以生成非常复杂的表达式树。
- en: But with great power comes great responsibility. Even though this is possible,
    it doesn’t mean it’s necessarily a good idea. The structures can be hard to understand
    and debug, so I would recommend not going all in and treating it as a new programming
    language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但权力越大，责任越大。尽管这是可能的，但这并不意味着这一定是个好主意。这些结构可能难以理解且难以调试，所以我建议不要全力以赴，而应将其视为一种新的编程语言。
- en: 'Let’s say we have a type we want to manipulate the property of. For simplicity,
    let’s make our type a simple type with a string property that we want to set:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个想要操作其属性的类型。为了简单起见，让我们将我们的类型设为一个具有字符串属性的类型，我们想要设置该属性：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For this sample, we want to manipulate the **StringProperty** property, so we’re
    making it a **class** rather than a **record**, enabling us to manipulate its
    state.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们想要操作**StringProperty**属性，因此我们将其制作为一个**类**而不是**记录**，这样我们就可以操作其状态。
- en: 'To create an expression representing the property we need to build, start off
    with something that represents the type the property belongs to. The owning type
    will also be represented by an expression. For this sample, we don’t want the
    expression to create an instance of the **MyType** type but rather manipulate
    an existing one. The instance it will be working on is represented by a parameter
    for the expression:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个表示我们需要构建的属性的表示式，首先从表示属性所属类型的某个东西开始。拥有类型也将由一个表示式表示。对于这个示例，我们不想让表达式创建**MyType**类型的实例，而是操作一个现有的实例。它将要操作的那个实例将由表示式的参数表示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The parameter takes the type of the parameter. But you can also give it a name
    with one of the overloads of the **.Parameter()** method, which can be very useful
    for debugging information if one has multiple parameters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 参数接受参数的类型。但你也可以使用**.Parameter()**方法的某个重载给它一个名字，这在有多个参数时对于调试信息非常有用。
- en: 'For us to work with the property, we need to use C# reflection to get the **PropertyInfo**
    for the property we want to manipulate:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与属性一起工作，我们需要使用C#反射来获取我们想要操作的属性的**PropertyInfo**：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the parameter representing the instance, we will manipulate the actual
    property. We can now create an expression representing the property on the type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表示实例的参数，我们将操作实际属性。现在我们可以创建一个在类型上表示属性的表达式：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last thing we want to do is then to do the actual assignment. For this,
    we use the **Expression.Assign()** method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后想要做的是进行实际的赋值。为此，我们使用**Expression.Assign()**方法：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The **Expression.Assign()** method takes the left-hand expression representing
    the target while the right-hand expression is the source. In the code, we assign
    it a constant of **Hello world**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Expression.Assign()**方法接受表示目标的左侧表达式，而右侧表达式是源。在代码中，我们将其分配给一个**Hello world**的常量。'
- en: Obviously, this is a very simple sample and doesn’t really do much. You can
    really go to town with expressions and leverage things such as **Expression.IfThen()**
    and **Expression.IfElse()** for **if**/**else** statements and you can even go
    and do **Expression.Call()** to invoke methods, passing along arguments and dealing
    with the result. Results can be manipulated with things such as **Expression.Add()**
    and **Expression.Subtract()**. Anything you can imagine can be done. For this
    book, we’ll just keep it simple with regard to building expressions representing
    logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个非常简单的示例，实际上并没有做什么。你可以真正地利用表达式，利用诸如**Expression.IfThen()**和**Expression.IfElse()**之类的功能来处理**if**/**else**语句，你甚至可以执行**Expression.Call()**来调用方法，传递参数并处理结果。可以使用诸如**Expression.Add()**和**Expression.Subtract()**之类的功能来操作结果。你可以想象到的一切都可以做到。对于这本书，我们将在构建表示逻辑的表达式方面保持简单。
- en: Expressions aren’t really useful unless we can invoke them and get the result.
    What we want to do is build out the expression tree we want and then be able to
    quite easily call them with standard C# code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们可以调用它们并获得结果，否则表达式实际上并没有什么用处。我们想要做的是构建我们想要的表达式树，然后能够非常容易地用标准的C#代码调用它们。
- en: Creating expressions as delegates and executing them
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表示式作为委托并执行它们
- en: We can think of expressions as methods or functions we can call. They might
    have parameters or not and they might return results or not. We can represent
    the expressions as either **Action** or **Func**. Both are delegate types found
    in the **System** namespace. **Action** represents a parameter-less action that
    can, if you need to, return results. While **Func** represents a function that
    has one or more parameters and can return a result. Both of these delegate types
    can take generic parameters representing the input parameter types and the result
    type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将表达式视为可以调用的方法或函数。它们可能包含参数或不包含参数，并且可能返回结果或不返回结果。我们可以将表达式表示为**Action**或**Func**。这两个都是**System**命名空间中找到的委托类型。**Action**表示一个无参数的操作，如果需要，可以返回结果。而**Func**表示一个具有一个或多个参数的函数，并且可以返回一个结果。这两种委托类型都可以接受泛型参数，代表输入参数类型和结果类型。
- en: Delegates are basically just representations of methods. They define a callable
    signature. We can invoke delegates as methods directly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 委托基本上只是方法的表示。它们定义了一个可调用签名。我们可以直接将委托作为方法调用。
- en: 'With expressions, we can turn them into a callable expression. This is done
    through **Expression.Lambda()**. Let’s build on the property assign expression
    we had earlier:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式，我们可以将它们转换成可调用的表达式。这是通过**Expression.Lambda()**完成的。让我们基于我们之前拥有的属性赋值表达式来构建：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can create the following lambda:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建以下lambda表达式：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The **Expression.Lambda()** method takes a generic parameter – the type of delegate.
    This delegate can be whatever delegate type you want – your own custom delegate
    or just use either **Action** or **Func**. For this example, we’ll use **Action<MyType>**
    since we are going to just call the expression and it will manipulate the instance
    we give it. We pass along the expression representing the assignment of the value
    and then the definition of the parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Expression.Lambda()**方法接受一个泛型参数——委托的类型。这个委托可以是任何你想要的委托类型——你自己的自定义委托或者直接使用**Action**或**Func**。在这个例子中，我们将使用**Action<MyType>**，因为我们只是调用表达式，它将操作我们给出的实例。我们传递表示赋值表达式的表达式，然后是参数的定义。'
- en: 'With the lambda expression in place, we can compile the expression down to
    a callable delegate and call it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda表达式就位的情况下，我们可以将表达式编译成一个可调用的委托并调用它：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code calls the **.Compile()** method, which will then compile the expression
    down into a delegate we can invoke directly. It creates an instance of the **MyType**
    type and passes it along to the delegate. Running the program, you should now
    see the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用**.Compile()**方法，然后会将表达式编译成一个可以直接调用的委托。它创建一个**MyType**类型的实例，并将其传递给委托。运行程序，你现在应该看到以下内容：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is pretty straightforward and this example probably doesn’t show the full
    potential.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接，这个例子可能没有展示出全部潜力。
- en: Creating a query engine
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建查询引擎
- en: Let’s switch gears a little bit and increase the complexity a couple of levels
    and make it a little bit more relevant. One thing we could use expressions for
    is as a way to do dynamic querying of data. Some applications might want to even
    give the end user the ability to create arbitrary queries for your data. I’ve
    worked on solutions that offered this type of power to the end user, which can
    be a tough problem to solve if you’re providing a flexible query system for the
    end user without something such as expressions. I’ve seen solutions that basically
    just expose SQL directly to the end user instead of trying to tackle this problem.
    Giving this level of power to the end user can cause problems in the future. What
    you end up doing is completely obliterating all abstractions between your data
    storage and your end users. Good luck changing technologies or supporting multiple
    data storage mechanisms. But luckily, we have the power of expressions in our
    hands, giving us the opportunity to create an abstraction that puts us in the
    pit of success.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下方向，提高几个级别的复杂性，使其更加相关。我们可以使用表达式来做数据动态查询。一些应用程序甚至可能希望让最终用户能够为你的数据创建任意查询。我参与过提供这种类型能力给最终用户的项目，如果为最终用户提供一个灵活的查询系统而没有像表达式这样的工具，这可能会是一个难题。我见过一些解决方案，它们基本上只是直接将SQL暴露给最终用户，而不是尝试解决这个问题。给最终用户提供这种级别的权力可能会在未来造成问题。你最终会完全消除数据存储和最终用户之间的所有抽象。祝你好运，改变技术或支持多种数据存储机制。但幸运的是，我们手中拥有表达式的力量，这给了我们创建一个成功之坑的抽象的机会。
- en: Expressions, as discussed in [*Chapter 7*](B19418_07.xhtml#_idTextAnchor118),
    *Reasoning about Expressions*, are disconnected from how they are translated for
    execution for the target data source. As long as we keep our expression trees
    simple enough, it should be possible to execute them optimally for the data source.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第[*第7章*](B19418_07.xhtml#_idTextAnchor118)中讨论的，表达式与它们如何为目标数据源执行翻译是分离的。只要我们保持我们的表达式树足够简单，就应能够针对数据源进行优化执行。
- en: Building out an interactive query user interface is involved, so for this book,
    let’s make it a bit more developer-centric and make our query interface a JSON
    document. We want to create a data store that can hold data with the capability
    of being queried with a defined query language.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个交互式查询用户界面是复杂的，所以对于这本书，让我们让它更侧重于开发者，并使我们的查询界面成为一个JSON文档。我们希望创建一个能够使用定义的查询语言查询数据的数据库。
- en: A MongoDB-like database
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个类似MongoDB的数据库
- en: Let’s build something that resembles a document database. MongoDB can be a good
    blueprint for this. Obviously, we’re not going to be building a fully capable
    document database but will use the characteristics of one and also be inspired
    by them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个类似于文档数据库的东西。MongoDB可以是一个好的蓝图。显然，我们不会构建一个完全功能的文档数据库，但我们将使用其特性，并从中汲取灵感。
- en: 'MongoDB has a query language that is very much like JSON, meaning that you
    construct the different clauses as key/value expressions. Let’s say we have a
    document in JSON that looks like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB有一个非常类似于JSON的查询语言，这意味着你将构建不同的子句作为键/值表达式。假设我们有一个如下所示的JSON文档：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With a MongoDB-like syntax, we can do a query that does an equals match for
    the **LastName** property as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似MongoDB的语法，我们可以执行一个对**LastName**属性的等于匹配查询，如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To add more properties that needs to match – a typical **And** operation –
    you just simply add another property as a key/value with the value you want it
    to be:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加更多需要匹配的属性——一个典型的**And**操作——你只需简单地添加另一个键/值属性，并设置你想要的值：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sometimes you have **Or** statements, saying *this* or *this*, with MongoDB
    that would be expressed as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会有**Or**语句，表示“这个”或“这个”，在MongoDB中，这将如下表示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you want to do queries that need a value to be greater than, less than,
    or similar to, you would need an object structure for the right-hand side:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要执行需要值大于、小于或类似的查询，你需要一个右侧的对象结构：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, in MongoDB, keywords are prefixed with **$**. We’re not going
    to implement them all, but just a few – enough to make it interesting.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在MongoDB中，关键字前缀为**$**。我们不会实现所有这些，但只是几个——足以使其有趣。
- en: Building a simple query engine
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个简单的查询引擎
- en: With the requirements in place, we’re now ready to start building out the engine
    that will be able to parse queries and create expressions that we can call from
    code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在满足要求后，我们现在可以开始构建能够解析查询并创建我们可以从代码中调用的表达式的引擎。
- en: 'Start by creating a folder called **Chapter8**. Change into this folder in
    your command-line interface and create a new console project:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为**Chapter8**的文件夹。在命令行界面中切换到这个文件夹，并创建一个新的控制台项目：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a file called **QueryParser.cs**. Add the following to the file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为**QueryParser.cs**的文件。向该文件添加以下内容：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code adds the namespaces we’re going to need for this to work and then adds
    a class that holds, for now, a representation of the parameter we’re going to
    pass into the query evaluation expression that we will have at the end.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码添加了我们需要为此工作所需的命名空间，然后添加了一个类，该类目前持有我们将传递到查询评估表达式的参数的表示，该表达式将在最后拥有。
- en: One of the characteristics of document databases is that, by default, they don’t
    have a definition of the shape of objects being put into them, unlike a SQL database,
    which has a table definition with columns. To mimic that behavior, you’re going
    to be using a key/value dictionary represented as **IDictionary<string, object>**.
    This is the parameter of the expression.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 文档数据库的一个特点是，默认情况下，它们没有放入其中的对象的形状定义，与具有列的表定义的SQL数据库不同。为了模仿这种行为，你将使用表示为**IDictionary<string,
    object>**的键/值字典。这是表达式的参数。
- en: 'The query expressions will have the following structure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式将具有以下结构：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That means we need to build the correct left value expression and right value
    expression. Add the following method to the **QueryParser** class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要构建正确的左值表达式和右值表达式。向**QueryParser**类添加以下方法：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code is based on the fact that your query is coming in as a JSON construct.
    It’s built for recursion, which is why it takes a **parentProperty** and a **property**.
    This is to support more than the **equals** operand and support the nested **greater
    than** type of operands. At the top level, the **parentProperty** and **property**
    will be the same, while when we do the nested ones, we need the **parentProperty**
    and not the **property** in the nested expression as that represents the operand
    and value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基于这样一个事实，即你的查询是以 JSON 构造的形式传入的。它是为递归而构建的，这就是为什么它需要一个 **parentProperty** 和一个
    **property**。这是为了支持不仅仅是 **equals** 操作符，还支持嵌套的 **greater than** 类型操作符。在顶层，**parentProperty**
    和 **property** 将是相同的，而当我们进行嵌套时，我们需要 **parentProperty** 而不是嵌套表达式中的 **property**，因为那代表操作符和值。
- en: The first thing the code does is create an expression that accesses the dictionary.
    This is done by using the **Item** property that exists on **IDictionary<string,
    object>**. The **Item** property is not a property you’ll see on the interface.
    It represents the indexer when you typically index using **["SomeString"]**. Indexers
    are properties that take an argument. The code, therefore, sets up an **IndexerExpression**
    by using one of the overloads of the **Expression.Property()** method. It passes
    the indexer property and a constant that represents the property on the document.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先做的事情是创建一个访问字典的表达式。这是通过使用存在于 **IDictionary<string, object>** 上的 **Item**
    属性来完成的。**Item** 属性不是你会在接口上看到的属性。它代表当你通常使用 **["SomeString"]** 进行索引时的索引器。索引器是接受参数的属性。因此，代码通过使用
    **Expression.Property()** 方法的某个重载来设置一个 **IndexerExpression**。它传递索引器属性和一个表示文档上属性的常量。
- en: The last thing the code needs to do is make sure the value being returned is
    of the correct type. Since we have **IDictionary<string, object>**, the values
    are represented as **object**. You do this to be able to use the different operands
    (**=**, **>**, **<**). If you don’t do this, you’ll get an exception because it
    will not know how to deal with comparing **object** to the actual type of the
    right-hand expression.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要做的最后一件事是确保返回的值是正确类型的。由于我们有 **IDictionary<string, object>**，值被表示为 **object**。你这样做是为了能够使用不同的操作符（**=**、**>**、**<**）。如果你不这样做，你会得到一个异常，因为它不知道如何处理将
    **object** 与右侧表达式的实际类型进行比较。
- en: Numbers are value types and need to be unboxed, while strings and Booleans need
    to cast to their actual type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是值类型，需要取消装箱，而字符串和布尔值需要转换为它们的实际类型。
- en: Important note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: JSON numbers are hardcoded to be an **int**. This is just a simplification for
    this sample. Numbers could be more than that, such as **float**, **double**, **Int64**,
    and more.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 数字被硬编码为 **int**。这只是本示例的一个简化。数字可能不仅仅是那样，例如 **float**、**double**、**Int64**
    以及更多。
- en: 'Now that you have your left-hand expression, you’ll need the right-hand expression:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了左侧表达式，你需要右侧表达式：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code creates constant expressions that get the value in the correct type.
    On the **JsonProperty** type, the **Value** property is the **JsonElement** type.
    It has methods for getting the actual value in the type you’re expecting. Since
    the query engine is somewhat limited in types, it just supports **int**, **string**,
    and **bool**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建常量表达式，以获取正确类型的值。在 **JsonProperty** 类型中，**Value** 属性是 **JsonElement** 类型。它具有获取你期望类型实际值的方法。由于查询引擎在类型方面有些限制，它仅支持
    **int**、**string** 和 **bool**。
- en: With the right-hand side also in place, you’re going to need something that
    builds on both the left- and right-hand expressions and puts them together as
    an expression you can use. The defined query capabilities include being able to
    do **greater than**, **less than**, and more and we have defined that as a complex
    object as the value in the key/value part of the query JSON. With that, you need
    a method that builds the correct expressions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于右侧也到位了，你需要某种东西来构建左右两侧的表达式，并将它们组合成一个可以使用的表达式。定义的查询功能包括能够执行 **greater than**、**less
    than** 以及更多，我们将其定义为查询 JSON 中键/值部分的复杂对象。有了这个，你需要一个构建正确表达式的函数。
- en: 'Add the following method to the **QueryParser** class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到 **QueryParser** 类中：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code enumerates the object given and makes it possible to have more than
    one clause. It groups these as **And** operations. It leverages the methods you
    created earlier to get the left- and right-hand expressions and then for each
    supported operand, uses these to create the correct operand expression.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码枚举给定的对象，并使其能够有多个子句。它将这些子句作为 **And** 操作分组。它利用您之前创建的方法来获取左右表达式，然后对于每个支持的运算符，使用这些表达式来创建正确的运算符表达式。
- en: 'Since the **GetNestedFilterExpression** method is only dealing with the nested
    filter clauses based on an object, you need a method that will deal with the top-level
    clause and call into the nested one if it’s a nested object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **GetNestedFilterExpression** 方法仅处理基于对象的嵌套过滤子句，您需要一个方法来处理顶层子句，并在它是嵌套对象时调用嵌套的子句：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Based on the kind of value, the code chooses to use the nested expression only
    if it’s an object representation. For everything else, it creates a simple **equal**
    expression.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据值的类型，代码选择仅当它是对象表示时才使用嵌套表达式。对于其他所有内容，它创建一个简单的 **equal** 表达式。
- en: 'Earlier, we discussed having the ability to do Or operations and not just And
    operations. Add the following method to the **QueryParser** class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了能够执行 Or 操作而不仅仅是 And 操作的能力。将以下方法添加到 **QueryParser** 类中：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We defined the Or expressions as an array of expressions. The code enumerates
    the value as an array and for each element, it calls **GetQueryExpression** –
    the next method we’ll be needing. From the result, it creates an **OrElse** expression.
    The reason for the **OrElse** expression is that we only want to evaluate the
    Or if the prior expression evaluates to **false**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Or 表达式定义为表达式数组。代码将值枚举为数组，并对每个元素调用 **GetQueryExpression** –这是我们接下来需要的方法。从结果中，它创建一个
    **OrElse** 表达式。**OrElse** 表达式的原因是我们只想在先前的表达式评估为 **false** 时评估 Or。
- en: 'Go ahead and add the following method to the **QueryParser** class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加以下方法到 **QueryParser** 类中：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since the query JSON can consist of multiple statements, the code enumerates
    the object and evaluates each property. If it is an Or expression, it calls the
    **GetOrExpression** method. Anything else goes to the **GetFilterExpression**.
    This is the place you could be adding more operations. For each of the properties
    in the query, it will And them together.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询 JSON 可以包含多个语句，代码会遍历对象并评估每个属性。如果是 Or 表达式，则调用 **GetOrExpression** 方法。其他任何内容都转到
    **GetFilterExpression**。这是您可以添加更多操作的地方。对于查询中的每个属性，它都会将它们组合在一起。
- en: With the **GetQueryExpression** method in place, we have all the logic for the
    query engine in place. Now we need an entry point from the outside.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **GetQueryExpression** 方法已经就位，我们已经拥有了查询引擎的所有逻辑。现在我们需要一个外部入口点。
- en: 'Add the following method to the **QueryParser** class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到 **QueryParser** 类中：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The **Parse** method takes a JSON document representing the query and returns
    an expression that is meant to be used with single documents where each document
    is **IDictionary<string, object>**. It calls into **GetQueryExpression** to create
    the actual expression based on the root element of the JSON and then wraps the
    expression in a callable **lambda** expression that takes a dictionary as a parameter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parse** 方法接受一个表示查询的 JSON 文档，并返回一个表达式，该表达式旨在与单个文档一起使用，其中每个文档是 **IDictionary<string,
    object>**。它调用 **GetQueryExpression** 来根据 JSON 的根元素创建实际的表达式，然后将其包装在一个可调用的 **lambda**
    表达式中，该表达式接受一个字典作为参数。'
- en: Now that you have your query engine in place, it’s time to create some data
    and a query, and some code to test it out.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置了查询引擎，是时候创建一些数据和查询，以及一些用于测试的代码了。
- en: 'Add a file called **data.json** and add the following or your own content to
    it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 **data.json** 的文件，并在其中添加以下内容或您自己的内容：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For the query itself, add a file called **query.json** and add the following
    or your own query to it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于查询本身，添加一个名为 **query.json** 的文件，并在其中添加以下内容或您自己的查询：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You then want to have code that parses these files and creates an expression
    from the **query.json**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您接下来想要编写代码来解析这些文件，并从 **query.json** 创建一个表达式。
- en: To be able to parse the **data.json** file and get a nice collection of **Dictionary<string,
    object>** types, we need a JSON converter. By default, if you try to deserialize
    JSON into this, the serializer will give you a **JsonElement** for the value.
    We want the actual value. The JSON converter listing and walk-through have no
    value in this context. They can be found in the GitHub repository referenced at
    the beginning of the chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够解析 **data.json** 文件并获取一个漂亮的 **Dictionary<string, object>** 类型集合，我们需要一个 JSON
    转换器。默认情况下，如果你尝试将 JSON 反序列化到这个集合中，序列化器会给你一个 **JsonElement** 类型的值。我们想要实际的值。在这个上下文中，JSON
    转换器的列表和说明没有价值。它们可以在章节开头引用的 GitHub 仓库中找到。
- en: 'In the **Program.cs** file, replace everything with the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Program.cs** 文件中，将所有内容替换为以下内容：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code loads the **query.json** and the **data.json** files and parses them.
    For the query, you need it as a **JsonDocument** before it’s passed into the **QueryParser.Parse()**
    method, while the data is deserialized into a collection of **Dictionary<string,
    object>**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码加载 **query.json** 和 **data.json** 文件并解析它们。对于查询，在将其传递给 **QueryParser.Parse()**
    方法之前，你需要将其作为 **JsonDocument**。而数据则反序列化成一个 **Dictionary<string, object>** 类型的集合。
- en: Since the documents are **IEnumerable**, you don’t get the **.Where()** extension
    methods you’re looking for. The code therefore does a **.AsQueryable()** first
    and then passes the parsed query expression into it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文档是 **IEnumerable**，你得不到你想要的 **.Where()** 扩展方法。因此，代码首先执行 **.AsQueryable()**，然后将解析的查询表达式传递给它。
- en: The filtered objects can then be enumerated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 经过过滤的对象可以被枚举。
- en: 'Running the code should give you the following result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码应该给出以下结果：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The benefit of this approach rather than presenting something such as SQL to
    the end user is that you now have an abstraction that works with different data
    stores. You can even apply the same expression in memory as you would for a database.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与向最终用户展示 SQL 等类似的方法相比，这种方法的优点是，你现在有一个可以与不同数据存储一起工作的抽象。你甚至可以将相同的表达式应用于内存中，就像应用于数据库一样。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the power of building out expressions
    and expression trees. Not only can they represent queries but, in fact, they can
    be just as powerful as generating intermediate language code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了构建表达式和表达式树的力量。它们不仅能够表示查询，实际上，它们可以与生成中间语言代码一样强大。
- en: With expressions, you get an alternative to intermediate language. They do have
    some limitations over generating intermediate language code, such as you can’t
    simply create types and implement interfaces or override the behavior of virtual
    methods inherited. But as a tool for expressing simpler actions, they are really
    great.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式，你得到了中间语言的替代品。它们在生成中间语言代码方面确实有一些限制，例如，你不能简单地创建类型和实现接口或覆盖继承的虚拟方法的行为。但作为表达简单动作的工具，它们真的非常出色。
- en: In the next chapter, we will look at yet another approach to dynamically creating
    types and implementations by leveraging the capabilities of the **Dynamic** **Language
    Runtime**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一种利用 **Dynamic** **语言运行时** 的能力动态创建类型和实现的方法。
