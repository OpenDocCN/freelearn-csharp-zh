<html><head></head><body>
        

                            
                    <h1 class="header-title">Working with External Resource Files and Devices</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Loading external resource files—using Unity default resources</li>
<li>Loading external resource files—downloading files from the internet</li>
<li>Loading external resource files—manually storing files in the Unity  resources or <kbd>StreamingAssets</kbd> folders</li>
<li>Saving project files into Unity Asset Bundles</li>
<li>Loading resources from Unity Asset Bundles</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>For some projects, it works well to use the <strong>Inspector</strong> window to manually assign imported assets to the component slots, and then build and play the game with no further changes. However, there are also many times when external data of some kind can add flexibility and features to a game. For example, it might add updateable or user-editable content; it can allow memory of user preferences and achievements between scenes, and even game-playing sessions. Using code to read local or internet file content at runtime can help file organization and the separation of tasks between game programmers and content designers. Having an arsenal of different assets and long-term game memory techniques means providing a wide range of opportunities to deliver a rich experience to players and developers alike.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>Before getting on with the recipes, let's step back and have a quick review of the role of the asset files and the Unity game building and running process. The most straightforward way to work with assets is to import them into a Unity project, use the <strong>Inspector</strong> window to assign the assets to the components in the Inspector, and then build and play the game:</p>
<div><img src="img/efbf595d-70a6-4d51-9933-1493f7102ec1.png" style="width:34.75em;height:16.75em;"/></div>
<p>Standalone executables offer another possible workflow, which is the adding of files into the <kbd>Resources</kbd> folder of the game after it has been built. This will support game media asset developers being able to provide the final version of assets after development and building has been completed. However, another option is to use the <strong>WWW</strong> class to dynamically read assets from the web at runtime or, perhaps, for communication with a high score or multiplayer server, and sending and receiving information and files.</p>
<p>When loading/saving data either locally or via the web interface, it is important to keep in mind the data types that can be used. When writing C# code, our variables can be of any type permitted by the language, but when communicated by the web interface, or to a local storage using Unity's <strong>PlayerPrefs</strong> class, we are restricted in the types of data that we can work with. Unity's <strong>WWW</strong> class permits three file types (text files, binary audio clips, and binary image textures), but, for example, for 2D UIs, we sometimes need <strong>Sprite</strong> images and not Textures, so we have provided in this chapter a C# method to create a <strong>Sprite</strong> from a <strong>Texture</strong>.</p>
<p>When using the <strong>PlayerPrefs</strong> class, we are limited to saving and loading integers, floats, and strings:</p>
<div><img src="img/959e4092-0018-46b2-b1c7-53f99f6ca981.png" style="width:42.92em;height:25.33em;"/></div>
<p>The WWW is a small class and is straightforward to use. In recent years, Unity has introduced the <strong>Unity Web Request system</strong>, as part of its networking library, for creating and processing HTTP messages (requests and responses). While the <strong>WWW</strong> class is sufficient for the resource saving and loading recipes in this chapter, if you are likely to want to work in a more sophisticated way with HTTP messages, then you would be advised to learn about Unity Web Requests, such as at the following links:</p>
<ul>
<li>Unity manual section on Unity Web Requests: <a href="https://docs.unity3d.com/Manual/UnityWebRequest.html">https://docs.unity3d.com/Manual/UnityWebRequest.html</a></li>
<li>Example use of a Unity Web Request on GitHub: <a href="https://gist.github.com/emoacht/89590d4e4571d40f9e1b">https://gist.github.com/emoacht/89590d4e4571d40f9e1b</a></li>
<li>Examples of HTTP GET/PUT, and so on, requests from StackOverflow: <a href="https://stackoverflow.com/questions/46003824/sending-http-requests-in-c-sharp-with-unity">https://stackoverflow.com/questions/46003824/sending-http-requests-in-c-sharp-with-unity</a></li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading external resource files – using Unity Default Resources</h1>
                
            
            
                
<p>In this recipe, we will load an external image file, and display it on the screen, using the Unity Default Resources file (a library created at the time the game was compiled).</p>
<p>This method is perhaps the simplest way to store and read the external resource files. However, it is only appropriate when the contents of the resource files will not change after compilation, since the contents of these files are combined and compiled into the <kbd>resources.assets</kbd> file.</p>
<p>The <kbd>resources.assets</kbd> file can be found in the <kbd>Data</kbd> folder for a compiled game:</p>
<div><img src="img/f782bcfb-b96b-4115-9a58-6b21ed2a68c7.png" style="width:25.58em;height:16.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In the 10_01 folder, we have provided an image file, a text file, and an audio file in the <kbd>.ogg</kbd> format for this recipe:</p>
<ul>
<li><kbd>externalTexture.jpg</kbd></li>
<li><kbd>cities.txt</kbd></li>
<li><kbd>soundtrack.ogg</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To load the external resources from Unity Default Resources, do the following:</p>
<ol>
<li>Create a new 3D Unity project.</li>
<li>In the <kbd>Project</kbd> window, create a new folder and rename it <kbd>Resources</kbd>.</li>
<li>Import the <kbd>externalTexture.jpg</kbd> file and place it in the <kbd>Resources</kbd> folder.</li>
<li>Create a 3D cube, and name it <kbd>Cube-1</kbd>.</li>
<li>Create a C# <kbd>ReadDefaultResources</kbd> script class and add an instance object as a component to <kbd>Cube-1</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> <br/> public class ReadDefaultResources : MonoBehaviour {<br/>   public string fileName = "externalTexture";<br/>   private Texture2D externalImage;<br/> <br/>   void Start () {<br/>     externalImage = (Texture2D)Resources.Load(fileName);<br/>     Renderer myRenderer = GetComponent&lt;Renderer&gt;();<br/>     myRenderer.material.mainTexture = externalImage;<br/> }<br/> }</pre>
<ol start="6">
<li>Play the scene. The <kbd>texture</kbd> will be loaded and displayed on the screen.</li>
<li>If you have another image file, put a copy into the <kbd>Resources</kbd> folder. Then, in the <kbd>Inspector</kbd> window, change the public file name to the name of your image file and play the scene again. The new image will now be displayed.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>Resources.Load (fileName)</kbd> statement makes Unity look inside its compiled project data file called resources.assets for the contents of a file named <kbd>externalTexture.</kbd> The contents are returned as a texture image, which is stored into the <kbd>externalImage</kbd> variable. The last statement in the <kbd>Start()</kbd> method sets the texture of the GameObject  the script has been attached to our externalImage variable.</p>
<p>The string variable <kbd>fileName</kbd> is public property, so you can select GameObject Cube-1 in the Hierarchy, and edit the File Name string in the Read Default Resources (Script) component in the Inspector.</p>
<p>The filename string passed to <kbd>Resources.Load()</kbd> does not include the file extension (such as <kbd>.jpg</kbd> or <kbd>.txt</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some details that you won't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading text files with this method</h1>
                
            
            
                
<p>You can load the external text files using the same approach. The private variable needs to be a string (to store the text file content). The <kbd>Start()</kbd> method uses a temporary <kbd>TextAsset</kbd> object to receive the text file content, and the text property of this object contains the string content that are to be stored in the private <kbd>textFileContents </kbd>variable:</p>
<pre>using UnityEngine;<br/> <br/> public class ReadDefaultResourcesText : MonoBehaviour {<br/>   public string fileName = "textFileName"; // e.g.: cities.txt<br/>   private string textFileContents;<br/> <br/>   void Start () {<br/>     TextAsset textAsset = (TextAsset)Resources.Load(fileName);<br/>     textFileContents = textAsset.text;<br/>     Debug.Log(textFileContents);<br/>   }<br/> } </pre>
<p>Finally, this string is displayed on the console:</p>
<div><img src="img/c09513a5-3963-4d1f-ba3e-c34142b4819a.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading and playing audio files with this method</h1>
                
            
            
                
<p>You can load external audio files using the same approach. The private variable needs to be an <kbd>AudioClip</kbd>:</p>
<pre>using UnityEngine;<br/> <br/>[RequireComponent (typeof (AudioSource))]<br/>public class ReadDefaultResourcesAudio : MonoBehaviour {<br/>   public string fileName = "soundtrack";<br/> <br/>   void Start () {<br/>     AudioSource audioSource = GetComponent&lt;AudioSource&gt;();<br/>     audioSource.clip = (AudioClip)Resources.Load(fileName);<br/>     if(!audioSource.isPlaying &amp;&amp; audioSource.clip.loadState == AudioDataLoadState.Loaded)<br/>           audioSource.Play();<br/> }<br/> }</pre>
<p>We don't try to play the <kbd>AudioClip</kbd> until loading has been completed, which we can test with the audio clip's <kbd>loadState</kbd> property. Learn more about <strong>Audio Load State</strong> in the Unity scripting reference pages: <a href="https://docs.unity3d.com/ScriptReference/AudioDataLoadState.html">https://docs.unity3d.com/ScriptReference/AudioDataLoadState.html</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>Refer to the following recipes in this chapter for more information:</p>
<ul>
<li>Loading external resource files by manually storing files in Unity <kbd>Resources</kbd> folder</li>
<li>Loading external resource files by downloading files from the internet</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading external resource files by downloading files from the internet</h1>
                
            
            
                
<p>One way to store and read a text file data is to store the text files on the web. In this recipe, the content of a text file for a given URL are downloaded, read, and then displayed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, you need to have access to the files on a web server. If you run a local web server such as Apache, or have your own web hosting, then you can use the files in the <kbd>10_02</kbd> folder and the corresponding URL.</p>
<p>Otherwise, you may find the following URLs useful, since they are the web locations of an image file (a Packt Publishing logo) and a text file (an ASCII-art badger picture):</p>
<ul>
<li><a href="http://www.packtpub.com/sites/default/files/packt_logo.png" target="_blank">www.packtpub.com/sites/default/files/packt_logo.png</a></li>
<li><a href="http://www.ascii-art.de/ascii/ab/badger.txt" target="_blank">www.ascii-art.de/ascii/ab/badger.txt</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To load external resources by downloading them from the Internet, do the following:</p>
<ol>
<li>In a 3D project, create a new RawImage UI GameObject.</li>
<li>Create a C# ReadImageFromWeb script class and add an instance object as a component to the RawImage GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEngine.UI;<br/> using System.Collections;<br/> <br/> public class ReadImageFromWeb : MonoBehaviour {<br/>     public string url = "http://www.packtpub.com/sites/default/files/packt_logo.png";<br/> <br/>     IEnumerator Start() {<br/>         WWW www = new WWW(url);<br/>         yield return www;<br/> <br/>         Texture2D texture = www.texture;<br/>         GetComponent&lt;RawImage&gt;().texture = texture;<br/>     }<br/> } </pre>
<ol start="3">
<li>Play the <strong>Scene.</strong> Once downloaded, the content of the image file will be displayed:</li>
</ol>
<div><img src="img/73064cad-b97b-4763-b97e-f4c7e5f52bfa.png" style="width:18.67em;height:19.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Note the need to use the <kbd>UnityEngine.UI</kbd> package for this recipe.</p>
<p>When the game starts, our <kbd>Start()</kbd> method starts the coroutine method called <kbd>LoadWWW()</kbd>. A <strong>coroutine</strong> is a method that can keep on running in the background without halting or  slowing down the other parts of the game and the frame rate. The yield statement indicates that once a value can be returned for <kbd>imageFile,</kbd> the remainder of the method can be executed—that is, until the file has finished downloading, no attempt should be made  to extract the texture property of the <kbd>WWW</kbd> object variable.</p>
<p>Once the image data has been loaded, execution will progress past the yield statement. Finally, the texture property of the RawImage GameObject, to which the script is attached, is changed to the image data that is downloaded from the web (inside the texture variable of the WWW object).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting from Texture to Sprite</h1>
                
            
            
                
<p>While in the recipe, we used a UI RawImage, and so we could use the downloaded texture directly; however, there may be times when we wish to work with a Sprite rather than a Texture.  To create a Sprite object from a texture create the following script-class:</p>
<pre>using UnityEngine;<br/> using UnityEngine.UI;<br/> using System.Collections;<br/> <br/> public class ImageFromWebTextureToSprite : MonoBehaviour {<br/>     public string url = "http://www.packtpub.com/sites/default/files/packt_logo.png";<br/> <br/>     IEnumerator Start() {<br/>         WWW www = new WWW(url);<br/>         yield return www;<br/> <br/>         Texture2D texture = www.texture;<br/>         GetComponent&lt;Image&gt;().sprite = TextureToSprite(texture);<br/>     }<br/> <br/>     private Sprite TextureToSprite(Texture2D texture) {<br/>         Rect rect = new Rect(0, 0, texture.width, texture.height);<br/>         Vector2 pivot = new Vector2(0.5f, 0.5f);<br/>         Sprite sprite = Sprite.Create(texture, rect, pivot);<br/>         return sprite;<br/>     }<br/> } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Downloading a text file from the web</h1>
                
            
            
                
<p>Use this technique to download a text file (attach an instance of a script class to a UI Text object):</p>
<pre>using UnityEngine;<br/> using System.Collections;<br/> using UnityEngine.UI;<br/> <br/> public class ReadTextFromWeb : MonoBehaviour {<br/>     public string url = "http://www.ascii-art.de/ascii/ab/badger.txt";<br/> <br/>     IEnumerator Start() {<br/>         Text textUI = GetComponent&lt;Text&gt;();<br/>         textUI.text = "(loading file ...)";<br/>         WWW www = new WWW(url);<br/>         yield return www;<br/> <br/>         string textFileContents = www.text;<br/>         Debug.Log(textFileContents);<br/>         textUI.text = textFileContents;<br/>     }<br/> } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The WWW class and the resource content</h1>
                
            
            
                
<p>The WWW class defines several different properties and methods to allow the downloaded media resource file data to be extracted into appropriate variables for use in the game.  The most useful of these include the following:</p>
<ul>
<li><kbd>.text</kbd>: A read-only property, returning the web data as string</li>
<li><kbd>.texture</kbd>: A read-only property, returning the web data as a <kbd>Texture2D</kbd> image</li>
<li><kbd>.GetAudioClip()</kbd>: A method that returns the web data as an <kbd>AudioClip</kbd></li>
</ul>
<p>For more information about the Unity WWW class, visit <a href="http://docs.unity3d.com/ScriptReference/WWW.html">http://docs.unity3d.com/ScriptReference/WWW.html</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An example using UnityWebRequest</h1>
                
            
            
                
<p>Rather than the <kbd>WWW</kbd> class, we can also download the texture using the <kbd>UnityWebRequest</kbd> library. Just replace the content of the <kbd>ReadImageFromWeb</kbd> script class with the following:</p>
<pre>using UnityEngine;<br/>using UnityEngine.UI;<br/>using System.Collections;<br/>using UnityEngine.Networking;<br/>public class ReadImageFromWebUnityWebRequest : MonoBehaviour {<br/> public string url = "http://www.packtpub.com/sites/default/files/packt_logo.png";<br/>IEnumerator Start() {<br/> using (UnityWebRequest uwr = UnityWebRequestTexture.GetTexture(url)) {<br/> yield return uwr.SendWebRequest();<br/>if (uwr.isNetworkError || uwr.isHttpError)<br/> Debug.Log(uwr.error);<br/> else {<br/> Texture2D texture = DownloadHandlerTexture.GetContent(uwr);<br/> UpdateUIRawImage(texture);<br/> }<br/> }<br/> }<br/> <br/> private void UpdateUIRawImage(Texture2D texture) {<br/> GetComponent&lt;RawImage&gt;().texture = texture; <br/> }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>Refer to the following recipes in this chapter for more information:</p>
<ul>
<li>Loading external resource files by <strong>Unity Default Resources</strong></li>
<li>Loading external resource files by manually storing files in the Unity  <kbd>Resources</kbd> folder</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading external resource files by manually storing files in the Unity  Resources or StreamingAssets folders</h1>
                
            
            
                
<p>At times, the content of the external resource files may need to be changed after the game compilation. Hosting the resource files on the web may not be an option. There is a method of manually storing and reading files from the <kbd>Resources</kbd> folder of the compiled game, which allows for those files to be changed after the game compilation.</p>
<p>The <kbd>Resources</kbd> folder technique works when you compile to a Windows or Mac standalone executables. The <kbd>SteamingAssets</kbd> folder technique works with these, and also iOS and Android devices. The next recipe illustrates the Resources folder technique, and then at the end we discuss how to use the <kbd>StreamingAssets</kbd> approach.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The <kbd>10_01</kbd> folder provides the texture image that you can use for this recipe:</p>
<ul>
<li><kbd>externalTexture.jpg</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To load external resources by manually storing the files in the Resources folder, do the following:</p>
<ol>
<li>Create a new 3D project.</li>
<li>Create a new UI Image GameObject. Make this take up most of the screen.</li>
<li>Create a new UI Text GameObject. Position this to stretch the full width of the screen, along the bottom.</li>
<li>Create a C# ReadManualResourceImageFile script class and add an instance object as a component to the UI Image GameObject:</li>
</ol>
<pre style="padding-left: 60px">using System.Collections;<br/> using UnityEngine;<br/> using UnityEngine.UI;<br/> using System.IO;<br/> <br/> public class ResourceFileLoader : MonoBehaviour<br/> {<br/>     public Text textUrl;<br/> <br/>     private string fileName = "externalTexture.jpg";<br/>     private string urlPrefixMac = "file://";<br/>     private string urlPrefixWindows = "file:///";<br/> <br/>     IEnumerator Start()<br/>     {<br/>         //        string url = urlPrefixWindows + Application.dataPath;<br/>         string url = urlPrefixMac + Application.dataPath;<br/>         url = Path.Combine(url, "Resources");<br/>         url = Path.Combine(url, fileName);<br/> <br/>         textUrl.text = url;<br/> <br/>         WWW www = new WWW(url);<br/>         yield return www;<br/> <br/>         Texture2D texture = www.texture;<br/>         GetComponent&lt;Image&gt;().sprite = TextureToSprite(texture);<br/>     }<br/> <br/>     private Sprite TextureToSprite(Texture2D texture)<br/>     {<br/>         Rect rect = new Rect(0, 0, texture.width, texture.height);<br/>         Vector2 pivot = new Vector2(0.5f, 0.5f);<br/>         Sprite sprite = Sprite.Create(texture, rect, pivot);<br/>         return sprite;<br/>     }<br/> } </pre>
<ol start="5">
<li>With the UI Image GameObject selected in the Hierarchy, drag the UI Text object to populate the public Text URL property, in the Inspector, for the ResourceFileLoader (Script) component.</li>
<li>Save the current scene, and add it to the build settings.</li>
<li>Build your (Windows or Mac) standalone executable.</li>
<li>Copy the externalTexture.jpg image to your standalone's <kbd>Resources</kbd> folder:</li>
</ol>
<div><img src="img/205d9d02-dbbf-4607-8587-7e5f8eec85e1.png" style="width:31.83em;height:5.50em;"/></div>
<ol start="9">
<li>Run your standalone game application, and the image will be read at run-time from the Resources folder and displayed (and the path to that resource will be shown in the UI Text at the bottom of the application window):</li>
</ol>
<div><img src="img/aba7b749-cc3e-4d4a-9f4d-7508f65aa022.png" style="width:29.83em;height:22.67em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>A URL-path is defined, stating where Unity can find the desired image in the Resources folder of the standalone application build. This path is shown onscreen by setting the text property of the UI Text GameObject to that path's string value.</p>
<p>The <strong>WWW</strong> object spots that the URL starts with the file-protocol, and so Unity attempts to find the external resource file in its Resources folder (waiting until it has finished loading), and then load its content.</p>
<p>The <kbd>Start()</kbd> method is declared as an <kbd>IEnumerator</kbd>, allowing it to run as a <strong>co-routine</strong>, and so wait until the WWW class object completes its loading of the image file:</p>
<p>You will need to place the files in the Resources folder manually after every compilation.<br/>
When you create a Windows or Linux standalone executable, there is also a <kbd>_Data</kbd> folder, created with the executable application file. The Resources folder can be found inside this Data folder.<br/>A Mac standalone application executable looks like a single file, but it is actually a macOS package folder. Right-click on the executable file and select <strong>Show Package Contents</strong>. You will then find the standalone's Resources folder inside the Contents folder.</p>
<p>We are using the file protocol for the URL, which must start in the form: <kbd>file:///:</kbd><br/>For the OSX standalone, the Unity Application.dataPath will return a path in the form <kbd>/user/location-to-Contents</kbd>, so we prefix this with <kbd>file://</kbd> to get a valid file-protocol URL in the form <kbd>file:///user/location-to-Contents</kbd>.<br/>For Windows the standalone for the Unity Application.dataPath will return a path in the form <kbd>C:Projects/MyUnityProject/location-to-</kbd><kbd>Data</kbd>, so we prefix this with <kbd>file:/// to get a valid file-prototcol</kbd> URL in the form <kbd>file:///C:Projects/MyUnityProject/location-to-Data</kbd></p>
<p>Learn more from the Unity documentation and Unity answers pages:</p>
<ul>
<li>Scripting <kbd>Application.dataPath</kbd>: <a href="https://docs.unity3d.com/ScriptReference/Application-dataPath.html">https://docs.unity3d.com/ScriptReference/Application-dataPath.html</a></li>
<li>Unity Answers: <a href="https://answers.unity.com/questions/517414/how-to-use-www-to-load-local-files.html">https://answers.unity.com/questions/517414/how-to-use-www-to-load-local-files.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding cross-platform problems with Path.Combine() rather than / or \</h1>
                
            
            
                
<p>The filepath folder separator character is different for Windows and Mac file systems (backslash \ for Windows, forward slash / for the Mac). However, Unity knows which kind of standalone you are compiling your project into; therefore, the <kbd>Path.Combine()</kbd> method will insert the appropriate separator slash character form the file URL that is required.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">SteamingAssets folder</h1>
                
            
            
                
<p>If deploying to iOS or Android, the <kbd>Resources</kbd> folder technique won't work, and you should create and store resource files in a folder named <kbd>StreamingAssets.</kbd> For example, if you had a text file named <kbd>MyTextFile.txt</kbd>, you could create a folder named <kbd>StreamingAssets</kbd> in the <strong>Project</strong> panel, store file <kbd>MyTextFile.txt</kbd> in that folder, and use the following code to load the content of that file at run-time with your built application:</p>
<pre>string filePath = System.IO.Path.Combine(Application.streamingAssetsPath, "MyTextFile.txt");<br/>string contents = System.IO.File.ReadAllText(filePath);</pre>
<p>Learn more about the StreamingAsset folder in Unity at the following links: <a href="https://docs.unity3d.com/Manual/StreamingAssets.html">https://docs.unity3d.com/Manual/StreamingAssets.html</a> and  <a href="https://docs.unity3d.com/ScriptReference/Application-streamingAssetsPath.html">https://docs.unity3d.com/ScriptReference/Application-streamingAssetsPath.html</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>Refer to the following recipes in this chapter for more information:</p>
<ul>
<li>Loading external resource files by Unity Default Resources</li>
<li>Loading external resource files by downloading files from the internet</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving Project files into Unity Asset Bundles</h1>
                
            
            
                
<p>Unity provides the Asset Bundle mechanism as another way to manage the loading of resources at run-time. Asset Bundles can be stored locally, or on the intenet.</p>
<p>In this recipe, we will create a prefab (of a 3D cube GameObject), and save it into an Asset Bundle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In the <kbd>10_06</kbd> folder, we have provided the <kbd>externalTexture.jpg</kbd> image file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To save Unity Asset Bundles, do the following:</p>
<ol>
<li>Create a new 3D Unity project.</li>
<li>Import the provided image file (into a new folder named Textures).</li>
<li>Create a new Cube (named <kbd>Cube-1</kbd>) in the scene, and apply the imported texure image.</li>
<li>In the Project window, create a new folder and rename it Prefabs.</li>
<li>In the Project folder Prefabs, create a new empty Prefab named cube.</li>
<li>From the Scene panel, drag GameObject Cube-1 over the Prefab cube in Project folder Prefabs. The prefab should turn blue and now be a file storing the properties of GameObject Cube-1.</li>
<li>With the file cube selected in the Project panel, go to the bottom of the Inspector panel and create a new AssetBundle, naming it chapter11. See the screenshot illustrating this:</li>
</ol>
<div><img src="img/79fde76b-531e-4a77-9c81-f85e0d4a6ef6.png" style="width:17.83em;height:21.58em;"/></div>
<ol start="8">
<li>In the Project panel, create a new folder called <kbd>Editor</kbd> and <kbd>AssetBundles</kbd>.</li>
<li>In the Editor folder, create a new C# CreateAssetBundles script class containing the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> <br/> public class CreateAssetBundles<br/> {<br/>     [MenuItem("Assets/Build AssetBundles/Mac")]<br/>     static void BuildAllAssetBundlesMac()<br/>     {<br/>         string assetBundleDirectory = "Assets/AssetBundles";<br/>         BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSX);<br/>     }<br/> <br/>     [MenuItem("Assets/Build AssetBundles/Windows")]<br/>     static void BuildAllAssetBundlesWindows()<br/>     {<br/>         string assetBundleDirectory = "Assets/AssetBundles";<br/>         BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);<br/>     }<br/> } </pre>
<ol start="10">
<li>You should now see two new menu items added to the bottom of the Assets menu:</li>
</ol>
<div><img src="img/ded3e541-21cc-49a7-86d5-5bb0ba87c20b.png" style="width:25.25em;height:10.58em;"/></div>
<ol start="11">
<li>Choose the create bundles action for the operating system you are using (Mac or Windows).</li>
<li>You should now see files created in folder <kbd>AssetBundles</kbd>: <kbd>AssetBundles</kbd> and <kbd>chapter11</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>Resources.Load(fileName)</kbd> statement makes Unity look inside its compiled project data file called <kbd>resources.assets</kbd> for the content of a file named <kbd>externalTexture</kbd>. The content is returned as a texture image, which is stored into the <kbd>externalImage</kbd> variable. The last statement in the <kbd>Start()</kbd> method sets the texture of the GameObject to which the script has been attached to our <kbd>externalImage</kbd> variable.</p>
<p>The string varable fileName is a public property, so you can select GameObject Cube-1 in the Hierarchy, and edit the File Name string in the Read Default Resources (Script) component in the Inspector.</p>
<p>Learn more about AssetBundles and the workflow recommended by Unity at the following addresses:</p>
<ul>
<li>Asset Bundles Workflow: <a href="https://docs.unity3d.com/2018.1/Documentation/Manual/AssetBundles-Workflow.html">https://docs.unity3d.com/2018.1/Documentation/Manual/AssetBundles-Workflow.html</a></li>
<li>Native use of Asset Bundles: <a href="https://docs.unity3d.com/2018.1/Documentation/Manual/AssetBundles-Native.html">https://docs.unity3d.com/2018.1/Documentation/Manual/AssetBundles-Native.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading resources from Unity Asset Bundles</h1>
                
            
            
                
<p>In this recipe, we will load an Asset Bundle, and retrieve a prefab, then create (Instantiate) a <kbd>GameObject</kbd> in the scene from the retrieved data:</p>
<div><img src="img/517b3d1c-838f-4c05-93d4-e6653824610a.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe uses the files created by the previous reciple. We have also provided a copy of folder AssetBundles in <kbd>10_07</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To load Unity Asset Bundles, do the following:</p>
<ol>
<li>Create a new 3D Unity project.</li>
<li>Import the provided folder <kbd>AssetBundles</kbd>.</li>
<li>Create the following C# <kbd>AssetBundleLoader</kbd> script class and add an instance as a component of the Main Camera:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System.IO;<br/> using UnityEngine.Networking;<br/> using System.Collections;<br/> <br/> public class AssetBundleLoader : MonoBehaviour<br/> {<br/>     public string bundleFolderName = "AssetBundles";<br/>     public string bundleName = "chapter11";<br/>     public string resourceName = "cube";<br/> <br/>     void Start()<br/>     {<br/>         StartCoroutine(LoadAndInstantiateFromUnityWebRequest());<br/>     }<br/> <br/>     private IEnumerator LoadAndInstantiateFromUnityWebRequest()<br/>     {<br/>         // (1) load asset bundle<br/>         string uri = "file:///" + Application.dataPath;<br/>         uri = Path.Combine(uri, bundleFolderName);<br/>         uri = Path.Combine(uri, bundleName);<br/> <br/>         UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(uri, 0);<br/>         yield return request.SendWebRequest();<br/> <br/>         // (2) extract 'cube' from loaded asset bundle<br/>         AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);<br/>         GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(resourceName);<br/> <br/>         // (3) create scene GameObject based on 'cube'<br/>         Instantiate(cube);<br/>     }<br/> } </pre>
<ol start="4">
<li>Run the <strong>Scene,</strong> and a cube should appear in the scene, created by extracting the Prefab cube file from the Asset Bundle, and then instantiating a new GameObject based on this prefab.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Unity method <kbd>UnityWebRequestAssetBundle.GetAssetBundle(...)</kbd> expects a file-protocol URI to a named Asset Bundle. This bundle was loaded into variable bundle, and then the <kbd>LoadAsset(...)</kbd> method used to extract the file named <kbd>cube</kbd>. Finally, a GameObject was created at run-time based on this prefab, resulting in the cube that we see when we run the scene.</p>
<p>The variables <kbd>bundleFolderName,</kbd> <kbd>bundleName,</kbd> and <kbd>resourceName</kbd> define the folder, Asset Bundle filename and prefab inside the <kbd>Asset</kbd> Bundle for this project.</p>
<p>If you select the <kbd>chapter11</kbd> manifest file (the icon that looks like a piece of paper with lines), then in the Inspector, you can see that it contains our cube prefab:</p>
<pre>    ...<br/>     Assets:<br/>     - Assets/Prefabs/cube.prefab </pre>
<p>Learn more about <kbd>AssetBundles</kbd> and the workflow recommended by Unity at the following addresses:</p>
<ul>
<li>Asset Bundles Workflow: <a href="https://docs.unity3d.com/2018.1/Documentation/Manual/AssetBundles-Workflow.html" target="_blank">https://docs.unity3d.com/2018.1/Documentation/Manual/AssetBundles-Workflow.html</a></li>
<li>Native use of Asset Bundles: <a href="https://docs.unity3d.com/2018.1/Documentation/Manual/AssetBundles-Native.html" target="_blank">https://docs.unity3d.com/2018.1/Documentation/Manual/AssetBundles-Native.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading AssetBundles via AssetBundle.LoadFromFile()</h1>
                
            
            
                
<p>An alternative to <kbd>UnityWebRequest</kbd> for local loading from tiles is to use <kbd>AssetBundle.LoadFromFile():</kbd></p>
<pre>    void Start()<br/>     {<br/>         // (1) load asset bundle<br/>         string path = Path.Combine(Application.streamingAssetsPath, bundleName);<br/>         AssetBundle myLoadedAssetBundle = AssetBundle.LoadFromFile(path);<br/> <br/>         if (null == myLoadedAssetBundle)<br/>         {<br/>             Debug.Log("Failed to load AssetBundle: " + path);<br/>             return;<br/>         }<br/> <br/>         // (2) extract 'cube' from loaded asset bundle<br/>         string resourceName = "cube";<br/>         GameObject prefabCube = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(resourceName);<br/> <br/>         // (3) create scene GameObject based on 'cube'<br/>         Instantiate(prefabCube);<br/>     } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading AssetBundles hosted via a web server</h1>
                
            
            
                
<p>Although we have just illustrated how to load an <kbd>AssetBundle</kbd> from a local file, often such resources are loaded from a web server. In this case, the URI needs to be an internet protocol.</p>
<p>For example, if files are being served locally on port 8000, then the host will be http://localhost:8000 and so on:</p>
<pre>    public string bundleName = "chapter11";<br/>     public string resourceName = "cube";<br/> <br/>     public string host = "http://localhost:8000";<br/> <br/>     void Start() {<br/>         StartCoroutine(LoadAndInstantiateFromUnityWebRequestServer());<br/>     }<br/> <br/>     private IEnumerator LoadAndInstantiateFromUnityWebRequestServer() {<br/>         string uri = Path.Combine(host, bundleName);<br/>         UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(uri, 0);<br/>         yield return request.SendWebRequest();<br/> <br/>         AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);<br/>         GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(resourceName);<br/>         Instantiate(cube);<br/>     } </pre>


            

            
        
    </body></html>