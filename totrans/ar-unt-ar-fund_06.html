<html><head></head><body><div><div><h1 id="_idParaDest-75"><em class="italic"><a id="_idTextAnchor077"/>Chapter 4</em><strong class="bold">: Creating an AR User Framework</strong></h1>
			<p>In this chapter, we will develop a framework for building<strong class="bold"> Augmented Reality</strong> (<strong class="bold">AR</strong>) applications that manage user interaction modes and the corresponding <strong class="bold">user interface </strong>(<strong class="bold">UI</strong>). The framework includes important <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>) steps when starting up the AR session at runtime and interacting with AR features. This framework will form the basis for new scenes for projects later in this book.</p>
			<p>This is a Unity framework for building mode-based applications. It generalizes some of the scene structure that I have found myself repeating from one project to the next. For example, when an AR app first starts, it must verify that the device supports AR. Once the AR session is initialized, the app may prompt the user to begin scanning the environment to establish tracking. At some point later in the application, the user might be prompted to tap the screen to place a virtual object, often in <em class="italic">Add-object mode</em>. These steps are common to many AR applications, including the projects in this book, so we will set up some infrastructure beforehand in a scene that may be used as a template.</p>
			<p>This chapter involves some advanced C# coding. If you're already an intermediate or advanced programmer, you should be able to follow along fairly easily. If you're a novice, you can just copy/paste the code provided here and learn from it. Or, you have the option of skipping the chapter altogether and using the scene template from this chapter found in this book's GitHub repository. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Installing prerequisite assets for our framework</li>
				<li>Starting with a new scene</li>
				<li>Creating the UI canvas and panels</li>
				<li>Creating the UI controller, using a Singleton class</li>
				<li>Creating an interaction modes controller</li>
				<li>Creating the interaction modes, including startup, scan, main, and non-AR modes</li>
				<li>Usng the Unity onboarding UX assets</li>
				<li>Creating a scene template for new scenes</li>
			</ul>
			<p>By the end of the chapter, you'll have a scene template, named <code>ARTemplate</code>, with AR onboarding features, and a user interaction framework that can be used as a starting point for other AR projects.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>To implement the project in this chapter, you need Unity installed on your development computer, connected to a mobile device that supports AR applications. We'll use the Unity project set up for AR development in <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up for AR Development</em>. In review, the project configuration included the following:</p>
			<ul>
				<li>It created a new project (via <strong class="bold">Unity Hub</strong>) using the <strong class="bold">Universal Render Pipeline</strong> template.</li>
				<li>It set <strong class="bold">Target Platform</strong> for <strong class="bold">Android</strong> or <strong class="bold">iOS</strong> in <strong class="bold">Build Settings</strong>, and the corresponding required <strong class="bold">Player Settings</strong>.</li>
				<li>It installed an <strong class="bold">XR Plugin</strong>, <strong class="bold">AR Foundation</strong> package, and configured the <strong class="bold">URP Forward Renderer</strong> for AR.</li>
				<li>It installed the <strong class="bold">Input System</strong> package and sets <strong class="bold">Active Input Handling</strong> (to <strong class="bold">Input System Package</strong> or <strong class="bold">Both</strong>).</li>
			</ul>
			<p>The completed scene from this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation">https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation</a>.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor079"/>Understanding AR interaction flow</h1>
			<p>In an <a id="_idIndexMarker303"/>Augmented Reality application, one of the first things the user must do is scan the environment with the device camera, slowly moving their device around until it detects geometry for tracking. This might be horizontal planes (floor, tabletop), vertical planes (walls), a human face, or other objects. A simplistic user flow given in many example scenes is shown in the following diagram:</p>
			<div><div><img src="img/Figure_4.01-OnboardingFlow.jpg" alt="Figure 4.1 – A simple AR onboarding user workflow&#13;&#10;" width="956" height="623"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – A simple AR onboarding user workflow</p>
			<p>As shown in the preceding diagram, the app starts by checking for AR support, asking the user for permission to access the device camera and other initializations. Then, the app asks the <a id="_idIndexMarker304"/>user to scan the environment for trackable objects, and may need to report scanning problems, such as if the room is too dark or there's not enough texture to detect features. Once tracking is achieved, the user is prompted to tap the screen to place a virtual object in the scene.</p>
			<p>This is great for demo scenes but is probably too simplistic for a real AR application. For example, in the Art Gallery app that we are going to build in <a href="B15145_06_Final_SB_epub.xhtml#_idTextAnchor136"><em class="italic">Chapter 6</em></a>, <em class="italic">Gallery: Building an AR App</em>, after the application starts, the environment is scanned for vertical planes (walls). </p>
			<p>Then, the app enters <strong class="bold">Main</strong> mode, where the user must tap an <strong class="bold">Add</strong> button to add a new picture. That, in turn, displays a modal <strong class="bold">Select Image</strong> menu. With pictures added to the scene, the user can pick one and enter <strong class="bold">Edit</strong> mode to move, resize, or otherwise modify the virtual object. Part of this general interaction flow is shown in the following diagram:</p>
			<div><div><img src="img/Figure_4.02-userflow-add-edit.jpg" alt="Figure 4.2 – User interaction flow, including Main, Add, and Edit modes&#13;&#10;" width="849" height="571"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – User interaction flow, including Main, Add, and Edit modes</p>
			<p>Naturally, each <a id="_idIndexMarker305"/>application has its own interaction flows. The framework we are building in this chapter supports this scenario and can be adapted for other projects that require managing a current modal state and corresponding UI. </p>
			<p>This framework<a id="_idIndexMarker306"/> implements a <strong class="bold">state machine</strong> design pattern, where the scene has a current <em class="italic">state</em> (interaction mode and visible UI). Specific conditions must be met to then transition from one state to another.</p>
			<p>There are two major areas of this framework – the UI panels and the interaction modes. Generally, there will be a one-to-one correlation between the modes and the UI used by the modes. For example, in <em class="italic">Main mode</em>, there will be the main menu UI. In <em class="italic">Add-object mode</em>, there will be a UI prompt for the user to tap to place an object in the scene. This implements a design pattern<a id="_idIndexMarker307"/> called <strong class="bold">view-controller</strong>, with UI views and mode controllers.</p>
			<p>Let's now <a id="_idIndexMarker308"/>begin to implement this basic workflow in our scene by adding a number of additional prerequisite packages to the project. </p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/>Installing prerequisite assets</h1>
			<p>Our user<a id="_idIndexMarker309"/> interaction framework uses several additional packages that need to be installed in your project, namely, TextMeshPro, DOTween, and Serialized Dictionary Lite. In this section, I will also include some utility assets. Let's install them now.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>TextMeshPro</h2>
			<p>TextMeshPro <a id="_idIndexMarker310"/>provides<a id="_idIndexMarker311"/> high-quality text assets that replace the built-in text element. It is not mandatory, but I strongly recommend it. To import <strong class="bold">TextMeshPro</strong>, if you haven't installed it yet in your project, perform the following steps:</p>
			<ol>
				<li>Go to <strong class="bold">Window | TextMeshPro | Import TMP Essential Resources</strong>. </li>
				<li>In the <strong class="bold">Import Unity Package</strong> window, click <strong class="bold">Import</strong>.</li>
			</ol>
			<p>The TextMeshPro package is now installed. You may also install the <strong class="bold">TMP Examples and Extras</strong> package, which includes additional fonts and other assets that may be useful and fun for your projects.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/>DOTween</h2>
			<p>DOTween<a id="_idIndexMarker312"/> is, in <a id="_idIndexMarker313"/>my opinion, an indispensable free package for doing small, lightweight animation effects on just about any <code>MonoBehaviour</code> property. Without it, you may need to write a dozen lines of code to do what DOTween does in one. Documentation for DOTween can be found <a id="_idIndexMarker314"/>online at <a href="http://dotween.demigiant.com/documentation.php">http://dotween.demigiant.com/documentation.php</a>.</p>
			<p>To add DOTween, perform the following steps:</p>
			<ol>
				<li value="1">Go to its Unity Asset Store page: <a href="https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676">https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676</a>. </li>
				<li>Press <strong class="bold">Add to My Assets</strong> and/or <strong class="bold">Open In Unity</strong>.</li>
				<li>This will take you to the <strong class="bold">Package Manager</strong> window in your Unity project. </li>
				<li>Ensure <strong class="bold">My Assets</strong> is selected from the <strong class="bold">Packages</strong> filter dropdown in the upper-left corner of the <strong class="bold">Package Manager</strong> window.</li>
				<li>Search for <code>DOTween</code> using the search text input field in the upper-right corner of the <strong class="bold">Package Manager</strong> window.</li>
				<li>Select the <strong class="bold">DOTween</strong> package and then click <strong class="bold">Install</strong>.</li>
				<li>Once<a id="_idIndexMarker315"/> imported, you<a id="_idIndexMarker316"/> are prompted to <strong class="bold">Open DOTween Utility Panel</strong> to set up the package. </li>
				<li>Then, click the <strong class="bold">Setup DOTween</strong> button.</li>
			</ol>
			<p>DOTween is now installed and set up on your project.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Serialized Dictionary Lite</h2>
			<p>A C# <strong class="bold">dictionary</strong> is a<a id="_idIndexMarker317"/> key-value list structure where <a id="_idIndexMarker318"/>values in the list can be referenced by a key value. For example, we will use dictionaries to look up a UI panel or interaction mode object by name. Unfortunately, Unity does not provide native support for dictionaries in the Editor's <strong class="bold">Inspector</strong> window. <strong class="bold">Serialized Dictionary Lite</strong> is a free extension to the Unity Editor that allows dictionaries to be edited using <strong class="bold">Inspector</strong>. To add Serialized Dictionary Lite to your project, perform the following steps:</p>
			<ol>
				<li value="1">Go to its Unity Asset Store page, <a href="https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992">https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992</a><a href="https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992.%0D"/></li>
				<li>Press <strong class="bold">Add to My Assets</strong> and/or <strong class="bold">Open In Unity</strong>.</li>
				<li>This will take you to the <strong class="bold">Package Manager</strong> window in your Unity project. </li>
				<li>Ensure <strong class="bold">My Assets</strong> is selected from the <strong class="bold">Packages</strong> filter dropdown in the upper-left corner of the <strong class="bold">Package Manager</strong> window.</li>
				<li>Search for <code>Serialized</code> using the search text input field in the upper-right corner of the <strong class="bold">Package Manager</strong> window.</li>
				<li>Select<a id="_idIndexMarker319"/> the <strong class="bold">Serialized Dictionary Lite</strong> package<a id="_idIndexMarker320"/> and click <strong class="bold">Install</strong> (or, if prompted, click <strong class="bold">Download</strong> and then <strong class="bold">Import</strong>).</li>
			</ol>
			<p>Serialized Dictionary Lite is now installed in your project.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Other prerequisite assets</h2>
			<p>In addition to<a id="_idIndexMarker321"/> the aforementioned packages, we will assume that you have the following already added to your Unity project:</p>
			<ul>
				<li>Assets from the Unity <code>ARF-samples.unity</code> package created in <a href="B15145_02_Final_SS_epub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Your First AR Scene</em>.</li>
				<li>In <a href="B15145_02_Final_SS_epub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Your First AR Scene</em>, we also created an <strong class="bold">AR Input Actions</strong> asset containing an <strong class="bold">Action Map</strong> named <strong class="bold">ARTouchActions</strong>, including (at least) one <strong class="bold">PlaceObject</strong> action. </li>
			</ul>
			<p>With our prerequisite assets present, we can get started with building the scene.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor085"/>Starting with a new scene</h1>
			<p>We start<a id="_idIndexMarker322"/> this project with a new empty scene and set it up with the AR Foundation objects: <code>ARFramework</code> using the following steps:</p>
			<ol>
				<li value="1">Create a new scene using <strong class="bold">File | New Scene</strong>.</li>
				<li>Choose the <strong class="bold">Basic (Built-in)</strong> template. Press <strong class="bold">Create</strong>.</li>
				<li>Save the scene using <code>Assets/Scenes/</code> folder, give it the name <code>ARFramework</code>, and then click <strong class="bold">Save</strong>.</li>
			</ol>
			<p>Next, we'll set up the scene with the basic AR Foundation game objects as follows:</p>
			<ol>
				<li value="1">Delete <strong class="bold">Main Camera</strong> from the <strong class="bold">Hierarchy</strong> window by <em class="italic">right-clicking</em> and selecting <strong class="bold">Delete</strong> (or the pressing <em class="italic">Del</em> key on your keyboard). </li>
				<li>Add an AR session by selecting <strong class="bold">GameObject</strong> from the main menu, and then<strong class="bold"> XR | AR Session</strong>.</li>
				<li>Add an <strong class="bold">AR Session Origin</strong> object by selecting <strong class="bold">GameObject</strong> from the main menu, and then <strong class="bold">XR | AR Session Origin</strong>.</li>
				<li>Select the <code>raycast</code>, and then add an <strong class="bold">AR Raycast Manager</strong> component.</li>
				<li>Unfold <strong class="bold">AR Session Origin</strong> and select its child <strong class="bold">AR Camera</strong>. In the <strong class="bold">Inspector</strong> window, use the <strong class="bold">Tag</strong> selector in the upper-left corner to set its tag to <strong class="bold">MainCamera</strong>. (This is not required, but it is a good practice to have one camera in the scene tagged as MainCamera).</li>
				<li>In the <code>audio listener</code>, and add an <strong class="bold">Audio Listener</strong> component to the camera.</li>
			</ol>
			<p>For demo purposes, we'll add an <strong class="bold">AR Plane Manager</strong> component for detecting and tracking horizontal planes. This may change based on the requirements of a specific project:</p>
			<ol>
				<li value="1">With <code>ar plane manager</code>, and then add an <strong class="bold">AR Plane Manager</strong> component.</li>
				<li>Choose an AR plane visualizer prefab and add it to the <code>ARF-samples/Prefabs</code> folder.</li>
			</ol>
			<p>We can also set <a id="_idIndexMarker323"/>up some basic AR light estimation as follows:</p>
			<ol>
				<li value="1">Select <strong class="bold">Main Camera</strong> in the <strong class="bold">Hierarchy</strong> window. On its <strong class="bold">AR Camera Manager</strong> component, set <strong class="bold">Light Estimation</strong> to <strong class="bold">Everything</strong>.</li>
				<li>In the <code>light estimation</code>, and then add a <strong class="bold">Basic Light Estimation</strong> component.</li>
				<li>Drag the <strong class="bold">AR Camera</strong> object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Basic Light Estimation | Camera Manager</strong> slot.</li>
				<li>Save your work using <strong class="bold">File | Save</strong>. </li>
			</ol>
			<p>We now have a scene named <code>ARFramework</code> with a few things set up, including the AR Session, AR Session Origin, AR Camera, and basic light estimation. We can now begin to construct our framework's UI panels.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor086"/>Creating the UI canvas and panels</h1>
			<p>The main<a id="_idIndexMarker324"/> screen <a id="_idIndexMarker325"/>space UI canvas will contain various user interface panels that may be displayed at various times throughout the application. Presently, we'll include the following UI panels.</p>
			<ul>
				<li>The Startup UI panel with any initialization messages</li>
				<li>The Scan UI panel, which prompts the user to scan for trackable features</li>
				<li>The Main UI panel for the main mode that could display the main menu buttons</li>
				<li>The NonAR<a id="_idIndexMarker326"/> UI panel, which could be shown when the device does not <a id="_idIndexMarker327"/>support Augmented Reality</li>
			</ul>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Creating the screen space canvas</h2>
			<p>First, we need<a id="_idIndexMarker328"/> to create a Canvas to contain these panels. Follow these steps:</p>
			<ol>
				<li value="1">From the main menu, select <code>UI Canvas</code>. We can leave the default <strong class="bold">Render Mode</strong> as <strong class="bold">Screen Space – Overlay</strong>. This will also add an <strong class="bold">Event System</strong> game object to the scene if one is not already present.</li>
				<li>By default, the new Canvas is in screen space, and this is what we want here. Some people prefer to change <strong class="bold">Canvas Scaler UI Scale Mode</strong> from <strong class="bold">Constant Pixel Size</strong> to <strong class="bold">Scale With Screen Size</strong>.</li>
				<li>To edit a Screen Space canvas, let's switch the <strong class="bold">Scene</strong> window to a 2D view by clicking the <strong class="bold">2D</strong> button in the <strong class="bold">Scene</strong> window toolbar. Then, double-click the <strong class="bold">UI Canvas</strong> object in the <strong class="bold">Hierarchy</strong> window to focus the <strong class="bold">Scene</strong> view on this object. </li>
				<li>It's also helpful to arrange the <strong class="bold">Game</strong> window and <strong class="bold">Scene</strong> window side by side. Because we're developing for AR, set the <strong class="bold">Game</strong> window's display to a fixed portrait aspect ratio, such as <strong class="bold">2160x1080 Portrait</strong> using the dimension select list in the <strong class="bold">Game</strong> window's top toolbar. </li>
			</ol>
			<p>On this canvas, we will add the separate panels. First, let's add an app title at the top of the screen.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Adding an app title</h2>
			<p>Let's add a <a id="_idIndexMarker329"/>placeholder for an app title as a text panel positioned at the top of the screen. Add the title using the following steps:</p>
			<ol>
				<li value="1"><em class="italic">Right-click</em> on <code>App Title Panel</code>. </li>
				<li>With the <strong class="bold">App Title Panel</strong> object selected, in its <strong class="bold">Inspector</strong> window, open the <strong class="bold">Anchor Presets</strong> menu (found in the upper-left corner of the <strong class="bold">Rect Transform</strong> component), and click the <strong class="bold">Stretch-Top</strong> button. The <strong class="bold">Anchor Presets</strong> menu is shown open in the following screenshot, to the left of the <strong class="bold">Rect Transform</strong> component:<div><img src="img/Figure_4.03-apptitle-anchorpreset.jpg" alt="Figure 4.3 – Anchor Presets menu for App Title Panel set to Top-Stretch&#13;&#10;" width="678" height="423"/></div><p class="figure-caption">Figure 4.3 – Anchor Presets menu for App Title Panel set to Top-Stretch</p></li>
				<li>Then, press <em class="italic">Shift + Alt +</em> <strong class="bold">Stretch-Top</strong> to set its pivot and position.</li>
				<li>Set <code>100</code>.</li>
				<li>Next, <em class="italic">right-click</em> on <code>Title Text</code>.</li>
				<li>In its <code>My AR Project</code>.</li>
				<li>Using the <strong class="bold">Anchor Presets</strong> menu in the upper-left corner of <strong class="bold">Rect Transform</strong>, select <strong class="bold">Stretch-Stretch</strong>. Then, press <em class="italic">Shift + Alt +</em> <strong class="bold">Stretch-Stretch</strong>.</li>
				<li>Set <strong class="bold">Alignment</strong> to <strong class="bold">Center</strong> and <strong class="bold">Middle</strong>.</li>
				<li>You may <a id="_idIndexMarker330"/>also choose to adjust the <strong class="bold">Font Size</strong> and <strong class="bold">Vertex Color</strong> fields as you wish.</li>
			</ol>
			<p>There isn't much to see, but the <strong class="bold">Game</strong> window, along with the title of the app, is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.04-apptitlepanel.jpg" alt="Figure 4.4 – Game window (cropped) with the App Title panel anchored as Top-Stretch&#13;&#10;" width="487" height="100"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Game window (cropped) with the App Title panel anchored as Top-Stretch</p>
			<p>Now that you have experience using the <strong class="bold">Anchor Presets</strong> menu, I'll abbreviate the instructions going forward. Next, we'll add a panel for the start up mode.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor089"/>Creating the UI panels</h2>
			<p>We'll now create <a id="_idIndexMarker331"/>the UI panels for each of the initial interaction modes supported by the framework. Since they are all very similar, we'll create the first one, and then duplicate and modify it for the others.</p>
			<p>The first UI panel, <strong class="bold">Startup UI</strong>, will be a text panel displayed when the app is initializing. Create it using the following steps:</p>
			<ol>
				<li value="1">In the <code>Startup UI</code>.</li>
				<li>We don't need a background image so, in the <strong class="bold">Inspector</strong> window, remove the <strong class="bold">Image</strong> component using the <em class="italic">3-dot context menu</em> <strong class="bold">| Remove Component</strong>.</li>
				<li>Click the <code>canvas group</code>, and add a <strong class="bold">Canvas Group</strong> component to the panel. We're going to use this component to fade panels on and off later in this chapter.</li>
				<li><em class="italic">Right-click</em> the <strong class="bold">Startup UI</strong> object and select <strong class="bold">UI | Text – TextMeshPro</strong>.</li>
				<li>Set <code>Initializing…</code>.</li>
				<li>Using its <strong class="bold">Anchor Presets</strong> menu, select <strong class="bold">Stretch-Stretch</strong>. Then, press <em class="italic">Shift + Alt +</em> <strong class="bold">Stretch-Stretch</strong>.</li>
				<li>Set <strong class="bold">Alignment</strong> to <strong class="bold">Center</strong> and <strong class="bold">Middle.</strong></li>
			</ol>
			<p>Next, we can add a panel that can be displayed if the device we're running on does not support AR. Create this panel as follows:</p>
			<ol>
				<li value="1"><em class="italic">Right-click</em> the <code>NonAR UI</code>.</li>
				<li>Unfold the object and select its child text object. Change the text content to <code>Augmented reality not supported on this device</code>.</li>
			</ol>
			<p>The Scan UI panel will be used to prompt the user to scan the room while the app tries to detect AR features. Create the panel by following these steps:</p>
			<ol>
				<li value="1"><em class="italic">Right-click</em> the <code>Scan UI</code>.</li>
				<li>Unfold the object and select its child text object. Change the text content to <code>Scanning… Please move device slowly</code>.</li>
			</ol>
			<p>Lastly, we'll add a placeholder panel for the main mode UI. This panel could later include, for example, a main menu for the app: </p>
			<ol>
				<li value="1"><em class="italic">Right-click</em> the <code>Main UI</code>.</li>
				<li>Unfold <a id="_idIndexMarker332"/>the object and select its child text object. For development purposes, change the text content to <code>Main Mode Running</code>.</li>
			</ol>
			<p>The current UI Canvas hierarchy is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.05-uicanvas-hier.jpg" alt="Figure 4.5 – UI Canvas hierarchy&#13;&#10;" width="371" height="306"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – UI Canvas hierarchy</p>
			<p>So far, we have created a simple hierarchy of UI panels under a screen space UI Canvas. The panels are acting as a placeholder, for the most part, containing a text element so that you can see which panel is active at runtime. As you build your own apps from this scene, you'll fill in the panels with app-specific UI elements.</p>
			<p>Next, we'll create the UI controller script.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor090"/>Creating the UI controller</h1>
			<p>It will be <a id="_idIndexMarker333"/>convenient to have a script with a small API that makes it easy to switch between UI panels. For the controller scripts in our framework, I've decided to define them as singletons. </p>
			<p>A <code>Instance</code> in the class definition. Learn more at <a href="https://wiki.unity3d.com/index.php/Singleton">https://wiki.unity3d.com/index.php/Singleton</a>.</p>
			<p>Then, we'll write a <code>UIController</code> script that controls the visibility of your UI panels. Lastly, we'll implement some code to fade in and out for a more pleasing user experience when we hide and show the panels.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Creating a Singleton class script</h2>
			<p>We'll begin by<a id="_idIndexMarker335"/> writing a <code>Singleton</code> <a id="_idIndexMarker336"/>class to use (or, if you already have a favorite, feel free to use that <code>Singleton</code> class definition instead). You can find some singleton implementations available as packages in the Unity Asset Store, but all we need is a short script that you can now create as follows:</p>
			<ol>
				<li value="1">In your <code>Scripts/</code> folder by <em class="italic">right-clicking</em> and selecting <code>Singleton</code>.</li>
				<li>Write the script as follows:<pre>using UnityEngine;
///     Singleton behaviour class, used for components         that should only have one instance
/// &lt;/summary&gt;
/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
public class Singleton&lt;T&gt; : MonoBehaviour where T : Singleton&lt;T&gt;
{
    public static T Instance { get; private set; }
    /// &lt;summary&gt;
    ///     Returns whether the instance has been             initialized or not.
    /// &lt;/summary&gt;
    public static bool IsInitialized {
        get { return Instance != null; }
    }
    /// &lt;summary&gt;
    ///     Base awake method that sets the singleton's             unique instance.
    /// &lt;/summary&gt;
    protected virtual void Awake()
    {
        if (Instance != null)
            Debug.LogError($"Trying to instantiate a                 second instance of singleton class                     {GetType().Name}");
        else
            Instance = (T)this;
    }
    protected virtual void OnDestroy()
    {
        if (Instance == this)
            Instance = null;
    }
}</pre></li>
				<li>Save the file.<p class="callout-heading">Info: A singleton as an anti-pattern</p><p class="callout">Note that the singleton pattern can be abused, and some programmers are adamantly opposed to using it, as it can cause problems down the road should your application grow and get more complex. But it's a powerful tool when you are certain that the app will only <a id="_idIndexMarker337"/>ever require one instance of the <a id="_idIndexMarker338"/>class, as will be the case in this interaction framework. One of the main advantages of singletons is that you can then reference the object instance as a static variable on the object class itself. An alternative technique is to find the instance to the component at runtime, for example, by calling <code>FindObjectOfType&lt;T&gt;()</code> from the script's <code>Start()</code> function.  </p></li>
			</ol>
			<p>This script can be used to declare a singleton's <code>MonoBehaviour</code> class, as we'll see next in <code>UIController</code> and other scripts.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor092"/>Writing the UIController script</h2>
			<p>With our <a id="_idIndexMarker339"/>Singleton class in hand, we can now write a UI controller. This component provides a way to switch between UI panels visible to the user. Perform the following steps to write the <code>UIController</code> class:</p>
			<ol>
				<li value="1">Begin by creating a new script in your <code>Scripts/</code> folder by <em class="italic">right-clicking and selecting</em> <code>UIController</code>.</li>
				<li><em class="italic">Double-click</em> the file to open it for editing and replace the default content, starting with the following declarations:<pre>using UnityEngine;
using RotaryHeart.Lib.SerializableDictionary;
[System.Serializable]
public class UIPanelDictionary : SerializableDictionaryBase&lt;string, CanvasGroup&gt; { }
public class UIController : Singleton&lt;UIController&gt;
{
    [SerializeField] UIPanelDictionary uiPanels;
    CanvasGroup currentPanel;</pre><p>At the top, we<a id="_idIndexMarker340"/> declare a serializable dictionary, <code>UIPanelDictionary</code>, using the <code>CanvasGroup</code> component.</p><p>Instead of declaring <code>UIController</code> as a <code>MonoBehaviour</code> class, we declare it a <code>Singleton</code> (which itself derives from <code>MonoBehaviour</code>). Don't worry about the syntax of the declaration, <code>public class UIController : Singleton&lt;UIController&gt;</code>. This is what our <code>Singleton</code> class expects.</p><p>The script declares a <code>uiPanels</code> variable as a <code>UIPanelDictionary</code>. We also declare a <code>currentPanel</code> variable to track which panel is presently active.</p></li>
				<li>Next, add the following functions to the script, which ensure all the UI panels are disabled when the app is started, by iterating through the <code>uiPanels</code> list and calling <code>SetActive(false)</code>:<pre>    void Awake()
    {
        base.Awake();
        ResetAllUI();
    }
    void ResetAllUI()
    {
        foreach (CanvasGroup panel in uiPanels.Values)
        {
            panel.gameObject.SetActive(false);
        }
    }
}</pre><p>Note<a id="_idIndexMarker341"/> that <code>Awake</code> calls <code>base.Awake()</code> because the parent <code>Singleton</code> class also has an <code>Awake</code> that must be called in order for this to work. Then it calls <code>ResetAllUI</code>.</p></li>
				<li>Then, add the following functions to the script:<pre>    public static void ShowUI(string name)
    {
        Instance?._ShowUI(name);
    }
    void _ShowUI(string name)
    {
        CanvasGroup panel;
        if (uiPanels.TryGetValue(name, out panel))
        {
            ChangeUI(uiPanels[name]);
        }
        else
        {
            Debug.LogError("Undefined ui panel " + name);
        }    }
    void ChangeUI(CanvasGroup panel)
    {
        if (panel == currentPanel)
            return;
        if (currentPanel)
            currentPanel.gameObject.SetActive(false);
        currentPanel = panel;
        if (panel)
            panel.gameObject.SetActive(true);
    }</pre><p><code>_ShowUI</code> is an <a id="_idIndexMarker342"/>instance function that, given a panel name, calls <code>ChangeUI</code>. <code>ChangeUI</code> hides the current panel and then activates the required one (note that I'm using an underscore prefix to distinguish private instance functions from the public one). The C# dictionary, <code>TryGetValue</code>, looks up the value for the given key.</p></li>
			</ol>
			<p>The static <code>ShowUI</code> class function simply calls the instance's <code>_ShowUI</code> function. In this way, another script can show a panel by calling <code>UIController.ShowUI(panelname);</code> without requiring a direct reference to the instance. It uses the null-conditional operator (<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-</a>) as a shortcut to make sure the instance is defined before we reference it.</p>
			<p>Now, add the<a id="_idIndexMarker343"/> script as a component on the UI Canvas and set up its properties by performing the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select <strong class="bold">UI Canvas</strong>.</li>
				<li>Drag the <code>UIController</code> script onto <strong class="bold">UI Canvas</strong>, adding it as a component.</li>
				<li>In the <strong class="bold">Inspector</strong> window, on the <strong class="bold">UI Controller</strong> component, unfold the <strong class="bold">UI Panels</strong> dictionary list.</li>
				<li>Click the <strong class="bold">+</strong> button in the bottom-right corner of the UI Panels list.</li>
				<li>In the elements <code>Startup</code>.</li>
				<li>Unfold the element and then, from the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">Startup UI</strong> game object onto the <strong class="bold">Value</strong> slot.</li>
				<li>Repeat steps 4 – 6 three times for each of the following: <code>NonAR</code> : <code>Scan</code> : <code>Main</code> : <strong class="bold">Main UI</strong>.</li>
			</ol>
			<p>The UI Controller component should now look like the following:</p>
			<div><div><img src="img/Figure_4.06-uipanels-insp.jpg" alt="Figure 4.6 – UI Controller component populated with UI panel references&#13;&#10;" width="658" height="303"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – UI Controller component populated with UI panel references</p>
			<p>Thus far, we have created a simple UI for an AR application, organized on one canvas as a set of separate panels. Our plan is to present only one panel at a time to the user, depending on<a id="_idIndexMarker344"/> what the application is doing. We also wrote a <code>UIController</code> script to handle switching between panels.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/>Fading the UI panels</h2>
			<p>An improvement<a id="_idIndexMarker345"/> we can make is to fade the UI in and out while <a id="_idIndexMarker346"/>transitioning instead of abruptly hiding/showing a panel. Presently, we call <code>SetActive</code> to change the panel's visibility. Instead, we can use the panel's <code>CanvasGroup</code> component and animate its Alpha value, and the <code>DOTween</code> library is very handy for this. (You can skip this modification if you do not want to install DOTween). To do this, follow these steps:</p>
			<ol>
				<li value="1">Open the <code>UIController</code> script for editing and add the followin<a id="_idTextAnchor094"/>g declaration at the top of the file:<pre>using DG.Tweening;</pre></li>
				<li>Add these two fader helper <a id="_idTextAnchor095"/>functions at the bottom of the class:<pre>    void FadeIn(CanvasGroup panel)
    {
        panel.gameObject.SetActive(true);
        panel.DOFade(1f, 0.5f);
    }
    void FadeOut(CanvasGroup panel)
    {
        panel.DOFade(0f, 0.5f).OnComplete(() =&gt; panel            gameObject.SetActive(false));
    }</pre></li>
				<li>Then, modify <a id="_idIndexMarker347"/>the <code>ChangeUI</code> function to call the fader helps instead<a id="_idIndexMarker348"/> of <code>SetActive</code>, as shown her<a id="_idTextAnchor096"/>e (the lines in comments are replaced):<pre>    void ChangeUI(CanvasGroup panel)
    {
        if (panel == currentPanel)
            return;
<strong class="bold">        if (currentPanel)</strong>
<strong class="bold">            FadeOut(currentPanel);</strong>
<strong class="bold">            //currentPanel.gameObject.SetActive(false);</strong>
        currentPanel = panel;
<strong class="bold">        if (panel)</strong>
<strong class="bold">            FadeIn(panel);</strong>
<strong class="bold">            //panel.gameObject.SetActive(true);</strong>
    }</pre></li>
			</ol>
			<p>Eventually, when you run the scene, the UI panels will fade in and out when shown and hidden, respectively. </p>
			<p>Next, we will <a id="_idIndexMarker349"/>write <a id="_idIndexMarker350"/>an Interaction Controller that handles the application interaction modes and uses the UI Controller to display the specific UI it needs.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor097"/>Creating an Interaction Controller mode</h1>
			<p>For our user framework, we will make a clever use GameObject with a mode script on it to represent interaction modes. Modes will be enabled (and disabled) by enabling (and disabling) the<a id="_idIndexMarker351"/> corresponding objects. We'll organize these objects in a hierarchy, like the UI panels we created in the previous section, but separated to keep the "controllers" apart from the "views," as prescribed by the controller/view software pattern. Presently, we'll include the following modes:</p>
			<ul>
				<li><strong class="bold">Startup mode</strong>: Active while the AR session is initializing, and then it initiates Scan mode.</li>
				<li><strong class="bold">NonAR mode</strong>: A placeholder should you want your application to run even if the device does not support AR.</li>
				<li><strong class="bold">Scan mode</strong>: This prompts the user to scan for trackable features until the AR session is ready, and then it initiates Main mode. </li>
				<li><strong class="bold">Main mode</strong>: This displays the main menu and handles non-modal interactions.</li>
			</ul>
			<p>First, we'll create the object hierarchy representing each of these modes, under an Interaction Controller game object. With separate GameObjects representing each mode, we'll be able to enable one mode or another separately.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/>Creating the interaction mode hierarchy</h2>
			<p>To <a id="_idIndexMarker352"/>create the interaction mode hierarchy, perform the following steps:</p>
			<ol>
				<li value="1">From the main menu, select <code>Interaction Controller</code>.</li>
				<li><em class="italic">Right-click</em> the <code>Startup Mode</code>.</li>
				<li>Repeat <em class="italic">step 2</em> three more times to create objects named <code>NonAR Mode</code>, <code>Scan Mode</code>, and <code>Main Mode</code>.</li>
			</ol>
			<p>The mode hierarchy game objects now look <a id="_idIndexMarker353"/>like the following:</p>
			<div><div><img src="img/Figure_4.07-internactionmode-hier.jpg" alt="Figure 4.7 – Interaction Controller modes hierarchy&#13;&#10;" width="169" height="86"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Interaction Controller modes hierarchy</p>
			<p>Now we can write and set up the <code>InteractionController</code> script.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor099"/>Writing the Interaction Controller</h2>
			<p>The role of our <a id="_idIndexMarker354"/>Interaction Controller is to manage the top-level user interaction of the application. W<a id="_idTextAnchor100"/>e'll begin by writing the script as follows:</p>
			<ol>
				<li value="1">Create a new script in your <code>Scripts/</code> folder by <em class="italic">right-clicking</em> <code>InteractionController</code>.</li>
				<li><em class="italic">Double-click</em> the file to open it for editing and replace the default content, starting with the following declarations:<pre>using System.Collections;
using UnityEngine;
using RotaryHeart.Lib.SerializableDictionary;
[System.Serializable]
public class InteractionModeDictionary : SerializableDictionaryBase&lt;string, GameObject&gt; { }
public class InteractionController : Singleton&lt;InteractionController&gt;
{
    [SerializeField] InteractionModeDictionary         interactionModes;
    GameObject currentMode;
}</pre><p>At the top, we <a id="_idIndexMarker355"/>declare a serializable dictionary, <code>InteractionModeDictionary</code>, using the <code>InteractionController</code> as a <code>MonoBehaviour</code> class, we declare it a <code>Singleton</code> (which itself derives from <code>MonoBehaviour</code>). </p><p>Then we declare the <code>interactionModes</code> variable as this type of dictionary. We also declare a <code>currentMode</code> variable that tracks the current enabled mode.</p></li>
				<li>Next, add the following functions to the script, which ensures all the modes are disabled when the app is started, by iterating through the <code>interactionModes</code> list by calling <code>SetActive(false)</code>:<pre>    protected override void Awake()
    {
        base.Awake();
        ResetAllModes();
    }
    void ResetAllModes()
    {
        foreach (GameObject mode in interactionModes             Values)
        {
            mode.SetActive(false);
        }
    }</pre><p>Note<a id="_idIndexMarker356"/> that <code>Awake</code> calls <code>base.Awake()</code> because the parent <code>Singleton</code> class also has an <code>Awake</code> that must be called in order for this to work. It then calls <code>ResetAllModes</code>.</p></li>
				<li>Then, add the following functions to the script:<pre>   public static void EnableMode(string name)
    {
        Instance?._EnableMode(name);
    }
    void _EnableMode(string name)
    {
        GameObject modeObject;
        if (interactionModes.TryGetValue(name, out             modeObject))
        {
            StartCoroutine(ChangeMode(modeObject));
        }
        else
        {
            Debug.LogError("undefined mode named " +                name);
        }    }
    IEnumerator ChangeMode(GameObject mode)
    {
        if (mode == currentMode)
            yield break;
        if (currentMode)
        {
            currentMode.SetActive(false);
            yield return null;
        }
        currentMode = mode;
        mode.SetActive(true);
    }</pre><p><code>_EnableMode</code> is an instance function that, given a mode name, calls <code>ChangeMode</code>. <code>ChangeMode</code> disables the current mode and then activates the requested one. </p><p>Note that <code>ChangeMode</code> is <a id="_idIndexMarker357"/>called as a <code>EnableMode</code> class function simply calls the instance's <code>_EnableMode</code> function. In this way, another script can show a panel by calling <code>InteractionController.EnableMode(modename);</code> without requiring a<a id="_idIndexMarker359"/> direct reference to the instance. It uses the null-conditional operator (<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-</a>) as a shortcut to make sure the instance is defined before we reference it.</p></li>
				<li>Lastly, assuming we want the app to start in <code>Startup</code> mode, add the following:<pre>    void Start()
    {
        _EnableMode("Startup");
    }</pre><p>This assumes we will include a <code>"Startup"</code> mode in the <code>interactionModes</code> dictionary.</p></li>
			</ol>
			<p><code>UIController</code> will contain references to each of the app's mode game objects. When the app needs to switch modes, it will call <code>InteractionController.EnableMode(modeName)</code> with the name of the mode. The current mode will be disabled, and the required one will be enabled. </p>
			<p>Add the script as a component on the Interaction Controller game object and set up its properties by following these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Interaction Controller</strong> game object.</li>
				<li>Drag the <code>InteractionController</code> script onto the <strong class="bold">Interaction Controller</strong>, adding it as a component.</li>
				<li>In the <strong class="bold">Inspector</strong> window, on the <strong class="bold">Interaction Controller</strong> component, unfold the <strong class="bold">Interaction Modes</strong> dictionary list.</li>
				<li>Click the <strong class="bold">+</strong> button in the bottom-right corner of the <strong class="bold">Interaction Modes</strong> list.</li>
				<li>On the elements <code>Startup</code>.</li>
				<li>Unfold the element and then, from the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">Startup Mode</strong> game <a id="_idIndexMarker360"/>object onto the <strong class="bold">Value</strong> slot.</li>
				<li>Repeat steps 4 – 6 three times for each of the following: <code>NonAR</code> : <code>Scan</code> : <code>Main</code> : <strong class="bold">Main Mode</strong>.<p>The <strong class="bold">Interaction Controller</strong> component should now look like the following:</p><div><img src="img/Figure_4.08-interactionmode-list-insp.jpg" alt="Figure 4.8 – Interaction Controller component populated with interaction mode object references&#13;&#10;" width="667" height="312"/></div><p class="figure-caption">Figure 4.8 – Interaction Controller component populated with interaction mode object references</p></li>
				<li>The <strong class="bold">Interaction Controller</strong> component will be responding to user input, so we need to add a <strong class="bold">Player Input </strong>component (assuming your project is using the new Input system).<p>With <strong class="bold">Interaction Controller</strong> selected in the <strong class="bold">Hierarchy</strong> window, click <strong class="bold">Add Component</strong> in the <strong class="bold">Inspector</strong> window.</p></li>
				<li>Search for <code>player inp ut</code> and add a <strong class="bold">Player Input</strong> component.</li>
				<li>Locate the <code>Inputs/</code> folder) and drag it to the <strong class="bold">Player Input | Actions</strong> slot. (As noted in the <em class="italic">Technical requirements</em> <a id="_idIndexMarker361"/>earlier in the chapter, I assume you already have this asset as created in <a href="B15145_02_Final_SS_epub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Your First AR Scene</em>).</li>
				<li>Set <strong class="bold">Player Input | Behavior</strong> to <strong class="bold">Broadcast Messages</strong>. <p><em class="italic">THIS IS IMPORTANT!</em> We need to make sure the player actions are forwarded to the child mode objects.</p></li>
			</ol>
			<p>In this section, we have created a hierarchy for interaction modes, organized under one Interaction Controller game object that has a script for enabling/disabling mode objects. Our plan is to allow only one mode to be active at a time. Of course, we still need to write the scripts that control each mode, and handle conditions when it's time to transition from one particular mode to a different one. </p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor101"/>Creating the interaction modes behavior</h1>
			<p>When the app <a id="_idIndexMarker362"/>enables a mode, it will enable the corresponding game object, which has a script that controls the behavior of that mode. When the app changes modes, the current mode object will be disabled, and the new one enabled. Each mode is responsible for the following:</p>
			<ul>
				<li>Displaying its corresponding UI</li>
				<li>Transitioning to a different mode when specific conditions are met</li>
			</ul>
			<p>We will write<a id="_idIndexMarker363"/> mode scripts for each of the modes.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor102"/>The StartupMode script</h2>
			<p>Startup <a id="_idIndexMarker364"/>mode begins when the application <a id="_idIndexMarker365"/>starts (it's enabled from the <code>InteractionController</code> <code>Start()</code> function). It displays the Startup UI panel. Then it waits for the <code>ARSession</code> state to become ready, and transitions to Scan mode. Or, if the <code>ARSession</code> reports that AR is not supported on the current device, it transitions to NonAR mode. </p>
			<p>Follow these steps to create Startup mode:</p>
			<ol>
				<li value="1">Create a new script in your <code>Scripts/</code> folder by <em class="italic">right-clicking</em> and selecting <code>StartupMode</code>.</li>
				<li>Drag the <code>StartupMode</code> script onto the <strong class="bold">Startup Mode</strong> game object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li><em class="italic">Double-click</em> the <code>StartupMode</code> script file to open it for editing and write it as follows:<pre>using UnityEngine;
using UnityEngine.XR.ARFoundation;
public class StartupMode : MonoBehaviour
{
    [SerializeField] string nextMode = "Scan";
    void OnEnable()
    {
        UIController.ShowUI("Startup");
    }
    void Update()
    {
        if (ARSession.state ==            ARSessionState.Unsupported)
        {
            InteractionController.EnableMode("NonAR");
        }
        else if (ARSession.state &gt;= ARSessionState.Ready)
        {
            InteractionController.EnableMode(nextMode);        }
    }
}</pre></li>
			</ol>
			<p>The <a id="_idIndexMarker366"/>script <a id="_idIndexMarker367"/>uses the AR Foundation's <code>ARSession</code> class state variable, <code>ARSession.state</code>, to determine when the session is initialized or whether AR is unsupported. The state is an <code>enum ARSessionState</code> with one of the following values:</p>
			<ul>
				<li><code>None</code>: The session has not yet been initialized.</li>
				<li><code>Unsupported</code>: The device does not support AR.</li>
				<li><code>CheckingAvailability</code>: The session is in the process of checking availability.</li>
				<li><code>NeedsInstall</code>: The device needs to install or update AR support software.</li>
				<li><code>Installing</code>: The device is in the process of installing AR support software.</li>
				<li><code>Ready</code>: The device supports AR and you can enable the <code>ARSession</code> component.</li>
				<li><code>SessionInitializing</code>: The AR session is scanning the environment and trying to detect trackable objects.</li>
				<li><code>SessionTracking</code>: The AR session has found trackable objects and can determine the device's location within the real-world 3D environment.</li>
			</ul>
			<p>When <code>state</code> is <code>Unsupported</code>, we <a id="_idIndexMarker368"/>transition<a id="_idIndexMarker369"/> to NonAR mode.</p>
			<p>When <code>state</code> is <code>Ready</code> (or higher), we transition to Scan mode.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor103"/>The ScanMode script</h2>
			<p>Scan<a id="_idIndexMarker370"/> mode<a id="_idIndexMarker371"/> is enabled when the device is scanning the environment, trying to detect trackable features in the real world. It displays a prompt asking the user to point the camera into the room and slowly move the device. </p>
			<p>The conditions for ending Scan mode may vary depending on the AR application. For example, it may wait until at least one horizontal or vertical plane has been detected, or a reference image has been recognized, or a selfie face is being tracked. Presently, we'll check <code>ARPlaneManager</code> if any trackables have been detected.</p>
			<p>Perform the following steps to create Scan mode:</p>
			<ol>
				<li value="1">Create a new script in your <code>Scripts/</code> folder by <em class="italic">right-clicking</em> and selecting <code>ScanMode</code>.</li>
				<li>Drag the <code>ScanMode</code> script onto the <strong class="bold">Scan Mode</strong> game object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li><em class="italic">Double-click</em> the <code>ScanMode<a id="_idTextAnchor104"/></code> script file to open it for editing and write it as follows:<pre>using UnityEngine;
using UnityEngine.XR.ARFoundation;
public class ScanMode : MonoBehaviour
{
    [SerializeField] ARPlaneManager planeManager;
    void OnEnable()
    {
        UIController.ShowUI("Scan");
    }
    void Update()
    {
        if (planeManager.trackables.count &gt; 0)
        {
            InteractionController.EnableMode("Main");
        }
    }
}</pre></li>
				<li>Drag <a id="_idIndexMarker372"/>the <strong class="bold">AR Session Origin</strong> object <a id="_idIndexMarker373"/>from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Scan Mode | Plane Manager</strong> slot.</li>
			</ol>
			<p>When Scan mode is enabled, the <code>planeManager.trackables.count &gt; 0</code> before switching to Main mode.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor105"/>The MainMode script</h2>
			<p>Main <a id="_idIndexMarker374"/>mode, as<a id="_idIndexMarker375"/> its name implies, is the main operating mode of the application. It may display the main menu, for example, and handle main user interactions. For our default framework, there's not much to do yet apart from display the Main UI panel. </p>
			<p>Perform the following steps to create Main mode:</p>
			<ol>
				<li value="1">Create a new script in your Project's <code>Scripts/</code> folder by <em class="italic">right-clicking</em> and selecting <code>MainMode</code>.</li>
				<li>Drag the <code>MainMode</code> script onto the <strong class="bold">Main Mode</strong> game object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li><em class="italic">Double-click</em> the <code>MainMode</code> script file to open it for editing and write it as follows:<pre>using UnityEngine;
public class MainMode : MonoBehaviour
{
    void OnEnable()
    {
        UIController.ShowUI("Main");
    }
}</pre></li>
			</ol>
			<p>Lastly, we define NonAR mode.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor106"/>The NonARMode script</h2>
			<p>NonAR <a id="_idIndexMarker376"/>mode will be enabled when the device <a id="_idIndexMarker377"/>you're running does not support AR. You might simply notify the user that the app cannot run, and gracefully exit. Alternatively, you may continue to run the app without AR capabilities if that makes sense for your project.</p>
			<p>Perform the following steps to create a NonAR mode placeholder:</p>
			<ol>
				<li value="1">Create a new script in your Project's <code>Scripts/</code> folder by <em class="italic">right-clicking and selecting</em> <code>NonARMode</code>.</li>
				<li>Drag the <code>NonARMode</code> script onto the <strong class="bold">NonAR Mode</strong> game object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li><em class="italic">Double-click</em> the <code>NonARMode</code> script file to open it for editing and write it as follows:<pre>using UnityEngine;
public class NonARMode: MonoBehaviour
{
    void OnEnable()
    {
        UIController.ShowUI("NonAR");
    }
}</pre></li>
			</ol>
			<p>That about does it. We've created a hierarchy with each of the interaction modes as children of <code>InteractionController.EnableMode()</code>, which disables the current mode and activates a new one. When a mode is enabled, its mode script begins running, showing its UI, and<a id="_idIndexMarker378"/> potentially interacting with the user until specific conditions are<a id="_idIndexMarker379"/> met, and then transitions to a different mode. Let's try running the scene on your device.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor107"/>Testing it out</h1>
			<p>Now is a good time to <strong class="bold">Build And Run</strong> the scene to make sure things are working as expected so far. Perform the following steps:</p>
			<ol>
				<li value="1">First, be sure to save your work by using <strong class="bold">File | Save</strong>.</li>
				<li>Select <strong class="bold">File | Build Settings</strong> to open the <strong class="bold">Build Settings</strong> window.</li>
				<li>Click <code>ARFramework</code> scene to <strong class="bold">Scenes In Build</strong>, and ensure it is the only scene in the list with a checkmark.</li>
				<li>Ensure that your target device is plugged into a USB port and that it is ready.</li>
				<li>Click <strong class="bold">Build And Run</strong> to build the project.</li>
			</ol>
			<p>Once the project builds without errors and launches on your device in <strong class="bold">Startup</strong> mode. You'll first see the words <strong class="bold">Initializing…</strong> from the <strong class="bold">Startup</strong> UI panel. </p>
			<p>Once the AR Session is started, the app transitions to Scan mode and you will see the words <strong class="bold">Scanning... Please move device slowly</strong>. </p>
			<p>Once a horizontal plane is being tracked, Scan mode transitions to Main mode. You will then see on the screen the words <strong class="bold">Main Mode Running...</strong>.</p>
			<p>If all goes well, the framework is working as intended. To accomplish this, we have implemented the Canvas UI and child panels for the user interface. We have implemented the Interaction Controller and child mode controllers with scripts that implement the UI and interactions required in each mode. And it's all wired together. This is a basic framework for an AR project that we will use for projects in this book.</p>
			<p>There are many ways in which we can improve and build on this framework. For one, we can make the UI a little more interesting by replacing some of the text prompts with animated graphics from the AR Onboarding UX from Unity.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor108"/>Using the Unity onboarding UX assets</h1>
			<p>Unity provides a <a id="_idIndexMarker380"/>set of AR onboarding UX assets useful for prompting users in <a id="_idIndexMarker381"/>an AR application. <strong class="bold">Onboarding</strong> refers to the user experience when your app starts up and prompts the user to interact with AR features. First, I'll explain some of what this package provides. Then we'll prepare the assets for use in our own projects.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor109"/>Introducing the onboarding assets</h2>
			<p>The onboarding <a id="_idIndexMarker382"/>UX assets are part of the AR Foundation Demos project found at <a href="https://github.com/Unity-Technologies/arfoundation-demos">https://github.com/Unity-Technologies/arfoundation-demos</a>. (This is different from the <em class="italic">AR Foundation Samples</em> project we explored in <a href="B15145_02_Final_SS_epub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Your First AR Scene</em>). And its documentation can be found on that project's GitHub page.</p>
			<p>The onboarding UX assets include icons and video graphics to prompt the user when scanning is required. It automatically tells the user the reasons why tracking may be failing, such as the room is too dark, or the camera view does not see sufficient details. It provides components to manage that process that are composed into an example prefab, named <strong class="bold">ScreenspaceUI</strong>, which can be customized to the look and feel of your own project. </p>
			<p>For example, when the app is scanning, you can use an animated graphic prompt to <em class="italic">Move Device Slowly</em> while scanning the room. If there's a problem, it will display the reason, as shown in the left-side panel of the following image (where I have my finger covering the camera lens). It says <strong class="bold">Look for more textures or details in the area</strong>. If you want to prompt the user to tap the screen to place an object, there's a <strong class="bold">Tap to Place</strong> animated graphic, and so on:</p>
			<div><div><img src="img/Figure_4.09-OnboardingStepsCapture.jpg" alt="Figure 4.9 – Using the onboarding UX assets&#13;&#10;" width="964" height="939"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Using the onboarding UX assets</p>
			<p>Furthermore, the <a id="_idIndexMarker383"/>package supports localization of the text prompts, should your project require multi-language support for various countries. It also includes some good default assets for visualizing AR planes and point clouds that you can use.</p>
			<p>The package includes the following components.</p>
			<ul>
				<li><strong class="bold">ARUX Animation Manager</strong>: This displays instructional graphic animations to prompt the user to find a plane or<a id="_idIndexMarker384"/> tap to place, for example.</li>
				<li><strong class="bold">ARUX Reasons Manager</strong>: This checks the AR Session's status and displays reasons why tracking may be failing as hints to the user.</li>
				<li><strong class="bold">Localization Manager</strong>: This supports localized text and graphics for adapting the instructional and reasons UI to different languages.</li>
				<li><code>UIManager</code> script from the AR Foundation Demos project is a useful control script, but it is only an example of how to interface with the <code>ARUXAnimationManager</code>. Reading the script is informative but not reusable. In our framework, we have implemented our own solution for the user flow that replaces the <code>UIManager</code> script.</p></li>
			</ul>
			<p><strong class="bold">UI Manager</strong> lets you set up one or two goals via the <strong class="bold">Inspector</strong> window. A goal may be <strong class="bold">Found a Plane</strong> or <strong class="bold">Placed an Object</strong>. You then set the instructional UI to prompt the<a id="_idTextAnchor110"/> user to perform the <a id="_idIndexMarker386"/>current activity until its goal has been completed. </p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor111"/>Preparing the Unity AR onboarding assets</h2>
			<p>While the<a id="_idIndexMarker387"/> onboarding UX assets are also available as a package in the Unity Asset Store, I recommend you clone the GitHub project version <a id="_idIndexMarker388"/>because it has more examples and assets, including <strong class="bold">Universal Render Pipeline</strong> (<strong class="bold">URP</strong>) shader-graph shaders. Both versions are full Unity projects, so either way, you will need to open it in a new Unity project and then export the assets into a package that you can import into your own projects.</p>
			<p>We will clone the project and then export the AR Foundation Demos assets into a <code>.unitypackage</code> file that we can import into our own project. I will also provide a copy of this Unity package with the files for this book in the GitHub repository. </p>
			<p>To clone the project and export the folders we want, perform the following steps:</p>
			<ol>
				<li value="1">Clone a copy of the project from GitHub to your local machine. The project can be found at <a href="https://github.com/Unity-Technologies/arfoundation-demos">https://github.com/Unity-Technologies/arfoundation-demos</a>. Please use whatever cloning method you prefer, for example, GitHub Desktop (<a href="https://desktop.github.com/">https://desktop.github.com/</a>) or Command Line (<a href="https://git-scm.com/download/">https://git-scm.com/download/</a>).</li>
				<li>Open the <strong class="bold">Unity Hub</strong> application on your desktop.</li>
				<li>Add the project to <strong class="bold">Unity Hub</strong> by selecting <strong class="bold">Projects | Add</strong>, navigating to the cloned project's root folder, and then press <strong class="bold">Select Folder</strong>.</li>
				<li>In the <strong class="bold">Unity Hub</strong> projects list, if you see a yellow warning icon indicating that the Unity version used by the cloned project is not presently installed on your system, use the <strong class="bold">Unity Version</strong> selection to choose a newer version of the editor that you do have installed (preferably the same major release number). </li>
				<li>Open the <a id="_idIndexMarker389"/>project by selecting it from the <strong class="bold">Unity Hub</strong> projects list.</li>
				<li>We're going to move selected folders into a root folder named <code>ARFoundationDemos</code> that we can export into a package. <p>In Unity, in the <code>ARFoundationDemos</code>. </p></li>
				<li>With your mouse, move the following four folders into this <code>ARFoundationDemos/</code> folder: <strong class="bold">AddressableAssetsData</strong>, <strong class="bold">Common</strong>, <strong class="bold">Shaders</strong>, and <strong class="bold">UX</strong>.</li>
				<li>In the <code>ARFoundationDemos/</code> folder and select <strong class="bold">Export Package</strong>.</li>
				<li>The <strong class="bold">Exporting Package</strong> window will open. Click <strong class="bold">Export</strong>.</li>
				<li>Choose a directory outside of this project's root and name the file (such as <code>ARF-OnboardingUX</code>). Then, click <strong class="bold">Save</strong>.</li>
			</ol>
			<p>Before you close the <code>ARFoundationDemos</code> project, you may want to look in the <strong class="bold">Package Manager</strong> window and note the <strong class="bold">AR Foundation</strong> package version used in the given project, to make sure your own project uses the same or later version of AR Foundation. </p>
			<p>You can close the <code>ARFoundationDemos</code> project now. You now have an asset package you can <a id="_idIndexMarker390"/>use in this and other projects. </p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor112"/>Installing dependency packages</h2>
			<p>The AR<a id="_idIndexMarker391"/> onboarding UX has some dependencies on other Unity packages that you must install in your own project: <em class="italic">Addressables</em> and <em class="italic">Localization</em>. Open your AR project and install them now. </p>
			<p>The Addressable Asset system simplifies loading assets at runtime with a unified scheme. Assets can be loaded from any location with a unique address, whether they reside in your application or on a content delivery network. Assets can be accessed via direct references, traditional asset bundles, or <code>Resource</code> folders. The <strong class="bold">Addressables</strong> package is required by the onboarding UX assets. To learn more, see <a href="mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.16/manual/index.html">https://docs.unity3d.com/Packages/com.unity.addressables@1.16/manual/index.html</a>.</p>
			<p>To import the <strong class="bold">Addressables</strong> package, perform the following steps:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Package Manager</strong> window by using <strong class="bold">Window | Package Manager</strong>. </li>
				<li>Ensure <strong class="bold">Unity Registry</strong> is selected from the <strong class="bold">Packages</strong> filter dropdown in the upper-left corner of the <strong class="bold">Package Manager</strong> window.</li>
				<li>Search for <code>Addressables</code> using the search text input field in the upper-right corner of the <strong class="bold">Package Manager</strong> window.</li>
				<li>Select the <strong class="bold">Addressables</strong> package and click <strong class="bold">Install</strong>.</li>
			</ol>
			<p>The <strong class="bold">Addressables</strong> package is now installed.</p>
			<p>The <strong class="bold">Localization</strong> package translates text strings and other assets into local languages. See <a href="mailto:https://docs.unity3d.com/Packages/com.unity.localization@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.localization@1.0/manual/index.html</a>. To import the <strong class="bold">Localization </strong>package, perform the following steps (these steps may have changed by the time you read this):</p>
			<ol>
				<li value="1">If you have not already done so, enable <strong class="bold">Preview Packages</strong> by navigating to the <strong class="bold">Edit | Project Settings | Package Manager</strong> settings and checking the <strong class="bold">Enable Preview Packages</strong> checkbox. </li>
				<li>Then, in the <strong class="bold">Package Manager</strong> window, use the <strong class="bold">+</strong> button in the top-left corner and select <strong class="bold">Add Package From Git URL</strong>.</li>
				<li>Then, type <code>com.unity.localization</code> to begin installing the package.<p class="callout-heading">Info: Using Preview packages and Git URLs</p><p class="callout">As I write <a id="_idIndexMarker392"/>this, the <strong class="bold">Localization</strong> package is in <em class="italic">preview</em>, that is, not yet fully released by Unity. Also, it is not yet included in the Unity package registry. To enable preview packages, you must click <strong class="bold">Enable Preview Packages</strong> in <strong class="bold">Project Settings</strong>. Also if a package is not included in the built-in Unity registry, you can add a package from a Git URL, from disk, or from a tarball file.  </p></li>
			</ol>
			<p>The <strong class="bold">Localization</strong> package is now installed. We can now install the AR onboarding UX assets themselves.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor113"/>Importing the OnboardingUX package</h2>
			<p>We saved<a id="_idIndexMarker393"/> the assets<a id="_idIndexMarker394"/> exported from the AR Foundation Demos project into a file named <code>OnboardingUX.unitypackage</code>. Importing the package is straightforward. Follow these steps to add it to your project. Back in your own Unity project, do the following:</p>
			<ol>
				<li value="1">Select <code>OnboardingUX.unitypackage</code> file from your Explorer or Finder directly into the Unity <strong class="bold">Project</strong> window. </li>
				<li>In the <strong class="bold">Import Unity Package</strong> window, click <strong class="bold">Import</strong>.</li>
				<li>The assets include materials that use the built-in render pipeline. Since our project is using the URP, you need to convert the materials by selecting <code>ARFoundationDemos/Common/Materials/</code> folder and, in the <strong class="bold">Inspector</strong> window, change its <strong class="bold">Shader</strong>, using the drop-down menu, to <strong class="bold">ShaderGraphs/BlurredShadowPlane</strong>. </p></li>
			</ol>
			<p>The onboarding UX assets are now imported into your project. We can now add it to our framework scene.</p>
			<p>Currently, our <a id="_idIndexMarker395"/>app renders a UI<a id="_idIndexMarker396"/> panel with text to prompt the user to scan the environment. This panel is a game object that is enabled when needed. Basically, we want to replace the panel text with animated graphics. </p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor114"/>Writing the AnimatedPrompt script</h2>
			<p>Let's <a id="_idIndexMarker397"/>start by writing a new<a id="_idIndexMarker398"/> script, <code>AnimatedPrompt</code>, that displays a specific animation when it is enabled and hides the animation when disabled: </p>
			<ol>
				<li value="1">Create a new script in your <code>Scripts/</code> folder by <em class="italic">right-clicking and selecting</em> <code>AnimatedPrompt</code>.</li>
				<li><em class="italic">Double-click</em> the file to open it for editing and replace the default content, starting with the following declarations:<pre>using UnityEngine;
public class AnimatedPrompt : MonoBehaviour
{
    public enum InstructionUI
    {
        CrossPlatformFindAPlane,
        FindAFace,
        FindABody,
        FindAnImage,
        FindAnObject,
        ARKitCoachingOverlay,
        TapToPlace,
        None
    };
    [SerializeField] InstructionUI instruction;
    [SerializeField] ARUXAnimationManager         animationManager;
    bool isStarted;</pre><p>In this<a id="_idIndexMarker399"/> script, we <a id="_idIndexMarker400"/>declare a public property, <code>instruction</code>, whose value is an <code>enum InstructionUI</code> type that indicates which animation to play (borrowed from the <code>UIManager</code> script from the onboarding assets, to be consistent).</p></li>
				<li>When the script is started or enabled, it will initiate the animated graphics. Inversely, when the object is disabled, the graphics are turned off:<pre>    void Start()
    {
        ShowInstructions();
        isStarted = true;
    }
    void OnEnable()
    {
        if (isStarted)
            ShowInstructions();
    }
    void OnDisable()
    {
        animationManager.FadeOffCurrentUI();
    }</pre><p>I've added <a id="_idIndexMarker401"/>a <a id="_idIndexMarker402"/>fix to ensure the animation does not restart when both <code>Start</code> and <code>OnEnable</code> are called at the start.</p></li>
				<li>When the script is enabled, it calls the helper function, <code>ShowInstructions</code>, which calls a corresponding function in <code>ARUXAnimationManager</code>:<pre>    void ShowInstructions()
    {
        switch (instruction)
        {
            case InstructionUI.CrossPlatformFindAPlane:
                animationManager.                   ShowCrossPlatformFindAPlane();
                break;
            case InstructionUI.FindAFace:
                animationManager.ShowFindFace();
                break;
            case InstructionUI.FindABody:
                animationManager.ShowFindBody();
                break;
            case InstructionUI.FindAnImage:
                animationManager.ShowFindImage();
                break;
            case InstructionUI.FindAnObject:
                animationManager.ShowFindObject();
                break;
            case InstructionUI.TapToPlace:
                animationManager.ShowTapToPlace();
                break;
            default:
                Debug.LogError("instruction switch                 missing, please edit AnimatedPrompt.cs "                + instruction);
                break;
        }
    }
}}</pre></li>
			</ol>
			<p>Now we can add this to our scene.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor115"/>Integrating the onboarding graphics</h2>
			<p>To integrate<a id="_idIndexMarker403"/> the onboarding <a id="_idIndexMarker404"/>graphics, we can add the demo prefab (unfortunately named <code>ScreenspaceUI</code>) from the AR Foundation Demos package. Follow these steps:</p>
			<ol>
				<li value="1">In the <code>ARFoundationDemos/UX/Prefabs/</code> folder and drag the <strong class="bold">ScreenspaceUI</strong> prefab into the <strong class="bold">Hierarchy</strong> window root of the scene.</li>
				<li>Give it a more indicative name; rename the object <code>OnboardingUX</code>. </li>
				<li>Our framework replaces the demo <strong class="bold">UI Manager</strong> component, so you should remove this. <p>With the <strong class="bold">OnboardingUX</strong> object selected in <strong class="bold">Hierarchy</strong>, click the <em class="italic">3-dot context menu</em> in the top-right corner of the <strong class="bold">UI Manager</strong> component in the <strong class="bold">Inspector</strong> window and select <strong class="bold">Remove Component</strong>.</p></li>
			</ol>
			<p>We can now use <code>AnimatedPrompt</code> to replace the text in our UI prompt panels. To use it, perform the following steps:</p>
			<ol>
				<li value="1">In the <code>Animated Prompt</code>.</li>
				<li>With the <code>AnimatedPrompt</code> script from the <strong class="bold">Project</strong> window onto the object.</li>
				<li>Set the <strong class="bold">Animated Prompt | Instruction</strong> to <strong class="bold">Cross-Platform Find A Plane.</strong></li>
				<li>From the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">OnboardingUX</strong> object into the <strong class="bold">Inspector</strong> window and drop it on to the <strong class="bold">Animation Manager</strong> slot.</li>
				<li>You can disable the <strong class="bold">Text (TMP)</strong> child element of <strong class="bold">Scan Prompt Panel</strong> so that it won't be rendered.</li>
			</ol>
			<p>If you <strong class="bold">Build And Run</strong> the project again, when it enters Scan mode, you will be greeted with nice, animated graphics instead of the text prompt. </p>
			<p>With a<a id="_idIndexMarker405"/> working AR us<a id="_idTextAnchor116"/>er <a id="_idIndexMarker406"/>framework, let's make this scene into a template that we can use when creating new scenes.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor117"/>Creating a scene template for new scenes</h1>
			<p>We can<a id="_idIndexMarker407"/> save this <strong class="bold">ARFramework</strong> scene we've been working on as a template to use for starting new scenes in this Unity project. To create a scene template, perform the following steps.</p>
			<ol>
				<li value="1">With the <strong class="bold">ARFramework</strong> scene open, select <strong class="bold">File | Save As Scene Template</strong>.</li>
				<li>In the <code>Scenes/</code> folder, verify the template name (<code>ARFramework.scenetemplate</code>), and then press <strong class="bold">Save</strong>.</li>
				<li>Subsequently, when you want to start a new AR scene, use this template. By default, Unity will duplicate any dependencies within the scene into a separate folder. In our case, this is generally <em class="italic">not</em> what we want to do.<p>To prevent cloning the scene dependencies when the template is used, click on this new scene template file in your <code>Assets/</code> window.</p></li>
				<li>In its <code>ARFramework</code>. Just remember to check the <strong class="bold">Dependencies</strong> list in the template if you've added any new assets to the scene as these will default to be cloned.</p></li>
			</ol>
			<p>To use the template when creating a new scene in this project, use <strong class="bold">File | New Scene</strong> as usual. The dialog box will now contain the <strong class="bold">ARFramework</strong> template as an option. Select the location in your assets folder and press <strong class="bold">Create</strong>. If the template specifies any assets to be<a id="_idIndexMarker408"/> cloned, those copies will be added to a subfolder with the same name as the new scene.</p>
			<p>We are now ready to build upon the work we did in this chapter, using the <strong class="bold">ARFramework</strong> template for new project scenes.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor118"/>Summary</h1>
			<p>In this chapter, we developed a framework for building AR applications and saved it as a template we can use for projects in this book. The framework provides a state-machine structure for implementing modes and identifying the conditions when to transition to a different mode. The framework also offers a controller-view design pattern where, when a mode is active, its corresponding UI is visible, keeping the mode control objects separate from the UI view objects. </p>
			<p>For the framework template, we implemented four modes: Startup mode, Scan mode, Main mode, and NonAR mode, along with four UI panels: Startup UI, Scan UI, Main UI, and NonAR UI. Scan mode uses the onboarding UX assets from the AR Foundation Demos project to prompt the user to scan for trackable features and report problems with detection and the AR session. </p>
			<p>In the next chapter, I will demonstrate the use of this framework with a simple demo project and then build upon the framework more extensively in subsequent chapters. </p>
		</div>
	</div></body></html>