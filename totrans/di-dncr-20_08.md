# 模式 - 依赖注入

在[第7章](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml)中，*拦截*，我们完成了探索**依赖注入**（**DI**）支柱的旅程。现在，是时候学习依赖注入背后的原则，并探索如何应用不同的技术来实现这些原则，以获得松散耦合的架构。有各种技术可以实现DI，但如果你在编码时没有选择合适的技术，你将成为项目的麻烦制造者。

在本章中，我们将讨论不同的技术，也称为**依赖注入模式**，并附上适当的说明。我将阐明用例、优点和缺点，以便您能够轻松地可视化您当前在应用程序中看到的问题。这将最终说服您在应用程序中采用这些模式，从而实现更好的架构。

构造函数注入是所有这些模式中最重要的一个。然而，作为开发者，我们应该理解每个可用的模式。始终建议通过分析依赖的使用频率和情况来为特定场景选择最佳匹配的模式。

虽然这些模式中的大多数都针对某些特定上下文，但请始终记住构造函数注入是最简单的，并且可以在没有任何混淆的情况下选择使用。

本章将涵盖以下主题：

+   依赖倒置原则

+   控制反转

+   DI模式

+   实现模式的正确方式

+   每个模式的优缺点

+   .NET Core 2.0中的采用和示例

# 依赖倒置原则

SOLID原则中有一个D，称为**依赖倒置原则**（**DIP**）。以下是对DIP的描述，由Robert C. Martin提供：

“高级模块不应依赖于低级模块。两者都应依赖于抽象。”

你可以将高级模块视为一个应用程序的业务模块，它包含应用程序的复杂逻辑，而低级模块则是实际执行基本或主要功能的类，例如将数据写入磁盘、与数据库交互等，这些操作由业务模块接收的命令执行。

当高级模块的对象与低级模块的对象交互时，它们会产生耦合。这是因为你必须引用低级模块的类才能访问它们以进行实例化。然而，DIP并不推荐这样做。该原则鼓励我们减少耦合，使模块能够独立生活。它还解释了如何通过抽象来实现这一点。两者都应该致力于抽象，而不是直接相互依赖。让我们用一个例子来理解这个观点。

考虑一个名为`FeedbackService`的类，它将一个`Feedback`详情保存到数据库中：

[PRE0]

这里的主要方法是 `SaveFeedback`，它不仅保存反馈，还发送通知。它接受 `Feedback` 对象和通知类型作为参数。当保存反馈时，通常向客户和管理员发送一条通知。

`FeedbackService` 实现了一个接口，其代码可以如下编写：

[PRE1]

`INotifier` 是一个接口，所有通知类型都实现了这个接口。看看下面的代码：

[PRE2]

注意，我没有定义方法的主体，因为它们在这里是为了说明。你可以编写逻辑并实现自己的代码。

# 问题

这种方法看起来是正确的，但不推荐，并且不尊重以下描述的软件设计原则：

显然，我们正在违反单一职责原则。`FeedbackService` 不仅负责保存反馈，还在成功后发送通知。

与具体的类 `Feedback` 以及其他 `Notifier` 类如 `EmailNotifier`、`SmsNotifier` 和 `VoiceNotifier` 存在紧密耦合。

我们最常用的 `new` 关键字在 `FeedbackService` 类的 `SendNotification` 方法中使用，根据输入的 `notify` 类型的 `enum` 来决定创建哪个 `Notifier` 实例，它可以定义如下：

[PRE3]

# 解决方案

解决方案应该解决前面方法的所有问题，从而使最终的架构变得松耦合。让我们开始吧。

第一件事是将 `FeedbackService` 类的责任分离出来。这可以通过将 `SendNotification` 责任转移到通知者而不是在类内部完成。

因此，我们可以在构造函数中注入 `INotifier` 类型的依赖。这样，我们就可以通过 `_notifier.SendNotification()` 发送注入的类型通知。我们还改变了 `SaveFeedback` 的签名，现在它接受 `IFeedback` 类型的参数。

`FeedbackService` 可以重写如下：

[PRE4]

现在 `Service` 不依赖于具体的实现，并且我们从类中消除了决定发送哪种通知的 `if...else...if` 繁琐代码。通知类型的决定现在由 `Service` 类实例的创建者来决定。这可以在组合根（Composition Root）内部完成，如下所示：

[PRE5]

# 控制反转（IoC）

**控制反转**（**IoC**）是一种支持 **依赖倒置原则**（**DIP**）的软件设计模式。这两个术语之间有很多混淆，但如果你仔细观察，名称本身就能澄清疑惑。

DIP 是一种原则或规则集合的理论。另一方面，控制反转是一种定义良好的步骤模式，我们可以遵循它来使我们的代码符合 DIP。你已经体验过 IoC 的步骤，不是吗？

注意我们采取的步骤，将 `FeedbackService` 类的对象创建控制权从外部位置移除，这可以被视为组合根。我们做了以下具体操作：

1.  介绍具体依赖项的接口：`INotifier` 和 `IFeedback`。

1.  将具体依赖项更新为从接口实现：`EmailNotifier`、`SmsNotifier` 和 `VoiceNotifier`。

1.  将依赖项提供给构造函数并存储在 `private readonly` 成员中：

[PRE6]

1.  通过私有成员，我们可以直接调用依赖类的方法：`_notifier.SendNotification(feedback);`

1.  在组合根中实例化 `Service` 并包含依赖项：

    `var feedbackService = new FeedbackService(new SmsNotifier());`。

因此，现在有人正在尝试管理对象创建和生命周期。在我们执行这些步骤之前，该类本身使用 `new` 关键字在其内部实例化所有依赖项。因此，我们反转了控制权，对象的管理流程是通过其他人反向进行的，不是吗！就是这样，这正是 IoC（控制反转）试图表达的内容。

最后一步是将依赖对象注入到 `Service` 的构造函数中，这种模式被称为 **构造函数注入模式**。让我们在下一节中探讨这个模式以及其他重要模式。

下图表示了依赖倒置原则（DIP）和非依赖倒置原则（non-DIP）的实现。注意箭头。在非DIP中，依赖项由类本身管理，因此箭头指向具体类对象，而在DIP中，箭头指向类，因为依赖对象是由其他人发送的：

![](img/c6784d17-712d-41e5-a556-ff8a8142d1a6.png)

当一个类自己管理所有依赖项时，它被视为 **控制狂**，这是一种反模式。我们将在下一章中讨论更多关于这种反模式的内容。

# 模式

以下是我们可以通过实现依赖注入的四个重要模式：

+   构造函数注入模式

+   属性注入模式

+   方法注入模式

+   环境上下文

让我们逐一通过插图、优点和缺点来探讨。

# 构造函数注入模式

如其名所示，注入将借助构造函数。换句话说，构造函数是注入的目标。注入是通过将依赖项作为参数提供给构造函数来执行的。这是将依赖项注入到类中最常见的技巧。

客户端调用构造函数来创建对象，在实例化过程中，依赖项被注入，如下所示：

![](img/923d38e0-dcca-4797-a364-e90566508b8b.png)

例如，一家公司最初只设立了一个名为工程部的部门。让我们为这家公司设计以下 `Employee` 类：

[PRE7]

我们有一个构造函数，它接受 `id` 和 `name` 作为参数，并初始化一个 `Employee` 对象。正如我之前所说的，公司最初只有工程部门，所以很明显，我们将 `EmployeeDept` 赋值为 `Engineering` 类的新对象。`Engineering` 和 `Department` 类可能看起来如下所示：

[PRE8]

# 问题

您能预见这个设计中可能存在的复杂问题吗？如果公司扩大并建立了另一个部门，比如营销部门，我们将如何将这个新部门纳入 `Employee` 类中？如何表示某个员工属于营销部门？

不幸的是，在这里没有方法可以做到这一点，因为 `Employee` 类与 `Engineering` 类紧密耦合。这不仅会导致设计不良，而且开发者也会在单元测试中遇到障碍。

# 解决方案

那么，解决方案是什么？当我们用 `Employee` 实例化时，我们只需要一个 `Department` 对象。我们是否可以直接向 `Employee` 类提供所需的 `Department` 类型（工程/营销）引用呢？

这非常简单。让我们看看修改后的代码。

1.  首先，设计一个接口 `IDepartment`，该接口可以被 `Department` 类实现：

[PRE9]

1.  我们不再拥有 `Department` 类型的属性，现在我们将拥有 `IDepartment` 类型的属性。基本上，我们可以通过这种技术允许不同的部门类型。我们很快就会看到这个技术的实际应用。同时，您也可以看到这个属性是如何在构造函数中使用 `IDepartment` 类型的 `dept` 参数进行初始化的。

[PRE10]

1.  现在让我们看看不同部门的类。它们从 `Department` 继承，从而实现了 `IDepartment`：

[PRE11]

1.  现在创建不同部门的员工变得容易了。如果我们将在 `main` 方法内部创建这样的对象，我们可以做以下操作：

[PRE12]

您可以看到一个特定的 `Department` 对象是如何传递给 `Employee` 构造函数以创建属于不同部门的员工。这就是我们进行的注入。我们将 `IDepartment` 类型的对象（`Engineering` 和 `Marketing`）注入到 `Employee` 构造函数中。

以下为输出结果：

![图片](img/192956cf-7f83-4a52-95ee-0a24461d5e0d.png)

# 曲线球

您可能认为前面的内容都是完美的。但事实并非如此。让我们来分析一下：

[PRE13]

您可以看到我创建了一个部门为 `Engineering` 的对象。然后在下一行，我们可以轻松地通过将 `Marketing` 对象赋值给它来更改部门。这应该完全避免。

为了做到这一点，该字段必须被标记为 `private` 和 `readonly`。

[PRE14]

虽然这并不是严格推荐的，但我们确实应该遵循这一点，以便开发者不能无端地篡改实际值。

其次，构造函数没有处理依赖实例作为 `null` 接收的情况。构造函数可以被修改如下：

[PRE15]

现在重要的是，构造函数不仅负责将依赖实例推送到一个 `private` 属性，还向其他成员变量（如 `EmployeeId` 和 `EmployeeName`）插入值。这违反了单一职责原则。因此，我们应该让构造函数只处理依赖项，而无需做其他事情：

[PRE16]

此外，以这种方式编写可以保证当创建一个对象时，它将包含其中的依赖项。同时，这只有在类从此以后完全依赖于依赖项的情况下才有价值。

让我快速总结以下要点：

+   依赖的类必须公开一个 `public` 构造函数，以便注入依赖项

+   如果需要多个依赖项，则可以向构造函数添加更多参数

+   依赖类应将成员变量标记为 `private readonly`，其中将分配依赖实例

+   依赖类构造函数应仅执行管理依赖项的工作，而无需做其他事情

# 使用 .NET Core 2.0 注入

我们之前看到了每个示例，都是使用 `new` 关键字进行初始化。然而，我们应该使用 .NET Core 2.0 的方式来解决依赖项：

[PRE17]

我们使用 `ServiceCollection` 对象来注册在解析时我们期望的类型接口。当我们执行 `serviceProvider.GetService();` 时，它返回一个部门为 `Engineering` 的员工对象，因为我们已在集合中将 `IDepartment` 注册为 `Engineering`。

# ASP.NET Core 2.0 内部的实现

让我们更仔细地看看位于 `Microsoft.AspNetCore.Mvc.Core` `Controllers` 中的 `ControllerActivatorProvider.cs` 的 ASP.NET Core 2.0 内部代码，以了解构造函数注入是如何实现的。

# ControllerActivatorProvider.cs

我将展示一个包含构造函数的类的截图：

![](img/91b877ef-c090-4344-a6c7-592199f1c23f.png)

`IControllerActivator` 是注入到这个类构造函数中的依赖项。然后，它使用这个实例在类内部执行一些操作。我们可以在 .NET Core 2.0 中轻松找到更多这样的例子。

要查看这种依赖是如何解决的，我们可以检查位于 `Microsoft.AspNetCore.Mvc.Core` `DependencyInjection` 中的 `MvcCoreServiceCollectionExtensions.cs` 类的 `AddMvcCoreServices` 方法：

![](img/84f0c2b9-30ec-40f1-8bbc-5edd42b9bdd4.png)

# 构造函数注入模式的重要性

由于注入与构造函数相关联，这意味着每次尝试实例化特定类时，我们都能100%确信依赖项被包含或与创建的对象绑定。通过 Guard Clause 确保依赖项不是 `null` 并将其分配给 `private readonly` 数据成员，从而确保了拥有依赖项的保证。否则，类的构造函数将抛出异常。

没有可能不注入依赖就拥有此类的一个对象。因此，对象的状态始终有效，没有差异。使用模拟进行单元测试变得容易。让我们也看看其优缺点。

# 构造函数注入模式的优势

这是尊重DI概念的最受欢迎的方式。大多数DI容器都针对构造函数。它也是DI最常见和更广泛使用的模式。注入的组件可以在类的任何地方使用，因为当你创建对象时，注入的依赖项会自动进入类并保存在某个变量中。

当类需要一些外部依赖来启动所有其他操作时，开发者更喜欢这种技术。由于构造函数涉及其中，一旦实例化，对象就准备好了依赖对象。

# 属性注入模式的不利之处

当类包含许多构造函数时，这并不容易实现。此外，当类的依赖项数量增加时，每次更新构造函数都不是一项可行的任务。

当构造函数有多个参数时，通过添加依赖项与现有参数一起，类看起来会很混乱。

# 属性注入模式

在这种技术中，我们不会要求构造函数支持注入，而是直接将依赖注入到类的属性中。让我们开始吧。

以下图表描述了一个属性`EmployeeDept`，它可以直接注入`IDepartment`实现：

![](img/f37e69e5-b4e1-40e3-8395-a2b7c24b106b.png)

没有构造函数参数`IDepartment`和新的设置属性`Employee`类看起来如下所示：

[PRE18]

我们刚刚从构造函数中移除了`IDepartment`参数，因为我们打算直接将一个`IDepartment`类型的对象分配给属性`EmployeeDept`。这可以在创建`Employee`对象时完成，如下所示：

[PRE19]

因此，通过执行`emp.EmployeeDept = new Engineering();`，我们直接将`Engineering`对象推入属性`EmployeeDept`。对于`emp1`也执行了同样的操作。

然而，这段代码无法编译。我们遗漏了一些重要的东西。考虑以下截图：

![](img/dbb64f95-24c4-4dc0-bb7b-b52175be846e.png)

错误完全自解释。我们忘记包含获取器块，因为我们想打印部门名称。考虑以下代码片段：

[PRE20]

现在，我们做得很好。当你运行它时，你会看到与构造函数注入案例中相同的输出。

当类需要可选依赖项时，首选属性注入。这意味着，如果你不提供值，类不会介意，因为它可以在没有此依赖项的情况下运行。如果开发者忘记分配依赖项，它不应影响应用程序的流程。

例如，在我们的例子中，如果您不对属性`EmployeeDept`做任何操作，只要您不读取该属性，类将像往常一样表现。在下一节中，我将告诉您如何美化代码，因为代码还没有完美。

# 曲球

我们采取的方法存在的问题可以是以下任何一个：

+   如果您没有为属性分配任何内容（就像我们开发者有时因为懒惰而忘记做的那样），当您打印时，输出不会返回任何内容。

+   您可以像这样简单地分配`null`给属性：`emp.EmployeeDept = null;`。

+   一旦您将依赖项分配给属性，您就可以轻松地分配另一个依赖项，这可能会成为一个问题。这可能会意外发生，然而，它将在某个时间点对整个系统产生副作用。想象一下这种情况：您用工程初始化了属性，然后将其更改为营销，这是错误的。

为了处理所有这些情况，我们应该为属性引入更多的保护。让我们这样做：

[PRE21]

在设置器内部，我们检查`null`并抛出异常。然后，我们再次调查它是否已经存在，并抛出`InvalidOperationException`。同样，在获取器中，当传入`null`时，我们将其分配为默认值作为工程。因此，我们保护了我们的属性以应对所有这些困难的情况，如前所述。

属性注入不是.NET Core内置的DI或IoC容器默认支持的。目前也没有计划将其引入默认容器。您必须使用外部容器，例如Autofac，来支持此功能。

# 属性注入模式的优势

我们可以看到以下拥有设置器注入模式的优点：

+   它不需要添加新的构造函数或修改现有的构造函数。

+   如果类有多个不同类型的依赖项，这个模式就派上用场了。假设有一个类，它将在不同条件下同时使用不同类型的日志记录，例如日志记录到文本或数据库，那么拥有两个设置器属性，我们可以简单地注入所需的记录器来完成我们的任务。

# 属性注入模式的缺点

在特定设计中识别设置器以注入外部依赖项并不容易。尽管如此，在某些情况下它们仍然被优先考虑。然而，在使用注入的属性时我们应该小心，因为那可能为`null`。在您想要使用它的任何地方都应该进行额外的`null`检查。正如我们之前讨论的，必须为属性提供保护以避免不一致的行为。

属性注入在大多数情况下被认为是不良实践，因为它隐藏了依赖关系。当类被实例化时，没有保证依赖对象将可用于类执行任何操作，这与构造函数注入不同，在实例化过程中依赖项本身就会找到路径。

# 方法注入模式

正如其名所示，我们将像在构造函数的情况中那样将依赖项注入到一个方法中。当我们想在类的不同方法中使用不同类型的依赖项时，这会非常有用。

看以下图表，它告诉我们 `Employee` 类中的 `AssignDepartment(IDepartment)` 方法如何作为依赖项使用：

>![](img/c4d5974f-df2b-4a27-b678-d84fa27f333f.png)

客户端可以创建 `Employee` 类的一个对象，然后使用适当的 `IDepartment` 实现调用 `AssignDepartment`，从而提供依赖项。

让我们看看如何编码 `Employee` 类：

[PRE22]

在这个特定场景中，有一个 `AssignDepartment` 方法，它接受一个 `IDepartment` 类型的参数，并将其分配给属性。可以相应地创建一个 `Employee` 对象。考虑以下代码片段：

[PRE23]

它也产生了我们之前已经看到的相同输出。

这种模式在需要某些依赖项仅用于方法中的某些特定操作，而不是整个类时非常有用。有时，情况需要一个小改动，可能是一个边缘情况。为了适应这个小改动，最简单的方法是创建一个方法，并在其中做任何你想做的事情（使用作为参数传递的依赖项），而不是触摸构造函数或属性。

# Curveball

在方法注入的情况下，按照惯例，我们也应该注意空值检查，以确保在使用之前依赖项可用：

[PRE24]

# 使用 .NET Core 2.0 注入

如我们在之前的模式中所做的那样，我们将使用 `GetService` 方法获取实例，然后通过注入依赖项调用所需的方法：

[PRE25]

你接下来会看到以下输出：

![](img/055312b3-271d-43f1-8df4-7710be1f7737.png)

这是因为我们有一个接受 `integer` 和 `string` 参数的构造函数。提供者不知道如何解析它们的过程，因此抛出异常。解决方案是提供一个默认构造函数，因为服务提供者正在寻找它。

[PRE26]

# .NET Core 2.0 中的实现

在 .NET Core 2.0 中，我们可以找到许多方法注入模式的使用实例。其中之一是在最简单且最常用的类 `MvcServiceCollectionExtensions.cs` 中。

# MvcServiceCollectionExtensions.cs

`MvcServiceCollectionExtensions.cs` 类包含 `AddMvcCore` 方法，这是一个方法注入的例子。以下截图展示了该方法的概览：

![](img/9ee3d342-6b6d-4060-8b90-980db41fb1f6.png)

`IServiceCollection` 被注入到 `AddMvcCore` 方法中。在它被验证为非 `null` 之后，服务集合会被进一步处理。我仅展示相关代码的截图以理解该概念。你肯定可以在其他类中找到这样的例子。

**接口注入模式**是我们已经在其他模式中讨论过的一种模式，其中我们将实现（如 `IDepartment`，它是一个接口）注入到构造函数、属性或方法中。建议注入实现而不是具体类，以避免紧密耦合。接口注入使我们能够实现解耦和抽象。

# Ambient 上下文

Ambient 是一个形容词，意为完全围绕或包含。这意味着当我们说 Ambient 上下文时，它表示某种上下文，这将涉及其在背景或周围的存在和行为。

当许多类需要相同的依赖项时，我们应该遵循一些技术来使其对每个此类客户端可用。

我们讨论的模式不适用于这种场景。例如，如果你尝试使用构造函数注入来实现这一点，你最终将为每个类添加一个构造函数，并将相同的依赖项注入其中。

这听起来更像是一个横切关注点，不是吗？为了实现这一点，我们可以简单地为依赖项添加一个静态访问器。这将确保依赖项对所有要求它的客户端都是可访问的。

这个概念可以在以下图中可视化：

![](img/e94dcddc-982d-4c55-8bbb-3f7a0f95a6ff.png)

让我们通过一个例子来更好地理解实现方式。可以设计一个抽象类 `DepartmentProvider`，以提供名为 `Current` 的静态访问器：

[PRE27]

我们将类标记为 `abstract`，并且有一个名为 `Department` 的 `virtual` 属性，它将被任何需要它的类访问。

让我们看看如何使用 `Current` 属性。以下代码使用了 `MarketingProvider` 类的实例，它是 `DepartmentProvider` 的派生类：

[PRE28]

看看我们如何使用内置的 DI 容器注册 `MarketingProvider`。然后我们将它分配给 `Current` 属性，通过这个属性，我们能够在读取 `DepartmentProvider.Current.Department` 时获取到营销值。`MarketingProvider` 是 `DepartmentProvider` 的子类，它返回一个 `Marketing` 对象。请参考以下代码：

[PRE29]

因此，我们得出结论。我们可以在应用程序内部需要的地方使用 `static` 属性，除非你在其中设置了不同的值，否则值将是相同的。

# 曲球

在实现 Ambient Context 时，以下是一些重要要点需要记住：

+   这应该只在真正必要时使用。在决定使用 Ambient Context 之前，构造函数注入或属性注入应该是首选。如果你无法决定，就选择其他 DI 模式。

+   服务定位器反模式在提供依赖的方式上与这个模式非常相似。然而，有一个区别，那就是环境上下文提供单个依赖项，而服务定位器负责提供所有请求的依赖项。我们将在第 9 章 [Anti-Patterns and Misconceptions on Dependency Injection](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml) 中进一步讨论服务定位器。

+   如果你没有正确实现环境上下文，它将会有副作用。假设你开始使用一个上下文或提供者，在过程中由于某些原因更改了它。现在，当你读取值时，由于静态特性，它将提供更改后的值而不是第一个值。这意味着你在实现时需要非常小心。

+   通过我们讨论的实现，你可以轻松地将 `null` 设置到 `Current` 属性 `DepartmentProvider.Current = null;`。因此，我们必须通过使用守卫子句来保护它。

以下代码表示在获取器和设置器块中的简单守卫子句：

[PRE30]

我们在获取器和设置器中都进行了空检查，并使用了一个名为 `DefaultDepartmentProvider` 的备用提供者来克服处理上下文不当的情况。

# 在 .NET Core 2.0 中的实现

`corefx` 库在 `System.Threading` 命名空间下的部分类 `Thread` 中有一个 `CurrentPrincipal` `static` 属性。

[PRE31]

使用示例可以在命名空间 `System.Security.Permissions` 下的类 `PrincipalPermission` 的方法 `Demand()` 中看到：

![图片](img/18fdc3f9-c8d6-4b42-81ca-435b2c7dc3ff.png)

# 环境上下文的优点

当应用程序在执行期间多次请求相同的依赖项时，环境上下文绝对是一个救星。在编写注入依赖项的代码时，很难意识到在应用程序内部有如此多的重复请求相同依赖项的实例。这就是我们应该利用环境上下文模式的时候，通过一个简单的 `static` 访问器，我们就能获取到依赖项。这不仅减少了代码，还遵循了 DRY 原则。

# 环境上下文的缺点

环境上下文不易实现，在使用时需要仔细注意。仅通过查看一个类，我们无法判断它是否实现了环境上下文模式。如果在执行过程中上下文发生变化，结果将不同，从而导致副作用。

# 摘要

在实现依赖注入时，我们绝对应该学习与之相关的技术。这些技术，也称为依赖注入模式，在应用程序架构中起着至关重要的作用。因此，决定何时使用哪种模式是注入依赖项时最重要的因素。

构造函数注入是最广泛使用的，简单易用，并且应该始终是你的首选。然而，在某些情况下，你可能需要选择另一种模式。

当你看到某个类的不同操作需要多个依赖项时，选择方法注入模式，因为它允许你根据需要灵活地注入依赖项。

当你遇到需要在应用程序的多个地方使用特定依赖项的情况时，另一个漂亮的设计案例就会显现出来。这看起来像是一个横切关注点，然而，你期望得到一个特定的返回类型，即依赖项。为此，你需要使用环境上下文，而不能依赖于拦截器。这是因为你需要返回的依赖项在类中执行某些操作。

属性注入是一种允许你注入可选依赖项的技术。这意味着它肯定依赖于本地默认值，否则在请求它时我们可能会遇到异常。

在[第9章](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml)《依赖注入中的反模式和误解》中，我们将探讨在实现依赖注入时的一些不良做法，这些做法被称为反模式。
