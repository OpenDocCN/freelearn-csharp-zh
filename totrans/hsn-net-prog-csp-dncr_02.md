# 网络概述

很难想象任何阅读这本书的人对网络实际上是什么没有一些直观的想法*.* 当我写这篇引言时，我周围至少有六个不同的、可触及的网络连接设备。即使在开始软件工程职业生涯之前，我也能给出一个关于网络构成的大致准确的描述。然而，无论对网络是什么或可能在其上运行什么有怎样的直觉，无论使用在分布式系统上运行的软件，都无法解释分布式架构对代码的影响。正是这种对软件设计和实现决策的影响，我们将在本章中探讨。

我们将尝试给出一个关于网络的明确定义，并考虑在为这些网络编写软件时需要解决的新问题。本书假设读者具备相当程度的 C#语言通用编程技能。我不会花费时间去解释原生语言结构、类型或关键字的使用，也不会讨论或解释在整个过程中使用的通用算法。然而，我不会对读者对网络的了解、设备间通信或.NET Core 中解决这些问题的方法做出任何假设。因此，本章将从最基本的第一原理开始，旨在为至少具备一些编程技能的任何人提供一个稳定的基石，使他们能够胜任本书其余部分的学习。

本章将涵盖以下主题：

+   在网络上分配计算或数据资源所面临的独特挑战，以及这些挑战如何在软件中体现

+   网络的不同组成部分，以及如何安排这些组件以实现不同的目标

+   设备多样性、延迟、不稳定性和网络标准化对为网络使用编写的应用程序复杂性的影响

+   网络编程中常用的概念、术语和数据结构，以及.NET Core 如何暴露这些概念

+   理解网络架构使可能的应用程序的范围，以及发展网络编程技能以实现这些类型应用程序的重要性

# 技术要求

由于这是一个入门章节，我们将不会提供有意义的代码示例，因为我们将涵盖网络的高级概念和词汇，为本书的其余部分建立一个清晰的基础。然而，在本章中，我们将讨论.NET Core 提供的`System.Net`类库。虽然这次讨论将在非常高的层次上进行，但这将是一个熟悉由 Microsoft Visual Studio Community 版提供的开发工具的好机会。这是免费的，并且提供了丰富的功能套件，默认支持.NET Core 项目管理和维护。当我们讨论.NET Core 工具中提供的某些库时，我鼓励您使用 Visual Studio IDE 将这些库包含到您的项目中，并通过 IDE 的 IntelliSense 开始探索它们。

# 扩展软件的范畴——分布式系统和它们带来的挑战

理解网络编程的第一步当然是理解网络。定义它们是什么，明确我们关心的网络方面，探讨网络架构对我们编写的程序的影响，以及网络需要什么样的软件解决方案才能有效。

# 什么是网络？

在最基本的意义上，网络不过是一个无向图的物理实现；一系列节点和节点之间的边，或者说是连接，如下面的图所示：

![图片](img/564485cf-f5a8-4ebd-9334-0fadeb8fa45c.png)

[一个基本的、无向图]

然而，前面的图并没有完全捕捉到全貌。构成节点的要素是什么，以及什么才足够构成一个连接，这些都是非常相关的细节，需要明确。一个节点可能需要能够与网络上的其他节点进行有意义的交互，否则你可能不得不为通过两根线连接到路由器和服务器上的土豆编写程序。可以说，土豆显然不是节点，而一个活跃且稳定的 Azure 服务器显然是节点，因此网络中节点与非节点的界限可能介于这两者之间。同样，我们可以很容易地识别出，从电脑的电源到墙上的插座之间的电缆并不构成网络连接，而从我们的电脑到路由器的 CAT-5 电缆显然是。这条界限可能介于这两者之间，而且我们一定要小心准确地划出这条线。

为了这本书的目的，我们将从网络的一个可行定义开始，解析这个定义，并考察我们为什么选择做出特定的区分，最后，考虑每个网络的基本属性对我们程序员意味着什么。所以，不再多言，计算机网络的定义如下：

<q>对于我们的目的而言，计算机网络是由任意大量计算或导航设备组成，这些设备通过通信渠道连接，计算资源可以通过这些渠道可靠地发送、接收、转发或处理。</q>

表面上看，这似乎很基本，但那个定义中有很多细微之处值得我们思考。所以，让我们深入探讨一下。

# 任意大量集合

当我们说“任意大量”时，我们指的是什么？当你为路由器编写软件时（接受你实际上会受到物理可寻址空间最大大小的限制），你不会（也不应该）关心有多少设备实际上连接到你的硬件，或者你需要多少路由来可靠地传递资源或请求。假设你正在为无线路由器编写系统软件。在这样做的时候，你告诉你的产品经理，他们的营销文案应该明确指出这款路由器最多只能连接四台电脑到互联网。你能想象任何产品经理会友好地接受这个消息吗？你很快就会在寻找新的工作了！网络必须能够根据用户的需求进行扩展。

几乎所有计算机网络的一个基本属性是设备无关性，也就是说，网络上的任何设备都应该在任何给定时刻假设不知道该网络上的其他设备数量或种类。事实上，一个程序或设备可能需要判断特定设备或软件是否存在于网络上，但网络连接本身不会传达任何信息。相反，它应该能够以通常为发送消息的通信协议标准化的格式发送和接收消息。然后，使用这些标准化消息，设备可以请求有关网络上其他设备的可用性、配置或功能的信息，而无需知道它期望在网络上可用的设备实际上是否真的可用。

确保任何给定设备发出的任何出站连接的接收端正确连接，或者接收设备已相应配置，这是支持你的软件的网络工程师的关心的问题。响应由你的软件发送的请求是接收软件作者的职责。显然，如果你在一个足够小的软件公司工作，这两个角色可能也会由你担任；但在一个足够成熟的职场环境中，你很可能会依赖其他人来为你处理这些任务。然而，当你的软件部署到网络设备上的时间到来时，仅仅因为连接到网络，你无法简单地获得这些责任是否得到妥善处理的信息。

设备无关性意味着网络不知道连接到它的是什么，因此，它也无法告诉你太多。网络的一个相关属性是，网络上的其他设备无法也不会通知你的设备或软件已经连接并成为资源。

最终，这就是任意大量设备的意思。技术上讲，一台单独的电脑构成一个由一个节点和零连接组成的网络（尽管，为了这本书的目的，我们只会考虑至少有两个节点，并且任何给定节点与网络中任何其他节点之间至少有一个连接的网络），但没有一个固定的节点数量上限，超过这个上限网络就不再是网络。任何任意数量的节点，从一到无穷大（或者可能的最大物理节点数量），只要这些节点之间以及与网络其他部分之间有有效的连接，就构成了一个有效的网络。

# 计算设备

现在我们知道我们可以在网络中拥有任意数量的计算设备作为节点，那么进一步审视一下究竟什么是计算设备是很有必要的。虽然这看起来可能很明显，至少最初是这样，但我们可以通过一个例子很快地识别出它变得不清楚的地方。

根据我们对网络的定义，我现在用来撰写这本书的设备可能完全符合自包含网络的标准。我有一个键盘、鼠标、显示器和电脑，它们都通过标准化的通信通道连接。在概念层面上，这看起来非常像网络，但直观上，我们可能会倾向于说这是一个由一个设备组成的网络，因此，实际上并不是真正的网络。然而，虽然我的电脑的非网络状态在表面上看起来很明显，但原因可能就不那么明确了。

这就是为什么我们需要明确说明，为了我们定义网络的目的，什么构成了计算设备。仅仅能够执行计算对于网络节点来说是远远不够的。在我的例子中，我可以告诉你，我的鼠标（一款相对高端的游戏鼠标）确实执行了许多复杂的计算，将激光传感器信号转换成方向输入，传递给我的电脑。我的显示器也必须进行相当数量的计算，将像素颜色的原始二进制数据转换成我每秒看到 60 或 120 次的渲染屏幕。这两个设备都通过可靠的、标准化的通信协议连接到我的机器上，但我不一定会倾向于认为它们是网络上的节点。当我的电脑连接到互联网或我的本地家庭网络时，它当然构成一个节点，但它的个别外围设备呢？我倾向于说不是。

那么，如果外围设备不是网络设备，那么它们缺失的基本属性是什么？开放通信。虽然显示器和键盘可以通过连接与各种其他设备通信，但它们可以通信的方式仅限于一个非常特定和有限的信号范围。这突出了在分布式系统和网络之间需要做出的重要区分**。**虽然网络始终是分布式系统，但分布式系统不一定总是构成网络。

我的计算机是一个分布式系统；其组件可以独立于彼此运行，但它们以协调的方式运行以执行计算机的责任。然而，我的计算机显然不是一个网络。它缺乏设备无关性，因为每个组件都是明确配置为将其存在通知图中的下一个节点，以便它可以用于满足最终用户的需求。它也不是任意可扩展的。在任何给定时间，我最多只能将三个显示器连接到我的机器上，并且只有在非常具体的连接接口和组织条件下才能做到。当连接到网络时，我的计算机及其每个外围设备在概念上可以被视为一个单一的、原子的计算设备。因此，在网络中，我们可以指定计算设备是能够促进网络需求的东西。它通过设备无关的通信渠道开放接受和通信，以提供或利用该网络上的计算资源。

# 导航设备

在我们对网络的定义中，我指定了计算或导航设备。为了这本书的目的，导航设备是一个有效的网络设备，并且构成了我们网络中的一个节点。计算设备和导航设备（或资源）之间的有意义区别在于，导航设备不提供自己的资源，而仅仅存在是为了促进网络中其他设备的成功通信。简单的交换机或路由器就属于这一类别。这些设备仍然被编程以在网络中成功运行，但通常是在系统级别使用 C 或 C++进行，并带有板载固件。对这些中介设备的编程问题通常超出了这本书的范围，但我想要为了清晰和完整性而指出这种区别。

# 通信渠道

在网络的环境中，构成通信渠道的仅仅是网络中任何两个设备之间数据传输的共享接口。对通信渠道的物理实现没有约束，也没有对通过渠道传输的数据格式的要求，只需至少两个设备可以通过该渠道进行通信。

# 软件影响

当编写旨在利用或被网络上的其他设备利用的软件时，开发者需要考虑和约束的新问题，当只为本地系统编写代码时，这些问题是受到保护的。如何最好地处理这些问题将在后续章节中更详细地讨论，但就目前而言，考虑这些一般计算机网络方面的方面对我们编写的软件可能产生的影响是值得的。

# 设备无关性的影响

当我们谈论设备无关性时，我们假设我们的软件没有关于我们期望可用的资源实际上是否可用的信息。因此，回到我的计算机作为分布式系统而不是网络的例子，我可以可靠地编写本地程序，将信息打印或绘制到屏幕上。因为程序是在本地执行的，我可以相信我的操作系统将负责获取与我的监视器的连接，并将从我的程序堆栈帧到监视器显示端口连接的数据传输。

监视器不是分布式系统固有的资源；我可以在我自己的计算机上技术上执行任何一系列命令而不需要监视器。对于系统功能来说，这不是必要的，即使对于系统以我能够理解的方式运行来说，这是必要的。然而，我可以可靠地假设，如果监视器存在于系统中，我的软件将能够访问它们，因为我的操作系统充当了那些外围设备之间请求的智能经纪人。它将始终存在，并且能够提供任何我的软件需要使用的设备的状态信息。

当我的软件需要访问网络上分布的资源时*，*然而，我不能再对这些资源的可用性做出假设。这就是设备无关性的核心，以及它如何影响网络程序。当我的计算机的操作系统作为智能经纪人时，我们不能假设网络也是如此。因此，验证资源的存在以及我们访问它们的能力，成为我们软件设计中的关键组成部分。并且我要指出，当我们有多个设备可以提供我们正在寻找的资源时，这项任务变得更加具有挑战性。

在那种情况下，网络中某些软件的责任是确定哪个特定设备最终为我们软件请求的资源提供服务。这项工作是由我们自己的程序作为其通信算法的一部分来完成，还是由部署到网络中的某些其他智能经纪人来处理以促进这种情况，这项工作都需要完成，以便我们的软件能够在这样的网络上可靠地运行。

# 为开放通信编写

当我们谈论网络上的开放通信时，我们是在谈论不同设备或软件组件之间的协作。这种协作给每个打算利用其他资源资源的开发者带来了一些责任；即达成一些通信标准的共识，并按照该协议作出响应。在管道中发送和接收数据的方式可能有功能上无限多种，但除非网络上的其他人同意以你决定发送的格式接收你的数据，否则这些都无法被认为是有效的*.* 你本质上是在对空喊。

可能性的广泛范围产生了一个需要标准化的需求，这个需求由同样广泛数量的组织来满足，包括**万维网联盟**（**W3C**）和**国际标准化组织**（**ISO**）。这意味着对你来说，你最终将负责理解你的软件应该遵守哪些标准，以便满足你项目的功能需求，并为你的产品的其他用户提供最大价值。在这本书中，你将了解到的一些常见标准包括通信协议，如 TCP、UDP 和 HTTP，以及寻址和命名标准，如 IP 寻址标准和域名系统。

# **拓扑结构和物理基础设施**

在花费足够的时间讨论了什么是网络之后，我们现在应该考虑网络是如何实际实现的。本节将考虑工程师们为构建符合网络定义的系统而找到的各种解决方案。我们将讨论网络逻辑拓扑和物理拓扑之间的区别，然后检查前者的最常见例子。

# **物理和逻辑拓扑**

就像地理区域的拓扑结构描述了该区域特征如何安排在该区域的面积上一样，网络的拓扑结构描述了该网络组件相对于彼此的排列方式。思考网络组织的方式有两种。正如本小节标题所暗示的，它们是物理拓扑和逻辑拓扑**。**

物理拓扑描述了网络在真实空间中的物理连接和组织方式。它描述了建立连接的介质，连接本身的介质，设备在物理空间中的位置，以及节点之间连接的布局。它部分由网络的具体网络设备和这些设备允许的连接决定（我无法使用同轴电缆连接到只有以太网端口的路由器）。另外，物理拓扑本身决定了网络在性能、弹性和在某些情况下甚至安全性方面的最大能力。想象一下，所有试图访问我拥有的**局域网**（**LAN**）的入站网络流量都必须通过防火墙进行安全过滤。如果我只暴露一个物理设备作为防火墙，我的网络将不会有很高的容错能力。然而，如果我有多个防火墙设备，每个设备服务于不同区域的请求，我可以大大提高我的容错能力。特别是如果每个设备都能在另一个设备因任何原因离线时作为备份，那么一个防火墙的物理拓扑提供的容错能力将低于多个防火墙的物理拓扑。

物理拓扑还描述了我在任何给定时间点使用的网络设备的多样性。这是我们的高级通信通道和节点或计算设备抽象被具体化的地方。物理拓扑不是用链路或连接来描述的，而是将连接描述为有线或无线。一个健壮的拓扑甚至可能指定使用的线缆类型，如同轴电缆或光纤电缆，这在大多数高速家庭互联网连接中很典型，或者像电信网络中使用的双绞线。

这也是我们的网络节点被固定到具体、特定设备的地方。我们不是使用计算设备，而是使用交换机、路由器、网桥和**网络接口控制器**（**NIC**）。这些设备中的每一个都在网络上负责不同的任务或服务，并且它们中的某些或全部可能存在于任何特定的实现中。例如，在我的家庭无线网络上，我并不需要网桥，但很难想象整个互联网在没有使用我列出的每一个设备以及更多我没有列出的设备的情况下如何存在。

同时，网络的逻辑拓扑解释了网络中相关参与者之间的概念组织，以及他们可以或必须通过哪些连接路径与该网络上的任何其他参与者进行通信。然而，有一个重要考虑因素需要指出，物理拓扑并不一定直接映射到逻辑拓扑。回顾我们之前关于具有一个防火墙的物理拓扑与具有多个防火墙的物理拓扑的例子，我们可以说明物理和逻辑之间的区别。首先，让我们看看使用单个物理防火墙设备来限制对服务器资源的访问的初始、天真实现：

![图片](img/e1a34020-234c-433e-a8ed-f9f75a42dd03.png)

初始的单防火墙物理拓扑

虽然完整的物理拓扑将定义和描述支持的连接类型，甚至可能定义前面图中表示的物理设备的型号，但这将满足我们的目的。接下来，让我们看看具有多个防火墙和未响应防火墙的故障转移策略的更具弹性的物理拓扑：

![图片](img/00c0380a-fa01-4cd8-a9a0-1edbe78f27b1.png)

很容易看出物理拓扑图为什么会不同，因为其中涉及不同的物理组件。更重要的是，尽管它们之间的差异很简单，但这两个物理之间的差异并非微不足道，因为第二个拓扑对网络所有者在成本、可靠性和性能方面有重要的影响。

然而，我们想要说明的是，在这两种物理实现中，逻辑拓扑保持不变。如果我们把单个防火墙（在第一种物理拓扑的情况下）和多个防火墙以及请求中继路由器（在第二种物理拓扑的情况下）在概念上视为进入我们内部网络的单一安全接入点，那么我们可以很容易地看到这两种物理拓扑如何映射到以下逻辑拓扑：

![图片](img/87c248bf-016f-4675-b5d4-383bbf73fb68.png)

观察这个图，你可能会注意到它与第一个图的物理布局非常相似，但与第二个图完全不同。这有助于说明逻辑拓扑可能与它的物理对应物一对一映射，但并不一定与它的物理实现一对一映射。

在本书的剩余部分，我们将专门关注网络的逻辑拓扑，因为这种抽象定义了我们将在构建的软件中处理的交互。设备制造商可以处理硬件组件，网络工程师可以努力满足物理性能限制。我们只需考虑我们需要什么资源，或者需要提供什么资源，以及我们如何满足这些需求。逻辑拓扑将足够满足这一点。

然而，我们网络的逻辑拓扑的具体组织可能对我们的软件实现有影响，并且存在各种常见的拓扑，它们各自有其优势和劣势，我们需要考虑，因此我们应该花些时间来做这件事。

# 点对点拓扑

让我们从最基本的概念开始。点对点拓扑学正如其名。网络中两个节点之间的一条单一逻辑连接。这种拓扑学定义了一个最小完整网络，也就是说，至少两个节点之间至少有一个连接。在实现成本方面，这是最低的，并且对部署到此类网络的软件的工程考虑影响最小。点对点网络可以在两个相关节点之间保持专用连接，或者根据需要动态建立该连接。任何直接的点对点通信都是你系统上点对点网络的一个实例，即使该点对点连接是在更复杂的逻辑网络拓扑上建立的，通信会话本身也是逻辑点对点拓扑的一个实例。

虽然点对点连接的成本可能非常低，但你可以从这些成本中获得的好处也非常低。点对点网络设计解决的问题范围有限，通常与一个直接的问题相关。

# 线性拓扑（菊花链）

线性拓扑学正如其名——一条线！它是点对点拓扑学最原始的扩展，从概念上讲，是最简单的逻辑拓扑之一，并且在物理实现方面通常也是最便宜的。在线性网络拓扑中，我们扩展我们的点对点模型，使得在任何给定时间只有一个节点连接到最多两个其他节点。这里的优势显然在于物理实现成本（即使具有高可靠性，这种配置也只能变得如此复杂）。然而，缺点也同样明显。从一个节点到除其最近邻节点之外的其他节点的通信将需要中间节点做一些工作，调查目标请求，并确定它们是否适合处理该请求，如果不适合，知道将请求传递给未发起请求的邻居。

注意，不要将请求返回给最初发起请求的邻居。如果节点通过简单地向两个邻居盲目提交请求来响应，你将陷入在两个节点之间提交和重新提交请求的无穷循环。在任何一对节点中，至少有一个节点必须足够意识到不要向其发起者重新提交请求。这突出了这种拓扑最重要的缺点。具体来说，它需要节点与其在网络结构中的概念位置紧密耦合。

虽然这一切并不特别复杂，但你已经可以看到你的网络逻辑组织如何影响你的网络代码设计。随着拓扑复杂性的增加，这一点将变得更加明显。

# 总线拓扑

总线拓扑是一种网络拓扑，其中网络上的每个节点都通过单个通信通道连接到网络上的每个其他节点，如下面的图所示：

![图片](img/8274a2f7-9a0e-456d-b23f-98ec4c290bc2.png)

从节点发出的每个连接都通过简单的连接接口连接到所有节点之间的共享连接。在总线拓扑上发送的任何数据包都将与网络上传送的每个其他数据包在同一个总线上传输，并且总线上的每个节点都负责确定它是否是服务该数据包所携带请求的最合适的节点。类似于之前描述的线性网络，总线拓扑上的数据包必须包含有关请求目标节点的信息。

就像每个较低复杂性的拓扑一样，总线拓扑具有明显的优点，即实施成本低，以及相对较低的开销。然而，希望我之前的描述有助于描述与这种特定网络拓扑相关的特定挑战。因为所有网络通信都通过单个通道进行，所以即使在理想情况下，所有流量也受该通道带宽的限制。特别是，在总线拓扑上，健谈的软件表现不佳，因为它往往会垄断节点之间的连接。

此外，由于整个网络中只有一个通信通道，因此该通道成为网络的单一故障点。如果中心总线断开，那么每个节点将同时被隔离。

# 星型拓扑

最后，我们开始考虑在企业网络中更常见的网络拓扑。星型拓扑以产生类似星形的形状排列，每个外围节点通过单个通道连接到中心集线器节点，如下面的图所示：

![图片](img/44b58274-dd79-4b7c-a914-83fc3edd9596.png)

星型拓扑的**中心节点**充当所有外围节点之间的通信代理。它通过直接、点对点连接接收并转发其外围节点中的每个节点的请求。

这种拓扑的优点在于将外围节点或它们与中心节点的连接故障隔离到特定的节点。其他每个节点都可以通过任何一个节点故障来维持与网络中所有其他节点的连接。它至少在概念上（如果不是在物理上）是无限可扩展的。向网络添加节点的唯一必要任务是添加新节点与中心节点之间的链接。

希望到讨论网络拓扑的这一阶段，你已经已经识别出这种方法的明显缺点。如果中心节点离线，整个网络就会消失。从任何一个外围节点的角度来看，中心节点的丢失意味着整个网络的丢失，因为所有通信只能与中心节点进行。

在阅读我的描述时，你可能也已经意识到，某些网络拓扑可以被分解为具有完全不同拓扑的子网络。由任何给定外围节点和星型拓扑的中心节点定义的网络本身就是点对点网络的单个实例。同样，由任何两个外围节点和星型拓扑的中心节点定义的网络在技术上是一种线性拓扑（它本身是总线拓扑的一种特殊实现）。通过逻辑上扩展这些简单的图到更大的组合拓扑，我们可以描述任何可能为软件编写的网络类型。

# 环形拓扑

环形拓扑与线性拓扑非常相似（正如我之前提到的，线性拓扑在技术上是一种总线拓扑的实现），只不过在环形拓扑的情况下，端点最终是连接在一起的，通信是单向的，如下面的图所示：

![环形拓扑](img/196aa31f-9d9d-45c3-8b6e-2faadbcb99ab.png)

这种特定的网络拓扑的优点可能不会立即显现，但网络中的每个节点都作为链中前一个节点的对等节点，因此不需要任何请求代理或特定的通信软件或硬件。这可以大幅度降低您的网络管理成本。

其缺点与之前每种实现方式相似，即一旦链中的某个链接断裂，网络基本上就变得毫无用处。技术上，由于环形拓扑的单向通信模式，链中断裂链接之后的节点仍然可以与网络中的每个其他节点通信，并保持一定程度的运行。然而，由于任何响应设备都无法将它们的响应传回原始节点，因此链上的所有节点之间的通信将是一向的。我很难想象一个场景，其中网络上的设备可以通过严格的一向通信有意义地与分布式系统交互。

另一个不那么明显的缺点是，整个网络的最大性能将受到网络中任意两个节点之间性能最差链接的限制。这是因为任何两个节点之间请求-响应的往返通信必然要穿越整个链。

# 网格拓扑

网格拓扑是目前使用中最具弹性和最常见的一种网络拓扑。其原因是它在组织方式上几乎完全是任意的。网格拓扑简单描述了任何非正式的连接拓扑，其中一些节点通过单点对点连接与其他节点相连，而一些节点可能与其他多个节点有多个连接。本章开头的原始图示，如下所示，在技术上是一个网格网络拓扑：

![](img/9057649e-d8a6-4b6d-bcda-3870d05f9b1b.png)

如果你忘记了。

你会注意到，前一个图中的节点与其他网络中的节点有从一到三个直接连接。这可以在必要时提供其他网络拓扑的一些弹性，而不会产生它们的成本。由于网格网络没有明显的规范，除了它没有完全实现我们讨论过的任何其他网络拓扑之外，它可以包括节点之间具有任意连接度的网络，包括完全连接的网格网络。

# 完全连接的网格网络

一个完全连接的网格网络是这样的，其中每个节点都与网络中的每个其他节点有直接连接，如下面的图示所示：

![](img/2429ea22-6539-483c-81e6-e7ddfa851e9d.png)

如果这个图看起来有点拥挤，你已经注意到了完全连接的网格网络最大的缺点。几乎不可能扩展到某个点以上，因为网络上的每个新节点都需要与网络中之前连接的每个节点建立连接。对于每个要添加的新节点，连接的数量呈二次增长。在网络中超过几个节点后，物理上变得几乎不可能。

然而，一个完全连接的网状网络的成本非常高，但它带来了最稳定和最具有弹性的拓扑。没有节点需要负责数据包转发或请求切换，因为不应该存在两个节点间接通信的上下文。任何一个节点或节点之间的连接都可以中断，而网络上的其他每个节点都可以保持完整的连接性，没有任何性能损失。两个节点之间单一薄弱的连接对任何其他两个节点的性能没有影响。从拓扑的角度来看，完全连接的网状拓扑是坚不可摧的。它也往往过于昂贵，因此在除了最小和最简单的情况下，并不常见。

# 混合和专用拓扑

如我之前所述，你可能需要访问资源的多数大型网络都是由多个拓扑结构组合而成的，通常被称为**混合型**。例如，一个星型拓扑，其中外围节点之一也是线性拓扑中的一个链路，就是这种混合型拓扑的一个例子。

其他类型的拓扑实际上是我们在本节中讨论的拓扑的变体。例如，一个线性网络拓扑的节点同时也是次要线性拓扑的接入点的情况构成了一个树型拓扑，简单地说，就是一个分层线性拓扑。这些结构的细节不如知道它们的存在重要，以及根据你打算部署到网络上的软件的性质，你知道对于它们有成本和考虑需要做出。说到这些成本...

# 在网络上分配资源对软件的影响

到目前为止，所有关于设备无关性和开放通信的讨论可能听起来非常抽象。你可能正在阅读这段内容，心想，嗯，那又怎样呢？我不用编写网络交换机的代码，这可能确实如此。确实，你不必使用.NET Core 在 C#中编写网络交换机的代码，因为这远远超出了框架的范围和能力，因此，这本书的范围。然而，网络不可预测性对你的软件的影响将是相当大的，并且这将对网络堆栈的任何部分编程都是如此。所以，让我们看看你的代码应该如何为分布式系统做好准备。

# 安全性

我首先讨论了最明显且复杂的问题，因为我认为这最有意思。在专业环境中编写软件，总体上要求你编写安全的应用程序。即使你的工作没有明确要求，我也会不遗余力地争论，作为一个工程师，你有道德义务编写安全的软件，无论是否明确要求。这可能是一项艰巨的任务。特别是，因为确保软件安全始终是一个移动的目标。然而，重要的是要记住，让你的软件作为一个资源对广泛的善意消费者有用，这本质上会使你面临恶意意图。

这就是设备无关性和开放通信变得极其重要的地方。设备无关性意味着你无法合理地确信一个恶意行为者没有访问到你可能认为已经在上游托管环境中得到保护的网络安全。你将只会在你的软件的访问点上看到和处理请求。开放通信意味着你可能会收到许多格式不正确的请求，你将尝试最初解析它们，然后确定你无法解析，并将它们丢弃。这种首先读取你给出的消息的需要，以便知道它们是否是你关心的，因为这最终会使你面临恶意命令或代码。

幸运的是，正如我们稍后将要探讨的，.NET Core 库提供了大量的强大安全组件，直接开箱即用，而获取和利用加密库以及请求清理算法的工作，只需知道在源文件顶部包含哪些`using`语句即可。

# 通信开销

在网络编程中，你面临的另一个最明显的问题是如何处理开放通信的开放性。这一特性意味着你将不得不花费大量时间熟悉不同通信协议的具体消息标准（我将在本书中深入探讨）。将数据压缩成格式良好的数据包，并添加适当的头部信息，以便告诉你的软件何时开始和何时停止从你的连接中读取以获取完整的、不间断的二进制流，并将其转换回代码中的有意义的数据结构，这需要大量的组织工作。描述这个过程本身就是一件头疼的事情。

在本地托管代码中，你可以通过在消费者应用程序之间共享库的 DLL 来方便地共享数据结构的合同。你可以通过文件系统本身与系统上的其他软件进行通信。你可以仅使用系统文件访问 API 来公开你的消息中存在多少数据，数据的编码方式是什么，并通过随机访问文件来公开这些信息。

在网络中，您必须提供足够的上下文，以便其他人能够通过消息本身理解您的信息。您必须以消费者在获得上下文之前能够理解的方式传达这种上下文。再次强调，.NET 库将在这里为您提供帮助，提供易于使用的类，这些类公开标准化的头和消息格式，以保持您的代码清晰，避免这种开销。

# 弹性

我在讨论网络拓扑时提到过这个概念几次，但在这里特别提一下，因为您将负责从连接的两端维护您应用程序的弹性。如果您的应用程序在网络中利用任何资源，您必须考虑到这些资源在网络上可能实际上不可用的可能性。在这种情况下，您需要编写代码，以确保即使在出现此类故障的情况下，代码仍然能够以可靠和稳定的方式响应用户。

同样，如果您的软件是您网络中其他系统的依赖项，并且它崩溃了，您最好的做法是制定一个策略来从这种故障中恢复。目前有几种可行的解决方案来通知您的下游消费者您已经从故障中恢复过来，每种方案都有其自身的优势和成本，包括资源使用或开发时间，我们将在本书的后面讨论其中几个。然而，现在，在设计解决方案时考虑这一点并相应调整设计就足够了。

# 异步

与弹性和开放通信的概念紧密相关的是异步通信的概念。这对于在网络程序中保持任何可靠性能至关重要。简单来说，这是处理当结果变得可用时，系统内部代码未提供的结果的概念。

当您的程序需要从其网络上的另一个节点请求一些资源时，发送初始请求并接收一些有意义响应之间存在往返时间。在这段时间内，您的程序在技术上可以锁定并等待响应返回，但现实中没有理由让它锁定并等待。然而，即使我们的程序可能已经继续前进，决定不对初始请求的响应等待，我们通常希望退一步处理当响应通过网络返回时的响应。这个过程是异步编程，它是开发合理性能网络软件的关键。

您可能遇到的一个异步编程的明显例子是在网络编程之外，即在编程响应式用户界面（UI）时。通常，UI 组件需要积极监听并响应用户输入，无论用户何时选择与之交互。由于程序员永远无法确切知道用户何时会按下他们提供的按钮，他们必须在最早的时刻响应用户输入，而不必在等待响应时保持资源处于等待状态。

# .NET Core 中的网络对象和数据结构

从零开始编写网络代码可能听起来是一项艰巨的任务，在某些情况下，这确实如此。然而，.NET Core 类库提供了帮助。有了这些库，您将能够开始使用干净的抽象来处理复杂且经常令人沮丧的网络协议和标准，从而在分布式网络上开始生产有价值的组件。

# 使用 System.Net

`using`语句可能是您可以在包含任何类型网络代码的源文件中包含的最重要语句之一。System.Net 命名空间是一套通用的.NET Core 类和实用工具，用于编程大多数协议和网络化系统行为。它是您在阅读本书时将使用的最常见网络类的根命名空间。

该命名空间包括以下类：

+   域名解析和 DNS 访问

+   抽象基类`WebRequest`和`WebResponse`，以及这些类的常见实现，包括`FtpWebRequest`和`HttpWebRequest`

+   **互联网协议**（**IP**）解析和定义

+   Socket 实用类定义

+   许多其他类

在您开始开发更复杂和强大的软件时，这个命名空间中的类将成为您的日常必需品，您应该花相当多的时间熟悉 System.Net 命名空间封装的功能和功能。

# 专注于子命名空间

虽然 System.Net 命名空间封装了大量的网络编程有用类，但在 System.Net 包层次结构下还有许多有用的子命名空间，您也应该熟悉，如下所示。

+   `System.Net.Http`：一个实用类，用于在您的.NET Core 应用程序中提供符合 HTTP 标准的消息和交互

+   `System.Net.NetworkInformation`：提供有关网络中主机节点的流量数据、地址信息和其他详细信息

+   `System.Net.Security`：提供可靠的安全网络通信和资源共享及访问

+   `System.Net.Sockets`：提供对 WinSock 接口的 netcore 托管访问

在本书的整个过程中，我们将更深入地探讨这些命名空间以及它们公开的类。但到目前为止，我想让你了解.NET Core 开箱即用的最常用、最有价值的网络类。

他们的软件是开源的，并且在这里有详尽的文档描述：

[`docs.microsoft.com/en-us/dotnet/api/?view=netcore-2.1`](https://docs.microsoft.com/en-us/dotnet/api/?view=netcore-2.1)

对于考虑从事网络 Web 开发职业的人来说，花时间检查这些类无疑是值得的。

# 一个全新的计算世界

一件软件能提供的最大价值受限于能够利用该软件的下游消费者数量。将你的软件部署在广泛可用的网络上可以增加它对你的组织或消费者社区的整体影响。本节的最后部分将探讨这一转变所开启的应用类型。

# 长距离通信

感谢**文件传输协议**（**FTP**）和**简单邮件传输协议**（**SMTP**）等通信协议，在发送者发送后几秒钟内，就可以在地球的另一端写入或接收一封信。这一工程技术成就得益于支持整个互联网的强大、弹性的物理基础设施，到本书结束时，目标是让你具备开发这类应用所需的技能。

使用对等通信协议，我们可以构建网络化多人游戏系统，用于实时、高强度、高动作的游戏。

# 分享功能，而不是代码

使用如 RESTful API 设计以及 HTTP 消息格式等明确的标准，你可以编写稳定、干净、良好隔离的 Web API 项目，这些项目允许各种消费者按需请求你编写的功能。你不必直接共享代码，而可以通过良好的文档化通信渠道，仅允许对所拥有的业务流程进行概念性访问，从而保持你的抽象抽象化。

# 摘要

本章深入探讨了少数几个主题。我们给出了一个仔细考虑的网络定义，然后考虑了该定义的关键组成部分如何影响我们的网络程序开发策略。我们考虑了物理网络拓扑和逻辑网络拓扑之间的区别，然后探讨了我们将要工作的最常见逻辑拓扑。最后，我们考虑了在开始编写第一个网络程序时，我们将不得不做出的新设计决策和策略，以及.NET 类将如何帮助我们轻松且干净地实现这些策略。

在下一章中，我们将迈出网络编程的第一步，我们将探讨资源定位和寻址。

# 问题

1.  网络的定义是什么？

1.  物理拓扑和逻辑拓扑之间的区别是什么？

1.  本章中唯一讨论的、没有暴露给潜在的单点故障的网络拓扑是哪一个？

1.  在网络上实现通信通道的一些物理设备有哪些？哪些物理设备作为节点？

1.  .NET Core 提供的最常见的网络库和类的根命名空间是什么？

1.  至少列出 System.Net 命名空间暴露的四个类。

1.  .NET Core 为可靠和稳定的网络编程提供了哪些其他四个最常用的命名空间？

# 进一步阅读

想要获取有关网络的更多信息，请查看由 Steven Noble 编写的 *Building Modern Networks*，通过 Packt Publishing 提供。这是一本了解现代网络工程师面临的挑战的绝佳资源，也是对本章讨论的概念应用的深入探讨。
