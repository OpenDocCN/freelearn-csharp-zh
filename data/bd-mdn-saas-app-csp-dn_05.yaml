- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Building Restful APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建RESTful API
- en: In today’s online-centric digital landscape, **application programming interfaces**
    (**APIs**) have become ubiquitous in the development of **Software-as-a-Service**
    (**SaaS**) applications. They allow different systems and applications to communicate
    with each other and share data. Among the different types of APIs, **Representational
    State Transfer** (**REST**)ful APIs have become the most widely used and accepted
    standard, and that is what we will focus on in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今以在线为中心的数字景观中，**应用程序编程接口**（**APIs**）在**软件即服务**（**SaaS**）应用程序的开发中变得无处不在。它们允许不同的系统和应用程序相互通信并共享数据。在众多类型的API中，**表征状态转移**（**REST**）API已成为最广泛使用和接受的标准，这也是本章我们将关注的重点。
- en: This chapter will introduce you to the basics of building RESTful APIs and the
    key principles that guide their design. You will learn about the key components
    of a RESTful API, such as resources, representations, and the main HTTP verbs
    (`GET`, `POST`, `PUT`, `PATCH`, and `DELETE`).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍构建RESTful API的基础以及指导其设计的核心原则。您将了解RESTful API的关键组件，例如资源、表示和主要的HTTP动词（`GET`、`POST`、`PUT`、`PATCH`和`DELETE`）。
- en: Additionally, you will learn about the various strategies to version RESTful
    APIs, such as URL versioning, custom header versioning, media type versioning,
    and deprecation and sunsetting.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还将了解各种版本RESTful API的策略，例如URL版本控制、自定义头版本控制、媒体类型版本控制和弃用及停用。
- en: 'The main topics covered in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: What are RESTful APIs?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是RESTful API？
- en: Matching API operations to HTTP verbs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将API操作与HTTP动词匹配
- en: Designing better with REST
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST设计得更好
- en: Versioning public APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共API版本控制
- en: Testing APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试API
- en: By the end of this chapter, you will have a solid understanding of the key principles
    and strategies to build RESTful APIs, and you will be well-equipped to design,
    develop, and test them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对构建RESTful API的关键原则和策略有扎实的理解，并且将准备好设计、开发和测试它们。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码均可在[https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5)找到。
- en: What are RESTful APIs?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是RESTful API？
- en: REST was introduced by Roy Fielding in his doctoral dissertation at the University
    of California, Irvine, in 2000\. In his dissertation, Fielding defined the architectural
    constraints that formed the basis of RESTful systems and described how REST could
    be used to build scalable and flexible web services. The concepts outlined in
    his dissertation have since become widely adopted and are used as the foundation
    to build many modern web APIs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: REST是由Roy Fielding在2000年于加州大学欧文分校的博士论文中提出的。在他的论文中，Fielding定义了构成RESTful系统基础的架构约束，并描述了如何使用REST来构建可扩展和灵活的Web服务。他在论文中概述的概念自那时起已被广泛采用，并作为构建许多现代Web
    API的基础。
- en: RESTful APIs are a type of web-based interface that allows for communication
    between different software systems. They utilize a standard set of constraints
    and principles defined by the REST architecture to exchange data between a client
    and server. Resources are identified by unique URLs, and the behavior toward these
    resources is defined by the HTTP methods used. RESTful APIs are commonly used
    to build scalable and flexible web services and can return data in different formats,
    such as JSON or XML. They offer a simple and flexible way for different software
    systems to interact and exchange data over the internet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API是一种基于Web的接口，允许不同软件系统之间的通信。它们利用REST架构定义的标准约束和原则，在客户端和服务器之间交换数据。资源通过唯一的URL进行标识，对这些资源的行为由使用的HTTP方法定义。RESTful
    API通常用于构建可扩展和灵活的Web服务，可以以不同的格式返回数据，如JSON或XML。它们为不同的软件系统在互联网上交互和交换数据提供了一种简单灵活的方式。
- en: Let’s break down what the REST acronym means!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下REST这个缩写的含义！
- en: '**Representational** refers to the idea that each resource in a RESTful API
    is represented by a unique identifier (such as a URL) and can be represented in
    a variety of formats, such as JSON or XML. The representation of a resource is
    a snapshot of its current state and can be used by a client to manipulate the
    resource.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示**指的是RESTful API中每个资源都由一个唯一的标识符（如URL）表示，并且可以用多种格式表示，例如JSON或XML。资源的表示是其当前状态的快照，客户端可以使用它来操作资源。'
- en: 'You can think of a resource as an object, such as a description of a user in
    a system. The user will typically have a unique ID that is used to refer to that
    user. In a REST system, the user *resource* with an ID = 123 could be *represented*
    by the following URL:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将资源视为一个对象，例如系统中用户描述。用户通常会有一个唯一的ID，用于引用该用户。在REST系统中，ID为123的用户*资源*可以通过以下URL表示：
- en: '`https://www.a-system.com/api/v1/users/123`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://www.a-system.com/api/v1/users/123`'
- en: The user can be retrieved, modified, or deleted by using this URL. The URL *represents*
    the user on any external system that is consuming the **PAI**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过使用此URL检索、修改或删除。该URL*代表*在消费**PAI**的任何外部系统上的用户。
- en: The `GET`, `POST`, `PUT`, and `DELETE`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT`和`DELETE`。'
- en: If you were to issue a `GET` request to the preceding dummy URL, you would receive
    the *state* of the object represented by that URL.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向前面的虚拟URL发出`GET`请求，你会收到该URL所表示对象的*状态*。
- en: '**Transfer** refers to the transfer of the representation of a resource from
    a server to a client and vice versa. The transfer is typically performed over
    the HTTP protocol and is based on the principles of statelessness and uniform
    resource identification. In RESTful APIs, the transfer of state is used to create,
    read, update, and delete resources on the server.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输**指的是将资源的表示从服务器传输到客户端，反之亦然。传输通常通过HTTP协议执行，并基于无状态和统一资源标识的原则。在RESTful API中，状态的传输用于在服务器上创建、读取、更新和删除资源。'
- en: RESTful APIs do not have to communicate over HTTP, although they very often
    do. They could use any other possible communication protocol, such as **remote
    procedure calls** (**RPCs**). However, the large majority of RESTful APIs use
    HTTP as the chosen communication mechanism, and that is all that we will consider
    in this chapter. If you have a use case for an alternative communication protocol,
    then I hope the information in this chapter is useful in a more general sense!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API不一定要通过HTTP进行通信，尽管它们通常是这样。它们可以使用任何其他可能的通信协议，例如**远程过程调用**（**RPCs**）。然而，绝大多数RESTful
    API使用HTTP作为选择的通信机制，这是我们本章将考虑的全部内容。如果你有使用替代通信协议的用例，那么我希望本章中的信息在更广泛的意义上是有用的！
- en: Before we get into the details of building restful APIs, there are a few general
    points to consider that will aid our understanding of some of the more complex
    concepts that will follow.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨构建RESTful API的细节之前，有一些一般性的观点需要考虑，这将有助于我们理解随后将出现的某些更复杂的概念。
- en: Idempotency
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幂等性
- en: In the context of a RESTful API, idempotency is a property of an API endpoint
    that allows multiple identical requests to have the same effect as a single request.
    This means that, regardless of the number of times the same request is made, the
    end result should be the same.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在RESTful API的上下文中，幂等性是API端点的一个属性，它允许多个相同的请求产生与单个请求相同的效果。这意味着，无论相同的请求被发出多少次，最终结果都应该是相同的。
- en: An idempotent request will always produce the same response from a server, regardless
    of how many times it is executed. This property is useful to reduce the chance
    of errors and conflicts when making multiple requests to the same endpoint, especially
    when dealing with network connectivity issues or other types of failures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性请求无论执行多少次，都会从服务器产生相同的响应。这个属性在向同一端点发出多个请求时非常有用，尤其是在处理网络连接问题或其他类型的故障时，可以减少错误和冲突的可能性。
- en: The most common HTTP methods considered idempotent are `GET`, `PUT`, `DELETE`,
    and certain types of `POST` requests. On the other hand, non-idempotent methods,
    such as `POST` without specifying the idempotent semantics, may have unintended
    side effects if repeated multiple times.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到幂等的HTTP方法最常见的是`GET`、`PUT`、`DELETE`和某些类型的`POST`请求。另一方面，非幂等的方法，如未指定幂等语义的`POST`，如果多次重复执行，可能会产生意外的副作用。
- en: This is to say that you can retrieve a resource at a URL as many times as you
    like, and the response will be the same every time. A `GET` request is idempotent.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以根据需要多次从 URL 获取资源，并且每次的响应都将相同。`GET` 请求是幂等的。
- en: Safety
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: In the context of a RESTful API, a “safe” operation is one that is guaranteed
    not to modify the state of a server or have any side effects. Safe operations
    are read-only and do not alter any resources on the server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 的上下文中，“安全”操作是指保证不会修改服务器状态或产生任何副作用的操作。安全操作是只读的，并且不会更改服务器上的任何资源。
- en: The most common example of a safe operation is a `GET` request, which retrieves
    data from the server without changing it. Other safe operations might include
    `OPTIONS`, `HEAD`, and some types of `POST` requests that are specifically designed
    to only retrieve data and not make any changes to the server state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的安全操作示例是 `GET` 请求，它从服务器检索数据而不更改它。其他安全操作可能包括 `OPTIONS`、`HEAD` 以及一些专门设计为仅检索数据而不更改服务器状态的
    `POST` 请求类型。
- en: Safe operations are contrasted with “unsafe” operations, such as `PUT`, `POST`,
    and `DELETE`, operations that modify the state of the server and may have side
    effects. These operations are considered unsafe because they can have unintended
    consequences if executed improperly, such as deleting important data or altering
    resources in unexpected ways.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安全操作与“不安全”操作（如 `PUT`、`POST` 和 `DELETE`）相对，这些操作会修改服务器状态并可能产生副作用。这些操作被认为是“不安全”的，因为如果执行不当，可能会产生意外的后果，例如删除重要数据或以意想不到的方式更改资源。
- en: HTTP status codes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: HTTP status codes are three-digit numbers returned by a server in response to
    a client’s request. These codes indicate the outcome of the request and provide
    information about the status of the requested resource.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码是服务器在响应客户端请求时返回的三位数。这些代码指示请求的结果，并提供有关请求资源状态的信息。
- en: There are many HTTP status codes – I will briefly reference only the set that
    I think is most applicable to building RESTful APIs. Don’t worry about memorizing
    all of these! As you will see, when we start to build up the examples, it is quite
    intuitive which ones should be used and when! And remember, information like this
    is only ever a Google search away!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码有很多，我只会简要地引用我认为对构建 RESTful API 最适用的那一组。不必担心记住所有这些！正如你将看到的，当我们开始构建示例时，哪些应该使用以及何时使用是非常直观的！而且记住，像这样的信息永远只在
    Google 搜索的一步之遥！
- en: 'Each status code is a three-digit number. The first digit gives the category
    of the status code. There are five category codes, each with a specific meaning
    and purpose. These are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态码是一个三位数。第一位数字给出了状态码的类别。有五种类别代码，每种都有特定的含义和目的。具体如下：
- en: '`100 Continue`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`100 继续进行`。'
- en: '`200 OK` and `201 Created`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK` 和 `201 已创建`。'
- en: '`301 Moved Permanently` and `302 Found`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301 永久移动` 和 `302 找到`。'
- en: '`400 Bad Request` and `401 Unauthorized`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 错误请求` 和 `401 未授权`。'
- en: '`500 Internal Server Error` and `503` `Service Unavailable`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500 内部服务器错误` 和 `503 服务不可用`。'
- en: 'There are many status codes within these categories. Some of the common and
    most applicable to RESTful APIs are given here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别中有许多状态码。其中一些常见且适用于 RESTful API 的状态码如下：
- en: '`200 OK`: The request was successful, and the requested resource was returned.
    This status is commonly returned from a successful `GET`, `PUT`, or `PATCH` request.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK`: 请求成功，并返回了请求的资源。这个状态通常在成功的 `GET`、`PUT` 或 `PATCH` 请求中返回。'
- en: '`201 Created`: The request was successful, and a new resource was created as
    a result. This status code is often returned as the result of a successful `POST`
    request.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201 已创建`: 请求成功，并且因此创建了一个新的资源。这个状态码通常作为成功 `POST` 请求的结果返回。'
- en: '`204 No Content`: The request was successful, but no resource was returned.
    This status is commonly returned from a successful `DELETE` request.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`204 无内容`: 请求成功，但没有返回任何资源。这个状态通常在成功的 `DELETE` 请求中返回。'
- en: '`400 Bad Request`: The request was malformed or invalid. With a RESTful API,
    requests are often in JSON format. This would imply that the object is not correct
    per the expectations of the API.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 错误请求`: 请求格式不正确或无效。在 RESTful API 中，请求通常以 JSON 格式。这意味着对象不符合 API 的预期。'
- en: '`401 Unauthorized`: The request requires authentication, and the client did
    not provide valid credentials.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 未授权`: 请求需要身份验证，但客户端没有提供有效的凭据。'
- en: '`403 Forbidden`: The client does not have access to the requested resource.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403 禁止访问`: 客户端没有访问请求资源的权限。'
- en: '`404 Not Found`: The requested resource could not be found. The request is
    looking for a resource that is not there.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404 Not Found`：请求的资源找不到。请求正在寻找一个不存在的资源。'
- en: '`405 Method Not Allowed`: The request method, such as `GET`, `POST`, and `DELETE`,
    is not allowed for the requested resource on the server.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`405 Method Not Allowed`：请求方法（如 `GET`、`POST` 和 `DELETE`）在服务器上不允许对请求的资源进行操作。'
- en: '`500 Internal Server Error`: An unspecified error occurred on the server. This
    status code is a “catch-all” error to let the user know that something has gone
    wrong on the server – for example, there could be an exception in the backend
    code.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500 Internal Server Error`：服务器上发生了未指定的错误。这个状态码是一个“通配符”错误，用于让用户知道服务器上出了问题——例如，后端代码中可能发生了异常。'
- en: '`503 Service Unavailable`: The server is currently unable to handle the request
    due to maintenance or high traffic.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`503 Service Unavailable`：服务器目前无法处理请求，可能是由于维护或流量过高。'
- en: There are many other HTTP status codes that can be used, each with a specific
    meaning and purpose. We will make use of these codes when we build out an example
    later in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他 HTTP 状态码可以使用，每个都有其特定的含义和目的。我们将在本章后面的示例中利用这些代码。
- en: Dealing with errors
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: When it comes to dealing with an error code on a RESTful API, it is important
    to have a clear and consistent approach in place. The HTTP status code is an essential
    part of this approach, and by using the status codes correctly, clients of the
    API are able to understand what has gone wrong and will have an idea as to why.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理 RESTful API 上的错误代码时，实施一个清晰且一致的方法非常重要。HTTP 状态码是这个方法的一个基本部分，通过正确使用状态码，API
    的客户端能够理解发生了什么问题，并会有一个关于为什么发生问题的想法。
- en: In addition to using the status codes correctly, it also helps to provide clear
    and informative error messages. These messages should explain what has gone wrong
    in an easily understood way and, if possible, provide guidance on how to resolve
    the issue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正确使用状态码外，提供清晰且信息丰富的错误消息也有帮助。这些消息应以易于理解的方式解释发生了什么问题，并在可能的情况下，提供解决问题的指导。
- en: The preceding will help users of the API, but it is also very important that
    the developers of the API are also informed when there has been an error so that
    they can take action to resolve or prevent recurrences. Because developers cannot
    watch over every API interaction, this is typically done with logging.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助 API 的用户，但 API 的开发者当出现错误时也应得到通知，以便他们可以采取措施解决问题或防止再次发生。由于开发者无法监控每个 API 交互，这通常是通过日志记录来完成的。
- en: Logging refers to the process of capturing and recording information about an
    API’s behavior and performance and persisting this information in a data store
    so that it can be searched later to identify issues and troubleshoot problems.
    Logging is an essential part of any API’s operational infrastructure, as it provides
    a record of what has happened on the system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是指捕获和记录有关 API 行为和性能的信息，并将这些信息持久化存储在数据存储中，以便以后可以搜索以识别问题和排除故障。日志记录是任何 API
    运营基础设施的重要组成部分，因为它记录了系统上发生的事情。
- en: This chapter will focus on API implementation, but we haven’t forgotten about
    logging and monitoring – we will cover both in detail in [*Chapter 9*](B19343_09.xhtml#_idTextAnchor219)!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍 API 实现，但我们没有忘记日志记录和监控——我们将在[第 9 章](B19343_09.xhtml#_idTextAnchor219)中详细介绍这两者！
- en: JSON data formatting
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 数据格式化
- en: While RESTful APIs do not have to use **JavaScript Object Notation** (**JSON**)
    formatting, it is an exceptionally popular choice and will be the formatting standard
    that is used throughout this book. JSON is a lightweight data exchange format
    that is easy for humans to read and write, and it is also easy for machines to
    parse and generate. It is completely language-independent, but it does make use
    of conventions that are familiar to the C family of languages (C, C++, C#, Java,
    and so on).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 RESTful API 不必使用 **JavaScript 对象表示法**（**JSON**）格式，但它是一个非常流行的选择，并将成为本书中使用的格式标准。JSON
    是一种轻量级的数据交换格式，易于人类阅读和编写，同时也易于机器解析和生成。它是完全语言无关的，但它确实使用了与 C 家族语言（C、C++、C#、Java 等）熟悉的约定。
- en: 'Here is an example of some information represented as JSON:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些以 JSON 格式表示的信息示例：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JSON data takes the form of key-value pairs, where each key is a string, and
    each value can be of type string, number, Boolean, null, array, or another JSON
    object. The ability to nest JSON objects allows for complex types to be represented
    in this straightforward way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 数据采用键值对的形式，其中每个键都是字符串，每个值可以是字符串、数字、布尔值、null、数组或另一个 JSON 对象。嵌套 JSON 对象的能力允许以这种方式表示复杂类型。
- en: The keys are always strings, so they are encased in double quotation marks.
    The values are encased in quotes if they are strings, square brackets if they
    are arrays, and curly brackets if they are objects. All of these are shown in
    the preceding snippet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 键始终是字符串，因此它们被双引号包围。如果值是字符串，则被引号包围；如果是数组，则被方括号包围；如果是对象，则被花括号包围。所有这些都在前面的代码片段中展示。
- en: We have established that JSON-encoded data will be sent and received over HTTP.
    Next, we will look at how that data is transmitted, looking at the most common
    HTTP verbs and describing how and when to use them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定 JSON 编码的数据将通过 HTTP 发送和接收。接下来，我们将探讨这些数据是如何传输的，查看最常用的 HTTP 动词，并描述如何以及何时使用它们。
- en: Matching API operations to HTTP verbs
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 API 操作与 HTTP 动词匹配
- en: In language, a verb is a “doing” word. It describes an action, state, or occurrence.
    In English, examples of verbs include “run,” “think,” “sing,” and “do,” as well
    as many thousands more!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言中，动词是一个“动作”词。它描述了一个动作、状态或事件。在英语中，动词的例子包括“run”（跑）、“think”（思考）、“sing”（唱歌）和“do”（做），以及成千上万的更多！
- en: The HTTP verbs describe things that you can “do” over HTTP! Five main verbs
    are used – `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`. Each of these serves a
    different purpose, although the precise purpose of each is not tightly defined,
    and it is not uncommon to accidentally use the wrong one. In this section, we
    will cover the uses of the five commonly used HTTP verbs, and we will give an
    example of them being used in our demo application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 动词描述了您可以通过 HTTP “执行”的事情！使用了五个主要动词——`GET`、`POST`、`PUT`、`PATCH` 和 `DELETE`。每个动词都有不同的用途，尽管每个动词的确切用途并没有严格定义，而且不小心使用错误的动词并不少见。在本节中，我们将介绍五个常用
    HTTP 动词的用法，并给出它们在我们演示应用程序中使用的示例。
- en: GET
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET
- en: The `GET` HTTP verb is used to *retrieve a resource from a server*. When a client
    sends a `GET` request to a server, the server responds by returning the requested
    resource to the client. The resource can be any type of data, such as a web page,
    image, or file. The `GET` verb is the most widely used HTTP verb and is considered
    to be a safe and idempotent method, which means that it can be called multiple
    times without any side effects. It is also cacheable, which means that the response
    can be stored in a cache and reused to improve performance. The `GET` verb should
    only be used to retrieve information and never to make changes on the server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` HTTP 动词用于从服务器*检索资源*。当客户端向服务器发送 `GET` 请求时，服务器通过返回请求的资源来响应客户端。资源可以是任何类型的数据，例如网页、图像或文件。`GET`
    动词是使用最广泛的 HTTP 动词，被认为是安全且幂等的，这意味着它可以多次调用而不会产生任何副作用。它还可以缓存，这意味着响应可以存储在缓存中并重复使用以提高性能。`GET`
    动词应仅用于检索信息，绝不应用于在服务器上做出更改。'
- en: When it comes to RESTful APIs, the `GET` verb is used to retrieve a representation
    of a resource or a collection of resources from a server. The resource can be
    identified by a `GET` request can also include query parameters, which can be
    used to filter the results or specify the format of the returned data. The server
    responds to a `GET` request with a representation of the resource in the form
    of an HTTP response, along with the appropriate HTTP status code. The most common
    status code for a `GET` request is `200 OK`, indicating that the request was successful
    and the resource was returned.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 RESTful API 时，`GET` 动词用于从服务器检索资源或资源集合的表示。资源可以通过 `GET` 请求识别，也可以包括查询参数，这些参数可以用于过滤结果或指定返回数据的格式。服务器通过以
    HTTP 响应的形式返回资源的表示以及适当的 HTTP 状态码来响应 `GET` 请求。`GET` 请求最常见的状态码是 `200 OK`，表示请求成功且资源已返回。
- en: POST
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST
- en: The `POST` HTTP verb is used to *submit an entity to be processed by the resource
    identified by the URI*. A `POST` request is typically used to create a new resource
    or (sometimes) to update an existing one. The `POST` verb is not idempotent, which
    means that it can have different effects depending on how many times it is called.
    It is also not safe, meaning that it can modify the resource on the server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` HTTP 动词用于将实体提交给由 URI 标识的资源进行处理。通常情况下，`POST` 请求用于创建新的资源或（有时）更新现有的资源。`POST`
    动词不是幂等的，这意味着它的效果可能因调用次数的不同而不同。它也不是安全的，意味着它可以修改服务器上的资源。'
- en: When a client sends a `POST` request to a RESTful API, typically, the server
    creates a new resource with the data provided in the request body and returns
    a response with a status code indicating the outcome of the request. The most
    common status code for a successful `POST` request is `201 Created`, indicating
    that a new resource has been successfully created. The URI of the newly created
    resource is typically included in the response headers so that the client application
    can retrieve and work with the newly created resource immediately. The data in
    a `POST` request can be in any format, such as JSON or XML, but it is usually
    in the JSON format.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向 RESTful API 发送 `POST` 请求时，通常情况下，服务器会使用请求体中提供的数据创建新的资源，并返回一个包含状态码的响应，指示请求的结果。对于成功的
    `POST` 请求，最常见的状态码是 `201 Created`，表示新资源已成功创建。新创建资源的 URI 通常包含在响应头中，以便客户端应用程序可以立即检索和处理新创建的资源。`POST`
    请求中的数据可以是任何格式，如 JSON 或 XML，但通常使用 JSON 格式。
- en: DELETE
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DELETE
- en: The `DELETE` HTTP verb is used to *delete a resource from a server*. A `DELETE`
    request is used to remove the specified resource from the server. The `DELETE`
    verb is idempotent, which means that it can be called multiple times without any
    side effects. It is also not safe, meaning that it can modify the resource on
    the server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` HTTP 动词用于从服务器中删除资源。`DELETE` 请求用于从服务器中删除指定的资源。`DELETE` 动词是幂等的，这意味着它可以多次调用而不会产生任何副作用。它也不是安全的，意味着它可以修改服务器上的资源。'
- en: When a client sends a `DELETE` request to a RESTful API, the server deletes
    the specified resource and returns a response with a status code, indicating the
    outcome of the request. The most common status code for a successful `DELETE`
    request is `204 No Content`, indicating that the resource has been successfully
    deleted. The client usually doesn’t receive any content in the response body,
    only the status code. The `DELETE` request usually requires the URI of the resource
    to be specified in the request so that the server is able to identify which resource
    to delete.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向 RESTful API 发送 `DELETE` 请求时，服务器会删除指定的资源，并返回一个包含状态码的响应，指示请求的结果。对于成功的 `DELETE`
    请求，最常见的状态码是 `204 No Content`，表示资源已成功删除。客户端通常不会在响应体中收到任何内容，只有状态码。`DELETE` 请求通常需要在请求中指定资源的
    URI，以便服务器能够识别要删除的资源。
- en: It’s worth noting that some RESTful APIs may not allow `DELETE` requests and
    will return a `405 Method Not Allowed` status code if a `DELETE` request is received.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一些 RESTful API 可能不允许 `DELETE` 请求，如果收到 `DELETE` 请求，将返回 `405 Method Not
    Allowed` 状态码。
- en: PUT
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PUT
- en: The `PUT` HTTP verb is used to *update an existing resource or create a new
    one if it does not exist*. A `PUT` request is used to submit a representation
    of the resource to be updated or created. The representation of the resource is
    included in the request body and typically encoded in a format such as JSON or
    XML. The `PUT` verb is idempotent, which means that it can be called multiple
    times without any side effects. It is also not safe, meaning that it can modify
    the resource on the server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` HTTP 动词用于更新现有资源或（如果不存在）创建新资源。`PUT` 请求用于提交要更新或创建的资源表示。资源的表示包含在请求体中，通常以
    JSON 或 XML 等格式编码。`PUT` 动词是幂等的，这意味着它可以多次调用而不会产生任何副作用。它也不是安全的，意味着它可以修改服务器上的资源。'
- en: When a client sends a `PUT` request to a RESTful API, the server updates the
    specified resource with the data provided in the request body and returns a response
    with a status code, indicating the outcome of the request. The most common status
    code for a successful `PUT` request is `200 OK`, indicating that the resource
    has been successfully updated. If a new resource is created, the `201 Created`
    status code will be returned. The URI of the updated resource is typically included
    in the response headers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向 RESTful API 发送 `PUT` 请求时，服务器使用请求体中提供的数据更新指定的资源，并返回一个包含状态码的响应，指示请求的结果。成功的
    `PUT` 请求最常见的状态码是 `200 OK`，表示资源已成功更新。如果创建了新的资源，将返回 `201 Created` 状态码。更新资源的 URI
    通常包含在响应头中。
- en: It’s worth noting that `PUT` requests may require a client to send the full
    representation of the resource in the request body, including all properties,
    even if only a few of them are to be updated. This can make a `PUT` request inefficient
    in terms of bandwidth used, and it may be better to use the `PATCH` verb.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`PUT` 请求可能要求客户端在请求体中发送资源的完整表示，包括所有属性，即使只有少数属性需要更新。这可能会使 `PUT` 请求在带宽使用方面效率低下，可能更好的选择是使用
    `PATCH` 动词。
- en: PATCH
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PATCH
- en: The `PATCH` HTTP verb is used to *partially update an existing resource on a
    server*. A `PATCH` request is used to submit a set of changes to be made to the
    specified resource rather than replacing the entire resource. The set of changes
    is typically encoded in a format such as JSON or XML and is included in the request
    body. The `PATCH` verb is idempotent, which means that it can be called multiple
    times without any side effects. It is also not safe, meaning that it can modify
    the resource on the server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATCH` HTTP 动词用于在服务器上*部分更新现有的资源*。`PATCH` 请求用于提交要应用于指定资源的更改集，而不是替换整个资源。更改集通常以
    JSON 或 XML 等格式编码，并包含在请求体中。`PATCH` 动词是幂等的，这意味着它可以多次调用而不会产生任何副作用。它也不是安全的，这意味着它可以修改服务器上的资源。'
- en: In a RESTful API context, the `PATCH` verb is typically used to partially update
    an existing resource on the server. When a client sends a `PATCH` request to a
    RESTful API, the server applies the changes provided in the request body to the
    specified resource and returns a response with a status code indicating the outcome
    of the request. The most common status code for a successful `PATCH` request is
    `200 OK`, indicating that the resource has been successfully updated. The URI
    of the updated resource is typically included in the response headers. The data
    in a `PATCH` request can be in any format, such as JSON or XML.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 的上下文中，`PATCH` 动词通常用于在服务器上部分更新现有的资源。当客户端向 RESTful API 发送 `PATCH`
    请求时，服务器将请求体中提供的更改应用于指定的资源，并返回一个包含状态码的响应，指示请求的结果。成功的 `PATCH` 请求最常见的状态码是 `200 OK`，表示资源已成功更新。更新资源的
    URI 通常包含在响应头中。`PATCH` 请求中的数据可以是任何格式，例如 JSON 或 XML。
- en: It’s worth noting that `PATCH` requests require a client to send a specific
    set of changes to be made to the resource rather than the full representation
    of the resource. This makes `PATCH` requests more lightweight and efficient than
    `PUT` requests for partial updates.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`PATCH` 请求要求客户端发送要应用于资源的特定更改集，而不是资源的完整表示。这使得 `PATCH` 请求在部分更新方面比 `PUT`
    请求更轻量级和高效。
- en: Data transfer objects
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据传输对象
- en: Another important concept to understand when working with APIs is **data transfer
    objects** (**DTOs**). A DTO is a design pattern that is commonly used to transfer
    data between layers or systems. In the case of a RESTful API, this is typically
    to transfer data from the backend (API) to the frontend **user interface** (**UI**).
    The general purpose of DTOs is to decouple the structure of the data from the
    underlying systems that use it, allowing for more flexibility and easier maintenance.
    They also provide a standardized way to handle data, making it easier for different
    components of a system to communicate and exchange information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 API 一起工作时，另一个需要理解的重要概念是**数据传输对象**（**DTOs**）。DTO 是一种常用的设计模式，用于在层或系统之间传输数据。在
    RESTful API 的情况下，这通常是用于将后端（API）的数据传输到前端**用户界面**（**UI**）。DTO 的一般目的是将数据的结构与其使用的底层系统解耦，从而提供更大的灵活性和更易于维护。它们还提供了一种标准化的数据处理方式，使得系统中的不同组件之间的通信和交换信息变得更加容易。
- en: DTOs are particularly useful in RESTful APIs, as they provide a standard way
    to represent data when sending and receiving requests between a client and a server.
    When designing a RESTful API, the use of DTOs allows the API to define the structure
    of the data that is exchanged without having to tightly couple the implementation
    of the API to the structure of the data. This decoupling makes it easier to evolve
    the API and make changes to the underlying data model without affecting the API
    clients. Additionally, using DTOs enables the API to shape the data it returns
    to better match the needs of the client, reducing the amount of data transferred
    over the network and improving performance. Furthermore, DTOs can be used to validate
    the data being passed between the client and server, ensuring that only valid
    data is accepted and processed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs 在 RESTful API 中特别有用，因为它们提供了一个在客户端和服务器之间发送和接收请求时表示数据的标准方式。在设计 RESTful API
    时，使用 DTOs 允许 API 定义交换数据的结构，而无需将 API 的实现与数据的结构紧密耦合。这种解耦使得 API 更容易进化，并且可以在不影响 API
    客户端的情况下对底层数据模型进行更改。此外，使用 DTOs 可以使 API 修改返回的数据以更好地满足客户端的需求，减少通过网络传输的数据量，并提高性能。此外，DTOs
    还可以用来验证客户端和服务器之间传递的数据，确保只接受和处理有效数据。
- en: 'The first set of DTOs that we will see in this chapter will look a lot like
    the entity types that we defined for our database in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082)
    and [*Chapter 4*](B19343_04.xhtml#_idTextAnchor102), and they will relate to operations
    that we may wish to perform on the database. For example, the following entity
    type represents `Habit` in the database:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到的第一个 DTO 集将非常类似于我们在 [*第 3 章*](B19343_03.xhtml#_idTextAnchor082) 和
    [*第 4 章*](B19343_04.xhtml#_idTextAnchor102) 中为数据库定义的实体类型，并且它们将与我们可能希望对数据库执行的操作相关。例如，以下实体类型代表了数据库中的
    `Habit`：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s say that we wanted to create a simple `Habit` that only had a `Name`
    property populated and was tied to a certain `User`. We could send the following
    DTO:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个简单的 `Habit`，它只包含一个已填充的 `Name` 属性，并且与某个 `User` 相关联。我们可以发送以下 DTO：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This could be used by the backend to create a simple `GoodHabit` object in the
    database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被后端用来在数据库中创建一个简单的 `GoodHabit` 对象。
- en: 'If we wanted to retrieve the `GoodHabit` objects but only with the name and
    ID properties, we could use a DTO that looked like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想检索具有名称和 ID 属性的 `GoodHabit` 对象，我们可以使用一个看起来像这样的 DTO：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, if we needed more information than simply a name and an ID, we could further
    define another DTO that looked like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要比仅仅名称和 ID 更多的信息，我们可以进一步定义另一个看起来像这样的 DTO：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see how we can start with the entity type that has a lot of database-specific
    information, and we can selectively model that data in different ways for different
    use cases.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们如何从一个具有大量数据库特定信息的实体类型开始，并且我们可以根据不同的用例选择性地以不同的方式建模这些数据。
- en: We will illustrate this point with examples later in this chapter!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面通过示例来说明这一点！
- en: Designing better with REST
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REST 设计得更好
- en: Good design with RESTful APIs is essential to create an API that is easy to
    use and understand. One of the key principles of REST is that it is based on the
    use of resources and their representations. Therefore, it’s essential to design
    the API’s resources and their representations in a way that is meaningful and
    consistent.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RESTful API 进行良好的设计对于创建易于使用和理解的 API 至关重要。REST 的一个关键原则是它基于资源及其表示的使用。因此，设计
    API 的资源和它们的表示方式，使其有意义且一致是至关重要的。
- en: When designing resources, it’s important to use URIs that are meaningful and
    consistent. Resources should be named in a way that is easy to understand, and
    the URIs should be structured logically and hierarchically – for example, `/users/1/orders/2`
    is more meaningful than `/users?id=1&orderid=2`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计资源时，使用有意义的和一致的 URI 非常重要。资源应该以易于理解的方式命名，并且 URI 应该以逻辑和层次结构的方式组织 – 例如，`/users/1/orders/2`
    比起 `/users?id=1&orderid=2` 更有意义。
- en: Representations of resources should be in a format that is easy to parse, such
    as JSON or XML. It’s also important to use the `Content-Type` and `Accept` headers
    to specify the format of the request and response. This allows the client to specify
    its preferred format and the server to provide the appropriate representation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的表现形式应该是一个易于解析的格式，例如 JSON 或 XML。同时，使用 `Content-Type` 和 `Accept` 头部来指定请求和响应的格式也很重要。这允许客户端指定其首选的格式，服务器提供适当的表示。
- en: Another important aspect of a good RESTful API design is stateless communication.
    This means that a client and server should not maintain any state between requests.
    This can be achieved through the use of HTTP headers and cookies. This allows
    for a higher degree of scalability and flexibility, as the server does not have
    to maintain any state for each client.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的 RESTful API 设计的另一个重要方面是无状态通信。这意味着客户端和服务器在请求之间不应保持任何状态。这可以通过使用 HTTP 头和 cookie
    来实现。这允许更高的可扩展性和灵活性，因为服务器不需要为每个客户端维护任何状态。
- en: Security is also an important aspect of RESTful API design. It’s important to
    use secure communication protocols, such as HTTPS, and to implement authentication
    and authorization mechanisms to protect an API’s resources.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性也是 RESTful API 设计的一个重要方面。使用安全的通信协议，如 HTTPS，以及实现身份验证和授权机制来保护 API 的资源是很重要的。
- en: 'In addition to the aforementioned points, good RESTful API design also includes
    error handling, caching, versioning, and documentation. Good documentation is
    essential for developers to understand how to use the API. It’s also important
    to provide clear and informative error messages to clients when an error occurs.
    In the previous chapter, we built up a database. In this chapter, we’ll now add
    an API to interact with the database that we built. We will use a very typical
    layer structure for a SaaS app that looks something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述要点外，良好的 RESTful API 设计还包括错误处理、缓存、版本控制和文档。良好的文档对于开发者理解如何使用 API 是必不可少的。当发生错误时，向客户端提供清晰且信息丰富的错误消息也很重要。在前一章中，我们建立了一个数据库。在本章中，我们将现在添加一个
    API 来与我们所构建的数据库交互。我们将使用一个非常典型的 SaaS 应用程序层结构，看起来像这样：
- en: '![Figure 5.1 – The layering structure](img/B19343_05_01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 层次结构](img/B19343_05_01.jpg)'
- en: Figure 5.1 – The layering structure
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 层次结构
- en: In the preceding diagram, we can see the database and the **object–relational
    mapping** (**ORM**) that we covered in previous chapters. In this chapter, we
    are learning about the API, so we will build a service layer to interact with
    the database and a controller layer to handle communication with the UI or any
    other client.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到我们之前章节中提到的数据库和**对象关系映射**（**ORM**）。在本章中，我们将学习关于 API 的内容，因此我们将构建一个服务层来与数据库交互，以及一个控制器层来处理与
    UI 或任何其他客户端的通信。
- en: A service layer is an architectural pattern in software design that acts as
    an intermediary between the application’s UI and the underlying data storage.
    The main purpose of a service layer is to encapsulate and abstract the business
    logic of an application, promoting the separation of concerns and making it easier
    to maintain and modify the code. It also enables better unit testing, as the service
    layer can be tested in isolation from the rest of the application. Additionally,
    it can improve the scalability of an application by allowing the UI and data storage
    components to evolve independently.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层是软件设计中的一个架构模式，它充当应用程序的 UI 和底层数据存储之间的中介。服务层的主要目的是封装和抽象应用程序的业务逻辑，促进关注点的分离，并使代码的维护和修改更容易。它还允许更好的单元测试，因为服务层可以在与应用程序的其他部分隔离的情况下进行测试。此外，它可以通过允许
    UI 和数据存储组件独立演变来提高应用程序的可扩展性。
- en: In a RESTful API, controllers are responsible for handling HTTP requests from
    clients and returning appropriate HTTP responses. They act as an intermediary
    between a client and an application’s business logic, using the appropriate service
    layer to perform any necessary operations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 中，控制器负责处理来自客户端的 HTTP 请求并返回适当的 HTTP 响应。它们充当客户端和应用程序业务逻辑之间的中介，使用适当的服务层执行任何必要的操作。
- en: Controllers are responsible for mapping URLs to specific actions in an application,
    such as retrieving data from a database, creating new resources, or updating existing
    ones. They parse an incoming request to determine the desired action and then
    use the appropriate service layer to perform that action and generate a response.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器负责将 URL 映射到应用程序中的特定操作，例如从数据库检索数据、创建新资源或更新现有资源。它们解析传入的请求以确定所需操作，然后使用适当的服务层执行该操作并生成响应。
- en: An example API design
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例 API 设计
- en: You will recall that in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), we
    started to build out the `HabitService` API with a couple of endpoints. We’ll
    start from where we left off in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082),
    but we will add a lot more functionality to the controller!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会记得，在 [*第3章*](B19343_03.xhtml#_idTextAnchor082) 中，我们开始构建 `HabitService` API，并添加了一些端点。我们将从
    [*第3章*](B19343_03.xhtml#_idTextAnchor082) 中我们停止的地方开始，但我们将向控制器添加更多功能！
- en: 'The three endpoints that we have already added are the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加的三个端点是以下这些：
- en: 'A `GET` endpoint that gets a single habit based on a passed-in ID:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `GET` 端点，根据传入的 ID 获取单个习惯：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another `GET` endpoint that returns all of the habits:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `GET` 端点，用于返回所有习惯：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And finally, a `POST` endpoint that will create a new habit in the database:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个用于在数据库中创建新习惯的 `POST` 端点：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we will add an endpoint for each of the five primary HTTP verbs
    that we have discussed in this chapter. We already have `GET` and `POST`, so we
    will add `PUT`, `PATCH`, and `DELETE`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为本章讨论的五个主要 HTTP 动词中的每一个添加一个端点。我们已经有 `GET` 和 `POST`，所以我们将添加 `PUT`、`PATCH`
    和 `DELETE`。
- en: DTOs
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DTOs
- en: 'But, before we write the endpoints, we will first add the DTOs. We already
    have a `CreateHabitDto` that was added in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082).
    Run the following script from the root folder, or add the files manually:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们编写端点之前，我们首先会添加 DTOs。我们已经在 [*第3章*](B19343_03.xhtml#_idTextAnchor082) 中添加了
    `CreateHabitDto`。从根目录运行以下脚本，或者手动添加文件：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Copy the following into the `HabitDetailDto` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制到 `HabitDetailDto` 类中：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then add the following to the `HabitDto` class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下内容添加到 `HabitDto` 类中：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And finally, add the following to the `UpdateHabitDto` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下内容添加到 `UpdateHabitDto` 类中：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That is all that is required for the DTOs. We will use these when we start to
    build out the endpoints.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DTOs，这就足够了。当我们开始构建端点时，我们将使用这些。
- en: AutoMapper
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AutoMapper
- en: We now need to consider a tool that we will use to convert between the database
    types and the DTOs. That tool is AutoMapper.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要考虑一个工具，我们将使用它来在数据库类型和 DTOs 之间进行转换。这个工具就是 AutoMapper。
- en: AutoMapper is an open source library that enables you to establish a configuration
    to convert one object to another. This can be particularly useful when translating
    between different types of objects, such as database entities and DTOs. Even though
    both the DTO and the entities might have a similar structure, their implementation
    can differ. This library helps to keep your codebase clean and maintainable by
    reducing the amount of repetitive and boilerplate mapping code that is needed
    to translate between different types, making your application more efficient and
    easier to modify or add new features.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper 是一个开源库，它允许你建立配置以将一个对象转换为另一个对象。这在将不同类型的对象（如数据库实体和 DTOs）之间进行转换时尤其有用。尽管
    DTO 和实体可能具有相似的结构，但它们的实现可能不同。这个库通过减少在不同类型之间转换所需的重复和样板映射代码量，有助于保持你的代码库整洁和可维护，使你的应用程序更高效，更容易修改或添加新功能。
- en: 'AutoMapper is designed to make it easy to map one type of object to another,
    and it provides a simple, fluent API to define the mappings. Some of the key features
    of AutoMapper include:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper 被设计成简化将一种类型的对象映射到另一种类型的过程，并提供了一个简单、流畅的 API 来定义映射。AutoMapper 的一些关键特性包括：
- en: Support for flattening and unflattening of object hierarchies
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持对象层次结构的展开和折叠
- en: Support for converting between different data types and custom-type converters
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持在不同数据类型和自定义类型转换器之间进行转换
- en: Support for advanced configuration options, such as mapping to and from interfaces
    and inheritance hierarchies
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持高级配置选项，例如映射到和从接口以及继承层次结构
- en: Support for custom logic and conventions to be used during mapping
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持在映射过程中使用自定义逻辑和约定
- en: Support for **Language Integrated Query** (**LINQ**) expressions to define mappings
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用 **语言集成查询**（**LINQ**）表达式来定义映射
- en: AutoMapper can help to keep your codebase clean and maintainable by reducing
    the amount of repetitive, boilerplate mapping code that is required to convert
    between different types. This can make your application more efficient, and it
    makes it easier to add new features or make changes to existing ones.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper 可以通过减少在不同类型之间转换所需的重复、样板映射代码量，帮助你保持代码库整洁和可维护。这可以使你的应用程序更高效，并使添加新功能或修改现有功能变得更加容易。
- en: 'To get started with AutoMapper, install the tool in the API project with the
    following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 AutoMapper，请在 API 项目中使用以下命令安装工具：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the packages updated, as shown in the preceding code snippet, we can start
    to create mappings for the database types that we have created.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码片段所示，更新了包后，我们可以开始为创建的数据库类型创建映射。
- en: You will recall that we added an entity type called ‘Habit’ in the database
    project in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), and we have added
    a number of additional properties to the object in [*Chapter 4*](B19343_04.xhtml#_idTextAnchor102).
    If you run the `HabitService` and use Thunder Client to hit the endpoint that
    returns all of the habits, you will see that the data which is returned includes
    all of these additional properties.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得我们在数据库项目中添加了一个名为“Habit”的实体类型，在 [*第 3 章*](B19343_03.xhtml#_idTextAnchor082)
    中，我们还在 [*第 4 章*](B19343_04.xhtml#_idTextAnchor102) 中为该对象添加了多个附加属性。如果您运行 `HabitService`
    并使用 Thunder Client 打击返回所有习惯的端点，您将看到返回的数据包括所有这些附加属性。
- en: This habit class represents a database entity. It is very specific to the database
    and works very well to represent the idea of a good habit for that specific use
    case. But, it does not work well to transmit data to the UI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个习惯类代表了一个数据库实体。它非常具体于数据库，并且非常适合代表特定用例中良好习惯的概念。但是，它不适合将数据传输到 UI。
- en: We would rather that the data was sent to the UI in the form of a DTO, such
    as the one we created previously.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更希望数据以 DTO 的形式发送到 UI，就像我们之前创建的那样。
- en: There is no need to include the collections for the progress updates or the
    reminders. Including this information could add a huge amount to the required
    bandwidth of the app.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要包括进度更新或提醒的集合。包含这些信息可能会大大增加应用程序所需的带宽。
- en: The `TenentName` property is of no use to the user because they will already
    know which tenant they are!
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TenentName` 属性对用户没有用处，因为他们已经知道他们属于哪个租户！'
- en: 'The DTO that we have created looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 DTO 看起来是这样的：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we are taking the ID, name, and description of the habit directly
    from the entity type, but more complex transformations are also possible.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们直接从实体类型中获取习惯的 ID、名称和描述，但更复杂的转换也是可能的。
- en: While we could simply copy the properties over manually, that could quickly
    get very tedious, so we’ll use `AutoMapper` to do this automatically!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以简单地手动复制属性，但这可能会很快变得非常乏味，所以我们将使用 `AutoMapper` 自动完成这项工作！
- en: 'Start by going into the `Program.cs` class and adding the `AutoMapper` service:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进入 `Program.cs` 类并添加 `AutoMapper` 服务：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, open up the `HabitsController` class, and add the following to the `using`
    statements: using `AutoMapper`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `HabitsController` 类，并在 `using` 语句中添加以下内容：`using AutoMapper`。
- en: 'Then, add the following to the class definition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在类定义中添加以下内容：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add the `using` statement:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加 `using` 语句：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, modify the constructor to take in the mapper, like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改构造函数以接受映射器，如下所示：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, modify the two existing `GET` endpoints in the controller to use `AutoMapper`,
    like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改控制器中现有的两个 `GET` 端点以使用 `AutoMapper`，如下所示：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before, the controller was simply returning the entity object from the database,
    now that object is being mapped automatically to a DTO, which is returned from
    the controller. This does require a little configuration, though.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，控制器只是简单地从数据库返回实体对象，现在该对象正在自动映射到一个 DTO，该 DTO 由控制器返回。但这确实需要一点配置。
- en: The final step is to tell `AutoMapper` how it should convert between the two
    types.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是告诉 `AutoMapper` 如何在两种类型之间进行转换。
- en: 'Add a folder called `Mappers` in the `HabitService` project and a class called
    `HabitMapper.cs`. You can use this script:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HabitService` 项目中添加一个名为 `Mappers` 的文件夹和一个名为 `HabitMapper.cs` 的类。您可以使用以下脚本：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this class, add the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，添加以下内容：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `CreateMap` method instructs `AutoMapper` to map between the two types.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateMap` 方法指示 `AutoMapper` 在两种类型之间进行映射。'
- en: 'You can now hit the endpoint using Thunder Client to get the habits, and you
    should see something like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 Thunder Client 打击端点以获取习惯，您应该看到如下内容：
- en: '![Figure 5.2 – A successful response](img/B19343_05_02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 成功的响应](img/B19343_05_02.jpg)'
- en: Figure 5.2 – A successful response
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 成功的响应
- en: This section has demonstrated how we can automatically convert between database
    types and types for data transfer. This is a very important piece of the API puzzle,
    and understanding how to operate AutoMapper will help you write better code and
    also reduce the amount of data sent between the API and any connected clients.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了我们如何自动在数据库类型和数据传输类型之间进行转换。这是API拼图中的一个非常关键的组成部分，理解如何操作AutoMapper将帮助你编写更好的代码，并减少API和任何连接的客户端之间传输的数据量。
- en: Modify the service
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改服务
- en: Before we can build the additional endpoints on the API to update and delete
    the habits, we need to add some functionality to the service class. We already
    created the service class and interface in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082),
    but we will extend the functionality here.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在API上构建更新和删除习惯的额外端点之前，我们需要在服务类中添加一些功能。我们已经在[*第3章*](B19343_03.xhtml#_idTextAnchor082)中创建了服务类和接口，但我们将在这里扩展其功能。
- en: 'Add the following to the interface:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到接口中：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `HabitService` class that implements the preceding interface will need
    to have two methods added to delete and update the habits that are stored in the
    database. Add the following two methods to the `HabitService` class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实现前面接口的`HabitService`类需要添加两个方法来删除和更新存储在数据库中的习惯。将以下两个方法添加到`HabitService`类中：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will also need to add a `using` statement to the service class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在服务类中添加一个`using`语句：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That is all that is required in the service layer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层中所需的所有内容都已添加。
- en: That has been quite a lot of configuration, but we are now ready to build the
    controller class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经有很多配置了，但我们现在准备好构建控制器类。
- en: Add to the controller
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加到控制器
- en: 'We have done most of the heavy lifting already by adding the DTOs, configuring
    AutoMapper, and building the service layer. We will need to add three additional
    endpoints to the controller. Let’s start with the `DELETE` endpoint:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过添加DTOs、配置AutoMapper和构建服务层完成了大部分繁重的工作。我们需要在控制器中添加三个额外的端点。让我们从`DELETE`端点开始：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is pretty straightforward. It uses the service method to delete the entry
    in the database and then returns `NoContent` – which is considered best practice
    for a delete method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接。它使用服务方法来删除数据库中的条目，然后返回`NoContent`——这是删除方法的最佳实践。
- en: 'Next, add the endpoint to update the object with the `PUT` verb:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加使用`PUT`动词更新对象的端点：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There is some error trapping here, which returns `404` if the client attempts
    to update an entry that does not exist.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些错误处理，如果客户端尝试更新一个不存在的条目，它将返回`404`。
- en: 'Finally, add the endpoint that updates an object using the `PATCH` verb:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加使用`PATCH`动词更新对象的端点：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is a little more involved, as it uses `JsonPatchDocument` to modify the
    object. You will also need to add two `using` statements:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容稍微复杂一些，因为它使用了`JsonPatchDocument`来修改对象。你还需要添加两个`using`语句：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That is all that we need to do at this stage. We now have a good example of
    the five most common HTTP verbs. Before we move on, we should test that these
    all work. We will use Thunder Client for this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需要做这些。现在我们有一个很好的例子，展示了五种最常见的HTTP动词。在我们继续之前，我们应该测试这些是否都正常工作。我们将使用Thunder
    Client进行测试。
- en: Testing
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: To test the endpoint that we have just added, we will need a test client. In
    keeping with the theme of using **Visual Studio Code** (**VS Code**), we will
    add an extension to the code so that we can do everything in one place. We have
    touched on this tool a couple of times already, but we will take a close look
    in this section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们刚刚添加的端点，我们需要一个测试客户端。遵循使用**Visual Studio Code**（**VS Code**）的主题，我们将向代码中添加一个扩展，以便我们可以在一个地方完成所有操作。我们已经提到了这个工具几次，但我们将在本节中对其进行详细探讨。
- en: 'You’ll see the Thunder Client icon on the extensions toolbar:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在扩展工具栏上看到Thunder Client图标：
- en: '![Figure 5.3 – The Thunder Client icon](img/B19343_05_03.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – Thunder Client图标](img/B19343_05_03.jpg)'
- en: Figure 5.3 – The Thunder Client icon
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – Thunder Client图标
- en: 'With Thunder Client, you can hit your API straight from VS Code and check that
    it is behaving as expected. We’ll do this now. Start the API running by going
    to the terminal in VS Code, navigating to the API project, and typing the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Thunder Client，你可以直接从VS Code中调用你的API并检查其是否按预期运行。我们现在就做这个。通过在VS Code的终端中启动API，导航到API项目，并输入以下内容来启动API：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will build the project and get the API running. Now we can start adding
    the tests!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建项目并启动API。现在我们可以开始添加测试了！
- en: Add a GET request
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个GET请求
- en: 'Now, complete the following steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成以下步骤：
- en: Click on the Thunder Client icon (*if you don’t see this on the left-hand menu,
    exit and restart the* *Docker environment*).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Thunder Client图标（如果你在左侧菜单中看不到它，退出并重新启动* *Docker环境*）。
- en: Click on the `GoodHabits`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`GoodHabits`。
- en: '*Right-click* on the newly created collection, click `GET` Habits (don’t click
    on the bit below the **New Request** button; right-click the collection).'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的集合上*右键点击*，点击`GET`习惯（不要点击在**新请求**按钮下面的部分；右键点击集合）。
- en: 'Your collection should look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你的集合应该看起来像这样：
- en: '![Figure 5.4 – The Thunder Client collection](img/B19343_05_04.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – Thunder Client集合](img/B19343_05_04.jpg)'
- en: Figure 5.4 – The Thunder Client collection
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – Thunder Client集合
- en: Click on the `tenant` key with the `CloudSphere` value (you’ll remember from
    [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082) that we need to specify the tenant
    for the multi-tenancy).
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击带有`CloudSphere`值的`tenant`键（你会记得从[*第3章*](B19343_03.xhtml#_idTextAnchor082)中，我们需要为多租户指定租户）。
- en: 'When you’re done, it should look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，它应该看起来像这样：
- en: '![Figure 5.5 – The configured request](img/B19343_05_05.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 配置的请求](img/B19343_05_05.jpg)'
- en: Figure 5.5 – The configured request
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 配置的请求
- en: The preceding screenshot shows a correctly configured `GET` request that should
    return all of the habits in the database.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了一个正确配置的`GET`请求，它应该返回数据库中的所有习惯。
- en: 'Finally, click the `GET` request and test the endpoint. You will see the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击`GET`请求并测试端点。你会看到以下内容：
- en: '![Figure 5.6 – The returned habits](img/B19343_05_06.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 返回的习惯](img/B19343_05_06.jpg)'
- en: Figure 5.6 – The returned habits
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 返回的习惯
- en: We have put in quite a lot of work to get to this stage! We are showing the
    data from the `SeedData` file in the database project, returned from our `HabitsService`.
    We will shortly build a UI to present this information.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了达到这个阶段投入了相当多的工作！我们正在展示数据库项目中`SeedData`文件的数据，这些数据是从我们的`HabitsService`返回的。我们很快将构建一个UI来展示这些信息。
- en: Add a POST request
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个POST请求
- en: 'Repeat the preceding, building a `POST`user request. In this case, we’ll need
    to specify the habit details in the body in JSON format:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 重复前面的步骤，构建一个`POST`用户请求。在这种情况下，我们需要在正文中以JSON格式指定习惯详情：
- en: '![Figure 5.7 – The configured POST request](img/B19343_05_07.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 配置的POST请求](img/B19343_05_07.jpg)'
- en: Figure 5.7 – The configured POST request
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 配置的POST请求
- en: You can see that the JSON specified matches the `CreateHabitDto` class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到指定的JSON与`CreateHabitDto`类匹配。
- en: Don’t forget to set the tenant in the header and change the request type to
    `POST`! Hitting **Send** will confirm that the habit has been created.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在头部设置租户并将请求类型更改为`POST`！点击**发送**将确认习惯已被创建。
- en: So far, we have tested the `get all` endpoint and the `POST` endpoint. It would
    be a useful exercise to add another `GET` to test the `get-by-id` endpoint as
    well!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经测试了`get all`端点和`POST`端点。添加另一个`GET`来测试`get-by-id`端点也是一个有用的练习！
- en: Add a DELETE request
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个DELETE请求
- en: 'We may want to delete a habit from the database, so we have added the required
    methods to the service and the controller. We can test this again in the same
    way:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要从数据库中删除一个习惯，因此我们已经向服务和控制器中添加了所需的方法。我们可以以同样的方式再次测试：
- en: '![Figure 5.8 – The configured DELETE request](img/B19343_05_08.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 配置的DELETE请求](img/B19343_05_08.jpg)'
- en: Figure 5.8 – The configured DELETE request
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 配置的DELETE请求
- en: The preceding screenshot shows that no content is required in the body. But
    don’t forget to add the tenant header!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示在正文中不需要任何内容。但不要忘记添加租户头部！
- en: Add a PUT request
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个PUT请求
- en: 'Testing the `PUT` endpoint that we have added is fairly straightforward. Configure
    a `PUT` request like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们添加的`PUT`端点是相当直接的。配置一个像这样的`PUT`请求：
- en: '![Figure 5.9 – The configured PUT request](img/B19343_05_09.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 配置的PUT请求](img/B19343_05_09.jpg)'
- en: Figure 5.9 – The configured PUT request
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 配置的PUT请求
- en: The preceding figure shows how to configure a `PUT` request. This will alter
    the name and description of the habit with `id=103`. You may need to change the
    ID in the URL if you have made changes to the data along the way. You can check
    that this has made the changes by hitting the `get-by-id` endpoint again.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了如何配置一个`PUT`请求。这将更改`id=103`的习惯的名称和描述。如果你在过程中对数据进行过更改，可能需要更改URL中的ID。你可以通过再次点击`get-by-id`端点来检查是否已进行了更改。
- en: Add a PATCH request
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个PATCH请求
- en: 'Testing the `PATCH` endpoint is a little more tricky. You will recall that
    the `PATCH` endpoint that we built in the controller is expecting a `JsonPatchDocument`
    object, so this is what we will have to supply. A `Patch` document could look
    like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `PATCH` 端点稍微有些棘手。您会记得，我们在控制器中构建的 `PATCH` 端点期望一个 `JsonPatchDocument` 对象，因此这就是我们必须提供的。一个
    `Patch` 文档可能看起来像这样：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code uses the `replace` operator to change the value of the `Name`
    variable. We can set up the request like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用 `replace` 操作符来更改 `Name` 变量的值。我们可以这样设置请求：
- en: '![Figure 5.10 – The configured PATCH request](img/B19343_05_10.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 配置的 PATCH 请求](img/B19343_05_10.jpg)'
- en: Figure 5.10 – The configured PATCH request
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 配置的 PATCH 请求
- en: Configuring this and hitting send will update the habit with `id=103`. Again,
    you may need to change the ID in the URL.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 配置此设置并点击发送将更新具有 `id=103` 的习惯。再次提醒，您可能需要更改 URL 中的 ID。
- en: You will notice that the service will return a `204 No Content` response upon
    a successful patch. This is the expected behavior and is considered best practice
    for the response to a successful `PATCH`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在成功修补后，服务将返回 `204 No Content` 响应。这是预期的行为，并且被认为是成功 `PATCH` 响应的最佳实践。
- en: This would be a good time to talk a bit more about HTTP codes!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是讨论更多关于 HTTP 状态码的好时机！
- en: Using the correct HTTP codes
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用正确的 HTTP 状态码
- en: Earlier in this chapter, we talked about HTTP status codes, and we looked at
    a few that may be useful to consider, even for the very basic examples we saw
    previously.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们讨论了 HTTP 状态码，并查看了一些可能对基本示例有用的状态码。
- en: 'The two that we should add and test are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加并测试的两个是以下内容：
- en: If a request is made to get a user that does not exist, the correct status code
    should be `404` `Not found`
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求获取一个不存在的用户，正确的状态码应该是 `404` `未找到`
- en: If a successful request is made to create a new user, the correct status code
    should be `201 Created`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果成功请求创建一个新用户，正确的状态码应该是 `201 Created`
- en: Because we have separated the service and the controller, we do not have to
    change any of the service logic to facilitate this. The controller has the sole
    responsibility for assigning the HTTP status codes. While the example here is
    fairly straightforward, I hope you can see how separating the logic in this way
    can be very beneficial when things start to get more complex.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将服务和控制器分离，我们不需要更改任何服务逻辑来促进这一点。控制器负责分配 HTTP 状态码。虽然这里的例子相当直接，但我希望您能看出以这种方式分离逻辑在事情变得复杂时非常有好处。
- en: 'We’ll start by modifying the `GET` method, which takes an `id` parameter to
    look like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从修改 `GET` 方法开始，该方法接受一个 `id` 参数，如下所示：
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have simply added a check to see whether the user object is `null`, and if
    so, we return `NotFound()`, which will return the `404` status code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是添加了一个检查，看看用户对象是否为 `null`，如果是，则返回 `NotFound()`，这将返回 `404` 状态码。
- en: 'You can test this in Thunder Client by requesting a user ID that you know doesn’t
    exist in your database:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Thunder Client 中通过请求一个您知道在数据库中不存在的用户 ID 来测试这一点：
- en: '![Figure 5.11 – Habit not found](img/B19343_05_11.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 未找到习惯](img/B19343_05_11.jpg)'
- en: Figure 5.11 – Habit not found
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 未找到习惯
- en: In the preceding screenshot, we have demonstrated that requesting a non-existent
    user now results in a `404` HTTP status code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们演示了请求一个不存在的用户现在会导致 `404` HTTP 状态码。
- en: 'Next, let’s fix the HTTP code to create a new user. Modify the `Create` endpoint
    to look like the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们修复创建新用户的 HTTP 状态码。将 `Create` 端点修改如下：
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have changed the return from `Ok()` to `CreatedAtAction(…)`. This will return
    `201 – Created` and also the location of the newly created resource to the user.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将返回值从 `Ok()` 更改为 `CreatedAtAction(…)`。这将返回 `201 – Created` 以及新创建的资源位置给用户。
- en: 'If you go back into Thunder Client and create another user, you will see the
    following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回到 Thunder Client 并创建另一个用户，您将看到以下内容：
- en: '![Figure 5.12 – Created with a 201 status code](img/B19343_05_12.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 使用 201 状态码创建](img/B19343_05_12.jpg)'
- en: Figure 5.12 – Created with a 201 status code
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 使用 201 状态码创建
- en: Clicking on the **Headers** tab will give you the location of the newly created
    resource. This can be very useful to consumers of your API who may want to interact
    with the new resource immediately.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Headers** 选项卡将给出新创建资源的位置。这对希望立即与新资源交互的 API 消费者非常有用。
- en: If you look at the `PUT` and the `PATCH` endpoints in `HabitsController`, you
    can see that we are returning a few different status codes depending on what has
    happened when processing the response. It would be a good exercise to go through
    these and convince yourself that you have understood why each of them has been
    selected.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`HabitsController`中的`PUT`和`PATCH`端点，你会看到我们根据处理响应时发生的情况返回几个不同的状态码。这是一个很好的练习，你可以通过这些来确信你已经理解了为什么选择了每一个。
- en: 'If you look at the `PATCH` endpoint, you will see that it performs the following
    actions:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`PATCH`端点，你会看到它执行以下操作：
- en: It checks to see whether the ID provided is valid and, if not, returns `404
    –` `Not Found`
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会检查提供的ID是否有效，如果不是，则返回`404 –` `Not Found`。
- en: It checks to see whether the updated model is valid and, if not, returns a validation
    problem (a subset of `400` `Bad Request`)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会检查更新的模型是否有效，如果不是，则返回一个验证问题（`400` `Bad Request`的一个子集）。
- en: If there are any other issues with the update, it returns `400` `Bad Request`
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果更新有任何其他问题，它返回`400` `Bad Request`。
- en: If there are no issues, it returns `204` `No Content`
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有问题，它返回`204` `No Content`。
- en: The `No Content` HTTP status code (`204`) is used to indicate that the server
    has successfully processed the request and that there is no response body to return.
    In the case of a `PATCH` request, the `No Content` status code is used to indicate
    that the server has successfully processed the update to the resource without
    returning any content in the response. The idea is that the client already knows
    what the updated resource looks like, and therefore, there is no need to return
    the updated resource information in the response. The client can simply assume
    that the update was successful and that the resource was updated as requested.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`No Content` HTTP状态码（`204`）来表示服务器已成功处理请求，并且没有响应体需要返回。在`PATCH`请求的情况下，`No Content`状态码用于表示服务器已成功处理对资源的更新，但在响应中未返回任何内容。其理念是客户端已经知道更新后的资源看起来是什么样子，因此没有必要在响应中返回更新后的资源信息。客户端可以简单地假设更新已成功，并且资源已按请求更新。
- en: Versioning public APIs
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共API的版本控制
- en: Versioning public RESTful APIs is the process of creating and maintaining multiple
    versions of an API to accommodate changes and new features. This ensures that
    existing clients are not affected by changes made to the API and that new clients
    can take advantage of the new features.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制公共RESTful API是创建和维护多个API版本的过程，以适应更改和新功能。这确保了现有客户端不会受到对API所做的更改的影响，并且新客户端可以利用新功能。
- en: Versioning is a critical aspect of API development and maintenance because it
    enables the evolution of an API over time while maintaining compatibility with
    existing clients. This is particularly important in cases where APIs are used
    by multiple clients, and breaking changes would impact the functionality of those
    clients. With versioning, multiple versions of an API can coexist, and clients
    can choose to upgrade to the latest version or continue using an earlier version
    that suits their needs. This way, versioning provides the necessary flexibility
    for APIs to evolve and improve over time without disrupting the stability of existing
    integrations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是API开发和维护的关键方面，因为它使得API随着时间的推移而演变，同时保持与现有客户端的兼容性。这在API被多个客户端使用的情况下尤为重要，因为破坏性更改会影响这些客户端的功能。通过版本控制，可以同时存在多个API版本，客户端可以选择升级到最新版本或继续使用满足其需求的早期版本。这样，版本控制为API随着时间的推移而演变和改进提供了必要的灵活性，而不会破坏现有集成的稳定性。
- en: 'There are several strategies to version RESTful APIs, each with its own advantages
    and disadvantages:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种策略可以用于版本控制RESTful API，每种策略都有其自身的优缺点：
- en: '`/v1/users` or `/v2/users`. This approach is easy to implement and understand,
    but it can be difficult to maintain and scale as the number of versions increases.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v1/users`或`/v2/users`。这种方法易于实现和理解，但随着版本数量的增加，可能难以维护和扩展。'
- en: '`X-API-Version`. This approach allows for more flexibility, as the URI does
    not have to change, but it can be more complex to implement and may not be supported
    by all clients.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-API-Version`。这种方法允许更大的灵活性，因为URI不需要改变，但它可能更复杂来实现，并且可能不被所有客户端支持。'
- en: '`application/vnd.example.v1+json` or `application/vnd.example.v2+json`. This
    approach allows for more flexibility, as the URI and headers do not have to change,
    but it can be more complex to implement and may not be supported by all clients.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/vnd.example.v1+json` 或 `application/vnd.example.v2+json`。这种方法提供了更大的灵活性，因为URI和头信息不需要更改，但实现起来可能更复杂，并且可能不被所有客户端支持。'
- en: '**Deprecation and sunsetting**: This strategy involves marking old versions
    of the API as deprecated and eventually sunsetting them. This approach allows
    for a gradual transition and gives clients time to update their code before the
    old version is removed.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弃用和停用**：这种策略涉及将API的旧版本标记为弃用，并最终将其停用。这种方法允许逐步过渡，并为客户端提供时间在旧版本被移除之前更新他们的代码。'
- en: It is worth noting that the most appropriate versioning strategy will depend
    on the specific needs of an API and its clients. It’s important to communicate
    the versioning strategy and the timeline for the deprecation of old versions to
    the API’s clients in order to minimize disruption and allow them to plan accordingly.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，最合适的版本控制策略将取决于API及其客户端的具体需求。向API的客户端传达版本控制策略和旧版本弃用的时间表，以最小化中断并允许他们相应地规划，这是非常重要的。
- en: 'The most common way to version an API is to include the version number in the
    URL of the API endpoint. For example, the URL of an API endpoint might look like
    this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为API进行版本控制最常见的方式是将版本号包含在API端点的URL中。例如，API端点的URL可能看起来像这样：
- en: '[PRE32]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method allows different versions of an API to coexist and makes it easy
    to manage changes to the API over time by simply changing the version number in
    the URL. This also allows clients to choose which version of the API they want
    to use in their applications, and it helps prevent breaking changes in the API
    from affecting existing client applications.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许不同版本的API共存，并且通过简单地更改URL中的版本号，就可以轻松地管理API随时间的变化。这也允许客户端选择他们希望在应用程序中使用的API版本，并有助于防止API的破坏性更改影响现有的客户端应用程序。
- en: 'If a second version of the preceding example was created, it could be found
    at the following link:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建了前面示例的第二版本，它可以在以下链接中找到：
- en: '[PRE33]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A huge benefit of this is that both versions can exist at the same time and
    users who have clients that still expect the `v1` version can continue to work
    seamlessly. Of course, supporting multiple versions can be hard, and ideally,
    this would be a transient state with the intention to deprecate the `v1` version
    at some point.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个好处是，两个版本可以同时存在，并且那些仍然期望`v1`版本的客户端用户可以无缝地继续工作。当然，支持多个版本可能很困难，理想情况下，这应该是一个过渡状态，目的是在某个时候弃用`v1`版本。
- en: Example code showing how to version an API
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码展示如何对API进行版本控制
- en: 'Previously in this chapter, we built a controller to manage the users and added
    a number of endpoints to it. We have not yet added any versioning to the API,
    though; note that the URLs that we have tested with (using Thunder Client) do
    not have a version associated with them, such as the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们构建了一个控制器来管理用户，并向其添加了多个端点。尽管如此，我们还没有为API添加任何版本控制；请注意，我们使用Thunder Client测试的URL没有与它们关联的版本，如下所示：
- en: '[PRE34]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let’s change that!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变一下！
- en: 'Start by opening a console and adding the versioning package to the `HabitService`
    project:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开控制台，并将版本控制包添加到`HabitService`项目中：
- en: '[PRE35]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the `using` statement into `Program.cs`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将`using`语句添加到`Program.cs`文件中：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, copy the following into `Program.cs`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下内容复制到`Program.cs`文件中：
- en: '[PRE37]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s review the preceding code in detail:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细回顾一下前面的代码：
- en: The first flag sets the default API version. This allows a client to work with
    the API without specifying a version.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个标志设置默认的API版本。这允许客户端在无需指定版本的情况下与API一起工作。
- en: The second flag instructs the application to use the default if nothing is specified.
    This is an example of defensive programming – your users will thank you for this!
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个标志指示应用程序在没有指定任何内容时使用默认版本。这是一个防御性编程的例子——你的用户会感谢你的！
- en: The third flag is returns options – this returns the available versions in the
    response header so that a calling client can see that there are options available
    for that method.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个标志是返回选项——这会在响应头中返回可用的版本，以便调用客户端可以看到该方法有可用的选项。
- en: Finally, `ApiVersionReader` makes it possible for clients to choose whether
    to put the version in the URL or the request header. Again, it’s good to give
    consumers of the API the choice in this.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`ApiVersionReader`使客户端能够选择是否将版本放在URL中或请求头中。再次强调，给API的消费者选择是很好的。
- en: Now, we need to update `HabitsController` to work with multiple versions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`HabitsController`以支持多个版本。
- en: To illustrate this point, we’ll just use a simple `GET` endpoint. But you can
    apply the same logic to any of the endpoints.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将只使用一个简单的`GET`端点。但您可以将相同的逻辑应用于任何端点。
- en: 'Change the attributes of the `HabitsController` class to the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将`HabitsController`类的属性更改为以下内容：
- en: '[PRE38]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s prove what we have done by adding an endpoint to the controller and mapping
    it to `version 1.0`, like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向控制器添加一个端点并将其映射到`version 1.0`来证明我们所做的工作，如下所示：
- en: '[PRE39]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have flagged this method as virtual so that we can override it in a subsequent
    version.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将此方法标记为虚拟，以便我们可以在后续版本中覆盖它。
- en: 'Create a file called `HabitsControllerv2.cs` and add the following to it:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`HabitsControllerv2.cs`的文件，并将其添加以下内容：
- en: '[PRE40]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that this maps the `version` endpoint to the `v2` API. You can test this
    in Thunder Client in the usual way, and you will see that changing the version
    you provide in the URL changes which response you get.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这将`version`端点映射到`v2` API。您可以在Thunder Client中按常规方式测试它，您将看到更改URL中提供的版本将更改您收到的响应。
- en: Also, note that we have specified the `Route` attribute twice – once with the
    version included and once without. This allows the default versioning that we
    specified in `Program.cs` to take effect.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们已两次指定`Route`属性——一次包含版本，一次不包含。这允许在`Program.cs`中指定的默认版本生效。
- en: 'In Thunder Client, run three tests – one test without a version, one with `v1`,
    and one with `v2`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在Thunder Client中运行三个测试——一个没有版本，一个有`v1`，一个有`v2`：
- en: 'No version: http://localhost:5100/api/Habits/version'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有版本：http://localhost:5100/api/Habits/version
- en: 'Version 1: `http://localhost:5100/api/v1/Habits/version`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 1：`http://localhost:5100/api/v1/Habits/version`
- en: 'Version 2: `http://localhost:5100/api/v2/Habits/version`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 2：`http://localhost:5100/api/v2/Habits/version`
- en: You will see that the first one returns `v1`, as that is the default, and you
    will see that the other two perform as you would expect.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到第一个返回`v1`，因为这是默认版本，您将看到其他两个按预期执行。
- en: You should also note that the requests that we previously set up in Thunder
    Client continue to operate as expected. This is great from the point of view of
    a consumer of the API. We have just introduced versioning and added `v2` without
    breaking any existing functionality!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该注意，我们在Thunder Client中之前设置的所有请求继续按预期运行。从API消费者的角度来看，这是非常好的。我们刚刚引入了版本控制并添加了`v2`，而没有破坏任何现有功能！
- en: Testing APIs
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试API
- en: In this chapter, we have demonstrated quite extensively how to test your API
    using Thunder Client. Testing APIs (and testing in general) is a huge subject
    that could be the subject of a book on its own. If you are interested, I have
    provided some pointers for further reading in the following section!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们广泛地展示了如何使用Thunder Client测试您的API。测试API（以及一般测试）是一个巨大的主题，可以成为一本单独的书的主题。如果您感兴趣，我在以下部分提供了一些进一步阅读的指南！
- en: 'The following list provides some examples of the type of testing that you may
    want to carry out to ensure that your API is functioning correctly. Unit testing
    involves testing individual components of an API to ensure that they are working
    as expected. This is typically done using a unit testing framework, such as NUnit,
    and can be automated:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了一些测试类型示例，以确保您的API正常运行。单元测试涉及测试API的各个组件以确保它们按预期工作。这通常使用单元测试框架，如NUnit，并且可以自动化：
- en: Functional testing involves testing an API end to end to ensure that all the
    components are working together correctly. This can be done manually or by using
    an automated testing tool, such as Selenium or TestComplete.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试涉及端到端测试API以确保所有组件都正确协同工作。这可以手动完成或使用自动化测试工具，如Selenium或TestComplete。
- en: Integration testing involves testing an API in conjunction with other systems,
    such as a database or other API. This can be done using an integration testing
    framework, such as Cucumber or FitNesse.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试涉及在与其他系统（如数据库或其他API）结合的情况下测试API。这可以通过使用集成测试框架，如Cucumber或FitNesse来完成。
- en: Performance testing involves testing an API to ensure that it can handle the
    expected load and is performing optimally.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试包括测试一个API以确保其能够处理预期的负载并表现最佳。
- en: Security testing involves testing an API to ensure that it is secure and not
    vulnerable to common security threats, such as SQL injection or cross-site scripting.
    This can be done using a security testing tool, such as Nessus or OWASP ZAP.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全测试包括测试一个API以确保其安全且不受常见安全威胁的影响，例如SQL注入或跨站脚本攻击。这可以通过使用安全测试工具，如Nessus或OWASP ZAP来实现。
- en: Usability testing involves testing an API to ensure that it is easy to use and
    understand. This can be done manually or by using a usability testing tool, such
    as UserTesting or Crazy Egg.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试包括测试一个API以确保其易于使用和理解。这可以手动进行或使用可用性测试工具，如UserTesting或Crazy Egg。
- en: Postman is a popular tool for testing RESTful APIs. It allows developers to
    easily create, send, and analyze HTTP requests. It has a user-friendly interface
    and supports various features, such as request and response validation, environment
    variables, and automated testing. It also allows us to test end-to-end scenarios,
    and it can be integrated with other tools such as Jenkins.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman是测试RESTful API的流行工具。它允许开发者轻松创建、发送和分析HTTP请求。它具有用户友好的界面，支持各种功能，如请求和响应验证、环境变量和自动化测试。它还允许我们测试端到端场景，并且可以与其他工具如Jenkins集成。
- en: It’s worth noting that testing RESTful APIs is an ongoing process that should
    be done throughout the development process, not just at the end. This will help
    to ensure that an API works as expected and any issues are identified and resolved
    quickly.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，测试RESTful API是一个持续的过程，应该在开发过程中始终进行，而不仅仅是最后。这将有助于确保API按预期工作，并且任何问题都能迅速识别和解决。
- en: In this chapter, we have demonstrated testing an API using Thunder Client inside
    VS Code. This is a very useful tool, with the benefit that the tests that are
    defined are saved in the repo and are checked against the code.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何在VS Code中使用Thunder Client测试API。这是一个非常有用的工具，其优点是定义的测试被保存在仓库中，并与代码进行比对。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a *lot* in this chapter! I hope it has not been overwhelming!
    We started at the start with a definition of REST. Then, we covered HTTP status
    codes and HTTP verbs to give some background on some of the underlying fundamentals
    of REST APIs.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了很多内容！希望它没有让你感到不知所措！我们从REST的定义开始，然后介绍了HTTP状态码和HTTP动词，以提供一些关于REST API底层基础知识的背景。
- en: We then looked at an example, covered the five most important HTTP verbs (`GET`,
    `POST`, `DELETE`, `PUT`, and `PATCH`), and showed how we could build them and
    test them with Thunder Client right within VS Code!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看了一个示例，介绍了五个最重要的HTTP动词（`GET`、`POST`、`DELETE`、`PUT`和`PATCH`），并展示了我们如何在VS
    Code中直接使用Thunder Client构建和测试它们！
- en: We also looked at `AutoMapper` and how to simplify object conversions to create
    DTOs from entity types.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了`AutoMapper`以及如何简化对象转换以从实体类型创建DTO。
- en: Finally, we worked through an example of how to version an API and looked at
    some additional testing techniques.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过一个示例演示了如何对API进行版本控制，并探讨了额外的测试技术。
- en: In the next chapter, we will consider microservices, and we’ll look at how we
    can break up this application into a number of smaller microservices!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑微服务，并探讨如何将此应用程序拆分为多个较小的微服务！
- en: Further reading
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'HTTP response status codes: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP响应状态码：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- en: 'Using HTTP Methods for RESTful Services: [https://www.restapitutorial.com/lessons/httpmethods.html](https://www.restapitutorial.com/lessons/httpmethods.html)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP方法进行RESTful服务：[https://www.restapitutorial.com/lessons/httpmethods.html](https://www.restapitutorial.com/lessons/httpmethods.html)
- en: HATEOAS and Why It’s Needed in RESTful API? [https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/](https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/)
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HATEOAS及其在RESTful API中的必要性 [https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/](https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/)
- en: 'Testing an API: [https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/](https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试一个API：[https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/](https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/)
- en: 'How to use API versioning in ASP.NET Core Web API and integrate it with Swagger
    using .NET 6: [https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/](https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 ASP.NET Core Web API 中使用 API 版本控制并将其与 .NET 6 集成：[https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/](https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/)
- en: Questions
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the advantages of using `PATCH` over `PUT`?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PATCH` 而不是 `PUT` 的优势是什么？
- en: What is the benefit of using AutoMapper?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 AutoMapper 的好处是什么？
- en: What HTTP code should be used when a new resource has been created?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当创建新资源时应该使用哪个 HTTP 状态码？
- en: What does the `500` range of HTTP codes signify?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP 状态码的 `500` 范围表示什么？
- en: What does REST stand for?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST 代表什么？
- en: What is the purpose of DTOs?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DTO 的用途是什么？
