- en: Decorator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: The Decorator is one of those rare patterns where the name represents its purpose
    perfectly. As its name implies, the Decorator pattern permits us to decorate an
    object; this is, of course, a very vague explanation. So, a more concrete but
    simple explanation of its core purpose is that it offers us a way to decorate
    old code with new code, by dynamically adding functionality to an object.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是那些名称完美代表其目的的罕见模式之一。正如其名所示，装饰器模式允许我们装饰一个对象；当然，这是一个非常模糊的解释。所以，一个更具体但简单的核心目的解释是，它为我们提供了一种用新代码装饰旧代码的方法，通过动态地向对象添加功能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: We will review the basics of the Decorator pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾装饰器模式的基本知识
- en: We will build a system to add attachments to a rifle dynamically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将构建一个系统，以动态地向步枪添加附件
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is hands-on, so you will need to have a basic understanding of
    Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的，因此您需要对Unity和C#有一个基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concept:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：
- en: Constructors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: If you are unfamiliar with this concept, please review it before starting this
    chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个概念不熟悉，请在开始这一章之前复习它。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际效果：
- en: '[http://bit.ly/2U0MT6x](http://bit.ly/2U0MT6x)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2U0MT6x](http://bit.ly/2U0MT6x)'
- en: The basics of the Decorator pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式的基本知识
- en: The Decorator pattern is the type of pattern that you would need to implement
    in code in order to fully understand, so we are going to keep the theory section
    brief. In its most basic form, the Decorator pattern offers us a mechanism that
    permits us to add behaviors to objects at runtime without altering the objects
    in the process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式是你需要通过代码实现以完全理解的模式类型，因此我们将保持理论部分简短。在其最基本的形式中，装饰器模式为我们提供了一种机制，允许我们在运行时向对象添加行为，而无需在过程中更改对象。
- en: As its name implies, it decorates objects; but it does so by chaining references
    of decorator objects through the constructor of a base class. It might sound abstract,
    but in practice it works, because of the way objects refer to each other in memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，它装饰对象；但它通过在基类的构造函数中链式引用装饰器对象来实现。这听起来可能很抽象，但在实践中它是有效的，因为对象在内存中相互引用的方式。
- en: 'Let''s look at the following diagram in order to visualize the relationship
    structure between classes in the Decorator pattern:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图表，以可视化装饰器模式中类之间的关系结构：
- en: '![](img/b3d39cef-7c29-4fb1-8c3b-c7fe649bc279.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3d39cef-7c29-4fb1-8c3b-c7fe649bc279.png)'
- en: As you can see, there's an interface, `IRifle`, which is offering an implementation
    contract to all classes that want to be rifles. But, the most important class
    in the diagram is the `RifleDecorator`. It's the class that will permit us to
    attach the `WithScope` and `WithStabilizer` decorators to any rifle object that
    implements `IRifle`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个接口`IRifle`，它为所有希望成为步枪的类提供了一个实现合同。但，图中最重要的类是`RifleDecorator`。它是允许我们将`WithScope`和`WithStabilizer`装饰器附加到实现`IRifle`的任何步枪对象的类。
- en: But, before writing this in code, let's review some of the core benefits and
    possible drawbacks when using the Decorator pattern.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在编写代码之前，让我们回顾一下使用装饰器模式时的核心优点和可能的缺点。
- en: Benefits and drawbacks
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: 'The Decorator pattern has an excellent reputation; it''s even a significant
    part of the Python language. So, its benefits often outweigh its drawbacks, as
    we can see in the following list:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式享有极高的声誉；它甚至是Python语言的一个重要部分。因此，其优点通常超过了其缺点，正如以下列表所示：
- en: 'The following are the benefits:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些优点：
- en: '**Alternative to subclassing**: The Decorator pattern focuses on injecting
    functionality into an object, instead of inheriting and then extending.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替代子类化**：装饰器模式侧重于向对象注入功能，而不是继承和扩展。'
- en: '**Manageable permutations**: Features and requirements change all the time
    during production; the Decorator pattern offers a way to add functionality by
    distributing it through self-contained components, without modifying core implementations.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可管理的排列组合**：在生产的整个过程中，功能和需求都在不断变化；装饰者模式提供了一种通过分布到自包含组件中来添加功能的方法，而不需要修改核心实现。'
- en: '**Runtime dynamics**: The Decorator pattern permits us to add functionality
    to an object at runtime without modifying it directly.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时动态性**：装饰者模式允许我们在不直接修改对象的情况下在运行时向对象添加功能。'
- en: 'The following are the drawbacks:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些缺点：
- en: '**Code complexity**: Like most advanced patterns, implementing the Decorator
    pattern can result in a more complex code base.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码复杂性**：像大多数高级模式一样，实现装饰者模式可能会导致代码库变得更加复杂。'
- en: '**Relationship complexity**: Keeping track of the chain of initialization and
    the relationships between decorators can become very complicated if there are
    multiple layers of decorators around an object.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系复杂性**：如果围绕一个对象有多个装饰者层，跟踪初始化链和装饰者之间的关系可能会变得非常复杂。'
- en: The drawbacks of specific patterns are often related to the complexity and verbosity
    they add to a code base. It's mostly an issue when working in a team of members
    with various levels of experience, because junior programmers might not have the
    skills to recognize specific patterns just by reading the code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 特定模式的缺点通常与它们给代码库带来的复杂性和冗余性有关。这主要是在一个由经验水平不同的成员组成的团队中工作时会遇到的问题，因为初级程序员可能没有通过阅读代码来识别特定模式的能力。
- en: Use case example
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: Weapons are an essential element of video games, especially in the first-person
    shooter (FPS) genre. A very cool and profitable feature to have in an FPS is weapon
    customization. The ability to upgrade a basic rifle by attaching new components
    to it, such as a scope or silencer, is very engaging. But, as a game programmer,
    having to write all these variations and configurations in code, in a structured
    and modular manner, can be very complicated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 武器是视频游戏的一个基本元素，尤其是在第一人称射击（FPS）类型中。在FPS游戏中拥有武器定制功能是一个非常酷且有利可图的特性。通过为新组件，如瞄准镜或消音器，附加到基本步枪上来升级它的能力，是非常吸引人的。但是，作为一个游戏程序员，必须以结构化和模块化的方式在代码中编写所有这些变体和配置，这可能会非常复杂。
- en: But, with the Decorator pattern, we can reproduce the real-life concept of attaching
    components to a configurable weapon in code. This is what we are going to do in
    the following code example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用装饰者模式，我们可以在代码中重现将组件附加到可配置武器的现实生活概念。这正是我们将在下面的代码示例中做的。
- en: The Adapter and Decorator patterns are similar, but Adapter is used to adapt
    an object's interface, while Decorator enhances an object’s responsibilities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器和装饰者模式相似，但适配器用于适配对象的接口，而装饰者增强了对象的责任。
- en: Code example
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'A particular thing to keep in mind in the following code example is that we
    are going to use constructors. It''s often recommended not to use them in Unity,
    because if you are working with `Monobehaviours` or `ScritableObjects` derived
    classes and you attach them to `GameObjects` included in a scene, the engine will
    automatically initialize them. But, in this example, we are going to break this
    rule; mainly because the Decorator is dependent on the internal mechanisms of
    the constructor, as we are going to see in the following code snippets:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，需要注意的一个特定事项是我们将使用构造函数。通常建议不要在Unity中使用它们，因为如果你正在使用`Monobehaviours`或其派生类的`ScritableObjects`，并将它们附加到场景中包含的`GameObjects`，引擎将自动初始化它们。但在这个例子中，我们将打破这个规则；主要是因为装饰者依赖于构造函数的内部机制，正如我们将在下面的代码片段中看到的：
- en: 'Let''s begin the implementation of our weapon customization system by writing
    an interface that will be used as an *implementation* *contract* for all our derived
    rifle types:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过编写一个接口来开始我们武器定制系统的实现，这个接口将作为所有派生步枪类型的*实现* *合约*：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, it's a simple interface with one function that returns the accuracy
    value of a rifle as a float.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个简单的接口，它有一个返回步枪精度值的浮点数的函数。
- en: 'Now that we have a standard interface for all our rifle objects, let''s write
    a concrete rifle class that will represent a basic configuration of a rifle:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为所有步枪对象定义了一个标准接口，让我们编写一个具体的步枪类，它将代表步枪的基本配置：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `BasicRifle` class is doing nothing special; it just implements the `IRifle`
    interface; but we are going to use it as a foundation object that we are going
    to decorate with attachments that will upgrade its default accuracy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicRifle`类并没有做任何特别的事情；它只是实现了`IRifle`接口；但我们打算将其用作一个基础对象，我们将用附件来装饰它，从而提高其默认精度。'
- en: 'We now need a class that will take the responsibility of attaching the decorators
    to our `BasicRifle` object:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要一个类来负责将装饰器附加到我们的`BasicRifle`对象上：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are implementing the core of the Decorator pattern in the `RifleDecorator`
    class. We can see that the `RifleDecorator` class is implementing the `IRifle`
    interface, but there's a small detail that's very important to notice. The `GetAccuracy()`
    function is virtual, which means that any derived class of `RifleDecorator` will
    be able to override it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`RifleDecorator`类中实现了装饰器模式的核心。我们可以看到`RifleDecorator`类实现了`IRifle`接口，但有一个非常重要的细节需要注意。`GetAccuracy()`函数是虚拟的，这意味着`RifleDecorator`的任何派生类都能够重写它。
- en: 'Now that we have our Decorator class, let''s see how an actual decorator object
    will attach itself to our `BasicRifle` object during runtime:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的装饰器类，让我们看看实际的装饰器对象如何在运行时将其自身附加到我们的`BasicRifle`对象上：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first thing to notice is the constructor; it takes an `IRifle` type object
    as an argument, and then calls its base constructor. This approach might seem
    very tangled at first view, but it's going to become clear once we implement the
    client side of this example. Another detail to note is that we are overriding
    the `GetAccuracy()` function, but also changing the overall accuracy of the rifle
    by adding `m_ScopeAccurancy` to the base value in the return path.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是构造函数；它接受一个`IRifle`类型的对象作为参数，然后调用其基类构造函数。这种做法乍一看可能非常混乱，但一旦我们实现了这个示例的客户端，它就会变得清晰。另一个需要注意的细节是，我们正在重写`GetAccuracy()`函数，但在返回路径中通过添加`m_ScopeAccurancy`到基值来改变整支枪的整体精度。
- en: 'To showcase the flexibility of the Decorator pattern, let''s add another decorator
    to our example:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了展示装饰器模式的灵活性，让我们在我们的示例中添加另一个装饰器：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`WithStabilizer` has the same implementation as the `WithScope`, except for
    the final accuracy value that it returns.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithStabilizer`的实现与`WithScope`相同，只是它返回的最终精度值不同。'
- en: 'Now, it''s time to implement the client; this is where we are going to trigger
    the decoration feature of the Decorator pattern:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现客户端了；这是我们触发装饰器模式装饰功能的地方：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The most important element to notice in this class is the chaining of the constructor
    calls in the following line:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中最重要的元素是以下行中的构造函数调用链：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this line of code, we are basically attaching the `WithScope` and `WithStabilizer`
    decorators to a `BasicRifle` instance by chaining them with the base constructor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一行代码，我们基本上通过链式调用基类构造函数，将`WithScope`和`WithStabilizer`装饰器附加到`BasicRifle`实例上。
- en: So, we can now get different accuracy outputs depending on how many attachments
    we attach to the `BasicRifle` instance, as follows.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以根据附加到`BasicRifle`实例的附件数量来获取不同的精度输出，如下所示。
- en: 'The following code returns accuracy of `5.0f`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码返回精度为`5.0f`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code returns accuracy of `25.0f`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码返回精度为`25.0f`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code returns accuracy of `35.0f`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码返回精度为`35.0f`：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, by using the Decorator pattern, we now have an underlying implementation
    of a dynamic weapon customization system that we can extend to build a collection
    of runtime attachments for our game's weaponry.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用装饰器模式，我们现在有一个动态武器定制系统的底层实现，我们可以扩展它来构建游戏武器运行时附件的集合。
- en: Summary
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we reviewed a pattern that offers a game programmer a flexible
    way to implement an often requested feature – weapon customization. It appears
    that the Decorator pattern was perfectly designed to accomplish this type of task.
    But, as you can imagine, the Decorator can be used to implement all kinds of customizable
    systems and features, such as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了一个为游戏程序员提供灵活方式实现经常请求的功能——武器定制的模式。看起来装饰器模式非常适合完成这类任务。但正如你所想象的那样，装饰器可以用来实现所有类型的可定制系统和服务，例如以下内容：
- en: Vehicle upgrades
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车辆升级
- en: Armour and clothing
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装甲和服装
- en: In the next chapter, we will transition out of Behavioral patterns and will
    instead focus on Decouplers, starting with the Event Bus.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从行为模式过渡出来，转而关注解耦器，从事件总线开始。
- en: Practice
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In this chapter, we decided to use native C# constructors, which is proper because
    we were not using `MonoBehaviours` or `ScritableObjects`. But this not always
    the case, so, as an exercise, you should try to refactor the code example we just
    completed, but without any constructors and primarily using native Unity `MonoBehaviours`
    and `ScriptableObjects`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们决定使用原生C#构造函数，这是合适的，因为我们没有使用`MonoBehaviours`或`ScritableObjects`。但这种情况并不总是如此，因此，作为一个练习，你应该尝试重构我们刚刚完成的代码示例，但不使用任何构造函数，主要使用原生的Unity
    `MonoBehaviours`和`ScriptableObjects`。
- en: You can find hints on how to accomplish this in the official Unity API documentation
    on `ScriptableObjects`; please check the *Further reading* section for more information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方Unity API文档的`ScriptableObjects`部分找到如何实现这一点的提示；请查阅*进一步阅读*部分以获取更多信息。
- en: Further reading
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Unity – Scripting API: ScriptableObject* [https://docs.unity3d.com/ScriptReference/ScriptableObject.html](https://docs.unity3d.com/ScriptReference/ScriptableObject.html)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Unity – 脚本API: ScriptableObject* [https://docs.unity3d.com/ScriptReference/ScriptableObject.html](https://docs.unity3d.com/ScriptReference/ScriptableObject.html)'
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    John Vlissides, Ralph Johnson, and Richard Helm'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式：可复用面向对象软件元素》由Erich Gamma, John Vlissides, Ralph Johnson和Richard Helm所著
- en: '[http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[《设计模式：可复用面向对象软件元素》](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)'
