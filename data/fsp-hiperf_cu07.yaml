- en: Chapter 7. Language Features and Constructs Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。语言特性和结构优化
- en: 'When we code, it happens quite often that we are sunk into optimization details.
    We often have to focus on dealing with concurrency, performance/benchmark measurements,
    and profiling other elements such as memory consumptions. This focus on concurrency
    and performance/benchmark measurements is, of course, a big and important element
    of our code, especially concurrency. This topic has been described extensively
    in the previous two chapters: [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency * *in F#* and [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2
    "Chapter 5. Advanced Concurrency Support in F#"), *Advanced Concurrency Support
    in F#*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编码时，常常会陷入优化细节中。我们经常必须专注于处理并发、性能/基准测量，以及分析其他元素，如内存消耗。当然，这种对并发和性能/基准测量的关注是我们代码中的一个重要且庞大的元素，尤其是并发。这个主题在前两章中已经进行了详细描述：[第
    4 章](fsp-hiperf_cu04.html#aid-11C3M2 "第 4 章。F# 并发简介")，*F# 并发简介*和[第 5 章](fsp-hiperf_cu05.html#aid-164MG2
    "第 5 章。F# 高级并发支持")，*F# 高级并发支持*。
- en: There are other elements in F# to be recognized as optimization opportunities,
    the language constructs that are commonly used in code and also advanced language
    constructs such as computation workflow. Language constructs, including the combination
    of semantics and syntax, are crucial too because we are directly dealing with
    them as we code. This chapter is dedicated to identifying performance optimizations
    in language features, focusing on language constructs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，还有其他元素可以被识别为优化机会，包括在代码中常用的语言结构以及如计算工作流等高级语言结构。语言结构，包括语义和语法的组合，同样至关重要，因为我们编码时直接与之打交道。本章致力于识别语言特性中的性能优化，重点关注语言结构。
- en: Many F# language constructs are mostly trivial and they are already optimized,
    unless those constructs often require special care because of the subtlety of
    the implementation detail and also correctness, in the sense of having predictable
    results. Trivial constructs such as asynchronous workflow, list comprehension
    of `head::tail`, and list splicing are fully optimized, and often, to optimize
    further, we have to interop with other .NET libraries such as .NET TPL, in conjunction
    with F# asynchronous workflow, or dive further into the source code of F list.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 F# 语言结构大多是微不足道的，并且它们已经得到了优化，除非这些结构由于实现细节的微妙性和正确性（即具有可预测的结果）而经常需要特别关注。像异步工作流、`head::tail`
    的列表推导和列表拼接这样的微不足道结构已经得到了完全优化，并且通常，为了进一步优化，我们必须与其他 .NET 库（如 .NET TPL）进行互操作，结合 F#
    异步工作流，或者进一步深入研究 F 列表的源代码。
- en: When we are using F# collections, it's better to optimize on usage instead of
    optimizing the internal semantic implementations (the internal source code) as
    we already discussed in [Chapter 3](fsp-hiperf_cu03.html#aid-NQU22 "Chapter 3. Optimizing
    Data Structures"), *Optimizing Data Structures*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 F# 集合时，最好优化使用方式，而不是像我们在[第 3 章](fsp-hiperf_cu03.html#aid-NQU22 "第 3 章。优化数据结构")，*优化数据结构*中讨论的那样，优化内部语义实现（内部源代码）。
- en: 'This chapter focuses on subtle language constructs. We will now discuss these
    topics in optimizing language features and constructs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于微妙的语言结构。我们现在将讨论这些主题，以优化语言特性和结构：
- en: Overview of F# language features and constructs optimizations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 语言特性和结构优化概述
- en: Optimizing common F# language constructs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化常见的 F# 语言结构
- en: Optimizing inline functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化内联函数
- en: Identifying tail call in recursive constructs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别递归结构中的尾调用
- en: Overview of language features and constructs optimization
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言特性和结构优化概述
- en: F# as a functional programming language has lots of language features. These
    language features also define the unique traits of F# itself, differentiating
    from other languages such as C#/VB.NET.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种函数式编程语言，F# 拥有很多语言特性。这些语言特性也定义了 F# 本身的独特特性，与其他语言如 C#/VB.NET 区别开来。
- en: 'For example, the following are the F# language features related to functional
    programming:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是与函数式编程相关的 F# 语言特性：
- en: Pattern matching
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Active pattern
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活跃模式
- en: Type inference (including type inference generalization)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断（包括类型推断泛化）
- en: Inline function (also called function inlining)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联函数（也称为函数内联）
- en: Discriminated union
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分联合
- en: Discriminated union is a language feature and it is also a type that is unique
    to F# implementation, although it is compatible with C#/VB.NET. The best practices
    of using discriminated union are already discussed in [Chapter 3](fsp-hiperf_cu03.html#aid-NQU22
    "Chapter 3. Optimizing Data Structures"), *Optimizing Data Structures*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合是一种语言特性，它也是F#实现中独特的类型，尽管它与C#/VB.NET兼容。区分联合的最佳实践已在[第3章](fsp-hiperf_cu03.html#aid-NQU22
    "第3章。优化数据结构")中讨论，即*优化数据结构*。
- en: 'By a simple definition, a language feature has the following elements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的定义，语言特性包含以下元素：
- en: Syntax, the keyword and the usage
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法，关键字和用法
- en: Constructs, the overall unification of syntax and the contextual usage, especially
    when used within other language elements
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造，语法和上下文使用的整体统一，尤其是在其他语言元素中使用时
- en: Semantics, the actual context and meaning of the code that has the constructs
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义，具有构造的代码的实际上下文和意义
- en: We all know what syntax is. But constructs are quite subtle. The term *constructs*
    comes from the fact that syntaxes with identifiers and arguments forms a composite
    code that is heavily related to the syntaxes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道什么是语法。但构造相当微妙。术语*构造*来源于这样的事实，即具有标识符和参数的语法形成了一个与语法高度相关的复合代码。
- en: 'For example, let''s examine the `if` syntax:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们来检查`if`语法：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we describe the syntax, it is by using an abstract concept such as `boolean-expression`
    or just an expression. We have highlighted the keywords for you: `if`, `then,
    else.`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们描述语法时，是通过使用抽象概念如`布尔表达式`或只是一个表达式来进行的。我们已为您突出显示关键字：`if`、`then`、`else`。
- en: Before we are going to use `if`, we have to understand the semantics of `if`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`if`之前，我们必须理解`if`的语义。
- en: 'The following information are the semantics of `if`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息是`if`的语义：
- en: Within the `boolean-expression`, the expression has to be an expression that
    always evaluates to either true or false as this is also the nature of a Boolean
    type. It can be a direct value of Boolean itself, such as true or false, or it
    can be in the form of a symbol variable or as a function that evaluates to Boolean
    result.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`布尔表达式`中，表达式必须是一个始终评估为真或假的表达式，因为这也是布尔类型的本质。它可以是布尔本身的直接值，如true或false，也可以是符号变量或函数，其评估结果为布尔值。
- en: The expression after `then` means evaluate and execute the expression after
    the `then` keyword.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then`后面的表达式意味着评估并执行`then`关键字后面的表达式。'
- en: The `else` keyword means to optionally evaluate and execute the expression if
    the `boolean-expression` is evaluated to be false.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`关键字意味着如果`布尔表达式`评估为假，则可选地评估和执行表达式。'
- en: 'The constructs of `if` as a sample is quite trivial, we just give a sample
    usage of `if` here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例的`if`构造相当简单，我们在这里只给出`if`的一个示例用法：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The sample code means that the `if` construct uses the `if..then` construct,
    instead of the full `if..then..else` construct, as illustrated in this fugure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码表示`if`构造使用`if..then`构造，而不是完整的`if..then..else`构造，如图所示：
- en: '![Overview of language features and constructs optimization](img/image00317.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![语言特性和构造优化概述](img/image00317.jpeg)'
- en: Therefore, when we discuss constructs, it is often better to express it with
    a sample code, rather than using the abstract form of syntax usage and description.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们讨论构造时，通常用示例代码来表达它，而不是使用语法使用和描述的抽象形式。
- en: If we look up and check F# documentation in MSDN Library, the syntax usage is
    defined using the common **Backus-Naur Form** (**BNF**) notation. This BNF notation
    is a notation to represent syntax definition and usage, originally taken from
    compiler theory in the realm of computer science discipline.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在MSDN库中查找并检查F#的文档，其语法使用是通过常见的**巴科斯-诺尔范式**（**BNF**）符号来定义的。这种BNF符号是用来表示语法定义和使用的符号，最初来源于计算机科学学科领域的编译理论。
- en: There are simplified and full notations of BNF, but for the sake of simplicity
    and to avoid confusion, we shall use simplified BNF. The simplified form is also
    commonly used in MSDN Library when describing programming language syntaxes, including
    those in F#, C#, VB, C++, JavaScript.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: BNF有简化和完整两种表示形式，但为了简单起见，避免混淆，我们将使用简化的BNF。简化形式也常用于MSDN库中描述编程语言语法，包括F#、C#、VB、C++、JavaScript等。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some programming books use full BNF notation to describe syntax. It is also
    valid, but it is also quite confusing at the same time for people who are not
    from a computer science background. Throughout this book, we will describe syntax
    using the simplest form of BNF notation instead of the full BNF.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程书籍使用完整的 BNF 符号来描述语法。这也是有效的，但同时也对非计算机科学背景的人来说相当混乱。在这本书中，我们将使用 BNF 符号的最简单形式来描述语法，而不是完整的
    BNF。
- en: It is also quite common to use the angled brackets, `[ .. ]`, to denote optional
    syntax. In the context of our `if` syntax, the `else` keyword with the expression
    is also optional.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尖括号 `[ .. ]` 来表示可选语法也是很常见的。在我们的 `if` 语法上下文中，带有表达式的 `else` 关键字也是可选的。
- en: 'For more information on the overview of BNF notation, its variants, and the
    grammar of the syntax, check out this comprehensive article:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 BNF 符号概述、其变体和语法语法的更多信息，请参阅这篇全面的文章：
- en: '[http://matt.might.net/articles/grammars-bnf-ebnf/](http://matt.might.net/articles/grammars-bnf-ebnf/)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://matt.might.net/articles/grammars-bnf-ebnf/](http://matt.might.net/articles/grammars-bnf-ebnf/)'
- en: Optimizing common F# language constructs
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化常见的 F# 语言结构
- en: When we are optimizing F# language constructs, the best way to start optimizing
    is to identify the most commonly used F# language constructs. This is quite subtle,
    but important, because commonly used F# language constructs are easier to understand
    and learn first rather than the rarely used or more advanced ones. However, we
    shall focus on the constructs that often have subtle performance impacts and recommended
    correctness to enforce predictable behaviors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在优化 F# 语言结构时，开始优化的最佳方式是识别最常用的 F# 语言结构。这相当微妙，但很重要，因为常用的 F# 语言结构更容易理解和首先学习，而不是很少使用或更高级的结构。然而，我们应该关注那些经常有微妙性能影响和推荐正确性以强制可预测行为的结构。
- en: Predictable behaviors in the context of a running code means having predictable
    results on the entire flow of code, including when dealing with branches, switching
    execution contexts such as async and parallelisms, and having awareness on exceptions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码的上下文中，可预测的行为意味着在整个代码流程中都有可预测的结果，包括处理分支、切换执行上下文（如异步和并行）以及处理异常时的意识。
- en: 'Let''s visit the most commonly used F# constructs: active pattern, pattern
    matching, and delegate or function lambda in F#.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看最常用的 F# 结构：活跃模式、模式匹配和 F# 中的委托或函数 lambda。
- en: Best practices of interoperability of F# delegate with .NET delegate
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 委托与 .NET 委托互操作性的最佳实践
- en: Delegate in F#, as we have seen, is very useful and unique but at the same time
    it maintains the high compatibility bar with the .NET delegate.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，F# 中的委托非常实用且独特，但同时也保持了与 .NET 委托的高度兼容性。
- en: As a matter of fact, the internal and actual implementation of F# delegates
    actually derives from the .NET Delegate class. This is important as F# has to
    be compatible with and maintain the underlying .NET CLR, and on the higher layer,
    compatible with .NET Base Class Library (BCL) that is defined in the `mscorlib.dll`
    and `System.dll` assemblies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，F# 委托的内部和实际实现是从 .NET Delegate 类派生出来的。这一点很重要，因为 F# 必须与并维护底层的 .NET CLR 兼容，并在更高层上与定义在
    `mscorlib.dll` 和 `System.dll` 集合中的 .NET 基类库 (BCL) 兼容。
- en: For normal functions implemented in F#, it should have planning in the future
    to define whether it will be compatible with C#/VB or is just available to be
    called from external F# compiled assemblies, or it is only used within its own
    compiled assembly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 F# 中实现的普通函数，未来应该规划其是否将与 C#/VB 兼容，或者只是可供外部 F# 编译的汇编调用，或者它仅用于其自身的编译汇编。
- en: 'The best practice rules with the related scenarios from the F# side are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: F# 方面的最佳实践规则与相关场景包括：
- en: For functions that are planned to be called within their own assembly and do
    not have any direct use or reference to .NET delegate (for example, LINQ expression
    tree), always use F# delegates. This is faster than always mixing with the .NET
    delegate, although the function is always used within the assembly scope.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于计划在其自身汇编中调用的函数，且没有直接使用或引用 .NET 委托（例如 LINQ 表达式树），始终使用 F# 委托。这比总是与 .NET 委托混合更快，尽管函数总是在汇编范围内使用。
- en: For a function that is planned to be available to be called from external assembly
    that is also implementing the whole F# compiled code and does not have any direct
    use or reference to a .NET delegate (for example, LINQ expression tree), always
    use F# delegates. It is still faster than .NET delegates.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个计划从外部实现整个 F# 编译代码的汇编程序调用（例如，LINQ 表达式树）且没有直接使用或引用 .NET 代表（例如）的功能，始终使用 F#
    代表。这仍然比 .NET 代表更快。
- en: For a function that is planned to be available to be called from any .NET delegate
    and does not have any direct use or reference to a .NET delegate (for example,
    LINQ expression tree), special care has to be taken into account, such as interoperability
    when the .NET delegate is calling the F# delegate.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个计划从任何 .NET 代表调用且没有直接使用或引用 .NET 代表（例如，LINQ 表达式树）的功能，必须特别小心，例如在 .NET 代表调用
    F# 代表时的互操作性。
- en: For a function that is planned to be available to be called from any .NET delegate
    and also has calls to .NET delegate, use the .NET delegate model instead of F#
    delegate. This usage of .NET delegate is slightly slower than F# delegate, but
    the overall performance is compensated when the function is called many times
    from .NET delegate, while at the same time achieving the highest compatibility
    with .NET delegate and other managed languages, such as C#/VB.NET/managed C++.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个计划从任何 .NET 代表调用且也调用 .NET 代表的功能，使用 .NET 代表模型而不是 F# 代表。这种 .NET 代表的使用略慢于 F#
    代表，但函数多次从 .NET 代表调用时的整体性能得到了补偿，同时实现了与 .NET 代表和其他托管语言（如 C#/VB.NET/托管 C++）的最高兼容性。
- en: Currently, there is no other known scenario for delegate interoperability other
    than the rules just mentioned. As long as we are aware about F# and other managed
    languages' feature parity, we are always guaranteed to have a high predictability.
    A best sample for this parity is the lambda function feature. This feature is
    available on both F# and most other managed languages such as C#/VB and IronPython.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，除了上述规则之外，没有其他已知的代表互操作性场景。只要我们了解 F# 和其他托管语言的特性兼容性，我们总是可以保证有高度的预测性。这个兼容性的最佳示例是
    lambda 函数功能。这个功能在 F# 和大多数其他托管语言（如 C#/VB 和 IronPython）上都是可用的。
- en: Unfortunately, managed C++ has this full support for language lambda feature
    parity only since the release of Visual Studio 2013\. It is good to know that
    Microsoft has provided extensive documentation on using this feature on managed
    C++.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，托管 C++ 仅从 Visual Studio 2013 的发布开始支持语言 lambda 功能的完全兼容性。了解微软提供了关于在托管 C++
    上使用此功能的广泛文档是很好的。
- en: 'For more information about lambda in C++, visit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 C++ 中 lambda 的更多信息，请访问：
- en: '[https://msdn.microsoft.com/en-us/library/dd293608.aspx](https://msdn.microsoft.com/en-us/library/dd293608.aspx)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/dd293608.aspx](https://msdn.microsoft.com/en-us/library/dd293608.aspx)'
- en: 'However, when doing interoperability with .NET delegate, avoid the following
    pitfalls:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在进行与 .NET 代表的互操作性时，应避免以下陷阱：
- en: Calling or mixing .NET delegates with normal asynchronous workflow. This will
    yield unpredictable behaviors because a .NET delegate is best suited within the
    Task Asynchrony Programming model of .NET Task asynchrony. F# has its own asynchrony
    without the need for using the same context switching model of .NET Task asynchrony.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用或混合 .NET 代表与正常的异步工作流。这将产生不可预测的行为，因为 .NET 代表最适合在 .NET Task 异步编程模型的 .NET Task
    异步中。F# 有自己的异步性，无需使用与 .NET Task 异步相同的上下文切换模型。
- en: Calling F# delegate/function that has implementation of asynchronous workflow
    from normal .NET method. This is fine, as long as the .NET method is not treated
    as asynchronous. But if the calling .NET method is implemented asynchronously,
    unpredictable behavior will always occur, and it might lead to race condition
    in the context switching.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从正常的 .NET 方法调用实现异步工作流的 F# 代表/函数。这是可以的，只要 .NET 方法不被视为异步。但如果调用 .NET 方法是异步实现的，则总会发生不可预测的行为，并可能导致上下文切换中的竞争条件。
- en: '*Do not* mix F# delegate within .NET unsafe methods. Unless we must have an
    unsafe implementation to a known Windows API, it is highly recommended to avoid
    this practice.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*不要* 在 .NET 不安全方法中混合 F# 代表。除非我们必须对已知的 Windows API 有不安全实现，否则强烈建议避免这种做法。'
- en: Let's do the real work of these delegates interoperability in the next section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中真正完成这些代表的互操作性工作。
- en: Passing a .NET delegate as an F# function
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 .NET 代表作为 F# 函数传递
- en: Let's start passing an F# function from C#, and this fits with scenario 4 for
    any function that is going to be called from C#.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 C# 开始传递 F# 函数，这适用于任何将从 C# 调用的函数的场景 4。
- en: 'For example, suppose we implement a function to get the row index of data from
    an `IEnumerable`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们实现一个函数来获取 `IEnumerable` 数据的行索引：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our C# project, first add a reference to the assembly that has the implementation
    of `GetRowIndex`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 C# 项目中，首先添加对实现 `GetRowIndex` 的程序集的引用。
- en: 'Then, we can import the namespace and use the F# function directly within C#
    using this sample:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以导入命名空间，并在 C# 中直接使用这个示例来调用 F# 函数：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code will get all of the running process of our machine, then
    search for a process named `explorer.exe`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将获取我们机器上所有正在运行的过程，然后搜索名为 `explorer.exe` 的进程。
- en: When we pass a C#/VB delegate, it is actually a .NET delegate. But the lambda
    will evaluate as a different lambda that F# has; therefore, we have to convert
    our lambda expression parameter to `FSharpFunc` (F# lambda) before passing it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递 C#/VB 委托时，它实际上是一个 .NET 委托。但是 lambda 表达式将被评估为 F# 有不同的 lambda 表达式；因此，在传递之前，我们必须将我们的
    lambda 表达式参数转换为 `FSharpFunc`（F# lambda）。
- en: '`FuncConvert` is available in the `FSharp.Core` assembly under the namespace
    of `Microsoft.FSharp.Core.FuncConvert`. This helper class has enough converter
    methods that support all forms of .NET `Func`, as indicated by the signature symbol
    of `FuncConvert`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`FuncConvert` 可在 `FSharp.Core` 集合中找到，位于 `Microsoft.FSharp.Core.FuncConvert`
    命名空间下。这个辅助类有足够的转换方法，支持所有形式的 .NET `Func`，如 `FuncConvert` 的签名符号所示：'
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For more information about F# `FuncConvert`, visit MSDN:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 F# `FuncConvert` 的更多信息，请访问 MSDN：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.funcconvert-class-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.funcconvert-class-%5Bfsharp%5D)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.funcconvert-class-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.funcconvert-class-%5Bfsharp%5D)'
- en: Calling .NET delegate within F#
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 F# 中调用 .NET 委托
- en: Now, what about calling a common .NET delegate, such as `Func<'T,'U>`, in our
    F# code?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于在我们的 F# 代码中调用常见的 .NET 委托，如 `Func<'T,'U>`，又是怎样的呢？
- en: It is quite simple and straightforward, and it is also simpler than passing
    a .NET delegate as an F# delegate.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简单直接，而且比传递一个 .NET 委托作为 F# 委托还要简单。
- en: 'For example, we could call LINQ and pass the delegate parameter:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以调用 LINQ 并传递委托参数：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, the `Func` delegate is instantiated first, then the constructor
    is filled with the number of parameters and the correct type annotation, whether
    it is generic or not.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先实例化了 `Func` 委托，然后构造函数填充了参数的数量和正确的类型注解，无论是否为泛型。
- en: Best practices in pattern matching and active pattern
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配和主动模式的最佳实践
- en: Pattern matching is one of the most commonly used language features/constructs.
    It is both a language feature and a language construct with syntax.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是使用最广泛的语言特性/结构之一。它既是一个语言特性，也是一个具有语法的语言结构。
- en: 'The starting syntax for pattern matching is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配的起始语法如下：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The keyword `match` means to match the expression with the pattern below the
    `match` keyword. It is highly required for the patterns to be matched in order
    to have the same indentation as the `match` declaration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `match` 表示将表达式与 `match` 关键字下方的模式进行匹配。为了使模式匹配，要求模式与 `match` 声明具有相同的缩进。
- en: 'Not all kinds of functional language patterns are supported, and this is already
    defined in F# 4.0 language specification. The full specification of F# 4.0 predefined/supported
    patterns of pattern matching is documented at:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类型的函数式语言模式都受支持，这已经在 F# 4.0 语言规范中定义。F# 4.0 预定义/支持的模式匹配的完整规范在以下位置有文档记录：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching)'
- en: The easiest pattern to use is the constant pattern. The constant value means
    that the expression will be inferred as a type of the constant pattern as long
    as the pattern is consistently defining all the patterns and uses the same type
    of constant.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易使用的模式是常量模式。常量值意味着只要模式一致地定义所有模式并使用相同的常量类型，表达式就会被推断为常量模式的类型。
- en: 'For example, let''s write a code to convert *ABC* grade to the commentary report.
    Using pattern matching, this is the code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写一个代码来将 *ABC* 等级转换为评语报告。使用模式匹配，这是代码：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The grade parameter is inferred by the mostly used types of the constant patterns,
    typed as string. This pattern matching usage is common, and it is also easier
    to understand and easier to reason than using different types as constants. These
    common pattern matching uses of constants are also faster to compile because the
    type used as constants value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 等级参数被推断为常量模式的最常用类型，类型为字符串。这种模式匹配的使用很常见，并且它也比使用不同类型的常量更容易理解，更容易推理。这些常见的常量模式匹配用法也更快地编译，因为用作常量值的类型。
- en: 'To test on the type of grade parameter and the return type, we can use F# interactive.
    Simply highlight the code of `SimpleGradePattern` and press *Alt* + *Enter*. Then
    the type will be inferred as `string -> string`, as illustrated in the following
    screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试等级参数的类型和返回类型，我们可以使用 F# 交互式环境。只需突出显示 `SimpleGradePattern` 的代码，然后按 *Alt* +
    *Enter*。然后类型将被推断为 `string -> string`，如下面的截图所示：
- en: '![Best practices in pattern matching and active pattern](img/image00318.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![模式匹配和主动模式最佳实践](img/image00318.jpeg)'
- en: This inferred type is a proof that type inference flows nicely in a consistent
    way, as indicated by the use of string constants. The use of `_` in the last pattern
    specifies that we should take care of the other patterns not mentioned, regardless
    of the content of the grade parameter. Omitting this will result in compile error
    because F# compiler always checks for all possible conditions in pattern matching
    and requires that all possible conditions in pattern matching must be handled.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推断类型是类型推断以一致的方式流畅流动的证明，如使用字符串常量的使用所示。在最后一个模式中使用 `_` 指定我们应该注意其他未提及的模式，无论等级参数的内容如何。省略此操作将导致编译错误，因为
    F# 编译器始终检查模式匹配中所有可能的情况，并要求处理模式匹配中所有可能的情况。
- en: Comparing constant pattern matching with if constructs
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较常量模式匹配与 `if` 构造
- en: Some developers, especially when dealing with pattern matching, always compare
    pattern matching with a similar common language construct, the `if` construct.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者，尤其是在处理模式匹配时，总是将模式匹配与类似常见的语言构造 `if` 构造进行比较。
- en: The `if` condition construct is also supported in F#. It has an additional syntactic
    sugar, the `elif` keyword, to define that an else is immediately followed by the
    `if` construct. This `elif` keyword is the same as having the `else if` syntax.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: F# 也支持 `if` 条件构造。它有一个额外的语法糖，即 `elif` 关键字，用于定义 `else` 立即跟在 `if` 构造之后。这个 `elif`
    关键字与 `else if` 语法相同。
- en: The use of `if` is common in non-functional programming languages, especially
    in OOP languages such as C#/VB.NET/C++, because it implicitly enforces imperative
    as is usually found in OOP languages as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '在非函数式编程语言中，`if` 的使用很常见，尤其是在像 C#/VB.NET/C++ 这样的面向对象编程语言中，因为它隐式地强制执行通常在面向对象编程语言中找到的命令式。 '
- en: 'The `if` syntax in F# is defined as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的 `if` 语法定义如下：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following explains the syntax and semantics of the `if` constructs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解释了 `if` 构造的语法和语义：
- en: The keywords `if` and `then` are required because they define the condition
    to evaluate and also what to do if the condition is evaluated as true.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字 `if` 和 `then` 是必需的，因为它们定义了要评估的条件以及条件评估为真时要执行的操作。
- en: '`boolean-expression` means that the expression is an expression that will result
    as Boolean, either true or false. This is required, and `boolean-expression` has
    to comply with the F# language specification for `boolean-expression`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean-expression` 表示该表达式是一个将结果为布尔值的表达式，要么为真，要么为假。这是必需的，并且 `boolean-expression`
    必须符合 F# 语言规范中的 `boolean-expression`。'
- en: The `else` construct is optional, and it does not have to be in the same line.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else` 构造是可选的，并且不必在同一行。'
- en: 'The official documentation of F# `if` specification is available at:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: F# `if` 规范的官方文档可在以下位置找到：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/conditional-expressions-if-then-else](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/conditional-expressions-if-then-else).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/conditional-expressions-if-then-else](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/conditional-expressions-if-then-else).'
- en: Now, let's go back to our grade pattern. We are now going to convert our grade
    to use `if` instead of using pattern matching.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的等级模式。我们现在将使用 `if` 而不是使用模式匹配来转换我们的等级。
- en: 'The code to convert our grade has to be written well to capture all of the
    semantics of `SimpleGradePattern`. There are many ways to write the code using
    `if`, but we are going to leverage `elif` in F#. This is the code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 转换我们的成绩的代码必须写得很好，以捕获`SimpleGradePattern`的所有语义。使用`if`编写代码有很多种方式，但我们将利用F#中的`elif`。这是代码：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To make the comparison more interesting, let's add more functions to test and
    to sample these constructs, comparing `if` with pattern matching.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使比较更有趣，让我们添加更多函数来测试和抽样这些结构，比较`if`与模式匹配。
- en: 'First, we will use the `Stopwatch` object from .NET BCL of `System.Diagnostics`,
    by importing the namespace first, with the `System` namespace as well:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用来自.NET BCL的`System.Diagnostics`中的`Stopwatch`对象，首先导入命名空间，同时使用`System`命名空间：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we will write a function to test the one pass running of `SimpleGradePattern`
    and `SimpleGradeNoPattern`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个函数来测试`SimpleGradePattern`和`SimpleGradeNoPattern`的单次运行：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code has the following notable elements of semantics and flows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码具有以下显著的语义和流程元素：
- en: The use of stopwatch `swtimer` as mutable. This is important because `swtimer`
    will be used and changed many times inside the scope of our `GradeBenchmarkTest`
    function.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停表`swtimer`的使用是可变的。这很重要，因为`swtimer`将在我们的`GradeBenchmarkTest`函数的作用域内被多次使用和更改。
- en: The stopwatch needs to be reset every time it is stopped and is going to be
    used again because we need to ensure that the timespan result at the initial start
    is reset to 0.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停表每次停止并再次使用时都需要重置，因为我们需要确保初始开始时的时间跨度结果重置为0。
- en: The result of the stopwatch will be available after it is stopped, and it is
    stored in the `Elapsed` property, typed as `TimeSpan`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停表的结果将在停止后可用，并存储在`Elapsed`属性中，类型为`TimeSpan`。
- en: The use of `5000000` times iteration using `for..to` loop. The number of iterations
    is important because the nature of today's processor is so fast, and most sampling
    ends in milliseconds. Less than 1,000,000 sampling will yield less than 10 ms,
    and it will be hard to differentiate between pattern matching and `if` usage.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for..to`循环进行`5000000`次迭代的`5000000`。迭代次数很重要，因为今天处理器的速度如此之快，大多数抽样都以毫秒结束。少于1,000,000次的抽样将产生少于10毫秒，这将很难区分模式匹配和`if`的使用。
- en: We are using the same parameter of `B` to ensure that the code will evaluate
    as semantically the same (from the perspective of parameter and result).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用相同的`B`参数来确保代码在语义上评估为相同（从参数和结果的角度来看）。
- en: We are returning the milliseconds result as `Tuple`, which has two fields to
    contain `timerSimpleGradePattern` and `timerSimpleGradeNoPattern` results. The
    direct use of .NET Tuple instead of F# Tuple is chosen because this will ensure
    that the returning result will be used easily by the calling function.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将毫秒结果作为`Tuple`返回，它包含两个字段以包含`timerSimpleGradePattern`和`timerSimpleGradeNoPattern`的结果。选择直接使用.NET
    `Tuple`而不是F# `Tuple`，因为这将确保返回的结果可以很容易地被调用函数使用。
- en: The `Elapsed` property is using `TimeSpan` because it is used to store *the
    duration of time spanned*. This is important because `TimeSpan` can have a resolution
    from hours to milliseconds.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Elapsed`属性使用`TimeSpan`，因为它用于存储跨越的时间段。这很重要，因为`TimeSpan`的分辨率可以从小时到毫秒。'
- en: 'For more information on `TimeSpan`, consult the following page:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`TimeSpan`的信息，请参阅以下页面：
- en: '[https://msdn.microsoft.com/en-us/library/system.timespan(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.timespan(v=vs.110).aspx)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/system.timespan(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.timespan(v=vs.110).aspx)'
- en: Now, we need further samples to get the average execution time of both constant
    pattern matching and `if` usage. To simplify calculating the average, we shall
    call `GradeBenchmarkTest` within a frequency value as defined by function parameter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要进一步抽样以获取常数模式匹配和`if`使用的平均执行时间。为了简化计算平均值，我们将在函数参数定义的频率值内调用`GradeBenchmarkTest`。
- en: 'The following code tests the statistical sampling of the benchmark:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码测试了基准的统计抽样：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s run it by putting the benchmark to test by putting `GradeBenchmarkSamplingTest`
    with a high enough frequency sampling:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将基准测试通过`GradeBenchmarkSamplingTest`以足够高的频率抽样来运行它：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To minimize friction with debugging, run without debugging by pressing *Ctrl*
    + *F5* and this is one of the sample displays:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化调试时的摩擦，可以通过按*Ctrl* + *F5*来运行不带调试，这是其中一个示例显示：
- en: '![Comparing constant pattern matching with if constructs](img/image00319.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![比较常量模式匹配与if结构](img/image00319.jpeg)'
- en: 'On my machine, under the configuration of core i7 4^(th) generation with 16
    GB of RAM, the `SimpleGradePattern` function (with constant pattern matching)
    is outperforming `SimpleGradeNoPattern` by a narrow margin results:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，在core i7第四代16 GB RAM的配置下，`SimpleGradePattern`函数（具有常量模式匹配）仅以微弱的优势优于`SimpleGradeNoPattern`的结果：
- en: '| `Sampling` | `SimpleGradePattern` | `SimpleGradeNoPattern` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `Sampling` | `SimpleGradePattern` | `SimpleGradeNoPattern` |'
- en: '| 1 | 96 ms | 97 ms |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 96 ms | 97 ms |'
- en: '| 2 | 97 ms | 97 ms |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 97 ms | 97 ms |'
- en: '| 3 | 98 ms | 99 ms |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 98 ms | 99 ms |'
- en: '| 4 | 96 ms | 98 ms |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 96 ms | 98 ms |'
- en: '| 5 | 97 ms | 100 ms |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 97 ms | 100 ms |'
- en: '| 6 | 96 ms | 99 ms |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 96 ms | 99 ms |'
- en: '| 7 | 97 ms | 100 ms |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 97 ms | 100 ms |'
- en: The results on your own machine may vary, but this result highly depends on
    the specifications of your machine, including CPU and RAM.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上的结果可能会有所不同，但这个结果高度依赖于您的机器规格，包括CPU和RAM。
- en: 'In order to successfully execute and sample timing sensitive benchmark, it
    is highly recommended to have the following preconditions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功执行和采样时间敏感的基准测试，强烈建议满足以下先决条件：
- en: Windows Update is turned off. On Windows 10, the best way to do this is to disconnect
    all your networks as Windows 10 will always try to update every time you are connected
    to any internet/network.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows更新已被关闭。在Windows 10中，最好的做法是断开所有网络连接，因为Windows 10会始终尝试在连接到任何互联网/网络时更新。
- en: We should always run the benchmarked code without debugging. This will give
    more accurate results because the Visual Studio debugger will not be loaded, and
    the execution will be faster.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该始终在不调试的情况下运行基准测试代码。这将提供更准确的结果，因为Visual Studio调试器不会被加载，执行速度会更快。
- en: Turn off any Windows notifications. There are overheads when you have many notifications
    running in background, and this may affect one or two cores on your system.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭所有Windows通知。当您在后台运行许多通知时，会有开销，这可能会影响系统的一个或两个核心。
- en: On an average, `SimpleGradePattern` is 1 to 3 ms faster than `SimpleGradeNoPattern`.
    If you run this again, results may vary but in the overall condition, using pattern
    matching is better than using `if`. To understand why, we shall dive deeper into
    the resulting IL.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 平均而言，`SimpleGradePattern`比`SimpleGradeNoPattern`快1到3毫秒。如果您再次运行，结果可能会有所不同，但在总体条件下，使用模式匹配比使用`if`更好。要了解原因，我们将更深入地研究生成的IL。
- en: 'Let''s dive into the IL of `SimpleGradePattern`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`SimpleGradePattern`的IL：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The IL code in `SimpleGradePattern` is divided into two sections: the first
    section handles the conditions and the second section (after `br.s` in the line
    segment `IL_004e`) handles the return value as the destination of branches before
    `IL_004e`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleGradePattern`中的IL代码分为两部分：第一部分处理条件，第二部分（在`IL_004e`行段的`br.s`之后）处理返回值作为`IL_004e`之前的分支目标。'
- en: 'Let''s dive into the IL of `SimpleGradeNoPattern`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`SimpleGradeNoPattern`的IL：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After reading the IL of `SimpleGradeNoPattern`, we come to the following conclusions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取`SimpleGradeNoPattern`的IL后，我们得出以下结论：
- en: All of the conditions of `A` to `E` (including `undefined`) are stored onto
    heap. This is normal and this is the nature of string, it being a reference type.
    Storing onto heap is indicated by the instruction of `ldstr`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`A`到`E`（包括`undefined`）的所有条件都存储在堆上。这是正常的，这也是字符串的本质，它是一个引用类型。使用`ldstr`指令指示存储在堆上。'
- en: All of the patterns in the pattern matching results need a storage. The storage
    is prepared using `stloc`. This IL instruction will prepare stack storage, then
    all the condition results (the Boolean result) of `A` to `E` are stored onto the
    same stack. There is a stack allocation overhead at the first initialization,
    but this is compensated by using stack to load the value after the stack is allocated
    by calling `ldloc`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式匹配结果中的所有模式都需要存储。使用`stloc`准备存储。这个IL指令将准备堆栈存储，然后所有`A`到`E`的条件结果（布尔结果）都存储在同一个堆栈上。在第一次初始化时，会有堆栈分配的开销，但通过调用`ldloc`在堆栈分配后加载值来补偿。
- en: In the code that uses `if`, the conditions result of `A` to `E` are loaded onto
    heap. This is needed for `if` because it needs a different location for each `if`,
    and it's faster to allocate the heap at the initial declaration in `if` because
    it will avoid stack allocation overhead. Then, the flow branches to the next instructions.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用 `if` 的代码中，条件结果 `A` 到 `E` 被加载到堆上。这是必要的，因为 `if` 需要为每个 `if` 分配不同的位置，而在 `if`
    的初始声明时分配堆会更高效，因为它可以避免栈分配的开销。然后，流程分支到下一组指令。
- en: String in both the codes is evaluated using calls to the `System.String.Equals()`
    method. However, the interesting fact is the use of `call` in `SimpleGradePattern`
    instead of `callvirt`. This is subtle but different; `call` is used to call a
    static method of `String.Equals()`, while `callvirt` requires instantiation of
    string before calling `String.Equals()`. A static call is always faster to execute
    than method instance calls.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两种代码中的字符串都是通过调用 `System.String.Equals()` 方法来评估的。然而，有趣的事实是 `SimpleGradePattern`
    中使用 `call` 而不是 `callvirt`。这是微妙但不同的；`call` 用于调用 `String.Equals()` 的静态方法，而 `callvirt`
    在调用 `String.Equals()` 之前需要实例化字符串。静态调用总是比方法实例调用执行得更快。
- en: This narrow result of benchmark clearly shows and proves that using constant
    pattern matching is faster than the sequences of `if`, although it shows a small
    amount of difference in milliseconds.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准测试的狭窄结果清楚地显示并证明了使用常量模式匹配比 `if` 序列更快，尽管它显示了毫秒级的小量差异。
- en: We can safely conclude that it is common best practice to use pattern matching
    instead of `if` constructs for patterns that have the same data type and the patterns
    used are easily evaluated.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地得出结论，对于具有相同数据类型且易于评估的模式，使用模式匹配而不是 `if` 结构是常见的最佳实践。
- en: 'The results will be more apparent if the patterns used have many patterns,
    for example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用的模式有很多，结果将更加明显，例如：
- en: 52 patterns of poker cards
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 52 种扑克牌模式
- en: 7 days of a week
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一周中的 7 天
- en: 12 months of a year
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一年中的 12 个月
- en: And the semantic of pattern matching always enforces correctness by always enforcing
    us to evaluate all the possible outcomes. For example, in `SimpleGradePattern`
    there can be input outside `A` to `E`, and we can consider outside of these inputs
    as undefined or invalid. If we do not provide this information to satisfy the
    outside predefined conditions, we will have a compile error, and the code will
    not run even on F# interactive mode.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配的语义总是通过始终强制我们评估所有可能的输出结果来强制执行正确性。例如，在 `SimpleGradePattern` 中，可能有 `A` 到 `E`
    之外的输入，我们可以将这些输入视为未定义或无效。如果我们不提供这些信息以满足外部预定义的条件，我们将有一个编译错误，并且代码即使在 F# 交互模式下也无法运行。
- en: If we use too many patterns to be matched, then the code execution will be slower
    to compile and execute because F# compiler will try to parse the patterns used
    and search for unused/unidentified patterns; then, the IL code generated will
    add more overhead on branching, and branches with too many fall downs are not
    effective because later conditions will always be evaluated longer before the
    first conditions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用太多的模式进行匹配，那么代码的编译和执行速度会变慢，因为 F# 编译器会尝试解析使用的模式并搜索未使用/未识别的模式；然后，生成的 IL 代码将在分支上添加更多的开销，并且具有太多分支的分支效率不高，因为后续的条件总是在第一个条件之前被评估得更长。
- en: To relate to our example code of `SampleGradePattern`, the `E` condition is
    always treated to be evaluated after `A` to `D`. Therefore, too many patterns
    (especially above 10 patterns) will not be efficient, and later conditions, especially
    patterns nearing the end, will always be evaluated longer after previous conditions
    are evaluated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的 `SampleGradePattern` 示例代码为例，`E` 条件总是被处理为在 `A` 到 `D` 之后评估。因此，太多的模式（尤其是超过
    10 个模式）将不会高效，并且后续的条件，尤其是接近末尾的模式，总是在之前的条件评估之后评估得更长。
- en: 'To mitigate the slow execution problems of many patterns to be matched, it
    is better to refactor it and then we could use one of these:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻匹配许多模式导致的慢速执行问题，最好是重构它，然后我们可以使用以下之一：
- en: A dictionary of key and value. The key will have to be treated like a unique
    primary key, and the value can be anything as long as it has relations to its
    key. This value can then be extended to be typed as delegates or F# functions
    to be executed when we search for a key that has values as actions to be executed.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个键值对的字典。键必须被当作唯一的候选键来处理，而值可以是任何与键相关的内容。这个值可以扩展为委托或 F# 函数，当搜索具有作为执行动作的值的键时执行。
- en: A list of data typed as `KeyValue` pairs and this F# list is more efficient
    than the .NET dictionary because it will be stored as a linked list, with immutability
    coming by default and known recursive support by `head::tail`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一系列数据类型为 `KeyValue` 对的列表，并且这个 F# 列表比 .NET 字典更高效，因为它将以链表的形式存储，默认具有不可变性，并且通过 `head::tail`
    提供已知的递归支持。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, .NET 4.6.1 does not have support for built-in
    read-only dictionary. Although we can use read-only collections that are parts
    of Microsoft's NuGet of `Immutable.Collections`, it is better to use F# list because
    of the nature of immutability, and it's faster to access than a .NET list as linked
    list. It is faster to access because the linked list implementation of F# list
    is faster than a normal .NET list in nature and it has support for recursive access
    within head and tails.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，.NET 4.6.1 不支持内置的只读字典。虽然我们可以使用 Microsoft NuGet 的 `Immutable.Collections`
    部分的只读集合，但由于不可变性的特性，最好使用 F# 列表，并且它比 .NET 列表作为链表更快地访问。它之所以更快，是因为 F# 列表的链表实现比正常的
    .NET 列表在本质上更快，并且它支持在头和尾中进行递归访问。
- en: Best practices in using active patterns
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用活跃模式的最佳实践
- en: Active pattern is one of the language constructs in F# that is very useful.
    It is often used in pattern matching and embedded within `if` constructs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃模式是 F# 中非常有用的语言构造之一。它通常用于模式匹配，并嵌入在 `if` 构造中。
- en: 'There are only two kinds of active patterns in F#: complete active pattern
    and partial active pattern. A complete active pattern is an active pattern that
    contains more than one identifier whereas a partial active pattern only has one
    identifier and the `_` identifier to denote the rest of the conditions, much similar
    to the use of `_` in pattern matching.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中只有两种活跃模式：完整活跃模式和部分活跃模式。完整活跃模式是一个包含多个标识符的活跃模式，而部分活跃模式只有一个标识符和 `_` 标识符来表示其余的条件，这与模式匹配中使用
    `_` 的用法非常相似。
- en: 'The syntax for active pattern is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃模式的语法如下：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For example, we can define an active pattern to contain even and odd number
    as pattern of *even* and *odd* like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个活跃模式来包含偶数和奇数，模式为 *even* 和 *odd*，如下所示：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The operator `%` in F# means modulo, so the condition checks if modulo 2 equals
    0 or not. If it equals 0 then it will be resolved as `Even`, otherwise (else)
    `Odd`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的运算符 `%` 表示取模，因此条件检查模 2 是否等于 0。如果等于 0，则解析为 `Even`，否则（else）为 `Odd`。
- en: 'We can then harness active patterns within pattern matching, for example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在模式匹配中使用活跃模式，例如：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now within our entry point of main, we can test with the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的主入口点中，我们可以使用以下内容进行测试：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the code without debugging, and this is the result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不带调试运行代码，这是结果：
- en: '![Best practices in using active patterns](img/image00320.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![使用活跃模式的最佳实践](img/image00320.jpeg)'
- en: 'How does the pattern translate into raw IL? Let''s dive into IL. Looking at
    the layout of the resulting output of IL Disassembler (ILDASM), we see this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将模式转换为原始 IL？让我们深入 IL。查看 IL Disassembler (ILDASM) 生成的输出布局，我们看到如下内容：
- en: '![Best practices in using active patterns](img/image00321.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![使用活跃模式的最佳实践](img/image00321.jpeg)'
- en: 'Based on the preceding picture, we can see the following interesting parts:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图示，我们可以看到以下有趣的部分：
- en: The module that holds our code, `ActivePatterns`, is defined as `public static
    class`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含我们代码的模块 `ActivePatterns` 被定义为 `public static class`。
- en: The active pattern is defined as a method. The method references to a class
    of `Microsoft.FSharp.Core.FSharpChoice` with two generic type parameters (indicated
    by `'2`)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 活跃模式定义为一种方法。该方法引用 `Microsoft.FSharp.Core.FSharpChoice` 类，该类有两个泛型类型参数（由 `'2'`
    表示）。
- en: The function that performs the test-the `TestEvenNumber`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试的函数`TestEvenNumber`。
- en: 'Let''s dump the IL of `Even|Odd`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导出 `Even|Odd` 的 IL：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s examine `TestEvenNumber`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 `TestEvenNumber`：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Yes, the `Even|Odd` class is defined based on registering the `Even` and `Odd`
    passed as parameters for `FSharpChoice` class. In F# code, this class is called
    `Core.Choice<'T1,'T2>` because it has two generic parameterized types, and it
    is documented as a helper class to define active patterns.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`Even|Odd` 类是基于为 `FSharpChoice` 类注册 `Even` 和 `Odd` 参数定义的。在 F# 代码中，这个类被称为
    `Core.Choice<'T1,'T2>`，因为它有两个泛型参数化类型，并且它被记录为一个用于定义活跃模式的辅助类。
- en: 'We can deduce that there is a limit to the number of active patterns defined.
    The limit of the number of patterns is 7, as defined by active pattern documentation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以推断出定义的主动模式数量是有限的。模式的数量限制为7，这是由主动模式文档定义的：
- en: '*There can be up to seven partitions in an active pattern definition.*'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在主动模式定义中可以有最多七个分区。*'
- en: 'The documentation for active pattern is available at:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 主动模式的文档可在以下位置找到：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns)'
- en: F# `Choice` is powerful because it is used heavily in active patterns to effectively
    express our patterns as choices, which are then passed to `Choice1of2` and `Choice2of2`
    to be processed as the result of a choice. The kind of `Choice` class used depends
    on how many patterns we have as active patterns.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: F# `Choice` 非常强大，因为它在主动模式中被大量使用，有效地将我们的模式表达为选择，然后传递给 `Choice1of2` 和 `Choice2of2`
    以作为选择的结果进行处理。使用的 `Choice` 类取决于我们有多少模式作为主动模式。
- en: For example, three patterns used means that it will be translated into calls
    to the `Choice<'T1,'T2,'T3>` class, which then calls `Choice1of3`, `Choice2of3`,
    and `Choice2of3` as needed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用三个模式意味着它将被转换为对 `Choice<'T1,'T2,'T3>` 类的调用，然后根据需要调用 `Choice1of3`、`Choice2of3`
    和 `Choice2of3`。
- en: 'Interestingly enough, all F# `Choice` classes are declared as discriminated
    unions. For example, F# `Choice<''T1,''T2>` is declared as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 趣味的是，所有 F# `Choice` 类都被声明为区分联合。例如，F# `Choice<'T1,'T2>` 的声明如下：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This means that `Choice` can also have the benefit of discriminated unions without
    having to redefine inner classes that go intermingled with generics embedded.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `Choice` 也可以享受到区分联合的好处，而无需重新定义与泛型嵌入的内部类混合的内部类。
- en: The most commonly used active patterns are patterns of two and three. This includes
    the implicit leverage of `Core.Choice<'T1,'T2>` and `Core.Choice<'T1,'T2,'T3>`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的主动模式是两种和三种的模式。这包括对 `Core.Choice<'T1,'T2>` 和 `Core.Choice<'T1,'T2,'T3>` 的隐式利用。
- en: 'For more information about `Core.Choice<''T1,''T2>` and `Core.Choice<''T1,''T2,''T3>`,
    visit the following links:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `Core.Choice<'T1,'T2>` 和 `Core.Choice<'T1,'T2,'T3>` 的更多信息，请访问以下链接：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.choice%5b''t1,''t2%5d-union-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.choice%5b''t1,''t2%5d-union-%5bfsharp%5d)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.choice%5b''t1,''t2%5d-union-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.choice%5b''t1,''t2%5d-union-%5bfsharp%5d)'
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.choice%5b''t1,''t2,''t3%5d-union-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.choice%5b''t1,''t2,''t3%5d-union-%5bfsharp%5d)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.choice%5b''t1,''t2,''t3%5d-union-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.choice%5b''t1,''t2,''t3%5d-union-%5bfsharp%5d)'
- en: For the sake of correctness, the use of active patterns combined with pattern
    matching is recommended as long as the active pattern used is simple enough and
    the nature of the active pattern is a complete active pattern.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保正确性，只要使用的主动模式足够简单，且主动模式的性质是完整的主动模式，就建议使用主动模式与模式匹配相结合。
- en: 'The use of partial active patterns is not recommended because:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用部分主动模式，因为：
- en: The rest of the unevaluated conditions will always be a fallback. This fallback
    of all unevaluated conditions might imply an uncaught error or exception, and
    this is not a good practice. All the conditions should be carefully thought and
    then handled as this will provide clear reasoning.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的未评估条件始终是后备选项。所有未评估条件的后备可能意味着未捕获的错误或异常，这不是一个好的做法。所有条件都应该仔细考虑，然后进行处理，这将提供清晰的推理。
- en: Because of the nature of unevaluated conditions, any exceptions that may happen
    might be uncaught after the pattern is passed to the code that uses the active
    pattern. This uncaught exception is harder to resolve because our code is not
    in the correct context of where the exception should be caught.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于未评估条件的性质，在将模式传递给使用主动模式的代码后，可能发生的任何异常可能未被捕获。这种未被捕获的异常更难以解决，因为我们的代码不在捕获异常的正确上下文中。
- en: Considerations in catching exceptions in active patterns
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在主动模式中捕获异常的注意事项
- en: Uncaught exceptions in active pattern, no matter how subtle it is, are always
    expensive. The call stack preparations and the state will always lead to undesirable
    effects such as losing the previous states, including not evaluating the rest
    of the active patterns we have. Losing the previous states, especially losing
    the current execution state before the exception happened always leads us to execution
    termination, unless the exception is caught.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在活动模式中未捕获的异常，无论其多么微妙，总是昂贵的。调用堆栈的准备和状态总是会导致不希望的结果，例如丢失先前的状态，包括未评估我们拥有的其他活动模式。丢失先前的状态，尤其是丢失异常发生前的当前执行状态，总是会导致执行终止，除非异常被捕获。
- en: Catching an exception itself is expensive, but having an uncaught exception
    is more dangerous as it will always force our code to be halted/terminated. Propagating
    and then displaying the exception information (including stack traces) is common
    in many software applications that have GUI, in order to give user the information
    of what exception is caught.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获异常本身是昂贵的，但未捕获的异常更为危险，因为它会强制我们的代码停止/终止。在许多具有图形用户界面的软件应用程序中，传播并显示异常信息（包括堆栈跟踪）是常见的做法，以便向用户提供捕获到的异常信息。
- en: In .NET BCL, the stack traces are represented in the `StackFrame` class. It
    will by default be always instantiated when we catch any exception. This is one
    of the many reasons *why catching exceptions is expensive*, because it will implicitly
    instantiate `StackFrame`, building information based on the current stack and
    call site and then hooking up the information. Hooking up the call site and the
    `StackFrame` itself takes some CPU overhead as it goes back and forth to the hooking
    up pointers and v-table of call stacks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET BCL 中，堆栈跟踪由 `StackFrame` 类表示。默认情况下，在捕获任何异常时都会实例化它。这是捕获异常昂贵的许多原因之一，因为它会隐式实例化
    `StackFrame`，基于当前的堆栈和调用位置构建信息，然后连接这些信息。连接调用位置和 `StackFrame` 本身需要一些 CPU 开销，因为它需要在连接指针和调用堆栈的
    v-table 之间来回移动。
- en: 'The `StackFrame` class is available under the `System.Diagnostics` namespace
    within the assembly of `mscorlib.dll`. For more information about .NET `StackFrame`,
    visit:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackFrame` 类在 `mscorlib.dll` 集合的 `System.Diagnostics` 命名空间下可用。有关 .NET `StackFrame`
    的更多信息，请访问：'
- en: '[https://msdn.microsoft.com/en-us/library/system.diagnostics.stackframe(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.diagnostics.stackframe(v=vs.110).aspx)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/system.diagnostics.stackframe(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.diagnostics.stackframe(v=vs.110).aspx)'
- en: 'Now, let''s turn our focus to optimizing one of the subtle language constructs
    of F#: inline functions.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向优化 F# 中微妙的语言结构之一：内联函数。
- en: Optimizing inline functions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化内联函数
- en: F# has features of inline functions since F# 1.9, although the previous version
    already had it as experimental.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: F# 从 1.9 版本开始具有内联函数的功能，尽管之前的版本已经将其作为实验性功能。
- en: 'The definition of inline function is quite non-trivial: an inline function
    is a function that is *integrated* into the calling code. The word integrated
    must have a clear context; what kind of integration? It is integrated in the sense
    that the type is not generalized, but it is compiled accordingly when the inline
    function is used within other functions. The inline function body is embedded
    directly. This function embedding will be discussed in detail in the next section.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数的定义相当复杂：内联函数是一种被*集成*到调用代码中的函数。这个词必须有一个明确的上下文；是什么样的集成？这里的集成是指类型不是泛化的，但在内联函数在其他函数中使用时，会相应地进行编译。内联函数体是直接嵌入的。这种函数嵌入将在下一节中详细讨论。
- en: Before we discuss in-depth about inline functions, let's first examine the background
    of the importance and relevance of inline functions in the next section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论内联函数之前，让我们首先在下一节中检查内联函数的重要性及其相关类型推断的背景。
- en: Background overview of inline functions and related type inferences
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联函数及其相关类型推断的背景概述
- en: To understand this integration, we must know the background of how functions
    and arguments are evaluated first, especially if the arguments have no type annotation
    at all. When an F# function declaration has type annotations, the mechanism is
    simpler because the compiler will not perform any automatic generalization strategy
    at all. The evaluation of functions and its arguments are part of type inference
    mechanisms in F#, including automatic generalizations and inline functions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这种集成，我们首先必须了解函数和参数评估的背景，特别是如果参数根本没有任何类型注解的话。当一个 F# 函数声明有类型注解时，机制更简单，因为编译器将不会执行任何自动泛化策略。函数及其参数的评估是
    F# 中类型推断机制的一部分，包括自动泛化和内联函数。
- en: Automatic generalization strategy is unique in F#, it is powerful but at the
    same time will put the burden of type inference on the compiler.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 自动泛化策略在 F# 中是独特的，它功能强大，但同时也将类型推断的负担放在编译器上。
- en: When there are type annotations applied in the function argument's declaration,
    heavy automatic generalization will not always occur. If the type annotation itself
    contains a normal generic type annotation such as `` `T ``, then the generalization
    is done partially because of the availability of existing type annotations in
    the declarations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数参数声明的类型注解中应用类型注解时，重度的自动泛化并不总是发生。如果类型注解本身包含一个正常的泛型类型注解，如` `T ``，则泛化部分是因为声明中存在现有的类型注解而进行的。
- en: F# has further optimizations to use instead of having normal generic generalizations
    (including automatic generalizations) using inline functions. This inline function
    feature is a well-known and powerful feature of F#, although it is rarely used.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: F# 有进一步的优化，可以使用内联函数而不是使用正常的泛型泛化（包括自动泛化）。这个内联函数特性是 F# 中一个众所周知且强大的特性，尽管它很少被使用。
- en: Overview of F# type inference mechanism of generic type inference
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 泛型类型推断机制概述
- en: 'The most known aspect when writing a function declaration is writing the parameters
    without any type annotation at all. F# compiler infers the type using the following
    algorithm:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数声明时，最知名的一个方面是无需任何类型注解地编写参数。F# 编译器使用以下算法来推断类型：
- en: If the function body contains expressions that employ common arithmetic operators
    such as additions and multiplications, the type will be inferred as `Int32` by
    default. Any calculation that involves a rational number (for example, 2.5) will
    perform a type inference resulting as `Double`.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数体包含使用常见算术运算符（如加法和乘法）的表达式，则默认推断类型为`Int32`。任何涉及有理数（例如，2.5）的计算都将执行类型推断，结果为`Double`。
- en: If the function body contains more complex statements such as `if` and `try...with`,
    the type inference will perform an *automatic generalization*. The resulting signature
    will be similar to a C#/VB method that has generic types as parameters.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数体包含更复杂的语句，如`if`和`try...with`，则类型推断将执行*自动泛化*。生成的签名将类似于具有泛型参数的 C#/VB 方法。
- en: Overview of automatic generalization in F#
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F# 自动泛化概述
- en: '**Automatic generalization** means that type inference will resolve as generic
    when it cannot further infer as concrete types. In F#, automatic generalizations
    mostly happen when the type inference cannot be inferred further not just by the
    content of the function body. When a more complex construct such as `if` is used,
    the generalization will try to infer generic type, and it has more complex algorithms
    to prevent more generalization from using too many generic types.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动泛化**意味着当无法进一步推断为具体类型时，类型推断将解析为泛型。在 F# 中，自动泛化主要发生在类型推断无法仅通过函数体的内容进一步推断时。当使用更复杂的结构，如`if`，泛化将尝试推断泛型类型，并且它有更复杂的算法来防止过度泛化使用过多的泛型类型。'
- en: Compiling a function that resolves as generalized parameters will generate IL
    for generic types, and the number of generic types is determined by the function
    body itself.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 编译解析为泛型参数的函数将生成泛型类型的 IL，泛型类型的数量由函数体本身确定。
- en: Let's examine automatic generalization samples from the simplest one.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查从最简单的一个开始自动泛化的示例。
- en: 'The following code has `if` in the function body:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在函数体中包含`if`：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The type of `a` and `b` will be generalized and inferred to be typed as `'a`,
    because it assumes that `a` and `b` must have the same type due to the existence
    of `>` parameter in the function body.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`和`b`的类型将被泛化并推断为`''a`类型，因为它假设由于函数体中存在`>`参数，`a`和`b`必须具有相同的类型。'
- en: This simple sample proves that automatic generalizations depend on the signature
    declaration and the function body.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例证明了自动泛化依赖于签名声明和函数体。
- en: For functions with type annotations that use normal generic type annotations,
    F# will try to check for the existence of a simple arithmetic expression and will
    infer it as long as the arithmetic expression does not contain another recursive
    call.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用普通泛型类型注解的类型注解的函数，F# 将尝试检查是否存在简单的算术表达式，并且只要算术表达式不包含另一个递归调用，就会进行推断。
- en: However, using generalization in a generic type will have its own disadvantages
    because generic type resolution is resolved at compile time but the user of the
    function might have a different use of concrete type, and this will add overheads
    in the compilation time and also small overheads when it is run. The runtime will
    always try to keep the original generalized type as is, and there is a chance
    that some type will be bound using late binding strategy instead of early binding.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在泛型类型中使用泛化有其自身的缺点，因为泛型类型的解析是在编译时完成的，但函数的使用者可能对具体类型有不同的使用，这将在编译时间和运行时增加开销。运行时总是会尽量保持原始的泛化类型不变，并且有可能某些类型会使用后期绑定策略而不是早期绑定。
- en: 'For example, the `greaterThan` function might be called with different concrete
    types as long as the type inferred implements the `>` operator:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`greaterThan`函数可以与不同的具体类型一起调用，只要推断出的类型实现了`>`运算符：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The late binding of type resolution will always add overhead to the overall
    performance, although it rarely occurs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 类型解析的后期绑定总是会增加整体性能的开销，尽管这种情况很少发生。
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not mix late binding with dynamic typing. Late binding is different from
    dynamic typing; in dynamic binding, type resolution is done at runtime instead
    of compile time. Therefore, in dynamic typing languages, type resolution always
    happens at runtime, and it is mostly done using techniques such as combination
    of dynamic type resolution and call site caching.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将后期绑定与动态类型混用。后期绑定与动态类型不同；在动态绑定中，类型解析是在运行时而不是在编译时完成的。因此，在动态类型语言中，类型解析总是在运行时发生，并且通常使用诸如动态类型解析与调用站点缓存组合等技术。
- en: To minimize the overheads of type binding at runtime (although the type resolution
    is done at compile time), F# has other features to replace the type of the parameter
    as a concrete type when the function is called by another function that has a
    concrete type resolved. This is called inline function, and it is described in
    the next section.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化运行时类型绑定的开销（尽管类型解析是在编译时完成的），F# 有其他功能，当函数被另一个具有具体类型解析的函数调用时，可以将参数类型替换为具体类型。这被称为内联函数，将在下一节中描述。
- en: Best practices in implementing inline functions
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现内联函数的最佳实践
- en: F# supports *statically typed parameters*, not just normal parameters. The term,
    *static type parameters,* means that the type parameters are replaced with the
    concrete types at compile time instead of runtime.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: F# 支持*静态类型参数*，而不仅仅是普通参数。术语*静态类型参数*意味着类型参数在编译时而不是在运行时被替换为具体类型。
- en: This means an increased performance because the type is already filled in and
    there is no further generic type translation at runtime. It also increases correctness
    and predictability because the type is already inferred at compile time, minimizing
    the overhead of normal generic type materialization into a concrete type and at
    the same time providing a guarantee to be strongly typed at runtime.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着提高了性能，因为类型已经填充，并且在运行时没有进一步的泛型类型转换。它还增加了正确性和可预测性，因为类型已经在编译时推断出来，最小化了将普通泛型类型材料化为具体类型的开销，同时保证了在运行时是强类型的。
- en: 'There is a caveat: once we have declared the generic type parameter to be statically
    typed, we cannot mix with the normal generic type.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项：一旦我们声明了泛型类型参数为静态类型，就不能与普通泛型类型混用。
- en: 'The syntax for this statically typed parameter uses a caret, the `^` symbol
    instead of the normal apostrophe `''` symbol. Take for example the following function
    signature:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种静态类型参数的语法使用的是撇号，即`^`符号，而不是正常的撇号`'`符号。例如，以下函数签名：
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The statically typed parameter can be used only in conjunction with inline functions
    and methods.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型参数只能与内联函数和方法一起使用。
- en: 'In function/member declaration, a statically typed parameter is for all generic
    types used, so again there is no mixing with normal/common generics. For example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数/成员声明中，静态类型参数适用于所有使用的泛型类型，因此再次没有与普通/常见泛型混合。例如：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `static` type flows into all usage, including at the declaration of the
    interface implementation used, the signature of the discriminated union, and the
    declaration of type constraints.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`类型流向所有使用，包括接口实现的声明、区分联合的签名和类型约束的声明。'
- en: 'Let''s start exploring inline functions. In this sample, we create a multiplication
    inline function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索内联函数。在这个示例中，我们创建了一个乘法内联函数：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we have an inline `inlinemul` function that takes `a`
    and `b` as parameters.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个内联的`inlinemul`函数，它接受`a`和`b`作为参数。
- en: 'The inline functions can be implemented in defining custom operators:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数可以在定义自定义操作符时实现：
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we have the `^*` operator that takes `a` and `b` as parameters.
    The resulting semantic of sample `mul` and `^*` operator is the same, and it is
    also the same from the perspective of IL implementation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`^*`操作符，它接受`a`和`b`作为参数。样本`mul`和`^*`操作符的语义结果是相同的，并且从IL实现的角度来看也是相同的。
- en: First, we need to verify the signature based on the documentation. To check
    the signature of the previous `inlinemul` function, we can use F# interactive.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要根据文档验证签名。要检查前一个`inlinemul`函数的签名，我们可以使用F# interactive。
- en: 'After evaluating both `mul` and `^*` operator, we have the following signatures
    in **F# Interactive**:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估了`mul`和`^*`操作符之后，我们在**F# Interactive**中得到了以下签名：
- en: '![Best practices in implementing inline functions](img/image00322.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![实现内联函数的最佳实践](img/image00322.jpeg)'
- en: All generic type parameters are declared with a caret prefix instead of using
    the common normal apostrophe/single quote, `'`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 所有泛型类型参数都是使用撇号前缀声明的，而不是使用常见的普通撇号/单引号，`'`。
- en: 'Let''s extract and examine the declaration of `inlinemul` (with line number
    added for clarity):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提取并检查`inlinemul`（添加行号以清晰）的声明：
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Reading the inline function declaration might not be quite trivial, but it is
    quite straightforward to understand because it has predefined semantics within
    some syntaxes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读内联函数声明可能并不十分简单，但由于它在某些语法中有预定义的语义，因此理解起来相当直接。
- en: 'The following explains the semantics:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解释了其语义：
- en: Line 1 defines an inline function declaration definition.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第1行定义了内联函数声明定义。
- en: Line 2 defines function arguments signature that has a signature of `^a -> ^b
    -> ^c`. It has type definitions to the effect that parameters `a`, `b`, and `c`
    are generic type parameters that are statically typed.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第2行定义了函数参数签名，其签名为`^a -> ^b -> ^c`。它具有类型定义，其效果是参数`a`、`b`和`c`是静态类型的泛型类型参数。
- en: Line 3 defines constraints (using `when` keyword) for `^a` or `^b` to the effect
    that it must have a static member of the `*` operator implemented within the `^a`
    or `^b`. It means that `^a` or `^b` must have implementations of the `*` operator
    which has arguments of `a` and `b`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第3行定义了`^a`或`^b`的约束（使用`when`关键字），其效果是它必须在`^a`或`^b`内部实现`*`操作符的静态成员。这意味着`^a`或`^b`必须实现具有`a`和`b`作为参数的`*`操作符。
- en: Now that we have grabbed the contextual meaning of the inline function semantics,
    it is easier to see that type inference also plays an important role inferring
    the operation of the function, going deeper into explicitly adding constraints
    to define that the operator must be implemented in the generic type.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经抓取了内联函数语义的上下文意义，那么就可以更容易地看出类型推断在推断函数操作中也起着重要作用，这涉及到显式添加约束来定义操作符必须在泛型类型中实现。
- en: This constraint gives the meaning and reasoning why it is called statically
    typed parameter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束给出了为什么它被称为静态类型参数的意义和推理。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: C# has comparable generic constraints keyword that are similar to F#'s `when`
    keyword, the generic constraint limiting of `where` keyword. This `where` keyword
    in the generic type constraint declaration/definition is different from the `where`
    keyword in LINQ because the `where` keyword in LINQ is actually translated into
    call to `Enumerable.Where` or `Queryable.Where`, depending on which LINQ provider
    is used.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有类似的泛型约束关键字，类似于 F# 的 `when` 关键字，`where` 关键字的泛型约束限制。在泛型类型约束声明/定义中的 `where`
    关键字与 LINQ 中的 `where` 关键字不同，因为 LINQ 中的 `where` 关键字实际上被翻译为对 `Enumerable.Where` 或
    `Queryable.Where` 的调用，具体取决于使用的 LINQ 提供程序。
- en: 'Based on the definition of inline functions, the type will be made available
    at compile time: therefore, the type resolution is done at compile time. This
    will add some overhead, especially if the inline function contains complex operations.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 根据内联函数的定义，类型将在编译时可用：因此，类型解析是在编译时完成的。这可能会增加一些开销，特别是如果内联函数包含复杂操作的话。
- en: 'Let''s see these inline functions used by other functions, by creating quick
    symbolic properties to test them:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建快速符号属性来测试这些内联函数被其他函数使用的情况：
- en: '[PRE30]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s put these inline functions and the test functions inside a module, called
    `InlineFunctions`. Now, let''s see the generated IL of the `InlineFunctions` module
    by using ILDASM:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些内联函数和测试函数放入一个模块中，称为 `InlineFunctions`。现在，让我们使用 ILDASM 来查看 `InlineFunctions`
    模块的生成 IL：
- en: '![Best practices in implementing inline functions](img/image00323.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![实现内联函数的最佳实践](img/image00323.jpeg)'
- en: 'The compiled inline functions are compiled under the following names:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的内联函数被编译为以下名称：
- en: 'The `inlinemul` function is compiled as `inlinemul: !!c <a,b,c>(!!a a, !!b
    b)`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inlinemul` 函数被编译为 `inlinemul: !!c <a,b,c>(!!a a, !!b b)`'
- en: 'The inline `^*` operator is compiled as `op_HatMultiply: !!c <a,b,c>(!!a a,
    !!b b)`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '内联操作符 `^*` 被编译为 `op_HatMultiply: !!c <a,b,c>(!!a a, !!b b)`'
- en: 'Let''s look at the IL of `inlinemul`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `inlinemul` 的 IL：
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding IL is explained as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面 IL 的解释：
- en: The overall semantic of `inlinemul` and `op_HatMultiply` are basically the same
    because the body is using the same generated IL from the same expression of `a
    * b`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`inlinemul` 和 `op_HatMultiply` 的整体语义基本上是相同的，因为它们的主体使用了从 `a * b` 的相同表达式中生成的相同
    IL。'
- en: Operator `^*` is compiled into IL as the `op_HatMultiply` function method.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作符 `^*` 被编译为 IL 中的 `op_HatMultiply` 函数方法。
- en: The compiled prefix of `!!` in the parameter declaration means it is defined
    as compiled IL from statically typed parameter. It is unique in F# generated IL,
    and this might change in the future because it is considered as an implementation
    detail of how F# treats the statically typed parameters to be compiled into IL.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数声明中的编译前缀 `!!` 表示它被定义为从静态类型参数编译的 IL。这在 F# 生成的 IL 中是独特的，并且这可能会在未来发生变化，因为它被认为是
    F# 处理要编译为 IL 的静态类型参数的实现细节。
- en: The parameters of `a` and `b` are allocated and stored onto the stack, which
    is then passed as a parameter to `LanguagePrimitives.MultiplyDynamic` because
    we are using multiplication in the function body.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a` 和 `b` 的参数被分配并存储到栈上，然后作为参数传递给 `LanguagePrimitives.MultiplyDynamic`，因为我们函数体中使用了乘法操作。'
- en: 'The returning result is also marked as statically typed generics, compiled
    with the same `!!` prefix. Again, this is the implementation detail of emitted
    IL from F# compiler and this might change. But the same rule of thumb is applied
    in the IL: the compiler generates different IL for statically typed parameters
    and common generic type parameters.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的结果也被标记为静态类型泛型，使用相同的 `!!` 前缀进行编译。再次强调，这是 F# 编译器生成的 IL 的实现细节，并且可能会发生变化。但在 IL
    中应用了相同的经验法则：编译器为静态类型参数和通用类型参数生成不同的 IL。
- en: 'Now, let''s explore the IL of `inlinemul` usage, the `MulIntTest` property:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索 `inlinemul` 的 IL 使用情况，即 `MulIntTest` 属性：
- en: '[PRE32]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We now see other proofs that F# type inference is powerful because this symbolic
    property is translated into a property with only a getter, as defined with `.get`
    getter declaration. This getter calls the `get_MulIntTest` method. The `get_MulIntTest`
    method is defined in the following IL:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到其他证据表明 F# 类型推断功能强大，因为这种符号属性被翻译为只包含获取器的属性，如使用 `.get` 获取器声明定义的。这个获取器调用 `get_MulIntTest`
    方法。`get_MulIntTest` 方法在以下 IL 中定义：
- en: '[PRE33]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This `ldsfld` instruction means that the code pushes the value of `MulIntTest@9`
    result onto the stack. Because of the fact that all operations are compiled into
    IL instructions that utilize the stack, the performance is quite fast.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `ldsfld` 指令意味着代码将 `MulIntTest@9` 结果的值推入堆栈。由于所有操作都被编译成利用堆栈的 IL 指令，性能相当快。
- en: However, if the implementation body of an inline function is more complex (more
    than one operator is involved), then all calls to the inline function will have
    large overheads of multiple calls to respective dynamic operators, which then
    has many indirections of having to specify the type information for the call site
    (the function that calls the inline function or inline operator). These overheads
    of stack allocations of type translations and call site stack frame allocations
    will decrease performance at the initial run.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果内联函数的实现体更复杂（涉及多个运算符），那么对内联函数的所有调用都将有大量调用相应动态运算符的开销，这会导致许多需要指定调用点（调用内联函数或内联运算符的函数）类型信息的中介。这些类型转换的堆分配和调用点堆栈帧分配的开销将降低初始运行的性能。
- en: We can also safely conclude that inline functions are best for functions that
    focus on simple generic types that incorporate simple arithmetic, although inline
    functions can speed up recursive operations, for example when dealing with operations
    that have a recursive nature of iterating head and tail of F# native list, a linked
    list.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以安全地得出结论，内联函数最适合关注简单泛型类型且包含简单算术的函数，尽管内联函数可以加速递归操作，例如在处理具有递归性质的迭代 F# 原生列表（链表）的头和尾的操作时。
- en: Now that we understand the IL generated and the gory details of how the statically
    typed parameter works with inline functions, we now understand the integrated
    part of the inline function with the call site.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了生成的 IL 和静态类型参数与内联函数一起工作的细节，我们现在理解了内联函数与调用点的集成部分。
- en: It is integrated in a sense that each usage of our inline functions will translate
    the type parameter from the call site, and each call site can have its own type,
    regardless of whether it is different or the same.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们内联函数的每次使用都会将类型参数从调用点转换过来，每个调用点都可以有自己的类型，无论它是否不同或相同。
- en: Identifying tail call in recursive constructs
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在递归结构中识别尾调用
- en: One of the characteristics of a functional programming language is the common
    use of recursive constructs in many of the implementation of the functions; F#
    compiler itself is also a good sample of code that has many implementations of
    recursive constructs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言的一个特点是，在许多函数的实现中普遍使用递归结构；F# 编译器本身也是一个很好的示例，它包含了许多递归结构的实现。
- en: Functional programming languages always prefer to have recursive constructs
    instead of having loops or iterative constructs because recursive is better to
    use in the most complex calculations or in any operation that requires the ability
    to perform the same operation when the problem solving or calculation is broken
    into smaller problems.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言总是更喜欢使用递归结构而不是循环或迭代结构，因为递归在处理最复杂的计算或任何需要将问题分解为更小问题以执行相同操作的操作时更为有用。
- en: Having recursive calls is quite common in F#, and it is recommended to optimize
    further to have tail call optimization, although the optimization may not be applied
    to all the cases.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，递归调用相当常见，建议进一步优化以实现尾调用优化，尽管优化可能不会应用于所有情况。
- en: Overview of recursion in functional programming
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程中递归的概述
- en: The use of recursion is more apparent in dealing with problems that require
    resolving problems into smaller problems with the same algorithm. This is why,
    in many cases, using iterations such as loop is not preferred because a loop will
    add more complexity in the form of exponential steps instead of relying on a return
    mechanism after resolving smaller problems.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理需要将问题分解为具有相同算法的更小问题的场景中，递归的使用更为明显。这就是为什么在许多情况下，使用迭代（如循环）并不被推荐，因为循环会在解决较小问题后增加更多以指数级步骤形式存在的复杂性，而不是依赖于返回机制。
- en: For example, we can write a factorial function to be implemented using a loop,
    but then this loop becomes more complex to write because the number of loops might
    be large, and there will be overhead in the initial memory allocations instead
    of going deeper into performing the calculation recursively. Going deeper into
    performing the calculation or doing some processes requires a returning point
    to remember if the calculation is done and if the calculation is called by a previous
    calculation.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个使用循环实现的阶乘函数，但这样写会使循环变得更加复杂，因为循环的次数可能很大，而且初始内存分配会有开销，而不是更深入地递归执行计算。更深入地执行计算或执行某些过程需要返回点来记住计算是否完成以及计算是否被前一个计算调用。
- en: The consequences of this returning nature after finishing the final smallest
    problem require us to have a stack to store the locations and the state of the
    calculation. When the calculation takes long or deep levels of recursions, most
    codes will throw `StackOverflowException` because the stack allocation is exhausted.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成最终最小问题后的这种返回性质所带来的后果要求我们有一个栈来存储计算的位置和状态。当计算时间较长或递归层次较深时，大多数代码会抛出 `StackOverflowException`，因为栈分配已耗尽。
- en: 'F# has support for common recursive functions by marking it with the `rec`
    keyword as a requirement to indicate an explicit recursive function only if the
    function body contains a call to itself. This is the easiest concept of recursion:
    *a function that calls itself*. It is the most common because most of us get used
    to the idea of recursive in recursive functions, which is a function that calls
    itself.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: F# 通过使用 `rec` 关键字来支持常见的递归函数，作为显式递归函数的要求，只有当函数体包含对自身的调用时才需要标记。这是递归的最基本概念：*一个调用自身的函数*。它是最常见的，因为大多数人都习惯了递归函数中的递归概念，即一个调用自身的函数。
- en: 'However, in terms of a functional programming language, the traits of recursive
    constructs are broader:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在函数式编程语言中，递归结构的特性更广泛：
- en: A function that calls itself. This concept of a function that calls itself is
    the most common and also the easiest construct to understand. It is also by definition
    quite self-explanatory. This construct is also widely used not just in functional
    programming languages but also in non-functional programming languages, such as
    C#, VB, and C++.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个调用自身的函数。这个调用自身函数的概念是最常见且最容易理解的。它也是定义上相当自解释的。这种结构不仅在函数式编程语言中广泛使用，而且在非函数式编程语言中也很常见，如C#、VB和C++。
- en: A function that has a function as an argument, and then the function body contains
    a call to the function that is defined as an argument of the calling function.
    This trait might be confusing at first, but it is quite trivial when we see the
    examples later.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个将函数作为参数的函数，并且函数体包含对作为调用函数参数定义的函数的调用。这种特性一开始可能有些令人困惑，但当我们看到后面的例子时，它就相当简单了。
- en: A function that contains flow branches that always end up with function calls
    to itself. This is quite similar to a function that takes a function as its parameter
    that contains a call to a function as its argument. In the end, both of the last
    expressions evaluated are functions, not constants or statements.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含总是以对自身进行函数调用的流程分支的函数。这与一个将函数作为其参数的函数非常相似，该函数将函数作为其参数进行调用。最终，两个最后评估的表达式都是函数，而不是常量或语句。
- en: An example of point 1 is the most common, and it is also the most understood
    form of recursion.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点的例子是最常见的，也是对递归最容易被理解的形式。
- en: 'For example, consider the following code for a factorial function:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下阶乘函数的代码：
- en: '[PRE34]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this factorial function, we implement the branching using pattern matching,
    and this is useful and more correct because all the conditions of possible values
    of `n` are checked.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶乘函数中，我们使用模式匹配来实现分支，这很有用且更正确，因为所有可能的 `n` 值的条件都被检查。
- en: Point 2 and point 3 require a deeper understanding of the nature of a curried
    function and how recursion does not stop at only one case of when a function calls
    itself, but also naturally has further optimizations that can be compiled as a
    loop or any other optimization such as a tail call optimization.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点和第三点需要更深入地理解柯里化函数的本质以及递归不仅停止在函数调用自身的一个案例，而且自然具有可以编译为循环或其他优化（如尾调用优化）的进一步优化。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The factorial function is one of the best examples to have the deciding factor
    of recursion. It is better to understand factorials as recursive instead of iterative.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数是具有递归决定因素的最好例子之一。理解阶乘作为递归而不是迭代会更好。
- en: 'If we call a factorial with a very large number, such as 50,000, the stack
    allocation will be quickly exhausted, and therefore there will be no more stack
    available for us. The function will throw `StackOverflowException` to inform that
    it is running out of stack and the stack that contains the returning state is
    full. In order to avoid or handle this exception, we can do one of these:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用一个非常大的数字调用阶乘，例如 50,000，栈分配将很快耗尽，因此将没有更多的栈可供我们使用。函数将抛出 `StackOverflowException`
    来通知它正在耗尽栈，并且包含返回状态的栈已满。为了避免或处理此异常，我们可以做以下之一：
- en: We change the implementation to use a loop instead, but this is not feasible
    for all cases of recursion by nature.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现改为使用循环，但这是递归的许多情况中不切实际的。
- en: We can rely on compiler optimization because F# compiler will do its own optimization
    by translating common recursive functions into loop with IL optimization.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以依赖编译器优化，因为 F# 编译器将通过将常见的递归函数转换为带有 IL 优化的循环来自行进行优化。
- en: We can use tail call optimization by implementing recursive with a specific
    pattern.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过实现具有特定模式的递归来使用尾调用优化。
- en: The last point, using tail call, is the most efficient optimization but it requires
    more understanding to implement it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，使用尾调用，是最有效的优化，但需要更多的理解来实现它。
- en: Tail call recursion in F# and .NET CLR
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 和 .NET CLR 中的尾调用递归
- en: It is also common in many functional programming languages to have a tail call
    optimization in recursive constructs. Tail call recursion means that any recursion
    is optimized not to use stack instead of optimizing it to have a tail call.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多函数式编程语言中，在递归结构中实现尾调用优化也是很常见的。尾调用递归意味着任何递归都会被优化，不使用栈，而不是优化为尾调用。
- en: F# supports both common recursion and tail call optimized recursion; tail call
    support is also available in .NET CLR.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: F# 支持常见的递归和尾调用优化递归；尾调用支持也存在于 .NET CLR 中。
- en: What is tail call? A tail call means a function that has a call within a function
    whose result is immediately used as the output of the function. It is then a call
    that has a tail in its call to a function, usually as the last result of a calculation.
    The position is usually at the last position to mark the call; this is why it
    is called a tail call.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是尾调用？尾调用意味着一个函数在其内部有一个调用，其结果立即用作函数的输出。然后是一个在其函数调用中具有尾部的调用，通常作为计算的最后一个结果。位置通常在最后一个位置标记调用；这就是为什么它被称为尾调用。
- en: 'The definitive and full explanation of a tail call in F# is explained in this
    MSDN blog from the Visual F# team:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中尾调用的 definitive 和完整解释可以在 Visual F# 团队的 MSDN 博客中找到：
- en: '[https://blogs.msdn.microsoft.com/fsharpteam/2011/07/08/tail-calls-in-f/](https://blogs.msdn.microsoft.com/fsharpteam/2011/07/08/tail-calls-in-f/)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/fsharpteam/2011/07/08/tail-calls-in-f/](https://blogs.msdn.microsoft.com/fsharpteam/2011/07/08/tail-calls-in-f/)'
- en: Identifying tail call optimized implementation
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别尾调用优化实现
- en: According to the MSDN blog, tail call is a call in tail position implemented
    recursively because the last expression is a function, not a composite expression,
    such as an addition between numbers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 根据MSDN博客，尾调用是一种在尾位置实现的递归调用，因为最后一个表达式是一个函数，而不是一个复合表达式，例如数字之间的加法。
- en: 'A common sample of an expression that contains composite expression is the
    following function:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 包含复合表达式的表达式的一个常见示例是以下函数：
- en: '[PRE35]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The code tells us that the call to `sumList` is followed with a `+` operator;
    therefore, it is obvious that this calculation is not a simple call to only a
    function. Therefore, it is not implemented to have a tail call.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 代码告诉我们，对 `sumList` 的调用后面跟着一个 `+` 操作符；因此，很明显，这个计算不是一个只调用函数的简单调用。因此，它没有实现尾调用。
- en: 'To prove that `sumList` does not have a tail call, let''s look at the IL:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明 `sumList` 没有尾调用，让我们看看 IL：
- en: '[PRE36]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is no tail call IL in the compiled `sumList` function. Although it is
    recursive in the code, `sumList` is compiled to use an iterative loop, as indicated
    by the `br.s` instruction at line `IL_000b` to call the `FSharpList,get_TailOrNull`
    function.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 编译的 `sumList` 函数中没有尾调用 IL。尽管它在代码中是递归的，但 `sumList` 被编译为使用迭代循环，如行 `IL_000b` 中的
    `br.s` 指令所示，以调用 `FSharpList,get_TailOrNull` 函数。
- en: Let's try to implement the tail call function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试实现尾调用函数。
- en: 'The tail call optimization is not available by default; we have to turn it
    on based on the project scope, not on the solution scope. To turn on tail call
    optimization, open the project''s properties and select the **Build** tab. This
    tab contains all the properties of the F# project, including the runtime target
    of 32-bit and 64-bit. Set the checkbox of **Generate tail calls** as illustrated
    in the following screenshot:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用优化不是默认启用的；我们必须根据项目范围而不是解决方案范围来启用它。要启用尾调用优化，请打开项目的属性并选择**构建**选项卡。此选项卡包含F#项目的所有属性，包括32位和64位的运行时目标。设置**生成尾调用**复选框，如图下所示：
- en: '![Identifying tail call optimized implementation](img/image00324.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![识别尾调用优化实现](img/image00324.jpeg)'
- en: 'Let''s examine the simplest function that has an argument that is typed as
    a function, then the main function body calls the function of the argument:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个最简单的函数，它有一个作为函数类型参数的参数，然后主函数体调用参数的函数：
- en: '[PRE37]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function is implemented to have tail call support because it minimizes
    stack allocation, while the recursion still applies. This is possible because
    it fits the pattern to have tail call as the last expression in a function.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被实现为支持尾调用，因为它最小化了栈分配，同时仍然应用递归。这是因为它符合将尾调用作为函数中最后一个表达式的模式。
- en: 'Let''s check the IL of `apply`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`apply`的IL：
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we have a tail call optimization, as indicated in line `IL_0003` that contains
    the `tail.` instruction.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了尾调用优化，如`IL_0003`行所示，其中包含`tail.`指令。
- en: 'Now let''s apply tail call optimization to calculate the factorial. Let''s
    create a new function of the factorial that contains a recursive inner function.
    This inner function has recursive calls to the inner function itself:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来应用尾调用优化来计算阶乘。让我们创建一个新的阶乘函数，它包含一个递归的内联函数。这个内联函数对自身进行递归调用：
- en: '[PRE39]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And this is the IL of `accFactorial`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`accFactorial`的IL：
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We now have a tail call recursion in our function. In the next section, we will
    discuss the advantages of having tail call optimization.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的函数中有了尾调用递归。在下一节中，我们将讨论具有尾调用优化的优点。
- en: Advantages of having tail call recursive implementation
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有尾调用递归实现的优点
- en: Having tail call is a common technique in functional programming languages.
    Fortunately, F# is not just a single part of this tail call because tail call
    is also supported at the .NET runtime level, in a sense that the .NET CLR has
    IL support for tail call.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程语言中，具有尾调用是一种常见的技术。幸运的是，F#不仅仅是一个尾调用的部分，因为尾调用在.NET运行时级别也得到了支持，从某种意义上说，.NET
    CLR对尾调用有IL支持。
- en: It is a very useful and powerful feature of F# because of the tight coupling
    of F# compiler and the generated IL on .NET; therefore, optimization is available
    in the compiled phase and in the runtime.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为F#编译器和生成的.NET IL之间的紧密耦合，所以F#是一个非常有用且强大的功能；因此，优化可以在编译阶段和运行时进行。
- en: 'Let''s compare the stack trace of our initial (unoptimized) factorial function
    with the optimized tail call factorial function:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较我们的初始（未优化）阶乘函数与优化后的尾调用阶乘函数的堆栈跟踪：
- en: '![Advantages of having tail call recursive implementation](img/image00325.jpeg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![具有尾调用递归实现的优点](img/image00325.jpeg)'
- en: 'Let''s look at `accFactorial`''s stack trace. Our tail call optimized function''s
    stack trace shows that it has only one stack trace of `accFactorial`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`accFactorial`的堆栈跟踪。我们的尾调用优化函数的堆栈跟踪显示它只有一个`accFactorial`的堆栈跟踪：
- en: '![Advantages of having tail call recursive implementation](img/image00326.jpeg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![具有尾调用递归实现的优点](img/image00326.jpeg)'
- en: It proves that tail call optimization is very efficient because we only have
    one stack allocation. This is also faster than having no tail call optimization
    because there is minimal stack allocation overhead or is close to only having
    stack allocation once.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了尾调用优化非常高效，因为我们只有一个栈分配。这也比没有尾调用优化要快，因为栈分配的开销最小或接近只有一次栈分配。
- en: Although F#'s tail call optimization is a powerful optimization, its implementation
    is limited to specific cases, as described in the next section.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然F#的尾调用优化是一种强大的优化，但其实现仅限于特定的案例，如下一节所述。
- en: Limitations of tail call recursion in F#
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#中尾调用递归的限制
- en: There are limitations on how tail call is implemented, especially for F#-specific
    cases. Not all kinds of function can have tail call optimizations, mostly because
    of the nature of tail call itself.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归的实现存在限制，尤其是在 F# 特定的情况下。并非所有类型的函数都可以进行尾递归优化，这主要是因为尾递归本身的性质。
- en: 'The following are the limitations and restrictions of tail call optimization
    in F#:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 F# 中尾递归优化的限制和约束：
- en: Tail call optimizations will not be implemented on functions that return `Unit`
    (or `void` in C#/VB). This is important and natural because tail call relies on
    the returning the result from the last result of recursive function as a position
    to have tail call. The compiler will confuse the IL emission because F# has `Unit`,
    other languages such as C# that has `void`. Also all functions that return `void`
    are not compatible with F# functions that return `Unit`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尾递归优化不会在返回 `Unit`（或在 C#/VB 中的 `void`）的函数上实现。这是重要且自然的，因为尾递归依赖于从递归函数的最后结果返回结果作为尾递归的位置。编译器会因为
    F# 有 `Unit`，其他如 C# 这样的语言有 `void` 而混淆 IL 生成。此外，所有返回 `void` 的函数都与返回 `Unit` 的 F#
    函数不兼容。
- en: Tail call cannot be implemented within `try...with` constructs. It is also recommended
    that the exception handling should not be included in the body of the recursive
    function.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尾递归不能在 `try...with` 构造中实现。还建议不要在递归函数的主体中包含异常处理。
- en: Tail call cannot be used to optimize calls to unsafe functions. Forcing to mix
    tail call with native unmanaged calls will yield unpredictable behavior and results.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尾递归不能用于优化对不安全函数的调用。强制将尾递归与原生非托管调用混合将产生不可预测的行为和结果。
- en: The limitations just listed are simply not restrictions for all recursive cases
    specially exception handling.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才列出的限制并不是对所有递归情况，特别是异常处理的限制。
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have enough knowledge to optimize common and subtle F# language constructs-from
    pattern matching combined with active pattern to the subtle F# features, such
    as inline functions, tail call recursion optimizations, and tail call identification.
    These constructs are features that make F# competitively unique in the .NET ecosystem.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有足够的知识来优化常见的和微妙的 F# 语言结构——从结合主动模式的模式匹配到内联函数、尾递归优化和尾递归识别等细微的 F# 功能。这些结构是使
    F# 在 .NET 生态系统中具有竞争优势的独特特性。
- en: Pattern matching and active patterns can be optimized without sacrificing correctness
    and functional style. We are now able to enforce type strictness by using statically
    typed generic parameters in conjunction with inline functions. Having tail calls
    in recursion optimization in F# is not only more efficient but also gives us a
    good exercise of optimizing at code level by identifying tail call semantics.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配和主动模式可以在不牺牲正确性和函数式风格的情况下进行优化。我们现在能够通过使用静态类型泛型参数结合内联函数来强制执行类型严格性。在 F# 中，尾递归优化不仅更高效，而且通过识别尾递归语义，也为我们提供了在代码级别进行优化的良好练习。
- en: 'Now, it''s time to optimize F# complex features and constructs that deserve
    a separate chapter: [Chapter 8](fsp-hiperf_cu08.html#aid-1JFUC2 "Chapter 8. Optimizing
    Computation Expressions"), *Optimizing Computation Expressions*.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候优化 F# 的复杂特性和结构，这些特性和结构值得单独成章：[第 8 章](fsp-hiperf_cu08.html#aid-1JFUC2 "第
    8 章。优化计算表达式")，*优化计算表达式*。
