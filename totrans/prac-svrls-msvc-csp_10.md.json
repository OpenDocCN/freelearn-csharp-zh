["```cs\npublic class JWT\n{\n  // Private field to store the JWT token\n  private JwtSecurityToken token;\n  // Internal constructor to initialize the JWT with a given token\n  internal JWT(JwtSecurityToken token)\n  {\n    this.token = token;\n  }\n  // Property to get the expiration date and time of the token\n  public DateTime ValidTo => token.ValidTo;\n  // Property to get the string representation of the token\n  public string Value => \n    new JwtSecurityTokenHandler().WriteToken(this.token);\n}\ninternal class JWTBuilder \n{\n  public JWT  Build() // Method to build the JWT. JWT is an object \n{\n    var claims = new List<Claim> // Creating a list of claims\n    {\n       new Claim(JwtRegisteredClaimNames.Sub,this.subject), \n       new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) \n    }.Union(this.claims.Select(item => new Claim(item.Key, item.Value))); \n    var token = new JwtSecurityToken( \n      issuer: this.issuer, \n      audience: this.audience, \n      claims: claims, \n      expires: DateTime.UtcNow.AddMinutes(expiryInMinutes), \n      signingCredentials: new SigningCredentials( \n        this.securityKey, \n        SecurityAlgorithms.HmacSha256) \n    );\n    return new JWT(token);\n  }\n} \n```", "```cs\nprivate static async Task GetUserProfile()\n{\n  IPublicClientApplication clientApp = PublicClientApplicationBuilder\n    .Create(clientId)\n    .WithRedirectUri(redirectUri)\n    .WithAuthority(AzureCloudInstance.AzurePublic, \"common\")\n    .Build();\n  var resultadoAzureAd = await clientApp.AcquireTokenInteractive(scopes)\n    .WithPrompt(Prompt.SelectAccount)\n    .ExecuteAsync();\n  if (resultadoAzureAd != null)\n  {\n    // Print the username of the authenticated user\n    Console.WriteLine(\"User: \" + resultadoAzureAd.Account.Username);\n  }\n} \n```", "```cs\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: example-network-policy\n  namespace: example-namespace\nspec:\n  podSelector:\n    matchLabels:\n      myLabel: matValue\n      myLabel1: matValue1\n  policyTypes: # may be either Ingress, or Egress or both\n  - Ingress \n  - Egress\n  ingress:\n  - from:\n      ….\n  egress:\n  - to:\n    ---- \n```", "```cs\n    - ipBlock:\n            cidr: 172.17.0.0/16\n            except:\n            - 172.17.1.0/24 \n    ```", "```cs\n    - podSelector:\n          matchLabels:\n          podlabel1: podvalue1 \n          … \n    ```", "```cs\n    - namespaceSelector:\n          matchLabels:\n            namespacelabel1: namespacevalue1\n            … \n    ```", "```cs\n- namespaceSelector:\n    matchLabels:\n      namespacelabel1: namespacevalue1\n  podSelector:\n    matchLabels:\n      podlabel1: podvalue1 \n```", "```cs\nports:\n  - protocol: TCP\n    port: 6379\n   …\n  - protocol: TCP\n    port: 8000\n    endPort: 9000 \n```", "```cs\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: example-network-policy\n  namespace: mysample\nspec:\n  podSelector: {}\n  policyTypes: \n  - Ingress \n  ingress:\n  - from:\n    - podSelector:{}\n    - namespaceSelector:\n      matchExpressions:\n      - key: namespace\n        operator: In\n        values: [\"mysafe\"] \n```", "```cs\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: example-network-policy\n  namespace: mysample\nspec:\n  podSelector: {}\n  policyTypes: \n  - Ingress \n  ingress:\n  - from:\n    - podSelector:{}\n    - namespaceSelector:\n      matchExpressions:\n      - key: namespace\n        operator: In\n        values: [\"mysafe\"]\n    ports:\n    - protocol: TCP\n      port: 80 \n```", "```cs\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: access-control\n  namespace: militarized-zone\nspec:\n  podSelector: \n    matchLabels:\n      role: access-control\n  policyTypes: \n  - Ingress \n  ingress:\n  - from:\n    - podSelector:{}\n    - namespaceSelector:{} \n```", "```cs\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: access-control\n  namespace: militarized-zone\nspec:\n  podSelector: \n    matchExpression:\n    - key: role\n      operator: NotIn\n      values: [\"access-control\"]\n  policyTypes: \n  - Ingress \n  ingress:\n  - from:\n    - podSelector:{} \n```", "```cs\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: <namespace name> \n  name: <role name>\nrules:\n- apiGroups: [\"\"] # \"\" indicates the core API group\n  resources: [\"pods\"]\n  verbs: [\"get\", \"watch\", \"list\"] # also \"create\", \"update\", \"patch\", \"delete\" \n```", "```cs\n        kubectl patch pod <pod name> -p '{\"spec\":{\"containers\":[{\"name\":\"kubernetes-serve-hostname\",\"image\":\"new image\"}]}}' \n        ```", "```cs\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: my-app\n  name: developer-user-role\nrules:\n- apiGroups: [\"\", \"apps\"]\n  resources: [\"pods\", \"services\", \"configmaps\", \"secrets\", \"deployments\", \"replicasets\"]\n  verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"delete\"] \n```", "```cs\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: <role binding name>\n  namespace: <reference namespace>\nsubjects:\n- kind: User # specific user\n  name: jane # \"name\" is case sensitive\n  apiGroup: rbac.authorization.k8s.io\n- kind: Group #user group\n  name: namespace:administrators  # \"name\" is case sensitive\n  apiGroup: rbac.authorization.k8s.io\n…\nroleRef:\n  # \"roleRef\" specifies the binding to a Role \n  kind: Role #this must be Role \n  name: <role-name> # this must match the name of the Role you wish to bind to\n  apiGroup: rbac.authorization.k8s.io \n```", "```cs\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: developers-binding\n  namespace: my-app\nsubjects:\n- kind: Group\n  name: developers\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: developer-user-role\n  apiGroup: rbac.authorization.k8s.io \n```", "```cs\n     openssl genrsa -out mynewuser.key 2048 \n    ```", "```cs\n    openssl req -new -key mynewuser.key -out mynewuser.csr -subj \"/CN= mynewuser /O=example:mygroup\" \n    ```", "```cs\n    cat mynewuser.csr | base64 | tr -d \"\\n\" \n    ```", "```cs\n    apiVersion: certificates.k8s.io/v1\n    kind: CertificateSigningRequest\n    metadata:\n      name: mynewuserrequest\n    spec:\n      request: <base64 encoded csr>\n      signerName: kubernetes.io/kube-apiserver-client\n      expirationSeconds: <duration in seconds>\n      usages:\n      - client: auth \n    ```", "```cs\n    Kubectl apply -f mynewuserrequest.yaml. \n    ```", "```cs\n    kubectl certificate approve mynewuserrequest \n    ```", "```cs\n    kubectl get csr mynewuserrequest -o jsonpath='{.status.certificate}'> mytempfile.txt \n    ```", "```cs\n    cat mytempfile.txt | base64 -d > mynewuser.crt \n    ```", "```cs\naz role assignment create `\n--assignee <USER IDENTITY RESOURCE ID> `\n--role <ROLE NAME> `\n--scope <ENVIRONMENT OR APPLICATION_RESOURCE_ID> \n```", "```cs\nvar builder = WebApplication.CreateBuilder(args);\n// Retrieve Application Insights connection string from configuration\nstring appInsightsConnectionString = builder.Configuration[\n  \"AzureMonitor:ConnectionString\"];\nbuilder.Services.AddOpenTelemetry()\n  .WithTracing(tracerProviderBuilder =>\n  {\n    tracerProviderBuilder\n      // Set resource builder with application name\n      .SetResourceBuilder(\n        ResourceBuilder.CreateDefault().AddService(\n          builder.Environment.ApplicationName))\n      // Add ASP.NET Core instrumentation\n      .AddAspNetCoreInstrumentation()\n      // Add HTTP client instrumentation\n      .AddHttpClientInstrumentation()\n      // Add Azure Monitor Trace Exporter with connection string\n      .AddAzureMonitorTraceExporter(options =>\n      {\n        options.ConnectionString = appInsightsConnectionString;\n      });\n  });\n// Add Application Insights only for logging & metrics \n// (without re-adding tracing)\nbuilder.Services.AddApplicationInsightsTelemetry(options =>\n{\n  options.ConnectionString = appInsightsConnectionString;\n  // Disable AI's automatic trace sampling\n  options.EnableAdaptiveSampling = false; \n  // Prevents duplicate dependency tracking\n  options.EnableDependencyTrackingTelemetryModule = false; \n  // Prevents duplicate HTTP request tracking\n  options.EnableRequestTrackingTelemetryModule = false; \n});\nvar app = builder.Build(); \n```", "```cs\n// Map GET request to /error endpoint\napp.MapGet(\"/error\", async (HttpContext context) =>\n{\n  var httpClient = new HttpClient();\n  var response = await httpClient.GetAsync(\n    \"https://anyhost.sample.com/data\");\n  return \"Hello Trace!\";\n}); \n```", "```cs\n// Map GET request to /success endpoint\napp.MapGet(\"/success\", async (HttpContext context) =>\n{\n  var httpClient = new HttpClient();\n  var response = await httpClient.GetAsync(\"https://www.packtpub.com/\");\n  return \"Hello Trace!\";\n}); \n```"]