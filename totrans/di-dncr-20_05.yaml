- en: Object Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency Injection
    in ASP.NET Core*, we got an insight into Dependency Injection with .NET Core and
    ASP.NET Core with default DI Container. We explored how to apply DI to different
    components of the application like controllers and views. Now it's time to deep
    dive into the actual fundamentals behind Dependency Injection.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving forward with the main topic, we need to first understand why do
    we even care to read about this topic. The programming world is surrounded with
    objects and their interactions. We achieve certain solutions or build features
    getting help from classes that we generate for two basic reasons that are **code
    reuse** and **maintainability**.
  prefs: []
  type: TYPE_NORMAL
- en: Now you might ask me why create classes at all! Yes, I second you, unless you
    ask me to alter code after some days. Then, even I can't help you because that
    will be a nightmare for me. And you know why? That is because I might have to
    repeat the codes (you have already written) in my new classes.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have a class named `Customer` with the properties `CustomerId`,
    `FirstName`, `LastName`, `Email`, `MobileNumber`, `Address1`, `Address2`, `City`
    and so on. I come in and start working on another entity named as `Seller` with
    the properties `SellerId`, `FirstName`, `LastName`, `Email`, `MobileNumber`, `Address1`,
    `Address2`, `City` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: I think you are smart enough to identify the problem. We can see the properties
    which are *italicised* are getting repeated. One solution to this problem would
    be to create another class, something named `User` with all those common properties.
    Then, the `Customer` and `Seller` classes become its children. Thus, we will achieve
    a simple design to deal with future entities as well. I can easily reuse the `User`
    class to create some other child class, which would inherit the common properties
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, this chapter plays an important role in helping you grab these relationships.
    Designing a complex class with smaller flexible and reusable classes is an essential
    part of a software project, which will be the focused of this chapter. The following
    are the key topics that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition over Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of Object Composition in Dependency Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object Composition in .NET Core 2.0 Console and MVC Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding object relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to understand object relationships by first considering human relationships.
    The examples may not be the aptest but if we want to learn about object relationships,
    then why not look into it?
  prefs: []
  type: TYPE_NORMAL
- en: You depend on your parents till you get a job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a wife and two children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trees have blossom and leaves on them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A motherboard is part of a computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these relationships possess unique characteristics. Let me simplify my statement.
    You depend on your parents. However, if they become jobless, you are not going
    to die. You will find some way to deal with the situation. On the contrary, if
    a tree dies, its blossom and leaves will die eventually. The relationship between
    the tree and its parts are tightly coupled. After the tree gets a life (instantiated),
    within a short period of time, its parts come to life as well. A motherboard without
    a computer is useless. It comes into play when it becomes a component of a computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following code snippet to understand the relationship between
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have one `Organisation` class and `Packt`, being an organization, derives
    the parent class `Organisation`. This relationship is denoted as *is a* relationship
    because `Packt` is an organization. `Account` is a class, which can become *a
    part of* a `Packt` class. Thus, there is another relationship between `Packt`
    and `Account`. The name of the relationship is *a part of***.**
  prefs: []
  type: TYPE_NORMAL
- en: Notice the method `PrintPacktInfo()` inside `Packt` class, which prints all
    information regarding `Packt`. However, that is not all, because you can see there
    is an `Account` class instance generated inside the method by which we are able
    to print the account information of `Packt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Main` method looks as follows, where we create an instance of `Packt`
    and provide any necessary details through properties and then call `PrintPacktInfo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1e32247-cae9-4cf4-9e49-f75a0129a769.png)'
  prefs: []
  type: TYPE_IMG
- en: The important thing to take away from this example is the way the `Packt` class
    depends on the `Account` class. `Dependency` is generated inside the `Packt` class.
  prefs: []
  type: TYPE_NORMAL
- en: Like the preceding one, we can find patterns, relationships, and hierarchies
    in programming. Let's investigate these in more detail and learn how to improve
    code reusability and elasticity of classes.
  prefs: []
  type: TYPE_NORMAL
- en: Object Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When I searched for the word composition in Google, the first thing I saw was:'
  prefs: []
  type: TYPE_NORMAL
- en: the nature of something's ingredients or constituents; the way in which a whole
    or mixture is made up.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's very simple to guess what Object Composition would be. Objects collectively
    mix themselves to constitute (be a part of) complex objects.
  prefs: []
  type: TYPE_NORMAL
- en: A simple real life example would be a car whose whole body consists of different
    types of components like engine, break, gear, battery, door, etc. Thus, these
    parts are actually the building blocks of the car and are composed in a very innovative
    way by the maker of the car.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, as we discussed, the `Account` class reference inside the `Packt`
    class method in the last section, which generates a relationship among them. We
    can consider that as a dependency too, as we can't execute the method of the `Packt`
    class without an instance of `Account` class. Clearly, we can say that the `Packt`
    object composes itself with the help of the `Account` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice the bracketed phrase in the first paragraph *be* *a part of*?
    Confused! Let's discuss again and get hold of this phrase. In other words, this
    phrase can also be represented as *has a,* if I form the sentence from the complex
    object point of view. Refer the lines below.
  prefs: []
  type: TYPE_NORMAL
- en: A computer *has a* keyboard. (Keyboard *is a part of* computer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A car *has an* engine. (Engine *is a part of* car)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's pretty clear now, as you can see how these complex objects are made up
    of small objects conceptualizing Object Composition.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, different fundamental data types like `int`, `string`,
    boolean, and so on, or other class types, can be packaged into one structure or
    another class type, therefore, classes are often considered composite types.
  prefs: []
  type: TYPE_NORMAL
- en: The most important benefit of applying this concept to your projects is to get
    more easily manageable parts. Not only does it reduces the complexity of the application,
    but it also helps us to write code faster. Another noticeable advantage is code
    reuse, which leads to fewer errors as you will be using codes which have already
    been verified after testing.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Object Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two subtypes of Object Composition, **Composition** and **aggregation**.
    Let's discuss one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Composition is a way through which you can bind objects together. One object
    can contain another object of the same/another class as a building block.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, in our last example, `Packt` was dependent upon the `Account`
    class for its operation. The instance is created by the `Packt` class, giving
    life to it and then operated some function with the instance. You can add another
    class like `Packt` and do the same using an `Account` instance. Thus, you are
    trying to compose the objects to form a more complex one, which enables us to
    execute behavior (methods) of all composed/part objects with one composite object.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the relationships, which is satisfied by the object and it's
    member or part, qualify as a Composition.
  prefs: []
  type: TYPE_NORMAL
- en: '**The part** **(member) is a component of the object (class)**: As we have
    already discussed, the part or smaller class should be a part of the bigger complex
    class. For example, your kidney is a part of your body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The part (member) can only belong to one object (class) at a time**: If the
    smaller class is referred to the complex class at a certain period, then it can''t
    be a part of other classes at the same time. For example, your kidney, which is
    a part of your body, can''t be a part of someone else''s body at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The part (member) has its existence managed by the object (class)**: The
    object is responsible for the existence of the parts in a Composition relationship.
    In simple words, the part is created when the object is created and destroyed
    when the object is destroyed. This means the object manages the part''s lifetime
    in such a way that the user of the object does not need to get involved. For example,
    when a body is created, the kidney is created too. When a person''s body is destroyed,
    their kidney is destroyed too. Because of this, the Composition is sometimes called
    a **Death Relationship**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The part (member) does not know about the existence of the object (class):**
    A particular part in a Composition doesn''t know about the existence of the whole
    object. Your kidney is unaware that it is part of a larger structure but works
    as expected. This is called a **Unidirectional Relationship**. For example, the
    body knows about the kidney, but not the other way around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are thinking that as body parts can be transferable, why not member classes,
    then you are assuming right. Member classes can also be transferred. Thus, the
    new larger class is now the owner of the member class and the member class is
    no more related to the previous owner unless that is transferred again.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our favorite `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Come on, don''t be so surprised and please don''t scold me now. I know this
    looks like a very basic class, but that is what Composition is all about, in short.
    Don''t believe me? Alright, allow me to match those relationships with this `Student`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1: Part of a complex class**: You can see the class members which are
    of different types such as `Integer`, `string`, `DateTime`, `Class` and `List<Class>`
    type. `Integer`, `string`, and `DateTime` are the data types already defined inside
    the `System` namespace of .NET Framework, whereas the `Address` and `Book` classes
    are user-defined classes. All are part of a complex class `Student`. Thus, the
    first condition is satisfied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2: Members should belong to one object**: If I create an instance of
    the `Student` class, with a constructor, the members will only belong to the student
    object at that time. It can''t be a member of another instance. Moreover, the
    members are private, which prevents them being used by any other class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Rule 3: Members gets a life by the complex class (Death Relationship)**:
    As you can see, members don''t have any existence until we instantiate the `Student`
    class and they get destroyed when the object is dead; proving our rule 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 4: Members are unaware of the existence of the complex object (Unidirectional
    Relationship):** The members are very obedient. They just store whatever value
    is assigned to them and don''t even bother about who is assigning them for what
    reasons. The complex instance is their parent but these members behave like orphans
    and don''t recognize it. Likewise, we don''t mind what they are doing because
    our rule 4 is proved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important thing to note here is that the complex class can have a multiplicative
    member like `List<Book> Books`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you know the shortcut to create a constructor? Just type **ctor** at the
    line where you want the constructor and then hit the *Tab* key two times. You
    will see an empty constructor block available for you. Moreover, Visual Studio
    tooltip tells you how to handle the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/211734ba-9e84-4120-bcf5-997859ff6c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Contrasting features of Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The parts are created with the composite class's creation. That means the composite
    class is responsible for the creation. Also, the destruction of the part depends
    upon the destruction of their creator composite class. However, rules are meant
    to be broken and that happens in the case of Composition too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The creation of a part is postponed till it is actually used. For instance,
    our `Student` class doesn't create the list of books until the user or any other
    method assigns some data to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Composition assigns the responsibility of destructing the part to some other
    object. We are already aware of such routine named **Garbage Collector**, who
    manages the destruction of unused objects from time to time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition acts like a guardian, where all care of the members is taken by
    the composite class. Creation, assignment, and destruction; all are mostly managed
    by the composite class.
  prefs: []
  type: TYPE_NORMAL
- en: Why are subclasses inside Composition?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is always a decision you need to take while you program. If you closely
    analyze our `Student` class, you will realize a few things. The properties of
    the `Address` class be can directly be declared inside the `Student` class instead
    of declared as a different entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We did this. Basically, we just separated out the address properties in a container
    class named `Address`. The following code block shows how we can extract out `Address`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These are some of the advantages of doing a subclass instead of directly adding
    them to the composite class:'
  prefs: []
  type: TYPE_NORMAL
- en: The subclass is independent and simplifies the architecture. The code seems
    very easy to understand. The actual benefit you get out of it is when you try
    to do something extra on it, in the future. Suppose, I tell you to include another
    member Street for `Address`. If you have designed address properties directly
    inside composite classes, then you have to manually go to each class and add another
    member. However, in the case of the subclass, you just need to add that to the
    subclass and all composite classes using that will get the access automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The more you break down the classes into subclasses, the more you make them
    be reusable. The address class, for instance, can be reused in some other class
    as well. It is no more tightly coupled with the Composition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the introduction of subclasses, the composite class is not complex anymore.
    Moreover, the subclasses can have methods defined in them which makes the life
    of the composite object easy. That is because the subclass can define it's related
    functions which can be called by the composite class. For example, if we want
    to get the full address, we can easily have a method inside the `Address` class,
    which will return a string using all those address properties. Thus, the composite
    class does not need to do anything on `Address` related stuff.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thinking of a better design, such that it distributes responsibilities among
    different entities, is tough. But it is not impossible. When we start building
    the app, we don't always have full specifications or realize what could happen
    next. Eventually, when more specifications come in, we face problems as we ignore
    building subclasses for a certain common usage. Therefore, you will also see bad
    and repeated codes in many classes which can be packaged in a subclass and could
    easily be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Composite or main classes should be responsible for what it is designed. A `Student`
    class is responsible for managing student information. There is no doubt that
    the address of the student is something it should handle. But, what if we get
    another entity like `Teacher` who also has an address? We have to repeat the same
    set of properties inside the `Teacher` class to achieve this. Code smell isn't
    it! That is when you should decide to separate `Address`--related information
    to another class.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregation is another type of object Composition. Let's explore this in details.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is the process by which you bring existing objects together to form a new
    object. At first, it looks similar to Composition. But in reality, it has differences.
    To qualify as an aggregation, the complex object and its parts must satisfy the
    following relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The part (member) is a component of the object (class)**: It is similar to
    Composition. That means the smaller object is a part of the complex object. For
    example, a person has a Google Drive folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The part (member) can belong to more than one object (class) at a time**:
    Unlike Composition, here the member is independent of the class. It might be referenced
    by other classes as well at the same time. For example, a Drive folder can be
    shared by many users at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The part (member) does not have its existence managed by the object (class):**
    As the last point states the member is not tied to the complex class, so it''s
    creation and destruction is not managed by it. For example, all those people with
    whom the folder is shared have not created it. Unless they are provided with admin
    rights, they can''t delete the folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The part (member) does not know about the existence of the object (class):**
    The member does not know whether the complex object exists or not, same as Composition.
    For example, a person does not know if the Drive folder exists or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will try to alter the `Student` class which was illustrated in the
    Composition lesson. I am doing it because we have an `Address` property there.
    See how the constructor is updated to have the address as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is not new to you. Let's try to elaborate it. We are simply passing the
    `Address` object into the constructor, which is then assigned to the `Address`
    property of the composite class `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: The next confusion is what is the difference then? Let me explain. The `Address`
    property is declared inside the composite class gets created/destroyed like other
    members. But inside the constructor, we are assigning an external `Address` object
    to it. That means the composite class does not have any control over that incoming
    external object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Student` class initialization will also be altered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze how this change can be considered as an Aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1: The part (member) is a component of the object (class)**: The `Address`
    property is referenced inside the `Student` class. Thus, it becomes a part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2: The part (member) can belong to more than one object (class) at a
    time**: I passed an `Address` object into the constructor, which is used inside
    the composite class, for further operation. However, the object `add` is pretty
    much independent as it is created by the routine (`Main`, as shown in the preceding
    code). Let me allow it to be used by another `Student` as well:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I know you might have some reservations about whether this will work or not.
    Here is the output for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d96c6715-c721-4cfb-8a68-133bc34fff36.png)'
  prefs: []
  type: TYPE_IMG
- en: Straightforward, isn't it! The `Main` method is the creator, so it can be used
    inside the scope anywhere till it is destroyed by it or by Garbage Collector.
    The `add` object is passed as a reference to both of the students. From these
    facts, we can infer that `Jayashree` and `Lipsa` and are two students who stay
    at the same address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 3: The part (member) does not have its existence managed by the object
    (class)**: Since it is wrapped inside the `Main` method, the composite object
    can''t destroy it. By the way, it did not create it either. It was `Main` who
    gave birth to that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 4: The part (member) does not know about the existence of the object
    (class)**: The `Address` object does not have any idea about these student objects.
    It is autonomous inside the `Main` block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition versus Aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have explored both types of Object Composition, let''s look at
    the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Composition** | **Aggregation** |'
  prefs: []
  type: TYPE_TB
- en: '| Generally, contains built-in type member variablesManages member''s creation
    and destruction | Generally contains reference variables which live out of the
    scope of the composite classDoes not manage member''s creation and destruction
    |'
  prefs: []
  type: TYPE_TB
- en: While these concepts have such tiny but important differences, they can still
    be mixed up in a composite class. That means a `Student` class having simple parts
    like `Id`, `Name`, `Address`, and so on as an Aggregation will be treated as a
    mix of both these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case of Composition, you have the control to manage those members as you
    like. However, they are not independent and you can't use them in other places.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas in Aggregation, there is no control of the member's life and if you
    forget to destroy the member after creation, it will be a culprit of memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: While both of them have their own pros and cons, it is just a matter of deciding
    which one to use where, according to the scenario. Moreover, you can mix them
    up and do amazing things. For example, some properties like `Id`, `Name`, etc.
    are used exclusively inside the class, so ideally we won't reuse these properties
    anywhere in the application. Therefore, if you build another class with all these
    properties and reference (aggregate) in the first class, that becomes unnecessary
    because the other class has no such usage outside the first class.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when you identify that some properties that can be packed
    up as a subclass (`AddressId`, `Address`, `State`, `City`, `Country`, and so on),
    you might have a requirement in future to refer to that new subclass somewhere
    in the code. Better to aggregate that. Let the caller manage its lifetime. Just
    get that into your composite class and use as required and forget it's management.
  prefs: []
  type: TYPE_NORMAL
- en: Other important relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few other relationships which you should be aware of. Unless you
    know these, you won't be able to visualize how objects typically work with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have completed two types of Object Composition, Composition, and Aggregation.
    Just to confirm that we are on the same page, Object Composition is used to package
    relationships into a complex object that is from one or more simpler objects (parts/members).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll take a look at a type of relationship between two otherwise unrelated
    objects, called an **Association**. An Association is a bonding between two unrelated
    objects and they must satisfy the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object (member) associated is unrelated to the other object (class):** Here
    the objects, which are going to be associated, are not related to the object.
    Rather than being a part of a complex object as in a composition or aggregation,
    it is totally independent in nature. For example, a `Teacher` and `Student` are
    two independent objects, but not contained in each other. These entities get associated
    with each other while in a class for lessons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object (member) associated can belong to more than one object (class) at
    a time:** Like aggregation, the associated object can belong to multiple objects
    at the same time. For example, a `Student` can be associated with many teachers
    and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object (member) associated does not have its existence managed by the other
    object (class)**: All aggregated objects are independent here. Everyone manages
    themselves. For example, neither `Teacher` is going to decide what a `Student`
    will do nor does the `Student` decides what the actions of the `Teacher` should
    be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object (member) associated may or may not know about the existence of the
    object (class)**: Association relationships might be unidirectional or bidirectional.
    That means the two associated objects may or may not know each other. We will
    get more clarification on this once we see the code snippet. For example, a `Student`
    may or may not recognize a `Teacher`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association can be defined as *uses...a* relationship. The `Teacher` *uses*
    the `Student` to teach the lessons. The `Student` uses the `Teacher` to clarify
    doubts.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take an example of a cricket player and bat. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Explanation of the preceding code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have two different classes, `CricketPlayer` and `Bat`. Now let me create
    the objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/366514c2-bb00-4a94-9786-07d076c94e2b.png)'
  prefs: []
  type: TYPE_IMG
- en: The methods `Play` inside the `CricketPlayer` class and `StartPlay` inside the
    `Bat` class are the ones, which you should be concentrating on at this point.
    Both are taking a reference param pointing to the other class's object. The whole
    point of this type of relationship between the player and bat is the common cause
    of starting t0 play.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the rules which this relationship follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1: Object (member) associated is unrelated to the other object (class)**:
    Neither the bat relates to the player nor the player relates to the bat. But we
    will gradually see how they get associated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2: Object (member) associated can belong to more than one object (class)
    at a time:** The bat can be used by many other players in the team, not just by
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 3: Object (member) associated does not have its existence managed by
    the other object (class)**: The player is not responsible for managing the bat.
    It is created even before the player comes to the team. Likewise, the bat is not
    going to give birth to or be the cause of death of a player unless the player
    hits himself with the bat, which is not going to happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 4: Object (member) associated may or may not know about the existence
    of the object (class)**: The player knows about the bat as the bat is passed as
    an argument in the `Play` method. Similarly, the bat knows about the player as
    that got passed to the `StartPlay` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you understand cricket a little bit, you must know that a player uses a bat
    to bat. That means it depends on the bat object. The bat object, however, can
    be used by any batsman in the team, which leads to a `StartPlay` method in the
    `Bat` class. Obviously, the bat object needs to get associated with a player,
    which eventually commences the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of the objects depend on each other in order to start the game. They still
    exist as independent objects. Suppose, you don''t call the `Play` and `StartPlay`
    method, nothing will change. The code will compile. That defines the association
    with each other for a common cause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, I just commented out codes for play. That did not have any impact on the
    objects and they still exist. Then I used them to call other methods like `GetPlayerName`
    and `GetBrandName`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/788af1ce-221c-4b96-8f6e-9ff2a7beb171.png)'
  prefs: []
  type: TYPE_IMG
- en: Types of Association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned a bit about Association. However, there are different types
    and it would be handy for us to know about them.
  prefs: []
  type: TYPE_NORMAL
- en: Reflexive Association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When two objects of the same type get associated, that association is called
    as **Reflexive Association**. Let''s consider the class `Medicine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is very useful in many scenarios when we have dependencies of the same
    entity. We know that a medicine might have one alternate medicine, which again
    might have another alternate and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Indirect Association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Association, when formed by other means and not directly between two objects,
    is called an **Indirect Association**. We will try to grasp this concept with
    the help of the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have two classes named `SoftwareEngineer` and `Laptop` which are meant to
    be associated with each other. In this case, we are trying to relate them indirectly
    via a static class `AvailableLaptops` which has a list of `Laptop` objects containing
    their `Id` and `Name`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on the `Main` method now. A `SoftwareEngineer` is instantiated (`Name
    Tworit Dash` with a `LaptopId 3`). We need to print his name and the laptop name
    he is using. We have the `LaptopId`. If you closely look at the `AvailableLaptops`
    class, there is a static method `GetLaptop` which takes `laptopId` as an argument
    and then finds the laptop from the list it already has.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `Laptop usedLaptop = AvailableLaptops.GetLaptop(3);` would get us the required
    `Laptop` object which has ID `3` and `Name Laptop3`. Now, it is just a matter
    of printing the engineer''s name and the name of the laptop returned by the static
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/234d4192-1dbf-46a9-aca4-3b138a01321d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is called **Indirect Association** because the association is established
    with the help of another class which can interact with a class and returns the
    results to another class requesting any data from the first class.
  prefs: []
  type: TYPE_NORMAL
- en: To summarise the relationships, let's do a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition:**'
  prefs: []
  type: TYPE_NORMAL
- en: Part of a complex class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members can't be a part of multiple classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members are created and destroyed by a complex class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unidirectional: Members do not know about the complex object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A part of* relationship'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation:**'
  prefs: []
  type: TYPE_NORMAL
- en: Part of a complex class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members can be a part of multiple classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members are neither created nor destroyed by a complex class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unidirectional: Members do not know about the complex object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Has a* relationship'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Association:**'
  prefs: []
  type: TYPE_NORMAL
- en: Classes are not related but require each other when needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associated members or objects can be used by multiple objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members are neither created or destroyed by a complex class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unidirectional or Bidirectional: Objects may or may not know each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Uses a* relationship'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition over Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This topic is very interesting and is discussed online in many websites and
    blogs. As the topic headline says **Composition is preferred over Inheritance**,
    we need to understand why it is so important by identifying the problems. The
    better the design from the beginning of your software development, the better
    the maintainability and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and Composition are two pillars of OOPs concepts. Unless they are
    used wisely according to your architecture, they will create problems in the future
    when you start adding complexity to your application.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed Composition, now, let's discuss Inheritance before
    we move towards the main topic of discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, the act of acquiring or deriving some behavior from someone
    is called **Inheritance**. In the programming world, when a certain class is inherited
    from another class, it creates an Inheritance. Some basic examples are written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A car *is a* vehicle. The vehicle has a certain behavior which the car acquires
    when it is built.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rectangle *is a* shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `HourlyEmployee` *is an* employee. A `MonthlyEmployee` *is an* employee too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chicken curry *is a* dish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice, they all have something in common. That is the phrase *is a*. Inheritance
    is defined as an *is a* relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The car is a vehicle, but it might have a music system as well, which is not
    a common behavior of a vehicle. Thus, the derived or child classes can have their
    own behavior as well. `HourlyEmployee` and `MonthlyEmployee` are employees of
    a certain company who share many benefits from the company. However, their salary
    is not the same.
  prefs: []
  type: TYPE_NORMAL
- en: Example on User class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how we can implement Inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have different types of users in our company such as `Admin`, `Manager`,
    `TeamLeads`, `HR`, and more. Although these entities are different, they have
    some properties in common. They must have an `Id`, `RoleId`, `Name`, `EmailId`,
    `MobileNumber`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As they have common properties and behavior we make an abstract base class `User`
    which has all those declared inside it. We won't be instantiating this class,
    so it is restricted by using an abstract keyword. Every type of user is going
    to have some operation. The simplest operation is `SaveUser()`, which is defined
    inside the base class so that it will be available for all child classes.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have different properties declared inside child classes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Admin--`public string CompanyDepartment { get; set; }`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manager--`public List<TeamLead> TeamLeads { get; set; }`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TeamLead--`public List<string> Projects { get; set; }`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also define different methods specific to them inside these child classes.
    When we try to create objects, or in other words, create an `Admin` and `Manager`,
    it will look something like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see we are creating each type of user and then sending their IDs to
    the save method for further database processing. `RoleId` is assigned inside the
    constructors of each type of `User` class. This produces output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/095ed841-57ce-4638-903f-e14c08a99c8b.png)'
  prefs: []
  type: TYPE_IMG
- en: New User Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The company decides to have a new type of employee named  Delivery Manager,
    who will be having certain privileges, but not all. This role will take partial
    responsibilities from `Manager` as well as from `TeamLead`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Delivery Manager can `CreateProject` (like a TeamLead) and  ;`AssignProjectToTeamLead`
    (like a `Manager`). Also while doing all these, he/she can `SendNotificationToCto`
    which is a new method. So, those two methods will have additional codes which
    are not an exact copy from the  `Manager` and `TeamLead` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6bad7a4-a498-4945-95b5-7839807fdeef.png)**Multiple Inheritance** is
    a language-specific feature which enables a class to inherit features of more
    than one parent class. This feature can introduce complexities in the design and
    the supported languages have their own way of handling such scenarios. C#, Java,
    Swift etc. does not support Multiple Inheritance, but they allow implementing
    multiple protocols which are named **Interfaces**. I just wanted to show you that
    we have to go with some alternative approach to solve the problem in hand instead
    of inheriting from multiple classes as shown above, which is anyway not supported
    by C#.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem which we come across
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio complains to me that I can't code like this, which is actually
    termed Multiple Inheritance. Moreover, when a company introduces more roles, the
    system gets complex to manage when we have responsibilities (methods) defined
    in each class. Because when we have to mix responsibilities for a certain user
    role, we will have to create duplicate codes that would have been already written
    in some class.
  prefs: []
  type: TYPE_NORMAL
- en: To explain what I'm saying, imagine a `Car` class, which gets inherited by classes
    like `Toyota`, `BMW`, `Volkswagen`, and more. For some reason, I got mad and brought
    both `Toyota` and `Volkswagen` to my workshop and then built a new brand out of
    them. I will name it VolksTaditToy. Please don't kill me for this name.
  prefs: []
  type: TYPE_NORMAL
- en: VolksTaditToy now has a combination of functions from both of these cars. But
    there is no way to deal with them in my program. Don't be so surprised, if you
    see more of such cars on the road because there is no scarcity of such fools in
    this world. Gradually your program will be in a situation where there is no escape.
  prefs: []
  type: TYPE_NORMAL
- en: How can we write this class with the concept of inheritance? Impossible right!
    Let's make that possible for our initial `User` problem.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The composition is our savior here. Let''s see how we can solve this problem
    using this relationship. We will introduce a `Role` class. Obvious right! `Manager`,
    `TeamLead`, and `DeliveryManager` are different roles played by employees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now every other user type class will derive from this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, what is the next step? The remaining class is `User`. We need to do
    a couple of modifications in that, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first modification is to remove the abstract keyword because we will now
    create objects of this class. Next is to have a property `public List<Role> RoleIds
    { get; set; }` instead of `public int RoleId { get; set; }`. We did this to allow
    assigning multiple roles to a user/employee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe, how we can create a user with multiple roles in the following main
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While creating a `DeliveryManager` type of `User`, we are assigning multiple
    roles to the user by creating a list of `Manager` and `TeamLead` types. As they
    inherit from `Role` base class, so `RoleIds` recognize these types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This piece of code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5707a7e8-fbbb-4fbe-8ef6-3838aa1269af.png)'
  prefs: []
  type: TYPE_IMG
- en: We conclude that Composition takes over Inheritance in many of such cases. That
    means you need to be very careful when you start designing the classes. Otherwise,
    the situation will get worse in the future when your system grows as you will
    create a mess. You should definitely avoid duplicate codes. When you see that
    you are writing something which has already been written before, stop and think
    before you proceed. Try to normalize as much as possible at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: Role of Object Composition in Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand the concept of Object Composition, let''s analyze an
    actual software project problem and how that can be trapped using Object Composition.
    In the process, we will find out the importance of this concept in a DI context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, the `Notification` class is inheriting the `Mail` class, so that it can
    call `SendMail()`. This structure is not wrong, but it will create complications
    going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine another class for `Sms`, where we can have a method something like `SendSms()`.
    There is no way here for the `Notification` class to call that method as multiple
    inheritances is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we can easily use Object Composition along with Dependency
    Injection. Let''s alter the code first. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`IEmail` and `ISms` are interfaces which have `SendMail()` and `SendSms()`
    methods respectively. The next thing is to implement these interfaces in classes
    `Mail` and `Sms`. We will write our sending logic inside the methods implemented
    in these classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `Notification` class, which is not inheriting any class, rather it
    is referencing new interfaces. Then inside a parameterized constructor, we have
    `IMail` and `ISms` as arguments. The `SendNotification()` method now takes the
    necessary details like `mailId`, `mobile` and `message` to call the methods using
    the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the advantage then? We wrote more code, didn''t we? The point here
    is very interesting. If you look at the code to instantiate `Notification` class,
    you will get some hint. Let''s look at that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Got the hint? Let me explain. We injected the `Mail` and `Sms` class instances
    into the `Notification` constructor which is assigned to the properties `_mail`
    and `_sms`. It would automatically call the methods inside `Mail` and `Sms` classes.
    So, we composed `Notification` class with `IMail` and `ISms` references. This
    is where Object Composition came into the picture along with Dependency Injection.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose at some point in time you want to include another class for mail sending
    (something like `SmtpMail`). You just need to write that class implementing the
    same `IMail` interface and define the `SendMail` method. Bang, it's done. No need
    to make the `Notification` class dirty anymore. It will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I just declared the new class and injected the object like `new
    SmtpMail()` instead of `new Mail()`. That is the only change. The rest will work
    as expected because I have injected the object instead of directly referencing
    it inside the `Notification` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarise, the following is what we achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: We introduced flexibility through interfaces for concrete dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily plug in new concrete class dependency just by implementing the
    interface abstraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We composed `Notification` object with the dependency objects just with one
    go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We moved all initialization code to one place inside the `Main` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When I said we moved the initialization code to one place, that location is
    denoted as the **Composition Root** of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Composition Root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composition Root composes all the independent modules of the application. During
    runtime, Object Composition is the first thing that happens before any other operations.
    As soon as the object graph is wired up with dependencies, Object Composition
    is finished, then the components related to the application can take over. Object
    Composition should happen as close as possible to the application's entry point.
  prefs: []
  type: TYPE_NORMAL
- en: The entry points in .NET Core 2.0 Console App and ASP.NET Core 2.0 MVC app are
    the same and that is inside the `Main` method of the `Program.cs` class. .NET
    Core 2.0 Console App's `Main` method is clean, but on the other hand, ASP.NET
    Core 2.0 MVC has some bootstrapping codes inside the `Main` method. However, we
    usually write composition codes inside a `ConfigureServices` method which can
    be called inside the `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you do a File | New | Project | .NET Core | Console App (.NET Core) in
    Visual Studio 2017, you will see the following in the `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of ASP.NET Core 2.0 MVC App, when you select  File | New | Project | Web
    | ASP.NET Core Web Application (in the next screen, select appropriate template),
    the template for Web Application generates the `Main` method in the `Program`
    class and `Startup` would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b43a5769-7a5c-4917-b9c0-ffc24875d597.png)'
  prefs: []
  type: TYPE_IMG
- en: The way we composed the `Notification` object in the last section is known as
    **Poor Man's DI**. Instead of doing that, we should apply DI Containers to compose
    and manage objects in that location.
  prefs: []
  type: TYPE_NORMAL
- en: Object Composition is the fundamental building block of DI and the easiest one
    to understand because we already know how to compose objects with many examples.
    Now it's time to learn what are the challenges we would face composing objects
    for DI due to the framework capabilities. The issues are related to a framework
    and nothing to do with the Object Composition concept. Let's find out in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Composing .NET Core 2.0 Console application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the `Main` method, we can easily compose objects with built-in DI Container.
    If you remember, we have already discussed that from container initialization,
    registration of objects to the container, resolving dependencies and then release
    the components from the container, everything should happen inside the Composition
    Root, which is considered as the `Main` method here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of the `Main` method inside a console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is simple code which leverages the extension method available, `Add***`, to
    register the dependency with the container. Then we used the `GetService` method
    to get the implemented type by the interface. With the instance, we then can do
    everything we want further in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that Composition Root is the place where we should do all operations
    related to Dependency Management. It's not recommended to use the `serviceProvider`
    outside the Composition Root or `Main` method to be specific. The same rule applies
    to ASP.NET Core MVC as well. We are going to explore that in a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, of course, introduce another method and you can name it `ConfigureServices` (shown
    as follows) for a cleaner code structure. You can give any name to the method,
    but this name resembles the name of the method specially dedicated in ASP.NET
    Core MVC app for dependency injection configurations as we saw in the picture
    in the last section. This new method added is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are not manually releasing the objects or the container. The
    reason is that release is automatically handled by the DI Container according
    to the life style you decide. `AddTransient`, `AddSingleton` and `AddScoped` are
    readily available methods which helps to perform different types of lifetime for
    the objects. We will explore more about Object Lifetime in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml),
    *Object Lifetime*.
  prefs: []
  type: TYPE_NORMAL
- en: Object Composition in ASP.NET Core MVC 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Console Application, we can follow the same procedure to deal with dependencies
    inside ASP.NET Core MVC 2.0 apps. Unlike the console app, the `Main` method inside
    the `Program.cs`, in this case, is populated with default codes to initiate the
    MVC App with required configurations. It is that location from which it instructs
    the framework to load the Startup class. The `host` inside the `Main` method executes
    the `Startup` class `ConfigureServices` method.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core MVC is designed to be DI-friendly. But it does not force you to
    apply DI always. To deal with dependencies in ASP.NET MVC, we can take the Poor
    Man's DI approach to manually manage them or leverage built-in/third party DI
    Container's technique to register, resolve, and release dependencies. Let's dive
    a little deep into the controller initiation process and see if we find anything
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: The heart of MVC lies in controllers. Controllers handle requests, process them,
    and return the response back to the client. Thus, the controllers should delegate
    their responsibility to the other modules as required. That means the controller
    will refer to other classes for certain tasks. It will use the `new` keyword for
    the dependency object creation inside the action methods, which we can easily
    avoid as we are using DI Container. With the dependency injection technique, we
    should be able to inject dependencies into the controllers with Constructor Injection.
  prefs: []
  type: TYPE_NORMAL
- en: '`IControllerFactory` is an interface inside `Microsoft.AspNetCore.Mvc.Controllers`
    namespace which enables us to create and release controllers. The interface contains
    two methods, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'ASP.NET Core MVC 2.0 ships with a `DefaultControlFactory` which implements
    this interface. Let''s have a look at the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`DefaultControllerFactory` has a constructor injection with the required dependencies
    for the `ControllerActivator` and `PropertyActivators`. Thus, this factory is
    composed of activators. Like a factory, there is an interface for `Activator`
    also named `IControllerActivator`. There are providers for Factory and Activators
    named `ControllerFactoryProvider` and `ControllerActivatorProvider` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the most important part. The Object Composition of these factories is
    actually done inside the `AddMvcCore()` method of class `MvcServiceCollectionExtensions`
    which stays inside `namespace` `Microsoft.Extensions.DependencyInjection`. The
    `namespace` name contains `DependencyInjection`, which itself gives us a hint
    that we are going to do some injection for sure to initiate these activators and
    factories. Let''s see a snapshot of the `AddMvcCoreServices()` method ( which
    is another method called from `AddMvcCore()`) responsible for composing all required
    dependencies for controller activation and initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5e5e48a-e6fa-4263-8628-a0a148146ea7.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the interfaces are registered as the concrete classes. This
    method contains many other service registrations for all the background work needed
    for the controller process. But we got an idea about how Object Composition is
    implemented inside the framework itself.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to design our own custom controller factory, we can do that as well
    by registering the required factory and provider inside this method for initiation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter touched upon important relationships between objects in programming.
    We created very basic classes and tried to grasp the concepts. Then we moved our
    focus to Object Composition, and it's types, Composition, and Aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we discussed Association. With code examples and outputs, we saw how
    these relationships matter a lot while coding.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we were introduced to Inheritance with an example. Once we completed
    all these, we moved towards a very important saying *Composition over Inheritance*.
    This is a real-time issue which developers face while applying new requirements
    to existing class structures.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed the important role played by Object Composition in Dependency
    Injection. Also, we saw how this pattern is followed in ASP.NET Core MVC 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to see how objects are created, how they live and are then destroyed
    in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml), *Object Lifetime*.
    We will relate the object lifetime with what we already know from this chapter.
  prefs: []
  type: TYPE_NORMAL
