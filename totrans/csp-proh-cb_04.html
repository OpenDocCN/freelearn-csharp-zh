<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Composing Event-Based Programs Using Reactive Extensions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Composing Event-Based Programs Using Reactive Extensions</h1></div></div></div><p>This chapter deals with <span class="strong"><strong>Reactive Extensions</strong></span> (<span class="strong"><strong>Rx</strong></span>). To understand Rx, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing Rx</li><li class="listitem" style="list-style-type: disc">Events versus observables</li><li class="listitem" style="list-style-type: disc">Using LINQ to perform queries</li><li class="listitem" style="list-style-type: disc">Using schedulers in Rx</li><li class="listitem" style="list-style-type: disc">Debugging lambda expressions</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Introduction</h1></div></div></div><p>Often, during your day-to-day dealings with developing applications in C#, you will have to use asynchronous programming. You might also have to deal with many data sources. Think of a web service that returns the current exchange rates, a Twitter search returning a stream of related data, or even different events generated by multiple computers. Rx provides an elegant solution in the form of the <code class="literal">IObserver&lt;T&gt;</code> interface.</p><p>You use the <code class="literal">IObserver&lt;T&gt;</code> interface to subscribe to the events. Then, the <code class="literal">IObservable&lt;T&gt;</code> interface, which maintains a list of <code class="literal">IObserver&lt;T&gt;</code> interfaces, will notify them on the change of state. In essence, Rx will stick together multiple data sources (social media, RSS feeds, UI events, and so on) that generate data. Rx, therefore, brings these data sources together in one interface. In fact, Rx can be thought of as consisting of three sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Observables</strong></span>: The interface that<a class="indexterm" id="id224"/> brings together and represents all these data streams</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Language-Integrated Query</strong></span> (<span class="strong"><strong>LINQ</strong></span>): The <a class="indexterm" id="id225"/>ability to use LINQ to query these multiple data streams</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Schedulers</strong></span>: Parametrizing <a class="indexterm" id="id226"/>concurrency using schedulers</li></ul></div><p>The question on many minds might be why developers should use (or find use for) Rx. Here are a few examples where <a class="indexterm" id="id227"/>Rx are really useful:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a search that has an autocomplete function. You don't want the code to perform a search for each value you type into the search area. Rx allows you to throttle the search.</li><li class="listitem" style="list-style-type: disc">Making the UI of your application more responsive.</li><li class="listitem" style="list-style-type: disc">Being notified when data changes instead of having to poll the data for changes. Think of real-time stock prices.</li></ul></div><p>To keep up to date<a class="indexterm" id="id228"/> with Rx, you can have a look at the GitHub page: <a class="ulink" href="https://github.com/Reactive-Extensions/Rx.NET">https://github.com/Reactive-Extensions/Rx.NET</a>.</p></div></div>
<div class="section" title="Installing Rx"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Installing Rx</h1></div></div></div><p>Before we can begin<a class="indexterm" id="id229"/> exploring Rx, we need to install it. The easiest way to do this is using<a class="indexterm" id="id230"/> NuGet.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec72"/>Getting ready</h2></div></div></div><p>For this chapter on Rx, we will not create a separate class. All the code will be written in a console application.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec73"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on your solution and select <span class="strong"><strong>Manage NuGet Packages for Solution…</strong></span> from the context menu:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_01.jpg"/></div></li><li class="listitem">In the window<a class="indexterm" id="id231"/> that is displayed <a class="indexterm" id="id232"/>afterwards, type <code class="literal">System.Reactive</code> in the search text box and search for the NuGet installer:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_02.jpg"/></div></li><li class="listitem">At the time of <a class="indexterm" id="id233"/>writing this book, the last stable release was version 3.0.0. Next, select the <a class="indexterm" id="id234"/>projects that you want to install Rx on. For simplicity sake, we just selected it to be installed project wide:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_03.jpg"/></div></li><li class="listitem">The next screenshot that is<a class="indexterm" id="id235"/> displayed is a confirmation dialog box, asking <a class="indexterm" id="id236"/>you to confirm the changes to the project. It will show a preview of the changes it will be making to each project. If you are happy with the changes, click on the <span class="strong"><strong>OK</strong></span> button:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_04.jpg"/></div></li><li class="listitem">A license agreement <a class="indexterm" id="id237"/>might be presented to you in the last dialog screen, <a class="indexterm" id="id238"/>which you will need to accept. To continue, click on the <span class="strong"><strong>I Accept</strong></span> button.</li><li class="listitem">After the installation is complete, you will see the references added to Rx under the <span class="strong"><strong>References</strong></span> node in your project. These are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">System.Reactive.Core</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">System.Reactive.Interfaces</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">System.Reactive.Linq</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">System.Reactive.PlatformServices</code></li></ul></div><div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_06.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec74"/>How it works…</h2></div></div></div><p>NuGet is by far the<a class="indexterm" id="id239"/> easiest way to add additional components to your projects. As you can <a class="indexterm" id="id240"/>see from the added references, <code class="literal">System.Reactive</code> is the main assembly. To gain a better understanding of <code class="literal">System.Reactive</code>, view the assemblies in <span class="strong"><strong>Object Browser</strong></span>. To do this, double-click on any of the assemblies in the <span class="strong"><strong>References</strong></span> option of your project:</p><div class="mediaobject"><img alt="How it works…" src="graphics/B05391_04_07.jpg"/></div><p>
<code class="literal">System.Reactive.Linq</code> contains all the<a class="indexterm" id="id241"/> querying functionality in Rx. You will also notice<a class="indexterm" id="id242"/> that <code class="literal">System.Reactive.Concurrency</code> contains all the schedulers.</p></div></div>
<div class="section" title="Events versus observables"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Events versus observables</h1></div></div></div><p>Being developers, we <a class="indexterm" id="id243"/>should all be quite familiar with events. Most developers have been creating events since we started writing code. In fact, if you have even dropped a button control on a form and double-clicked the button to create the method that handles the click of the button, you have created an event. In .NET, we can declare events using the <code class="literal">event</code> keyword, publish to the event by invoking it, and subscribe to that event by adding a handler to the event. We therefore have the following operations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Declare</li><li class="listitem" style="list-style-type: disc">Publish</li><li class="listitem" style="list-style-type: disc">Subscribe</li></ul></div><p>With Rx, we have a similar structure where we declare a data stream, publish data to that stream, and subscribe to it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec75"/>Getting ready</h2></div></div></div><p>First, we will see how an event works in C#. We will then see the working of an event using Rx and, in doing so, highlight the differences.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec76"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In your console application, add a new class called <code class="literal">DotNet</code>. To this class, add a property called <code class="literal">AvailableDatatype</code>:<div class="informalexample"><pre class="programlisting">public class DotNet
{
    public string  AvailableDatatype { get; set; }
}</pre></div></li><li class="listitem">In the main program class, add a new static action event called <code class="literal">types</code>. Basically, this is just a delegate and will receive some value, in our case, the available .NET data types:<div class="informalexample"><pre class="programlisting">class Program
{
    // Static action event
    static event Action&lt;string&gt; types;

    static void Main(string[] args)
    {
    
    }
}</pre></div></li><li class="listitem">Inside <code class="literal">void Main</code>, create a <code class="literal">List&lt;DotNet&gt;</code> class called <code class="literal">lstTypes</code>. Inside this list, add several values of type <code class="literal">DotNet</code> class. Here, we will just add hardcoded data of some of the data types in .NET:<div class="informalexample"><pre class="programlisting">List&lt;DotNet&gt; lstTypes = new List&lt;DotNet&gt;();
DotNet blnTypes = new DotNet();
blnTypes.AvailableDatatype = "bool";
lstTypes.Add(blnTypes);

DotNet strTypes = new DotNet();
strTypes.AvailableDatatype = "string";
lstTypes.Add(strTypes);

DotNet intTypes = new DotNet();
intTypes.AvailableDatatype = "int";
lstTypes.Add(intTypes);

DotNet decTypes = new DotNet();
decTypes.AvailableDatatype = "decimal";
lstTypes.Add(decTypes);</pre></div></li><li class="listitem">Our next task is to <a class="indexterm" id="id244"/>subscribe to this event with an event handler that is simply outputting the value of <span class="emphasis"><em>x</em></span> to the console window. We will then raise the event each time we loop through our <code class="literal">lstTypes</code> list by adding the line <code class="literal">types(lstTypes[i].AvailableDatatype);</code>:<div class="informalexample"><pre class="programlisting">types += x =&gt;
{
    Console.WriteLine(x);
};


for (int i = 0; i &lt;= lstTypes.Count - 1; i++)
{
    types(lstTypes[i].AvailableDatatype);
}

Console.ReadLine();</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>In reality, before raising an event, we should always check that the event isn't null. Only after this check should we raise the event. For brevity, we have not added this check before raising the event.</p></div></div></li><li class="listitem">When you have added <a class="indexterm" id="id245"/>all the code from step 1 to step 4, your console application should look like this:<div class="informalexample"><pre class="programlisting">class Program
{
    // Static action event
    static event Action&lt;string&gt; types;

    static void Main(string[] args)
    {
        List&lt;DotNet&gt; lstTypes = new List&lt;DotNet&gt;();
        DotNet blnTypes = new DotNet();
        blnTypes.AvailableDatatype = "bool";
        lstTypes.Add(blnTypes);

        DotNet strTypes = new DotNet();
        strTypes.AvailableDatatype = "string";
        lstTypes.Add(strTypes);

        DotNet intTypes = new DotNet();
        intTypes.AvailableDatatype = "int";
        lstTypes.Add(intTypes);

        DotNet decTypes = new DotNet();
        decTypes.AvailableDatatype = "decimal";
        lstTypes.Add(decTypes);


        types += x =&gt;
        {
            Console.WriteLine(x);
        };


        for (int i = 0; i &lt;= lstTypes.Count - 1; i++)
        {
            types(lstTypes[i].AvailableDatatype);
        }

        Console.ReadLine();
    }
}</pre></div></li><li class="listitem">Running your application will set our list with values and then raise the event created to output the values of the list to the console window:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_08.jpg"/></div></li><li class="listitem">Let's see the working<a class="indexterm" id="id246"/> of events using Rx. Add a static <code class="literal">Subject</code> of <code class="literal">string</code>. You might also need to add the <code class="literal">System.Reactive.Subjects</code> namespace to your project as <code class="literal">Subjects</code> live in this separate namespace:<div class="informalexample"><pre class="programlisting">class Program
{
    
    static Subject&lt;string&gt; obsTypes = new Subject&lt;string&gt;();

    static void Main(string[] args)
    {
    
    }
}</pre></div></li><li class="listitem">After the code that created the list of <code class="literal">DotNet</code>, we used <code class="literal">+=</code> to wire up an event handler. This time round, we will use <code class="literal">Subscribe</code>. This is the <code class="literal">IObservable</code> portion of the code. After you have added this, raise the event using the <code class="literal">OnNext</code> keyword. This is the <code class="literal">IObserver</code> portion of the code. Therefore, as we loop through our list, we will call <code class="literal">OnNext</code> to pump out the values to the subscribed <code class="literal">IObservable</code> interface:<div class="informalexample"><pre class="programlisting">// IObservable
obsTypes.Subscribe(x =&gt;
{
    Console.WriteLine(x);
});

// IObserver
for (int i = 0; i &lt;= lstTypes.Count - 1; i++)
{
    obsTypes.OnNext(lstTypes[i].AvailableDatatype);
}

Console.ReadLine();</pre></div></li><li class="listitem">When you have <a class="indexterm" id="id247"/>completed adding all the code, your application should look like this:<div class="informalexample"><pre class="programlisting">class Program
{
    
    static Subject&lt;string&gt; obsTypes = new Subject&lt;string&gt;();

    static void Main(string[] args)
    {
        List&lt;DotNet&gt; lstTypes = new List&lt;DotNet&gt;();
        DotNet blnTypes = new DotNet();
        blnTypes.AvailableDatatype = "bool";
        lstTypes.Add(blnTypes);

        DotNet strTypes = new DotNet();
        strTypes.AvailableDatatype = "string";
        lstTypes.Add(strTypes);

        DotNet intTypes = new DotNet();
        intTypes.AvailableDatatype = "int";
        lstTypes.Add(intTypes);

        DotNet decTypes = new DotNet();
        decTypes.AvailableDatatype = "decimal";
        lstTypes.Add(decTypes);


        // IObservable
        obsTypes.Subscribe(x =&gt;
        {
            Console.WriteLine(x);
        });

        // IObserver
        for (int i = 0; i &lt;= lstTypes.Count - 1; i++)
        {
            obsTypes.OnNext(lstTypes[i].AvailableDatatype);
        }

        Console.ReadLine();
    }
}</pre></div></li><li class="listitem">When you run <a class="indexterm" id="id248"/>your application, you will see the same items output to the console window as earlier:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_09.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec77"/>How it works…</h2></div></div></div><p>In Rx, we can declare an event stream with the <code class="literal">Subject</code> keyword. So, we have a source of events that we can publish to using <code class="literal">OnNext</code>. To see those values in the console window, we subscribed to the event stream using <code class="literal">Subscribe</code>.</p><p>Rx allows you to have <a class="indexterm" id="id249"/>objects that are just publishers or just subscribers. This is because the <code class="literal">IObservable</code> and <code class="literal">IObserver</code> interfaces are in fact separate. Also, note that in Rx, the observables can be passed as parameters, returned as results, and stored in variables, which makes them first class:</p><div class="mediaobject"><img alt="How it works…" src="graphics/B05391_04_10.jpg"/></div><p>Rx also allows you to specify that the event stream is completed or that an error occurred. This really sets Rx apart from events in .NET. Also, it is important to note that including the <code class="literal">System.Reactive.Linq</code> namespace in your project allows developers to write queries over the <code class="literal">Subject</code> type because a <code class="literal">Subject</code> is an <code class="literal">IObservable</code> interface:</p><div class="mediaobject"><img alt="How it works…" src="graphics/B05391_04_11.jpg"/></div><p>This is another feature that sets Rx apart from the events in .NET.</p></div></div>
<div class="section" title="Using LINQ to perform queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Using LINQ to perform queries</h1></div></div></div><p>Rx allow developers to <a class="indexterm" id="id250"/>use the <code class="literal">IObservable</code> interface that represents synchronous data streams to write queries using LINQ. To recap, Rx can be thought of as consisting of three sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Observables</strong></span>: The<a class="indexterm" id="id251"/> interface that brings together and represents all these data streams</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Language-Integrated Query</strong></span> (<span class="strong"><strong>LINQ</strong></span>): The <a class="indexterm" id="id252"/>ability to use LINQ to query these multiple data streams</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Schedulers</strong></span>: Parametrizing <a class="indexterm" id="id253"/>concurrency using schedulers</li></ul></div><p>In this recipe, we will be<a class="indexterm" id="id254"/> looking at the LINQ functionality of Rx in more detail.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec78"/>Getting ready</h2></div></div></div><p>As observables are just data streams, we can use LINQ to query them. In the following recipe, we will output text to the screen based on a LINQ query.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec79"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by adding a new Windows Forms project to your solution:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_12.jpg"/></div></li><li class="listitem">Call the <a class="indexterm" id="id255"/>project <code class="literal">winformRx</code> and click on the <span class="strong"><strong>OK</strong></span><a class="indexterm" id="id256"/> button:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_13.jpg"/></div></li><li class="listitem">In<a class="indexterm" id="id257"/> <span class="strong"><strong>Toolbox</strong></span>, search<a class="indexterm" id="id258"/> for the <span class="strong"><strong>TextBox</strong></span> control and add it to your form:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_14.jpg"/></div></li><li class="listitem">Finally, add a<a class="indexterm" id="id259"/> label control<a class="indexterm" id="id260"/> to your form:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_15.jpg"/></div></li><li class="listitem">Right-click on <a class="indexterm" id="id261"/>your <code class="literal">winformRx</code> project and <a class="indexterm" id="id262"/>select <span class="strong"><strong>Manage NuGet Packages…</strong></span> from the context menu:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_16.jpg"/></div></li><li class="listitem">In the search text box, enter <code class="literal">System.Reactive</code> to search for the NuGet package and click <a class="indexterm" id="id263"/>on the <span class="strong"><strong>Install</strong></span> button:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_17.jpg"/></div></li><li class="listitem">Visual <a class="indexterm" id="id264"/>Studio will ask you to review the changes it's about to make to your project. Click on the <span class="strong"><strong>OK</strong></span> button:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_18.jpg"/></div></li><li class="listitem">Before the installation <a class="indexterm" id="id265"/>starts, you might need to <a class="indexterm" id="id266"/>accept the license agreement by clicking on the <span class="strong"><strong>I Accept</strong></span> button:</li><li class="listitem">After the installation completes, you should see the newly added references to your <code class="literal">winformRx</code> project if you expand the <span class="strong"><strong>References</strong></span> for the project:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_20.jpg"/></div></li><li class="listitem">Finally, right-click<a class="indexterm" id="id267"/> on the project and set <code class="literal">winformRx</code> as<a class="indexterm" id="id268"/> your startup project by clicking on <span class="strong"><strong>Set as StartUp Project</strong></span> from the context menu:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_21.jpg"/></div></li><li class="listitem">Create the form load event handler for the form by double-clicking anywhere on the Windows Form. To this form, add the <code class="literal">Observable</code> keyword. You will notice that the keyword<a class="indexterm" id="id269"/> is immediately underlined. This<a class="indexterm" id="id270"/> is because you are missing the reference to the LINQ assembly of <code class="literal">System.Reactive</code>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_22.jpg"/></div></li><li class="listitem">To add this, press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>.</em></span> (period) to bring up the possible suggestions to fix the issue. Select to add the <code class="literal">using System.Reactive.Linq</code> namespace to your project:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_23.jpg"/></div></li><li class="listitem">Continue adding the following code to your form load event. Basically, you are using LINQ and telling the compiler that you want to select the text from the event pattern that matches the text changed event of the text box on the form called <code class="literal">textBox1</code>. After you have done that, add a subscription to the variable and tell it to output <a class="indexterm" id="id271"/>whatever it finds in the text to the label on the form called <code class="literal">label1</code>:<div class="informalexample"><pre class="programlisting">private void Form1_Load(object sender, EventArgs e)
{
    var searchTerm = Observable.FromEventPattern&lt;EventArgs&gt;(textBox1, "TextChanged")
    .Select(x =&gt; ((TextBox)x.Sender).Text);

    searchTerm.Subscribe(trm =&gt; label1.Text = trm);
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>When we added the text box and label to our form, we left the control names as default. If, however, you changed the default names, you would need to specify those names instead of <code class="literal">textBox1</code> and <code class="literal">label1</code> for the controls on the form.</p></div></div></li><li class="listitem">Click on the run<a class="indexterm" id="id272"/> button to run your application. The Windows Form will be displayed with the text box and label on it:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_24.jpg"/></div></li><li class="listitem">Notice that the text is output to the label on the form as you type:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_25.jpg"/></div></li><li class="listitem">Let's jazz things up a bit by adding a <code class="literal">Where</code> condition to the LINQ statement. We will <a class="indexterm" id="id273"/>specify that the <code class="literal">text</code> string must only select the text when it ends with a period. This means that the text will only be<a class="indexterm" id="id274"/> displayed in the label after each full sentence. As you can see, we aren't doing anything special here. We are merely using standard LINQ to query our data stream and return the results to our <code class="literal">searchTerm</code> variable:<div class="informalexample"><pre class="programlisting">private void Form1_Load(object sender, EventArgs e)
{
    var searchTerm = Observable.FromEventPattern&lt;EventArgs&gt;(textBox1, "TextChanged")
    .Select(x =&gt; ((TextBox)x.Sender).Text) 
    .Where(text =&gt; text.EndsWith("."));

    searchTerm.Subscribe(trm =&gt; label1.Text = trm);
}</pre></div></li><li class="listitem">Run your application and start typing in a line of text. You will see that nothing is output to the label control as you type, as was evident in the previous example before<a class="indexterm" id="id275"/> we added in our <code class="literal">Where</code> condition:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_26.jpg"/></div></li><li class="listitem">Add a period <a class="indexterm" id="id276"/>and start adding a second line of text:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_27.jpg"/></div></li><li class="listitem">You will see that only<a class="indexterm" id="id277"/> after each period, the text<a class="indexterm" id="id278"/> entered is added to the label. Our <code class="literal">Where</code> condition is, therefore, working perfectly:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_28.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec80"/>How it works…</h2></div></div></div><p>The LINQ aspect of Rx allows <a class="indexterm" id="id279"/>developers to construct observables. Here are some examples: </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Empty&lt;&gt;</code>: Returns an empty observable sequence</li><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Return&lt;&gt;</code>: Returns an observable sequence containing a single element</li><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Throw&lt;&gt;</code>: Returns an observable sequence terminating with an exception</li><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.Never&lt;&gt;</code>: Returns a non-terminating observable sequence infinite in duration</li></ul></div><p>The use of LINQ in Rx allows<a class="indexterm" id="id280"/> the developer to manipulate and filter the data stream to return exactly what they need.</p></div></div>
<div class="section" title="Using schedulers in Rx"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Using schedulers in Rx</h1></div></div></div><p>Sometimes, we need to have<a class="indexterm" id="id281"/> an <code class="literal">IObservable</code> subscription run at a specific time. Imagine <a class="indexterm" id="id282"/>having to synchronize events across servers in geographically different areas and time zones. You might also need to read data from a queue while preserving the order in which the events occur. Another example would be to perform some kind of I/O task that could take some time to complete. Schedulers come in very handy in these situations.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec81"/>Getting ready</h2></div></div></div><p>Additionally, you can <a class="indexterm" id="id283"/>consider reading up more on using schedulers on MSDN. Have a look at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx">https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec82"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If you haven't already done so, create a new Windows Form application and call it <code class="literal">winformRx</code>. Open the form designer and in <span class="strong"><strong>Toolbox</strong></span>, search for the <span class="strong"><strong>TextBox</strong></span> control and add it to your form:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_14.jpg"/></div></li><li class="listitem">Next, add <a class="indexterm" id="id284"/>a label <a class="indexterm" id="id285"/>control to your form:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_15.jpg"/></div></li><li class="listitem">Double-click on your Windows Form designer to create the onload event handler. Inside this handler, add some code to read the text entered into the text box and only <a class="indexterm" id="id286"/>display that text 5 seconds after the user has stopped typing. This is achieved using the <code class="literal">Throttle</code> keyword. Add a<a class="indexterm" id="id287"/> subscription to the <code class="literal">searchTerm</code> variable, writing the result of the text input to the label control's text property:<div class="informalexample"><pre class="programlisting">private void Form1_Load(object sender, EventArgs e)
{
    var searchTerm = Observable.FromEventPattern&lt;EventArgs&gt;(textBox1, "TextChanged")
    .Select(x =&gt; ((TextBox)x.Sender).Text) 
    .Throttle(TimeSpan.FromMilliseconds(5000));

    searchTerm.Subscribe(trm =&gt; label1.Text = trm);
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Note that you might need to add <code class="literal">System.Reactive.Linq</code> in your <code class="literal">using</code> statements.</p></div></div></li><li class="listitem">Run your application and start typing in some text into the text box. Immediately, we will receive an exception. It is a cross-thread violation. This occurs when there is <a class="indexterm" id="id288"/>an attempt to update the UI from a background thread. The <code class="literal">Observable</code> interface is running a timer from <code class="literal">System.Threading</code>, which isn't on the same thread as the UI. Luckily, there is an <a class="indexterm" id="id289"/>easy way to overcome this. Well, it turns out that the UI-threading capabilities lie in a different assembly, which we found easiest to get via the <span class="strong"><strong>Package Manager Console</strong></span>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_29.jpg"/></div></li><li class="listitem">Click on <span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Other Windows</strong></span> | <span class="strong"><strong>Package Manager Console</strong></span> to access the <span class="strong"><strong>Package Manager Console</strong></span>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_16.jpg"/></div></li><li class="listitem">Enter the<a class="indexterm" id="id290"/> following <a class="indexterm" id="id291"/>command: <code class="literal">PM&gt; Install-Package System.Reactive.Windows.Forms</code><div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_30.jpg"/></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Please note that you need to ensure that the <span class="strong"><strong>Default project</strong></span> selection is set to <code class="literal">winformRx</code> in the <span class="strong"><strong>Package Manager Console</strong></span>. If you don't see this option, resize the <span class="strong"><strong>Package Manager Console</strong></span> screen width until the option is displayed. This way you can be certain that the package is added to the correct project.</p></div></div></li><li class="listitem">After the<a class="indexterm" id="id292"/> installation completes, modify your code in the<a class="indexterm" id="id293"/> onload event handler and change <code class="literal">searchTerm.Subscribe(trm =&gt; label1.Text = trm);</code>, which does the subscription, to look like this:<div class="informalexample"><pre class="programlisting">searchTerm.ObserveOn(new ControlScheduler(this)).Subscribe(trm =&gt; label1.Text = trm);</pre></div><p>You will notice that we are using the <code class="literal">ObserveOn</code> method here. What this basically tells the compiler is that the <code class="literal">this</code> keyword in <code class="literal">new ControlScheduler(this)</code> is actually a reference to our Windows Form. Therefore, <code class="literal">ControlScheduler</code> will use the Windows Forms timers to create the interval to update our UI. The message happens on the correct thread, and we no longer have our cross-thread violation.</p></li><li class="listitem">If you have not<a class="indexterm" id="id294"/> added the <code class="literal">System.Reactive.Concurrency</code> namespace to your project, Visual Studio will underline the <code class="literal">ControlScheduler</code> line of code with a squiggly line. Pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>.</em></span> (the Control key and dot) will allow you to add the missing namespace:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_33.jpg"/></div></li><li class="listitem">This means that <code class="literal">System.Reactive.Concurrency</code> contains a scheduler that can talk to Windows<a class="indexterm" id="id295"/> Forms controls so that it can do the scheduling. Run your application again and start typing some text into your text box:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_34.jpg"/></div></li><li class="listitem">Five seconds after we stop typing, the throttle condition is fulfilled, and the text is output to our label:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_35.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec83"/>How it works…</h2></div></div></div><p>What we need to keep in mind here from the code we created is that there are <code class="literal">ObserveOn</code> and <code class="literal">Subscribe</code>. You should<a class="indexterm" id="id296"/> not confuse the two. In most cases, when dealing with schedulers, you will use <code class="literal">ObserveOn</code>. The <code class="literal">ObserveOn</code> method allows you to<a class="indexterm" id="id297"/> parametrize where the <code class="literal">OnNext</code>, <code class="literal">OnCompleted</code>, and <code class="literal">OnError</code> messages run. With <code class="literal">Subscribe</code>, we parameterize where the actual subscribe and unsubscribe code runs.</p><p>We also need to remember that Rx use the threading timers (<code class="literal">System.Threading.Timer</code>) as a default, which is why we encountered the cross-thread violation earlier. As you saw though, we used schedulers to parameterize what timer to use. The way schedulers do this is by exposing three components. These are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The scheduler's ability to perform some action</li><li class="listitem" style="list-style-type: disc">The order in which the action or work to be performed is executed</li><li class="listitem" style="list-style-type: disc">A clock that allows the scheduler to have a notion of time</li></ul></div><p>The use of a clock is important because it allows the developer to use timers on remote machines, for example (where<a class="indexterm" id="id298"/> there might be a time difference between you <a class="indexterm" id="id299"/>and them), to tell them to perform an action at a particular time.</p></div></div>
<div class="section" title="Debugging lambda expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Debugging lambda expressions</h1></div></div></div><p>Visual Studio 2015 has added the<a class="indexterm" id="id300"/> ability for developers to debug lambda expressions. This is a fantastic addition to the features of our favorite IDE. It allows us to check the results of a lambda expression on the fly and modify the expression to test different scenarios.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec84"/>Getting ready</h2></div></div></div><p>We will create a very basic lambda expression and change it in the <span class="strong"><strong>Watch</strong></span> window to produce a different value.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec85"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a class called <code class="literal">CSharpSix</code>. Add a property to this class called <code class="literal">FavoriteFeature</code>:<div class="informalexample"><pre class="programlisting">public class CSharpSix
{
    public string FavoriteFeature { get; set; }
}</pre></div></li><li class="listitem">Next, create a <code class="literal">List&lt;CSharpSix&gt;</code> object and add a few of your favorite C# 6 features to this list:<div class="informalexample"><pre class="programlisting">List&lt;CSharpSix&gt; FavCSharpFeatures = new List&lt;CSharpSix&gt;();
CSharpSix feature1 = new CSharpSix();
feature1.FavoriteFeature = "String Interpolation";
FavCSharpFeatures.Add(feature1);

CSharpSix feature2 = new CSharpSix();
feature2.FavoriteFeature = "Exception Filters";
FavCSharpFeatures.Add(feature2);

CSharpSix feature3 = new CSharpSix();
feature3.FavoriteFeature = "Nameof Expressions";
FavCSharpFeatures.Add(feature3);</pre></div></li><li class="listitem">Then, create an expression to return only the features starting with the <code class="literal">"Ex"</code> string. Here, we would obviously expect to see exception filters as a result:<div class="informalexample"><pre class="programlisting">var filteredFeature = FavCSharpFeatures.Where(feature =&gt; feature.FavoriteFeature.StartsWith("Ex"));</pre></div></li><li class="listitem">Place a breakpoint on the expression and run your application. When the code stops at the breakpoint, you can copy the lambda expression:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_36.jpg"/></div></li><li class="listitem">Paste the lambda <a class="indexterm" id="id301"/>expression into your <span class="strong"><strong>Watch</strong></span> windows and change the string in the <code class="literal">StartsWith</code> method. You will see that the result has changed to the <code class="literal">"Nameof Expressions"</code> string:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_04_37.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec86"/>How it works…</h2></div></div></div><p>Being able to debug lambda expressions allows us to change and debug a lambda expression easily. This is something that was not possible in previous versions of Visual Studio. It is obviously of great importance to know this tip when working with these expressions.</p><p>Another point to note is that<a class="indexterm" id="id302"/> you can do the same thing from the <span class="strong"><strong>Immediate</strong></span> window in Visual Studio 2015, as well as pinned variables from the lambda expression.</p></div></div></body></html>