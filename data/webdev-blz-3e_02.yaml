- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Creating Your First Blazor App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个 Blazor 应用程序
- en: In this chapter, we will set up our development environment so that we can start
    developing Blazor apps. We will create our first Blazor app and go through the
    project structure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置我们的开发环境，以便我们可以开始开发 Blazor 应用程序。我们将创建我们的第一个 Blazor 应用程序，并了解项目结构。
- en: By the end of this chapter, you will have a working development environment
    and have created a Blazor App that can run a mix of streaming server-side rendering,
    Blazor Server, and Blazor WebAssembly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个可工作的开发环境，并创建了一个可以运行混合流式服务器端渲染、Blazor 服务器和 Blazor WebAssembly 的
    Blazor 应用程序。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up your development environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: Creating our first Blazor application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Blazor 应用程序
- en: Using the command line
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行
- en: Figuring out the project structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定项目结构
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will create a new project (a blog engine) and will continue working on that
    project throughout the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的项目（一个博客引擎），并在整本书中继续对该项目进行工作。
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter02).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter02)
    找到本章结果的源代码。
- en: Setting up your development environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: In this book, the focus will be on Windows development, and any screenshots
    are going to be from Visual Studio (unless stated otherwise). But since .NET 8
    is cross-platform, we will go through how to set up your development environment
    on Windows, macOS, and Linux.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将重点关注 Windows 开发，并且任何截图都将来自 Visual Studio（除非另有说明）。但由于 .NET 8 是跨平台的，我们将介绍如何在
    Windows、macOS 和 Linux 上设置您的开发环境。
- en: The go-to link for all the platforms can be found at [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有平台的链接可以在这里找到：[https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/).
- en: We can download Visual Studio or Visual Studio Code from the web page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从网页上下载 Visual Studio 或 Visual Studio Code。
- en: Windows
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: On Windows, we have many different options for developing Blazor applications.
    Visual Studio 2022 is the most powerful tool we can use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们有很多不同的选项来开发 Blazor 应用程序。Visual Studio 2022 是我们可以使用的最强大的工具。
- en: 'There are three different editions, which are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个不同的版本，如下所示：
- en: Community 2022
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区 2022
- en: Professional 2022
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专业 2022
- en: Enterprise 2022
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业 2022
- en: 'In short, the Community Edition is free, while the others cost money. The Community
    Edition does have some limitations, and we can compare the different editions
    here: [https://visualstudio.microsoft.com/vs/compare/](https://visualstudio.microsoft.com/vs/compare/).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，社区版是免费的，而其他版本则需要付费。社区版确实有一些限制，我们可以在以下链接中比较不同的版本：[https://visualstudio.microsoft.com/vs/compare/](https://visualstudio.microsoft.com/vs/compare/).
- en: 'For this book, we can use any of these versions. Take the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我们可以使用这些版本中的任何一种。请按照以下步骤操作：
- en: Download Visual Studio 2022 from [https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/).
    Choose the version that is right for you.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/)
    下载 Visual Studio 2022。选择适合您的版本。
- en: 'Install Visual Studio and, during the installation, make sure to select **ASP.NET
    and web development**, as shown in *Figure 2.1*:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Visual Studio，并在安装过程中确保选择 **ASP.NET 和 Web 开发**，如图 *图 2.1* 所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_02_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  自动生成的描述](img/B21849_02_01.png)'
- en: 'Figure 2.1: Visual Studio 2022 installation on Windows'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：Windows 上 Visual Studio 2022 的安装
- en: To the right is a list of all the components that will be installed. Check **.NET
    WebAssembly Build Tools**. There might be a .NET6 or .NET 7 version in the list
    as well but we want the one without a version number.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧是一个将安装的所有组件的列表。请检查 **.NET WebAssembly Build Tools**。列表中可能还有 .NET6 或 .NET
    7 版本，但我们想要不带版本号的版本。
- en: We can also use Visual Studio Code to develop Blazor on Windows, but we won’t
    discuss the installation process for Windows.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 Visual Studio Code 在 Windows 上开发 Blazor，但我们将不会讨论 Windows 的安装过程。
- en: macOS and Linux (or Windows)
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: macOS 和 Linux（或 Windows）
- en: Visual Studio Code is cross-platform, which means we can use it on Linux, macOS,
    or Windows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 是跨平台的，这意味着我们可以在 Linux、macOS 或 Windows 上使用它。
- en: The different versions are available at [https://code.visualstudio.com/Download](https://code.visualstudio.com/Download).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不同版本可在 [https://code.visualstudio.com/Download](https://code.visualstudio.com/Download)
    获取。
- en: 'Once installed, we also need to add two extensions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们还需要添加两个扩展：
- en: Open Visual Studio Code and open the extension panel by pressing *Shift* + *command*
    + *X*on macOS or *Ctrl*+ *Shift*+ *X on Linux and Windows*.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code 并通过按 *Shift* + *command* + *X*（在 macOS 上）或 *Ctrl*+ *Shift*+
    *X*（在 Linux 和 Windows 上）打开扩展面板。
- en: Search for `C# Dev Kit for Visual Studio Code` and click **Install**. You might
    need a Microsoft account to install C# Dev Kit.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `Visual Studio Code 的 C# 开发工具包` 并点击 **安装**。您可能需要一个 Microsoft 账户来安装 C# 开发工具包。
- en: Search for `JavaScript Debugger (Nightly)` and click **Install**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `JavaScript 调试器（夜间版）` 并点击 **安装**。
- en: There are other IDEs that are cross-platform as well, like JetBrains Rider for
    example, that some prefer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他跨平台的 IDE，例如 JetBrains Rider，有些人更喜欢使用。
- en: Now that everything is set up, let’s create our first app.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，让我们创建我们的第一个应用。
- en: Creating our first Blazor application
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Blazor 应用程序
- en: Throughout the book, we will create a blog engine. There won’t be a lot of business
    logic that you’ll have to learn; the app is simple to understand but will touch
    base on many of the technologies and areas you will be faced with when building
    a Blazor app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将创建一个博客引擎。您不需要学习很多业务逻辑；该应用易于理解，但将涉及您在构建 Blazor 应用时将面临的技术和领域。
- en: I had an opportunity to discuss the project with Steve Sanderson (creator of
    Blazor) and Dan Roth (program manager for ASP.NET). We came to the conclusion
    that this is going to showcase the most important features of Blazor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我有机会与 Steve Sanderson（Blazor 的创造者）和 Dan Roth（ASP.NET 的项目经理）讨论该项目。我们得出的结论是，这将展示
    Blazor 最重要的功能。
- en: The project will allow visitors to read blog posts and post comments. It will
    also have an admin site where we can write a blog post, which will be password-protected.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将允许访客阅读博客文章并发表评论。它还将有一个管理网站，我们可以在这里撰写博客文章，这将受到密码保护。
- en: We will create an app that leverages Blazor Server, Blazor WebAssembly, and
    streaming server-side rendering.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个利用 Blazor 服务器、Blazor WebAssembly 和流式服务器端渲染的应用。
- en: IMPORTANT NOTE
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This guide will use Visual Studio 2022 from now on, but other platforms have
    similar ways of creating projects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，本指南将使用 Visual Studio 2022，但其他平台也有类似创建项目的方法。
- en: Exploring the templates
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索模板
- en: In .NET 8, Microsoft reduced the amount of templates we have access to. We will
    explore them further in *Chapter 4*, *Understanding Basic Blazor Components*.
    This chapter will give you a quick overview.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 8 中，微软减少了我们可访问的模板数量。我们将在 *第 4 章*，*理解基本 Blazor 组件* 中进一步探讨它们。这一章将为您提供一个快速概述。
- en: In .NET 7, we had different templates depending on whether we wanted sample
    code, but in .NET 8 we only have two. We also have one Blazor Hybrid template
    (.NET MAUI), but we will return to it in *Chapter 18*, *Visiting .NET MAUI*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 7 中，根据我们是否需要示例代码，我们有不同的模板，但在 .NET 8 中我们只有两个。我们还有一个 Blazor 混合模板 (.NET
    MAUI)，但我们将会在 *第 18 章*，*访问 .NET MAUI* 中回到它。
- en: Blazor Web App
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor Web 应用
- en: The **Blazor Web App** template gives us a Blazor app. Once we have selected
    this template, we get options for how we want our app to run. We can configure
    our app with sample code or without. We can choose whether our app should support
    interactive components and what type of interactivity we want. We can also choose
    whether we want to specify the rendering mode per component or for the full app.
    So, right away, we don’t need to choose whether or not we want to choose Blazor
    Server or Blazor WebAssembly; we can mix and match.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blazor Web 应用** 模板为我们提供了一个 Blazor 应用。一旦我们选择了这个模板，我们就可以选择我们希望应用如何运行。我们可以使用示例代码或无代码配置我们的应用。我们可以选择是否支持交互式组件以及我们想要的交互类型。我们还可以选择是否为每个组件或整个应用指定渲染模式。因此，一开始，我们不需要选择是否要选择
    Blazor 服务器或 Blazor WebAssembly；我们可以混合搭配。'
- en: If we add sample pages, we get a couple of components to see what a Blazor app
    looks like and some basic setup and menu structure. It also contains code for
    adding Bootstrap, Isolated CSS, and things like that (see *Chapter 9*, *Sharing
    Code and Resources*).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加示例页面，我们将获得一些组件来查看 Blazor 应用看起来像什么，以及一些基本的设置和菜单结构。它还包含添加 Bootstrap、隔离 CSS
    以及类似内容的代码（见 *第 9 章*，*共享代码和资源*）。
- en: This is the template we will use in the book to better understand how things
    go together.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中将使用的模板，以便更好地理解事物是如何组合在一起的。
- en: Blazor WebAssembly Standalone App
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 独立应用
- en: The **Blazor WebAssembly Standalone App** template gives us (as the name implies)
    a Blazor WebAssembly standalone app. Here, we can choose whether we want to have
    sample pages as well. It contains a couple of components to see what a Blazor
    app looks like and some basic setup and menu structure. It also contains code
    for adding Bootstrap, isolated CSS, and things like that (see *Chapter 9*, *Sharing
    Code and Resources*). So why do we have this one? Well, the Blazor Web App is
    dependent on server rendering technologies in one way or another. If you want
    to be able to run your app from a file share, GitHub Pages, or Azure Static Web
    Apps (to name a few), this is the template for you.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blazor WebAssembly Standalone App**模板（正如其名所示）为我们提供了一个Blazor WebAssembly独立应用程序。在这里，我们可以选择是否要包含示例页面。它包含一些组件，以展示Blazor应用程序的外观，以及一些基本的设置和菜单结构。它还包含添加Bootstrap、独立CSS等代码（见*第9章*，*共享代码和资源*）。那么为什么我们有这个模板呢？嗯，Blazor
    Web App在某种程度上依赖于服务器渲染技术。如果你想要能够从文件共享、GitHub Pages或Azure Static Web Apps（仅举几个例子）运行你的应用程序，这个模板就是为你准备的。'
- en: Creating a Blazor web application
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Blazor Web应用程序
- en: 'To start, we will create a Blazor Server application and play around with it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个Blazor服务器应用程序并对其进行操作：
- en: 'Start Visual Studio 2022, and you will see the following screen:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2022，你将看到以下屏幕：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_02_02.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B21849_02_02.png)'
- en: 'Figure 2.2: Visual Studio startup screen'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：Visual Studio启动屏幕
- en: Click **Create a new project**, and in the search bar, type `blazor`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建新项目**，在搜索栏中输入`blazor`。
- en: 'You will get a list of different templates – this is a mix of .NET 7 and .NET
    8 templates. Now we need to select the template for our project. Select **Blazor
    Web App** from the search results and click **Next**:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将获得不同模板的列表——这是.NET 7和.NET 8模板的混合。现在我们需要选择项目的模板。从搜索结果中选择**Blazor Web App**并点击**下一步**：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_02_03.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B21849_02_03.png)'
- en: 'Figure 2.3: The Visual Studio Create a new project screen'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Visual Studio创建新项目屏幕
- en: 'Now name the project (this is the hardest part of any project, but fear not,
    I have done that already!). Name the application `BlazorWebApp`. Change the solution
    name to `MyBlog` and click **Next**:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在命名项目（这是任何项目中最难的部分，但别担心，我已经完成了这个步骤！）！将应用程序命名为`BlazorWebApp`。将解决方案名称更改为`MyBlog`并点击**下一步**：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_02_04.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B21849_02_04.png)'
- en: 'Figure 2.4: The Visual Studio Configure your new project screen'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：Visual Studio配置新项目屏幕
- en: Next, choose what kind of Blazor app we should create. Select **.NET 8.0 (Long
    Term Support)** from the dropdown menu. Set **Authentication type** to **None**.
    Check **Configure** for HTTPS. Set Interactive render mode to **Auto (Server and
    Webassembly)** and **Interactivity location** to **Per page/component**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择我们应该创建哪种类型的Blazor应用程序。从下拉菜单中选择**.NET 8.0（长期支持）**。将**身份验证类型**设置为**无**。勾选**配置**以启用HTTPS。将交互式渲染模式设置为**自动（服务器和Webassembly）**并将**交互性位置**设置为**每页/组件**。
- en: 'Check **Include sample pages**. Uncheck **Do not use top-level statements**.
    Uncheck **Enlist in .NET Aspire orchestration** and click **Create**:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**包含示例页面**。取消选择**不使用顶级语句**。取消选择**加入.NET Aspire编排**并点击**创建**：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_02_05.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B21849_02_05.png)'
- en: 'Figure 2.5: Visual Studio screen for creating a new Blazor app'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：Visual Studio创建新Blazor应用程序屏幕
- en: Now run the app by pressing **Ctrl** + **F5** (we can also find it under the
    menu **Debug** | **Start without debugging**).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过按**Ctrl** + **F5**（我们也可以在**调试** | **不调试启动**菜单下找到它）来运行应用程序。
- en: 'Congratulations! You have just created your first Blazor web application. The
    site should look something like in *Figure 2.6*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你第一个Blazor Web应用程序。网站应该看起来像*图2.6*所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_02_06.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B21849_02_06.png)'
- en: 'Figure 2.6: A new Blazor Web App'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：一个新的Blazor Web App
- en: Explore the site a bit, navigate to **Counter** and **Weather** to get a feeling
    for the load times, and see what the sample application does.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 探索一下网站，导航到**计数器**和**天气**以了解加载时间，并查看示例应用程序的功能。
- en: The different pages have different ways of running. The Counter page is interactive
    and uses auto render mode. This means if loading the WebAssembly version takes
    longer than 100 milliseconds, the web will first start up a SignalR connection
    that will load the component fast. In the background, the WebAssembly version
    is downloaded and cached. The next time the user visits our site, it will use
    the cached version and load much faster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的页面有不同的运行方式。计数器页面是交互式的，并使用自动渲染模式。这意味着如果加载 WebAssembly 版本需要超过 100 毫秒，网页将首先启动一个
    SignalR 连接，以便快速加载组件。在后台，WebAssembly 版本将被下载并缓存。下次用户访问我们的网站时，它将使用缓存的版本并快速加载。
- en: The browser downloads the page, some CSS, and then `blazor.web.js`, which is
    responsible for setting up the site. In some cases, it’s a SignalR connection
    back to the server, and in some, it’s starting up WebAssembly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器下载页面、一些 CSS 和 `blazor.web.js`，这是负责设置网站的文件。在某些情况下，它是一个返回服务器的 SignalR 连接，在某些情况下，它启动
    WebAssembly。
- en: The Counter page is configured as `RenderMode:Auto`, which means it will first
    render with Blazor Server and then any following requests will update with WebAssembly.
    As soon as you switch to the Counter page, a bunch of files will get downloaded
    in the background.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器页面配置为 `RenderMode:Auto`，这意味着它将首先使用 Blazor Server 进行渲染，然后任何后续请求都将使用 WebAssembly
    进行更新。一旦切换到计数器页面，就会在后台下载大量文件。
- en: 'In this case, when the page gets downloaded, it will trigger a download of
    the necessary JavaScript files. Then, `blazor.boot.json` gets downloaded. *Figure
    2.13* shows an example of part of `blazor.boot.json`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当页面被下载时，将触发必要的 JavaScript 文件的下载。然后，下载 `blazor.boot.json`。*图 2.13* 展示了
    `blazor.boot.json` 部分内容的示例：
- en: '![A close up of text  Description automatically generated](img/B21849_02_07.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![文本的特写  自动生成的描述](img/B21849_02_07.png)'
- en: 'Figure 2.7: Part of the blazor.boot.json file'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：blazor.boot.json 文件的部分内容
- en: The most important thing `blazor.boot.json` contains is the entry assembly,
    which is the name of the DLL the browser should start executing. It also includes
    all the framework DLLs the app needs to run. Now, our app knows what it needs
    to start up. In previous versions of .NET, the files were DLL files. In .NET 8,
    we download `.wasmfiles`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`blazor.boot.json` 中最重要的内容是入口程序集，这是浏览器应该开始执行 DLL 的名称。它还包括应用程序运行所需的所有框架 DLL。现在，我们的应用程序知道它需要启动什么。在
    .NET 的早期版本中，文件是 DLL 文件。在 .NET 8 中，我们下载 `.wasmfiles`。'
- en: By default, Blazor will use `Webcil`, which is a payload format. `Webcil` will
    package the DLLs. Some providers have turned off support for DLL files, and anti-virus
    programs have issues with DLL files, so this is an awesome update.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Blazor 将使用 `Webcil`，这是一种有效载荷格式。`Webcil` 将打包 DLLs。一些提供商已经关闭了对 DLL 文件的支持，并且防病毒程序与
    DLL 文件存在问题，因此这是一个很棒的更新。
- en: 'JavaScript will then download all the resources mentioned in `blazor.boot.json`:
    this is a mix of your code compiled to a .NET Standard DLL, Microsoft .NET Framework
    code, and any community or third-party DLLs you might use. The JavaScript then
    downloads `dotnet.native.wasm`, the Mono runtime compiled to WebAssembly, which
    will start booting up your app.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 将下载 `blazor.boot.json` 中提到的所有资源：这是一个混合体，包括您的代码编译成的 .NET Standard
    DLL、Microsoft .NET Framework 代码以及您可能使用的任何社区或第三方 DLL。然后，JavaScript 下载 `dotnet.native.wasm`，这是编译成
    WebAssembly 的 Mono 运行时，它将启动您的应用程序。
- en: Now, we have the base for our project. Throughout this book, we will use Visual
    Studio, but there are other ways to run your Blazor site, such as using the command
    line. The command line is a super powerful tool, and in the next section, we will
    take a look at how to set up a project using the command line.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了项目的基线。在这本书的整个过程中，我们将使用 Visual Studio，但还有其他方法可以运行您的 Blazor 网站，例如使用命令行。命令行是一个超级强大的工具，在下一节中，我们将探讨如何使用命令行设置项目。
- en: Using the command line
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行
- en: With .NET 5, we got a super powerful tool called `dotnet.exe`. Developers who
    have used .NET Core before will already be familiar with the tool, but with .NET
    5, it is no longer exclusively for .NET Core developers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5 中，我们获得了一个名为 `dotnet.exe` 的超级强大工具。之前使用过 .NET Core 的开发者已经熟悉这个工具了，但在 .NET
    5 中，它不再仅限于 .NET Core 开发者使用。
- en: It can do many things Visual Studio can do, for example, creating projects,
    adding and creating NuGet packages, and much more. In the following example, we
    will create a Blazor Server and a Blazor WebAssembly project using the **dotnet**
    command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以完成 Visual Studio 可以做的许多事情，例如创建项目、添加和创建 NuGet 包，等等。在下面的示例中，我们将使用 **dotnet**
    命令创建一个 Blazor Server 和一个 Blazor WebAssembly 项目。
- en: Creating projects using the command line
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行创建项目
- en: The following steps are to demonstrate the power of using the command line.
    We will not use this project later in the book, so if you don’t want to try it,
    go ahead and skip this section. The CLI is cross-platform, so this can be used
    on Linux and macOS as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是为了展示使用命令行的强大功能。我们将在本书的后续内容中不会使用此项目，所以如果你不想尝试，可以跳过这一部分。CLI 是跨平台的，因此这也可以在
    Linux 和 macOS 上使用。
- en: 'To create a solution with a Blazor app, you can do the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Blazor 应用程序创建解决方案，你可以执行以下操作：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will not go deeper into the CLI in this book but know that it is a great
    way to create projects, add packages, and much, much more.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中不会深入探讨 CLI，但要知道它是一种创建项目、添加包以及更多操作的好方法。
- en: 'NOTE: THE .NET CLI'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：.NET CLI
- en: 'The idea is that you should be able to do everything from the command line.
    If you prefer working with the command line, you should check out the .NET CLI;
    you can read more about the .NET CLI here: [https://docs.microsoft.com/en-us/dotnet/core/tools/](https://docs.microsoft.com/en-us/dotnet/core/tools/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，你应该能够从命令行完成所有操作。如果你更喜欢使用命令行，你应该查看 .NET CLI；你可以在以下链接中了解更多关于 .NET CLI 的信息：[https://docs.microsoft.com/en-us/dotnet/core/tools/](https://docs.microsoft.com/en-us/dotnet/core/tools/)。
- en: Let’s go back to the Blazor template, which has added a lot of files for us.
    In the next section, we will look at what Visual Studio has generated for us.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 Blazor 模板，它为我们添加了许多文件。在下一节中，我们将查看 Visual Studio 为我们生成的内容。
- en: Figuring out the project structure
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定项目结构
- en: 'Visual Studio will generate two projects: `Blazor App`, which is the server
    project, and `BlazorWebApp.Client`, which is where we put our WebAssembly components.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 将生成两个项目：`Blazor App`，这是服务器项目，以及 `BlazorWebApp.Client`，这是我们放置 WebAssembly
    组件的地方。
- en: Now, it’s time to look at the different files and how they may differ in different
    projects. Take a look at the code in the two projects we just created (in the
    *Creating our first Blazor app* section) while we go through them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候查看不同的文件以及它们在不同项目中的可能差异了。在我们逐一查看时，请查看我们刚刚创建的两个项目中的代码（在 *创建我们的第一个 Blazor
    应用* 部分）。
- en: Program.cs (BlazorWebApp project)
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Program.cs (BlazorWebApp 项目)
- en: '`Program.cs` is the first class that gets called. So, let’s start looking at
    that one.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs` 是第一个被调用的类。因此，让我们从它开始看起。'
- en: 'The `Program.cs` file looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs` 文件看起来是这样的：'
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In .NET 6, Microsoft removed the `Startup.cs` file and put all the startup code
    in `Program.cs`. It also uses top-level statements, which makes the code a bit
    less bloated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6 中，Microsoft 删除了 `Startup.cs` 文件，并将所有启动代码放入 `Program.cs`。它还使用了顶级语句，这使得代码略微不那么臃肿。
- en: There are a few things worthy of mentioning here. The Program class starts with
    adding all the dependencies we need in our application. In this case, we add `RazorComponent`,
    which enables us to run Razor components. Then, we add `InteractiveServerComponents`,
    giving us access to all the objects we need to run Blazor Server. Since we selected
    the auto render mode, we also get access to Blazor WebAssembly by adding `InteractiveWebAssemblyComponents.`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一些值得提到的事情。`Program` 类从添加我们应用程序中需要的所有依赖项开始。在这种情况下，我们添加了 `RazorComponent`，这使得我们能够运行
    Razor 组件。然后，我们添加了 `InteractiveServerComponents`，这使我们能够访问运行 Blazor 服务器所需的所有对象。由于我们选择了自动渲染模式，我们还通过添加
    `InteractiveWebAssemblyComponents` 获得了对 Blazor WebAssembly 的访问。
- en: It also configures **HTTP Strict Transport Security** (**HSTS**), forcing your
    application to use HTTPS, and will make sure that your users don’t use any untrusted
    resources or certificates. We also ensure that the site redirects to HTTPS to
    secure the site.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它还配置了 **HTTP 严格传输安全**（**HSTS**），强制应用程序使用 HTTPS，并确保用户不会使用任何不受信任的资源或证书。我们还确保网站重定向到
    HTTPS 以保护网站。
- en: '`UseStaticFiles` enables downloading static files such as CSS or images.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseStaticFiles` 允许下载静态文件，如 CSS 或图像。'
- en: '`UseAntiforgery` is a method that adds anti-forgery middleware to the application
    pipeline, providing a layer of security against **Cross-Site Request Forgery**
    (**CSRF** or **XSRF**) attacks.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAntiforgery` 是一个方法，它将反伪造中间件添加到应用程序管道中，提供一层针对 **跨站请求伪造**（**CSRF** 或 **XSRF**）攻击的安全防护。'
- en: These types of attacks occur when a malicious web app influences the interaction
    between a client browser and a web app that trusts that browser, often leading
    to unwanted actions being performed without the user’s consent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的攻击发生在恶意网络应用程序影响客户端浏览器与信任该浏览器的网络应用程序之间的交互时，通常会导致未经用户同意执行不希望的操作。
- en: The different `Use*` methods add request delegates to the request pipeline or
    middleware pipeline. Each request delegate (`ExceptionHandler`, `HttpRedirection`,
    `StaticFiles`, and so on) is called consecutively from the top to the bottom in
    the order they are added in `Program.cs` and back again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 `Use*` 方法将请求代理添加到请求管道或中间件管道。每个请求代理（`ExceptionHandler`、`HttpRedirection`、`StaticFiles`
    等）都按照它们在 `Program.cs` 中添加的顺序从上到下依次调用，然后再从下到上。
- en: This is why the exception handler is the first one to be added.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么异常处理器是第一个被添加的原因。
- en: 'If there is an exception in any of the request delegates that follow, the exception
    handler will still be able to handle it (since the request travels back through
    the pipeline), as shown in *Figure 2.15*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在后续的任何请求代理中发生异常，异常处理器仍然能够处理它（因为请求会通过管道返回），如图 *2.15* 所示：
- en: '![Figure 2.15 – The request middleware pipeline](img/B21849_02_08.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 请求中间件管道](img/B21849_02_08.png)'
- en: 'Figure 2.8: The request middleware pipeline'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：请求中间件管道
- en: If any of these request delegates handle the request in the case of a static
    file, for example, there is no need to involve routing, and the remaining request
    delegates will not get called. Sometimes, it is essential to add the request delegates
    in the correct order; for example, we want to run authentication early in the
    pipeline to make sure that users can’t access things they shouldn’t.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些请求代理中的任何一个在处理静态文件等情况下处理请求，则不需要涉及路由，其余的请求代理将不会被调用。有时，添加请求代理的正确顺序是至关重要的；例如，我们希望在管道中尽早运行身份验证，以确保用户无法访问他们不应访问的内容。
- en: 'NOTE:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：
- en: 'There is more information about this here if you want to dig even deeper: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解，这里有一些更多信息：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0)。
- en: At the end of the class, we map Razor components to the `App` component. We
    add the different render modes and additional assemblies – in this case, the `BlazorWebApp.Client`
    project, which is our WebAssembly project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在类末尾，我们将 Razor 组件映射到 `App` 组件。我们添加不同的渲染模式和额外的程序集 – 在这种情况下，`BlazorWebApp.Client`
    项目，这是我们的 WebAssembly 项目。
- en: Program.cs (BlazorWebApp.Client)
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Program.cs (BlazorWebApp.Client)
- en: The `program.cs` located in the Blazor WebAssembly project doesn’t contain many
    things.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 Blazor WebAssembly 项目的 `program.cs` 文件中不包含很多东西。
- en: 'It looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It simply sets up a host builder and uses the default configuration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是设置主机构建器并使用默认配置。
- en: App (BlazorWebApp)
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App (BlazorWebApp)
- en: The next thing that happens is that the `App` component runs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来发生的事情是 `App` 组件运行。
- en: 'It looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s go through it and see what we can learn. It starts with `html`, `doctype`,
    and a `head` tag. The `head` tag contains meta tags and **stylesheets** (**CSS**).
    The `base` tag is so the application finds the appropriate files. If we are, for
    example, hosting our application in a subfolder (like on GitHub Pages) we need
    to modify the `base` tag to reflect that. The `HeadOutlet` component is for us
    to add things like page titles from within our code (we will return to that in
    *Chapter 5*, *Creating Advanced Blazor Components*).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析，看看我们能学到什么。它从 `html`、`doctype` 和一个 `head` 标签开始。`head` 标签包含元标签和 **样式表**（**CSS**）。`base`
    标签是为了让应用程序找到适当的文件。如果我们，例如，在子文件夹（如 GitHub Pages）中托管我们的应用程序，我们需要修改 `base` 标签以反映这一点。`HeadOutlet`
    组件用于我们在代码中添加诸如页面标题等内容（我们将在 *第 5 章*，*创建高级 Blazor 组件*中回到这一点）。
- en: The `Routes` component is the component that handles all the routing, which
    we will take a look at next. And last but not least, we have the JavaScript that
    makes all of this possible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routes` 组件是处理所有路由的组件，我们将在下一节中对其进行探讨。最后但同样重要的是，我们还有使所有这些成为可能的 JavaScript。'
- en: Routes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: 'The `Routes` component is the one that handles all the routing. It looks like
    this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routes` 组件是处理所有路由的组件。它看起来像这样：'
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This file handles the routing, finding the suitable component to show (based
    on the `@page` directive). It shows an error message if the route can’t be found.
    In *Chapter 8*, *Authentication and Authorization*, we will make changes to this
    file when we implement authentication.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件处理路由，查找要显示的合适组件（基于 `@page` 指令）。如果找不到路由，它会显示错误消息。在 *第 8 章*，*身份验证和授权*中，我们将在此文件实现身份验证时对其进行更改。
- en: The `Routes` component also includes a default layout. We can override the layout
    per component, but usually, you’ll have one layout page for your site. In this
    case, the default layout is called `MainLayout`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routes`组件还包括一个默认布局。我们可以为每个组件覆盖布局，但通常，你将为你的网站有一个布局页面。在这种情况下，默认布局被称为`MainLayout`。'
- en: The `FocusOnNavigate` will set the focus on a specific element once we have
    navigated/loaded a new component/route – in this case, `H1`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`FocusOnNavigate`将在我们导航/加载新的组件/路由后，将焦点设置在特定的元素上——在本例中，是`H1`。'
- en: MainLayout
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MainLayout
- en: '`MainLayout`, which we can find in the shared folder, contains the default
    layout for all components when viewed as a page. The `MainLayout` contains a couple
    of `div` tags, one for the sidebar and one for the main content:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainLayout`，我们可以在共享文件夹中找到，包含所有组件作为页面查看时的默认布局。`MainLayout`包含几个`div`标签，一个用于侧边栏，一个用于主要内容：'
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only things you need in this document are `@inherits LayoutComponentBase`
    and `@Body`; the rest is just Bootstrap.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这份文档中需要的只有`@inherits LayoutComponentBase`和`@Body`；其余的都是Bootstrap。
- en: Bootstrap is one of the most popular CSS frameworks for developing responsive
    and mobile-first websites.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是开发响应式和移动优先网站中最受欢迎的CSS框架之一。
- en: We can find a reference to Bootstrap in the `App.Razor` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`App.Razor`文件中找到对Bootstrap的引用。
- en: 'It was created by and for Twitter/X. You can read more about Bootstrap here:
    [https://getbootstrap.com/](https://getbootstrap.com/).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它是由Twitter/X创建的，用于Twitter/X。你可以在[https://getbootstrap.com/](https://getbootstrap.com/)了解更多关于Bootstrap的信息。
- en: The `@inherits` directive inherits from `LayoutComponentBase`, which contains
    all the code to use a layout. `@Body` is where the component will be rendered
    (when viewed as a page).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`@inherits`指令从`LayoutComponentBase`继承，其中包含使用布局所需的所有代码。`@Body`是组件将被渲染的位置（当作为页面查看时）。'
- en: It also contains the default error UI for Blazor.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含Blazor的默认错误UI。
- en: 'At the top of the layout, you can see `<NavMenu>`, a Razor component. It is
    located in the `Components/Layout` folder and looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局的顶部，你可以看到`<NavMenu>`，一个Razor组件。它位于`Components/Layout`文件夹中，看起来像这样：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It contains the left-side menu and is a standard Bootstrap menu. It also has
    three menu items and logic for a hamburger menu (if viewed on a phone). This type
    of nav menu is usually done with JavaScript, but this one is done solely with
    CSS and C#.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含左侧菜单，是一个标准的Bootstrap菜单。它还具有三个菜单项和汉堡菜单的逻辑（如果是在手机上查看）。这种导航菜单通常是用JavaScript完成的，但这个是用CSS和C#完成的。
- en: You will find another component, `NavLink`, which is built into the framework.
    It will render an anchor tag but will also check the current route. If you are
    currently on the same route/URL as the nav link, it will automatically add a CSS
    class called `active` to the tag.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现另一个组件，`NavLink`，它是框架内建的。它将渲染一个锚点标签，但也会检查当前路由。如果你当前位于与导航链接相同的路由/URL上，它将自动向标签添加一个名为`active`的CSS类。
- en: We will run into a couple more built-in components that will help us along the
    way. There are also some pages in the template, but we will leave them for now
    and go through them in the next chapter when we go into components.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遇到一些内置的组件，这些组件将帮助我们前进。模板中也有一些页面，但现在我们将暂时忽略它们，并在下一章中介绍组件时再进行讨论。
- en: CSS
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS
- en: 'In the `Components/Layout` folder, there are two CSS files: : `NavMenu.razor.css`
    and `MainLayout.razor.css`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Components/Layout`文件夹中，有两个CSS文件：`NavMenu.razor.css`和`MainLayout.razor.css`。
- en: These files are CSS styles that affect only the specific component (the first
    part of the name). We will return to a concept called isolated CSS in *Chapter
    9*, *Sharing Code and Resources*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是仅影响特定组件（名称的第一部分）的CSS样式。我们将在第9章中返回一个称为隔离CSS的概念，*共享代码和资源*。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got the development environment up and running, and we created
    our first Blazor app. We learned in what order classes, components, and layouts
    are called, making it easier to follow the code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功搭建了开发环境，并创建了我们的第一个Blazor应用程序。我们学习了类、组件和布局的调用顺序，这使得跟踪代码变得更加容易。
- en: In the next chapter, we will take a break from Blazor to look at managing state
    and set up a repository to store our blog posts.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从Blazor中暂时休息一下，看看如何管理状态，并设置一个存储我们的博客文章的仓库。
