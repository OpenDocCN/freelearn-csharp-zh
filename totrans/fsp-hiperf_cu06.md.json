["```cs\nopen System \nopen System.Data \nopen System.Data.Linq \nopen Microsoft.FSharp.Data.TypeProviders \nopen Microsoft.FSharp.Linq \n\ntype NorthwindSchema = SqlDataConnection<\"Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=Northwind;Data Source=localhost\"> \nlet nwdb = NorthwindShema.GetDataContext() \n\n```", "```cs\nlet customer = nwdb.Customers \n\n```", "```cs\nlet customer = nwdb.Customers \nlet customerNameData =  \n    query { for c in customer do \n            select c.ContactName } \n\nlet displayAllCustomerName () = \n    for c in customerNameData do \n        Console.WriteLine(c) \n    () \n\n```", "```cs\n[<EntryPoint>] \nlet main argv =  \n    //printfn \"%A\" argv \n    SampleFSharpData.displayAllCustomerName()  \n    0 // return an integer exit code \n\n```", "```cs\nlet displayCustomerNameStartsWith prefix = \n    let customerStartWith = \n        query { for c in customer do  \n                where (c.ContactName.StartsWith(prefix)) \n                sortBy c.ContactName \n                select c.ContactName} \n    for c in customerStartWith do \n        Console.WriteLine(c) \n    () \n\n```", "```cs\n    class Program \n    { \n        static void Main(string[] args) \n        { \n            SampleFSharpData.displayCsutomerNameStartsWith(\"Maria\"); \n        } \n    } \n\n```", "```cs\n        var customerData = from cust in SampleFSharpData.nwdb.Customers \n                           orderby cust.ContactName \n                           select cust; \n        foreach (var item in customerData) \n        { \n            Console.WriteLine(\"Customer name = \" + item.ContactName + \"; Company =\" + item.CompanyName); \n        } \n\n```", "```cs\ntype NorthwindSchema = SqlDataConnection<\"Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=Northwind;Data Source=localhost\"> \n\n```", "```cs\n/// A base type providing default implementations of type provider functionality when all provided  \n/// types are of type ProvidedTypeDefinition. \ntype TypeProviderForNamespaces = \n\n    /// Initializes a type provider to provide the types in the given namespace. \n    new : namespaceName:string * types: ProvidedTypeDefinition list -> TypeProviderForNamespaces \n\n    /// Initializes a type provider  \n    new : unit -> TypeProviderForNamespaces \n\n    /// Invoked by the type provider to add a namespace of provided types in the specification of the type provider. \n    member AddNamespace : namespaceName:string * types: ProvidedTypeDefinition list -> unit \n\n    /// Invoked by the type provider to get all provided namespaces with their provided types. \n    member Namespaces : seq<string * ProvidedTypeDefinition list>  \n\n    /// Invoked by the type provider to invalidate the information provided by the provider \n    member Invalidate : unit -> unit \n\n    /// Invoked by the host of the type provider to get the static parameters for a method. \n    member GetStaticParametersForMethod : MethodBase -> ParameterInfo[] \n\n    /// Invoked by the host of the type provider to apply the static argumetns for a method. \n    member ApplyStaticArgumentsForMethod : MethodBase * string * obj[] -> MethodBase  \n\n    /// AssemblyResolve handler. Default implementation searches <assemblyname>.dll file in registered folders  \n    abstract ResolveAssembly : ResolveEventArgs -> Assembly \n    default ResolveAssembly : ResolveEventArgs -> Assembly \n\n    /// Registers custom probing path that can be used for probing assemblies \n    member RegisterProbingFolder : folder: string -> unit \n\n    /// Registers location of RuntimeAssembly (from TypeProviderConfig) as probing folder \n    member RegisterRuntimeAssemblyLocationAsProbingFolder : config: TypeProviderConfig -> unit \n\n```", "```cs\n/// Initializes a type provider to provide the types in the given namespace. \nnew : namespaceName:string * types: ProvidedTypeDefinition list -> TypeProviderForNamespaces \n\n/// Initializes a type provider  \nnew : unit -> TypeProviderForNamespaces \n\n```", "```cs\nnew (namespaceName:string,types:list<ProvidedTypeDefinition>) = new TypeProviderForNamespaces([(namespaceName,types)]) \nnew () = new TypeProviderForNamespaces([]) \n\n```", "```cs\nmember this.Invalidate() = invalidateE.Trigger(this,EventArgs())  \n\n```", "```cs\ninterface ITypeProvider with \n\n```", "```cs\n        member __.GetInvokerExpression(methodBase, parameters) = \n            let rec getInvokerExpression (methodBase : MethodBase) parameters = \n                match methodBase with \n                | :? ProvidedMethod as m when (match methodBase.DeclaringType with :? ProvidedTypeDefinition as pt -> pt.IsErased | _ -> true) -> \n                    m.GetInvokeCodeInternal false parameters \n                    |> expand \n                | :? ProvidedConstructor as m when (match methodBase.DeclaringType with :? ProvidedTypeDefinition as pt -> pt.IsErased | _ -> true) ->  \n                    m.GetInvokeCodeInternal false parameters \n                    |> expand \n                // Otherwise, assume this is a generative assembly and just emit a call to the constructor or method \n                | :?  ConstructorInfo as cinfo ->   \n                    Expr.NewObjectUnchecked(cinfo, Array.toList parameters)  \n                | :? System.Reflection.MethodInfo as minfo ->   \n                    if minfo.IsStatic then  \n                        Expr.CallUnchecked(minfo, Array.toList parameters)  \n                    else \n                        Expr.CallUnchecked(parameters.[0], minfo, Array.toList parameters.[1..]) \n                | _ -> failwith (\"TypeProviderForNamespaces.GetInvokerExpression: not a ProvidedMethod/ProvidedConstructor/ConstructorInfo/MethodInfo, name=\" + methodBase.Name + \" class=\" + methodBase.GetType().FullName) \n            and expand expr =  \n                match expr with \n                | NewObject(ctor, args) -> getInvokerExpression ctor [| for arg in args -> expand arg|] \n                | Call(inst, mi, args) -> \n                    let args =  \n                        [| \n                            match inst with \n                            | Some inst -> yield expand inst \n                            | _ -> () \n                            yield! List.map expand args \n                        |] \n                    getInvokerExpression mi args \n                | ShapeCombinationUnchecked(shape, args) -> RebuildShapeCombinationUnchecked(shape, List.map expand args) \n                | ShapeVarUnchecked v -> Expr.Var v \n                | ShapeLambdaUnchecked(v, body) -> Expr.Lambda(v, expand body) \n            getInvokerExpression methodBase parameters \n\n```", "```cs\ntype ProvidedAssembly = \n    /// Create a provided generated assembly \n    new : assemblyFileName:string -> ProvidedAssembly \n\n    /// Emit the given provided type definitions as part of the assembly  \n    /// and adjust the 'Assembly' property of all provided type definitions to return that \n    /// assembly. \n    /// \n    /// The assembly is only emitted when the Assembly property on the root type is accessed for the first time. \n    /// The host F# compiler does this when processing a generative type declaration for the type. \n    member AddTypes : types : ProvidedTypeDefinition list -> unit \n\n    /// <summary> \n    /// Emit the given nested provided type definitions as part of the assembly. \n    /// and adjust the 'Assembly' property of all provided type definitions to return that \n    /// assembly. \n    /// </summary> \n    /// <param name=\"enclosingTypeNames\">A path of type names to wrap the generated types. The generated types are then generated as nested types.</param> \n    member AddNestedTypes : types : ProvidedTypeDefinition list * enclosingGeneratedTypeNames: string list -> unit \n\n    static member RegisterGenerated : fileName:string -> Assembly \n\n```", "```cs\ntype ProvidedAssembly(assemblyFileName: string) =  \n    let theTypes = ResizeArray<_>() \n    let assemblyGenerator = AssemblyGenerator(assemblyFileName) \n    let assemblyLazy =  \n        lazy  \n            assemblyGenerator.Generate(theTypes |> Seq.toList) \n            assemblyGenerator.Assembly \n    let theAssemblyBytesLazy =  \n      lazy \n        assemblyGenerator.GetFinalBytes() \n\n    do \n        GlobalProvidedAssemblyElementsTable.theTable.Add(assemblyGenerator.Assembly, theAssemblyBytesLazy) \n\n```", "```cs\ntype ProvidedParameter = \n    inherit ParameterInfo \n    new : parameterName: string * parameterType: Type * ?isOut:bool * ?optionalValue:obj -> ProvidedParameter \n    member IsParamArray : bool with get,set \n\n/// Represents a provided static parameter. \ntype ProvidedStaticParameter = \n    inherit ParameterInfo \n    new : parameterName: string * parameterType:Type * ?parameterDefaultValue:obj -> ProvidedStaticParameter \n\n    /// Add XML documentation information to this provided constructor \n    member AddXmlDoc            : xmlDoc: string -> unit     \n\n    /// Add XML documentation information to this provided constructor, where the computation of the documentation is delayed until necessary \n    member AddXmlDocDelayed   : xmlDocFunction: (unit -> string) -> unit    \n\n```", "```cs\ntype ProvidedConstructor =     \n    inherit ConstructorInfo \n\n    /// Create a new provided constructor. It is not initially associated with any specific provided type definition. \n    new : parameters: ProvidedParameter list -> ProvidedConstructor \n\n    /// Add a 'System.Obsolete' attribute to this provided constructor \n    member AddObsoleteAttribute : message: string * ?isError: bool -> unit     \n\n    member AddXmlDoc          : xmlDoc: string -> unit    \n\n    member AddXmlDocDelayed   : xmlDocFunction: (unit -> string) -> unit    \n\n    member AddXmlDocComputed   : xmlDocFunction: (unit -> string) -> unit    \n\n    member InvokeCode         : (Quotations.Expr list -> Quotations.Expr) with set \n\n    /// FSharp.Data addition: this method is used by Debug.fs \n    member internal GetInvokeCodeInternal : bool -> (Quotations.Expr [] -> Quotations.Expr) \n\n    /// Set the target and arguments of the base constructor call. Only used for generated types. \n    member BaseConstructorCall : (Quotations.Expr list -> ConstructorInfo * Quotations.Expr list) with set \n\n    member IsImplicitCtor : bool with get,set \n\n    member AddDefinitionLocation : line:int * column:int * filePath:string -> unit \n\n    member IsTypeInitializer : bool with get,set \n\n```", "```cs\ntype ProvidedMethod =  \n    inherit MethodInfo \n\n    /// Create a new provided method. It is not initially associated with any specific provided type definition. \n    new : methodName:string * parameters: ProvidedParameter list * returnType: Type -> ProvidedMethod \n\n    member AddObsoleteAttribute : message: string * ?isError: bool -> unit     \n\n    member AddXmlDoc            : xmlDoc: string -> unit     \n\n    member AddXmlDocDelayed   : xmlDocFunction: (unit -> string) -> unit    \n\n    /// Add XML documentation information to this provided constructor \n    member AddXmlDocComputed   : xmlDocFunction: (unit -> string) -> unit    \n\n    member AddMethodAttrs       : attributes:MethodAttributes -> unit \n\n    member SetMethodAttrs       : attributes:MethodAttributes -> unit \n\n    member IsStaticMethod       : bool with get, set \n\n    member InvokeCode         : (Quotations.Expr list -> Quotations.Expr) with set \n\n    /// FSharp.Data addition: this method is used by Debug.fs \n    member internal GetInvokeCodeInternal : bool -> (Quotations.Expr [] -> Quotations.Expr) \n\n    member AddDefinitionLocation : line:int * column:int * filePath:string -> unit \n\n    /// Add a custom attribute to the provided method definition. \n    member AddCustomAttribute : CustomAttributeData -> unit \n\n    member DefineStaticParameters     : parameters: ProvidedStaticParameter list * instantiationFunction: (string -> obj[] -> ProvidedMethod) -> unit \n\n```", "```cs\ntype ProvidedProperty = \n    inherit PropertyInfo \n\n    /// Create a new provided type. It is not initially associated with any specific provided type definition. \n    new  : propertyName: string * propertyType: Type * ?parameters:ProvidedParameter list -> ProvidedProperty \n\n    member AddObsoleteAttribute : message: string * ?isError: bool -> unit     \n\n    /// Add XML documentation information to this provided constructor \n    member AddXmlDoc            : xmlDoc: string -> unit     \n\n    member AddXmlDocDelayed   : xmlDocFunction: (unit -> string) -> unit    \n\n    member AddXmlDocComputed   : xmlDocFunction: (unit -> string) -> unit    \n\n    /// Get or set a flag indicating if the property is static. \n    /// FSharp.Data addition: the getter is used by Debug.fs \n    member IsStatic             : bool with get,set \n\n    /// Set the quotation used to compute the implementation of gets of this property. \n    member GetterCode           : (Quotations.Expr list -> Quotations.Expr) with set \n\n    /// Set the function used to compute the implementation of sets of this property. \n    member SetterCode           : (Quotations.Expr list -> Quotations.Expr) with set \n\n    /// Add definition location information to the provided type definition. \n    member AddDefinitionLocation : line:int * column:int * filePath:string -> unit \n\n    /// Add a custom attribute to the provided property definition. \n    member AddCustomAttribute : CustomAttributeData -> unit \n\n```", "```cs\noverride __.GetAccessors _nonPublic  = notRequired \"nonPublic\" propertyName \noverride __.GetGetMethod _nonPublic = if hasGetter() then getter.Force() :> MethodInfo else null \noverride __.GetSetMethod _nonPublic = if hasSetter() then setter.Force() :> MethodInfo else null \n\n```", "```cs\nmember __.GetInvokeCodeInternal isGenerated = \n    match invokeCode with \n    | Some f ->  \n        // FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs \n        let paramNames =  \n            parameters \n            |> List.map (fun p -> p.Name)  \n            |> List.append (if not isGenerated || isStatic() then [] else [\"this\"]) \n            |> Array.ofList \n        QuotationSimplifier(isGenerated).TranslateQuotationToCode f paramNames \n    | None -> failwith (sprintf \"ProvidedConstructor: no invoker for '%s'\" (nameText())) \n\n```", "```cs\nopen System \nopen System.Text \nopen System.IO \nopen System.Reflection \nopen System.Linq \nopen System.Linq.Expressions \nopen System.Collections.Generic \nopen Microsoft.FSharp.Quotations \nopen Microsoft.FSharp.Quotations.Patterns \nopen Microsoft.FSharp.Quotations.DerivedPatterns \nopen Microsoft.FSharp.Core.CompilerServices \n\n```", "```cs\n    member __.GetInvokeCodeInternal isGenerated = \n        match invokeCode with \n        | Some f ->  \n            // FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs \n            let parallelizedSeq = System.Linq.Enumerable.Select(Seq.ofList parameters, fun p -> p.Name).AsParallel() \n            let paramlist = List.ofSeq parallelizedSeq \n            let paramNames =  \n                paramlist \n                |> List.append (if isStatic() then [] else [\"this\"]) \n                |> Array.ofList \n            QuotationSimplifier(isGenerated).TranslateQuotationToCode f paramNames \n        | None -> failwith (sprintf \"ProvidedConstructor: no invoker for '%s'\" (nameText())) \n\n```", "```cs\nnamespace ProviderImplementation \n\nopen System.Reflection \nopen Microsoft.FSharp.Quotations \nopen Microsoft.FSharp.Core.CompilerServices \nopen ProviderImplementation.ProvidedTypes \n\n[<TypeProvider>] \ntype BasicProvider (config : TypeProviderConfig) as this = \n    inherit TypeProviderForNamespaces () \n\n    let ns = \"StaticProperty.Provided\" \n    let asm = Assembly.GetExecutingAssembly() \n    let ctxt = ProvidedTypesContext.Create(config) \n\n    let createTypes () = \n        let myType = ctxt.ProvidedTypeDefinition(asm, ns, \"MyType\", Some typeof<obj>) \n        let myProp = ctxt.ProvidedProperty(\"MyProperty\", typeof<string>, IsStatic = true, getterCode = (fun args -> <@@ \"Hello world\" @@>)) \n        myType.AddMember(myProp) \n        [myType] \n\n    do \n        this.AddNamespace(ns, createTypes()) \n\n[<assembly:TypeProviderAssembly>] \n    do () \n\n```"]