<html><head></head><body>
		<div><h1 id="_idParaDest-19"><em class="italic"><a id="_idTextAnchor020"/>Chapter <a id="_idTextAnchor021"/>1</em>: Designing and Architecting the Enterprise Application</h1>
			<p>Enterprise applications are software solutions designed to solve large and complex problems for enterprise organizations. They enable <em class="italic">Order-to-Fulfillment</em> capabilities for enterprise customers in the IT, government, education, and public sectors. They empower them to digitally transform their businesses with capabilities such as product purchasing, payment processing, automated billing, and customer management. When it comes to enterprise applications, the number of integrations is quite high, and the volume of users is also very high as, typically, applications are targeted at a global audience.</p>
			<p>To ensure that enterprise systems remain highly reliable, highly available, and highly performant, getting the design and architecture right is very important. Design and architecture form the foundation of any good software. They form the basis of the rest of the software development life cycle; therefore, it is very important to, first, get the right design to avoid any rework later, which could prove very expensive, depending on the changes required. So, you need a flexible, scalable, extensible, and maintainable design and architecture.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>A primer on common design principles and patterns</li>
				<li>Understanding common enterprise architectures</li>
				<li>Identifying enterprise application requirements (business and technical)</li>
				<li>Architecting an enterprise application</li>
				<li>Solution structuring for an enterprise application</li>
			</ul>
			<p>By the end of this chapter, you will be able to start designing and architecting enterprise applications.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor022"/>A primer on common design principles and patterns</h1>
			<p>Every piece of software in the world solves at least one real-world problem. As time goes by, things change, including what we expect from any specific software. To manage this change and <a id="_idIndexMarker000"/>deal with various aspects of software, engineers have developed several programming paradigms, frameworks, tools, techniques, processes, and principles. These principles and patterns, proven over time, have become guiding stars for engineers to build quality software. </p>
			<p>Principles are high-level abstract guidelines to be followed while designing. They are applicable regardless of the programming language being used. They do not provide implementation guidelines.</p>
			<p>Patterns are low-level <a id="_idIndexMarker001"/>specific implementation guidelines that are proven, reusable solutions for recurring problems. First, let's start with design principles.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor023"/>Design principles</h2>
			<p>Techniques become principles if they are widely accepted, practiced, and proven to be useful in any industry. Those principles become solutions to make software designs more understandable, flexible, and maintainable. In this section, we will cover the SOLID, KISS, and DRY design principles.</p>
			<h3>SOLID</h3>
			<p>The SOLID principles <a id="_idIndexMarker002"/>are a subset of the many principles promoted <a id="_idIndexMarker003"/>by an American software engineer and instructor, Robert C. Martin. These principles have become the de facto standard principles in the OOP world and have become part of the core philosophy for other methodologies and paradigms.</p>
			<p>SOLID is an acronym for the following five principles:</p>
			<ol>
				<li><strong class="bold">Single-responsibility principle</strong> (<strong class="bold">SRP</strong>): An entity or software module should only <a id="_idIndexMarker004"/>have a single responsibility. You should avoid granting multiple responsibilities to one entity. </li>
			</ol>
			<div><div><img src="img/Figure_1.1_B18507.jpg" alt="Figure 1.1 – SRP&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – SRP</p>
			<ol>
				<li value="2"><strong class="bold">Open-closed principle</strong> (<strong class="bold">OCP</strong>): Entities should be designed in such a way that they are <a id="_idIndexMarker005"/>open for extension but closed for modification. This means the regression testing of existing behaviors can be avoided; only extensions need to be tested.</li>
			</ol>
			<div><div><img src="img/Figure_1.2_B18507.jpg" alt="Figure 1.2 – OCP&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – OCP</p>
			<ol>
				<li value="3"><strong class="bold">Liskov substitution principle</strong> (<strong class="bold">LSP</strong>): Parent or base class instances should be <a id="_idIndexMarker006"/>replaceable with instances of their derived classes or subtypes without altering the sanity of the program.</li>
			</ol>
			<div><div><img src="img/Figure_1.3_B18507.jpg" alt="Figure 1.3 – LSP&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – LSP</p>
			<ol>
				<li value="4"><strong class="bold">Interface segregation principle</strong> (<strong class="bold">ISP</strong>): Instead of one common large interface, you <a id="_idIndexMarker007"/>should plan multiple, scenario-specific interfaces for better decoupling and change management:</li>
			</ol>
			<div><div><img src="img/Figure_1.4_B18507.jpg" alt="Figure 1.4 – ISP&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – ISP</p>
			<ol>
				<li value="5"><strong class="bold">Dependency inversion principle</strong> (<strong class="bold">DIP</strong>): You should avoid having any direct dependency <a id="_idIndexMarker008"/>on concrete implementations. High-level modules and low-level modules should not depend on each other directly. Instead, both should depend on abstractions as much as possible. Abstractions should not depend on details, and details should depend on abstractions.</li>
			</ol>
			<div><div><img src="img/Figure_1.5_B18507.jpg" alt="Figure 1.5 – DIP&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – DIP</p>
			<h3>Don't Repeat Yourself (DRY)</h3>
			<p>With DRY, a system should be designed in such a way that the implementation of a feature <a id="_idIndexMarker009"/>or a pattern should not be repeated in multiple places. This would result in maintenance overhead, as a change in requirements <a id="_idIndexMarker010"/>would result in modifications being needed at multiple places. If you fail to make a necessary update in one place by mistake, the behavior of the system will become inconsistent. Rather, the feature should be wrapped into a package and should be reused in all places. In the case of a database, you should look at using data normalization to reduce redundancy.</p>
			<div><div><img src="img/Figure_1.6_B18507.jpg" alt="Figure 1.6 – DRY&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – DRY</p>
			<p>This strategy helps in reducing redundancy and promoting reuse. This principle helps an organization's culture too, encouraging more collaboration.</p>
			<h3>Keep it simple, stupid (KISS) </h3>
			<p>With KISS, a <a id="_idIndexMarker011"/>system should be designed as simply as possible, avoiding complicated designs, algorithms, new untried <a id="_idIndexMarker012"/>technologies, and more. You should focus on leveraging the right OOP concepts and reusing proven patterns and principles. Include new or non-simple things only if it is necessary and adds value to the implementation.</p>
			<p>When you keep it simple, you will be able to do the following better:</p>
			<ul>
				<li>Avoid mistakes while designing/developing.</li>
				<li>Keep the train running (there is always a team whose job is to maintain the system, even though they are not the team that developed the system in the first place).</li>
				<li>Read and understand your system code (your system code needs to be understandable to people who are new to it or for people who will use it in the future).</li>
				<li>Do better and less error-prone change management.</li>
			</ul>
			<p>With this, we are done with our primer on common design principles; we have learned about SOLID, DRY, and KISS. In the next section, we'll look at some common design patterns in the context of real-world examples to help you understand the difference between principles and patterns and when to leverage which pattern—a skill that's essential for good design and architecture.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>Design patterns</h2>
			<p>While following <a id="_idIndexMarker013"/>design principles in the OOP paradigm, you might see the same structures and patterns repeating over and again. These repeating structures and techniques are proven solutions to common problems and are known as <strong class="bold">design patterns</strong>. Proven design patterns are easy to reuse, implement, change, and test. The well-known book, <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>, comprising <a id="_idIndexMarker014"/>what is known as the <strong class="bold">Gang of Four</strong> (<strong class="bold">GOF</strong>) design patterns, is considered the bible of patterns.</p>
			<p>We can categorize the GOF patterns as follows:</p>
			<ul>
				<li><strong class="bold">Creative</strong>: Helpful in creating objects</li>
				<li><strong class="bold">Structural</strong>: Helpful in dealing with the composition of objects</li>
				<li><strong class="bold">Behavioral</strong>: Helpful in defining the interactions between objects and distributing responsibility</li>
			</ul>
			<p>Let's look at these patterns with some real-life examples.</p>
			<h3>Creational design patterns</h3>
			<p>Let's take <a id="_idIndexMarker015"/>a look at some creational design <a id="_idIndexMarker016"/>patterns, along with relevant examples, in the following table:</p>
			<div><div><img src="img/Table_1.1.jpg" alt="Table 1.1 – Creational design patterns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.1 – Creational design patterns</p>
			<h3>Structural design patterns</h3>
			<p>The <a id="_idIndexMarker017"/>following <a id="_idIndexMarker018"/>table includes some examples of structural design patterns:</p>
			<div><div><img src="img/Table_1.2.jpg" alt="Table 1.2 – Structural design patterns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.2 – Structural design patterns</p>
			<h3>Behavioral design patterns</h3>
			<p>The <a id="_idIndexMarker019"/>following <a id="_idIndexMarker020"/>table includes some examples of behavioral design patterns:</p>
			<div><div><img src="img/Table_1.3.jpg" alt="Table 1.3 – Behavioral design patterns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.3 – Behavioral design patterns</p>
			<p>Sometimes, you can become overwhelmed by all these patterns being inside the table. But really, any design is a good design until it violates the basic principles. One rule of thumb that we can use is to <em class="italic">go back to the basics</em>, and in design, principles are the basics.</p>
			<div><div><img src="img/Figure_1.7_B18507.jpg" alt="Figure 1.7 – Patterns versus principles&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Patterns versus principles</p>
			<p>With this, we are done with our primer on common design principles and patterns. By now, you should have a good understanding of the different principles and patterns, where to use them, and what it takes to build a great solution. Now, let's spend some time looking at common enterprise architectures.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor025"/>Understanding common enterprise architectures</h1>
			<p>There are a few principles and architectures that are commonly practiced when designing <a id="_idIndexMarker021"/>enterprise applications. First and foremost, the goal of any architecture is to support business needs at the lowest cost possible (costs being time and resources). A business wants software to enable it rather than act as a bottleneck. In today's world, availability, reliability, and performance are the three KPIs of any system.</p>
			<p>In this section, first, we will look at the issues with monolithic architectures, and then we will see how to avoid them by using widely adopted and proven architectures for developing enterprise applications.</p>
			<p>Consider a classical monolithic e-commerce website application, such as the one shown in the following diagram, with all the business providers and functionality in a single app and data being stored in a classical SQL database:</p>
			<div><div><img src="img/Figure_1.8_B18507.jpg" alt="Figure 1.8 – A monolithic app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – A monolithic app</p>
			<p>The monolithic <a id="_idIndexMarker022"/>architecture was widely adopted 15–20 years ago, but plenty of problems arose for software engineering teams when systems grew and business needs expanded over time. Let's look at some of the common issues with this approach.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor026"/>Common issues with monolithic apps</h2>
			<p>Let's <a id="_idIndexMarker023"/>take a look at the scaling issues:</p>
			<ul>
				<li>In a monolithic app, the only way to horizontally scale is by adding more compute to the system. This leads to higher operational costs and unoptimized resource utilization. Sometimes, scaling becomes impossible due to conflicting needs in terms of resources.</li>
				<li>As all the features mostly use single storage, there is the possibility of locks leading to high latency, and there will also be physical limits as to how far a single storage instance can scale.</li>
			</ul>
			<p>Here is a list of issues associated with availability, reliability, and performance:</p>
			<ul>
				<li>Any changes in the system will require the redeployment of all components, leading to downtime and low availability.</li>
				<li>Any non-persistent state, such as sessions stored in a web app, will be lost after every deployment. This will lead to the abandonment of all workflows that were triggered by users.</li>
				<li>Any bugs in a module, such as memory leaks or security bugs, make all the modules vulnerable and have the potential to impact the whole system.</li>
				<li>Due to <a id="_idIndexMarker024"/>the highly coupled nature and sharing of resources within modules, there will always be unoptimized use of resources, leading to high latency in the system.</li>
			</ul>
			<p>Lastly, let's see what the impact on the business and engineering teams is:</p>
			<ul>
				<li>The impact of a change is difficult to quantify and requires extensive testing. Hence, it slows down the rate of delivery to production. Even a small change will require the entire system to be deployed again.</li>
				<li>In a single highly coupled system, there will always be physical limits on collaborations across teams to deliver any features.</li>
				<li>New scenarios such as mobile apps, chatbots, and analysis engines will take more effort as there are no independent reusable components or services.</li>
				<li>Continuous deployment is almost impossible.</li>
			</ul>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor027"/>Let's try to solve these common problems by adopting some proven principles/ architectures.</h2>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor028"/>Separation of concerns/single-responsibility architecture </h2>
			<p>Software should be divided into components or modules based on the kind of work it performs <a id="_idIndexMarker025"/>where every module <a id="_idIndexMarker026"/>or component owns a single responsibility from the entire software's responsibility. Interaction between components happens via interfaces or messaging systems. Let's look at the n-tier and microservices architecture and how the separation of concerns is taken care of.</p>
			<h3>N-tier architecture</h3>
			<p>N-tier <a id="_idIndexMarker027"/>architecture divides the application of a system into three (or n) tiers:</p>
			<ul>
				<li><strong class="bold">Presentation</strong> (known <a id="_idIndexMarker028"/>as the <a id="_idIndexMarker029"/>UX layer, the <a id="_idIndexMarker030"/>UI layer, or the work surface)</li>
				<li><strong class="bold">Business</strong> (known as <a id="_idIndexMarker031"/>the business <a id="_idIndexMarker032"/>rules layer or <a id="_idIndexMarker033"/>the services layer)</li>
				<li><strong class="bold">Data</strong> (known as <a id="_idIndexMarker034"/>the data <a id="_idIndexMarker035"/>storage and access layer)</li>
			</ul>
			<div><div><img src="img/Figure_1.9_B18507.jpg" alt="Figure 1.9 – N-tier architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – N-tier architecture</p>
			<p>These tiers can be owned/managed/deployed separately. For example, multiple presentation layers, such as the web, mobile, and bot layers, can leverage the same business and data tier.</p>
			<h3>Microservices architecture</h3>
			<p>Microservices <a id="_idIndexMarker036"/>architecture consists of small, loosely coupled, independent, and autonomous services. Let's see their benefits:</p>
			<ul>
				<li>Services can be deployed and scaled independently. An issue in one service will have a local <a id="_idIndexMarker037"/>impact and can be fixed by just deploying the impacted service. There is no compulsion to share technology or frameworks.</li>
				<li>Services communicate with each other via well-defined APIs or messaging systems such as the Azure service bus.</li>
			</ul>
			<div><div><img src="img/Figure_1.10_B18507.jpg" alt="Figure 1.10 – Microservices architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Microservices architecture</p>
			<p>As you can <a id="_idIndexMarker038"/>see in the preceding diagram, a service can be owned by independent teams and have its own cycle. Services are responsible for managing their own data stores. Scenarios demanding lower latency can be optimized by bringing in a cache or high-performance NoSQL stores.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor029"/>Stateless services architecture</h2>
			<p>Services should <a id="_idIndexMarker039"/>not have any state. State and data should <a id="_idIndexMarker040"/>be managed independently from services, that is, externally through a data store such as a distributed cache or a database. By delegating the state externally, services will have the resources to serve more requests with high reliability. The following diagram shows an example of stateful services on the left-hand side. Here, state is maintained in each service through an in-memory cache or session provider, whereas a stateless service, as shown on the right-hand side, manages state and data externally.</p>
			<div><div><img src="img/Figure_1.11_B18507.jpg" alt="Figure 1.11 – Stateful (left) versus stateless (right) &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Stateful (left) versus stateless (right) </p>
			<p>Session <a id="_idIndexMarker041"/>affinity should not be enabled as it leads to <a id="_idIndexMarker042"/>sticky session issues and will stop you from getting the benefits of load balancing, scalability, and the distribution of traffic.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor030"/>Event-driven architecture </h2>
			<p>The <a id="_idIndexMarker043"/>main features of event-driven <a id="_idIndexMarker044"/>architectures are listed as follows:</p>
			<ul>
				<li>In an <a id="_idIndexMarker045"/>event-driven architecture, communication, which is <a id="_idIndexMarker046"/>generally known as <strong class="bold">publisher-subscriber communication</strong>, between modules, is primarily asynchronous and achieved via events. Producers and consumers are totally decoupled from each other. The structure of the event is the only contract that is exchanged between them.</li>
				<li>There can be multiple consumers of the same event taking care of their specific operations; ideally, they won't even be aware of each other. Producers can continuously push events without worrying about the availability of consumers.</li>
				<li>Publishers <a id="_idIndexMarker047"/>publish events via a messaging infrastructure such as queues or a service bus. Once an event has been published, the messaging infrastructure is responsible for sending the event to eligible subscribers.</li>
			</ul>
			<div><div><img src="img/Figure_1.12_B18507.jpg" alt="Figure 1.12 – Event-driven architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Event-driven architecture</p>
			<p>This architecture is best suited for scenarios that are asynchronous in nature. For example, long-running operations can be queued for processing. A client might poll for status or even act as a subscriber for an event.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor031"/>Resiliency architecture</h2>
			<p>As the communication between components increases, so does the possibility of failures. A system <a id="_idIndexMarker048"/>should be designed to recover from any kind of failure. We will cover a few strategies for building a fault-tolerant system that can heal itself in the case of failures. </p>
			<p>If you are <a id="_idIndexMarker049"/>familiar with Azure, you'll know that applications, services, and data should be replicated globally in at least two Azure regions for planned downtime and unplanned transient or permanent failures, as shown in the following screenshot. In these scenarios, choosing Azure App Service to host web applications, using REST APIs, and choosing a globally distributed database <a id="_idIndexMarker050"/>service, such as Azure Cosmos DB, is wise. Choosing Azure paired regions will help in <strong class="bold">business continuity and disaster recovery</strong> (<strong class="bold">BCDR</strong>), as at least one region in each pair will be prioritized for recovery if an outage affects multiple regions. </p>
			<div><div><img src="img/Figure_1.13_B18507.jpg" alt="Figure 1.13 – Resiliency architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – Resiliency architecture</p>
			<p>Now, let's <a id="_idIndexMarker051"/>see how to tackle different types of faults.</p>
			<p>Transient faults <a id="_idIndexMarker052"/>can occur in any type of communication or service. You need to have a strategy to recover from transient faults, such as the following:</p>
			<ul>
				<li>Identify the operation and type of transient fault. Then, determine the appropriate retry count and interval.</li>
				<li>Avoid anti-patterns such as endless retry mechanisms with a finite number of retries or circuit breakers.</li>
			</ul>
			<p>If a failure is not transient, you should respond to the failure gracefully by choosing some of the following options:</p>
			<ul>
				<li>Failing over</li>
				<li>Compensating for any failed operations</li>
				<li>Throttling/blocking the bad client/actor</li>
				<li>Using a leader election to select a leader in the case of a failure</li>
			</ul>
			<p>Here, telemetry <a id="_idIndexMarker053"/>plays a big role; you should have custom metrics to keep a tab on the health of any component. Alerts can be raised when a custom event occurs or a specific metric reaches a certain threshold.</p>
			<p>With this, we are done with our coverage of common enterprise architectures. Next, we will look at the requirements of enterprise applications and their different architectures through the lens of the design principles and common architectures that we learned about earlier.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor032"/>Identifying enterprise application requirements (business and technical)</h1>
			<p>In the next few chapters, we will build a working e-commerce application. It will be a three-tier <a id="_idIndexMarker054"/>application consisting of a UI layer, a service layer, and a database. Let's look at the requirements for this e-commerce application.</p>
			<p>The solution requirements are the capabilities to be implemented and made available in the product to solve a problem or achieve an objective.</p>
			<p>The business requirements are simply the end customer's needs. In the IT world, <em class="italic">business, generally, refers to customers</em>. These requirements are collected from various stakeholders and documented as a single source of truth for everyone's preference. Eventually, this becomes the backlog and scope of work to be completed.</p>
			<p>The technical requirements are the technology-related aspects that a system should implement, such <a id="_idIndexMarker055"/>as reliability, availability, performance, and BCDR. These are also known as <strong class="bold">quality-of-service</strong> (<strong class="bold">QoS</strong>) requirements.</p>
			<p>Let's break the typical business requirements for an e-commerce application site down into the following cat<a id="_idTextAnchor033"/>egories: <strong class="bold">Epic</strong>, <strong class="bold">Feature</strong>, and <strong class="bold">User Story</strong>.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor034"/>The application's business requirements</h2>
			<p>The following screenshot, from Azure DevOps, shows a summary of the backlog of our business <a id="_idIndexMarker056"/>requirements. You can see the different features that are expected in our application along with the user stories.</p>
			<div><div><img src="img/Figure_1.14_B18507.jpg" alt="Figure 1.14 – Requirement backlog from Azure DevOps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14 – Requirement backlog from Azure DevOps</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor035"/>The application's technical requirements</h2>
			<p>Having <a id="_idIndexMarker057"/>seen the business requirements, let's now go through the technical requirements:</p>
			<ul>
				<li>The e-commerce application should be <strong class="bold">highly available</strong>, that is, available for 99.99% of the time during any 24-hour period.</li>
				<li>The e-commerce application should be <strong class="bold">highly reliable</strong>, that is, reliable for 99.99% of the time during any 24-hour period.</li>
				<li>The e-commerce application should be <strong class="bold">highly performant</strong>, that is, 95% of operations should take less than or be equal to 3 seconds during any 24-hour period.</li>
				<li>The e-commerce application should be <strong class="bold">highly scalable</strong>: It should automatically scale up/down based on the varying load.</li>
				<li>The e-commerce application should have <strong class="bold">monitoring and alerts</strong>: An alert should be sent to a support engineer in the case of any system failures.</li>
			</ul>
			<p>Here are the <strong class="bold">technical aspects</strong> and requirements that have been identified for the e-commerce application:</p>
			<h3>The frontend</h3>
			<ul>
				<li>A web <a id="_idIndexMarker058"/>application (e-commerce) using ASP.Net 6.0</li>
			</ul>
			<h3>The core components</h3>
			<ul>
				<li>Logging/caching/configuration <a id="_idIndexMarker059"/>in C# 10.0 and .Net 6.0</li>
			</ul>
			<h3>The middle tier</h3>
			<ul>
				<li>An Azure <a id="_idIndexMarker060"/>API gateway to implement authentication</li>
				<li>A user management service through an ASP.NET 6.0 web API to add/remove users</li>
				<li>Product and pricing services through an ASP.NET 6.0 web API to get products from the data store</li>
				<li>A domain data service through an ASP.NET 6.0 web API to get the domain data, such as country data</li>
				<li>A payment service through an ASP.NET 6.0 web API to complete payments</li>
				<li>An order <a id="_idIndexMarker061"/>processing service through an ASP.NET 6.0 web API to submit and search orders</li>
				<li>An invoice processing service through an ASP.NET 6.0 web API to generate invoices</li>
				<li>A notification service through an ASP.NET 6.0 web API to send notifications such as emails</li>
			</ul>
			<h3>The data tier</h3>
			<ul>
				<li>A data <a id="_idIndexMarker062"/>access service through an ASP.NET 6.0 web API to talk to Azure Cosmos DB to read/write data</li>
				<li>Entity Framework Core to access data</li>
			</ul>
			<h3>Azure Stack</h3>
			<ul>
				<li>Azure <a id="_idIndexMarker063"/>Cosmos DB as a backend data store</li>
				<li>Azure Service Bus for asynchronous message processing</li>
				<li>Azure App Service to host the web application and web APIs</li>
				<li>Azure Traffic Manager for high availability and responsiveness</li>
				<li>Azure Application Insights for diagnostics and telemetry</li>
				<li>Azure <a id="_idIndexMarker064"/>paired regions for better resiliency</li>
				<li>Azure resource <a id="_idIndexMarker065"/>groups to create <strong class="bold">Azure Resource Manager</strong> (<strong class="bold">ARM</strong>) templates and deploy them to the Azure subscription</li>
				<li>Azure <a id="_idIndexMarker066"/>Pipelines for <strong class="bold">continuous integration and continuous deployment </strong>(<strong class="bold">CI/CD</strong>)</li>
			</ul>
			<p>We are now done with the requirements of the enterprise application. Next, we will look at how to architect an enterprise application.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor036"/>Architecting an enterprise application</h1>
			<p>The following <a id="_idIndexMarker067"/>architectural diagram depicts what we are building. We need to bear in mind all of the design principles, patterns, and requirements that we have seen in this chapter when we are architecting and developing the application. The following diagram shows the proposed architecture for our e-commerce enterprise application:</p>
			<div><div><img src="img/Figure_1.15_B18507.jpg" alt="Figure 1.15 – The e-commerce application's three-tier architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15 – The e-commerce application's three-tier architecture</p>
			<p><strong class="bold">Separation of concerns/SRP</strong> has been taken care of at each tier. The presentation tier, containing <a id="_idIndexMarker068"/>the UI, is separated from the services tier containing the business logic. This is again separated from the data access tier containing the data store.</p>
			<p>The high-level components are unaware of the low-level components consuming them. The data access tier is unaware of the services consuming it, and the services are unaware of the UX tier consuming them.</p>
			<p>Each service is separated based on the business logic and functionality it is supposed to perform.</p>
			<p><strong class="bold">Encapsulation</strong> has been <a id="_idIndexMarker069"/>taken care of at the architecture level and should be taken care of during development, too. Each component in the architecture will be interacting with other components through well-defined interfaces and contracts. We should be able to replace any component in the diagram without having to worry about its internal implementation and whether it adheres to the contracts.</p>
			<p>The loosely coupled architecture here also helps with faster development and faster deployment to the market for customers. Multiple teams can work, in parallel, on each of their components independently. They share the contracts and timelines for integration testing at the start, and once the internal implementation and unit tests are done, they can start with integration testing.</p>
			<p>Refer to the following diagram:</p>
			<div><div><img src="img/Figure_1.16_B18507.jpg" alt="Figure 1.16 – The eCommerce application's three-tier architecture with highlighted chapters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16 – The eCommerce application's three-tier architecture with highlighted chapters</p>
			<p>From the <a id="_idIndexMarker070"/>preceding diagram, we can identify the chapters in which different parts of the e-commerce application that we will build will be covered. They can be explained as follows:</p>
			<ul>
				<li>Creating an ASP.NET web application (our e-commerce portal) will be covered in <a href="B18507_11_Epub.xhtml#_idTextAnchor1228"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web Application</em>.</li>
				<li>Authentication will be covered in <a href="B18507_12_Epub.xhtml#_idTextAnchor1389"><em class="italic">Chapter 12</em></a>, <em class="italic">Understanding Authentication</em>.</li>
				<li>The order processing service and the invoice processing service are the two core services for generating orders and invoicing. They will be the heart of the e-commerce application as they are the ones that are responsible for the revenue. Creating an ASP.NET Core web API will be covered in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>,<em class="italic"> Creating an ASP.NET Core 6 Web API</em>, and cross-cutting concerns will be covered in <a href="B18507_05_Epub.xhtml#_idTextAnchor445"><em class="italic">Chapter 5</em></a>, <em class="italic">Dependency Injection in .NET 6</em>, <a href="B18507_06_Epub.xhtml#_idTextAnchor473"><em class="italic">Chapter 6</em></a>,<em class="italic"> Configuration in .NET 6</em>, and <a href="B18507_07_Epub.xhtml#_idTextAnchor596"><em class="italic">Chapter 7</em></a>, <em class="italic">Logging in .NET 6</em>, respectively. The DRY principle will be taken care of by reusing core components and cross-cutting concerns instead of repeating implementations.</li>
				<li>Caching will be covered as part of the product pricing service in <a href="B18507_08_Epub.xhtml#_idTextAnchor714"><em class="italic">Chapter 8</em></a>,<em class="italic"> All You Need to Know about Caching</em>. Caching will help us to improve the performance and scalability of our system, with temporary copies of frequently accessed data being available in memory.</li>
				<li>Data storage, access, and the number of providers will be covered as part of the data access layer in <a href="B18507_09_Epub.xhtml#_idTextAnchor860"><em class="italic">Chapter 9</em></a>, <em class="italic">Working with Data in .NET 6</em>. The kind of architecture that we have adopted, where data and access to it are separate from the rest of the application, gives us better maintenance. Azure Cosmos DB is our choice to scale throughput and storage elastically and independently across any number of Azure regions worldwide. Additionally, it is secure by default and enterprise-ready.</li>
			</ul>
			<p>This concludes our discussion on architecting our enterprise application. Next, we will look at the solution structure for our enterprise application.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor037"/>Solution structuring of the application</h1>
			<p>To keep things simple, we will go with a single solution for all our projects, as shown in the following <a id="_idIndexMarker071"/>screenshot. The other approach of having separate solutions for the UI, shared components, and web APIs can also be considered when the number of projects in the solution explodes and causes maintenance issues. The following screenshot shows our application's solution structure:</p>
			<div><div><img src="img/Figure_1.17_B18507.jpg" alt="Figure 1.17 – The solution structure of the e-commerce application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17 – The solution structure of the e-commerce application</p>
			<p>Here, we have adopted separation of concerns by having separate folder structures and projects for UX, Service, Data, Core, and Testing.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor038"/>Summary</h1>
			<p>In this chapter, we learned about common design principles such as SOLID, DRY, and KISS. Also, we looked at various design patterns with real-world examples. Then, we looked at different enterprise architectures, identified the requirements for the e-commerce application that we are going to build, and applied what we learned to architect our e-commerce application. You can now apply what you have learned here when you design any application. </p>
			<p>In the next chapter, we will learn about .NET 6 Core and Standard.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor039"/>Questions</h1>
			<ol>
				<li value="1">What is the LSP?</li>
			</ol>
			<p>a. Base class instances should be replaceable with instances of their derived type.</p>
			<p>b. Derived class instances should be replaceable with instances of their base type.</p>
			<p>c. Designing for generics that can work with any data type.</p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="2">What is SRP?</li>
			</ol>
			<p>a. Instead of one common large interface, plan for multiple scenario-specific interfaces for better decoupling and change management.</p>
			<p>b. You should avoid taking a direct dependency approach on concrete implementation. Instead, you should depend on abstractions as much as possible.</p>
			<p>c. An entity should only have a single responsibility. You should avoid empowering one entity with multiple responsibilities.</p>
			<p>d. Entities should be designed in such a way that they should be open for extension but closed for modification.</p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="3">What is OCP?</li>
			</ol>
			<p>a. Entities should be open to modification but closed for extension.</p>
			<p>b. Entities should be open to extension but closed for modification.</p>
			<p>c. Entities should be open to composition but closed for extension.</p>
			<p>d. Entities should be open to abstraction but closed for inheritance.</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="4">Which pattern is used to make two incompatible interfaces work together? </li>
			</ol>
			<p>a. Proxy</p>
			<p>b. Bridge</p>
			<p>c. Iterator</p>
			<p>d. Adapter</p>
			<p><strong class="bold">Answer: d</strong></p>
			<ol>
				<li value="5">Which principle ensures that services can be deployed and scaled independently and that an issue in one service will have a local impact, which can be fixed by just redeploying the impacted service?</li>
			</ol>
			<p>a. The domain-driven design principle</p>
			<p>b. The single-responsibility principle</p>
			<p>c. The stateless service principle</p>
			<p>d. The resiliency principle</p>
			<p><strong class="bold">Answer: b</strong></p>
		</div>
	</body></html>