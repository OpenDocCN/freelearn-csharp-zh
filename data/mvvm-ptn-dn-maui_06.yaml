- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Working with Collections
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与集合一起工作
- en: Collections are a fundamental part of nearly every application, allowing us
    to manage and organize groups of related objects. In this chapter, we’ll explore
    the power of collections in the context of the MVVM design pattern, offering you
    the tools and knowledge to efficiently work with data in your .NET MAUI applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 集合几乎是每个应用程序的基本组成部分，使我们能够管理和组织相关对象的组。在本章中，我们将探讨在 MVVM 设计模式背景下集合的力量，为您提供在 .NET
    MAUI 应用程序中高效处理数据的工具和知识。
- en: Up until now, our focus has primarily been on binding single values, such as
    titles, ratings, and commands. However, with the introduction of collections,
    we can take our applications to the next level. Collections empower us to represent
    groups of items, whether it be a collection of recipes, lists of ingredients,
    or arrays of user ratings. By harnessing the capabilities of collections, we can
    create dynamic, data-driven UIs that provide enhanced user experiences.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的主要关注点一直是绑定单个值，例如标题、评分和命令。然而，随着集合的引入，我们可以将我们的应用程序提升到新的水平。集合使我们能够表示项目组，无论是食谱集合、成分列表还是用户评分数组。通过利用集合的能力，我们可以创建动态、数据驱动的
    UI，提供增强的用户体验。
- en: 'This chapter is structured into three key sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为三个关键部分：
- en: Using `BindableLayout`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `BindableLayout`
- en: The `ICollectionChanged` interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ICollectionChanged` 接口'
- en: Working with `CollectionView`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `CollectionView` 一起工作
- en: By the end of this chapter, you will have a strong understanding of working
    with collections in .NET MAUI, significantly expanding your capabilities in building
    rich, data-centric applications such as our *Recipes!* app. Let’s dive in!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对在 .NET MAUI 中使用集合有深入的理解，这将显著扩展您构建丰富、以数据为中心的应用程序（如我们的 *Recipes!* 应用程序）的能力。让我们深入探讨吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Throughout this chapter, we will be enhancing the functionality of the *Recipes!*
    app. The code base for this chapter and all the assets, including the additional
    classes and code required to cover the topics in this chapter effectively, can
    be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06).
    The starting point for this chapter is provided in the `Start` folder, which includes
    the necessary classes and code that have been added specifically for this chapter.
    The code in the `Start` folder serves as the starting point to follow along with
    this chapter’s content, building upon the foundation we established in the previous
    chapters. The completed code, which includes all the code we have written throughout
    this chapter, can be found in the `Finish` folder for reference and comparison.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将增强 *Recipes!* 应用程序的功能。本章的代码库以及所有资产，包括为有效覆盖本章主题所需的额外类和代码，可以在 GitHub 上找到：[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06)。本章的起点在
    `Start` 文件夹中提供，其中包含为本章特别添加的必要类和代码。`Start` 文件夹中的代码是跟随本章内容的基础，建立在之前章节中建立的基础上。本章完成后的代码，包括我们本章中编写的所有代码，可以在
    `Finish` 文件夹中找到，供参考和比较。
- en: Using BindableLayout
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BindableLayout
- en: The `BindableLayout` class is a static class that provides *attached properties*
    for binding collections to layout containers. An attached property is a concept
    that allows you to attach additional properties to existing elements or controls.
    These properties are not defined within the element itself but are provided by
    an external class. They enable you to extend the behavior and functionality of
    elements without modifying their underlying code. `Grid.Row` is probably one of
    the most commonly used attached properties in .NET MAUI. It can be applied to
    any UI element, allowing you to define the row position within a `Grid` layout.
    It is not a property of the UI element itself; instead, it is an attached property
    that enhances the flexibility and power of the `Grid` layout. As such, `BindableLayout`
    provides a set of attached properties that can be used to bind collections of
    data to layout containers, such as `VerticalStackLayout` or `Grid`. You can leverage
    its attached properties to effortlessly bind and display dynamic collections of
    data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindableLayout` 类是一个静态类，它为将集合绑定到布局容器提供了 *附加属性*。附加属性是一个概念，允许您将额外的属性附加到现有元素或控件上。这些属性不是在元素本身中定义的，而是由外部类提供的。它们使您能够在不修改其底层代码的情况下扩展元素的行为和功能。`.NET
    MAUI` 中最常用的附加属性之一可能是 `Grid.Row`。它可以应用于任何 UI 元素，允许您在 `Grid` 布局中定义行位置。它不是 UI 元素本身的属性；相反，它是一个增强
    `Grid` 布局灵活性和强大功能的附加属性。因此，`BindableLayout` 提供了一组附加属性，可用于将数据集合绑定到布局容器，例如 `VerticalStackLayout`
    或 `Grid`。您可以利用其附加属性轻松绑定并显示动态数据集合。'
- en: Although the `BindableLayout` class’s attached properties can be added to any
    layout that derives from the `Layout` class, it is commonly used with layouts
    such as `VerticalStackLayout` and `HorizontalStackLayout`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以将 `BindableLayout` 类的附加属性添加到任何继承自 `Layout` 类的布局中，但它通常与 `VerticalStackLayout`
    和 `HorizontalStackLayout` 等布局一起使用。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`BindableLayout` is a lightweight and straightforward solution for displaying
    collections of data. It works great for scenarios with a limited number of items,
    offering simplicity and ease of use.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindableLayout` 是显示数据集合的一个轻量级且直接的方法。它非常适合项目数量有限的情况，提供了简单性和易用性。'
- en: However, it’s important to consider that `BindableLayout` generates UI elements
    for each item in the collection without built-in features such as virtualization
    or view recycling. This means that for large collections with many items, there
    may be performance implications and increased memory usage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要考虑，`BindableLayout` 在没有内置功能如虚拟化或视图回收的情况下为集合中的每个项目生成 UI 元素。这意味着对于包含许多项目的大型集合，可能会有性能影响和内存使用增加。
- en: Let’s have a look at how we can use `BindableLayout` to show a collection of
    data inside a `VerticalStackLayout`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用 `BindableLayout` 在 `VerticalStackLayout` 内部显示数据集合。
- en: What to show and how to show it
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示什么以及如何显示
- en: Two essential attached properties of `BindableLayout` are `ItemsSource` and
    `ItemTemplate`. These two properties play a crucial role in defining what collection
    of data needs to be shown and how each data item should be visualized. The `ItemsSource`
    property is used to bind a collection of data, while the `ItemTemplate` property
    is used to define the `DataTemplate` for each item in the collection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindableLayout` 的两个基本附加属性是 `ItemsSource` 和 `ItemTemplate`。这两个属性在定义需要显示哪些数据集合以及如何可视化每个数据项方面起着至关重要的作用。`ItemsSource`
    属性用于绑定数据集合，而 `ItemTemplate` 属性用于定义集合中每个项目的 `DataTemplate`。'
- en: Since a recipe is nothing without its list of ingredients, in the first example,
    we are going to display the list of ingredients on `RecipeDetailPage`. However,
    before we dive into how to effectively use `BindableLayout`, let’s first discuss
    `RecipeIngredientViewModel`, which is used to hold the information of ingredients.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个食谱如果没有其配料列表就什么都不是，在第一个例子中，我们将在 `RecipeDetailPage` 上显示配料列表。然而，在我们深入探讨如何有效使用
    `BindableLayout` 之前，让我们首先讨论 `RecipeIngredientViewModel`，它用于存储配料的信息。
- en: Defining ingredients
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义配料
- en: The `RecipeIngredientViewModel` class represents an ingredient within a recipe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecipeIngredientViewModel` 类表示食谱中的一个配料。'
- en: 'It contains the name of the ingredient and information about the required quantity
    of the ingredient for a specific number of servings. The purpose of the `DisplayAmount`
    property is to dynamically adjust and display the appropriate quantity of ingredients
    for the desired number of servings. It allows the user to see the adjusted amount
    that aligns with their selected serving size, providing accurate ingredient measurements
    for their recipe preparation. Let’s have a look at its `UpdateServings` method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含成分的名称和关于特定份数所需成分数量的信息。`DisplayAmount`属性的目的在于动态调整并显示所需份数的适当数量的成分。它允许用户看到与所选份量相匹配的调整后的数量，为他们的食谱准备提供准确的成分测量。让我们看看它的`UpdateServings`方法：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method updates the `DisplayAmount` property based on the desired number
    of servings, allowing the user to see the appropriate quantity of the ingredient
    for their selected serving size. As the setter of the `DisplayAmount` property
    calls the `PropertyChanged` event when its value changes, we can bind this property
    to a UI element in our view to dynamically display the adjusted ingredient amount
    based on the selected number of servings.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法根据期望的份量更新`DisplayAmount`属性，使用户能够看到所选份量中成分的适当数量。由于`DisplayAmount`属性的setter在值变化时调用`PropertyChanged`事件，我们可以将此属性绑定到视图中的UI元素，以根据所选的份量动态显示调整后的成分数量。
- en: 'We can extend `IngredientsListViewModel` with an additional property: `Ingredients`.
    This property is a list of `RecipeIngredientViewModel` objects that, for demo
    purposes, is assigned a hard-coded list of ingredients needed for making a Caesar
    salad.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展`IngredientsListViewModel`以添加一个额外的属性：`Ingredients`。这个属性是一个`RecipeIngredientViewModel`对象的列表，为了演示目的，它被分配了一个硬编码的成分列表，这些成分是制作凯撒沙拉所需的。
- en: 'Finally, the `NumberOfServings` property is updated. The following code block
    shows how the `UpdateServings` method on each of the ingredients is called when
    the value of the `NumberOfServings` property is changed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新了`NumberOfServings`属性。以下代码块展示了当`NumberOfServings`属性的值发生变化时，如何调用每个成分上的`UpdateServings`方法：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When updating `NumberOfServings`, the `DisplayAmount` property of each ingredient
    is updated as well, by calling the `UpdateServings` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新`NumberOfServings`时，通过调用`UpdateServings`方法，每个成分的`DisplayAmount`属性也会更新。
- en: With all of this in place, we can finally move over to XAML and see how we can
    bind this collection of `RecipeIngredientViewModels` to a `VerticalStackLayout`
    while using the attached properties of `BindableLayout`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪后，我们最终可以转向XAML，看看我们如何将这个`RecipeIngredientViewModels`集合绑定到一个`VerticalStackLayout`上，同时使用`BindableLayout`的附加属性。
- en: Showing ingredients on the screen
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在屏幕上显示成分
- en: 'In the following steps, we’ll go through the process of setting up the XAML
    code to display the ingredients in a visually appealing manner. Note that everything
    we are about to do in XAML can also be done in code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将通过设置XAML代码来以视觉上吸引人的方式显示成分。请注意，我们将在XAML中执行的所有操作也可以在代码中完成：
- en: 'On `RecipeDetailPage`, right below the `HorizontalStackLayout`, which holds
    the `Stepper` property that controls the number of servings, we can add a new
    `VerticalStackLayout`. As shown in the following code block, we can use the `ItemsSource`
    property of the `BindableLayout` class to bind to the list of ingredients:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RecipeDetailPage`上，在包含控制份量的`Stepper`属性的`HorizontalStackLayout`下方，我们可以添加一个新的`VerticalStackLayout`。如下面的代码块所示，我们可以使用`BindableLayout`类的`ItemsSource`属性来绑定到成分列表：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we need to define the UI elements that need to be rendered for each of
    the items in the bound collection. We can define this using the `ItemTemplate`
    property. This property needs a value of the `DataTemplate` class. It can be defined
    like this:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义需要渲染的UI元素，这些元素对应于绑定集合中的每个项目。我们可以使用`ItemTemplate`属性来定义这一点。这个属性需要一个`DataTemplate`类的值。它可以这样定义：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that on a `DataTemplate`, we can define `x:DataType` if we want to leverage
    compiled bindings, as we saw in [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069),
    *Data Binding in .**NET MAUI*.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在`DataTemplate`中，如果我们想利用编译绑定，就像我们在[*第4章*](B20941_04.xhtml#_idTextAnchor069)中看到的，*在.NET
    MAUI中的数据绑定*，我们可以定义`x:DataType`。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s very important to realize that the `BindingContext` of a `DataTemplate`
    is set to an individual item of the bound collection. Because the template is
    repeated for each item in the collection, UI elements named with `x:Name` in `DataTemplate`
    are inaccessible in the code behind. Their name is confined to that template’s
    scope. However, the name can still be used for element binding within the same
    `DataTemplate`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要认识到，`DataTemplate`的`BindingContext`被设置为绑定集合的单独项目。因为模板会为集合中的每个项目重复，所以在`DataTemplate`中用`x:Name`命名的UI元素在代码后面是不可访问的。它们的名称仅限于该模板的作用域。然而，名称仍然可以用于同一`DataTemplate`内的元素绑定。
- en: 'The following code snippet shows how we can define a `DataTemplate` for the
    ingredients. This is how we define how each of the ingredients needs to be visualized:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了我们可以如何为配料定义一个`DataTemplate`。这就是我们定义每个配料需要如何可视化的方式：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For each ingredient, we want to render a `HorizontalStackLayout` containing
    a label showing the ingredient’s name, a label showing the `DisplayAmount`, and
    finally, a label showing the `Measurement`. *Figure 6**.1* shows what it looks
    like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个配料，我们希望渲染一个包含显示配料名称的标签、显示`DisplayAmount`的标签，以及最后显示`Measurement`的标签的`HorizontalStackLayout`。*图6**.1*显示了它的样子：
- en: '![Figure 6.1: The Ingredients list](img/B20941_06_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：配料列表](img/B20941_06_01.jpg)'
- en: 'Figure 6.1: The Ingredients list'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：配料列表
- en: Notice that `DisplayAmount` is bound `OneWay`, meaning that when the `PropertyChanged`
    event for this property is triggered, the label’s `Text` property is updated accordingly.
    All the other properties can be bound `OneTime` as their values won’t change once
    they’re displayed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`DisplayAmount`是`OneWay`绑定的，这意味着当此属性的`PropertyChanged`事件被触发时，标签的`Text`属性会相应地更新。所有其他属性都可以绑定`OneTime`，因为它们的值在显示后不会改变。
- en: Tip
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In terms of performance, it’s worth noting that `OneTime` binding mode is generally
    more efficient than `OneWay` data binding. This is especially important when binding
    collections of data! `OneTime` binding establishes the binding once and does not
    track subsequent changes to the source property. Therefore, it’s advisable to
    use `OneTime` binding wherever possible to optimize performance and reduce unnecessary
    UI updates.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，值得注意的是，`OneTime`绑定模式通常比`OneWay`数据绑定更高效。这在绑定数据集合时尤为重要！`OneTime`绑定只建立一次绑定，不会跟踪源属性后续的变化。因此，在可能的情况下使用`OneTime`绑定来优化性能和减少不必要的UI更新是明智的。
- en: 'A `DataTemplate` can also be defined in a resource dictionary. This allows
    `DataTemplate`s to be reused, which can be especially convenient when showing
    the same kind of data in different parts of your app. By defining the template
    once in `Application.Resources` (in `App.xaml`), for example, it can be reused
    throughout the app. Then, we can use the `StaticResource` markup extension to
    bind a particular `DataTemplate` to the `BindableLayout` `ItemTemplate` property
    using the key that was defined in the resource dictionary. The following code
    block shows how to add a `DataTemplate` to the page’s resources and use it later
    on as the `ItemTemplate` of the `VerticalStackLayout` showing the ingredients:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataTemplate`也可以在资源字典中定义。这允许`DataTemplate`被重用，这在在应用的不同部分显示相同类型的数据时特别方便。例如，通过在`Application.Resources`（在`App.xaml`中）中一次性定义模板，它可以在整个应用中重用。然后，我们可以使用`StaticResource`标记扩展，通过在资源字典中定义的键将特定的`DataTemplate`绑定到`BindableLayout`的`ItemTemplate`属性。下面的代码块显示了如何将`DataTemplate`添加到页面的资源中，并在稍后将其用作`VerticalStackLayout`显示配料的`ItemTemplate`：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous code snippet, a `DataTemplate` is defined within the `ContentPage.Resources`
    section and is assigned the `"recipeIngredientTemplate"` key. Later, this template
    is used in the `VerticalStackLayout` by us referencing it through the `StaticResource`
    markup extension, using the `"``recipeIngredientTemplate"` key.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，在`ContentPage.Resources`部分定义了一个`DataTemplate`，并将其分配给`"recipeIngredientTemplate"`键。稍后，通过使用`StaticResource`标记扩展引用该模板，使用`"recipeIngredientTemplate"`键，在`VerticalStackLayout`中使用了此模板。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In .NET MAUI, if you bind a collection without assigning a specific `DataTemplate`,
    the framework automatically invokes the `ToString` method of each object in the
    collection. The returned string value is what will be displayed on the screen.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI中，如果你绑定一个集合而没有分配特定的`DataTemplate`，框架会自动调用集合中每个对象的`ToString`方法。返回的字符串值就是将在屏幕上显示的内容。
- en: With all of this in place, our app now shows a list of ingredients on the recipe’s
    detail page, where each ingredient is rendered using the defined `ItemTemplate`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪之后，我们的应用现在在菜谱详情页上显示了一份成分列表，其中每个成分都使用定义好的`ItemTemplate`进行渲染。
- en: But what if not all items in a particular collection should be rendered the
    same way? Let’s see how we can choose a `DataTemplate` dynamically at runtime.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果某个特定集合中的所有项目都不应该以相同的方式渲染呢？让我们看看如何在运行时动态选择`DataTemplate`。
- en: Dynamically choosing a DataTemplate at runtime
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时动态选择DataTemplate
- en: While ingredients are essential to a recipe app, not much can be done with the
    ingredients without a comprehensive set of cooking instructions. So, let’s bring
    these instructions to life within our app! In addition to the essential steps,
    a list of instructions may also include valuable cooking tips and additional information
    to enhance the cooking experience. Let’s explore how we can incorporate these
    cooking instructions, along with any accompanying notes, into our *Recipes!* app.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然成分对于菜谱应用至关重要，但没有一套全面的烹饪说明，对成分的处理就非常有限。因此，让我们在我们的应用中让这些说明变得生动起来！除了基本步骤外，说明列表还可能包括有价值的烹饪技巧和额外信息，以增强烹饪体验。让我们探讨如何将这些烹饪说明以及任何相关的备注整合到我们的*Recipes!*应用中。
- en: Defining cooking instructions and notes
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义烹饪说明和备注
- en: In our app, we use `InstructionViewModel` and `NoteViewModel` for cooking instructions
    and notes, respectively. `InstructionViewModel` has `Index` and `Description`
    properties, while `NoteViewModel` has just a `Note` property. Both are grouped
    under a common parent, `InstructionBaseViewModel`, and stored in a list called
    `Instructions` in `RecipeDetailViewModel`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们使用`InstructionViewModel`和`NoteViewModel`分别表示烹饪说明和备注。`InstructionViewModel`有`Index`和`Description`属性，而`NoteViewModel`只有一个`Note`属性。它们都归组在共同的父类`InstructionBaseViewModel`下，并存储在`RecipeDetailViewModel`中的`Instructions`列表中。
- en: For now, this list is initialized with some cooking instructions and a tip for
    creating a Caesar salad.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个列表初始化了一些烹饪说明和制作凯撒沙拉的技巧。
- en: If we want to show this list, which contains both instructions and notes, on
    the screen, we would need a mechanism that would allow us to use a different `ItemTemplate`,
    depending on the type. Let’s see how a `DataTemplateSelector` can achieve this!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在屏幕上显示包含说明和备注的列表，我们需要一个机制，允许我们根据类型使用不同的`ItemTemplate`。让我们看看`DataTemplateSelector`如何实现这一点！
- en: Creating a DataTemplateSelector
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个DataTemplateSelector
- en: 'With a `DataTemplateSelector`, we can write code that determines what `DataTemplate`
    to use at runtime. Writing a `DataTemplateSelector` is pretty straightforward.
    Let’s have a look at how we can build one:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DataTemplateSelector`，我们可以编写在运行时确定使用哪个`DataTemplate`的代码。编写`DataTemplateSelector`相当直接。让我们看看我们如何构建一个：
- en: In the `TemplateSelectors` by right-clicking the **Recipes.Mobile** project
    and selecting **Add** | **New Folder**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TemplateSelectors`中，通过右键单击**Recipes.Mobile**项目并选择**添加** | **新建文件夹**。
- en: Next, right-click this newly added folder, select `InstructionsDataTemplateSelector`
    as the name.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击这个新添加的文件夹，将其命名为`InstructionsDataTemplateSelector`。
- en: 'For our class to function as a `DataTemplateSelector`, it needs to inherit
    from `Microsoft.Maui.Controls.DataTemplateSelector`, as shown in the following
    snippet:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的类作为`DataTemplateSelector`工作，它需要从`Microsoft.Maui.Controls.DataTemplateSelector`继承，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inheriting from the `DataTemplateSelector` class requires overriding the abstract
    `OnSelectTemplate` method. This method is invoked at runtime to select the appropriate
    `DataTemplate` and takes two parameters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从`DataTemplateSelector`类继承需要重写抽象的`OnSelectTemplate`方法。该方法在运行时被调用以选择适当的`DataTemplate`，并接受两个参数：
- en: '`item` (of type `object`) is the object we want to display, such as a `NoteViewModel`
    or `InstructionViewModel` item in our app'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`（类型为`object`）是我们想要显示的对象，例如我们应用中的`NoteViewModel`或`InstructionViewModel`项目。'
- en: '`container` (of type `BindableObject`) refers to the layout element that holds
    the collection, such as `VerticalStackLayout` in our example'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container`（类型为`BindableObject`）指的是包含集合的布局元素，例如我们示例中的`VerticalStackLayout`'
- en: Using these parameters, the `OnSelectTemplate` method in a `DataTemplateSelector`
    assists you in selecting the appropriate `DataTemplate` for a given item. In our
    specific scenario, the method will determine the template based solely on the
    type of the passed-in item.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些参数，`DataTemplateSelector`中的`OnSelectTemplate`方法可以帮助你为给定项目选择适当的`DataTemplate`。在我们的特定场景中，该方法将根据传入项目的类型来确定模板。
- en: 'Let’s introduce two properties to `InstructionsDataTemplateSelector`. These
    two properties, `NoteTemplate` and `InstructionTemplate`, dictate which `DataTemplate`
    the `DataTemplateSelector` should return based on the type of the passed-in item
    parameter. Specifically, if it is a `NoteViewModel`, the `OnSelectTemplate` method
    should return `NoteTemplate`. Conversely, if it’s an `InstructionViewModel`, `InstructionTemplate`
    will be returned. Let’s explore how to accomplish this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`InstructionsDataTemplateSelector`中引入两个属性。这两个属性，`NoteTemplate`和`InstructionTemplate`，决定了`DataTemplateSelector`应该根据传入的项目参数类型返回哪个`DataTemplate`。具体来说，如果它是一个`NoteViewModel`，则`OnSelectTemplate`方法应该返回`NoteTemplate`。相反，如果是`InstructionViewModel`，则返回`InstructionTemplate`。让我们探索如何实现这一点：
- en: 'Add the following properties to `InstructionsDataTemplateSelector`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`InstructionsDataTemplateSelector`：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code block shows how we can implement the `OnSelectTemplate`
    method so that it checks the type of the given item and returns the appropriate
    `DataTemplate`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块显示了如何实现`OnSelectTemplate`方法，以便它检查给定项的类型并返回适当的`DataTemplate`：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the given item isn’t an `InstructionViewModel` or `NoteViewModel` item, `null`
    is returned. As a result, the value returned by the object’s `ToString` method
    will be rendered, which is the same behavior when not providing a `DataTemplateSelector`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果给定的项既不是`InstructionViewModel`也不是`NoteViewModel`项，则返回`null`。因此，对象的`ToString`方法返回的值将被渲染，这与不提供`DataTemplateSelector`时的行为相同。
- en: That’s it for `InstructionsDataTemplateSelector`. Let’s see how we can use this
    `DataTemplateSelector` to show both instructions and notes in the app.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`InstructionsDataTemplateSelector`的内容。让我们看看我们如何使用这个`DataTemplateSelector`在应用中显示说明和笔记。
- en: Showing instructions and notes on the screen
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在屏幕上显示说明和笔记
- en: 'Now that the data is in place as well as the `DataTemplateSelector` that we
    want to use, we need to do a few things in XAML to display the recipe’s instructions
    and notes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经就绪，我们也确定了想要使用的`DataTemplateSelector`，我们需要在XAML中做一些事情来显示菜谱的说明和笔记：
- en: 'Let’s start by thinking about how we want to represent a `InstructionViewModel`
    in the app. Here’s a template that we could add to the `RecipeDetailPage’s` resources
    for that data type:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先思考一下我们如何在应用中表示`InstructionViewModel`。以下是一个我们可以添加到`RecipeDetailPage`资源中的模板：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `DataTemplate` for an `InstructionViewModel` defines how we want to visualize
    this type of item: showing the `Index` property with the `Description` below it.'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`InstructionViewModel`的`DataTemplate`定义了我们想要如何可视化此类项：显示`Index`属性，其下方是`Description`。'
- en: Note that we’ve given the `DataTemplate` a key (`instructionTemplate`) that
    we can use later on to reference this specific template.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们给`DataTemplate`分配了一个键（`instructionTemplate`），我们可以稍后使用它来引用这个特定的模板。
- en: 'Let’s add a `DataTemplate` for the `NoteViewModel` items as well. The following
    code block shows a `DataTemplate` for visualizing such items:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个`NoteViewModel`项的`DataTemplate`。以下代码块显示了可视化此类项的`DataTemplate`：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By using this `DataTemplate`, we can visualize notes by showing an icon – for
    which we use the `MaterialIconsRegular` font – followed by the note itself. Both
    are in a specific color so that there is a clear distinction between notes and
    instructions. As before, we’ve given the `DataTemplate` a specific key (`noteTemplate`)
    so that we can reference it later on.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用这个`DataTemplate`，我们可以通过显示一个图标（我们使用`MaterialIconsRegular`字体）来可视化笔记，然后是笔记本身。两者都使用特定的颜色，以便在笔记和说明之间有清晰的区分。和之前一样，我们给`DataTemplate`分配了一个特定的键（`noteTemplate`），这样我们就可以稍后引用它。
- en: 'Next, let’s add an `InstructionsDataTemplateSelector` to `RecipeDetailPage`.
    Start by adding said `DataTemplateSelector`’s namespace as an XML namespace to
    the page, as shown here:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将`InstructionsDataTemplateSelector`添加到`RecipeDetailPage`。首先，将所述`DataTemplateSelector`的命名空间作为XML命名空间添加到页面中，如下所示：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once this is in place, we can add an instance of the `InstructionsDataTemplateSelector`
    class to the page’s `Resources`, as shown in the following snippet:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦设置好，我们就可以将`InstructionsDataTemplateSelector`类的一个实例添加到页面的`Resources`中，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `StaticResource` markup extension is used to reference the two `DataTemplate`s
    that we created earlier to assign them to the respective properties of this `InstructionsDataTemplateSelector`.
    Just like we did with the individual `DataTemplate`, we’ve given this instance
    of the `InstructionsDataTemplateSelector` a key (`instructionDataTemplateSelector`)
    that we can use later on to reference it.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `StaticResource` 标记扩展来引用我们之前创建的两个 `DataTemplate`，并将它们分配给 `InstructionsDataTemplateSelector`
    的相应属性。就像我们对单个 `DataTemplate` 所做的那样，我们给这个 `InstructionsDataTemplateSelector` 实例提供了一个键（`instructionDataTemplateSelector`），我们可以在以后使用它来引用。
- en: 'To display the list of instructions, we can add a `VerticalStackLayout` near
    the bottom of `RecipeDetailPage`. The following code snippet demonstrates this
    setup:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示指令列表，我们可以在 `RecipeDetailPage` 的底部附近添加一个 `VerticalStackLayout`。以下代码片段演示了此设置：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Figure 6.2: Showing instructions and notes](img/B20941_06_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 6.2: Showing instructions and notes](img/B20941_06_02.jpg)'
- en: 'Figure 6.2: Showing instructions and notes'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 6.2: Showing instructions and notes'
- en: With that, we’ve explored how to leverage `DataTemplate`s and a `DataTemplateSelector`
    to visualize instructions and notes within our *Recipes!* app. By defining separate
    `DataTemplate`s and using a `DataTemplateSelector`, we can dynamically choose
    the appropriate template for each item in the collection, providing a customized
    and intuitive display of cooking instructions and additional notes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经探讨了如何在 *Recipes!* 应用程序中利用 `DataTemplate` 和 `DataTemplateSelector` 来可视化指令和注释。通过定义单独的
    `DataTemplate` 并使用 `DataTemplateSelector`，我们可以动态地为集合中的每个项目选择适当的模板，提供定制且直观的烹饪指令和附加注释的显示。
- en: Now that we have successfully implemented the visualization of instructions
    and notes, let’s move on to handling empty collections.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功实现了指令和注释的可视化，让我们继续处理空集合。
- en: Handling empty collections
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理空集合
- en: Besides the `ItemsSource` and `ItemTemplate` properties, `BindableLayout` also
    has `EmptyView` and `EmptyViewTemplate` properties. These properties allow us
    to define what to show if the provided `ItemsSource` is empty or null.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `ItemsSource` 和 `ItemTemplate` 属性外，`BindableLayout` 还具有 `EmptyView` 和 `EmptyViewTemplate`
    属性。这些属性允许我们定义如果提供的 `ItemsSource` 为空或为 null 时显示的内容。
- en: 'The `EmptyView` property can be a string value or a `View`. So, in its simplest
    form, we could add the following to a `VerticalStackLayout` to show the shopping
    list:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmptyView` 属性可以是字符串值或 `View`。因此，在其最简单的形式中，我们可以在 `VerticalStackLayout` 中添加以下内容来显示购物清单：'
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`"Nothing to see here"` is shown on the screen when the bound `ItemSource`
    contains no items.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定的 `ItemSource` 不包含任何项目时，屏幕上会显示 `"Nothing to see here"`。
- en: 'Or, if we want to have more control over the appearance of what is shown when
    the collection is empty, we could also do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想要对集合为空时显示的内容的外观有更多控制，我们也可以这样做：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: public ObservableCollection<RecipeIngredientViewModel>
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public ObservableCollection<RecipeIngredientViewModel>
- en: ShoppingList { get; } = new();
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ShoppingList { get; } = new();
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: public IRelayCommand AddToShoppingListCommand { get; }
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public IRelayCommand AddToShoppingListCommand { get; }
- en: public IRelayCommand RemoveFromShoppingListCommand
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public IRelayCommand RemoveFromShoppingListCommand
- en: '{ get; }'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{ get; }'
- en: private void AddToShoppingList(
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private void AddToShoppingList(
- en: RecipeIngredientViewModel viewModel)
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RecipeIngredientViewModel viewModel)
- en: '{'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if (ShoppingList.Contains(viewModel))
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (ShoppingList.Contains(viewModel))
- en: return;
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return;
- en: ShoppingList.Add(viewModel);
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ShoppingList.Add(viewModel);
- en: '}'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: private void RemoveFromShoppingList
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private void RemoveFromShoppingList
- en: (RecipeIngredientViewModel viewModel)
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (RecipeIngredientViewModel viewModel)
- en: '{'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if (ShoppingList.Contains(viewModel))
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (ShoppingList.Contains(viewModel))
- en: ShoppingList.Remove(viewModel);
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ShoppingList.Remove(viewModel);
- en: '}'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: public RecipeDetailViewModel()
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public RecipeDetailViewModel()
- en: '{'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '...'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: AddToShoppingListCommand = new RelayCommand
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: AddToShoppingListCommand = new RelayCommand
- en: <RecipeIngredientViewModel>(AddToShoppingList);
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <RecipeIngredientViewModel>(AddToShoppingList);
- en: RemoveFromShoppingListCommand = new RelayCommand
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RemoveFromShoppingListCommand = new RelayCommand
- en: <RecipeIngredientViewModel>
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <RecipeIngredientViewModel>
- en: (RemoveFromShoppingList);
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (RemoveFromShoppingList);
- en: '}'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <VerticalStackLayout Padding="10">
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <VerticalStackLayout Padding="10">
- en: <Label ...
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Label ...
- en: Text="Ingredients list" />
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text="Ingredients list" />
- en: '...'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: <VerticalStackLayout Margin="10,0" Padding="10">
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <VerticalStackLayout Margin="10,0" Padding="10">
- en: <Label
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Label
- en: FontAttributes="Italic,Bold"
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FontAttributes="Italic,Bold"
- en: FontSize="16" Text="Shopping list" />
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FontSize="16" Text="Shopping list" />
- en: <VerticalStackLayout
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <VerticalStackLayout
- en: Margin="0,10" Spacing="10"
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Margin="0,10" Spacing="10"
- en: BindableLayout.ItemsSource="{Binding
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: BindableLayout.ItemsSource="{Binding
- en: ShoppingList, Mode=OneTime}"
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ShoppingList, Mode=OneTime}"
- en: BindableLayout.EmptyView="Nothing added">
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: BindableLayout.EmptyView="Nothing added">
- en: </VerticalStackLayout>
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </VerticalStackLayout>
- en: </VerticalStackLayout>
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </VerticalStackLayout>
- en: </VerticalStackLayout>
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </VerticalStackLayout>
- en: '[PRE19]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <HorizontalStackLayout Spacing="5">
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <HorizontalStackLayout Spacing="5">
- en: <Button
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<Button'
- en: Command="{Binding AddToShoppingListCommand,
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Command="{Binding AddToShoppingListCommand,
- en: Source={RelativeSource AncestorType={x:Type
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Source={RelativeSource AncestorType={x:Type
- en: vms:RecipeDetailViewModel}}}"
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vms:RecipeDetailViewModel}}}"
- en: CommandParameter="{Binding}"
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CommandParameter="{Binding}"
- en: FontFamily="MaterialIconsRegular"
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FontFamily="MaterialIconsRegular"
- en: Text="&#xe854;" />
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text="&#xe854;" />
- en: <Label
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Label
- en: FontAttributes="Bold"
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FontAttributes="Bold"
- en: FontSize="16" VerticalOptions="Center"
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FontSize="16" VerticalOptions="Center"
- en: Text="{Binding IngredientName,
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text="{Binding IngredientName,
- en: StringFormat='{0}:'}" />
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: StringFormat='{0}:'}" />
- en: '...'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: </HorizontalStackLayout>
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </HorizontalStackLayout>
- en: '[PRE20]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <Button
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Button
- en: Command="{Binding RemoveFromShoppingListCommand,
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Command="{Binding RemoveFromShoppingListCommand,
- en: Source={RelativeSource AncestorType={x:Type
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Source={RelativeSource AncestorType={x:Type
- en: vms:RecipeDetailViewModel}}}"
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vms:RecipeDetailViewModel}}}"
- en: CommandParameter="{Binding}"
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CommandParameter="{Binding}"
- en: FontFamily="MaterialIconsRegular"
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FontFamily="MaterialIconsRegular"
- en: Button has a different icon and has its Command bound to RemoveFromShoppingListCommand,
    allowing the user to remove an ingredient again from the list.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Button has a different icon and has its Command bound to RemoveFromShoppingListCommand,
    allowing the user to remove an ingredient again from the list.
- en: '[PRE21]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <ShellContent AppShell.xaml file, as shown earlier, and don’t worry about it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <ShellContent AppShell.xaml file, as shown earlier, and don’t worry about it.
- en: 'To display the recipes in `RecipesOverviewPage`, we can use `CollectionView`.
    The `ItemsSource` property of `CollectionView` is bound to the `Recipes` property
    of the `RecipesOverviewViewModel` class, which serves as the page’s `BindingContext`.
    Similar to `BindableLayout`, we define the `ItemTemplate` property to specify
    how each item in the collection should be rendered. The following code snippet
    demonstrates this setup:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'To display the recipes in `RecipesOverviewPage`, we can use `CollectionView`.
    The `ItemsSource` property of `CollectionView` is bound to the `Recipes` property
    of the `RecipesOverviewViewModel` class, which serves as the page’s `BindingContext`.
    Similar to `BindableLayout`, we define the `ItemTemplate` property to specify
    how each item in the collection should be rendered. The following code snippet
    demonstrates this setup:'
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The usage of `CollectionView` should feel familiar if you have worked with `BindableLayout`
    before. You can copy the `DataTemplate` class from `BindableLayout` and it will
    show up the same.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: The usage of `CollectionView` should feel familiar if you have worked with `BindableLayout`
    before. You can copy the `DataTemplate` class from `BindableLayout` and it will
    show up the same.
- en: 'Now, let’s leverage one of the more powerful features of `CollectionView`:
    data grouping. Let’s explore how to effectively display grouped data.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now, let’s leverage one of the more powerful features of `CollectionView`:
    data grouping. Let’s explore how to effectively display grouped data.'
- en: Displaying grouped data
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Displaying grouped data
- en: 'Grouping data in a collection is a powerful way to organize and present information
    in a meaningful and structured manner. By grouping related items, you can provide
    intuitive navigation and enhance the user experience. `CollectionView` allows
    us to easily display grouped data and provides both `GroupHeaderTemplate` and
    `GroupFooterTemplate` properties. These templates allow us to define what’s being
    displayed above and below a group of items. *Figure 6**.4* illustrates how a list
    of grouped items is rendered with group headers and footers:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中对数据进行分组是一种强大的方式，可以有意义和结构化地组织和展示信息。通过分组相关项目，您可以提供直观的导航并增强用户体验。`CollectionView`
    允许我们轻松显示分组数据，并提供 `GroupHeaderTemplate` 和 `GroupFooterTemplate` 属性。这些模板允许我们定义在项目组上方和下方显示的内容。*图
    6.4* 展示了如何使用分组标题和脚本来渲染分组项目列表：
- en: '![Figure 6.4: Group headers and footers](img/B20941_06_04.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：分组标题和脚注](img/B20941_06_04.jpg)'
- en: 'Figure 6.4: Group headers and footers'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：分组标题和脚注
- en: '`RecipeRatingDetailPage`, which can be accessed by tapping on the rating information
    on `RecipeDetailPage`, should show all the ratings of a recipe grouped by the
    number of stars. Let’s walk through the steps needed to set this up:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecipeRatingDetailPage`, which can be accessed by tapping on the rating information
    on `RecipeDetailPage`, should show all the ratings of a recipe grouped by the
    number of stars. Let’s walk through the steps needed to set this up:'
- en: While `RecipeRatingsDetailViewModel` already contains a list of all the reviews
    of a recipe, it doesn’t group the data yet. First, let’s create a class for holding
    a group of ratings. In the `RatingGroup` as its name.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: While `RecipeRatingsDetailViewModel` already contains a list of all the reviews
    of a recipe, it doesn’t group the data yet. First, let’s create a class for holding
    a group of ratings. In the `RatingGroup` as its name.
- en: 'The `RatingGroup` class inherits from `List<UserReviewModel>` and has an additional
    property called `Key`. Here’s what it looks like:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'The `RatingGroup` class inherits from `List<UserReviewModel>` and has an additional
    property called `Key`. Here’s what it looks like:'
- en: '[PRE23]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This class serves as a specialized list for holding `UserReviewViewModel` objects.
    It inherits from `List<UserReviewViewModel>`, meaning it can do anything a regular
    list can do, such as holding multiple `UserReviewViewModel` items. In addition
    to that, the class includes an extra property called `Key`. This property is used
    to group the user reviews by some criteria, such as a rating or a category.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类作为一个专门用于存储 `UserReviewViewModel` 对象的列表。它继承自 `List<UserReviewViewModel>`，这意味着它可以做任何常规列表能做的事情，例如存储多个
    `UserReviewViewModel` 项目。除此之外，该类还包括一个名为 `Key` 的额外属性。这个属性用于根据某些标准（如评分或类别）对用户评论进行分组。
- en: '3.  Next, add a `GroupedReviews` property to `RecipeRatingsDetailViewModel`.
    This property is of type `List<RatingGroup>`. It holds groups of reviews that
    are organized based on the number of stars. Each `RatingGroup` in the list will
    contain reviews that share the same number of stars, which is represented by the
    `Key` property. The following snippet shows this newly added property and how
    it gets initialized in the constructor:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 接下来，向 `RecipeRatingsDetailViewModel` 添加一个 `GroupedReviews` 属性。这个属性的类型是 `List<RatingGroup>`。它包含根据星级数量组织的评论组。列表中的每个
    `RatingGroup` 将包含具有相同星级数量的评论，这由 `Key` 属性表示。以下代码片段展示了这个新添加的属性以及如何在构造函数中初始化它：
- en: '[PRE24]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the constructor, we have grouped all the reviews by their rating, rounded
    to 0.5\. We use this grouping to create a list of `RatingGroups` items that we
    assign to the `GroupedReviews` property.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构造函数中，我们已经根据评分（四舍五入到 0.5）对所有的评论进行了分组。我们使用这个分组来创建一个 `RatingGroups` 项目的列表，并将其分配给
    `GroupedReviews` 属性。
- en: '4.  Now, we can bind the `GroupedReviews` property to the `CollectionView`
    on `RecipeRatingDetailPage`. When binding a grouped collection, we also need to
    make sure the `IsGrouped` property of `CollectionView` is set to true, as the
    following snippet shows:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4. 现在，我们可以将 `GroupedReviews` 属性绑定到 `RecipeRatingDetailPage` 上的 `CollectionView`。在绑定分组集合时，我们还需要确保
    `CollectionView` 的 `IsGrouped` 属性设置为 true，如下代码片段所示：
- en: '[PRE25]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 5.  As we did previously, we should be defining an `ItemTemplate` to declare
    how each item should be rendered. Once that is in place, `CollectionView` renders
    all the items but there isn’t a clear distinction between the different groups
    yet.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5. 正如我们之前所做的那样，我们应该定义一个 `ItemTemplate` 来声明每个项目应该如何渲染。一旦设置好，`CollectionView`
    就会渲染所有项目，但不同组之间还没有明显的区分。
- en: 'So, let''s add `GroupHeaderTemplate` and `GroupFooterTemplate` to clearly distinguish
    the different groups. The following code block demonstrates how this can be done:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们添加 `GroupHeaderTemplate` 和 `GroupFooterTemplate` 以清楚地区分不同的组。以下代码块演示了如何实现这一点：
- en: '[PRE26]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `BindingContext` of these templates is an instance of `RatingGroup`, allowing
    us to bind to its properties, such as `Key` and `Count`. With this, we can make
    the groupings visually clear to the user.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些模板的 `BindingContext` 是 `RatingGroup` 的一个实例，允许我们绑定到其属性，如 `Key` 和 `Count`。有了这个，我们可以使分组对用户来说在视觉上更加清晰。
- en: 'Grouping data in `CollectionView` allows for a more organized and structured
    presentation of information, as shown in *Figure 6**.5*:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CollectionView` 中对数据进行分组允许以更有组织和结构化的方式展示信息，如图 6.5 所示。5：
- en: '![Figure 6.5: Grouping data](img/B20941_06_05.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5：分组数据](img/B20941_06_05.jpg)'
- en: 'Figure 6.5: Grouping data'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：分组数据
- en: By leveraging the `GroupHeaderTemplate` and `GroupFooterTemplate` properties,
    you can enhance the user experience and provide intuitive navigation within your
    app.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 `GroupHeaderTemplate` 和 `GroupFooterTemplate` 属性，您可以增强用户体验，并在您的应用中提供直观的导航。
- en: Not only can `CollectionView` render your data, it also offers various interactive
    features to engage users with your app. From selecting items to incrementally
    loading data and other common functionalities, let’s discover how to get the most
    out of this powerful control, by keeping MVVM principles in mind.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅 `CollectionView` 可以渲染您的数据，它还提供了各种交互功能，以吸引用户参与您的应用。从选择项目到增量加载数据和其他常见功能，让我们在保持
    MVVM 原则的同时，发现如何充分利用这个强大的控件。
- en: Selecting items
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 选择项目
- en: When working with `CollectionView`, you have various options for selecting items
    and managing the selection state. By binding the `SelectedItem` property, you
    can easily track the currently selected item in your ViewModel. Additionally,
    you can bind the `SelectedItems` property to a collection in your ViewModel to
    track multiple selected items. The `SelectionMode` property allows you to define
    whether single or multiple items can be selected or whether or not selecting items
    is disabled. You can use the `SelectionChangedCommand` property to bind a command
    in your ViewModel that will be executed when the selection changes or handle the
    `SelectionChanged` event, allowing you to implement flexible and interactive item
    selection behavior in your app.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `CollectionView` 时，您有多种选择项目和管理选择状态的方法。通过绑定 `SelectedItem` 属性，您可以在 ViewModel
    中轻松跟踪当前选中的项目。此外，您可以将 `SelectedItems` 属性绑定到 ViewModel 中的集合以跟踪多个选中的项目。`SelectionMode`
    属性允许您定义是否可以选择单个或多个项目，或者是否禁用项目选择。您可以使用 `SelectionChangedCommand` 属性绑定 ViewModel
    中的命令，该命令将在选择更改时执行，或者处理 `SelectionChanged` 事件，从而在您的应用程序中实现灵活和交互式的项目选择行为。
- en: 'Let’s see how we can allow the user to select one or more reviews, allowing
    the user to report inappropriate reviews, for example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何允许用户选择一个或多个评论，例如允许用户报告不适当的评论：
- en: 'Add the following property to `RecipeRatingsDetailViewModel`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到 `RecipeRatingsDetailViewModel`：
- en: '[PRE27]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This property will hold the items that the user has selected on the `CollectionView`.
    Note that this `ObservableCollection` uses `object` as its type parameter, rather
    than a more specific type. Though it’s not explicitly documented, using `object`
    appears to be the only way to successfully bind multiple selections in `CollectionView`.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此属性将保存用户在 `CollectionView` 上选择的项目。请注意，此 `ObservableCollection` 使用 `object` 作为其类型参数，而不是更具体的类型。尽管没有明确记录，但使用
    `object` 似乎是在 `CollectionView` 中成功绑定多选的唯一方法。
- en: '2.  Now, let’s add a command called `ReportReviewsCommand` that can only be
    executed when one or more reviews are selected, as shown here:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 现在，让我们添加一个名为 `ReportReviewsCommand` 的命令，该命令只能在选择一个或多个评论时执行，如下所示：
- en: '[PRE28]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '3.  As the `SelectedReviews` property is an `ObservableCollection`, we can
    listen to the `CollectionChangedEvent` and call the `ReportReviewsCommand`’s `NotifyCanExecuteChanged`
    method. That way the `ReportReviewsCommand`’s `CanExecute` method gets re-evaluated.
    The following snippet shows how to implement this:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 由于 `SelectedReviews` 属性是 `ObservableCollection`，我们可以监听 `CollectionChangedEvent`
    并调用 `ReportReviewsCommand` 的 `NotifyCanExecuteChanged` 方法。这样，`ReportReviewsCommand`
    的 `CanExecute` 方法将重新评估。以下代码片段显示了如何实现这一点：
- en: '[PRE29]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '4.  Update the `CollectionView` on `RecipeRatingDetailPage` so that its `SelectedItems`
    property is bound to the `SelectedReviews` property. We also need to set the appropriate
    `SelectionMode`, as shown here:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4. 更新 `RecipeRatingDetailPage` 上的 `CollectionView`，使其 `SelectedItems` 属性绑定到
    `SelectedReviews` 属性。我们还需要设置适当的 `SelectionMode`，如下所示：
- en: '[PRE30]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By adding this code, the items the user selects on the UI will be added to the
    `SelectedReviews` list, while selected items that the user de-selects will be
    removed from it. The `ReportReviews` method, we can easily access the `SelectedReviews`
    property to see what items have been selected.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加此代码，用户在 UI 上选择的项目将被添加到 `SelectedReviews` 列表中，而用户取消选择的项目将从其中移除。通过 `ReportReviews`
    方法，我们可以轻松访问 `SelectedReviews` 属性以查看已选择的项目。
- en: 'As a final example, let’s look at how we can bind the `SelectedItem` and `SelectionChangedCommand`
    properties to trigger something such as navigation. Let’s take a look at how to
    implement this on `RecipesOverviewPage`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，让我们看看如何将 `SelectedItem` 和 `SelectionChangedCommand` 属性绑定以触发导航等操作。让我们看看如何在
    `RecipesOverviewPage` 上实现这一点：
- en: 'On `RecipesOverviewPage`, update the `CollectionView` and bind its `SelectedItem`
    and `SelectionChangedCommand` properties, like this:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecipesOverviewPage` 上，更新 `CollectionView` 并绑定其 `SelectedItem` 和 `SelectionChangedCommand`
    属性，如下所示：
- en: '[PRE31]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `SelectedItem` property is bound `TwoWay` to the `SelectedRecipe` property
    and `SelectionChangedCommand` is bound to `NavigateToSelectedDetailCommand`. Both
    properties will be added shortly. Also, the `SelectionMode` property is set to
    `"Single"`, allowing the user to select one item in the list.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SelectedItem` 属性与 `SelectedRecipe` 属性双向绑定，并且 `SelectionChangedCommand` 绑定到
    `NavigateToSelectedDetailCommand`。这两个属性将很快被添加。此外，`SelectionMode` 属性设置为 `"Single"`，允许用户在列表中选择一个项目。'
- en: '2.  Now, let’s add the two properties mentioned earlier to `RecipeOverviewViewModel`.
    Here’s what they look like:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  现在，让我们将前面提到的两个属性添加到 `RecipeOverviewViewModel` 中。以下是它们的形状：
- en: '[PRE32]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '3.  The following snippet shows how the command is instantiated in the constructor
    of the ViewModel:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  以下代码片段展示了如何在 ViewModel 的构造函数中实例化该命令：
- en: '[PRE33]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because this command is bound to the `SelectionChangedCommand` of the `CollectionView`,
    it will get triggered when an item is selected or de-selected.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为此命令绑定到 `CollectionView` 的 `SelectionChangedCommand`，所以当选择或取消选择项目时，它将被触发。
- en: '4.  The following code block shows the `NavigateToSelectedDetail` method:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  以下代码块显示了 `NavigateToSelectedDetail` 方法：
- en: '[PRE34]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the user selects an item in `CollectionView`, the `SelectedRecipe` property
    on the ViewModel will be updated. Next, `NavigateToSelectedDetailCommand` will
    be executed, which will call the `NavigateToSelectedDetail` method. In this method,
    we can access the `SelectedRecipe` property and act upon it, such as navigating
    to its detail page, for example. Finally, we set the `SelectedRecipe` property
    to null. As this property is bound `TwoWay`, the item will get de-selected in
    `CollectionView`. As a result, if we navigate back from `RecipeDetailPage`, no
    item will be selected on the overview and then we can immediately select another
    one.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 `CollectionView` 中选择一个项目时，ViewModel 上的 `SelectedRecipe` 属性将被更新。接下来，`NavigateToSelectedDetailCommand`
    将被执行，这将调用 `NavigateToSelectedDetail` 方法。在这个方法中，我们可以访问 `SelectedRecipe` 属性并对其采取行动，例如导航到其详细页面。最后，我们将
    `SelectedRecipe` 属性设置为 null。由于此属性是双向绑定的，项目将在 `CollectionView` 中取消选中。因此，如果我们从 `RecipeDetailPage`
    返回，概述中不会选择任何项目，然后我们可以立即选择另一个项目。
- en: Now, let’s have a look at how we can load data incrementally while the user
    scrolls through a large dataset.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在用户滚动大型数据集时增量加载数据。
- en: Incrementally loading data
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 增量加载数据
- en: 'As the user scrolls through large datasets in `CollectionView`, providing a
    seamless and interactive user experience is crucial. The `RemainingItemsThreshold`
    and `RemainingItemsThresholdReachedCommand` properties allow you to effortlessly
    load additional items. By specifying a threshold value for the remaining items,
    new data is dynamically fetched and seamlessly loaded, ensuring a smooth and continuous
    experience. Let’s explore how to implement this interactive functionality in just
    a few simple steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 `CollectionView` 中滚动大型数据集时，提供无缝和交互式的用户体验至关重要。`RemainingItemsThreshold`
    和 `RemainingItemsThresholdReachedCommand` 属性允许您轻松地加载更多项目。通过指定剩余项目的阈值，新数据将动态获取并无缝加载，确保流畅和连续的体验。让我们通过几个简单的步骤来探索如何实现这种交互功能：
- en: 'Add the following method to `RecipesOverviewViewModel`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `RecipesOverviewViewModel`：
- en: '[PRE35]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method adds items to the `Recipes` `ObservableCollection` class as it has
    fewer items than what’s defined in the `TotalNumberOfRecipes` property. It’s a
    pretty dumb implementation, but it should get the point across. In a real-life
    scenario, we would fetch this data from an API or something. We’ll look at this
    in [*Chapter 10*](B20941_10.xhtml#_idTextAnchor165), *Working with* *Remote Data*.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将项目添加到 `Recipes` `ObservableCollection` 类中，因为它比 `TotalNumberOfRecipes` 属性中定义的项目要少。这是一个相当愚蠢的实现，但它应该能说明问题。在现实场景中，我们会从
    API 或其他地方获取这些数据。我们将在 [*第 10 章*](B20941_10.xhtml#_idTextAnchor165)，*与远程数据工作* 中查看这一点。
- en: '2.  Next, let’s add a command called `TryLoadMoreItemsCommand`. This is the
    command that should be invoked when we want to load more items. We want to instantiate
    it in the constructor of `RecipesOverviewViewModel`, as shown here:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  接下来，让我们添加一个名为 `TryLoadMoreItemsCommand` 的命令。这是我们想要加载数据时应该调用的命令。我们希望将其实例化在
    `RecipesOverviewViewModel` 的构造函数中，如下所示：
- en: '[PRE36]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '3.  Now, we can update the `CollectionView` and add both `RemainingItemsThreshold`
    and `RemainingItemsThresholdReachedCommand`, as shown in the following code block:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  现在，我们可以更新 `CollectionView` 并添加 `RemainingItemsThreshold` 和 `RemainingItemsThresholdReachedCommand`，如下面的代码块所示：
- en: '[PRE37]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With this code in place, `TryLoadMoreItemsCommand` will be invoked as soon as
    the user scrolls and the number of remaining items reaches the specified threshold
    of five or less. The `TryLoadMoreItems` method will then add items to the `Recipes`
    `ObservableCollection`. Because this method implements the `ICollectionChanged`
    interface, the added items will be automatically added to `CollectionView`.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码设置后，当用户滚动并且剩余项目数量达到指定的五个或更少时，`TryLoadMoreItemsCommand` 将被调用。然后，`TryLoadMoreItems`
    方法将向 `Recipes` `ObservableCollection` 添加项目。因为此方法实现了 `ICollectionChanged` 接口，所以添加的项目将被自动添加到
    `CollectionView`。
- en: Incrementally loading data is a good idea when dealing with very large datasets
    and `CollectionView` makes it extremely convenient to implement using the `RemainingItemsThreshold`
    and `RemainingItemsThresholdReachedCommand` properties.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理非常大的数据集时，增量加载数据是一个好主意，而 `CollectionView` 通过使用 `RemainingItemsThreshold` 和
    `RemainingItemsThresholdReachedCommand` 属性，使得实现这一点变得极其方便。
- en: Other common interactions
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见交互
- en: In addition to the features we’ve discussed, it’s worth mentioning that common
    interactions such as pull-to-refresh and item context menus are also available
    in .NET MAUI. These interactions allow users to refresh the data that’s displayed
    in the collection and access additional actions or information specific to each
    item. While they are used on collections very often, it’s important to note that
    these features are not exclusive to `CollectionView` and can be implemented anywhere
    in your application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们讨论的功能之外，还值得提一下，常见的交互，如下拉刷新和项目上下文菜单，也在 .NET MAUI 中提供。这些交互允许用户刷新集合中显示的数据，并访问针对每个项目的附加操作或信息。虽然它们在集合上使用得非常频繁，但重要的是要注意，这些功能并不局限于
    `CollectionView`，可以在应用程序的任何地方实现。
- en: '`SwipeView` is a versatile control that allows you to add swipe gestures to
    individual items in a collection. It enables users to perform actions by swiping
    horizontally or vertically on an item, such as deleting an item or revealing additional
    options.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwipeView` 是一个多才多艺的控件，允许您向集合中的单个项目添加滑动手势。它使用户能够通过在项目上水平或垂直滑动来执行操作，例如删除项目或显示附加选项。'
- en: '`RefreshView`, on the other hand, is a control that provides a standard pull-to-refresh
    functionality. It allows users to refresh the data that’s displayed in a collection
    by pulling down on the screen. When triggered, `RefreshView` executes a command
    to update the collection with fresh data.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`RefreshView` 是一个提供标准下拉刷新功能的控件。它允许用户通过在屏幕上向下拉来刷新集合中显示的数据。当被触发时，`RefreshView`
    执行一个命令以使用新鲜数据更新集合。
- en: Summary
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the powerful features and capabilities of collections
    in .NET MAUI. We learned how to effectively bind collections to UI elements using
    `BindableLayout` and `CollectionView`, enabling dynamic and efficient rendering
    of data. We covered topics such as data templating, item selection, grouping,
    and incremental loading. `CollectionView` proved to be a versatile control, offering
    advanced functionality such as item virtualization and seamless data loading.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 .NET MAUI 中集合的强大功能和能力。我们学习了如何使用 `BindableLayout` 和 `CollectionView`
    有效地将集合绑定到 UI 元素，从而实现数据的动态和高效渲染。我们涵盖了数据模板、项目选择、分组和增量加载等主题。`CollectionView` 证明是一个多才多艺的控件，提供了如项目虚拟化和无缝数据加载的高级功能。
- en: As we continue our journey in building robust and scalable apps, in the next
    chapter, we will delve into the important concepts of dependency injection, services,
    and messaging. These fundamental aspects of app development will empower us to
    create modular and maintainable code, enhance code reusability, and enable effective
    communication between different parts of our application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续构建健壮和可扩展的应用程序之旅，在下一章中，我们将深入探讨依赖注入、服务和消息传递等重要概念。这些应用程序开发的基本方面将使我们能够创建模块化和可维护的代码，提高代码的可重用性，并使应用程序不同部分之间的有效通信成为可能。
- en: Further reading
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: '`BindableLayout`: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BindableLayout`: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout)'
- en: '`CollectionView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollectionView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview)'
- en: '`ListView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview)'
- en: '`CarouselView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarouselView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview)'
- en: '`SwipeView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwipeView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview)'
- en: '`RefreshView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RefreshView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview)'
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Part 2: Building a .NET MAUI App Using MVVM'
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：使用MVVM构建.NET MAUI应用程序
- en: In this part, we focus on equipping you with the essential tools and techniques
    needed to craft a genuine .NET MAUI application that leverages the MVVM pattern.
    We will dive into the core mechanisms such as dependency injection, services,
    and messaging, which form the backbone of any robust app. We will help you master
    MVVM-based navigation in .NET MAUI with or without Shell, refine user interactions
    with precise input and validation, and connect seamlessly with remote data sources.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们专注于为您提供构建真正的.NET MAUI应用程序所需的必要工具和技术，该应用程序利用MVVM模式。我们将深入研究核心机制，如依赖注入、服务和消息传递，这些是任何强大应用程序的骨架。我们将帮助您掌握.NET
    MAUI中的基于MVVM的导航，无论是否有Shell，以及通过精确的输入和验证来细化用户交互，并与远程数据源无缝连接。
- en: 'This part has the following chapters:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B20941_07.xhtml#_idTextAnchor119), *Dependency Injection, Services,
    and Messaging*'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B20941_07.xhtml#_idTextAnchor119), *依赖注入、服务和消息传递*'
- en: '[*Chapter 8*](B20941_08.xhtml#_idTextAnchor132), *.NET MAUI Shell and Navigation*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B20941_08.xhtml#_idTextAnchor132), *.NET MAUI Shell和导航*'
- en: '[*Chapter 9*](B20941_09.xhtml#_idTextAnchor148), *Handling User Input and Validation*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B20941_09.xhtml#_idTextAnchor148), *处理用户输入和验证*'
- en: '[*Chapter 10*](B20941_10.xhtml#_idTextAnchor165), *Working with Remote Data*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B20941_10.xhtml#_idTextAnchor165), *处理远程数据*'
