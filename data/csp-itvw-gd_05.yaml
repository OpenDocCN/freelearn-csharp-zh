- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Fundamentals of C# Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 编程基础
- en: Welcome to [*Chapter 3*](B20871_03.xhtml#_idTextAnchor055), where we shall dive
    into the heart of technical interviews, specifically focusing on the fundamentals
    of C# programming. C# is a widely adopted, robust, and versatile language, used
    across various domains, including but not limited to game development, web services,
    and enterprise-level software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第 3 章*](B20871_03.xhtml#_idTextAnchor055)，我们将深入探讨技术面试的核心，特别是关注 C# 编程的基础。C#
    是一种广泛采用、稳健且灵活的语言，被用于各个领域，包括但不限于游戏开发、网络服务和企业级软件。
- en: Grasping the essentials of a programming language such as C# is crucial to excel
    in technical interviews. In this chapter, we will walk you through the vital principles
    of C#, commencing with essential concepts, data types, variables, and operators,
    and swiftly move to control structures and loops. Our aim is not just to acquaint
    you with the syntax but to also ensure that you comprehend the logic behind it,
    enabling you to write effective and clean code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握像 C# 这样的编程语言的基本要素对于在技术面试中表现出色至关重要。在本章中，我们将向您介绍 C# 的关键原则，从基本概念、数据类型、变量和运算符开始，迅速过渡到控制结构和循环。我们的目标不仅是让您熟悉语法，还要确保您理解其背后的逻辑，使您能够编写有效且干净的代码。
- en: Furthermore, we shall delve into the basics of **object-oriented programming**
    (**OOP**) using C#. Understanding OOP allows you to design and manage complex
    applications, a skill that is greatly appreciated in the tech industry.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将深入探讨使用 C# 的**面向对象编程**（**OOP**）的基础。理解 OOP 允许你设计和管理复杂的应用程序，这是科技行业中非常受重视的技能。
- en: By the end of this chapter, you will possess a solid foundation in C# programming.
    This knowledge will empower you to confidently tackle coding challenges and demonstrate
    your problem-solving abilities during technical interviews. This chapter is designed
    to provide you with a balanced mix of theoretical understanding and practical
    exercises, thereby ensuring you can apply the learned concepts effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有 C# 编程的坚实基础。这些知识将使您能够自信地应对编码挑战，并在技术面试中展示您的解决问题的能力。本章旨在提供理论与实践的平衡，确保您能够有效地应用所学概念。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Essential C# concepts and principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 的基本概念和原则
- en: Working with data types, variables, and operators in C#
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中使用数据类型、变量和运算符
- en: Writing control structures and loops in C#
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中编写控制结构和循环
- en: Exploring the basics of OOP using C#
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 探索 OOP 的基础
- en: Essential C# concepts and principles
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 的基本概念和原则
- en: In this section, we aim to help you deepen your understanding of fundamental
    C# principles, enabling you to confidently answer the related questions you may
    encounter during technical interviews. This section is designed as a Q&A in which
    we will tackle potential interview questions covering a range of topics, from
    the basics of the C# syntax to key concepts of OOP in C#. We believe this interactive
    approach will help reinforce your knowledge and prepare you effectively for real-world
    interview scenarios.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们旨在帮助您深化对 C# 基本原则的理解，使您能够自信地回答在技术面试中可能遇到的相关问题。本节设计为一个问答环节，我们将解决可能出现的面试问题，涵盖从
    C# 语法基础到 C# 中 OOP 关键概念的各个主题。我们相信这种互动方法将有助于巩固您的知识，并有效地为实际面试场景做好准备。
- en: Let’s dive in and start exploring the questions you might face and how to approach
    answering them effectively.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索您可能会遇到的问题以及如何有效地回答它们。
- en: What does the C# language represent, and for which platforms and applications
    is it intended?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 语言代表什么，它旨在哪些平台和应用程序中使用？
- en: C# is a programming language created by Microsoft and part of the .NET platform.
    With C#, a variety of applications can be developed, such as desktop applications,
    web applications, mobile applications, gaming applications (via Unity), cloud
    computing solutions, and more. C# is supported across various platforms thanks
    to .NET Core and Xamarin.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是由微软创建的编程语言，是 .NET 平台的一部分。使用 C#，可以开发各种应用程序，如桌面应用程序、网络应用程序、移动应用程序、游戏应用程序（通过
    Unity）、云计算解决方案等。C# 由于 .NET Core 和 Xamarin 的支持，在各种平台上得到支持。
- en: What’s the fundamental difference between .dll and .exe files in the context
    of C# projects?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 项目背景下，.dll 和 .exe 文件之间的基本区别是什么？
- en: In the context of C# and .NET, an `.exe` (`.exe` file, the program starts its
    execution. On the other hand, a `.dll` (**dynamic-link library**) file is a code
    library that doesn’t have a direct entry point but can be called by another program
    or application. It’s a means of code reuse among different projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 和 .NET 的上下文中，`.exe`（`.exe` 文件，程序开始执行。另一方面，`.dll`（**动态链接库**）文件是一个代码库，它没有直接的入口点，但可以被另一个程序或应用程序调用。它是不同项目之间代码重用的一种方式。
- en: How does the entry point of a program written in C# look?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 编写的程序的入口点是如何的？
- en: 'The entry point in a C# program is typically represented by the `Main()` method,
    which is located in the `Program` class. This method must be static and serves
    as the starting point for the program’s execution. Usually, its structure looks
    like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C# 程序的入口点通常由 `Main()` 方法表示，该方法位于 `Program` 类中。此方法必须是静态的，并作为程序执行的起点。通常，其结构如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `args` argument contains an array of strings that is passed to the program
    upon its launch.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`args` 参数包含一个字符串数组，该数组在程序启动时传递给程序。'
- en: How is memory management conducted in C#?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中是如何进行内存管理的？
- en: In C#, memory management is handled automatically thanks to the **garbage collector**
    mechanism. It automatically identifies objects that are no longer used by the
    program and frees the memory they occupy. While the garbage collector simplifies
    memory management, developers need to carefully manage unmanaged resources that
    are not controlled by the .NET garbage collector, such as database connections
    or file streams. If developers do not release these resources, they will persist
    for the lifetime of the application, potentially causing memory leaks and system
    strain.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，由于垃圾回收器机制，内存管理是自动处理的。它自动识别程序不再使用的对象，并释放它们占用的内存。虽然垃圾回收器简化了内存管理，但开发人员需要仔细管理不受
    .NET 垃圾回收器控制的非托管资源，例如数据库连接或文件流。如果开发人员不释放这些资源，它们将保持应用程序的生命周期，可能造成内存泄漏和系统压力。
- en: What are the principles of OOP in C#?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中面向对象编程（OOP）的原则是什么？
- en: 'OOP is based on four main principles: encapsulation, inheritance, polymorphism,
    and abstraction. In C#, this means the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程基于四个主要原则：封装、继承、多态性和抽象。在 C# 中，这意味着以下内容：
- en: '**Encapsulation** allows data and methods to be bundled into a unit (class)
    and restricts access to certain components.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**允许将数据和方法捆绑成一个单元（类），并限制对某些组件的访问。'
- en: '**Inheritance** permits one class (the child or derived class) to inherit the
    attributes and methods of another class (the parent or base class). This promotes
    the reuse of code and establishes a hierarchical relationship between classes.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法。这促进了代码的重用，并在类之间建立了层次关系。'
- en: '**Polymorphism** is the capability of a single function or method to work in
    various ways based on its inputs or on which object it is called upon. In C#,
    polymorphism can be achieved through method overriding, using the **override**
    keyword, and method hiding, utilizing the **new** keyword to hide a method in
    the base class.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**是指单个函数或方法根据其输入或被调用的对象以不同方式工作的能力。在 C# 中，可以通过方法重写实现多态性，使用 **override**
    关键字，以及通过使用 **new** 关键字隐藏基类中的方法来实现方法隐藏。'
- en: '**Abstraction** allows developers to hide complex implementations and show
    only the essential features of an object. This means that the user interacts with
    only what’s necessary and the internal workings are kept hidden. In C#, abstract
    classes and interfaces are tools that can help achieve abstraction.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**允许开发人员隐藏复杂的实现，只显示对象的必要功能。这意味着用户只与必要的部分交互，内部工作被隐藏。在 C# 中，抽象类和接口是帮助实现抽象的工具。'
- en: These principles help in designing robust and scalable applications, allowing
    for easy maintenance and further development. C# offers a rich set of features
    to implement and benefit from these principles effectively.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则有助于设计健壮和可扩展的应用程序，允许轻松维护和进一步开发。C# 提供了一组丰富的功能，以有效地实现并从这些原则中受益。
- en: How is error handling done in C#?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中是如何处理错误的？
- en: In C#, the primary error handling mechanism is based on the use of `try`, `catch`,
    `finally`, and `throw` constructs. When code in a `try` block causes an error,
    execution jumps to the corresponding `catch` block, where the exception is handled.
    The `finally` block, if present, is typically executed after `try/catch`, regardless
    of whether there was an exception or not. However, there are critical exceptions,
    such as `StackOverflowException` or `OutOfMemoryException`, which can result in
    a program crash and thus the `finally` block won’t be executed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，主要的错误处理机制基于 `try`、`catch`、`finally` 和 `throw` 构造的使用。当 `try` 块中的代码引发错误时，执行将跳转到相应的
    `catch` 块，在那里处理异常。如果存在，`finally` 块通常在 `try/catch` 之后执行，无论是否发生异常。然而，有一些关键异常，如 `StackOverflowException`
    或 `OutOfMemoryException`，可能导致程序崩溃，因此 `finally` 块将不会执行。
- en: What does the dependency injection principle mean and how is it implemented
    in C#?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入原则的含义是什么，如何在 C# 中实现？
- en: '**Dependency injection** (**DI**) is a software design approach that reduces
    tight coupling between system components. At the core of DI is the passing of
    dependencies (services, objects) to components rather than creating them inside
    those components. In C# and .NET, DI is often implemented using dependency containers,
    such as *Microsoft.Extensions.DependencyInjection*, *Ninject*, *Autofac*, and
    others.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）是一种软件设计方法，它减少了系统组件之间的紧密耦合。依赖注入的核心是将依赖（服务、对象）传递给组件，而不是在组件内部创建它们。在
    C# 和 .NET 中，依赖注入通常使用依赖容器来实现，例如 *Microsoft.Extensions.DependencyInjection*、*Ninject*、*Autofac*
    等。'
- en: What are boxing and unboxing in C#, and why can they be a problem?
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中的装箱和拆箱是什么，为什么它们可能成为问题？
- en: '`object` type or any interface type implemented by that value type. `object`
    type is converted back to the corresponding value type. The primary concern with
    boxing and unboxing in C# is their potential to degrade application performance.
    Boxing necessitates heap memory allocation and value type copying, thus slowing
    operations, especially with large datasets or in high-frequency scenarios. Unboxing,
    if incorrectly managed, can lead to runtime errors due to improper type casting,
    disrupting program execution. Additionally, these operations can increase the
    workload on the garbage collector, causing more frequent collection cycles and
    negatively impacting the application’s responsiveness.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`object` 类型或由该值类型实现的任何接口类型。`object` 类型将转换回相应的值类型。在 C# 中，装箱和拆箱的主要关注点是它们可能降低应用程序的性能。装箱需要堆内存分配和值类型复制，从而减慢操作，尤其是在大型数据集或高频场景中。如果管理不当，拆箱可能导致运行时错误，因为类型转换不正确，从而中断程序执行。此外，这些操作可能会增加垃圾回收器的负载，导致更频繁的收集周期，并负面影响应用程序的响应能力。'
- en: What does Entity Framework represent and how is it applied?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Entity Framework 代表什么，它是如何应用的？
- en: '**Entity Framework** (**EF**) is an **object-relational mapping** (**ORM**)
    framework developed by Microsoft for the .NET ecosystem. It enables developers
    to work with databases using object models instead of writing direct SQL code.
    This tool simplifies the process of creating and managing data models, automating
    database schema migrations, and writing queries that make database interaction
    more intuitive.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Entity Framework**（**EF**）是由 Microsoft 为 .NET 生态系统开发的 **对象关系映射**（**ORM**）框架。它允许开发者使用对象模型而不是直接编写
    SQL 代码来与数据库交互。这个工具简化了创建和管理数据模型、自动化数据库模式迁移以及编写使数据库交互更直观的查询的过程。'
- en: What’s the difference between threads and processes in C#?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中线程和进程有什么区别？
- en: In an operating system, a process is a distinct execution entity that has its
    own memory space. A thread is the smallest unit of execution within a process.
    Each process can have one or multiple threads. In C#, threads can be managed using
    the `Thread` class from the `System.Threading` namespace. The main difference
    lies in the fact that threads within a single process can share the same memory
    area, whereas each process has its own isolated memory context.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中，进程是一个具有自己内存空间的独立执行实体。线程是进程内的最小执行单元。每个进程可以有一个或多个线程。在 C# 中，可以使用 `System.Threading`
    命名空间中的 `Thread` 类来管理线程。主要区别在于，单个进程内的线程可以共享相同的内存区域，而每个进程都有自己的独立内存上下文。
- en: What are the main development environments used for C#, and are there alternatives
    to Visual Studio?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要用于 C# 的开发环境有哪些，Visual Studio 有没有替代品？
- en: 'The main IDE for C# is Visual Studio from Microsoft. However, there are alternatives,
    such as Visual Studio Code (a lightweight code editor with support for C# extensions)
    and JetBrains Rider. Each environment has its own benefits and features, and the
    choice depends on the specific needs of the developer:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的主要 IDE 是微软的 Visual Studio。然而，也有一些替代品，例如 Visual Studio Code（一个支持 C# 扩展的轻量级代码编辑器）和
    JetBrains Rider。每个环境都有其自身的优点和特性，选择取决于开发者的具体需求：
- en: '**Visual Studio**:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio**:'
- en: '*Features*: Comprehensive IDE with advanced tools for large-scale projects
    and multi-language support'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*特性*: 综合型 IDE，具有用于大型项目和多语言支持的先进工具'
- en: '*Use case*: Best suited for enterprise-level applications, offering a range
    of tools for collaborative and complex projects'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*: 最适合企业级应用，提供一系列用于协作和复杂项目的工具'
- en: '**Visual** **Studio Code**:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**:'
- en: '*Features*: Lightweight, open source code editor with a rich ecosystem of extensions,
    including C# support'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*特性*: 轻量级、开源代码编辑器，拥有丰富的扩展生态系统，包括对 C# 的支持'
- en: '*Use case*: Ideal for individual developers or small teams, providing a flexible
    and extensible environment for various languages and frameworks'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*: 适用于个人开发者或小型团队，提供灵活且可扩展的环境，支持各种语言和框架'
- en: '**JetBrains Rider**:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JetBrains Rider**:'
- en: '*Features*: Cross-platform .NET IDE with powerful tools for .NET development
    and a rich set of plugins'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*特性*: 跨平台 .NET IDE，具有强大的 .NET 开发工具和丰富的插件集'
- en: '*Use case*: Excellent for cross-platform development, offering consistent experiences
    and high-quality code analysis and refactoring tools'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*: 适用于跨平台开发，提供一致的经验和高质量的代码分析和重构工具'
- en: What programming patterns do you know, and which ones have you implemented in
    C#?
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你知道哪些编程模式，你在 C# 中实现了哪些？
- en: Programming patterns are proven solutions for common development challenges.
    They indicate the optimal way to implement a specific task. In C#, I often use
    patterns such as *Singleton*, *Factory*, *Observer*, *Strategy*, and *Decorator*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编程模式是针对常见开发挑战的经过验证的解决方案。它们表明实现特定任务的优化方式。在 C# 中，我经常使用如 *Singleton*、*Factory*、*Observer*、*Strategy*
    和 *Decorator* 等模式。
- en: Can you describe different software testing methods and their primary differences?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能描述不同的软件测试方法和它们的主要区别吗？
- en: 'There are several types of testing, including the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种测试类型，包括以下几种：
- en: '**Unit testing**: Focuses on individual pieces of code, particularly functions
    or methods'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**: 专注于单个代码片段，尤其是函数或方法'
- en: '**Integration testing**: Checks the interaction between different parts of
    the software'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**: 检查软件不同部分之间的交互'
- en: '**System testing**: Tests the entire system'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**: 测试整个系统'
- en: The main difference lies in the level of access and the scope of testing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于访问级别和测试范围。
- en: How do you determine the best time to conduct unit testing compared to integration
    or system testing?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你是如何确定进行单元测试的最佳时间，与集成测试或系统测试相比？
- en: Unit testing is best conducted during development when a specific component
    or function is being created or modified.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试最好在开发期间进行，当创建或修改特定组件或函数时。
- en: Integration testing should be applied after several components have been combined
    to verify their correct interaction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试应该在将几个组件组合在一起以验证它们正确交互之后应用。
- en: System testing should be applied when the entire product or a significant portion
    of it is ready for release.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试应该在整个产品或其重要部分准备发布时应用。
- en: What is NuGet, and how can it be used to add libraries to your project?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NuGet 是什么，它是如何用于向你的项目添加库的？
- en: '**NuGet** is a package manager for the .NET platform that allows developers
    to easily add, update, and remove external libraries and dependencies in their
    projects. To add an external library to a project through NuGet, you need to open
    the NuGet console in the development environment (e.g., in Visual Studio) or use
    its graphical interface, find the desired package, and install it.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**NuGet** 是 .NET 平台的包管理器，允许开发者轻松地向项目中添加、更新和删除外部库和依赖项。要通过 NuGet 向项目中添加外部库，你需要在开发环境（例如
    Visual Studio）中打开 NuGet 控制台或使用其图形界面，找到所需的包，并安装它。'
- en: Having mastered the essential concepts and principles of C#, you’ve already
    taken a significant step toward understanding this powerful programming language.
    But the journey doesn’t end here. Your next step is to delve into working with
    data types, variables, and operators in C#. Ready to continue? It’s time to dive
    even deeper!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了C#的基本概念和原则之后，你已经朝着理解这个强大的编程语言迈出了重要的一步。但旅程还没有结束。你的下一步是深入研究在C#中处理数据类型、变量和运算符。准备好继续了吗？现在是深入探索的时候了！
- en: Working with data types, variables, and operators in C#
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中处理数据类型、变量和运算符
- en: When diving into C#, it’s essential to grasp data types, variables, and operators—they’re
    the backbone of your applications. In this section, we’ll explore these foundational
    elements, paving the way for more advanced coding. Ready to solidify your understanding?
    Let’s dive in!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当深入研究C#时，掌握数据类型、变量和运算符是至关重要的——它们是您应用程序的骨架。在本节中，我们将探讨这些基础元素，为更高级的编码铺平道路。准备好巩固您的理解了吗？让我们深入探讨吧！
- en: What are the basic primitive data types in C#? What is the main difference between
    value type and reference type?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的基本原始数据类型是什么？值类型和引用类型之间的主要区别是什么？
- en: In C#, there are primitive data types, such as `int`, `float`, `double`, `char`,
    `bool`, `byte`, and others. The main difference between the *value* type and *reference*
    type lies in how they are stored and how their memory management. Value types
    are stored on the stack and directly contain their value, while reference types
    are stored in the heap and contain a reference to the object in memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，有原始数据类型，如`int`、`float`、`double`、`char`、`bool`、`byte`等。值类型和引用类型之间的主要区别在于它们的存储方式和内存管理。值类型存储在栈上，并直接包含其值，而引用类型存储在堆上，并包含对内存中对象的引用。
- en: What is the primary distinction between string and StringBuilder in the context
    of strings?
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在字符串的上下文中，字符串和StringBuilder之间的主要区别是什么？
- en: The `string` type in C# is immutable, meaning every time the string is modified,
    a new instance is created. On the other hand, `StringBuilder` is designed for
    efficiently modifying strings without the need to create numerous new instances.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`string`类型是不可变的，这意味着每次修改字符串时都会创建一个新的实例。另一方面，`StringBuilder`旨在高效地修改字符串，而无需创建多个新实例。
- en: How do you initialize and interact with one-dimensional and multidimensional
    arrays? What differentiates "string[][]" from "string[,]"?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何初始化和交互一维和多维数组？什么是“string[][]”与“string[,]”的区别？
- en: 'A one-dimensional array in C# is initialized like this: `int[] arr = new int[5];`.
    As for multidimensional arrays, `string[,]` is a two-dimensional array, while
    `string[][]` is an array of arrays, also known as a *jagged* array.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的一维数组初始化如下：`int[] arr = new int[5];`至于多维数组，`string[,]`是一个二维数组，而`string[][]`是数组的数组，也称为*锯齿*数组。
- en: What are bitwise operations and which operators in C# support these operations?
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算是什么？C#中的哪些运算符支持这些操作？
- en: Bitwise operations allow for manipulations at the level of individual bits of
    a numerical value. The primary bitwise operators in C# are `&` (*AND*), `|` (*OR*),
    `^` (*XOR*), and `~` (*NOT*).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算允许对数值的各个位进行操作。C#中的主要位运算符是`&`（*AND*）、`|`（*OR*）、`^`（*XOR*）和`~`（*NOT*）。
- en: What is the purpose of "nullable" types in C# and how do you work with them
    correctly?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的“可空”类型有什么作用，如何正确地使用它们？
- en: '`Nullable` types in C# allow representing an absent or uninitialized value
    for value types. They are typically used when there is a need to distinguish a
    *zero* value from the absence of a value. To check for the presence of a value,
    you can use the `HasValue` property, and to retrieve the value itself, you use
    `Value`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`Nullable`类型允许表示值类型的缺失或未初始化的值。它们通常用于需要区分*零*值和值缺失的情况。要检查值的存在，可以使用`HasValue`属性，要检索值本身，则使用`Value`。
- en: What is known about operator overloading in C# and why can it be useful?
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于C#中的运算符重载你知道些什么？为什么它可能很有用？
- en: Operator overloading allows defining the actions of operators for user-defined
    data types, such as classes. This can be useful, for instance, for easy manipulation
    of complex numbers, vectors, or other mathematical structures.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载允许为用户定义的数据类型（如类）定义运算符的操作。例如，这可以用于轻松操作复数、向量或其他数学结构。
- en: How can one overload an operator in C# and could you provide an example?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中如何重载运算符，你能提供一个例子吗？
- en: In C#, operator overloading allows you to redefine the way built-in operators
    work for user-defined types such as classes and structs. To overload an operator,
    you define a static method in your class or struct with the `operator` keyword
    followed by the operator symbol you want to overload. The method must return a
    result and take at least one parameter of the type you’re overloading the operator
    for.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，运算符重载允许你重新定义内置运算符对用户定义类型（如类和结构体）的工作方式。要重载运算符，你需要在你的类或结构体中定义一个静态方法，使用`operator`关键字后跟你要重载的运算符符号。该方法必须返回一个结果，并至少接受一个参数，该参数是你正在重载运算符的类型。
- en: 'Here’s a simple example of overloading the `+` operator for a custom `Vector`
    class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个重载自定义`Vector`类中`+`运算符的简单示例：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How do comparison and relational operators work in C#?
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的比较和关系运算符是如何工作的？
- en: Comparison (`==`, `!=`) and relational (`<`, `>`, `<=`, `>=`) operators are
    used to compare two values. It’s important to remember that when comparing reference
    types, the `==` operator checks for reference equality, not content.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符（`==`, `!=`）和关系运算符（`<`, `>`, `<=`, `>=`）用于比较两个值。重要的是要记住，当比较引用类型时，`==`运算符检查引用相等性，而不是内容。
- en: What is the purpose of logical operators in C#, how do they function, and why
    is it important to pay attention to operator precedence?
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的逻辑运算符的目的是什么？它们是如何工作的？为什么要注意运算符优先级？
- en: Logical operators, such as `&&` (*logical “and”*), `||` (*logical “or”*), and
    `!` (*logical negation*), are used for combined logical conditions. It’s important
    to know operator precedence as it affects the order of operations. For example,
    the expression `A && B || C` will be interpreted as `(A && B) || C`, not `A &&
    (B || C)`, which can lead to different results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符，如`&&`（逻辑“与”），`||`（逻辑“或”），和`!`（逻辑否定），用于组合逻辑条件。了解运算符优先级很重要，因为它会影响运算的顺序。例如，表达式`A
    && B || C`将被解释为`(A && B) || C`，而不是`A && (B || C)`，这可能导致不同的结果。
- en: When and why should you use “const” variables in C#? What’s the difference between
    them and “readonly”?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在什么情况下以及为什么应该使用C#中的“const”变量？它们与“readonly”有什么区别？
- en: '`const` variables should be used when you need to define a variable that doesn’t
    change throughout the program’s life cycle. They must have a value assigned at
    compile time. On the other hand, `readonly` can be initialized in a class constructor
    and ensure that its value cannot be changed afterward.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要定义一个在整个程序生命周期中不改变的变量时，应该使用`const`变量。它们必须在编译时分配一个值。另一方面，`readonly`可以在类构造函数中初始化，并确保其值之后不能被更改。
- en: Which method of object comparison in C# is better to use, “==” or “Equals()”,
    and why?
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中，哪种对象比较方法更好用，“==”还是“Equals()”，以及为什么？
- en: For value types, `==` and `Equals()` usually work the same way, but for reference
    types, `==` checks for reference equality, not content. `Equals()` can be overridden
    for custom classes to ensure content-based comparison. As a rule, if you want
    to compare the content of objects, it’s better to use `Equals()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于值类型，`==`和`Equals()`通常以相同的方式工作，但对于引用类型，`==`检查引用相等性，而不是内容。`Equals()`可以被自定义类重写以确保基于内容的比较。一般来说，如果你想比较对象的内容，最好使用`Equals()`。
- en: What’s the primary distinction between “is” and “as” when converting types in
    C#?
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中将类型转换为“is”和“as”时，主要区别是什么？
- en: '`is` checks whether an object is an instance of a certain type and returns
    a Boolean value. `as` is used for safe type casting and will return `null` if
    the conversion is not possible, rather than throwing an exception.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`检查一个对象是否是特定类型的实例，并返回一个布尔值。`as`用于安全类型转换，如果转换不可行，将返回`null`，而不是抛出异常。'
- en: What do explicit and implicit type conversions mean in C#?
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的显式类型转换和隐式类型转换是什么意思？
- en: Implicit-type conversion happens automatically when a data type that can hold
    less information is converted to one that can hold more (for example, from `int`
    to `double`). Explicit-type conversion (casting) is required when there’s a risk
    of data loss during the conversion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型转换在将可以存储较少信息的数据类型转换为可以存储更多信息的数据类型时自动发生（例如，从`int`到`double`）。显式类型转换（类型转换）在转换过程中有数据丢失风险时是必需的。
- en: What is the purpose of the "??" operator in C# and in which scenarios should
    it be used?
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的“??”运算符的目的是什么？在哪些场景下应该使用它？
- en: The `??` operator is a null-coalescing operator that returns the left operand
    if it’s not `null`; otherwise, it returns the right one. It’s useful for setting
    default values for potentially `null` values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`??`运算符是一个空合并运算符，如果左操作数不是`null`，则返回左操作数；否则，返回右操作数。它对于设置可能为`null`的值的默认值非常有用。'
- en: What are tuples, how are they used in C#, and what are their advantages compared
    to classes?
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组是什么，它们在C#中如何使用，与类相比它们有哪些优势？
- en: Tuples in C# are ordered collections of various types. They are useful for representing
    datasets without creating specific types. Compared to classes, tuples are typically
    lighter and more convenient for small, temporary datasets.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的元组是有序的各种类型的集合。它们用于表示数据集，而无需创建特定的类型。与类相比，元组通常更轻便，对于小型、临时数据集来说更加方便。
- en: In this section, we delved into the core components of C#—data types, variables,
    and operators, which form the backbone of any C# application. We explored the
    differences between value and reference types and examined string manipulations,
    alongside the initialization and handling of various arrays. We also discussed
    the role of bitwise and logical operators, the use of nullable types, and the
    principles of operator overloading. We touched upon important topics such as object
    comparison methods, type conversions, and the advantages of using tuples for compact
    data representation. With this solid foundation, we are ready to advance to the
    next section, *Writing control structures and loops in C#*, to further enhance
    our programming skills.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了C#的核心组件——数据类型、变量和运算符，它们构成了任何C#应用程序的骨架。我们探讨了值类型和引用类型之间的差异，并检查了字符串操作，以及各种数组的初始化和处理。我们还讨论了位运算符和逻辑运算符的作用，可空类型的用法，以及运算符重载的原则。我们还触及了对象比较方法、类型转换以及使用元组进行紧凑数据表示的优势等重要主题。有了这个坚实的基础，我们准备进入下一节，*在C#中编写控制结构和循环*，以进一步提高我们的编程技能。
- en: Writing control structures and loops in C#
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中编写控制结构和循环
- en: Control structures and loops are fundamental elements of any program, allowing
    developers to efficiently manage the flow of code execution. In the C# language,
    there is a variety of powerful tools for this purpose. In this section, we will
    delve into various control structures, such as conditional statements and selection,
    as well as key concepts of looping through data using different types of loops.
    Through an in-depth study of these elements, you’ll gain a solid foundation for
    writing efficient and structured code in C#. Let’s begin!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构和循环是任何程序的基本元素，允许开发者高效地管理代码执行的流程。在C#语言中，有各种强大的工具用于此目的。在本节中，我们将深入研究各种控制结构，如条件语句和选择，以及使用不同类型的循环通过数据循环的关键概念。通过深入研究这些元素，你将获得编写高效和结构化代码的坚实基础。让我们开始吧！
- en: What are the main loops available in C# and how do you choose the best loop
    for a specific situation?
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中有哪些主要的循环类型，以及如何为特定情况选择最佳的循环？
- en: 'In C#, several types of loops are available: `for`, `foreach`, `while`, and
    `do-while`. Let’s look at each of them:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，有几种循环类型可用：`for`、`foreach`、`while`和`do-while`。让我们逐一看看它们：
- en: '**for**: This is the most commonly used loop when you know the number of iterations
    beforehand.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for**: 当你事先知道迭代次数时，这是最常用的循环。'
- en: '**foreach**: This type of loop is perfect for iterating through collections
    or arrays when you need to work with each element sequentially.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**foreach**: 此类循环非常适合在需要按顺序处理每个元素时遍历集合或数组。'
- en: '**while**: This loop executes as long as the specified condition is true. It’s
    useful when you don’t know the number of iterations beforehand.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**while**: 当指定的条件为真时，此循环会一直执行。当你事先不知道迭代次数时，它非常有用。'
- en: '**do-while**: This loop is similar to **while**, but the condition is checked
    after executing the loop body, ensuring the loop body is executed at least once.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**do-while**: 此循环与**while**类似，但条件是在执行循环体之后检查的，确保循环体至少执行一次。'
- en: Choosing the best loop depends on the specific situation. If you need to iterate
    over all elements of a collection, `foreach` would be the most convenient. If
    you know the number of iterations, `for` would be the most efficient. In cases
    where you don’t know the number of iterations in advance, you can use `while`
    or `do-while`, depending on whether you want the loop body to execute at least
    once or not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最佳循环取决于具体的情况。如果你需要遍历集合中的所有元素，`foreach` 将是最方便的。如果你知道迭代次数，`for` 将是最高效的。在不知道迭代次数的情况下，你可以使用
    `while` 或 `do-while`，这取决于你是否希望循环体至少执行一次。
- en: How do you use the “if”, “else if”, and “else” operators in C#? In which situations
    would you recommend using each of them?
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何在 C# 中使用 “if”，“else if”，和 “else” 操作符？在哪些情况下你会推荐使用它们？
- en: The `if`, `else if`, and `else` operators are used for conditional code execution.
    `if` checks a condition and, if it’s `true`, executes the code block following
    it. `else if` allows you to check additional conditions if the previous conditions
    were `false`. `else` executes a code block when none of the previous conditions
    were met. Use `if` to check a single primary condition, `else if` to check additional
    conditions, and `else` as a fallback code block to execute.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`，`else if`，和 `else` 操作符用于条件代码执行。`if` 检查一个条件，如果它是 `true`，则执行其后的代码块。`else
    if` 允许你在前面的条件为 `false` 时检查额外的条件。`else` 在没有满足前面的条件时执行代码块。使用 `if` 检查单个主要条件，`else
    if` 检查额外条件，`else` 作为后备代码块执行。'
- en: What’s the difference between “for” and “foreach” loops? In which cases is it
    better to use each?
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “for” 循环和 “foreach” 循环有什么区别？在哪些情况下使用每个更好？
- en: The `for` loop is used when you know in advance how many times you need to execute
    the loop. The `foreach` loop is designed for iterating over collections, such
    as lists or arrays. Use `for` when you have a specific number of iterations, and
    `foreach` when you need to iterate over all elements in a collection.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环用于你知道需要执行循环多少次的情况。`foreach` 循环设计用于遍历集合，如列表或数组。当你有一个特定的迭代次数时使用 `for`，当你需要遍历集合中的所有元素时使用
    `foreach`。'
- en: What is the “switch” operator and how is it different from a sequence of “if-else”
    operators?
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “switch” 操作符是什么，它与一系列的 “if-else” 操作符有何不同？
- en: The `switch` operator allows you to check a variable against multiple values.
    It is more compact and often more convenient for checking the values of a single
    variable. An `if-else` sequence, on the other hand, offers more flexibility as
    it can check different conditions, not being limited to just one variable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 操作符允许你将一个变量与多个值进行比较。它更紧凑，通常更方便用于检查单个变量的值。另一方面，`if-else` 序列提供了更多的灵活性，因为它可以检查不同的条件，而不仅仅是一个变量。'
- en: What do the “continue” and “break” operators do in loops, and when can they
    be useful?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “continue” 和 “break” 操作符在循环中做什么，它们在什么情况下可能有用？
- en: '`continue` skips the current loop iteration and proceeds to the next one. `break`
    exits the loop prematurely. `continue` is useful when some loop iterations need
    to be skipped, and `break` when you need to terminate the loop execution under
    a certain condition.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 跳过当前循环迭代并继续下一个。`break` 提前退出循环。`continue` 在需要跳过某些循环迭代时很有用，而 `break`
    在需要根据某些条件终止循环执行时很有用。'
- en: How do you combine multiple conditions in a single “if” statement using logical
    operators?
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用逻辑运算符在单个 “if” 语句中组合多个条件？
- en: You can use logical operators `&&` (*logical “and”*) and `||` (*logical “or”*)
    to combine multiple conditions, for example, `if (x > 5 && y <` `10) {...}`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用逻辑运算符 `&&`（逻辑“与”）和 `||`（逻辑“或”）来组合多个条件，例如，`if (x > 5 && y < 10) {...}`。
- en: What is the peculiarity of the “do-while” loop compared to the regular “while”
    loop?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与常规的 “while” 循环相比，“do-while” 循环有什么特殊性？
- en: The primary difference is that in the `do-while` loop, the condition is checked
    after the loop body is executed, ensuring that the loop body runs at least once,
    regardless of the condition.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于在 `do-while` 循环中，条件是在循环体执行之后检查的，确保循环体至少运行一次，无论条件如何。
- en: What does a nested loop look like and why can it be useful?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套循环是什么样的，为什么它可能有用？
- en: 'A nested loop is a loop placed inside another loop. It is often used for processing
    a two-dimensional array or matrix. See the following for an example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环是将一个循环放置在另一个循环内部。它通常用于处理二维数组或矩阵。以下是一个示例：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How can you prevent a potentially infinite loop execution?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何防止潜在的无限循环执行？
- en: To prevent an infinite loop, it’s crucial to ensure that a loop termination
    condition will be met. This can be done by checking conditions before entering
    the loop, using execution time limiters, or through internal counters and monitoring
    tools.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止无限循环，确保循环终止条件会被满足是至关重要的。这可以通过在进入循环前检查条件、使用执行时间限制器或通过内部计数器和监控工具来实现。
- en: What is recursion in C# and how do you prevent stack overflow when using recursive
    methods?
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的递归是什么，以及如何在使用递归方法时防止栈溢出？
- en: Recursion is a technique where a method calls itself. To prevent stack overflow,
    it’s important to have a clear base case that will halt the recursive calls and
    to limit the recursion depth.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种方法调用自身的技术。为了防止栈溢出，重要的是要有明确的基例来终止递归调用，并限制递归深度。
- en: How can you optimize a loop for processing a large amount of data in C#?
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在C#中优化循环以处理大量数据？
- en: To optimize a loop, you can use parallelism, employ efficient data structures,
    reduce the number of operations within the loop, and utilize caching where possible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化循环，你可以使用并行处理、采用高效的数据结构、减少循环内的操作数量，并在可能的情况下利用缓存。
- en: What is “yield return” in C# and when can it be useful?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的“yield return”是什么，何时可以使用它？
- en: '`yield return` allows you to create iterators without the need to generate
    an auxiliary collection. It’s useful when you want to lazily generate values as
    you iterate through a collection.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield return`允许你创建迭代器，而无需生成辅助集合。当你想要在遍历集合时懒加载值时，这非常有用。'
- en: How do you create an infinite loop using “for”?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用“for”创建无限循环？
- en: 'An infinite loop can be created using `for` in the following manner:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方式使用`for`创建无限循环：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the condition, initialization, and increment are absent, so the loop will
    run indefinitely.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，条件、初始化和增量都是缺失的，因此循环将无限运行。
- en: In this section, we explored control structures and loops, essential tools for
    dictating the flow of code in C#. We discussed various loop types, such as `for`,
    `foreach`, `while`, and `do-while`, highlighting how to select the appropriate
    one depending on the task at hand. We also covered the usage and applications
    of conditional operators `if`, `else if`, and `else`. We examined the efficiency
    of the `switch` operator compared to that of a chain of `if-else` statements,
    and the roles of `continue` and `break` operators within loops. With this foundation,
    we are now prepared to delve into more advanced topics.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了控制结构和循环，这是决定代码流程的基本工具。我们讨论了各种循环类型，如`for`、`foreach`、`while`和`do-while`，强调了根据任务选择合适的循环类型。我们还涵盖了`if`、`else
    if`和`else`条件运算符的用法和应用。我们比较了`switch`运算符与一系列`if-else`语句的效率，并探讨了`continue`和`break`运算符在循环中的作用。有了这个基础，我们现在准备深入更高级的主题。
- en: Exploring the basics of OOP using C#
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索使用C#的OOP基础知识
- en: In this section, we turn our focus toward the basics of OOP using C#. As we
    venture further, we will unravel the core principles of OOP, a paradigm that facilitates
    organized and reusable code. Through C#, we will explore key OOP concepts such
    as classes, objects, inheritance, and polymorphism, fostering a deeper understanding
    and equipping you with the skills to craft robust and efficient applications.
    Let’s embark on this enlightening journey.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注使用C#的OOP基础知识。随着我们进一步探索，我们将揭示OOP的核心原则，这是一种促进有组织和可重用代码的范式。通过C#，我们将探索诸如类、对象、继承和多态等关键OOP概念，加深你的理解，并为你提供构建健壮和高效应用程序的技能。让我们开始这段启发性的旅程。
- en: How does C# integrate the principles of OOP?
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#是如何整合OOP原则的？
- en: 'C# supports all the core principles of OOP: *encapsulation*, *inheritance*,
    *polymorphism*, and *abstraction*. For instance, classes and interfaces in C#
    allow for the implementation of inheritance and polymorphism, while access modifiers
    facilitate encapsulation.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持所有核心的面向对象编程（OOP）原则：*封装*、*继承*、*多态*和*抽象*。例如，C#中的类和接口允许实现继承和多态，而访问修饰符则有助于封装。
- en: How does encapsulation work in C#?
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的封装是如何工作的？
- en: In C#, encapsulation is ensured through access modifiers such as `private`,
    `protected`, and `public`. These modifiers determine the visibility of class members,
    allowing for the hiding of implementation details and exposing only the necessary
    API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，封装通过`private`、`protected`和`public`等访问修饰符来确保。这些修饰符决定了类成员的可见性，允许隐藏实现细节，仅暴露必要的API。
- en: How is polymorphism implemented in C#?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中多态是如何实现的？
- en: Polymorphism in C# is realized through the ability to override methods in subclasses
    using the `virtual` and `override` keywords, as well as through interfaces that
    allow different classes to have a consistent set of methods.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的多态是通过使用`virtual`和`override`关键字在子类中覆盖方法的能力，以及通过允许不同类具有一致方法集的接口来实现的。
- en: What does inheritance entail in C#?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的继承包含哪些内容？
- en: Inheritance in C# allows for the creation of a new class based on an existing
    one, inheriting its attributes and behavior. This is achieved using the `:` keyword,
    followed by the name of the base class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的继承允许基于现有类创建一个新的类，继承其属性和行为。这是通过使用冒号`:`，后跟基类名称来实现的。
- en: What is the difference between a class and its instance in C#?
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中类与其实例之间的区别是什么？
- en: A class serves as a schematic or prototype that delineates the characteristics
    and functions of objects. An object (or instance of a class) is a specific representation
    of that class with a unique set of attribute values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类充当一个示意图或原型，它定义了对象的特征和功能。一个对象（或类的实例）是该类的一个特定表示，具有一组独特的属性值。
- en: Why are access modifiers such as “public”, “private”, “protected”, and “internal”
    used in C#?
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么在C#中使用诸如“public”、“private”、“protected”和“internal”之类的访问修饰符？
- en: These modifiers determine the level of access to class members. `public` makes
    a member accessible to any code; `private` restricts access to only the methods
    of the given class; `protected` allows access to the given class and its descendants,
    and `internal` makes a member accessible to any code within the same assembly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修饰符决定了类成员的访问级别。`public`使成员对任何代码都可用；`private`仅限制对给定类的方法的访问；`protected`允许对给定类及其派生类进行访问，而`internal`使成员对同一程序集内的任何代码都可用。
- en: Can a class in C# inherit from multiple other classes simultaneously?
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的类能否同时从多个其他类继承？
- en: No, C# does not support multiple inheritance for classes. However, a class can
    implement multiple interfaces.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不，C#不支持类的多重继承。然而，一个类可以实现多个接口。
- en: How do method overloading and method overriding differ in C#?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中方法重载和方法重写有何不同？
- en: Method overloading allows having multiple versions of a single method in one
    class with different parameters. Method overriding allows a subclass to replace
    the implementation of a method provided by its base class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载允许在一个类中拥有多个具有不同参数的单个方法版本。方法重写允许子类替换其基类提供的方法的实现。
- en: What are the main differences between interfaces and base classes in C#?
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中接口和基类的主要区别是什么？
- en: Interfaces define a contract (a set of methods without implementation) that
    must be adhered to by the class that implements it. Base classes contain an implementation
    that can be inherited and extended. A class can inherit only one base class but
    can implement multiple interfaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了一个合同（一组没有实现的方法），实现它的类必须遵守。基类包含可以继承和扩展的实现。一个类只能继承一个基类，但可以实现多个接口。
- en: Why is composition sometimes considered a better choice than inheritance?
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么组合有时被认为比继承更好？
- en: Composition offers greater flexibility, allowing dynamic changes to an object’s
    behavior on the fly, and reduces the risk of issues associated with tight coupling
    between classes. It also promotes the principle of *composition over inheritance*,
    suggesting that using composition for the reusability of code is a more desirable
    approach.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 组合提供了更大的灵活性，允许在运行时动态更改对象的行为，并减少了与类之间紧密耦合相关的问题风险。它还促进了*组合优于继承*的原则，即使用组合来提高代码的可重用性是一种更可取的方法。
- en: What are properties in C# and how do they differ from fields?
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的属性是什么，它们与字段有何不同？
- en: Properties are a special kind of class member in C# that represents access to
    data with the ability to define logic when reading or writing that data. They
    allow you to control access to internal fields and can contain additional logic,
    for instance, for validation. Fields, on the other hand, are variables defined
    in the class and are used to store data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是C#中的一种特殊类成员，它代表了对数据的访问，并能够在读取或写入该数据时定义逻辑。它们允许您控制对内部字段的访问，并且可以包含额外的逻辑，例如验证。另一方面，字段是在类中定义的变量，用于存储数据。
- en: What’s the main difference between abstract classes and interfaces in C#?
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中抽象类和接口的主要区别是什么？
- en: Abstract classes can contain methods both with and without implementation. They
    cannot be instantiated directly. Interfaces only contain method declarations without
    implementation. A class can implement multiple interfaces but can inherit only
    one abstract class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以包含有和没有实现的方法。它们不能直接实例化。接口只包含没有实现的方法声明。一个类可以实现多个接口，但不能继承多个抽象类。
- en: Why is encapsulating fields important for the SOLID principles?
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么封装字段对于SOLID原则很重要？
- en: Encapsulation helps keep the internal state of an object protected and hidden
    from the external world, which supports adherence to the *Open/Closed Principle*
    of SOLID. It also helps prevent unwanted state changes that could violate the
    *Single* *Responsibility Principle*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 封装有助于保护对象的内部状态，使其对外部世界隐藏，这支持遵循SOLID原则的*开放/封闭原则*。它还有助于防止可能违反*单一责任原则*的不希望的状态变化。
- en: What is the role of delegates in OOP in the context of C#?
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#的面向对象编程（OOP）中，代表者的角色是什么？
- en: Delegates in C# are objects that can point to methods. They allow for the realization
    of the function pointers concept in a type-safe manner. Delegates are often used
    to implement events and callbacks.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的代表者是指向方法的对象。它们以类型安全的方式实现了函数指针的概念。代表者通常用于实现事件和回调。
- en: How are constructors used for object initialization and how do they differ from
    static constructors?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数是如何用于对象初始化的，它们与静态构造函数有何不同？
- en: Constructors help initialize an object at the time of its creation, setting
    the necessary state or performing any other required setup. Static constructors
    are used to initialize static members of a class or to perform actions that should
    occur only once for the class, not for each individual object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数有助于在对象创建时初始化对象，设置必要的状态或执行任何其他所需的设置。静态构造函数用于初始化类的静态成员或执行仅对类而不是每个单个对象应发生一次的操作。
- en: What do aggregation and association mean in OOP, and how are they implemented
    in C#?
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在OOP中，聚合和关联的含义是什么，它们在C#中是如何实现的？
- en: '**Aggregation** and **association** represent two distinct relationships between
    classes within the OOP paradigm. Association denotes a broader connection between
    two classes, indicating that one class incorporates the other.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合**和**关联**代表了在OOP范式中类之间两种不同的关系。关联表示两个类之间更广泛的关系，表明一个类包含另一个类。'
- en: 'Let me show some examples of how they are implemented:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我展示一些它们是如何实现的示例：
- en: 'Association is a bi-directional relationship between two classes. Here, we
    demonstrate a one-to-many association between a **Library** class and a **Book**
    class:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联是两个类之间的双向关系。在这里，我们演示了**图书馆**类和**书籍**类之间的一对多关联：
- en: '[PRE4]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, the `Library` class has a list of `Book` objects, illustrating
    a one-to-many association.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Library`类有一个`Book`对象的列表，说明了一对一的关联。
- en: 'Aggregation represents a relationship where one class is a part of another
    class. Here, we illustrate an aggregation between a **Car** class and an **Engine**
    class:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合表示一个类是另一个类的部分的关系。在这里，我们展示了**汽车**类和**引擎**类之间的聚合关系：
- en: '[PRE16]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, the `Car` class contains an `Engine` object, demonstrating
    an aggregation relationship where the `Engine` class represents a part of the
    `Car` class.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，`Car`类包含一个`Engine`对象，展示了聚合关系，其中`Engine`类代表`Car`类的一部分。
- en: Through these examples, we can see how both association and aggregation relationships
    can be implemented in C# using class properties and constructors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，我们可以看到如何在C#中使用类属性和构造函数实现关联和聚合关系。
- en: How can multiple inheritance be implemented in C# if there is no direct support?
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果C#没有直接支持，如何实现多重继承？
- en: In C#, there’s no direct support for multiple inheritance. However, multiple
    inheritance can be realized using interfaces. A class can implement multiple interfaces
    that may come from different sources.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，没有直接的多重继承支持。然而，可以通过接口实现多重继承。一个类可以实现来自不同来源的多个接口。
- en: What does the principle of “composition over inheritance” mean and when is it
    useful?
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “组合优于继承”的原则是什么意思，它在什么时候有用？
- en: '**Composition** over **inheritance** is a software design approach that encourages
    the use of composition (where objects utilize other objects) over inheritance
    for code reusability. It can be useful when a class’s behavior requires dynamic
    changes or when inheritance might lead to undesired rigid coupling between classes.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**优于**继承**是一种软件设计方法，它鼓励使用组合（对象利用其他对象）而不是继承来实现代码重用。当类的行为需要动态变化或继承可能导致类之间不希望出现的刚性耦合时，这可能很有用。'
- en: Why are exceptions in C# considered objects, and how do you create your own
    exception class?
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么 C# 中的异常被认为是对象，以及你如何创建自己的异常类？
- en: In C#, exceptions are implemented as objects that inherit from the base `Exception`
    class. This allows for passing additional information about the exception and
    creating custom exception types. To create your own exception class, simply inherit
    it from the `Exception` class or one of its subclasses.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，异常被实现为继承自基类 `Exception` 的对象。这允许传递有关异常的附加信息，并创建自定义异常类型。要创建自己的异常类，只需从 `Exception`
    类或其子类继承即可。
- en: What is the purpose of the “base” keyword in the context of inheritance in C#?
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 继承的上下文中，“base” 关键字有什么作用？
- en: The `base` keyword allows you to call members from the base class when in a
    derived class. It is most commonly used in derived classes to call the constructor
    of the base class or to access other base class members that were overridden in
    the derived class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`base` 关键字允许你在派生类中调用基类的成员。它最常用于派生类中调用基类的构造函数或访问在派生类中被覆盖的其他基类成员。'
- en: How is the “this” keyword used in C#?
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 中，“this” 关键字是如何使用的？
- en: The `this` keyword points to the present instance of the class. It is often
    used to point to the fields or methods of the current object, especially when
    method parameter names overlap with class field names.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 关键字指向类的当前实例。它通常用于指向当前对象的字段或方法，尤其是在方法参数名称与类字段名称重叠时。'
- en: We’ve reached the end of our journey through the basics of C# and OOP in this
    chapter. With a strong foundation established, you’re well-equipped to tackle
    the most common C# coding scenarios in your technical interviews.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中完成了对 C# 和面向对象编程基础的探索之旅。在建立了坚实的基础后，你将准备好应对技术面试中最常见的 C# 编码场景。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dove deep into key concepts, explored data types, variables,
    and operators, dissected control structures and loops, and discovered the basics
    of OOP. However, becoming proficient in C# is a continuous learning journey.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了关键概念，研究了数据类型、变量和运算符，分析了控制结构和循环，并发现了面向对象编程的基础。然而，精通 C# 是一个持续的学习过程。
- en: As we turn the page, we’ll start navigating the more advanced terrain of C#
    programming in the next chapter. [*Chapter 4*](B20871_04.xhtml#_idTextAnchor127),
    *Advanced C# Concepts*, will bring light to the advanced facets of C#, including
    working with collections, LINQ, exception handling, debugging, asynchronous programming,
    and a lot more.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们翻过这一页，我们将在下一章开始探索 C# 编程的更高级领域。[*第 4 章*](B20871_04.xhtml#_idTextAnchor127)，*高级
    C# 概念*，将揭示 C# 的高级特性，包括处理集合、LINQ、异常处理、调试、异步编程以及更多。
- en: We will unravel the complexities of C# and learn how to make the best use of
    its capabilities to solve more intricate problems and enhance application performance.
    From creating reusable code with generic classes, methods, and interfaces to diving
    deep into multithreading and garbage collection, we’ll gear you up for a higher
    level of programming challenges. Remember, each concept is a stepping stone, leading
    you to master the art of C# programming. So, buckle up for the next exciting chapter
    in your learning journey!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将揭开 C# 的复杂性，学习如何充分利用其功能来解决更复杂的问题并提高应用程序性能。从使用泛型类、方法和接口创建可重用代码，到深入多线程和垃圾回收，我们将为你提供应对更高层次编程挑战的准备。记住，每个概念都是一块垫脚石，引领你掌握
    C# 编程的艺术。所以，系好安全带，准备开始你学习旅程中的下一章精彩内容！
- en: Additional reading
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外阅读
- en: '*C# 12 and .NET 8 – Modern Cross-Platform Development Fundamentals - Eighth
    Edition,* by Mark J. Price'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C# 12 和 .NET 8 – 现代跨平台开发基础 - 第八版》，作者：马克·J·普赖斯*'
- en: '[https://www.packtpub.com/product/c-12-and-net-8-modern-cross-platform-development-fundamentals-eighth-edition/9781837635870](https://www.packtpub.com/product/c-12-and-net-8-modern-cross-platform-development-fundamentals-eighth-edition/9781837635870)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[C# 12 和 .NET 8 现代跨平台开发基础第八版](https://www.packtpub.com/product/c-12-and-net-8-modern-cross-platform-development-fundamentals-eighth-edition/9781837635870)'
- en: '*Refactoring with C#,* by Matt Eland'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 C# 代码重构》*，作者：Matt Eland'
- en: '[https://www.packtpub.com/product/refactoring-with-c/9781835089989](https://www.packtpub.com/product/refactoring-with-c/9781835089989)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[使用 C# 代码重构](https://www.packtpub.com/product/refactoring-with-c/9781835089989)'
