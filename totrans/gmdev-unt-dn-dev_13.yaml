- en: '*Chapter 10*: Serialization System and Assets Management in Unity and Azure'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：Unity 和 Azure 中的序列化系统与资产管理'
- en: In the last chapter, [*Chapter 9*](B17146_09_Final_ASB_ePub.xhtml#_idTextAnchor165),
    *Using Data-Oriented Technology Stack in Unity*, we learned what the data-oriented
    technology stack is and how you can use this technology to take advantage of multicore
    processors to improve the performance of your game. In this chapter, we will cover
    some other important topics in Unity development, namely, **serialization** and
    **asset management** in Unity. Usually, a game not only has code but also consists
    of many different kinds of assets, such as models, textures, and audio. Hence,
    understanding what the serialization system in Unity is and what the assets workflow
    is can help you better develop games with Unity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，[*第 9 章*](B17146_09_Final_ASB_ePub.xhtml#_idTextAnchor165)，*在 Unity 中使用面向数据的技术堆栈*，我们学习了什么是面向数据的技术堆栈以及如何使用这项技术利用多核处理器来提高您游戏的表现力。在本章中，我们将介绍
    Unity 开发中的其他一些重要主题，即 Unity 中的 **序列化**和**资产管理**。通常，一个游戏不仅包含代码，还由许多不同类型的资产组成，如模型、纹理和音频。因此，了解
    Unity 中的序列化系统以及资产工作流程可以帮助您更好地使用 Unity 开发游戏。
- en: In the last section of this chapter, we will also explore an interesting topic
    – how to use the **Azure Cloud storage** services to host the content of a Unity
    game and load the content from the Azure Cloud to the Unity game by using Unity's
    **Addressable Assets system**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们还将探讨一个有趣的话题——如何使用 **Azure 云存储**服务来托管 Unity 游戏的内容，并通过使用 Unity 的 **可寻址资产系统**从
    Azure 云将内容加载到 Unity 游戏中。
- en: 'The following key topics will be included in our learning path:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关键主题将包含在我们的学习路径中：
- en: Serialization system in Unity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 中的序列化系统
- en: The Assets workflow in Unity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 中的资产工作流程
- en: Introducing the special folders in Unity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Unity 中的特殊文件夹
- en: Azure Blob storage with Unity's Addressable Assets system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Unity 的可寻址资产系统与 Azure Blob 存储结合
- en: By the end of this chapter, you will not only understand the serialization system
    and assets management in Unity, but you will also be familiar with Azure Cloud
    storage services.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您不仅将了解 Unity 中的序列化系统和资产管理，还将熟悉 Azure 云存储服务。
- en: Sounds exciting!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很激动！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Since this chapter will be covering Azure''s Storage account service, if you
    don''t have an Azure account available, I recommend you set up a free Azure trial
    account first before starting this chapter. You can click the following link to
    create a free Azure trial account with $200 credit:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章将涵盖 Azure 的存储账户服务，如果您没有可用的 Azure 账户，我建议您在开始本章之前先设置一个免费的 Azure 试用账户。您可以通过以下链接创建一个带有
    200 美元信用额的免费 Azure 试用账户：
- en: '[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)'
- en: '![Figure 10.1 – Microsoft Azure page'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.1 – Microsoft Azure 页面'
- en: '](img/Figure_10.01_B17146.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.01_B17146.jpg](img/Figure_10.01_B17146.jpg)'
- en: Figure 10.1 – Microsoft Azure page
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.1 – Microsoft Azure 页面
- en: Now, let's get started!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: Serialization system in Unity
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 中的序列化系统
- en: When developing a game, adding a reliable content saving and loading feature
    is a critical part of the development process. If you're using a game engine editor,
    such as the Unity engine editor, you'll also need some common editor features,
    such as undo, saving editor settings, and more. All of this, whether the game
    saves or loads content at runtime, or whether the developer uses the editor to
    develop the game, is built on **serialization**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发游戏时，添加可靠的内容保存和加载功能是开发过程中的一个关键部分。如果您使用的是游戏引擎编辑器，例如 Unity 引擎编辑器，您还需要一些常见的编辑器功能，如撤销、保存编辑器设置等。所有这些，无论是游戏在运行时保存或加载内容，还是开发者使用编辑器开发游戏，都是建立在
    **序列化**基础上的。
- en: What is Unity's serialization system?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 的序列化系统是什么？
- en: So, what is `deserialization`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是 `反序列化`。
- en: 'In Unity, there are three serialization formats, namely the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，有三种序列化格式，即以下内容：
- en: Binary serialization
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制序列化
- en: '`YAML` serialization'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YAML` 序列化'
- en: '`JSON` serialization'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON` 序列化'
- en: YAML and binary serialization in Unity
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unity 中的 YAML 和二进制序列化
- en: Assets created by Unity, such as `Scenes` and `Prefabs`, will be saved in `YAML`
    format by default. For example, if we open the Scene of this chapter, namely,
    `Chapter10.unity`, in a text editor such as `OcclusionCullingSettings` and `RenderSettings`.
    If you scroll down, you can also find the GameObjects and components contained
    in this Scene.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 创建的资产，如 `场景` 和 `预制体`，默认将保存为 `YAML` 格式。例如，如果我们在这个章节中打开场景，即 `Chapter10.unity`，在文本编辑器如
    `OcclusionCullingSettings` 和 `RenderSettings` 中。如果你向下滚动，你还可以找到这个场景中包含的 GameObjects
    和组件。
- en: '![Figure 10.2 – The Scene in YAML format'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – YAML 格式的场景'
- en: '](img/Figure_10.02_B17146.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.02_B17146.jpg)'
- en: Figure 10.2 – The Scene in YAML format
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – YAML 格式的场景
- en: 'As shown in *Figure 10.2*, there is no doubt that the YAML format is human-readable
    and makes it easy for the version control tools to work with. However, YAML is
    a text-based format, so you can also choose to use binary serialization for the
    more efficient use of space and increased security. Let''s perform the following
    steps to set Unity''s serialization mode:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10.2* 所示，毫无疑问，YAML 格式是可读的，并且使得版本控制工具易于使用。然而，YAML 是一种基于文本的格式，因此你也可以选择使用二进制序列化来更有效地使用空间并提高安全性。让我们执行以下步骤来设置
    Unity 的序列化模式：
- en: 'Open the **Project Settings** window by clicking the **Edit | Project Settings...**
    item in the Unity Editor toolbar, as shown in the following screenshot:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 Unity 编辑器工具栏中的 **编辑 | 项目设置...** 项来打开 **项目设置** 窗口，如下面的截图所示：
- en: '![Figure 10.3 – Opening the Project Settings window'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 打开项目设置窗口'
- en: '](img/Figure_10.03_B17146.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.03_B17146.jpg)'
- en: Figure 10.3 – Opening the Project Settings window
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 打开项目设置窗口
- en: 'Next, click the settings panel, as shown in *Figure 10.4*:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击设置面板，如 *图 10.4* 所示：
- en: '![Figure 10.4 – The Editor settings panel'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – 编辑器设置面板'
- en: '](img/Figure_10.04_B17146.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.04_B17146.jpg)'
- en: Figure 10.4 – The Editor settings panel
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 编辑器设置面板
- en: In the **Asset Serialization** section, we can find that the **Mode** option
    is **Force Text** by default. In this mode, all the assets created by Unity will
    be serialized in YAML format. This is also the recommended setting if you use
    a version management tool such as Git, as using plain text serialization can often
    avoid unresolvable merge conflicts. As shown in *Figure 10.5*, in the drop-down
    window, we can select **Force Binary** mode to convert all the assets to binary
    format, and we can also choose the **Mixed** mode option to retain the serialization
    format of the current assets; that is, the assets that are serialized in binary
    format are still in binary format, and assets that are serialized using YAML format
    are still in YAML format. However, newly created assets will be serialized in
    binary format.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **资产序列化** 部分，我们可以看到默认的 **模式** 选项是 **强制文本**。在这种模式下，所有由 Unity 创建的资产都将使用 YAML
    格式进行序列化。如果你使用像 Git 这样的版本管理工具，这也是推荐的设置，因为使用纯文本序列化通常可以避免无法解决的合并冲突。如 *图 10.5* 所示，在下拉窗口中，我们可以选择
    **强制二进制** 模式将所有资产转换为二进制格式，我们还可以选择 **混合** 模式选项以保留当前资产的序列化格式；也就是说，以二进制格式序列化的资产仍然是二进制格式，而使用
    YAML 格式序列化的资产仍然是 YAML 格式。然而，新创建的资产将以二进制格式进行序列化。
- en: '![Figure 10.5 – Asset Serialization mode'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 资产序列化模式'
- en: '](img/Figure_10.05_B17146.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.05_B17146.jpg)'
- en: Figure 10.5 – Asset Serialization mode
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 资产序列化模式
- en: 'Here, we can select **Force Binary** mode and check the same Scene file in
    our text editor again. The Scene file is converted to binary format, as shown
    in the following screenshot:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以选择 **强制二进制** 模式，并在我们的文本编辑器中再次检查相同的场景文件。场景文件已转换为二进制格式，如下面的截图所示：
- en: '![Figure 10.6 – The Scene file in binary format'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – 二进制格式的场景文件'
- en: '](img/Figure_10.06_B17146.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.06_B17146.jpg)'
- en: Figure 10.6 – The Scene file in binary format
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 二进制格式的场景文件
- en: As we mentioned earlier, serialization is also an important part of implementing
    the Unity Editor. Not only are the assets created by Unity as used in the game,
    such as game Scenes, serialized by Unity, but the various settings in the Unity
    Editor are also serialized by Unity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，序列化也是实现 Unity 编辑器的一个重要部分。不仅 Unity 创建的资产，如游戏场景，会被 Unity 序列化，Unity 编辑器中的各种设置也会被
    Unity 序列化。
- en: 'In the project root directory, we can find the `ProjectSettings` folder, which
    is automatically created by the Unity Editor when the project is created, as shown
    in *Figure 10.7*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录中，我们可以找到 `ProjectSettings` 文件夹，这是在创建项目时由 Unity 编辑器自动创建的，如 *图 10.7* 所示：
- en: '![Figure 10.7 – The ProjectSettings folder'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – ProjectSettings 文件夹'
- en: '](img/Figure_10.07_B17146.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.07_B17146.jpg)'
- en: Figure 10.7 – The ProjectSettings folder
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – ProjectSettings 文件夹
- en: Double-click this folder to open it. We can find all the settings files of the
    current project here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 双击此文件夹以打开它。我们可以在其中找到当前项目的所有设置文件。
- en: '![Figure 10.8 – The settings files in the ProjectSettings folder'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.8 – ProjectSettings 文件夹中的设置文件'
- en: '](img/Figure_10.08_B17146.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.08_B17146.jpg)'
- en: Figure 10.8 – The settings files in the ProjectSettings folder
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – ProjectSettings 文件夹中的设置文件
- en: 'Next, we still use the text editor to open a settings file, such as `GraphicsSettings.asset`,
    and serialize this file using Unity''s binary serialization mode and text serialization
    mode, respectively. *Figure 10.9* shows the settings file serialized in binary
    format:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们仍然使用文本编辑器打开一个设置文件，例如 `GraphicsSettings.asset`，并分别使用 Unity 的二进制序列化模式和文本序列化模式来序列化此文件。*图
    10.9* 展示了以二进制格式序列化的设置文件：
- en: '![Figure 10.9 – The settings file in binary format'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9 – 二进制格式的设置文件'
- en: '](img/Figure_10.09_B17146.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.09_B17146.jpg)'
- en: Figure 10.9 – The settings file in binary format
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 二进制格式的设置文件
- en: 'On the other hand, you can see the settings file serialized in YAML format
    in *Figure 10.10*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可以在 *图 10.10* 中看到以 YAML 格式序列化的设置文件：
- en: '![Figure 10.10 – The settings file in YAML format'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.10 – YAML 格式的设置文件](img/Figure_10.09_B17146.jpg)'
- en: '](img/Figure_10.10_B17146.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.10_B17146.jpg)'
- en: Figure 10.10 – The settings file in YAML format
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – YAML 格式的设置文件
- en: So far, we've discussed Unity's binary serialization and text-based YAML serialization,
    but we haven't covered the JSON serialization provided by Unity yet. Next, let's
    take a look at JSON serialization in Unity.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了 Unity 的二进制序列化和基于文本的 YAML 序列化，但我们还没有涵盖 Unity 提供的 JSON 序列化。接下来，让我们看看
    Unity 中的 JSON 序列化。
- en: JsonUtility class and JSON serialization in Unity
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unity 中的 JsonUtility 类和 JSON 序列化
- en: 'If you have previous experience of developing .NET projects, you are probably
    familiar with JSON serialization. You can choose the solutions provided by .NET,
    such as using the `DataContractJsonSerializer` class defined in the `System.Runtime.Serialization.Json`
    namespace or using the `JsonSerializer` class defined in the `System.Text.Json`
    namespace, and there are also solutions from the open source community, such as
    `Newtonsoft.Json`, which is a very popular JSON framework for .NET. Unity also
    provides game developers with JSON serialization capabilities in Unity development,
    namely, the `JsonUtility` class. We can call `JsonUtility`''s `ToJson` method
    to serialize an object into a JSON string, and conversely, `JsonUtility`''s `FromJson`
    method can deserialize a JSON string into an object. Next, let''s look at an example
    of how to use the `JsonUtility` class in Unity:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前有开发 .NET 项目的经验，你可能对 JSON 序列化很熟悉。你可以选择 .NET 提供的解决方案，例如使用 `System.Runtime.Serialization.Json`
    命名空间中定义的 `DataContractJsonSerializer` 类或使用 `System.Text.Json` 命名空间中定义的 `JsonSerializer`
    类，还有来自开源社区的解决方案，例如 `Newtonsoft.Json`，这是一个非常流行的 .NET JSON 框架。Unity 还为游戏开发者提供了 Unity
    开发中的 JSON 序列化功能，即 `JsonUtility` 类。我们可以调用 `JsonUtility` 的 `ToJson` 方法将对象序列化为 JSON
    字符串，反之，`JsonUtility` 的 `FromJson` 方法可以将 JSON 字符串反序列化为对象。接下来，让我们看看如何在 Unity 中使用
    `JsonUtility` 类的示例：
- en: Create a new folder named `Scripts` by clicking the **Create | Folder** item
    in the **Project** window.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **项目** 窗口中点击 **创建 | 文件夹** 项，创建一个名为 `Scripts` 的新文件夹。
- en: '![Figure 10.11 – Creating the Scripts folder'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.11 – 创建 Scripts 文件夹'
- en: '](img/Figure_10.11_B17146.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.11_B17146.jpg)'
- en: Figure 10.11 – Creating the Scripts folder
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 创建 Scripts 文件夹
- en: 'Double-click on the `Scripts` folder to enter it, and then create a new C#
    script in this folder, name it `PlayerData`, and add the following to this script.
    The `PlayerData` struct is used to store the data of a player, and an object of
    it will be serialized to a JSON string later. And you should note that fields
    of the structs or classes should be `public`; otherwise, the Unity serializer
    will ignore these fields:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `Scripts` 文件夹以进入它，然后在此文件夹中创建一个新的 C# 脚本，命名为 `PlayerData`，并将以下内容添加到该脚本中。`PlayerData`
    结构用于存储玩家的数据，稍后该结构的一个对象将被序列化为 JSON 字符串。你应该注意，结构体或类的字段应该是 `public` 的；否则，Unity 序列化器将忽略这些字段：
- en: '[PRE0]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we also need to create another C# script in the same folder and name
    it `JSONSerializationSample`. The code in `JSONSerializationSample` is as follows.
    In the `Start` method, we create a new `PlayerData` object and assign values to
    its fields, and then call the `JsonUtility.ToJson` method to serialize this object
    into a JSON string and print the string to the `Console` window:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还需要在同一个文件夹中创建另一个C#脚本，并将其命名为`JSONSerializationSample`。`JSONSerializationSample`中的代码如下。在`Start`方法中，我们创建一个新的`PlayerData`对象，并为其字段赋值，然后调用`JsonUtility.ToJson`方法将此对象序列化为JSON字符串，并将字符串打印到`控制台`窗口：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new GameObject in the Scene, attach the `JSONSerializationSample`
    script to it, and run the game in the editor. The JSON string, as shown in the
    following screenshot, will be printed:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新的GameObject，将其`JSONSerializationSample`脚本附加到它上，并在编辑器中运行游戏。以下截图所示的JSON字符串将被打印出来：
- en: '![Figure 10.12 – The JSON string'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.12 – JSON字符串'
- en: '](img/Figure_10.12_B17146.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.12_B17146.jpg](img/Figure_10.12_B17146.jpg)'
- en: Figure 10.12 – The JSON string
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – JSON字符串
- en: 'Deserializing a JSON string to an object is fairly straightforward; you just
    need to call `JsonUtility.FromJson<T>`, which is a generic method. If you don''t
    know about generic methods in C#, generic methods are methods declared with type
    parameters. So, let''s go back to `JSONSerializationSample` and update the code
    in the `Start` method. This code will deserialize the JSON string into a new object,
    and the object''s `Name` field will be printed in the **Console** window:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JSON字符串反序列化为对象相对简单；你只需要调用`JsonUtility.FromJson<T>`，这是一个泛型方法。如果你不了解C#中的泛型方法，泛型方法是使用类型参数声明的。因此，让我们回到`JSONSerializationSample`并更新`Start`方法中的代码。这段代码将反序列化JSON字符串到一个新的对象，并且对象的`Name`字段将在**控制台**窗口中打印出来：
- en: '[PRE2]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the game in the editor. The name of this player is printed as shown in
    the following screenshot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中运行游戏。这个玩家的名字将按以下截图所示打印出来：
- en: '![Figure 10.13 – Deserializing the JSON string'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.13 – 反序列化JSON字符串'
- en: '](img/Figure_10.13_B17146.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.13_B17146.jpg](img/Figure_10.13_B17146.jpg)'
- en: Figure 10.13 – Deserializing the JSON string
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 反序列化JSON字符串
- en: 'If you want `PlayerData` as a field of another class and you want to serialize
    this class, `PlayerData` needs to be marked with the `[System.Serializable]` attribute,
    otherwise, `PlayerData` as a field won''t be serialized correctly. So, let''s
    go back to `PlayerData` and update the code to add the `[System.Serializable]`
    attribute:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望`PlayerData`作为另一个类的字段，并且想要序列化这个类，`PlayerData`需要标记为`[System.Serializable]`属性，否则，作为字段的`PlayerData`将无法正确序列化。因此，让我们回到`PlayerData`并更新代码以添加`[System.Serializable]`属性：
- en: '[PRE3]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that you know how to use the `JsonUtility` class to serialize an object
    to a JSON string and deserialize a JSON string to an object in Unity, it's time
    to discuss the advantages and limitations of Unity's `JsonUtility` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在Unity中使用`JsonUtility`类将对象序列化为JSON字符串，并将JSON字符串反序列化为对象，是时候讨论Unity的`JsonUtility`类的优缺点了。
- en: Advantages and limitations of Unity's JsonUtility class
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unity的JsonUtility类的优缺点
- en: Let's start with the advantages of Unity's `JsonUtility` class. Using the `JsonUtility`
    class in Unity can achieve relatively high performance in terms of serializing
    and deserializing JSON. The `ToJson` method and the `FromJson` method of `JsonUtility`
    use the Unity serializer internally, and it has better support for some built-in
    types of Unity, such as `Vector2` and `Vector3`. In addition, since it is provided
    by the Unity game engine, there is no need to install additional packages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Unity的`JsonUtility`类的优点开始。在Unity中使用`JsonUtility`类可以在序列化和反序列化JSON方面实现相对较高的性能。`JsonUtility`的`ToJson`方法和`FromJson`方法内部使用Unity序列化器，并且对Unity的一些内置类型（如`Vector2`和`Vector3`）有更好的支持。此外，由于它是由Unity游戏引擎提供的，因此无需安装额外的包。
- en: 'However, `JsonUtility` has limited functionality compared to other popular
    JSON frameworks such as `Newtonsoft.Json`. The two most obvious limitations are
    that `JsonUtility` does not support the serialization of dictionaries and that
    the root element must be an object, not an array or a list. Let''s look at an
    example of the limitations of the `JsonUtility` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与`Newtonsoft.Json`等其他流行的JSON框架相比，`JsonUtility`的功能有限。两个最明显的限制是`JsonUtility`不支持字典的序列化，并且根元素必须是对象，而不是数组或列表。让我们看看`JsonUtility`类的限制示例：
- en: 'Create a new C# script in the `Scripts` folder, name it `TeamData`, and add
    the following to this script. As shown in the following code, this class has two
    fields, a `PlayerData` list and a dictionary:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`TeamData`，并将以下内容添加到该脚本中。如下面的代码所示，这个类有两个字段，一个`PlayerData`列表和一个字典：
- en: '[PRE4]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we also need to create another C# script in the same folder and name
    it `JsonUtilityLimitationsSample`. The code in `JsonUtilityLimitationsSample`
    is as follows. In the `Start` method, we create a new `TeamData` object, add an
    element to the `Players` list, and add a key and value to the `Roles` dictionary.
    Then, call the `JsonUtility.ToJson` method to serialize this object into a JSON
    string and print the string to the **Console** window:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还需要在同一个文件夹中创建另一个C#脚本，并将其命名为`JsonUtilityLimitationsSample`。`JsonUtilityLimitationsSample`中的代码如下。在`Start`方法中，我们创建一个新的`TeamData`对象，向`Players`列表中添加一个元素，并向`Roles`字典中添加一个键值对。然后，调用`JsonUtility.ToJson`方法将此对象序列化为JSON字符串，并将字符串打印到**控制台**窗口：
- en: '[PRE5]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the game in the editor; you can find that only the `Players` list is serialized,
    but the `Roles` dictionary is not serialized as expected, as shown in the following
    screenshot. This is because `JsonUtility` does not support serializing dictionaries
    in Unity.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中运行游戏；你会发现只有`Players`列表被序列化，但`Roles`字典没有按预期序列化，如下面的截图所示。这是因为`JsonUtility`不支持在Unity中序列化字典。
- en: '![Figure 10.14 – The Roles dictionary is not serialized'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.14 – Roles字典未序列化'
- en: '](img/Figure_10.14_B17146.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.14_B17146.jpg)'
- en: Figure 10.14 – The Roles dictionary is not serialized
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – Roles字典未序列化
- en: 'Then, let''s go back to `JsonUtilityLimitationsSample` and update the code
    in the `Start` method to try to serialize the `Players` list individually:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们回到`JsonUtilityLimitationsSample`，并更新`Start`方法中的代码，尝试单独序列化`Players`列表：
- en: '[PRE6]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the game in the editor again and you will find that the `Players` list is
    not serialized this time, as shown in the following screenshot. This is because
    if using `JsonUtility` for serialization, the root element must be an object,
    not an array or list.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在编辑器中运行游戏，你会发现这次`Players`列表没有被序列化，如下面的截图所示。这是因为如果使用`JsonUtility`进行序列化，根元素必须是一个对象，而不是数组或列表。
- en: '![Figure 10.15 – The Players list is not serialized'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15 – Players列表未序列化'
- en: '](img/Figure_10.15_B17146.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.15_B17146.jpg)'
- en: Figure 10.15 – The Players list is not serialized
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – Players列表未序列化
- en: Newtonsoft.Json framework
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Newtonsoft.Json框架
- en: 'It is a real headache to encounter the problems mentioned in the preceding
    example during development, so some other JSON frameworks may also be worth trying.
    Next, we will use `Newtonsoft.Json` to modify the preceding example so that the
    `Roles` dictionary in the `TeamData` class and the individual `Players` list can
    be serialized into JSON strings correctly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中遇到前面例子中提到的问题真是个头疼的问题，因此尝试一些其他的JSON框架可能也是值得的。接下来，我们将使用`Newtonsoft.Json`来修改前面的例子，以便`TeamData`类中的`Roles`字典和单个`Players`列表可以正确地序列化为JSON字符串：
- en: First, if the `Newtonsoft.Json` package is not installed in your project, you
    can install it through Unity's Package Manager. You can open it by clicking the
    **Window | Package Manager** item in the toolbar.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果你的项目中没有安装`Newtonsoft.Json`包，你可以通过Unity的包管理器来安装它。你可以在工具栏中点击**Window | Package
    Manager**项来打开它。
- en: '![Figure 10.16 – Opening Package Manager'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.16 – 打开包管理器'
- en: '](img/Figure_10.16_B17146.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.16_B17146.jpg)'
- en: Figure 10.16 – Opening Package Manager
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 打开包管理器
- en: Then, click the **+** in the upper-left corner to open the drop-down menu, and
    select the **Add package from git URL…** item in the drop-down menu.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击左上角的**+**来打开下拉菜单，并从下拉菜单中选择**Add package from git URL…**项。
- en: '![Figure 10.17 – Add package from git URL'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.17 – 从git URL添加包'
- en: '](img/Figure_10.17_B17146.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.17_B17146.jpg)'
- en: Figure 10.17 – Add package from git URL
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 从git URL添加包
- en: Enter `com.unity.nuget.newtonsoft-json` in the input box that appears, click
    the **Add** button, and wait for Package Manager to install this package.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的输入框中输入`com.unity.nuget.newtonsoft-json`，点击**Add**按钮，等待包管理器安装此包。
- en: '![Figure 10.18 – Adding Newtonsoft.Json'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.18 – 添加Newtonsoft.Json'
- en: '](img/Figure_10.18_B17146.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.18_B17146.jpg)'
- en: Figure 10.18 – Adding Newtonsoft.Json
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 添加Newtonsoft.Json
- en: 'After installing the package in the project, we can use the `Newtonsoft.Json`
    framework in our C# script, so let''s go back to `JsonUtilityLimitationsSample.cs`
    and update the code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中安装包后，我们可以在 C# 脚本中使用 `Newtonsoft.Json` 框架，因此让我们回到 `JsonUtilityLimitationsSample.cs`
    并更新代码：
- en: '[PRE7]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s break down the code as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解代码：
- en: We add the `Newtonsoft.Json` namespace with the `using` keyword, which provides
    classes and methods for JSON serialization and deserialization.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `using` 关键字添加 `Newtonsoft.Json` 命名空间，它提供了用于 JSON 序列化和反序列化的类和方法。
- en: In the `Start` method, we replace the `JsonUtility.ToJson` method with the `JsonConvert.SerializeObject`
    method that is defined in the `Newtonsoft.Json` namespace.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Start` 方法中，我们将 `JsonUtility.ToJson` 方法替换为在 `Newtonsoft.Json` 命名空间中定义的 `JsonConvert.SerializeObject`
    方法。
- en: Run the game. You will find that the `Roles` dictionary field of the `TeamData`
    object is serialized as expected, while the `Players` list as the root element
    is also serialized correctly.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。您会发现 `TeamData` 对象的 `Roles` 字典字段按预期进行了序列化，而作为根元素的 `Players` 列表也正确地进行了序列化。
- en: '![Figure 10.19 – Newtonsoft.Json works correctly'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.19 – Newtonsoft.Json 正确工作'
- en: '](img/Figure_10.19_B17146.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.19_B17146.jpg)'
- en: Figure 10.19 – Newtonsoft.Json works correctly
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – Newtonsoft.Json 正确工作
- en: In this section, we have explained what Unity's serialization system is and
    how to use JSON serialization in your Unity project. Now I think you're ready
    to continue exploring how assets in your game project are managed by the Unity
    engine!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了 Unity 的序列化系统以及如何在您的 Unity 项目中使用 JSON 序列化。现在我认为您已经准备好继续探索游戏项目中资产是如何被
    Unity 引擎管理的了！
- en: The assets workflow in Unity
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 中的资产工作流程
- en: Unity's assets workflow is another very interesting topic that is also very
    closely related to serialization. So, what is an `asset` in Unity? If you look
    at a Unity project, you will find that there is a folder called `Assets` in the
    root directory of this project, and an asset is a file stored in this folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的资产工作流程是另一个非常有趣的话题，它也与序列化密切相关。那么，Unity 中的 `asset` 是什么呢？如果您查看一个 Unity 项目，您会在该项目的根目录下找到一个名为
    `Assets` 的文件夹，资产就是存储在这个文件夹中的文件。
- en: 'In Unity development, assets can be divided into the following two categories
    according to their sources:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 开发中，根据其来源，资产可以分为以下两类：
- en: External assets that are imported into Unity; the most common in this case are
    `models,` `textures,` and `audio`. They are often created by third-party tools,
    such as `Maya,` `3Ds Max,` and `Photoshop`, and then imported into Unity for use.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入到 Unity 中的外部资产；在这种情况下最常见的是 `模型`、`纹理` 和 `音频`。它们通常由第三方工具创建，例如 `Maya`、`3Ds Max`
    和 `Photoshop`，然后导入到 Unity 中使用。
- en: Assets created by Unity itself, such as `Prefab` and `Scene` files.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Unity 本身创建的资产，例如 `Prefab` 和 `Scene` 文件。
- en: 'Whether it''s an imported asset or an asset created by Unity, Unity does the
    following three things with them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是导入的资产还是由 Unity 创建的资产，Unity 对它们执行以下三个操作：
- en: Unity will assign a GUID to this asset.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity 将为该资产分配一个 GUID。
- en: Then, a meta file will be created automatically by Unity to store some additional
    information about the asset, such as the GUID and the import settings of this
    asset. *Figure 10.20* shows an example of an automatically created meta file.
    When a PNG file named `SampleTexture` is imported into the Unity project, Unity
    automatically creates a meta file and names it `SampleTexture.PNG.meta`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Unity 将自动创建一个元数据文件来存储有关资产的一些附加信息，例如该资产的 GUID 和导入设置。*图 10.20* 展示了一个自动创建的元数据文件示例。当名为
    `SampleTexture` 的 PNG 文件导入到 Unity 项目中时，Unity 自动创建一个名为 `SampleTexture.PNG.meta`
    的元数据文件。
- en: '![Figure 10.20 – A meta file'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.20 – 元数据文件'
- en: '](img/Figure_10.20_B17146.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.20_B17146.jpg)'
- en: Figure 10.20 – A meta file
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 元数据文件
- en: Finally, Unity will process the asset file, convert its content into an internal
    representation in Unity, and store the internal representation in the `Library`
    folder in the project root. We will cover this in detail when we introduce the
    `Library` folder later.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，Unity 将处理资产文件，将其内容转换为 Unity 的内部表示，并将内部表示存储在项目根目录下的 `Library` 文件夹中。我们将在介绍
    `Library` 文件夹时详细说明。
- en: '![Figure 10.21 – The Library folder'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.21 – Library 文件夹'
- en: '](img/Figure_10.21_B17146.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.21_B17146.jpg)'
- en: Figure 10.21 – The Library folder
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – Library 文件夹
- en: 'Armed with an understanding of Unity''s assets workflow, let''s introduce the
    three things involved in this workflow in more detail: GUID and File ID, meta
    files, and the `Libary` folder.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了 Unity 的资产工作流程之后，让我们更详细地介绍这个工作流程中涉及的三件事：GUID 和文件 ID、元文件以及 `Libary` 文件夹。
- en: GUID and File ID
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GUID 和文件 ID
- en: GUID and File ID are obviously an important topic when we discuss Unity's asset
    workflow. This is because no matter whether we use Unity to create an asset or
    import an external asset, Unity has to uniquely identify this asset, and this
    unique value is the GUID. File ID is often used together with GUID; it is not
    used to identify an asset like GUID, but is used to identify a reference to another
    object within an object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 Unity 的资产工作流程时，GUID 和文件 ID 显然是一个重要的话题。这是因为无论我们使用 Unity 创建资产还是导入外部资产，Unity
    都必须唯一地识别这个资产，而这个唯一值就是 GUID。文件 ID 通常与 GUID 一起使用；它不是用来识别资产，而是用来识别对象内另一个对象的引用。
- en: Now that we have a brief understanding of GUID and File ID, it's time to move
    on to exploring GUID and File ID in more detail!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 GUID 和文件 ID 有了一个初步的了解，是时候更深入地探索 GUID 和文件 ID 了！
- en: GUID
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GUID
- en: As we just mentioned, Unity assigns a GUID to each asset in the `Assets` folder
    as the asset's identifier. We can use a text editor to open the meta file associated
    with this asset to find the GUID of this asset within the Unity engine.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，Unity 将一个 GUID 分配给 `Assets` 文件夹中的每个资产，作为资产的标识符。我们可以使用文本编辑器打开与该资产关联的元文件，以在
    Unity 引擎中找到该资产的 GUID。
- en: 'Let''s now perform the following steps to create a new C# script as an asset
    and check the `GUID` of this C# script in Unity:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将执行以下步骤来创建一个新的 C# 脚本作为资产，并在 Unity 中检查这个 C# 脚本的 `GUID`：
- en: 'Create a new C# script in the `Scripts` folder, name it `AssetSample`, and
    add the following to this script. As shown in the following code, this class has
    a `Texture` field:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scripts` 文件夹中创建一个新的 C# 脚本，命名为 `AssetSample`，并将以下内容添加到该脚本中。如下代码所示，这个类有一个 `Texture`
    字段：
- en: '[PRE8]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A meta file called `AssetSample.cs.meta` is created next to the C# script file
    in the file explorer, as shown in the following screenshot:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件资源管理器中，紧挨着 C# 脚本文件创建了一个名为 `AssetSample.cs.meta` 的元文件，如下截图所示：
- en: '![Figure 10.22 – The AssetSample.cs.meta file'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.22 – AssetSample.cs.meta 文件'
- en: '](img/Figure_10.22_B17146.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.22_B17146.jpg)'
- en: Figure 10.22 – The AssetSample.cs.meta file
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – AssetSample.cs.meta 文件
- en: 'Open the `AssetSample.cs.meta` file in a text editor, and you will discover
    that the GUID of this C# script asset in Unity is `e35f96b75211edd4bad6451a26675090`,
    as shown in the following screenshot:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `AssetSample.cs.meta` 文件，你会发现这个 C# 脚本资产在 Unity 中的 GUID 是 `e35f96b75211edd4bad6451a26675090`，如下截图所示：
- en: '![Figure 10.23 – The GUID of this C# script'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.23 – 此 C# 脚本的 GUID'
- en: '](img/Figure_10.23_B17146.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.23_B17146.jpg)'
- en: Figure 10.23 – The GUID of this C# script
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 – 此 C# 脚本的 GUID
- en: After reading this, you should know how to find the GUID of an asset in Unity;
    however, where is the File ID stored, and how does Unity use it to create and
    maintain references between objects? So, let's continue our journey with another
    example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本文后，你应该知道如何在 Unity 中找到资产的 GUID；然而，文件 ID 存储在哪里，Unity 是如何使用它来创建和维护对象之间的引用的？那么，让我们通过另一个示例继续我们的旅程。
- en: File ID
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件 ID
- en: We mentioned earlier that Unity uses a `File ID` to refer to another object
    within an object, which is the unique ID of the object referenced within that
    object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，Unity 使用 `File ID` 来引用对象内的另一个对象，这是在该对象内引用的对象的唯一 ID。
- en: Now, let's take a look at an example to learn how to find the `File IDs` and
    how Unity uses the `File IDs` to maintain the reference relationship between objects.
    In this example, we will still use the `AssetSample` script we just created, so
    now let's get started!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个示例来学习如何找到 `File IDs` 以及 Unity 是如何使用 `File IDs` 来维护对象之间的引用关系的。在这个示例中，我们仍然将使用我们刚才创建的
    `AssetSample` 脚本，现在让我们开始吧！
- en: 'First, create a new GameObject in the Scene and name it `AssetSampleGameObject`.
    You already know that a `Transform` component is automatically created and attached
    to this GameObject, as shown in *Figure 10.24*:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在场景中创建一个新的 GameObject，命名为 `AssetSampleGameObject`。你已经知道，一个 `Transform` 组件会自动创建并附加到这个
    GameObject 上，如图 *图 10.24* 所示：
- en: '![Figure 10.24 – Creating an AssetSampleGameObject'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.24 – 创建 AssetSampleGameObject'
- en: '](img/Figure_10.24_B17146.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.24_B17146.jpg)'
- en: Figure 10.24 – Creating an AssetSampleGameObject
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24 – 创建 AssetSampleGameObject
- en: Attach an `AssetSample` component to `AssetSampleGameObject`, and then assign
    a texture from the `Texture` field of `AssetSample`. Then, attach another `AssetSample`
    component to the same GameObject; however, this time, we set the `AssetSample`
    to **None** and save the Scene.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`AssetSample`组件附加到`AssetSampleGameObject`上，然后从`AssetSample`的`Texture`字段分配一个纹理。然后，将另一个`AssetSample`组件附加到同一个GameObject上；然而，这次我们将`AssetSample`设置为**None**并保存场景。
- en: '![Figure 10.25 – Adding AssetSample components to the GameObject'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.25 – 向GameObject添加AssetSample组件'
- en: '](img/Figure_10.25_B17146.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.25_B17146.jpg)'
- en: Figure 10.25 – Adding AssetSample components to the GameObject
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25 – 向GameObject添加AssetSample组件
- en: 'Make sure your project''s **Asset Serialization** mode is now **Force Text**
    (we covered this topic in the *YAML and binary serialization in Unity* section),
    and then use a text editor to open the Scene file from **File Explorer**. You
    will see a lot of content in the Scene file, as shown in the following screenshot:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的项目**资产序列化**模式现在是**强制文本**（我们已在*Unity中的YAML和二进制序列化*部分讨论了此主题），然后使用文本编辑器从**文件资源管理器**打开场景文件。您将在场景文件中看到很多内容，如下面的截图所示：
- en: '![Figure 10.26 – Opening the Scene file in a text editor'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.26 – 在文本编辑器中打开场景文件'
- en: '](img/Figure_10.26_B17146.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.26_B17146.jpg)'
- en: Figure 10.26 – Opening the Scene file in a text editor
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26 – 在文本编辑器中打开场景文件
- en: 'This file gives us a lot of information, recording the GameObjects, components,
    and referenced assets in the Scene. So let''s break it down:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件为我们提供了大量信息，记录了场景中的GameObject、组件和引用的资产。因此，让我们将其分解：
- en: 'First of all, we can find the record of the GameObject called `AssetSampleGameObject`
    in the file. In the following screenshot, you can see that there are three components
    attached to this GameObject, with File IDs of `306521988`, `306521989`, and `306521990`,
    respectively:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以在文件中找到名为`AssetSampleGameObject`的GameObject的记录。在下面的截图中，您可以看到有三个组件附加到这个GameObject上，分别具有文件ID`306521988`、`306521989`和`306521990`：
- en: '![Figure 10.27 – The AssetSampleGameObject record'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.27 – AssetSampleGameObject记录'
- en: '](img/Figure_10.27_B17146.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.27_B17146.jpg)'
- en: Figure 10.27 – The AssetSampleGameObject record
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27 – AssetSampleGameObject记录
- en: If we search these three `File IDs`, we can find records for three components
    in this file – a `Transform` component, which is created and attached to this
    GameObject when the GameObject is created, and two `MonoBehaviour` components,
    which represent C# script components.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们搜索这三个`File IDs`，我们可以在文件中找到三个组件的记录 – 一个`Transform`组件，当GameObject创建时创建并附加到该GameObject上，以及两个`MonoBehaviour`组件，代表C#脚本组件。
- en: '![Figure 10.28 – File IDs'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.28 – 文件ID'
- en: '](img/Figure_10.28_B17146.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.28_B17146.jpg)'
- en: Figure 10.28 – File IDs
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28 – 文件ID
- en: So, what is the difference between File ID and GUID? If we focus on these two
    `MonoBehaviour` components, we can see that the `m_Script` field of both components
    references the same C# script with a GUID of `e35f96b75211edd4bad6451a26675090`.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，文件ID和GUID之间的区别是什么？如果我们关注这两个`MonoBehaviour`组件，我们可以看到这两个组件的`m_Script`字段都引用了具有GUID`e35f96b75211edd4bad6451a26675090`的相同C#脚本。
- en: '![Figure 10.29 – The MonoBehaviour components'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.29 – MonoBehaviour组件'
- en: '](img/Figure_10.29_B17146.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.29_B17146.jpg)'
- en: Figure 10.29 – The MonoBehaviour components
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29 – MonoBehaviour组件
- en: Therefore, we can find that although these two component objects refer to the
    same C# script, namely, `AssetSample`, they are two different instances of `AssetSample`;
    the file ID of the first `MonoBehaviour` component object is `306521989`, and
    the file ID of the second `MonoBehaviour` component object is `306521990`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以发现，尽管这两个组件对象引用的是同一个C#脚本，即`AssetSample`，但它们是`AssetSample`的两个不同实例；第一个`MonoBehaviour`组件对象的文件ID是`306521989`，第二个`MonoBehaviour`组件对象的文件ID是`306521990`。
- en: Moreover, the `_texture` field of one instance refers to a texture asset, and
    the `_texture` field of the other instance does not refer to any texture asset.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个实例的`_texture`字段引用了一个纹理资产，而另一个实例的`_texture`字段没有引用任何纹理资产。
- en: By reading this section, we learned that Unity uses GUID to identify an asset
    and File ID to identify a referenced object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本节，我们了解到Unity使用GUID来识别资产，使用文件ID来识别引用的对象。
- en: Meta files
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元文件
- en: We already know that a meta file records the GUID of its associated asset in
    a Unity project, and that a meta file also records the import settings of this
    asset. In this section, we will talk about meta files that look inconspicuous
    but are actually very important.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，元文件记录了其关联资产在 Unity 项目中的 GUID，并且元文件还记录了该资产的导入设置。在本节中，我们将讨论那些看似不起眼但实际上非常重要的元文件。
- en: Meta files and version management
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元文件和版本管理
- en: A common mistake developers new to Unity make is not paying attention to these
    autogenerated meta files. One such example is ignoring meta files when using Git
    or other version control systems to manage the version of the Unity project.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始使用 Unity 的开发者来说，一个常见的错误就是没有注意到这些自动生成的元文件。一个这样的例子是在使用 Git 或其他版本控制系统来管理 Unity
    项目的版本时忽略元文件。
- en: If you remember from the previous section, Unity assigns each asset a GUID,
    uses this GUID to identify the asset, and records this GUID in the meta file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得上一节的内容，Unity 会为每个资产分配一个 GUID，使用这个 GUID 来识别资产，并在元文件中记录这个 GUID。
- en: So, if your version management system does not include meta files, your Unity
    development progress may be disrupted.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您的版本管理系统中不包括元文件，您的 Unity 开发进度可能会受到影响。
- en: To illustrate this, let's imagine a scenario where, when a Unity project that
    does not contain meta files is cloned from a remote repository to your colleague's
    local machine, the Unity Editor will reimport those assets and assign them new
    GUIDs and create meta files to store this information. As a result, references
    that previously existed between objects in your Unity project will no longer be
    valid.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们想象一个场景，当不包含元文件的 Unity 项目从远程仓库克隆到同事的本地机器上时，Unity 编辑器将重新导入这些资产，为它们分配新的
    GUID 并创建元文件来存储这些信息。结果，您 Unity 项目中之前存在的对象之间的引用将不再有效。
- en: 'As an example, assuming that the `AssetSample.cs.meta` meta file of the `AssetSample`
    C# script we created earlier is not managed by the version management system,
    then you will encounter the `Script Missing` error, as shown in *Figure 10.30*,
    after cloning and opening the project on another computer:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们之前创建的 `AssetSample` C# 脚本的 `AssetSample.cs.meta` 元文件没有被版本管理系统管理，那么在另一台计算机上克隆并打开项目后，您将遇到如图
    10.30 所示的 `Script Missing` 错误：
- en: '![Figure 10.30 – The Script Missing error'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.30 – 脚本缺失错误'
- en: '](img/Figure_10.30_B17146.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.30_B17146.jpg)'
- en: Figure 10.30 – The Script Missing error
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.30 – 脚本缺失错误
- en: At this point, the script actually exists, but since its GUID has been regenerated,
    the previous reference relationship is invalid.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，脚本实际上存在，但由于其 GUID 已经被重新生成，之前的引用关系无效。
- en: Therefore, when developing a Unity project, please make sure that the meta files
    are managed by your version management tool.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开发 Unity 项目时，请确保元文件被您的版本管理工具管理。
- en: Import settings in meta files
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元文件中的导入设置
- en: In addition to storing the GUID of an asset, a meta file also stores the import
    settings of this asset. Of course, the meta files that will be discussed in this
    subsection mainly refer to the meta files of assets created in third-party software
    and that are then imported into the Unity Editor, such as models, textures, and
    audio.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储资产的 GUID 之外，元文件还存储了该资产的导入设置。当然，本小节中将要讨论的元文件主要是指第三方软件中创建并导入到 Unity 编辑器中的资产元文件，例如模型、纹理和音频。
- en: Let's use a meta file of an audio asset as an example to see how the import
    settings of the asset are saved.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个音频资产的元文件为例，看看资产的导入设置是如何保存的。
- en: 'The audio asset we are using here is from Unity''s Asset Store and you can
    download it from here: [https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047](https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的音频资产来自 Unity 的 Asset Store，您可以从这里下载它：[https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047](https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047)。
- en: '![Figure 10.31 – Audio pack'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.31 – 音频包'
- en: '](img/Figure_10.31_B17146.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.31_B17146.jpg)'
- en: Figure 10.31 – Audio pack
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.31 – 音频包
- en: 'After importing the audio into the Unity project, we can select the first audio
    file in the `Ultra SF Game Audio Weapons Pack v.1` folder to open the audio''s
    Inspector window in the Unity Editor, which shows the asset''s import settings.
    Then we use a text editor to open the meta file of the same audio asset in the
    folder explorer and, as shown in *Figure 10.32*, we can see that `AudioImporter`
    in the meta file corresponds to the import settings in the editor:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在将音频导入Unity项目后，我们可以选择`Ultra SF Game Audio Weapons Pack v.1`文件夹中的第一个音频文件，在Unity编辑器中打开音频的检查器窗口，它显示了资产的导入设置。然后我们使用文本编辑器在文件夹资源管理器中打开同一音频资产的元文件，如图*图10.32*所示，我们可以看到元文件中的`AudioImporter`对应于编辑器中的导入设置：
- en: '![Figure 10.32 – WPN_SCI-FI_FIRE_01 audio''s import settings and meta file'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.32 – WPN_SCI-FI_FIRE_01音频的导入设置和元文件'
- en: '](img/Figure_10.32_B17146.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.32_B17146.jpg)'
- en: Figure 10.32 – WPN_SCI-FI_FIRE_01 audio's import settings and meta file
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32 – WPN_SCI-FI_FIRE_01音频的导入设置和元文件
- en: 'The import settings of a texture asset and a model asset are also stored in
    their meta files. The following screenshot shows the import settings for a texture
    and a model:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理资产和模型资产的导入设置也存储在其元文件中。以下截图显示了纹理和模型的导入设置：
- en: '![Figure 10.33 – Import settings of a texture (left) and the import settings
    of a model (right)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.33 – 纹理的导入设置（左）和模型的导入设置（右）]'
- en: '](img/Figure_10.33_B17146.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.33_B17146.jpg)'
- en: Figure 10.33 – Import settings of a texture (left) and the import settings of
    a model (right)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33 – 纹理的导入设置（左）和模型的导入设置（右）
- en: Since the meta file stores the import settings of the asset, once we modify
    the import settings of the asset in the Unity Editor, the corresponding meta file
    will be updated.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元文件存储了资产的导入设置，一旦我们在Unity编辑器中修改了资产的导入设置，相应的元文件将被更新。
- en: The import settings often affect how Unity processes these assets, so it is
    important to ensure that the import settings can be managed according to the requirements
    of the project. For example, in many mobile game projects, we should check the
    **Force To Mono** option on the audio import settings to reduce the memory usage
    of this audio file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 导入设置通常会影响Unity处理这些资产的方式，因此确保导入设置可以根据项目需求进行管理非常重要。例如，在许多移动游戏项目中，我们应该检查音频导入设置中的**Force
    To Mono**选项，以减少此音频文件的内存使用。
- en: Next, let's take a look at how to manage import settings through a C# script
    in Unity.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在Unity中通过C#脚本管理导入设置。
- en: The AssetPostprocessor class and the import pipeline
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产后处理器类和导入流程
- en: Unity provides the `AssetPostprocessor` class for game developers to hook into
    the assets import pipeline in Unity. When importing an asset, we can manage the
    import pipeline according to the asset type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为游戏开发者提供了`AssetPostprocessor`类，以便将其钩入Unity的资产导入流程。当导入资产时，我们可以根据资产类型管理导入流程。
- en: 'In the following example, we will create a new C# script to set the **Force
    To Mono** option enabled in the import settings of all audio files in the Unity
    projec:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个新的C#脚本，以在Unity项目中所有音频文件的导入设置中启用**Force To Mono**选项：
- en: Create a subfolder in the `Scripts` folder and name it `Editor`. This is because
    the C# class that we will create inherits from the `AssetPostprocessor` class,
    which is a class for the editor, so it needs to be placed in an `Editor` folder.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个子文件夹，命名为`Editor`。这是因为我们将创建的C#类将继承自`AssetPostprocessor`类，这是一个编辑器类，因此它需要放置在`Editor`文件夹中。
- en: '![Figure 10.34 – Creating an Editor folder'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.34 – 创建编辑器文件夹'
- en: '](img/Figure_10.34_B17146.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.34_B17146.jpg)'
- en: Figure 10.34 – Creating an Editor folder
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34 – 创建编辑器文件夹
- en: 'Double-click on the `Editor` folder to enter it, create a new C# script in
    this folder, name it `AssetImporterSample`, and then add the following to this
    script:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Editor`文件夹进入，在此文件夹中创建一个新的C#脚本，命名为`AssetImporterSample`，然后向此脚本中添加以下内容：
- en: '[PRE9]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s break down how this works:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下它是如何工作的：
- en: First, the code is using the `UnityEditor` namespace. This is because the `AssetPostprocessor`
    class is defined in this namespace, which also means that the `AssetImporterSample`
    C# script is used in the Unity Editor and not at runtime.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，代码使用了`UnityEditor`命名空间。这是因为`AssetPostprocessor`类定义在这个命名空间中，这也意味着`AssetImporterSample`
    C#脚本是在Unity编辑器中使用，而不是在运行时使用。
- en: The `AssetImporterSample` class inherits the `AssetPostprocessor` class and
    implements the `OnPreprocessAudio` method, which will be called before the audio
    asset is imported. We can also implement other similar methods to be called when
    other asset types will be imported. For example, the `OnPreprocessTexture` method
    will be called before the texture asset is imported, and the `OnPreprocessModel`
    method will be called before the model asset is imported.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssetImporterSample` 类继承自 `AssetPostprocessor` 类并实现了 `OnPreprocessAudio` 方法，该方法将在音频资产导入之前被调用。我们还可以实现其他类似的方法，以便在其他资产类型导入时被调用。例如，`OnPreprocessTexture`
    方法将在纹理资产导入之前被调用，而 `OnPreprocessModel` 方法将在模型资产导入之前被调用。'
- en: In the `OnPreprocessAudio` method, we can get an instance of `AudioImporter`,
    set the `forceToMono` option to `true`, and then save and re-import the asset
    to ensure that the new import settings for the asset take effect.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `OnPreprocessAudio` 方法中，我们可以获取 `AudioImporter` 的实例，将 `forceToMono` 选项设置为 `true`，然后保存并重新导入资产以确保资产的新导入设置生效。
- en: 'Save the C# script and the Unity Editor should modify the import settings of
    these audio assets in the project and then re-import them, as shown in *Figure
    10.35*:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 C# 脚本后，Unity 编辑器应修改项目中这些音频资产的导入设置，然后重新导入，如图 *图 10.35* 所示：
- en: '![Figure 10.35 – Importing audio assets'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.35 – 导入音频资产](img/Figure_10.35.jpg)'
- en: '](img/Figure_10.35_B17146.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.35_B17146.jpg](img/Figure_10.35_B17146.jpg)'
- en: Figure 10.35 – Importing audio assets
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.35 – 导入音频资产
- en: 'Let''s now select an audio file to check its import settings. As shown in *Figure
    10.36*, the new import settings work as expected:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们选择一个音频文件来检查其导入设置。如图 *图 10.36* 所示，新的导入设置按预期工作：
- en: '![Figure 10.36 – New import settings'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.36 – 新的导入设置](img/Figure_10.36.jpg)'
- en: '](img/Figure_10.36_B17146.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.36_B17146.jpg](img/Figure_10.36_B17146.jpg)'
- en: Figure 10.36 – New import settings
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.36 – 新的导入设置
- en: In this subsection, we introduced how to use C# code to manage the asset import
    pipeline. Next, let's explore another assets workflow topic in Unity – the `Library`
    folder.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们介绍了如何使用 C# 代码来管理资产导入流程。接下来，让我们探索 Unity 中的另一个资产工作流程主题 – `Library` 文件夹。
- en: The Library folder
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Library 文件夹
- en: In a Unity project, Unity will process and convert the external assets into
    Unity internal format assets and save them in the `Library` folder. Because the
    data stored in the `Library` folder is cached data that can always be regenerated
    from the source asset files based on the import settings, the `Library` folder
    should generally not be included in a version management system.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 项目中，Unity 将处理和转换外部资产为 Unity 内部格式资产，并将它们保存在 `Library` 文件夹中。因为 `Library`
    文件夹中存储的数据是缓存数据，可以根据导入设置从源资产文件中重新生成，所以 `Library` 文件夹通常不应包含在版本管理系统中。
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In addition to the `Library` folder, there are some other Unity folders that
    need to be excluded from version management, including `Temp, Obj,` and `Logs`.
    If you are using Git as your version management tool, you can find the `.gitignore`
    file for Unity projects at this link: [https://github.com/github/gitignore/blob/main/Unity.gitignore](https://github.com/github/gitignore/blob/main/Unity.gitignore).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Library` 文件夹外，还有一些其他 Unity 文件夹需要从版本管理中排除，包括 `Temp, Obj,` 和 `Logs`。如果您使用
    Git 作为版本管理工具，您可以在以下链接中找到 Unity 项目的 `.gitignore` 文件：[https://github.com/github/gitignore/blob/main/Unity.gitignore](https://github.com/github/gitignore/blob/main/Unity.gitignore)。
- en: You can find the `Library` folder in the root directory of your Unity project,
    as shown in *Figure 10.37*. If there is no `Libary` folder in the root directory
    of your Unity project, you need to open the project with the Unity Editor. The
    Unity Editor will import the assets in the `Assets` folder and generate the `Library`
    folder automatically.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Unity 项目的根目录中找到 `Library` 文件夹，如图 *图 10.37* 所示。如果您的 Unity 项目根目录中没有 `Library`
    文件夹，您需要使用 Unity 编辑器打开项目。Unity 编辑器将导入 `Assets` 文件夹中的资产并自动生成 `Library` 文件夹。
- en: '![Figure 10.37 – The Library folder'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.37 – Library 文件夹](img/Figure_10.37.jpg)'
- en: '](img/Figure_10.37_B17146.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.37_B17146.jpg](img/Figure_10.37_B17146.jpg)'
- en: Figure 10.37 – The Library folder
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.37 – Library 文件夹
- en: Double-click the `Library` folder to enter it and you will see the `ScriptAssemblies`
    subfolder, which saves the assemblies of the C# code in the project, and you can
    also see the `PackageCache` subfolder, which saves the cache of Unity packages
    used by the project. In addition to these, you also can see the `Artifacts` subfolder,
    where the assets processed by Unity are saved.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 `Library` 文件夹进入它，您将看到 `ScriptAssemblies` 子文件夹，其中保存了项目中 C# 代码的组件，您还可以看到 `PackageCache`
    子文件夹，其中保存了项目使用的 Unity 包的缓存。除了这些，您还可以看到 `Artifacts` 子文件夹，其中保存了由 Unity 处理的资产。
- en: '![Figure 10.38 – The Artifacts folder'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.38 – 资产夹'
- en: '](img/Figure_10.38_B17146.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.38 – 图10.38_B17146.jpg]'
- en: Figure 10.38 – The Artifacts folder
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38 – 资产夹
- en: In this section, we introduced Unity's assets workflow, covering topics such
    as GUIDs, File IDs, meta files, and the `Library` folder. Next, let's take a look
    at the special folders created and managed by developers related to assets management
    in Unity.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Unity的资产工作流程，涵盖了GUID、文件ID、元文件和`库`文件夹等主题。接下来，让我们看看与Unity中的资产管理相关的由开发者创建和管理的特殊文件夹。
- en: Introducing the special folders in Unity
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Unity中的特殊文件夹
- en: We already covered some of these special folders related to scripting in Unity
    in [*Chapter 2*](B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025), *Scripting
    Concepts in Unity*. In this section, we will introduce the remaining special folders,
    which are related to asset management in Unity.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第2章*](B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025)“Unity中的脚本概念”中介绍了一些与Unity脚本相关的特殊文件夹。在本节中，我们将介绍剩余的特殊文件夹，这些文件夹与Unity中的资产管理相关。
- en: Resources folder
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源文件夹
- en: First, let's take a look at the `Resources` folder in Unity. `Resources` is
    a special folder name in Unity, but Unity does not automatically create a `Resources`
    folder for you. If you want to use a `Resources` folder to manage assets, you
    need to create it yourself. It should be noted that there can be multiple `Resources`
    folders in the `Assets` directory in a Unity project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看Unity中的`资源`文件夹。`资源`是Unity中的一个特殊文件夹名称，但Unity不会自动为你创建一个`资源`文件夹。如果你想使用`资源`文件夹来管理资产，你需要自己创建它。需要注意的是，在一个Unity项目中，`Assets`目录中可以有多个`资源`文件夹。
- en: 'Unity provides the `Resources.Load` method to load assets in `Resources` folders.
    Next, we will use an example to learn how to use `Resources` folders to manage
    assets:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了`Resources.Load`方法来加载`资源`文件夹中的资产。接下来，我们将通过一个示例来学习如何使用`资源`文件夹来管理资产：
- en: Create a new folder named `Resources` by clicking the **Create | Folder** item
    in the **Project** window.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**项目**窗口中的**创建 | 文件夹**项，创建一个名为`资源`的新文件夹。
- en: '![Figure 10.39 – Creating a Resources folder'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.39 – 创建资源文件夹'
- en: '](img/Figure_10.39_B17146.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.39 – 图10.39_B17146.jpg]'
- en: Figure 10.39 – Creating a Resources folder
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.39 – 创建资源文件夹
- en: 'Create an empty GameObject, name it `SamplePrefab`, and drag it into the `Resources`
    folder to create a new prefab, as shown in *Figure 10.40*:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空GameObject，命名为`SamplePrefab`，并将其拖入`资源`文件夹以创建一个新的预制体，如图10.40所示：
- en: '![Figure 10.40 – SamplePrefab'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.40 – SamplePrefab'
- en: '](img/Figure_10.40_B17146.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.40 – 图10.40_B17146.jpg]'
- en: Figure 10.40 – SamplePrefab
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.40 – SamplePrefab
- en: 'Create a new C# script in the `ResourcesLoadExample`, and add the following
    to this script:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ResourcesLoadExample`中创建一个新的C#脚本，并将以下内容添加到该脚本中：
- en: '[PRE10]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down how this works:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下它是如何工作的：
- en: In the `Start` method, we call the `Resources.Load` method and pass the path
    to the asset to load as an argument to this method, which is `SamplePrefab`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`方法中，我们调用`Resources.Load`方法，并将要加载的资产的路径作为参数传递给此方法，即`SamplePrefab`。
- en: Then, if the prefab asset is loaded, we instantiate it to create a new GameObject
    in the game Scene.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果预制体资产被加载，我们将实例化它以在游戏场景中创建一个新的GameObject。
- en: Create a new GameObject and attach the `ResourcesLoadExample` script to it.
    Run the game in the Unity Editor by clicking the **Play** button. We can see that
    a new instance of the prefab is created as expected.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的GameObject，并将`ResourcesLoadExample`脚本附加到它上。通过点击Unity编辑器中的**播放**按钮运行游戏。我们可以看到如预期地创建了一个新的预制体实例。
- en: '![Figure 10.41 – Loading assets from the Resources folders'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.41 – 从资源文件夹加载资产'
- en: '](img/Figure_10.41_B17146.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.41 – 图10.41_B17146.jpg]'
- en: Figure 10.41 – Loading assets from the Resources folders
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.41 – 从资源文件夹加载资产
- en: 'Through this example, we see that using `Resources` folders to manage assets
    is very convenient, especially when you need to develop a prototype quickly, but
    managing assets in a Unity project by using `Resources` folders is not recommended
    for the following reasons:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们可以看到使用`资源`文件夹来管理资产非常方便，尤其是在你需要快速开发原型时，但是以下原因不建议在Unity项目中使用`资源`文件夹来管理资产：
- en: When the Unity Editor builds the game, the assets in `Resources` folders will
    be included in the build, even if the assets are not used, so improper use of
    the `Resources` folder may cause the build game to be too large. In addition,
    it will also affect the game's startup speed.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Unity编辑器构建游戏时，`资源`文件夹中的资产将被包含在构建中，即使这些资产没有被使用，因此不恰当地使用`资源`文件夹可能会导致构建的游戏文件过大。此外，它还会影响游戏的启动速度。
- en: Using `Resources` folders will make incremental content upgrades to the game
    very difficult or impossible.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`资源`文件夹将使得游戏内容的增量升级变得非常困难或不可能。
- en: Now that we have an understanding of the `Resources` folders, we know the situations
    in which they will be suitable, such as developing a rapid prototype, as well
    as its limitations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`Resources`文件夹，我们知道它们在哪些情况下将是合适的，例如开发快速原型，以及它们的局限性。
- en: Next, we will continue to introduce another special folder in Unity, namely,
    `StreamingAssets`
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续介绍Unity中的另一个特殊文件夹，即`StreamingAssets`
- en: StreamingAssets folder
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StreamingAssets文件夹
- en: In Unity, `StreamingAssets` is also a special folder name. We actually already
    covered this in [*Chapter 6*](B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095),
    *Integrating Audio and Video in a Unity Project*. In this subsection, we will
    discuss it in more detail.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，`StreamingAssets`也是一个特殊的文件夹名称。我们实际上已经在[*第6章*](B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095)，*在Unity项目中集成音频和视频*中讨论过这一点。在本小节中，我们将更详细地讨论它。
- en: We mentioned earlier that Unity will process assets in the `Assets` folder in
    a format that the Unity engine understands, but there is an exception.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，Unity会以Unity引擎理解的形式处理`Assets`文件夹中的资源，但有一个例外。
- en: The assets in the `StreamingAssets` folder in the Unity project will still be
    in the original format and these assets will not be built into the game along
    with the other assets when Unity builds the game. Instead, all assets in the folder
    will be copied to a specific folder on the target device.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Unity项目中的`StreamingAssets`文件夹中的资源将保持原始格式，并且当Unity构建游戏时，这些资源不会与其他资源一起构建到游戏中。相反，文件夹中的所有资源都将复制到目标设备上的特定文件夹中。
- en: Since the location of this special folder is different on different platforms,
    Unity provides the `Application.streamingAssetsPath` property so that we can access
    the correct path to this folder from C# code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特殊文件夹的位置在不同平台上不同，Unity提供了`Application.streamingAssetsPath`属性，以便我们可以从C#代码中访问到这个文件夹的正确路径。
- en: 'The following code snippet is from the example used in [*Chapter 6*](B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095),
    *Integrating Audio and Video in a Unity Project*. We can see how to use `Application.streamingAssetsPath`
    in C# code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自示例中使用的[*第6章*](B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095)，*在Unity项目中集成音频和视频*。我们可以看到如何在C#代码中使用`Application.streamingAssetsPath`：
- en: '[PRE11]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similar to the `Resources` folder, Unity does not automatically create the
    `StreamingAssets` folder for you. If you wish to use it, you need to create it
    yourself, as shown in *Figure 10.42*:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Resources`文件夹类似，Unity不会自动为您创建`StreamingAssets`文件夹。如果您想使用它，您需要自己创建，如图10.42所示：
- en: '![Figure 10.42 – Creating a StreamingAssets folder'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.42 – 创建StreamingAssets文件夹'
- en: '](img/Figure_10.42_B17146.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.42_B17146.jpg)'
- en: Figure 10.42 – Creating a StreamingAssets folder
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.42 – 创建StreamingAssets文件夹
- en: Then we can place an audio WAV file in the `StreamingAssets` folder. As you
    can see from the following screenshot, the icon of this WAV file is not the same
    as the icon of an audio clip in Unity that we are already familiar with. This
    is because Unity does not process the WAV file; it still maintains its original
    format.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`StreamingAssets`文件夹中放置一个音频WAV文件。如图所示，这个WAV文件的图标与我们在Unity中已经熟悉的音频剪辑图标不同。这是因为Unity没有处理WAV文件；它仍然保持其原始格式。
- en: '![Figure 10.43 – Placing a WAV file in the StreamingAssets folder'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.43 – 在StreamingAssets文件夹中放置WAV文件'
- en: '](img/Figure_10.43_B17146.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.43_B17146.jpg)'
- en: Figure 10.43 – Placing a WAV file in the StreamingAssets folder
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.43 – 在StreamingAssets文件夹中放置WAV文件
- en: In this section, we explored the `Resources` folder and the `StreamingAssets`
    folder, which are special folders in Unity, and understood that what they do can
    help you better develop games with Unity.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了`Resources`文件夹和`StreamingAssets`文件夹，这些是Unity中的特殊文件夹，并了解了它们的功能如何帮助您更好地使用Unity开发游戏。
- en: Next, we'll cover another interesting topic; how to use Azure Blob storage in
    the Azure Cloud with Unity's Addressable Asset system.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍另一个有趣的主题；如何在Azure Cloud中使用Azure Blob存储与Unity的Addressable Asset系统。
- en: Azure Blob storage with Unity's Addressable Asset system
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Blob存储与Unity的Addressable Asset系统
- en: In this section, we'll cover the Azure Blob storage service in Microsoft's Azure
    Cloud and how to use it with Unity's Addressable Asset system.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Microsoft Azure Cloud中的Azure Blob存储服务以及如何使用它与Unity的Addressable Asset系统。
- en: '**Azure Blob storage** is a type of Azure Storage account in Azure. Other types
    of Azure Storage accounts include **queues**, **file shares**, and **tables**.
    Among them, Blob storage is very suitable for storing large amounts of unstructured
    data such as binary data.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Blob 存储**是 Azure 中的 Azure 存储帐户类型之一。其他类型的 Azure 存储帐户包括**队列**、**文件共享**和**表**。其中，Blob
    存储非常适合存储大量非结构化数据，如二进制数据。'
- en: Note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find additional information and resources about the Azure Storage account
    in Microsoft's Azure Cloud at [https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction](https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Microsoft 的 Azure 云中找到有关 Azure 存储帐户的更多信息资源，请参阅[https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction](https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction)。
- en: Unity's Addressable Asset system, as the name suggests, provides a convenient
    method for loading specific assets, whether on the local or remote server, according
    to a specific address. When discussing the `Resources` folder in the previous
    section, we discussed various limitations when using it in terms of managing assets,
    and the Addressable Asset system can solve these problems very well; for example,
    the size of the game package can be well controlled, there is no need to include
    unnecessary assets in game builds, and assets can be hosted on remote servers,
    such as the Azure Cloud, to incrementally update assets within the game.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的 Addressable Asset 系统正如其名所示，提供了一种方便的方法，可以根据特定的地址在本地或远程服务器上加载特定的资产。在上一节讨论“资源”文件夹时，我们讨论了在使用它管理资产时存在的各种限制，而
    Addressable Asset 系统可以很好地解决这些问题；例如，可以很好地控制游戏包的大小，无需在游戏构建中包含不必要的资产，并且可以将资产托管在远程服务器上，例如
    Azure 云，以在游戏中增量更新资产。
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before the Addressable Asset system was introduced, developers could also use
    `AssetBundles` to manage assets; `AssetBundles` is beyond the scope of what we
    need here, but if you're interested, you can find out more at [https://docs.unity3d.com/Manual/AssetBundlesIntro.html](https://docs.unity3d.com/Manual/AssetBundlesIntro.html).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Addressable Asset 系统引入之前，开发者也可以使用 `AssetBundles` 来管理资产；`AssetBundles` 不在我们需要讨论的范围之内，但如果您感兴趣，可以在[https://docs.unity3d.com/Manual/AssetBundlesIntro.html](https://docs.unity3d.com/Manual/AssetBundlesIntro.html)上了解更多信息。
- en: Well, now we have an understanding of Azure Blob storage and the Addressable
    Asset system. Next, we will explore how to use Azure Blob storage to host assets
    and use the Addressable Asset system to manage them.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经了解了 Azure Blob 存储和 Addressable Asset 系统的概念。接下来，我们将探讨如何使用 Azure Blob
    存储来托管资产，并使用 Addressable Asset 系统来管理它们。
- en: Let's start!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Setting up an Azure Blob storage service
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Azure Blob 存储服务
- en: First, make sure you have an available Azure subscription. You can apply for
    a free Azure trial account on the page introduced at the beginning of this chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保您有一个可用的 Azure 订阅。您可以在本章开头介绍的页面上申请免费的 Azure 试用帐户。
- en: If everything is ready, we can create our first resource in Azure, namely, an
    **Azure resource group**.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切准备就绪，我们就可以在 Azure 中创建我们的第一个资源，即**Azure 资源组**。
- en: Creating a new resource group
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的资源组
- en: Usually, a resource group is our first resource in the Azure Cloud. This is
    because a resource group is a container for holding other Azure resources.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，资源组是我们 Azure 云中的第一个资源。这是因为资源组是用于存放其他 Azure 资源的容器。
- en: 'We can create a resource group in just a few steps:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅通过几个步骤就创建一个资源组：
- en: Sign in to the Azure portal page with your account at [https://portal.azure.com/](https://portal.azure.com/).
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的帐户登录到 Azure 门户页面[https://portal.azure.com/](https://portal.azure.com/)。
- en: '![Figure 10.44 – Azure portal page'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.44 – Azure 门户页面'
- en: '](img/Figure_10.44_B17146.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.44_B17146.jpg)'
- en: Figure 10.44 – Azure portal page
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.44 – Azure 门户页面
- en: The Azure portal page does not display the portal menu by default. We can click
    the **Show portal menu** button in the upper-left corner of the page to open the
    portal menu.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure 门户页面默认不显示门户菜单。我们可以点击页面左上角的**显示门户菜单**按钮来打开门户菜单。
- en: '![Figure 10.45 – Show portal menu'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.45 – 显示门户菜单'
- en: '](img/Figure_10.45_B17146.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.45_B17146.jpg)'
- en: Figure 10.45 – Show portal menu
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.45 – 显示门户菜单
- en: Select **Resource groups** from the portal menu.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从门户菜单中选择**资源组**。
- en: '![Figure 10.46 – Selecting the Resource groups service'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.46 – 选择资源组服务'
- en: '](img/Figure_10.46_B17146.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.46_B17146.jpg)'
- en: Figure 10.46 – Selecting the Resource groups service
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.46 – 选择资源组服务
- en: 'The **Resource groups** page will then open. Click the **Create** button on
    this page, as shown in *Figure 10.47*:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后资源组页面将打开。点击此页面上的**创建**按钮，如*图10.47*所示：
- en: '![Figure 10.47 – Creating a resource group'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.47 – 创建资源组'
- en: '](img/Figure_10.47_B17146.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.47_B17146.jpg)'
- en: Figure 10.47 – Creating a resource group
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.47 – 创建资源组
- en: 'Then, you will see the `rg-unitybook-dev-001`. Select the region of the resource
    group as `(Asia Pacific) Australia East` and then click on **Review + create**
    to verify the settings of this resource group and create it, as shown in *Figure
    10.48*:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将看到`rg-unitybook-dev-001`。选择资源组的区域为`(亚太地区) 澳大利亚东部`，然后点击**审查 + 创建**以验证此资源组的设置并创建它，如*图10.48*所示：
- en: '![Figure 10.48 – Creating a resource group'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.48 – 创建资源组'
- en: '](img/Figure_10.48_B17146.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.48_B17146.jpg)'
- en: Figure 10.48 – Creating a resource group
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.48 – 创建资源组
- en: We've created a resource group in Azure. Next, let's create an Azure Storage
    account resource.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已在Azure中创建了一个资源组。接下来，让我们创建一个Azure存储账户资源。
- en: Note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find additional information about the naming convention in Microsoft's
    Azure Cloud at [https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming](https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Microsoft Azure Cloud的命名约定中找到更多信息，请参阅[https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming](https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming)。
- en: Creating a new Azure Storage account resource
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的Azure存储账户资源
- en: In order to set up an Azure Blob storage service, we will need to create an
    Azure Storage account to provide a unique namespace in Azure for the assets that
    will be hosted first.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置Azure Blob存储服务，我们需要创建一个Azure存储账户，为将要托管的第一批资产在Azure中提供一个唯一的命名空间。
- en: 'We will perform the following steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行以下步骤：
- en: 'Go back to the Azure portal page, repeat the steps introduced previously to
    open the portal menu, and then click **Storage accounts** this time, as shown
    in *Figure 10.49*:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Azure门户页面，重复之前介绍的步骤以打开门户菜单，然后这次点击**存储账户**，如*图10.49*所示：
- en: '![Figure 10.49 – Clicking Storage accounts'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.49 – 点击存储账户'
- en: '](img/Figure_10.49_B17146.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.49_B17146.jpg)'
- en: Figure 10.49 – Clicking Storage accounts
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.49 – 点击存储账户
- en: 'The Storage accounts page will then open. Click the **Create** button on this
    page, as shown in *Figure 10.50*:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储账户页面将打开。点击此页面上的**创建**按钮，如*图10.50*所示：
- en: '![Figure 10.50 – Creating a storage account'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.50 – 创建存储账户'
- en: '](img/Figure_10.50_B17146.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.50_B17146.jpg)'
- en: Figure 10.50 – Creating a storage account
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.50 – 创建存储账户
- en: Similar to creating a resource group, on the `unitybookchapter10` and `(Asia
    Pacific) Australia East`, respectively. The other settings can be left as their
    defaults, and then click the **Review + create** button to create the resource.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与创建资源组类似，分别在`unitybookchapter10`和`(亚太地区) 澳大利亚东部`上。其他设置可以保留默认值，然后点击**审查 + 创建**按钮来创建资源。
- en: '![Figure 10.51 – Creating a storage account'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.51 – 创建存储账户'
- en: '](img/Figure_10.51_B17146.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.51_B17146.jpg)'
- en: Figure 10.51 – Creating a storage account
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.51 – 创建存储账户
- en: We can click the notifications button in the upper-right corner of the page
    to view the progress of the resource deployment. When the resource is deployed,
    we can click **Go to resource** to go to the resource page.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以点击页面右上角的“通知”按钮来查看资源部署的进度。当资源部署完成后，我们可以点击**转到资源**来进入资源页面。
- en: '![Figure 10.52 – Notifications'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.52 – 通知'
- en: '](img/Figure_10.52_B17146.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.52_B17146.jpg)'
- en: Figure 10.52 – Notifications
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.52 – 通知
- en: 'As shown in *Figure 10.53*, a Storage account named `unitybookchapter10` is
    created:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*图10.53*所示，已创建一个名为`unitybookchapter10`的存储账户：
- en: '![Figure 10.53 – The Storage account page'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.53 – 存储账户页面'
- en: '](img/Figure_10.53_B17146.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.53_B17146.jpg)'
- en: Figure 10.53 – The Storage account page
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.53 – 存储账户页面
- en: At this point, we have set up a Storage account resource in Azure. Next, let's
    set up Blob Storage.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已在Azure中设置了一个存储账户资源。接下来，让我们设置Blob存储。
- en: Creating a container
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建容器
- en: 'As we mentioned at the beginning of this section, Blob Storage is a type of
    Azure Storage account, so we can find the settings for Blob Storage on the Storage
    account page we just opened. We can perform the following steps to set up Blob
    Storage:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在此节开头所述，Blob 存储是一种 Azure 存储账户类型，因此我们可以在刚刚打开的存储账户页面上找到 Blob 存储的设置。我们可以执行以下步骤来设置
    Blob 存储：
- en: First, we need to create a container, similar to a directory in the filesystem
    on our computers, to organize a group of files, and a container to organize a
    group of blobs on the Azure Cloud. Scroll down the menu on the left side of the
    Storage account page and, in the **Data storage** section, we can see four different
    storage types. Then, select **Containers**.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个容器，类似于我们在计算机文件系统中的目录，用于组织一组文件，并在 Azure 云上组织一组 blob 的容器。向下滚动存储账户页面左侧的菜单，在
    **Data storage** 部分中，我们可以看到四种不同的存储类型。然后，选择 **Containers**。
- en: '![Figure 10.54 – Selecting containers'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.54 – 选择容器'
- en: '](img/Figure_10.54_B17146.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.54_B17146.jpg)'
- en: Figure 10.54 – Selecting containers
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.54 – 选择容器
- en: 'Then, click the **+ Container** button, as shown in *Figure 10.55*:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击如图 *图 10.55* 所示的 **+ 容器** 按钮：
- en: '![Figure 10.55 – Clicking the + Container button'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.55 – 点击 + 容器按钮'
- en: '](img/Figure_10.55_B17146.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.55_B17146.jpg)'
- en: Figure 10.55 – Clicking the + Container button
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.55 – 点击 + 容器按钮
- en: In the `remotedata` as the name of the container, and for simplicity, we set
    **Public access level** to **Blob** to allow anonymous access to blobs inside
    the container.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `remotedata` 中作为容器的名称，并且为了简单起见，我们将 **Public access level** 设置为 **Blob** 以允许匿名访问容器内的
    blob。
- en: '![Figure 10.56 – Creating a new container'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.56 – 创建新的容器'
- en: '](img/Figure_10.56_B17146.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.56_B17146.jpg)'
- en: Figure 10.56 – Creating a new container
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.56 – 创建新的容器
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For security purposes, you should try to manage access to blobs in a more secure
    way, for example, by using an **access key** for authorization, or by using a
    **Shared Access Signature (SAS)** to delegate access. If you're interested, you
    can find out more at [https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal](https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，您应该尝试以更安全的方式管理对 blob 的访问，例如，使用 **访问密钥** 进行授权，或使用 **共享访问签名 (SAS)** 来委派访问。如果您感兴趣，可以在
    [https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal](https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal)
    上了解更多信息。
- en: Now that we have set up Azure Blob storage, we also need to use the Addressable
    Assets system in Unity to create asset packages and deploy them to Azure.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 Azure Blob 存储，我们还需要在 Unity 中使用 Addressable Assets 系统来创建资产包并将它们部署到
    Azure。
- en: Installing the Addressable Assets system package
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Addressable Assets 系统包
- en: By default, the Addressable Asset system is not available in a Unity project.
    So, we need to install the `Addressables` package first.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Addressable Asset 系统在 Unity 项目中不可用。因此，我们需要首先安装 `Addressables` 包。
- en: As shown in *Figure 10.57*, we can find this package in Unity's Package Manager
    and install it in our project.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10.57* 所示，我们可以在 Unity 的包管理器中找到此包，并将其安装到我们的项目中。
- en: '![Figure 10.57 – Installing the Addressables package'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.57 – 安装 Addressables 包'
- en: '](img/Figure_10.57_B17146.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.57_B17146.jpg)'
- en: Figure 10.57 – Installing the Addressables package
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.57 – 安装 Addressables 包
- en: Once installed, you can find the **Addressables** item in the **Window** menu
    of the Unity Editor.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以在 Unity 编辑器的 **Window** 菜单中找到 **Addressables** 项。
- en: '![Figure 10.58 – Addressables item'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.58 – Addressables 项'
- en: '](img/Figure_10.58_B17146.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.58_B17146.jpg)'
- en: Figure 10.58 – Addressables item
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.58 – Addressables 项
- en: Next, let's build addressable content by using the Addressable Assets system.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 Addressable Assets 系统构建可寻址内容。
- en: Building addressable content
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建可寻址内容
- en: 'Building addressable content that can be hosted on the Azure Cloud sounds complicated,
    but we can break this task down further into the following tasks:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可在 Azure 云上托管的可寻址内容听起来很复杂，但我们可以将此任务进一步分解为以下任务：
- en: First, mark an asset as addressable.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将资产标记为可寻址。
- en: Then, enable the remote catalog.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，启用远程目录。
- en: And finally, build the content.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建内容。
- en: Now, let's move on to explore the first task.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探索第一个任务。
- en: Marking addressable assets
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记可寻址资产
- en: In the Unity Editor, we can easily mark an asset as addressable. Before we mark
    an addressable asset, let's create a new asset first. We can create a new cube
    in the Scene, name it `SampleContentOnAzure`, and drag it into the **Project**
    window to create a new prefab asset.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中，我们可以轻松地将资产标记为地址化。在我们标记地址化资产之前，让我们首先创建一个新的资产。我们可以在场景中创建一个新的立方体，命名为
    `SampleContentOnAzure`，并将其拖到 **项目** 窗口中以创建一个新的预制件资产。
- en: 'Then, select this new prefab to open its **Inspector** window and you can see
    the **Addressable** checkbox in the window, as shown in *Figure 10.59*:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择此新预制件以打开其 **检查器** 窗口，您可以在窗口中看到 *图 10.59* 中所示的 **地址化** 复选框：
- en: '![Figure 10.59 – Marking an addressable asset'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.59 – 标记地址化资产'
- en: '](img/Figure_10.59_B17146.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.59_B17146.jpg)'
- en: Figure 10.59 – Marking an addressable asset
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.59 – 标记地址化资产
- en: By checking this checkbox, we will mark the prefab asset as addressable.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 通过勾选此复选框，我们将标记预制件资产为地址化。
- en: Enabling the remote catalog
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用远程目录
- en: Before enabling the remote catalog in the Addressable Asset settings, we can
    first create a new profile that defines variables such as `RemoteLoadPath`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用地址化资产设置中的远程目录之前，我们首先可以创建一个新的配置文件，该配置文件定义了诸如 `RemoteLoadPath` 这样的变量。
- en: Creating a profile
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建配置文件
- en: 'So, let''s start by creating a profile using the following steps:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照以下步骤创建一个配置文件：
- en: In the toolbar, click on **Window | Asset Management | Addressables | Profiles**.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏中，点击 **窗口 | 资产管理 | 地址化 | 配置文件**。
- en: '![Figure 10.60 – Opening the Profiles window'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.60 – 打开配置文件窗口'
- en: '](img/Figure_10.60_B17146.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.60_B17146.jpg)'
- en: Figure 10.60 – Opening the Profiles window
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.60 – 打开配置文件窗口
- en: In the **Addressables Profiles** window, click the **Create** button and select
    **Profile** in the drop-down menu to create a new profile.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **地址化配置文件** 窗口中，点击 **创建** 按钮，然后在下拉菜单中选择 **配置文件** 以创建一个新的配置文件。
- en: '![Figure 10.61 – Creating a new profile'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.61 – 创建新配置文件'
- en: '](img/Figure_10.61_B17146.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.61_B17146.jpg)'
- en: Figure 10.61 – Creating a new profile
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.61 – 创建新配置文件
- en: Then, rename this new profile to **AzureCloud** and enter the URL of the Azure
    Blob container in relation to the **RemoteLoadPath** variable.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此新配置文件重命名为 **AzureCloud** 并输入与 **RemoteLoadPath** 变量相关的 Azure Blob 容器 URL。
- en: '![Figure 10.62 – Setting up the new profile'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.62 – 设置新配置文件'
- en: '](img/Figure_10.62_B17146.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.62_B17146.jpg)'
- en: Figure 10.62 – Setting up the new profile
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.62 – 设置新配置文件
- en: 'If you don''t know the URL of the Azure Blob container, you can find it on
    the container''s **Properties** page in Azure, as shown in the following screenshot:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道 Azure Blob 容器的 URL，您可以在 Azure 中容器属性页面上找到它，如下面的截图所示：
- en: '![Figure 10.63 – Container Properties'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.63 – 容器属性'
- en: '](img/Figure_10.63_B17146.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.63_B17146.jpg)'
- en: Figure 10.63 – Container Properties
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.63 – 容器属性
- en: Creating a new addressables group
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建新的地址化组
- en: Next, we also need to create a new **addressables group**, which is a container
    for addressable assets and their data, and can determine whether the assets within
    the group will be hosted on a remote server or stored locally. We can then place
    assets that need to be hosted on a remote server in this new group without changing
    the local location configured in the default group.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要创建一个新的 **地址化组**，这是一个用于地址化资产及其数据的容器，并可以确定组内的资产是否托管在远程服务器上或存储在本地。然后，我们可以将需要托管在远程服务器上的资产放置在这个新组中，而无需更改默认组中配置的本地位置。
- en: 'Let''s perform the following steps:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: In the toolbar, click on **Window | Asset Management | Addressables | Groups**.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏中，点击 **窗口 | 资产管理 | 地址化 | 组**。
- en: '![Figure 10.64 – Opening the Groups window'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.64 – 打开组窗口'
- en: '](img/Figure_10.64_B17146.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.64_B17146.jpg)'
- en: Figure 10.64 – Opening the Groups window
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.64 – 打开组窗口
- en: In the **Addressables Groups** window, click the **Create** button, then select
    **Group > Packed Assets** to create a new group.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **地址化组** 窗口中，点击 **创建** 按钮，然后选择 **组 > 打包资产** 来创建一个新的组。
- en: '![Figure 10.65 – Creating a new group'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.65 – 创建新组'
- en: '](img/Figure_10.65_B17146.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.65_B17146.jpg)'
- en: Figure 10.65 – Creating a new group
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.65 – 创建新组
- en: Rename it to **Azure Remote Group**.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 将其重命名为 **Azure 远程组**。
- en: '![Figure 10.66 – Azure Remote Group'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.66 – Azure 远程组'
- en: '](img/Figure_10.66_B17146.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.66_B17146.jpg)'
- en: Figure 10.66 – Azure Remote Group
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.66 – Azure 远程组
- en: Change the active profile from **Default** to **AzureCloud** so that the Addressable
    Assets system can access the variables in **AzureCloud**.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将活动配置文件从 **默认** 更改为 **AzureCloud**，以便可寻址资产系统可以访问 **AzureCloud** 中的变量。
- en: '![Figure 10.67 – Activating the AzureCloud profile'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.67 – 激活 AzureCloud 配置文件'
- en: '](img/Figure_10.67_B17146.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.67_B17146.jpg)'
- en: Figure 10.67 – Activating the AzureCloud profile
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.67 – 激活 AzureCloud 配置文件
- en: Select the Azure remote group in the **Addressables Groups** window to open
    its **Inspector** window and set **Content Packing & Loading** using the remote
    path defined in the **AzureCloud** profile.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **可寻址组** 窗口中选择 Azure 远程组以打开其 **检查器** 窗口，并使用在 **AzureCloud** 配置文件中定义的远程路径设置
    **内容打包和加载**。
- en: '![Figure 10.68 – Setting up the addressables group'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.68 – 设置可寻址组'
- en: '](img/Figure_10.68_B17146.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.68_B17146.jpg)'
- en: Figure 10.68 – Setting up the addressables group
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.68 – 设置可寻址组
- en: By default, the marked addressable asset will be under **Default Local Group**;
    we need to move it to the Azure remote group we just created.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，标记的可寻址资产将位于 **默认本地组** 下；我们需要将其移动到我们刚刚创建的 Azure 远程组。
- en: '![Figure 10.69 – Moving the asset to Azure Remote Group'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.69 – 将资产移动到 Azure 远程组'
- en: '](img/Figure_10.69_B17146.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.69_B17146.jpg)'
- en: Figure 10.69 – Moving the asset to Azure Remote Group
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.69 – 将资产移动到 Azure 远程组
- en: Finally, we also need to set a label, `Addressables.LoadResourceLocationsAsync`
    method with this key in C# code.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要在 C# 代码中设置一个标签，使用此键的 `Addressables.LoadResourceLocationsAsync` 方法。
- en: '![Figure 10.70 – Setting a label'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.70 – 设置标签'
- en: '](img/Figure_10.70_B17146.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.70_B17146.jpg)'
- en: Figure 10.70 – Setting a label
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.70 – 设置标签
- en: Now that we've set up the addressables group, next, let's move on to enable
    the ability to build remote content.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了可寻址组，接下来，让我们继续启用构建远程内容的能力。
- en: Enabling the Build Remote Catalog checkbox
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用构建远程目录复选框
- en: Back to the toolbar, click on **Window | Asset Management | Addressables | Settings**
    to open the **Addressable Asset Settings** window.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回工具栏，点击 **窗口 | 资产管理 | 可寻址 | 设置** 以打开 **可寻址资产设置** 窗口。
- en: '![Figure 10.71 – Opening the Addressable Asset Settings window'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.71 – 打开可寻址资产设置窗口'
- en: '](img/Figure_10.71_B17146.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.71_B17146.jpg)'
- en: Figure 10.71 – Opening the Addressable Asset Settings window
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.71 – 打开可寻址资产设置窗口
- en: Scroll down the window and you will find the **Content Update** section. Then,
    check the **Build Remote Catalog** checkbox and set the **Build Path** and **Load
    Path** fields, respectively.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动窗口，你将找到 **内容更新** 部分。然后，勾选 **构建远程目录** 复选框，并分别设置 **构建路径** 和 **加载路径** 字段。
- en: '![Figure 10.72 – The Build Remote Catalog settings'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.72 – 构建远程目录设置'
- en: '](img/Figure_10.72_B17146.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.72_B17146.jpg)'
- en: Figure 10.72 – The Build Remote Catalog settings
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.72 – 构建远程目录设置
- en: Now that you know how to enable the remote catalog in the Addressable Asset
    system, I think you're ready and can't wait to learn how to build the content.
    Let's go!
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在可寻址资产系统中启用远程目录，我认为你已经准备好了，迫不及待地想要学习如何构建内容。让我们开始吧！
- en: Building the content
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建内容
- en: 'It''s finally time to build the content with the help of the following steps:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在以下步骤的帮助下构建内容了：
- en: 'Go back to the **Addressables Groups** window, click **Play Mode Script**,
    and select **Use Existing Build (requires built groups)** in the drop-down menu,
    as shown in *Figure 10.73*:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 **可寻址组** 窗口，点击 **播放模式脚本**，并在下拉菜单中选择如图 *图 10.73* 所示的 **使用现有构建（需要构建组）**：
- en: '![Figure 10.73 – Setting up the Play mode scripts'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.73 – 设置播放模式脚本'
- en: '](img/Figure_10.73_B17146.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.73_B17146.jpg)'
- en: Figure 10.73 – Setting up the Play mode scripts
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.73 – 设置播放模式脚本
- en: Note
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unity provides developers with three build scripts to create play mode data.
    Here, we are using **Use Existing Build** mode, which best matches the game build
    deployed. You can find more information about build scripts in the Addressable
    Asset system at [https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html](mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 为开发者提供了三个构建脚本以创建播放模式数据。在这里，我们使用 **使用现有构建** 模式，这与部署的游戏构建最匹配。你可以在 [https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html](mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html)
    找到有关可寻址资产系统构建脚本的更多信息。
- en: Then, click **Build | New Build | Default Build Script** to build the content.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**构建 | 新构建 | 默认构建脚本**来构建内容。
- en: '![Figure 10.74 – Building the content'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.74 – 构建内容'
- en: '](img/Figure_10.74_B17146.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.74_B17146.jpg)'
- en: Figure 10.74 – Building the content
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.74 – 构建内容
- en: Wait for the build to complete and then you can find the build in the `ServerData`
    folder in your project root.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待构建完成，然后你可以在项目根目录下的`ServerData`文件夹中找到构建的内容。
- en: '![Figure 10.75 – ServerData'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.75 – ServerData'
- en: '](img/Figure_10.75_B17146.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.75_B17146.jpg)'
- en: Figure 10.75 – ServerData
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.75 – ServerData
- en: Now that you know how to build addressable content in the Addressable Asset
    system, next, let's move on to deploy the content to the Azure Cloud.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在Addressable Asset系统中构建可寻址内容，接下来，让我们继续学习如何将内容部署到Azure云。
- en: Deploying content to the Azure Cloud
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将内容部署到Azure云
- en: 'To deploy the addressable content we just built to the Azure Cloud, follow
    these steps:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们刚刚构建的可寻址内容部署到Azure云，请按照以下步骤操作：
- en: Navigate to the **remotedata** container we created in Azure and then click
    the **Upload** button.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到我们在Azure中创建的**remotedata**容器，然后点击**上传**按钮。
- en: '![Figure 10.76 – The remotedata container page'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.76 – 远程数据容器页面'
- en: '](img/Figure_10.76_B17146.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.76_B17146.jpg)'
- en: Figure 10.76 – The remotedata container page
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.76 – 远程数据容器页面
- en: An **Upload blob** panel will then appear. Select the files you want to upload
    and click the **Upload** button.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将出现一个**上传blob**面板。选择您想要上传的文件，然后点击**上传**按钮。
- en: '![Figure 10.77 – Uploading the content'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.77 – 上传内容'
- en: '](img/Figure_10.77_B17146.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.77_B17146.jpg)'
- en: Figure 10.77 – Uploading the content
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.77 – 上传内容
- en: Wait for the upload to finish and then we can see our addressable content in
    the blobs list in the **remotedata** container.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待上传完成，然后我们可以在**remotedata**容器中的blob列表中看到我们的可寻址内容。
- en: '![Figure 10.78 – The addressable content in Azure'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.78 – Azure中的可寻址内容'
- en: '](img/Figure_10.78_B17146.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.78_B17146.jpg)'
- en: Figure 10.78 – The addressable content in Azure
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.78 – Azure中的可寻址内容
- en: Now that you know how to deploy addressable content to the Azure Cloud, next,
    let's move on to exploring how to load content into your game from Azure.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何将可寻址内容部署到Azure云，接下来，让我们继续探索如何从Azure加载内容到你的游戏中。
- en: Loading addressable content from the Azure Cloud
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Azure云加载可寻址内容
- en: Since we are using the Addressable Asset system to manage assets, loading content
    from the Azure Cloud into the game also needs to use the methods provided by the
    Addressable Asset system.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Addressable Asset系统来管理资产，因此从Azure云加载内容到游戏也需要使用Addressable Asset系统提供的方法。
- en: Let's get started!
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'Create a new C# script in the `Scripts` folder, name it `LoadAddressableContentFromAzureCloud`,
    and add the following to this script:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`LoadAddressableContentFromAzureCloud`，并将以下内容添加到该脚本中：
- en: '[PRE12]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the code, we first provide `_assetKey`, whose value is the
    label of the asset we set in the previous section. Then, we call the `Addressables.LoadResourceLocationsAsync`
    method to load content and `Addressables.InstantiateAsync` to instantiate a GameObject.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在代码中所见，我们首先提供了`_assetKey`，其值为我们在上一节中设置的资产的标签。然后，我们调用`Addressables.LoadResourceLocationsAsync`方法来加载内容，并调用`Addressables.InstantiateAsync`来实例化一个GameObject。
- en: Create a new GameObject, attach the `LoadAddressableContentFromAzureCloud` script
    to it, set the value of `Asset Key` to `Azure`, and then run the game in the Unity
    Editor by clicking the **Play** button. We can see that a new instance of the
    prefab is created as expected.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的GameObject，将其`Asset Key`的值设置为`Azure`，并将`LoadAddressableContentFromAzureCloud`脚本附加到它上，然后在Unity编辑器中通过点击**播放**按钮运行游戏。我们可以看到如预期地创建了一个新的预制体实例。
- en: '![Figure 10.79 – Loading the addressable content from the Azure Cloud'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.79 – 从Azure云加载可寻址内容'
- en: '](img/Figure_10.79_B17146.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.79_B17146.jpg)'
- en: Figure 10.79 – Loading the addressable content from the Azure Cloud
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.79 – 从Azure云加载可寻址内容
- en: By reading this section, you learned what the Azure Blob storage service in
    the Microsoft Azure Cloud is and how to use it with Unity's Addressable Asset
    system to host and update game content. This section also brings us to the end
    of the chapter!
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本节，你了解了Microsoft Azure云中的Azure Blob存储服务是什么，以及如何使用Unity的Addressable Asset系统来托管和更新游戏内容。本节也标志着本章的结束！
- en: Summary
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've come a long way in this chapter. We started by introducing Unity's serialization
    system, discussing binary serialization, YAML serialization, and JSON serialization
    in Unity. Then we explored the assets workflow in Unity, covering important concepts
    such as GUIDs, File IDs, meta files, the `Library` folder, and how to manage the
    assets import pipeline from C# code. Next, we discussed the `Resources` folder
    and the `StreamingAssets` folder in detail, which are special folders in Unity,
    and understood that what they do can help you better develop games with Unity.
    Finally, we covered quite a bit about Azure Blob storage and Unity's Addressable
    Asset system, from how to create an Azure Blob storage service in the Azure Cloud
    to how to load the addressable content from Azure into a Unity project. It's been
    an amazing journey!
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经走得很远了。我们首先介绍了 Unity 的序列化系统，讨论了 Unity 中的二进制序列化、YAML 序列化和 JSON 序列化。然后我们探讨了
    Unity 中的资产工作流程，涵盖了诸如 GUID、文件 ID、元文件、`Library` 文件夹以及如何从 C# 代码中管理资产导入管道等重要概念。接下来，我们详细讨论了
    `Resources` 文件夹和 `StreamingAssets` 文件夹，这些是 Unity 中的特殊文件夹，并理解了它们的功能可以帮助你更好地使用 Unity
    开发游戏。最后，我们详细介绍了 Azure Blob 存储和 Unity 的可寻址资产系统，从如何在 Azure 云中创建 Azure Blob 存储服务到如何将可寻址内容从
    Azure 加载到 Unity 项目中。这是一段令人惊叹的旅程！
- en: The knowledge you have acquired in this chapter will help you choose the appropriate
    serialization mode in Unity according to your needs, manage assets reasonably,
    and use the Azure Cloud to achieve incremental updates of game content.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中你获得的知识将帮助你根据需求在 Unity 中选择合适的序列化模式，合理管理资产，并利用 Azure 云实现游戏内容的增量更新。
- en: In the next chapter, we will continue this wonderful journey to explore how
    to create games with Unity, Microsoft Game Dev, and the Azure Cloud.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将继续这段美好的旅程，探索如何使用 Unity、Microsoft Game Dev 和 Azure 云来创建游戏。
