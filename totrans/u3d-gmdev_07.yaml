- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Rigid Bodies and Physics Interaction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚体与物理交互
- en: 'In many game interactions, there needs to be physics. Whether you have items
    falling, bouncing, or just reacting to a collision in a procedural manner, you
    will most likely need to use Rigidbody components on your GameObjects. This component
    works with physics. We will first go through several use cases for the Rigidbody
    component. Once we’ve been through that, we will take some time to explain how
    we are using physics in our interactions for our project. Finally, we will show
    the scripting that is used to achieve these interactions in as much detail as
    possible. As always, the project files on GitHub will follow the structure in
    the *Readme* file. The topics in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏交互中，需要物理。无论你有物品下落、弹跳，还是以程序方式对碰撞做出反应，你很可能需要在你的GameObject上使用Rigidbody组件。此组件与物理一起工作。我们将首先介绍Rigidbody组件的几个用例。一旦我们了解了这些，我们将花些时间解释我们如何在项目中使用物理进行交互。最后，我们将尽可能详细地展示用于实现这些交互的脚本。像往常一样，GitHub上的项目文件将遵循*Readme*文件中的结构。本章包括以下主题：
- en: The Rigidbody component
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rigidbody组件
- en: Collision detection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Design and implementation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计与实现
- en: Telekinesis and physics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 心灵感应与物理
- en: The Rigidbody component
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rigidbody组件
- en: This powerful physics-focused component can be added to GameObjects to determine
    its position through physics. By default, just adding this component to a GameObject
    will put its motion under the influence of gravity. To understand how Unity uses
    physics, let’s take some time to look at the component.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个强大的以物理为重点的组件可以添加到GameObject中，通过物理确定其位置。默认情况下，只需将此组件添加到GameObject中，就会使其运动受到重力的影响。为了了解Unity如何使用物理，让我们花些时间看看这个组件。
- en: '*Figure 7.1* is a screenshot of the Rigidbody in Unity. There is a Rigidbody
    2D component. Do not use this component for a 3D application. The primary problem
    with this is that the 2D and 3D versions of the physics steps do not interact
    with each other. It’s best to choose one and stick with it! We will go through
    all the pieces to the **Rigidbody** component after the figure.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1* 是Unity中Rigidbody的截图。这里有一个Rigidbody 2D组件。不要在3D应用程序中使用此组件。这个问题的主要问题是2D和3D版本的物理步骤不会相互交互。最好选择一个并坚持下去！在图之后，我们将详细介绍Rigidbody组件的所有部分。'
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_07_01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成，置信度中等](img/B17304_07_01.png)'
- en: 'Figure 7.1: Rigidbody component'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：Rigidbody组件
- en: Mass
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量
- en: The **Mass** property of the Rigidbody refers to that object’s relationship
    to other object’s masses. This will not make gravity affect it differently, but
    it will affect collisions with other objects. For example, if two GameObjects
    that are identical except for their mass on the Rigidbody collide, the item with
    the larger mass will act as though it’s heavier. Just as in the real world, mass
    doesn’t cause items to fall faster. This is due to the drag of the objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Rigidbody的**质量**属性指的是该对象与其他对象质量的关系。这不会使重力对其产生不同的影响，但它会影响与其他对象的碰撞。例如，如果两个GameObject在Rigidbody上的质量相同，除了质量外，它们相撞时，质量较大的物品会表现得像更重。就像在现实世界中一样，质量不会使物品下落得更快。这是由于物体的阻力造成的。
- en: Drag
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 阻力
- en: Objects with **Drag** will decrease the rate at which it accelerates due to
    gravity. An example of this is a parachute. This object drastically decreases
    the acceleration of falling. For example, a skydiver has a very low drag, and
    when they open their parachute, the drag increases a lot. This is regardless of
    the rotation of the object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 带有**阻力**的对象将降低由于重力引起的加速度。一个例子就是降落伞。这个物体会大大降低下落的加速度。例如，跳伞者的阻力非常低，当他们打开降落伞时，阻力会大大增加。这与物体的旋转无关。
- en: Angular Drag
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角阻力
- en: '**Angular Drag** is the same concept as drag; however, it’s specifically focused
    on rotation values. If you have a very small value for the angular drag, the object
    will rotate when bumped or collided with depending on the colliding object’s oncoming
    angle. If you raise the value, it will rotate less.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**角阻力**与阻力概念相同；然而，它专门关注旋转值。如果你角阻力的值非常小，物体在被撞击或碰撞时将旋转，具体取决于碰撞物体的来角。如果你提高这个值，它将旋转得少一些。'
- en: Use Gravity boolean
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用重力布尔值
- en: 'The **Use Gravity** boolean simply allows gravity to affect the GameObject;
    the Rigidbody is a component of. As shown in *Figure 7.2*, in **Edit** > **Project
    Settings** > **Physics**, gravity is defined as -`9.81`, which is the same as
    Earth’s gravity. Adjusting the **Y** axis gravity setting to -`9.81` will be the
    most familiar to the players in emulating the likeness of Earth’s gravity. If
    you are working with a game with less gravity and it’s the same all the time,
    you can set it here. You can also set the gravity in code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用重力**布尔值仅允许重力影响GameObject；Rigidbody是其组件。如*图7.2*所示，在**编辑** > **项目设置** > **物理**中，重力被定义为-`9.81`，这与地球的重力相同。将**Y**轴重力设置调整为-`9.81`将使玩家在模拟地球重力时感到最熟悉。如果你正在制作重力较小且始终相同的游戏，你可以在这里设置它。你还可以在代码中设置重力：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The 0s should be replaced with the values of gravity that are needed, generally
    in the *y* direction.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 0应该替换为所需的引力值，通常在*y*方向。
- en: '![Graphical user interface  Description automatically generated](img/B17304_07_02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 描述自动生成](img/B17304_07_02.png)'
- en: 'Figure 7.2: Project Settings – Physics settings'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：项目设置 – 物理设置
- en: Is Kinematic boolean
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否是运动学布尔值
- en: When designing the level, there may be items that move around that need to affect
    the physics of another Rigidbody during runtime. A very simple example you could
    imagine is a sphere with a Rigidbody above a large cube. When you press play,
    the sphere would fall and hit the cube as expected. If you had the **Is Kinematic**
    boolean set to false and tried to rotate the cube, the sphere would stay put and
    clip through the cube. This is due to the cube not updating itself as a moving
    body after the sphere hit it and stopped. Setting this flag is helpful during
    an optimization pass, and it can be set for every known static item that still
    needs to have a Rigidbody component. Although, if you need to update the physics
    during runtime, set the ground to kinematic and when you rotate it, the sphere
    will react as expected and try to roll off the sloping downside of the cube.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计关卡时，可能会有一些在运行时需要影响其他Rigidbody物理的移动项目。一个你可以想象到的非常简单的例子是一个带有Rigidbody的球体在大型立方体上方。当你按下播放时，球体会像预期的那样落下并击中立方体。如果你将**是否运动学**布尔值设置为false并尝试旋转立方体，球体会保持原位并穿过立方体。这是由于立方体在球体击中它并停止后没有作为移动体更新自己。设置此标志有助于优化过程，并且可以设置每个已知的静态项目，这些项目仍然需要具有Rigidbody组件。尽管如此，如果你需要在运行时更新物理，将地面设置为运动学，并在你旋转它时，球体将像预期的那样反应，并试图从立方体的斜坡下滚落。
- en: This is a very common mistake when you start working with physics items. If
    during runtime your Rigidbody items aren’t moving in a way you’d expect, check
    to see if they should be kinematic.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在你开始使用物理项目时一个非常常见的错误。如果在运行时你的Rigidbody项目没有以你预期的方式移动，请检查它们是否应该是运动学的。
- en: Interpolate
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值
- en: '**Interpolate** means to place things in between other things. In our case,
    we need to know if interpolating is attempting to achieve one of three parameters
    in our physics update.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**插值**意味着将事物放置在其他事物之间。在我们的案例中，我们需要知道插值是否试图在物理更新中实现三个参数之一。'
- en: 'Those parameters are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数是：
- en: '**None**: Do not interpolate or extrapolate'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：不插值或外推'
- en: '**Interpolate**: Place the object in between the current frame and the next
    frame'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插值**：将对象放置在当前帧和下一帧之间'
- en: '**Extrapolate**: Assume the next location from the previous frames and put
    it where you think it might go'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外推**：假设从前一帧的下一个位置，并将其放置在你认为它可能会去的地方'
- en: Figuring out the appropriate parameters to interpolate can be complicated to
    answer. The reason being is that there is more than one option when addressing
    interpolation, therefore, making the solution not as straightforward to resolve.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 确定适当的插值参数可能很复杂。原因是处理插值时有多于一个选项，因此，使得解决方案不是那么直接就能解决。
- en: 'There are multiple variables to account for. These variables may contain these
    questions such as: How is the camera moving? Is the object moving quickly? Are
    you worried about the collision looking correct? Are you worried about the object
    moving incorrectly every time as the camera follows its motion? A simple answer
    is if your camera follows a character using a Rigidbody, then set it to **Interpolate**
    and everything else to **None**.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个变量需要考虑。这些变量可能包含这些问题，例如：摄像机是如何移动的？对象移动得快吗？你是否担心碰撞看起来是否正确？你是否担心对象每次跟随摄像机移动时都会移动不正确？一个简单的答案是，如果你的摄像机使用Rigidbody跟随角色，那么将其设置为**插值**，其他所有设置为**无**。
- en: Diving into the physics system just a little bit, this system is calculated
    at a fixed interval, in contrast to graphics rendering. Graphics on a game can
    lag slightly and pop into place, where the physics will always calculate at a
    fixed interval. This can cause artifacts to visually occur, such as clipping into
    a wall. Clipping into a wall or other game objects within your scene would be
    seen if a fast-moving object is being followed closely by the camera and collides
    with the wall or surrounding GameObjects. The object would initially clip through
    the wall until the physics gets updated, and it would then update as though it
    bounced off the wall.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解物理系统，这个系统是以固定间隔进行计算的，与图形渲染不同。游戏中图形可能会稍微滞后并突然出现，而物理计算则始终以固定间隔进行。这可能导致视觉上的伪影，例如物体剪裁到墙上。如果快速移动的物体被相机紧随其后，并且与墙壁或周围的GameObject发生碰撞，就会看到物体剪裁到墙内或其他游戏对象。物体最初会穿过墙壁，直到物理更新，然后它会像反弹一样更新。
- en: In this case, you would want to choose the **Interpolate** option because the
    physics system would interpolate the in-between values as the graphics are being
    rendered. This doesn’t allow clipping while moving in a physics sense. It does
    cost some performance as it’s calculating values in different intervals than it
    would normally.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能会想选择**插值**选项，因为物理系统会在图形渲染时插值中间值。这不允许在物理意义上的移动时发生剪裁。但这会消耗一些性能，因为它在不同于正常情况的不同间隔计算值。
- en: '**Extrapolate** does a good job of figuring out what the values will be in
    the future. This is helpful for simulating a flying object, but not good for collision
    detection as it will assume it’s past a wall or object and clip at a higher framerate
    and movement. Movement being followed closely could use **Interpolate** or **Extrapolate**.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**外推**在预测未来值方面做得很好。这对于模拟飞行物体很有帮助，但不适用于碰撞检测，因为它会假设物体已经过了墙壁或对象，并以更高的帧率和移动进行剪裁。如果移动被紧密跟随，可以使用**插值**或**外推**。'
- en: It’s best to start with **Interpolate** and see if it feels good for the movement
    of your experience. If it feels slow, try **Extrapolate**. Weigh the pros and
    cons of each with a higher speed of movement in your action sequences to determine
    which interpolate method you need to use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最好从**插值**开始，看看它是否适合你体验中的移动。如果感觉太慢，尝试**外推**。权衡每个选项的优缺点，以更高的移动速度在你的动作序列中确定你需要使用哪种插值方法。
- en: Understanding this will allow you to choose the best option for the physics
    values and the graphical representation of the items you are simulating with physics.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点将允许你为使用物理模拟的物品选择最佳的物理值和图形表示选项。
- en: Collision detection
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: 'When using physics to determine the position of GameObject, there need to be
    collision checks to determine whether your object has collided with another object,
    regardless of if it’s staying still or moving in the scene. This is an interesting
    dilemma now that you’ve learned that physics are fixed, and rendering is not fixed.
    The physics system can’t assume what every object is using for collision types
    or interpolation. We need to have several options that would best suit each GameObject’s
    physics needs from within the experience. There are four different collision detection
    types to consider: **Discrete**, **Continuous**, **Continuous Dynamic**, and **Continuous
    Speculative**. If you have a GameObject that is moving quickly, it may clip through
    GameObjects, meaning that it will not know that it has hit a collider and will
    keep moving through it as the physics is updated. This can be prevented through
    collision detection modes. Each mode has different implications on performance;
    however, the general guideline is that fast objects are set to **Continuous Dynamic**
    while the things they may collide with should be set to **Dynamic**. Other options
    are explained in the breakdown of each choice below.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用物理来确定GameObject的位置时，需要碰撞检查来确定你的物体是否与另一个物体发生了碰撞，无论它是静止的还是正在场景中移动。现在你已经了解到物理是固定的，而渲染不是固定的，这是一个有趣的困境。物理系统不能假设每个对象使用什么碰撞类型或插值。我们需要有几种选项，以最好地满足每个GameObject的物理需求。有四种不同的碰撞检测类型需要考虑：**离散**、**连续**、**连续动态**和**连续推测**。如果你有一个快速移动的GameObject，它可能会穿过GameObject，这意味着它将不知道它已经击中了碰撞体，并且会继续穿过它，因为物理更新正在进行。这可以通过碰撞检测模式来防止。每种模式对性能有不同的影响；然而，一般规则是，快速物体设置为**连续动态**，而它们可能与之碰撞的物体应该设置为**动态**。其他选项在下面的每个选择的分解中解释。
- en: Discrete
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 离散
- en: This collision detection mode is the best mode for performance, and it’s aptly
    named **Discrete** as it’s only checking the physics collision at fixed intervals,
    as mentioned previously. If you have a wall with a box collider and there is a
    ball moving quickly enough that its known location before the wall wasn’t colliding
    with it and the next fixed update was past the wall, there is no collision! This
    can be frustrating at first as it looks like it’s not working, or more frustratingly,
    it only happens intermittently as the ball may have collided with the wall when
    you ran the simulation a couple of times. It should be understood why this is
    happening so you can make different mode choices upon the needs of the physics
    simulation. The reason for this is that the physics update does not realize that
    the object was supposed to be affected by anything. The physics loop in **Discrete**
    mode will only check if the object needs to change trajectory once it’s in the
    loop. If you have a fast-moving object, defined as an object moving more than
    its height or width in distance per frame, then there may be a point at which
    this object is past the other object and physics will not know to react to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种碰撞检测模式是性能最好的模式，它恰当地被命名为**离散**，因为它只检查固定间隔的物理碰撞，如前所述。如果你有一面墙和一个盒子碰撞体，并且有一个球以足够快的速度移动，以至于在墙之前的已知位置没有与之碰撞，而下一个固定更新已经过了墙，那么就没有碰撞！一开始这可能会让人感到沮丧，因为它看起来好像不起作用，或者更令人沮丧的是，它可能只是间歇性地发生，因为球在运行模拟几次时可能已经与墙发生了碰撞。你应该理解为什么会发生这种情况，这样你就可以根据物理模拟的需要做出不同的模式选择。这种情况发生的原因是物理更新没有意识到物体应该受到任何影响。**离散**模式的物理循环只会检查物体是否在循环中需要改变轨迹。如果你有一个快速移动的物体，定义为每帧移动距离超过其高度或宽度的物体，那么可能存在这样一个点，这个物体已经超过了另一个物体，而物理系统并不知道要对此做出反应。
- en: If there are no fast-moving items, **Discrete** is a fantastic choice. If you
    are planning on having fast-moving objects, then **Continuous** is the answer,
    but please read about the rest of the options as they all don’t interact with
    each other intuitively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有快速移动的物品，**离散**是一个非常好的选择。如果你计划有快速移动的物体，那么**连续**就是答案，但请阅读关于其他选项的其余内容，因为它们都不直观地相互作用。
- en: Continuous
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连续
- en: If you choose **Continuous**, you may see that the object still clips through
    GameObjects you may not have expected it to. It is very important to understand
    that **Continuous** collision detection only checks if your GameObject is colliding
    with static objects. This mode is heavy on resources and should be used with caution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择**连续**，你可能会看到物体仍然会穿过你可能没有预料到的GameObject。非常重要的一点是，**连续**碰撞检测只检查你的GameObject是否与静态物体发生碰撞。此模式资源消耗大，应谨慎使用。
- en: '**Static objects** are GameObjects that are in the scene with collider components
    on them but no Rigidbody component. They are not updated with physics. Upon describing
    collision detection there will be modes that will only work with static GameObjects.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态物体**是带有碰撞组件但没有Rigidbody组件的GameObject。它们不使用物理更新。在描述碰撞检测时，将会有一些模式只能与静态GameObject一起使用。'
- en: An example of an object that would use **Continuous** mode is fast moving GameObjects
    that need to collide with static items only. The simplest example of this is Pachinko.
    This is a game where a small metal ball gets dropped from the top of the screen
    and falls down, hitting static items, bouncing off them. All of the items on the
    field are static, so there will be no clipping.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**连续**模式的物体例子是快速移动的GameObject，它们只需要与静态物品发生碰撞。这个最简单的例子是弹珠机。这是一款游戏，一个小金属球从屏幕顶部掉落并下落，撞击静态物品，然后弹开。场上的所有物品都是静态的，所以不会有穿过的现象。
- en: Continuous Dynamic
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 连续动态
- en: This mode is very similar to the **Continuous** mode; however, it will also
    work with GameObjects that use a Rigidbody component. This is a common usage within
    game mechanics. As you can imagine, adding the ability to work with the Rigidbody
    component increases the cost of resources within a game. This is more resource-heavy
    than the standard continuous mode.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式与**连续**模式非常相似；然而，它还可以与使用Rigidbody组件的GameObject一起工作。这在游戏机制中是一种常见用法。正如你可以想象的那样，添加与Rigidbody组件一起工作的能力会增加游戏中的资源成本。这比标准的连续模式更耗费资源。
- en: An example of continuous dynamic is a game you might have played, Smash Hit.
    This game is a mobile title in which you are a player on rails moving forward.
    When you tap the screen, a metal ball shoots out towards the location you tapped.
    If it collides with glass, it shatters. The glass is dynamic and interacts where
    the ball hits. Those broken pieces are also dynamic and interact with the environment
    when falling. If it wasn’t dynamic, the ball would go right through the glass.
    This would make for a much less entertaining game!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 连续动态的一个例子是你可能玩过的游戏，Smash Hit。这是一款移动游戏，你作为玩家在轨道上向前移动。当你点击屏幕时，一个金属球会向你点击的位置射出。如果它与玻璃相撞，它会破碎。玻璃是动态的，并且在与球接触的地方进行交互。那些破碎的碎片也是动态的，并且在下落时与环境交互。如果不是动态的，球会直接穿过玻璃。这将使游戏变得非常无趣！
- en: Continuous Speculative
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连续预测
- en: The word “speculative” suggests a sense of guessing. The system is speculating
    if the collision will happen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “预测”一词暗示了一种猜测的感觉。系统正在预测碰撞是否会发生。
- en: This mode does what **Continuous Dynamic** does, and objects with this setting
    can collide with both static and dynamic GameObjects; however, it’s cheaper. There
    is a bit of an accuracy cost, though. Two objects that are flying toward each
    other may end up bouncing away from each other without even touching if they both
    have **Continuous Speculative** set. This would happen because both objects are
    speculating where they will be in the next frame, which makes them think they
    should’ve bounced off each other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式执行与**连续动态**相同的功能，具有此设置的物体可以与静态和动态的GameObject发生碰撞；然而，它更节省资源。尽管如此，会有一定的精度损失。如果两个物体都设置了**连续预测**，那么它们可能会在没有接触的情况下相互弹开。这是因为两个物体都在预测它们在下一帧的位置，这使得它们认为它们应该相互弹开。
- en: An example of this is a game called Beat Saber. This is a game where you’re
    in VR and you must hit blocks at certain angles to slice them properly. Having
    your saber’s detection set to **Continuous Speculative** will allow you to know
    that you will hit the blocks that are moving at a high rate towards you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子是名为Beat Saber的游戏。这是一款VR游戏，你必须以特定角度击打方块以正确切割它们。如果你的光剑检测设置为**连续预测**，这将允许你知道你会击中那些以高速向你移动的方块。
- en: Understanding all the modes for collision detection will help you create the
    right setup for physics-based work. Take time to play with these modes in your
    own project to get a good sense of how they all work together.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 理解所有碰撞检测模式将帮助您为基于物理的工作创建正确的设置。花时间在自己的项目中尝试这些模式，以获得它们如何协同工作的良好感觉。
- en: Constraints
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束
- en: 'Now that we’ve talked about some difficult questions, let’s bring it back to
    a simpler topic: **Constraints**! This does exactly what you may think it does.
    If your item should not move or rotate on a specific axis, you may constrain it.
    An example of this is a platformer game that has moving platforms. You want them
    to move but maybe not along a specific axis. To ensure that the platform will
    not get nudged off course, you can constrain the GameObject in the *x*, *y*, or
    *z* direction so it will never update in that direction.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些难题，让我们回到一个更简单的话题：**约束**！这确实如您所想的那样工作。如果您的项目在特定轴上不应该移动或旋转，您可以对其进行约束。一个例子是具有移动平台的平台游戏。您希望它们移动，但可能不沿特定轴移动。为了确保平台不会偏离轨道，您可以在*x*、*y*或*z*方向上约束GameObject，使其永远不会在该方向上更新。
- en: This was the last of the editable fields on the Rigidbody component. The last
    section is devoted to read-only fields for runtime debugging. Let’s take a look
    at what information you can gain from these fields.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Rigidbody组件上可编辑字段的最后。最后一部分是用于运行时调试的只读字段。让我们看看您可以从这些字段中获得哪些信息。
- en: Info
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息
- en: 'The **Info** block of the Rigidbody component is essential for working with
    physics and debugging the strange behaviours that can come about. Every application
    may have unique problems that arise. Looking at the **Info** object when in play,
    you can debug what is going on with ease. This section has many values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Rigidbody组件的**信息**块对于处理物理和调试可能出现的奇怪行为至关重要。每个应用程序都可能存在独特的问题。在游戏运行时查看**信息**对象，可以轻松地进行调试。本节包含许多值：
- en: '**Speed**: Magnitude of the velocity'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：速度的大小'
- en: '**Velocity**:  Rate of change of Rigidbody position'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：Rigidbody位置的变化率'
- en: '**Angular Velocity**: Angular velocity vector of the Rigidbody measured in
    radians per second'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角速度**：以每秒弧度计量的Rigidbody的角速度向量'
- en: '**Inertia Tensor**: Diagonal matrix in a reference frame positioned at this
    body’s center of mass and rotated by **Inertia Tensor Rotation**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惯性张量**：位于该物体质心参考系中并通过**惯性张量旋转**旋转的对角矩阵'
- en: '**Inertia Tensor Rotation**: Rotation of the inertia tensor'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惯性张量旋转**：惯性张量的旋转'
- en: '**Local Center of Mass**: Center of mass relative to the transform’s origin'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部质心**：相对于变换原点的质心'
- en: '**World Center of Mass**: Center of mass of the Rigidbody in world space'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界质心**：Rigidbody在全局空间中的质心'
- en: '**Sleep State**: Optimization strategy to not always account for every object,
    with two settings:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**睡眠状态**：一种优化策略，不是总是考虑每个对象，有两个设置：'
- en: '**Awake**: Physics is considering this Rigidbody'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唤醒**：物理正在考虑此Rigidbody'
- en: '**Asleep**: Physics is not considering this Rigidbody'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**休眠**：物理不再考虑此Rigidbody'
- en: Each of these values above has its unique purposes depending on what you are
    trying to watch or debug during runtime. Working with the previously mentioned
    platformer, you may think that your platform should be in the alignment of your
    character, but something pushed it out of the way just enough to not allow the
    character to land on it. With the **Info** block, you can watch the movement or
    velocity. If there should be no velocity in the *z* direction, then looking at
    that value will let you know if it is working as intended.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个值都有其独特的作用，具体取决于您在运行时试图监视或调试什么。在与之前提到的平台游戏一起工作时，您可能会认为您的平台应该与您的角色对齐，但某物将其推离轨道，使其不足以让角色着陆。通过**信息**块，您可以监视运动或速度。如果*z*方向上不应该有速度，那么查看该值将让您知道它是否按预期工作。
- en: We have a strong idea of how the Rigidbody 3D component works now and can refer
    to these pages if there are some confusing movements when building physics-focused
    interactions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Rigidbody 3D组件的工作原理有了清晰的认识，如果构建以物理为重点的交互时遇到一些令人困惑的运动，可以参考这些页面。
- en: Design and implementation considerations
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和实现考虑因素
- en: It is very easy to try to add physics to each of your GameObjects to get movement
    in your interactions. Not every item specifically needs a Rigidbody to complete
    its movement in a manner that your interactions need to provide a fantastic experience.
    At the end of the day, it’s all about frames per second. Try to make any moving
    item without Rigidbody components, but if they’re needed, then add them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易尝试为每个GameObject添加物理属性以获得交互中的运动。并不是每个物品都需要Rigidbody来完成你的交互所需的运动方式。最终，一切都关乎每秒帧数。尽量让任何移动的物品没有Rigidbody组件，但如果需要，就添加它们。
- en: Telekinesis and physics interaction
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 心灵感应和物理交互
- en: For our game’s first puzzle, we focused heavily on making the environment narrative
    the key interest point. From the moment you walk into the first room, your vision
    will be placed on the back door, which houses the puzzle’s solution. In the final
    puzzle, we need to force the player to use more brainpower on figuring out the
    puzzle instead of finding the answers around them. To do this, we decided to give
    the player the power of telekinesis that Myvari, our character, realizes she has
    had within her the whole time. We have three steps to get the player to this point
    of understanding.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们游戏中的第一个谜题，我们重点在于使环境叙事成为关键兴趣点。从你走进第一个房间的那一刻起，你的视线就会被放在后门上，那里藏有谜题的解决方案。在最后的谜题中，我们需要迫使玩家更多地使用脑力来解决问题，而不是在他们周围寻找答案。为此，我们决定赋予玩家Myvari（我们的角色）意识到她一直拥有的心灵感应能力。我们有三步来让玩家达到这个理解点。
- en: Rocks Falling
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 石头掉落
- en: Telekinesis hasn’t been seen in this game in any form yet. Some magic came from
    her necklace, but we need to provide some information to tell the player that
    she has something in her. A cinematic works well for this. We need to design the
    interaction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 心灵感应在这个游戏中还没有以任何形式出现过。一些魔法来自她的项链，但我们需要提供一些信息来告诉玩家她身上有东西。电影场景对此很有效。我们需要设计交互。
- en: Design
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: After finishing the first door puzzle, you encounter a large hallway with old
    statues of your past. This is a nice look into the culture of her race’s past.
    There is nothing to solve here; there’s just a nice walk. Behind the final statue
    is a tight space to walk through that leads to a cliff path. About halfway along
    the path, some rocks fall. This triggers a cinematic effect where Myvari defends
    herself from these falling rocks with her telekinesis. Looking confused, she needs
    to move forward to find out what is going on. Her adventurous side beckons her
    to push on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成第一个门谜题之后，你遇到了一个宽敞的大厅，里面摆放着你过去的旧雕像。这是对她种族过去文化的一个很好的了解。这里没有需要解决的问题；这里只有一段愉快的散步。在最后一个雕像后面，有一个狭窄的空间可以穿过去，通往悬崖小径。沿着小径大约走了一半，一些石头掉了下来。这触发了一个电影效果，其中Myvari用她的心灵感应来保护自己免受这些掉落石头的伤害。看起来很困惑，她需要继续前进以了解发生了什么。她的冒险精神在召唤她继续前进。
- en: Implementation
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: What needs to be implemented here is in two pieces. One large piece is the cinematic
    of the rocks and Myvari. Cinematics are when the user doesn’t have power over
    the interaction. This is helpful for gaining knowledge but shouldn’t be overused
    because the game can become like an interactive movie. Cinematics should be used
    with restraint. The second part is physics-based rocks as a secondary motion from
    the boulder falling.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在这里实现的是两件事。一部分是石头和Myvari的电影场景。电影场景是指用户对交互没有控制权的时候。这有助于获取知识，但不应该过度使用，因为游戏可能会变成一部互动电影。电影场景应该适度使用。第二部分是基于物理的石头作为从大石头掉落时的次要运动。
- en: 'The cinematic will be triggered in the same way as previously: we turn off
    the player’s ability to manipulate Myvari or the camera and transition to the
    cinematics’ animation while moving the camera to emphasize the object we want,
    in this case, the boulder. If you need a refresher for this, look at *Chapter
    6*, *Interactions and Mechanics*, during the implementation of the tight spaces.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 电影场景将像之前一样触发：我们关闭玩家操纵Myvari或摄像机的权限，并在移动摄像机的同时切换到电影场景的动画，以强调我们想要的对象，在这种情况下，是大石头。如果你需要复习这一点，请查看*第6章*，*交互和机制*，在实现狭窄空间时。
- en: The physics-based rocks, however, we can’t just animate. We want them to feel
    as though they fell on their own. It makes the larger boulder seem like it fell,
    which helps sell the immersion that this location might be real.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于物理的石头我们不仅仅可以动画化。我们希望它们看起来像是自己掉下来的。这使大石头看起来像是掉下来的，这有助于营造这个地点可能真实存在的沉浸感。
- en: Even though this shows the telekinesis coming from Myvari, we need to have the
    player perform the interaction or else it’s just an ability they can’t use. We
    will go over the player’s interaction next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这显示了来自 Myvari 的心灵感应，但我们仍需要让玩家执行交互，否则这只是一个他们无法使用的技能。我们将在下一节中介绍玩家的交互。
- en: The Broken Pedestal
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破碎的基座
- en: This is the first time the player gets to use Myvari’s newfound power. We need
    to design this puzzle so it’s impossible to miss because the player isn’t used
    to using this power. This pedestal is a small version of the final puzzle.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是玩家第一次使用 Myvari 新获得的力量。我们需要设计这个谜题，使其不可能错过，因为玩家不习惯使用这种力量。这个基座是最终谜题的一个小型版本。
- en: In this micro-puzzle, you need to place the fallen piece onto the pedestal to
    fix it. We will need to be very careful with how we design this to ensure the
    player’s experience explains how this works before they touch the interaction
    button. Let’s run through the design together.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个微型谜题中，你需要将掉落的碎片放置在基座上以修复它。我们需要非常小心地设计这一点，以确保在玩家触摸交互按钮之前，他们的体验能够解释这是如何工作的。让我们一起来回顾一下设计。
- en: Design
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: After we make it along the cliff path and across a small crumbling bridge, the
    bridge then falls, and the way back is impassable. The only way to go is through
    a large door. When we walk up to it, it will start opening into a large open cavern,
    water pooled in the bottom, with ruins in the background and a fall to certain
    doom. Directly in front of Myvari is a pedestal that is broken, but the broken
    piece is on the ground close to it. Looking at it, we can see that it is outlined
    in the same color as the power that protected Myvari from the falling rocks. We
    will display a UI helper showing which button to press, which we will go over
    in *Chapter 8*, *User Interface and Menus*. This will make interaction with her
    ability tied to a button to provide the player agency. When we press the button,
    Myvari lifts the broken piece off the ground and fits it onto the pedestal, where
    it affixes itself and lights up. Pressing the interaction button will then transition
    the open space into a night scene and some water rises up from below to reveal
    a pathway to the ruins.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们沿着悬崖路径和一座小碎裂的桥梁前进后，桥梁随后倒塌，返回的路已经不通。唯一的出路是通过一扇大门。当我们走近它时，它将开始打开，进入一个宽敞的洞穴，底部积满了水，背景中有废墟，还有通往必然毁灭的深渊。在
    Myvari 正前方有一个破碎的基座，但破碎的碎片就在它附近的地面上。看着它，我们可以看到它被与保护 Myvari 免受落石伤害的相同颜色的能量勾勒出来。我们将显示一个
    UI 辅助器，显示要按哪个按钮，我们将在*第 8 章*，*用户界面和菜单*中详细说明。这将使与她的能力交互与一个按钮相关联，为玩家提供自主权。当我们按下按钮时，Myvari
    将将破碎的碎片从地上抬起并放置在基座上，碎片固定并亮起。按下交互按钮后，将场景从开放空间转变为夜景，并且从下方升起一些水，揭示通往废墟的道路。
- en: Implementation
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: We know that the mechanic we want to include here is a subset of the final puzzle.
    To do this, we don’t want to write code just for this single item, so instead,
    we set it up to be a simple standalone using a public enum.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们想要包含的机制是最终谜题的一个子集。为了做到这一点，我们不想只为这个单一的项目编写代码，所以我们设置它使用公共枚举作为简单的独立项目。
- en: To keep this as easy to read as possible, we will ask you to take your time
    reading this section, which is about the final puzzle. We will be explaining some
    more advanced features and it all builds on itself up to the end. We are using
    some amazing Unity timing in this code, which will take some explanation, and
    breaking it up as we’ve done will help you to understand it. So, let’s move on
    to the final puzzle design, and then we will break down all of the pieces of this
    and the final puzzle’s implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '为了尽可能保持可读性，我们将要求您花时间阅读这一节，它关于最终谜题。我们将解释一些更高级的功能，所有这些功能都一直累积到结尾。我们在代码中使用了惊人的
    Unity 时间控制，这将需要一些解释，并且像我们之前那样分解它将有助于您理解。因此，让我们继续到最后一个谜题的设计，然后我们将分解这个和最终谜题的所有部分实现。 '
- en: The Final Puzzle
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终谜题
- en: We’ve made it to the big final puzzle. Luckily, we took the time to show the
    player what Myvari gained through stress from the boulder falling toward her.
    Then we learned how to use it to get here by fixing the broken pedestal. Now we
    have this puzzle slightly open, but allows the environment to teach the player
    what they need to do. Let’s dive in to see how we design this last puzzle.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了最后的重大谜题。幸运的是，我们花了时间向玩家展示 Myvari 通过来自滚石的压力获得了什么。然后我们学会了如何通过修复破碎的基座来使用它到达这里。现在这个谜题稍微开放了一些，但允许环境教会玩家他们需要做什么。让我们深入探讨，看看我们是如何设计这个最后一个谜题的。
- en: Design
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: Now that you’ve made it to the ruins, there is some architecture in the background
    that lights up some runes on the pillars. This corresponds with some cables on
    the ground that connect to all the pillars. The puzzle consists of six pillars
    that connect the power to the main tree, which is in the center of the ruins and
    has wires connected to it. The wires are only properly connected from three of
    the pillars. Myvari needs to use her telekinesis to connect the correct pillars
    following the wires on the ground. Bringing power to the tree opens a small compartment
    in the tree, which houses a tiara. The tiara is revealed through a cinematic and
    will end the gameplay of this vertical slice. Now that we have the general idea
    of what we need to do, let’s move on to implementation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经到达了废墟，背景中有些建筑照亮了柱子上的符文。这对应于地面上连接到所有柱子的某些电缆。这个谜题由六个柱子组成，它们将电力连接到位于废墟中心的主体树，该树上有电线连接。只有三个柱子的电线连接是正确的。Myvari需要使用她的心灵感应能力，根据地上的电线连接正确的柱子。将电力引入树中会在树中打开一个小隔间，里面放着一顶王冠。王冠将通过一段电影式画面揭示，并将结束这个垂直切片的游戏玩法。现在我们已经了解了我们需要做什么的一般想法，让我们继续到实现部分。
- en: Implementation
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: The implementation of this puzzle is the completion of the telekinesis mechanic.
    When we wrote this, we allowed ourselves to push into more advanced topics. To
    ensure this makes sense, we will go over all the topics here and break them down
    as much as possible. Ensure that you pay attention to the minutiae as there are
    bits of information here that will seem hidden or counter-intuitive at first.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的实现是心灵感应机制的完成。当我们编写这个时，我们让自己深入到更高级的主题。为了确保这有意义，我们将在这里介绍所有主题，尽可能详细地分解它们。请确保您注意细节，因为这里有一些信息在最初看起来可能是隐藏的或反直觉的。
- en: 'Programming topics that we will be covering are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要涵盖的编程主题包括：
- en: Execution order
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行顺序
- en: Static methods
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: '`UnityAction` (delegate)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnityAction`（委托）'
- en: Coroutines
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: Let’s first go over the execution order for Unity. We haven’t spent any time
    talking about the nitty-gritty of how it works under the hood.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解一下Unity的执行顺序。我们还没有花时间讨论它底层的工作细节。
- en: Execution order
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行顺序
- en: There is an order to the execution of every frame when in runtime, or playing,
    inside the editor and opening a build. We would show you a screenshot of the flowchart,
    but it’s a bit too large. Instead, we will place a link here as well as a Google
    search term for you to search online to find the website and see this flowchart.
    I will cover the higher-level topics here and the reason why they matter within
    each portion that they affect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当在运行时、在编辑器中播放或在构建中打开时，每一帧的执行都有一个顺序。我们本想展示一个流程图的截图，但它有点太大。相反，我们将在此处放置一个链接，以及一个Google搜索词，供您在线搜索以找到网站并查看此流程图。我将在这里介绍高级主题，以及它们在每个受影响部分中的重要性原因。
- en: '[https://docs.unity3d.com/Manual/ExecutionOrder.xhtml](https://docs.unity3d.com/Manual/ExecutionOrder.xhtml)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Manual/ExecutionOrder.xhtml](https://docs.unity3d.com/Manual/ExecutionOrder.xhtml)'
- en: 'Google search term: `Unity Execution Order`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Google搜索词：`Unity Execution Order`
- en: 'The major concept here is that there has to be a hierarchy of execution of
    certain bits of information. We needed to have a strong think about this to have
    a baseline of what will be dealt with at each frame. The uncomfortable truth is
    that there is a lot to think about. Here is the list in chronological form with
    highest-level terminology for the execution order, with a small snippet of information
    on each of them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要概念是必须对某些信息片段的执行顺序有一个层次结构。我们需要深入思考，以确定每一帧将处理什么。不愉快的真相是，有很多东西需要思考。以下是按时间顺序排列的列表，包含执行顺序的最高级术语，以及关于每个术语的一小段信息：
- en: '**Initialization**: This is for `Awake` and `onEnable` only.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化**：这仅适用于`Awake`和`onEnable`。'
- en: '**Editor**: Reset when scripts are added and not in play mode.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器**：当添加脚本且不在播放模式时重置。'
- en: '**Initialization**: The second part of initialization is for the `Monobehaviour`
    method `Start` only.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化**：初始化的第二部分仅适用于`Monobehaviour`方法的`Start`。'
- en: '**Physics**: This is where all physics updates will happen. It can potentially
    be run more than once per frame if the fixed time step is set higher than the
    frame update time.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理**：所有物理更新都将发生在这里。如果固定时间步长设置高于帧更新时间，它可能每帧运行多次。'
- en: '**Input Events**: Any non-update focused input, such as `OnMouseDown`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入事件**：任何非更新相关的输入，例如`OnMouseDown`。'
- en: '**Game Logic**: Update, coroutine logic and yielding, animation events, write
    properties, and `LateUpdate` run in here. These will be more apparent during implementation
    of the game logic further in the chapter.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏逻辑**: 更新、协程逻辑和yield、动画事件、写入属性和`LateUpdate`在这里运行。这些将在本章后面关于游戏逻辑的实现中更加明显。'
- en: '**Scene Rendering**: Many scene-rendering functions run here in every frame
    to deal with culling objects from the camera, visible objects, and post rendering.
    We will not be breaking this down heavily, if you are curious, please read into
    the execution order manual for more information.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景渲染**: 许多场景渲染函数在这里每帧运行，以处理从相机中剔除对象、可见对象和后渲染。我们不会对此进行深入分析，如果你好奇，请阅读执行顺序手册以获取更多信息。'
- en: '**Gizmo Rendering**: Specifically, the `OnDrawGizmo` method of the Unity Editor.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gizmo渲染**: 特指Unity编辑器的`OnDrawGizmo`方法。'
- en: '**GUI Rendering**: The `OnGui` method, which can run multiple times per frame.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GUI渲染**: `OnGui` 方法，可以在每一帧运行多次。'
- en: '**End of Frame**: Allows coroutines to be paused or yielded at the end of the
    frame, waiting for all of the rest to finish before starting again at the top
    of game logic section.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧尾**: 允许在帧尾暂停或yield协程，等待所有其他操作完成后再从游戏逻辑部分的顶部重新开始。'
- en: '**Pausing**: When the application has been paused; before the application is
    paused, a single frame is run.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暂停**: 当应用程序被暂停时；在应用程序暂停之前，运行一个单独的帧。'
- en: '**Decommissioning**: Cleans up memory with `OnApplicationQuit`, `OnDisable`,
    and `OnDestroy` in that order.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退役**: 使用`OnApplicationQuit`、`OnDisable`和`OnDestroy`按此顺序清理内存。'
- en: Before we move on to the next section, there is something you need to make sure
    you understand. You do not, by any means, need to understand all of the preceding
    list. There is a lot to learn there, and if you go to the execution order documentation
    you will see every method that is listed in more detail. We will be showing portions
    of the execution and explaining what is affecting our code during the rest of
    this chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，有一件事你需要确保你理解。你不必以任何方式理解前面列出的所有内容。那里有很多东西要学习，如果你查看执行顺序文档，你会看到列出的每个方法的更详细说明。我们将展示执行的部分，并在本章的其余部分解释影响我们代码的因素。
- en: The key takeaway from the chronological list of higher-level sections being
    listed is that Unity has an order. That’s a relieving concept to wrap your head
    around as a developer. When you get confused about why something is happening
    the way it is, you can rely on this to see if it’s an execution order problem
    that you might be running into.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从按时间顺序列出的高级部分的关键点来看，Unity有一个顺序。这对于开发者来说是一个令人欣慰的概念。当你对为什么事情以这种方式发生感到困惑时，你可以依赖这个顺序来查看是否是执行顺序问题，你可能正在遇到。
- en: During the next sections, we will have images of the section of the execution
    order we had to pay attention to. This will allow you to see how it can be used
    for your future development work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将展示执行顺序中需要注意的部分的图像。这将允许你看到它如何被用于你未来的开发工作。
- en: 'Now that we’ve looked at the execution order, we should get into the code.
    We are using three scripts to make this work with the telekinesis mechanics:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了执行顺序，我们应该进入代码部分。我们使用三个脚本来实现与心灵感应机制的工作：
- en: '`PhysicsPuzzleTrigger.cs`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhysicsPuzzleTrigger.cs`'
- en: '`PhysicsPuzzlePiece.cs`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhysicsPuzzlePiece.cs`'
- en: '`FinalPuzzle.cs`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FinalPuzzle.cs`'
- en: '`PhysicsPuzzleTrigger.cs` has two pieces of code that are important to know
    about first: the `PhysicsPuzzleTrigger` class and the `PhysicsPuzzlePieceType`
    enum. We will tackle the `PhysicsPuzzlePieceType` first as it’s much easier to
    get into than the trigger. We have an enum that allows us to choose which puzzle
    piece type it is on the GameObject. We define this as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhysicsPuzzleTrigger.cs`中有两段重要的代码需要了解：`PhysicsPuzzleTrigger`类和`PhysicsPuzzlePieceType`枚举。我们将首先处理`PhysicsPuzzlePieceType`，因为它比触发器更容易理解。我们有一个枚举，允许我们在GameObject上选择它是哪种拼图类型。我们定义如下：'
- en: '[PRE1]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, in the `PhysicsPuzzlePiece.cs` script, we implement it as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`PhysicsPuzzlePiece.cs`脚本中，我们按以下方式实现：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we add the `PhysicsPuzzlePiece.cs` script to any GameObject, we then get
    a dropdown to choose which type it is. This is very useful when you want explicit
    items to fit together. We’re using this to use the same mechanics but allow for
    different puzzle types.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`PhysicsPuzzlePiece.cs`脚本添加到任何GameObject时，我们就会得到一个下拉菜单来选择它的类型。当你想要明确的项目能够配合在一起时，这非常有用。我们正在使用这个来使用相同的机制，但允许不同的拼图类型。
- en: We said in *The Broken Pedestal* section above that we would explain it within
    the implementation of the entire mechanic. What we do is allow the `Intro` option
    to be aligned with this mechanic and be explicit for that action. Even though
    it’s impossible to get the final puzzle pieces in that location, this is a great
    practice to ensure data is consistent with your code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的*破碎的基石*部分，我们提到会在整个机制的实施中解释它。我们做的是允许`Intro`选项与这个机制对齐，并明确该动作。尽管在那个位置无法获得最终的谜题碎片，但这是一种很好的实践，以确保数据与代码的一致性。
- en: 'Let’s get back into the `PhysicsPuzzleTrigger.cs` code. We start off by declaring
    the fields we’re used to working with so far, but then on line 12, there is something
    unique that has two concepts we need to go over. This is the use of `static` and
    `UnityAction`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`PhysicsPuzzleTrigger.cs`代码。我们首先声明了我们迄今为止习惯使用的字段，但在第12行，有一些独特之处，涉及两个我们需要讨论的概念。这是`static`和`UnityAction`的使用：
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’re going to break out of describing exactly what we’re doing with this line
    to explain the context of what both `static` and `UnityAction` are. After we do
    that, we will then proceed to how we are using them in this code for this mechanism.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂时跳过描述这一行的具体做法，来解释`static`和`UnityAction`的上下文。在这样做之后，我们将继续探讨我们如何在代码中为这个机制使用它们。
- en: Static methods
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'A static method, field, property, or event is callable on any class that is
    within the namespace without needing the `using` directive or inheritance. Let’s
    say you have one script that has a field as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法、字段、属性或事件可以在命名空间内的任何类上调用，无需使用`using`指令或继承。假设你有一个脚本，其中有一个字段如下所示：
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You could then have another script in the same project that, without specifically
    calling for that script when using or inheriting it, could access it like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一个项目中创建另一个脚本，无需在调用或继承该脚本时特别指定，就可以像这样访问它：
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This may not look very useful by itself, but the concept is the important part
    to take away at this time. `Static` members of a class can be accessed by other
    classes by just using the class name before the required member.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这可能看起来并不很有用，但这个概念是现在需要记住的重要部分。类的`static`成员可以通过在所需成员之前使用类名来被其他类访问。
- en: An example of this being used commonly is keeping a count of something as the
    `static` field has only one instance. We’re using it to store a `UnityAction`.
    We need to go over that next before we get into how we are using these directly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法的一个常见例子是保持某个计数，因为`static`字段只有一个实例。我们正在使用它来存储`UnityAction`。在我们深入探讨如何直接使用这些之前，我们需要先了解这一点。
- en: UnityActions
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UnityActions
- en: 'A `UnityAction` is a Unity-specific delegate. A delegate in C# is a sort of
    generic concept of a method that has a parameter list which also returns a specific
    type. Interestingly, a `UnityAction` returns `void` by default. A common way of
    explaining delegates is through the concept of the subscribe model. This means
    that the delegate is looking for methods to be attached to it and when something
    uses the delegate, it will try to run the methods attached as long as the methods
    are returning the same type. This is a bit abstract, so let’s look at an example.
    We will be using the `UnityAction MathAction` to add to how many times a button
    is pressed and then see if that new number is even or odd:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnityAction`是Unity特定的委托。在C#中，委托是一种通用的方法概念，它有一个参数列表，并返回一个特定类型。有趣的是，`UnityAction`默认返回`void`。解释委托的一个常见方式是通过订阅模型的概念。这意味着委托正在寻找要附加到其上的方法，当某个东西使用委托时，它将尝试运行附加的方法，只要这些方法返回相同的类型。这有点抽象，所以让我们看一个例子。我们将使用`UnityAction
    MathAction`来增加按钮被按下的次数，然后看看这个新数字是偶数还是奇数：'
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’re using the `Button` class, so ensure to import `UnityEngine.UI` so we can
    use buttons from that class. Following the lines down, we made a new `UnityAction`
    named `MathAction`. On `Start`, we grabbed the button so we could add logic to
    it. Then we attached the `AddOne` and `CheckEven` methods to `UnityAction`. The
    `+=` that you see is `MathAction` attaching itself to those methods in order.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是`Button`类，所以请确保导入`UnityEngine.UI`，这样我们就可以使用该类中的按钮。沿着这些行向下，我们创建了一个名为`MathAction`的新`UnityAction`。在`Start`方法中，我们获取了按钮，以便向其添加逻辑。然后我们将`AddOne`和`CheckEven`方法附加到`UnityAction`上。你看到的`+=`是`MathAction`依次将这些方法附加到其上。
- en: 'Addition assignment operator – we’re using a special “syntactic sugar” to make
    the code a bit cleaner to read and less redundant. The addition assignment operator
    looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 加法赋值运算符——我们使用一种特殊的“语法糖”来使代码更易于阅读，并减少冗余。加法赋值运算符看起来像这样：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Written another way is:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You then see that we assigned `UnityAction` to the button’s listener. When you
    press the button, both of these functions will be running because `UnityAction`
    is assigned to both of them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你看到我们将`UnityAction`分配给了按钮的监听器。当你按下按钮时，这两个函数都会运行，因为`UnityAction`被分配给了它们。
- en: Before we can go further into the code, we need to cover one more topic, coroutines.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步深入代码之前，我们需要覆盖一个更多的话题，那就是协程。
- en: Coroutines
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 协程
- en: A coroutine allows you to spread a task over multiple frames. This is not a
    form of multithreading. Every action is still being run on the main thread. The
    power of coroutines is that they allow directable pausing through a new term,
    `yield`. Taking a look at the execution order in the figure below, you may remember
    seeing **yield null** after **Update** in the **Game Logic** section. If you don’t
    have the execution order up on a browser tab, look at *Figure 7.3*. The small
    note on the left says it nicely. If a coroutine previously yielded or paused,
    and it’s due to resume, it will resume at that point in the execution order.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 协程允许你将任务分散到多个帧上。这不是多线程的一种形式。每个动作仍然在主线程上运行。协程的力量在于它们允许通过一个新的术语`yield`进行可暂停操作。查看下面的执行顺序图，你可能记得在**游戏逻辑**部分的**Update**之后看到了**yield
    null**。如果你没有在浏览器标签页上打开执行顺序，请查看*图7.3*。左边的注释很好地说明了这一点。如果一个协程之前已经yield或暂停，并且它应该恢复，它将在执行顺序中的那个点恢复。
- en: '![Graphical user interface  Description automatically generated](img/B17304_07_03.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_07_03.png)'
- en: 'Figure 7.3: Game logic of the execution order'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：执行顺序的游戏逻辑
- en: 'That’s awesome, isn’t it? How does it know to resume, you ask? Good question,
    reader. It knows that it should resume because of the logic in the code. There
    is a fantastic example from the Unity Docs going over a basic fade from opaque
    to transparent using a coroutine. Let’s go through it quickly:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是太棒了，不是吗？你是怎么知道要恢复的呢？这是一个好问题，读者。它知道应该恢复是因为代码中的逻辑。Unity文档中有一个出色的例子，介绍了使用协程从不透明到透明的基本淡入淡出。让我们快速浏览一下：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I put in bold the three things that may be new to you. `StartCoroutine(Fade())`
    is asking the application to start a coroutine with the `Fade` method. You will
    start the coroutine during the start of the game logic at the bottom of the `yield`
    statements; refer to *Figure 7.3* again for this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我将可能对你来说新的三件事情加粗。`StartCoroutine(Fade())`是请求应用程序使用`Fade`方法启动一个协程。你将在`yield`语句底部的游戏逻辑开始时启动协程；再次参考*图7.3*以了解这一点。
- en: '`IEnumerator` is stating that this method is iterable. Remember back to the
    last time you made a method. The keyword before the name is the type. We use `void`
    if it returns nothing, but since this will be iterated on, it needs to know. We
    let the computer know this by adding `IEnumerable` as the return type.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerator`表示此方法是可以迭代的。记得你上次创建方法的时候。名称前的关键字是类型。如果我们什么也不返回，我们使用`void`，但由于这将进行迭代，它需要知道。我们通过添加`IEnumerable`作为返回类型来让计算机知道这一点。'
- en: The last part is `yield` `return null`. This is tricky the first time looking
    over the `for` loop. In most cases, a `return` will take you out of a loop, but
    since we have a `yield` there, Unity asks if we’ve finished with everything in
    the method. It pauses after subtracting 0.1f from the current alpha and waits
    for the game logic portion to start again to do it again until it satisfies the
    `for` loop logic. Once that is completed, it no longer yields.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是`yield` `return null`。第一次查看`for`循环时可能会觉得有点棘手。在大多数情况下，`return`会带你退出循环，但由于我们这里有一个`yield`，Unity会询问我们是否已经完成了方法中的所有内容。它在从当前alpha减去0.1f后暂停，等待游戏逻辑部分再次开始以再次执行，直到满足`for`循环的逻辑。一旦完成，它就不再yield。
- en: Summarizing this code, pressing *F* will fade the GameObject this script is
    on out from the scene. We think you have a good enough grasp of these concepts.
    Let’s get back to the code in our project to finish up our implementation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这段代码，按下*F*将使此脚本所在的GameObject从场景中淡出。我们认为你对这些概念已经有了足够的了解。让我们回到我们项目中的代码，完成我们的实现。
- en: Back to the code
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回代码
- en: OK…we took a little aside to explain some key concepts, but we’re back now.
    Let’s open `PhysicsPuzzleTrigger.cs` back up. The concept here is that you have
    telekinesis and when you move an item close to its trigger volume, it will then,
    on its own, move into place over a transitional period we define. We’ve seen `OnTriggerEnter`
    previously, so that isn’t surprising with a volume trigger. We do want it to move
    on its own, so we need to disable a bunch of fields of the Rigidbody and disable
    the collider. This is done on lines 28-33 in `PhysicsPuzzleTrigger.cs`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧……我们稍微偏离了一下，来解释一些关键概念，但现在我们回来了。让我们重新打开`PhysicsPuzzleTrigger.cs`。这里的理念是，你拥有心灵感应能力，当你将一个物品移到其触发体积附近时，它将在这个我们定义的过渡期间自行移动到正确的位置。我们之前已经看到了`OnTriggerEnter`，所以体积触发器并不令人惊讶。我们确实希望它能够自行移动，所以我们需要禁用Rigidbody的一些字段和禁用碰撞器。这在`PhysicsPuzzleTrigger.cs`的第28-33行完成。
- en: Now, this is where we get to see new code. We need to set up the references
    to where the items need to transition from and to as this script is on several
    GameObjects, so we need to reference their relative positions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们到了可以看到新代码的地方。我们需要设置从哪里到哪里的引用，因为此脚本位于几个GameObject上，所以我们需要引用它们的相对位置。
- en: Then we start the coroutine on line 40.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第40行开始协程。
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have some code for changing the color of the trigger; this is temporary for
    debugging.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些代码用于更改触发器的颜色；这是用于调试的临时代码。
- en: 'Then we have a `tween` loop, which is an animation term for “between” which
    means the change in movement in our case. We have our `while` loop running for
    as long as `tweenDuration` is set to, normalized from how long it has been from
    the start. This is defined as `delta`. We then Lerp the position and Slerp the
    rotation to the transform we want it to end with:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个`tween`循环，这是一个动画术语，表示“之间”，在我们的情况下意味着运动的变化。我们的`while`循环会持续到`tweenDuration`被设置为，从开始的时间进行归一化。这被定义为`delta`。然后我们将位置Lerp到我们想要的变换，将旋转Slerp到我们想要的变换：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, we see the `yield` `return null`!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到`yield return null`！
- en: We’re now paused until the next game logic loop unless `tweenDuration` is complete
    and we don’t enter the `while` loop, which means we have completed the `tween`.
    We set the position and angles on line 61 for the moving piece to ensure the transform
    is ready to be referenced in our `UnityAction`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在暂停，直到下一个游戏逻辑循环，除非`tweenDuration`完成并且我们没有进入`while`循环，这意味着我们已经完成了`tween`。我们在第61行设置移动部件的位置和角度，以确保变换准备好在我们的`UnityAction`中被引用。
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we move into our `UnityAction`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入我们的`UnityAction`：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This looks interesting. Why is there a question mark there? There is a conditional
    operator called a “null condition operator”, which asks if `OnPieceSlotted` is
    `null` or not before performing the following method. This is another syntactical
    sugar. You could get the same result by making an `if` statement checking if `OnPieceSlotted`
    is `null`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很有趣。为什么那里有一个问号？有一个条件运算符叫做“空条件运算符”，它在执行以下方法之前询问`OnPieceSlotted`是否为`null`。这是一种另一种语法糖。你可以通过创建一个检查`OnPieceSlotted`是否为`null`的`if`语句来得到相同的结果。
- en: In the case of `UnityAction`, this is saying something very specific. It’s asking
    if anything has been attached to this action.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UnityAction`的情况下，这是说得很具体的。它询问是否有任何东西附加到这个动作上。
- en: If there is a method assigned to this `UnityAction`, then please call whatever
    function is assigned with the following arguments; the `this` GameObject and the
    `tweenPiece` as the `PhysicsPuzzlePiece` type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为这个`UnityAction`分配了方法，那么请使用以下参数调用分配的任何函数；`this` GameObject和`tweenPiece`作为`PhysicsPuzzlePiece`类型。
- en: This is where some magic happens. Remember that we assigned `OnPieceSlotted`
    to be a static member of the `PhysicsPuzzleTrigger` class? Well, open up `FinalPuzzle.cs`
    and let’s show the power of static members.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些魔法般的事情。记得我们已将`OnPieceSlotted`分配为`PhysicsPuzzleTrigger`类的静态成员吗？那么，打开`FinalPuzzle.cs`，让我们展示静态成员的力量。
- en: 'On `Start`, we add a local function named `OnPieceSlotted` to the static `UnityAction`
    from `PhysicsPuzzleTrigger.OnPieceSlotted`. We know that when our player puts
    an object into the right position, by the end of the coroutine it needs to update
    which object it was. Was it the final puzzle or the intro puzzle? We defined that
    through our enum on `PuzzlePieceType`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start`方法中，我们将一个名为`OnPieceSlotted`的本地函数添加到从`PhysicsPuzzleTrigger.OnPieceSlotted`继承的静态`UnityAction`中。我们知道当我们的玩家将一个物体放置到正确的位置时，协程结束时需要更新它所对应的物体。是最终拼图还是入门拼图？我们通过`PuzzlePieceType`枚举定义了这一点：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This local method being run from `UnityAction` gives us the trigger and `piece`
    tells us if we have finished the intro puzzle or if we have worked on the final
    puzzle. We can use any script later on in the game for this specific mechanic
    as it’s static and available to us. Static is not only fun with socks on the carpet
    shocking your siblings. It’s also magic in programming!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个从 `UnityAction` 运行的本地方法为我们提供了触发器，而 `piece` 告诉我们是否完成了介绍性的谜题，或者是否已经处理了最终谜题。我们可以在游戏后期使用任何脚本来实现这个特定的机制，因为它静态且对我们可用。静态不仅是在地毯上穿着袜子电击你的兄弟姐妹时很有趣，在编程中也是一种魔法！
- en: We just did some intermediate-level Unity programming. These tools are usable
    in so many situations, but they aren’t always easy to think about as the first
    option to the answer of your problem. Take your time and work through each section.
    Make some coroutines with GameObjects. See if you can make your own `UnityAction`
    within one script, as we showed above. Test static methods and see how they work,
    and in time these tools will become natural to you when developing your games.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚进行了一些中级水平的 Unity 编程。这些工具在许多情况下都可以使用，但它们并不总是作为你问题的答案的第一个选项那么容易想到。花点时间，逐节工作。用
    GameObjects 制作一些协程。看看你能否在单个脚本中创建自己的 `UnityAction`，就像我们上面展示的那样。测试静态方法，看看它们是如何工作的，随着时间的推移，这些工具将在你开发游戏时变得自然。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'What a jam-packed chapter! We went over a lot, so I think we need a small summary
    here. The concept of physics is already a tough subject to tackle. We’re using
    it for simulation in games on a small scale. We went over the Rigidbody component
    in its entirety and then dove deep into some brand-new C# work. For C#, we went
    over:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 多么充实的一章！我们讨论了很多内容，所以我认为我们需要在这里做一个简短的总结。物理学的概念本身就是一个很难对付的主题。我们在游戏中使用它进行小规模的模拟。我们全面介绍了
    Rigidbody 组件，然后深入研究了全新的 C# 工作。对于 C#，我们讨论了：
- en: Execution order
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行顺序
- en: Static methods
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: '`UnityAction` (delegate)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnityAction`（委托）'
- en: Coroutines
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: All these new concepts are tools to use on your next project. Take as much time
    as needed to digest these concepts. You will see them used in almost every project
    that you work with.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些新概念都是你下一个项目中可以使用的工具。花尽可能多的时间来消化这些概念。你将在你工作的几乎每个项目中看到它们的使用。
- en: In the next chapter, we need to add menu systems and a user interface so that
    the user can have more context for the gameplay.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们需要添加菜单系统和用户界面，以便用户对游戏玩法有更多的上下文。
