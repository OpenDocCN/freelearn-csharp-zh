- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Libraries for Client Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the updates from the last chapter, the Game API is available to use – including
    access to the database. In this chapter, we’ll create a .NET library that can
    be used by all .NET client applications to access the service. Instead of the
    need to create HTTP requests with every client application, we create a library
    that can be shared.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a library to send HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a client console application to play a game using the library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Microsoft Kiota tool to generate code based on the OpenAPI document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository at [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).
    The source code folder `ch04` contains the code samples for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The service implementation from the previous chapter is stored in the `server`
    folder. There’s just a small change to the previous chapter with the models. The
    models contain annotations (`Required`, `MinLength`, and `MaxLength` attributes).
    This information shows up in the OpenAPI document and can be used on creating
    the client. You can use the file `Chapter04.server.sln` to open and run the solution.
    You need to start the service when running the client application. Based on your
    preference, you need to configure SQL Server or Azure Cosmos DB as discussed in
    the previous chapter. You can also use the in-memory repository instead so that
    you don’t need to have a database running. Change the configuration with the `appsettings.json`
    file based on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new code is in the `client` folder. Here, you will find these projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.GameApis.Client`: This is the new library that includes custom
    models and the `GamesClient` class, which sends HTTP requests to the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Client.Console`: This is a new console application that references
    the client library and can be used to play the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GamesApis.Kiota`: This is a client library that can be used as
    an alternative to `Codebreaker.GameApis.Client` with generated code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Kiota.Console`: This is a console application that uses the Kiota
    client library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library to create HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a microservices team, a good practice is when the team is not only responsible
    to develop the complete service including the database access code, but also at
    least one of the client applications. With traditional development teams, client
    and server development is often spread across different teams. The issue with
    that is that the client and service are best created in collaboration. Creating
    the client, you’ll find answers missing from the services API. Here, a fast communication
    between the client and service developers helps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a library for the client allows us to reuse this functionality from
    all .NET clients; you can create clients with any .NET client technology, such
    as Blazor, WinUI, .NET MAUI, and others. In this chapter, we will just create
    a console application, but you can find clients using Blazor, WinUI, .NET MAUI,
    WPF, and Platform Uno in the GitHub organization at [https://github.com/codebreakerapp](https://github.com/codebreakerapp).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the library to be used by client applications, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a library with multi-targeting support to support different .NET versions
    with the clients
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the `HttpClient` with the main class the client interacts with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send HTTP requests to the games service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a NuGet package for easier use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a library with multi-targeting support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create the library for the client using the `dotnet` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this library, we need the model types for the data to transfer between
    the client and the service and a client class that does the HTTP requests to invoke
    the services API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support clients using different .NET versions, the library is configured
    with multi-targeting support:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Client/Codebreaker.GameAPIs.Client.csproj
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instead of the default entry, `TargetFramework`, an `s` is appended to contain
    a list of frameworks. With multiple frameworks added, multiple binaries are added
    when creating a NuGet package. It might be okay for you to create a library with
    .NET 6, which can also be used from .NET 7 and .NET 8 clients. Using multiple
    frameworks you can create optimized code based on the client version.
  prefs: []
  type: TYPE_NORMAL
- en: 'An optimization is shown with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Generic attributes are new since C# 11\. The generic type of the `JsonStringEnumConverter`
    is new with .NET 8\. This generic version supports Native AOT compilation. The
    older version and the non-generic `JsonStringEnumConverter` uses reflection. Using
    the C# preprocessor directive `#if` and the predefined symbol `NET8_0_OR_GREATER`,
    different code gets compiled based on the framework version.
  prefs: []
  type: TYPE_NORMAL
- en: The models are mainly the same between the client and the service. Here, you
    might choose to move the models from the service-only library to a common library
    that is referenced both from the client and service applications. However, with
    client technologies, you might have other requirements based on validating and
    change notification. With the models of the client library, you can implement
    the interface `INotifyPropertyChanged`, which is used by different client technologies
    to update the user interface automatically if a change is notified. Later in this
    chapter, we’ll also create a library from the OpenAPI document created in [*Chapter
    2*](B21217_02.xhtml#_idTextAnchor031), which can be another reason not to create
    a shared library.
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateGameRequest` is the class we need to send the request when starting
    the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateGameRequest` contains the properties `GameType` and `PlayerName`,
    which are required to start the game. The `GamesQuery` class is used to send different
    query parameters to retrieve a filtered list of games based on the query:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Client/Models/GamesQuery.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `AsUrlQuery` method converts the properties of the record to create HTTP
    query parameters as specified with the games API service and returns the combined
    query string. You might think about adding this method to the `Game` class. The
    `Game` class just defines the structure of the data representing a game. The `GamesQuery`
    class controls how its data can be converted into a URL query string.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `CreateGameResponse`, `UpdateGameRequest`, `UpdateGameResponse`,
    `Game`, and `Move` are needed with this library. Check these types with the GitHub
    repo.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the HttpClient class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GamesClient` class we create next is used to send requests to the games
    service. To use the `HttpClient` class, an object of this class can be injected.
    With the application using the library, this `HttpClient` needs to be configured
    with the base address (in [*Chapter 9*](B21217_09.xhtml#_idTextAnchor216), this
    will be extended with authentication).
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the constructor of the `GamesClient` class is shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Client/GamesClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the constructor of the `GamesClient`, the injected `HttpClient` instance
    is assigned to a variable, and `JsonOptions` is configured. ASP.NET Core maps
    properties on JSON serialization to lowercase. With the options as defined here,
    casing is ignored, so the lowercase map is transferred to uppercase properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t create a new instance of the `HttpClient` class with every request. Instead,
    injecting the client will shift the responsibility to creating instances to the
    calling application. With the dependency injection container, we’ll configure
    the `HttpClient` to be created from a factory.
  prefs: []
  type: TYPE_NORMAL
- en: Sending HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s send some requests to the service to retrieve information about games,
    start games, and set moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first methods are used to retrieve game information:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Client/GamesClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `GetGameAsync` method retrieves one game passing the identifier of the game.
    `GetGamesAsync` uses the previously created `GamesQuery` to create the URI for
    the service to send the HTTP GET request. `GetFromJsonAsync` is an extension method
    for the `HttpClient` class to send an HTTP GET request, checks for a successful
    status code using `EnsureSuccessStatusCode` with `HttpResponseMessage` (which
    throws an `HttpRequestException` if not successful), and uses the `System.Text.Json`
    deserializer to deserialize the stream from the response. When the `game-id` passed
    was not found, we want to return `null` instead of throwing an exception so this
    exception is caught.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending a request to start a game is implemented with the `StartGameAsync`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Client/GamesClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StartGamesAsync` method sends an HTTP POST request after creating the
    data that should be sent with the HTTP body: `CreateGameRequest`. After receiving
    a success response, the `ReadFromJsonAsync` extension method deserializes the
    returned HTTP body and returns the methods result using a tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To send a games move, the game is updated using an HTTP PATCH request:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Client/GamesClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending an HTTP PATCH request is very similar to sending a POST request: the
    `UpdateGameRequest` object is created to send this JSON-serialized information
    to the server. Receiving the result, the body is deserialized to an `UpdateGameResponse`
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With REST APIs, a HTTP PUT request is usually used to update a resource, while
    HTTP PATCH is used for a partial update. Here, the game resource is updated, but
    not by sending the complete game and just some partial data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a NuGet Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a NuGet package from the library, you can use the `dotnet` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the content of the NuGet package, you can rename it to `zip`. For easy
    use of this package, you can add it to a shared folder and configure the Visual
    Studio NuGet Package manager to reference this folder. You can also publish the
    package to Azure DevOps Artifacts. Referencing this, you can create a `nuget.config`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the generated `nuget.config` file, you need to specify the shared folder
    or the link to your Azure DevOps Artifacts feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a `nuget.config` file created using `dotnet new` with one additional
    entry for a custom feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this NuGet configuration file, the entry `<clear />` removes all the default
    feeds. The `nuget` key with the first `add` element references the default feed
    of the NuGet server. Similarly, you can add custom feeds with other keys and links
    to the package feeds on the server.
  prefs: []
  type: TYPE_NORMAL
- en: For the Codebreaker solution, you can look for the NuGet package `Cninnovation.Codebreaker.Client`,
    which is available on the NuGet server. After making NuGet packages available
    on NuGet, a readme file, a license, and some more metadata should be added to
    the package. See further readings for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having the library in place, let’s create a client application. A simple console
    application fulfils the purpose to play the game. With the sample application
    of this chapter, the NuGet packages `Microsoft.Extensions.Hosting`, `Microsoft.Extensions.Http.Resiliency`,
    and `Spectre.Console.Cli` are added. Navigate to the folder of the solution file
    before invoking these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Microsoft.Extensions.Hosting` will be used for a dependency injection container
    and configuration support and `Microsoft.Extensions.Http.Resilience` is the package
    offering an `HttpClientFactory`. Of course, the library created previously needs
    to be referenced as well.'
  prefs: []
  type: TYPE_NORMAL
- en: To interact with the user, you can use simple `Console.ReadLine` and `Console.WriteLine`
    statements. With the sample application available in the books GitHub repo, the
    NuGet package `Spectre.Console.Cli` is used. Just check the source code for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the dependency injection container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The top-level statements of the application are shown with the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Console/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateApplicationBuilder` of the `Host` class configures the dependency
    injection container and has default configuration for the application configuration
    providers and the logging providers. The `AddHttpClient` extension method is implemented
    with the HttpClient factory. Here, the generic method overload is used to specify
    the `GamesClient` class that will receive the `HttpClient` injected as specified
    with the `configureClient` lambda expression. The `BaseAddress` of the `HttpClient`
    is configured to have the `GamesApiUrl` configuration value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the configuration, we create the `appsettings.json` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Console/appsettings.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `GamesApiUrl` key is configured to contain the address of the Games API
    service. To not mess up logging with the console output for the game play, the
    log level is configured to only log warning, error, and critical error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interaction with the user and the invocation of the service happens via
    the `Runner` class. Here, the previously created `GamesClient` is injected into
    the primary constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Console/Runner.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `RunAsync` method first asks the user what to do next. The main options
    are to play a game, to show the status of a single game, to show a list of games,
    or to delete a game. This code snippet makes use of the `Inputs` class, which
    in turn uses the `AnsiConsole` class from the mentioned NuGet package `Spectre.Console.Cli`.
    With this, you get a nice console user interface, as shown in *Figure 4**.1*,
    with easy selections. Depending on what you used for interacting with the user,
    your user interface might look different.
  prefs: []
  type: TYPE_NORMAL
- en: To run a game, first start the server before starting the client. With the client,
    select **Play** (*Figure 4**.1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Console output to select a main task](img/B21217_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Console output to select a main task
  prefs: []
  type: TYPE_NORMAL
- en: Next, select a game type (*Figure 4**.2*), for example, **Game6x4**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Selecting the game type](img/B21217_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Selecting the game type
  prefs: []
  type: TYPE_NORMAL
- en: Enter a player name (*Figure 4**.3*) and enter all the colors needed for a single
    move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Entering the name and selecting the colors depending on the
    game type](img/B21217_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Entering the name and selecting the colors depending on the game
    type
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.4* shows the result of the move (here with three colors correct
    but in the wrong positions) and the start of the next move. Repeat this until
    you solve the codes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Moving the result and the next move](img/B21217_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Moving the result and the next move
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of a successful move is shown in *Figure 4**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Game results](img/B21217_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Game results
  prefs: []
  type: TYPE_NORMAL
- en: From there, you can repeat this to play another game or query for the list of
    games. From the list of games, you can get a game identifier and query for a single
    game passing the identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Using Microsoft Kiota to create a client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the API service generating the OpenAPI document (this was done in [*Chapter
    2*](B21217_02.xhtml#_idTextAnchor031)), we can leverage this information, and
    create the client code automatically. With the sample code of this chapter, the
    OpenAPI document is stored with the file `gamesapi-swagger.json`, which you can
    reference without starting the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option with Visual Studio is to use **Add** | **Connected Client** and
    add a service reference to an OpenAPI document. But this option (at the time of
    this writing) has some limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It still uses the Newtonsoft Json serializer, whereas the new `System.Text.Json`
    one is faster and uses less memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client implementation makes use of strings instead of streams, which can
    result in objects in the large object heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter, creating a custom library to create HTTP requests
    is not that hard and can be optimized for your own domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now there’s another option that should be considered: Microsoft Kiota(https://learn.microsoft.com/openapi/kiota/).
    Microsoft Kiota is a command-line tool that offers code generation from the OpenAPI
    for several languages including Java, PHP, Python, Typescript, C#, and many others.
    Let’s give this a chance.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kiota
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kiota is available as a `dotnet` tool. We install this tool as part of the new
    library for another class library project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library is created with the following commands. Run these commands from
    the `solution` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Kiota, we also need to add some Kiota NuGet packages for different serializers
    and a Kiota HTTP client library. The Kiota tool is installed with the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Generating Code with Kiota
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the Kiota tool is installed, we can generate the code using the OpenAPI
    document `gamesapi-swagger.json`. This file is available in the `ch04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using these options, source code is generated using the referenced OpenAPI document
    `gamesapi-swagger.json`, the generated files are stored in the subdirectory `codebreaker`,
    C# is used for the code generation, the main class to do the HTTP requests is
    named `GamesAPIClient`, and the namespace for all the generated code is `Codebreaker.Client`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the generated code, you’ll see that Kiota-generated code is not using
    the same coding convention as used in this book or as the .NET team is using.
    For example, the opening of curly braces is done in the same line as the method
    name, which is a convention used with many JavaScript programs. If you use Visual
    Studio, you can easily change this with the complete program using the context
    menu in Solution Explorer, navigating to **Analyze and Code Cleanup** | **Run
    Code Cleanup**. You might need to configure your preferences with code cleanup
    first.
  prefs: []
  type: TYPE_NORMAL
- en: The types created using Kiota are the models (using the `schemas` within OpenAPI)
    and request builders (using the `paths` where the requests are defined). Check
    the book repository for the generated code files.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Kiota-generated models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For all the requests and responses and all the types specified within the schemas,
    Kiota generates classes in the `Models` directory. Let’s have a look at the `CreateGameRequest`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GamesAPIs.KiotaClient/codebreaker/Models/CreateGameRequest.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The model types implement the `IParsable` interface. This is not the `System.IParsable`
    interface, but a version from the Kiota library in the namespace `Microsoft.Kiota.Abstractions.Serialization`.
    This interface defines instance members `GetFieldDeserializers` and `Serialize`.
    With this, Kiota offers an abstraction layer, which allows for the use of different
    serializers.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect that needs mentioning is that all the properties of
    the model types are declared to be nullable. While EF Core supports nullability
    to map non-nullable members to be required in the database, this annotation is
    not used when generating the OpenAPI document using the minimal APIs. Adding the
    `Required` attribute to the models on the server adds `required`. Other annotations
    such as `MaxLength` and `MinLength` are mapped as well with `maxLength` and `minLength`,
    as you can see with `gamesapi-swagger.json`.
  prefs: []
  type: TYPE_NORMAL
- en: However, many APIs don’t pay attention to nullability. With the OpenAPI definition
    too, it’s also not exlpicitly specified how strict nullability should be enforced.
    Depending on the context where the model is used, information can still be left
    out from the server, and the data is not sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a discussion about the Kiota implementation: https://github.com/microsoft/kiota/issues/2594'
  prefs: []
  type: TYPE_NORMAL
- en: With the next major version of the OpenAPI specification, this might change.
    With the decisions made for the current Kiota implementation, Kiota is on the
    safe side to declare all the model properties as nullable, but this also means
    that we need to check for `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Kiota-generated request builders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal of request builders is to easily create requests. Let’s look at some
    of the generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GamesAPIs.KiotaClient/codebreaker/GamesAPIClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All the request builders derive from the base class, `BaseRequestBuilder`. The
    `GamesApiClient` class, where the name was specified with the code generation,
    is the request builder that needs to be initiated to communicate with the Games
    API. In the constructor, you can see default serializers and deserializers configured.
    Here, Kiota gives another flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Games` property of `GamesApiClient` returns another request builder: `GamesRequestBuilder`.
    This builder is in the `GamesRequestBuilder.cs` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GamesAPIs.KiotaClient/codebreaker/Games/GamesRequestBuilder.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This request builder is then used to invoke requests of the games API. Methods
    implemented by this request builder are `GetAsync` and `PostAsync`. The `GetAsync`
    method is used to retrieve a list of games with query parameters. `PostAsync`
    sends a POST request with the generated `CreateGameRequest` model.
  prefs: []
  type: TYPE_NORMAL
- en: To get a single game, update a game by sending a game move, and delete a game,
    the games API needs a game identifier. With Kiota, this is solved by offering
    an indexer with `GamesRequestBuilder`, which in turn returns another request builder,
    `GameItemsRequestBuilder`. Here, a fluent API can be used to pass a game identifier
    and invoke the `GetAsync` and `PutAsync` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement another console application to use this generated code in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Kiota-generated code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kiota-generated code is used with the console application `Codebreaker.KiotaConsole`.
    With big parts, the code of this application is similar to the console application
    from before. Mainly the invocations to the service, which are done with the `Runner`
    class, are now replaced and the dependency injection container configuration is
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HttpClient factory is no longer registered with the DI container, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.KiotaConsole/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Other than removing the code for the `HttpClient` configuration, the base address
    is now configured to supply values for the `RunnerOptions` class. This class just
    defines the `GamesApiUrl` property to specify the base address for the games service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of the `Runner` class where the options are passed is shown
    in the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.KiotaConsole/Runner.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation of the `Runner` constructor, the `GamesAPIClient` class
    is instantiated. This class receives `HttpClientRequestAdapter`, which has the
    base address of the service configured. The constructor of `HttpClientRequestAdapter`
    receives an object implementing the `IAuthenticationProvider` interface. Here,
    `AnonymousAuthenticationProvider` is used as no authentication is needed. Kiota
    offers various authentication providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending a GET request with query parameters to get a list of games, you invoke
    the `GetAsync` method of `GamesRequestBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.KiotaConsole/Runner.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Games` property returns the generated `GamesRequestBuilder`, which allows
    us to invoke the `GetAsync` method passing query parameters. Kiota offers its
    own `Date` type within the `Microsoft.Kiota.Abstractions` namespace, which represents
    the date-only part of `DateTime`. Today, .NET offers `DateOnly`, but this type
    is not available with .NET Standard 2.0, which is also supported by Kiota.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting a game is done by sending a POST request, as shown in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.KiotaConsole/Runner.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Starting the game, the user input for the player name and the game type are
    assigned to the `CreateGameRequest` object. This model type is then passed with
    the invocation of the `PostAsync` method to start a game and to receive `CreateGameResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving a single game passing the game identifier is shown in the next code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.KiotaConsole/Runner.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving a single game, updating the game with a HTTP PATCH request, and deleting
    a game with the HTTP DELETE request all need the game identifier as the query
    parameter. To use this, Kiota offers an indexer passing `game-id` and continuing
    with a fluent API. To retrieve a single game, the `GetAsync` method is used. Patching
    and deleting games are very similar.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, you can use the Kiota-generated code and write the implementation
    to update the game by sending a game move with the `PostAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new client, you can run the game in the same way as shown before!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working through this chapter, you’ll have a running client console application
    to run the game. We used the `HttpClient` class to send requests to the games
    service. To reuse this with different client technologies, we created a library.
    For efficient use of the `HttpClient` class, you learned to use the HttpClient
    factory.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of implementing the models on your own, you learned using Microsoft
    Kiota to create code from the OpenAPI definition. With your own scenarios, you
    can now decide what’s the best option for you.
  prefs: []
  type: TYPE_NORMAL
- en: Before reading the next chapter, you can reuse this newly created library and
    create clients of your choice such as Blazor, WinUI, or .NET MAUI. While these
    frameworks are outside of the scope of this book, you can check [https://github.com/codebreakerapp](https://github.com/codebreakerapp)
    for more clients available.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what client you implement, before diving into the next chapter, it’s
    well deserved to play one more game—this time with your own created client application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the focus will be on the services again; we’ll host the
    service application (and another service) with a Docker container. This new service
    will also use the HTTP client created in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient` guidelines: https://learn.microsoft.com/dotnet/fundamentals/networking/http/httpclient-guidelines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NuGet packages best practices: https://learn.microsoft.com/nuget/create-packages/package-authoring-best-practices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The large object heap on Windows systems: https://learn.microsoft.com/dotnet/standard/garbage-collection/large-object-heap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Kiota documentation: [https://learn.microsoft.com/openapi/kiota/](https://learn.microsoft.com/openapi/kiota/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kiota GitHub repository: [https://github.com/microsoft/kiota](https://github.com/microsoft/kiota)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Hosting and Deploying'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part focuses on essential aspects of hosting and deploying microservices.
    You will begin by gaining a comprehensive understanding of Docker fundamentals,
    such as creating Dockerfiles, building Docker images using the .NET CLI, and running
    Docker containers with .NET Aspire on your development environment. You will then
    proceed to publish Docker images to the Azure Container Registry, deploy them
    to the Azure Container Apps environment (based on Kubernetes), and incorporate
    Azure services like Azure App Configuration and Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this part, you will utilize Azure resources for local application
    execution, deploy applications to Azure using the Azure Developer CLI, and establish
    GitHub Actions for automated deployment to Azure upon code updates in the repository.
    To ensure seamless operation in both on-premises and Azure environments, authentication
    will be implemented with Azure Active Directory B2C and Microsoft Entra, alongside
    ASP.NET Core Identities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21217_05.xhtml#_idTextAnchor110), *Containerization of Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21217_06.xhtml#_idTextAnchor137), *Microsoft Azure for Hosting
    Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21217_07.xhtml#_idTextAnchor162)*, Flexible Configuration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21217_08.xhtml#_idTextAnchor183)*, CI/CD – Publishing with GitHub
    Actions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21217_09.xhtml#_idTextAnchor216)*, Authentication and Authorization
    with Services and Clients*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
