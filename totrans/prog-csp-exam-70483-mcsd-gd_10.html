<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Find, Execute, and Create Types at Runtime Using Reflection</h1>
                </header>
            
            <article>
                
<p>The .NET Framework contains not just code but metadata as well. Metadata is data about assemblies, types, methods, properties, and so on used in a program. These assemblies, properties, types, and methods are classes defined within the C# programming language. These classes, types, and methods are retrieved at runtime to parse a developer's application logic for execution. Attributes allow us to add extra information to these programs as well as methods that can be used during runtime while executing application logic.</p>
<p>The .NET Framework also allows developers to define this metadata information during development. It can be read during runtime using reflection. Reflection enables us to create an instance of the type retrieved and to invoke its methods and properties.</p>
<p>In this chapter, we will understand how the .NET Framework allows us to read and create metadata, and we will also learn how to use reflection to read metadata and process it during runtime. I<span>n the </span><em>Attributes</em><span> section, w</span>e will focus on using attributes, creating custom attributes, and learn how to retrieve attribute information at runtime. The <em>Reflection</em> section supplies an overview of how we can use reflection to create types, access properties, and invoke methods. Reflection also allows us to retrieve attribute information; for example, this could be extra information that we provided to .NET Runtime to be processed while executing the application logic.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>Attributes</li>
<li>Reflection</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The exercises in this chapter can be performed using Visual Studio 2012 and later with the .NET Framework 2.0 and later. However, any new C# features from C# 7.0 and later require you to have Visual Studio 2017.</p>
<p>If you don't have a license for any of these products, then you can download the Community Version of Visual Studio 2017 from<span> <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</span></p>
<p>The sample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter10">https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter10</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attributes</h1>
                </header>
            
            <article>
                
<p>Metadata or declarative information on types, methods, and properties can be associated using attributes. Metadata refers to what types are defined in a program. For instance, a class is a type: each class defines certain properties and methods, each property is of a type, and each method accepts certain data types and returns certain data types. All this information is referred to as metadata and can be accessed and retrieved during program execution.</p>
<p><span>L</span>ike<span> any other method, </span>while you define an attribute, you can define the parameters as well. You can define one or more attributes on an assembly, class, method, or property. Based on the program requirements, you can define what types of attribute your application needs and define them in your program. Once defined, you can read this information while executing your program and then process it.</p>
<p>In the following section, we will demonstrate how to use attributes and create custom attributes as per our requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using attributes</h1>
                </header>
            
            <article>
                
<p>A declarative way of associating information to code can be done via attributes. However, only a few attributes can be used on every type. Instead, they are used for specific types. Attributes on any type can be specified by using square brackets, <kbd>[]</kbd>, on top of the type that we want to apply.</p>
<p class="mce-root"/>
<p><span>Let's take a look at the following code. </span>Generally, we see the <kbd>Serializable</kbd> attribute when we want to serialize an object to the binary or XML formats. In real-world applications, when we need to transfer a large object over the wire, we serialize an object into one of the aforementioned formats and then send it. The s<span>erialize attribute</span> <span>on a class enables runtime to allow converting the object to binary or XML or any format required by the program:</span></p>
<pre>[Serializable]<br/>public class AttributeTest<br/>{<br/>//object of this class can now be serialized<br/>}</pre>
<p>Another common usage of attributes is in unit test projects. Observe the following code:</p>
<pre>namespace Chapter10.Test<br/>{<br/>    [TestClass]<br/>    public class UnitTest1<br/>    {<br/>        [TestMethod]<br/>        public void TestMethod1()<br/>        {<br/>        }<br/>    }<br/>}</pre>
<p>In the preceding code snippet, we create a new test project where two attributes are added to each class and method. By adding them in this way, we are letting the framework know that this class represents a test class and that the method is a test method.</p>
<p>As mentioned earlier, the use of attributes can be restricted to specific types. To achieve this, we will use attribute targets. By default, an attribute is applied to the preceding type. However, using a target, we can set whether the attribute applies to a class, method, or an assembly.</p>
<p>When the target is set to assembly, it means that the attribute is applied to the entire assembly. Similarly, a target can be set to a module, field, event, method, property, or type.</p>
<p>For example, an attribute can be set on a field to let the runtime know what type of input is accepted. Additionally, it can be set on a method to specify whether it is a normal method or a web method.</p>
<p class="mce-root"/>
<p>Some common attributes defined by the framework include the following:</p>
<ul>
<li><strong>Global</strong>: Attributes that are applied at the assembly or module level are generally global attributes, for example, <kbd>AssemblyVersionAttribute</kbd>. You might have seen this in every <span>.NET </span>project that is created using Visual Studio.</li>
</ul>
<p style="padding-left: 60px">Let's take a look at the following example. Here, you can see the <kbd>assembly.cs</kbd> file created when you create any .NET project using Visual Studio. Every assembly contains the following code, which tells the runtime about the current assembly that is being executed:</p>
<pre style="padding-left: 60px">using System.Reflection;<br/>using System.Runtime.CompilerServices;<br/>using System.Runtime.InteropServices;<br/><br/>[assembly: AssemblyTitle("Chapter10")]<br/>[assembly: AssemblyDescription("")]<br/>[assembly: AssemblyConfiguration("")]<br/>[assembly: AssemblyCompany("")]<br/>[assembly: AssemblyProduct("Chapter10")]<br/>[assembly: AssemblyCopyright("Copyright © 2019")]<br/>[assembly: AssemblyTrademark("")]<br/>[assembly: AssemblyCulture("")]<br/><br/>[assembly: ComVisible(false)]<br/><br/>// The following GUID is for the ID of the typelib if this project is exposed to COM<br/>[assembly: Guid("f8a2951a-4520-4d0f-ab30-7dd609db84d5")]<br/><br/>[assembly: AssemblyVersion("1.0.0.0")]<br/>[assembly: AssemblyFileVersion("1.0.0.0")]</pre>
<ul>
<li><strong>Obsolete</strong>: This attribute allows us to mark an entity or a class that should not be used. Therefore, when applied, it generates a warning message that is provided while applying the attribute. This class defines three constructors: the first without any parameters, the second with one parameter, and the third with two parameters. From a code-readability perspective, it is recommended that we use constructors with parameters as they generate warning or error messages based on usage. Additionally, setting the second parameter to <kbd>true</kbd> while applying an attribute will throw an error, whereas <kbd>false</kbd> will generate a warning. In the following code, we will see how we can use an obsolete attribute.</li>
</ul>
<p style="padding-left: 60px">In the following code snippet, we defined a class named <kbd>Firstclass</kbd>; later, a new class was created with the name <kbd>SecondClass</kbd>. When we want new users accessing our library to use the second class rather than the first class, then we can use an <kbd>Obsolete</kbd> attribute with a message so that new users will see it and act accordingly:</p>
<pre style="padding-left: 60px">[System.Obsolete(Firstclass is not used any more instead use SecondClass)]<br/>class FirstClass<br/>{<br/>    //Do Firstthing<br/>}<br/><br/>class SecondClass<br/>{<br/>    //Do Secondthing<br/>}</pre>
<ul>
<li><strong>Conditional</strong>: When a conditional attribute is applied, the execution of the preceding code depends on the evaluation of the attribute. In a real-project scenario, while running a program in a live environment, you don't want to log information and messages and fill up your storage. Instead, you can have a conditional attribute on your log methods, which will allow you to write when a flag in your configuration file is set to <kbd>true</kbd>. In this way, you can actually implement selecting logging.</li>
</ul>
<p style="padding-left: 60px"><span><span>In the following code, we have a <kbd>LogMessage</kbd> method; however, the attribute above the class will let the run</span></span><span><span>time application know that, when the <kbd>LogErrorOn</kbd> attribute is set to <kbd>yes</kbd> or</span></span> <kbd>true</kbd><span><span>, it should execute this method:</span></span></p>
<pre style="padding-left: 60px"><span class="hljs-keyword">using</span><span> System; <br/></span><span class="hljs-keyword">using</span><span> System.Diagnost</span><span>ics;</span><br/>Public class Logging<br/>{<br/>    [Conditional(LogErrorON)]<br/>    public static void LogMessage(string message)<br/>    {<br/>        Console.WriteLine(message)<br/>    }<br/>}<br/><span class="hljs-keyword">public</span><span> </span><span class="hljs-keyword">class</span><span> TestLogging</span><span><br/>{     <br/>    </span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()     <br/>    </span><span>{         <br/>        Trace.Msg(</span><span class="hljs-string">"Main method executing..."</span><span>);         <br/>        Console.WriteLine(</span><span class="hljs-string">"This is the last statement."</span><span>);     <br/>    } <br/>} </span><br/><br/></pre>
<ul>
<li><strong>Caller information</strong>: The caller information attribute allows you to retrieve who is calling the method. They are <kbd>CallerfilePathAttribute</kbd>, <kbd>CallerLineNumberAttribute</kbd>, <kbd>CallerMemberNameAttribute</kbd>. Each one has its own purpose, as their names suggest. They allow us to get the line number, the method name, and the path of the file. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom attributes</h1>
                </header>
            
            <article>
                
<p>C# allows you to define your own attributes. This is similar to normal C# programming where you define classes and properties. To define an attribute, the first thing you need to do is to inherit it from the <kbd>System.Attribute</kbd> class. The class and properties you define are used to store and retrieve data at runtime.</p>
<p>There are four steps that you need to complete in order to complete defining custom attributes:</p>
<ul>
<li>Attribute usage</li>
<li>Declaring attribute class</li>
<li>Constructors</li>
<li>Properties</li>
</ul>
<p>Attribute usage can be defined by using <kbd>System.AttributeUsageAttribute</kbd>. We already mentioned that there are restrictions on certain attributes, which define where they can be used—for example, in classes, methods, or properties. <kbd>AttributeUsageAttribte</kbd> allows us to define such restrictions. <kbd>AllowMultiple</kbd> specifies whether this attribute can be used more than once on a specific type. Inherited controls defining child classes form the current attribute class. The following is the general syntax for using the <kbd>AttributeUsage</kbd> class:</p>
<pre>[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]</pre>
<p>As you might have observed, you can declare the <kbd>AttributeUsage</kbd> attribute using its constructor on top of the custom attribute you want to define with the three parameters. With <kbd>AtributeTargetsAll</kbd>, you can use <kbd>CustomAttribute</kbd> on any type of element that is a class, property, method, and so on. A full list of allowed values is defined at <a href="https://docs.microsoft.com/en-us/dotnet/api/system.attributetargets?view=netframework-4.7.2#System_AttributeTargets_All">https://docs.microsoft.com/en-us/dotnet/api/system.attributetargets?view=netframework-4.7.2#System_AttributeTargets_All</a>.</p>
<p class="mce-root"/>
<p><kbd>Inherited</kbd> and <kbd>AllowMultiple</kbd> are both Boolean properties, which accept true or false.</p>
<p>Once we define <kbd>AttributeUsage</kbd>, we can now move on to declare our custom class. This should be a public class and must inherit from the <kbd>System.Attribute</kbd> class. </p>
<p>Now that we have our class declared, we can move on and define our constructors and properties. The framework allows us to define one or more constructors, covering all possible scenarios around a different combination of properties. Let's define a custom attribute. A constructo<span>r of these attributes </span>accepts three parameters—<span><kbd>AttributeTargets</kbd>, <kbd>AllowMultiple</kbd>, and <kbd>Inherited</kbd>:</span></p>
<pre>using System;<br/><br/>namespace Chapter10<br/>{<br/>    [System.AttributeUsage(System.AttributeTargets.Field | System.AttributeTargets.Property, Inherited =false,AllowMultiple = false)]<br/>    public class CustomerAttribute : Attribute<br/>    {<br/>        public CustomerType Type { get; set; }<br/><br/>        public CustomerAttribute()<br/>        {<br/>            Type = CustomerType.Customer;<br/>        }<br/>    }<br/><br/>    public enum CustomerType<br/>    {<br/>        Customer,<br/>        Supplier,<br/>        Vendor<br/>    }<br/>}</pre>
<p>The preceding code defines a custom attribute named <kbd>CustomerAttribute</kbd>. We also defined a <kbd>CustomerType</kbd> <span>enum </span>that we want to use as an <kbd>Attribute</kbd> property. By not defining any parameters in the constructor and assigning the <kbd>Customer</kbd> type to a <kbd>Type</kbd> property, we are telling runtime, by default, when its value is a customer. Additionally, this attribute is set to be used on either a field or property so that it cannot be used at the class level.</p>
<p class="mce-root"/>
<p>Now, let's examine how we can use this attribute in our class:</p>
<pre>namespace Chapter10<br/>{<br/>    <br/>    internal class Account<br/>    {<br/>        public string CustomerName { get; set; }<br/><br/>        [Customer]<br/>        public RatingType Rating { get; set; }<br/>    }<br/><br/>    public enum RatingType<br/>    {<br/>        Gold =1,<br/>        Silver =2,<br/>        Bronze=3<br/>    }<br/>}</pre>
<p>Here, we defined an <kbd>Account</kbd> class where we used our custom attribute. We applied an attribute without any parameters. This means that, by default, we create an account of the customer type. In the following section, we will demonstrate how we can retrieve these attributes and use them in our application logic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving metadata</h1>
                </header>
            
            <article>
                
<p>As you are aware of OOP concepts, retrieving attribute information is as simple as creating an instance of the attribute that we want to retrieve, and then invoking the<span> </span><kbd>GetCustomAttribute</kbd><span> </span>method of the<span> </span><kbd>System.Attribute</kbd><span> </span>class.</p>
<p>In the following example, we define a new attribute called <kbd>ChapterInfo</kbd> and define a constructor to mark two of its properties as required parameters:</p>
<pre>[System.AttributeUsage(System.AttributeTargets.Class, Inherited =false,AllowMultiple = false)]<br/>    public class ChapterInfoAttribute : Attribute<br/>    {<br/>        public string ChapterName{ get; set; }<br/>        public string ChapterAuthor { get; set; }<br/><br/>        public ChapterInfoAttribute(string Name, string Author)<br/>        {<br/>            ChapterName = Name;<br/>            ChapterAuthor = Author;<br/>        }<br/>    }</pre>
<p><kbd>ChapterName</kbd> and <kbd>ChapterAuthor</kbd> are the two required parameters that the developer has to define when using this attribute.</p>
<p>As you can see, in the following code the attribute is being defined over the <kbd>Program</kbd> class with two values: <kbd>Name</kbd> and <kbd>Author</kbd>. In the main method,<span> </span><kbd>GetCustomAttribute</kbd><span> </span>is invoked to read its properties, as you would do for any other class type variable:</p>
<pre>namespace Chapter10<br/>{<br/>    [ChapterInfo("SAMPLECHAPTER", "AUTHOR1")]<br/>    class Program<br/>    {<br/>        static void Main(string[] args)<br/>        {<br/>            ChapterInfoAttribute _attribute = (ChapterInfoAttribute)Attribute.GetCustomAttribute(typeof(Program), typeof(ChapterInfoAttribute));<br/>            Console.WriteLine($"Chapter Name is: {_attribute.ChapterName} and Chapter Author is: {_attribute.ChapterAuthor}");<br/>            // Keep the console window open in debug mode.<br/>            System.Console.WriteLine("Press any key to exit.");<br/>            System.Console.ReadKey();<br/>        }<br/>    }<br/>}</pre>
<p>Observe the following output:</p>
<pre><strong>//Output</strong><br/><strong>Chapter Name is: SAMPLECHAPTER and Chapter Author is: AUTHOR1</strong><br/><strong>Press any key to exit.</strong></pre>
<p><span>As you can see, the (<kbd>[ChapterInfo("SAMPLECHAPTER", "AUTHOR1")]</kbd>) values passed in the attribute definition over the program class were retrieved and displayed.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reflection</h1>
                </header>
            
            <article>
                
<p style="font-weight: 400">Reflection is a way to query metadata at runtime from the application program. Reflection supplies type information from the assemblies loaded into memory that you can use to create an instance of the class and also access properties and methods of the class.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p style="font-weight: 400">For example, your application code executes a query and returns a dataset object, but your frontend accepts a custom class or model, and the model is defined during runtime. Based on the request received, reflection can be used to create the required model/class at runtime, access its properties or fields, and set their value by traversing through the resulting dataset.</p>
<p style="font-weight: 400">Additionally, in previous sections, we learned how we can create custom attributes. So, in a scenario where you create an attribute to restrict numbers in a specific property, you can then use reflection to read the attribute, get the preceding property, implement application logic to restrict numbers, or display a message to users.</p>
<p>We can also use reflection to create a type at runtime and access its methods and properties. Reflection works with <kbd>System.Types</kbd> to query information about assemblies that are currently loaded into memory and are being executed.</p>
<p>The <span><strong>Common Language Runtime</strong> (<strong>CLR</strong>)</span> manages application domains with boundaries around objects that are of the same scope.  This process includes loading assemblies into these domains and controlling them as required.</p>
<p>In the .NET world, assemblies contain modules, modules contain types, and types contain members. An assembly class is used to load assemblies. Modules are used to identify information about classes in the assembly as well as global and non-global methods.</p>
<p>There are many methods available in the <kbd>Reflection</kbd> class, such as <kbd>MethodInfo</kbd>, <kbd>PropertyInfo</kbd>, <kbd>Type</kbd>, <kbd>CustomAttribute</kbd>, and many more. These methods help developers to retrieve information at runtime. In the previous example, we used the <kbd>GetCustomAttribute</kbd> method to retrieve attribute information and displayed it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Invoking methods and using properties</h1>
                </header>
            
            <article>
                
<p>In this section, we'll take a look at how we can access the properties and methods of a custom class at runtime using reflection.</p>
<p>This example serves to give you an idea of how we can access methods and properties using reflection at runtime. However, based on your requirements, you can dynamically access properties, their types and methods, and their parameters.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We created a new custom class where we defined two integer type properties: <kbd>Number1</kbd> and <kbd>Number2</kbd>. Then, we defined a public method that accepts a parameter and <span>returns a number to be added or subtracted</span>: </p>
<pre>internal class CustomClass1<br/>    {<br/>        public int Number1 { get; set; }<br/>        public int Number2 { get; set; }<br/><br/>        public int Getresult(string action)<br/>        {<br/>            int result = 0;<br/>            switch (action)<br/>            {<br/>                case "Add":<br/>                    result = Number1 + Number2;<br/>                    Console.WriteLine($"Sum of numbers {Number1} and {Number2} is : {result}");<br/>                    break;<br/><br/>                case "Subtract":<br/>                    result = Number1 - Number2;<br/>                    Console.WriteLine($"Difference of numbers {Number1} and {Number2} is : {result}");<br/>                    break;<br/>            }<br/>            return result;<br/>        }<br/>    }</pre>
<p>Then, we created a simple method where we could access the properties and methods of the custom class that we created previously. In the first line, we retrieved the type information of the custom class. Using this type, we created an instance of the class using the <kbd>Activator.CreateInstance</kbd> method. Now, using the <kbd>Getproperties</kbd> method of the type we retrieved, we accessed all the properties and set a value to each of them based on the property name.</p>
<p>In the next line, using the <kbd>Type</kbd> information of the object, we retrieve <kbd>MethodInfo</kbd> using the <kbd>GetMethod</kbd> method. Then, we invoked the <kbd>public</kbd> method of the custom class twice with two different actions called <kbd>Add</kbd> and <kbd>Subtract</kbd>:</p>
<pre>public static void GetResults()<br/>        {<br/>            Type objType = typeof(CustomClass1);<br/>            object obj = Activator.CreateInstance(objType);<br/>            foreach (PropertyInfo prop in objType.GetProperties())<br/>            {<br/>                if(prop.Name =="Number1")<br/>                    prop.SetValue(obj, 100);<br/>                if (prop.Name == "Number2")<br/>                    prop.SetValue(obj, 50);<br/>            }<br/><br/>            MethodInfo mInfo = objType.GetMethod("Getresult");<br/>            mInfo.Invoke(obj, new string[] { "Add" });<br/>            mInfo.Invoke(obj, new string[] { "Subtract" });<br/>        }</pre>
<p>If you run the program and debug every line, you will see that each property has been retrieved and values have been set. The following is the output of the program:</p>
<pre><strong>Sum of numbers 100 and 50 is : 150</strong><br/><strong>Difference of numbers 100 and 50 is : 50</strong><br/><strong>Press any key to exit.</strong></pre>
<p>This sample is a simple one, as we created two properties, both of the integer type. However, in real time, such simple scenarios may not exist. Therefore, at runtime, you need to use the <kbd>GetType</kbd> method in order to understand the type of property retrieved.</p>
<p>Additionally, in the example we were able to get the type of the <kbd>Custom</kbd> class where we hardcoded it. Using generics, we can even pass the class at runtime and get the info type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In<span> </span>this chapter, we learned how we can use system attributes, create custom attributes, retrieve attributes, and then use them in our application logic. Using reflection to retrieve attribute information, we also looked at how we can create types, access properties, and invoke<span> </span>a method.</p>
<p>In the next chapter, we will gain an understanding of why is it<span> </span>important to validate application input, the type of information that flows into our application, and how can we handle it.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>While creating custom attributes, <span>a target can be set to restrict the usage of an attribute</span>?
<ol>
<li>True</li>
<li>False</li>
</ol>
</li>
<li>_______ is the method used to retrieve attribute information.
<ol>
<li><kbd>GetAttributeValue</kbd></li>
<li><kbd>GetCustomAttribute</kbd></li>
<li><kbd>GetMetadata</kbd></li>
<li><kbd>GetAttributeMetadata</kbd></li>
</ol>
</li>
<li>The system allows you to retrieve property information from the object?
<ol>
<li>True</li>
<li>False</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Answers</h1>
                </header>
            
            <article>
                
<ol>
<li style="list-style-type: none">
<ol>
<li><strong>True</strong></li>
<li><strong>GetAttributeValue</strong></li>
<li><strong>True</strong></li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    </body></html>