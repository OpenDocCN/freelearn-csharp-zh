- en: Chapter 2. Looking at Multithreaded Classes – BackgroundWorker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# offers a variety of ways to create and control threads in our applications.
    There are the `Thread` and `ThreadPool` classes, the **Task Parallel Library**
    (**TPL**), the `Async` methods, and the `BackgroundWorker` component. The `BackgroundWorker`
    is the original way of doing multiple things at once in C# and, to many, it has
    become passé and `Tasks` and `Threads` are now the preferred method. But for simple
    multithreaded needs, `BackgroundWorker` is an extremely handy and easy-to-use
    way to accomplish multiple things at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will study this component in detail, and we will begin
    developing multithreaded applications that take full advantage of multiprocessing.
    After reading this and following the exercises, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop applications that are able to execute tasks in the background while
    keeping alive the graphical user interface, offering the user a more real-life
    experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to create independent threads using a simple component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the differences between synchronous and asynchronous execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop applications that are able to show the progress of their many concurrent
    running tasks in the graphical user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to start and cancel background tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop applications capable of launching multiple background tasks when necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with the BackgroundWorker component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the introduction of .NET 2.0 (C# 2005), a new component has become a part
    of Visual C# that simplifies the execution of tasks in independent threads, separated
    from the main thread. It is the `BackgroundWorker` component (`System.ComponentModel.BackgroundWorker`),
    and it allows us to begin working with many threads and taking advantage of parallelism
    with very little effort.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of components in C# and the .NET working environment
    is the possibility to define their properties, values, and events in design time
    without the need to write lots of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the `BackgroundWorker` component is not a **Windows Presentation
    Foundation** (**WPF**) component. As you can see in the following screenshot,
    in a Windows Form application, it is available in **Toolbox** under **Components**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the BackgroundWorker component](img/8321EN_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a WPF application, it is not available, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the BackgroundWorker component](img/8321EN_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This does not mean that it is not available in WPF. It just means that you
    will need to implement it completely in code instead of being able to manipulate
    it in the **Designer** view. To declare a `BackgroundWorker` instance in WPF,
    we simply add the following `using` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Historically, multithreaded programming terrified developers because of the
    extreme complexity of the code needed to initialize, coordinate, stop, and free
    those threads.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to begin experimenting with multithreading in .NET and learn
    the basic principles is to use the `BackgroundWorker` component. It allows us
    to define certain properties in design time (in Windows Forms) and introduce the
    code for the `DoWork` event handler. It represents an easy and rapid way to generate
    a new thread, independent of the main thread (the one that runs the main application's
    flow), and without having to use more flexible or more complicated methods.
  prefs: []
  type: TYPE_NORMAL
- en: The work to be done and run in a new thread is programmed in the `DoWork` event
    handler of `BackgroundWorker`. To understand how it works, let's look at an example
    to see it in action and experience the difference between the code running in
    the same thread (the application's main thread) and in another thread.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we must create a CodeBreaker application. There is a code of four
    Unicode characters, and we want to break it by a brute-force attack. Therefore,
    we must loop through each Unicode character until we have a match, then move on
    to the next character, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the application will take some time to break the code, we do not
    want to get caught by a guard during the hacking process. Therefore, we will add
    some pictures that will simulate a Fishes game, present in the *How to do it*
    section under the *Simple example without a BackgroundWorker object* section.
    We must be able to hide our hacking application and show the Fishes game by clicking
    on a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to build a new C# application, and we will program a classic
    linear programming loop with some processing in order to run the code in the same
    thread (the application''s main thread):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a computer with at least two cores or two microprocessors installed
    in order to achieve significant results for the forthcoming experiments, and for
    the examples in the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Simple example without a BackgroundWorker object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start this WPF chapter by first creating a single thread version of
    our CodeBreaking application. This will give us a starting point and show us the
    limitations of running everything on a single thread. We will then refactor our
    application to use two threads, and then many threads, to show the improved performance
    and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, we will be doing all of this in a WPF application instead
    of Windows Forms. This will require us to work with the `BackgroundWorker` component
    entirely in code instead of being able to use it at design time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps that we need to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new WPF application C# project in Visual Studio (**File** | **New**
    | **Project** | **Visual C#** | **WPF Application**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IDE will create a very simple application with `MainWindow.xaml` and `MainWindow.xaml.cs`
    files. We will name our project `CodeBreaker`:![How to do it](img/8321EN_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `MainWindow.xaml` in the designer, and add the following controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two images showing a skull and an agent (`imgSkull` and `imgAgent`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Three images showing three fish (`imgFish1`, `imgFish2`, and `imgFish3`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Four textblock elements with their `Text` property set to `"#1"`,`"#2"`,`"#3"`,
    and `"#4"` (`txtNumber1`, `txtNumber2`, `txtNumber3`, and `txtNumber4` respectively).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Four labels with their `Text` property set to `"*"` (`txtOutput1`, `txtOutput2`,
    `txtOutput3`, and `txtOutput4`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One textblock element with its `Text` property set to `"CodeBreaker (Single-threaded)"`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One textblock with its `Text` property set to `"Fishes Game!!!"`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One button with its `Text` property set to `"Start"` (`btnStart`). This is the
    button that will run the main loop, which will find the code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One button showing with its `Text` property set to `"Hide"` (`btnHide`). This
    button must hide all the controls related to the CodeBreaker and show the Fishes
    game. You will click on this button when the guard is coming!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One button with its `Text` property set to `"Game over"` (`btnGameOver`). This
    button must hide all the controls related to the Fishes game and show the CodeBreaker
    again. You will click on this button when the guard has gone and you will feel
    safe to continue breaking the code!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The controls mentioned here are shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_02_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the `MainWindow.xaml.cs` code file, add the following line in the `public
    partial class MainWindow : Window` definition to declare two private variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method, `SimulateCodeGeneration`, to our `MainWindow` class.
    This will simulate the code that must be broken:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following procedure, `setFishesVisibility`. This will change the visibility
    of the controls related to the Fishes game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following procedure, `setCodeBreakerVisibility`. This will change the
    visibility of the controls related to the CodeBreaking procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following procedure, `showFishes`. This will show the Fishes game and
    will hide everything related to the CodeBreaking procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following procedure, `showCodeBreaker`. This will hide the Fishes game
    (implying you do not want to play), and will show everything related to the CodeBreaking
    procedure. You need this in order to break the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, `checkCodeChar`. This will return `true` if the
    received character and position matches the one in the code. This will help us
    in our simulation, and we can then replace it with a real decoder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the MainWindow constructor (after `InitializeComponent()`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Click` event in the button `butGameOver` and enter the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Click` event in the button `butHide`, and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Click` event in the button `butStart`, and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application:![How to do it](img/8321EN_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start** button. While the loop is running and the code is being
    broken by brute force, try clicking on the **Hide** button. You won't be able
    to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a guard comes past when you are trying to break the code, you will be caught
    because there is no way to stop the CodeBreaking once it starts until it completes.
  prefs: []
  type: TYPE_NORMAL
- en: Why? Because we do not have a multithreaded application, we lose control over
    the graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The code programmed in the `btnStart` click event handler runs in the main thread.
    Therefore, when the user clicks on this button, he or she loses control over the
    UI and cannot click on the other button to hide the CodeBreaker-related controls
    because the thread is processing the `btnStart` click method. Until this method
    finishes, nothing else can be processed.
  prefs: []
  type: TYPE_NORMAL
- en: The code is quite simple. It generates the 65,536 Unicode characters four times,
    and calls the `checkCodeChar` function in order to determine whether it is part
    of the code or not. It tries to display the progress showing each tested character
    in the window, but as it is a single-threaded application, it fails in this objective.
    Again, as the loop is run in the main thread of the process created when the application
    is executed, we lose control over the UI. We cannot move the window, change its
    size, or push a button. The main thread is processing the intensive loop and consuming
    all the processing time of a single core. Hence, it cannot show information in
    the main window.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, when the guard comes, you are dead. Hence, let's create a multithreaded
    application and save human lives!
  prefs: []
  type: TYPE_NORMAL
- en: WPF example with an asynchronous BackgroundWorker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A loop like the one used in the previous example is an ideal task to run in
    an independent thread. That way, we could keep control over the UI and have the
    possibility of canceling the job, displaying its progress, hiding the CodeBreaker
    controls, and displaying our Fishes game. Hence, we can avoid being shot by the
    guard (death or jail).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how to use the `BackgroundWorker` component in
    a simple way to create a second concurrent thread in our application, which will
    allow the user to perform other actions while the CodeBreaking process is being
    performed.
  prefs: []
  type: TYPE_NORMAL
- en: We will first do this in an asynchronous way and then in a synchronous way in
    the next chapter. The differences will be shown; in the asynchronous method, we
    will be able to take advantage of concurrent processing with two threads, but
    we will lose visibility as to the status of the second thread. We will not know
    where it is in the CodeBreaking process and when it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s make some changes to the application. We will process the CodeBreaking
    loop using a `BackgroundWorker` component in order to run the code in an independent
    thread:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project, `CodeBreaker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `BackgroundWorker` object to the `MainWindow` (`bakCodebreaker`) class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, register the `DoWork` event handler in the constructor of the `MainWindow`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the `DoWork` event handler method and paste the same code entered
    previously in the `Click` event in the button, `btnStart` (this is the code that
    is going to be run when the `BackgroundWorker` object is started):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, comment out the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You must comment out these lines of code because, as the `BackgroundWorker`
    object creates a new thread in which the loop is going to run, it cannot make
    changes to the user interface. There are mechanisms to do that, and we will learn
    them later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `Click` event in the button `btnStart`, and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start** button. While the loop is running and the code is being
    broken by brute force in a new thread created by the `BackgroundWorker` component,
    try to click on the **Hide** button. It works, and while the CodeBreaker code
    is still working in the background, you will see the Fishes game being displayed
    in the window, as shown in the following screenshot:![How to do it](img/8321EN_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the window, change its size, maximize it, and do anything else you want
    to. While you do these operations, the code programmed in the `DoWork` event will
    keep on executing in another thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can click on the **Hide** button, and the window shows the three fish with
    the **Game Over** button, but the program continues processing the CodeBreaker
    in the other thread (the `DoWork` method of `BackgroundWorker`).
  prefs: []
  type: TYPE_NORMAL
- en: The code programmed in the `DoWork` event handler runs in an independent thread.
    Therefore, when the user clicks on the **Start** button, a new thread is created,
    and he or she does not lose control over the UI. While the CodeBreaker is running,
    the user can move the mouse cursor over other buttons, change the window size,
    and use other user interface components similar to the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: However, we cannot see the progress of the code being broken. We will fix this
    issue shortly.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work without blocking the UI?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After calling the `RunWorkerAsync()` method of `BackgroundWorker`, the advantage
    of threading begins by running the code programmed in the `DoWork` event handler
    in a new independent thread. This mechanism is known as **asynchronous execution**.
  prefs: []
  type: TYPE_NORMAL
- en: When an asynchronous method is called, it runs in an independent way and the
    program flow goes on with the instruction after the method call, even though the
    code has not finished its execution. The code in the asynchronous method runs
    concurrently with the main program flow.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to run our last example step-by-step in order to understand the
    asynchronous execution and how the main thread's code goes on running.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps that need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project `CodeBreaker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a breakpoint in the line `bakCodebreaker.RunWorkerAsync();` in the `Click`
    event code of `btnStart`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a breakpoint in the line `showFishes();` in the `Click` event code of
    `btnHide`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F5* or navigate to **Debug** | **Start Debugging** in the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start** button. The line with the breakpoint defined is shown
    highlighted as the next statement that will be executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F10* or navigate to **Debug** | **Step Over** in the main menu a few
    times. As you can see, the next statement that will be executed in the main thread
    is not in the **DoWork** event handler of `BackgroundWorker`. It remains in the
    `Click` event code of `btnStart`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on the **Hide** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F10* or navigate to **Debug** | **Step Over** in the main menu a few
    times. As you can see, the thread created by `BackgroundWorker` keeps running
    while the next statement that will be executed in the main thread is not in the
    `DoWork` event handler of `BackgroundWorker`. It remains in the `Click` event
    code of `btnHide`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running the application step by step, we could not enter the code in the `DoWork`
    event handler of `BackgroundWorker`. However, the code was running because the
    CodeBreaker thread did its job. It happened because the `BackgroundWorker` object
    starts an asynchronous execution of the code in another thread. Therefore, the
    main thread continues with its next statements as if the `RunWorkerAsync()`method
    had completed successfully. Hence, that method does not execute code in a linear,
    synchronous way.
  prefs: []
  type: TYPE_NORMAL
- en: The execution flow in the main thread is synchronous. The main thread and the
    one created by `BackgroundWorker` run concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nevertheless, not everything that shines is gold. Asynchronous code execution
    brings many new headaches to programmers because it ends with many implicit warranties
    related to synchronous and linear code execution. We will be talking about them
    and will provide simple solutions for the most common problems.
  prefs: []
  type: TYPE_NORMAL
- en: When we worked with a single thread, we used to be the only owners of all the
    available elements in the programming context, the instances, the variables, the
    collections, the arrays, the controls that compose the graphical user interface,
    the components, and so on. However, when we work with multiple threads and asynchronous
    execution, we are sharing this world, in many ways, with strangers. Hence, there
    may be some code that runs concurrently, affecting the values for some variables,
    or accomplishing changes in the instances of the objects that we were going to
    work on.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, a paradigm shift in the way we approach our code is needed.
    We must stop thinking that we are alone with our code. The same thing happened
    when home computers were not connected to a network, some decades ago. They did
    not use a hard drive, and the user was the complete and unique owner of everything
    that was executed. Things such as memory swapping did not take place then. On
    the other side, nowadays, it would be difficult to find a modern computer without
    some kind of Internet connection. The antivirus, antispyware, anti-malware, and
    many other anti-threats that could interrupt the digital ecosystem harmony appeared.
    Therefore, every action in an application on a website is accompanied by those
    "anti-" whatever threat.
  prefs: []
  type: TYPE_NORMAL
- en: The same happens with multithreading and asynchronous execution. New threats
    appear and they can make the most perfectly designed code for a single thread
    produce completely unexpected and incomprehensible results when executed in a
    multithreading environment.
  prefs: []
  type: TYPE_NORMAL
- en: Many techniques must be applied in order to avoid the different problems related
    to concurrent programming. We are going to analyze them with concrete examples
    through this book, case by case.
  prefs: []
  type: TYPE_NORMAL
- en: WPF example with a synchronous BackgroundWorker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are used to synchronous execution when we work with a single thread. This
    mechanism executes the next instruction once the current instruction processing
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: When a synchronous method is called, it runs on the same thread and the program
    flow goes into the method's code. Once it returns from the method with or without
    a result, it goes on with the instruction next to the method call. There is no
    code in the method left for later execution, because it finishes when it returns
    the control to the caller. The main program has to wait for the method to complete
    its execution in order to go on with the next set of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: This is what happens when you debug a single-threaded application, step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: In a single-threaded application, the synchronous execution takes place as we
    observed in classic linear programming. When a line of code executes, nothing
    else runs.
  prefs: []
  type: TYPE_NORMAL
- en: However, in a multithreaded application, such as the ones using one or more
    `BackgroundWorker` controls, asynchronous execution comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must master this important change in the way methods are called and new independent
    threads are created on the fly, in order to get used to parallel and concurrent
    programming in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Showing progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users may get impatient when processes are delayed for more than a few seconds.
    In such cases, they need to know how long it will take them to finish. A good
    evidence of this is the replacement of messages such as *Hold on…* by animated
    dialog boxes with progress bars, entertaining the users while they wait for the
    process and showing them an approximate time required to finish the task.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting progress is one of the main problems when we work with only one thread
    and make intensive use of the processing power. Now, we will make changes to the
    application to show the code as it is being decoded and report the decoding progress
    for each character. This way, you will be able to decide whether to hide the CodeBreaker
    when the guard is coming or wait for the process to finish.
  prefs: []
  type: TYPE_NORMAL
- en: As we work in the same thread that updates the user interface, if we send orders
    to make changes in a control to show any kind of progress, it will probably show
    the update whenever the main thread retrieves control (usually, when the process
    has already finished). Hence, as it is not useful to watch when the process has
    finished, it is necessary to update the progress report regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a rule, we cannot make calls to a control since the thread used is different
    from the one that created it. If that happened, an `InvalidOperationException`
    would be raised. In order to make these calls safely, we must use delegates and
    asynchronous calls, known as **callbacks**.
  prefs: []
  type: TYPE_NORMAL
- en: The `BackgroundWorker` component offers a straightforward way to report progress
    and simplifies updating any control in the user interface that shows this progress,
    without any need to use delegates or asynchronous calls (callbacks). The last
    two are indeed much more complex ways to achieve the same results.
  prefs: []
  type: TYPE_NORMAL
- en: In order to show the progress of an operation using the `BackgroundWorker` component,
    we must assign the `true` value to its `WorkerReportsProgress` property. Its type
    is `bool`, and it tells whether the code executed in the new thread will report
    some kind of progress or not. If the value is `true`, the `BackgroundWorker` component
    will trigger the `ProgressChanged` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: This event facilitates updating the user interface. Therefore, it allows changes
    to control values, without having to consider the problems generated when we want
    to do it from a thread different from the one that created the control (the application's
    main thread).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to make some changes to our second example to take advantage of
    the features offered by the `BackgroundWorker` component to report progress in
    the user interface without delegates or callbacks. This way, we will be safe from
    the guards.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps that need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project `CodeBreaker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add four `ProgressBar` controls to `frmMain` (`pgbProgressChar1`, `pgbProgressChar2`,
    `pgbProgressChar3`, and `pgbProgressChar4`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Register the `ProgressChanged` event handler in the `MainWindow` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the `WorkerReportsProgress` property of `bakCodebreaker` to true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to the `setCodeBreakerVisibility` procedure.
    This will change the visibility of the new controls related to the progress of
    the CodeBreaking procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines of code in the form class declaration to declare a
    new private variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the form constructor (after `InitializeComponent()`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new class file to the project and call it `CodeBreakerProgress`. The new
    `CodeBreakerProgress` class will have properties that will help provide many values
    related to the progress to update the user interface. Add the following code to
    the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `DoWork` event in `bakCodebreaker` of `BackgroundWorker`, and enter
    the following code at the beginning, before the `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the same event, add the following code before the `if (checkCodeChar(lcChar,
    liCharNumber))` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the same event, add the following code before the `break;` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `ProgressChanged` event in the `bakCodebreaker` of `BackgroundWorker`
    and enter the following code (this is the code that will be run when the `ReportProgress`
    method is called):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start** button and you will see the progress bars filling up,
    showing how the process advances from 0 to 65,535 Unicode characters and the characters
    being tested. This is shown in the following screenshot. Now you have more information
    to decide whether to hide the application or not.![How to do it](img/8321EN_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the code is being broken, the UI can be used because the CodeBreaking
    is being done in a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: If the CodeBreaking runs too fast on your system, to see what is going on, add
    the following line before the `if (checkCodeChar(lcChar, liCharNumber))` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will add a 1-millisecond wait between each character being checked.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code programmed in the loop reports the progress only if the percentage
    completed increased by a unit or more. Otherwise, we would be triggering 65,536
    events in order to report only 100 different percentages. That would not make
    sense and add extra burdensome processing. That would be very inefficient and
    would make the loop take longer to complete its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a BackgroundWorker thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Executing a time-consuming process in an independent thread allows us to work
    concurrently while showing its progress. One of the advantages of doing this is
    the possibility of allowing the user to go on using the controls in the graphical
    user interface without the restrictions of single-threaded applications. For example,
    perhaps he or she wants to cancel the CodeBreaking process instead of letting
    it finish.
  prefs: []
  type: TYPE_NORMAL
- en: The `BackgroundWorker` component simplifies the task of canceling the execution
    of the code running in the thread it creates without a lot of programming effort.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we must assign the `true` value to the `WorkerSupportsCancellation`
    property of `BackgroundWorker`. It is a `bool` value and tells whether the code
    executed in the new thread will support cancellation through a call to the `CancelAsync()`
    method of `BackgroundWorker`. This method simply assigns the `true` value to the
    `BackgroundWorker` property `CancellationPending`. Hence, the code being executed
    in the `DoWork` event handler must regularly check this property's value to determine
    whether it has to go on working or not.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the CodeBreaking does not stop the CodeBreaking process. So, we can still
    get caught if someone hacks into our computer and sees the process. Therefore,
    it is very important to provide the application with a fast cancellation procedure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to make some changes to our example to allow the user to cancel
    the loop at any time without delegates or callbacks, using the features provided
    by the `BackgroundWorker` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project `CodeBreaker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `WorkerSupportsCancellation` property of `bakCodebreaker` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button control `btnStop`. Set its `Text` property to `"Stop"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line of code to the procedure, `setCodeBreakerVisibility`.
    It will change the visibility of the new button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `DoWork` event in `bakCodebreaker` and enter the following code before
    the line `lcChar = (char)(i)` in the beginning of the `for` loop (the code now
    adds support for a premature cancellation):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Click` event in the button `btnStart` and add the following lines
    of code at the beginning (the code now disables the **Start** button and enables
    the **Stop** button):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the `IsEnabled` property of the `btnStop` button to `false` in the constructor.
    Hence, the button will be disabled when the application starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Click` event in the `btnStop` button and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start** button. Now click on the **Stop** button. The CodeBreaker
    will cancel its execution. The thread created by the `BackgroundWorker` component
    will stop running. The result is shown in the following screenshot:![How to do
    it](img/8321EN_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on the **Start** button and let the CodeBreaking complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, you could avoid the guards, and now you are able to stop the CodeBreaking
    in case spies hack your system!
  prefs: []
  type: TYPE_NORMAL
- en: We can now develop an application that is able to execute a time-consuming task
    in the background, while keeping the graphical user interface alive. This offers
    the user a more real-life experience and we can offer the user the possibility
    of starting and stopping the process whenever they want to. We have done all of
    this using the `BackgroundWorker` component features.
  prefs: []
  type: TYPE_NORMAL
- en: However, the application has a defect. When we click on the **Start** button
    and let the process finish, the **Stop** button will not be shown disabled. Additionally,
    we cannot see the final code on the screen. We must create a remedy for this.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple BackgroundWorker components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can work with many `BackgroundWorker` components in order to run many concurrent
    threads. Usually, we will use the `Thread` class to run many threads at once,
    but the `BackgroundWorker` class provides us an easy way to do this as well. As
    we learned in the previous chapter, the performance results will depend upon the
    number of cores or processors available in the computer in which we run the application
    and how busy each core is with other threads of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Using the real algorithms, the process of breaking the four Unicode characters
    code is very intensive and requires more time than expected. Breaking the code
    must take the minimum time possible. So far, we have been using multithreading
    to have a more responsive application, but now, we must make execution of the
    CodeBreaking process much faster.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to take the code presented in our previous examples and divide
    it into four `BackgroundWorker` components. With this example, we will learn how
    multiple `BackgroundWorker` components coexist and create new independent threads,
    and hence achieve an incredible performance enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps that need to be followed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project `CodeBreaker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three new `BackgroundWorker` components (`bakCodeBreaker2`, `bakCodeBreaker3`,
    and `bakCodeBreaker4`) to create four independent threads. This is done in the
    declaration section of the `MainWindow` class. Next, set the `True` value for
    their properties `WorkerReportsProgress` and `WorkerSupportsCancellation` in the
    class constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class to the project and call it `CodeBreakerParameters`. The `CodeBreakerParameters`
    class will have properties that will help provide many values that will be available
    as parameters for the four `BackgroundWorker` components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, add another new class file. This one will be called `CodeBreakerResult`.
    The new `CodeBreakerResult` class will have properties that help in providing
    many values as parameters for the four `BackgroundWorker` components'' `RunWorkerCompleted`
    events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Click` event in the `btnStart` button and add the following lines
    of code before the line `bakCodebreaker.RunWorkerAsync();` (now the code will
    set the parameters for the four `BackgroundWorker` components and will run them
    asynchronously):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the same aforementioned event, remove the line `bakCodebreaker.RunWorkerAsync();`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Click` event in the `btnStop` button and add the following lines
    of code (now the code will cancel the four `BackgroundWorker` components, `bakCodebreaker`
    and the three `BackgroundWorker` components added in the following lines):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create generic procedures to handle the following programmed events
    of `BackgroundWorker` components, receiving the same parameters as the corresponding
    event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DoWorkProcedure` for the `DoWork` event'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RunWorkerCompletedProcedure` for the `RunWorkerCompleted` event'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgressChangedProcedure` for the `ProgressChanged` event'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Paste the `DoWork` event handler code of `bakCodebreaker` in a new private
    procedure and then make the following changes as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following variable definitions at the beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the line `int liTotal = (int)e.Argument`; with the following (now the
    event handler procedure needs more parameters, and so we create a class to manage
    them):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the line that defines the first loop with the following (now the loop
    takes into account the parameters received through a `CodeBreakerParameters` instance):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the pending cancellation check with the following line (we use the
    `sender` parameter typecast because the same procedure is employed by the four
    `BackgroundWorker` components):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the call to the `ReportProgress` method by the following line (again,
    we use the `sender` parameter typecasted for generalization):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the call to the `ReportProgress` method when the `checkCodeChar` function
    returns `true` with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the line `e.Result = lsBrokenCode;` with the following lines (now we
    must return more than one result; therefore, we use an instance of the `CodeBreakerResult`
    class created earlier):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code to create the new `RunWorkerCompleted` procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code to create the new `ProgressChangedProcedure` procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you have to program the code for the three additional event handlers of
    the four `BackgroundWorker` components. As we have used procedures, we will use
    the same code for the four `BackgroundWorker` components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in the four `BackgroundWorker` components'' `DoWork`
    event handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the four `BackgroundWorker` components'' `ProgressChanged`
    event handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the four `BackgroundWorker` components'' `RunWorkerCompleted`
    event handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start** button and let the process finish. You will see that
    all four characters are being decoded at the same time concurrently. If you have
    a machine with four cores in it, you will see all four cores being utilized simultaneously
    and much improved performance:![How does it work?](img/8321EN_02_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And here is how it looks once it is completed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How does it work?](img/8321EN_02_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, your CodeBreaking procedure is very fast! Each character of the code is
    being decoded in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, it is easy to split a process into many threads using the features
    provided by the `BackgroundWorker` component. The results of the execution of
    the previous example will depend on the number of cores or processors available
    in the computer. The ideal situation is to start as many `BackgroundWorker` components
    as the number of cores available. This way, we can achieve the best performance
    for each thread and take the CPU usage to around 95 percent. Of course this will
    vary and we will not always know the number of cores on a target machine. As we
    will see in future chapters, there are ways to use the **Task Parallel Library**
    (**TPL**) to achieve maximum concurrency on machines when we do not know the number
    of cores on a machine ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we do not need to run many instances of an application to take advantage
    of parallel processing capabilities. Using the `BackgroundWorker` component and
    everything we have learned so far, we can quite easily split a process into many
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: However, we had to make some important changes to the code because we needed
    to generalize the behavior of four `BackgroundWorker` components without writing
    the same piece of code four times. This is called **refactoring** and should also
    be done when developing software to minimize redundant code.
  prefs: []
  type: TYPE_NORMAL
- en: We created new classes to pass parameters and obtain results because we needed
    many parameters and many results. As you can see, with typecasting, C# offers
    us excellent alternatives to generalize the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key was the `sender` parameter. Remember that this parameter, available
    in the event handlers, offers a reference to the component (the `BackgroundWorker`)
    that triggers the event. Typecasting the `sender` parameter to a `BackgroundWorker`
    component, we could generalize the code in the different event handlers and create
    procedures for each one.
  prefs: []
  type: TYPE_NORMAL
- en: There were many changes. But once the code patterns are practiced and learned,
    it will be easier to work with concurrent programming structures. This will be
    especially important when working with the TPL.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, the application uses four `BackgroundWorker` components, and hence
    four independent threads not including the main thread. It does not give the user
    a message about the end of the CodeBreaking global process.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try adding another `BackgroundWorker` to show a message box telling the user
    the process has finished, or disabling the **Stop** button and enabling the **Start**
    button, when the four `BackgroundWorker` components complete their work. You can
    use the `IsBusy()` function.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the **Process Explorer** to view the running threads for the example
    and monitor its activities. You can download and install **Process Explorer**
    from [http://download.cnet.com/Process-Explorer/3000-2094_4-10223605.html](http://download.cnet.com/Process-Explorer/3000-2094_4-10223605.html),
    if you do not already have it loaded. This is a very handy utility and will allow
    you to really dissect what is happening with the different threads in your application.
    The following is a sample of Process Explorer running alongside our `CodeBreaker`
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Apply all the things we have learned in the previous chapter. Also, use the
    Windows Task Manager. You will have a better understanding of the differences
    between multiple processes and multithreaded applications when monitoring the
    application running concurrently with the four `BackgroundWorker` threads, in
    a computer with a quad-core microprocessor and using the Process Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the **Start** button is pressed, these are the threads and information
    you should see for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring other examples](img/8321EN_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the **Start** button is pressed, these are the threads and information
    you should see for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring other examples](img/8321EN_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Monitor the application using one, two, three, and four threads running concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Enhance the application using the patterns we have learned in the previous example
    using only one `BackgroundWorker` component. Change the code to add the possibility
    to start and stop the threads running in each `BackgroundWorker` component.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor the application starting and stopping one, two, three, and four threads
    running concurrently, and pay attention to what happens with the threads' activities
    and CPU usage in the Process Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application in different computers with different microprocessors and
    use the Process Explorer to monitor their behavior and measure their performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned a lot in this chapter about working with threads using the `BackgroundWorker`
    component. Specifically, we covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications that are able to create background threads using the
    `BackgroundWorker` component and showing the progress of execution by taking advantage
    of the methods provided by this component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming the threads' code to be executed by `BackgroundWorker`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the differences between synchronous and asynchronous execution
    and how they are related to threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting the progress of multiple threads in the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting and canceling threads created using `BackgroundWorker` instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching multiple threads using many `BackgroundWorker` components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the various event handlers of the `BackgroundWorker` component in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've learned a simple way to create many threads in a C# application
    using the `BackgroundWorker` component, we're ready to do these things using a
    much more flexible but more complex technique—the `Thread` class—which is the
    topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
