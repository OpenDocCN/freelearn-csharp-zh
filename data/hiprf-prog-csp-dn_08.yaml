- en: '*Chapter 6*: The .NET Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*: .NET 集合'
- en: Collections are an integral part of .NET. There are different ways to use these
    collections. Microsoft .NET makes heavy use of arrays and collections when dealing
    with things such as datasets, arrays, lists, dictionaries, stacks, and queues.
    You will be hard-pressed to write a C# program without having to use the Collections
    Framework. The different ways of using the collections and arrays differ in terms
    of their performance degradation and performance improvement. Therefore, understanding
    when to use arrays and when to use collections will form an important aspect of
    your C# and .NET programming skills.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是 .NET 的一个重要组成部分。使用这些集合的方式有很多种。Microsoft .NET 在处理数据集、数组、列表、字典、栈和队列等事物时，大量使用了数组和集合。您很难编写一个不使用集合框架的
    C# 程序。使用集合和数组的不同方式在性能下降和性能提升方面有所不同。因此，了解何时使用数组以及何时使用集合将成为您 C# 和 .NET 编程技能的一个重要方面。
- en: In this chapter, you will learn how to improve the performance of your collection
    operations. By using `BenchmarkDotNet` with different versions of the code, you
    will be able to see the differences in performance and be in a position to choose
    the best method that suits your needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何提高您的集合操作性能。通过使用 `BenchmarkDotNet` 与代码的不同版本，您将能够看到性能差异，并处于选择最适合您需求的最佳方法的位置。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: '`System.Collections`, `System.Collections.Generic`, `System.Collections.Concurrent`,
    and `System.Collections.Specialized` namespaces.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Collections`、`System.Collections.Generic`、`System.Collections.Concurrent`
    和 `System.Collections.Specialized` 命名空间。'
- en: '`IEnumerable` and `IQueryable`. This section will show you how to develop our
    sample database with sample data that will be used later in this chapter.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable` 和 `IQueryable`。本节将向您展示如何使用样本数据开发我们的示例数据库，这些数据将在本章的后续部分使用。'
- en: '**Deciding between interfaces and concrete classes**: In this section, you
    will benchmark the performance between using classes and interfaces. Then, you
    will be able to decide on the method that best suits your needs.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**决定使用接口还是具体类**: 在本节中，您将基准测试使用类和接口的性能，然后您将能够决定最适合您需求的方法。'
- en: '**Deciding between using arrays or collections**: There are strengths and weaknesses
    between using arrays and collections. In this section, you will benchmark the
    performance of arrays and collections and decide which to use based on your performance
    requirements.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**决定使用数组还是集合**: 使用数组和集合各有优缺点。在本节中，您将基准测试数组和集合的性能，并根据性能需求决定使用哪种。'
- en: '**Accessing objects using indexers**: In this section, we will discuss accessing
    objects in the same way we would access items in an array by using indexers.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用索引器访问对象**: 在本节中，我们将讨论通过使用索引器以与访问数组项相同的方式访问对象。'
- en: '**Comparing IEnumerable and IEnumerator**: In this section, we will benchmark
    iterations using both IEnumerable and IEnumerator. You will see that there is
    a definite performance difference between these ways of enumerating.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较 IEnumerable 和 IEnumerator**: 在本节中，我们将使用 IEnumerable 和 IEnumerator 进行迭代基准测试。您将看到这两种枚举方式之间确实存在性能差异。'
- en: '**Database query performance**: In this section, we will query a database using
    five different methods, benchmarking their performance to see which method produces
    the fastest performance.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库查询性能**: 在本节中，我们将使用五种不同的方法查询数据库，基准测试它们的性能，以查看哪种方法产生最快的性能。'
- en: '`yield` keyword and how it relates to the performance of your applications,
    especially when it comes to iterating through collections and arrays.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield` 关键字及其与您应用程序性能的关系，尤其是在迭代集合和数组时。'
- en: '**Learning the difference between concurrency and parallelism**: In this section,
    you will understand the difference between concurrency and parallelism, and learn
    when to use one over the other.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习并发与并行之间的区别**: 在本节中，您将了解并发与并行之间的区别，并学习何时使用一种而非另一种。'
- en: '**Learning the difference between Equals() and ==**: In this section, you will
    understand the differences between the different equality operators, and learn
    when to use one over the other.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习 Equals() 和 == 之间的区别**: 在本节中，您将了解不同相等运算符之间的区别，并学习何时使用一种而非另一种。'
- en: '**Studying LINQ performance**: LINQ is a C# query language that is heavily
    utilized when it comes to processing collections, but it can be slow or fast,
    depending on the way you code your queries. In this section, you will learn how
    to benchmark different ways of performing the same types of queries. In doing
    so, you will see the difference in performance between the different ways of writing
    the same queries.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**研究LINQ性能**：LINQ是一种C#查询语言，在处理集合时被广泛使用，但它的速度可能快或慢，这取决于你编写查询的方式。在本节中，你将学习如何基准测试执行相同类型查询的不同方式。通过这样做，你将看到不同方式编写相同查询的性能差异。'
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Describe the different collections available and their uses
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述可用的不同集合及其用途
- en: Choose between using interfaces and collections
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用接口和集合之间进行选择
- en: Understand the trade-offs between arrays and collections
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数组和集合之间的权衡
- en: Write indexers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写索引器
- en: Choose the best form of iteration for your particular needs
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择最适合你特定需求的迭代形式
- en: Use the `yield` keyword
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`yield`关键字
- en: Know which equality operator to use for different types of equality checking
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解用于不同类型相等性检查的相等运算符
- en: Improve LINQ query performance
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高LINQ查询性能
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you will need access to the following tools:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要访问以下工具：
- en: Visual Studio 2022
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022
- en: SQL Server (any version) Express or higher
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（任何版本）Express或更高版本
- en: SQL Server Management Studio
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server Management Studio
- en: 'This book''s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06)
- en: Understanding the different collection offerings
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同的集合提供
- en: A collection is a group of records that can be treated as one logical unit.
    Examples of logical record groups include people, countries, products, ingredients,
    books, authors, and more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一组可以作为一个逻辑单元处理的记录。逻辑记录组的例子包括人、国家、产品、成分、书籍、作者等等。
- en: 'There are four main types of collections, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有四种类型的集合，如下所示：
- en: '**Index-based** collections, such as an array or list. Index-based collections
    contain an internal index. The index can be either numeric or string-based. An
    index-based collection is more commonly accessed using a numerical index. Numerical
    indexes are zero-based. This means that a collection''s index will start at zero
    for the first record and increase in value by the order of one for each subsequent
    record. Collections that can be accessed using numerical indexes include arrays
    and lists.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于索引**的集合，例如数组或列表。基于索引的集合包含一个内部索引。索引可以是数字或基于字符串的。基于索引的集合通常使用数字索引来访问。数字索引是从零开始的。这意味着集合的索引将从零开始，对于每个后续记录，其值将按顺序增加一。可以使用数字索引访问的集合包括数组和列表。'
- en: '`Hashtable` and `SortedList` use a key to look up the value stored in a collection.
    So, for example, if you have a collection of products, you can access the product
    you need by using the product code that was assigned as the key when the product
    was added to the key/value pair collection.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hashtable`和`SortedList`使用键来查找存储在集合中的值。例如，如果你有一个产品集合，你可以通过使用在将产品添加到键/值对集合时分配的产品代码作为键来访问所需的产品。'
- en: '**Prioritized** collections, such as a stack or queue. Prioritized collections
    allow you to store and extract records in a particular sequence. A queue uses
    the **First In First First Out** (**FIFO**) sequence, while a stack uses the **Last
    In First Out** (**LIFO**) sequence.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**集合，例如栈或队列。优先级集合允许你以特定顺序存储和提取记录。队列使用**先进先出**（**FIFO**）顺序，而栈使用**后进先出**（**LIFO**）顺序。'
- en: '`CollectionsUtil` class, which creates collections that ignore the case in
    strings, and the `ListDictionary` class, which is recommended for collections
    that contain less than 10 items. It implements `IDictionary` using a singly linked
    list.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollectionsUtil`类，它创建忽略字符串大小写的集合，以及`ListDictionary`类，它适用于包含少于10个项目的集合。它使用单链表实现`IDictionary`。'
- en: The .NET Collections Framework consists of the legacy `System.Collections` namespaces,
    as well as the newer `System.Collections.Generic`, `System.Collections.Concurrent`,
    and `System.Collections.Specialized` namespaces. Before we delve into the performance
    of collections, it is a good idea to reacquaint ourselves with the different collections
    that are available in each of the aforementioned namespaces.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 集合框架由传统的 `System.Collections` 命名空间以及较新的 `System.Collections.Generic`、`System.Collections.Concurrent`
    和 `System.Collections.Specialized` 命名空间组成。在我们深入研究集合的性能之前，重新熟悉上述每个命名空间中可用的不同集合是个好主意。
- en: The System.Collections namespace
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`System.Collections` 命名空间'
- en: The `System.Collections` namespace contains various classes, structures, and
    interfaces. In this section, we will briefly cover what is available. The collections
    in this namespace are not thread-safe. If you require thread-safe collections,
    it would be better to use the collections in the `System.Collections.Concurrent`
    namespace instead, as advised by Microsoft!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections` 命名空间包含各种类、结构和接口。在本节中，我们将简要介绍可用的内容。此命名空间中的集合不是线程安全的。如果您需要线程安全的集合，最好使用
    `System.Collections.Concurrent` 命名空间中的集合，正如微软所建议的！'
- en: The `ICollection` interface defines the size, enumerators, and synchronization
    methods for all non-generic collections. To compare two objects, you can implement
    the `IComparer` interface. You can represent non-generic key/value pair collections
    using `Idictionary`. To enumerate a non-generic dictionary, you can use the `IDictionaryEnumerator`
    interface. Simple iteration over non-generic collections is provided by the `IEnumerator`
    interface, while equality between objects is implemented via the `IEqualityComparer`
    interface. The `IList` interface is used to implement non-generic collections
    of objects that can be individually accessed using the index. Structural comparison
    of objects and structural equality comparison of objects is implemented using
    the `IStructuralComparable` and `IStructuralEquatable` interfaces, respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICollection` 接口定义了所有非泛型集合的大小、枚举器和同步方法。要比较两个对象，您可以实现 `IComparer` 接口。您可以使用 `Idictionary`
    来表示非泛型键/值对集合。要枚举非泛型字典，您可以使用 `IDictionaryEnumerator` 接口。非泛型集合的简单迭代由 `IEnumerator`
    接口提供，而对象之间的相等性是通过 `IEqualityComparer` 接口实现的。`IList` 接口用于实现可以通过索引单独访问的对象的非泛型集合。对象的结构比较和对象的结构相等比较分别使用
    `IStructuralComparable` 和 `IStructuralEquatable` 接口实现。'
- en: The `ArrayList` class implements the `IList` interface using a dynamic array
    that can grow and shrink in size as required.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList` 类使用可以按需增长和缩小的动态数组实现 `IList` 接口。'
- en: On (`0`) and off (`1`), which are represented by the Boolean values `false`
    and `true`, respectively, are managed by the `BitArray` class.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在（`0`）和关闭（`1`），分别由布尔值 `false` 和 `true` 表示，由 `BitArray` 类管理。
- en: To compare two objects while ignoring string casing, you can use the `CaseInsensitiveComparer`
    class. Use `CaseInsensitiveHashCodeProvider` to generate hash codes using algorithms
    that ignore string casing.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在忽略字符串大小写的情况下比较两个对象，您可以使用 `CaseInsensitiveComparer` 类。使用 `CaseInsensitiveHashCodeProvider`
    生成忽略字符串大小写的算法的哈希码。
- en: When you're building a strongly typed collection, inherit from the `CollectionBase`
    class.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建强类型集合时，从 `CollectionBase` 类继承。
- en: The `Comparer` class is used to compare two objects for equivalence with case-sensitive
    string comparison.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comparer` 类用于对两个对象进行大小写敏感的字符串比较以确定它们是否相等。'
- en: Use `DictionaryBase` as the abstract class when developing strongly typed collections
    of key/value pairs.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发强类型键/值对集合时，使用 `DictionaryBase` 作为抽象类。
- en: A collection of key/value pairs organized by key-based hash codes is represented
    by the `Hashtable` class.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过基于键的哈希码组织键/值对的集合由 `Hashtable` 类表示。
- en: The `Queue` class provides a collection with FIFO access.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue` 类提供了一个具有先进先出（FIFO）访问的集合。'
- en: The `ReadOnlyCollectionBase` abstract class is used as the base class for strongly
    typed non-generic, read-only collections.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadOnlyCollectionBase` 抽象类被用作强类型非泛型、只读集合的基类。'
- en: Use the `SortedList` class to hold a collection of key/value pairs that are
    sorted by the keys and are accessible by key or index.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SortedList` 类来保存按键排序且可以通过键或索引访问的键/值对集合。
- en: Use the `Stack` class if you need LIFO access for your collection.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要为您的集合提供后进先出（LIFO）访问，请使用 `Stack` 类。
- en: To compare two collection objects structurally, you can use the `StructuralComparisons`
    class.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要结构性地比较两个集合对象，您可以使用 `StructuralComparisons` 类。
- en: The `DictionaryEntry` structure defines a dictionary key/value pair that can
    be set or retrieved.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DictionaryEntry` 结构定义了一个可以设置或检索的字典键/值对。'
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`IHashCodeProvider` has now been marked obsolete and is no longer recommended
    by Microsoft for new development. Microsoft recommends that you use the `IEqualityComparer`
    and `IEqualityComparer<T>` interfaces instead.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IHashCodeProvider` 现已标记为过时，并且不再由 Microsoft 推荐用于新开发。Microsoft 建议您使用 `IEqualityComparer`
    和 `IEqualityComparer<T>` 接口。'
- en: We now know what is available in the `System.Collections` namespace. Now, let's
    look at what's available in the `System.Collections.Generic` namespace.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了 `System.Collections` 命名空间中有什么可用。现在，让我们看看 `System.Collections.Generic`
    命名空间中有什么可用。
- en: The System.Collections.Generic namespace
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`System.Collections.Generic` 命名空间'
- en: The classes and interfaces that are available in the `System.Collections.Generic`
    namespace provide collections that are strongly typed and that perform better
    than the classes within the `System.Collections` namespace. This namespace contains
    many classes, structs, and interfaces.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Generic` 命名空间中提供的类和接口提供了强类型集合，其性能优于 `System.Collections`
    命名空间中的类。此命名空间包含许多类、结构和接口。'
- en: The `CollectionExtensions` class provides extension methods for generic collections.
    To compare two objects, you can use the `Comparer<T>` class, which implements
    the `IComparer<T>` interface. The `IComparer<T>` interface defines the method
    types to implement to compare two objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionExtensions` 类为泛型集合提供了扩展方法。要比较两个对象，您可以使用实现 `IComparer<T>` 接口的 `Comparer<T>`
    类。`IComparer<T>` 接口定义了实现比较两个对象的方法类型。'
- en: The `IDictionary<TKey, TValue>` interface provides methods for implementing
    generic dictionaries. For a dictionary to be read-only, it must implement the
    `IReadOnlyDictionary<TKey, TValue>` interface. A collection of keys and values
    is represented by the `Dictionary<TKey, TValue>` class. `Dictionary<TKey, TValue>.KeyCollection`
    cannot be inherited and represents the collection of keys within a `Dictionary<TKey,
    TValue>` collection. Finally, `Dictionary<TKey, TValue>.ValueCollection` cannot
    be inherited and represents the collection of values within a `Dictionary<TKey,
    TValue>` collection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDictionary<TKey, TValue>` 接口提供了实现泛型字典的方法。要使字典为只读，它必须实现 `IReadOnlyDictionary<TKey,
    TValue>` 接口。键值对的集合由 `Dictionary<TKey, TValue>` 类表示。`Dictionary<TKey, TValue>.KeyCollection`
    不能被继承，并代表 `Dictionary<TKey, TValue>` 集合中的键集合。最后，`Dictionary<TKey, TValue>.ValueCollection`
    不能被继承，并代表 `Dictionary<TKey, TValue>` 集合中的值集合。'
- en: The `IEqualityComparer<T>` interface defines methods that you can use to compare
    objects for equality. A base class for implementations of the `IEqualityComparer<T>`
    interface is provided called `EqualityComparer<T>`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEqualityComparer<T>` 接口定义了您可以使用的方法来比较对象的相等性。为 `IEqualityComparer<T>` 接口的实现提供了一个基类，称为
    `EqualityComparer<T>`。'
- en: '`HashSet<T>` represents a set of values. When a key that''s been used to access
    a collection cannot be found within the collection that''s being searched, then
    a `KeyNotFoundException` is raised. A key/value pair instance is generated using
    the `KeyValuePair` class. For a doubly linked list, use the `LinkedList<T>` class.
    The non-inheritable `LinkedListNode<T>` class represents a node in a collection
    of the `LinkedList<T>` type.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet<T>` 表示一组值。当用于访问集合的键在正在搜索的集合中找不到时，将引发 `KeyNotFoundException`。使用 `KeyValuePair`
    类生成键/值对实例。对于双向链表，请使用 `LinkedList<T>` 类。不可继承的 `LinkedListNode<T>` 类代表 `LinkedList<T>`
    类型集合中的一个节点。'
- en: '`IList<T>` represents a collection of objects for implementing lists that can
    be accessed by index. Read-only lists implement the `IReadOnlyList<T>` interface.
    When you need a collection that is strongly typed that enables searching, sorting,
    and manipulating lists, then use the `List<T>` class. For FIFO collections, use
    the `Queue<T>` class.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList<T>` 表示一个对象集合，用于实现可以通过索引访问的列表。只读列表实现了 `IReadOnlyList<T>` 接口。当您需要一个强类型集合，它支持搜索、排序和操作列表时，请使用
    `List<T>` 类。对于先进先出（FIFO）集合，请使用 `Queue<T>` 类。'
- en: '`ReferenceEqualityComparere` is an `IEqualityComparer<T>` that uses reference
    equality by calling `ReferenceEquals(Object, Object)` instead of using value equality
    by calling `Equals(Object)` when comparing two object instances.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReferenceEqualityComparere` 是一个 `IEqualityComparer<T>`，它在比较两个对象实例时通过调用 `ReferenceEquals(Object,
    Object)` 而不是通过调用 `Equals(Object)` 来使用引用相等性。'
- en: A key/value pair collection that's sorted on the key is represented by the `SortedDictionary<TKey,
    TValue>` class. This type of collection is represented by `SortedDictionary<TKey,
    TValue>.KeyCollection`, which cannot be inherited. The values that have been collected
    are represented by `SortedDictionary<TKey, TValue>.ValueCollection`, which cannot
    be inherited.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 按键排序的键/值对集合由 `SortedDictionary<TKey, TValue>` 类表示。此类集合由 `SortedDictionary<TKey,
    TValue>.KeyCollection` 表示，不能被继承。收集到的值由 `SortedDictionary<TKey, TValue>.ValueCollection`
    表示，也不能被继承。
- en: The `SortedList<TKey, TValue>` class represents a collection of key/value pairs
    that are sorted by key based on the associated `IComparer<T>` implementation.
    A collection of objects that has been maintained in sorted order is represented
    by the `SortedSet<T>` class. The `Stack<T>` class provides LIFO manipulation for
    instances of the same type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedList<TKey, TValue>` 类表示一个按键排序的键/值对集合，基于关联的 `IComparer<T>` 实现进行排序。维护在排序顺序中的对象集合由
    `SortedSet<T>` 类表示。`Stack<T>` 类为同一类型的实例提供 LIFO 操作。'
- en: There are several structures available for the various generic collection classes
    that allow you to enumerate the elements in the collection. These structures are
    called enumerators.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种通用集合类，有几种结构可供使用，允许您遍历集合中的元素。这些结构被称为枚举器。
- en: Asynchronously enumerating over values of a specific type can be done by implementing
    the `IAsyncEnumerable<T>` interface. `IAsyncEnumerator<T>` provides the necessary
    support to iterate over a generic collection. `ICollection<T>` defines the methods
    needed to manipulate generic collections. Strongly typed collections that are
    read-only implement the `IReadOnlyCollection<T>` interface. Sets implement the
    `ISet<T>` interface, while read-only sets implement the `IReadOnlySet<T>` interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `IAsyncEnumerable<T>` 接口，可以异步遍历特定类型的值。`IAsyncEnumerator<T>` 提供了遍历泛型集合所需的必要支持。`ICollection<T>`
    定义了操作泛型集合所需的方法。只读的强类型集合实现了 `IReadOnlyCollection<T>` 接口。集合实现了 `ISet<T>` 接口，而只读集合实现了
    `IReadOnlySet<T>` 接口。
- en: Now that we've looked at what the `System.Collections.Generic` namespace has
    to offer, let's turn our attention to the `System.Collections.Concurrent` namespace.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 `System.Collections.Generic` 命名空间提供的内容，让我们将注意力转向 `System.Collections.Concurrent`
    命名空间。
- en: The System.Collections.Concurrent namespace
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`System.Collections.Concurrent` 命名空间'
- en: The collections in the `System.Collections.Concurrent` namespace are thread-safe.
    Whenever multiple threads are concurrently accessing a collection, use the collections
    in this namespace over the collections in the `System.Collections` and `System.Collections.Generic`
    namespaces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Concurrent` 命名空间中的集合是线程安全的。当多个线程并发访问集合时，应使用此命名空间中的集合，而不是
    `System.Collections` 和 `System.Collections.Generic` 命名空间中的集合。'
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Extension methods and explicit interface implementations of these collections
    are not guaranteed to be thread-safe. To ensure thread safety, synchronization
    may be required in these instances.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些集合的扩展方法和显式接口实现不一定保证是线程安全的。为了确保线程安全，在这些情况下可能需要同步。
- en: '`IProducerConsumerCollection<T>` defines methods that form the basis of thread-safe
    collection manipulation in producer/consumer usage (also known as publisher/subscriber
    usage). Higher-level abstractions such as the `BlockingCollection<T>` class can
    use this collection as their underlying storage mechanism.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`IProducerConsumerCollection<T>` 定义了在生产者/消费者使用（也称为发布者/订阅者使用）中形成线程安全集合操作基础的方法。高级抽象，如
    `BlockingCollection<T>` 类，可以使用此集合作为其底层存储机制。'
- en: The `BlockingCollection<T>` class provides blocking and bounding capabilities
    to thread-safe collections that implement the `IProducerConsumerCollection<T>`
    interface.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>` 类为实现了 `IProducerConsumerCollection<T>` 接口的线程安全集合提供了阻塞和边界能力。'
- en: Options to control partitioner buffering behavior are specified by the `EnumerablePartitionerOptions`
    enum.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `EnumerablePartitionerOptions` 枚举指定了控制分区器缓冲行为的选择项。
- en: Arrays, lists, and enumerable partitioning strategies are provided by the `Partitioner`
    class. The `Partitioner<Tsource>` class provides a particular manner of splitting
    a data source into multiple partitions, while `OrderablePartioner<Tsource>` splits
    an orderable data source into multiple partitions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Partitioner` 类提供了数组、列表和可枚举分区策略。`Partitioner<Tsource>` 类提供了一种将数据源分割成多个分区的方式，而
    `OrderablePartioner<Tsource>` 则将可排序的数据源分割成多个分区。'
- en: The `Concurrent<T>` class contains a thread-safe unordered list of objects.
    Thread-safe FIFO collections use the `ConcurrentQueue<T>` class, while thread-safe
    LIFO collections use the `ConcurrentStack<T>` class. To concurrently access key/value
    pairs in a thread-safe manner, use the `ConcurrentDictionary<Tkey, Tvalue>` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concurrent<T>`类包含一个线程安全的对象无序列表。线程安全的FIFO集合使用`ConcurrentQueue<T>`类，而线程安全的LIFO集合使用`ConcurrentStack<T>`类。要线程安全地访问键/值对，请使用`ConcurrentDictionary<Tkey,
    Tvalue>`类。'
- en: With that, we've covered the `System.Collections.Concurrent` namespace. Now,
    let's look at the `System.Collections.Specialized` namespace.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经涵盖了`System.Collections.Concurrent`命名空间。现在，让我们看看`System.Collections.Specialized`命名空间。
- en: The System.Collections.Specialized namespace
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`System.Collections.Specialized`命名空间'
- en: The `System.Collections.Specialized` namespace contains specialized and strongly
    typed collections. Let's see what it has to offer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Specialized`命名空间包含专用和强类型的集合。让我们看看它有什么可以提供的。'
- en: The `CollectionChangedEventManager` class provides a `WeakEventManager` implementation.
    By using the `WeakEventListener` pattern, you can attach listeners for the collection-changed
    event.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionChangedEventManager`类提供了一个`WeakEventManager`实现。通过使用`WeakEventListener`模式，您可以附加集合更改事件的监听器。'
- en: To build a collection of strings that ignores the string casing, you can use
    the `CollectionUtils` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个忽略字符串大小写的字符串集合，您可以使用`CollectionUtils`类。
- en: The `HybrdDictionary` class changes its behavior when the collection is small,
    and when the collection grows in size. It does this by implementing `IDictionary`
    using a `ListDictionary` when the collection is small; it uses a `Hashtable` when
    the collection grows in size and becomes large.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合较小时，`HybrdDictionary`类会改变其行为；当集合增长并变得较大时，它也会改变行为。它是通过在集合较小时使用`ListDictionary`实现`IDictionary`，在集合增长并变得较大时使用`Hashtable`来实现的。
- en: For fewer than 10 items, you can use `ListDictionary`, which implements `IDictionary`
    by using a singly linked list.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于少于10个项的情况，您可以使用`ListDictionary`，它通过使用单链表实现`IDictionary`。
- en: To hold a collection of the string keys of a collection, use `NameObjectCollectionBase.KeysCollection`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存集合的字符串键集合，请使用`NameObjectCollectionBase.KeysCollection`。
- en: When you need to provide data for the `CollectionChanged` event, use the `NotifyCollectionChangedEventArgs`
    class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要为`CollectionChanged`事件提供数据时，请使用`NotifyCollectionChangedEventArgs`类。
- en: When you have an ordered collection of key/value pairs that you need to be accessible
    via either the key or the index, use `OrderedDictionary`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个需要通过键或索引访问的有序键/值对集合时，请使用`OrderedDictionary`。
- en: You can use the `StringCollection` class to hold a collection of strings, and
    you can use the `StringEnumerator` class to perform a simple iteration of the
    `StringCollection` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`StringCollection`类来保存字符串集合，并且可以使用`StringEnumerator`类对`StringCollection`类进行简单迭代。
- en: To get a hash table of keys and strongly typed string values, use the `StringDictionary`
    class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取键和强类型字符串值的哈希表，请使用`StringDictionary`类。
- en: To store a Boolean value or small integer in 32 bits of memory, you can use
    the `BitVector32` structure. You can use `BitVector32.Section` of the vector to
    store an integer number.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在32位内存中存储布尔值或小整数，您可以使用`BitVector32`结构。您可以使用向量的`BitVector32.Section`存储整数。
- en: Indexed collections of key/value pairs are represented by the `IOrderedDictionary`
    interface. The `INotifyCollectionChanged` interface is used to notify listeners
    of dynamic changes to a collection, such as when items are added, modified, or
    removed. The `NotifyCollectionChangedAction` enum describes the action that resulted
    in the `CollectionChanged` event being fired.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值对的索引集合由`IOrderedDictionary`接口表示。`INotifyCollectionChanged`接口用于通知监听器集合的动态更改，例如当项目被添加、修改或删除时。`NotifyCollectionChangedAction`枚举描述了导致`CollectionChanged`事件被触发的行为。
- en: Now, let's look at custom collections and write one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看自定义集合并编写一个。
- en: Creating custom collections
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义集合
- en: 'To create custom collections, you must inherit from `CollectionBase`. The `CollectionBase`
    class has a read-only `ArrayList` property called `InnerList`, and it implements
    the `IList`, `ICollection`, and `IEnumerable` interfaces. Then, you can add your
    own `Add`, `Remove`, `Clear`, and `Count` methods. We''ll do this in our project.
    We will create a very simple custom collection that inherits from `CollectionBase`
    so that you can see how easy it is to create custom collections. Follow these
    steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义集合，你必须从 `CollectionBase` 继承。`CollectionBase` 类有一个只读的 `ArrayList` 属性，称为
    `InnerList`，并且实现了 `IList`、`ICollection` 和 `IEnumerable` 接口。然后，你可以添加自己的 `Add`、`Remove`、`Clear`
    和 `Count` 方法。我们将在我们的项目中这样做。我们将创建一个非常简单的自定义集合，它继承自 `CollectionBase`，这样你就可以看到创建自定义集合是多么容易。按照以下步骤操作：
- en: Add a new class under the `CustomCollections` folder called `CustomCollections`
    that inherits from `CollectionBase`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CustomCollections` 文件夹下添加一个名为 `CustomCollections` 的新类，使其继承自 `CollectionBase`。
- en: 'Add the `Add(object item)` method to the class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Add(object item)` 方法添加到类中：
- en: '[PRE0]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method adds an item to `InnerList`, which we have inherited from the `CollectionBase`
    class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将一个项目添加到 `InnerList` 中，这是从 `CollectionBase` 类继承而来的。
- en: 'Add the `Remove(object item)` method to the class:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Remove(object item)` 方法添加到类中：
- en: '[PRE1]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method removes an item from the inherited `InnerList`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从继承的 `InnerList` 中移除一个项目。
- en: 'Add the `Clear()` method:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Clear()` 方法：
- en: '[PRE2]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method clears all the items from `InnerList`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法清除 `InnerList` 中的所有项目。
- en: 'Add the `Count()` method:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Count()` 方法：
- en: '[PRE3]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method returns the count of the number of items in `InnerList`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回 `InnerList` 中项目数量的计数。
- en: As you can see, creating custom collections does not have to be hard. Our implementation
    is very simple and basic. However, such a class can be made to hold specific types
    instead of the generic object type. You could also make your class generic so
    that it accepts classes that implement a specific interface.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建自定义集合并不一定困难。我们的实现非常简单和基础。然而，这样的类可以被设计为只持有特定类型，而不是泛型对象类型。你也可以使你的类成为泛型，以便它接受实现特定接口的类。
- en: 'The following is a detailed article by Microsoft on implementing custom collections
    by implementing `ICollection`: [https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.](https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由微软撰写的关于通过实现 `ICollection` 来实现自定义集合的详细文章：[https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.](https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.)
- en: As you read through this chapter, you will see different aspects of collections.
    You will also measure their performance. This way, as you create custom collections,
    you can choose the most performant way of doing things for the tasks at hand.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你阅读本章内容，你将看到集合的不同方面。你还将测量它们的性能。这样，当你创建自定义集合时，你可以为当前任务选择最有效的操作方式。
- en: Now that we've briefly covered the different collection offerings in the .NET
    Collections Framework, let's look at what Big O notation is.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要介绍了 .NET 集合框架中不同集合的提供情况，让我们来看看什么是 Big O 表示法。
- en: Understanding Big O notation
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Big O 表示法
- en: Big O notation is used to determine algorithmic efficiency. It determines how
    time scales concerning input. Constant time equates to a Big O notation value
    of O(1). Data operations that scale linearly over time, depending on the size
    of the operation, have a Big O notation value of (*N*), where *N* equals the amount
    of data being processed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Big O 表示法用于确定算法效率。它决定了与输入相关的时间尺度。常数时间等于 Big O 表示法值 O(1)。随时间线性扩展的数据操作，根据操作的大小，具有
    Big O 表示法值 (*N*)，其中 *N* 等于正在处理的数据量。
- en: For example, if you were iterating over several elements in an array or collection,
    you would use O(*N*), which is a linear time, where *N* is the size of the array
    or collection. If an iteration contains pairs such as *x* and *y*, where you iterate
    over *x* in the iteration and then *y* in the iteration, then your Big O notation
    would be O(*N*2). Another scenario would be identifying the amount of time it
    takes to harvest a square plot of land. This could be written as O(*a*), where
    *a* is the area of land. Alternatively, you could write the Big O notation as
    O(*s*2), where *s* is the length of one size.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在遍历数组或集合中的几个元素，你会使用O(*N*)，这是一个线性时间，其中*N*是数组或集合的大小。如果一个迭代包含如*x*和*y*这样的成对元素，其中你在迭代中遍历*x*，然后是*y*，那么你的大O表示法将是O(*N*2)。另一个场景是确定收获一块正方形土地所需的时间。这可以写成O(*a*)，其中*a*是土地面积。或者，你也可以将大O表示法写成O(*s*2)，其中*s*是一个尺寸的长度。
- en: 'There are some rules to consider when using Big O notation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大O表示法时需要考虑一些规则：
- en: Different steps in your algorithm are added together. So, if step 1 takes O(*a*)
    time, and step 2 takes O(*b*) time, then your Big O notation for the algorithm
    will be O(*a+b*).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的算法中的不同步骤被相加。因此，如果步骤1需要O(*a*)时间，步骤2需要O(*b*)时间，那么你的算法的大O表示法将是O(*a+b*)。
- en: Drop constants. For example, if you have two operations that are both constants
    in your algorithm, you do not write O(*2N*). The notation remains O(*N*).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃常数。例如，如果你算法中有两个都是常数的操作，你不需要写O(*2N*)。表示法仍然是O(*N*)。
- en: If you have different inputs that are different variables, such as collection
    a and collection b, then your Big O notation would be O(*a*b*).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有不同的输入，这些输入是不同的变量，例如集合a和集合b，那么你的大O表示法将是O(*a*b*)。
- en: Drop non-dominant terms. So, O(*n*2) is equivalent to O(*n + n*2), which is
    equivalent to (*n*2*+n*2).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃非主导项。所以，O(*n*2)等同于O(*n + n*2*)，等同于(*n*2*+n*2)。
- en: Now that we understand what Big O notation is and the various collections available
    to us, let's look at choosing the right collections for our work items.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了大O表示法是什么以及我们可用的各种集合，让我们看看如何为我们的工作项选择正确的集合。
- en: Choosing the right collection
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的集合
- en: 'The key to performance when working with multiple items of data in memory is
    to choose the correct storage mechanism that offers the fastest processing time
    for your requirements. Here''s the list of the different types of collections
    and their strengths to help you choose the right collections for the right tasks:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中处理多个数据项时，性能的关键是选择正确的存储机制，以提供满足你要求的最快处理时间。以下是一系列不同类型的集合及其优势，以帮助你为正确的任务选择正确的集合：
- en: A `Dictionary` is an unordered collection with contiguous storage that is directly
    accessible via a key. A dictionary's lookup efficiency using a key is O(1) and
    its manipulation efficiency is also O(1). Dictionaries are best used for high-performance
    lookups.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary`是一个无序的集合，具有连续的存储，并且可以通过键直接访问。字典使用键的查找效率为O(1)，其操作效率也为O(1)。字典最适合用于高性能查找。'
- en: A `HashSet` is unordered, has contiguous storage, and is directly accessible
    via a key. It has a lookup efficiency using a key of O(1), and a manipulation
    efficiency of O(1). `HashSet` is a unique unordered collection, called `Dictionary`,
    except the key and the value are the same object.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashSet`是无序的，具有连续的存储，并且可以通过键直接访问。使用键的查找效率为O(1)，操作效率为O(1)。`HashSet`是一个独特的无序集合，称为`Dictionary`，除了键和值是同一个对象。'
- en: A `LinkedList` lets the user have complete control over how it is ordered, does
    not have contiguous storage, and is not directly accessible. It has a lookup efficiency
    value of O(*n*), and a manipulation efficiency of O(1). It's best to use lists
    when you need to insert or remove items and no direct access is required.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedList`允许用户完全控制其顺序，没有连续的存储，并且不能直接访问。它的查找效率值为O(*n*)，操作效率为O(1)。当你需要插入或删除项目且不需要直接访问时，最好使用列表。'
- en: A `List` lets the user have complete control over how it is ordered, has contiguous
    storage, and is directly accessible via an index. It has a lookup efficiency using
    an index of O(1), and a lookup efficiency using a value of O(*n*). Its manipulation
    efficiency is O(*n*). It is best to use this list when direct access is required,
    the list is small, and there is no sorting.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`允许用户完全控制其顺序，具有连续的存储，并且可以通过索引直接访问。使用索引的查找效率为O(1)，使用值的查找效率为O(*n*)。其操作效率为O(*n*)。当需要直接访问、列表较小且不需要排序时，最好使用此列表。'
- en: A `Queue` is ordered according to FIFO, has contiguous storage, and only has
    direct access from the front of the queue. It has a lookup efficiency at the front
    of the queue of O(1), and a manipulation index of O(1). It is essentially the
    same as `List<T>`, except it is only processed using FIFO.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue`根据FIFO排序，具有连续存储，并且只能从队列的前端直接访问。它在队列前端具有O(1)的查找效率，操作索引为O(1)。它基本上与`List<T>`相同，只是它只使用FIFO进行处理。'
- en: A `SortedDictionary` is ordered, does not have contiguous storage, and can be
    directly accessed using a key. It has a lookup efficiency using the key of O(*log
    n*) with a manipulation efficiency of O(*log n*). This collection makes a trade-off
    between speed and ordering and uses a binary search tree.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedDictionary`是有序的，没有连续存储，并且可以使用键直接访问。它使用键的查找效率为O(*log n*)，操作效率为O(*log
    n*)。这个集合在速度和排序之间做出了权衡，并使用二叉搜索树。'
- en: A `SortedList` is ordered, has contiguous storage, and is directly accessible
    via a key. It has a lookup efficiency using the key of O(*log n*) and a manipulation
    efficiency of (O(*n*). The tree is implemented as an array, making lookups faster
    on preloaded data, but slower on loads.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedList`是有序的，具有连续存储，并且可以通过键直接访问。它使用键的查找效率为O(*log n*)，操作效率为O(*n*)。树作为数组实现，这使得在预加载数据上的查找更快，但在加载时较慢。'
- en: A `SortedSet` is ordered, does not have contiguous storage, and is directly
    accessible via a key. It has a lookup efficiency using a key of O(*log n*), and
    a manipulation efficiency of O(*log n*). It's a unique sorted collection, similar
    to a `SortedDictionary`, except the key and value are the same object.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedSet`是有序的，没有连续存储，并且可以通过键直接访问。它使用键的查找效率为O(*log n*)，操作效率为O(*log n*)。它是一个独特的有序集合，类似于`SortedDictionary`，但键和值是相同的对象。'
- en: A `Stack` is ordered according to LIFO, has contiguous storage, and can only
    be directly accessed from the top of the stack. It has a lookup efficiency of
    the top item of O(1) and a manipulation efficiency of O(1)*. It is essentially
    the same as `List<T>`, except it is only processed using LIFO.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack`根据LIFO排序，具有连续存储，并且只能从堆栈的顶部直接访问。它具有O(1)的顶部项查找效率，操作效率为O(1)*。它基本上与`List<T>`相同，只是它只使用LIFO进行处理。'
- en: Note
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For mission-critical code, it is advised that you avoid using classes in the
    `System.Collection` namespace. Instead, you should be using the classes from the
    `System.Collections.Generic` namespace. Although this may sound like tried and
    tested advice, you are advised to run benchmark tests to see which method is best
    for your particular scenario.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于关键任务代码，建议您避免在`System.Collection`命名空间中使用类。相反，您应该使用`System.Collections.Generic`命名空间中的类。尽管这听起来像是一条经过验证的建议，但建议您运行基准测试以查看哪种方法最适合您的特定场景。
- en: Now that you have been introduced to arrays and collections, we will set up
    our sample database before we continue looking at collections from a performance
    perspective.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了数组和集合，在我们从性能角度继续查看集合之前，我们将设置我们的示例数据库。
- en: Setting up our sample database
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的示例数据库
- en: In this chapter, we will be demonstrating the difference between how different
    collection interfaces handle data. For our demonstrations, we require access to
    database data. To do so, we will create a database, add a table to it, and populate
    it with data. We will use SQL Server for our database engine and SQL Server Management
    Studio to develop our sample database.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示不同的集合接口如何处理数据之间的差异。为了我们的演示，我们需要访问数据库数据。为此，我们将创建一个数据库，向其中添加一个表，并用数据填充它。我们将使用SQL
    Server作为我们的数据库引擎，并使用SQL Server Management Studio来开发我们的示例数据库。
- en: 'To add our database, follow these steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的数据库，请按照以下步骤操作：
- en: Open **SQL Server Management Studio** and connect to your database engine.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**SQL Server Management Studio**并连接到您的数据库引擎。
- en: 'Right-click on the **Databases** folder in **Object Explorer**, as shown in
    the following screenshot:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象资源管理器**中的**数据库**文件夹上右键单击，如下面的截图所示：
- en: '![Figure 6.1 – SQL Server Management Studio – Object Explorer'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – SQL Server Management Studio – 对象资源管理器'
- en: '](img/B16617_Figure_6.1.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_6.1.jpg)'
- en: Figure 6.1 – SQL Server Management Studio – Object Explorer
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – SQL Server Management Studio – 对象资源管理器
- en: 'Select **New Database** from the context menu. This will display the **New
    Database** dialog, as shown in the following screenshot:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择**新建数据库**。这将显示**新建数据库**对话框，如下面的截图所示：
- en: '![Figure 6.2 – SQL Server Management Studio – the New Database dialog'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – SQL Server Management Studio – 新建数据库对话框'
- en: '](img/B16617_Figure_6.2.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_6.2.jpg]'
- en: Figure 6.2 – SQL Server Management Studio – the New Database dialog
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – SQL Server Management Studio – 新数据库对话框
- en: Once you have entered `SampleData` under **Database name**, click on the **OK**
    button to create the database.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **数据库名称** 下输入 `SampleData`，然后点击 **确定** 按钮创建数据库。
- en: 'Locate the database by expanding the `Products`, as shown here:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过展开 `Products` 定位数据库，如下所示：
- en: '![Table 6.1 – The Products table''s design'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 6.1 – The Products table''s design]'
- en: '](img/Table_6.1.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Table_1.1.jpg]'
- en: Table 6.1 – The Products table's design
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – 产品表的设计
- en: '**Save** the table, and then expand the **Tables** folder. Right-click on the
    **Product** table and select **Edit Top n records**, where *n* will be the number
    of configured records to edit. This is 200 by default.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存** 表，然后展开 **表** 文件夹。右键单击 **产品** 表，选择 **编辑前 n 条记录**，其中 *n* 将是配置要编辑的记录数。默认情况下为
    200。'
- en: 'Add the data shown in the following table to the **Product** table:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下表中的数据添加到 **产品** 表：
- en: '![Table 6.2 – The Product table''s row data'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 6.2 – The Product table''s row data]'
- en: '](img/Table_6.2.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Table_6.2.jpg]'
- en: Table 6.2 – The Product table's row data
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 – 产品表的行数据
- en: We now have a database with a single table filled with data that we will later
    use in this chapter. Now, let's understand collections from a performance perspective.
    Let's start by looking at how we decide between using arrays or collections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含数据的单个表数据库，我们将在本章后面使用。现在，让我们从性能的角度理解集合。让我们首先看看我们如何决定使用数组还是集合。
- en: Deciding between interfaces and concrete classes
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在接口和具体类之间做出决定
- en: 'In this section, we will show that declaring a collection using an interface
    declaration rather than a concrete class declaration provides better time-based
    performance. We will accomplish this by benchmarking the generation of collections
    using an `IList` interface, as well as by using a `List` concrete class, so that
    you can see the difference in the performance of the different approaches. Follow
    these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示使用接口声明而不是具体类声明来声明集合可以提供更好的基于时间的性能。我们将通过基准测试使用 `IList` 接口生成的集合以及使用
    `List` 具体类，以便您可以看到不同方法性能的差异。按照以下步骤操作：
- en: In the `CH06_Collections` project, add a new folder called `ConcreteVsInterface`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CH06_Collections` 项目中，添加一个名为 `ConcreteVsInterface` 的新文件夹。
- en: 'In the `ConcreteVsInterface` folder, add the `ITax` interface:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ConcreteVsInterface` 文件夹中，添加 `ITax` 接口：
- en: '[PRE4]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This interface defines a contract that various concrete tax classes will have
    to adhere to. It enforces impact analysis since a change in this interface will
    be felt by all the classes that implement it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口定义了一个合同，各种具体税类都必须遵守。它强制执行影响分析，因为此接口的更改将影响所有实现它的类。
- en: 'Next, add the `BaseTax` class:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `BaseTax` 类：
- en: '[PRE5]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This abstract class implements the `ITax` interface but marks `Calculate(decimal
    amount)` as abstract so that its implementation is left up to the subclasses.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象类实现了 `ITax` 接口，但将 `Calculate(decimal amount)` 标记为抽象，因此其实现留给子类。
- en: 'Now, add the `TaxRate` enum:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `TaxRate` 枚举：
- en: '[PRE6]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `TaxRate` enum provides the different types of tax rates for UK income tax.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaxRate` 枚举提供了英国所得税的不同税率类型。'
- en: 'Add the `TaxtType` enum:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `TaxType` 枚举：
- en: '[PRE7]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `TaxType` interface provides the different kinds of UK taxes. Add the `BaseRate`
    class. This class will inherit from the `BaseTax` class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaxType` 接口提供了不同种类的英国税收。添加 `BaseRate` 类。这个类将继承自 `BaseTax` 类。'
- en: 'Then, add the following constructor:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下构造函数：
- en: '[PRE8]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This constructor sets the properties contained within `BaseClass` to the values
    applicable to basic rate income tax.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数将 `BaseClass` 中包含的属性设置为适用于基本税率所得税的值。
- en: 'Now, implement the `Calculate(decimal amount)` method:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现 `Calculate(decimal amount)` 方法：
- en: '[PRE9]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method checks if the percentage is less than one and throws an exception
    if it is not. The lower and upper amounts a person earns that are taxed are checked.
    If the amount is outside of this range, then zero is returned. The amount of tax
    on earnings is then returned and the method exits.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查百分比是否小于一，如果不小于一则抛出异常。检查个人应税收入的下限和上限。如果金额超出此范围，则返回零。然后返回应税收入的税额，并退出方法。
- en: 'Add a new class called `TaxMan`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `TaxMan` 的新类：
- en: '[PRE10]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our class is now configured to perform benchmarking using `BenchmarkDotNet`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们班级现在已配置为使用 `BenchmarkDotNet` 进行基准测试。
- en: 'Add the following method:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE11]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `BasicRateInterface()` method declares a list of `BasicRate` objects using
    the `IList` interface.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicRateInterface()` 方法使用 `IList` 接口声明了一个 `BasicRate` 对象的列表。'
- en: 'Add the `BasicRateConcrete()` method:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `BasicRateConcrete()` 方法：
- en: '[PRE12]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `BasicRateConcrete()` method declares a list of `BasicRate` objects using
    the concrete `List` class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicRateConcrete()` 方法使用具体的 `List` 类声明了一个 `BasicRate` 对象的列表。'
- en: 'In the `Program` class, comment out the code in the `Main` method and add the
    following line of code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类中，注释掉 `Main` 方法中的代码，并添加以下代码行：
- en: '[PRE13]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This line of code will run our benchmarks. Do a release build, and then run
    the executable from the command line. You should see the following output or similar:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将运行我们的基准测试。进行发布构建，然后从命令行运行可执行文件。您应该看到以下输出或类似内容：
- en: '![Figure 6.3 – The BenchmarkDotNet summary report showing the time difference
    between assigning IList<T> and List<T>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – BenchmarkDotNet 汇总报告显示分配 IList<T> 和 List<T> 之间的时间差异](img/B16617_Figure_6.3.jpg)'
- en: '](img/B16617_Figure_6.3.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – BenchmarkDotNet 汇总报告显示分配 IList<T> 和 List<T> 之间的时间差异](img/B16617_Figure_6.3.jpg)'
- en: Figure 6.3 – The BenchmarkDotNet summary report showing the time difference
    between assigning IList<T> and List<T>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – BenchmarkDotNet 汇总报告显示分配 IList<T> 和 List<T> 之间的时间差异
- en: As we can see from the report, memory utilization is the same for both the interface
    and the concrete class implementations. But the faster instantiation time is obtained
    by assigning `IList<T>` instead of `List<T>`. Although the value will not be noticeable
    to the naked eye, it will become more noticeable over some time if there are a
    large number of assignments, such as when a large data iteration is taking place.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从报告中我们可以看出，接口和具体类实现之间的内存利用率是相同的。但是，通过分配 `IList<T>` 而不是 `List<T>` 可以获得更快的实例化时间。尽管这个值对肉眼来说可能不明显，但如果存在大量的赋值操作，比如在大数据迭代过程中，这个差异将变得更加明显。
- en: Now, let's look at array and collection performance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看数组和集合的性能。
- en: Deciding between using arrays or collections
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用数组或集合之间做出决定
- en: In this section, we'll discuss the pros and cons of using arrays and collections.
    We will also perform various benchmarks that measure array and collection performance.
    Armed with benchmark information, you can then make informed decisions as to whether
    arrays or collections are best suited to your specific needs. We will start by
    looking at arrays.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用数组和集合的优缺点。我们还将执行各种基准测试，以衡量数组和集合的性能。有了基准信息，您就可以做出明智的决定，确定数组或集合最适合您的特定需求。我们将首先查看数组。
- en: 'The downsides to using arrays are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组的缺点如下：
- en: Arrays are fixed in size, meaning that once the size of the array has been changed,
    its size cannot be changed.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的大小是固定的，这意味着一旦数组的尺寸被改变，其尺寸就不能再改变。
- en: Since arrays are fixed in size, they are not recommended for efficient memory
    usage.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数组的大小是固定的，因此它们不推荐用于高效内存使用。
- en: Arrays can only hold heterogeneous data types, and data types can be primitive
    and object types.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组只能持有异构数据类型，数据类型可以是原始类型和对象类型。
- en: Data elements of the `object` type can hold different types of data elements.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object` 类型的数据元素可以持有不同类型的数据元素。'
- en: Arrays lack many useful methods.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组缺少许多有用的方法。
- en: 'The benefits of using arrays are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组的优点如下：
- en: Arrays have a small memory footprint and have undergone some serious performance
    improvements in C# 9.0 and .NET 5.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组具有较小的内存占用，并且在 C# 9.0 和 .NET 5 中经历了某些严重的性能改进。
- en: However, as arrays are fast and have undergone speed improvements, they are
    recommended when performance matters.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，由于数组速度快且经过速度改进，当性能很重要时，它们是推荐的。
- en: 'The downside to using collections is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合的缺点如下：
- en: When it comes to performance, they are not recommended over arrays.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在性能方面，它们不建议用于替代数组。
- en: 'The benefits of using arrays are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组的优点如下：
- en: Collections effectively wrap arrays; `generic List<T>` is a good example.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合有效地封装了数组；`generic List<T>` 是一个很好的例子。
- en: They are growable, which means that we can shrink and grow our collections as
    required. Because of this, collections are recommended over arrays when it comes
    to efficient memory utilization.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可增长的，这意味着我们可以根据需要缩小和扩大我们的集合。正因为如此，在高效内存利用方面，集合比数组更受欢迎。
- en: Data elements (item data) in a collection can be homogeneous and heterogeneous.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合中的数据元素（项目数据）可以是同构的也可以是异构的。
- en: Collection classes have ready-made method support for most operations and can
    easily be extended. By this, we mean that arrays lack some useful methods that
    we get for free when we use collections.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合类为大多数操作提供了现成的方法支持，并且可以轻松扩展。这里的含义是，数组缺少一些在使用集合时我们免费获得的有用方法。
- en: Note
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that you do not use the collections in the `System.Collections`
    namespace. Instead, you are encouraged to use the collections in the `System.Collections.Generic`
    namespaces.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议您不要使用 `System.Collections` 命名空间中的集合。相反，鼓励您使用 `System.Collections.Generic`
    命名空间中的集合。
- en: The standard collection that most programmers will be familiar with is the generic
    `List<T>` class. In this section, we will create a new project. Then, we will
    build up a `uint` array and a `List<uint>` collection and iterate through them.
    This process will be benchmarked using `BenchmarkDotNet`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员都熟悉的标准集合是泛型 `List<T>` 类。在本节中，我们将创建一个新的项目。然后，我们将构建一个 `uint` 数组和 `List<uint>`
    集合，并通过它们进行迭代。这个过程将使用 `BenchmarkDotNet` 进行基准测试。
- en: 'We will be benchmarking adding items, iterating through, and retrieving items
    from arrays and collections. So, let''s begin:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对添加项、迭代和从数组和集合中检索项进行基准测试。所以，让我们开始吧：
- en: 'Add a new class under the project root called `ArraysVsCollections` with the
    following `using` statements:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下添加一个名为 `ArraysVsCollections` 的新类，并包含以下 `using` 语句：
- en: '[PRE14]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These `using` statements give us what we need to work with arrays and collections
    and benchmark them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `using` 语句为我们提供了与数组和集合一起工作以及基准测试它们所需的内容。
- en: 'Add the following member variables:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下成员变量：
- en: '[PRE15]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The array of `int` and the list of `int` will be used to benchmark adding, getting,
    and iterating arrays and collections.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 数组和 `int` 列表将被用来基准测试添加、获取和迭代数组和集合。'
- en: 'Next, add the `GlobalSetup()` method:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `GlobalSetup()` 方法：
- en: '[PRE16]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `GlobalSetup()` method is attributed to the `[GlobalSetup]` attribute. This
    informs `BenchmarkDotNet` to run this method before all other benchmark methods.
    It initializes the array and collection with a size of `1000` and adds a value
    of `i` in the current iteration to both the array and collection.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalSetup()` 方法被 `[GlobalSetup]` 属性标记。这通知 `BenchmarkDotNet` 在所有其他基准方法之前运行此方法。它使用大小为
    `1000` 的数组集合初始化，并将当前迭代中的 `i` 值添加到数组和集合中。'
- en: 'Although we will not be utilizing the `GlobalCleanup()` method, we will add
    it for completeness so that you know how to perform cleanup operations when benchmarking:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们不会使用 `GlobalCleanup()` 方法，但我们添加它以保持完整性，这样您就知道如何在基准测试时执行清理操作：
- en: '[PRE17]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `GlobalCleanup()` method is where you would provide your cleanup logic if
    it were needed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalCleanup()` 方法是您提供清理逻辑的地方，如果需要的话。'
- en: 'Now, add the `ArrayAdd1000Logic()` method:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `ArrayAdd1000Logic()` 方法：
- en: '[PRE18]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ArrayAdd1000Logic()` method declares an array of 1000 `int` values and
    later proceeds to add integer values to each element in the array.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayAdd1000Logic()` 方法声明了一个包含 1000 个 `int` 值的数组，随后对数组中的每个元素添加整数值。'
- en: 'Add the `CollectionAdd1000Logic()` method:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `CollectionAdd1000Logic()` 方法：
- en: '[PRE19]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `CollectionAdd1000Logic ()` method declares a list of `int` elements. Then,
    it loops 1,000 times using a `for` loop and adds the current value to the collection.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionAdd1000Logic()` 方法声明了一个 `int` 元素列表。然后，它使用 `for` 循环循环 1,000 次，并将当前值添加到集合中。'
- en: 'Add the `ArrayIterationLogic()` method:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ArrayIterationLogic()` 方法：
- en: '[PRE20]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ArrayIterationLogic()` method declares an `int` variable and assigns it
    a value of `0`. A `for` loop is used to iterate 1,000 times and add the value
    of the array at the index position to the `res` value. Once the iteration is over,
    the `res` variable is returned.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayIterationLogic()` 方法声明了一个 `int` 变量，并将其赋值为 `0`。使用 `for` 循环迭代 1,000 次，并将数组在索引位置上的值添加到
    `res` 值中。一旦迭代完成，返回 `res` 变量。'
- en: 'Now, add the `CollectionIterationLogic()` method:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `CollectionIterationLogic()` 方法：
- en: '[PRE21]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`CollectionIterationLogic()` declares an `int` variable and assigns it a value
    of `0`. A `for` loop is used to iterate 1,000 times and add the value of the array
    at the index position to the `res` value. Once the iteration is over, the `res`
    variable is returned.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionIterationLogic()` 声明了一个 `int` 变量，并将其赋值为 `0`。使用 `for` 循环迭代 1,000
    次，并将数组在索引位置上的值添加到 `res` 值中。一旦迭代完成，返回 `res` 变量。'
- en: 'Add the `ArrayGetElement500Logic()` method:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ArrayGetElement500Logic()` 方法：
- en: '[PRE22]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ArrayGetElement500Logic()` method returns the value of the array at position
    `500`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayGetElement500Logic()` 方法返回数组在位置 `500` 的值。'
- en: 'Now, add the `CollectionGetElement500Logic()` method:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `CollectionGetElement500Logic()` 方法：
- en: '[PRE23]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `CollectionGetElement500Logic()` method returns the value of the collection
    at position `500`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionGetElement500Logic()`方法返回集合在位置`500`的值。'
- en: 'Replace the code in the `Main` method with the following line of code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Main`方法中的代码替换为以下代码行：
- en: '[PRE24]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This call will run our benchmarks. Release build your code and run it from
    the console. You should see a report with similar timings to those shown in the
    following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将运行我们的基准测试。发布构建您的代码，并在控制台运行它。您应该会看到一个与以下截图相似的报告：
- en: '![Figure 6.4 – The BenchmarkDotNet summary report for array and collection
    operations'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – BenchmarkDotNet对数组和集合操作的总结报告'
- en: '](img/B16617_Figure_6.4.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_6.4.jpg)'
- en: Figure 6.4 – The BenchmarkDotNet summary report for array and collection operations
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – BenchmarkDotNet对数组和集合操作的总结报告
- en: Looking at the performance in terms of time, adding items to an array is faster
    than adding items to a collection. Iterating a collection is faster than iterating
    over an array and getting an item from an array using its index is faster than
    getting a collection from a collection by its index. Based on these findings,
    you need to decide what your requirements are, and then choose the best type based
    on these requirements.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从时间性能的角度来看，向数组中添加项目比向集合中添加项目更快。遍历集合比遍历数组更快，并且通过索引从数组中获取项目比通过索引从集合中获取集合更快。基于这些发现，您需要决定您的需求是什么，然后根据这些需求选择最佳类型。
- en: Now, let's look at indexers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看索引器。
- en: Accessing objects using indexers
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引器访问对象
- en: Indexes enable objects in classes to be accessed in the same way you access
    items in an array. An indexer will have a modifier, a return type, the `this`
    keyword to indicate the object of the current class, and an argument list. You
    will always use the `this` keyword when creating an indexer. Indexer is the term
    given to a parameterized property. The index is created using the `get` and `set`
    accessors. You are not allowed to use the `ref` or `out` keywords to modify indexer
    parameters. A minimum of one parameter should be specified. An indexer cannot
    be static since it is an instance member. However, the indexer properties can
    be static. You would implement an indexer if you need to operate on a group of
    elements. The main difference between a property and an indexer is that you identify
    and access a property by its name. On the other hand, with an indexer, it is identified
    by its signature and accessed using indexes. Moreover, you can overload indexers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 索引使类中的对象可以像访问数组中的项目一样访问。索引器将有一个修饰符、一个返回类型、一个`this`关键字来指示当前类的对象，以及一个参数列表。您在创建索引器时始终会使用`this`关键字。索引器是参数化属性的术语。索引是通过`get`和`set`访问器创建的。不允许使用`ref`或`out`关键字来修改索引器参数。应指定至少一个参数。索引器不能是静态的，因为它是一个实例成员。然而，索引器属性可以是静态的。如果您需要操作一组元素，则可以实现索引器。属性和索引器之间的主要区别在于，您通过其名称识别和访问属性。另一方面，使用索引器时，它通过其签名识别，并通过索引访问。此外，您可以重载索引器。
- en: 'Now, let''s write a simple indexer example. In this example, we will have a
    class that has a constructor that takes a size. This size will set the size of
    an internal array of strings. We will be able to get the index of a string in
    the array by name and get an item from the array by index using indexers. Follow
    these steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们写一个简单的索引器示例。在这个例子中，我们将有一个类，它有一个构造函数，该构造函数接受一个大小。这个大小将设置一个内部字符串数组的大小。我们将能够通过名称获取数组中字符串的索引，并通过索引器使用索引从数组中获取项目。按照以下步骤操作：
- en: 'Add a new class called `Indexers` and add a `using` statement to `System namespace`.
    Then, add the following array and constructor at the top of the class:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Indexers`的新类，并将`using`语句添加到`System`命名空间。然后，在类的顶部添加以下数组和构造函数：
- en: '[PRE25]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `_items` array will contain several strings. The size of the array is set
    by the value that's passed into the constructor that initializes the array.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`_items`数组将包含几个字符串。数组的大小由传递给构造函数并初始化数组的值设置。'
- en: 'Add the indexer to get a string by index:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加索引器以通过索引获取字符串：
- en: '[PRE26]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This indexer uses an `int` value to get an item from the array and set the value
    of the array at the given index. Items are only set and retrieved if the index
    is valid.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此索引器使用一个`int`值从数组中获取一个项目并设置给定索引处的数组值。只有当索引有效时，才会设置和检索项目。
- en: 'We can check the index by passing it into the `IsValidIndex(int index)` method,
    which returns a `bool`. Let''s add the `IsValidIndex(int index)` method:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将其传递到`IsValidIndex(int index)`方法中来检查索引，该方法返回一个`bool`。让我们添加`IsValidIndex(int
    index)`方法：
- en: '[PRE27]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method returns `true` if the index is greater than -1 and less than the
    length of the array. Otherwise, it returns `false`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法如果索引大于-1且小于数组的长度，则返回`true`。否则，返回`false`。
- en: 'Now, add the index that takes a `string` and returns the string''s index:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个接受`string`并返回字符串索引的索引：
- en: '[PRE28]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This indexer takes a `string`. Then, it looks up the index for the string and
    returns the index. There is no setter for this index.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此索引器接受一个`string`。然后，它查找字符串的索引并返回索引。此索引没有设置器。
- en: 'In the `Program` class, add the `IndexerExample()` method:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类中添加`IndexerExample()`方法：
- en: '[PRE29]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method creates a new `Indexer` object with an internal array size of `1000`.
    Then, it loops 1,000 times and sets the value of each item in the array. After
    that, it prints out the value of the array at position 500 and prints out the
    value of `Item 500`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个新的`Indexer`对象，其内部数组大小为`1000`。然后，它循环1,000次并设置数组中每个元素的值。之后，它打印出数组位置500的值，并打印出`Item
    500`的值。
- en: 'Comment out the code in the `Main` method, and then add the following line:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中注释掉代码，然后添加以下行：
- en: '[PRE30]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This statement calls the method that executes our `Indexer` method. You should
    see the following output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句调用了执行我们的`Indexer`方法的函数。你应该看到以下输出：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That concludes our look at indexers. As you can see, they are pretty simple.
    You can use any data item that you like for an indexer. However, it will be up
    to you to see how well such indexers perform. Now, let's look at the difference
    between the `IEnumerable` and `IEnumerator` interfaces.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对索引器的探讨。正如你所见，它们相当简单。你可以为索引器使用任何你喜欢的数据项。然而，如何评估这些索引器的性能将取决于你。现在，让我们看看`IEnumerable`和`IEnumerator`接口之间的区别。
- en: Comparing IEnumerable and IEnumerator
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较`IEnumerable`和`IEnumerator`
- en: The `IEnumerable` and `IEnumerator` interfaces can both be used for iteration
    but in different ways. Let's understand each in brief.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable`和`IEnumerator`接口都可以用于迭代，但方式不同。让我们简要了解每个接口。'
- en: 'An object of the `IEnumerable` type will know how to traverse the collection
    that it holds, regardless of what its internal structure is like. There is one
    method that makes up an enumerable: `GetEnumerator()`. It returns as an instance
    of a class that implements the `IEnumerable` interface. Iteration is normally
    carried out using a `foreach` loop. Iterations of an enumerable are carried out
    using a `foreach` loop. However, an enumerable does not remember its location
    when iterating.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable`类型的对象将知道如何遍历它所持有的集合，无论其内部结构如何。有一个方法构成了可枚举：`GetEnumerator()`。它返回一个实现`IEnumerable`接口的类的实例。迭代通常使用`foreach`循环进行。可枚举的迭代使用`foreach`循环进行。然而，可枚举在迭代时不会记住其位置。'
- en: 'Objects of the `Ienumerator` type declare two methods: `MoveNext()` and `Reset()`.
    There is one property called `Current` that gets the current item in the list
    that''s being enumerated. The `MoveNext()` method moves to the next record in
    a collection and returns a Boolean value indicating the end of the collection.
    `Reset()` will reset the position to the first item in the collection. The `Current`
    property is called through an object that implements the `IEnumerable` interface,
    which returns the current element in the collection. An enumerator remembers its
    current location and uses a `while` loop when iterating.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ienumerator`类型的对象声明了两个方法：`MoveNext()`和`Reset()`。有一个名为`Current`的属性，用于获取正在枚举的列表中的当前项。`MoveNext()`方法将移动到集合中的下一个记录，并返回一个布尔值，指示集合的结束。`Reset()`将位置重置为集合中的第一个项。`Current`属性通过实现`IEnumerable`接口的对象调用，该接口返回集合中的当前元素。枚举器会记住其当前位置，并在迭代时使用`while`循环。'
- en: Let's see which method of enumeration is fastest. Will it be looping using an
    enumerable, or will it be looping using an iterator?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看哪种枚举方法最快。是使用可枚举的循环，还是使用迭代器的循环？
- en: 'Add a new class called `IEnumerableVsIEnumerable` with the following `using`
    statements:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`IEnumerableVsIEnumerable`的新类，并包含以下`using`语句：
- en: '[PRE32]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These `using` statements provide the elements we will need to build and test
    the performance between `IEnumerable` and `IEnumerator`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`using`语句提供了我们将需要构建和测试`IEnumerable`和`IEnumerator`性能的元素。
- en: 'Add the following code to the class:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE33]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we are declaring a list of `int` values that will hold several year values.
    Our constructor then initializes the array with the years `1970` to `1979`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个`int`值的列表，它将包含几个年份值。然后我们的构造函数初始化数组，包含年份`1970`到`1979`。
- en: 'Add the `IterateEnumerator1970to1975()` method:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`IterateEnumerator1970to1975()`方法：
- en: '[PRE34]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This method iterates over the values `1970` to `1975` and prints the values
    out to the debug window.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历值`1970`到`1975`并将值打印到调试窗口。
- en: 'If the current year is greater than `1975`, then the enumerator is passed into
    the `IterateEnumerator1976To1979(IEnumerator<int> years)` method, which we will
    add now:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前年份大于`1975`，则枚举器将被传递到`IterateEnumerator1976To1979(IEnumerator<int> years)`方法中，我们将在下面添加它：
- en: '[PRE35]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method takes in an enumerator and iterates through it. On each iteration,
    it prints the current year to the debug window.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个枚举器并遍历它。在每次迭代中，它将当前年份打印到调试窗口。
- en: 'Add the following line to the end of the `Main` method in the `Program` class:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的`Main`方法末尾添加以下行：
- en: '[PRE36]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This line of code calls a method that will run our example and show how an enumerator
    remembers where it is in the iteration.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码调用一个方法，该方法将运行我们的示例并展示枚举器如何记住迭代中的位置。
- en: 'Add the `IEnumerableVsIEnumeratorExample()` method to the `Program` class:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IEnumerableVsIEnumeratorExample()`方法添加到`Program`类中：
- en: '[PRE37]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This method runs our code. If you do a debug build and run the code, then you
    should see the years *1970* to *1979* printed to the output window.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法运行我们的代码。如果你进行调试构建并运行代码，那么你应该看到年份*1970*到*1979*被打印到输出窗口。
- en: Now that you have seen an enumerator in action, we will add two methods to the
    `IEnumerableVsIEnumerator` class.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了枚举器的实际应用，我们将向`IEnumerableVsIEnumerator`类添加两个方法。
- en: 'Add the `BenchmarkIEnumerabled()` method:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`BenchmarkIEnumerabled()`方法：
- en: '[PRE38]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method uses an enumerable and a `foreach` loop to iterate through the years
    and write them to the debug window.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用可枚举和`foreach`循环遍历年份并将它们写入调试窗口。
- en: 'Add the `BenchmarkIEnumerator()` method:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`BenchmarkIEnumerator()`方法：
- en: '[PRE39]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method uses an enumerator and a `while` loop to iterate through the years
    and write them to the debug window.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用枚举器和`while`循环遍历年份并将它们写入调试窗口。
- en: 'Comment out the code in the `Main` method in the `Program` class, and then
    add the following line:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的`Main`方法中注释掉代码，然后添加以下行：
- en: '[PRE40]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This line of code detects our benchmarks and runs them to produce a summary
    report on performance. Do a release build and run the program from the command
    prompt. You should see the following output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码检测我们的基准测试并运行它们，以生成性能总结报告。进行发布构建并从命令提示符运行程序。你应该看到以下输出：
- en: '![Figure 6.5 – The BenchmarkDotNet summary report showing that IEnumerator'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – BenchmarkDotNet总结报告显示IEnumerator比IEnumerable快](img/B16617_Figure_6.5.jpg)'
- en: is faster than IEnumerable
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: is faster than IEnumerable
- en: '](img/B16617_Figure_6.5.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_6.5.jpg)'
- en: Figure 6.5 – The BenchmarkDotNet summary report showing that IEnumerator is
    faster than IEnumerable
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – BenchmarkDotNet总结报告显示IEnumerator比IEnumerable快
- en: As we can see, even though `IEnumerable` and `IEnumerator` both perform iterations
    on the same collection, they do so in different ways. And by viewing the benchmarking
    summary report, we can see that the clear winner in terms of performance is the
    `IEnumerator` interface. Now, let's look at the difference between `IEnumerable`,
    `IEnumerator`, and `IQueryable`, and the effects these differences have on performance
    when performing LINQ queries on a database.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，尽管`IEnumerable`和`IEnumerator`都在相同的集合上执行迭代，但它们以不同的方式执行。通过查看基准测试总结报告，我们可以看到在性能方面，`IEnumerator`接口是明显的赢家。现在，让我们看看`IEnumerable`、`IEnumerator`和`IQueryable`之间的区别，以及这些差异在执行数据库上的LINQ查询时的性能影响。
- en: Database query performance
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库查询性能
- en: 'In the previous section, we saw how `IEnumerator` is different from and performs
    faster than `IEnumerable` when iterating through an in-memory collection. Now,
    let''s query a database and iterate through the resulting collection using various
    benchmarked techniques. To do so, we''ll follow these steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了`IEnumerator`在遍历内存集合时与`IEnumerable`的不同之处，以及它的性能更快。现在，让我们查询数据库并使用各种基准测试技术遍历结果集合。为此，我们将遵循以下步骤：
- en: Add a new class called `IEnumeratorVsIQueryable`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`IEnumeratorVsIQueryable`的新类。
- en: We will be connecting to a SQL Server database, and we will have information
    we need to keep secret. Our `secret.json` files do not get checked into version
    control. So, right-click on the project and select **Manage User Secrets** from
    the context menu.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将连接到 SQL Server 数据库，并且我们将拥有需要保密的信息。我们的 `secret.json` 文件不会提交到版本控制中。因此，右键单击项目并从上下文菜单中选择
    **管理用户密钥**。
- en: 'A dialog box will pop up, informing you that additional packages are required.
    Click on **Yes**:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会弹出一个对话框，告知你需要额外的包来管理用户密钥。点击 **是**：
- en: '![Figure 6.6 – A dialog box, informing you that additional packages are required
    to manage user secrets'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – 一个对话框，告知你需要额外的包来管理用户密钥](img/B16617_Figure_6.6.jpg)'
- en: '](img/B16617_Figure_6.6.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – 一个对话框，告知你需要额外的包来管理用户密钥](img/B16617_Figure_6.6.jpg)'
- en: Figure 6.6 – A dialog box, informing you that additional packages are required
    to manage user secrets
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 一个对话框，告知你需要额外的包来管理用户密钥
- en: Visual Studio will then open the `secrets.json` file in a new tab. This is where
    you will add your user secrets.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将在新标签页中打开 `secrets.json` 文件。这就是你添加用户密钥的地方。
- en: 'Open the Package Manager Console and add the following packages:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开包管理控制台并添加以下包：
- en: '`Microsoft.EntityFrameworkCore`'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore`'
- en: '`Microsoft.EntityFrameworkCore.SqlServer`'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.SqlServer`'
- en: '`Microsoft.EntityFrameworkCore.Tools`'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.Tools`'
- en: '`Microsoft.Extensions.Configuration`'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration`'
- en: '`Microsoft.Extensions.Configuration.EnvironmentVariables`'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.EnvironmentVariables`'
- en: '`Microsoft.Extensions.Configuration.UserSecrets`'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.UserSecrets`'
- en: '`Microsoft.Extensions.OptionsConfigurationExtensions`'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.OptionsConfigurationExtensions`'
- en: These packages allow you to connect to and extract data from our SQL Server
    database.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包允许你连接到并从我们的 SQL Server 数据库中提取数据。
- en: 'Update your `secrets.json` file with the connection string to the database
    that we created at the start of this chapter:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的 `secrets.json` 文件，包含我们在这章开头创建的数据库的连接字符串：
- en: '[PRE41]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This connection string will be used to connect to our database, perform a query
    that returns some data, and allow us to iterate through that data and perform
    some operations on it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个连接字符串将用于连接到我们的数据库，执行返回一些数据的查询，并允许我们遍历这些数据并对它进行操作。
- en: 'Add a folder called `Configuration`. In that folder, add a class called `SecretsManager`
    with an empty static constructor and the following `using` statements:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Configuration` 的文件夹。在该文件夹中，添加一个名为 `SecretsManager` 的类，它有一个空的静态构造函数和以下
    `using` 语句：
- en: '[PRE42]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We need these `using` statements for our file I/O and system configuration,
    such as obtaining secrets from a `secrets.json` file.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些 `using` 语句来进行文件 I/O 和系统配置，例如从 `secrets.json` 文件中获取密钥。
- en: 'Add the following line at the top of the `SecretsManager` class:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SecretsManager` 类的顶部添加以下行：
- en: '[PRE43]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This line declares our static configuration property, which is used to obtain
    the configuration data within our application.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码声明了我们的静态配置属性，它用于在我们的应用程序中获取配置数据。
- en: 'Now, add the following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下代码：
- en: '[PRE44]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code gets the environment variables for the .NET Core environment. Then,
    it gets the code to see if it is running in a software development environment.
    The configuration is built for the environment it will be running in. If we are
    in development, then we must add our `secrets` class as defined by the `T` variable.
    Switch to the `Product` class in the `Models` folder.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码获取 .NET Core 环境的环境变量。然后，它获取代码以查看它是否在软件开发环境中运行。配置是为它将要运行的环境构建的。如果我们处于开发状态，那么我们必须添加由
    `T` 变量定义的 `secrets` 类。切换到 `Models` 文件夹中的 `Product` 类。
- en: Add a `using` statement for `System.ComponentModel.DataAnnotations`. Change
    the struct to a class, and add the `[Key]` attribute to the `Id` property. We
    need these changes since we are using Entity Framework to connect to a database
    and extract data.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `System.ComponentModel.DataAnnotations` 添加一个 `using` 语句。将结构更改为类，并将 `[Key]`
    属性添加到 `Id` 属性。我们需要这些更改，因为我们正在使用 Entity Framework 连接到数据库并提取数据。
- en: 'Add the `DatabaseSettings` class to the `Configuration` folder:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DatabaseSettings` 类添加到 `Configuration` 文件夹：
- en: '[PRE45]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This class has a single property called `ConnectionString` that will hold our
    connection string to our `SampleData` database. Notice that the name of the class
    and property match the name of the JSON section and property!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个名为 `ConnectionString` 的单个属性，它将保存我们到 `SampleData` 数据库的连接字符串。注意，类的名称和属性的名称与
    JSON 部分的名称和属性名称相匹配！
- en: 'Now, add `appsettings.json` to the root of your project with the following
    contents:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `appsettings.json` 添加到项目的根目录，并包含以下内容：
- en: '[PRE46]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This file contains the same layout as the `secrets.json` file and the `DatabaseSettings`
    class. This file is used to store our connection string. In development, it is
    set in our `secrets` file, while in production, it is set in Azure. Now that we
    have our database configuration in place, we can add our benchmarking code.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含与`secrets.json`文件和`DatabaseSettings`类相同的布局。此文件用于存储我们的连接字符串。在开发中，它设置在我们的`secrets`文件中，而在生产中，它设置在Azure中。现在我们已经设置了数据库配置，我们可以添加我们的基准测试代码。
- en: 'Add a new class to the root of the project called `DatabaseQueryAndIteration`
    that implements `IDisposable` with the following code:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中添加一个名为`DatabaseQueryAndIteration`的新类，该类实现`IDisposable`，代码如下：
- en: '[PRE47]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code declares our class and defines the fact that it implements `IDisposable`.
    It is also configured to be benchmarked.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码声明我们的类并定义了它实现`IDisposable`的事实。它也被配置为可进行基准测试。
- en: 'Implement the `IDisposable` interface in our class:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类中实现`IDisposable`接口：
- en: '[PRE48]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code disposes of our managed resources and suppresses the call to the class
    finalizer method.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码释放我们的托管资源并抑制对类终结器方法的调用。
- en: 'We have everything in place to benchmark the methods in this class, access
    database resources, and clean up after ourselves. Add the following code to the
    class:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好对类中的方法进行基准测试，访问数据库资源，并在自己之后进行清理。将以下代码添加到类中：
- en: '[PRE49]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The _`context` variable provides us with our database access. The `GlobalSetup()`
    method gets our connection string from our secrets file and creates a new `DatabaseContext`
    using the safely stored connection string. The `GlobalSetup()` method will run
    before our benchmarks. The `GlobalCleanup()` method calls the `Dispose(disposing)`
    method to clean up our managed resources after our benchmarks have finished running.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`_`变量`context`为我们提供了数据库访问。`GlobalSetup()`方法从我们的秘密文件中获取连接字符串，并使用安全存储的连接字符串创建一个新的`DatabaseContext`。`GlobalSetup()`方法将在基准测试之前运行。`GlobalCleanup()`方法在基准测试完成后调用`Dispose(disposing)`方法来清理我们的托管资源。'
- en: 'Next, add the `QueryDb()` method:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`QueryDb()`方法：
- en: '[PRE50]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `QueryDb()` method performs a simple LINQ query on the database by selecting
    products with an ID that's greater than `1`. Then, it iterates each product in
    the `lQueryable<Product>` list and writes the product name out to the debug window.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryDb()`方法通过选择ID大于`1`的产品对数据库执行简单的LINQ查询。然后，它迭代`lQueryable<Product>`列表中的每个产品，并将产品名称写入调试窗口。'
- en: 'Now, add the `QueryDbAsList()` method:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`QueryDbAsList()`方法：
- en: '[PRE51]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`QueryDbAsList()` performs the same query as `QueryDb()`, except the processed
    type is of the `List<Product>` type.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryDbAsList()`执行与`QueryDb()`相同的查询，但处理类型为`List<Product>`类型。'
- en: 'Add the `QueryDbAsIEnumerable()` method:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`QueryDbAsIEnumerable()`方法：
- en: '[PRE52]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `QueryDbAsIEnumerable()` method performs the same query as `QueryDbAsList`,
    but the processed type is of the `Ienumerable<Product>` type instead.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryDbAsIEnumerable()`方法执行与`QueryDbAsList`相同的查询，但处理类型为`Ienumerable<Product>`类型。'
- en: 'Add the `QueryDbAsIEnumerator()` method:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`QueryDbAsIEnumerator()`方法：
- en: '[PRE53]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`QueryDbAsIEnumerator()` does the same as the previous methods but operates
    on the `IEnumerator<Product>` type and iterates using a `while` loop instead of
    a `foreach` loop.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryDbAsIEnumerator()`与前面的方法执行相同，但操作`IEnumerator<Product>`类型，并使用`while`循环而不是`foreach`循环进行迭代。'
- en: 'Our final method in this class is the `QueryDbAsIQueryable()` method:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本类中的最后一个方法是`QueryDbAsIQueryable()`方法：
- en: '[PRE54]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method is the same as `QueryDb` but explicitly operates on the `IQueryable<Product>`
    type.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与`QueryDb`相同，但明确操作`IQueryable<Product>`类型。
- en: 'Replace the code in the `Main` method within the `Program` class with the following
    code:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Program`类中的`Main`方法中的代码替换为以下代码：
- en: '[PRE55]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This code runs our benchmarks. Do a release build of the code and run the executable
    from the command line. You should see a summary report similar to the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码运行我们的基准测试。进行代码的发布构建并从命令行运行可执行文件。你应该看到类似于以下摘要报告：
- en: '![Figure 6.7 – The different times and memory allocations of various database
    query types using LINQ'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 – 使用LINQ的各种数据库查询类型的不同时间和内存分配'
- en: '](img/B16617_Figure_6.7.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_6.7.jpg](img/B16617_Figure_6.7.jpg)'
- en: Figure 6.7 – The different times and memory allocations of various database
    query types using LINQ
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 使用LINQ的各种数据库查询类型的不同时间和内存分配
- en: In terms of memory usage, the worst performer is the `QueryDb()` method, followed
    by the `QueryDbAsList()` method. `QueryDbAsIEnumerable()` and `QueryDbAsIQueryable()`
    are both slightly better than the previous two. However, the best performing method
    in terms of memory allocation out of all five methods is the `QueryDbAsIEnumerator()`
    method.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存使用方面，表现最差的是 `QueryDb()` 方法，其次是 `QueryDbAsList()` 方法。`QueryDbAsIEnumerable()`
    和 `QueryDbAsIQueryable()` 都比前两种略好。然而，在所有五种方法中，就内存分配而言，表现最好的方法是 `QueryDbAsIEnumerator()`
    方法。
- en: Speedwise, the `QueryDb()` method was the worst again, followed by `QueryDbAsIEnumerable()`,
    then `QueryDbAsList()`, and then `QueryDbAsIQueryable()`. And again, the best
    performer in terms of speed is the `QueryDbAsIEnumerator()` method.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在速度方面，`QueryDb()` 方法再次表现最差，其次是 `QueryDbAsIEnumerable()`，然后是 `QueryDbAsList()`，最后是
    `QueryDbAsIQueryable()`。再次强调，就速度而言，表现最好的方法是 `QueryDbAsIEnumerator()`。
- en: Here, we can see that the best performing method for querying and iterating
    a database in terms of both speed and memory usage is the `QueryDbAsIEnumerator()`
    method. Now, let's look at the `yield` keyword.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，在速度和内存使用方面，查询和迭代数据库表现最好的方法是 `QueryDbAsIEnumerator()` 方法。现在，让我们看看
    `yield` 关键字。
- en: Exploring the yield keyword
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 `yield` 关键字
- en: 'The `yield` keyword:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` 关键字：'
- en: '`yield return <expression>;`: This returns the value of the expression.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield return <expression>;`：这将返回表达式的值。'
- en: '`yield break;`: This will exit from the iteration'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield break;`：这将退出迭代'
- en: 'When using the `yield` keyword, there are some restrictions to be aware of.
    These are as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `yield` 关键字时，有一些限制需要注意。具体如下：
- en: You cannot use the `yield` keyword in `unsafe` blocks of code.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在 `unsafe` 代码块中使用 `yield` 关键字。
- en: You cannot use the `ref` or `out` parameters for methods, operators, or accessors.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在方法、运算符或访问器中使用 `ref` 或 `out` 参数。
- en: You cannot return using the `yield` keyword in a `try-catch` block.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `try-catch` 块中，你不能使用 `yield` 关键字来返回。
- en: You cannot use the `yield` keyword in anonymous methods.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在匿名方法中使用 `yield` 关键字。
- en: You can use `yield` in a `try` block if the `try` block is followed by the `finally`
    block.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `try` 块后面跟着 `finally` 块，你可以在 `try` 块中使用 `yield`。
- en: You can use `yield break` in a `try-catch` block but not the `finally` block.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 `try-catch` 块中使用 `yield break`，但不能在 `finally` 块中使用。
- en: 'In this section, we are going to add a class that shows the `yield` keyword
    in action. Then, we will benchmark two ways to return an `IEnumerable<long>` consisting
    of 1 million items, and show the vast difference in performance between them.
    Let''s begin:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个显示 `yield` 关键字实际用法的类。然后，我们将基准测试两种返回包含 1 百万项的 `IEnumerable<long>`
    的方法，并展示它们之间在性能上的巨大差异。让我们开始：
- en: 'Add a new class called `Yield` to the root of the project:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为 `Yield` 的新类添加到项目的根目录：
- en: '[PRE56]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This class will benchmark the use of the `yield` keyword.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将基准测试 `yield` 关键字的用法。
- en: 'Now, add the `YieldSample()` method:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `YieldSample()` 方法：
- en: '[PRE57]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `YieldSample()` method will be called from our `Program` class. It will
    run all three methods.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`YieldSample()` 方法将从我们的 `Program` 类中调用。它将运行所有三个方法。'
- en: 'Add the `Countdown()` method:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Countdown()` 方法：
- en: '[PRE58]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This method loops from `10` to `0`. Each iteration is returned using the `yield`
    keyword.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法从 `10` 循环到 `0`。每次迭代都使用 `yield` 关键字返回。
- en: 'Add the `DoCountdown()` method:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `DoCountdown()` 方法：
- en: '[PRE59]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `DoCountdown()` method prints the countdown from `10` to `0` to the console
    window.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoCountdown()` 方法将 `10` 到 `0` 的倒计时打印到控制台窗口。'
- en: 'Add a class called `Month`:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Month` 的类：
- en: '[PRE60]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This class holds the name of a month of the year and its number.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含一年中月份的名称及其编号。
- en: 'Now, add the `Months` class:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `Months` 类：
- en: '[PRE61]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This class returns a collection of `Month` objects using the `yield` keyword.
    Switch back to the `Yield` class.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用 `yield` 关键字返回 `Month` 对象的集合。切换回 `Yield` 类。
- en: 'Add the `PrintMonthsOfYear()` method:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `PrintMonthsOfYear()` 方法：
- en: '[PRE62]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This method iterates through the months of the year and prints them out to the
    console window.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法遍历年份中的月份并将它们打印到控制台窗口。
- en: 'Add the `BreakIteration()` method:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `BreakIteration()` 方法：
- en: '[PRE63]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This method iterates `20` times. A check is made upon each iteration. If the
    value is less than `15`, the result is yielded and the variable is incremented.
    Otherwise, the iteration is exited.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法迭代 `20` 次。每次迭代都会进行检查。如果值小于 `15`，则产生结果并增加变量。否则，退出迭代。
- en: 'Add the `DoBreakIteration()` method:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `DoBreakIteration()` 方法：
- en: '[PRE64]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `DoBeakIteration()` method iterates through `BreakIteraton()` and writes
    the value to the console window.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoBeakIteration()` 方法遍历 `BreakIteraton()` 并将值写入控制台窗口。'
- en: 'In the `Program` class, add a method called `Yield()`, and call it from your
    `Main` method:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类中，添加一个名为`Yield()`的方法，并在你的`Main`方法中调用它：
- en: '[PRE65]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This method runs our `yield` keyword examples. Do a debug build and step through
    the code so that you can see how it behaves. You will see that each time the `yield`
    keyword is encountered, it returns to the calling method. Then, it continues the
    iteration from where it left off.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法运行我们的`yield`关键字示例。进行调试构建并逐步执行代码，以便你可以看到它的行为。你会看到每次遇到`yield`关键字时，它都会返回到调用方法。然后，它从上次离开的地方继续迭代。
- en: 'Now, let''s add our benchmarking to test the performance of the `yield` keyword.
    Add the `GetValues()` method:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加基准测试来测试`yield`关键字的性能。添加`GetValues()`方法：
- en: '[PRE66]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This method creates a collection of `long` values using a generic `List`. It
    iterates 1 million items and adds them to the collection. Once complete, the collection
    is returned to the caller as an `IEnumerable<long>` collection.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用泛型`List`创建一个`long`值的集合。它迭代1百万个项并将它们添加到集合中。一旦完成，集合作为`IEnumerable<long>`集合返回给调用者。
- en: 'Add the `GetValuesYield()` method:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GetValuesYield()`方法：
- en: '[PRE67]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This method iterates through 1 million items and returns a collection of `IEnumerable<long>`.
    The iteration uses the `yield` keyword, so each iteration is returned to the caller.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历1百万个项，并返回一个`IEnumerable<long>`集合。迭代使用`yield`关键字，因此每次迭代都会返回给调用者。
- en: 'Add the `GetValuesBenchmark()` method:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GetValuesBenchmark()`方法：
- en: '[PRE68]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This method benchmarks the `GetValues()` method.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法对`GetValues()`方法进行基准测试。
- en: 'Add the `GetValuesYieldBenchmark()` method:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GetValuesYieldBenchmark()`方法：
- en: '[PRE69]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This method benchmarks the `GetValuesYield()` method.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法对`GetValuesYield()`方法进行基准测试。
- en: 'Replace the code in the `Main` method in the `Program` class with the following
    line of code:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Program`类中的`Main`方法中的代码替换为以下行代码：
- en: '[PRE70]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This line of code runs our benchmarks. Do a release build and then run the
    executable from the command line. You should see the following summary report:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码运行我们的基准测试。进行发布构建，然后从命令行运行可执行文件。你应该会看到以下摘要报告：
- en: '![Figure 6.8 – The BenchmarkDotNet summary report showing the performance benefits
    of using the yield keyword'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 – BenchmarkDotNet摘要报告显示了使用`yield`关键字的性能优势'
- en: '](img/B16617_Figure_6.8.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_6.8.jpg)'
- en: Figure 6.8 – The BenchmarkDotNet summary report showing the performance benefits
    of using the yield keyword
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – BenchmarkDotNet摘要报告显示了使用`yield`关键字的性能优势
- en: As you can see from the report, building a list of 1 million `long` values is
    much slower compared to using the `yield` keyword. The `yield` keyword significantly
    speeds up how collections are processed. That's a 13,102,611.27 ns / 14.50 ns
    = 903,628.26 times increase in performance! So, you can see that the use of the
    `yield` keyword is very beneficial to the performance of your computer programs.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如报告所示，构建包含1百万个`long`值的列表比使用`yield`关键字慢得多。`yield`关键字显著提高了集合的处理速度。这相当于性能提高了13,102,611.27
    ns / 14.50 ns = 903,628.26倍！所以，你可以看到使用`yield`关键字对你的计算机程序的性能是非常有益的。
- en: In the next section, we will look at the difference between concurrency and
    parallelism and the effects they have on performance.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨并发和并行之间的区别以及它们对性能的影响。
- en: Learning the difference between concurrency and parallelism
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习并发和并行之间的区别
- en: Concurrency and parallelism are often mistaken for the same thing, but they
    are different. Concurrency does many tasks at the same time using multi-threading.
    Multi-threading allots time to various threads based on time/context switching.
    This presents the illusion that the computer is doing multiple things at the same
    time. But it is, in reality, only doing one thing. Parallelism, on the other hand,
    does many things all at the same time.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行经常被误认为是同一件事，但它们是不同的。并发使用多线程同时执行许多任务。多线程根据时间/上下文切换为各种线程分配时间。这给人一种计算机同时在做很多事情的错觉。但实际上，它只做了一件事。另一方面，并行性同时做很多事情。
- en: Concurrency is used to manage multiple computations simultaneously. It accomplishes
    this using interleaving operations. The benefit of concurrency is that it increases
    the amount of work that can be completed over time. It uses context switching
    to perform interleaving operations. Concurrency can work with a single processor.
    You are already aware of concurrency at work, as you will have had multiple applications
    running at the same time. All these programs are making use of concurrency.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 并发用于同时管理多个计算。它通过交错操作来实现这一点。并发的优点是增加了在一段时间内可以完成的工作量。它使用上下文切换来执行交错操作。并发可以与单个处理器一起工作。你已经了解并发在工作中的应用，因为你可能已经同时运行了多个应用程序。所有这些程序都在使用并发。
- en: The main usage of concurrency is to have usable applications that are non-blocking.
    For example, if you have an application that performs a long-running operation,
    this operation can be run on a background thread to allow the user to still use
    the application and get work done. So, concurrency is not necessarily about performance
    – it is more about not blocking your users from being able to do what they intend
    with your application.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '并发的主要用途是拥有非阻塞的可用应用程序。例如，如果你有一个执行长时间运行操作的应用程序，这个操作可以在后台线程上运行，以便用户仍然可以使用该应用程序并完成工作。因此，并发不一定关乎性能——它更多的是关于不让用户在使用你的应用程序时受阻。 '
- en: Parallelism performs multiple computations at the same time in parallel to each
    other. To accomplish parallelism, multiple processors are required. The benefit
    of using parallelism is increased computational processing speed. Running document
    crawlers over a cluster and performing parallel queries and big data are examples
    of using parallelism.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化在彼此之间并行执行多个计算。为了实现并行化，需要多个处理器。使用并行化的好处是提高了计算处理速度。在集群上运行文档爬虫和执行并行查询以及大数据都是使用并行化的例子。
- en: The main goal of parallelism is performance. In other words, the intention of
    using parallelism is to complete an operation in the shortest amount of time.
    An example of parallelism in use would be data-intensive number crunching for
    report generation.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化的主要目标是性能。换句话说，使用并行的目的是在最短的时间内完成操作。并行化使用的一个例子是对报告生成进行数据密集型数值计算。
- en: You should never mix concurrency with performance. If you do, your design will
    either be bad or over-engineered. So, if you want user interfaces to be non-blocking,
    use concurrency. However, if you want non-UI tasks to complete in the shortest
    possible time, use parallelism. Later in this book, we will devote whole chapters
    to concurrency, parallelism, and asynchronous processing. But for now, let's turn
    our attention to the difference between `Equals()` and `==`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该将并发与性能混合使用。如果你这样做，你的设计要么是糟糕的，要么是过度设计的。所以，如果你想用户界面非阻塞，使用并发。然而，如果你想非UI任务尽可能快地完成，使用并行化。在本书的后续章节中，我们将专门讨论并发、并行化和异步处理。但就目前而言，让我们将注意力转向`Equals()`和`==`之间的区别。
- en: Learning the difference between Equals() and ==
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习`Equals()`和`==`之间的区别
- en: The `==` operator compares object references, known as shallow comparison, while
    the `Equals()` method compares object content, known as deep comparison. Both
    the operator and the method can be overloaded.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符比较对象引用，称为浅比较，而`Equals()`方法比较对象内容，称为深比较。这两个运算符和方法都可以被重载。'
- en: Note
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you overload the `==` operator, then you should overload the `Equals()` method
    and vice versa.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重载了`==`运算符，那么你应该重载`Equals()`方法，反之亦然。
- en: 'The `==` operator returns `true` in the following situations:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，`==`运算符返回`true`：
- en: '`Value Type Value == Value Type Value`'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Value Type Value == Value Type Value`'
- en: '`Reference Type Instance == Reference Type Instance`'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reference Type Instance == Reference Type Instance`'
- en: '`String == String`'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String == String`'
- en: 'The `Equals()` method returns `true` in the following situations:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，`Equals()`方法返回`true`：
- en: '`ReferenceType.Equals(ReferenceType)` both refer to the same object reference'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceType.Equals(ReferenceType)`都指向相同的对象引用'
- en: '`ValueType.Equals(ValueType)` are both the same type and have the same value'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueType.Equals(ValueType)`都是同一类型且具有相同的值'
- en: 'Now, let''s add a new class called `Equality` to the root of the *CH06_Collections*
    project to demonstrate the difference in performance between the `==` operator
    and the `Equals()` method. Let''s get started:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向*CH06_Collections*项目的根目录添加一个名为`Equality`的新类，以演示`==`运算符和`Equals()`方法之间的性能差异。让我们开始吧：
- en: 'Add the `Equality` class, as follows:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Equality`类，如下所示：
- en: '[PRE71]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With that, our class has been configured to perform benchmarking.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的类已经配置好以执行基准测试。
- en: 'Add the following code to the top of the class:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类的顶部：
- en: '[PRE72]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we have our value types, reference types, and string types in place that
    will have their equality tested.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经准备好了我们的值类型、引用类型和字符串类型，它们将进行相等性测试。
- en: 'Now, add the `GlobalSetup()` method:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `GlobalSetup()` 方法：
- en: '[PRE73]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This method assigns our variables in preparation for our equality benchmarks.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法分配我们的变量，为我们的相等性基准测试做准备。
- en: 'Add the `ValueOperatorValue()` method:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ValueOperatorValue()` 方法：
- en: '[PRE74]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `ValueOperatorValue()` method benchmarks the equality checking of two values
    using the `equality` operator.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueOperatorValue()` 方法使用 `equality` 运算符对两个值进行相等性检查的基准测试。'
- en: 'Add the `ValueEqualsValue()` method:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ValueEqualsValue()` 方法：
- en: '[PRE75]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `ValueEqualsValue()` method benchmarks the equality checking of two values
    using the `Equals(value)` method.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueEqualsValue()` 方法使用 `Equals(value)` 方法对两个值进行相等性检查的基准测试。'
- en: 'Add the `ReferenceOperatorReference()` method:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReferenceOperatorReference()` 方法：
- en: '[PRE76]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `ReferenceOperatorReference()` method benchmarks the equality checking of
    two reference values using the equality operator.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReferenceOperatorReference()` 方法使用相等运算符对两个引用值进行相等性检查的基准测试。'
- en: 'Add the `ReferenceEqualsReference()` method:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReferenceEqualsReference()` 方法：
- en: '[PRE77]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `ReferenceEqualsReference()` method benchmarks the equality checking of
    two values using the `Equals(reference)` method.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReferenceEqualsReference()` 方法使用 `Equals(reference)` 方法对两个值进行相等性检查的基准测试。'
- en: 'Add the `StringOperatorString()` method:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `StringOperatorString()` 方法：
- en: '[PRE78]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `StringOperatorString()` method benchmarks the equality testing of two strings
    using the `==` operator.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringOperatorString()` 方法使用 `==` 运算符对两个字符串进行相等性测试的基准测试。'
- en: 'Next, add the `StringEqualsString()` method:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `StringEqualsString()` 方法：
- en: '[PRE79]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `StringEqualsString()` method benchmarks the equality testing of two strings
    using the `Equals()` method.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringEqualsString()` 方法使用 `Equals()` 方法对两个字符串进行相等性测试的基准测试。'
- en: 'Add `BenchmarkRunner.Run<Equality>();` to the `Main` method of the `Program`
    class, do a `Release` build, and then run your executable from the command line.
    You should end up with the following benchmark report:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BenchmarkRunner.Run<Equality>();` 添加到 `Program` 类的 `Main` 方法中，进行 `Release`
    构建并从命令行运行您的可执行文件。你应该会得到以下基准测试报告：
- en: '![Figure 6.9 – The BenchmarkDotNet summary report for various equality checks'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.9 – BenchmarkDotNet 对各种相等性检查的总结报告'
- en: '](img/B16617_Figure_6.9.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_6.9.jpg)'
- en: Figure 6.9 – The BenchmarkDotNet summary report for various equality checks
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – BenchmarkDotNet 对各种相等性检查的总结报告
- en: As we can see, it is quicker to test value type equality using the `==` operator,
    quicker to use the `==` operator to test reference type equality, and quicker
    to use `Equals(string)` when comparing strings.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 `==` 运算符测试值类型相等性更快，使用 `==` 运算符测试引用类型相等性更快，而在比较字符串时使用 `Equals(string)`
    更快。
- en: With that, we have completed this chapter. But before we move on to [*Chapter
    7*](B16617_07_Final_SB_Epub.xhtml#_idTextAnchor139), *LINQ Performance*, let's
    summarize what we have learned in this chapter.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了这一章。但在我们继续进入 [*第 7 章*](B16617_07_Final_SB_Epub.xhtml#_idTextAnchor139)，*LINQ
    性能* 之前，让我们总结一下本章学到的内容。
- en: Summary
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the different types of collections and their
    usage. We saw that we should prefer using generic collections over non-generic
    collections. Then, we briefly touched on Big O Notation and how to use it to determine
    algorithmic efficiency. After that, we looked at choosing the right type of collection
    for what we needed.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了不同类型集合及其用法。我们了解到应该优先使用泛型集合而非非泛型集合。然后，我们简要介绍了大 O 表示法及其如何用于确定算法效率。之后，我们探讨了根据需要选择合适的集合类型。
- en: After that, we set up a sample database to test the querying and iteration of
    data using further on in the chapter. Then, we looked at how to choose between
    using interfaces and concrete classes and choosing between arrays and collections.
    Next, we looked at indexers and then moved on to look at `IEnumerable<T>`, `IEnumerator<T>`,
    and `IQueryable<T>` and their performance.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们设置了一个示例数据库来测试本章后面部分的数据查询和迭代。然后，我们探讨了如何选择使用接口和具体类，以及选择使用数组还是集合。接下来，我们看了索引器，然后转向查看
    `IEnumerable<T>`、`IEnumerator<T>` 和 `IQueryable<T>` 及其性能。
- en: The next topic we looked at was using the `yield` keyword. We touched on the
    differences between concurrency and parallelism and mentioned that these will
    be looked at in more depth in later chapters. Finally, we looked at the difference
    between the `==` operator and the `Equals()` method in terms of performance.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来探讨的是使用`yield`关键字。我们讨论了并发和并行之间的差异，并提到这些将在后面的章节中更深入地探讨。最后，我们探讨了在性能方面`==`运算符和`Equals()`方法之间的差异。
- en: In the next chapter, we will be looking at LINQ performance. But for now, see
    if you can answer the following questions, and check out the *Further reading*
    section to solidify what you have learned in this chapter.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨LINQ的性能。但到目前为止，尝试回答以下问题，并查看“进一步阅读”部分以巩固本章所学内容。
- en: Questions
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: List the different namespace collections.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出不同的命名空间集合。
- en: What is Big O notation used for?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大O表示法用于什么？
- en: What does algorithmic efficiency measure?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法效率衡量的是什么？
- en: Is it preferable to use `IList<T>` or `List<T>` in terms of instantiation speed?
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例化速度方面，使用`IList<T>`还是`List<T>`更可取？
- en: Should we use collections or arrays?
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用集合还是数组？
- en: What does an indexer do?
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引器的作用是什么？
- en: Which method of iteration is fastest on an in-memory collection between `IEnumerable<T>`
    and `IEnumerator<T>`?
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IEnumerable<T>`和`IEnumerator<T>`之间，哪种迭代方法在内存集合中速度最快？
- en: In terms of memory and speed performance, what database query method performs
    best?
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内存和速度性能方面，哪种数据库查询方法表现最佳？
- en: When building a collection using iteration, what is the quickest way to build
    the collection up and return the results?
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用迭代构建集合时，最快的方式是构建集合并返回结果是什么？
- en: Further reading
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及主题的信息，请查看以下资源：
- en: '*Indexers*: [https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/](https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/).'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*索引器*: [https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/](https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/).'
- en: '*ConsoleSecrets*: [https://github.com/jasonshave/ConsoleSecrets](https://github.com/jasonshave/ConsoleSecrets).'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ConsoleSecrets*: [https://github.com/jasonshave/ConsoleSecrets](https://github.com/jasonshave/ConsoleSecrets).'
- en: '*Equality Operators*: [https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators](https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators).'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等式运算符*: [https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators](https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators).'
- en: '*Interesting Performance Implications of C# 9 Records Equality Check*: [https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919](https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919).'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C# 9记录等性检查的有趣性能影响*: [https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919](https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919).'
- en: '*Improving Struct Equality Performance in C#:* [http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C](http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C).'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*改进C#中结构体等性性能*: [http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C](http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C).'
- en: '*String Equality and Performance in C#:* [https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/](https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/).'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中的字符串等性和性能*: [https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/](https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/).'
- en: '*Performance Implications of Default Struct Equality in C#:* [https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/](https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/).'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中默认结构体等性的性能影响*: [https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/](https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/).'
- en: '*Performance Best Practices in C#:* [https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a](https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a).'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中的性能最佳实践*: [https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a](https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a).'
- en: '*8 Techniques to Avoid GC Pressure and Improve Performance in C# .NET*: [https://michaelscodingspot.com/avoid-gc-pressure/](https://michaelscodingspot.com/avoid-gc-pressure/).'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*8 技巧避免 C# .NET 中的 GC 压力并提高性能*: [https://michaelscodingspot.com/avoid-gc-pressure/](https://michaelscodingspot.com/avoid-gc-pressure/).'
