- en: The Containerization of Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter focused on several advanced topics to do with building
    web services using ASP.NET Core. This chapter offers a quick introduction to containers
    and how they can be useful for running your application locally in a sandbox environment.
    This chapter is not designed to cover everything about containers; rather, it's
    more of a brief introduction to them. We will learn how to run the catalog service
    on containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run the catalog service on Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of .NET Core Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, distributed systems form the base of every application. In turn, the
    foundation of distributed systems is containers. The goal of containerization
    is to run resources in an isolated environment. Containers define boundaries and
    the separation of concerns between the components of a distributed system. This
    separation of concerns is a way for us to reuse containers by providing parameterized
    configurations. Another important feature of web services and web applications
    is *scalability*. It should be easy to scale up your containers and create new
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a tool that is designed to create, run, and deploy applications using
    containers. Docker is also referred to as a platform that promotes this technology.
    Over the last few years, Docker has become somewhat of a buzzword, and it has
    been adopted by a considerable number of companies, start-ups, and open source
    projects. Various projects are associated with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, let's talk about **Moby** ([https://github.com/moby/moby](https://github.com/moby/moby)),
    which is an open source project created by Docker. As a large number of people
    and communities started to contribute to the project, Docker decided to develop
    Moby. All contributions to the Moby project, which can be considered as a sort
    of research and development department of Docker, are open source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moby is a framework that is used to build specific container systems. It provides
    a library of components that are the fundamentals of a container system:'
  prefs: []
  type: TYPE_NORMAL
- en: OS and container runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also provides the tools that are necessary to build up these components to
    create a runnable artifact for each platform and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: If we are looking for more downstream solutions, we have the Docker **Community
    Edition** (**CE**) and Docker **Enterprise Edition** (**EE**) versions, which
    are products that use the Moby project. Docker CE is used by small teams and developers
    to build their system, while business customers use Docker EE. Both are recommended
    solutions allowing us to use containerization in development and enterprise environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will use Docker CE to containerize the catalog service. Docker
    CE and Docker EE are available on the Docker website: [https://www.docker.com/](https://www.docker.com/).
    You can download and install the Community Edition by following the steps provided
    at [https://www.docker.com/get-started](https://www.docker.com/get-started).'
  prefs: []
  type: TYPE_NORMAL
- en: Docker terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before setting up our service to use Docker, let's take a quick look at the
    terminology behind this technology.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by defining a container image, which is the list of all dependencies
    and artifacts needed to create a container instance. The term *container image*
    should not be confused with the term *container instance*, which refers to a single
    instance of a container image*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'A core part of a container image is the Dockerfile. The Dockerfile provides
    the instructions to build a container. For example, in the case of a container
    that runs a .NET Core solution, it gives the commands to restore the packages
    and build the solution. Docker also provides a way to tag the container images
    and group them all in collections known as **repositories**. Repositories are
    usually covered by a registry, which allows access to a specific repository. The
    repositories can be public or private, depending on what they are used for. For
    example, a private company can use a private repository to provide different versions
    of containers to internal teams. This centralized way of thinking is powerful,
    and it gives us a way to reuse containers. The main example of a public repository
    is [https://hub.docker.com/](https://hub.docker.com/), which is the world''s most
    extensive library that provides container images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3f3196b-bd1e-44b6-b602-8c37057cdda5.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram describes a typical interaction between the components
    we described in this section. The client usually provides some Docker commands
    that are parsed and executed in the **Docker HOST**. The **Docker HOST**contains
    both of the *containers* we are running on the local machine and the images used
    by those containers. The images are usually taken by a Docker public or private
    registry, which is generally to the Docker Hub website or a private company repository.
  prefs: []
  type: TYPE_NORMAL
- en: Another essential term to do with Docker is the compose tool. The compose tool
    is used for defining and running a multi-container application or service. A composer
    is usually combined with a definition file in a different format, such as a YAML
    file that defines the structure of the container group.
  prefs: []
  type: TYPE_NORMAL
- en: The compose tool usually runs using the `docker-compose` CLI command. In this
    chapter, we will use the `docker-compose` command to get our service running in
    the local environment.
  prefs: []
  type: TYPE_NORMAL
- en: An essential part of a container system is the *orchestrator*. An *orchestrator*
    simplifies the use of a multi-container system. Moreover, orchestrators are usually
    applied to complex systems. Examples of container orchestrators include Kubernetes,
    Azure Service Fabric, and Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: This book will not cover the use of orchestrators. This chapter gives a high-level
    overview of the capabilities of Docker and, more generally, containerization.
    More complex topics to do with Docker require DevOps and system engineering skills.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to look at the power of containerization and how to use it to
    build our applications and services quickly. The next section will apply container
    principles to the catalog service built in the previous chapter. The following
    section will also use container technologies extensively to get our examples up
    and running.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker to run the catalog service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section explains how to combine our catalog service with Docker to get
    it running locally. Let''s start by examining the systems behind the catalog service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70b28f16-f147-46c6-9efd-3a732844e21c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding diagram, the web service part runs over the
    `microsoft/dotnet` Docker image, and the data source part runs over the Microsoft
    SQL Server instance using the `microsoft/mssql-server-linux` Docker image (we
    already dealt with the containerization of MSSQL in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    *Building the Data Access Layer*). Both of the images are downloaded from the
    public Microsoft repository already present in Docker Hub; let's take a look at
    how to use `docker-compose` to define the whole infrastructure of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a `docker-compose.yml` file with the following
    content in the root folder of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding file uses the YAML syntax to define two containers. The first
    is the `catalog_api` container: it will be used to host the core part of the service
    built on top of the ASP.NET Core framework. The second container is `catalog_db`,
    which uses a `microsoft/mssql-server-linux` image (the same that we used in [Chapter
    8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building the Data Access Layer*)
    to set up the MSSQL database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we should proceed by creating the following folder structure in
    the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding folders will contain the files related to the API and the database
    containers specified in the `docker-compose.yml` file. Let''s continue by examining
    the definition of the `catalog_api` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet of code specifies the current folder as the build context
    and the `containers/api/Dockerfile` file to build the Docker image. It also refers
    to an environment variables file by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it declares the container under a network called `my_network` and exposes
    port `5000` to the hosting system using the `ports:` directive.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, the `catalog_db` container declares the same network defined
    for the `catalog_api` container, and it specifies a different environment variables
    file using the same approach as seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `docker-compose.yml` file, there is the definition of `my_network`,
    which uses a bridge driver. The bridge driver is the default option for the network.
    Two containers under the same bridge network can share traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the types of drivers provided out of the box, refer
    to the following link: [https://docs.docker.com/network/](https://docs.docker.com/network/).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker provides a lot of ways to specify the environment variables of a container.
    In the `docker-compose.yml` file specified earlier; we use the `env_file` approach.
    Furthermore, we can proceed by creating the `api/api.env` file in the corresponding
    path specified in the definition of the `catalog_api` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The file syntax expects each line in the file to be in the following format:
    `VAR=VAL`. In the preceding case, we are defining the environment variables used
    by ASP.NET Core to run the service: the `ASPNETCORE_URLS` variable specifies the
    URLs used by the web service and `ASPNETCORE_ENVIRONMENT` specifies the environment
    name used by the application. In the same way, we should also proceed by defining
    the `db/db.env` file in the corresponding folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the file defines the corresponding variables for the SQL Server
    container: `SA_PASSWORD` specifies the system administrator account password,
    the `ACCEPT_EULA` needed by the startup process of SQL Server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, `docker-compose` supports declaring default environment
    variables in the `.env` file. The file must be placed in the same directory as
    the `docker-compose.yml` file. The file contains some simple rules for defining
    environment variables. Let''s create a new `.env` file in the root folder of the
    catalog service directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `COMPOSE_PROJECT_NAME` variable is a reserved variable of the `docker-compose`
    command provided by Docker. It specifies the project name to use to run the containers.
    Therefore, both the `catalog_api` and `catalog_db` containers will run under the
    same project, called `store`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s proceed by describing the Dockerfile of our compose project. As mentioned
    previously, the Dockerfile is a simple text file that contains the commands a
    user could call to assemble an image. Let''s examine a possible definition of
    the Dockerfile contained in the `containers/api/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines specific steps to build the Docker image. The `FROM` directive
    refers to the base image to use during the build process. This directive is mandatory,
    and it must be the first instruction of the file. The `COPY` directive copies
    the project into the `/app` folder, and the `WORKDIR` command sets the `/app`
    folder as the default working directory. After that, the build script proceeds
    by executing the `dotnet restore` and `dotnet build` commands. Finally, the Dockerfile
    adds the `/root/.dotnet/tools` path inside the `PATH` variable and executes the
    `containers/api/entrypoint.sh` Bash file, which has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `entrypoint.sh` entry point file is stored on the same level as the Dockerfile.
    It runs the main project of the catalog service by performing the `dotnet run`
    command and, once the database container is ready, it proceeds by executing the
    `dotnet ef database update` command to create the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the docker-compose command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the catalog service locally, we must complete the compose process from
    the CLI using the `docker-compose` command. It is possible to get an overview
    of the commands by running `docker-compose --help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main commands related to the composition of a multi-container application
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose build`: This builds the services. It executes the build using
    the Dockerfile associated with the images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose images`: This lists the current container images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose up`: This creates and runs the containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose config`: This validates and views the `docker-compose.yml`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can proceed by running the catalog service using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By specifying the `--build` flag, it is possible to trigger the build before
    running the containers. Once the build is made, we can just run the `docker-compose
    up` command until our code changes and we need to rebuild the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we are now able to run our service using containers, the build and
    run process is not optimized: we are copying all of the files in the solution
    into the container; on top of that, we are running the container using the whole
    SDK of .NET Core, which is not needed if we want to run the project. In the next
    section, we will see how to optimize the containerization process to be more lightweight.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft provides different Docker images to run ASP.NET Core, and, in general,
    .NET Core applications using Docker. It is essential to understand that a container
    that executes an ASP.NET Core service doesn't need to provide the SDK as well.
  prefs: []
  type: TYPE_NORMAL
- en: This section presents an overview of the different Docker images available on
    Docker Hub and how to optimize our deployment using proper Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of different Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microsoft provides various images, depending on what it is you''re trying to
    achieve with your application. Let''s take a look at the different Docker images
    supplied in the `microsoft/dotnet` repository in Docker Hub ([https://hub.docker.com/u/microsoft/](https://hub.docker.com/r/microsoft/dotnet/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Image** | **Description** | **Size** |'
  prefs: []
  type: TYPE_TB
- en: '| `mcr.microsoft.com/dotnet/core/sdk:3.1` | This image contains the whole SDK
    of .NET Core. It provides all of the tools to develop, run, and build your application.
    It is possible to use development commands such as `dotnet run`, `dotnet ef`,
    and the whole set of commands provided by the SDK. | 690 MB |'
  prefs: []
  type: TYPE_TB
- en: '| `mcr.microsoft.com/dotnet/core/runtime:3.1` | This image contains the .NET
    Core runtime. It provides a way to run .NET Core applications, such as console
    applications. Since the image contains only the runtime, it is not possible to
    build the application. The image exposes only the runtime CLI command, `dotnet`.
    | 190 MB |'
  prefs: []
  type: TYPE_TB
- en: '| `mcr.microsoft.com/dotnet/core/aspnet:3.1` | This image contains the .NET
    Core runtime and the ASP.NET Core runtime. It is possible to execute both the
    .NET Core application and the ASP.NET Core application. As a runtime image, it
    is not possible to build the application. | 205 MB |'
  prefs: []
  type: TYPE_TB
- en: '| `mcr.microsoft.com/dotnet/core/runtime-deps:3.1` | This image is a very light
    one. It contains only the lower-level dependencies ([https://github.com/dotnet/core/blob/master/Documentation/prereqs.md](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md))
    that .NET Core needs to run. It doesn''t contain the .NET Core runtime or the
    ASP.NET Core runtime. It is designed for self-hosted applications. | 110 MB |'
  prefs: []
  type: TYPE_TB
- en: 'Docker images are usually available in three modes: *debian:stretch-slim*,
    *ubuntu:bionic*, and *alpine*, depending on the OS the image runs on. By default,
    images run on the DebianOS. It is possible, however, to use another OS, such as
    *Alpine*, to save some storage. For example, Alpine-based images reduce the size
    of the `aspnetcore-runtime` image from ~260 MB to ~160 MB.'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage builds on the catalog service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's apply the concept of a *multi-stage* build to the previously defined Docker
    image. Multi-stage builds are a new feature that requires Docker 17.05 or higher.
    Multi-stage builds are useful for anyone who has struggled to optimize Dockerfiles
    while keeping them easy to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how it is possible to apply the multi-stage build process by
    taking a look at the catalog service Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously defined file can be changed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the Dockerfile now executes three different steps (the first
    two steps are described together because they use the same Docker image):'
  prefs: []
  type: TYPE_NORMAL
- en: The `builder` step uses the `mcr.microsoft.com/dotnet/core/sdk` image to copy
    the files and trigger the build of the project using the `dotnet build` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `publish` step uses the same image to trigger the `dotnet publish` command
    for the `Catalog.API` project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `final` step, as the name suggests, executes the published package in the
    runtime environment using the `mcr.microsoft.com/dotnet/core/aspnet:3.1` image.
    Finally, it runs the service using the `ENTRYPOINT` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that this change optimizes the resulting image produced
    by the Dockerfile. After this change, we don't need the `entrypoint.sh` file anymore
    because the Dockerfile directly triggers the execution of the service using the
    `dotnet Catalog.API.dll` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a multi-stage build approach, we should also notice that we cannot trigger
    the execution of the database migrations because the runtime Docker image doesn''t
    use the **Entity Framework Core** (**EF Core**) tools. Consequently, we need to
    find another way to trigger the migrations. One possible option is to unleash
    the migrations from the `Startup` file of our service. Furthermore, EF Core provides
    a way to apply migrations at runtime by using the following syntax in the `Configure`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code ensures the execution of the database migrations through
    the execution of the `app.ApplicationServices.GetService<CatalogContext>().Database.Migrate()`
    instruction. Because of the startup times of the `msssql` container, we need to
    implement a retry policy by handling `SqlException` and retrying with an exponential
    time approach. The preceding implementation uses `Polly` to define and execute
    a retry policy. Furthermore, we need to add the `Polly` dependency by executing
    the following command in the `Catalog.API` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Retry policies are really useful in the distributed systems world, to successfully
    handle failure. `Polly` and the implementation of resilience policies in a web
    service will be discussed in the next chapter as part of communication over HTTP
    between multiple services.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world application, it is quite unusual to execute migrations during
    the deployment phase of the service. The database schema rarely changes, and it
    is essential to separate the implementations related to the service with the changes
    made in the database schema. For demonstration reasons, we are executing the migrations
    of the database in every deployment by overwriting the database changes to take
    the most straightforward approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided a quick overview of the capabilities of Docker
    and how to use it to improve isolation, maintainability, and service reliability.
    We looked at the different Docker images supplied by Microsoft and how to use
    them combined with a multi-step build approach.
  prefs: []
  type: TYPE_NORMAL
- en: The topics covered in this chapter provide an easy way to run our service locally,
    in an isolated environment, and spread the same environment configuration into
    staging and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to improve our knowledge of how to share information
    between multiple services. We will also explore some patterns to do with multi-service
    systems. The concepts related to Docker that we explored in this chapter will
    also be used in the next chapter to provide a smooth deployment experience.
  prefs: []
  type: TYPE_NORMAL
