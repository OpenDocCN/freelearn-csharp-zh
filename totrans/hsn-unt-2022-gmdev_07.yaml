- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Physics Collisions and Health System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理碰撞和健康系统
- en: As games try to simulate real-world behaviors, one important aspect to simulate
    is physics, which dictates how objects move and how they collide with each other,
    such as in the collision of players and walls, or bullets and enemies. Physics
    can be difficult to control due to the myriad of reactions that can happen after
    a collision, so we will learn how to properly configure our game to create physics
    as accurately as we can. This will generate the desired arcade movement feeling
    but get realistic collisions working—after all, sometimes, real life is not as
    interesting as video games!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着游戏试图模拟现实世界的表现，一个重要的模拟方面是物理，它决定了物体如何移动以及它们如何相互碰撞，例如玩家与墙壁的碰撞，或者子弹与敌人的碰撞。由于碰撞后可能发生的无数反应，物理可能难以控制，因此我们将学习如何正确配置我们的游戏，以尽可能精确地创建物理效果。这将产生期望的街机移动感觉，并使真实的碰撞效果工作——毕竟，有时候，现实生活并不像电子游戏那样有趣！
- en: 'In this chapter, we will examine the following collision concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下碰撞概念：
- en: Configuring physics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置物理
- en: Detecting collisions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: Moving with physics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物理移动
- en: First, we will learn how to properly configure physics, a step needed for the
    collisions between objects to be detected by our scripts, using new Unity events
    that we are also going to learn. All of this is needed in order to detect when
    our bullets touch our enemies and damage them. Then, we are going to discuss the
    difference between moving with `Transform`, as we have done so far, as well as
    moving with Rigidbody and the pros and cons of each version. This will be used
    to experiment with different ways of moving our player and let you decide which
    one you will want to use. Let’s start by discussing physics settings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何正确配置物理设置，这是为了让我们的脚本能够检测到物体之间的碰撞，我们将学习使用新的Unity事件。所有这些都需要，以便检测我们的子弹何时触碰到敌人并对其造成伤害。然后，我们将讨论使用`Transform`移动（这是我们迄今为止所做的那样）和使用Rigidbody移动之间的区别，以及每个版本的优缺点。这将用于尝试不同的移动玩家方式，并让你决定你想要使用哪一种。让我们从讨论物理设置开始。
- en: Configuring physics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置物理
- en: Unity’s physics system is prepared to cover a great range of possible gameplay
    applications, so properly configuring it is important to get the desired result.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理系统已经准备好覆盖广泛的可能的游戏应用，因此正确配置它对于获得期望的结果非常重要。
- en: 'In this section, we will examine the following physics settings concepts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下物理设置概念：
- en: Setting shapes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置形状
- en: Physics object types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理对象类型
- en: Filtering collisions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞过滤
- en: We are going to start by learning about the different kinds of colliders that
    Unity offers, and then learn about different ways to configure those to detect
    different kinds of physics reactions (**collisions** and **triggers**). Finally,
    we will discuss how to ignore collisions between specific objects to prevent situations
    such as the player’s bullets damaging the player.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习Unity提供的不同类型的碰撞体，然后学习不同的配置方法以检测不同类型的物理反应（**碰撞**和**触发器**）。最后，我们将讨论如何忽略特定物体之间的碰撞，以防止玩家子弹损坏玩家的情况。
- en: Setting shapes
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置形状
- en: At the beginning of this book, we learned that objects usually have two shapes,
    the visual shape—which is basically the 3D mesh—and the physical one, the collider—the
    one that the physics system will use to calculate collisions. Remember that the
    idea of this is to allow you to have a highly detailed visual model while having
    a simplified physics shape to increase the performance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我们了解到物体通常有两种形状，一种是视觉形状——基本上是3D网格——另一种是物理形状，即碰撞体——物理系统将使用它来计算碰撞。请记住，这个想法是让你拥有高度详细的可视模型，同时拥有简化的物理形状以提高性能。
- en: 'Unity has several types of colliders, so here we will recap the common ones,
    starting with the primitive types, that is, **Box**, **Sphere**, and **Capsule**.
    These shapes are the cheapest ones (in terms of performance) to detect collisions
    due to the fact that the collisions between them are done via mathematical formulae,
    unlike other colliders such as the **Mesh Collider**, which allows you to use
    any mesh as the physics body of the object, but with a higher performance cost
    and some limitations. The idea is that you should use a primitive type to represent
    your objects or a combination of them, for example, an airplane could be done
    with two Box colliders, one for the body and the other one for the wings. You
    can see an example of this in the following screenshot, where you can see a weapons
    collider made from primitives:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有几种类型的碰撞体，所以在这里我们将回顾常见的几种，从原始类型开始，即**盒子**、**球体**和**胶囊体**。这些形状由于它们之间的碰撞是通过数学公式完成的，因此在性能上是最便宜的（与其他碰撞体如**网格碰撞体**不同，网格碰撞体允许你使用任何网格作为物体的物理体，但性能成本更高，并且有一些限制）。想法是，你应该使用原始类型来表示你的对象或它们的组合，例如，一架飞机可以用两个盒子碰撞体来完成，一个用于机身，另一个用于机翼。你可以在下面的屏幕截图中看到这个例子，其中你可以看到由原始形状制成的武器碰撞体：
- en: '![](img/B18585_07_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_01.png)'
- en: 'Figure 7.1: Compound colliders'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：复合碰撞体
- en: Anyway, this is not always necessary; if we want the weapon to just fall to
    the ground, maybe a Box collider covering the entire weapon can be enough, considering
    those kinds of collisions don’t need to be accurate, thereby increasing performance.
    Also, some shapes cannot be represented even with a combination of primitive shapes,
    such as ramps or pyramids, where your only solution is to use a Mesh collider,
    which asks for a 3D mesh to use for collisions, but we won’t use them in this
    book given their high-performance impact; we will solve all of our physics colliders
    with primitives.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这并不总是必要的；如果我们想让武器直接掉到地上，可能一个覆盖整个武器的盒子碰撞体就足够了，考虑到这类碰撞不需要非常精确，从而提高性能。此外，有些形状即使通过原始形状的组合也无法表示，例如斜坡或金字塔，这时你唯一的解决方案是使用网格碰撞体，它需要一个3D网格用于碰撞，但鉴于其高性能的影响，我们在这本书中不会使用它们；我们将使用原始形状来解决所有的物理碰撞体。
- en: 'Now, let’s add the necessary colliders to our scene to prepare it to calculate
    collisions properly. Consider that if you used an Asset Store environment package
    other than mine, you may already have the scene modules with colliders; I will
    be showing the work I needed to do in my case, but try to extrapolate the main
    ideas here to your scene. To add the colliders, follow these steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向场景中添加必要的碰撞体，以便正确地计算碰撞。考虑到如果你使用了除了我的以外的Asset Store环境包，你可能已经拥有了带有碰撞体的场景模块；我将展示我在我的情况中需要做的工作，但尽量将这里的主要思想应用到你的场景中。要添加碰撞体，请按照以下步骤操作：
- en: Select a wall in the base and check the object and possible child objects for
    collider components; in my case, I have no colliders. If you detect any Mesh collider,
    you can leave it if you want, but I would suggest you remove it and replace it
    with another option in the next step. The idea is to add the collider to it, but
    the problem I detected here is that, due to the fact my wall is not an instance
    of a Prefab, I need to add a collider to every wall in the scene.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基础中选择一个墙壁并检查对象及其可能的子对象是否有碰撞体组件；在我的情况下，我没有碰撞体。如果你检测到任何网格碰撞体，你可以保留它，如果你想要的话，但我建议你在下一步中将其移除并替换为另一个选项。想法是添加碰撞体，但我在这里发现的问题是，由于我的墙壁不是Prefab的实例，我需要为场景中的每个墙壁添加碰撞体。
- en: 'One option is to create a Prefab and replace all of the walls with instances
    of the Prefab (the recommended solution) or to just select all walls in the Hierarchy
    (by clicking them while pressing *Ctrl* or *Cmd* on Mac) and, with them selected,
    use the **Add Component** button to add a collider to all of them. In my case,
    I will use the `Box Collider` component, which will adapt the size of the collider
    to the mesh. If it doesn’t adapt, you can just change the **Size** and **Center**
    properties of the **Box Collider** to cover the entire wall:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个选择是创建一个Prefab并将所有墙壁替换为Prefab的实例（推荐解决方案）或者只是选择层次结构中的所有墙壁（在Mac上按住*Ctrl*或*Cmd*点击它们），然后选择它们，使用**添加组件**按钮为它们添加碰撞体。在我的情况下，我将使用`Box
    Collider`组件，它将调整碰撞体的尺寸以适应网格。如果它没有适应，你只需更改**盒子碰撞体**的**大小**和**中心**属性，以覆盖整个墙壁：
- en: '![](img/B18585_07_02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_02.png)'
- en: 'Figure 7.2: A Box Collider added to a wall'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：添加到墙上的盒子碰撞体
- en: Repeat *steps 1* and *2* for the corners, floor tiles, and any other obstacle
    that will block player and enemy movement.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对角落、地板砖和任何其他会阻挡玩家和敌人移动的障碍物重复*步骤1*和*步骤2*。
- en: Now that we have added the needed colliders to the walls and floor, we can continue
    with the player and enemy. We will be adding the **Capsule Collider** to them,
    the usual collider to use in movable characters due to the fact that the rounded
    bottom will allow the object to smoothly climb ramps. Being horizontally rounded
    allows the object to easily rotate in corners without getting stuck, along with
    other conveniences of that shape. You might want to create an enemy Prefab based
    on one of the characters we downloaded before, so you can add the collider to
    that Prefab. Our player is a simple GameObject in the scene, so you will need
    to add the collider to that one, but consider also creating a Prefab for the player
    for convenience.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为墙壁和地板添加了所需的碰撞器，我们可以继续处理玩家和敌人。我们将为他们添加**胶囊碰撞器**，这是在可移动角色中通常使用的碰撞器，因为其圆形底部将允许物体平滑地爬坡。水平圆形允许物体在角落中轻松旋转而不会卡住，以及其他该形状的便利性。您可能想要基于我们之前下载的角色之一创建一个敌人Prefab，这样您就可以将碰撞器添加到该Prefab中。我们的玩家是场景中的一个简单GameObject，所以您需要将碰撞器添加到那个GameObject上，但考虑也创建一个玩家Prefab以方便使用。
- en: You may be tempted to add several Box colliders to the bones of the character
    to create a realistic shape of the object, and while we can do that to apply different
    damage according to the part of the body where the enemies were shot, we are just
    creating movement colliders; the capsule is enough. In advanced damage systems,
    both capsule and Bone colliders will coexist, one for the movement and the other
    for damage detection; but we will simplify this in our game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想给角色的骨骼添加几个盒子碰撞器以创建物体的逼真形状，虽然我们可以这样做以根据敌人被射击的身体部位施加不同的伤害，但我们只是在创建运动碰撞器；胶囊就足够了。在高级伤害系统中，胶囊和骨骼碰撞器将共存，一个用于运动，另一个用于伤害检测；但我们在游戏中将简化这一点。
- en: 'Also, sometimes the collider won’t adapt well to the visual shape of the object,
    and in my case, the Capsule collider didn’t fit the character very well. I needed
    to fix its shape to match the character by setting its values as shown in the
    following screenshot: **Center** to `0,1,0,` **Radius** to `0.5`, and **Height**
    to `2`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时碰撞器无法很好地适应物体的视觉形状，在我的情况下，胶囊碰撞器与角色并不非常匹配。我需要通过设置以下截图中的值来调整其形状以匹配角色：**中心**设置为`0,1,0,`
    **半径**设置为`0.5`，**高度**设置为`2`：
- en: '![](img/B18585_07_03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_03.png)'
- en: 'Figure 7.3: Character collider'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：角色碰撞器
- en: The bullet we created with the Sphere already had a Sphere collider, but if
    you replaced the mesh of the bullet with another one, you might want to change
    the collider. For now, we don’t need other objects in our game, so now that everything
    has its proper collider, let’s see how to set the different physics settings to
    each object to enable proper collision detection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用球体创建的子弹已经有一个球体碰撞器，但如果您用另一个网格替换子弹的网格，您可能想要更改碰撞器。目前，我们游戏中不需要其他对象，所以现在所有对象都已经有了合适的碰撞器，让我们看看如何为每个对象设置不同的物理设置以启用适当的碰撞检测。
- en: If you check the Terrain’s components, you will see that it has its own kind
    of collider, the **Terrain Collider**. For Terrains, that’s the only collider
    to use.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查地形组件，您会看到它有自己的碰撞器类型，即**地形碰撞器**。对于地形，这是唯一要使用的碰撞器。
- en: Physics object types
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理对象类型
- en: 'Now that we have added colliders to every object by making the objects have
    a presence in the physics simulation, it is time to configure them to have the
    exact physics behavior we want. We have a myriad of possible combinations of settings,
    but we will discuss a set of common profiles that cover most situations. Remember,
    besides colliders, we saw the Rigidbody component at the beginning of this book,
    which is the one that applies physics to the object. The following profiles are
    done with a combination of colliders and Rigidbody settings:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过使对象在物理模拟中具有存在感为每个对象添加了碰撞器，是时候配置它们以获得我们想要的精确物理行为。我们有无数可能的设置组合，但我们将讨论一组常见的配置文件，这些配置文件涵盖了大多数情况。记住，除了碰撞器之外，我们在本书的开头看到了Rigidbody组件，它是将物理应用于对象的那一个。以下配置文件是通过结合碰撞器和Rigidbody设置完成的：
- en: '**Static Collider**: As the name suggests, this kind of collider is not supposed
    to move, aside from some specific exceptions. Most of the environment objects
    fall into this category, such as walls, floors, obstacles, and the terrain. These
    kinds of colliders are just colliders with no `Rigidbody` component, so they have
    a presence in the physics simulation but don’t have any physics applied to them;
    they cannot be moved by other objects’ collisions, they won’t have physics, and
    they will be fixed in their position no matter what. Take into account that this
    has nothing to do with the **Static** checkbox at the top-right part of the editor;
    those are for systems we will explore later in several chapters (such as Chapter
    12, Lighting Using the Universal Render Pipeline), so you can have a Static Collider
    with that checkbox unchecked if needed.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态碰撞体**：正如其名所示，这种碰撞体不应该移动，除了某些特定例外。大多数环境对象都属于这一类别，例如墙壁、地板、障碍物和地形。这类碰撞体只是没有`Rigidbody`组件的碰撞体，因此它们存在于物理模拟中，但没有任何物理作用；它们不能被其他对象的碰撞移动，它们不会有物理作用，并且无论发生什么情况，它们的位置都会固定。请注意，这与编辑器右上角的**静态**复选框无关；那些是我们在后续章节中将要探索的系统（例如第12章，使用通用渲染管道进行照明），因此如果需要，您可以将静态碰撞体与该复选框未选中。'
- en: '**Physics Collider**: These are colliders with a `Rigidbody` component, like
    the example of the falling ball we did in the first part of this book. These are
    fully physics-driven objects that have gravity and can be moved through forces;
    other objects can push them and they perform every other physics reaction you
    can expect. You can use this for the player, grenade movement, falling crates,
    or in all objects in heavily physics-based games such as *The Incredible Machine*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理碰撞体**：这些是具有`Rigidbody`组件的碰撞体，就像我们在本书第一部分所做的下落球体的例子。这些是完全由物理驱动的对象，具有重力并且可以通过力移动；其他对象可以推动它们，并且它们会执行您所期望的任何其他物理反应。您可以使用此功能用于玩家、手榴弹移动、下落箱子，或在像*The
    Incredible Machine*这样的高度基于物理的游戏中的所有对象。'
- en: '**Kinematic Collider**: These are colliders that have a `Rigidbody` component
    but have the **Is Kinematic** checkbox checked. These don’t have physics reactions
    to collisions and forces like **Static Colliders**, but they are expected to move,
    allowing **Physics Colliders** to properly handle collisions against them when
    moving. These can be used in objects that need to move using animations or custom
    scripting movements such as moving platforms.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动学碰撞体**：这些是具有`Rigidbody`组件但已勾选**是运动学**复选框的碰撞体。它们不像**静态碰撞体**那样对碰撞和力有物理反应，但它们预期会移动，允许**物理碰撞体**在移动时正确处理与它们的碰撞。这些可以用于需要使用动画或自定义脚本移动的对象，例如移动平台。'
- en: '**Trigger Static Collider**: This is a regular Static Collider but with the
    **Is Trigger** checkbox of the collider checked. The difference is that kinematic
    and physics objects pass through it but by generating a `Trigger` event, an event
    that can be captured via scripting, which tells us that something is inside the
    collider.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发静态碰撞体**：这是一个常规静态碰撞体，但已勾选碰撞体的**是触发**复选框。区别在于运动学和物理对象会穿过它，但通过生成一个`触发`事件，一个可以通过脚本捕获的事件，它告诉我们有东西在碰撞体内部。'
- en: This can be used to create buttons or trigger objects, in areas of the game
    when the player passes through something happening, such as a wave of enemies
    being spawned, a door being opened, or winning the game in case that area is the
    goal of the player. Note that regular Static Colliders won’t generate a trigger
    event when passing through this type because those aren’t supposed to move.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来创建按钮或触发对象，在玩家穿过游戏中的某些事件区域时，例如生成一波敌人、开门或在该区域是玩家的目标时赢得游戏。请注意，常规静态碰撞体在穿过此类类型时不会生成触发事件，因为它们不应该移动。
- en: '**Trigger Kinematic Collider**: Kinematic Colliders don’t generate collisions,
    so they will pass through any other object, but they will generate `Trigger` events,
    so we can react via scripting. This can be used to create moveable power-ups that,
    when touched, disappear and give us points, or bullets that move with custom scripting
    movements and no physics, just straight like our bullets, but damage other objects
    when they touch them.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发运动学碰撞体**：运动学碰撞体不会生成碰撞，因此它们会穿过任何其他对象，但它们会生成`触发`事件，因此我们可以通过脚本进行响应。这可以用来创建可移动的奖励物品，当被触摸时，它们会消失并给我们加分，或者子弹会通过自定义脚本移动，没有物理作用，就像我们的子弹一样，但它们接触其他对象时会造成伤害。'
- en: Of course, other profiles can exist aside from the specified ones to use in
    some games with specific gameplay requirements, but it’s down to you to experiment
    with all possible combinations of physics settings to see whether they are useful
    for your case; the described profiles will cover 99% of cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了指定的配置外，还可以存在其他配置，用于满足某些游戏的具体游戏玩法要求，但具体还是要靠你自己去尝试所有可能的物理设置组合，看看它们是否适用于你的情况；所描述的配置将涵盖99%的情况。
- en: 'To recap the previous scenarios, I leave you with the following table showing
    the reaction of contact between all of the types of colliders. You will find a
    row per each profile that can move; remember that static profiles aren’t supposed
    to move. Each column represents the reaction when they collide with the other
    types, `Nothing` meaning the object will pass through with no effect, `Trigger`
    meaning the object will pass through but raise `Trigger` events, and `Collision`
    meaning that the object won’t be able to pass through the object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾之前的场景，我给你留下以下表格，显示所有类型碰撞器之间的接触反应。每个可以移动的配置都有一个行；请记住，静态配置不应该移动。每一列代表它们与其他类型碰撞时的反应，`无`表示对象将无效果地穿过，`触发器`表示对象将穿过但会引发`触发器`事件，而`碰撞`表示对象将无法穿过另一个对象：
- en: '|  | **Collides with Static** | **Collides with Dynamic** | **Collides with
    Kinematic** | **Collides with Trigger Static** | **Collides with Trigger Kinematic**
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  | **与静态碰撞** | **与动态碰撞** | **与运动学碰撞** | **与触发静态碰撞** | **与触发运动学碰撞** |'
- en: '| Dynamic | Collision | Collision | Collision | Trigger | Trigger |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 动态 | 碰撞 | 碰撞 | 碰撞 | 触发器 | 触发器 |'
- en: '| Kinematic | Nothing | Collision | Nothing | Trigger | Trigger |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 运动学 | 无 | 碰撞 | 无 | 触发器 | 触发器 |'
- en: '| Trigger Kinematic | Trigger | Trigger | Trigger | Trigger | Trigger |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 触发运动学 | 触发器 | 触发器 | 触发器 | 触发器 | 触发器 |'
- en: 'Figure 7.4: Collision Reaction Matrix'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：碰撞反应矩阵
- en: Considering this, let’s start configuring the physics of our scene’s objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们开始配置场景对象的物理属性。
- en: 'The walls, corners, floor tiles, and obstacles should use the Static Collider
    profile, so no `Rigidbody` component on them, and their colliders will have the
    **Is Trigger** checkbox unchecked:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 墙壁、角落、地板砖和障碍物应使用静态碰撞器配置，因此它们上没有`Rigidbody`组件，并且它们的碰撞器将不会勾选**是触发器**复选框：
- en: '![](img/B18585_07_04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_04.png)'
- en: 'Figure 7.5: Configuration for floor tiles; remember the Static checkbox is
    for lighting only'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：地板砖的配置；请记住，静态复选框仅用于照明
- en: 'The player should move and generate collisions against objects, so we need
    it to have a **Dynamic** profile. This profile will generate a funny behavior
    with our current movement script (which I encourage you to test), especially when
    colliding against walls, so it won’t behave as you expected. We will deal with
    this later in this chapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家应移动并生成与对象的碰撞，因此我们需要它具有**动态**配置。此配置将与我们当前的运动脚本（我鼓励你测试）产生有趣的行为，尤其是在与墙壁碰撞时，所以它不会像你预期的那样表现。我们将在本章后面处理这个问题：
- en: '![](img/B18585_07_05.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_05.png)'
- en: 'Figure 7.6: Dynamic settings on the player'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：玩家上的动态设置
- en: 'The `Enemy` Prefab we suggested you create previously will be using the Kinematic
    profile because we will be moving this object with Unity’s AI systems later, so
    we don’t need physics here, and as we want the player to collide against them,
    we need a collision reaction there, so there’s no `Trigger` here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前建议你创建的`Enemy`预制体将使用运动学配置，因为我们将在稍后使用Unity的AI系统移动此对象，所以这里不需要物理效果，并且由于我们希望玩家与之碰撞，我们需要在那里有一个碰撞反应，所以这里没有`触发器`：
- en: '![](img/B18585_07_06.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_06.png)'
- en: 'Figure 7.7: Kinematic setting for the enemy'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：敌人的运动学设置
- en: 'For the `Bullet` Prefab, it moves with simplistic movement via scripting (it
    just moves forward), and not physics. We don’t need collisions; we will code the
    bullet to destroy itself as soon as it touches something and will damage the collided
    object (if possible), so a Kinematic Trigger profile is enough for this one. We
    will use the `Trigger` event to script the contact reactions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Bullet`预制体，它通过脚本进行简单的移动（只是向前移动），而不是通过物理。我们不需要碰撞；我们将编写代码，使子弹在接触任何东西时立即销毁，并（如果可能）损坏碰撞的对象，所以运动学触发器配置就足够了。我们将使用`触发器`事件来编写接触反应的脚本：
- en: '![](img/B18585_07_07.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_07.png)'
- en: 'Figure 7.8: The Kinematic Trigger setting for our bullet; Is Trigger and Is
    Kinematic are checked'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：子弹的运动学触发设置；勾选了**是触发器**和**是运动学**
- en: Now that we have properly configured the objects, let’s check how to filter
    undesired collisions between certain object types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确配置了对象，让我们来看看如何过滤某些对象类型之间不希望发生的碰撞。
- en: Filtering collisions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤碰撞
- en: Sometimes we want certain objects to ignore each other, like the bullets shot
    by the player, which shouldn’t collide with the player itself. We can always filter
    that with an `if` statement in the C# script, checking whether the hit object
    is from the opposite team or whatever filtering logic you want, but by then, it
    is too late; the physics system wasted resources by checking a collision between
    objects that were never meant to collide. Here is where the Layer Collision Matrix
    can help us.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们希望某些对象相互忽略，比如玩家射出的子弹，它们不应该与玩家本身发生碰撞。我们总可以在C#脚本中使用`if`语句来过滤这些情况，检查被击中的对象是否来自敌方或任何你想要的过滤逻辑，但那时已经太晚了；物理系统已经浪费了资源去检查本不应该发生碰撞的对象之间的碰撞。这就是层碰撞矩阵能帮到我们的地方。
- en: The **Layer Collision Matrix** sounds scary, but it is a simple setting of the
    physics system that allows us to specify which groups of objects should collide
    with other groups. For example, the player’s bullets should collide with enemies,
    and enemy bullets should collide with the player. In this case the enemies’ bullets
    will pass through enemies, but this is desired in our case. The idea is to create
    those groups and put our objects inside them, and in Unity, those groups are called
    **layers**. We can create layers and set the layer property of the GameObject
    (the top part of the Inspector) to assign the object to that group or layer. Note
    that you have a limited number of layers, so try to use them wisely.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**层碰撞矩阵**听起来很吓人，但它只是物理系统的一个简单设置，允许我们指定哪些对象组应该与其他组发生碰撞。例如，玩家的子弹应该与敌人碰撞，敌人的子弹应该与玩家碰撞。在这种情况下，敌人的子弹会穿过敌人，但这是我们想要的。我们的想法是创建这些组，并将我们的对象放入其中，在Unity中，这些组被称为**层**。我们可以创建层，并将GameObject（检查器顶部部分）的层属性设置为将对象分配到该组或层。请注意，你的层数量有限，所以尽量明智地使用它们。'
- en: 'We can achieve this by doing the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式实现：
- en: 'Go to **Edit | Project Settings** and, inside it, look for the **Tags and Layers**
    option from the left pane:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑 | 项目设置**，在其中，从左侧面板查找**标签和层**选项：
- en: '![](img/B18585_07_08.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_08.png)'
- en: 'Figure 7.9: The Tags and Layers settings'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：标签和层设置
- en: 'From the **Layers** section, fill the empty spaces to create layers. We will
    use this for the bullet scenario, so we need four layers: `Player`, `Enemy`, `PlayerBullet`,
    and `EnemyBullet`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层**部分，填写空白区域以创建层。我们将使用这个来处理子弹场景，所以我们需要四个层：`Player`、`Enemy`、`PlayerBullet`和`EnemyBullet`：
- en: '![](img/B18585_07_09.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_09.png)'
- en: 'Figure 7.10: Creating layers'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：创建层
- en: 'Select the `Player` GameObject in the Hierarchy and, from the top part of the
    Inspector, change the **Layer** property to `Player`. Also, change the `Enemy`
    Prefab to have the `Enemy` layer. A window will show, asking you whether you want
    to also change the child objects; select **Yes**:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`Player`GameObject，从检查器的顶部部分更改**层**属性为`Player`。同时，将`Enemy`预制件更改为`Enemy`层。将显示一个窗口，询问你是否想同时更改子对象；选择**是**：
- en: '![](img/B18585_07_10.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_10.png)'
- en: 'Figure 7.11: Changing the layers of the player and the enemy Prefab'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：更改玩家和敌人预制件的层
- en: 'In the case of the bullet, we have a problem; we have one Prefab but two layers,
    and a Prefab can only have one layer. We have two options: changing the layer
    according to the shooter via scripting, or having two bullet Prefabs with different
    layers. For simplicity, I will choose the latter, also taking the chance to apply
    another material to the enemy bullet to make it look different.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子弹的情况下，我们有一个问题；我们有一个预制件但有两个层，而预制件只能有一个层。我们有两个选择：通过脚本根据射击者更改层，或者有两个具有不同层的子弹预制件。为了简单起见，我将选择后者，并借此机会将另一种材质应用到敌人子弹上，使其看起来不同。
- en: We will be creating a Prefab **Variant** of the player bullet. Remember that
    a Variant is a Prefab that is based on an original one like class inheritance.
    When the original Prefab changes, the Variant will change, but the Variant can
    have differences, which will make it unique.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建玩家子弹的预制件**变体**。记住，变体是基于原始预制件的一个预制件，就像类继承一样。当原始预制件发生变化时，变体也会变化，但变体可以有不同的地方，这将使其变得独特。
- en: Drop a bullet Prefab into the scene to create an instance.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子弹预制件拖放到场景中以创建实例。
- en: Drag the instance again to the `Prefabs` folder, this time selecting the **Prefab**
    **Variant** option in the window that will appear.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次将实例拖动到`预制件`文件夹中，这次在出现的窗口中选择**预制件** **变体**选项。
- en: Rename it `Enemy Bullet`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`Enemy Bullet`。
- en: Destroy the Prefab instance in the scene.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁场景中的预制实例。
- en: Create a second material similar to the player bullet with a different color
    and put it on the enemy bullet Prefab Variant.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与玩家子弹类似但颜色不同的第二个材质，并将其放置在敌人子弹预制件变体上。
- en: Select the enemy bullet Prefab, set its layer to `EnemyBullet`, and do the same
    for the original Prefab (`PlayerBullet`). Even if you changed the original Prefab
    layer, as the Variant modified it, the modified version (or override) will prevail,
    allowing each Prefab to have its own layer.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择敌人子弹预制件，将其层级设置为`EnemyBullet`，并对原始预制件（`PlayerBullet`）执行相同的操作。即使你更改了原始预制件的层级，由于变体对其进行了修改，修改后的版本（或覆盖）将占优，允许每个预制件拥有自己的层级。
- en: 'Now that we have configured the layers, let’s configure the physics system
    to use them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了层级，让我们配置物理系统以使用它们：
- en: Go to **Edit | Project Settings** and look for the **Physics** settings (not
    **Physics 2D**).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**编辑 | 项目设置**并查找**物理**设置（不是**物理2D**）。
- en: 'Scroll down until you see the **Layer Collision Matrix**, a half grid of checkboxes.
    You will notice that each column and row is labeled with the names of the layers,
    so each checkbox in the cross of a row and column will allow us to specify whether
    these two should collide. In our case, we configured it as shown in the following
    screenshot so that player bullets do not hit the player or other player bullets,
    and enemy bullets do not hit enemies or other enemy bullets:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动直到你看到**层级碰撞矩阵**，一个半网格的复选框。你会注意到每一列和行都标注了层级的名称，所以每一行和列交叉处的复选框将允许我们指定这两个层级是否应该碰撞。在我们的例子中，我们将其配置如下，以便玩家子弹不会击中玩家或其他玩家子弹，敌人子弹不会击中敌人或其他敌人子弹：
- en: '![](img/B18585_07_11.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_11.png)'
- en: 'Figure 7.12: Making player bullets collide with enemies and enemy bullets with
    the player'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：使玩家子弹与敌人碰撞，敌人子弹与玩家碰撞
- en: It is worth noticing that sometimes filtering logic won’t be that fixed or predictable,
    for example, only hit objects that have a certain amount of life, objects that
    don’t have an invisibility temporal buff, or conditions that can change during
    the game and are difficult to generate for all possible layers for all possible
    groups. So, in these cases, we should rely on manual filtering after the **Trigger**
    or **Collision** event.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有时过滤逻辑可能不会那么固定或可预测，例如，仅击中具有一定生命值的对象，没有隐形时间增益的对象，或者可以在游戏过程中改变且难以为所有可能的层级和组生成条件的对象。因此，在这些情况下，我们应该在**触发**或**碰撞**事件之后依赖手动过滤。
- en: Now that we have filtered collisions, let’s check whether our settings are working
    properly by reacting to collisions in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经过滤了碰撞，接下来让我们通过下一节中的碰撞反应来检查我们的设置是否正常工作。
- en: Detecting collisions
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: As you can see, proper physics settings can be complicated and very important,
    but now that we have tackled that, let’s do something with those settings by reacting
    to the contact in different ways and creating a **health system** in the process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，适当的物理设置可能很复杂且非常重要，但现在我们已经解决了这个问题，让我们通过以不同的方式反应接触并在这个过程中创建一个**健康系统**来使用这些设置吧。
- en: 'In this section, we will examine the following collision concepts:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下碰撞概念：
- en: Detecting Trigger events
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测触发事件
- en: Modifying the other object
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改其他对象
- en: First, we are going to explore the different collision and trigger events Unity
    offers to react to contact between two objects through the Unity collision events.
    This allows us to execute any reaction code we want to place, but we are going
    to explore how to modify the contacted object components using the `GetComponent`
    function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨Unity提供的不同碰撞和触发事件，以便通过Unity碰撞事件来反应两个对象之间的接触。这允许我们执行我们想要放置的任何反应代码，但我们将探讨如何使用`GetComponent`函数修改接触对象组件。
- en: Detecting Trigger events
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测触发事件
- en: 'If objects are properly configured, as previously discussed, we can get two
    reactions: collisions or triggers. The **Collision** reaction has a default effect
    that blocks the movement of the objects, but we can add custom behavior on top
    of that using scripting; but with a **Trigger**, unless we add custom behavior,
    it won’t produce any noticeable effect. Either way, we can script reactions to
    both possible scenarios such as adding a score, reducing health, and losing the
    game. To do so, we can use the suite of **Physics events**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象配置得当，如前所述，我们可以得到两种反应：碰撞或触发。**碰撞**反应有一个默认效果，即阻止对象的移动，但我们可以通过脚本添加自定义行为；但**触发**器，除非我们添加自定义行为，否则不会产生任何明显的效果。无论如何，我们可以为两种可能的场景编写脚本，例如添加分数、减少生命值和输掉游戏。为此，我们可以使用**物理事件**套件。
- en: These events are split into two groups, **Collision events** and **Trigger events**,
    so according to your object setting, you will need to pick the proper group. Both
    groups have three main events, **Enter**, **Stay**, and **Exit**, telling us when
    a collision or trigger began (*Enter*), whether they are still happening or are
    still in contact (*Stay*), and when they stopped contacting (*Exit*). For example,
    we can script a behavior such as playing a sound when two objects first make contact
    in the Enter event, such as a friction sound, and stop it when the contact ends,
    in the Exit event.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件分为两组，**碰撞事件**和**触发事件**，因此根据你的对象设置，你需要选择正确的组。两组都有三个主要事件，**进入**、**持续**和**退出**，告诉我们碰撞或触发何时开始（*进入*），它们是否仍在发生或仍在接触（*持续*），以及何时停止接触（*退出*）。例如，我们可以在`进入`事件中编写一个行为，比如在两个物体首次接触时播放声音，例如摩擦声，并在`退出`事件中停止播放。
- en: 'Let’s test this by creating our first contact behavior: the bullet being destroyed
    when coming into contact with something. Remember that the bullets are configured
    to be triggers, so they will generate `Trigger` events on contact with anything.
    You can do this with the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建我们的第一个接触行为来测试这个功能：子弹在接触任何物体时被销毁。记住，子弹被配置为触发器，因此它们在接触任何物体时都会生成`触发`事件。你可以按照以下步骤操作：
- en: Create and add a script called `ContactDestroyer` on the **Player Bullet** Prefab;
    as the **Enemy Bullet** Prefab is a Variant of it, it will also have the same
    script.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**玩家子弹**预制件上创建并添加一个名为`ContactDestroyer`的脚本；由于**敌人子弹**预制件是其变体，它也将具有相同的脚本。
- en: To detect when a trigger happens, such as with **Start** and **Update**, create
    an event function named `OnTriggerEnter`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检测触发器何时发生，例如使用**开始**和**更新**，创建一个名为`OnTriggerEnter`的事件函数。
- en: 'Inside the event, use the `Destroy(gameObject);` line to make the bullet destroy
    itself when touching something:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件内部，使用`Destroy(gameObject);`行来使子弹在接触物体时销毁自身：
- en: '![](img/B18585_07_12.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_12.png)'
- en: 'Figure 7.13: Auto-destroying on contact with something'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：与物体接触时自动销毁
- en: Save the script and shoot the bullets against the walls to see how they disappear
    instead of passing through them. Here we don’t have a collision, but a trigger
    that destroys the bullet on contact. So, this way, we are sure that the bullet
    will never pass through anything, but we are still not using physics movement.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，并将子弹射向墙壁以查看它们如何消失而不是穿过它们。在这里，我们没有碰撞，而是一个在接触时销毁子弹的触发器。因此，这样我们就可以确保子弹永远不会穿过任何东西，但我们仍然没有使用物理运动。
- en: For now, we won’t need the other Collision events, but if you need them, they
    will work similarly; just create a function called `OnCollisionEnter` instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不需要其他碰撞事件，但如果你需要，它们的工作方式类似；只需创建一个名为`OnCollisionEnter`的函数即可。
- en: 'Now, let’s explore another version of the same function. It not only tells
    us that we hit something but also what we came into contact with. We will use
    this to make our **Contact Destroyer** also destroy the other object. To do this,
    follow these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索同一功能的另一个版本。它不仅告诉我们我们击中了某个物体，还告诉我们我们接触到了什么。我们将使用这个功能来使我们的**接触销毁器**也能销毁其他对象。为此，请按照以下步骤操作：
- en: 'Replace the `OnTriggerEnter` method signature with the one in the following
    screenshot. This one receives a parameter of the `Collider` type, indicating the
    exact collider that hit us:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnTriggerEnter`方法签名替换为以下截图中的签名。这个签名接收一个`Collider`类型的参数，表示击中我们的确切碰撞器：
- en: '![](img/B18585_07_13.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_13.png)'
- en: 'Figure 7.14: Version of the trigger event that tells us which object we collided
    with'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：告诉我们我们与哪个对象发生碰撞的触发事件版本
- en: 'We can access the GameObject of that collider using the `gameObject` property.
    We can use this to destroy the other one as well, as shown in the following screenshot.
    If we just use the `Destroy` function by passing the `other` variable, it will
    only destroy the `Collider` component:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`gameObject`属性访问那个碰撞器的GameObject。我们可以使用这个来销毁另一个对象，如下面的截图所示。如果我们只是使用`Destroy`函数并通过传递`other`变量，它将只销毁`Collider`组件：
- en: '![](img/B18585_07_14.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_14.png)'
- en: 'Figure 7.15: Destroying both objects'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：销毁两个对象
- en: Save and test the script. You will notice that the bullet will destroy everything
    it touches. Remember to verify that your enemy has a Capsule collider for the
    bullet to detect collisions against it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并测试脚本。您会注意到子弹将销毁它接触到的所有东西。请记住验证您的敌人是否有胶囊碰撞器，以便子弹能够检测到与之的碰撞。
- en: 'The equivalent version in Visual Scripting would be like the following figure:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉脚本中的等效版本如下所示：
- en: '![](img/B18585_07_15.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_15.png)'
- en: 'Figure 7.16: Destroying both objects with Visual Scripting'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：使用视觉脚本销毁两个对象
- en: 'As you can see, we created an **On Trigger Enter** node and chained it to two
    **Destroy** nodes. To specify which object each **Destroy** node will destroy,
    we used the **Component: Get GameObject** node twice. The right one was created
    with no node connected to its left input pin, which means it will return the GameObject
    that is currently executing this script (hence, the **This** label in the node
    left pin), in this case, the bullet. For the second one we needed to connect the
    **Collider** output pin at the right of the **OnTriggerEnter** node to the **Get
    GameObject** node; this way we specify we want to obtain the GameObject that contains
    the collider our bullet collided with.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，我们创建了一个**On Trigger Enter**节点并将其连接到两个**Destroy**节点。为了指定每个**Destroy**节点将销毁哪个对象，我们使用了两次**Component:
    Get GameObject**节点。右侧的一个没有连接到其左侧输入引脚的节点，这意味着它将返回当前执行此脚本的GameObject（因此，节点左侧的**This**标签），在这种情况下，是子弹。对于第二个，我们需要将**OnTriggerEnter**节点右侧的**Collider**输出引脚连接到**Get
    GameObject**节点；这样我们指定我们想要获取子弹碰撞到的包含碰撞器的GameObject。'
- en: Now, in our game we don’t want the bullet to destroy everything on contact;
    instead, we will make the enemies and the player have a life amount; the bullets
    will reduce that life amount until it reaches 0, so let’s check how to do that.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的游戏中，我们不想让子弹在接触时销毁一切；相反，我们将让敌人和玩家拥有生命值；子弹将减少生命值，直到它达到0，所以让我们看看如何做到这一点。
- en: Modifying the other object
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改其他对象
- en: For the bullet to damage the collided object, we will need to access a `Life`
    component to change its amount, so we will need to create this `Life` component
    to hold a float field with the amount of life. Every object with this component
    will be considered a damageable object. To access the `Life` component from our
    bullet scripts we will need the `GetComponent` function to help us.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让子弹损坏碰撞的对象，我们需要访问一个`Life`组件来更改其数量，因此我们需要创建这个`Life`组件来保存一个包含生命值的浮点字段。具有此组件的每个对象都将被视为可损坏的对象。要从我们的子弹脚本中访问`Life`组件，我们需要`GetComponent`函数来帮助我们。
- en: 'If you have a reference to a GameObject or component, you can use `GetComponent`
    to access a specific component if the object contains it (if not, it will return
    `null`). Let’s see how to use that function to make the bullet lower the amount
    of life of the other object:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个GameObject或组件的引用，您可以使用`GetComponent`来访问对象中包含的特定组件（如果没有，它将返回`null`）。让我们看看如何使用该函数使子弹降低其他对象的生命值：
- en: 'Create and add a `Life` component with a `public float` field called `amount`
    to both the player and enemy Prefabs. Remember to set the value `100` (or whatever
    life amount you want to give them) in the **Amount** field for both in the Inspector:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家和敌人预制体中创建并添加一个名为`amount`的`public float`字段的生命组件。记住在检查器中为两者设置值`100`（或您想要给予他们的任何生命值）：
- en: '![](img/B18585_07_16.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_16.png)'
- en: 'Figure 7.17: The Life component'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17：生命组件
- en: Remove the `ContactDestroyer` component from the player bullet, which will also
    remove it from the **Enemy Bullet Variant**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从玩家子弹中移除`ContactDestroyer`组件，这也会将其从**Enemy Bullet Variant**中移除。
- en: Add a new script called `ContactDamager` to both the enemy and player.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`ContactDamager`的新脚本添加到敌人和玩家上。
- en: Add an `OnTriggerEnter` event that receives the `other` collider as a parameter
    and just add the `Destroy` function call that auto-destroys itself, not the one
    that destroys the other object; our script won’t be responsible for destroying
    it, just reducing its life.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `OnTriggerEnter` 事件，它接收一个参数 `other` 碰撞器，并仅添加一个 `Destroy` 函数调用来自动摧毁自身，而不是摧毁其他对象；我们的脚本不负责摧毁它，只是减少其生命值。
- en: Add a float field called `damage`, so we can configure the amount of damage
    to inflict on the other object. Remember to save the file and set a value before
    continuing.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `damage` 的浮点字段，这样我们就可以配置对其他对象施加的伤害量。记得保存文件并设置一个值后再继续。
- en: 'Use `GetComponent` on the reference to the other collider to get a reference
    to its `Life` component and save it in a variable:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对其他碰撞器的引用上使用 `GetComponent` 来获取其 `Life` 组件的引用，并将其保存到一个变量中：
- en: '![](img/B18585_07_17.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_17.png)'
- en: 'Figure 7.18: Accessing the collided object’s Life component'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18：访问碰撞对象的 `Life` 组件
- en: Before reducing the life of the object, we must check that the `Life` reference
    isn’t `null`, which would happen if the other object doesn’t have the `Life` component,
    as in the case of walls and obstacles. The idea is that the bullet will destroy
    itself when anything collides with it and reduce the life of the other object
    if it is a damageable object that contains the `Life` component.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在减少对象的生命值之前，我们必须检查 `Life` 引用不是 `null`，这可能会发生在其他对象没有 `Life` 组件的情况下，例如墙壁和障碍物。想法是子弹在遇到任何东西时都会摧毁自己，如果它是一个包含
    `Life` 组件的可伤害对象，则会减少其他对象的生命值。
- en: 'In the following screenshot, you will find the full script:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以找到完整的脚本：
- en: '![](img/B18585_07_18.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_18.png)'
- en: 'Figure 7.19: Reducing the life of the collided object'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19：减少碰撞对象的寿命
- en: Place an enemy in the scene and set its speed to `0` to prevent it from moving.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中放置一个敌人，并将其速度设置为 `0` 以防止其移动。
- en: Select it in the Hierarchy before hitting **Play** and start shooting at it.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按 **Play** 键之前在层次结构中选择它，并开始射击它。
- en: You can see how the life value reduces in the Inspector. You can also press
    the *Esc* key to regain control of the mouse and select the object while in **Play**
    mode to see the life field change during the runtime in the editor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在检查器中看到生命值的减少。你还可以按 *Esc* 键恢复鼠标控制，并在 **Play** 模式下选择对象，以在编辑器中查看运行时生命字段的更改。
- en: 'Now, you will notice that life is decreasing, but it will become negative;
    we want the object to destroy itself when life is below 0 instead. We can do this
    in two ways: one is to add an `Update` to the `Life` component, which will check
    all of the frames to see whether life is below 0, destroying itself when that
    happens. The second way is by encapsulating the life field and checking that inside
    the setter to prevent all frames from being checked. I would prefer the second
    way, but we will implement the first one to make our scripts as simple as possible
    for beginners.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会注意到生命值正在减少，但它会变成负数；我们希望当生命值低于 0 时对象能够自我摧毁。我们可以有两种方式实现这一点：一种是在 `Life` 组件中添加一个
    `Update` 方法，它会检查每一帧的生命值是否低于 0，如果是，则摧毁自己。第二种方式是通过封装生命字段并在设置器中检查它来防止检查所有帧。我更倾向于第二种方式，但我们将实现第一种方式，以使脚本尽可能简单，便于初学者理解。
- en: 'To do this, follow these steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按照以下步骤操作：
- en: Add `Update` to the `Life` component.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Life` 组件添加 `Update` 方法。
- en: Add `If` to check whether the amount field is below or equals `0`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `If` 条件来检查数量字段是否小于或等于 `0`。
- en: Add `Destroy` in case the `if` condition is `true`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if` 条件为 `true` 的情况下添加 `Destroy`。
- en: 'The full `Life` script will look like the following screenshot:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的 `Life` 脚本将如下所示：
- en: '![](img/B18585_07_19.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_19.png)'
- en: 'Figure 7.20: The Life component'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20：`Life` 组件
- en: Save and see how the object is destroyed once `Life` becomes `0`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并查看当 `Life` 变为 `0` 时对象是如何被摧毁的。
- en: 'The Visual Scripting version for the `Life` component would look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Life` 组件的视觉脚本版本看起来是这样的：'
- en: '![](img/B18585_07_20.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_20.png)'
- en: 'Figure 7.21: The Life component in Visual Scripting'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21：视觉脚本中的 `Life` 组件
- en: 'The script is pretty straightforward—we check if our `Life` variable is less
    than 0 and then destroy ourselves as we did previously. Now, let’s check the **Damager**
    script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本相当直接——我们检查我们的 `Life` 变量是否小于 0，然后像之前一样摧毁自己。现在，让我们检查一下 **Damager** 脚本：
- en: '![](img/B18585_07_21.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_21.png)'
- en: 'Figure 7.22: The Damager component in Visual Scripting'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22：视觉脚本中的 `Damager` 组件
- en: 'This version is a little bit different from our C# counterpart. At first glance
    it looks the same: we use **Get Variable** as before to read the life, then we
    use the **Subtract** node to subtract **damage** from **life**, and the result
    of that calculation becomes the new value of **life**, with the **Set Variable**
    node used to alter the current value of that variable.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本与我们的C#版本略有不同。乍一看，它看起来相同：我们像以前一样使用**获取变量**来读取生命值，然后我们使用**减去**节点从**生命**中减去**伤害**，计算结果成为新的**生命**值，使用**设置变量**节点来改变该变量的当前值。
- en: The first difference we can see here is the absence of any `GetComponent` node.
    In C# we used that instruction to get the `Life` component on the collided object
    in order to read and alter its **amount** variable, reducing the remaining life.
    But as in Visual Scripting our node graphs don’t have variables, so we don’t need
    to access the component to read them. Instead, knowing that the enemy has a `Life`
    variable in its **Variables** component, we use the **Get Variable** node, connecting
    it to the collider we hit (the **Collider** output pin of **On Trigger Enter**),
    so essentially we are reading the value of the `Life` variable of the collided
    object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到的第一个不同之处是缺少任何`GetComponent`节点。在C#中，我们使用这个指令来获取碰撞对象的`Life`组件，以便读取和修改其**数量**变量，减少剩余的生命值。但在视觉脚本中，我们的节点图没有变量，所以我们不需要访问组件来读取它们。相反，我们知道敌人其**变量**组件中有一个名为`Life`的变量，我们使用**获取变量**节点，将其连接到我们撞击的碰撞器（**On
    Trigger Enter**的**Collider**输出引脚），因此本质上我们正在读取被撞击对象的`Life`变量值。
- en: 'The same goes for changing its value: we use the **Set Value** node, connecting
    it to the collider, specifying we want to alter the value of the `Life` variable
    of the collider object, not ours (as bullets, we even don’t have a `Life` variable).
    Note that this can raise an error if the collided object doesn’t have the `Life`
    variable, and that is why we added the **Object Has Variable** node, which checks
    if the object has a variable called `Life`. If it doesn’t, we just do nothing,
    which is useful when we collide with walls or other non-destructible objects.
    Finally, we make the **Damager** (the bullet in this case) auto-destroy itself.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更改其值也是一样：我们使用**设置值**节点，将其连接到碰撞器，指定我们想要改变碰撞器对象的`Life`变量值，而不是我们自己的（因为我们甚至没有`Life`变量）。请注意，如果碰撞对象没有`Life`变量，这可能会引发错误，这就是为什么我们添加了**对象有变量**节点，它检查对象是否有一个名为`Life`的变量。如果没有，我们就什么也不做，这在与墙壁或其他不可破坏的对象碰撞时很有用。最后，我们让**伤害者**（在这个例子中是子弹）自动销毁自己。
- en: Optionally, you can instantiate an object when this happens such as a sound,
    a particle, or maybe a power-up. I will leave this as a challenge for you. By
    using a similar script, you can make a life power-up that increases the life value
    or a speed power-up that accesses the `PlayerMovement` script and increases the
    **Speed** field; from now on, use your imagination to create exciting behaviors
    using this.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，当发生这种情况时，你可以实例化一个对象，例如声音、粒子或可能是一个增强道具。我将把这个留给你作为挑战。通过使用类似的脚本，你可以制作一个增加生命值的生命增强道具，或者一个通过访问`PlayerMovement`脚本并增加**速度**字段的加速增强道具；从现在开始，发挥你的想象力，使用这个来创建令人兴奋的行为。
- en: Now that we have explored how to detect collisions and react to them, let’s
    explore how to fix the player falling when hitting a wall.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何检测碰撞并对其做出反应，让我们来探讨如何修复玩家在撞击墙壁时掉落的问题。
- en: Moving with physics
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用物理移动
- en: So far, the player, the only object that moves with the **Dynamic Collider Profile**
    and the one that will move with physics, is actually moving through custom scripting
    using the Transform API. Every dynamic object should instead move using the Rigidbody
    API functions in a way the physics system understands better. As such, here we
    will explore how to move objects, this time through the Rigidbody component.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，玩家是唯一一个使用**动态碰撞器配置文件**移动的对象，并且它将使用物理引擎移动，实际上是通过自定义脚本使用Transform API来移动的。每个动态对象都应该使用Rigidbody
    API函数以物理系统更易理解的方式移动。因此，在这里我们将探讨如何移动对象，这次是通过Rigidbody组件。
- en: 'In this section, we will examine the following physics movement concepts:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下物理移动概念：
- en: Applying forces
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用力
- en: Tweaking physics
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整物理
- en: We will start by seeing how to move objects the correct physical way, through
    forces, and we will apply this concept to the movement of our player. Then, we
    will explore why real physics is not always fun, and how we can tweak the physics
    properties of our objects to have a more responsive and appealing behavior.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看如何通过力以正确的方式移动物体，并将这个概念应用到玩家的运动中。然后，我们将探讨为什么现实中的物理并不总是有趣的，以及我们如何调整物体的物理属性以获得更灵敏和吸引人的行为。
- en: Applying forces
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用力
- en: The physically accurate way of moving an object is through forces, which affect
    the object’s velocity. To apply force, we need to access `Rigidbody` instead of
    `Transform` and use the `AddForce` and `AddTorque` functions to move and rotate
    respectively. These are functions where you can specify the amount of force to
    apply to each axis of position and rotation. This method of movement will have
    full physics reactions; the forces will accumulate on the velocity to start moving
    and will suffer drag effects that will make the speed slowly decrease, and the
    most important aspect here is that they will collide against walls, blocking the
    object’s way.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 移动物体的物理准确方式是通过力，这会影响物体的速度。要应用力，我们需要访问`Rigidbody`而不是`Transform`，并使用`AddForce`和`AddTorque`函数分别移动和旋转。这些函数允许你指定要施加到位置和旋转每个轴上的力的大小。这种运动方式将具有完整的物理反应；力将累积在速度上以开始移动，并将受到阻力效应的影响，使速度逐渐减小，而且这里最重要的方面是它们将碰撞到墙壁，阻挡物体的路径。
- en: 'To get this kind of movement, we can do the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得这种运动方式，我们可以做以下操作：
- en: 'Create a `Rigidbody` field in the `PlayerMovement` script, but this time, make
    it `private`, meaning, do not write the `public` keyword in the field, which will
    make it disappear in the editor; we will get the reference another way:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerMovement`脚本中创建一个`Rigidbody`字段，但这次将其设置为`private`，这意味着不要在字段中写入`public`关键字，这样它就会在编辑器中消失；我们将以另一种方式获取引用：
- en: '![](img/B18585_07_22.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_22.png)'
- en: 'Figure 7.23: The private Rigidbody reference field'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23：私有Rigidbody引用字段
- en: Note that we named this variable `rb` just to prevent our scripts from being
    too wide, making the screenshots of the code in the book too small. It’s recommended
    to call the variable properly in your scripts—in this case, it would be named
    `rigidbody`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们之所以将这个变量命名为`rb`，是为了防止我们的脚本过于宽泛，使得书中代码的截图太小。建议你在脚本中正确地调用变量——在这种情况下，它应该命名为`rigidbody`。
- en: 'Using `GetComponent` in the `Start` event function, get our Rigidbody and save
    it in the field. We will use this field to cache the result of the `GetComponent`
    function; calling that function every frame to access the Rigidbody is not performant.
    Also, you can notice here that the `GetComponent` function can be used to retrieve
    not only components from other objects (like the collision example) but also your
    own:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`事件函数中使用`GetComponent`，获取我们的Rigidbody并将其保存在字段中。我们将使用这个字段来缓存`GetComponent`函数的结果；每帧调用该函数来访问Rigidbody不是性能良好的做法。此外，你还可以注意到，`GetComponent`函数不仅可以用来检索其他对象的组件（如碰撞示例），也可以用来检索你自己的组件：
- en: '![](img/B18585_07_23.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_23.png)'
- en: 'Figure 7.24: Caching the Rigidbody reference for future usage'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24：缓存Rigidbody引用以供将来使用
- en: Replace the `transform.Translate` calls with `rb.AddRelativeForce`. This will
    call the add force functions of the Rigidbody, specifically the relative ones,
    which will consider the current rotation of the object. For example, if you specify
    a force in the *z*-axis (the third parameter), the object will apply its force
    along with its forward vector.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`transform.Translate`调用替换为`rb.AddRelativeForce`。这将调用Rigidbody的加力函数，特别是相对的加力函数，这将考虑物体的当前旋转。例如，如果你在*z*-轴（第三个参数）上指定一个力，物体将沿着其前进向量应用其力。
- en: 'Replace the `transform.Rotate` calls with `rb.AddRelativeTorque`, which will
    apply rotation forces:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`transform.Rotate`调用替换为`rb.AddRelativeTorque`，这将应用旋转力：
- en: '![](img/B18585_07_24.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_24.png)'
- en: 'Figure 7.25: Using the Rigidbody forces API'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25：使用Rigidbody力API
- en: Check that the player GameObject capsule collider is not intersecting with the
    floor, but just a little bit over it. If the player is intersecting, the movement
    won’t work properly. If this is the case, move it upward.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查玩家GameObject胶囊碰撞体是否没有与地板相交，而是略微超出它。如果玩家相交，运动将无法正常工作。如果是这种情况，请将其向上移动。
- en: 'In the Visual Scripting version, the change is the same; replace the **Transform**
    and **Rotate** nodes with **Add Relative Force** and **Add Relative Torque** nodes.
    An example of **Add Relative Force** would be the following one:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉脚本版本中，变化是相同的；将**变换**和**旋转**节点替换为**添加相对力**和**添加相对扭矩**节点。**添加相对力**的一个例子如下：
- en: '![](img/B18585_07_25.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_25.png)'
- en: 'Figure 7.26: Using the Rigidbody forces API'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26：使用Rigidbody力API
- en: 'And for rotation like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 并且对于这样的旋转：
- en: '![](img/B18585_07_26.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_26.png)'
- en: 'Figure 7.27: Using the Rigidbody torque API'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27：使用Rigidbody扭矩API
- en: You can see that we don’t need to use **GetComponent** nodes here either, given
    that just using the **Add Relative Force** or **Torque** nodes makes Visual Scripting
    understand that we want to apply those actions on our own Rigidbody component
    (explaining again the **This** label). If in any other case we need to call those
    functions on a Rigidbody other than ours, we would need the **GetComponent** node
    there, but let’s explore that later.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们在这里也不需要使用**GetComponent**节点，因为仅仅使用**添加相对力**或**扭矩**节点就足以让视觉脚本理解我们想要在自己的Rigidbody组件上应用这些动作（再次解释**This**标签）。如果在任何其他情况下我们需要在除了我们自己的Rigidbody之外的其他Rigidbody上调用这些函数，我们则需要在那里使用**GetComponent**节点，但让我们稍后再探讨这一点。
- en: Now, if you save and test the results, you will probably find the player falling
    and that’s because now we are using real physics, which contains floor friction,
    and due to the force being applied at the center of gravity, it will make the
    object fall. Remember that, in terms of physics, you are a capsule; you don’t
    have legs to move, and here is where standard physics is not suitable for our
    game. The solution is to tweak physics to emulate the kind of behavior we need.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你保存并测试结果，你可能会发现玩家掉落，这是因为现在我们正在使用真实的物理，它包含地板摩擦，并且由于力作用于重心，这会使物体掉落。记住，从物理学的角度来看，你是一个胶囊；你没有腿可以移动，这就是标准物理不适合我们的游戏的地方。解决方案是调整物理以模拟我们需要的这种行为。
- en: Tweaking physics
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整物理
- en: To make our player move like in a regular platformer game, we will need to freeze
    certain axes to prevent the object from falling. Remove the friction to the ground
    and increase the air friction (drag) to make the player reduce its speed automatically
    when releasing the keys.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的玩家像在普通平台游戏一样移动，我们需要冻结某些轴以防止物体掉落。移除地面的摩擦力，并增加空气摩擦（阻力），使玩家在释放按键时自动减速。
- en: 'To do this, follow these steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按照以下步骤操作：
- en: 'In the `Rigidbody` component, look at the **Constraints** section at the bottom
    and check the **X** and **Z** axes of the **Freeze Rotation** property:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Rigidbody`组件中，查看底部的**约束**部分，并检查**冻结旋转**属性的**X**和**Z**轴：
- en: '![](img/B18585_07_27.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_07_27.png)'
- en: 'Figure 7.28: Freezing rotation axes'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28：冻结旋转轴
- en: This will prevent the object from falling sideways but will allow the object
    to rotate horizontally. You might also freeze the *y*-axis of the **Freeze Position**
    property if you don’t want the player to jump, preventing some undesired vertical
    movement on collisions.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将防止物体向侧面掉落，但允许物体水平旋转。如果你不希望玩家跳跃，也可以冻结**冻结位置**属性的*y*轴，以防止碰撞时出现一些不希望的垂直移动。
- en: You will probably need to change the speed values because you changed from a
    meters-per-second value to newtons-per-second, the expected value of the **Add
    Force** and **Add Torque** functions. Using 1,000 in speed and 160 in rotation
    speed was enough for me.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要更改速度值，因为你从每秒米值更改为每秒牛顿值，这是**添加力**和**添加扭矩**函数的预期值。对我来说，速度设置为1,000，旋转速度设置为160就足够了。
- en: 'Now, you will probably notice that the speed will increase a lot over time,
    as will the rotation. Remember that you are using forces, which affects your velocity.
    When you stop applying forces, the velocity is preserved, and that’s why the player
    kill keeps rotating even if you are not moving the mouse. The fix to this is to
    increase the **Drag** and **Angular Drag**, which emulates air friction, and will
    reduce the movement and rotation respectively when no force is applied. Experiment
    with values that you see suitable; in my case, I used `2` for **Drag** and `10`
    for **Angular Drag**, needing to increase **Rotation Speed** to `150` to compensate
    for the drag increase:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可能会注意到速度会随着时间的推移而大幅增加，旋转也是如此。记住，你正在使用力，这会影响你的速度。当你停止施加力时，速度会被保留，这就是为什么即使你不移动鼠标，玩家也会继续旋转。解决这个问题的方法是增加**阻力**和**角阻力**，这模拟了空气摩擦，并在没有施加力时分别减少移动和旋转。尝试一些你认为合适的值；在我的情况下，我使用了`2`作为**阻力**和`10`作为**角阻力**，需要将**旋转速度**增加到`150`以补偿阻力的增加：
- en: '![](img/B18585_07_28.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_28.png)'
- en: 'Figure 7.29: Setting air friction for rotation and movement'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29：设置旋转和移动的空气摩擦
- en: Now, if you move while touching the wall, instead of sliding, like in most games,
    your Player will stick to the obstacles due to contact friction. We can remove
    this by creating a `Physics Material`, an asset that can be assigned to the colliders
    to control how they react in those scenarios.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你在触摸墙壁时移动，而不是像大多数游戏那样滑动，你的玩家会因为接触摩擦而粘附在障碍物上。我们可以通过创建一个`Physics Material`（物理材质），一个可以分配给碰撞体以控制它们在这些场景中如何反应的资产来移除这种效果。
- en: Start creating one by clicking on the **+** button from the **Project** window
    and selecting **Physics Material** (not the 2D version). Call it `Player` and
    remember to put it in a folder for those kinds of assets.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**项目**窗口中的**+**按钮并选择**物理材质**（不是2D版本）来开始创建一个。将其命名为`Player`，并记得将其放入一个用于这些资产的文件夹中。
- en: 'Select it and set **Static Friction** and **Dynamic Friction** to `0`, and
    **Friction Combine** to `Minimum`, which will make the **Physics** system pick
    the minimum friction of the two colliding objects, which is always the minimum—in
    our case, zero:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它，并将**静态摩擦**和**动态摩擦**设置为`0`，将**摩擦组合**设置为`最小`，这将使**物理**系统选择两个碰撞物体之间的最小摩擦，这总是最小的——在我们的例子中，是零：
- en: '![](img/B18585_07_29.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_29.png)'
- en: 'Figure 7.30: Creating a physics material'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30：创建物理材质
- en: 'Select the player and drag this asset to the **Material** property of the **Capsule
    Collider**:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择玩家并将此资产拖动到**胶囊碰撞体**的**材质**属性：
- en: '![](img/B18585_07_30.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_07_30.png)'
- en: 'Figure 7.31: Setting the physics material of the player'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.31：设置玩家的物理材质
- en: If you play the game now, you may notice that the player will move faster than
    before because now we don’t have any kind of friction on the floor, so you may
    need to reduce the movement force.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，你可能会注意到玩家移动的速度比以前快，因为现在地板上没有任何摩擦力，所以你可能需要减少移动力。
- en: As you can see, we needed to bend the physics rules to allow a responsive player
    movement. You can get more responsiveness by increasing drags and forces, so the
    speeds are applied faster and reduced faster, but that depends, again, on the
    experience you want your game to have.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们需要弯曲物理规则以允许响应的玩家移动。你可以通过增加阻力和力来获得更多的响应性，这样速度就会更快地应用和减少，但这取决于你希望游戏拥有的体验。
- en: Some games want an immediate response with no velocity interpolation, going
    from 0 to full speed and vice versa from one frame to the other, and in these
    cases, you can override the velocity and rotation vectors of the player directly
    at your will or even use other systems instead of physics, such as the `Character
    Controller` component, which have special physics for platformer characters; but
    let’s keep things simple for now.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏希望有即时的响应，没有速度插值，从一个帧到另一个帧从0到全速，反之亦然，在这些情况下，你可以直接根据你的意愿覆盖玩家的速度和旋转向量，或者甚至使用其他系统而不是物理，例如`Character
    Controller`组件，它为平台游戏角色有特殊的物理设置；但现在让我们保持简单。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Every game has physics in some way or another, for movement, collision detection,
    or both. In this chapter, we learned how to use the physics system for both, being
    aware of proper settings to make the system work properly, reacting to collisions
    to generate gameplay systems, and moving the player in such a way that it collides
    with obstacles, keeping its physically inaccurate movement. We used these concepts
    to create our player and bullet movement and make our bullets damage the enemies,
    but we can reuse the knowledge to create a myriad of other possible gameplay requirements,
    so I suggest you play a little bit with the physics concepts seen here; you can
    discover a lot of interesting use cases.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都以某种方式包含物理元素，无论是用于移动、碰撞检测，还是两者兼具。在本章中，我们学习了如何使用物理系统来实现这两者，注意适当的设置以确保系统正常工作，对碰撞做出反应以生成游戏玩法系统，以及以某种方式移动玩家，使其与障碍物发生碰撞，保持其物理上不准确的移动。我们利用这些概念来创建玩家的移动和子弹移动，并使子弹能够伤害敌人，但我们也可以重用这些知识来创建无数其他可能的游戏玩法需求，因此我建议你在这里尝试一下物理概念；你可以发现很多有趣的用例。
- en: In the next chapter, we will be discussing how to program the visual aspects
    of the game, such as effects, and make the UI react to the input.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何编程游戏的视觉方面，例如效果，并使用户界面对输入做出反应。
