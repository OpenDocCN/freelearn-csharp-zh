<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-111"><a id="_idTextAnchor111"/>5</h1>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>The One with the  Filesystem Chronicles</h1>
			<p><em class="italic">File Systems </em><em class="italic">and IO</em></p>
			<p>Computers are incredible machines, but they have one downside. If the power goes off, they forget everything. If we do not want to lose our work, we must store it elsewhere. We can print data, put it on the network, or store it in permanent storage. This is the most common option. Of course, we need to have a way to get data into the CPU. We can read data from a file or a network. We can even use the keyboard to enter data. This is something that both you (a programmer) and I (a writer) are very familiar with.</p>
			<p>When we are <a id="_idIndexMarker333"/>programming software, we refer to the concept of <strong class="bold">streams</strong>. A stream represents a sequence of data elements made available over time. This sequence can be stored on a disk, it can be data flowing over network wires, or it can be the state of a memory chip. Data must flow back and forth no matter what physical medium we use. This chapter handles that topic, covering streams, files, and other ways<a id="_idIndexMarker334"/> of <strong class="bold">Input and </strong><strong class="bold">Output</strong> (<strong class="bold">IO</strong>).</p>
			<p>One thing that we will not dive into in this chapter is the topic of networking. Networking is such a different concept that a separate chapter will deal with this topic. You can find all the low-level networking details in <a href="B20924_09.xhtml#_idTextAnchor181"><em class="italic">Chapter 8</em></a>. However, the concepts of data handling over that network are the same for files and other media. So, the principles laid out here still apply.</p>
			<p>In this chapter, we cover the following topics:</p>
			<ul>
				<li>How to work with files using .NET</li>
				<li>How to use Win32 APIs to work with the filesystem</li>
				<li>How to work with Directory and Path</li>
				<li>Why and how we should use asynchronous  IO</li>
				<li>How to use encryption and compression</li>
			</ul>
			<p>We have a lot of ground to cover, so let’s dive in!</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Technical requirements</h1>
			<p>To view all the code in this chapter, you can visit the following link: <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05</a>.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/>File writing basics</h1>
			<p>There <a id="_idIndexMarker335"/>cannot be anything more straightforward than writing to a file, right? That’s why I think that that is a good starting point. Here is the code to do so:</p>
			<pre class="source-code">
var path = System.IO.Path.GetTempPath();
var fileName = "WriteLines.txt";
var fullPath = Path.Combine(path, fileName);
File.WriteAllText(fullPath, "Hello, System Programmers");</pre>			<p>The first line gets the system <code>temp</code> path. Then we specify the filename, add that to the <code>temp</code> path, and write a line of text to that file.</p>
			<p>This example is simple enough, but it already shows something useful. First, we can get to the <code>temp</code> folder quickly; we don’t have to specify where that is in our code. Second, we can combine the filename and the path without worrying about the path separator. On Windows, the parts of the path are separated by a backslash, while on Linux, this is a forward slash. The CLR figures out what it should use and uses the correct one.</p>
			<p>The <code>File.WriteAllText</code> then takes that data and creates a file, opens it, writes the string, and closes the file. If the file is already there, the system overwrites it.</p>
			<p>If we wanted to have a temporary filename instead of <code>WriteLines.Text</code>, the code could have been even easier:</p>
			<pre class="source-code">
var path = System.IO.Path.GetTempFileName();
File.WriteAllText(path, "Hello, System Programmers");</pre>			<p>The system looks up the path for <code>temp</code> files, generates a new file with a unique filename, and uses that to write the string. The downside is that we now have no idea which file it is. We have to log that somewhere; otherwise, our <code>temp</code> folder will fill up quickly with unused files (most operating systems clean up the <code>temp</code> folder though, so no real worries there).</p>
			<p>You can<a id="_idIndexMarker336"/> obviously use any folder you want. However, if you want to use some of the special folders, such as the <code>Documents</code> folder on Windows, the system can help you get to those as well. Have a look at the following code snippet:</p>
			<pre class="source-code">
var path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
var fileName = "WriteLines.txt";
var fullPath = Path.Combine(path, fileName);
File.WriteAllText(fullPath, "Hello, System Programmers");</pre>			<p>This code looks up the location of <code>My Documents</code> on my machine and returns that so that I can write the file to that location. You can choose from a long list of special locations, all of which are part of the <code>SpecialFolder</code> enum. I will not list all of them; you can find them here: <a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0">https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0</a>.</p>
			<p>This way of writing files is effortless. However, as we have seen many times before, ease comes with less control. As systems programmers, we want all the control we can get. Let’s take back some control.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>FileStream</h2>
			<p>The static <code>File</code> class is <a id="_idIndexMarker337"/>easy to use and very convenient if you quickly want to write something to, or read something from, a file. However, it <a id="_idIndexMarker338"/>is not the fastest way. At least, it is not the fastest if we are referring to execution time. As systems programmers, we are very interested in speed, even if it means giving up on ease of coding.</p>
			<p>The following example is about 20% faster than the previous one, but it does the same things. It just needs a few more lines:</p>
			<pre class="source-code">
var fileName = Path.GetTempFileName();
var info = new UTF8Encoding(true).GetBytes("Hello, System Developers!");
using FileStream? fs = File.Create(fileName, info.Length);
try
{
    fs.Write(info, 0, info.Length);
}
finally
{
    fs.Close();
}</pre>			<p>This <a id="_idIndexMarker339"/>sample uses the <code>FileStream</code> that <code>File.Create()</code> returns. We can, of course, create one ourselves. Replace the line where we<a id="_idIndexMarker340"/> created the <code>FileStream</code> through <code>File</code> with the following:</p>
			<pre class="source-code">
using var fs = new FileStream(
    path: fileName,
    mode: FileMode.Create,
    access: FileAccess.Write,
    share: FileShare.None,
    bufferSize:0x1000,
    options: FileOptions.Asynchronous);</pre>			<p>I have used the most extensive overload here to show you some of the options that you can use. Most are self-explanatory, but I want to highlight two parameters: <strong class="bold">share</strong> and <strong class="bold">options</strong>.</p>
			<p><code>Share</code> is a flag that tells the operating system how to share the file while we use it. It has the following options:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-5">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Flag</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>None</code></p>
						</td>
						<td class="No-Table-Style">
							<p>0</p>
						</td>
						<td class="No-Table-Style">
							<p>No sharing is allowed. Any other process trying to access the file will fail to do so.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Read</code></p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p>Other processes can read the file while we are still using it.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Write</code></p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p>Other processes might write to the file at the same time.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ReadWrite</code></p>
						</td>
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p>This combines the <code>Read</code> and <code>Write</code> flags.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Delete</code></p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
						<td class="No-Table-Style">
							<p>This allows requests for deletion of the file while we are using it.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Inheritable</code></p>
						</td>
						<td class="No-Table-Style">
							<p>16</p>
						</td>
						<td class="No-Table-Style">
							<p>The file handle is inheritable by child processes. However, this does not work on Win32 applications.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1: Share options for files</p>
			<p>Although <a id="_idIndexMarker341"/>specifying a flag from this list might indicate that other processes can do things with our files while we use them, there is no guarantee that these other processes can actually do so. Usually, they need other permissions as well.</p>
			<p><code>Delete</code> is a nice flag. It <a id="_idIndexMarker342"/>allows for deletion while we are still working with the file. That could lead to weird situations. If we create a file and specify that we allow deletion, we might write to the file while another process has already deleted it. The system does not complain and continues running. However, you will end up without that file, which means losing your data forever. Let me show you what I mean:</p>
			<pre class="source-code">
using System.Text;
var fileName = Path.GetTempFileName();
var info = new UTF8Encoding(true).GetBytes("Hello fellow System Developers!");
using (var fs = new FileStream(
    path: fileName,
    mode: FileMode.Create,
    access: FileAccess.Write,
    share: FileShare.Delete, // We allow other processes to delete the                               //file.
    bufferSize: 0x1000,
    options: FileOptions.Asynchronous))
{
    try
    {
        fs.Write(info, 0, info.Length);
        Console.WriteLine($"Wrote to the file. Now try to delete it.             You can find it here:\n{fileName}");
        Console.ReadKey();
        fs.Write(info);
        Console.WriteLine("Done with all the writing");
        Console.ReadKey();
    }
    finally
    {
        fs.Close();
    }
}
Console.WriteLine("Done.");
Console.ReadKey();</pre>			<p>This example is straightforward. We will first get a temporary filename. Then, we will get the bytes that form <a id="_idIndexMarker343"/>our payload. After that, we will create an instance of the <code>FileStream</code>, setting a couple of properties as we do so.</p>
			<p>One of them is the <code>Share</code> option. We have set it to <code>FileShare.Delete</code>.</p>
			<p>We will write <a id="_idIndexMarker344"/>some data to the file and then pause the program. If you run it, this is the moment to take the output that tells you the name and location of the file and delete it. You should notice that you can do that. Then continue the program. As you can see, the following line writes the same data again to the file we just deleted. Nothing happens. Really, nothing happens. There are no errors, but no data is written anywhere either.</p>
			<p>In most cases, this is a behavior you would want to avoid. However, maybe your use case calls for just this kind of behavior. In that case, now you know how to do this.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Even faster – Win32</h2>
			<p>There<a id="_idIndexMarker345"/> is a faster way to write files. If we remove the overhead of the CLR, we can write files about 20% faster. A 20% increase in speed can mean the difference between a sluggish application and one that seems lightning-fast. As<a id="_idIndexMarker346"/> usual, this comes with a price. All the good things the CLR provides us with are now in our own hands. We have to do a lot more work. However, if you are looking for the fastest way to write data to a file, the<code> </code>Win32 approach is, again, the best way to do this.</p>
			<p>We will begin by declaring some constants:</p>
			<pre class="source-code">
private const uint GENERIC_WRITE = 0x40000000;
private const uint CREATE_ALWAYS = 0x00000002;
private const uint FILE_APPEND_DATA = 0x00000004;</pre>			<p><code>GENERIC_WRITE</code> tells the system that we want to write to a file. <code>CREATE_ALWAYS</code> specifies that we want to create a new file every time we call this. <code>FILE_APPEND_DATA</code> means that we want to add to the current file (which doesn’t make much sense, since we just created the file).</p>
			<p>It is time to import the Win32 APIs:</p>
			<pre class="source-code">
[DllImport("kernel32.dll", SetLastError = true)]
private static extern SafeFileHandle CreateFile(
    string lpFileName,
    uint dwDesiredAccess,
    uint dwShareMode,
    IntPtr lpSecurityAttributes,
    uint dwCreationDisposition,
    uint dwFlagsAndAttributes,
    IntPtr hTemplateFile);
[DllImport("kernel32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool WriteFile(
    SafeFileHandle hFile,
    byte[] lpBuffer,
    uint nNumberOfBytesToWrite,
    out uint lpNumberOfBytesWritten,
    IntPtr lpOverlapped);
[DllImport("kernel32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool CloseHandle(SafeFileHandle hObject);</pre>			<p>We will <a id="_idIndexMarker347"/>import three methods from <code>kernel32.dll</code>. <code>CreateFile</code> creates a file, <code>WriteFile</code> writes to that file, and <code>CloseHandle</code> closes <a id="_idIndexMarker348"/>handles and, in our case, the handle to the file.</p>
			<p>That is all we need to write. Let me show you how that works:</p>
			<pre class="source-code">
public void WriteToFile(string fileName, string textToWrite)
{
    var fileHandle = CreateFile(
        fileName,
        GENERIC_WRITE,
        0,
        IntPtr.Zero,
        CREATE_ALWAYS,
        FILE_APPEND_DATA,
        IntPtr.Zero);
    if (!fileHandle.IsInvalid)
        try
        {
            var bytes = Encoding.ASCII.GetBytes(textToWrite);
            var writeResult = WriteFile(
                fileHandle,
                bytes,
                (uint)bytes.Length,
                out var bytesWritten,
                IntPtr.Zero);
        }
        finally
        {
            // Always close the handle once you are done
            CloseHandle(fileHandle);
        }
    else
        Console.WriteLine("Failed to open file.");
}</pre>			<p>With the<a id="_idIndexMarker349"/> knowledge you have right now, you should be able to follow along. We will first create a file with the correct parameters. If that works, we will get the bytes we want to write and then use <code>WriteFile</code> to do the actual writing. After that, we will close the handle. We do that in the <code>finally</code> block; handles are expensive and they lock access to the file. We want to close it so other processes can access the file.</p>
			<p>You are<a id="_idIndexMarker350"/> partially correct if you think that this does not look too bad. This was very simple. However, I omitted a lot of things, such as error checking. Do you remember what I told you about performance? I said in the previous chapters that file IO takes forever compared to normal CPU operations. Thus, we must use the asynchronous approach as much as we can. You can do that with Win32, but that is pretty complex. I will not show you how to do that here, but if you do a quick search on the Win32 API, <code>CreateFile</code>, and <code>FILE_FLAG_OVERLAPPED</code>, you can find out how it all works. In short, you will have to check everything yourself. My advice is to stick to the CLR functions. We will discuss asynchronous I/O later in this chapter.</p>
			<p>We have learned how to write to files and all that goes with doing that. However, that is only one part of the story. Let’s move to the other half of the equation: reading a file.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>File reading basics</h1>
			<p>Great. We<a id="_idIndexMarker351"/> have written a file. Now we should be able to read it as well, right? Okay, let’s dive into that. We will start with a simple example: a file with some lines of text that we want to read into a string:</p>
			<pre class="source-code">
public string ReadFromFile(string fileName)
{
    var text = File.ReadAllText(fileName);
    return text;
}</pre>			<p>I can’t <a id="_idIndexMarker352"/>make it simpler than this. We have the static <code>ReadAllText</code> method, which takes a filename and reads all text into the string. Then we return that. Keep in mind that not all files contain text. I even dare to say that <em class="italic">most</em> files do not contain text. They are binary. Now, technically, a <code>text</code> file is also a <code>binary</code> file. So, let’s read the file again, but now by reading the actual bytes. I use the <code>FileStream</code> this time, so we have a bit more control over what is happening:</p>
			<pre class="source-code">
public string ReadWithStream(string fileName)
{
    byte[] fileContent;
    using (FileStream fs = File.OpenRead(fileName))
    {
        fileContent = new byte[fs.Length];
        fs.Read(fileContent, 0, (int)fs.Length);
        fs.Close();
    }
    return Encoding.ASCII.GetString(fileContent);
}</pre>			<p>The nice thing about the <code>FileStream</code> is that it knows the length of the stream. That means that we can allocate enough space for our array to contain all the data.</p>
			<p>We will read all data through one call to <code>fs.Read()</code>, giving it the byte array, the start position <code>0</code>, and the total number of bytes to read. Again, we will close the stream when we are done with it.</p>
			<p>Last, we will convert the file to a string, assuming the contents are ASCII characters.</p>
			<p>This way of reading works fine if you have a relatively small file. In that case, you can read it all in <a id="_idIndexMarker353"/>one go. However, if the file is too big, you must read it in chunks.</p>
			<p>For that, the <code>Read()</code> method helps you by telling you how much data it has read. You can create a loop and iterate through the complete file.</p>
			<p>We can rewrite the part where we read the file like this:</p>
			<pre class="source-code">
fileContent = new byte[fs.Length];
int i = 0;
int bytesRead=0;
do
{
    var myBuffer = new byte[1];
    bytesRead = fs.Read(myBuffer, 0, 1);
    if(bytesRead &gt; 0)
        fileContent[i++] = myBuffer[0];
}while(bytesRead &gt; 0);
fs.Close();</pre>			<p>This is a silly way to do this, but it illustrates my point. We will keep reading the file until we have all the data, in which case <code>fs.Read()</code> returns <code>0</code>.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>Reading binary data</h2>
			<p>If you have a <code>binary</code> file that <a id="_idIndexMarker354"/>you know the structure of, you can use a  <code>BinaryReader</code> to help.</p>
			<p>Binary data is usually much more memory-efficient than text data. Since we, as systems programmers, are always searching for more efficient code, this is worth looking into.</p>
			<p>Let’s assume that I have the following class. This doesn’t mean anything special; it is just a data collection:</p>
			<pre class="source-code">
class MyData
{
    public int Id { get; set; }
    public double SomeMagicNumber { get; set; }
    public bool IsThisAGoodDataSet { get; set; }
    public MyFlags SomeFlags { get; set; }
    public string? SomeText { get; set; }
}
[Flags]
public enum MyFlags
{
    FlagOne,
    FlagTwo,
    FlagThree
}</pre>			<p>Let us <a id="_idIndexMarker355"/>assume that I have created an instance of this class with the properties <code>42</code>, <code>3.1415</code>, <code>True</code>, <code>MyFlags.One | MyFlags.Three</code> and <code>Hello, Systems Programmers</code>. I can write it to a file using JSON serialization. That results in a file of 114 bytes. If I use a binary format, I can shrink it down to 44 bytes. That is a considerable saving, especially when putting that data on a network.</p>
			<p>Reading that file is straightforward using the <code>BinaryReader</code> class. Let me show you:</p>
			<pre class="source-code">
public MyData Read(string fileName)
{
    var myData = new MyData();
    using var fs = File.OpenRead(fileName);
    try
    {
        using BinaryReader br = new(fs);
        myData.Id = br.ReadInt32();
        myData.IsThisAGoodDataSet = br.ReadBoolean();
        myData.SomeMagicNumber = br.ReadDouble();
        myData.SomeFlags = (MyFlags)br.ReadInt32();
        myData.SomeText = br.ReadString();
    }
    finally
    {
        fs.Close();
    }
    return myData;
}</pre>			<p>Doing it this<a id="_idIndexMarker356"/> way means that you have to be very careful. You have to know the structure of the file precisely. You are responsible for getting all data in the correct order and knowing each field’s type exactly. However, doing it this way ensures efficiency and can save you many CPU cycles.</p>
			<p>We now know all about how to read and write files. However, files are not the only things we can find in file systems. We need a way to organize all those files. That brings us to the next topic in IO: directories!</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Directory operations</h1>
			<p>Imagine having <a id="_idIndexMarker357"/>a file system with one root folder. All files on your drive are stored there. You would have a tough time finding all your files. Luckily, operating systems all support the notion of folders or directories. The CLR helps us by giving us two classes to work with paths, folders, and directories: <strong class="bold">Path</strong> and <strong class="bold">Directory</strong>.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>The Path class</h2>
			<p><code>Path</code> is a<a id="_idIndexMarker358"/> class that has helper methods for dealing with<a id="_idIndexMarker359"/> paths. With <code>Path</code>, I mean the string that denotes the name of a directory. You should use the <code>Directory</code> class when dealing with the actual directory and files.</p>
			<p>We have already seen the <code>Path</code> class in previous samples. I used it to get a temporary filename and the name of the <code>Documents</code> folder. I also used it to combine a path and a filename to avoid dealing with path separators myself.</p>
			<p>There are quite a few handy<a id="_idIndexMarker360"/> methods and properties in the <code>Path</code> class. You can see some of the most-used ones in the following table.</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-4">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Method</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.Combine</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Combines two or more strings into a path</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ath.GetFileName</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the filename and extension of the specified path string</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.GetFileNameWithoutExtension</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the filename of the specified path string without the extension</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.GetExtension</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the extension (including the period) of the specified path string</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.GetDirectoryName</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the directory information for the specified path string</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.GetFullPath</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Converts a relative path to an absolute path</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.GetTempPath</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the path to the system’s temporary folder</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.GetRandomFileName</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns a random filename that is not already in use</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.GetInvalidFileNameChars</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an array of characters that are not allowed in filenames on the current platform</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.GetInvalidPathChars</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an array of characters that are not allowed in path strings on the current platform</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.ChangeExtension</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Changes the extension of a file path</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.HasExtension</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines whether a path includes a filename extension</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.IsPathRooted</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets a value indicating whether the specified path string contains a root</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Path.DirectorySeparatorChar</code></p>
						</td>
						<td class="No-Table-Style">
							<p>A platform-specific separator character that is used in path strings</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.2: The Path class and its methods and properties</p>
			<p>As you can see, the <code>Path</code> class <a id="_idIndexMarker361"/>has a set of nice and convenient helpers. We will encounter them again when we investigate other platforms, but for now, please remember to use them as much as possible.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>The Directory class</h2>
			<p>The <code>Directory</code> class<a id="_idIndexMarker362"/> deals with the actual directory in <a id="_idIndexMarker363"/>your filesystem. This class works closely with the <code>Path</code> class. If you need to specify the directory’s name (and thus its location), you would use the <code>Path</code> class.</p>
			<p>Let’s assume that we want to list all images in our <code>Pictures</code> folder on our Windows machine. You would do that like this:</p>
			<pre class="source-code">
var imagesPath =
Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
string[] allFiles =
    Directory.GetFiles(
        path: imagesPath,
        searchPattern: "*.jPg",
        searchOption: SearchOption.AllDirectories);
foreach (string file in allFiles)
{
    Console.WriteLine(file);
}</pre>			<p>I use <code>Environment.SpecialFolder.MyPictures</code> here to identify the folder that has all <a id="_idIndexMarker364"/>my pictures. The actual path depends on your operating system, the username, and how you have set up your machine. That means there are a lot of possible <a id="_idIndexMarker365"/>variations, but we need not bother much about that. Let the operating system figure that out, as long as we get the correct folder.</p>
			<p>I used the <code>Directory.GetFiles()</code> method to iterate through that folder. I want all the JPEG images I have collected in all subfolders. Notice how I spelled the extension in the <code>searchPattern</code> variable: <code>*.jPg</code>. On Windows, filenames are not case-sensitive. On Linux, they are. So, on a Linux-based machine, this would not work. Okay, it will work, but it does not return all the files you might expect to get. Unfortunately, <code>GetFiles()</code> cannot set up a filter for case insensitivity. If you want to get all JPG images, no matter what their extensions look like, you have to do this another way:</p>
			<pre class="source-code">
var regex = new Regex(@"\.jpe?g$", RegexOptions.IgnoreCase);
var allFiles =
    Directory.EnumerateFiles(imagesPath)
        .Where(file =&gt; regex.IsMatch(file));</pre>			<p>I have created a <a id="_idIndexMarker366"/>regular expression here, saying I want to filter on strings that end in <code>.jpg</code> or <code>jpeg</code> and ignore the case. Then I use <code>Directory.EnumerateFiles()</code> and apply the <code>Where()</code> LINQ operator to apply the <code>regex</code> filter.</p>
			<p>This method works fine on all platforms. You could have avoided the <code>regex</code> filter by using the following code, which is more verbose but, I assume, more readable to many people:</p>
			<pre class="source-code">
var files = Directory.EnumerateFiles(imagesPath)
    .Where(file =&gt; file.EndsWith(".jpg",
StringComparison.OrdinalIgnoreCase) ||
                   file.EndsWith(".jpeg",
StringComparison.OrdinalIgnoreCase));</pre>			<p>I have collected <a id="_idIndexMarker367"/>the most-used methods and properties of the <code>Directory</code> class <a id="_idIndexMarker368"/>for you in the following table:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-3">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Method </strong><strong class="bold">or property</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.CreateDirectory</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates all directories and subdirectories in the specified path unless they already exist</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory. Delete</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes the specified directory and, optionally, any subdirectories and files in the directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.Exists</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines whether the given path refers to an existing directory on the disk</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.GetCurrentDirectory</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the current working directory of the application</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.GetDirectories</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the names of subdirectories (including their paths) in the specified directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.GetFiles</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the names of files (including their paths) in the specified directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.GetFileSystemEntries</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the names of all the files and subdirectories in a specified directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.GetLastAccessTime</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the date and time when the specified file or directory was last accessed</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.GetLastWriteTime</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the date and time when the specified file or directory was last written to</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.GetParent</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves the parent directory of the specified path, including both absolute and relative paths</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.Move</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Moves a file or a directory and its contents to a new location</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.SetCreationTime</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the creation date and time for the specified file or directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.SetCurrentDirectory</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the application’s current working directory to the specified directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.SetLastAccessTime</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the date and time when the specified file or directory was last accessed</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Directory.SetLastWriteTime</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the date and time when the specified file or directory was last written to</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.3: The methods and properties of the Directory class</p>
			<p>The <code>Directory</code> has <a id="_idIndexMarker369"/>some nice helpers and properties. You<a id="_idIndexMarker370"/> could figure out all of these properties yourself, but why bother if the CLR is friendly enough to help you? These properties will also be beneficial when we move to other platforms later on.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>The DirectoryInfo class</h2>
			<p>There is <a id="_idIndexMarker371"/>one more <a id="_idIndexMarker372"/>class I want to discuss: the <code>DirectoryInfo</code> class. The difference between <code>Directory</code> and <code>DirectoryInfo</code> is that the former uses static methods, whereas the latter is used as an instance. <code>Directory</code> returns information about directories as strings. <code>DirectoryInfo</code> returns objects with much more information. Let me give you an example:</p>
			<pre class="source-code">
var imagesPath = Environment.GetFolderPath(
    Environment.SpecialFolder.MyPictures);
var directoryInfo = new DirectoryInfo(imagesPath);
Console.WriteLine(directoryInfo.FullName);
Console.WriteLine(directoryInfo.CreationTime);
Console.WriteLine(directoryInfo.Attributes);</pre>			<p>I created an instance of the <code>DirectoryInfo</code> class and gave it the path to our <code>images</code> folder. This instance has a lot of valuable properties, such as the full name, time of creation, attributes, and many more. I have listed the most-used properties and methods in <a id="_idIndexMarker373"/>the following table.</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Method </strong><strong class="bold">or property</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Create</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates a directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Delete</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes this instance of a <code>DirectoryInfo</code>, specifying whether to delete subdirectories and files</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Exists</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets a value indicating whether the directory exists</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Extension</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the string representing the extension part of the directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.FullName</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the full path of the directory or file</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Name</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the name of this <code>DirectoryInfo</code> instance</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Parent</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the parent directory of a specified subdirectory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Root</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the root portion of a path</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.GetFiles</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns a file list from the current directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.GetDirectories</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the subdirectories of the current directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.GetFileSystemInfos</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves an array of <code>FileSystemInfo</code> objects representing the files and subdirectories of the current directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.MoveTo</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Moves a <code>DirectoryInfo</code> instance and its contents to a new path</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Refresh</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Refreshes the state of the object</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.EnumerateFiles</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an enumerable collection of file information in the current directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.EnumerateDirectories</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an enumerable collection of directory information in the current directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryInfo.Enumerate FileSystemInfos</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an enumerable collection of file system information in the current directory</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.4: DirectoryInfo properties and methods</p>
			<p>As you <a id="_idIndexMarker374"/>can see, <code>Path</code>, <code>Directory</code>, and <code>DirectoryInfo</code> can <a id="_idIndexMarker375"/>greatly help when dealing with files.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/>File system monitoring</h1>
			<p>As<a id="_idIndexMarker376"/> systems programmers, we must find ways to communicate with our apps. After all, there is no user interface wherein the user can indicate their desired actions.</p>
			<p>Most apps in that category listen to network ports or have other ways for systems to communicate with them. One of those ways is to wait for changes in files or directories.</p>
			<p>Keeping an eye on files or folders is a fairly common scenario. For instance, we could build a system that processes the files that we get through an email system. As soon as a file is delivered as an attachment, the mail client places it in a directory and our system picks it up.</p>
			<p>This means that we need to have a way to keep an eye on that folder. Luckily, that is not too hard to do. It does require some explanation, so let me walk you through it.</p>
			<p>We will begin with the class that other classes interact with:</p>
			<pre class="source-code">
internal class MyFolderWatcher : Idisposable
{
    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            // Dispose managed state (managed objects).
        }
    }
     ~MyFolderWatcher()
    {
        Dispose(false);
    }
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}</pre>			<p>We will need to <a id="_idIndexMarker377"/>clean up some resources later, so I have implemented the <code>IDisposable</code> interface here. The class that we need to clean up is an instance of the <code>FileSystemWatcher</code> type. This class, when instantiated, keeps an eye on a folder and, optionally, a filter for the filenames. If something of interest happens there, the <code>FileSystemWatcher</code> notifies us. It is up to us to define what “something of interest” means.</p>
			<p>Let’s set it up as a private member of our class:</p>
			<pre class="source-code">
private FileSystemWatcher? _watcher;</pre>			<p>We could change our <code>Dispose</code>(bool disposing) method to clean this up, but I will hold on to that for now. We need to do more than just dispose of the <code>FileSystemWatcher</code>.</p>
			<p>A <code>FileSystemWatcher</code> is resource-intensive. Keeping an eye on a folder can lead to much CPU pressure. Therefore, we must be sure to only enable it when we need it.</p>
			<p>Then, we will add a method that enables the watcher and set some settings:</p>
			<pre class="source-code">
public void SetupWatcher(string pathToWatch)
{
    if(_watcher != null)
        throw new InvalidOperationException(
            "The watcher has already been set up");
    if(!Path.Exists(pathToWatch))
        throw new ArgumentOutOfRangeException(
            nameof(pathToWatch),
            "The path does not exist");
    // Set the folder to keep an eye on
    _watcher = new FileSystemWatcher(pathToWatch);
    // We only want notifications when a file is created or
    // when it has changed.
    _watcher.NotifyFilter =
        NotifyFilters.FileName |
        NotifyFilters.LastWrite;
    // Set the callbacks
    _watcher.Created += WatcherCallback;
    _watcher.Changed += WatcherCallback;
    // Start watching
    _watcher.EnableRaisingEvents = true;
}</pre>			<p>We will start <a id="_idIndexMarker378"/>with two checks. First, we will see whether the watcher has not already been created. If it has, we will throw an error. The second is to check whether the supplied path exists or not.</p>
			<p>If those two checks both pass, we will create an instance of the <code>FileSystemWatcher</code> class and give it the path we want to monitor.</p>
			<p>You can specify <a id="_idIndexMarker379"/>what you want to monitor. This is controlled by the <code>NotifyFilter</code> property. This property takes an enum or a combination of the <code>NotifyFilter</code> enums. You can see what your options are in the following table.</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table005">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">NotifyFilters enum</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Attributes</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes in the attributes of the file or folder</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>CreationTime</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Monitors changes to the creation times of files and directories</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DirectoryName</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes in the names of directories</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>FileName</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes in the names of files</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>LastAccess</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Monitors changes to the last access times of files and directories</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>LastWrite</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes to the last write times of files and directories</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Security</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Monitors changes in the security settings of files and directories</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Size</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes in the sizes of files and directories</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.5: NotifyFilters options</p>
			<p>I am only interested in new or changed files in our folder. So, I have given it the <code>NotifyFilters.FileName</code> | <code>NotifyFilters.LastWrite</code> value. The <code>FileName</code> of a file changes, of course, when you first create the file. I could also have chosen <code>CreationTime</code>, which hardly ever changes. I will also keep a watch on <code>LastWrite</code>, which tells me when a file has changed.</p>
			<p>After this, I will<a id="_idIndexMarker380"/> give the <code>_watcher</code> a callback to call when either of the two events I care about are raised. Since all events share the same signature, I can get away with just one method. That method is what we will look at next. However, before we do that, we need to start the watcher by setting <code>_watcher.EnableRaisingEvents</code> to <code>True</code>. The next piece of code contains the body of the <code>eventhandler</code>:</p>
			<pre class="source-code">
private void WatcherCallback(object sender, FileSystemEventArgs e)
{
    switch (e.ChangeType)
    {
        case WatcherChangeTypes.Created:
            FileAdded?.Invoke(this, new FileCreatedEventArgs                 (e.FullPath));
            break;
        case WatcherChangeTypes.Changed:
            FileChanged?.Invoke(this, new
                FileChangedEventArgs(e.FullPath));
            break;
    }
}</pre>			<p>When the watcher calls this callback, we get an instance of the <code>FileSystemEventArgs</code> class. This class contains a field called <code>ChangeType</code> that indicates what type of change triggered this call. It also contains the full path and name of the file affected in the <code>FullPath</code> property.</p>
			<p>We will switch on that <code>ChangeType</code> field and call one of the two event handlers for our class. Those two event handlers that are part of our class look like this:</p>
			<pre class="source-code">
public event EventHandler&lt;FileCreatedEventArgs&gt;? FileAdded;
public event EventHandler&lt;FileChangedEventArgs&gt;? FileChanged;</pre>			<p>The <code>FileCreatedEventArgs</code> and <code>FileChangedEventArgs</code> types for the <code>EventHandler</code> are straightforward as well. I could have used only one type. However, for future<a id="_idIndexMarker381"/> uses, I decided to give them distinct classes that I might extend at some point with more information. They look like this:</p>
			<pre class="source-code">
public class FileCreatedEventArgs : EventArgs
{
    public FileCreatedEventArgs(string filePath)
    {
        FilePath = filePath;
    }
    public string FilePath { get; }
}
public class FileChangedEventArgs : EventArgs
{
    public FileChangedEventArgs(string filePath)
    {
        FilePath = filePath;
    }
    public string FilePath { get; }
}</pre>			<p><code>FileSystemWatcher</code> implements <code>IDisposable</code>. So, we must dispose of it when we no longer use it. We need to rewrite our own <code>Dispose(bool disposing)</code> method to look<a id="_idIndexMarker382"/> like this:</p>
			<pre class="source-code">
protected virtual void Dispose(bool disposing)
{
    if (!disposing) return;
    if (_watcher == null)
        return;
    // Stop raising events
    _watcher.EnableRaisingEvents = false;
    // Clean whoever has subscribed to us
    // to prevent memory leaks
    FileAdded = null;
    FileChanged = null;
    _watcher.Dispose();
    _watcher = null;
}</pre>			<p>After doing some checks, we will stop the system from receiving any events. Then we will clear the events. If we do not do this, other objects might hold a reference to our class and thus prevent this class from being freed from memory.</p>
			<p>When that is done, we dispose of <code>_watcher</code> and set it to null.</p>
			<p>That’s it. If you run it from your program, give it a folder, and attach some <code>eventhandlers</code> to it, you will be able to see what happens when you add or change files in that folder.</p>
			<p>It is almost perfect. Almost – but not quite.</p>
			<p>If you add a file, you will get multiple events. If you think about that, it makes sense. After all, a file is created on the file system and then it is changed immediately. If you wanted to, you could change our class to consider that. It is not hard to do, so I will leave that up to you.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Asynchronous I/O</h1>
			<p>I have said it<a id="_idIndexMarker383"/> before, but this is so important that I have to repeat it here: IO is slow. Every piece of code that works with IO should be done asynchronously. Luckily, most of the classes in the <code>System.IO</code> namespace have asynchronous members that we can use with async/await.</p>
			<p>I would be happy if Microsoft decided to mark all non-asynchronous methods in <code>System.IO</code> as obsolete.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/>The naïve approach</h2>
			<p>Most of the<a id="_idIndexMarker384"/> methods you know in <code>System.IO</code> have an asynchronous version. So, just add the <code>async</code> postfix to the method name and await it. Simple!</p>
			<p>On second thought, no. It is not that simple.</p>
			<p>Let me show you an example:</p>
			<pre class="source-code">
public async Task CreateBigFileNaively(string fileName)
{
    var stream = File.CreateText(fileName);
    for (int i = 0; i &lt; Int32.MaxValue; i++)
    {
            var value = $"This is line {i}";
            Console.Writeline(value);
            await stream.WriteLineAsync(value);
                await Task.Delay(10);
    }
    Console.WriteLine("Closing the stream");
    stream.Close();
    await stream.DisposeAsync();
}</pre>			<p>This method<a id="_idIndexMarker385"/> creates a file and then writes a string line to it. Once finished, it closes the file and nicely disposes of it. It does that asynchronously. So this is the way things should be, right?</p>
			<p>Let’s use this method:</p>
			<pre class="source-code">
var asyncSample = new AsyncSample();
await asyncSample.CreateBigFileNaively(@"c:\temp\bigFile.txt");</pre>			<p>Add these two lines to your main Console application. Run it and let it run for a few seconds. Note what line is written to the file on the screen (it should say something to the effect of <em class="italic">This is the line n</em>, where <code>n</code> is the number of the line). Then press <em class="italic">Ctrl</em> + <em class="italic">C</em> to cancel the operation. The program will stop. Now, please open the file and see how far it got. There is a big chance that you will see that the last line written on the file is not the number that you saw on the screen.</p>
			<p>Why is that, you might wonder? The CLR ensures that performance is as high as possible for our code. So, all data written to a file system is buffered into a cache before it is sent to the SSD or other media. After all, writing to storage is slow. However, since we killed the process, the CLR did not have time to flush the cache.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor126"/>Using CancellationTokens</h2>
			<p>Of course, this<a id="_idIndexMarker386"/> would not happen often in the real world. However, you might want to cancel a long-running IO process, and then you might encounter this.</p>
			<p>There is a solution to this. Remember the chapter where we talked about threads? Remember that I said that there was this thing called a <code>CancellationToken</code>? That is the one that we need.</p>
			<p>Let’s rewrite<a id="_idIndexMarker387"/> the code that writes the file. Let’s remove the <code>naïve</code> from the method name; we know better now:</p>
			<pre class="source-code">
public async Task CreateBigFile(string fileName, CancellationToken cancellationToken)
{
    var stream = File.CreateText(fileName);
    for (int i = 0; i &lt; Int32.MaxValue; i++)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            Console.WriteLine("We are being cancelled");
            break;
        }
        else
        {
            var value = $"This is line {i}";
            Console.WriteLine(value);
            await stream.WriteLineAsync(value);
            try
            {
                await Task.Delay(10, cancellationToken);
            }
            catch (TaskCanceledException)
            {
                Console.WriteLine("We are being cancelled");
                break;
            }
        }
    }
    Console.WriteLine("Closing the stream");
    stream.Close();
    await stream.DisposeAsync();
}</pre>			<p>We have <a id="_idIndexMarker388"/>added quite a bit of code here. Let me walk you through it. First, we added a parameter of the <code>CancellationToken</code> type to the method. We will constantly check to see whether <code>Cancel</code> has been requested in our loop. If so, we will print the message on the screen and graciously exit the loop.</p>
			<p>In the <code>Task.Delay()</code>, we also passed the <code>CancellationToken</code>. After all, while the system waits for this delay, the cancellation can also be requested. However, when that happens during a <code>Task.Delay()</code>, the CLR will throw an exception of the <code>TaskCanceledException</code> type. We have to catch that to prevent our program from crashing and stopping. That’s why we have the <code>try..catch</code> block here. We need that <code>try..catch</code> block to prevent the exception from bubbling up the call stack.</p>
			<p>We have to mimic breaking up the loop from the outside. Change the code that calls this method into the following:</p>
			<pre class="source-code">
var cancellationTokenSource = new
CancellationTokenSource();
ThreadPool.QueueUserWorkItem((_) =&gt;
{
    Thread.Sleep(10000);
    Console.WriteLine("About to cancel the operation");
    cancellationTokenSource.Cancel();
});
var asyncSample = new AsyncSample();
await asyncSample.CreateBigFile(
    @"c:\temp\bigFile.txt",
    cancellationTokenSource.Token);</pre>			<p>First, we <a id="_idIndexMarker389"/>will create a new <code>CancellationtokenSource</code>. Then, we will pull a thread from the <code>ThreadPool</code> and give it something to do. After waiting for 10 seconds, it will request a cancellation.</p>
			<p>The call to <code>CreateBigFile</code> now has a <code>CancellationTokenSource</code>.</p>
			<p>Run it and see that it stops after 10 seconds. Notice which line it stopped on and check the actual file to see whether that was the last line written to it. On my machine, this works nicely.</p>
			<p>Remember: when dealing with asynchronous file handling, no matter what you do, try to use a <code>CancellationSourceToken</code>. Also, be sure that you deal with any side effects. Be sure to clean up after the cancellation has been requested so that the CLR can properly flush the cache and clean up its resources.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>BufferedStream</h2>
			<p>The<a id="_idIndexMarker390"/> CLR is pretty good at maximizing performance for your I/O operations. As we saw, it can cache data before writing to external devices. This caching speeds up our code since we no longer have to wait for the slow write operations to finish. However, the CLR makes an educated guess about those caches. Sometimes it gets it wrong. If we know the size of the data we want to write, we can use that knowledge to get even more performance out of our application.</p>
			<p>Let’s say that we have a system that writes the following record to the I/O:</p>
			<pre class="source-code">
internal readonly record struct DataRecord
{
    public int Id { get; init; }
    public DateTime LogDate { get; init; }
    public double Price { get; init; }
}</pre>			<p>This block is 24 bytes long. We can quickly determine that by adding up the sizes of <code>int</code>, <code>DateTime</code>, and double.</p>
			<p>If we write that to a file, the CLR will cache it until the systems find a suitable moment to do the actual writing of the data to the storage. However, we can improve that. We can use the <code>BufferedStream</code> class to write this data to a buffer first. Then the CLR can flush that buffer to the underlying storage when it thinks it is the best time. The advantage here is that we control the size of that buffer or cache. If we specify the size just right, we will not waste memory. However, we are also not making it too small so that it flushes too often. It is just right for us.</p>
			<p>The code to do that looks like this:</p>
			<pre class="source-code">
public async Task WriteBufferedData(string fileName)
{
    var data = new DataRecord
    {
        Id = 42,
        LogDate = DateTime.UtcNow,
        Price = 12.34
    };
    await using FileStream stream = new(fileName, FileMode.CreateNew,     FileAccess.Write);
    await using BufferedStream bufferedStream = new(stream,
    Marshal.SizeOf&lt;DataRecord&gt;());
    await using BinaryWriter writer = new(bufferedStream);
    writer.Write(data.Id);
    writer.Write(data.LogDate.ToBinary());
    writer.Write(data.Price);
}</pre>			<p>First, we will create a <code>FileStream</code>. This <code>FileStream</code> is the actual handle to the file we are<a id="_idIndexMarker391"/> writing to. Then, we will create a <code>BufferedStream</code> and give it the <code>FileStream</code> and the size of the record that we want to write. After that, we will create a <code>BinaryWriter</code> to take our data and write it to the buffer as efficiently as possible.</p>
			<p>When that has all been set up, we will do the writing.</p>
			<p class="callout-heading">A word of warning</p>
			<p class="callout">If you are not sure of the size of the data, having a <code>BufferedStream</code> might work against you. <code>BufferedStream</code> works best if you are doing a lot of smaller, frequent writes of data that you know the size of. Otherwise, the cache management is best left to the CLR.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>File system security</h1>
			<p>Files are<a id="_idIndexMarker392"/> where we store things. Those things might not be for everybody to see. Sometimes, we must hide data or ensure that only programs that we trust can access it. OSs can help. Every OS has a way of handling access to files and directories. You can generally allow or disallow read- or write access to them.</p>
			<p>However, what happens when you want to share files? Let us assume that you want to transfer data over a wire or store it on another drive such as a removable USB drive. In that case, ensuring that level of security is quite challenging. This means that you might have to encrypt data to prevent it from being abused.</p>
			<p class="callout-heading">Security – a topic of its own</p>
			<p class="callout">I am only covering the basics of security and encryption here. This is not a complete guide to this complicated and extensive topic. There have been hundreds of books written on this topic alone. I want you to know that you can do security and encryption. However, if you want to take this seriously, I suggest that you go out and find a few good resources on those topics and learn from there.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/>Encryption basics</h2>
			<p>Basically, we<a id="_idIndexMarker393"/> have two encryption flavors: <strong class="bold">symmetric</strong> and <strong class="bold">asymmetric</strong> algorithms. Although<a id="_idIndexMarker394"/> there are many<a id="_idIndexMarker395"/> similarities between them, one big difference is in how they handle keys.</p>
			<p>Let’s discuss an elementary sample. We’ll say that you have a message and want to transmit it to someone else. Since the contents of the message are sensitive, you do not want anyone else to be able to read it, so you decided to encrypt it. That means that you will change the contents of your message so that nobody can make any sense of it. The recipient then decrypts it to change your text into something intelligible. We call the text that people can actually read and <a id="_idIndexMarker396"/>understand <strong class="bold">cleartext</strong>. In contrast, the encrypted, unreadable text is something<a id="_idIndexMarker397"/> we call <strong class="bold">ciphertext</strong>. People read cleartext; ciphertext needs decrypting.</p>
			<p>This way of protecting information is not new. Julius Caesar did such a thing over 2,000 years ago. He used a straightforward substitution algorithm. All he did was take a piece of text he wanted to send to his commanders in the field and then shift all characters left or right by a certain number of positions. The number here is what we call his key.</p>
			<p>So, if Ceasar chose a key of <code>3</code>, all As in his message would become Ds. The character B would become an E, and so on.</p>
			<p>If you knew the key, you could take his ciphertext and reverse the operation to get back to the cleartext.</p>
			<p>The problem here is to transmit the actual number to use. Both parties need to know the key, or things never work out. You need a secure way of telling the other person which key to use so that they can decrypt your ciphertext into cleartext.</p>
			<p>If you know the other person, sharing this key is not hard. You can walk up to them, give them the key on a piece of paper in a sealed envelope, and tell them to open it only when they receive the encrypted message. These days, however, that is a lot harder to do. Computers do not know the other computer they want to talk to. It is hard to exchange keys safely.</p>
			<p>A possible solution for this is asymmetric encryption and decryption. This solution is complicated, but the basis is this: you have two keys. One key is used to encrypt the data and another is used to decrypt the data. One of the keys is kept private and the other is made public. The private key is yours and yours alone. You use it to encrypt a file. Anyone with the public key can then decrypt it. Of course, if you want the message to only be read by one other party, you can reverse this. You can request that the other party share their public key with you. You would then take that key and encrypt the message. Now, only the other party can decrypt it again with their private key.</p>
			<p>Symmetric algorithms<a id="_idIndexMarker398"/> are much faster than asymmetric ones. However, they face the issue of key sharing. This issue is why most algorithms combine the two methods. They use an asymmetric algorithm to encrypt a key, which can be used for symmetric encryption. The key is relatively tiny, so encrypting and decrypting can be done reasonably quickly. Then that symmetric key is used to encrypt the complete message. This way, the symmetric key can be part of the message. It is encrypted itself, so only the intended recipient can decrypt the key and, thus, the rest of the message.</p>
			<p>If this sounds complicated, I have some good news: the CLR has many classes to help us do this. They are pretty simple to use as well.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>Symmetric encryption and decryption</h2>
			<p>Let’s see <a id="_idIndexMarker399"/>whether we can encrypt and decrypt<a id="_idIndexMarker400"/> a simple message in C# code:</p>
			<pre class="source-code">
public static void EncryptFileSymmetric(string inputFile, string outputFile, string key)
{
    using (FileStream inputFileStream = new
    FileStream(inputFile, FileMode.Open, FileAccess.Read))
    using (FileStream outputFileStream = new FileStream(outputFile,     FileMode.Create, FileAccess.Write))
    {
        byte[] keyBytes = Encoding.UTF8.GetBytes(key);
        using (Aes aesAlg = Aes.Create())
        {
            aesAlg.Key = keyBytes;
            aesAlg.GenerateIV();
            byte[] ivBytes = aesAlg.IV;
            outputFileStream.Write(ivBytes, 0, ivBytes.Length);
            using (CryptoStream csEncrypt = new
               CryptoStream(outputFileStream,                aesAlg.CreateEncryptor(),
                       CryptoStreamMode.Write))
            {
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead =
                   inputFileStream.Read(buffer,                    0, buffer.Length)) &gt; 0)
                {
                    csEncrypt.Write(buffer, 0, bytesRead);
                }
            }
        }
    }
}</pre>			<p>This<a id="_idIndexMarker401"/> method<a id="_idIndexMarker402"/> takes the names of an input file, an output file, and a key. Then, it opens the input file, reads its contents, encrypts it, and writes the cyphertext to the output file.</p>
			<p>The way this works is pretty straightforward.</p>
			<p>First, we will create the two streams. Then we will take the key and generate its byte array. The key must be a 128-bit, 192-bit, or 256-bit array. In other words, it has to be 16, 24, or 32 bytes long. The longer the key, the harder it is to hack. However, a long key also slows down the encryption and decryption processes. The choice is yours.</p>
			<p>We will <a id="_idIndexMarker403"/>create an<a id="_idIndexMarker404"/> instance of the <code>Aes</code> class. <strong class="bold">Advanced Encryption Standard</strong> (<strong class="bold">AES</strong>) is <a id="_idIndexMarker405"/>widely considered a good and safe encryption algorithm. To make things even safer, the key we will use is augmented<a id="_idIndexMarker406"/> with an <strong class="bold">Initialization Vector</strong> (<strong class="bold">IV</strong>). You can think of this as something we add to the key to make it less readable. We will write that IV as the first thing in our file.</p>
			<p>Then, we will create an instance of the <code>CryptoStream</code> class. This class helps us write encrypted data, as you can see in the ensuing code block. We will take arrays of bytes and write them to the <code>CryptoStream</code> class. Since we initialized the <code>CryptoStream</code> class with our AES class (well, the result of the call to <code>CreateEncryptor</code> of that class, to be more precise), it uses our key to encrypt data.</p>
			<p>Decrypting is also simple. It works along the same principle: get the files from the key, read the IV from the file, then decrypt the rest and store it in a new file. That looks like this:</p>
			<pre class="source-code">
public static void DecryptFileSymmetric(string inputFile, string outputFile, string key)
{
    using (FileStream inputFileStream = new FileStream(inputFile,     FileMode.Open, FileAccess.Read))
    using (FileStream outputFileStream = new FileStream(outputFile,     FileMode.Create, FileAccess.Write))
    {
        byte[] keyBytes = Encoding.UTF8.GetBytes(key);
        using (Aes aesAlg = Aes.Create())
        {
            byte[] ivBytes = new byte[aesAlg.BlockSize / 8];
            inputFileStream.Read(ivBytes, 0,
               ivBytes.Length);
            aesAlg.Key = keyBytes;
            aesAlg.IV = ivBytes;
            using (CryptoStream csDecrypt =
                   new CryptoStream(outputFileStream,
                   aesAlg.CreateDecryptor(), CryptoStreamMode.Write))
            {
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead =
                inputFileStream.Read(buffer, 0, buffer.Length)) &gt; 0)
                {
                    csDecrypt.Write(buffer, 0, bytesRead);
                }
            }
        }
    }
}</pre>			<p>Instead of <a id="_idIndexMarker407"/>getting<a id="_idIndexMarker408"/> an <code>Encryptor</code> from the <code>CryptoStream</code>, we now get a <code>Decryptor</code>. The rest should be self-explanatory by now.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor131"/>Asymmetric encryption and decryption</h2>
			<p>In the previous<a id="_idIndexMarker409"/> example, we generated a <a id="_idIndexMarker410"/>simple 128-bit, 192-bit, or 256-bit key. For instance, you can pass it a string such as <code>SystemSoftware42</code> and get the bytes. The same key is used for encrypting and decrypting.</p>
			<p>For asymmetric encryption, keys are a bit harder to get. However, there are helper classes for that, so it’s not hard to do in practice. Here is the code:</p>
			<pre class="source-code">
public static (string, string) GenerateKeyPair()
{
    using RSA rsa = RSA.Create();
    byte[] publicKeyBytes = rsa.ExportRSAPublicKey();
    byte[] privateKeyBytes = rsa.ExportRSAPrivateKey();
    string publicKeyBase64 = Convert.ToBase64String(publicKeyBytes);
    string privateKeyBase64 = Convert.ToBase64String(privateKeyBytes);
    return (publicKeyBase64, privateKeyBase64);
}</pre>			<p>I used the <code>RSA</code> class<a id="_idIndexMarker411"/> to generate the key pair. The <strong class="bold">Rivest, Shamir, and Adleman</strong> (<strong class="bold">RSA</strong>) class was <a id="_idIndexMarker412"/>named after the three cryptographers <a id="_idIndexMarker413"/>who invented this algorithm.</p>
			<p>We will create an instance of <code>RSA</code> by calling <code>Create()</code>. Then, we will call <code>ExportRSAPublicKey()</code> and <code>ExportRSAPrivateKey()</code> to get the generated keys out of it.</p>
			<p>Since the keys are byte arrays, we will use <code>ToBase64String()</code> to make them more or less readable. That makes it easier to share the keys.</p>
			<p>Now that we have a key pair, we can use it to encrypt a message. Of course, we can also decrypt it again. That code looks like this:</p>
			<pre class="source-code">
public static byte[] EncryptWithPublicKey(
    byte[] data,
    byte[] publicKeyBytes)
{
    using RSA rsa = RSA.Create();
    rsa.ImportRSAPublicKey(publicKeyBytes, out _);
    return rsa.Encrypt(data, RSAEncryptionPadding.OaepSHA256);
}
public static byte[] DecryptWithPrivateKey(
    byte[] encryptedData,
    byte[] privateKeyBytes)
{
    using RSA rsa = RSA.Create();
    rsa.ImportRSAPrivateKey(privateKeyBytes, out _);
    return rsa.Decrypt(encryptedData, RSAEncryptionPadding.    OaepSHA256);
}</pre>			<p>This <a id="_idIndexMarker414"/>code is <a id="_idIndexMarker415"/>simple enough. I only want to point out the last parameter in the <code>rsa.Encrypt()</code> and <code>rsa.Decrypt()</code> methods. We will use padding here to add extra data to the results (and we will remove it again when decrypting). This padding makes it harder for attackers to try to hack our message.</p>
			<p>You can use the three methods combined like this:</p>
			<pre class="source-code">
(string, string) keyPair = Encryption.GenerateKeyPair();
keyPair.Item1.Dump();
keyPair.Item2.Dump();
var publicKey = Convert.FromBase64String(keyPair.Item1);
var privateKey = Convert.FromBase64String(keyPair.Item2);
string message = "This is the text that we, as System Programmers,     want to secure.";
byte[] messageBytes = Encoding.UTF8.GetBytes(message);
byte[] encryptedBytes = Encryption.EncryptWithPublicKey(messageBytes,     publicKey);
string encrypted = Encoding.UTF8.GetString(encryptedBytes);
encrypted.Dump(ConsoleColor.DarkYellow);
byte[] decryptedBytes = Encryption.    DecryptWithPrivateKey(encryptedBytes, privateKey);
string decrypted = Encoding.UTF8.GetString(decryptedBytes);
decrypted.Dump(ConsoleColor.DarkYellow);</pre>			<p>First, we will create a key pair. Our method returns that pair as strings so we can print them (I am again using our handy <code>Dump()</code> extension method). However, the keys need to be in a binary format, so I am reverting them to byte arrays.</p>
			<p>I will <a id="_idIndexMarker416"/>define <a id="_idIndexMarker417"/>the message I want to encrypt, get the bytes of that message, and encrypt it. Then, I will print the encrypted message. If you do this, I think you will agree that it is hard to see the actual message. It is a mess of characters.</p>
			<p>Then, we will reverse it by calling <code>DecryptWithPrivateKey()</code>. This method returns our string.</p>
			<p>If we send the <code>Base64</code> version of our public key to someone and then transmit the encoded message, they can decode it with that public key. They would be sure that we sent that message; no one, other than us, can generate a message that can be decrypted by that public key but us. After all, private and public keys are a pair. You need one to encrypt so the second can decrypt.</p>
			<p>Julius Caesar would be proud of us!</p>
			<p>However, we have one more thing to talk about. We need to lose weight. Well, not us personally, but the payload in our files could benefit from this. Let’s talk about file compression.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor132"/>File compression</h1>
			<p>Files can get <a id="_idIndexMarker418"/>quite large. As we have already discussed, file IO and network IO take a long time, especially compared to CPUs’ speeds. Anything we can do to minimize the time it takes to read from or write to IO could be worth it. This is even true if it means that we must make the CPU do a lot more. Of course, you need to measure this and see whether that also applies in your situation, but sometimes, sacrificing CPU time to speed up IO can make a huge difference.</p>
			<p>One of the ways to do this is by limiting the amount of data we write in a file or a network stream. That can be done using compression.</p>
			<p>In the CLR, you have a choice. You can use <code>DeflateStream</code> or <code>GZipStream</code> to do this. <code>GZipStream</code> uses <code>DeflateStream</code> internally, so <code>DeflateStream</code> is obviously faster. <code>GZipStream</code>, however, produces compressed files that can be read by external software. GZip is a standardized compression algorithm.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor133"/>Compressing some data</h2>
			<p>Let’s compress <a id="_idIndexMarker419"/>a string using <code>GZipStream</code>:</p>
			<pre class="source-code">
public async Task&lt;byte[]&gt; CompressString(string input,
    CancellationToken cancellationToken)
{
    // Get the payload as bytes
    byte[] data =
    System.Text.Encoding.UTF8.GetBytes(input);
    // Compress to a MemoryStream
    await using var ms = new MemoryStream();
    await using var compressionStream = new GZipStream(ms,
    CompressionMode.Compress);
    await compressionStream.WriteAsync(data, 0,
    data.Length, cancellationToken);
    await compressionStream.FlushAsync(cancellationToken);
    // Get the compressed data.
    byte[] compressedData = ms.ToArray();
    return compressedData;
}</pre>			<p>Since compression and decompression might take a long time to finish, we really should use the <code>Async/Await</code> pattern here.</p>
			<p>We will take<a id="_idIndexMarker420"/> some strings that we want to compress and pass them to the input variable. I use a <code>MemoryStream</code> in this example, but you could use any stream you like. Most real-world examples use a <code>FileStream</code> of some sort.</p>
			<p>I will create an instance of the <code>GZipStream</code> class and give it the <code>MemoryStream</code> instance. This memory stream is where it writes the data. I will also tell the class that I want to compress data.</p>
			<p>Then I just write data to it, flush the buffers, and get the bytes out of it.</p>
			<p>That’s it! I have just compressed a string.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/>Decompressing some data</h2>
			<p>Decompressing <a id="_idIndexMarker421"/>is just as easy. Look at the following code sample:</p>
			<pre class="source-code">
public async Task&lt;string&gt; DecompressString(byte[] input,
    CancellationToken cancellationToken)
{
    // Write the data into a memory stream
    await using var ms = new MemoryStream();
    await ms.WriteAsync(input, cancellationToken);
    await ms.FlushAsync(cancellationToken);
    ms.Position = 0;
    // Decompress
    await using var decompressionStream = new GZipStream(ms,     CompressionMode.Decompress);
    await using var resultStream = new MemoryStream();
    await decompressionStream.CopyToAsync(resultStream,     cancellationToken);
    // Convert to readable text.
    byte[] decompressedData = resultStream.ToArray();
    string decompressedString =
    System.Text.Encoding.UTF8.GetString(decompressedData);
    return decompressedString;
}</pre>			<p>Here, I used two<a id="_idIndexMarker422"/> instances of the <code>MemoryStream</code> class. I used one as the source of the data and one as the destination of the uncompressed data. Again, please use any stream you want.</p>
			<p>You can use these methods as follows:</p>
			<pre class="source-code">
var cts = new CancellationTokenSource();
var myText = "This is some text that I want to compress.";
var compression = new Compression();
var compressed = await compression.CompressString(myText, cts.Token);
var decompressed = await
    compression.DecompressString(compressed, cts.Token);
decompressed.Dump(ConsoleColor.DarkYellow);</pre>			<p>That was not too hard, was it?</p>
			<p>However, we are<a id="_idIndexMarker423"/> not done yet. The data that we want to store or read needs to be in a certain format. If you have a C# class with data in it, you cannot simply write that to a file. We need to translate that somehow. That’s where serialization comes in.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor135"/>Serialization – JSON and Binary</h1>
			<p>Earlier in this <a id="_idIndexMarker424"/>chapter, we saw how to write binary data to a stream. We can call all the <code>write</code> methods to write all sorts of types to a file. However, that can be pretty hard and also quite error-prone. You have to keep track of the format of the data. One simple mistake will make your files unreadable.</p>
			<p>A better way would be to serialize your data in a format that the streams can understand. There are two ways to do that: <strong class="bold">JSON</strong> and <strong class="bold">Binary</strong>.</p>
			<p>JSON is simple: most programming languages and platforms understand it. JSON has become the de facto standard for displaying a structure in text. In most places, JSON has replaced XML. JSON is smaller and more lightweight.</p>
			<p>However, it can be even more lightweight. You can also serialize your data as a binary stream. That requires more coding but usually results in much smaller files and data streams. Again, that might be precisely what we, as system programmers, are looking for.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/>JSON serialization</h2>
			<p>To<a id="_idIndexMarker425"/> serialize an object to the JSON format, people used to<a id="_idIndexMarker426"/> turn to <code>NewtonSoft.JSON</code> by default. <code>NewtonSoft.JSON</code> was the library of choice. It was easy to use (and still is) and offered many features that people liked, such as custom converters. However, Microsoft has since released <code>System.Text.Json</code>, which does the same but is much more efficient. As system programmers, we care about memory efficiency and speed, so I will focus on that one here.</p>
			<p>Before we can <a id="_idIndexMarker427"/>serialize something, we need something to serialize. The advantage of <code>System.Text.Json</code> is that I do not need to change my classes with attributes. The framework is smart enough to figure out what is needed and does that.</p>
			<p>I will use the <a id="_idIndexMarker428"/>same data class we saw earlier in this chapter in these examples. However, to save you from flipping th<a id="_idTextAnchor137"/>rough pages, I present it to you here once again:</p>
			<pre class="source-code">
class MyData
{
    public int Id { get; set; }
    public double SomeMagicNumber { get; set; }
    public bool IsThisAGoodDataSet { get; set; }
    public MyFlags SomeFlags { get; set; }
    public string? SomeText { get; set; }
}
[Flags]
public enum MyFlags
{
    FlagOne,
    FlagTwo,
    FlagThree
}</pre>			<p>If we want to serialize this to JSON to store it as text and later reread it, we will use the following code:</p>
			<pre class="source-code">
public string SerializeToJSon(MyData myData)
{
    var options = new JsonSerializerOptions
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };
    var result =
    System.Text.Json.JsonSerializer.Serialize(myData,options );
    return result;
}</pre>			<p>The code <a id="_idIndexMarker429"/>presented here is pretty straightforward. We will take the <code>MyData</code> class and give it to the static <code>Serialize</code> method, <code>System.Text.Json.JsonSerializer</code>. There are a couple of overloads for this method. I will <a id="_idIndexMarker430"/>use the one that takes an instance of the <code>JsonSerializerOptions</code> class. This way, I can format the output. I will set the <code>WriteIdented</code> property to <code>True</code>. I would get the whole string on one line if I had not done that. Granted, that would have saved me a couple of newline and tab characters, but for readability, I prefer this.</p>
			<p>We will get the following result if we run this with some values in our class:</p>
			<pre class="source-code">
{
  "id": 42,
  "someMagicNumber": 3.1415,
  "isThisAGoodDataSet": true,
  "someFlags": 2,
  "someText": "This is some text that we want to serialize"
}</pre>			<p>Deserializing, thereby<a id="_idIndexMarker431"/> reversing the process, is just as simple:</p>
			<pre class="source-code">
public MyData DeserializeFromJSon(string json)
{
    var options = new JsonSerializerOptions
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };
    var result = System.Text.Json.JsonSerializer.        Deserialize&lt;MyData&gt;(json, options);
    return result!;
}</pre>			<p>As you can see, the <a id="_idIndexMarker432"/>process is simple enough.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>Binary serialization</h2>
			<p>It is not the <a id="_idIndexMarker433"/>most efficient way to encode an object so you can <a id="_idIndexMarker434"/>store it in a file. It is relatively fast, but the actual data is also pretty large. Binary formatting is more work and the result is not human-readable, but it does lead to smaller files. That means that the time spent reading and writing data to a slow storage medium is significantly reduced. Of course, the tradeoff is that the CPU gets a bit busier, but that might be worth it. As always, measure and then decide whether this applies to your situation.</p>
			<p>In .NET Framework, before the days of .NET Core and .NET, we had a class named <code>BinaryFormatter</code>. That class, however, is now marked as obsolete. There are serious security concerns associated with that class, so Microsoft decided to get rid of it.</p>
			<p>There are third-party packages you can use to achieve the same goal. However, if you do not want to use those, you can always do it yourself. We already discussed the <code>BinaryWriter</code> class and its methods. There is nothing wrong with using that class, but the downside is that you must write all the code, writing and reading each field or property. The <code>BinaryFormatter</code> class did that. That was quite handy, to be honest.</p>
			<p>The best package<a id="_idIndexMarker435"/> these days to achieve the same thing is <code>protobuf-net</code>. This package is available on NuGet, making it easy to install in your project. If you want to use <code>protobuf-net</code>, you must annotate your classes before you can serialize them. Using our <code>MyData</code> class again, it would look like this:</p>
			<pre class="source-code">
[ProtoContract]
public class MyData
{
    [ProtoMember(1)]
    public int Id { get; set; }
    [ProtoMember(2)]
    public double SomeMagicNumber { get; set; }
    [ProtoMember(3)]
    public bool IsThisAGoodDataSet { get; set; }
    [ProtoMember(4)]
    public MyFlags SomeFlags { get; set; }
    [ProtoMember(5)]
    public string? SomeText { get; set; }
}</pre>			<p>We have <a id="_idIndexMarker436"/>decorated the class with the <code>ProtoContract</code> attribute. Then, we decorated the properties with the <code>ProtoMember</code> attribute. This attribute can have associated data, but the first one is mandatory. This is the tag and it defines where the field is stored in the file. There is no hard rule on the numbering or the order aside from one: you cannot start with 0. Yes. Indeed. I heard you gasp there. This is the only example I can think of in programming where starting with 0 is forbidden. If you want to start with 42, you can do that. However, the number has to be a positive integer, and 0 is not a positive integer.</p>
			<p>Serializing and deserializing are simple. You have to ensure that the data is available in a memory stream or can be written to a memory stream, but that is the only slightly complicated<a id="_idIndexMarker437"/> thing. This is the code:</p>
			<pre class="source-code">
public async Task&lt;byte[]&gt; SerializeToBinary(MyData myData)
{
    await using var stream = new MemoryStream();
    ProtoBuf.Serializer.Serialize(stream, myData);
    return stream.ToArray();
}
public async Task&lt;MyData&gt; DeserializeFromBinary(byte[] payLoad)
{
    await using var stream = new MemoryStream(payLoad);
    var myData =
        ProtoBuf.Serializer.Deserialize&lt;MyData&gt;(stream);
    return myData;
}</pre>			<p>That is it. I promised you that it would be simple, didn’t I?</p>
			<p>If I take the<a id="_idIndexMarker438"/> same data as in the JSON serialization and compare the sizes, I can see that the binary version is much smaller. Even if I use the option not to write intended files, thus saving on newlines and tabs, the JSON version is 131 bytes. In comparison, the binary version is only 60 bytes long. That is a big difference!</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor139"/>Next steps</h1>
			<p>I/O is essential for all software. No software runs in isolation, especially software written for systems. After all, these applications do not have a traditional user interface; they are meant to be used by other software. The only way to communicate with that software is by exchanging data in one way or another.</p>
			<p>This chapter has looked at ways to serialize and deserialize data to and from storage. We saw that JSON is simple and produces human-readable data. However, the data can be pretty big. In contrast, the binary version results in much smaller data, but that data is not human-readable anymore. Additionally, it requires a third-party package. What is the best solution? That depends on your use cases! It doesn’t matter whether you use files or a network connection; they are all approaches of I/O. In this chapter, you saw how to do that efficiently, quickly, and safely.</p>
			<p>However, one way that is much more efficient for systems software to communicate is through direct communication over <strong class="bold">Interprocess Communications</strong> (<strong class="bold">IPC</strong>). IPC is a perfect way for systems software to establish an interface layer that other software can talk to or listen to. It is also the topic of the next chapter.</p>
		</div>
	</body></html>