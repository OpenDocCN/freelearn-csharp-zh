<html><head></head><body>
        

                            
                    Using Resources and MVVM Patterns
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Using binary resources inside a WPF application</li>
<li>Using binary resources from another assembly</li>
<li>Accessing binary resources in code</li>
<li>Using static logical resources in WPF</li>
<li>Using dynamic logical resources in WPF</li>
<li>Managing logical resources</li>
<li>Using user selected colors and fonts</li>
<li>Building an application using the MVVM pattern</li>
<li>Using routed commands in a WPF application</li>
</ul>
<h1 id="uuid-f28482f3-781f-4678-97fc-939f90674c15" class="">Introduction</h1>
<p>While binary resources play a vital role in any application, WPF also provides a different kind of resource, called a <strong>logical resource</strong>. These logical resources are objects that can be shared throughout the application and can be accessed across multiple assemblies. These can be of two types, static logical resources and dynamic logical resources.</p>
<p>On the other hand, <strong>MVVM</strong> (<strong>Model-View-ViewModel</strong>) is a pattern that keeps a separation between the UI and the code, giving the designers and developers the flexibility to work on a single window without depending on each other.</p>
<p>In this chapter, we will first cover binary resources, logical resources, and then move forward to learn building applications using the MVVM pattern. We will also cover how to use <strong>RoutedCommands</strong> to demonstrate the <strong>Command Design Pattern</strong> in WPF applications, which can be invoked from multiple locations.</p>
<h1 id="uuid-830a53da-acaa-4bec-9457-826f4badc39f">Using binary resources inside a WPF application</h1>
<p><strong>Binary resources</strong> are chunks of bytes added to a project with <kbd>Build Action</kbd> defined for it. Generally, these are images, logos, fonts, files, and so on, which are required by the application and are bundled with it.</p>
<p>In this recipe, we will learn how to use binary resources in a WPF application.</p>
<h2 id="uuid-07e56998-3560-4209-8dd3-a7ebc9fdb6d1">Getting ready</h2>
<p>To get started, open your Visual Studio IDE and create a new project called <kbd>CH07.BinaryResourceDemo</kbd>. Make sure you select the WPF app as the project template.</p>
<h2 id="uuid-dcdcdd2e-5d78-462a-af1e-60529e05faf4">How to do it...</h2>
<p>Follow these steps to add images as binary resources inside a WPF application and load them into the application window:</p>
<ol>
<li>Right-click on the project to add a new folder. Follow the context menu path Add | New Folder. Rename the newly created folder as <kbd>Images</kbd>:</li>
</ol>
<div><img src="img/44e88c7a-c8c1-48b6-937f-30c1f87cff37.png" style=""/></div>
<ol start="2">
<li>Now right-click on the Images folder to add a few images. From the context menu entry, select Add | Existing Item... and add two images of your choice. In this example, we have added two existing images, <kbd>image1.png</kbd> and <kbd>image2.png</kbd>, for demonstration:</li>
</ol>
<div><img src="img/b4680435-a8c0-4974-bd50-7bbe6225cd56.png" style=""/></div>
<ol start="3">
<li>From the Solution Explorer, right-click on the <kbd>image1.png</kbd> and go to its Properties. Set the Build Action of the image to Resource, which is the default:
<div><img src="img/036e79bb-4c39-4c89-b047-a31b46c3ed42.png" style=""/></div>
</li>
<li>Now right-click on the <kbd>image2.png</kbd> from Solution Explorer, and go to its Properties. Set its Build Action to Content.</li>
</ol>
<p> </p>
<ol start="5">
<li>Change the Copy to Output Directory to Copy Always:
<div><img src="img/07e35f07-20d2-488a-8b3e-6b341e52228a.png" style=""/></div>
</li>
<li>From the Solution Explorer, open the <kbd>MainWindow.xaml</kbd> and replace the <kbd>Grid</kbd> with a horizontal <kbd>StackPanel</kbd>.</li>
<li>Now insert the two images inside the <kbd>StackPanel</kbd>, and set their <kbd>Source</kbd> property to <kbd>Images/image1.png</kbd> and <kbd>Images/image2.png</kbd>, respectively:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal"&gt; 
    &lt;Image Source="Images/image1.png" 
           Width="150" 
           Margin="8"/&gt; 
    &lt;Image Source="Images/image2.png" 
           Width="150" 
           Margin="8"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="8">
<li>Build the project and run the application. You will see the following UI on the screen:
<div><img src="img/002cfccd-a915-4aab-935b-d56a35475d18.png" style=""/></div>
</li>
<li>Now go to the project's bin | Debug directory. You will see a folder named Images containing the image (<kbd>image2.png</kbd>) that we defined as <kbd>Build Action = Content</kbd> and <kbd>Copy to Output Directory = Copy Always</kbd>.</li>
<li>Now replace the <kbd>image2.png</kbd> with a different image.</li>
<li>Run the application now, directly from the bin | Debug folder, instead of recompiling the project. Observe the output on the screen. You will see that the second image now points to the new image that we have placed in the bin | Debug | Images folder:
<div><img src="img/a7c3afee-7d81-4e26-9481-788a577e7765.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-d542ee82-7aea-4c62-aec9-971b3a755988">How it works...</h2>
<p>When the <kbd>Build Action</kbd> is set to <kbd>Resource</kbd>, the file is stored as a resource inside the compiled assembly. In our case, <kbd>image1.png</kbd> was set to <kbd>Resource</kbd> inside the project binary, which makes the actual image file unnecessary while deploying the application.</p>
<p class="mce-root">When the <kbd>Build Action</kbd> is set to <kbd>Content</kbd>, the resource is not included in the assembly. To make it available to the application, <kbd>Copy to Output Directory</kbd> needs to be set to either <kbd>Copy Always</kbd> or <kbd>Copy if Newer</kbd>.</p>
<p class="mce-root">This makes it more appropriate for when the resource needs to change often and a rebuild would be undesirable. If the resource is not available in the output directory, this will render a blank image while executing. If the resource is large and not always needed, it's better to leave it to the resulting assembly.</p>
<h2 id="uuid-bb945ef1-d527-4e18-bf23-f408e52e9fef">There's more...</h2>
<p>While inserting the image in the XAML, we often use the relative URI (<kbd>Images/image1.png</kbd>, in our case) as it is relative to the application. You can also assign it more verbosely as <kbd>pack://application:,,,/Images/image1.png</kbd>, which is generally used while assigning the image source from the code behind.</p>
<p>You can also use the Visual Studio editor to assign the image source. To do so, right-click on the image from the XAML designer view and go to its Properties. From the Properties panel, click the dropdown arrow, as shown in the following screenshot, to select the desired image from the available items in the list:</p>
<div><img src="img/068c8aa0-cf52-49d8-8e07-fad215f2a18a.png" style=""/></div>
<h1 id="uuid-6b8d57b8-28d2-42d3-9555-eb5e59759869">Using binary resources from another assembly</h1>
<p>It is not mandatory to have the resources defined in the same assembly where they are going to be used. Sometime, on an as-needed basis, the binary resources are defined in one assembly (generally, a class library), and used in another assembly.</p>
<p>WPF provides a uniform way of accessing these resources defined in other assemblies. To work with this, we need to use the pack URI scheme. In this recipe, we will learn how to use binary resources from another assembly.</p>
<h2 id="uuid-f584bbde-25d2-4485-a105-12021bbbca5d">Getting ready</h2>
<p>Let's begin with creating a new project called <kbd>CH07.RemoteBinaryResourceDemo</kbd>. Make sure you select the WPF app template while creating this project.</p>
<h2 id="uuid-e60c5ad3-04a5-4a20-be66-0cdb4f808842">How to do it...</h2>
<p>Follow these steps to create a class library to define the binary resource and use it from the application that we have already created:</p>
<ol>
<li>Create another project within the same solution. Let's name it <kbd>CH07.ResourceLibrary</kbd>, and make sure you select Class Library (.NET Framework) as the project template:</li>
</ol>
<div><img src="img/dcd734ec-5fcb-4e7a-8a24-5c8f0515d404.png" style=""/></div>
<ol start="2">
<li>Remove the autogenerated class file <kbd>Class1.cs</kbd>.</li>
<li>Now right-click on the project <kbd>CH07.ResourceLibrary</kbd> and create a new folder named <kbd>Images</kbd>.</li>
<li>Now right-click on the newly created folder and add an existing image (<kbd>image1.png</kbd>, in our case) into that folder.</li>
<li>Then right-click on the image (<kbd>image1.png</kbd>) and navigate to its Properties pane.</li>
<li>As demonstrated in the previous recipe, change its Build Action to <kbd>Resource</kbd>. Compile the project <kbd>CH07.ResourceLibrary</kbd> to make sure that the build is successful.</li>
<li>From the Solution Explorer, right-click on the other project named <kbd>CH07.RemoteBinaryResourceDemo</kbd> and navigate through the context menu entry Add | Reference... to add the assembly reference of the class library in this project.</li>
</ol>
<p> </p>
<ol start="8">
<li>From the Reference Manager dialog window, navigate to Projects and select the class library (CH07.ResourceLibrary) that we created. As shown in the following screenshot, click OK once you are done. This will add our class library as a reference to our application project:</li>
</ol>
<div><img src="img/284ff79f-6ca0-4479-84c7-cf1bd16b8292.png"/></div>
<ol start="9">
<li>Now, from the Solution Explorer, navigate to the <kbd>MainWindow.xaml</kbd> file of the <kbd>CH07.RemoteBinaryResourceDemo</kbd> project and add the following image inside the <kbd>Grid</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Image Source="/CH07.ResourceLibrary;component/<br/>Images/image1.png"/&gt; </pre>
<ol start="10">
<li>Let's compile the solution and run the application. You will see that the application window launches with an image, which is present in a different assembly. Here's a screenshot, based on our demo application:</li>
</ol>
<div><img src="img/9ec1e76a-333b-4b46-96d0-1d6a2e5d6be4.png" style=""/></div>
<h2 id="uuid-5c86e52d-2621-48b2-a9ed-c3de9b170a51">How it works...</h2>
<p>When you are using a referenced assembly, the WPF pack URI recognizes it as <kbd>/AssemblyReference;component/ResourceName</kbd> format. In the preceding example, the <strong>AssemblyReference</strong> is the name of the assembly, which is <kbd>CH07.ResourceLibrary</kbd> in our case, and the <strong>ResourceName</strong> is the complete path of the resource relative to the project component.</p>
<h2 id="uuid-639cb3bc-9a61-422e-82c8-8c3643757cf0">There's more...</h2>
<p>An <kbd>AssemblyReference</kbd> may also include a version and/or the public key token (in case the assembly is strongly named). The version is denoted by prefixing it with a <kbd>v,</kbd> as shown in the following example:</p>
<pre style="padding-left: 60px">/&lt;AssemblyName&gt;;v&lt;VersionNo&gt;;&lt;Token&gt;;component/&lt;ResourcePath&gt; 
 
"/CH07.ResourceLibrary;v1.0;3ca44a7f7ca54f49;component/Images/image1.png" </pre>
<p>This does not work with resources marked with <kbd>Build Action</kbd> as <kbd>Content</kbd>. To work with this, we need to use the full pack URI with a <kbd>siteOfOrigin</kbd> base, as follows:</p>
<pre style="padding-left: 60px">&lt;Image Source="pack://siteOfOrigin:,,,/Images/image1.png" /&gt; </pre>
<p>Please note that the Visual Studio Designer window will fail to load the image when <kbd>siteOfOrigin</kbd> is used, but this will work fine in runtime.</p>
<h1 id="uuid-2f38f746-1eac-4327-8ae2-fa00bcbb9ab8">Accessing binary resources in code</h1>
<p>Accessing binary resources in XAML is very simple, but there is an option to read a binary resource from the code behind. In this recipe, we will learn how to read a binary resource in code and set it in the UI. We will be using an image as an example.</p>
<h2 id="uuid-d3546a7c-86b2-4545-a59c-f14251a17df6">Getting ready</h2>
<p>Open your Visual Studio IDE. Let's begin with creating a new WPF project called <kbd>CH07.BinaryResourceFromCodeDemo</kbd>.</p>
<h2 id="uuid-015142d8-0aff-4e35-b22b-21f7673f3914">How to do it...</h2>
<p>Follow these steps to read an image file, embedded as a <kbd>Resource</kbd>, and display it in the UI:</p>
<ol>
<li>First, create a folder named <kbd>Images</kbd> inside the project and add an image inside it. Let's name the image <kbd>image1.png</kbd>.</li>
<li>Open the <kbd>MainWindow.xaml</kbd> file by navigating to Solution Explorer.</li>
<li>Add an image tag inside the <kbd>Grid</kbd> panel and name it <kbd>img</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Image x:Name="img" /&gt; 
&lt;/Grid&gt;</pre>
<ol start="4">
<li>Go to the <kbd>MainWindow.xaml.cs</kbd> file and, inside the constructor of the class, just after the <kbd>InitializeComponent()</kbd> call, create the <kbd>streamResourceInfo</kbd> from the resource stream of the image. Here's the code to get the stream info:</li>
</ol>
<pre style="padding-left: 90px">var streamResourceInfo = Application.GetResourceStream(new Uri("Images/image1.png", UriKind.RelativeOrAbsolute)); </pre>
<ol start="5">
<li>Now we need to create the instance of <kbd>BitmapImage</kbd> from that stream. Copy the following content and pass the <kbd>streamResourceInfo.Stream</kbd> to the <kbd>StreamSource</kbd> property of the <kbd>BitmapImage</kbd>:</li>
</ol>
<pre style="padding-left: 90px">var bitmapImage = new BitmapImage(); 
bitmapImage.BeginInit(); 
bitmapImage.CacheOption = BitmapCacheOption.OnLoad; 
bitmapImage.StreamSource = streamResourceInfo.Stream; 
bitmapImage.EndInit(); 
bitmapImage.Freeze(); </pre>
<ol start="6">
<li>Now set the <kbd>bitmapImage</kbd> instance to the <kbd>Source</kbd> property of the image::</li>
</ol>
<pre style="padding-left: 90px">img.Source = bitmapImage; </pre>
<ol start="7">
<li>Here's the complete code for accessing the stream and assigning it to the image source:</li>
</ol>
<pre style="padding-left: 90px">public MainWindow() 
{ 
    InitializeComponent(); 
 
    var streamResourceInfo = Application.GetResourceStream( 
                              new Uri("Images/image1.png",  
                              UriKind.RelativeOrAbsolute)); 
 
    var bitmapImage = new BitmapImage(); 
    bitmapImage.BeginInit(); 
    bitmapImage.CacheOption = BitmapCacheOption.OnLoad; 
    bitmapImage.StreamSource = streamResourceInfo.Stream; 
    bitmapImage.EndInit(); 
    bitmapImage.Freeze(); 
 
    img.Source = bitmapImage; 
}</pre>
<ol start="8">
<li>Once done, build the project and run it. You will see that the assigned image is loaded into the application window:
<div><img src="img/ce158173-a1ee-4262-8b93-569ad106ac6f.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-691c642d-2a12-40e0-a726-d537441db53f">How it works...</h2>
<p>The static method <kbd>Application.GetResourceStream</kbd> provides an easy way of accessing a resource using its relative URI. It returns a <kbd>StreamResourceInfo</kbd> object. The <kbd>Stream</kbd> property of the <kbd>StreamResourceInfo</kbd> object provides access to the actual binary data, which has been set as the image source property by converting it to an instance of <kbd>BitmapImage</kbd>.</p>
<p>For the <kbd>Application.GetResourceStream</kbd> method to work, the resource must be marked as a <kbd>Resource</kbd> in <kbd>Build Action</kbd>.</p>
<p>If the resource has been marked as <kbd>Content</kbd> in the <kbd>Build Action</kbd> property, then the <kbd>Application.GetContentStream</kbd> method should be used to get the resource stream.</p>
<h1 id="uuid-4552c38b-5f88-424c-9f01-4e78bc8e2ed5">Using static logical resources in WPF</h1>
<p>Logical resources in WPF are the objects that can be shared and reused across some part of a Visual Tree or an entire application. These can be colors, brushes, geometrics, styles, or any other .NET objects (<kbd>int</kbd>, <kbd>string</kbd>, <kbd>List&lt;T&gt;</kbd>, <kbd>T</kbd>, and more) defined by the .NET Framework or developer. These objects are typically placed inside a <kbd>ResourceDictionary</kbd>.</p>
<p>In this recipe, we will learn how to use logical resources using the binding key <kbd>StaticResource</kbd>.</p>
<h2 id="uuid-e413dfa0-0be7-47ef-9a48-9e1c630b008e">Getting ready</h2>
<p>Make sure that Visual Studio is running. Create a project called <kbd>CH07.StaticResourceDemo</kbd>, based on the WPF application template.</p>
<h2 id="uuid-989007a6-400a-4cf3-9c10-9aa01e3486be">How to do it...</h2>
<p>Follow these steps to create a logical resource and use it inside the application window:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file and replace the <kbd>Grid</kbd> with a horizontal <kbd>StackPanel</kbd>.</li>
<li>Insert a <kbd>Border</kbd> control inside the <kbd>StackPanel</kbd>. Set its <kbd>Height</kbd> and <kbd>Width</kbd> properties to <kbd>80</kbd> and <kbd>150,</kbd> respectively:</li>
</ol>
<pre style="padding-left: 90px">&lt;Border Height="80" 
        Width="150" 
        Margin="8"&gt; 
&lt;/Border&gt; </pre>
<ol start="3">
<li>Let's add a background color to the <kbd>Border</kbd> control. We will be using a linear gradient brush to decorate the background color. Let's modify it as shared here:</li>
</ol>
<pre style="padding-left: 90px">&lt;Border Height="80" 
        Width="150" 
        Margin="8"&gt; 
    &lt;Border.Background&gt; 
        &lt;LinearGradientBrush&gt; 
            &lt;GradientStop Offset="0" 
                          Color="LightYellow"/&gt; 
            &lt;GradientStop Offset="0.2" 
                          Color="Yellow"/&gt; 
            &lt;GradientStop Offset=".5" 
                          Color="YellowGreen"/&gt; 
            &lt;GradientStop Offset="1" 
                          Color="Green"/&gt; 
        &lt;/LinearGradientBrush&gt; 
    &lt;/Border.Background&gt; 
&lt;/Border&gt; </pre>
<ol start="4">
<li>Copy the same border with the preceding background and paste it inside the same panel. Now the <kbd>StackPanel</kbd> will have two border controls with the same properties.</li>
<li>Let's build the project and run it. You will see two rectangular shapes with a nice gradient color as the background:
<div><img src="img/916b85ed-1009-4414-acf1-c7ecaae40aa3.png" style=""/></div>
</li>
<li>As you can see, we have added the same background brush twice to represent the color; it's sometimes difficult to manage, and unnecessarily increases the XAML code as well as the complexity. To resolve this, we can now move the brush object as a logical resource, and access it within the same window or throughout the application. Let's move it to the window level. Insert the <kbd>LinearGradientBrush</kbd> inside the window resource (<kbd>Window.Resources</kbd>) and assign a key (<kbd>myLinearBrush</kbd>) to it:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;LinearGradientBrush x:Key="myLinearBrush"&gt; 
        &lt;GradientStop Offset="0" 
                      Color="LightYellow"/&gt; 
        &lt;GradientStop Offset="0.2" 
                      Color="Yellow"/&gt; 
        &lt;GradientStop Offset=".5" 
                      Color="YellowGreen"/&gt; 
        &lt;GradientStop Offset="1" 
                      Color="Green"/&gt; 
    &lt;/LinearGradientBrush&gt; 
&lt;/Window.Resources&gt; </pre>
<ol start="7">
<li>Now remove the background definition in both the controls and replace it with a binding to the previously mentioned brush. As it is defined within the resource, we will be using <kbd>{StaticResource}</kbd> to access it. Here's the modified version of the border controls inside the panel:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal"&gt; 
    &lt;Border Height="80" 
            Width="150" 
            Margin="8" 
            Background="{StaticResource myLinearBrush}"/&gt; 
    &lt;Border Height="80" 
            Width="150" 
            Margin="8" 
            Background="{StaticResource myLinearBrush}"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="8">
<li>Let's run the application once again. You will see the same background applied to the rectangular shaped border controls. In this case, we have used just one definition of the brush.</li>
</ol>
<h2 id="uuid-6eb86315-88a5-40a9-ab30-d168305080d8">How it works...</h2>
<p>Every UI element derived from the <kbd>FrameworkElement</kbd> has a property called <kbd>Resources</kbd>, which is of type <kbd>ResourceDictionary</kbd>. Thus, every element can have resources associated with it. In XAML, we need to define the <kbd>x:Key</kbd> attribute to the resource to access it, either from the XAML or from the code-behind file.</p>
<p>In our example, we defined <kbd>myLinearBrush</kbd> as an element of the <kbd>ResourceCollection</kbd> of the <kbd>Window</kbd>. Thus, it will be accessible by any control within the same window. If you move the definition inside the <kbd>StackPanel</kbd>, it will be accessible within that panel:</p>
<pre style="padding-left: 60px">&lt;Window.Resources&gt; 
    &lt;LinearGradientBrush x:Key="myLinearBrush"&gt; 
        &lt;GradientStop Offset="0" 
                      Color="LightYellow"/&gt; 
        &lt;GradientStop Offset="0.2" 
                      Color="Yellow"/&gt; 
        &lt;GradientStop Offset=".5" 
                      Color="YellowGreen"/&gt; 
        &lt;GradientStop Offset="1" 
                      Color="Green"/&gt; 
    &lt;/LinearGradientBrush&gt; 
&lt;/Window.Resources&gt; </pre>
<p>To use this resource in XAML, we need to use the markup extension, <kbd>{StaticResource}</kbd>, along with the resource key provided, <kbd>Background="{StaticResource myLinearBrush}"</kbd>, which will create the binding between them.</p>
<h2 id="uuid-b70fa16c-91cb-4703-bf7f-a3b0f57149cd">There's more...</h2>
<p>It is possible to manage the logical resources from the code behind. You can call the <kbd>FindResource</kbd> method, passing the resource key to it, to get the instance of the resource. Here's how you can find the resource named <kbd>myLinearBrush</kbd>:</p>
<pre style="padding-left: 60px">var resource = FindResource("myLinearBrush") as Brush; </pre>
<p>You can also programmatically add or remove a resource to the collection. Call the methods <kbd>Resources.Add</kbd> and <kbd>Resources.Remove</kbd> to add or remove a specific resource, as shown in the following code snippet:</p>
<pre style="padding-left: 60px">Resources.Add("myBrush", new SolidColorBrush(Colors.Red)); 
Resources.Remove("myBrush"); </pre>
<p>As the <kbd>Resources</kbd> property is basically a <kbd>Dictionary</kbd> object, make sure you check whether the specified key is already present before doing any operation, such as <kbd>Add</kbd>/<kbd>Remove</kbd>, on it.</p>
<h1 id="uuid-8a959db6-f6de-4e87-9051-deb0906ab0cd">Using dynamic logical resources in WPF</h1>
<p>In the previous recipe, we learned how to use logical resources using the <kbd>StaticResource</kbd> markup extension. In this recipe, we will learn how to use logical resources using the <kbd>DynamicResource</kbd> markup extension and will also learn the difference between them.</p>
<h2 id="uuid-3bcffb2a-408a-4e83-ae51-44ff389c4165">Getting ready</h2>
<p>Get started by creating a new project. Open the Visual Studio IDE and create a new WPF application project called <kbd>CH07.DynamicResourceDemo</kbd>.</p>
<h2 id="uuid-da8c66c6-7c19-4b67-9220-219f9b7d2f5f">How to do it...</h2>
<p>Follow these steps to use logical resources dynamically and modify the values of the resource as per the need:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file and replace the <kbd>Grid</kbd> with a <kbd>StackPanel</kbd>.</li>
<li>Add a border inside the <kbd>StackPanel</kbd> and set its dimensions.</li>
<li>Add another <kbd>StackPanel</kbd> inside the panel and add a group of three radio buttons inside it. Label them as <kbd>Red</kbd>, <kbd>Green</kbd>, and <kbd>Blue</kbd>. Here's the complete XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal"&gt; 
    &lt;Border Height="80" 
            Width="150" 
            Margin="8"/&gt; 
    &lt;StackPanel Margin="10"&gt; 
        &lt;RadioButton GroupName="colorGroup" 
                     Content="Red" 
                     Margin="4"/&gt; 
        &lt;RadioButton GroupName="colorGroup" 
                     Content="Green" 
                     IsChecked="True" 
                     Margin="4"/&gt; 
        &lt;RadioButton GroupName="colorGroup" 
                     Content="Blue" 
                     Margin="4"/&gt; 
    &lt;/StackPanel&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="4">
<li>Now add a <kbd>LinearGradientBrush</kbd> to the window resources and set its key name as <kbd>myLinearBrush</kbd>. Add some <kbd>GradientStop</kbd> to define a nice gradient brush, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;LinearGradientBrush x:Key="myLinearBrush"&gt; 
        &lt;GradientStop Offset="0" 
                      Color="LightYellow"/&gt; 
        &lt;GradientStop Offset="1" 
                      Color="Green"/&gt; 
    &lt;/LinearGradientBrush&gt; 
&lt;/Window.Resources&gt;</pre>
<ol start="5">
<li>It's time to bind the defined brush with the <kbd>Border</kbd> control. Modify the XAML to have a <kbd>StaticResource</kbd> binding between them, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Border Height="80" 
        Width="150" 
        Margin="8" 
        Background="{StaticResource myLinearBrush}"/&gt; </pre>
<ol start="6">
<li>Register <kbd>Checked</kbd> events for all three radio buttons, so that we can perform some changes on the checked status change:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal"&gt; 
    &lt;Border Height="80" 
            Width="150" 
            Margin="8" 
            Background="{StaticResource myLinearBrush}"/&gt; 
    &lt;StackPanel Margin="10"&gt; 
        &lt;RadioButton GroupName="colorGroup" 
                     Content="Red" 
                     Margin="4" 
                     Checked="OnRedRadioChecked"/&gt; 
        &lt;RadioButton GroupName="colorGroup" 
                     Content="Green" 
                     IsChecked="True" 
                     Margin="4" 
                     Checked="OnGreenRadioChecked"/&gt; 
        &lt;RadioButton GroupName="colorGroup" 
                     Content="Blue" 
                     Margin="4" 
                     Checked="OnBlueRadioChecked"/&gt; 
    &lt;/StackPanel&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="7">
<li>Navigate to the <kbd>MainWindow.xaml.cs</kbd> and add the following implementation for all the radio buttons' <kbd>Checked</kbd> event:</li>
</ol>
<pre style="padding-left: 90px">private void OnRedRadioChecked(object sender,  
 RoutedEventArgs e) 
{ 
    var brush = Resources["myLinearBrush"]; 
    if (brush is LinearGradientBrush lBrush) 
    { 
        lBrush = new LinearGradientBrush 
        { 
            GradientStops = new GradientStopCollection 
            { 
                new GradientStop<br/>                (Colors.LightGoldenrodYellow, 0), 
                new GradientStop(Colors.Red, 1) 
            } 
        }; 
 
        Resources["myLinearBrush"] = lBrush; 
    } 
} 
 
private void OnGreenRadioChecked(object sender,  
 RoutedEventArgs e) 
{ 
    var brush = Resources["myLinearBrush"]; 
    if (brush is LinearGradientBrush lBrush) 
    { 
        lBrush = new LinearGradientBrush 
        { 
            GradientStops = new GradientStopCollection 
            { 
                new GradientStop(Colors.LightYellow, 0), 
                new GradientStop(Colors.Green, 1) 
            } 
        }; 
 
        Resources["myLinearBrush"] = lBrush; 
    } 
} 
 
private void OnBlueRadioChecked(object sender,  
 RoutedEventArgs e) 
{ 
    var brush = Resources["myLinearBrush"]; 
    if (brush is LinearGradientBrush lBrush) 
    { 
        lBrush = new LinearGradientBrush 
        { 
            GradientStops = new GradientStopCollection 
            { 
                new GradientStop(Colors.LightBlue, 0), 
                new GradientStop(Colors.Blue, 1) 
            } 
        }; 
 
        Resources["myLinearBrush"] = lBrush; 
    } 
}</pre>
<ol start="8">
<li>Once this has been done, run the application. You will see a rectangle with three radio buttons. By default, the Green radio button will be selected. Change the selection to Red or Blue to observe the behavior. You will see that the color always stays Green, irrespective of the selection:
<div><img src="img/4e984e14-d3fd-42d0-84d5-fa27cd5c0407.png" style=""/></div>
</li>
<li>Let's close the application and navigate back to <kbd>MainWindow.xaml</kbd>.</li>
<li>Change the <kbd>StaticResource</kbd> to <kbd>DynamicResource</kbd>, as shared in the following code snippet:</li>
</ol>
<pre style="padding-left: 90px">&lt;Border Height="80" 
        Width="150" 
        Margin="8" 
        Background="{DynamicResource myLinearBrush}"/&gt;</pre>
<ol start="11">
<li>Now, run the application once again. By default, Green will be selected, and the rectangle will have a green gradient background. Change the selection to Red or Blue to observe the color change:
<div><img src="img/f3ebf49a-5140-49cb-a303-c0c53eed5d14.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-6f522938-81de-4a0b-8992-2a77308c0986">How it works...</h2>
<p>When you bind the logical resource as a <kbd>StaticResource</kbd>, it causes the binding to occur at construction time. On the other hand, the <kbd>DynamicResource</kbd> markup extension binds to a resource dynamically, only when it is needed.</p>
<p>In the preceding example, when we registered the resource to the <kbd>Background</kbd> property of the <kbd>Border</kbd> control as a <kbd>StaticResource</kbd>, we were not able to see the change reflected in the UI, even though we replaced the resource with a new object on selection of the radio button. But when we changed the binding to <kbd>DynamicResource</kbd>, the change was automatically reflected. This is because the dynamic resource binding refreshes itself if the object changes. But this is not same with the static resource binding, as it always keeps referencing the old object.</p>
<h2 id="uuid-e4f834d8-ef6b-4a6b-81d5-a9d83f34df94">There's more...</h2>
<p>The <kbd>StaticResource</kbd> binding throws an error at design time if the object specified by the <kbd>x:Key</kbd> is not present. On the other hand, <kbd>DynamicResource</kbd> does not throw any exception, and displays as blank. Later, when it finds the <kbd>Key</kbd>, it binds itself with that resource.</p>
<div><kbd>StaticResource</kbd> should be used most of the time, unless there is a need to replace resources dynamically. <kbd>DynamicResource</kbd> should be used by the themes that can easily swap the resources.<br/>
<br/>
Having a large collection of <kbd>DynamicResource</kbd> on a complex UI can impact the performance of the UI. Wherever possible, mark them as <kbd>StaticResource</kbd>.</div>
<h1 id="uuid-d7f11ca2-fd6b-40d6-a75e-8d25ee53bacf">Managing logical resources</h1>
<p>There could be several types of logical resources in a single application, and placing them inside a single XAML file (for example, <kbd>App.xaml</kbd>) will increase problems while maintaining them. To resolve this problem, you can separate the resources of different types into their own respective files and reference them in <kbd>App.xaml</kbd>.</p>
<p>In this recipe, we will learn how to manage these logical resources with a simple example. Though this will be shown with a single file, you can create separate files and reference them.</p>
<h2 id="uuid-818b21dd-b722-4d25-8590-4bdd03fbf91a">Getting ready</h2>
<p>Assuming that you have opened Visual Studio, now create a new WPF application project called <kbd>CH07.ManagingLogicalResourceDemo</kbd>.</p>
<h2 id="uuid-dc4c42e0-3154-464e-93f3-222a35e8e5fe">How to do it...</h2>
<p>Follow these simple steps to create separate resource files and reference them in the application:</p>
<ol>
<li>As we want to create a separate resource file, we need to create a file of type Resource Dictionary. Inside the Solution Explorer, right-click on the project node and create a new folder named <kbd>Themes</kbd>.</li>
<li>Now right-click on the Themes folder and select Add | Resource Dictionary... from the context menu entry:</li>
</ol>
<div><img src="img/037c287d-47ec-417c-aa89-582f890f6b31.png" style=""/></div>
<ol start="3">
<li>In the Add New Item dialog, make sure that the Resource Dictionary (WPF) template is selected. Name it <kbd>Brushes.xaml</kbd>, and click Add:</li>
</ol>
<div><img src="img/1e7d9177-bfbb-436f-b2f3-1b5a3a29d9e5.png" style=""/></div>
<ol start="4">
<li>From the Solution Explorer, open the newly created file <kbd>Brushes.xaml</kbd> and add the following <kbd>LinearGradientBrush</kbd> inside the <kbd>ResourceDictionary</kbd> element with a <kbd>x:Key</kbd> name of <kbd>myLinearBrush</kbd>. You can add multiple elements inside the <kbd>ResourceDictionary</kbd> to have a resource collection. Make sure you assign a unique key name to each one of them:</li>
</ol>
<pre style="padding-left: 90px">&lt;LinearGradientBrush x:Key="myLinearBrush"&gt; 
    &lt;GradientStop Offset="0" 
                  Color="Yellow"/&gt; 
    &lt;GradientStop Offset="1" 
                  Color="OrangeRed"/&gt; 
&lt;/LinearGradientBrush&gt;</pre>
<ol start="5">
<li>Open the <kbd>MainWindow.xaml</kbd> and replace the <kbd>Grid</kbd> with the following markup to have a <kbd>Border</kbd> control inside it. Set the size of the element and bind the <kbd>Background</kbd> property with the <kbd>myLinearBrush</kbd> that we have created:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Border Height="100" 
            Width="280" 
            Margin="8" 
            Background="{DynamicResource myLinearBrush}"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="6">
<li>If you run the application now, you won't see any elements inside the window, because the mapping of the file has not been created yet. As we have the binding as <kbd>DynamicResource</kbd>, you won't see any error.</li>
<li>Let's close the application and open the <kbd>App.xaml</kbd> file.</li>
<li>Inside the <kbd>Application.Resources</kbd>, add an element named <kbd>ResourceDictionary</kbd>. Inside this, create another element named <kbd>ResourceDictionary.MergedDictionaries</kbd> and load the <kbd>ResourceDictionary</kbd> that we have created. Here's how it will look:</li>
</ol>
<pre style="padding-left: 90px">&lt;Application.Resources&gt; 
    &lt;ResourceDictionary&gt; 
        &lt;ResourceDictionary.MergedDictionaries&gt; 
            &lt;ResourceDictionary  
                 Source="Themes/Brushes.xaml" /&gt; 
        &lt;/ResourceDictionary.MergedDictionaries&gt; 
    &lt;/ResourceDictionary&gt; 
&lt;/Application.Resources&gt; </pre>
<ol start="9">
<li>Now run the application once again. You will see a rectangular shaped border control in the application window with a nice gradient color, which we have created in the <kbd>Brushes.xaml</kbd> file. Here a screenshot of the application window:
<div><img src="img/8f442a66-a199-4115-b9cc-f90493e3e3bb.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-b0e85c35-09b6-4c59-9523-91eaab1a96d1">How it works...</h2>
<p>A <kbd>ResourceDictionary</kbd> can load one or more resource dictionaries using its <kbd>MergedDictionaries</kbd> property (<kbd>ResourceDictionary.MergedDictionaries</kbd>), which is a collection. It's not always mandatory to have a reference to other resource dictionaries, but it can also have its own resources as well:</p>
<pre style="padding-left: 60px">&lt;Application.Resources&gt; 
    &lt;ResourceDictionary&gt; 
        &lt;SolidColorBrush Color="Red" x:Key="redBrush" /&gt; 
        &lt;SolidColorBrush Color="Green" x:Key="greenBrush" /&gt; 
        &lt;SolidColorBrush Color="Blue" x:Key="blueBrush" /&gt; 
        &lt;ResourceDictionary.MergedDictionaries&gt; 
            &lt;ResourceDictionary  
                     Source="Themes/SolidBrushes.xaml" /&gt; 
            &lt;ResourceDictionary  
                     Source="Themes/GradientBrushes.xaml" /&gt; 
            &lt;ResourceDictionary Source="Themes/Fonts.xaml" /&gt; 
        &lt;/ResourceDictionary.MergedDictionaries&gt; 
    &lt;/ResourceDictionary&gt; 
&lt;/Application.Resources&gt; </pre>
<p>The <kbd>Source</kbd> property of the <kbd>ResourceDictionary</kbd> element must point to the location of the <kbd>ResourceDictionary</kbd>. If that location is within a subfolder, that subfolder must be included.</p>
<h2 id="uuid-edb858f0-54f5-4106-8e25-46bd02455ec1">There's more...</h2>
<p>When there exist two or more resources with the same key name that originated from multiple merged dictionaries, it will not throw any error or exception. Instead, it will load the one from the Resource Dictionary that was added last in the element tree.</p>
<h1 id="uuid-aa6daa48-3561-4ad9-911e-f30714ae40d8">Using user selected colors and fonts</h1>
<p>Sometimes, it is useful to use the system theme in an application UI to have a synchronous flow of colors and fonts between the operating system and the application. In these cases, we can dynamically load those values and apply them to our UI elements. This is achievable by accessing some special resource keys within the <kbd>SystemColors</kbd> and <kbd>SystemFonts</kbd> classes. In this recipe, we will learn how to use them.</p>
<h2 id="uuid-40ef1fe4-15e1-4f60-a528-a8fda1a1a897">Getting ready</h2>
<p>Let's get started by creating a new project called <kbd>CH07.SystemResourcesDemo</kbd>. Make sure you select the WPF application template from the available list.</p>
<h2 id="uuid-6a3889a4-19ed-4ce7-b54d-03bd2e148f14">How to do it...</h2>
<p>We will now build an application that uses system colors and fonts. Follow these steps to proceed with it:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file and insert the following <kbd>Rectangle</kbd> inside the <kbd>Grid</kbd> panel:</li>
</ol>
<pre style="padding-left: 90px">&lt;Rectangle Height="100" 
           Width="300"/&gt; </pre>
<ol start="2">
<li>We want to fill the rectangle with the color of the desktop brush. Add the following markup to fill the background color of the rectangle <kbd>Fill="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}"</kbd>. Now the XAML will look like the following:</li>
</ol>
<pre style="padding-left: 90px">&lt;Rectangle Fill="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}" 
           Height="100" 
           Width="300"/&gt; </pre>
<ol start="3">
<li>Let's run the application now. You will see that a background color for the rectangle has been picked up by the application. This is based on the selection that you have for the <kbd>DesktopBrush</kbd> in your system:
<div><img src="img/1340d9d6-0d62-44ab-94ee-d9d766cac3ad.png" style=""/></div>
</li>
<li>To confirm this, right-click on your desktop and select Personalize. If you are using Windows 10, you will see the Settings app navigates to the Background Settings page. Check the color that is selected in the Background settings and the color applied to your application. Both will be the same:</li>
</ol>
<div><img src="img/d2c2de3c-5b9f-4421-bf6e-86440924c026.png" style=""/></div>
<ol start="5">
<li>Let's select a different color from the Background Settings. You will see that the color will automatically get applied to your application:</li>
</ol>
<div><img src="img/f1450077-c84c-42f0-9ecc-94214a3123c8.png" style=""/></div>
<ol start="6">
<li>Now select the + symbol (Custom color) to select another color of the default colors in the palette:
<div><img src="img/b231a373-0eb6-49e8-ab1b-c9a2c42aa29a.png" style=""/></div>
</li>
<li>As shown here, pick a custom background color for your desktop and click Done:
<div><img src="img/1c5b0bbb-caea-4289-8540-c9765f2244fa.png" style=""/></div>
</li>
<li>Check the application window now. You will see that the color selected on the Settings app is applied to the rectangle background. Navigate to your desktop, the same color will be applied there too:
<div><img src="img/c0237bf1-4e73-48d5-b5c6-a53605d94aac.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-3ebf7b4f-f717-4ed3-ae8e-e48307e30726">How it works...</h2>
<p>It is not mandatory to provide a <kbd>string</kbd> type key name to a resource binding. You can also provide a static object to the binding. In this example, we used the static value <kbd>SystemColors.DesktopBrushKey</kbd> in combination with the <kbd>{x:Static}</kbd> markup extension:</p>
<pre style="padding-left: 60px">Fill="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}" </pre>
<p>As we have learned about the dynamic resource binding in the previous recipes, this example also follows the same method, and thus you can see the selected color is automatically applied to the rectangle.</p>
<p>There are many static keys under the <kbd>SystemColors</kbd> class, which you can reference in your design. This is often useful when you want your application to be in sync with the operating system's theme.</p>
<h2 id="uuid-77719f6c-ebc8-47b5-b1b7-16a591192c78">There's more...</h2>
<p>Just like <kbd>SystemColors</kbd>, we have the <kbd>SystemFonts</kbd> class too, which exposes font related static properties. You can define <kbd>FontFamily</kbd>, <kbd>FontSize</kbd>, and <kbd>FontWeight</kbd> styles from the system palette, as follows:</p>
<pre style="padding-left: 60px">&lt;TextBlock FontFamily="{DynamicResource {x:Static SystemFonts.CaptionFontFamily}}" 
           FontSize="{DynamicResource {x:Static SystemFonts.CaptionFontSizeKey}}" 
           FontWeight="{DynamicResource {x:Static SystemFonts.CaptionFontWeightKey}}" 
           Text="Hello World!"/&gt; </pre>
<h1 id="uuid-bbef633e-2ede-41eb-a52c-270ab4faedf5">Building an application using the MVVM pattern</h1>
<p><strong>MVVM</strong> stands for <strong>Model</strong>, <strong>View</strong>, and <strong>ViewModel</strong>, which is a pattern that facilitates the separation between the <strong>GUI</strong> (<strong>Graphical user interface</strong>) from the business logic. It means that a designer and developer can work together, without any hassle.</p>
<p>In this pattern, the model is the data that gets displayed in the view with the help of ViewModel. In this recipe, we will learn how to create an MVVM application, expose the properties from the ViewModel to the associated view, and display records without writing any code in the XAML code behind file.</p>
<h2 id="uuid-2eede2e8-ce0b-485e-b759-bf0e40e7dd0e">Getting ready</h2>
<p>Let's open the Visual Studio IDE and create a new project, called <kbd>CH07.MVVMDemo</kbd>, based on the WPF app template.</p>
<h2 id="uuid-70e3e47a-948f-4fc1-bf49-fce7630fda29">How to do it...</h2>
<p>Once the project has been created, follow these steps to construct the project for the MVVM standard (not mandatory) and build a sample demo using the MVVM pattern:</p>
<ol>
<li>Each WPF app project has a <kbd>MainWindow.xaml</kbd>. From the Solution Explorer, let's delete the default file.</li>
<li>Inside the project, create three folders named <kbd>Models</kbd>, <kbd>Views</kbd>, and <kbd>ViewModels</kbd>. This is just to create a proper structure for all our code files.</li>
<li>Now right-click on the Views folder, create a new <kbd>Window</kbd> by following the context menu path Add | Window..., and name it <kbd>MainWindow.xaml</kbd>.</li>
<li>Open the <kbd>App.xaml</kbd> file and modify the <kbd>StartupUri</kbd> to point to the correct file. As shown in the following screenshot, change the <kbd>StartupUri</kbd> to <kbd>ViewsMainWindow.xaml</kbd>:</li>
</ol>
<div><img src="img/dcefda1d-53a9-4c40-858f-705bf90bf401.png" style=""/></div>
<ol start="5">
<li>Open the <kbd>MainWindow.xaml</kbd> file from the Views folder and replace the <kbd>Grid</kbd> with a <kbd>DockPanel</kbd>.</li>
<li>Add two <kbd>StackPanel</kbd> inside the <kbd>Dock</kbd> and design the UI, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;DockPanel Margin="10"&gt; 
    &lt;StackPanel Orientation="Vertical" 
                DockPanel.Dock="Left"&gt; 
        &lt;ListBox Width="180" Height="110"&gt; 
        &lt;/ListBox&gt; 
        &lt;TextBlock&gt; 
        &lt;/TextBlock&gt; 
    &lt;/StackPanel&gt; 
    &lt;StackPanel Orientation="Vertical" 
                Margin="4 0" 
                DockPanel.Dock="Right"&gt; 
        &lt;TextBlock Text="Firstname"/&gt; 
        &lt;TextBox Text=""/&gt; 
        &lt;TextBlock Text="Lastname"/&gt; 
        &lt;TextBox Text=""/&gt; 
        &lt;Button Content="Add" 
                Margin="0 8"/&gt; 
    &lt;/StackPanel&gt; 
&lt;/DockPanel&gt; </pre>
<ol start="7">
<li>If you run the application now, you will see the application window looks like this:</li>
</ol>
<div><img src="img/1f16a9cb-657c-4b98-afef-8ae15e437a8d.png" style=""/></div>
<ol start="8">
<li>Now, right-click on the Models folder and create a class file named <kbd>UserModel.cs</kbd> and modify the class to have two properties of type <kbd>string</kbd>. As shown here, name them <kbd>Firstname</kbd> and <kbd>Lastname</kbd>:</li>
</ol>
<pre style="padding-left: 90px">public class UserModel 
{ 
    public string Firstname { get; set; } 
    public string Lastname { get; set; } 
} </pre>
<ol start="9">
<li>Right-click on the ViewModels folder and add another class file. Name it <kbd>MainWindowViewModel.cs</kbd>.</li>
<li>Open the <kbd>MainWindowViewModel.cs</kbd> file and add the following namespaces inside it:</li>
</ol>
<pre style="padding-left: 90px">using CH07.MVVMDemo.Models; 
using System.Collections.ObjectModel; 
using System.ComponentModel; </pre>
<ol start="11">
<li>Now inherit the <kbd>MainWindowViewModel</kbd> class from <kbd>INotifyPropertyChanged</kbd> interface, which is present under the <kbd>System.ComponentModel</kbd> namespace.</li>
</ol>
<pre style="padding-left: 90px">public class MainWindowViewModel : INotifyPropertyChanged </pre>
<ol start="12">
<li>As we already know, the <kbd>INotifyPropertyChanged</kbd> interface exposes the <kbd>PropertyChanged</kbd> event handler; we need to register that inside the class. Copy the following code to implement the interface:</li>
</ol>
<pre style="padding-left: 90px">public event PropertyChangedEventHandler PropertyChanged; 
public void OnPropertyChanged(string propertyName) 
{ 
    PropertyChanged?.Invoke(this,  
        new PropertyChangedEventArgs(propertyName)); 
}</pre>
<ol start="13">
<li>Once this has been done, create two properties inside the <kbd>ViewModel</kbd>. Name one <kbd>SelectedUser</kbd>, which is of type <kbd>UserModel</kbd> and the other <kbd>UserCollection</kbd>, which is of type <kbd>ObservableCollection&lt;UserModel&gt;</kbd>. Make sure you call the <kbd>OnPropertyChanged(str)</kbd> method from both the setters, so that the value change can be automatically reported to the UI. Here are the properties that we are going to refer to in this demonstration:</li>
</ol>
<pre style="padding-left: 90px">private UserModel m_selectedUser; 
public UserModel SelectedUser 
{ 
    get { return m_selectedUser; } 
    set 
    { 
        m_selectedUser = value; 
        OnPropertyChanged("SelectedUser"); 
    } 
} 
 
private ObservableCollection&lt;UserModel&gt; m_userCollection; 
public ObservableCollection&lt;UserModel&gt; UserCollection 
{ 
    get { return m_userCollection; } 
    set 
    { 
        m_userCollection = value; 
        OnPropertyChanged("UserCollection"); 
    } 
} </pre>
<ol start="14">
<li>Inside the constructor of the ViewModel, initialize the <kbd>UserCollection</kbd> property with some dummy data:</li>
</ol>
<pre style="padding-left: 90px">public MainWindowViewModel() 
{ 
    UserCollection = new ObservableCollection&lt;UserModel&gt; 
    { 
        new UserModel 
        { 
            Firstname = "User", Lastname = "One" 
        }, 
        new UserModel 
        { 
            Firstname = "User", Lastname = "Two" 
        }, 
        new UserModel 
        { 
            Firstname = "User", Lastname = "Three" 
        }, 
        new UserModel 
        { 
            Firstname = "User", Lastname = "Four" 
        }, 
    }; 
} </pre>
<ol start="15">
<li>As the <kbd>viewmodel</kbd> is ready, having all the properties that we need, let's associate it with the view as its <kbd>DataContext</kbd>. You can do this either from the code behind or from the XAML itself. As our target is to keep the code behind as small as possible, let's do it from the XAML. Open the <kbd>MainWindow.xaml</kbd> and add the following <kbd>XMLNS</kbd> entry to it, so that we can access the <kbd>viewmodel</kbd> that we have created:</li>
</ol>
<pre style="padding-left: 90px"> </pre>
<ol start="16">
<li>Inside the <kbd>Window.Resources</kbd> tag, add our <kbd>viewmodel</kbd> as a resource and define it as <kbd>x:Key="ViewModel"</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;viewmodels:MainWindowViewModel x:Key="ViewModel"/&gt; 
&lt;/Window.Resources&gt; </pre>
<ol start="17">
<li>As the <kbd>viewmodel</kbd> has been registered as a resource, set the <kbd>DataContext</kbd> of the <kbd>DockPanel</kbd> to the <kbd>ViewModel</kbd> that we defined. The binding needs to be done using the <kbd>{StaticResource}</kbd> markup extension. Here's how it will look:</li>
</ol>
<pre style="padding-left: 90px">&lt;DockPanel DataContext="{StaticResource ViewModel}" 
           Margin="10"&gt; </pre>
<ol start="18">
<li>Now set the <kbd>ItemsSource</kbd> and the <kbd>SelectedItem</kbd> properties of the <kbd>ListBox</kbd> control to have a data binding with the properties inside our <kbd>viewmodel</kbd>.</li>
</ol>
<pre style="padding-left: 90px">&lt;ListBox Width="180" Height="110" 
         ItemsSource="{Binding UserCollection}" 
         SelectedItem="{Binding SelectedUser}"&gt;</pre>
<ol start="19">
<li>Similarly, set the <kbd>DataContext</kbd> property of the <kbd>TextBlock</kbd> to <kbd>SelectedUser</kbd> and create the data binding, as shown, here to display the selected full name of the user:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBlock DataContext="{Binding SelectedUser}"&gt; 
    &lt;Run Text="Selected:"/&gt; 
    &lt;Run Text="{Binding Firstname}"/&gt; 
    &lt;Run Text="{Binding Lastname}"/&gt; 
&lt;/TextBlock&gt; </pre>
<ol start="20">
<li>Let's run this application now. You will see the following UI, where the values in <kbd>ListBox</kbd> control will be shown as the fully qualified name of the <kbd>model</kbd> class:
<div><img src="img/2f10b6ca-598c-469a-9ad3-491b8969bb8a.png" style=""/></div>
</li>
<li>To resolve this, we need to create the <kbd>DataTemplate</kbd> of the <kbd>ListBox</kbd>. Define the <kbd>ListBox.ItemTemplate</kbd> as follows, to have a <kbd>TextBlock</kbd> with the user's full name, by concatenating the <kbd>Firstname</kbd> and <kbd>Lastname</kbd> properties:</li>
</ol>
<pre style="padding-left: 90px">&lt;ListBox.ItemTemplate&gt; 
    &lt;DataTemplate&gt; 
        &lt;TextBlock&gt; 
            &lt;Run Text="{Binding Firstname}"/&gt; 
            &lt;Run Text="{Binding Lastname}"/&gt; 
        &lt;/TextBlock&gt; 
    &lt;/DataTemplate&gt; 
&lt;/ListBox.ItemTemplate&gt;</pre>
<ol start="22">
<li>Once this has been done, the XAML code of the application UI will look similar to this:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            DockPanel.Dock="Left"&gt; 
    &lt;ListBox Width="180" Height="110" 
             ItemsSource="{Binding UserCollection}" 
             SelectedItem="{Binding SelectedUser}"&gt; 
        &lt;ListBox.ItemTemplate&gt; 
            &lt;DataTemplate&gt; 
                &lt;TextBlock&gt; 
                &lt;Run Text="{Binding Firstname}"/&gt; 
                &lt;Run Text="{Binding Lastname}"/&gt; 
                &lt;/TextBlock&gt; 
            &lt;/DataTemplate&gt; 
        &lt;/ListBox.ItemTemplate&gt; 
    &lt;/ListBox&gt; 
    &lt;TextBlock DataContext="{Binding SelectedUser}"&gt; 
        &lt;Run Text="Selected:"/&gt; 
        &lt;Run Text="{Binding Firstname}"/&gt; 
        &lt;Run Text="{Binding Lastname}"/&gt; 
    &lt;/TextBlock&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="23">
<li>Let's run the application now. You will see the correct values inside the <kbd>ListBox</kbd>:
<div><img src="img/b990e214-aec2-4fcd-85be-c5bad3a12a69.png" style=""/></div>
</li>
<li>Select any of the <kbd>ListBox</kbd> items to see the selected username in the <kbd>TextBox</kbd>. Change the selection to update the UI automatically:
<div><img src="img/2de2c792-f96b-4fa5-913c-4b58d219d4f8.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-b3b4c570-4318-431d-a5d5-ac6dd9aab66b">How it works...</h2>
<p>MVVM consists of three important parts<strong>Model</strong>, <strong>View</strong>, and the <strong>ViewModel</strong>. The <em>Model</em> represents the data; the <em>View</em> is the actual UI, which displays the relevant parts of the model; and the <em>ViewModel</em> is the mechanism that hands out the required data to the view. A ViewModel basically exposes properties and commands, and maintains the relevant state of the view.</p>
<p>If we compare the MVVM pattern with a bike (as represented in the following screenshot), the bike <strong>Body</strong> is the <strong>View</strong>, the <strong>Fuel</strong> is the <strong>Model</strong> and the <strong>Engine</strong> of the bike is the <strong>ViewModel</strong>, which moves the View (bike body) by burning/using the Model (Fuel):</p>
<div><img src="img/733f6b5f-896f-4dab-8037-e6a8e5c9b146.png" style=""/></div>
<p>In our application, we used the <kbd>DataContext</kbd> to define the binding between the View and the ViewModel, which we then used to access the properties. If you now navigate to the <kbd>MainWindow.xaml.cs</kbd> file, you won't see any additional code except the constructor of the code-behind class.</p>
<p>In the MVVM pattern, our intention is to keep the code-behind file (<kbd>MainWindow.xaml.cs</kbd>) code free (or less code), so that the direct binding between the UI and the code will be reduced. Note that the MVVM is not a framework, but in using this pattern you can create a framework. For example, the <strong>MVVMLight</strong> (<a href="http://www.mvvmlight.net">http://www.mvvmlight.net</a>) from <strong>GalaSoft</strong> provides a fully customized framework, which you can use in your application to keep the development hassle free.</p>
<h1 id="uuid-608ac9f5-1ae7-4d31-b704-97d12e5a1e4e">Using routed commands in a WPF application</h1>
<p><strong>Routed commands</strong> are used to navigate a route through the element hierarchy. This process is also well known as bubbling and tunneling. The class <kbd>RoutedCommand</kbd> implements the <kbd>ICommand</kbd> interface and allows the attaching of input gestures, such as mouse input and keyboard shortcuts, to the target.</p>
<p>In this recipe, we will learn how to use routed commands with a simple example.</p>
<h2 id="uuid-50a2fc33-6000-4fad-a3f8-ba649b9604a3">Getting ready</h2>
<p>To work on this recipe, we will be using the previous MVVM demo application. Launch your Visual Studio IDE and open the project <kbd>CH07.MVVMDemo</kbd>. In this example, we will be using <kbd>RoutedCommand</kbd> for the Add button click event.</p>
<h2 id="uuid-cfbf27ea-351e-47c6-91c4-9ba878282d07">How to do it...</h2>
<p>Follow these simple steps to register the routed command to the button click and perform the operation:</p>
<ol>
<li>From the Solution Explorer, right-click on the project node and create a folder named <kbd>Commands</kbd>.</li>
</ol>
<p> </p>
<ol start="2">
<li>Right-click on the Commands folder and create a new class named <kbd>RoutedCommands.cs</kbd> by following the Add | Class... context menu path.</li>
<li>Inside the class implementation, declare a static member of type <kbd>RoutedCommand</kbd> and name it <kbd>AddCommand</kbd>. Here's the code implementation:</li>
</ol>
<pre style="padding-left: 90px">public class RoutedCommands 
{ 
    public static RoutedCommand AddCommand =  
                            new RoutedCommand(); 
} </pre>
<ol start="4">
<li>Add the following namespace to resolve the <kbd>RoutedCommand</kbd> class:</li>
</ol>
<pre style="padding-left: 90px">using System.Windows.Input; </pre>
<ol start="5">
<li>Once that has been done, navigate to the <kbd>MainWindowViewModel.cs</kbd> file, present under the ViewModels folder, and add a property named <kbd>NewUserDetails</kbd> of type <kbd>UserModel</kbd>. We will be using this property to bind with the <kbd>Text</kbd> property of the <kbd>TextBox</kbd> controls present in the UI. The property implementation is as follows:</li>
</ol>
<pre style="padding-left: 90px">private UserModel m_newUserDetails; 
public UserModel NewUserDetails 
{ 
    get { return m_newUserDetails; } 
    set 
    { 
        m_newUserDetails = value; 
        OnPropertyChanged("NewUserDetails"); 
    } 
} </pre>
<ol start="6">
<li>Now, inside the constructor of our ViewModel, initialize the <kbd>NewUserDetails</kbd> property:</li>
</ol>
<pre style="padding-left: 90px">public MainWindowViewModel() 
{ 
    UserCollection = new ObservableCollection&lt;UserModel&gt; 
    { 
        new UserModel 
        { 
            Firstname = "User", Lastname = "One" 
        }, 
        new UserModel 
        { 
            Firstname = "User", Lastname = "Two" 
        }, 
        new UserModel 
        { 
            Firstname = "User", Lastname = "Three" 
        }, 
        new UserModel 
        { 
            Firstname = "User", Lastname = "Four" 
        }, 
    }; 
 
    NewUserDetails = new UserModel(); 
} </pre>
<ol start="7">
<li>Navigate to <kbd>MainWindow.xaml</kbd> now, which is present under the Views folder. Modify the XAML as follows, to set a <kbd>DataContext</kbd> for the <kbd>StackPanel</kbd> and create data bindings with the <kbd>TextBox</kbd> controls. Make sure you set the data binding mode to <kbd>TwoWay</kbd>, else the code will not receive the updated value received from the UI:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            Margin="4 0" 
            DockPanel.Dock="Right" 
            DataContext="{Binding NewUserDetails}"&gt; 
    &lt;TextBlock Text="Firstname"/&gt; 
    &lt;TextBox Text="{Binding Firstname, Mode=TwoWay}"/&gt; 
    &lt;TextBlock Text="Lastname"/&gt; 
    &lt;TextBox Text="{Binding Lastname, Mode=TwoWay}"/&gt; 
    &lt;Button Content="Add" 
            Margin="0 8"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="8">
<li>Now add the following <kbd>XMLNS</kbd> attribute to the XAML page, so that we can access the classes present under the <kbd>CH07.MVVMDemo.Commands</kbd> namespace:</li>
</ol>
<pre style="padding-left: 90px"/>
<ol start="9">
<li>What next? We need to create the command binding under the <kbd>Window</kbd> tag. Add the following XAML code block inside the <kbd>Window</kbd> tag:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.CommandBindings&gt; 
    &lt;CommandBinding Command="{x:Static commands:RoutedCommands.AddCommand}" 
                    CanExecute="CanExecute_AddCommand" 
                    Executed="Execute_AddCommand"/&gt; 
&lt;/Window.CommandBindings&gt; </pre>
<ol start="10">
<li>Register the <kbd>CanExecute</kbd> and <kbd>Executed</kbd> events, named <kbd>CanExecute_AddCommand</kbd> and <kbd>Execute_AddCommand,</kbd> respectively, inside the code-behind class file, which is <kbd>MainWindow.xaml.cs</kbd> in our case.</li>
<li>Navigate back to the <kbd>MainWindow.xaml</kbd> and associate the command with the <kbd>Button</kbd> control, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Button Content="Add" 
        Margin="0 8" 
        Command="{x:Static commands:RoutedCommands.AddCommand}"/&gt; </pre>
<ol start="12">
<li>The complete markup changes will look like this:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            Margin="4 0" 
            DockPanel.Dock="Right" 
            DataContext="{Binding NewUserDetails}"&gt; 
    &lt;TextBlock Text="Firstname"/&gt; 
    &lt;TextBox Text="{Binding Firstname, Mode=TwoWay}"/&gt; 
    &lt;TextBlock Text="Lastname"/&gt; 
    &lt;TextBox Text="{Binding Lastname, Mode=TwoWay}"/&gt; 
    &lt;Button Content="Add" 
            Margin="0 8" 
            Command="{x:Static commands:RoutedCommands.AddCommand}"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="13">
<li>Now open the <kbd>MainWindow.xaml.cs</kbd> file and create a member variable of type <kbd>MainWindowViewModel</kbd>. Name it <kbd>ViewModel</kbd> and initialize it as <kbd>null</kbd>. This will be used to store the reference of the ViewModel from the window resources:</li>
</ol>
<pre style="padding-left: 90px">private MainWindowViewModel ViewModel = null;</pre>
<ol start="14">
<li>Inside the constructor, grab the associated <kbd>ViewModel</kbd> reference from the <kbd>Resources</kbd>:</li>
</ol>
<pre style="padding-left: 90px">public MainWindow() 
{ 
    InitializeComponent(); 
 
    ViewModel = Resources["ViewModel"] as  
                         MainWindowViewModel; 
    if (ViewModel == null)  
    {  
        throw new NullReferenceException("ViewModel <br/>        can't be NULL");  
    } 
} </pre>
<ol start="15">
<li>The <kbd>CanExecute_AddCommand</kbd> event passes an argument of type <kbd>CanExecuteRoutedEventArgs</kbd>. It contains a property named <kbd>CanExecute</kbd>, which is responsible for holding a <kbd>boolean</kbd> value, indicating whether the <kbd>System.Windows.Input.RoutedCommand</kbd> associated with this event can be executed on the command target. As we have associated the <kbd>AddCommand</kbd> with the button, <kbd>e.CanExecute = true</kbd> will enable the button. In other cases, it will be disabled. So, let's modify the <kbd>CanExecute_AddCommand</kbd> event to implement this logic:</li>
</ol>
<pre style="padding-left: 90px">private void CanExecute_AddCommand(object sender,  
 CanExecuteRoutedEventArgs e) 
{ 
    if (ViewModel != null) 
    { 
        var userDetails = ViewModel.NewUserDetails; 
        e.CanExecute =  <br/>        !string.IsNullOrWhiteSpace(userDetails.Firstname) &amp;&amp;  <br/>        !string.IsNullOrWhiteSpace(userDetails.Lastname); 
    } 
}</pre>
<ol start="16">
<li>Once that has been done, we need to implement the <kbd>Execute</kbd> command. Modify the <kbd>Execute_AddCommand</kbd> event handler, as follows:</li>
</ol>
<pre style="padding-left: 90px">private void Execute_AddCommand(object sender,  
 ExecutedRoutedEventArgs e) 
{ 
    ViewModel.UserCollection.Add(ViewModel.NewUserDetails); 
    ViewModel.SelectedUser = ViewModel.NewUserDetails; 
    ViewModel.NewUserDetails = new Models.UserModel(); 
} </pre>
<ol start="17">
<li>Let's run the application now. You will see that the Add button is disabled. This is because, as per our logic, the <kbd>e.CanExecute</kbd> property has been set to <kbd>false</kbd> as both the <kbd>TextBox</kbd> fields are empty:</li>
</ol>
<div><img src="img/f0097033-b474-41b7-a43a-9ab9ffc5cddc.png" style=""/></div>
<ol start="18">
<li>Enter some strings into both the <kbd>TextBox</kbd> fields and press the <em>TAB</em> key. It will automatically enable the button control, as follows:</li>
</ol>
<div><img src="img/a0ab56c5-c0f1-48cf-b3e8-04542e368323.png" style=""/></div>
<ol start="19">
<li>Click on Add, which will add the entered value to the collection and reset the <kbd>TextBox</kbd> fields. As soon as it resets the fields to empty, the button will automatically become disabled until the user fills the fields again:</li>
</ol>
<div><img src="img/8153737f-b546-4580-bce4-951fb10b4e72.png" style=""/></div>
<h2 id="uuid-c256bd27-2e3b-492d-ab86-46e2330bb6bb">How it works...</h2>
<p>The <kbd>RoutedCommand</kbd> class falls under the <kbd>System.Windows.Input</kbd> namespace, and provides two methods named <kbd>CanExecute</kbd> and <kbd>Execute</kbd>. The <kbd>CanExecute</kbd> method indicates whether the command is available, whereas the <kbd>Execute</kbd> method executes the command.</p>
<p>The <kbd>RoutedCommand</kbd> objects are basically empty shells and can't contain the implementation. For this to work, they look for a <kbd>CommandBinding</kbd> object from a target element that indicates the handler of the command. It registers the <kbd>CanExecute</kbd> and <kbd>Execute</kbd> methods to fire when the command associates with any control.</p>
<p>For example, in this demonstration, the <kbd>AddCommand</kbd> associated with the <kbd>Button</kbd> control has a <kbd>CommandBinding</kbd>, which denotes its <kbd>CanExecute</kbd> and <kbd>Execute</kbd> handler as <kbd>CanExecute_AddCommand</kbd> and <kbd>Execute_AddCommand</kbd>. When the button fires the <kbd>Click</kbd> event, it routes to the command binding to execute the associate command interface.</p>


            

            
        
    </body></html>