- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'In the first part of this book, we covered the process of refactoring and some
    of the more common refactoring techniques. Now, it’s time for us to take a step
    back and remind ourselves of what refactoring is: *refactoring is the process
    of changing the form or shape of the code without changing how* *it behaves*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，我们介绍了重构的过程和一些更常见的重构技术。现在，是我们退一步，提醒自己重构是什么：*重构是改变代码形式或形状的过程，而不改变其行为*。
- en: 'In other words, we can make our code as clean and easy to maintain as we can,
    but if those changes introduce bugs, that’s not refactoring since refactoring
    is about changing the form of code *without changing its behavior*. To improve
    our code without introducing bugs, we need a safety net: **unit testing**.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以使我们的代码尽可能干净和易于维护，但如果这些更改引入了错误，那么这不算重构，因为重构是关于在不改变其行为的情况下改变代码的形式。为了在不引入错误的情况下改进我们的代码，我们需要一个安全网：**单元测试**。
- en: 'In this chapter, we’ll explore unit tests and cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨单元测试，并涵盖以下主要主题：
- en: Understanding testing and unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试和单元测试
- en: Testing code with xUnit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用xUnit测试代码
- en: Refactoring unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构单元测试
- en: Exploring other testing frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索其他测试框架
- en: Adopting a testing mindset
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用测试思维
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter06/Ch6BeginningCode` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始代码可以从GitHub的[https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)在`Chapter06/Ch6BeginningCode`文件夹中获取。
- en: Understanding testing and unit tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试和单元测试
- en: 'Whenever I was managing or mentoring another developer and they wanted to make
    a change to a system I’d ask them a question: *“How can you be sure your change
    won’t* *break things?”*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我管理或指导其他开发者，他们想要对系统进行更改时，我会问他们一个问题：*“你如何确保你的更改不会* *破坏事物？”*
- en: 'This simple question can be deceptively hard to answer, but every answer I’ve
    ever heard boils down to a single concept: testing.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可能看起来很简单，但每个答案都归结为一个单一的概念：测试。
- en: I define **testing** as *the process of verifying software functionality and
    detecting unwanted changes to* *program behavior*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将**测试**定义为*验证软件功能并检测程序行为中不希望的变化的过程*。
- en: This testing could be done by a human, such as a developer or a quality assurance
    analyst, or it could be done via software, depending on the type of test involved.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试可以由人类执行，例如开发人员或质量保证分析师，或者可以通过软件执行，具体取决于所涉及的测试类型。
- en: Types of tests and the testing pyramid
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类型和测试金字塔
- en: 'Testing is a broad field that encompasses many different types of activities,
    including the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个广泛的领域，包括许多不同类型的活动，如下所示：
- en: '**Manual testing**, which involves a person performing some activity manually
    and verifying the outcome.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动测试**，涉及人员手动执行某些活动并验证结果。'
- en: '**Exploratory testing**, a subset of manual testing that focuses on exploring
    how the system reacts to things to find new types of bugs.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索性测试**，这是手动测试的一个子集，专注于探索系统对事物的反应，以发现新的错误类型。'
- en: '**Unit tests**, in which small parts of the software system are tested in isolation.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**，在这种测试中，软件系统的小部分被单独测试。'
- en: '**Component tests**, where larger components of the system are tested.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件测试**，其中测试系统的较大组件。'
- en: '**Integration tests**, which involve two components, such as an API and a database,
    that are tested together.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**，涉及两个组件，如API和数据库，它们一起被测试。'
- en: '**End-to-end tests**, in which entire paths through the system are tested.
    This usually involves multiple sets of components interacting in sequence.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**，在这种测试中，整个系统路径都会被测试。这通常涉及多个组件按顺序交互。'
- en: Most of these activities are automated tests where computer code interacts with
    the system to verify its behavior. We’ll talk more about what factors make up
    good tests at the end of this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些活动中的大多数都是自动化测试，其中计算机代码与系统交互以验证其行为。我们将在本章末尾更多地讨论构成良好测试的因素。
- en: Automated tests do have some drawbacks. First, automated tests take time to
    create. Typically, a human must write code or use some tool to script out the
    test. Secondly, these tests often require ongoing maintenance as the software
    system changes to stay relevant. Finally, these tests can offer a false sense
    of security. For example, let’s say a developer wrote a test to navigate to the
    “book a flight” web page and verify that open seats display as available. This
    test may pass even if the web page has obvious errors and misalignments on it,
    simply because the test was only coded to check a small part of the web page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试确实有一些缺点。首先，自动化测试需要时间来创建。通常，必须有人编写代码或使用某些工具来编写测试脚本。其次，这些测试通常需要持续维护，以保持与软件系统变化的关联。最后，这些测试可能会提供一种虚假的安全感。例如，假设一个开发者编写了一个测试来导航到“预订航班”网页并验证是否有空座位显示为可用。即使网页上有明显的错误和不匹配，这个测试也可能通过，仅仅是因为测试只编码了检查网页一小部分。
- en: On the other hand, human testers are intelligent. They have free agency and
    initiative and can make objective judgments about software that machines cannot.
    They can find issues that nobody ever thought of writing a test for, and they
    can provide valuable feedback about the functionality of your products. However,
    people are usually a lot slower than automated tests and it may take some time
    for a quality assurance analyst to test a feature once it is ready for testing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，人工测试人员是聪明的。他们有自由意志和主动性，可以对软件做出客观的判断，这是机器无法做到的。他们可以找到没有人想过要为它们编写测试的问题，并且可以提供关于您产品功能的有价值反馈。然而，人们通常比自动化测试慢得多，一旦某个功能准备好测试，质量保证分析师可能需要一些时间来测试它。
- en: There are strengths and weaknesses when it comes to both automated and manual
    tests. One is not better than the other; instead, they combine to make for an
    effective solution to quality issues in software projects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化和手动测试都有优点和缺点。一个并不比另一个更好；相反，它们结合起来为软件项目中的质量问题的有效解决方案。
- en: 'A popular concept in software quality is the idea of a **testing pyramid**.
    A testing pyramid shows the various types of tests an organization might perform.
    Additionally, as shown in *Figure 6**.1*, the width of each segment of the pyramid
    indicates the quantity of that type of test:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量中的一个流行概念是 **测试金字塔** 的想法。测试金字塔显示了组织可能执行的各种测试类型。此外，如图 *图6.1* 所示，金字塔每个部分的宽度表示该类型测试的数量：
- en: '![Figure 6.1 – An example of a testing pyramid](img/B21324_06_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 测试金字塔的一个示例](img/B21324_06_01.jpg)'
- en: Figure 6.1 – An example of a testing pyramid
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 测试金字塔的一个示例
- en: In a testing pyramid, such as this one, the items at the base should be the
    most numerous and the items at the top of the pyramid should be the rarest. Almost
    every diagram of a testing pyramid is different in the exact types of tests listed
    in the pyramid, but all of them agree that the most common form of testing should
    be the unit test and the least common should be manual testing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个测试金字塔中，例如这个，底部的项目应该是数量最多的，而金字塔顶部的项目应该是最稀少的。几乎每个测试金字塔的图表在金字塔中列出的测试类型上都有所不同，但它们都同意最常见的形式应该是单元测试，而最不常见的是手动测试。
- en: 'Many organizations get this wrong early in their software development maturity.
    When that happens, they have a lot of manual tests, few unit tests, and typically
    no end-to-end, integration, or component tests. As a result, the pyramid would
    look a little like *Figure 6**.2*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织在软件开发成熟度早期就犯了错误。当这种情况发生时，他们有很多手动测试，很少的单元测试，通常没有端到端、集成或组件测试。结果，金字塔看起来可能有点像
    *图6.2*：
- en: '![Figure 6.2 – Testing pyramid with many manual tests, few unit tests, and
    no other tests](img/B21324_06_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 具有许多手动测试、少量单元测试和没有其他测试的测试金字塔](img/B21324_06_02.jpg)'
- en: Figure 6.2 – Testing pyramid with many manual tests, few unit tests, and no
    other tests
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 具有许多手动测试、少量单元测试和没有其他测试的测试金字塔
- en: This pyramid *should* look ridiculous because having very little test automation
    is almost always a recipe for slow processes, delayed releases, and software bugs
    reaching production environments!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个金字塔 *应该* 看起来很荒谬，因为几乎总是缺乏测试自动化是缓慢过程、延迟发布和软件错误进入生产环境的配方！
- en: The larger your system becomes, the less feasible manual testing will be and
    the longer it will take to discover bugs manually.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您的系统越大，手动测试就越不切实际，手动发现错误的时间就越长。
- en: The solution to this is **automated testing**, particularly automated unit testing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是 **自动化测试**，尤其是自动化单元测试。
- en: Unit tests
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are small methods of code that test other methods in your system
    to verify those methods perform correctly given a specific scenario.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是代码中的小方法，用于测试系统中其他方法，以验证这些方法在特定场景下是否正确执行。
- en: '*More succinctly, unit tests are code that tests* *other code*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*更简洁地说，单元测试是测试其他代码的代码*。'
- en: Already familiar with tests?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 已经熟悉测试了吗？
- en: You may already be familiar with unit tests if you work with unit tests regularly.
    If that’s true, you may want to skim the rest of this chapter and resume with
    the next one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常使用单元测试，你可能已经熟悉单元测试了。如果是这样，你可能想快速浏览本章的其余部分，然后继续下一章。
- en: 'To illustrate the idea of unit testing, let’s look at a simple method that
    generates a flight status message:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明单元测试的概念，让我们看看一个简单的生成航班状态信息的方法：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While this method is very simple, let’s think about the steps we’d need to
    take to verify it works correctly:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法非常简单，但让我们考虑一下我们需要采取哪些步骤来验证它是否正确工作：
- en: Instantiate the `Flight` class and store that object in a variable.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化 `Flight` 类并将该对象存储在变量中。
- en: Declare a pair of string variables representing `id` and `status`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一对表示 `id` 和 `status` 的字符串变量。
- en: Invoke the `BuildMessage` method on our flight object from *Step 1*.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *步骤 1* 中调用我们的航班对象的 `BuildMessage` 方法。
- en: Store the result of *Step 3* in a new string variable.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *步骤 3* 的结果存储在一个新的字符串变量中。
- en: Verify the string we just stored matched what we expected.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们刚刚存储的字符串是否与预期相符。
- en: This is essentially what a unit test would do. It would instantiate your class,
    *arrange* the variables it needs, *act* on the method the unit test is trying
    to verify, and finally *assert* that the result of the method matched what we
    expected. We call this pattern the **arrange/act/assert** pattern and we’ll discuss
    it more later in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是一个单元测试会做的事情。它会实例化你的类，*安排*它需要的变量，*执行*单元测试试图验证的方法，并最终 *断言* 方法的结果是否符合预期。我们称这种模式为
    **安排/执行/断言** 模式，我们将在本章后面进一步讨论。
- en: 'To help illustrate this concept, here’s a sample test for the `BuildMessage`
    method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助说明这个概念，这里有一个 `BuildMessage` 方法的示例测试：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don’t worry about the specific syntax here as we’ll get into this shortly. For
    now, understand that the `GeneratedMessageShouldBeCorrect` method is an example
    of a unit test that tests a small unit of code to verify a specific piece of functionality.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这里的特定语法，因为我们很快就会涉及到这一点。现在，理解 `GeneratedMessageShouldBeCorrect` 方法是测试一小段代码以验证特定功能的单元测试的例子。
- en: Specifically, this method verifies that the `Flight` class’s `BuildMessage`
    method calculates and returns an accurate status message given the `id` and `status`
    parameters it receives.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，此方法验证 `Flight` 类的 `BuildMessage` 方法根据它接收的 `id` 和 `status` 参数计算并返回准确的状态信息。
- en: 'This test can be run quickly alongside all the other tests in the solution
    and will either pass if the `BuildMessage` method is acting as expected or will
    fail if the result of `BuildMessage` ever changes, as shown in *Figure 6**.3*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试可以快速与解决方案中的所有其他测试一起运行，如果 `BuildMessage` 方法按预期工作，则通过；如果 `BuildMessage` 的结果有任何变化，则失败，如图
    *6**.3* 所示：
- en: '![Figure 6.3 – A failing unit test](img/B21324_06_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 一个失败的单元测试](img/B21324_06_03.jpg)'
- en: Figure 6.3 – A failing unit test
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 一个失败的单元测试
- en: Test failures such as this are helpful because they highlight bugs that developers
    might otherwise release into production without the failing test flagging the
    potential issue.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的测试失败是有帮助的，因为它们突出了开发者可能在没有失败的测试标记潜在问题的前提下发布到生产环境中的错误。
- en: 'In the next section, we’ll explore unit tests more by introducing the most
    popular unit testing framework: **xUnit**.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过介绍最流行的单元测试框架：**xUnit**，来更深入地探讨单元测试。
- en: Testing code with xUnit
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 xUnit 测试代码
- en: xUnit.net, commonly referred to as xUnit, is currently the most popular unit
    testing library in .NET, followed by `Attributes` that you can use to identify
    your test code, as we’ll see shortly. Using these attributes lets a test runner,
    such as Visual Studio’s **Test Explorer**, recognize your methods as unit tests
    and run them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net，通常简称为 xUnit，是目前 .NET 中最受欢迎的单元测试库，其次是 `Attributes`，你可以使用它来标识你的测试代码，我们很快就会看到。使用这些属性可以让测试运行器，如
    Visual Studio 的 **测试资源管理器**，识别你的方法为单元测试并运行它们。
- en: This chapter’s code starts with most of the classes from the chapters up to
    this point, organized into various namespaces inside of the `Chapter6` `Chapter6BeginningCode`
    **solution**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码从到目前为止的章节中的大多数类开始，组织在 `Chapter6` 的 `Chapter6BeginningCode` **解决方案** 内的各种命名空间中。
- en: Solutions and projects
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案和项目
- en: In .NET, a project represents a distinct assembly of .NET code that accomplishes
    some purpose. Different projects have different types, from desktop applications
    to web servers to class libraries and test projects. Solutions, on the other hand,
    group all of these projects together into a collection of interrelated projects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，一个项目代表一个具有特定目的的 .NET 代码的独立程序集。不同的项目有不同的类型，从桌面应用程序到 Web 服务器，再到类库和测试项目。另一方面，解决方案将所有这些项目组合成一个相互关联的项目集合。
- en: In the remainder of this chapter, we’ll write tests for a number of the classes
    from the previous chapters. Since xUnit is currently the most popular testing
    library, let’s start by adding a new xUnit test project to the solution.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将为前几章中的几个类编写测试。由于 xUnit 目前是最受欢迎的测试库，让我们首先向解决方案中添加一个新的 xUnit 测试项目。
- en: Creating an xUnit Test Project
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 xUnit 测试项目
- en: To add a new project to a solution, right-click on the solution’s name at the
    top of **Solution Explorer**, just below the search bar, and then choose **Add**,
    followed by **New Project…**
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要向解决方案添加新项目，请右键单击 **解决方案资源管理器** 顶部的解决方案名称，位于搜索栏下方，然后选择 **添加**，接着选择 **新建项目…**
- en: 'Next, search for `xUnit` and select the **xUnit Test Project** result with
    the C# label attached to it, as shown in *Figure 6**.4*. Note that there are also
    versions of this test project that use other languages, such as VB or F#:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，搜索 `xUnit` 并选择带有 C# 标签的 **xUnit 测试项目** 结果，如图 *图 6.4* 所示。请注意，还有使用其他语言（如 VB
    或 F#）的此测试项目的版本：
- en: '![Figure 6.4 – Selecting the xUnit Test Project option](img/B21324_06_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 选择 xUnit 测试项目选项](img/B21324_06_04.jpg)'
- en: Figure 6.4 – Selecting the xUnit Test Project option
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 选择 xUnit 测试项目选项
- en: Click `Chapter6XUnitTests`, and click **Next** again.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `Chapter6XUnitTests`，然后再次点击 **下一步**。
- en: After this, you'll need to select the version of .NET to use. Since the code
    in this book uses **.NET 8**, you can select that option and click **Create**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，您需要选择要使用的 .NET 版本。由于本书中的代码使用 **.NET 8**，您可以选中该选项并点击 **创建**。
- en: 'This should open a new file in your editor that contains some basic test code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在您的编辑器中打开一个新文件，其中包含一些基本的测试代码：
- en: UnitTest1.cs
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: UnitTest1.cs
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Additionally, a new project was added to your solution that now appears in
    **Solution Explorer**, as shown in *Figure 6**.5*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个新的项目已添加到您的解决方案中，现在在 **解决方案资源管理器** 中可见，如图 *图 6.5* 所示：
- en: '![Figure 6.5 – The test project in Solution Explorer](img/B21324_06_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 解决方案资源管理器中的测试项目](img/B21324_06_05.jpg)'
- en: Figure 6.5 – The test project in Solution Explorer
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 解决方案资源管理器中的测试项目
- en: There are still a few more steps that we’ll need to do to test our code in the
    other project. But before we do that, it may surprise you that the code xUnit
    created is already a runnable unit test.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要执行几个步骤来测试其他项目中的代码。但在我们这样做之前，可能会让您惊讶的是，xUnit 创建的代码已经是一个可运行的单元测试。
- en: 'Click on the `Test1` unit test, which will turn into a green check mark once
    the test runs, as shown in *Figure 6**.6*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `Test1` 单元测试，一旦测试运行，它将变成绿色勾选标记，如图 *图 6.6* 所示：
- en: '![Figure 6.6 – Test Explorer with tests expanded to the point where Test1 is
    visible](img/B21324_06_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 测试资源管理器，测试展开到 Test1 可见的位置](img/B21324_06_06.jpg)'
- en: Figure 6.6 – Test Explorer with tests expanded to the point where Test1 is visible
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 测试资源管理器，测试展开到 Test1 可见的位置
- en: Troubleshooting
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除
- en: If you do not see **Test Explorer** after running your tests, click on the **View**
    menu and then select **Test Explorer**. You may also need to build your solution
    before running tests becomes an option.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行测试后看不到 **测试资源管理器**，请点击 **视图** 菜单，然后选择 **测试资源管理器**。您可能还需要在运行测试成为选项之前构建解决方案。
- en: Note that our current test isn’t much of a test and we still haven’t covered
    the code or how it works. We’ll get there shortly, but first, let’s take the final
    step in setting up our tests and connect our test project to our `Chapter6` project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们当前的测试并不算是一个真正的测试，我们还没有涵盖代码或它是如何工作的。我们很快就会到达那里，但首先，让我们完成设置测试的最后一步，并将我们的测试项目连接到
    `Chapter6` 项目。
- en: Connecting the xUnit Test Project to your main project
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 xUnit 测试项目连接到主项目
- en: In .NET, projects can depend on code in other projects. This allows you to have
    a class defined in one project and another project uses that class. This is something
    we’ll need to be able to do to test code from our unit test project. So, we’ll
    need to set up a project dependency from the test project to the `Chapter6` project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，项目可以依赖于其他项目中的代码。这允许你在一个项目中定义一个类，另一个项目可以使用该类。为了能够从我们的单元测试项目中测试代码，我们需要能够做到这一点。因此，我们需要从测试项目设置一个项目依赖到`Chapter6`项目。
- en: 'Right-click on the **Dependencies** node inside of the test project in **Solution
    Explorer** and choose **Add Project Reference…**, as shown in *Figure 6**.7*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，在测试项目内的**依赖项**节点上右键单击，并选择**添加项目引用…**，如图*图6**.7*所示：
- en: '![Figure 6.7 – Adding a project reference to our test project](img/B21324_06_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 向我们的测试项目添加项目引用](img/B21324_06_07.jpg)'
- en: Figure 6.7 – Adding a project reference to our test project
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 向我们的测试项目添加项目引用
- en: After this, click the checkmark next to `Chapter6` and click `Chapter6` project
    so that the test project can now reference classes defined in the other project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击“解决方案资源管理器”中测试项目内的“依赖项”节点旁边的复选标记，并点击“Chapter6”项目，以便测试项目现在可以引用其他项目中定义的类。
- en: With all this in place, we’re ready to write our first real test.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪后，我们就可以编写我们的第一个真正的测试了。
- en: Writing your first unit test
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你的第一个单元测试
- en: Our first tests will test the `BaggageCalculator` class we built in [*Chapter
    2*](B21324_02.xhtml#_idTextAnchor026).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一批测试将测试我们在[*第二章*](B21324_02.xhtml#_idTextAnchor026)中构建的`BaggageCalculator`类。
- en: '`BaggageCalculator` has a `CalculatePrice` method with the following method
    signature:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaggageCalculator`有一个名为`CalculatePrice`的方法，其方法签名如下：'
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also know the following rules for this method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道这个方法的一些规则：
- en: All carry-on baggage costs $30 per bag
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有手提行李每件费用为30美元
- en: The first checked bag a passenger checks in costs $40
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘客托运的第一个行李箱的费用为40美元
- en: Each subsequent checked bag costs $50
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个后续托运的行李箱费用为50美元
- en: If the travel occurs during the holidays, a 10% surcharge is applied
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果旅行发生在假日期间，将应用10%的附加费
- en: We won’t be able to test all this logic in a single test, and we shouldn’t try.
    Unit tests should be small and related to one specific piece of logic. If a test
    fails, that failure should tell you a lot about what is wrong in your system.
    If unit tests try to do too much, they become harder to understand and a failure
    tells you less about what is wrong.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在单个测试中测试所有这些逻辑，而且我们也不应该尝试这样做。单元测试应该是小的，并且与一个特定的逻辑相关。如果测试失败，这个失败应该告诉你很多关于系统错误的信息。如果单元测试试图做太多，它们就变得难以理解，失败时告诉你更少关于错误的信息。
- en: Let’s start by taking our `UnitTest1` class and renaming it using the rename
    refactoring we covered in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026). Tests
    are generally named after the class they test. Since our class tests `BaggageCalculator`,
    let’s rename it `BaggageCalculatorTests`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将我们的`UnitTest1`类重命名为`BaggageCalculatorTests`开始，使用我们在[*第二章*](B21324_02.xhtml#_idTextAnchor026)中介绍的重命名重构功能。测试通常以它们测试的类的名称命名。由于我们的类测试`BaggageCalculator`，让我们将其重命名为`BaggageCalculatorTests`。
- en: Next, we’ll rename the `Test1` method to reflect what we’re trying to verify.
    The name of this test will show up in a test failure. So, my general rule of thumb
    is that if I get a notification that a test failed, its name alone should tell
    me what went wrong.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重命名`Test1`方法，以反映我们试图验证的内容。这个测试的名称将出现在测试失败中。因此，我的一个基本原则是，如果收到一个测试失败的提醒，其名称本身就应该告诉我出了什么问题。
- en: In our case, we’re trying to verify that carry-on baggage is priced correctly.
    So, let’s rename `Test1` to something like `CarryOnBaggageIsPricedCorrectly`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们试图验证手提行李的定价是否正确。因此，让我们将`Test1`重命名为类似`CarryOnBaggageIsPricedCorrectly`的名称。
- en: 'Our code now reads as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码如下所示：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we move on to writing our test code, let’s highlight a few key things:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试代码之前，让我们强调几个关键点：
- en: First, our method has a `Fact` attribute applied to it. This lets xUnit tell
    the test runner about our test and effectively registers the test for potential
    execution.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们的方法应用了`Fact`属性。这允许xUnit告诉测试运行器关于我们的测试的信息，并有效地为潜在的执行注册测试。
- en: Next, `CarryOnBaggageIsPricedCorrectly` returns `void` and accepts no parameters.
    Test methods using the `Fact` attribute cannot accept parameters and must either
    return `void` or `Task` for asynchronous tests. We’ll discuss `Theory` and `InlineData`
    later in this chapter as they allow you to pass in parameters to unit tests.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，`CarryOnBaggageIsPricedCorrectly`方法返回`void`且不接受任何参数。使用`Fact`属性的测试方法不能接受参数，必须返回`void`或`Task`以进行异步测试。我们将在本章后面讨论`Theory`和`InlineData`，因为它们允许你向单元测试传递参数。
- en: Finally, both the class and the method are `public`. Both must be `public` for
    the unit test to appear in the test runner.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，类和方法都是`public`的。为了单元测试出现在测试运行器中，两者都必须是`public`。
- en: Now that we’ve covered some of the basic mechanics of unit tests, let’s follow
    the *arrange*/*act*/*assert* pattern to build our test.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些单元测试的基本机制，让我们遵循*arrange*/*act*/*assert*模式来构建我们的测试。
- en: Organizing tests with Arrange/Act/Assert
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Arrange/Act/Assert 组织测试
- en: 'The **arrange/act/assert pattern** is a structural pattern that’s used when
    writing tests. When following *arrange*/*act*/*assert*, you perform the following
    steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**arrange/act/assert模式**是一个结构化模式，用于编写测试。遵循*arrange*/*act*/*assert*时，你执行以下步骤：'
- en: '**Arrange** the things that you need for your tests by declaring variables.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过声明变量**安排**你需要用于测试的事情。
- en: '**Act** on the specific thing you’re trying to test.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行**你试图测试的具体事情。'
- en: '**Assert** that the result of your action produced the desired outcome.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断言**你的操作产生了预期的结果。'
- en: Let’s start by arranging the code. Since we’re testing the `CalculatePrice`
    method on the `BaggageCalculator` class, we’ll need to instantiate an instance
    of the baggage calculator.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从整理代码开始。由于我们要在`BaggageCalculator`类上测试`CalculatePrice`方法，我们需要实例化一个行李计算器的实例。
- en: We also know we’ll need to pass in the number of checked and carry-on bags,
    as well as the number of passengers and whether the travel is during a holiday
    season. These values should be whatever we think will make the most relevant or
    representative test, so they’re up to our discretion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道我们需要传递已检查的和托运行李的数量，以及乘客数量以及旅行是否在假日季节。这些值应该是我们认为最相关或最具代表性的测试值，因此它们取决于我们的判断。
- en: 'Filling out our *arrange* section with variable declarations results in the
    following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用变量声明填充我们的*arrange*部分会产生以下代码：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we’re setting up everything we need to carry out the *act* phase. Also,
    note that I included an `// Arrange` comment to group related code together. This
    is something I and many other developers I know do in our test code to help organize
    tests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在设置执行*act*阶段所需的一切。此外，请注意，我包含了一个`// Arrange`注释来将相关代码分组。这是我和许多其他我知道的开发者在测试代码中做的事情，以帮助组织测试。
- en: 'Now that we have our variables in place, we can act upon the code we’re testing:
    the `CalculatePrice` method. To do this, we must call the method and store the
    `decimal` value it returns:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了变量，我们可以对我们要测试的代码：`CalculatePrice`方法进行操作。为此，我们必须调用该方法，并存储它返回的`decimal`值：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unlike the *arrange* section, the *act* section is very brief, usually only
    a single line long. This is because the *act* section focuses on the thing you’re
    trying to test. We call the method we’re testing on the calculator object that
    was instantiated earlier and pass it the parameters it needs to do its job.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与*arrange*部分不同，*act*部分非常简短，通常只有一行长。这是因为*act*部分专注于你试图测试的事情。我们调用之前实例化的计算器对象上的测试方法，并传递它执行工作所需的参数。
- en: The system under test
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的系统
- en: In our example, the `calculator` variable stores the instance of the class we’re
    testing. This is commonly referred to as the `sut` variable name for the object
    they’re about to test.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`calculator`变量存储了我们正在测试的类的实例。这通常被称为即将测试的对象的`sut`变量名。
- en: 'Here’s the cool thing: from our test’s perspective, we don’t care how it does
    its job. All we care about is that we give the method a set of inputs and we expect
    a specific output.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是：从我们的测试角度来看，我们不在乎它是如何完成工作的。我们只关心我们给方法一组输入，并期望得到特定的输出。
- en: We verify this behavior in our *assert* section by asserting that one or more
    things are true. If these things turn out *not* to be true, our test will fail.
    If all of them turn out to be true, the test will pass.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*assert*部分通过断言一些事情是真实的来验证这种行为。如果这些事情最终*不是*真实的，我们的测试将失败。如果所有这些事情最终都是真实的，测试将通过。
- en: 'Assertions typically use the `Assert` class to verify that values match their
    expected value. In our case, the scenario has 2 carry-on bags and no other bags.
    At $30 per carry-on bag, this should work out to $60, so our test code becomes
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 断言通常使用`Assert`类来验证值是否与其预期值匹配。在我们的案例中，场景有2个托运行李，没有其他行李。每个托运行李30美元，这应该总计60美元，所以我们的测试代码如下：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first parameter of the `Equal` method is the expected value. That’s the
    value *you* expect your result to be. You should *not* be calculating this value
    in code; otherwise, you risk repeating the same potentially bad logic in the code
    you’re testing to begin with!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equal`方法的第一参数是预期值。这是你期望你的结果应该是的值。你不应该在代码中计算这个值；否则，你可能会在测试你正在测试的代码时重复相同的潜在不良逻辑！'
- en: The second parameter is the actual value, which is almost always the result
    of calling your method in the *act* section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是实际值，这几乎总是你在*act*部分调用你的方法的结果。
- en: Often, developers new to testing expect the first parameter to be the actual
    value and the second value to be the expected value. However, this is incorrect
    and will lead to confusing test failures with swapped values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对测试新手来说，他们期望第一个参数是实际值，第二个参数是预期值。然而，这是不正确的，会导致测试失败时值被颠倒的困惑测试。
- en: 'For example, if the result was 50 and we verified it correctly with `Assert.Equal(60m,
    result);` as we did earlier, you’d see a failure like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果结果是50，并且我们像之前那样正确地用`Assert.Equal(60m, result);`验证了它，你会看到这样的失败：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is helpful and tells the developer what went wrong.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，并告诉开发者出了什么问题。
- en: 'If you confused the two parameters and wrote `Assert.Equal(result, 60m);` you’d
    get this much more confusing message:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你混淆了两个参数并编写了`Assert.Equal(result, 60m);`，你会得到这样一个更令人困惑的消息：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This mistake has caused a lot of confusion and hair loss for me in the past.
    Do yourself a favor and remember that the first parameter is always the value
    you expect the result to be.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误在过去给我带来了很多困惑和头发脱落。请自己帮个忙，记住第一个参数总是你期望结果为的值。
- en: In [*Chapter 9*](B21324_09.xhtml#_idTextAnchor189), *Advanced Unit Testing*,
    we’ll introduce a cleaner way of writing assertions with the **Shouldly** and
    **FluentAssertions** libraries. For now, remember that the expected value goes
    first and the actual value goes second.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B21324_09.xhtml#_idTextAnchor189) *高级单元测试*中，我们将介绍使用**Shouldly**和**FluentAssertions**库编写断言的更简洁方法。现在，请记住预期的值先写，实际的值后写。
- en: Other Assert methods
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 Assert 方法
- en: The `Assert` class has more methods than just `Assert.Equal`. You can also use
    `Assert.True` and `Assert.False` to verify whether a boolean condition is true
    or false. `Assert.Null` and `Assert.NotNull` can help verify if something is or
    isn’t null. `Assert.Contains` and `Assert.DoesNotContain` will verify the presence
    or absence of an element in a collection. These are just a few of the methods
    available through the `Assert` class. For each of these messages, you can also
    provide a custom failure message to use when an assertion causes your test to
    fail.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`类除了`Assert.Equal`之外还有更多方法。你还可以使用`Assert.True`和`Assert.False`来验证布尔条件是否为真或假。`Assert.Null`和`Assert.NotNull`可以帮助验证某个东西是否为null。`Assert.Contains`和`Assert.DoesNotContain`将验证集合中元素的存在或不存在。这些只是通过`Assert`类可用的方法中的一部分。对于这些消息中的每一个，你还可以提供一个自定义的失败消息，当断言导致你的测试失败时使用。'
- en: Now that we’ve added our first unit test, let’s talk specifically about what
    makes a test pass and what makes a test fail.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了第一个单元测试，让我们具体谈谈什么使测试通过，什么使测试失败。
- en: Understanding tests and exceptions
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解测试和异常
- en: Every unit test that runs will pass – unless it encounters something that makes
    it fail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行的单元测试都会通过——除非它遇到了让它失败的东西。
- en: That failure could be an `Assert` statement not matching the expected value,
    or it could be your program or test throwing an exception without catching it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那个失败可能是`Assert`语句与预期值不匹配，或者可能是你的程序或测试抛出了异常而没有捕获它。
- en: When you investigate how `Assert` methods are implemented, you’ll see that they
    all throw exceptions when their conditions aren’t met. When these exceptions are
    thrown, the test runner catches them and fails the test, displaying the failure
    message and stack trace appropriately.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调查`Assert`方法的实现时，你会发现当它们的条件不满足时，它们都会抛出异常。当这些异常被抛出时，测试运行器会捕获它们并使测试失败，适当地显示失败信息和堆栈跟踪。
- en: This is why an empty test will pass even without any `Assert` statements, and
    this is why you generally never write a `try`/`catch` block in your unit tests
    unless you are explicitly trying to verify some form of exception-handling logic.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么一个空的测试即使没有任何`Assert`语句也会通过，这也是为什么你通常永远不会在单元测试中编写`try`/`catch`块，除非你明确地试图验证某种异常处理逻辑。
- en: Armed with this understanding of what makes a test fail, let’s write a second
    test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 带着对导致测试失败的因素的理解，让我们编写第二个测试。
- en: Adding additional test methods
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加额外的测试方法
- en: Just like classes can have multiple methods inside of them, test classes can
    have multiple test methods inside of them. This is because unit tests are just
    code in every sense of the word. Unit tests live in classes that are ordinary
    in every regard, except they live in a special project type and individual unit
    test methods have `[Fact]` just before the method is declared.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类可以在其中包含多个方法一样，测试类也可以在其中包含多个测试方法。这是因为从每个意义上说，单元测试只是代码。单元测试存在于每个方面都很普通的类中，除了它们存在于一个特殊的项目类型中，并且单个单元测试方法在声明方法之前有`[Fact]`。
- en: 'Let’s illustrate this by adding a test for the next scenario: *The first checked
    bag costs $40*. Here’s what that test would look like:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个针对下一个场景的测试来举例说明：*第一个托运行李费用为40美元*。这个测试看起来是这样的：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are a lot of similarities between this test and the prior one, but the
    key differences are that the number of carry-on and checked bags has changed to
    match the new scenario we’re testing, and the expected total is now $40 instead
    of $60.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与之前的测试有很多相似之处，但关键的区别在于携带行李和托运行李的数量已更改，以匹配我们正在测试的新场景，并且预期的总价现在是40美元而不是60美元。
- en: Each test you write should be different. However, if you start to notice a lot
    of commonalities between tests, it’s probably time to refactor your unit tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的每个测试都应该不同。然而，如果你开始注意到测试之间存在很多共性，那么可能就是时候重构你的单元测试了。
- en: Refactoring unit tests
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构单元测试
- en: Unit tests are code, and like other types of code, they can degrade in quality
    over time when not given proper respect and proactive refactoring.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是代码，就像其他类型的代码一样，如果得不到适当的尊重和主动重构，它们的质量可能会随着时间的推移而下降。
- en: Hence, when you see code smells such as duplicated code that appears in most
    of your tests, it’s a sign that your tests need to be refactored.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你看到代码中存在诸如在大多数测试中出现的重复代码这样的代码异味时，这是一个迹象，表明你的测试需要重构。
- en: In this section, we’ll explore several ways of refactoring your test code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几种重构测试代码的方法。
- en: Parameterizing tests with Theory and InlineData
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Theory`和`InlineData`参数化测试
- en: When we think about the similarities between our two tests, they only vary based
    on the values being passed into the method we’re testing and the value we expect
    the result to be.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑两个测试之间的相似性时，它们只基于传递给我们要测试的方法的值以及我们期望的结果值而有所不同。
- en: Thinking about our test method, this is a clear case where it’d be wonderful
    to have parameters that could go into one test method that could represent multiple
    unit tests, each testing something slightly different, but with similar code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的测试方法，这是一个很明显的例子，如果能有一个参数可以输入到一个测试方法中，就能代表多个单元测试，每个测试都略有不同，但代码相似，那就太好了。
- en: As you may recall from earlier, unit tests that use `Fact` cannot have any parameters
    to them. However, xUnit gives us another attribute called `Theory` that allows
    us to pass data into the unit test as parameters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从之前的内容中回忆起来，使用`Fact`的单元测试不能有任何参数。然而，xUnit给了我们另一个属性叫做`Theory`，它允许我们将数据作为参数传递给单元测试。
- en: There are multiple different ways of providing data to these parameters, but
    the most common way is to use an `InlineData` attribute to provide the test parameter
    data next to the method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种不同的方式向这些参数提供数据，但最常见的方式是使用`InlineData`属性在方法旁边提供测试参数数据。
- en: 'Here’s an example of using `Theory` and `InlineData` to test four different
    scenarios around baggage pricing using the same test code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`Theory`和`InlineData`来测试围绕行李定价的四个不同场景的示例，使用相同的测试代码：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While this is only a single method, each `InlineData` line represents a unique
    unit test and, as shown in *Figure 6**.8*, it will show up as an individual test
    in the test runner:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个单一的方法，但每个`InlineData`行代表一个独特的单元测试，如图*图6.8*所示，它将作为单独的测试出现在测试运行器中：
- en: '![Figure 6.8 – The four theory-based tests in Test Explorer grouped under a
    single test](img/B21324_06_08.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 测试资源管理器中按单个测试分组显示的基于理论的四个测试](img/B21324_06_08.jpg)'
- en: Figure 6.8 – The four theory-based tests in Test Explorer grouped under a single
    test
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 测试资源管理器中基于理论的四个测试被单个测试分组
- en: Although using `Theory` instead of `Fact` can initially be harder to read, the
    maintainability advantage is huge. First, parameterized tests have less code duplication.
    Secondly, if you need to update your tests later, you only need to update a single
    method instead of the many separate methods if you wrote the same tests using
    `Fact`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 `理论` 而不是 `事实` 可能一开始更难阅读，但可维护性的优势是巨大的。首先，参数化测试减少了代码重复。其次，如果你以后需要更新测试，你只需要更新一个方法，而不是使用
    `事实` 编写相同测试时需要更新的许多单独的方法。
- en: Initializing test code with constructors and fields
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数和字段初始化测试代码
- en: '`Theory` isn’t the only way to improve your test code. If you find that your
    tests do a lot of work that is potentially sharable, you can introduce private
    methods to help organize your test code.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`理论` 并不是提高测试代码的唯一方法。如果你发现你的测试做了很多可以共享的工作，你可以引入私有方法来帮助组织你的测试代码。'
- en: For example, let’s say you wanted to test the `FlightScheduler` class from [*Chapter
    5*](B21324_05.xhtml#_idTextAnchor101) and you wanted to start with testing that
    adding a flight to the schedule via `ScheduleFlight` results in that flight showing
    up when `GetAllFlights` is called.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想测试来自 [*第5章*](B21324_05.xhtml#_idTextAnchor101) 的 `FlightScheduler` 类，并且你想从测试通过
    `ScheduleFlight` 将航班添加到计划中，并在调用 `GetAllFlights` 时显示该航班开始。
- en: To do this, you’ve created a `FlightSchedulerTests` class and are working on
    a `ScheduleFlightShouldAddFlight` unit test.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你已经创建了一个 `FlightSchedulerTests` 类，并且正在编写一个 `ScheduleFlightShouldAddFlight`
    单元测试。
- en: As you begin to write the test, you notice the `ScheduleFlight` method requires
    an `IFlightInfo` instance, which, in turn, needs several `AirportEvent` objects.
    These `AirportEvent` objects require their own `Airport` instances.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写测试时，你会注意到 `ScheduleFlight` 方法需要一个 `IFlightInfo` 实例，而这个实例反过来又需要几个 `AirportEvent`
    对象。这些 `AirportEvent` 对象需要它们自己的 `Airport` 实例。
- en: 'These dependencies result in you writing a lot of *arrange* code to set up
    for your test:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖关系导致你编写了大量 *安排* 代码来为测试设置：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This large volume of code isn’t necessarily *bad*, but it does distract from
    the rest of the test method, which performs the scheduling and verifies that the
    flight was added:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这大量的代码并不一定是 *坏* 的，但它确实分散了测试方法的其他部分，该部分执行调度并验证航班是否已添加：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While a lengthy *arrange* section isn’t the end of the world, other tests may
    likely want to create their own `PassengerFlightInfo`, `Airport`, or `AirportEvent`,
    which would lead to very similar code showing up between tests.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `安排` 部分很长并不是世界末日，但其他测试可能需要创建自己的 `PassengerFlightInfo`、`Airport` 或 `AirportEvent`，这会导致测试之间出现非常相似的代码。
- en: 'To help improve the readability of our arrange method, we can introduce fields
    for the two airports and set them up in the constructor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助提高我们安排方法的可读性，我们可以引入两个机场的字段，并在构造函数中设置它们：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When xUnit runs your test code, it will instantiate the `FlightSchedulerTests`
    class once for every unit test in that class. This means that any logic in the
    constructor or field initializers will run whenever any test in that class is
    run.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当 xUnit 运行你的测试代码时，它将为该类中的每个单元测试实例化一次 `FlightSchedulerTests` 类。这意味着构造函数或字段初始化器中的任何逻辑都会在运行该类中的任何测试时运行。
- en: 'This lets us simplify the *arrange* section of our test considerably:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以显著简化测试的 `安排` 部分：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This process can be repeated as needed. For example, if you wanted to reuse
    the same `PassengerFlightInfo` between tests, you could add a `_flight` field
    and initialize it in the constructor as well.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以根据需要重复。例如，如果你想在不同测试之间重用相同的 `PassengerFlightInfo`，你可以在构造函数中添加一个 `_flight`
    字段并初始化它。
- en: The refactoring process isn’t about minimizing the size of the *arrange* section;
    it’s about keeping code duplication low while keeping the important aspects of
    your test visible to other developers reading your code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重构过程不是关于最小化 *安排* 部分的大小；它是关于在保持代码重复低的同时，让其他阅读你代码的开发者能够看到测试的重要方面。
- en: Sharing test code with methods
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法共享测试代码
- en: Another technique you can use to keep your code focused is to extract reusable
    methods from your test code to help accomplish common *arrange* tasks.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用另一种技术来保持你的代码集中，那就是从你的测试代码中提取可重用方法，以帮助完成常见的 *安排* 任务。
- en: For example, if you wanted to test that removing a flight correctly removes
    the flight from the scheduler, you’d need a test that looks a lot like the test
    we just covered.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想测试移除航班是否正确地从调度器中移除航班，你需要一个与刚才我们讨论的测试非常相似的测试。
- en: When you think about it, both tests don’t care much about the specifics of the
    flight being added – they care that when a flight is scheduled, it appears in
    the list of flights and that when a flight is removed, it should no longer be
    included.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这么想的时候，这两个测试并不太关心被添加的航班的详细信息——它们关心的是，当航班被安排时，它应该出现在航班列表中，而当航班被移除时，它应该不再被包含。
- en: 'To accomplish this, we can extract a method to create our `Flight` object.
    This method could take in a flight identifier and return the created flight, as
    shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以提取一个方法来创建我们的`Flight`对象。这个方法可以接受一个航班标识符并返回创建的航班，如下所示：
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our prior test can now call this method to create its flight:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的测试现在可以调用这个方法来创建其航班：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See how much more focused this method is? You can quickly read it and get the
    intent of the test without having to focus on all the mechanics needed to create
    the flight.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得这个方法有多专注？你可以快速阅读它，并了解测试的意图，而无需关注创建航班的所有必要机制。
- en: Testing void methods
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`void`方法
- en: One question I often encounter is “How do you test `void` methods since they
    don’t return anything?” Most of the time, when you write tests, you test the return
    value of a method, but with `void` methods, you test the side effects of that
    method. This `ScheduleFlight` test is an example of how a `void` method can be
    tested. In our case, the side effect of scheduling a flight *should* be that the
    flight is present later when we’re getting all the flights from the scheduler.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常遇到的一个问题是“如何测试`void`方法，因为它们不返回任何内容？”大多数时候，当你编写测试时，你会测试方法的返回值，但针对`void`方法，你测试的是该方法的副作用。这个`ScheduleFlight`测试就是一个例子，说明了如何测试`void`方法。在我们的案例中，安排航班的副作用应该是当我们从调度器获取所有航班时，航班会出现在列表中。
- en: 'Now, let’s look at the flight removal test, which uses the same method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看航班移除测试，它使用了相同的方法：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method is focused on the task of scheduling a flight and then removing
    it, and then verifying that the flight is no longer on the list of flights. If
    adding and removing a flight doesn’t remove it from the list of flights, that
    would be a bug and the test would fail.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法专注于安排航班然后移除它，并验证航班不再出现在航班列表中。如果添加和移除航班没有从航班列表中移除它，那将是一个错误，测试将失败。
- en: Sharing methods between test classes
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类之间共享方法
- en: If you find that many of your test classes would benefit from the same “helper”
    methods, such as `CreateFlight`, you may want to consider moving these helpers
    to a static class in your test project. This pattern is sometimes referred to
    as the **ObjectMother** or Builder pattern and is described further in the *Further*
    *reading* section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现许多测试类都会从相同的“辅助”方法中受益，例如`CreateFlight`，你可能想要考虑将这些辅助方法移动到测试项目的静态类中。这种模式有时被称为**ObjectMother**或Builder模式，在*进一步阅读*部分有更详细的描述。
- en: Alternatively, you could introduce a base testing class, move your shared methods
    to that class, and then have your tests inherit from that class. Test classes
    and test projects are just like normal code and many of the refactoring tricks
    we used in part 1 of this book will help improve your tests as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以引入一个基测试类，将你的共享方法移动到那个类中，然后让测试从那个类继承。测试类和测试项目就像正常代码一样，本书第一部分中使用的许多重构技巧也可以帮助你改进测试。
- en: Before we close out this chapter with a discussion on adopting a testing mindset,
    let’s briefly look at a pair of other popular C# testing frameworks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章关于采用测试思维的讨论之前，让我们简要地看看另一对流行的C#测试框架。
- en: Exploring other testing frameworks
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索其他测试框架
- en: Beyond xUnit, the next most popular testing frameworks are **NUnit** and **MSTest**.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了xUnit之外，最受欢迎的测试框架是**NUnit**和**MSTest**。
- en: These two frameworks operate in very similar ways to xUnit but with slight differences
    in the syntax you use to declare a unit test.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个框架与xUnit的操作方式非常相似，但在声明单元测试时使用的语法略有不同。
- en: I’ve had the opportunity to program professionally and recreationally in all
    three major testing frameworks and I can tell you that these differences are largely
    cosmetic. That said, you will find that certain frameworks have specific features
    that might not be present in the others.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我有机会在专业和休闲方面使用所有三个主要的测试框架，我可以告诉你，这些差异在很大程度上是表面的。话虽如此，你会发现某些框架具有某些特定功能，这些功能可能不在其他框架中。
- en: Testing with NUnit
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NUnit 进行测试
- en: Of the three testing frameworks, NUnit’s syntax is my favorite because it uses
    the `Test` name for both unit tests that require no parameters (equivalent to
    an xUnit `Fact`) and those that do (equivalent to an xUnit `Theory`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个测试框架中，NUnit 的语法是我最喜欢的，因为它使用 `Test` 名称来表示既不需要参数的单元测试（相当于 xUnit 的 `Fact`），也需要参数的单元测试（相当于
    xUnit 的 `Theory`）。
- en: 'Here’s a parameterized test that verifies the `Load` method on `PassengerFlightInfo`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个参数化测试，用于验证 `PassengerFlightInfo` 上的 `Load` 方法：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In `NUnit`, Test and `TestCase` replace Theory and `InlineData`. If this test
    were not parameterized, `TestCase` would become `Test`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NUnit` 中，Test 和 `TestCase` 替代了 Theory 和 `InlineData`。如果这个测试不是参数化的，`TestCase`
    将变为 `Test`。
- en: The assert section of this test is a little different. The first thing to note
    is that NUnit’s assertion method is `Assert.AreEqual` instead of `Assert.Equal`.
    While this is a minor difference, I find that the code reads a bit better.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的断言部分有一点不同。首先要注意的是，NUnit 的断言方法是 `Assert.AreEqual` 而不是 `Assert.Equal`。虽然这只是细微的差别，但我发现代码读起来更好。
- en: Below the `Assert.AreEqual` line is the `Assert.That` line. This is NUnit’s
    newer constraint model of unit tests; it reads a bit more fluently and reduces
    your chances of confusing parameters like the expected and actual values on an
    assertion. Both ways of writing NUnit tests are valid and work fine.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assert.AreEqual` 行下面是 `Assert.That` 行。这是 NUnit 的较新的单元测试约束模型；它读起来更流畅，并减少了在断言中混淆预期值和实际值等参数的可能性。两种编写
    NUnit 测试的方式都是有效的，并且运行良好。
- en: 'One final note: in NUnit, all tests in a test class share the same class instance.
    This means that values stored in fields or properties on your tests will be shared
    by all tests in that test class. This is different from xUnit which creates a
    new test class instance for each test that runs.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意：在 NUnit 中，测试类中的所有测试共享同一个类实例。这意味着存储在测试的字段或属性中的值将被该测试类中的所有测试共享。这与为每个运行的测试创建新测试类实例的
    xUnit 不同。
- en: With NUnit explored, let's look at MSTest.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 NUnit 之后，让我们来看看 MSTest。
- en: Testing with MSTest
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MSTest 进行测试
- en: MSTest’s official name was **Visual Studio Unit Testing Framework**, but the
    framework has come to be known as **MSTest** throughout the community and even
    throughout Microsoft’s internal documentation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: MSTest 的官方名称是 **Visual Studio 单元测试框架**，但该框架在社区中以及微软内部文档中都被广泛称为 **MSTest**。
- en: MSTest V2
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: MSTest V2
- en: While MSTest had a poor reputation for nearly a decade due to a lack of feature
    parity between it and NUnit and xUnit, Microsoft revised MSTest in 2016, calling
    it **MSTest V2** and bringing many improvements to the framework to the point
    where it is now on par with its competitors.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MSTest 与 NUnit 和 xUnit 之间缺乏功能一致性，MSTest 几乎十年来的声誉都很差。但在 2016 年，微软对 MSTest
    进行了修订，称之为 **MSTest V2**，并将许多改进引入到框架中，使其现在与竞争对手处于同一水平。
- en: Like NUnit, MSTest uses a single `TestMethod` attribute to mark both parameterized
    and unparameterized unit tests. However, unlike both NUnit and xUnit, MSTest also
    requires a `TestClass` attribute on the class itself to make the individual tests
    discoverable. This is something to watch out for when writing tests in MSTest
    as it’s another thing you can miss to make your tests not show up in the test
    runner.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与 NUnit 一样，MSTest 使用单个 `TestMethod` 属性来标记参数化和非参数化的单元测试。然而，与 NUnit 和 xUnit 不同，MSTest
    还需要在类本身上使用 `TestClass` 属性来使单个测试可发现。这是在编写 MSTest 测试时需要注意的事情，因为它是你可能会错过以使测试不在测试运行器中显示的另一个因素。
- en: 'Let’s look at a sample parameterized test in MSTest that verifies the `FullName`
    property of the `Passenger` class from our `BoardingProcessor` class from [*Chapter
    3*](B21324_03.xhtml#_idTextAnchor045):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 MSTest 中一个示例参数化测试，该测试验证了 `BoardingProcessor` 类中的 `Passenger` 类的 `FullName`
    属性：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, this parameterized test evaluates the name of each of this book’s technical
    reviewers from `DataRow`, just like `InlineData` does in xUnit or `TestCase` does
    in NUnit.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这个参数化测试评估了本书每位技术审查者的姓名，从 `DataRow` 中获取，就像 xUnit 中的 `InlineData` 或 NUnit
    中的 `TestCase` 一样。
- en: While the MSTest syntax is different, there are many similarities between it
    and the other test frameworks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MSTest的语法不同，但它与其他测试框架之间有许多相似之处。
- en: The major differences between MSTest and NUnit are the inclusion of the `TestClass`
    attribute and the names `TestMethod` and `DataRow` instead of `Test` and `TestCase`,
    respectively. Even the naming of the `Assert.AreEqual` methods are identical between
    the two frameworks.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: MSTest与NUnit之间的主要区别在于包含`TestClass`属性以及分别使用`TestMethod`和`DataRow`名称代替`Test`和`TestCase`。甚至在两个框架中`Assert.AreEqual`方法的命名也是相同的。
- en: Ultimately, these three testing frameworks are all very similar and serve a
    powerful role in your goal of high-quality software. I’ve found that I can work
    effectively in any of the three frameworks. While I tend to prefer NUnit’s syntax,
    I use xUnit in new projects because xUnit has largely become the community standard.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这三个测试框架都非常相似，并在实现高质量软件的目标中发挥着强大的作用。我发现我可以在这三个框架中的任何一个框架中有效地工作。虽然我倾向于更喜欢NUnit的语法，但我使用xUnit来处理新项目，因为xUnit在很大程度上已经成为社区标准。
- en: My recommendation is to pick the library whose syntax you like the most and
    use that for your projects and focus your efforts on writing good tests and adopting
    a testing mindset.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是选择你最喜欢的语法库，并将其用于你的项目，并将你的精力集中在编写良好的测试和采取测试心态上。
- en: Adopting a testing mindset
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取测试心态
- en: Let’s take a step back and talk about why a book on refactoring features an
    entire series of chapters around testing. The reason is that code that needs to
    be refactored is often a bit more volatile and tends to break more easily when
    changed. Since the art of refactoring is about changing the form of the software
    without changing its behavior, introducing bugs when refactoring is undesirable
    and unacceptable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，谈谈为什么一本关于重构的书会围绕测试展开整整一系列章节。原因是需要重构的代码通常更加易变，在更改时更容易出错。由于重构的艺术在于在不改变软件行为的情况下改变其形式，因此在重构时引入错误是不受欢迎且不可接受的。
- en: This is where tests come in. Tests give you the confidence you and your team
    need to be able to improve your code. Your legacy code may or may not have tests
    around it already, so the responsibility and necessity of ensuring good tests
    are present falls to you before you perform any testing work.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是测试发挥作用的地方。测试为你和你团队提供所需的信心，以便能够改进代码。你的遗留代码可能已经或尚未包含测试，因此在进行任何测试工作之前，确保存在良好测试的责任和必要性落在你的身上。
- en: This requires you to adopt a testing mindset. This phrase refers to thinking
    about tests at the *beginning* of the development process as a vital component
    of software development and refactoring, not as an afterthought.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要你采取测试心态。这个短语指的是在开发过程的**开始**就将测试视为软件开发和重构的一个关键组成部分，而不是事后考虑。
- en: While we’ll explore this concept at length in the next chapter as we discuss
    **test-driven development**, let’s touch on a few considerations that will help
    you be successful with tests in your organization and adopt a testing mindset.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将在下一章详细探讨这个概念，当我们讨论**测试驱动开发**时，让我们简要提及一些有助于你在组织中成功进行测试并采取测试心态的考虑因素。
- en: Incorporating testing into your workflow
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将测试融入工作流程
- en: Testing should be a standard part of your everyday life as a software engineer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该是软件工程师日常生活中的一个标准部分。
- en: This means that you should think about testing whenever you make any change
    to a system, whether the change is a new feature, fixing a bug, or paying down
    technical debt through refactoring.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当你对系统进行任何更改时，都应该考虑进行测试，无论这些更改是新增功能、修复错误还是通过重构来偿还技术债务。
- en: This requires a shift of mentality from seeing tests as tedious or something
    you ought to do to thinking of tests as things that have intrinsic value to the
    codebase and even to the larger organization. This is because tests provide value
    through their role as a sort of “living documentation” of your codebase, their
    ability to provide a safety net against certain types of bugs in the future, and
    their ability to give you and the business confidence in the code you’re writing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要从将测试视为繁琐或应该做的事情的心态转变为将测试视为对代码库甚至对整个组织具有内在价值的思维。这是因为测试通过充当代码库的“活文档”、提供对未来某些类型错误的防护网以及增强你和你团队对所编写代码的信心来提供价值。
- en: You will, of course, bump into pieces of software that are significantly harder
    to test. These might be pieces of code working with the user interface or they
    might be pieces of code with very strong dependencies to other systems.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会遇到一些测试起来非常困难的软件片段。这些可能是与用户界面一起工作的代码片段，或者可能是与其他系统有非常强依赖关系的代码片段。
- en: We’ll touch more on dependencies later in this section and again in *Chapters
    8* and *9*, but testing the user interface is typically done with specialized
    tools and libraries and varies based on whether you are testing a web, desktop,
    or mobile application. As a result, user interface testing is outside the scope
    of this book. However, isolating dependencies is usually a strong part of that
    process.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节稍后和*第8章*和*第9章*中再次讨论依赖关系，但通常使用专门的工具和库进行用户界面测试，并且根据你是在测试Web、桌面还是移动应用程序而有所不同。因此，用户界面测试超出了本书的范围。然而，隔离依赖通常是这个过程的一个重要部分。
- en: Isolating dependencies
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离依赖
- en: When we talk about isolating dependencies, this means that when we test a piece
    of code, testing it shouldn’t alter anything else.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论隔离依赖时，这意味着当我们测试一段代码时，测试它不应该改变其他任何东西。
- en: For example, when we’re trying to verify that scheduling a flight adds the flight
    to the list of flights in the system, we don’t want the system to send an email
    with a flight confirmation every time we run our unit test!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们试图验证安排航班会将航班添加到系统中的航班列表时，我们不希望每次运行我们的单元测试时系统都发送带有航班确认的电子邮件！
- en: 'Such an example might look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的例子可能看起来像这样：
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `FlightScheduler` has an `EmailClient` class and calls `SendMessage` on
    the client every time a flight is scheduled. This is a strong dependency from
    `FlightScheduler` to the `EmailClient` class and will result in an undesirable
    side effect of sending emails when this code is tested.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FlightScheduler`有一个`EmailClient`类，每次安排航班时都会在客户端上调用`SendMessage`。这是`FlightScheduler`对`EmailClient`类的强依赖，会导致在测试此代码时发送电子邮件的不希望出现的副作用。
- en: Side effects such as sending emails or interacting with the filesystem or a
    database are often undesirable in unit tests, as we’ll discuss shortly.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件或与文件系统或数据库交互等副作用通常在单元测试中是不希望的，我们将在稍后讨论。
- en: While it’s good for systems to be able to do these things, we want to test our
    units of code in isolation without them having side effects we don’t like. We
    can work around this via a process called **dependency injection**, where a class
    is no longer responsible for creating the dependencies it needs but gets them
    from others.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然让系统能够执行这些操作是好事，但我们希望在不产生我们不喜欢的副作用的情况下，单独测试我们的代码单元。我们可以通过一种称为**依赖注入**的过程来解决这个问题，在这个过程中，一个类不再负责创建它需要的依赖，而是从其他地方获取它们。
- en: 'A more testable version of `FlightScheduler` would look like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlightScheduler`的一个更可测试的版本可能看起来像这样：'
- en: '[PRE22]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the dependency on the `EmailClient` class is injected into this class
    in its constructor and a new `IEmailClient` interface is used so that we can use
    a different implementation of this interface for testing. This test-specific version
    wouldn’t have the negative side effect of sending emails, making it more acceptable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对`EmailClient`类的依赖是通过构造函数注入到这个类中的，并使用一个新的`IEmailClient`接口，这样我们就可以为测试使用这个接口的不同实现。这个针对测试的版本不会产生发送电子邮件的负面副作用，使其更可接受。
- en: Dependency injection and its related terms, **inversion of control** and **dependency
    inversion**, are complex topics that take some time to grasp. So, we’ll revisit
    them in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173), *Avoiding Code Anti-Patterns
    with SOLID*. Additionally, experienced testers may be crying out that a mocking
    framework such as Moq or NSubstitute can help with some of these concerns. We’ll
    cover these libraries in [*Chapter 7*](B21324_07.xhtml#_idTextAnchor161).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入及其相关术语，**控制反转**和**依赖倒置**，是复杂的话题，需要一些时间来掌握。因此，我们将在[*第8章*](B21324_08.xhtml#_idTextAnchor173)中重新讨论它们，*使用SOLID避免代码反模式*。此外，经验丰富的测试人员可能会大声疾呼，一个模拟框架，如Moq或NSubstitute，可以帮助解决一些这些问题。我们将在[*第7章*](B21324_07.xhtml#_idTextAnchor161)中介绍这些库。
- en: For now, let’s move on to talking about other factors that constitute good and
    bad tests.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论构成良好和不良测试的其他因素。
- en: Evaluating good and bad tests
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估良好和不良测试
- en: 'Good unit tests should be as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的单元测试应该是这样的：
- en: '**Fast to run**: If tests take minutes to run, developers won’t run them.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行速度快**：如果测试需要几分钟才能运行，开发者就不会运行它们。'
- en: '**Reliable and repeatable**: Tests shouldn’t randomly fail or pass or fail
    based on the day of the week, time of day, or which other tests were run earlier.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠和可重复**：测试不应该随机失败或通过或失败，这取决于星期几、一天中的时间或之前运行了哪些其他测试。'
- en: '**Independent from one another**: One test should never impact another test
    passing or failing and tests shouldn’t need to be run in a certain order.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相互独立**：一个测试永远不应该影响另一个测试的通过或失败，并且测试不需要按特定顺序运行。'
- en: '**Isolated**: They should be kept independent of dependencies such as databases,
    files on disk, cloud resources, or external APIs. Not only do these things slow
    down your tests but if we’re testing these interactions, that’s an *integration
    test*, not a unit test.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：它们应该与数据库、磁盘上的文件、云资源或外部API等依赖项保持独立。这些事情不仅会减慢你的测试速度，而且如果我们正在测试这些交互，那么那是一个**集成测试**，而不是单元测试。'
- en: '**Readable**: Tests serve as examples of how to interact with your classes.
    Additionally, when a test fails, its failure should be easy to understand.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：测试作为如何与你的类交互的示例。此外，当测试失败时，其失败应该容易理解。'
- en: '**Portable**: Tests shouldn’t require significant machine setup and should
    be runnable on any developer’s machine or another machine as part of a **continuous
    integration/continuous delivery** (**CI/CD**) pipeline.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携性**：测试不应该需要显著的机器设置，并且应该在任何开发者的机器上或在**持续集成/持续交付**（**CI/CD**）管道中的另一台机器上可运行。'
- en: In contrast, bad tests take time to run, are “flaky” and randomly fail, cannot
    be run in parallel or out of order, are difficult to understand regarding what
    they’re testing or why, and require a lot of manual configuration to run reliably.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，糟糕的测试需要时间来运行，是“不可靠的”并且随机失败，不能并行运行或按顺序运行，在理解它们测试的内容或为什么测试它们方面很困难，并且需要大量手动配置才能可靠地运行。
- en: In general, you want to favor many small unit tests that are fast to run, easy
    to understand, and reliable over more ambitious tests that test too many things
    at once, leading to slow tests that lead to unclear and unreliable test failures.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望优先考虑许多小型单元测试，这些测试运行速度快、易于理解且可靠，而不是更雄心勃勃的测试，这些测试一次测试太多东西，导致测试缓慢，且测试失败不明确、不可靠。
- en: Thoughts on code coverage
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于代码覆盖率
- en: I can’t talk about unit testing without introducing **code coverage**. Code
    coverage is the lines of code that run as part of any unit test. If a test causes
    the line of code to run, it is considered covered; otherwise, it is considered
    not covered.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能不介绍**代码覆盖率**就谈论单元测试。代码覆盖率是作为任何单元测试一部分运行的代码行。如果一个测试导致代码行运行，它被认为是已覆盖的；否则，它被认为是未覆盖的。
- en: 'Several tools calculate code coverage, including Visual Studio Enterprise and
    JetBrains ReSharper, which we talked about briefly in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026).
    If you have Visual Studio Enterprise, you can calculate code coverage by selecting
    the **Test** menu and then **Analyze Code Coverage for All Tests**. This will
    show the lines of code that are covered and not covered by unit tests, as shown
    in *Figure 6**.9*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 几种工具可以计算代码覆盖率，包括Visual Studio Enterprise和JetBrains ReSharper，我们简要讨论了[*第2章*](B21324_02.xhtml#_idTextAnchor026)。如果你有Visual
    Studio Enterprise，你可以通过选择**测试**菜单然后**分析所有测试的代码覆盖率**来计算代码覆盖率。这将显示被单元测试覆盖和未覆盖的代码行，如图*图6.9*所示：
- en: '![Figure 6.9 – Overview of Code Coverage Results in Visual Studio Enterprise](img/B21324_06_09.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – Visual Studio Enterprise中代码覆盖率结果的概述](img/B21324_06_09.jpg)'
- en: Figure 6.9 – Overview of Code Coverage Results in Visual Studio Enterprise
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – Visual Studio Enterprise中代码覆盖率结果的概述
- en: 'These coverage results will highlight any lines that are not covered by unit
    tests, such as the code of the `Unload` method in `PassengerFlightInfo`, as shown
    in *Figure 6**.10*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些覆盖率结果将突出显示任何未由单元测试覆盖的行，例如`PassengerFlightInfo`中的`Unload`方法的代码，如图*图6.10*所示：
- en: '![Figure 6.10 – Covered lines are highlighted in blue, while lines without
    tests are highlighted in red (line 14)](img/B21324_06_10.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 覆盖的行以蓝色突出显示，而未测试的行以红色突出显示（行14）](img/B21324_06_10.jpg)'
- en: Figure 6.10 – Covered lines are highlighted in blue, while lines without tests
    are highlighted in red (line 14)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 覆盖的行以蓝色突出显示，而未测试的行以红色突出显示（行14）
- en: Code coverage is one of those topics that can be divisive. On the one hand,
    code coverage gives you a metric that shows how much of your code is executed
    by any test. This gives you a meaningful way of measuring the extent of your unit
    testing safety net.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是那些可能引起分歧的话题之一。一方面，代码覆盖率为你提供了一个指标，显示了你的代码有多少部分被任何测试执行。这为你提供了一个有意义的衡量单元测试安全网范围的方法。
- en: However, code coverage can be deceptive. Just running a line of code does not
    mean that the effects of that line are verified by a unit test. This can lead
    to a false sense of security around your unit tests.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码覆盖率可能会产生误导。仅仅运行一行代码并不意味着该行的效果已被单元测试验证。这可能导致您对单元测试产生错误的安全感。
- en: Additionally, when organizations prioritize work that increases the code coverage
    percentage or requires a certain minimum percentage of code coverage for new work,
    this can lead to tests that focus on the less risky aspects of your software system.
    For example, do you need to write a unit test to verify code that throws an `ArgumentNullException`
    error when a null value is passed to a method, or is your time better spent elsewhere?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当组织优先考虑提高代码覆盖率百分比或要求新工作必须达到一定最低代码覆盖率的工作时，这可能导致测试集中在软件系统风险较低的部分。例如，您需要编写一个单元测试来验证当将
    null 值传递给方法时抛出 `ArgumentNullException` 错误的代码，还是您的时间花在其他地方更好？
- en: Often, the most critical areas of your application may already appear to be
    covered by your code coverage metrics, but no tests verify that these lines work
    correctly.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序中最关键的区域可能已经出现在代码覆盖率指标中，但没有测试验证这些行是否正确工作。
- en: My personal feeling is that code coverage is one of many useful metrics to monitor
    but should not be used to significantly drive the behavior of your development
    teams.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的感觉是，代码覆盖率是许多有用的指标之一，但不应被用来显著影响开发团队的行为。
- en: See the *Further reading* section for more information on code coverage and
    how to get started calculating it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *进一步阅读* 部分，了解更多关于代码覆盖率和如何开始计算它的信息。
- en: We’ll explore other metrics in [*Chapter 12*](B21324_12.xhtml#_idTextAnchor259),
    *Code Analysis in Visual Studio*, but for now, let’s conclude this chapter with
    some closing thoughts on unit testing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第12章*](B21324_12.xhtml#_idTextAnchor259) 中探索其他指标，*Visual Studio中的代码分析*，但在此，让我们以一些关于单元测试的总结来结束本章。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Unit testing is a powerful way to verify that refactoring code does not introduce
    bugs, document your classes, and prevent bugs from occurring in the future.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是验证重构代码不会引入错误、记录类文档以及防止未来出现错误的有效方式。
- en: Unit tests are code that tests other code. In .NET, project unit tests are usually
    performed with xUnit, NUnit, or MSTest. Each testing framework provides assertions
    that verify that code behaves correctly or fails a test if the actual value doesn’t
    match the expected value.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试其他代码的代码。在 .NET 中，项目单元测试通常使用 xUnit、NUnit 或 MSTest 来执行。每个测试框架都提供断言，用于验证代码是否正确行为，或者在实际值与预期值不匹配时失败测试。
- en: When we write unit tests, we typically structure our tests in the *arrange*/*act*/*assert*
    pattern, which sets up the thing being tested in the *arrange* step, does a single
    action in the *act* step, and verifies the correctness of the action’s result
    in the *assert* step.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写单元测试时，我们通常按照 *arrange*/*act*/*assert* 模式来组织我们的测试，在 *arrange* 步骤中设置要测试的对象，在
    *act* 步骤中执行单个操作，并在 *assert* 步骤中验证操作结果的正确性。
- en: In the next chapter, we’ll explore testing more with test-driven development.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过测试驱动开发来探索更多的测试。
- en: Questions
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试您对本章知识的了解：
- en: Which unit testing framework syntax do you like the most?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您最喜欢哪种单元测试框架的语法？
- en: What are the most complex parts of your application? Are they tested?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的应用程序中最复杂的部分是什么？它们被测试了吗？
- en: How would you test a method that calculates the credit score of an applicant?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会如何测试一个计算申请者信用评分的方法？
- en: How do you test a `void` method?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何测试一个 `void` 方法？
- en: What things can you do to help test code stay clean and readable?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以做些什么来帮助测试代码保持整洁和可读性？
- en: Further reading
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about the materials discussed in this chapter
    by checking out the following resources:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看以下资源来找到有关本章讨论的材料更多信息：
- en: '*Types of* *Tests*: [https://learn.microsoft.com/en-us/dotnet/core/testing/](https://learn.microsoft.com/en-us/dotnet/core/testing/)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试类型*: [https://learn.microsoft.com/en-us/dotnet/core/testing/](https://learn.microsoft.com/en-us/dotnet/core/testing/)'
- en: '*Visual Studio Test* *Explorer*: [https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer](https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Visual Studio Test Explorer*: [https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer](https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer)'
- en: '*xUnit*: [https://xunit.net/](https://xunit.net/)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*xUnit*: [https://xunit.net/](https://xunit.net/)'
- en: '*NUnit*: [https://nunit.org/](https://nunit.org/)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NUnit*：[https://nunit.org/](https://nunit.org/)'
- en: '*MSTest*: [https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MSTest*：[https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest)'
- en: '*The ObjectMother* *Pattern*: [https://www.martinfowler.com/bliki/ObjectMother.html](https://www.martinfowler.com/bliki/ObjectMother.html)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象母体* 模式：[https://www.martinfowler.com/bliki/ObjectMother.html](https://www.martinfowler.com/bliki/ObjectMother.html)'
- en: '*Code* *Coverage*: [https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested](https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码覆盖率*：[https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested](https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested)'
